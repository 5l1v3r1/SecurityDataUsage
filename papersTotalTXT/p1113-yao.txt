OAKE: A New Family of Implicitly Authenticated

Difﬁe-Hellman Protocols∗

[Extended Abstract] †

Andrew Chi-Chih Yao

Institute for Interdisciplinary Information
Sciences, Tsinghua University, China
andrewcyao@tsinghua.edu.cn

ABSTRACT
Cryptographic algorithm standards play an important role
both to the practice of information security and to cryptog-
raphy theory research. Among them, the KEA and OPAC-
ITY (KEA/OPACITY, in short) protocols, and the MQV
and HMQV ((H)MQV, in short) protocols, are a family
of implicitly authenticated Diﬃe-Hellman key-exchange (IA-
DHKE) protocols that are among the most eﬃcient authen-
ticated key-exchange protocols known and are widely stan-
dardized. In this work, from some new design insights, we
develop a new family of practical IA-DHKE protocols, re-
ferred to as OAKE (standing for “optimal authenticated key-
exchange” in brief). We show that the OAKE protocol fam-
ily combines, in essence, the advantages of both (H)MQV
and KEA/OPACITY, while saving from or alleviating the
disadvantages of them both.

Categories and Subject Descriptors
E.3 [Data Encryption]: public key cryptosystems, stan-
dards; D.4.6 [Security and Protection]: Authentication

Keywords
Authentication, key exchange, standards

∗

This research was supported in part by the National
Basic Research Program of China (973 Program) No.
2007CB807900, No. 2007CB807901, No. 2014CB340600,
and National Natural Science Foundation of China Grant
No.61033001, No.61061130540, No.
61070248, and No.
61272012, Innovation Project (No.12ZZ013) of Shanghai
Municipal Education Commission, and Joint Project of
SKLOLS.
†
A full version of
tology ePrint Archive, Report No.
http://eprint.iacr.org/2011/035
‡
Contact author.

is available as Cryp-
at

this paper

2011/035,

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS’13, November 4–8, 2013, Berlin, Germany.
Copyright 2013 ACM 978-1-4503-2477-9/13/11 ...$15.00.
http://dx.doi.org/10.1145/2508859.2516695.

‡
Yunlei Zhao

Software School, Fudan University, China
State Key Laboratory of Information Security

ylzhao@fudan.edu.cn

1.

INTRODUCTION

Diﬃe-Hellman key-exchange (DHKE) protocols [31] marked

the birth of modern cryptography, and are one of the main
pillars of both theory and practice of cryptography [22, 23].
Unfortunately, the basic DHKE protocol is not secure against
active adversaries, who control the communication chan-
nels and in particular can play the concurrent man-in-the-
middle (CMIM) attacks. The quest for DHKE protocols
secure against active attacks has triggered intensive subse-
quent works.

The common approach for achieving secure DHKE against
active attacks is to explicitly authenticate the messages be-
ing exchanged with some cryptographic primitives, e.g., sig-
nature, encryption, MAC, and hashing. Some salient ex-
amples following this approach include: IKE [43, 49] and
SIGMA [50], deniable IKE [72], STS [32], SSL [44, 35] and
TLS [30, 52], and JFK [3]. Though secure DHKE proto-
cols against active attacks can be achieved with explicit mu-
tual authentication, they usually incur signiﬁcant additional
computation and communication complexity as compared
with the basic DHKE protocol.

Motivated by reducing the performance cost associated
with authentication mechanisms for secure DHKE against
active attacks, Matsumoti et al., in 1986, initiated an am-
bitious line of research investigation to design implicitly au-
thenticated DHKE protocols [58]. By implicitly authenti-
cated DHKE, we mean DHKE protocol whose communica-
tion is identical to that of the basic DH protocol, yet it is
implicitly authenticated by the sole ability of the parties to
compute the resultant session-key [51].
In this work, we
focus on several widely standardized IA-DHKE protocols:
KEA [65] and OPACITY [70] (KEA/OPACITY, in short),
MQV [59] and HMQV [51, 42] ((H)MQV, in short).

Let G(cid:2) be a ﬁnite Abelian group of order N , G ⊆ G(cid:2) be
a subgroup of prime order q. Denote by g a generator of
G, by 1G the identity element, by G \ 1G = G − {1G} the
set of elements of G except 1G and by t = N
q the cofactor.
In this work, we use multiplicative notation for the group
operation in G(cid:2). Let (A = ga, a) (resp., (X = gx, x)) be the
public key and secret key (resp., the DH-component and DH-
exponent) of player ˆA, and (B = gb, b) (resp., (Y = gy, y))
be the public key and secret key (resp., the DH-component
and DH-exponent) of player ˆB, where a, x, b, y ← Z∗
q (i.e.,
each of them is taken uniformly and independently from Z∗
q ).
The (H)MQV and KEA protocols are described in Figure 1

1113(page 3), where HK (resp., h) is a hash function of k-bit
(resp., l-bit) output and l is set to be |q|/2 for HMQV.

The KEA algorithm [65, 53, 56] was designed by the US
National Security Agency (NSA) and was later standardized
by NIST. Note that the KEA protocol described in Figure 1
is actually the provably secure version proposed by Lauter,
et al. in [56]. In the original KEA protocol, the session-key
is set to be HK(Ay ⊕X b). Throughout this work, for presen-
tation simplicity, by KEA we simply refer to the provably
secure version proposed in [56].

The OPACITY (Open Protocol for Access Control, Iden-
tiﬁcation, and Ticketing with Privacy) algorithm [70] is an-
other IA-DHKE protocol, which is mainly for establishing
channels in contactless environment (e.g., access control for
buildings, and ticketing in transport systems). OPACITY
was sponsored by US Department of Defense and Interna-
tional Smart Card Alliance, and has now been registered as
an ISO/IEC 24727-6 authentication protocol [47], and spec-
iﬁed in the draft ANSI 504-1 national standard [4]. The
OPACITY protocol was designed based on KEA. With the
computation of ˆB as an illustration, the core authentica-
tion mechanism of both KEA and OPACITY is to derive
keys from (Ay, X b), possibly together with some auxiliary
information aux (e.g., players’ identities, and some proto-
col control information) related to the protocol run. This
authentication mechanism of KEA and OPACITY was also
proposed in [14].

The MQV and HMQV protocols stand for the current
state-of-the-art of (public key cryptography based) eﬃcient
authenticated DHKE, and marked the great milestones of
IA-DHKE developments. In particular, the ﬁrst formal anal-
ysis of IA-DHKE within the Canetti-Krawczyk framework
(CK-framework) was conducted w.r.t.
the HMQV proto-
col in [51], which is particularly helpful in understanding
the protocol design insights and the underlying parameter
choices. (H)MQV has been widely standardized [5, 45, 46,
63, 71, 64], and was announced by NSA as the key exchange
mechanism underlying “the next generation cryptography to
protect US government information”, including the protec-
tion of “classiﬁed or mission critical national security infor-
mation” [71, 51].

In order to provide more robust resilience to birthday
attacks on the hash function h and/or to the leakage of
DH components and exponents, MQV in the NIST stan-
dard [7] and HMQV (p.54, [51]) made the following prefer-
able modiﬁcation: players’ identities are put into session-
key derivation in the ﬁxed order of ( ˆA, ˆB). For presenta-
tion simplicity, we refer to (H)MQV with such a modiﬁ-
cation as robust (H)MQV, where the session-key is set to
be K = HK(K ˆA, ˆA, ˆB) = HK(K ˆB, ˆA, ˆB). Throughout this
work, an IA-DHKE protocol is called role-dependent (resp.,
role-independent), if its session-key derivation is dependent
(resp., independent) of players’ roles (i.e., initiator or re-
sponder). Note that (H)MQV is role-independent, while ro-
bust (H)MQV and KEA are role-dependent.
1.1 Motivation and Contributions

Both KEA/OPACITY and (H)MQV have advantageous
features, which made them both widely standardized and
desirable in accordance with diﬀerent application scenarios.
For the eﬃciency issue, (H)MQV is more eﬃcient as a whole;
in contrast, KEA/OPACITY is more eﬃcient in online set-
tings. For the security issue, the provable security of KEA

in the CK-framework allows robust leakage resilience, in the
sense that the exposed session-states include all the pre-
computed and stored session-speciﬁc values; by comparison,
the provable security of HMQV depends upon what pre-
computed values are speciﬁed in the session-states, where
some naturally pre-computable session-speciﬁc values are,
however, not assumed to be include in session-states and are
assumed to be unexposed. In addition, KEA/OPACITY al-
lows more ﬂexible deployment, and provides better privacy
protection. A detailed comparative study of (H)MQV versus
KEA/OPACITY is presented in Section 3.

In particular, KEA/OPACITY enjoys the advantages of
optimal online eﬃciency and honest-player deniability (HP-
deniability). By “optimal online eﬃciency”, we mean that
each player needs to online perform only one modular expo-
nentiation (besides some other minor operations like hashing
and/or MAC, etc). By “honest-player deniability”, we mean
that the transcript of a session run between a pair of honest
players, the resultant session-key, and all the pre-computed
and stored session-states, can be statistically simulated by
an eﬃcient algorithm from the public parameters and play-
ers’ public keys. By comparison, the use of the session-key
of (H)MQV can be traced back to the pair of players as the
value gab is involved in the session-key derivation, which is
referred to as gab-traceability for presentation simplicity.

Unfortunately, the advantages of KEA/OPACITY usu-
ally correspond to the disadvantages of (H)MQV, and vice
versa. On the other hand, as the session-key structure of
KEA/OPACITY and that of (H)MQV are diﬀerent in na-
ture, it is uneasy or ﬂexible to implement both of them and
then switch between them according to diﬀerent application
scenarios, particularly for applications based on low-power
devices. This leads to the following main motivation.

Motivation
Can we design a new family of IA-DHKE protocols
that could combine, in essence, the advantages of
both KEA/OPACITY and (H)MQV, while saving
from the disadvantages of them both?

We suggest that, though clearly being important both to
the theory and practice of KE, coming up with such an IA-
DHKE protocol is quite challenging, which calls for new IA-
DHKE protocol structures with new design insight or nov-
elty.
In general, despite its seemingly conceptual simplic-
ity, designing “sound ” and “right” key-exchange protocols
turns out to be extremely error prone and can be notori-
ously subtle, particularly witnessed by the evolution his-
tory of KEA [65, 56] and that of (H)MQV [58, 59, 48, 51,
60]. Also, the analysis of even a simple cryptographic pro-
tocol in intricate adversarial settings like the Internet can
be a luxury and dauntingly complex task [51, 19]. The
reason for this is the high system complexity and plenty
of subtleties surrounding the design, deﬁnition and analysis
of key-exchange protocols. In particular, though seemingly
conceptually simple, the (H)MQV protocols were actually
very delicately designed, in the sense that slight changes
in the design structure or parameters can lose provable se-
curity or even be totally insecure. Given the long-time
study of KEA/OPACITY and (H)MQV both in research
and in engineering, it may be commonly suggested that the
state-of-the-art of KEA/OPACITY and(H)MQV (in their
respective types) should hardly be broken. This further re-

1114P K ˆA : A = ga
SK ˆA : a

ˆA, A, X = gx

ˆB, B, Y = gy

P K ˆB : B = gb
SK ˆB : b

(H)MQV: K ˆB = (XAd)y+eb, K ˆA = (Y Be)x+da, K = HK(K ˆB) =H K(K ˆA)

MQV: d = 2l + (X mod 2l), e = 2l + (Y mod 2l), l = |q|/2

HMQV: d = h(X, ˆB), e = h(Y, ˆA), l = |q|/2

KEA: K = HK(Y a, Bx, ˆA, ˆB) =H K(Ay, X b, ˆA, ˆB)

(T)OAKE: K ˆB = Af b+yX b+ey, K ˆA = Bf a+xY a+ex, K = HK(K ˆB) =H K(K ˆA)

OAKE:

T-OAKE:

e = h( ˆA, A, ˆB, B, X, Y ), f = 0, l ≈ |q|
e = h( ˆA, A, ˆB, B, X, Y ), f = 1, l ≈ |q|

Figure 1: Speciﬁcations of (H)MQV, KEA and (T)OAKE

ﬂects the non-triviality of the goal of this work, i.e., achiev-
ing the best of both worlds: combining the advantages of
KEA/OPACITY and (H)MQV in authenticated key-exchange.

Our contributions. In this work, motivated for a mech-
anism of proving the knowledge of multiple DH-exponents
jointly and practically, and for conceptually simple proto-
col design and analysis, we introduce an extension of the
knowledge-of-exponent assumption (KEA) [27] in the ran-
dom oracle model [11], referred to as the joint knowledge-
of-exponent assumption (JKEA). We show that the JKEA
assumption is implied, and thus justiﬁed, by the traditional
KEA assumption in the random oracle model.

Based on this line of investigations and observations, we
develop a new practical IA-DHKE protocol, referred to as
OAKE.1 Brieﬂy speaking, the OAKE protocol enjoys the
following advantageous features simultaneously. More de-
tailed discussions and comparisons about the performance
advantages of OAKE are given in Section 5.

• It is as eﬃcient as, actually (slightly) more eﬃcient
than, HMQV in total. Notice that, as (H)MQV is
commonly viewed as nearly optimal in the integrity of
security and protocol eﬃciency, even minor eﬃciency
improvements (while preserving provable security) can
be challenging.

• It enjoys the optimal online eﬃciency and HP-deniability

of KEA/OPACITY, which is particularly desirable for

1The acronym of OAKE stands for “(toward) Optimally-
balanced (implicitly) Authenticated (Diﬃe-Hellman) Key-
Exchange (in the integrity of protocol eﬃciency, security,
privacy, and easy deployment)”.

applications based on low-power or wireless devices like
smart cards or phones, etc.

• It has provable security with robust leakage resilience
in the CK-framework,
in the sense that all values,
which can be oﬄine pre-computed and stored, can be
exposed to the attacker.

• It enjoys gab-ﬂexibility and more ﬂexible and mod-
ular protocol structure, in the sense that, for appli-
cations where gab-traceability takes priority over HP-
deniability, the value gab can simply get involved in
session-key computation at the minimal cost of one
modular addition incurred, while still preserving prov-
able security and online optimal eﬃciency. For pre-
sentation simplicity, the variant of OAKE that pro-
vides gab-traceability is referred to as traceable OAKE
(T-OAKE in short). T-OAKE is still (slightly) more
eﬃcient than HMQV in total.

• The shared DH-secret involves only a single hashing
operation, which particularly indicates that OAKE is
hardly viewed as a variant of HMQV. We remark that
cryptographic hashing, e.g., SHA-1, is quite an expen-
sive operation, particularly compared to modular mul-
tiplication, and is thus much desirable to minimize the
use of hashing particularly for highly practical proto-
cols like IA-DHKE.

• It eases deployments in practice, particularly for ap-
plications based on low-power devices like smart cards
or phones.

11152. PRELIMINARIES

If S is a ﬁnite set then |S| is its cardinality, and x ← S
is the operation of picking an element uniformly at ran-
dom from S.
If α is neither an algorithm nor a set then
x ← α is a simple assignment statement. A string or value
α means a binary one, and |α| is its binary length. We de-
note by N the set of natural numbers. Throughout this
work, unless otherwise speciﬁed, we use a hash function
h : {0, 1}∗ → {0, 1}l \ {0l} ⊆ Z∗
q , which is modeled as a
random oracle, and we denote by its output length l, usu-
ally presented in unary as 1l, as the security parameter. Two
ensembles X = {Xl}l∈N and Y = {Yl}l∈N are computation-
ally indistinguishable, if for any probabilistic polynomial-
time (PPT) algorithm D and for all suﬃciently large l’s,
| Pr[D(1l, Xl) = 1] − Pr[D(1l, Yl) = 1]| is negligible in l.

Throughout this paper, unless otherwise stated, we as-
sume that the underlying PKI does not require proof-of-
possession or proof-of-knowledge (POP/POK, in short) of
secret key during public key registration. As we focus on
IA-DHKE with robust leakage resilience, for presentation
simplicity, we assume that the Certiﬁcate Authority (CA)
will check the non-identity sub-group (i.e., G \ 1G) mem-
bership of registered public keys, which is also required by
HMQV whenever the pre-computation of DH component or
exponent is considered (cf.
the full version of [51]). But
supposing no pre-computation or leakage of DH exponents,
the sub-group test for registered public keys will be waived.
Roughly speaking, the discrete logarithm (DL) assump-
tion over G says that given X = gx, where x ← Z∗
q , no
eﬃcient, speciﬁcally probabilistic polynomial-time (PPT),
DL-solver algorithm can output x with non-negligible prob-
ability. The gap DL (GDL) assumption says that the DL as-
sumption holds even if the DL-solver algorithm is equipped
with a decisional Diﬃe-Hellman (DDH) oracle for the group
G and generator g, where on arbitrary input (U, V, Z) ∈ G3
the DDH oracle outputs 1 if and only if Z = CDH(U, V ).
The computational Diﬃe-Hellman (CDH) assumption says
that given X = gx, Y = gy, where x, y ← Z∗
q , no eﬃ-
cient CDH-solver algorithm can compute CDH(X, Y ) = gxy
with non-negligible probability. The Gap Diﬃe-Hellman
(GDH) assumption [66] roughly says that the CDH assump-
tion holds even if the CDH solver is equipped with a DDH
oracle for the group G and generator g.

Knowledge-of-Exponent Assumption (KEA) [27].
Let G be a cyclic group of prime order q generated by an el-
ement g, and consider an algorithm A that on input a triple
(g, C = gc, z) outputs a pair (Y, Z) ∈ G2, where c is taken
uniformly at random from Z∗
q and z ∈ {0, 1}∗ is an arbitrary
string that is generated independently of C. Such an algo-
rithm A is said to be a KEA algorithm if with non-negligible
probability (over the choice of g, c and A ’s random coins)
A (g, gc, z) outputs (Y, Z) ∈ G2 such that Z = Y c. The
algorithm A is called a strong KEA algorithm, if it is addi-
tionally equipped with a DDH oracle. Here, C = gc is the
random challenge to the KEA algorithm A , and z captures
the auxiliary input of A that is independent of the challenge
C. We say that the KEA assumption (resp., the strong
KEA assumption) holds over G, if for every probabilistic
polynomial-time KEA (resp., strong KEA) algorithm A for
G there exists another eﬃcient algorithm K, referred to as
the KEA-extractor, for which the following property holds
except for a negligible probability. Let (g, gc, z) be an input
to A , ρ a vector of random coins for A (and LDDH the an-

swers from the DDH-oracle for the strong KEA algorithm),
on which A outputs (Y, Z = Y c). Then, on the same inputs
and random coins, K(g, C, z, ρ) (resp., K(g, C, z, ρ, LDDH))
outputs the triple (Y, Z = Y c, y) where Y = gy.

Notice that, by deﬁnition, both KEA and strong KEA
are non-black-box assumptions. The KEA assumption is
derived from the CDH assumption, while the strong KEA
(SKEA) assumption is derived from the GDH assumption.

3.

(H)MQV VERSUS KEA/OPACITY:
A COMPARATIVE STUDY

The salient advantage of (H)MQV is that the session-key
computation essentially accounts for about one simultaneous
exponentiation (SE), which amounts to about 1.27 modular
exponentiations [61, 38, 33]. By comparison, each player in
KEA/OPACITY needs to perform two separate exponenti-
ations to derive the session-key. Indeed, (H)MQV is com-
monly viewed as nearly optimal in the integrity of security
and protocol eﬃciency, and even a minor eﬃciency improve-
ment (while preserving provable security) is desirable and
can be challenging.

On the other hand, KEA and OPACITY enjoy the ad-
vantages of optimal online eﬃciency and honest-player de-
niability (HP-deniability). By “optimal online eﬃciency”, we
mean that the values Y and Ay (resp., X and Bx) can be
oﬄine pre-computed and stored by the player ˆB (resp., ˆA),
and each player needs to perform only one modular expo-
nentiation X b or Y a (besides some other minor operations
like hashing and/or MAC, etc). By comparison, the session-
key computation of (H)MQV, which takes one simultane-
ous exponentiation, does not allow oﬄine pre-computability.
Notice that the known fastest simultaneous exponentiation
algorithm runs about 1.27 exponentiations [61, 38, 33]. By
“honest-player deniability”, we mean that the transcript of
a session run between a pair of honest players, the resultant
session-key, and all the pre-computed and stored session-
states, can be statistically simulated by an eﬃcient algo-
rithm from the public parameters and players’ public keys.
A formal deﬁnition of HP-deniability is given in Section 6.2.
The HP-deniability property of KEA/OPACITY is from the
fact that: the session-key, as well as the values Ay and Bx,
can be computed merely from the DH-exponents x and y (to-
gether with some public parameters). These advantageous
features of KEA/OPACITY made them much desirable for
deployments based on low-power devices like smart cards or
phones; indeed, OPACITY was designated mainly for ap-
plications with low-power devices in wireless settings. By
comparison, the use of the session-key of (H)MQV can be
deﬁnitely traced back to the pair of players as the value gab
is involved in the session-key derivation, which is referred to
as gab-traceability for presentation simplicity.

On the desirability of oﬄine pre-computability,
particularly for IA-DHKE. Firstly, in general, the “pos-
sibility of pre-computation to reduce on-line computational
complexity” is listed as one important feature for measuring
eﬃciency advantage of KE protocols [61, 17, 24], particularly
for deployment with low-power devices like smart cards.

Secondly, oﬄine pre-computability is particularly desir-
able for deployment of KE in the distributed client/server
setting (the major application scenario for which OPAC-
ITY was designed), where clients (e.g., smart-cards, smart-
phones) are usually more power-limited than the server (e.g.,

1116a bank, a base station, an organization) while the server is
usually static and its public key can be priorly known to
clients. In such a setting, it is much desirable for the low-
power clients to obtain oﬄine pre-computability in order
to accelerate online eﬃciency. Moreover, in such a setting,
the server (e.g., player ˆB in KEA/OPACITY) usually runs a
database of clients. Then, for each client player ˆA, the server
ˆB can pre-compute (Y, Ay) and stores the pre-computed val-
ues in the entry of player ˆA in the database. That is, the
server can also enjoy oﬄine pre-computability to accelerate
online eﬃciency.

Thirdly, oﬄine pre-computability is also much desirable
for deployment of KE in the station-to-station setting, which
is particularly the major application scenario of (H)MQV
by NSA. Speciﬁcally,
in such a setting, players are usu-
ally organizations or stations, whose identities and public
keys are known each other priorly, which allows oﬄine pre-
computability to accelerate online eﬃciency.

Fourthly, particularly for IA-DHKE, oﬄine pre-computability

allows more eﬃcient explicit sub-group test of peer’s DH-
component.
It is commonly suggested important for each
player of DHKE to make sure the DH-component from its
peer is indeed in the sub-group G (particularly in order to
avoid small group attacks).2 With oﬄine pre-computation,
KEA/OPACITY allows more eﬃcient explicit sub-group test.
With the computation of ˆB as an example, it can online
perform X b and X q in parallel, which amounts to about 1.2
modular exponentiations.

Finally, oﬄine pre-computability allows more robust em-
bedded sub-group test. For KEA/OPACITY with oﬄine
pre-computation, the value X y in session-key derivation can
be replaced by X yt, and the player ˆB aborts if X (cid:8)∈ G(cid:2) or
X yt (cid:8)= 1G. This fully guarantee that X is not in a (small)
subgroup of G(cid:2) with the order that is a factor of t. The em-
bedded sub-group test performed by (H)MQV, i.e., checking
(XAd)(y+be)t (cid:8)= 1G, does not fully ensure that X is not in a
small group in general.

On the desirability of HP-deniability. Firstly, for KE
protocols, both security and privacy are desired. Among pri-
vacy concerns, deniability is an essential privacy property,
and has always been a central concern in personal and busi-
ness communications. The reader is referred to [16, 68, 69,
34] for more motivations for deniability of KE.

Secondly, providing a certain level of privacy protection
serves as one of the major criteria underlying the evolu-
tion of a list of important industrial standards of KE pro-
tocols, which is particularly witnessed by the evolution of
IKE [49] (that is based on the SIGMA protocol [50]), as
well as the selection of the standards of KEA and OPAC-
ITY. IKE and SIGMA enjoy “plausible deniability” [50], in
the sense that the session transcript only consists of signa-
tures on the exchanged DH-components rather than play-

2The basic technique to check the DH-component, e.g., X,
is in G is to verify X q = 1G (and X ∈ G(cid:2) \1G) that performs
one exponentiation. However, if the cofactor t is small, e.g.,
G(cid:2) = Z∗
N such that N = 2q + 1, or G is the subgroup of an
elliptic curve over a ﬁnite ﬁeld (in this case the cofactor t is
usually a small constant and even just 1), the subgroup test
of X can be essentially reduced to: (1) check X ∈ G(cid:2); (2).
X t (cid:8)= 1G. We remark that, in general, checking X ∈ G(cid:2) and
X t (cid:8)= 1G guarantees that X is not in a (small) subgroup of
G(cid:2) with the order that is a factor of t, but it does not fully
guarantee X ∈ G (e.g., considering that X = −gx).

ers’ identities. However, as signatures are included in the
session transcript, IKE and SIGMA cannot be HP-deniable.
On the other hand, the HP-deniability is commonly viewed
as a useful feature of KEA/OPACITY, which we would like
to preserve.

Thirdly, for an IA-DHKE protocol, we cannot count on
full-ﬂedged deniability as deﬁned in [34, 72]. Notice that,
for all IA-DHKE protocols, their session transcripts are the
same. The privacy mainly lies in the way the session-key is
computed. In this sense, HP-deniability is the most useful
privacy property that any IA-DHKE protocol can render.

Finally, HP-deniability enables more modular and ﬂexi-
ble constructions of higher-level privacy-preserving crypto-
graphic systems, in order to oﬀer various privacy services
based upon it. Notice that,
if the session transcript in-
cludes players’ signatures or the session-key computation
involves the value gab, it can nullify an untraceability prop-
erty oﬀered by a fancy cryptographic protocol running at
the higher level. On the other hand, if deniability is not de-
sired, for some cases, some non-repudiable mechanisms, e.g.,
signatures, can be easily issued at the higher level. In a way,
the relationship between HP-deniability and full deniability
is analogue to that between honest-veriﬁer zero-knowledge
(HVZK) and ZK, where HVZK has already been commonly
viewed as a powerful building tool in the literature.

On the desirability of gab-ﬂexibility for IA-DHKE.
Note that KEA/OPACITY and (H)MQV have diﬀerent per-
formance advantages, and for diﬀerent applications we may
want to deploy diﬀerent protocols. However, as the session-
key derivation mechanisms of KEA/OPACITY and (H)MQV
are diﬀerent in nature, it is less easy or ﬂexible to switch be-
tween them in practice (particularly for applications based
on low-power devices). We hope for a protocol that is as
eﬃcient as (H)MQV, while simultaneously enjoying online
optimal eﬃciency and HP-deniability of KEA/OPACITY.

One additional ﬂexibility advantage of KEA is that, for
applications where gab-traceability takes priority over HP-
deniability, the value gab can be put into the input of the
session-key derivation function without sacriﬁcing the online
optimal eﬃciency. Speciﬁcally, K = HK(Ab, Ay, X b, ˆA, ˆB)
in this case, which is referred to as traceable KEA (T-KEA)
for presentation simplicity. Notice that the parallel com-
putation of Ab and Ay amounts to about 1.2 modular ex-
ponentiations. That is, the session-key computation of T-
KEA takes about 2.2 exponentiations, which is, however,
still in sharp contrast to the about 1.27 exponentiations of
(H)MQV in such a scenario. On the other hand, the session-
key derivation of (H)MQV is less ﬂexible than KEA, in the
sense that we do not know how to remove the value gab
from the session-key computation of HMQV for applications
where HP-deniability takes priority, while still preserving its
provable security.

In this work, we want for an IA-DHKE protocol with gab-
ﬂexibility, in the sense that, according to diﬀerent desirabil-
ity between gab-traceability and HP-deniability, the value
gab can be simply added to or removed from the session-
key derivation. Moreover, the switching on or oﬀ of gab
in session-key derivation is at the minimal cost of only one
modular addition incurred, without sacriﬁcing provable se-
curity and online eﬃciency. This can provide much more
ﬂexibilities and deployment ease in practice.

11173.1 Security of KEA/OPACITY and (H)MQV
KEA and its variants were analyzed in [53, 56], where
a slight variant of KEA was proven to be secure in accor-
dance with the CK-framework under the gap Diﬃe-Hellman
(GDH) assumption in the random oracle (RO) model [11].
In the security analysis of KEA [53, 56], for any session
other than the test-session and its matching session, the pre-
computed and stored session-state (that can be exposed to
attacker) at a player includes its DH-exponent, DH-component,
and the value Bx or Ay. The provable security of OPACITY
is still unknown to our knowledge, though we suggest the se-
curity analysis of KEA [56] may be adapted and extended
to that of OPACITY.

Assuming no leakage of any DH-component (that is to
be publicly exchanged in plain) or private secrecy like DH-
exponent, the provable security of HMQV is based merely
on the CDH assumption. However, whenever there is an un-
corrupted player whose DH component or component is pre-
computed and may be exposed prior to the session run (and
thus the attacker can just set this session as the test-session),
the provable security of HMQV is based on the GDH as-
sumption and the non-standard (non-black-box) strong KEA
assumption [72].3 The provable security of MQV in the CK-
framework is unknown to our knowledge.

However, for HMQV, its provable security does not con-
sider the leakage of all values that can be oﬄine pre-computed
and stored. Speciﬁcally, for (H)MQV, it is quite natural
for a player, e.g., ˆB, to oﬄine pre-compute and store the
values (Y, y, sB = y + eb) in order to accelerate online eﬃ-
ciency. Notice that cryptographic hashing, e.g., SHA-1, and
multiplication could be relatively expensive operations for
low-power devices, and are thus desirable to be oﬄine pre-
computed. But the leakage of sB = y + eb can cause the
following security damages.

• The leakage of sB = y + eb has already exposed the
session-key of the exposed session as well as its match-
ing session (in case the matching session exists).

• The leakage of sB = y + eb allows an adversary to
impersonate the player ˆB in other (non-matching) ses-
sions, by reusing the values (Y, sB) without necessarily
knowing the secret key b.

• In addition, the leakage of sB and y together actually

exposes the static secret key b.

This violates the principle that the secrecy leakage of one
session should have no adverse bearing on the security of
other (non-matching) sessions. To avoid this security dam-
ages, the provable security of HMQV explicitly exclude the
leakage of the value sB or sA. To be precise, for the prov-
able security of all the protocols, i.e., KEA, HMQV and
the OAKE protocol family developed in this work, the at-
tacker is additionally allowed to expose the static secret key
of any uncorrupted player other than the test-session peer,
i.e., player ˆB if the test-session is ( ˆA, ˆB, X0, Y0). Then, for
the provable security of HMQV in [51],
it implicitly im-
plies that the session-state (y, Y, sB) of ˆB for any session
3We notice that the provable security of HMQV, for the
case where DH exponents or components may be exposed,
is actually based on the strong KEA assumption (besides
the GDH assumption), while in [51] it was informally stated
to be based on the KEA assumption.

should not be exposed in order to comply with the security
in CK-framework (unless sB is not speciﬁed to be part of
the session-state). In other words, if sB is speciﬁed as part
of the session-state, the provable security of HMQV will be-
come much limited. More discussions on security, when the
session-state of the test-session or its matching session can
be exposed, are given in Section 6.4 (page 12).

On the desirability of robust leakage resilience. In
practice, many cryptographic applications will boost pro-
tocol performance by pre-computing and storing values for
later use in the protocol, particularly when they are based
on low-power devices like smart cards or phones. However,
these pre-computed and stored values are much vulnerable
to leakage, in view of the various side-channel attacks (see,
e.g., [41, 12]) discovered in recent years. In particular, the
powerful “cold-boot attack” [41] allows an attacker to reveal
information about memory contents, particulary the values
that are pre-computed and stored in memory, in the absence
of computation and even after the device is powered down
[57]! In addition, cryptosystems may usually be deployed in
hostile environments plagued with spyware or virus, which
can actively reveal memory content information, particu-
larly for applications based on low-power devices in wireless
settings. As a consequence, it is commonly suggested to be
imprudent to assume no secrecy leakage for cryptosystems
in reality [18].

A basic principle, guiding any security formulation for
key-exchange protocols, is that the leakage of ephemeral in-
formation associated with a particular session (e.g., its ses-
sion key or state) should not compromise other non-matching
sessions. Moreover, for DHKE protocols, the oﬄine pre-
computed and stored DH-components are much less pro-
tected in practice, as they are actually public values to be
exchanged in plain. For DHKE protocols running concur-
rently in settings like the Internet, we suggest that it is also
unreasonable or unrealistic to assume non-precomputation
and non-exposure of the public DH-components for all un-
corrupted parties in the system. Notice that, whenever there
is an honest user who pre-computes a DH-component (and
thus the attacker can choose that session as the test-session),
then for provable security in the CK-framework we have to
consider the potential leakage of DH-components.

In this work, we aim for secure IA-DHKE with robust
leakage resilience, in the sense that the exposed session-state
includes all the pre-computed and stored session-speciﬁc val-
ues. On the one hand, the pre-computed and stored values
are much more vulnerable to leakage (than the ephemeral
intermediate values generated on the ﬂy during a session
run). On the other hand, we suggest it appears strange to
assume, for a naturally pre-computable value, e.g., the value
sB = y + eb in (H)MQV, to be not pre-computed or to be
stored safely and separately from other pre-computed ses-
sion values. One suggestion may be to use a trust tamper-
proof hardware to store any SK-related secrecy, which is,
however, costly and unusual in practice (particularly for low-
power devices like smart cards or phones). As mentioned
above, the provable security of HMQV does consider and
allow the exposure of sB = y + eb or sA = x + da.

Thus, it is clearly desirable to have secure IA-DHKE with
robust leakage resilience. As already stressed in [51], secu-
rity of KE against the exposed oﬄine pre-computed values
(particularly, the DH-components to be exchanged in plain)
is deemed to be a must, as well as the main and prime

1118concern, for any robust KE protocol. This is particularly
the case for protocols that are widely standardized and are
aimed for protecting critical information including “classiﬁed
or mission critical national security information” [71, 51].

4.

JOINT KNOWLEDGE-OF-EXPONENT
ASSUMPTION

Motivated for breaking some impossibility barriers of black-
box cryptography, and for achieving cryptographic schemes
of conceptually simple structure and analysis, achieving cryp-
tographic schemes based on non-black-box assumptions or
primitives has been attracting much research attention in
recent years ([6, 20, 21, 37, 28, 13]). As a popular non-black-
box assumption, the KEA assumption, since its introduction
[27], has been shown to be successful in solving a number
of (at times notoriously open) cryptographic problems, and
has been used in a large body of subsequent works (see, e.g.,
[27, 40, 10, 9, 68, 51, 29, 69, 2, 62, 20, 21, 39, 36, 37, 72,
28, 13]). The KEA assumption and its variants are particu-
larly used for authenticated KE [51, 68, 69, 36, 72], and are
recently abstracted and generalized in [20, 21, 13].

In spite of the success and popularity of the KEA as-
sumption, by its nature the KEA assumption is actually
not very convenient for use in applications involving proving
the knowledge of multiple DH-exponents. In such settings,
to prove the knowledge of multiple DH-exponents with the
KEA assumption, each of the prover and the veriﬁer needs
to perform multiple separate exponentiations, which is less
eﬃcient (particularly for applications based on low-power
devices like smart-cards).

Motivated for more eﬃcient use of KEA-type assumptions
and for conceptually simple protocol design and analysis, in
this work we introduce an extension of the KEA assump-
tion in the random oracle model, referred to as the joint
knowledge-of-exponent assumption (JKEA).

Definition 4.1

(JKEA assumption). Let G be a cyclic

group of prime order q generated by an element g, and con-
sider an algorithm A with oracle access to an RO h : {0, 1}∗ →
{0, 1}l \ {0} ⊆ Z∗
q . On input a triple (g, X = gx, z), the
algorithm A outputs (B, Y, Π, aux) ∈ G3 × {0, 1}∗, where
x ← Z∗
q and z ∈ {0, 1}∗ is an arbitrary string that is gen-
erated independently of X. Such an algorithm A is said
to be a JKEA algorithm if, with non-negligible probability
(over the choice of g, x, A ’s random coins and the choice of
the random function h), A (g, gx, z) outputs (B, Y, Π, aux) ∈
G3×{0, 1}∗ satisfying Π = X b+h(aux,B,X,Y )y. The algorithm
A is called a strong JKEA algorithm, if it is additionally
equipped with a DDH oracle.

We say that the JKEA assumption (resp., strong JKEA
assumption) holds over G in the random oracle model, if for
any eﬃcient JKEA (resp., strong JKEA) algorithm A for
G there exists another eﬃcient algorithm K, referred to as
the JKEA-extractor, for which the following property holds
except for a negligible probability: let (g, gx, z) be an input
to A , ρ be the random coins of A , and LRO the answers
from the random oracle h (and LDDH the answers from
the DDH oracle for the strong JKEA algorithm), on which
A outputs (B, Y, Π, aux) ∈ G3 × {0, 1}∗ satisfying Π =
X b+h(aux,B,X,Y )y. Then, on the same inputs and random
coins, i.e., (g, X, z, ρ, LRO) (resp., (g, X, z, ρ, LRO, LDDH)),
K outputs both b and y, where B = gb and Y = gy.

Proposition 4.1. JKEA assumption (resp., strong JKEA
assumption) is implied by the KEA assumption (resp., strong
KEA assumption) in the random oracle model.

Proof. On input (g, X = gx, z), we can view the (strong)
KEA algorithm A outputs (Z = BY e, CDH(X, Z), aux)
with non-negligible probability, where e = h(aux, B, X, Y ).
Then, by the (strong) KEA assumption, the value s = b+ey
can be extracted.

(cid:2). On input (g, X, z), A

(cid:2) will output (Z(cid:2) = BY e(cid:2)

Now, from the algorithm A , we construct another (strong)
(cid:2) runs A as a
JKEA algorithm A
subroutine. In case A outputs (Z = BY e, CDH(X, Z), aux),
(cid:2) rewinds A to the point that A just made the oracle
A
query h(aux, B, X, Y ), redeﬁnes h(aux, B, X, Y ) to be a new
random value e(cid:2) (cid:8)= e, and runs A further from this rewind-
ing point. If A outputs (Z(cid:2) = BY e(cid:2)
(cid:2)
, CDH(X, Z(cid:2)), aux), A
just outputs it; otherwise, A aborts. By the forking lemma
, CDH(X, Z(cid:2)), aux) also
[67, 1], A
with non-negligible probability. Then, by the (strong) KEA
assumption, the value s(cid:2) = b + e(cid:2)y can be extracted. Notice
that, from (s, s(cid:2)), both b and y will be computed.
(cid:2)
Though the JKEA assumption is implied, and thus jus-
tiﬁed, by the KEA assumption in the RO model, as we
shall see, JKEA-based protocol design and analysis can be
more eﬃciency preserving and conceptually simpler for ap-
plications involving proving the knowledge of multiple DH-
exponents, in comparison with KEA-based protocol design
and analysis. Also, by getting rid of the forking lemma,
JKEA-based analysis can be much tighter than KEA-based
analysis. We remark that the JKEA-based approach is of
independent interest, and brings new insight into the design
of DH-protocols involving proving the knowledge of multiple
DH-exponents, which is particularly witnessed by the design
of the OAKE protocol family below.

5. OAKE: DESIGN AND SPECIFICATION
Consider the JKEA assumption proposed in Section 4.
By setting aux = ( ˆA, A, ˆB), we refer to X b+ey, where e =
h( ˆA, A, ˆB, B, X, Y ), as the joint proof-of-knowledge (JPOK)
of both b and y w.r.t. the random DH-component challenge
X, which is denoted as JP OK(b,y) = X b+ey for presentation
simplicity. The reason that we let e commit to the complete
session tag, denoted T ag = ( ˆA, A, ˆB, B, X, Y ), is that, in
practice, JPOK is actually run concurrently with other pro-
tocols over network. For secure use of JPOK in concurrent
settings like Internet, as is the focus of this work, we re-
quire that the JPOK provided by one party in a session
should be bounded to that session, in the sense that no ef-
ﬁcient attacker can, with non-negligible probability, make
two diﬀerent (non-matching) sessions have the same shared
DH-secret. More details are given in Section 6 with respect
to the analysis of the JPOK-based OAKE protocol in the
CK-framework.

Notice that JP OK(b,y) = X db+ey = (BdY e)x, where e =
h( ˆA, A, ˆB, B, X, Y ), actually can also be used to demon-
strate the knowledge of x. The key observation now is:
in order for ˆA to additionally prove the knowledge of its
secret key a, we can multiply X db+ey by Y a. This yields
K ˆB = AyX b+ey = BxY a+ex = K ˆA, where K ˆB (resp., K ˆA)
is computed by ˆB (resp., ˆA) respectively. The resultant
IA-DHKE protocol is named OAKE, and is depicted in Fig-
ure 1. Note that the computation of the shared DH-secret

1119Total eﬃciency
Online eﬃciency

1tse+1th+1tm+1ta
1te + 1th + 1tm + 1ta

1tse+1th+1tm+2ta
1te + 1th + 1tm + 1ta

1tse+2th+2tm+1ta
1tse+2th+2tm+1ta

OAKE

T-OAKE

HMQV

KEA
2te
1te

SK-Security

exposed session-state

Assumptions

(x, X, Bx)

GDL+SJKEA

or, GDH

(x, X)

GDL+SJKEA

or, GDH

(x, X)

(x, X, Bx)

GDH+SKEA

GDH

CDH-based security
w/o pre-computation

HP-deniability
gab-traceability
gab-ﬂexibility

⊥

(cid:3)

×

(cid:3)

⊥
×

(cid:3)

(cid:3)

(cid:3)
×

(cid:3)

⊥

⊥

(cid:3)

×

⊥

Table 1: A brief comparison among (T)OAKE, HMQV and KEA

K ˆA = K ˆB involves only a single hashing, where the out-
put length of h, i.e., l, is set approximately to be |q|. For
applications where gab-traceability takes priority over HP-
deniability, we set K ˆB = Ab+yX b+ey = Ba+xY a+ex = K ˆA,
which is referred to as traceable OAKE (T-OAKE, in short).
That is, the value gab can simply get involved (for applica-
tions where traceability takes priority over HP-deniability)
at the minimal cost of only one modular addition, which
eases more ﬂexible and modular deployments in practice.
More variants of OAKE are presented in Appendix A.

Some advantageous features of OAKE. The session-
key computation of OAKE takes about one simultaneous
exponentiation, and is slightly more eﬃcient than that of
HMQV. To our knowledge, OAKE (with embedded sub-
group test) is the most eﬃcient provably secure IA-DHKE
protocol to date. OAKE enjoys the online eﬃciency of KEA/OPACITY,
i.e., the value Ay (resp., Bx) can be oﬄine pre-computed
by ˆB (resp., ˆA), as well as the HP-deniability. Also, OAKE
eases deployments in practice, based on the following grounds.

• The OAKE protocol family combines, in essence, the
advantages of both KEA/OPACITY and (H)MQV,
while saving from the disadvantages of them both.

• Similar to IKE providing two protocols or modes [49]
to ease deployments in practice, according to diﬀerent
desirability between gab-traceability and HP-deniability
in diﬀerent applications, the value gab can be simply
switched on or oﬀ in the session-key computation, at
the minimal cost of only one modular addition.

• As clariﬁed in Section 3, the oﬄine pre-computability
of Ay and Bx allows more eﬃcient parallel explicit sub-
group test, as well as more robust embedded subgroup
test.

• No POP/POK of secret key is assumed during public

key registration.

• As we shall see, OAKE enjoys robust leakage resilience
in the sense that all the pre-computed values can be
exposed to the attacker without sacriﬁcing SK-security
in the CK-framework. This much eases deployments
based upon low-power devices, like smart cards or phones,
in hostile computing environments.

• In addition, as to be discussed in Section 6.5, it well
supports deployment in the public computation model

[54], and enjoys joint proof-of-knowledge session-key
computation without mandating POP/POK of secret
key.

A brief comparison. A brief comparison among (T)OAKE,

HMQV and KEA is summarized in Table 1 (page 8).
In
Table 1, tse stands for the time for performing one simulta-
neous exponentiation, te the time for performing one mod-
ular exponentiation, th the time for performing one hashing
operation, tm the time for performing one modular multipli-
cation over Z∗
q , and ta the time for performing one modular
addition over Z∗
q . For total eﬃciency, we only count the op-
erations needed to compute the input to the key derivation
function HK, as all the other operations are the same for all
these protocols.

For the item of “Assumptions” in Table 1, by SKEA (resp.,
SJKEA, GDL) we refer to strong KEA (resp., strong JKEA
and gap DL), where GDL (resp., SJKEA) is weaker than
GDH (resp., SKEA) in the RO model as discussed in Sec-
tion 2 and 4. The symbol “⊥” stands for “unapplicable”
or “unknown”. The item of “Secrecy exposure” refers to
the pre-computed and stored session-states that can be ex-
posed, where (x, X, Bx) stands for the situation where the
DH-components, DH-exponents, and the pre-computed val-
ues Bx’s and Ay’s for all sessions other than the test-session
and its matching session, can be exposed.

We choose KEA/OPACITY and (H)MQV as the bench-
mark protocols to compare, because they stand for the state-
of-the-art in their respective types and are widely standard-
ized. Needless to say, there are a large number of exist-
ing KE protocols in the literature. The bottom line here is
that, to the best of our knowledge, no protocol that com-
bines the advantages of both KEA/OPACITY and (H)MQV
is known. Still, we present discussions on the NAXOS pro-
tocol [55] in Appendix B, and comparisons with more proto-
cols in the full version [73]. If gab-traceability takes priority
over HP-deniability in some applications, one should com-
pare (H)MQV with T-OAKE directly, both of which pro-
vide gab-traceability but T-OAKE is still more eﬃcient and
provides more robust secrecy leakage resilience as to be dis-
cussed in Section 6.4 (page 12). Finally, we note that the
developed OAKE protocol family enjoys conceptual simplic-
ity, and we remark that still being of conceptual simplicity
and practical eﬃciency should be viewed as a blessing for
this over-studied area and for protocols aimed for real use.

11206. SECURITY ANALYSIS

6.1 Overview of the CK-Framework for IA-

DHKE

Following the works [51, 56], we brieﬂy describe the CK-
framework for the provable security of IA-DHKE. In the
CK-framework for an IA-DHKE protocol, a session run at
the side of player ˆA with a peer player ˆB, where the out-
coming (resp., incoming) DH-component is X (resp., Y ), is
assigned with a session identiﬁer as ( ˆA, ˆB, X, Y ).
In each
session, a party can be activated as the role of either initia-
tor (who sends the ﬁrst DH-component) or responder (who
sends the second DH-component). During a normal proto-
col run (without adversary interference) between two players
ˆA and ˆB, we require that both sessions (one at ˆA and one
at ˆB) should compute the same session-key, which is re-
ferred to as the completeness property. The completeness
property within the CK-framework is captured by the deﬁ-
nition of matching sessions, which aims to capture when two
sessions are “intended communication partners”, and plays
an important role in the security deﬁnition within the CK-
framework.

In the context of IA-DHKE, one natural interpretation for
two sessions ( ˆA, ˆB, X, Y ) and ( ˆB, ˆA, Y, X) to be matching is
that: the players ˆA and ˆB should have matching roles in the
two sessions, i.e., if ˆA is the initiator (resp., responder) then
ˆB is the responder (resp., initiator) in both of the two ses-
sions. However, as the basic (H)MQV is role-independent,
for two sessions between the same pair of players ˆA and
ˆB but with the opposite order of DH-component exchange
(which may be made by a cross-message attack [25]),4 player
ˆA (resp., ˆB) thinks it is interacting with a responder ˆB
(resp., ˆA), while the session-key outputs in these two ses-
sions are the same. That is, two sessions (between the same
pair of players) output the same session-key but with role
confusion between each other. The work [51] was (implic-
itly) clear of this situation, and such a problem is ruled out,
by deﬁnition, by simply deﬁning two sessions ( ˆA, ˆB, X, Y )
and ( ˆB, ˆA, Y, X) to be matching, no matter whether the two
players have matching roles or not. That is, two sessions
with adversary interference under a cross-message attack
[25] are deﬁned to be matching. However, from our view, in
light of the cross-message attack [25](that causes role con-
fusion between two matching sessions for role-independent
IA-DHKE), such a deﬁnition of matching sessions is “ill”, as
it does not well capture the intuition of “intended communi-
cation partners” without adversary interference. We notice
that, for robust (H)MQV and KEA that are role-dependent
as ( ˆA, ˆB) are involved in a ﬁxed order in session-key deriva-
tion, the more natural deﬁnition of matching sessions, where
the two players are required to have matching roles, is used
implicitly in [51] and explicitly in [56].

4In a cross-message attack, an adversary A concurrently in-
teracts, as the responder, with ˆA (resp., ˆB) in the name of
ˆB (resp., ˆA) in two sessions. After getting X and Y respec-
tively as the ﬁrst-round message in both of the two sessions,
it sends Y (resp., X) to ˆA (resp., ˆB) as the second-round
message in both of the two sessions. For the basic (H)MQV,
both of the two players will output the same session-key in
the two sessions but with role confusion.

A CMIM adversary A controls all the communication
channels among concurrent session runs of the KE protocol.
In addition, A is allowed access to secret information via
the following three types of queries: (1) state-reveal queries
for ongoing incomplete sessions; (2) session-key queries for
completed sessions; (3) corruption queries upon which all
information in the memory of the corrupted parties will be
leaked to A . A session ( ˆA, ˆB, X, Y ) is called exposed, if itself
or its matching session ( ˆB, ˆA, Y, X) suﬀers from any of these
three queries. The session-key security (SK-security) within
the CK-framework is captured as follows. For any com-
plete session ( ˆA, ˆB, X, Y ) between two uncorrupted players
ˆA and ˆB, which is adaptively chosen by A and is referred
to as the test session, as long as it is unexposed (in par-
ticular its matching session, if it exists, was not exposed
during its ongoing incomplete stage before A stops5) the
followings hold with overwhelming probability.
(1) Com-
pleteness: the session-key outputs of the test-session and its
matching session are identical. (2) Randomness: A cannot
distinguish, with non-negligible probability/advantage over
1/2, the session-key output of the test-session from a ran-
dom value. A variant of the CK-framework, referred to as
extended CK model (eCK-model), is also discussed in Ap-
pendix B.

Here, we would like to stress that, as already explicitly
clariﬁed in [25], the SK-security deﬁned for role-dependent
IA-DHKE (referred to as role-dependent SK-security) and
that for role-independent IA-DHKE (referred to as role-
independent SK-security), diﬀerentiated by the deﬁnition
of matching sessions, are fundamentally incomparable. On
the one hand, any role-dependent IA-DHKE, like robust
(H)MQV and KEA/OPACITY, does not satisfy, by deﬁ-
nition, the completeness property of role-independent SK-
security. On the other hand, any role-independent IA-DHKE
like the basic (H)MQV is totally broken according to role-
dependent SK-security (as the session-key of the test-session
can exist in a non-matching session by the cross-message at-
tack [25]), which might be viewed as more dangerous.

Throughout this work, for the OAKE protocol family,
KEA and robust (H)MQV that all are role-dependent, we
are referring to role-dependent SK-security, while for the ba-
sic (H)MQV that is role-independent, we are referring to the
role-independent SK-security w.r.t. the relaxed deﬁnition of
matching session without requiring matching roles.
6.2 HP-Deniability: Deﬁnition and Discussion

In this section, we introduce and formalize the HP-deniability

for IA-DHKE along with justiﬁcation and discussion.

Definition 6.1. On the security parameter n, consider
a complete session run of an IA-DHKE protocol between
a pair of honest players ˆA and ˆB, where player ˆA (resp.,
ˆB) has public key P K ˆA (resp., P K ˆB) and secret key SK ˆA
5For IA-DHKE, this makes sense mainly when the test-
session is held by a responder. Consider that the attacker
ﬁrst activates an initiator ˆA to get X, and then suspends this
session held by ˆA till ﬁnishing the test-session ( ˆB, ˆA, Y, X)
run by ˆB. If the session run by ˆA is never completed, the
DH-exponent x can be exposed to adversary (while ˆA cannot
be corrupted as the test-session is required to be between two
uncorrupted players); but if later this session is completed
and thus becomes matching to the test-session, it should be
unexposed for the SK-security.

1121)

ˆB(SK ˆB
ˆA(SK ˆA

Denote by view

(resp., SK ˆB), and has the key certiﬁcate C ˆA (resp., C ˆB)
issued by the Certiﬁcate Authority in the underlying PKI.
) (1n, C ˆA, C ˆB) a random variable de-
scribing the session transcript (i.e., the messages exchanged
during the session run), the resultant session-key, and all the
pre-computed and stored session-states6 (that can be exposed
by the state-reveal query).

We say the IA-DHKE protocol is HP-deniable, if there
exists a probabilistic polynomial-time simulator S, such that
for any suﬃciently large n, any pair of honest players ( ˆA, ˆB),
the following ensembles are statistically indistinguishable:

call such an adversary “strong adversary (with strong secrecy
exposure)”.

Theorem 6.1. OAKE is SK-secure against any PPT strong

adversary in the CK-framework, under the gap DL (GDL)
assumption and the strong JKEA (SJKEA) assumption in
the random oracle model.

Proof (of sketch). According to the SK-security deﬁnition
in the CK-framework, we need to prove that OAKE satisﬁes
the following two requirements.

{view

)

ˆB(SK ˆB
ˆA(SK ˆA

) (1n, C ˆA, C ˆB)}n∈N,C ˆA

,C ˆB

∈{0,1}∗,SK ˆA

,SK ˆB

∈{0,1}∗ ,

Requirement-1. If two parties ˆA, ˆB complete matching

sessions, then their session-keys are the same.

{S(1n, C ˆA, C ˆB)}n∈N,C ˆA

,C ˆB

∈{0,1}∗,SK ˆA

,SK ˆB

∈{0,1}∗ .

The IA-DHKE protocol is perfectly HP-deniable, if the

above ensembles are identical.

Requirement-2. There is no feasible adversary who suc-

ceeds, with non-negligible advantage (i.e., non-negligible
probability over 1/2), in distinguishing the session-key
of an unexposed session from a random value.

ˆB(SK ˆB
ˆA(SK ˆA

ˆB(SK ˆB
ˆA(SK ˆA

in place. The variable view

Here, statistical indistinguishability between view

Some comments about the HP-deniability deﬁnition are
)
) denotes the view of an
eavesdropping adversary A for a session run of DHKE be-
tween a pair of uncorrupted players ˆA and ˆB. Diﬀerent from
traditional honest-veriﬁer zero-knowledge (HVZK), the view
of A not only includes the messages being exchanged in the
session, but also includes the information that can be col-
lected by A via “session-key query” and “state-reveal query”.
)
) and
the output of simulator ensures forward deniability [68, 69].
If cast in the CK-framework for generality, we can consider
any CMIM adversary A as speciﬁed in the CK-framework
but with the following limitation: all the DH-components
exchanged in sessions between the pair of uncorrupted play-
ers ˆA and ˆB are honestly generated by themselves respec-
In other words, any session ( ˆA, ˆB, X, Y ) has the
tively.
matching session ( ˆB, ˆA, Y, X) with matching player roles,
and vice versa. Then, HP-deniability requires that the view
of A can be statistically simulated from the public values
and the secret keys of all the players other than ˆA and ˆB.
It is easy to see that, any IA-DHKE, where the session-
key, and all the pre-computed and stored session-states, can
be derived merely from DH-exponents x and y (and pub-
lic values),
In particular, both
KEA/OPACITY and OAKE are perfectly HP-deniable.
6.3 Security of OAKE in CK-Framework

is perfectly HP-deniable.

For the provable security of OAKE in the CK-framework,
in this work we consider a strong adversary A who can
expose, via state-reveal queries, all the oﬄine pre-computed
and stored session-speciﬁc values (including DH-components,
DH-exponents, the oﬄine pre-computed values Ay’s and Bx’s
for all sessions except the test-session and its matching ses-
sion). In addition, letting ( ˆA, ˆB, X0, Y0) be the test-session,
A can learn the static secret key of any uncorrupted player
except the player ˆB (i.e., the peer to the test-session).7 We
6Notice that, from the pre-computed and stored session-
state of a session, player’s random coins may not necessarily
be derived. For example, the coins of player ˆA for a session
are x(cid:2), while the pre-computed and stored session-state is
x = h(a, x(cid:2)).
7If the attacker exposes the static secret key b of the peer
player of the matching session, and in case Y is actually

The Requirement-1 is trivially satisﬁed with OAKE. In
the followings, we focus on establishing the Requirement-2.
Denote by ( ˆA, ˆB, X0 = gx0 , Y0 = gy0), where x0, y0 ∈ Z∗
q ,
the unexposed test-session between a pair of uncorrupted
players ˆA and ˆB where ˆA (cid:8)= ˆB, by HK (σ0) the session-key
of the test-session, and by σ0 = Ay0 X b+e0 y0 = Bx0 Y a+e0x0
the shared DH-secret, where e0 = h( ˆA, A, ˆB, B, X0, Y0). As
HK is a random oracle, there are only two strategies for the
adversary A to distinguish HK(σ0) from a random value:

• Key-replication attack. A succeeds in forcing the es-
tablishment of a session (other than the test-session
or its matching session) that has the same session-key
output as the test-session. In this case, A can learn
the test-session key by simply querying that session to
get the same key.

• Forging attack. At some point in its run, A queries

the RO HK with the value σ0.

The possibility of key-replication attack is trivially ruled
out unconditionally in the RO model. Speciﬁcally, for any
session tag ( ˆA, A, ˆB, B, X, Y ) and for any value σ ∈ G \ 1G,
it holds Pr[K ˆA = K ˆB = σ] ≤ 1
2l −1 for both OAKE and T-
OAKE, where the probability is only taken over the choice of
the random function h. Then, by the birthday paradox, any
eﬃcient attacker can succeed in the key-replication attack
only with negligible probability; speciﬁcally, with probabil-
s2
2l−1 in the RO model, where s is the number of
ity at most
sessions in the system.

Below, we focus on the analysis against the forging attack.
We further distinguish two cases, according to whether the
test-session has the matching session or not, and have the
following lemmas.

Lemma 6.1. For the case where the test-session has the
matching session, a successful forging attack can occur only
with negligible probability under the CDH assumption in the
random oracle model.

chosen by the attacker (this corresponds to the case where
the matching session does not exist), the attacker can com-
pute the session-key by itself and thus can trivially break
the SK-security.

1122Proof (of sketch). In this case, given two random DH-
components (X0 = gx0 , Y0 = gy0), a CDH-solver C (whose
goal is to compute CDH(X0, Y0)) works as follows. (1) It
generates the public and secret keys on behalf of all uncor-
rupted players (particularly the uncorrupted players ˆA and
ˆB of the test-session) in the system. (2) Then, it randomly
guesses the test-session and its matching session as follow.
Supposing there are s sessions in total in the system, where
s is a polynomial in the security parameter, C randomly
takes i, j ← {1, · · · , s}, hoping that the test-session (resp.,
the matching session) is the i-th (resp., the j-th) session.
The probability that C successfully guesses the test-session
and its matching session is 1
s2 . (3) C runs the (supposed)
forging attacker A and works as the honest players do in
all sessions except the test-session and its matching session.
Notice that C can perfectly answer by itself all queries from
A (speciﬁed in accordance with the CK-framework).
In
particular, for any session ( ˆA, A, ˆB, B, X, Y ), which is not
the test-session or its matching session, C can expose all the
pre-computed and stored values (a, X, x, Bx) to the attacker,
even if ˆA will be the player holding the test-session. (4) C
sets X0 (resp., Y0) as the DH-component to be sent in the
test-session (resp., the matching session).

It is easy to see that, conditioned on that C has correctly
guessed the test-session and its matching session, the emula-
tion of C is perfect from the view point of A . Now, suppose
A can succeed in the forging attack in this case, i.e., out-
putting σ0 = Ay0 X b+y0e0
, with non-negligible probability p.
Then, with probability p
s2 , C can compute CDH(X0, Y0) =
σ0/(Y a
0 X b
0 ) (recall that C knows the secret keys a and b in
this case).
(cid:2)

0

Lemma 6.2. For the case when no matching session ex-
ists, a successful forging attack can occur only with negligible
probability under the GDL and the SJKEA assumptions in
the random oracle model.

Proof (of sketch).

In this case, given random values
(X0 = gx0 , B = gb), where x0, b ← Z∗
q , the DL-solver C
(whose goal is to compute the discrete logarithm of B) works
as follows.

Suppose there are n parties { ˆP1, · · · , ˆPn} and s sessions
in total in the system, where n and s are polynomials in
the security parameter. C ﬁrst guesses the test-session and
the peer player of the test-session, by choosing uniformly at
random i ← {1, · · · , s} and j ← {1, · · · , n} and by setting
the i-th session as the test-session and the player ˆPj as the
peer player of the test-session. It generates the public and
secret keys on behalf of all uncorrupted players except the
player ˆPj in the system. For the player ˆPj , its public key
is just set to be B. WLOG, for presentation simplicity, we
assume that ˆB = ˆPj , and the player holding the test-session
is ˆA with public key A that is actually set by C.

Then, C runs the supposed forging attacker A by working
as the honest players do and answering queries made by A ,
except that:

• For the test-session, the DH-component to be sent by

ˆA is set to be X0.

• Consider any “session-key reveal” query made by A
against a session run by the uncorrupted player ˆB with
a peer player ˆZ. Denoted by ( ˆB, B, ˆZ, Z = gz, Y =

gy, X = gx) the corresponding session tag, where the
DH-exponent y is generated by (and thus known to) C
on behalf of ˆB, but the player ˆZ may be a corrupted
one and thus the secret key z or the DH-exponent x
is in general unknown to C. In particular, the values
(Y, y, Z cy) are (oﬄine) generated by C on behalf of ˆB,
and can be exposed to A upon its “state-reveal query”
against this session. For such a “session-key reveal”
query, C just returns back a value r taken uniformly
at random from {0, 1}k (i.e., the range of HK). How-
ever, from this point on, whenever A makes an RO-
query σ to the random oracle HK, C checks whether
σ = Z yX b+ey with the aid of a DDH-oracle O, speciﬁ-
cally, by checking whether CDH(X, B) = σ/(Z yX ey)
with the DDH-oracle O. If so, C returns the already
deﬁned value r to A as the RO answer on σ. Note that
the “session-key reveal” and RO queries are perfectly
answered by C in this case.

0

Notice that C can perfectly answer all the queries made
by A in accordance with the CK-framework. Conditioned
on C has successfully guessed the test-session and the peer
player ˆB of the test-session, which occurs with probabil-
ity 1
sn , the emulation of C is perfect from the viewpoint of
A . Now, suppose the forging attacker A can output, with
non-negligible probability p, σ0 = Ay0X b+e0 y0
for the test-
session of tag ( ˆA, A = ga, ˆB, B, X0, Y0), where the secret key
a is generated by and thus known to C while none of the dis-
crete logarithms of B, X0 or Y0 are known to C in general.
In particular, the value Y0 may be chosen by the attacker A
itself for the case when no matching session exists. Then,
with non-negligible probability p
sn , the algorithm C outputs
X b+e0 y0
from (σ0, a). Conditioned on this, by the strong
JKEA assumption, with overwhelming probability both b
and y0 can be extracted from the random coins of C and the
list of answers from the DDH-oracle O. With probability
negligibly close to p
sn , the discrete logarithm of B can be
computed, which then contradicts the GDL assumption. (cid:2)

0

Theorem 6.2. OAKE is SK-secure against any PPT strong

adversary in the CK-framework, under the GDH assumption
in the random oracle model.

Proof (of sketch). Note that the non-black-box JKEA
assumption was only used in the proof of Lemma 6.2 for the
case when no matching session exists. We show that the
forging attack for this case can actually be ruled out merely
based on the black-box GDH assumption, but at the price
of a looser security reduction via the forking lemma [67].

0

Speciﬁcally, conditioned on that the forging attacker A
successfully outputs σ0 = Ay0 X b+e0 y0
for the test-session
(that has no matching session for this case), which is as-
sumed to occur with non-negligible probability, with over-
whelming probability the attacker A has queried the ran-
dom oracle h( ˆA, A, ˆB, B, X0, Y0) to get e0. Then, the algo-
rithm C works as follows: C just rewinds the run of A to the
point that A just made the RO-query e0 = h( ˆA, A, ˆB, B, X0, Y0),
redeﬁnes the RO answer h( ˆA, A, ˆB, B, X0, Y0) to a new inde-
pendently random value e(cid:2)
0, and re-runs A from this rewind-
ing point. By the forking lemma [67], if the forging attacker
C outputs σ0 in the ﬁrst run with non-negligible probability,
in the repeated run C will get σ(cid:2)
with non-
negligible probability as well. Then, from (a, σ0, σ(cid:2)
0), the

b+e(cid:2)
0 = Ay0 X
0
0

y0

1123)−1

0

0)(e0−e(cid:2)

value CDH(X0, Y0) = (σ0/σ(cid:2)
can be computed.
Then, from a and CDH(X0, Y0), the value CDH(X0, B) =
σ0/(Y a
0 CDH(X0, Y0)e0 ) can be computed, which violates
the GDH assumption. Due to space limitation, the com-
plete proof is given in the full version [73].
(cid:2)
A note on security reduction tightness. By avoiding
the use of the forking lemma, the GDL- and SJKEA- based
security reduction of OAKE in Theorem 6.2 is as tight as
the GDH-based security reduction of KEA, which is in turn
much tighter than the GDH-based analysis of OAKE in The-
orem 6.2. On the other hand, the GDH-based security re-
duction of OAKE is still tighter than that of HMQV based
on GDH and SKEA. Speciﬁcally, the key-replication attack
is unconditionally ruled out with OAKE. By comparison, the
analysis of HMQV [51] for ruling out key-replication attack
is quite complicated, which is still reduced to the underly-
ing hardness assumptions.
In other parts of the analysis,
the security reduction of OAKE is at least as tight as that
of HMQV.
6.4 Security of T-OAKE in CK-Framework

The proofs of Theorem 6.1 and Theorem 6.2 can be di-
rectly extended to establish the SK-security of T-OAKE,
with the limitation that the values Ab+y’s or Ba+x’s are,
however, not allowed to be exposed in general. Details are
given in the full version [73] for space limitation.

Theorem 6.3. T-OAKE is SK-secure in the CK-framework

against any PPT strong adversary with the limitation that
the values Ab+y’s or Ba+x’s are not exposed, under the gap
DL assumption and the strong JKEA assumption, or the
GDH assumption, in the random oracle model.

The reason for this exposure limitation is as follows. For
the security against the forging attack for the case when the
test-session has no matching session, consider a session run
by ˆB with a peer player ˆZ of public key Z, where ˆZ may
be a corrupted one controlled by the forging attacker A .
Note that the simulator C does not know the secret key of
the uncorrupted player ˆB or the corrupted player ˆZ. In this
case, it is infeasible for C to compute the value Z b+y, even
though Y = gy for that session was generated by C itself.

We remark that the limitation of unexposed Ab+y’s or
Ba+x’s is only for provable security in the CK-framework.
We are unaware of any real security damage caused by the
leakage of such values in practice, compared to the secu-
rity damage or limitation caused by the leakage of the pre-
computed value sB = y + eb or sA = x + ea in (H)MQV.
Furthermore, in case of POP/POK of secret key during key
registration which assumes, in a sense, the attacker “knows”
the secret key z of Z = gz, the leakage of Z b+y actually cause
no real damage as the value Z b+y can actually be generated
by A itself.

On security with exposed session-states of the test-
session and the matching session. Let ( ˆA, ˆB, X0 =
gx0 , Y0 = gy0 ) be the test-session between a pair of uncor-
rupted players ˆA and ˆB. The gab-traceability of both T-
OAKE and (H)MQV, in turn, ensures the following security
property: even if both the DH-exponents x0 and y0 are ex-
posed, the session-key of the test-session remains unexposed.
Furthermore, for T-OAKE, even if both (x0, X0, Ba+x0 ) and
(y0, Y0, Ab+y0 ) are exposed (i.e., the session-states include all
the pre-computable values and are exposed), the session-key
of the test-session still remains unexposed. By comparison,

for (H)MQV, supposing the exposed session-state includes
the pre-computed value x0 + da or y0 + eb, the session-key
of the test-session will be exposed. In this sense, we suggest
that T-OAKE provide more robust secrecy leakage resilience
than (H)MQV does.
6.5 Security Beyond CK-Framework

In this section, we discuss some security properties beyond
the CK-framework, which further justify the design rationale
and performance advantages of the newly developed OAKE
protocol family.
6.5.1 Security in Public Computation Model
Kunz-Jacques and Pointcheval proposed a new attack sce-
nario for key-exchange protocols with public computations
[54], where it is convenient to split an entity (performing a
run of KE-protocol) into two parts: a trusted authentication
device, and an untrusted computing device. The authentica-
tion device enforces the conﬁdentiality of the authentication
data, while some computing operations required by the pro-
tocol are publicly carried out by the untrusted computing
device. This allows us to use an authentication device with
little computing power, and to make computing devices in-
dependent from users [54]. Cast in the trusted computing
setting, the authentication device corresponds to a trusted
platform module (TPM).

The work of Kunz-Jacques and Pointcheval [54] gives some
concrete applications that might be beneﬁted from public
computations. Mobile phones include smart cards which
store the user authentication data, where the handsets them-
selves are the computing devices. PCs (corresponding to
the computing device) equipped with a crypto token (cor-
responding to the authentication device) have a lot more
computing power than the token itself does, but may be
plagued by spyware or virus. For more details, the reader is
referred to [54].

(H)MQV with public computations. With the com-
putation of ˆB as an example (the same holds for ˆA), a nat-
ural split of authentication computation and public compu-
tation for (H)MQV is as follows [54]. The authentication
device generates (y, Y ), and forwards Y to the computation
device. After getting ( ˆA, X) from the computation device,
the authentication device computes sB = y + eb, and then
forwards sB to the computation device. On the other hand,
after getting sB from the authentication device, the compu-
tation device computes K ˆB = (XAd)sB and the session-key,
and then communicates with ˆA using the derived session-
key.

One key observation in [54] is: once the value sB is leaked
to an attacker who may compromise the computation device
that is assumed to be untrustful, the attacker can deﬁnitely
impersonate ˆB to ˆA in other sessions. Notice that, by only
compromising the computation device, the attacker does not
learn the DH-exponent y or the static secret key b. This
shows that (H)MQV is insecure in the public computation
model.

(T)OAKE with public computations. For applica-
tions in such a scenario, with the computation of ˆB as an ex-
ample (the similar holds for ˆA), the natural split of authen-
tication computation and public computation for (T)OAKE
is as follows. (1) The authentication device generates (y, Y ),
and possibly Af b+y if the authentication device has learnt
the peer identity ˆA, and then then forwards (Y, Af b+y) to the

1124computation device, where f = 0 for OAKE and f = 1 for
T-OAKE. (2) After getting X from the computation device,
the authentication device computes sB = b+ey and forwards
sB to the computation device. (3) After getting sB from
the authentication device, the computation device computes
K ˆB = Af b+yX sB and the session-key, and then communi-
cates with ˆA using the session-key. Note that (y, Y, Af b+y)
can be oﬄine pre-computed by the authentication device, and
the authentication device needs to online compute only ey
and sB. Also, the computation device essentially needs to
compute only one exponentiation X sB . That (T)OAKE well
supports the public computation model further eases the de-
ployment of (T)OAKE by low-power devices or by systems
embedded with TPM chips.

Note that, under the DLP assumption, the knowledge of
(Af b+y, sB) of a session of (T)OAKE, learnt by the adver-
sary by compromising the untrusted computation device,
is useless for the attacker to violate other sessions except
the matching session ( ˆB, ˆA, Y, X). Speciﬁcally, the value
sB = b + ey, where e = h( ˆA, A, ˆB, B, X, Y ), commits to the
whole session-tag. Thus, the value sB cannot be used by
the attacker to violate a non-matching session, unless it can
compute y from Ay (and thus b from sB) which is, however,
infeasible by the DLP assumption.

6.5.2 Exponent Dependent Attack, and Joint Proof-

of-Knowledge Session-Key Computation

An implicit rationale behind the design of authenticated
KE is: to successfully ﬁnish a session run, a player should
“know” both its static secret key and the ephemeral DH-
exponent. For IA-DHKE, we hope that the session-key com-
putation could itself serve as a joint proof-of-knowledge (JPOK)
of both the static secret key and the ephemeral DH-exponent.

The JKEA-based session-key derivation of the OAKE pro-
tocol family ensures such a JPOK property without requiring
POP/POK of secret key during public key registration. For
KEA and OPACITY, the ability of computing X b (resp.,
Ay) in session-key computation is used to demonstrate the
knowledge of the static secret key b (resp., the DH-exponent
y). However, such a JPOK mechanism in KEA/OPACITY
has some drawbacks; for example, the value Ay used by an
adversary for one session can be exposed from another (non-
matching) session. For (H)MQV, the basic idea is to use the
ability of computing (XAd)y+eb, with respect to the ran-
dom challenge XAd, to jointly demonstrate the knowledge
of both y and b.
In this work, we introduce an exponent
dependent attack (EDA) on (H)MQV, showing that a mali-
cious player can successfully set the session-key of (H)MQV
to be some publicly computable values.

Exponent dependent attack.

In a setting where a
value X ∈ G is given and the malicious player ˆA does not
necessarily know the discrete logarithm of X, ˆA computes d
and sets A = X −d−1 · gσ, where σ ∈ Zq and d = h(X, ˆB) for
HMQV or d = 2l +(X mod 2l) for MQV. Note that XAd =
X(X −d−1 ·gσ)d = XX −1gσd = gσd, and thus the shared DH-
secret now is K ˆA = (XAd)y+eb = gσdygσdeb = Y σdBσde.
Notice that the value K ˆA can be publicly computed with-
out involving the static secret key a or the DH-exponent x.
We refer to such an attack as exponent dependent attack
(EDA).

We remark that the above EDA attack does not violate
the security analysis of HMQV in [51], as it is beyond the
CK-framework. Nevertheless, for (H)MQV, the EDA attack
demonstrates the importance of mandating POP/POK of
secret key (during public key registration) in order to ensure
joint proof-of-knowledge session-key computation. POP/POK
of secret key is indeed mandated by MQV now, but was ex-
plicitly abandoned by HMQV in [51].

For space limitation, more security properties, including
security against reﬂection attack, key compromise imper-
sonation, unknown key share, and (weak) perfect forward
security, etc, most of which are beyond the CK-framework,
are presented in the full version [73].

7. FUTURE INVESTIGATIONS

We conclude this work by proposing some suggestions for

future investigations.

• One important direction for future research is to de-

velop IA-DHKE protocols that are as eﬃcient as (H)MQV
but provably secure in the absence of random oracles.
Toward this goal, we may rely upon some non-standard
yet still reasonable assumptions.

• We introduce and justify the JKEA assumption, and
demonstrate its usefulness with the design of the OAKE
protocol family. It is interesting to ﬁnd more crypto-
graphic applications of JKEA, as well as to come up
with more variants of JKEA.

• In this work, we mainly focus on the security analy-
sis of (T)OAKE in the basic CK-framework. Another
direction is to analyze (T)OAKE in more variants of
the CK-framework, e.g., analyze T-OAKE in the eCK-
model.

8. ACKNOWLEDGEMENT

We thank the anonymous referees for the detailed and
helpful comments. We are grateful to Colin Boyd, Liqun
Chen, Boru Gong, Hugo Krawczyk, Kouichi Sakurai, Dun-
can S. Wong, Moti Yung and Fangguo Zhang for many help-
ful discussions and suggestions.

9. REFERENCES
[1] M. Abdalla, J. H. An, M. Bellare, and

C. Namprempre. From identiﬁcation to signatures via
the Fiat-Shamir transform: Necessary and suﬃcient
conditions for security and forward-security. IEEE
Transactions on Information Theory, 54(8):3631–3646,
2008.

[2] M. Abe and S. Fehr. Perfect NIZK with adaptive

soundness. In TCC, pages 118–136, 2007.

[3] W. Aiello, S. M. Bellovin, M. Blaze, R. Canetti,

J. Ioannidis, A. D. Keromytis, and O. Reingold. Just
fast keying: Key agreement in a hostile internet. ACM
Trans. Inf. Syst. Secur., 7(2):242–273, 2004.

[4] ANSI. 504-1: Information technology-generic identity
command set, part 1: Card application command set.

[5] ANSI. American National Standard, X9.42-2001.
[6] B. Barak. How to go beyond the black-box simulation

barrier. In FOCS, pages 106–115, 2001.

[7] E. Barker, D. Johnson, and M. Smid. NIST special
publication 800-56A: Recommendation for pair-wise

1125key establishment schemes using discrete logarithm
cryptography (revised). Technical report, 2007.

authenticated key exchange protocol. In ACNS, pages
20–33, 2009.

[8] M. Bellare, R. Canetti, and H. Krawczyk. Keying hash

[27] I. Damg˚ard. Towards practical public key systems

functions for message authentication. In CRYPTO,
pages 1–15, 1996.

secure against chosen ciphertext attacks. In CRYPTO,
pages 445–456, 1991.

[9] M. Bellare and A. Palacio. The knowledge-of-exponent
assumptions and 3-round zero-knowledge protocols. In
CRYPTO, pages 273–289, 2004.

[28] I. Damg˚ard, S. Faust, and C. Hazay. Secure two-party
computation with low communication. In TCC, pages
54–74, 2012.

[10] M. Bellare and A. Palacio. Towards plaintext-aware

[29] A. W. Dent. The Cramer-Shoup encryption scheme is

public-key encryption without random oracles. In
ASIACRYPT, pages 48–62, 2004.

plaintext aware in the standard model. In
EUROCRYPT, pages 289–307, 2006.

[11] M. Bellare and P. Rogaway. Random oracles are

[30] T. Dierks and C. Allen. The TLS Protocol, Version

practical: A paradigm for designing eﬃcient protocols.
In ACM Conference on Computer and
Communications Security, pages 62–73, 1993.

[12] E. Biham and A. Shamir. Diﬀerential fault analysis of

secret key cryptosystems. In CRYPTO, pages
513–525, 1997.

[13] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer.

From extractable collision resistance to succinct
non-interactive arguments of knowledge, and back
again. In ITCS, pages 326–349, 2012.

[14] S. Blake-Wilson, D. Johnson, and A. Menezes. Key
agreement protocols and their security analysis. In
IMA Int. Conf., pages 30–45, 1997.

[15] C. Boyd, Y. Cliﬀ, J. M. G. Nieto, and K. G. Paterson.

Eﬃcient one-round key exchange in the standard
model. In ACISP, pages 69–83, 2008.

[16] C. Boyd, W. Mao, and K. G. Paterson. Deniable

authenticated key establishment for internet protocols.
In Security Protocols Workshop, pages 255–271, 2003.

[17] C. Boyd and A. Mathuria. Protocols for

Authentication and Key Establishment. ISBN
3-540-43107-1, Springer-Verlag.

[18] Z. Brakerski, Y. T. Kalai, J. Katz, and

V. Vaikuntanathan. Overcoming the hole in the
bucket: Public-key cryptography resilient to continual
memory leakage. In FOCS, pages 501–510, 2010.

[19] R. Canetti. Security and composition of cryptographic

protocols: a tutorial (part i). SIGACT News,
37(3):67–92, 2006.

[20] R. Canetti and R. R. Dakdouk. Extractable perfectly

one-way functions. In ICALP (2), pages 449–460,
2008.

[21] R. Canetti and R. R. Dakdouk. Towards a theory of
extractable functions. In TCC, pages 595–613, 2009.

[22] R. Canetti and H. Krawczyk. Analysis of key-exchange
protocols and their use for building secure channels. In
EUROCRYPT, pages 453–474, 2001.

[23] L. Chen and Y. Chen. The n-Diﬃe-Hellman problem

1.0. Request for Comments: 2246, January 1999.
[31] W. Diﬃe and M. E. Hellman. New directions in

cryptography. IEEE Transactions on Information
Theory, 22(6):644–654, 1976.

[32] W. Diﬃe, P. C. van Oorschot, and M. J. Wiener.

Authentication and authenticated key exchanges. Des.
Codes Cryptography, 2(2):107–125, 1992.

[33] V. S. Dimitrov, G. A. Jullien, and W. C. Miller.

Complexity and fast algorithms for
multiexponentiations. IEEE Trans. Computers,
49(2):141–147, 2000.

[34] Y. Dodis, J. Katz, A. Smith, and S. Walﬁsh.

Composability and on-line deniability of
authentication. In TCC, pages 146–162, 2009.
[35] A. Freier, P. Karlton, and P. Kocher. The SSL

Protocol, Version 3.0. INTERNET-DRAFT:
draft-freier-ssl-version3-02.txt, November 1996.

[36] R. Gennaro, H. Krawczyk, and T. Rabin.

Okamoto-Tanaka revisited: Fully authenticated
Diﬃe-Hellman with minimal overhead. In ACNS,
pages 309–328, 2010.

[37] S. Goldwasser, H. Lin, and A. Rubinstein. Delegation

of computation without rejection problem from
designated veriﬁer CS-proofs. IACR Cryptology ePrint
Archive, 2011:456, 2011.

[38] D. M. Gordon. A survey of fast exponentiation

methods. J. Algorithms, 27(1):129–146, 1998.
[39] J. Groth. Short pairing-based non-interactive

zero-knowledge arguments. In ASIACRYPT, pages
321–340, 2010.

[40] S. Hada and T. Tanaka. On the existence of 3-round

zero-knowledge protocols. In CRYPTO, pages
408–423, 1998.

[41] J. A. Halderman, S. D. Schoen, N. Heninger,

W. Clarkson, W. Paul, J. A. Calandrino, A. J.
Feldman, J. Appelbaum, and E. W. Felten. Lest we
remember: cold-boot attacks on encryption keys.
Commun. ACM, 52(5):91–98, 2009.

and its applications. In ISC, pages 119–134, 2011.

[42] S. Halevi and H. Krawczyk. One-pass HMQV and

[24] L. Chen and C. Kudla. Identity based authenticated

key agreement protocols from pairings. In CSFW,
pages 219–233, 2003.

[25] C. Cremers. Examining indistinguishability-based

security models for key exchange protocols: the case of
CK, CK-HMQV, and eCK. In ASIACCS, pages 80–91,
2011.

[26] C. J. F. Cremers. Session-state reveal is stronger than

asymmetric key-wrapping. In Public Key
Cryptography, pages 317–334, 2011.

[43] D. Harkins and D. Carreal. Internet Key Exchange

(IKE). RFC 2049, The Internet Engineering Task
Force, November 1998.

[44] K. Hickman. The SSL Protocol. Online document:

www.netscape.com/eng/security/SSL-2.html,
Feburary 1995.

ephemeral key reveal: Attacking the NAXOS

[45] IEEE. 1363-2000: Standard speciﬁcations for public

key cryptography.

1126[46] ISO/IEC. 11770-3:2008 information technology -

security techniques - key management - part 3:
Mechanisms using asymmetric techniques.

[47] ISO/IEC. 24727-6:2010 identiﬁcation cards -

integrated circuit card programming interfaces - part
6: Registration authority procedures for the
authentication protocols for interoperability.

[66] T. Okamoto and D. Pointcheval. The gap-problems: A
new class of problems for the security of cryptographic
schemes. In Public Key Cryptography, pages 104–118,
2001.

[67] D. Pointcheval and J. Stern. Security arguments for

digital signatures and blind signatures. J. Cryptology,
13(3):361–396, 2000.

[48] B. S. Kaliski. An unknown key-share attack on the

[68] M. D. Raimondo and R. Gennaro. New approaches for

MQV key agreement protocol. ACM Trans. Inf. Syst.
Secur., 4(3):275–288, 2001.

[49] C. Kaufman. Internet Key Exchange (IKEv2)

Protocol. The Internet Engineering Task Force:
INTERNET-DRAFT, October 2002.

[50] H. Krawczyk. SIGMA: The ’sign-and-mac’ approach

to authenticated Diﬃe-Hellman and its use in the
IKE-protocols. In CRYPTO, pages 400–425, 2003.
[51] H. Krawczyk. HMQV: A high-performance secure

Diﬃe-Hellman protocol. In CRYPTO, pages 546–566,
2005.

[52] H. Krawczyk, K. G. Paterson, and H. Wee. On the

security of the TLS protocol: A systematic analysis.
IACR Cryptology ePrint Archive, 2013:339, 2013.

[53] C. Kudla and K. G. Paterson. Modular security proofs

for key agreement protocols. In ASIACRYPT, pages
549–565, 2005.

[54] S. Kunz-Jacques and D. Pointcheval. A new key

exchange protocol based on MQV assuming public
computations. In SCN, pages 186–200, 2006.

[55] B. A. LaMacchia, K. Lauter, and A. Mityagin.

Stronger security of authenticated key exchange. In
ProvSec, pages 1–16, 2007.

[56] K. Lauter and A. Mityagin. Security analysis of KEA

authenticated key exchange protocol. In Public Key
Cryptography, pages 378–394, 2006.

[57] A. B. Lewko, Y. Rouselakis, and B. Waters. Achieving

leakage resilience through dual system encryption. In
TCC, pages 70–88, 2011.

[58] T. Matsumoto, Y. Takashima, and H. Imai. On

seeking smart public-key distribution systems. Trans.
IECE of Japan, E69(2):99–106, 1986.

[59] A. Menezes, M. Qu, and S. Vanstone. Some new key

agreement protocols providing mutual implicit
authentication. In SAC, pages 70–88, 1995.

[60] A. Menezes and B. Ustaoglu. On the importance of
public-key validation in the MQV and HMQV key
agreement protocols. In INDOCRYPT, pages 133–147,
2006.

[61] A. Menezes, P. C. van Oorschot, and S. A. Vanstone.
Handbook of Applied Cryptography. CRC Press, 1996.
[62] T. Mie. Polylogarithmic two-round argument systems.

J. Mathematical Cryptology, 2(4):343–363, 2008.

[63] NIST. Special publication 800-56 (DRAFT):

Recommendation on key establishment schemes, Draft
2, January 2003.

[64] NIST. SP 800-56 (DRAFT): Special publication

800-56, recommendation for pair-wise key
establishment schemes using discrete logarithm
cryptography, July 2005.

[65] NIST. SKIPJACK and KEA algorithm speciﬁcations.
http://csrc.nist.org/encryption/skipjack/skipjack.pdf,
1998.

deniable authentication. In ACM Conference on
Computer and Communications Security, pages
112–121, 2005.

[69] M. D. Raimondo, R. Gennaro, and H. Krawczyk.

Deniable authentication and key exchange. In ACM
Conference on Computer and Communications
Security, pages 400–409, 2006.

[70] E. Saint, D. Fedronic, and S. Liu. Open Protocol for

Access Control Identiﬁcation and Ticketing with
Privacy. Smart Card Alliance, July 2011.
http://www.smartcardalliance.org/resources/pdf/
OPACITY Protocol 3.7.pdf.

[71] J. Stasak. NSAs Elliptic Curve Licensing Agreement.

The IETF’s Security Area Advisory Group, 2004.
[72] A. C.-C. Yao and Y. Zhao. Deniable internet key

exchange. In ACNS, pages 329–348, 2010.

[73] A. C.-C. Yao and Y. Zhao. A new family of practical

non-malleable protocols. IACR Cryptology ePrint
Archive, 2011:35, 2011.

APPENDIX
A. MORE VARIANTS OF OAKE

Adding (explicit) mutual authentication. In order
to add mutual authentication to OAKE, besides the session-
key K we also need a MAC-key Km to be used within the
protocol run (but erased after the protocol run). Both the
session-key and the MAC-key are derived from the shared
DH-secret K ˆA = K ˆB, and are independent in the random
oracle model. For OAKE with mutual authentication, ˆB
sends an additional value tB = M ACKm (1) in the second-
round, and ˆA sends tA = M ACKm (0) in an additional third-
round.

OAKE with embedded subgroup tests. Let t be
the cofactor, for OAKE with embedded subgroup test, the
shared DH-secret is set to be: K ˆA = BxtY at+ext and K ˆB =
AytX bt+eyt. The subgroup test is performed as follows: each
player ﬁrst veriﬁes that its peer’s DH-component is in G(cid:2),
and then acts in accordance with one of the following two
modes.
Mode-1. If Bxt and Y at+ext (resp., Ayt and X bt+eyt) are
computed separately, particularly when Bxt (resp., Ayt)
is oﬄine pre-computed by ˆA (resp., ˆB), ˆA (resp., ˆB)
checks that Y at+ext (cid:8)= 1G (resp., X bt+eyt (cid:8)= 1G).

Mode-2. In case of no separate computation, ˆA (resp., ˆB)
veriﬁes K ˆA (cid:8)= 1G (resp., K ˆB (cid:8)= 1G). Note that the
checking of K ˆA (cid:8)= 1G and K ˆB (cid:8)= 1G, as done in MQV,
does not fully guarantee X t (cid:8)= 1G or Y t (cid:8)= 1G, but it
still provides reasonable assurance in the elliptic curve
setting.

We remark that the embedded subgroup test in Mode-1, well
supported by OAKE, provides stronger security guarantee
than that in Mode-2. Note that (H)MQV cannot oﬄine

1127pre-compute the values Be and Ad to ease the more robust
Mode-1 embedded subgroup test.

A note on subgroup test. We note that, as HMQV, the
subgroup test of peer’s DH-component can be waived (but
still with the supergroup G(cid:2) membership check), if no DH
exponent or component is pre-computed and thus leaked. In
particular, in this case, the black-box analysis of OAKE does
not rely upon such a test. The underlying reason is that,
even if an adversary learns some partial information about
b + ey by issuing a small subgroup attack against the honest
ˆB (by setting X to be in a small subgroup), it still can-
not derive the value b without compromising the ephemeral
value y. Actually, as the DH-exponent y is independent at
random in each session and is assumed not to be leaked in
this case, the adversary even cannot derive the full value of
b + ey by small subgroup attacks.

A note on session-key derivation. In the description
of OAKE in Figure 1, the session-key is set to be HK(K ˆA) =
HK (K ˆB), where the key derivation function HK is modeled
as a random oracle in security analysis. In reality, we can
use a PRF, e.g., HMAC [8], to derive the session-key; for
example, the session-key is derived as P RFS( ˆA, ˆB, X, Y ),
where S is the randomness seed that is derived from (or,
just to be) the intermediate secrecy K ˆA = K ˆB.
B. DISCUSSION ON ECK AND NAXOS

The extended CK model, namely eCK-model in short, was
proposed in [55] as a variant of the CK-framework. The key
diﬀerence between eCK and CK lies in that, in the eCK-
model, the session-states of both the test-session and the
matching session can be exposed. Let’s ﬁrst review the
NAXOS protocol proposed in [55] that is shown to be eCK-
secure.

q . Let h : {0, 1}∗ → Z∗

Let (a, x(cid:2)) (resp., (b, y(cid:2))) be the static and ephemeral se-
cret keys of player ˆA (resp., ˆB) of public key A = ga (resp.,
B = gb), where a, b, x(cid:2), y(cid:2) ← Z∗
q be
a cryptographic hash function. Player ˆA (resp., ˆB) sends
X = gx (resp., Y = gy), where x = h(a, x(cid:2)) and y = h(b, y(cid:2)).
Then, the session-key is derived as follows. Player ˆB com-
putes K = HK (Ay, X b, X y, ˆA, ˆB), and ˆA computes K =
HK (Y a, Bx, Y x, ˆA, ˆB). Notice that the session-key compu-
tation of ˆA and that of ˆB are not symmetric.

Some brief observations and remarks on NAXOS:
• The key trick of NAXOS is that, though the actually
used DH-exponents and DH-components are (x, X) and
(y, Y ) respectively, but for security proof of NAXOS
in eCK, only the values x(cid:2) and y(cid:2) are speciﬁed as the
session-states that are assumed to be exposed. This
is also a common trick to transform most KE proto-
cols secure in the traditional CK-framework into pro-
tocols secure in the eCK-model. However, the naturally
pre-computable values (x, X, Bx) and (y, Y, Ay) are not
speciﬁed to be included in session-states, and are as-
sumed to be unexposed or not to be pre-computed.
In a sense, the security of NAXOS in eCK comes at the
price of losing oﬄine pre-computability. Notice that,
supposing x and y are pre-computed and allowed to
be exposed as in the traditional CK-framework, the
leakage of both x and y will expose the session-key of
NAXOS, and consequently NAXOS is actually insecure
in the eCK-model in this case. In other words, the eCK-
security of NAXOS depends upon what are speciﬁed in
session-states.

• The trick of NAXOS, i.e., setting x = h(a, x(cid:2)) and y =
h(b, y(cid:2)), involves more uses of the static secret keys,
which may cause weak protection of static secret keys
in reality.
In addition, as mentioned, the session-key
computation of ˆA and that of ˆB are not symmetric.

• It is easy to see that, under the DLP assumption, NAXOS

cannot be HP-deniable according to our HP-deniability
deﬁnition.
In particular, given the exposed session-
state x(cid:2), we even do not know how to eﬃciently and
statistically simulate X = gh(a,x(cid:2)) or Bx = gbh(a,x(cid:2))
without knowing the secret key a.

Finally, we would also like to remind the reader of some
existing critiques on the eCK-model (see, e.g., [15, 26, 25]).
On the one hand, the CK-security and eCK-security are
incomparable in general. On the other hand, the security
requirements by eCK actually cause the eCK-model less ap-
plicable than the traditional CK-framework. In particular,
any DHKE, where the session-key can be derived from the
DH-exponents that are speciﬁed as the session-states (e.g.,
IKE [49] and SIGMA [50], STS [32], SSL [35] and TLS [30],
and JFK [3] and much more), cannot be proven secure in
the eCK-model.

1128