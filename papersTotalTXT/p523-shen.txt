Fast Two-Party Secure Computation with

Minimal Assumptions

[Extended Abstract]

∗

abhi shelat

University of Virginia
85 Engineer’s Way

Charlottesville, Virginia, U.S.A

.

abhi@virginia.edu

Chih-hao Shen
University of Virginia
85 Engineer’s Way

Charlottesville, Virginia, U.S.A

.

shench@virginia.edu

ABSTRACT
Almost all existing protocols for secure two-party computa-
tion require a speciﬁc hardness assumption, such as DDH,
discrete logarithm, or a random oracle, even after assum-
ing oracle access to the oblivious transfer functionality for
their correctness and/or eﬃciency. We propose and imple-
ment a Yao-based protocol that is secure against malicious
adversaries and enjoys the following beneﬁts:

1. it requires the minimal hardness assumption, i.e., OTs;

2. it uses 10 rounds of communication plus OT rounds;

3. it has the optimal overhead complexity (for an approach
that uses the circuit-level cut-and-choose technique); and

4. it is embarrassingly parallelizable in the sense that each
circuit can be processed in a pipelined manner, and all
circuits can be processed in parallel.

To achieve these properties, we describe novel solutions for
the three main obstacles for achieving security against mali-
cious adversaries in a cut-and-choose garbled-circuit proto-
col. We propose an eﬃcient proof to establish the genera-
tor’s output authenticity; we suggest the use of an auxiliary
circuit that computes a hash to ensure the generator’s input
consistency; and we advance the performance of Pinkas and
Lindell’s state-of-the-art approach for handling the selective
failure attack.

Not only does our protocol require weaker cryptographic
assumptions, but our implementation of this protocol also
demonstrates a several factor improvement over the best
prior work which relies on speciﬁc number-theoretic assump-
tions. Thus, we show that performance does not require
speciﬁc algebraic assumptions.

∗A full version is at http://eprint.iacr.org/2013/196.

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’13, November 4–8, 2013, Berlin, Germany.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-2477-9/13/11 ...$15.00.
http://dx.doi.org/10.1145/2508859.2516698.

Categories and Subject Descriptors
F.0 [Theory of Computation]: General

Keywords
The Yao protocol, Malicious Model, Cut-and-Choose

1.

INTRODUCTION

Secure Two-Party Computation (2PC) aims to allow two
parties to collaborate in a way that achieves maximal pri-
vacy of their inputs with simultaneous guarantees of correct-
ness of outputs. The correctness property guarantees that
when both parties follow the protocol honestly, the protocol
output is indeed the output of the objective function. The
privacy property ensures that during the protocol execution,
neither party can learn more than that derivable from her
own input and output.

The ﬁrst generic solution for Secure 2PC in the honest-but-
curious model was proposed by Yao [26]. In this protocol,
both parties agree on an objective function and its boolean
circuit format (called the objective circuit) in advance1. One
party (denoted by Gen) constructs a garbled version of this
objective circuit, and the other party (denoted by Eval)
obliviously evaluates this garbled circuit to compute an out-
put. By oblivious evaluation we mean that Eval does not
learn any intermediate value of the computation. This pro-
tocol satisﬁes the two security properties if both participants
follow the protocol instructions honestly.

This basic protocol must be hardened to handle the sit-
uation in which either party arbitrarily deviates from the
given instructions, e.g. by constructing a faulty circuit that
purposely reveals Eval’s private input.

The circuit-level cut-and-choose technique is one of the

most eﬃcient methods that enforce honest circuit garbling [11,
15, 16, 19, 23]. This technique instructs Gen to prepare mul-
tiple copies of the garbled circuit, each with independent
randomness, and instructs Eval then to randomly pick a
fraction of the circuits whose randomness is later revealed.
If any of the chosen circuits (called the check circuits) is
not consistent with the revealed randomness, Eval aborts
and Gen is caught cheating; otherwise, Eval starts to eval-
uate the remaining circuits (called the evaluation circuits)
as instructed in the Yao protocol. Finally, Eval takes the
majority of the evaluation outputs as the ﬁnal output. As
1The equivalence between the objective function and the
objective circuit is out of the scope of this paper.

523a result, a malicious Gen constructs either too many faulty
circuits and gets caught, or only a few and does not inﬂuence
the ﬁnal output at all. This approach is eﬃcient because it
can naturally be run in parallel.

Besides the threat of faulty circuits, there remain three
other subtle but equally critical security issues that need to
be addressed when dealing with malicious adversaries. The
ﬁrst two in fact result from the use of multiple garbled cir-
cuits (as instructed by the circuit-level cut-and-choose tech-
nique): two-output function handling and Gen’s input con-
sistency. The third issue is also known as the selective failure
attack. Prior solution to these three concerns either requires
speciﬁc hardness assumptions or introduces large overheads
in communication and computation.

1.1 Contributions

Our main contribution is to construct an optimal proto-
col in the circuit-level cut-and-choose-based category such
that (1) it requires minimal hardness assumptions, namely,
an oblivious transfer (OT) secure in the presence of mali-
cious adversaries; (2) it introduces little computational and
communicational overhead to solve the above three security
issues. In particular, its complexity is linear (in terms of the
security parameter) in the original Yao protocol, which is the
best a circuit-level cut-and-choose-based solution could ever
achieve.
In other words, we show that malicious security
comes almost for free both in terms of required hardness as-
sumptions and various protocol performance metrics. Let n
denote the input/output size, k denote the security param-
eter, and σ denote the number of garbled circuits needed2.
The contributions of this work are as follows:

1. We propose a novel witness-indistinguishable proof to
ensure Gen’s output authenticity. This proof requires
only standard primitives (a symmetric encryption scheme
and commitment scheme to be precise) and incurs about
the same amount of overhead as garbling and evaluat-
ing Gen’s output gates. In other words, it requires only
O(σn) symmetric operations; prior approaches require
O(σ2n) symmetric operations [15, 22] or O(σn) symmet-
ric operations plus O(σ) algebraic operations [11].

2. We suggest the use of an auxiliary circuit to achieve Gen’s
input consistency. This auxiliary circuit computes the
(universal) hash of Gen’s input. By utilizing an XOR-
homomorphic hash, we are able to evaluate the auxiliary
circuit almost for free. Our solution is much more eﬃ-
cient than the prior works which need O(σ2n) symmetric
operations [15, 18] or O(σn) algebraic operations [23].

3. Most importantly, the above two techniques allow us to
handle issues of two-output functions and Gen’s input
consistency while entirely avoiding algebraic operations,
except for those needed by OTs. Lindell and Pinkas’ [15]
and Woodruﬀ’s [25] approaches are the only prior works,
to the best of our knowledge, that enjoy this property.
Nevertheless, our approach works in a more eﬃcient man-
ner as shown in Table 1.

4. Lindell and Pinkas suggested the use of a k-probe-resistant
matrix (cf. Deﬁnition 5) to defend against the selective
failure attack [15]. This solution has little overhead while

2Typically, the number of garbled circuits needed is linear
to the security parameter, that is, σ = O(k).

combining with the free-XOR technique. However,
it
increases the number of OTs needed at the same time.
While XOR gates can be computed almost for free, the
OTs can not. While there exist extension techniques for
OTs, not all variants of OTs can be eﬃciently extended.
We therefore design a probabilistic algorithm based on
Reed-Solomon code such that the number of OTs needed
can be as low as 25% of that in the original Lindell and
Pinkas’ solution.

5. We propose an optimization technique that can save com-
munication overhead by up to 60% (when 60% of all the
garbled circuits are check circuits) with the price of a
slight increase of computation overhead. We stress that
our technique compares favorably with the Random Seed
Checking technique [14]. In particular, our approach is
compatible with the pipelining technique [8].

6. Based on an open-source system [14], we experimentally
verify our theories by developing some of the above tech-
niques. The integrated system can process 650,000+ gates
per second on Stampede [24]. This is the fastest mali-
ciously secure 2PC system reported.

1.2 Related Work

Prior work on converting the Yao protocol into a mali-
ciously secure one based on the cut-and-choose technique [11,
14–16, 18, 22, 23, 25] reports several completely diﬀerent ap-
proaches. Jarecki and Shmatikov suggested an approach
that needs only a single copy of the garbled circuit, but this
approach requires expensive zero-knowledge proof of cor-
rectness for every single gate [10] that also rely on speciﬁc
RSA-based hardness assumptions. Nielson et al. reported
a solution that uses eﬃcient OTs to generate a pool of au-
thenticated primitives [21]. With these primitives, both par-
ties are able to securely evaluate a boolean circuit based on
the generic Goldreich, Micali, and Wigderson protocol [5].
However, this protocol requires interactive communication
for every AND gate, and therefore the number of rounds of
communication depends on the circuit. While suitable for
small circuits, large complicated circuits will require thou-
sands of back-and-forth messages. Damg˚ard et al. proposed
a solution that uses somewhat homomorphic encryption to
precompute a bunch of triples that are later used to securely
compute an arithmetic circuit [1].

Among other approaches in the cut-and-choose-based cat-
egory, our approach demonstrates superior performance in
terms of the number of symmetric or algebraic operations
needed, as shown in Table 1. Note that by “in the cut-and-
choose-based category,” we mean that the number of the gar-
bled circuits needed is linear to the security parameter. So
there is a hidden cost of O(kC) of symmetric cryptographic
operations in all these approaches, where C is circuit size.
More details about Table 1 will be given in Section 3.

Our approach is also as competitive as any other in terms
of computation complexity, round complexity, and the com-
putation assumptions needed, as shown in Table 2. While
Jarecki and Shmatikov’s approach requires hundreds of ex-
pensive algebraic operations per gate, ours does not need
any (given oracle access to OTs) [10]. Although Neilson et
al.’s approach favorably compares to our approach in terms
of computation complexity, ours requires constant communi-
cation rounds while theirs needs rounds linear to the circuit
depth [21]. At last, since Damg˚ard et al.’s approach works

524Gen. Input Consist.

Gen. Output Auth.

Symm. Op. Alge. Op. Symm. Op. Alge. Op.

Assumptions
(besides OT)

[15]

[11]

[16]

[23]

[14]

This Work

O(k2n)
O(k2n)

O(kn)

O(kn)

O(kn)

O(kn)

O(kn)

O(kn)

O(kn)

O(k2n)

O(kn)

OWF

O(k)

Discrete Log.

not mentioned

Decisional Diﬃe-Hellman

O(kn)

O(kn)

O(kn)

O(kn)

O(k)

Discrete Log.

Discrete Log.

OWF

Table 1: Complexity of various circuit-level cut-and-choose-based approaches in terms of symmetric (or algebraic) operations.

with arithmetic circuits, it is incomparable to our work and
thus omitted in the table [1]

Symm. Op. Alge. Op. Rounds Assumptions

O(C)

O(C)

O( k

lg C C)

O( k

lg C C)

O( k

lg C C)

O( k

lg C C)

O(kC)

O(1)

O(1)

DCR + RSA

Discrete Log

O(Df )

Random Oracle

O(1)

Random Oracle

O(1)

OWF

[10]

[20]

[21]

[2]

This
work

Table 2: Overall complexity comparison with prior works, where
C is the circuit size and Df is the circuit depth.

We recently noticed an independent work by Mohassel and
Riva that also proposes an optimal Yao-based protocol [19].
Their protocol indeed shares the same asymptotic complex-
ity as ours and also relies on minimal assumptions. The
protocols for ensuring Gen’s output authenticity in both
works are essentially the same. Both protocols capture the
idea that Eval provides a unique random key corresponding
to each of Gen’s output wires as the proof of authenticity.
However, our approach favorably compares to theirs for

two reasons:

First, for each of Gen’s output wires in each of the garbled
circuits, Mahassel and Riva’s protocol requires two possible
random keys, which correspond to 0 or 1, to be encrypted
and exchanged, whereas our protocol only needs the one
that corresponds to Gen’s output value to be encrypted
and exchanged.
In other words, although both solutions
need O(σn) symmetric cryptographic operations, ours has a
smaller constant factor.

Second, their approach for checking Gen’s input consis-
tency uses a diﬀerent instance of circuit garbling, in which
Gen’s and Eval’s roles are reversed. Hence, their solution
requires O(n) extra instances of OTs in which the roles are
reversed, which is arguably more expensive than the extra
O(nk) cryptographic symmetric operations in our solution.
Paper Organization: We give background and nota-
tions in Section 2, show how the three attacks are handled
by cryptographic primitives in Section 3, and provide a de-
tailed description of our main protocol in Section 4. Finally,
experimental results are reported in Section 5.

2. PRELIMINARIES

We denote by f (x, y) 7→ (f1(x, y), f2(x, y)) a two-output
objective function, where Gen with input x gets output

f1(x, y) and Eval with input y gets output f2(x, y). For
simplicity, f1(x, y) and f2(x, y) are often noted as f1 and f2,
respectively. We use f1 = ⊥ or f2 = ⊥ to indicate that either
Gen or Eval gets no output. We denote by com(x; r) the
commitment to message x with randomness r. The random-
ness may be omitted for simplicity. We denote by ence(x)
the encryption of message x under encryption key e and by
decd(c) the decryption of ciphertext c under decryption key
d. Additionally, we denote by x||y or sometimes (x, y) the
concatenation of x and y, and by [n] the set {1, 2, . . . , n} for
some n ∈ N. We also use the notation that x(j)’s superscript
implies that this variable is related to the j-th circuit.

For the rest of this paper, we denote by k the security
parameter, by σ the number of copies of the garbled circuit
needed (also known as the statistical security parameter),
and by n the size of a participant’s input and output.

3. MALICIOUS SECURITY

Our protocols achieve security against malicious adver-
saries according to the standard ideal-real paradigm for deﬁn-
ing security. In the full version of this paper, we present the
standard deﬁnition of ideal-real security and prove that our
protocols achieve this notion using proof techniques already
highlighted in [15] and [23]. In this abstract, we focus on
a high-level discussion of our contributions—namely, how
we solve the three security issues faced by the protocol that
transforms the Yao protocol into one that is secure in the
malicious model via the cut-and-choose technique.

3.1 Two-Output Function Handling

For many real-world applications, both parties want to
learn an output from the secure computation. Since Eval al-
ways learns its output, the challenge is for Gen to learn hers
securely.
In particular, a solution needs to achieve Gen’s
output privacy and output authenticity. The former requires
that Eval does not learn Gen’s output, and the latter re-
quires that Gen gets either an authentic output or no output
at all, in which case Eval is caught cheating. We stress that
the two-output protocols we consider are not fair, that is,
Eval may learn its own output but refuse to send Gen’s
back—but if so, Eval is caught cheating.

Goldreich suggested the use of an auxiliary circuit that
encrypts Gen’s output and computes the digital signature
of the resulting ciphertext so that a malicious Eval could
neither learn Gen’s output from the ciphertext nor forge an
arbitrary signature [4]. Later, Lindell and Pinkas proposed
an approach that uses one-time-pad encryption and one-time
MAC circuits instead, which incurs O(kn) extra gates per
circuit [15]. Kiraz presented a two-party protocol in which a

525zero-knowledge proof of size O(σ) is executed at the end [11].
shelat and Shen reported a signature-based solution that
adds O(n) gates to each circuit, and requires a WI proof of
size O(σ + n) [23] under speciﬁc complexity assumptions.

Our approach solves Gen’s output privacy problem with
a one-time-pad encryption circuit, which requires only O(n)
extra XOR-gates per circuit. The novel part of our approach
is that we tackle the output authenticity problem in a way
that uses only O(n) symmetric operations per circuit and
no algebraic operations at all (hence no number-theoretic
intractability assumption is needed). Our idea comes from
the following three observations.

We ﬁrst observe that the random keys retrieved from eval-
uating Gen’s output gates can in fact serve as “message au-
thentication codes” suﬃcient for Eval to prove Gen’s out-
put authenticity [3]. Recall that the Yao protocol ensures
that Eval learns exactly one of the two random keys as-
signed to each wire. So the knowledge of the retrieved ran-
dom key corresponding to Gen’s output wire is more than
enough for Eval to show the output authenticity. What
remains is how Eval demonstrates this knowledge without
revealing the index of the garbled circuit from which Eval
retrieves the random key. This index has been shown to be
exploitable in breaching Eval’s input privacy [11].

The second observation we have, which is also pointed out
in shelat and Shen’s work [23], is that a WI proof suﬃces
the purposes here. Let us consider the case in which Gen
(plays as the veriﬁer) has private input U = {u(j)}j∈[s] for
some s ∈ N, and Eval (plays as the prover) knows u(m) for
some m ∈ [s]. In the honest-but-curious model, a simple WI
proof of Eval’s knowledge u(m) can be done as follows:

1. Gen picks random nonce r, and sends Eval {encu(r)}u∈U .

2. Eval receives C = {c(j)}j∈[s] and returns dec

u(m) (c(m)).

3. Gen receives r′ and accepts if r′ = r, or aborts otherwise.

This proof is sound because an Eval with no knowledge of
any u(m) ∈ U can only guess r with negligible probability.
However, this proof is not WI in the malicious model. In
fact, a malicious Gen may pick distinct r(j)s and send Eval

(enc

u(1) (r(1)), enc

u(2) (r(2)), . . . , enc

u(s) (r(s)))

so that u(m) can later be deduced by locating r′ in {r(j)}j∈[s].
To force Gen to behave honestly in Step 1, we suggest that
Gen discloses (U, r) after receiving r′ so that Eval could
check if C is constructed correctly. Our third observation is
that this disclosure does not compromise Gen’s input pri-
vacy. Indeed, Eval should have already learned the majority
of U from the circuit evaluation, and r is a random nonce
that has no information about Gen’s input at all. So Gen’s
input is not leaked through (U, r). Moreover, this disclosure
does not compromise the soundness of the protocol since
after Gen receives r′, Eval has already delivered its proof
of authenticity so that learning (U, r) afterwards will not
change the proof retroactively. Nonetheless, we stress that
Gen should not learn r′ before Eval ﬁnishes the check, and
nor should Eval be able to change r′ after the check. This
property suggests the use of a commitment scheme. Our
u(m) (c(m)) instead of giv-
idea is that Eval commits to dec
ing it away in clear. After Gen reveals (U, r), Eval checks
if C is indeed correctly generated. If the check fails, Eval

aborts; otherwise, Eval decommits to r′. Then Gen checks
if r′ = r and responds as in the honest-but-curious protocol.
One more issue is that a malicious Gen could learn Eval’s
private input u(m) with non-negligible probability by faking
its private inputs from the beginning. More speciﬁcally, a
malicious Gen could guess u(m) with probability 1/s and
then pretend that its private input is

¯U = (¯u(1), . . . , ¯u(m−1), u(m), ¯u(m+1), . . . , ¯u(s))

instead of U , where ¯u(j) is randomly picked. With this at-
tack, a malicious Gen is capable of providing checkable ci-
phertexts C when Eval’s private input is indeed u(m). In
particular, the fact that Eval can provide the correct nonce
r conﬁrms that its private input is indeed u(m). A straight-
forward way to get around this issue is for the two parties to
share the commitments to Gen’s private inputs in the ﬁrst
place. By the binding property of the commitment scheme,
a malicious Gen cannot change its private inputs at will.
The correctness of these commitments will be guaranteed
by the circuit-level cut-and-choose technique.

The complete description of our Gen’s output authentic-
ity protocol is presented in Figure 1, and the security of this
protocol is stated in Lemma 1.

Common Input: security parameter 1k, statistical secu-
rity parameter 1s, commitments to Gen’s private in-
put {(com(u(j)

0 ), com(u(j)
Private Input: Gen has {(u(j)

1 ))}j∈[s], and bit b.
0 , u(j)

1 )}j∈[s] and Eval has
random key v corresponding to Gen’s output wire of
value b in the m-th garbled circuit for some m ∈ [s].

1. Gen picks random nounce r ∈ {0, 1}k and sends Eval

{encu(r)}u∈U , where U = {u(j)

b }j∈[s].

2. Eval gets {c(j)}j∈[s] and sends Gen com(decv(c(m))).
3. After getting com(r′), Gen decommits to U .
4. Eval checks the decommitted values {u(j)}j∈[s] that

(a) if com(u(j)

b ) is correctly opened to u(j) for all j?

(b) if dec

u(j) (c(j))

?
= dec

u(s) (c(s)) for all j ∈ [s − 1]?

Eval aborts if any of the checks fails; otherwise, it de-
commits to r′.

5. Gen accepts the proof if com(r′) is correctly opened and

r′ = r; otherwise, it rejects.

Figure 1: A WI proof for Gen’s output authenticity with mali-
cious security (where Eval plays the role of the prover)

0 , u(j)

Lemma 1. Let {(u(j)

1 )}j∈[s] be Gen’s private input,
and let commitments {(com(u(j)
0 ), com(u(j)
1 ))}j∈[s] and bit b
be the common inputs. If all u(j)
b s are uniformly distributed
over {0, 1}k, then the protocol presented in Figure 1 satisﬁes
the following properties:

1. (Completeness) If Eval knows u(j)

for some j ∈ [s],

b

Gen always accepts.

2. (Soundness) If Eval does not know any of u(j)

b s, Gen

rejects with probability at least 1 − 2−k.

5263. (Witness-indistinguishability) Let VIEWv denote the
view of Gen from running the protocol with Eval using
input v. If Eval knows any V of {u(j)
b }j∈[s], then for
any v1, v2 ∈ V , {VIEWv1 }k∈N and {VIEWv2 }k∈N are
computationally indistinguishable.

3.2 Generator’s Input Consistency

In the cut-and-choose technique, multiple copies of the
garbled circuit are constructed and then either checked or
evaluated. It is conceivable that a malicious Gen may pro-
vide inconsistent inputs to diﬀerent evaluation circuits. Lin-
dell and Pinkas showed that for some functions, it is not
diﬃcult for a malicious Gen to use inconsistent inputs to
extract information of Eval’s input [15]. For instance, sup-
pose both parties agree upon the objective function

f ((a1, a2, a3), (b1, b2, b3)) 7→ (a1b1 ⊕ a2b2 ⊕ a3b3, ⊥),

where ai and bi is Gen’s and Eval’s i-th input bit, re-
spectively.
Instead of providing (a1, a2, a3) consistently, a
malicious Gen may send (1, 0, 0), (0, 1, 0), and (0, 0, 1) to
diﬀerent evaluation circuits. In the end, Gen learns the ma-
jority bit of Eval’s input, which is the extra information
that Eval did not agree to reveal.

Several approaches have been proposed to defend this at-
tack. Mohassel and Franklin proposed the equality-checker
technique, which requires O(σ2n) commitments to be com-
puted and exchanged [18]. Lindell and Pinkas developed
an approach that also requires O(σ2n) commitments [15].
Later, they realized that O(σ2n) commitments are too much
of the communication overhead, and then further suggested
a pseudo-random synthesizer that relies on eﬃcient zero-
knowledge proofs under speciﬁc hardness assumptions and
requires O(σn) algebraic operations [16]. shelat and Shen
proposed the use of malleable claw-free collections, which
also uses O(σn) algebraic operations, but they showed that
the witness-indistinguishability is suﬃcient [23]. Our ap-
proach gets the best of the both worlds, i.e., it requires only
O(σn) symmetric cryptographic operations.

We tackle this issue with an auxiliary circuit, in addition
to the objective circuit, that computes a function of Gen’s
input. At a high level, the circuit-level cut-and-choose tech-
nique ensures the correctness of this auxiliary circuit, and
its output is used to ensure Gen’s input consistency. In par-
ticular, for this idea to work, we need to endow the output
of this auxiliary circuit with collision-free and hiding prop-
erties. The former ensures that the consistency of the aux-
iliary outputs implies the consistency of Gen’s inputs, and
the latter ensures that the auxiliary outputs do not reveal
any information about Gen’s inputs.

A natural candidate for this auxiliary circuit is a commit-
ment circuit. The binding and hiding properties of a com-
mitment scheme satisfy the two security properties needed
here. This is a conceptually much simpler solution. We,
however, failed to ﬁnd a commitment circuit that intro-
duces less overhead than the previous state-of-the-art so-
lution does. Fortunately, we ﬁgured that a universal hash
circuit is a suﬃcient and much more eﬃcient alternative.
We next give the deﬁnition of universal hash functions, and
then we discuss how we achieve both collision-free and hiding
properties with a universal hash circuit. Finally, we present
an eﬃcient instantiation with proper parameters.

Definition 2

(Universal Hash). A collection of hash
functions H = {h|h : A → B} is called universal if for any

distinct x, y ∈ A, the probability that a uniformly chosen
h ∈ H satisﬁes that h(x) = h(y) is at most 1/|B|.

3.2.1 Collision-Free Property

This property comes naturally with universal hash func-
tions. Indeed, Deﬁnition 2 shows that for any distinct x, y,
if they are ﬁxed before h is uniformly chosen, their hashes
are unlikely to collide. This suggests that the collision-
free property can be achieved by letting Gen commit to
(ﬁx) its inputs before a hash function is jointly (uniformly)
picked. Later, the consistency of Gen’s inputs can be ver-
iﬁed by checking the consistency of the auxiliary outputs
(the hashes). Since both the objective circuit and the aux-
iliary circuit share the same input from Gen, Gen’s input
consistency to the auxiliary circuits implies the same to the
objective circuits. Our protocol is outlined as follows:

1. Gen commits to its inputs x(1), x(2), . . . , x(σ), where x(j)

denotes its input to the j-th garbled circuit.

2. Gen and Eval jointly and uniformly pick h ∈ H.

3. Gen constructs σ copies of the garbled circuit. Each cir-
cuit contains two parts: the objective circuit and the aux-
iliary circuit. While the ﬁrst part computes the objective
function, the j-th auxiliary circuit uses the input wires of
the objective circuit to compute h(x(j)).

4. Eval asks to check the correctness of a random fraction
of the garbled circuits. If the check fails, Eval aborts;
otherwise, Eval asks Gen to decommit to its inputs for
the remaining (unchecked) circuits.

5. Eval ﬁrst evaluates the remaining auxiliary circuits. If
the evaluation outputs (the hashes) are not consistent,
Eval aborts; otherwise, Eval proceeds to evaluating the
remaining objective circuits.

Since the cut-and-choose technique employs a majority
operation at the end, the ﬁnal evaluation output will not be
inﬂuenced by a few inconsistent inputs introduced by a ma-
licious Gen. We next argue, at a high level, that with high
probability, the protocol outlined above enjoys the desired
security property that Gen’s inputs to the majority of the
remaining circuits are consistent. Indeed, if a malicious Gen
is able to pass the hash consistency check and provide in-
consistent inputs to the majority of the remaining objective
circuits, there are only three possibilities:

1. The (auxiliary) circuits are faulty: The cut-and-choose
technique ensures that with high probability, this only
happens to a minority of the remaining circuits.

2. Gen is really lucky to have found a collision: By Def-
inition 2, this happens with probability at most 1/|B|,
which becomes negligible if B is properly chosen.

3. Gen is able to break the binding property of the commit-
ments: Since universal hash functions do not even pro-
vide pre-image resistance, given h and h(x(i)), it can be
easy to ﬁnd x(j) such that h(x(i)) = h(x(j)). So if Gen is
able to open the commitment from Step 1 to some value
computed after h is chosen in Step 2, it breaks the de-
sired security property. However, this would imply that
Gen is able to break the commitment scheme’s binding
property, which happens with negligible probability too.

527Remark 3.1. Since the above protocol is not the ﬁnal ver-
sion of our solution, we only provide the intuitions for now.
A simpler and more elaborate protocol will be given in Fig-
ure 2, but the same outline and security argument will apply.

3.2.2 Hiding Property

A deterministic universal hash h : A → B provides the
collision-free property we need, yet it is insuﬃcient for the
purposes here due to the lack of the hiding property. Indeed,
if the size of domain A is small, Eval could exhaustively
compute the hash of all possibilities in A and then deduce
x(j) ∈ A from h(x(j)). If the hashes are pseudo-random, they
reveal little information about the input, which is the hiding
property we desire. In particular, the celebrated left-over-
hash lemma [9] (LHL) states that the output of a uniformly
picked universal hash function h is pseudo-random (even if
h is made public) as long as the input has enough (min-
)entropy. Consequently, we suggest that function f (x, y) 7→
(f1, f2) is converted to g(x||r, y) 7→ (f1, h(x||r)||f2), where r
is randomness properly picked by Gen at the beginning and
h is a universal hash function uniformly picked after Gen
commits to its new input x||r.

We argue that our approach does provide the hiding prop-
erty even when h is public. Indeed, given h(x||r) and h, if r
is long enough (has enough entropy), for any x′, there must
exist r′ such that h(x||r) = h(x′||r′). This shows that giving
away hash h(x||r) does not rule out any possibilities of x.

3.2.3 Efﬁcient Instantiation

We suggest the use of the matrix universal hash family

Mk,m = {hM | hM (x) = M · x for some M ∈ {0, 1}k×m},

for some m ∈ N. A nice property of this hash family is that
it is ⊕-homomorphic, that is, for any x, y ∈ {0, 1}m and
hM ∈ Mk,m, it holds that hM (x ⊕ y) = hM (x) ⊕ hM (y).

This homomorphism allows an eﬃcient instantiation of
the protocol outlined above. The main idea is to let Eval
learn Gen’s input hash hM (x) not by circuit evaluation but
by ﬁrst giving away hM (π) and then revealing x⊕π, where π
is a randomly chosen one-time pad. The ⊕-homomorphism
of hM then allows Eval to compute hM (x) = hM (π) ⊕
hM (x⊕π) without learning x. We stress that although using
this technique allows hashes to be computed locally, we still
have to maintain the main structure of the above protocol
outline, that is, letting Gen commit to its inputs before hM
is jointly picked and letting Eval learn the hash of the in-
put to the evaluation circuits. The complete protocol of our
Gen’s input consistency check is presented in Figure 2, and
its security is stated in Lemma 3.

Lemma 3. Let k, σ ∈ N be common inputs such that σ =
O(k). Suppose Gen has private inputs {x(1), x(2), . . . , x(σ)},
and Eval has private input S ⊂ [σ]. If |S| = c · σ for some
1 > c > 0 and Eval accepts the proof presented in Figure 2,
the probability that no x(j) appears more than |S|/2 times in
multiset {x(j)}j∈S is negligible in k.

Remark 3.2. We stress that Gen’s private input x(j) in
Figure 2 refers to the concatenation of its actual input and
a random input as previously discussed.
It is also worth-
mentioning that k in Lemma 3 is also the security parameter
for the commitment scheme used in Figure 2.

Common Input: security parameter 1k, statistical se-
curity parameter 1σ, perfectly-hiding commitment
scheme com, and matrix hash function family Mk,m
for some m ∈ N.

Private Input: Gen has x(1), x(2), . . . , x(σ) ∈ {0, 1}m,

and Eval has subset S ⊂ [σ].

1. Gen randomly picks π(1), π(2), . . . , π(σ) ∈ {0, 1}m.

2. For all j ∈ [σ], Gen commits to x(j) by sending com(π(j))

and com(x(j) ⊕ π(j)) to Eval.

3. Gen and Eval jointly pick a random hM ∈ Mk,m.
4. Gen sends hM (π(1)), hM (π(2)), . . . , hM (π(σ)) to Eval.
5. Eval receives h(1)

π , . . . , h(σ)

π , h(2)

π . Next,

• if j ∈ [s]\S, Gen decommits com(π(j)) to π′(j), and

Eval checks if h(j)

π = hM (π′(j));

• if j ∈ S, Gen decommits com(x(j) ⊕ π(j)) to y(j), and

Eval computes h(j)

x = hM (y(j)) ⊕ h(j)
π .

Eval rejects if any of the commitments fails to open, any
of the checks fails, or for any distinct a, b ∈ S, h(a)
6=
h(b)
x ; otherwise, Eval accepts.

x

Figure 2: A proof for Gen’s input consistency

Remark 3.3. We allow Eval to select S, the set of cir-
cuits to evaluate. This saves the eﬀort of jointly picking set
S, but still guarantees that whatever S that Eval picks will
not compromise Gen’s privacy. Lemma 3 holds as long as S
is a constant fraction of [σ]. The use of perfectly-hiding com-
mitment schemes avoids the problems with the well-known
Selective Decommitment Attack.

Finally, we suggest the parameters for security level 2−k.
By Deﬁnition 2, Gen cannot ﬁnd a collision with probability
better than 1/|B|. So |B| needs to be at least 2k. As to the
size of random input r, the LHL lemma shows that if the
min-entropy of x||r is at least k + 2k = 3k and the output
hash is k-bits long, then the output is indistinguishable from
a truly random k-bit string with probability at least 1−2−k.
Since we make no assumptions about the input distribution
of x, a simple approach is to uniformly pick r such that
|r| = 3k. We can do better by exploiting speciﬁc properties
of Mk,m and reach the same goal with |r| = 2k + lg(k) as
shown in Lemma 4.

Lemma 4. Let Xn denote {0, 1}n for some n ∈ N and
Mk,m be deﬁned as above. For any x ∈ Xn and any t ≥
2k + lg(k), distributions {(h, h(x||r))} and {(h, y)} are sta-
tistically indistinguishable with probability at least 1 − 2−k,
where h, r, and y are uniformly chosen from Mk,n+t, Xt,
and Xk, respectively.

3.3 Selective Failure Attack

The Selective Failure Attack possible in the presence of
malicious adversaries has been pointed out by Mohassel and
Franklin [18] and by Kiraz and Schoenmakers [12]. This
attack occurs when a malicious Gen assigns (K0, K1) to an
Eval’s input wire in the garbled circuit while using (K0, K ∗
1 )
instead in the corresponding OT such that K1 6= K ∗
1 . Conse-
quently, if Eval has input 1, it learns K ∗
1 , gets stuck during
the evaluation, and Gen eventually learns Eval’s input.

528Lindell and Pinkas [15] suggested that Eval picks matrix
M ∈ {0, 1}n×m for some m ∈ N and computes its new input
¯y ∈ {0, 1}m such that M · ¯y = y. An auxiliary circuit will
later convert ¯y back to y to use as input to the original
circuit. The insight is that although selective failures allow
Gen to probe some partial information of ¯y, it is possible
that this partial information does not reveal any information
about Eval’s actual input y. For this approach to work, the
security property needed is formulated as follows:

Definition 5. For some m, n, k ∈ N, M ∈ {0, 1}n×m
is called k-probe-resistant if for any non-empty L ⊂ [n],
the Hamming distance of Li∈L Mi is at least k, where Mi
denotes the i-th row of matrix M .

As long as M is k-probe-resistant, a malicious Gen will have
to successfully probe k bits of ¯y in order to gain any partial
information of y, the probability of which is negligible. [15]
shows that when M is uniformly chosen from {0, 1}n×m
where m = max(4n, 8k), the probability that M fails to be
k-probe-resistant will be negligible. We stress that matrix M
can even be made public so that the auxiliary circuit could
consist of only XOR-gates, which requires no communication
overhead and can be computed eﬃciently when combining
with the free-XOR trick [13]. In short, not only does this
approach elegantly reduce the selective failure attack prob-
lem to the classic error correcting code construction, it also
has the potential to incur only little overhead.

Our idea to construct a k-probe-resistant matrix is to use
a maximum distance separable code such as Reed-Solomon
codes.3 We will work on the Reed-Solomon code over F
2t
for some t ∈ N with codeword size N and message size K.

By optimizing parameters, we prove the following in the

full version of this paper:

Lemma 6. Let P1, P2, . . . , Pn be distinct, non-zero poly-
nomials with degree at least K − 1 uniformly picked from
F2t [x], where integer K ≥ (lg(n) + n + k)/t. The probability
that there exist some i ∈ [n] and some L ⊂ [n]\{i} such that
Pi = Pj∈L Pj is at most 2−k.

Finally, we describe and implement an algorithm to ﬁnd
a k-probe-resistant M with high probability and prove the
correctness of this algorithm as follows:

Theorem 7. With probability at least 1 − 2−k, the algo-
rithm presented in Figure 5 outputs a k-probe-resistant ma-
trix M ∈ {0, 1}n×m such that m ∈ N and m ≤ lg(n) + n +
k + k · max(lg(4n), lg(4k)).

4. THE MAIN PROTOCOL

We now give the full description of our main protocol that

is based on the Yao protocol presented in Appendix B.4

3This direction has indeed been mentioned by Lindell and
Pinkas: “an explicit construction can be achieved using any
explicit linear code. [15]” Here, we develop their idea further
by describing an explicit solution that enjoys the optimal
performance—optimal asymptotic complexity with a con-
stant factor of one is worth reporting.
4We stress that although the Yao protocol is a well-known
work, readers are encouraged to get familiarized with our
notations and presentation, which serve as a steppingstone
to better understanding our main protocol.

Common Input: security parameter 1k, statistical secu-
rity parameter 1σ, symmetric cipher (enc, dec) with se-
mantic security, perfectly-hiding commitment scheme
com, and objective function f : (x, y) 7→ (f1, f2).

Private Input: Gen has input x and Eval has input y.

Private Output: Gen receives f1, Eval receives f2.

1. (New Inputs) Gen uniformly picks r ∈ {0, 1}2k+lg(k)
and e ∈ {0, 1}|f1|, while Eval samples k-probe-resistant
matrix M and computes ¯y such that M · ¯y = y. From
now on, Gen’s input refers to ¯x = x||e||r = ¯x1 ¯x2 . . . ¯xm1
and Eval’s input refers to ¯y = ¯y1 ¯y2 . . . ¯ym2 , where ¯xi and
¯yi denote the i-th bit of ¯x and ¯y, respectively.

Remark 4.1. r is Gen’s random input used to achieve
the hiding property of the hash of Gen’s input and protect
Gen’s input privacy, and e is the one-time pad used to
encrypt f1 and protect Gen’s output privacy.

Remark 4.2. By deﬁnition, k-probe-resistant matrix
M has to have full (row) rank. So for any y, there must
exist some ¯y such that M · ¯y = y. Also, given y and M ,
¯y can be eﬃciently computed by Gaussian elimination.

2. (Pick the Randomness) For all j ∈ [σ], Gen picks
randomness ρ(j) for the j-th garbled circuit and uses ρ(j)
to compute (K (j)
) ∈ {0, 1}2k+1 for all wires.
Let W (j)
). From
now on, W (j)
i,b is called the label that corresponds to wire
wi of value b in the j-th garbled circuit.

i,b denote key-locator pair (K (j)

i,b , b ⊕ π(j)

i

i,0 , K (j)

i,1 , π(j)

i

Remark 4.3. Randomness ρ(j) can be considered as
either a pool of truly random bits or a truly random seed
to a pseudo-random number generator.
It has internal
states that keep track of used and fresh random bits, and
it always returns fresh random bits when it is used. When
later requested, Gen needs to reveal ρ(j)’s initial state so
that Eval will be able to regenerate the random bits that
Gen used to construct the j-th garbled circuit.

3. (Commit to Input Label Pairs) Let {wi}i∈[m1] be the
wires corresponding to Gen’s input and {wm1+i}i∈[m2] be
those corresponding to Eval’s input. For each j ∈ [σ],
Gen uses randomness ρ(j) to commit to the label pairs
assigned to {wi}i∈[m1+m2] by sending commitments Θ(j)
and Ω(j) to Eval, where

Θ(j) = {com(W (j)

(j)
i,0⊕π
i

; θ(j)

i

), com(W (j)

(j)
i,1⊕π
i

; θ(j)

i

)}i∈[m1],

Ω(j) = {com(W (j)

m1+i,0), com(W (j)

m1+i,1)}i∈[m2].

Remark 4.4. The statement “ Gen uses randomness
ρ to commit to something” means that the randomness,
such as θ(j)
here, needed in the commitment is computed
from ρ in a standard, veriﬁable way. Also, recall that
some commitment may have its randomness omitted for
presentation simplicity, for example, Ω(j).

i

Remark 4.5. Gen commits to the label pairs assigned
to Gen’s and Eval’s input wires so that when Eval later
receives proper decommitments, it will know that the de-
committed labels are valid. Moreover, the commitment

529i

pairs assigned to Gen’s input wires need to be randomly
swapped so that each label’s semantics is independent of
its location. In other words, the location of a successfully
decommitted label will not disclose Gen’s input to Eval.
This random swap is done by reusing the permutation bit
π(j)
that is assigned to each wire and used to permute en-
tries in garbled truth tables. In contrast, the commitment
pairs corresponding to Eval’s input wires need to follow
a known order so that Eval can know the semantics of its
input labels and can verify that the successfully decommit-
ted labels actually match its input. As a result, the com-
mitment pairs in Θ(j) are randomly swapped so that the
commitment to b-label of the i-th wire is the (2·i+b⊕π(j)
)-
th entry, whereas in Ω(j), the commitment to b-label of the
i-th wire is the (2 · i + b)-th entry.

i

4. (Fix Gen’s Input) For each i ∈ [m1] and j ∈ [σ], Gen
commits to its input by sending commitments {Γ(j)}j∈[σ]
to Eval, where Γ(j) = {com(W (j)
i,¯xi

)}i∈[m1].

; γ(j)

i

Remark 4.6. It is crucial that commitments Γ(j) can-
not use the randomness from ρ(j) like commitments Θ(j)
do. If so, Eval will learn Gen’s inputs to check circuits.

Remark 4.7. Commitments Θ(j) in the previous step
along with commitments Γ(j) in this step play the role
of Step 2 of our Gen’s input consistency check shown
In particular, Θ(j) here is equivalent to
in Figure 2.
com(π(j)) there since the swapping pattern in Θ(j) is ex-
actly π(j), and Γ(j) here is equivalent to com(x(j) ⊕ π(j))
there since the committed label W (j)
).
i,¯xi

= (K (j)
i,¯xi

, ¯xi ⊕ π(j)

i

5. (Determine the Objective Circuit) Eval ﬁrst reveals
M , and then both parties jointly run a coin ﬂipping proto-
col to uniformly pick H ∈ {0, 1}k×m1 . Both parties now
have determined the objective circuit C that computes
g : (¯x, ¯y) 7→ (⊥, (c, g2)), where ¯x = x||e||r, y = M · ¯y,
g1 = f1(x, y), c = g1 ⊕ e, and g2 = f2(x, y).

Remark 4.8. Choosing H plays the role of Step 3 of
our Gen’s input consistency check presented in Figure 2.
The coin-ﬂipping protocol should guarantee unbiased out-
put even in the presence of one malicious party; thus a
three-round protocol suﬃces.

6. (Commit to Output Label Pairs) Let {wi}i∈O be the
wires corresponding to Eval’s output and O = O1 ∪ O2,
where O1 contains all the wire indices corresponding to
output c and O2 has those corresponding to output g2.
For each j ∈ [σ], Gen uses randomness ρ(j) to commit to
the label pairs assigned to {wi}i∈O1 by sending commit-
ments Φ(j) = {com(W (j)

i,1 )}i∈O1 to Eval.

i,0 ), com(W (j)

Remark 4.9. Commitments {Φ(j)}j∈[σ] are part of the
common input for our Gen’s output authenticity proof.

7. (Eval’s Input OTs) For each i ∈ [m2], both parties run

a (cid:0)2

1(cid:1)-OT in which Gen’s input equals

(cid:16){(W (j)

m1+i,0}j∈[σ], {(W (j)

m1+i,1)}j∈[σ](cid:17)

and Eval’s input equals ¯yi. Let Y (j) denote the set of de-
commitments Eval received for the j-th garbled circuit,
that is, Y (j) = {(W (j)

)}i∈[m2].

m1+i, ¯yi

Remark 4.10. There are σ·m2 decommitments needed
for Eval to retrieve its input labels from σ · m2 commit-
ment pairs {Ω(j)}j∈[σ], which Eval received in Step 3.
These decommitments are grouped according to Eval’s
input index i as Gen’s input to the OTs and grouped ac-
cording to circuit index j as decommitments Y (j).

8. (Circuit OTs) Eval randomly picks S ⊂ [σ] such that
|S| = 2σ/5. Let s ∈ {0, 1}σ such that sj = 1 if j ∈ S;
or sj = 0 otherwise. If sj = 0, Eval will learn the ran-
domness and check the j-th circuit; otherwise, Eval will
retrieve Gen’s input labels and evaluate the j-th circuit.
More speciﬁcally, for each j ∈ [σ], both parties run a
(cid:0)2
1(cid:1)-OT in which Eval’s input equals sj and Gen’s input
equals (ρ(j), (X (j)

π )), where

X (j)

1 = {(W (j)
i,¯xi

2 = {(W (j)
i,¯xi

, θ(j)

i

)}i∈[m1],

1 , X (j)
, γ(j)

2 , h(j)
)}i∈[m1], X (j)

i

and h(j)

π = H · (π(j)

1 ||π(j)

2 || · · · ||π(j)

Remark 4.11. The above (cid:0)2

lel if they provide security for parallel execution.

m1 ).
1(cid:1)-OTs could run in paral-

Remark 4.12. Decommitments X (j)

2 are used
for Eval to retrieve Gen’s input labels from commit-
ments Γ(j) received in Step 4 and Θ(j) received in Step 3,
In particular, each decommitment in X (j)
respectively.
opens one of a pair of commitments in Θ(j).

1 and X (j)

2

Remark 4.13. Revealing h(j)

π s plays the role of Step 4
of our Gen’s input consistency check shown in Figure 2.

9. (Garble the Circuit) For each gate g : {0, 1}×{0, 1} 7→
{0, 1} with input wires wa and wb and output wire wc,
Gen computes its garbled truth table

G(g)(j) =(hπ(j)

a , π(j)
h1 ⊕ π(j)

b i, hπ(j)
a , π(j)

a , 1 ⊕ π(j)
b i,
b i, h1 ⊕ π(j)

a , 1 ⊕ π(j)

b i),

where hb1, b2i = enc

K

(j)
a,b1

(enc

K

(j)
b,b2

(W (j)

c,g(b1,b2))).

Remark 4.14. Once (K (j)

)s are chosen for
all wires, no more randomness is needed for generating
the j-th garbled circuit. So ρ(j) is not needed here.

i,0 , K (j)

i,1 , π(j)

i

10. (Check the Circuit) Let {wi}i∈O be the circuit-output

wires. Gen then sends {G(C)(j)}j∈[σ] to Eval, where

G(C)(j) = (cid:16){G(g)(j)}g∈C , {π(j)

i }i∈O(cid:17) .

• (Check Circuits) For each j ∈ [σ]\S, Eval checks:
(a) if randomness ρ(j) received in Step 8 can regenerate
commitments {Θ(j), Ω(j), Φ(j)} received in Step 3 and
Step 6 and reconstruct garbled circuit G(C)(j)?

(b) if hash h(j)

π received in Step 8 (via circuit-OT) is indeed
m1 ), in which permuta-

2 || · · · ||π(j)

1 ||π(j)

is computed from randomness ρ(j)?

equal to H · (π(j)
tion bit π(j)

i

• (Evaluation Circuits) For each j ∈ S, Eval checks:
(a) if X (j)

received in Step 8 successfully opens
Γ(j) and half of Θ(j) received in Step 4, respectively?
and if the decommitted labels match? Namely,

and X (j)

1

2

530i. if the i-th entry of X (j)

1

entry of Γ(j)?

successfully opens the i-th

ii. if the i-th entry of X (j)

2

successfully opens the (2 · i +

¯xi ⊕ π(j)

i

)-th entry of Θ(j)?

iii. if the i-th decommitted labels from the above two

steps coincide?

(b) if Y (j) received in Step 7 successfully opens half of the
commitments in Ω(j)? Namely, if the i-th entry of Y (j)
successfully opens the (2 · i + ¯yi)-th entry of Ω(j)?

Eval aborts immediately if a failure occurs.

2

Remark 4.15. For evaluation circuits, the fact that
decommitments X (j)
(resp. Y (j)) successfully open Θ(j)
(resp. Ω(j)) shows that the majority of the decommitted
labels corresponding to Gen’s (resp. Eval’s) input are
valid. Furthermore, the fact that the decommitted labels
from commitments Γ(j) coincide with those from commit-
ments Θ(j) shows that Gen indeed commits to its inputs
before H is chosen, which is the necessary condition for
our 2-universal hash idea to work.

11. (Evaluate the Circuit) For each j ∈ S, Eval has ob-
tained garbled circuit G(C)(j) and (m1 + m2) labels cor-
responding to the (m1 + m2) circuit-input wires of C.
Eval then evaluates the circuit as follows:

(a) For each gate g with retrieved labels W (j)

b

, δ(j)

b = (K (j)

and W (j)
wires, Eval picks the (2·δ(j)
and computes label W (j)
K
sponding to the gate-output wire.

a +δ(j)
c = dec

a = (K (j)

a , δ(j)
a )
b ) corresponding to the gate-input
b )-th entry E in G(g)(j)
(E)) corre-

(dec

K

(j)
a

(j)
b

(b) For each circuit-output wire with retrieved label W (j)

(K (j)

i

, δ(j)

i

), Eval computes wire value b(j)

i = δ(j)

i =
i ⊕ π(j)
.

i

Eval interprets {b(j)
the labels that came with c(j).

i }i∈O as (c(j), g(j)

2 ). Let Z(j) denote

, δ(j)

i = (K (j)

12. (Gen’s Input Consistency Check) For all i ∈ [m1]
and j ∈ S, let W (j)
) be the decommitted
label corresponding to the i-th bit of Gen’s input to the
j-th garbled circuit. Eval computes h(j)
π ⊕ H ·
(δ(j)
m1 ) for all j ∈ S, and then veriﬁes Gen’s
input consistency by checking if for all a, b ∈ S, h(a)
¯x =
h(b)
¯x . Eval aborts if any of the checks fails.

2 || · · · ||δ(j)

¯x = h(j)

1 ||δ(j)

i

i

Remark 4.16. Checking the correctness of h(j)

π s re-
ceived in Step 10 and the checks here play the role of
Step 5 of our Gen’s input consistency check in Figure 2.

13. (Majority Operation) Let (c, g2) be the most common
tuple in Π = {(c(j), g(j)
2 )}j∈S. Eval aborts if (c, g2) is not
the majority in Π, that is, (c, g2) does not appear more
than |Π|

5 times in Π; otherwise, Eval outputs g2.

2 = σ

14. (Gen’s Output Authenticity Proof ) The two par-
ties conduct the protocol presented in Figure 1. In par-
ticular, the common inputs include security parameter
1k, statistical security parameter 1|S|, commitments to
label pairs assigned to Gen’s output wires {Φ(j)}j∈S,

i,0 , W (j)

and Gen’s alleged output c. Also, Gen’s input equals
{W (j)
i,1 }i∈O,j∈S and Eval’s input equals Z(j) for
some j ∈ S such that c(j) = c. If the proof fails, Gen
aborts; otherwise, Gen outputs c ⊕ e.

Theorem 8. Assume that the (cid:0)2

1(cid:1)-OT protocol is secure
in the presence of malicious adversaries, and there exist
a perfectly-hidng commitment scheme, a family of pseudo-
random functions, the main protocol (Gen, Eval) presented
above securely computes f : (x, y) 7→ (f1, f2) in the presence
of malicious adversaries.

The proof sketch is provided in Appendix C.

5. EXPERIMENTAL RESULTS

In this section, we report empirical evidence of our per-
formance advantages over prior work. We implemented our
work on top of the open-source project—KSS [14]. We ran
our experiments on the grid Stampede hosted in Texas Ad-
vanced Computing Center. Each instance of the experiments
invokes 32 computing nodes; each node has 32GB memory
and two 2 Intel Xeon E5-2680 2.7G processors; and each
processor has 8 cores.

5.1 Performance of our Proposed Technique

We show the performance of our Gen’s input consistency

check and k-probe-resistant matrix generating algorithm com-
pared with the prior state-of-the-art in Figure 3.

We ﬁrst compare the performance of the KSS system with
that of the KSS system integrated with our Gen’s input con-
sistency check. This experiment is conducted by using both
systems to evaluate circuits of various input sizes. These
circuits compute 2n blocks of AES128 encryption, where
n = 1, 2, . . . , 10 in which Gen provides inputs for 2n blocks
of AES128 (and thus has a 2n+7-bit input), Eval provides
a 128-bit encryption key, and Eval receives the 2n+7-bit
ciphertext. Figure 3a shows that when the input size in-
creases only to a moderate level (217), the performance gap
due to Gen’s input consistency check has almost dominated
the whole protocol execution. Speciﬁcally, the wall-clock
running of the improved protocol is 48.8 seconds versus 92.1
seconds for KSS (which was the fastest published protocol
whose results we could replicate on our setup).

Next, we show in Figure 3b that as Gen’s input size in-
creases, the ratio between the width and height of the k-
probe-resistant matrices generated by our algorithm indeed
approximates 1, while the ratio of those generated by Lindell
and Pinkas’s approach remains constant 4. This compari-
son suggests that for a circuit that has OTs as the dominant
component, the overall protocol execution time could be re-
duced to 25% simply by replacing the k-probe-resistant ma-
trix generated by the original work with the one generated
by our algorithm.

5.2 Performance of the Main Protocol

We show in Figure 4 the overall execution time of our
system securely evaluating circuits EDT-40955, RSA-2566,
and 1024-AES128. Overall, our system is able to handle
650, 000+ (or ∼ 200, 000 non-XOR) gates per second. We

5This circuit computes the edit distance of two 4,095-bit
inputs.
6This circuit computes a 256-bit modular exponentiation.

531i

)
c
e
s
(
 
e
m
T
 
k
c
o
C
!

l

l
l

a
W

100

80

60

40

20

0
 
2
10

KSS12
This Work

3
10

4
10

5
10

GEN’s Input Size (bits)

(a)

 

5

4

3

2

1

/

n
m

 

0
2
10

LP07

This Work

6
10

4
10

n

(b)

Figure 3: Performance comparison with prior works

Gen
(sec)

OT

comp
comm

0.4±0.09%
0.1± 1%

cut-& comp
comm

chk

–
–

Eval
(sec)

–

0.3±0.6%

–
–

Inp.
Chk

Evl.

Total

comp
comm

comp
comm

comp
comm

0.8± 1%
0.3± 1%

0.3±0.2%
0.9± 1%

11.4± 0.6% 28.0±0.4%
9.2± 1% 30.3±0.8%

12.6± 0.3% 28.0±0.2%
9.6± 1% 31.5±0.4%

Comm
(MB)

6

9

2,008

72,271

74,294

Table 3: The 95% two-sided conﬁdence intervals of the com-
putation andcommunication time for each stage in the 1024-
AES128 experiment (x, y) 7→ (⊥, 1024-AES128y(x)).

also observe that for all three circuits that we evaluated,
more than 60% of the execution time is spent on commu-
nicating the huge amount of data, the garbled circuits. If
we consider only the circuit garbling, the rate that our sys-
tem actually achieves could be as high as 1,600,000+ (or
500,000+ non-XOR) gates per second, with the help of var-
ious optimization techniques, including SSE2 and AESNI
instruction sets, and the free-XOR technique.

circuit

gates

(non-XOR)

time (sec)

comm.

EDT-4095
RSA-256
1024-AES128

(2.4B)

5.9B
0.93B (0.33B)
32M
(9.3M)

9,042
1,437
49

18 TB
3 TB
74 GB

Figure 4: The performance of our main protocol with k = 80 and
σ = 256. All numbers in “time” column come from an average of
30 data points and have the 95% conﬁdence interval < 1%.

6. ACKNOWLEDGEMENTS

We thank Benny Pinkas and Ben Riva for their gracious-
ness in correcting an earlier draft of this manuscript and the
anonymous reviewers for their insightful comments.

This work is supported by the Defense Advanced Research
Projects Agency (DARPA) and the Air Force Research Lab-
oratory (AFRL) under contract FA8750-11-2-0211. The views
and conclusions contained in this document are those of the
authors and should not be interpreted as representing the
oﬃcial policies, either expressed or implied, of the Defense
Advanced Research Projects Agency or the US government.

7. REFERENCES

 

[1] I. Damg˚ard, V. Pastro, N. Smart, and S. Zakarias.

Multiparty Computation from Somewhat
Homomorphic Encryption. CRYPTO ’12.
http://eprint.iacr.org/2011/535.

[2] T. K. Frederiksen, T. P. Jakobsen, J. B. Nielsen, P. S.
Nordholt, and C. Orlandi. MiniLEGO: Eﬃcient Secure
Two-Party Computation From General Assumptions.
EUROCRYPT ’13.
http://eprint.iacr.org/2013/155.

[3] R. Gennaro, C. Gentry, and B. Parno. Non-Interactive

Veriﬁable Computing: Outsourcing Computation to
Untrusted Workers. CRYPTO’10, pages 465–482.

[4] O. Goldreich. Foundations of Cryptography: Volume 2,
Basic Applications. Cambridge University Press, 2004.

[5] O. Goldreich, S. Micali, and A. Wigderson. How to

Play any Mental Game. STOC ’87, pp. 218–229.

[6] V. Goyal, P. Mohassel, and A. Smith. Eﬃcient

Two-Party and Multiparty Computation against
Covert Adversaries. EUROCRYPT’08, pp. 289–306.

[7] D. Hofheinz. Possibility and Impossibility Results for
Selective Decommitments. J. Cryptol., 24(3):470–516,
2011.

[8] Y. Huang, D. Evans, J. Katz, and L. Malka. Faster

Secure Two-Party Computation using Garbled
Circuits. USENIX SEC’11, pp. 35–35.

[9] R. Impagliazzo and D. Zuckerman. How to Recycle

Random Bits. SFCS ’89.

[10] S. Jarecki and V. Shmatikov. Eﬃcient Two-Party

Secure Computation on Committed Inputs.
EUROCRYPT ’07, pp. 97–114.

[11] M. Kiraz. Secure and Fair Two-Party Computation.

PhD thesis, Technische Universiteit Eindhoven, 2008.
[12] M. Kiraz and B. Schoenmakers. A Protocol Issue for

The Malicious Case of Yao’s Garbled Circuit
Construction. In 27th Symposium on Information
Theory in the Benelux, 2006.

[13] V. Kolesnikov and T. Schneider. Improved Garbled
Circuit: Free XOR Gates and Applications. ICALP
’08, pp. 486–498.

[14] B. Kreuter, a. shelat, and C. Shen. Billion-Gate
Secure Computation with Malicious Adversaries.
USENIX SEC’12, 2012.

[15] Y. Lindell and B. Pinkas. An Eﬃcient Protocol for
Secure Two-Party Computation in the Presence of
Malicious Adversaries. EUROCRYPT ’07.

[16] Y. Lindell and B. Pinkas. Secure Two-Party

Computation via Cut-and-Choose Oblivious Transfer.
TCC’11, pp. 329–346.

[17] D. Malkhi, N. Nisan, B. Pinkas, and Y. Sella.

Fairplay: A Secure Two-Party Computation System.
USENIX SEC’04, volume 13, pp. 287–302.

[18] P. Mohassel and M. Franklin. Eﬃciency Tradeoﬀs for

Malicious Two-Party Computation. PKC’06, pp.
458–473.

[19] P. Mohassel and B. Riva. Garbled Circuits Checking

Garbled Circuits: More Eﬃcient and Secure
Two-Party Computation, 2013.
http://eprint.iacr.org/2013/051.

532[20] J. Nielsen and C. Orlandi. LEGO for Two-Party

Secure Computation. TCC’09, volume 5444 of LNCS,
pages 368–386.

[21] J. B. Nielsen, P. S. Nordholt, C. Orlandi, and S. S.
Burra. A New Approach to Practical Active-Secure
Two-Party Computation. CRYPTO ’12, 2012.

[22] B. Pinkas, T. Schneider, N. P. Smart, and S. C.

Williams. Secure Two-Party Computation is Practical.
ASIACRYPT ’09, pp. 250–267.

[23] a. shelat and C.-H. Shen. Two-Output Secure

Computation with Malicious Adversaries.
EUROCRYPT’11, pp 386–405.

[24] Stampede. Tacc stampede.

http://www.tacc.utexas.edu/resources/hpc/stampede.

[25] D. Woodruﬀ. Revisiting the Eﬃciency of Malicious

Two-Party Computation. EUROCRYPT’07, volume
4515 of LNCS, pp. 79–96.

[26] A. C. Yao. Protocols for Secure Computations. SFCS

’82, pp. 160–164.

APPENDIX

A. ALGORITHM

Input: Eval’s input size n and a security parameter 1k
Output: A k-probe-resistant M ∈ {0, 1}n×m for some

m ∈ N

1 begin

2

3

4

5

6

7

8

9

10

11

12

t ← ⌈max(lg(4n), lg(4k))⌉
while 2t−1 > k + (lg(n) + n + k)/(t − 1) do

t ← t − 1;

end
K ← ⌈(lg(n) + n + k)/t⌉;
N ← K + k − 1;
for i ← 1 to n do

Pick P (x) = PK−1
Mi ← [P (1)2||P (2)2|| . . . ||P (N )2]

i=0 aixi, where ai ←R F

2t ;

end
return M ; // M ∈ {0, 1}n×m, where m = N t

13 end

Figure 5: A probabilistic algorithm to generate a k-probe-
resistant matrix M ∈ {0, 1}n×m for some m ∈ N. Line 2-5 is
to ﬁnd the minimum t such that 2t ≥ k + (lg(n) + n + k)/t, and
P (i)2 denotes a t × 1 row vector over {0, 1}.

B. THE YAO PROTOCOL

Our presentation uses the permuted garbled truth table
technique [17] (also known as the point-and-permute tech-
nique in the literature). Brieﬂy, this technique suggests to
assign each wire wi an extra random permutation bit πi.
The circuit garbling and evaluating is then slightly modi-
ﬁed:
for Gen, each garbled truth table is constructed in
the way that its entries are permuted according to its in-
put wires’ permutation bits; and for Eval, each random key
now comes with a locator that helps Eval identify the right
entry in the garbled truth table to decrypt.

For each wire, Eval learns exactly one key-locator pair
out of the two assigned to that wire from the circuit evalua-
tion, and the learned locator is in fact the evaluation result

of that wire one-time padded with the permutation bit. This
property ensures that Eval is oblivious to the intermediate
result of the circuit evaluation and allows Eval to learn the
output by revealing the permutation bits assigned to circuit-
output wires.

Common Input: security parameter 1k, boolean circuit
C that computes f (x, y), and symmetric encryption
scheme (enc, dec) with semantic security.

Private Input: Gen has private input x = x1x2 · · · xm1
and Eval has private input y = y1y2 · · · ym2 , where xi
and yi denote the i-th bit of x and y, respectively.

Output: Both Gen and Eval receive f (x, y) at the end.

1. (Pick the Randomness) Gen picks (Ki,0, Ki,1, πi) ∈
{0, 1}2k+1 at random for each wire wi. Let Wi,b denote
the key-locator pair (Ki,b, b ⊕ πi). Wi,b is called the label
corresponding to wire wi of value b hereafter.

2. (Retrieve Input Labels) Let {wi}i∈[m1] be the wires
corresponding to Gen’s input, and let {wm1 +i}i∈[m2] be
those corresponding to Eval’s input.

(a) (Gen’s Input Labels) Gen sends Eval the labels cor-

responding to its input {Wi,xi }i∈[m1].

(b) (Eval’s Input Labels) For each i ∈ [m2], Gen and
1(cid:1)-OT in which Gen’s input equals

Eval execute a (cid:0)2
(Wm1+i,0, Wm1+i,1) and Eval’s input equals yi.

3. (Garble the Circuit) For each gate g : {0, 1}×{0, 1} →
{0, 1} with input wires wa and wb and output wire wc,
Gen computes its garbled truth table

G(g) =(hπa, πbi, hπa, 1 ⊕ πbi,

h1 ⊕ πa, πbi, h1 ⊕ πa, 1 ⊕ πbi),

where hb1, b2i = encKa,b1
Let {wi}i∈O be the circuit-output wires. Gen sends Eval

(Wc,g(b1,b2))).

(encKb,b2

G(C) = ({G(g)}g∈C, {πi}i∈O).

4. (Evaluate the Circuit) Eval has obtained circuit G(C)
and (m1 + m2) labels corresponding to the (m1 + m2)
circuit-input wires. Eval evaluates the circuit as follows:

(a) For each gate g with retrieved input labels Wa = (Ka, δa)
and Wb = (Kb, δb), Eval picks the (2·δa +δb)-th entry E
in G(g) and computes the output label Wc = (Kc, δc) =
decKb (decKa (E)).

(b) For each circuit-output wire wi with corresponding label
Wi = (Ki, δi), Eval computes the wire value bi = δi⊕πi.
Recall that πi for wire wi comes with G(C).

Finally, Eval interprets {bi}i∈O as f (x, y) and sends it
to Gen. Both parties output f (x, y).

C. MAIN THEOREM PROOF SKETCH

We sketch the construction of simulators S1 and S2 such
that any malicious Gen∗ (resp. Eval∗) cannot tell whether
it is working with S1 (resp. S2) in the ideal model or with
honest Eval (resp. Gen) in the real model.

Malicious Gen∗

Simulator S1 acts as an honext Eval in the main protocol
all the way until the step of OTs except that S1 uses a fake
input ¯y′. In particular, S1 ﬁrst fake input y′ and then ﬁnds

533circuits. Next, S2 externally invokes the trusted third party
with input y′ = M · ¯y′ and gets f2(x, y′) in return. Note
that M is the k-probe-resistant matrix received from Eval∗
before OTs. After this, if s′
j = 0, the j-th garbled circuit is a
check circuit and needs to be honestly constructed according
to objective circuit C; otherwise, the j-th garbled circuit is
an evaluation circuit and is constructed in a way that it al-
ways outputs (h′, c′, f2(x, y′)), where h′ and c′ are randomly
picked by S2. From now on, S2 follows the Main protocol
faithfully. Finally, if S2 accepts in the step of Gen’s Output
Authenticity Proof, it sends 1 to the external oracle so that
S1 gets f1(x, y′); otherwise, S2 sends 0 to the external oracle
so that S1 gets ⊥.

Here we argue at a high level that Eval∗ cannot distin-
guish S2 using fake input ¯x′ in the ideal model versus Gen
using real input ¯x in the real model.

For check circuits, the only diﬀerence between S2 in the
ideal model and Gen in the real model is the committed
message in Γ(j). Note that this commitment is never
opened for check circuits. Therefore, if Eval∗ is able
to distinguish S2 committing to fake input ¯x′ from Gen
committing to real input ¯x in any check circuit, Eval∗
is able to break the hiding property of the commitment
scheme.

For evaluation circuits, the information Eval∗ learned
related the other party’s input is the location of the de-
committed labels within each pair of commitments and
the evaluation output:

1. Recall that the pairs of commitments to the labels as-
signed to Gen’s input wires are randomly swapped by
permutation bits {π(j)
i }i∈[m1],j∈[σ]. This random swap-
ping implies that the location learned in the ideal model
is ¯x′ ⊕ π′(j), where π′(j) = π′(j)
m1 , while
that learned in the real model is ¯x ⊕ π(j), where π(j) =
m1 . Since π′(j) and π(j) are indepen-
1 ||π(j)
π(j)
dently chosen from the uniform distribution, the loca-
tion information is statistically indistinguishable.

2 || . . . ||π′(j)

1 ||π′(j)

2 || . . . π(j)

2. The other message that might give S2 away is the evalua-
tion output. First, we claim that Eval∗ always gets con-
sistent output among diﬀerent garbled circuits. Indeed,
in the real model, since Gen is assumed to be honest,
the outputs from the evaluation circuits are identical,
and similarly, in the ideal model, S2 also generates eval-
uation circuits that have a ﬁxed output. So it remains
to argue that (h, c, f2) in the real model is indistinguish-
able from (h′, c′, f ′
Intuitively, h
and h′ are indistinguishable due to the hiding property
of our 2-universal hash scheme, c and c′ are indistin-
guishable due to the perfect secrecy of the one-time pad
encryption, and f2 and f ′
2 are indistinguishable due to
the simulation security of OTs.

2) in the ideal model.

a pre-image ¯y′ such that M · ¯y′ = y′, where M is the k-
probe-resitant matrix sampled at the beginning.

This fake input ¯y′ is used as input to Eval’s input OTs.
The OT’s receiver security ensures that Gen∗ (as the OT
sender) cannot distinguish the OT receiver’s input being ¯y′
provided by S1 in the ideal model from being ¯y provided by
Eval in the real model.

1 , X (j)

Next, for the circuit OTs, S1 invokes the OT’s simulator
(the existence of which is guaranteed by OT’s security) to
extract both inputs from Gen∗, including randomness ρ(j),
decommitments (X (j)
2 ) to Gen’s input labels, and hash
h(j)
π . A garbled circuit is bad if the retrieved randomness
cannot be used to regenerate the provided commitments and
garbled circuit. S1 aborts if more than σ/5 of the garbled
circuits are bad. This step is indistinguishable from the real
model due to the cut-and-choose technique. In particular,
if more than σ/5 circuits are bad, Eval in the real model
would abort with high probability too since the probability
that none of the bad circuits is checked is negligible.

If S1 does not abort, it learns the randomness of at least
4σ/5 good garbled circuits. Note that after Gen∗ passes the
circuit checking, S1 also learns decommitments (X (j)
1 , X (j)
2 )
for the 2σ/5 evaluation circuits. In other words, S1 learns
the randomness of at least σ/5 evaluation circuits, which are
good circuits too. The binding property of the commitments
ensures that S1 learns the private inputs that Gen∗ provided
to those good evaluation circuits. S1 aborts if these private
inputs are inconsistent. This step is indistinguishable from
the real model due to Gen’s input consistency check because
the check ensures that the probability of good evaluation
circuits having inconsistent inputs is negligible.

Let Gen∗’s private input extracted from above be ¯x′ =
x′||r′||e′. S1 sends x′ to the external trusted party and gets
f1(x′, y) in return, where y = M · ¯y. If S1 in the ideal model
(resp. Eval in the real model) has come to this far, with
high probability, Gen∗ must have provided majority good
evaluation circuits with valid input labels corresponding to
Gen∗’s input ¯x′ and S2’s input ¯y′ (resp. Eval’s input ¯y).
So the majority of Eval’s evaluation outputs are exactly
f1(x′, y) ⊕ e′. This implies that Gen∗ cannot distinguish S1
on input ¯y′ but providing f1(x′, y) ⊕ e′ (from the external
party) versus Eval on input ¯y and provding the evaluation
output f1(x′, y) ⊕ e′. Furthermore, the k-probe-resistant
matrix ensures that the diﬀerence between the probability
that S1 on fake input y′ aborts (due to selective failure) and
the probability that Eval on real input y aborts is negligible.
Finally, since S1 knows the randomness of many circuits,
it also knows the random keys corresponding to Gen∗’s en-
crypted output f1(x′, y) ⊕ e′. S1 is able to complete the
Gen’s Output Authenticity Proof as Eval does.

Malicious Eval∗

Simulator S2 honestly follows the main protocol all the way
until the step of OTs except that S2 picks a random ¯x′ ∈
{0, 1}m1 at the beginning and uses this fake input as in-
put. In particular, S2 commits to fake input ¯x′ in Step 4 by
committing to the corresponding labels. The commitments
are denoted by {Γ(j)}j∈[σ]. Then S2 invokes OT’s simulator
SOT
(whose existence is guaranteed by OT’s security) to ex-
tract Eval∗’s input to OTs, that is, its private input ¯y′ to
Eval’s Input OTs and the choice string s′ to Circuit OTs.
Recall that s′ determines the check circuits and evaluation

2

534