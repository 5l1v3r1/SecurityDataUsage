Protocol State Fuzzing of TLS Implementations
Joeri de Ruiter, University of Birmingham; Erik Poll, Radboud University Nijmegen
https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/de-ruiter

This paper is included in the Proceedings of the 24th USENIX Security SymposiumAugust 12–14, 2015 • Washington, D.C.ISBN 978-1-931971-232Open access to the Proceedings of  the 24th USENIX Security Symposium is sponsored by USENIXProtocol state fuzzing of TLS implementations

Joeri de Ruiter

School of Computer Science
University of Birmingham

Erik Poll

Institute for Computing and Information Science

Radboud University Nijmegen

Abstract

We describe a largely automated and systematic analysis
of TLS implementations by what we call ‘protocol state
fuzzing’: we use state machine learning to infer state ma-
chines from protocol implementations, using only black-
box testing, and then inspect the inferred state machines
to look for spurious behaviour which might be an indica-
tion of ﬂaws in the program logic. For detecting the pres-
ence of spurious behaviour the approach is almost fully
automatic: we automatically obtain state machines and
any spurious behaviour is then trivial to see. Detecting
whether the spurious behaviour introduces exploitable
security weaknesses does require manual investigation.
Still, we take the point of view that any spurious func-
tionality in a security protocol implementation is danger-
ous and should be removed.

We analysed both server- and client-side implemen-
tations with a test harness that supports several key ex-
change algorithms and the option of client certiﬁcate au-
thentication. We show that this approach can catch an
interesting class of implementation ﬂaws that is appar-
ently common in security protocol implementations: in
three of the TLS implementations analysed new security
ﬂaws were found (in GnuTLS, the Java Secure Socket
Extension, and OpenSSL). This shows that protocol state
fuzzing is a useful technique to systematically analyse
security protocol implementations. As our analysis of
different TLS implementations resulted in different and
unique state machines for each one, the technique can
also be used for ﬁngerprinting TLS implementations.

1 Introduction

TLS, short for Transport Layer Security, is widely used
to secure network connections, for example in HTTPS.
Being one of the most widely used security protocols,
TLS has been the subject of a lot of research and many
issues have been identiﬁed. These range from crypto-

graphic attacks (such as problems when using RC4 [4])
to serious implementation bugs (such as Heartbleed [13])
and timing attacks (for example, Lucky Thirteen and
variations of the Bleichenbacher attack [3, 30, 9]).

To describe TLS, or protocols in general, a state ma-
chine can be used to specify possible sequences of mes-
sages that can be sent and received. Using automated
learning techniques, it is possible to automatically ex-
tract these state machines from protocol implementa-
tions, relying only on black-box testing.
In essence,
this involves fuzzing different sequences of messages,
which is why we call this approach protocol state fuzzing.
By analysing these state machines, logical ﬂaws in the
protocol ﬂow can be discovered. An example of such
a ﬂaw is accepting and processing a message to per-
form some security-sensitive action before authentica-
tion takes place. The analysis of the state machines can
be done by hand or using a model checker; for the anal-
yses discussed in this paper we simply relied on manual
analysis. Both approaches require knowledge of the pro-
tocol to interpret the results or specify the requirements.
However, in security protocols, every superﬂuous state or
transition is undesirable and a reason for closer inspec-
tion. The presence of such superﬂuous states or transi-
tions is typically easy to spot visually.

1.1 Related work on TLS

Various formal methods have been used to analyse dif-
ferent parts and properties of the TLS protocol [33, 16,
22, 32, 20, 31, 26, 24, 28]. However, these analyses look
at abstract descriptions of TLS, not actual implementa-
tions, and in practice many security problems with TLS
have been due to mistakes in implementation [29]. To
bridge the gap between the speciﬁcation and implemen-
tation, formally veriﬁed TLS implementations have been
proposed [7, 8].

Existing tools to analyse TLS implementations mainly
focus on fuzzing of individual messages, in particular the

USENIX Association  

24th USENIX Security Symposium  193

certiﬁcates that are used. These certiﬁcates have been
the source of numerous security problems in the past.
An automated approach to test for vulnerabilities in the
processing of certiﬁcates is using Frankencerts as pro-
posed by Brubaker et al. [10] or using the tool x509test1.
Fuzzing of individual messages is orthogonal to the tech-
nique we propose as it targets different parts or aspects of
the code. However, the results of our analysis could be
used to guide fuzzing of messages by indicating proto-
col states that might be interesting places to start fuzzing
messages.

Another category of tools analyses implementations
by looking at the particular conﬁguration that is used.
Examples of this are the SSL Server Test2 and sslmap3.
Finally, closely related research on the implementation
of state machines for TLS was done by Beurdouche et al.
[6]. We compare their work with ours in Section 5.

1.2 Related work on state machine learn-

ing

When learning state machines, we can distinguish be-
tween a passive and active approach. In passive learning,
only existing data is used and based on this a model is
constructed. For example, in [14] passive learning tech-
niques are used on observed network trafﬁc to infer a
state machine of the protocol used by a botnet. This
approach has been combined with the automated learn-
ing of message formats in [23], which then also used the
model obtained as a basis for fuzz-testing.

When using active automated learning techniques, as
done in this paper, an implementation is actively queried
by the learning algorithm and based on the responses a
model is constructed. We have used this approach before
to analyse implementations of security protocols in EMV
bank cards [1] and handheld readers for online banking
[11], and colleagues have used it to analyse electronic
passports [2]. These investigations did not reveal new
security vulnerabilities, but they did provide interesting
insights in the implementations analysed. In particular,
it showed a lot of variation in implementations of bank
cards [1] – even cards implementing the same Master-
Card standard – and a known attack was conﬁrmed for
the online banking device and conﬁrmed to be ﬁxed in a
new version [11].

1.3 Overview

We ﬁrst discuss the TLS protocol in more detail in Sec-
tion 2. Next we present our setup for the automated
learning in Section 3. The results of our analysis of nine

1https://github.com/yymax/x509test
2https://www.ssllabs.com/ssltest/
3https://www.thesprawl.org/projects/sslmap/

TLS implementations are subsequently discussed in Sec-
tion 4, after which we conclude in Section 5.

2 The TLS protocol

The TLS protocol was originally known as SSL (Secure
Socket Layer), which was developed at Netscape. SSL
1.0 was never released and version 2.0 contained numer-
ous security ﬂaws [37]. This lead to the development of
SSL 3.0, on which all later versions are based. After SSL
3.0, the name was changed to TLS and currently three
versions are published: 1.0, 1.1 and 1.2 [17, 18, 19]. The
speciﬁcations for these versions are published in RFCs
issued by the Internet Engineering Task Force (IETF).

To establish a secure connection, different subproto-

cols are used within TLS:

• The Handshake protocol is used to establish session
keys and parameters and to optionally authenticate
the server and/or client.

• The ChangeCipherSpec protocol – consisting of
only one message – is used to indicate the start of
the use of established session keys.

• To indicate errors or notiﬁcations, the Alert protocol
is used to send the level of the alert (either warning
or fatal) and a one byte description.

In Fig. 1 a normal ﬂow for a TLS session is given. In
the ClientHello message, the client indicates the desired
TLS version, supported cipher suites and optional exten-
sions. A cipher suite is a combination of algorithms used
for the key exchange, encryption, and MAC computa-
tion. During the key exchange a premaster secret is es-
tablished. This premaster secret is used in combination
with random values from both the client and server to
derive the master secret. This master secret is then used
to derive the actual keys that are used for encryption and
MAC computation. Different keys are used for messages
from the client to the server and for messages in the op-
posite direction. Optionally, the key exchange can be
followed by client veriﬁcation where the client proves it
knows the private key corresponding to the public key
in the certiﬁcate it presents to the server. After the key
exchange and optional client veriﬁcation, a ChangeCi-
pherSpec message is used to indicate that from that point
on the agreed keys will be used to encrypt all messages
and add a MAC to them. The Finished message is ﬁ-
nally used to conclude the handshake phase. It contains
a keyed hash, computed using the master secret, of all
previously exchanged handshake messages. Since it is
sent after the ChangeCipherSpec message it is the ﬁrst
message that is encrypted and MACed. After the hand-
shake phase, application data can be exchanged over the
established secure channel.

194  24th USENIX Security Symposium 

USENIX Association

2

To add additional functionality, TLS offers the possi-
bility to add extensions to the protocol. One example of
such an extension is the – due to Heartbleed [13] by now
well-known – Heartbeat Extension, which can be used
to keep a connection alive using HeartbeatRequest and
HeartbeatResponse messages [36].

Client

Server

ClientHello
ServerHello;
[Certiﬁcate;]

[ServerKeyExchange;]
[CertiﬁcateRequest;]

ServerHelloDone

ClientKeyExchange;

[Certiﬁcate;]

[CertiﬁcateVerify;]
ChangeCipherSpec;

{Finished}

ChangeCipherSpec;

{Finished}

{ApplicationData}

{ApplicationData}

Figure 1: A regular TLS session. An encrypted message
m is denoted as {m}. If message m is optional, this is
indicated by [m].

As the actual state machine is not known, the equiv-
alence check has to be approximated, with what is ef-
fectively a form of model-based testing. For this we use
an improved version of Chow’s W-method [12]. The W-
method is guaranteed to be correct given an upper bound
for the number of states. For LearnLib we can specify a
depth for the equivalence checking: given a hypothesis
for the state machine, the upper bound for the W-method
is set to the number of found states plus the speciﬁed
depth. The algorithm will only look for counterexample
traces of which the lengths is at most the set upper bound,
and if none can be found the current hypothesis for the
state machine is assumed to be equivalent with the one
implemented. This assumption is correct if the actual
state machine does not have more states than the number
of found states plus the speciﬁed depth. The W-method
is very powerful but comes at a high cost in terms of per-
formance. Therefore we improved the algorithm to take
advantage of a property of the system we learn, namely
that once a connection is closed, all outputs returned af-
terwards will be the same (namely Connection closed).
So when looking for counterexamples, extending a trial
trace that results in the connection being closed is point-
less. The W-method, however, will still look for coun-
terexamples by extending traces which result in a closed
connection. We improved the W-method by adding a
check to see if it makes sense to continue searching for
counterexamples with a particular preﬁx, and for this we
simply check if the connection has not been closed. This
simple modiﬁcation of the W-method greatly reduced the
number of equivalence queries needed, as we will see in
Section 4.

3 State machine learning

3.1 Test harness

To infer the state machines of implementations of the
TLS protocol we used LearnLib [34], which uses a mod-
iﬁed version of Angluin’s L* algorithm [5]. An imple-
mentation that is analysed is referred to as the System
Under Test (SUT) and is considered to be a black box.
LearnLib has to be provided with a list of messages it
can send to the SUT (also known as the input alphabet),
and a command to reset the SUT to its initial state. A test
harness is needed to translate abstract messages from the
input alphabet to concrete messages that can be sent to
the SUT. To be able to implement this test harness we
need to know the messages that are used by the SUT.
By sending sequences of messages and reset commands,
LearnLib tries to come up with hypotheses for the state
machine based on the responses it receives from the SUT.
Such hypotheses are then checked for equivalence with
the actual state machine. If the models are not equivalent,
a counter-example is returned and LearnLib will use this
to redeﬁne its hypothesis.

To use LearnLib, we need to ﬁx an input alphabet
of messages that can be sent to the SUT. This alpha-
bet is an abstraction of the actual messages sent.
In
our analyses we use different input alphabets depend-
ing on whether we test a client or server, and whether
we perform a more limited or more extensive analy-
sis. To test servers we support the following mes-
sages: ClientHello (RSA and DHE), Certiﬁcate (RSA
and empty), ClientKeyExchange, ClientCertiﬁcateVer-
ify, ChangeCipherSpec, Finished, ApplicationData (reg-
ular and empty), HeartbeatRequest and HeartbeatRe-
sponse. To test clients we support the following mes-
sages: ServerHello (RSA and DHE), Certiﬁcate (RSA
and empty), CertiﬁcateRequest, ServerKeyExchange,
ServerHelloDone, ChangeCipherSpec, Finished, Appli-
cationData (regular and empty), HeartbeatRequest and
HeartbeatResponse.

We thus support all regular TLS messages as well as
the messages for the Heartbeat Extension. The test har-

USENIX Association  

24th USENIX Security Symposium  195

3

ness supports both TLS version 1.2 and, in order to test
older implementations, version 1.0. The input alphabet
is not ﬁxed, but can be conﬁgured per analysis as de-
sired. For the output alphabet we use all the regular TLS
messages as well as the messages from the Alert protocol
that can be returned. This is extended with some special
symbols that correspond with exceptions that can occur
in the test harness:

• Empty, this is returned if no data is received from
the SUT before a timeout occurs in the test harness.

• Decryption failed, this is returned if decryption fails
in the test harness after a ChangeChipherSpec mes-
sage was received. This could happen, for example,
if not enough data is received, the padding is incor-
rect after decryption (e.g. because a different key
was used for encryption) or the MAC veriﬁcation
fails.

• Connection closed, this is returned if a socket ex-

ception occurs or the socket is closed.

LearnLib uses these abstract inputs and outputs as la-
bels on the transitions of the state machine. To interact
with an actual TLS server or client we need a test harness
that translates the abstract input messages to actual TLS
packets and the responses back to abstract responses. As
we make use of cryptographic operations in the protocol,
we needed to introduce state in our test harness, for in-
stance to keep track of the information used in the key
exchange and the actual keys that result from this. Apart
from this, the test harness also has to remember whether
a ChangeCipherSpec was received or sent, as we have to
encrypt and MAC all corresponding data after this mes-
sage. Note that we only need a single test harness for
TLS to then be able to analyse any implementation. Our
test harness can be considered a ‘stateless’ TLS imple-
mentation.

When testing a server, the test harness is initialised by
sending a ClientHello message to the SUT to retrieve the
server’s public key and preferred ciphersuite. When a re-
set command is received we set the internal variables to
these values. This is done to prevent null pointer excep-
tions that could otherwise occur when messages are sent
in the wrong order.

After sending a message the test harness waits to re-
ceive responses from the SUT. As the SUT will not al-
ways send a response, for example because it may be
waiting for a next message, the test harness will gener-
ate a timeout after a ﬁxed period. Some implementations
require longer timeouts as they can be slower in respond-
ing. As the timeout has a signiﬁcant impact on the total
running time we varied this per implementation.

To test client implementations we need to launch a
client for every test sequence. This is done automati-

cally by the test harness upon receiving the reset com-
mand. The test harness then waits to receive the Client-
Hello message, after which the client is ready to receive
a query. Because the ﬁrst ClientHello is received before
any query is issued, this message does not appear explic-
itly in the learned models.

4 Results

We analysed the nine different implementations listed
in Table 1. We used demo client and server applica-
tions that came with the different implementations ex-
cept with the Java Secure Socket Extension (JSSE). For
JSSE we wrote simple server and client applications. For
the implementations listed the models of the server-side
were learned using our modiﬁed W-method for the fol-
lowing alphabet: ClientHello (RSA), Certiﬁcate (empty),
ClientKeyExchange, ChangeCipherSpec, Finished, Ap-
plicationData (regular and empty), HeartbeatRequest.
For completeness we learned models for both TLS ver-
sion 1.0 and 1.2, when available, but this always resulted
in the same model.

Due to space limitations we cannot include the models
for all nine implementations in this paper, but we do in-
clude the models in which we found security issues (for
GnuTLS, Java Secure Socket Extension, and OpenSSL),
and the model of RSA BSAFE for Java to illustrate how
much simpler the state machine can be. The other mod-
els can be found in [15] as well as online, together with
the code of our test harness.4 We wrote a Python ap-
plication to automatically simplify the models by com-
bining transitions with the same responses and replacing
the abstract input and output symbols with more readable
names. Table 2 shows the times needed to obtain these
state machines, which ranged from about 9 minutes to
over 8 hours.

A comparison between our modiﬁed equivalence algo-
rithm and the original W-method can be found in Table 3.
This comparison is based on the analysis of GnuTLS
3.3.12 running a TLS server. It is clear that by taking
advantage of the state of the socket our algorithm per-
forms much better than the original W-method: the num-
ber of equivalence queries is over 15 times smaller for
our method when learning a model for the server.

When analysing a model, we ﬁrst manually look if
there are more paths than expected that lead to a suc-
cessful exchange of application data. Next we determine
whether the model contains more states than necessary
and identify unexpected or superﬂuous transitions. We
also check for transitions that can indicate interesting be-
haviour such as, for example, a ’Bad record MAC’ alert
or a Decryption failed message. If we come across any

4Available at http://www.cs.bham.ac.uk/~deruitej/

196  24th USENIX Security Symposium 

USENIX Association

4

Name
GnuTLS

Java Secure Socket Extension (JSSE)

mbed TLS (previously PolarSSL)
miTLS
RSA BSAFE for C
RSA BSAFE for Java
Network Security Services (NSS)

OpenSSL

nqsb-TLS

Version
3.3.8
3.3.12
1.8.0_25
1.8.0_31
1.3.10
0.1.3
4.0.4
6.1.1
3.17.4

1.0.1g
1.0.1j
1.0.1l
1.0.2
0.4.0

URL
http://www.gnutls.org/

http://www.oracle.com/java/

https://polarssl.org/
http://www.mitls.org/
http://www.emc.com/security/rsa-bsafe.htm
http://www.emc.com/security/rsa-bsafe.htm
https://developer.mozilla.org/en-US/docs/
Mozilla/Projects/NSS
https://www.openssl.org/

https://github.com/mirleft/ocaml-tls

Table 1: Tested implementations

unexpected behaviour, we perform a more in-depth anal-
ysis to determine the cause and severity.

An obvious ﬁrst observation is that all the models
of server-side implementations are very different. For
example, note the huge difference between the mod-
els learned for RSA BSAFE for Java in Fig. 6 and for
OpenSSL in Fig. 7. Because all the models are different,
they provide a unique ﬁngerprint of each implementa-
tion, which could be used to remotely identify the imple-
mentation that a particular server is using.

Most demo applications close the connection after
their ﬁrst response to application data.
In the models
there is then only one ApplicationData transition where
application data is exchanged instead of the expected cy-
cle consisting of an ApplicationData transition that al-
lows server and client to continue exchanging application
data after a successful handshake.

In the subsections below we discuss the peculiarities
of models we learned, and the ﬂaws they revealed. Cor-
rect paths leading to an exchange of application data are
indicated by thick green transitions in the models.
If
there is any additional path leading to the exchange of
application data this is a security ﬂaw and indicated by a
dashed red transition.

4.1 GnuTLS

Fig. 2 shows the model that was learned for GnuTLS
3.3.8.
In this model there are two paths leading to a
successful exchange of application data: the regular one
without client authentication and one where an empty
client certiﬁcate is sent during the handshake. As we

did not require client authentication, both are accept-
able paths. What is immediately clear is that there are
more states than expected. Closer inspection reveals that
there is a ‘shadow’ path, which is entered by sending
a HeartbeatRequest message during the handshake pro-
tocol. The handshake protocol then does proceed, but
eventually results in a fatal alert (‘Internal error’) in re-
sponse to the Finished message (from state 8). From ev-
ery state in the handshake protocol it is possible to go to
a corresponding state in the ‘shadow’ path by sending the
HeartbeatRequest message. This behaviour is introduced
by a security bug, which we will discuss below. Addi-
tionally there is a redundant state 5, which is reached
from states 3 and 9 when a ClientHello message is sent.
From state 5 a fatal alert is given to all subsequent mes-
sages that are sent. One would expect to already receive
an error message in response to the ClientHello message
itself.

Forgetting the buffer in a heartbeat As mentioned
above, HeartbeatRequest messages are not just ignored
in the handshake protocol but cause some side effect:
sending a HeartbeatRequest during the handshake proto-
col will cause the implementation to return an alert mes-
sage in response to the Finished message that terminates
the handshake. Further inspection of the code revealed
the cause:
the implementation uses a buffer to collect
all handshake messages in order to compute a hash over
these messages when the handshake is completed, but
this buffer is reset upon receiving the heartbeat message.
The alert is then sent because the hashes computed by
server and client no longer match.

USENIX Association  

24th USENIX Security Symposium  197

5

Figure 2: Learned state machine model for GnuTLS 3.3.8

Figure 3: Learned state machine model for GnuTLS 3.3.12. A comparison with the model for GnuTLS 3.3.8 in Fig. 2
shows that the superﬂous states (8, 9, 10, and 11) are now gone, conﬁrming that the code has been improved.

198  24th USENIX Security Symposium 

USENIX Association

6

s
e
t
a
t
s
#

i

t
u
o
e
m
T
100ms
100ms
100ms
100ms
100ms
100ms
100ms
200ms
200ms
1500ms
500ms
500ms
200ms
100ms

12
7
8
16
11
10
7
9
9
6
8
6
9
8

)

m
m
:
h
(

e
m
T

i

0:45
0:09
0:39
0:31
0:16
0:14
0:06
0:41
0:39
0:53
3:16
0:18
8:16
0:15

s
e
i
r
e
u
q
p
i
h
s
r
e
b
m
e
m
#

s
e
i
r
e
u
q
e
c
n
e
l
a
v
i
u
q
e
#

1370
456
520
1016
680
624
350
584
584
392
520
392
584
399

5613
1347
2939
4171
2348
2249
902
2458
2176
517
5329
517
26353
1835

GnuTLS 3.3.8
GnuTLS 3.3.12
mbed TLS 1.3.10
OpenSSL 1.0.1g +
OpenSSL 1.0.1j +
OpenSSL 1.0.1l +
OpenSSL 1.0.2 +
JSSE 1.8.0_25
JSSE 1.8.0_31
miTLS 0.1.3
NSS 3.17.4
RSA BSAFE for Java 6.1.1
RSA BSAFE for C 4.0.4
nqsb-TLS 0.4.0 +
+ Without heartbeat extension

Table 2: Results of the automated analysis of server implementations for the regular alphabet of inputs using our
modiﬁed W-method with depth 2

Alphabet Algorithm
regular
full
full

modiﬁed W-method
modiﬁed W-method
original W-method

Time (hh:mm)
0:09
0:27
4:09

#states Membership queries Equivalence queries
7
9
9

1347
4126
68578

456
1573
1573

Table 3: Analysis of the GnuTLS 3.3.12 server using different alphabets and equivalence algorithms

This bug can be exploited to effectively bypass the in-
tegrity check that relies on comparing the keyed hashes
of the messages in the handshake: when also resetting
this buffer on the client side (i.e. our test harness) at the
same time we were able to successfully complete the
handshake protocol, but then no integrity guarantee is
provided on the previous handshake messages that were
exchanged.

By learning the state machine of a GnuTLS client
we conﬁrmed that the same problem exists when using
GnuTLS as a client.

This problem was reported to the developers of
GnuTLS and is ﬁxed in version 3.3.9. By learning mod-
els of newer versions, we could conﬁrm the issue is no
longer present, as can be seen in Fig. 3.

To exploit this problem both sides would need to reset
the buffer at the same time. This might be hard to achieve

as at any time either one of the two parties is computing a
response, at which point it will not process any incoming
message. If an attacker would successfully succeed to
exploit this issue no integrity would be provided on any
message sent before, meaning a fallback attack would be
possible, for example to an older TLS version or weaker
cipher suite.

4.2 mbed TLS

For mbed TLS, previously known as PolarSSL, we tested
version 1.3.10. We saw several paths leading to a suc-
cessful exchange of data. Instead of sending a regular
ApplicationData message, it is possible to ﬁrst send one
empty ApplicationData message after which it is still
possible to send the regular ApplicationData message.
Sending two empty ApplicationData messages directly

USENIX Association  

24th USENIX Security Symposium  199

7

after each other will close the connection. However, if in
between these message an unexpected handshake mes-
sage is sent, the connection will not be closed and only
a warning is returned. After this it is also still possible
to send a regular ApplicationData message. While this is
strange behaviour, it does not seem to be exploitable.

4.3 Java Secure Socket Extension

For Java Secure Socket Extension we analysed Java ver-
sion 1.8.0_25. The model contains several paths leading
to a successful exchange of application data and contains
more states than expected (see Fig. 4). This is the result
of a security issue which we will discuss below.

As long as no Finished message has been sent it is ap-
parently possible to keep renegotiating. After sending a
ClientKeyExchange, other ClientHello messages are ac-
cepted as long as they are eventually followed by another
ClientKeyExchange message. If no ClientKeyExchange
message was sent since the last ChangeCipherSpec, a
ChangeCipherSpec message will result in an error (state
7). Otherwise it either leads to an error state if sent di-
rectly after a ClientHello (state 8) or a successful change
of keys after a ClientKeyExchange.

Accepting plaintext data More interesting is that the
model contains two paths leading to the exchange of ap-
plication data. One of these is a regular TLS protocol
run, but in the second path the ChangeCipherSpec mes-
sage from the client is omitted. Despite the server not
receiving a ChangeCipherSpec message it still responds
with a ChangeCipherSpec message to a plaintext Fin-
ished message by the client. As a result the server will
send its data encrypted, but it expects data from the client
to be unencrypted. A similar problem occurs when trying
to negotiate new keys. By skipping the ChangeCipher-
Spec message and just sending the Finished message the
server will start to use the new keys, whereas the client
needs to continue to use its old keys.

This bug invalidates any assumption of integrity or
conﬁdentiality of data sent to the server, as it can be
tricked into accepting plaintext data. To exploit this issue
it is, for example, possible to include this behaviour in a
rogue library. As the attack is transparent to applications
using the connection, both the client and server applica-
tion would think they talk on a secure connection, where
in reality anyone on the line could read the client’s data
and tamper with it. Fig. 5 shows a protocol run where
this bug is triggered. The bug was report to Oracle and is
identiﬁed by CVE-2014-6593. A ﬁx was released in their
Critical Security Update in January 2015. By analysing
JSSE version 1.8.0_31 we are able to conﬁrm the issue
was indeed ﬁxed.

Client

Server

ClientHello

ServerHello;
Certiﬁcate;

ServerHelloDone

ClientKeyExchange;

Finished

ChangeCipherSpec;

{Finished}

ApplicationData

{ApplicationData}

Figure 5: A protocol run triggering a bug in the JSSE,
causing the server to accept plaintext application data.

This issue was identiﬁed in parallel by Beurdouche et
al. [6], who also reported the same and a related issue for
the client-side. By learning the client, we could conﬁrm
that the issue was also present there. Moreover, after re-
ceiving the ServerHello message, the client would accept
the Finish message and start exchanging application data
at any point during the handshake protocol. This makes
it possible to completely circumvent both server authen-
tication and the conﬁdentiality and integrity of the data
being exchanged.

4.4 miTLS

MiTLS is a formally veriﬁed TLS implementation writ-
ten in F# [8]. For miTLS 0.1.3, initially our test har-
ness had problems to successfully complete the hand-
shake protocol and the responses seemed to be non-
deterministic because sometimes a response was delayed
and appeared to be received in return to the next message.
To solve this, the timeout had to be increased consider-
ably when waiting for incoming messages to not miss
any message. This means that compared to the other im-
plementations, miTLS was relatively slow in our setup.
Additionally, miTLS requires the Secure Renegotiation
extension to be enabled in the ClientHello message. The
learned model looks very clean with only one path lead-
ing to an exchange of application data and does not con-
tain more states than expected.

4.5 RSA BSAFE for C

The RSA BSAFE for C 4.0.4 library resulted in a model
containing two paths leading to the exchange application
data. The only difference between the paths is that an

200  24th USENIX Security Symposium 

USENIX Association

8

Figure 4: Learned state machine model for JSSE 1.8.0_25

empty ApplicationData is sent in the second path. How-
ever, the alerts that are sent are not very consistent as they
differ depending on the state and message. For exam-
ple, sending a ChangeCipherSpec message after an ini-
tial ClientHello results in a fatal alert with reason ‘Ille-
gal parameter’, whereas application data results in a fatal
alert with ‘Unexpected message’ as reason. More cu-
rious however is a fatal alert ‘Bad record MAC’ that is
returned to certain messages after the server received the
ChangeCipherSpec in a regular handshake. As this alert
is only returned in response to certain messages, while
other messages are answered with an ‘Unexpected mes-
sage’ alert, the server is apparently able to successfully
decrypt and check the MAC on messages. Still, an error
is returned that it is not able to do this. This seems to be
a non-compliant usage of alert messages.

At the end of the protocol the implementation does
not close the connection. This means we cannot take any
advantage from a closed connection in our modiﬁed W-

method and the analysis therefore takes much longer than
for the other implementations.

4.6 RSA BSAFE for Java

The model for RSA BSAFE for Java 6.1.1 library looks
very clean, as can be seen in Fig. 6. The model again
contains only one path leading to an exchange of appli-
cation data and no more states than necessary. In gen-
eral all received alerts are ‘Unexpected message’. The
only exception is when a ClientHello is sent after a suc-
cessful handshake, in which case a ‘Handshake failure’
is given. This makes sense as the ClientHello message is
not correctly formatted for secure renegotiation, which is
required in this case. This model is the simplest that we
learned during our research.

USENIX Association  

24th USENIX Security Symposium  201

9

Figure 6: Learned state machine model for RSA BSAFE for Java 6.1.1

4.7 Network Security Services

The model for NSS that was learned for version 3.17.4
looks pretty clean, although there is one more state than
one would expect. There is only one path leading to a
successful exchange of application data. In general all
messages received in states where they are not expected
are responded to with a fatal alert (‘Unexpected mes-
sage’). Exceptions to this are the Finished and Heart-
beat messages:
these are ignored and the connection
is closed without any alert. Other exceptions are non-
handshake messages sent before the ﬁrst ClientHello:
then the server goes into a state where the connection
stays open but nothing happens anymore. Although the
TLS speciﬁcation does not explicitly specify what to
do in this case, one would expect the connection to be
closed, especially since it’s not possible to recover from
this. Because the connection is not actually closed in this
case the analysis takes longer, as we have less advantage
of our modiﬁcation of the W-method to decide equiva-
lence.

4.8 OpenSSL

Fig. 7 shows the model inferred for OpenSSL 1.01j. In
the ﬁrst run of the analysis it turned out that Heartbeat-
Request message sent during the handshake phase were
‘saved up’ and only responded to after the handshake
phase was ﬁnished. As this results in inﬁnite models we
had to remove the heartbeat messages from the input al-
phabet. This model obtained contains quite a few more
states than expected, but does only contain one path to
successfully exchange application data.

The model shows that it is possible to start by sending
two ClientHello messages, but not more. After the sec-
ond ClientHello message there is no path to a successful
exchange of application data in the model. This is due
to the fact that OpenSSL resets the buffer containing the
handshake messages every time when sending a Client-

Hello, whereas our test harness does this only on initial-
isation of the connection. Therefore, the hash computed
by our test harness at the end of the handshake is not ac-
cepted and the Finished message in state 9 is responded
to with an alert. Which messages are included in the hash
differs per implementation: for JSSE all handshake mes-
sages since the beginning of the connection are included.

In state 8 we see some unexpected be-
Re-using keys
haviour. After successfully completing a handshake, it is
possible to send an additional ChangeCipherSpec mes-
sage after which all messages are responded to with a
‘Bad record MAC’ alert. This usually is an indication of
wrong keys being used. Closer inspection revealed that
at this point OpenSSL changes the keys that the client
uses to encrypt and MAC messages to the server keys.
This means that in both directions the same keys are used
from this point.

We observed the following behaviour after the addi-
tional ChangeCipherSpec message. First, OpenSSL ex-
pects a ClientHello message (instead of a Finished mes-
sage as one would expect). This ClientHello is responded
to with the ServerHello, ChangeCipherSpec and Fin-
ished messages. OpenSSL does change the server keys
then, but does not use the new randoms from the Client-
Hello and ServerHello to compute new keys. Instead the
old keys are used and the cipher is thus basically reset
(i.e. the original IVs are set and the MAC counter reset
to 0). After receiving the ClientHello message, the server
does expect the Finished message, which contains the
keyed hash over the messages since the second Client-
Hello and does make use of the new client and server
randoms. After this, application data can be send over
the connection, where the same keys are used in both di-
rections. The issue was reported to the OpenSSL team
and was ﬁxed in version 1.0.1k.

202  24th USENIX Security Symposium 

USENIX Association

10

Figure 7: Learned state machine model for OpenSSL 1.0.1j

Figure 8: Learned state machine model for OpenSSL 1.0.1g, an older version of OpenSSL which had a known security
ﬂaw [27].

USENIX Association  

24th USENIX Security Symposium  203

11

Early ChangeCipherSpec The state machine model
of the older version OpenSSL 1.0.1g (Fig. 8) reveals a
known vulnerability that was recently discovered [27],
which makes it possible for an attacker to easily com-
pute the session keys that are used in the versions up to
1.0.0l and 1.0.1g, as described below.

As soon as a ChangeCipherSpec message is received,
the keys are computed. However, this also happened
when no ClientKeyExchange was sent yet, in which case
an empty master secret is used. This results in keys that
are computed based on only public data. In version 1.0.1
it is possible to completely hijack a session by sending
an early ChangeCipherSpec message to both the server
and client, as in this version the empty master secret is
also used in the computation of the hash in the Finished
message.
In the model of OpenSSL version 1.0.1g in
Fig. 8 it is clear that if a ChangeCipherSpec message is
received too early, the Finished message is still accepted
as a ChangeCipherSpec is returned (see path 0, 1, 6, 9, 12
in the model). This is an indication of the bug and would
be reason for closer inspection. The incoming messages
after this path cannot be decrypted anymore however, be-
cause the corresponding keys are only computed by our
test harness as soon as the ChangeCipherSpec message is
received, which means that these keys are actually based
on the ClientKeyExchange message. A simple modiﬁ-
cation of the test harness to change the point at which
the keys are computed will even provide a successful ex-
ploitation of the bug.

An interesting observation regarding the evolution of
the OpenSSL code is that for the four different versions
that we analysed (1.0.1g, 1.0.1j, 1.0.1l and 1.0.2) the
number of states reduces with every version. For ver-
sion 1.0.2 there is still one state more than required, but
this is an error state from which all messages result in a
closed connection.

4.9 nqsb-TLS

A recent TLS implementation, nqsb-TLS, is intended to
be both a speciﬁcation and usable implementation writ-
ten in OCaml [25]. For nsqb-TLS we analysed ver-
sion 0.4.0. Our analysis revealed a bug in this imple-
mentation: alert messages are not encrypted even af-
ter a ChangeCipherSpec is received. This bug was re-
ported to the nqsb-TLS developers and is ﬁxed in a newer
version. What is more interesting is a design decision
with regard to the state machine: after the client sends
a ChangeCipherSpec, the server immediately responds
with a ChangeCipherSpec. This is different compared to
all other implementations, that ﬁrst wait for the client to
also send a Finished message before sending a response.
This is a clear example where the TLS speciﬁcations are
not completely unambiguous and adding a state machine

would remove room for interpretation.

5 Conclusion

We presented a thorough analysis of commonly used
TLS implementations using the systematic approach we
call protocol state fuzzing: we use state machine learn-
ing, which relies only on black box testing, to infer a
state machine and then we perform a manual analysis of
the state machines obtained. We demonstrated that this
is a powerful and fast technique to reveal security ﬂaws:
in 3 out of 9 tested implementations we discovered new
ﬂaws. We applied the method on both server- and client-
side implementations. By using our modiﬁed version of
the W-method we are able to drastically reduce the num-
ber of equivalence queries used, which in turn results in
a much lower running time of the analysis.

Our approach is able to ﬁnd mistakes in the logic in
the state machine of implementations. Deliberate back-
doors, that are for example triggered by sending a par-
ticular message 100 times, would not be detected. Also
mistakes in, for example, the parsing of messages or cer-
tiﬁcates would not be detected.

An overview of different approaches to prevent secu-
rity bugs and more generally improve the security of soft-
ware is given in [38] (using the Heartbleed bug as a ba-
sis). The method presented in this paper would not have
detected the Heartbleed bug, but we believe it makes a
useful addition to the approaches discussed in [38]. It
is related to some of the approaches listed there; in par-
ticular, state machine learning involves a form of neg-
ative testing: the tests carried out during the state ma-
chine learning include many negative tests, namely those
where messages are sent in unexpected orders, which one
would expect to result in the closing of the connection
(and which probably should result in closing of the con-
nection, to be on the safe side). By sending messages in
an unexpected order we get a high coverage of the code,
which is different from for example full branch code cov-
erage, as we trigger many different paths through the
code.

In parallel with our research Beurdouche et al. [6] in-
dependently performed closely related research. They
also analyse protocol state machines of TLS implemen-
tations and successfully ﬁnd numerous security ﬂaws.
Both approaches have independently come up with the
same fundamental idea, namely that protocol state ma-
chines are a great formalism to systematically analyse
implementations of security protocols. Both approaches
require the construction of a framework to send arbi-
trary TLS messages, and both approaches reveal that
OpenSSL and JSSE have the most (over)complicated
state machines.

204  24th USENIX Security Symposium 

USENIX Association

12

The approach of Beurdouche et al. is different though:
whereas we infer the state machines from the code with-
out prior knowledge, they start with a manually con-
structed reference protocol state machine, and subse-
quently use this as a basis to test TLS implementations.
Moreover, the testing they do here is not truly random, as
the ‘blind’ learning by LearnLib is, but uses a set of test
traces that is automatically generated using some heuris-
tics.

The difference in the issues identiﬁed by Beurdouche
et al. and us can partly be explained by the difference
in functionality that is supported by the test frameworks
used. For example, our framework supports the Heart-
beat extension, whereas theirs supports Difﬁe-Hellman
certiﬁcates and export cipher suites. Another reason is
the fact that our approach has a higher coverage due to
its ‘blind’ nature.

One advantage of our approach is that we don’t have to
construct a correct reference model by hand beforehand.
But in the end, we do have to decide which behaviour
is unwanted. Having a visual model helps here, as it is
easy to see if there are states or transitions that seem re-
dundant and don’t occur in other models. Note that both
approaches ultimately rely on a manual analysis to as-
sess the security impact of any protocol behaviour that is
deemed to be deviant or superﬂuous.

When it comes to implementing TLS, the speciﬁca-
tions leave the developer quite some freedom as how
to implement the protocol, especially in handling errors
or exceptions. Indeed, many of the differences between
models we infer are variations in error messages. These
are not ﬁxed in the speciﬁcations and can be freely cho-
sen when implementing the protocol. Though this might
be useful for debugging, the different error messages are
probably not useful in production (especially since they
differ per implementation).

This means that there is not a single ‘correct’ state ma-
chine for the TLS protocol and indeed every implemen-
tation we analysed resulted in a different model. How-
ever, there are some clearly wrong state machines. One
would expect to see a state machine where there is clearly
one correct path (or possibly more depending on the con-
ﬁguration) and all other paths going to one error state –
preferably all with the same error code. We have seen
one model that conforms to this, namely the one for RSA
BSAFE for Java, shown in Fig. 6.

Of course, it would be interesting to apply the same
technique we have used on TLS implementations here on
implementations of other security protocols. The main
effort in protocol state fuzzing is developing a test har-
ness. But as only one test harness is needed to test all
implementations for a given protocol, we believe that this
is a worthwhile investment. In fact, one can argue that
for any security protocol such a test harness should be

provided to allow analysis of implementations.

The ﬁrst manual analysis of the state machines we ob-
tain is fairly straightforward: any superﬂuous strange be-
haviour is easy to spot visually. This step could even be
automated as well by providing a correct reference state
machine. A state machine that we consider to be correct
would be the one that we learned for RSA BSAFE for
Java.

Deciding whether any superﬂuous behaviour is ex-
ploitable is the hardest part of the manual analysis, but
for security protocols it makes sense to simply require
that there should not be any superﬂuous behaviour what-
soever.

The difference behaviour between the various imple-

mentations might be traced back to Postel’s Law:

‘Be conservative in what you send,
be liberal in what you accept.’

As has been noted many times before, e.g. in [35], this
is an unwanted and risky approach in security protocols:
if there is any suspicion about inputs they should be dis-
carded, connections should be closed, and no response
should be given that could possibly aid an attacker. To
quote [21]: ‘It’s time to deprecate Jon Postel’s dictum
and to be conservative in what you accept’.

Of course, ideally state machines would be included in
the ofﬁcial speciﬁcations of protocols to begin with. This
would provide a more fundamental solution to remove –
or at least reduce – some of the implementation freedom.
It would avoid each implementer having to come up with
his or her own interpretation of English prose speciﬁca-
tions, avoiding not only lots of work, but also the large
variety of state machines in implementations that we ob-
served, and the bugs that some of these introduce.

References

[1] AARTS, F., DE RUITER, J., AND POLL, E. Formal models of
bank cards for free. In Software Testing Veriﬁcation and Valida-
tion Workshop, IEEE International Conference on (2013), IEEE,
pp. 461–468.

[2] AARTS, F., SCHMALTZ, J., AND VAANDRAGER, F. Inference
and abstraction of the biometric passport. In Leveraging Appli-
cations of Formal Methods, Veriﬁcation, and Validation, T. Mar-
garia and B. Steffen, Eds., vol. 6415 of Lecture Notes in Com-
puter Science. Springer, 2010, pp. 673–686.

[3] AL FARDAN, N., AND PATERSON, K. Lucky Thirteen: Breaking
In Security and Privacy

the TLS and DTLS record protocols.
(SP), 2013 IEEE Symposium on (2013), IEEE, pp. 526–540.

[4] ALFARDAN, N., BERNSTEIN, D. J., PATERSON, K. G., POET-
TERING, B., AND SCHULDT, J. C. N. On the security of RC4 in
TLS. In Presented as part of the 22nd USENIX Security Sympo-
sium (USENIX Security 13) (2013), USENIX, pp. 305–320.

[5] ANGLUIN, D. Learning regular sets from queries and counterex-

amples. Information and Computation 75, 2 (1987), 87–106.

USENIX Association  

24th USENIX Security Symposium  205

13

[6] BENJAMIN BEURDOUCHE, KARTHIKEYAN BHARGAVAN, A.
D.-L., FOURNET, C., KOHLWEISS, M., PIRONTI, A., STRUB,
P.-Y., , AND ZINZINDOHOUE, J. K. A messy state of the union:
Taming the composite state machines of TLS.
In Security and
Privacy (SP), 2015 IEEE Symposium on (2015), IEEE, pp. 535–
552.

[7] BHARGAVAN, K., FOURNET, C., CORIN, R., AND ZALINESCU,
E. Cryptographically veriﬁed implementations for TLS. In Pro-
ceedings of the 15th ACM Conference on Computer and Commu-
nications Security (2008), CCS ’08, ACM, pp. 459–468.

[8] BHARGAVAN, K., FOURNET, C., KOHLWEISS, M., PIRONTI,
A., AND STRUB, P.
Implementing TLS with veriﬁed crypto-
graphic security. 2013 IEEE Symposium on Security and Privacy
(2013), 445–459.

[9] BLEICHENBACHER, D. Chosen ciphertext attacks against pro-
In
tocols based on the RSA encryption standard PKCS #1.
Advances in Cryptology – CRYPTO ’98, H. Krawczyk, Ed.,
vol. 1462 of Lecture Notes in Computer Science. Springer, 1998,
pp. 1–12.

[10] BRUBAKER, C., JANA, S., RAY, B., KHURSHID, S., AND
SHMATIKOV, V. Using Frankencerts for automated adversar-
ial testing of certiﬁcate validation in SSL/TLS implementations.
In Security and Privacy (SP), 2014 IEEE Symposium on (2014),
pp. 114–129.

[11] CHALUPAR, G., PEHERSTORFER, S., POLL, E., AND
DE RUITER, J. Automated reverse engineering using Lego. In
8th USENIX Workshop on Offensive Technologies (WOOT 14)
(2014), USENIX.

[12] CHOW, T. Testing software design modeled by ﬁnite-state ma-
chines. IEEE Transactions on Software Engineering 4, 3 (1978),
178–187.

[13] CODENOMICON. Heartbleed bug. http://heartbleed.com/.

Accessed on June 8th 2015.

[14] COMPARETTI, P., WONDRACEK, G., KRUEGEL, C., AND
KIRDA, E. Prospex: Protocol speciﬁcation extraction. In Secu-
rity and Privacy, 2009 30th IEEE Symposium on (2009), IEEE,
pp. 110–125.

[15] DE RUITER, J. Lessons learned in the analysis of the EMV
and TLS security protocols. PhD thesis, Radboud University Ni-
jmegen, 2015.

[16] DÍAZ, G., CUARTERO, F., VALERO, V., AND PELAYO, F. Auto-
matic veriﬁcation of the TLS handshake protocol. In Proceedings
of the 2004 ACM Symposium on Applied Computing (2004), SAC
’04, ACM, pp. 789–794.

[17] DIERKS, T., AND ALLEN, C. The TLS protocol version 1.0.

RFC 2246, Internet Engineering Task Force, 1999.

[18] DIERKS, T., AND RESCORLA, E. The Transport Layer Security
(TLS) protocol version 1.1. RFC 4346, Internet Engineering Task
Force, 2006.

[19] DIERKS, T., AND RESCORLA, E. The Transport Layer Security
(TLS) protocol version 1.2. RFC 5246, Internet Engineering Task
Force, 2008.

[20] GAJEK, S., MANULIS, M., PEREIRA, O., SADEGHI, A.-R.,
AND SCHWENK, J. Universally composable security analysis of
TLS. In Provable Security, J. Baek, F. Bao, K. Chen, and X. Lai,
Eds., vol. 5324 of Lecture Notes in Computer Science. Springer,
2008, pp. 313–327.

[21] GEER, D. Vulnerable compliance. login: The USENIX Magazine

35, 6 (2010), 10–12.

[22] HE, C., SUNDARARAJAN, M., DATTA, A., DEREK, A., AND
MITCHELL, J. C. A modular correctness proof of IEEE 802.11i
and TLS. In Proceedings of the 12th ACM Conference on Com-
puter and Communications Security (2005), CCS ’05, ACM,
pp. 2–15.

[23] HSU, Y., SHU, G., AND LEE, D. A model-based approach to
security ﬂaw detection of network protocol implementations. In
Network Protocols, 2008. ICNP 2008. IEEE International Con-
ference on (2008), IEEE, pp. 114–123.

[24] JAGER, T., KOHLAR, F., SCHÄGE, S., AND SCHWENK, J. On
In Advances
the security of TLS-DHE in the standard model.
in Cryptology – CRYPTO 2012, R. Safavi-Naini and R. Canetti,
Eds., vol. 7417 of Lecture Notes in Computer Science. Springer,
2012, pp. 273–293.

[25] KALOPER-MERŠINJAK, D., MEHNERT, H., MADHAVAPEDDY,
A., AND SEWELL, P. Not-quite-so-broken TLS: Lessons in
re-engineering a security protocol speciﬁcation and implemen-
tation. In 24th USENIX Security Symposium (USENIX Security
15) (2015), USENIX Association.

[26] KAMIL, A., AND LOWE, G. Analysing TLS in the strand spaces

model. Journal of Computer Security 19, 5 (2011), 975–1025.

[27] KIKUCHI, M. OpenSSL #ccsinjection vulnerability. http://

ccsinjection.lepidum.co.jp/. Access on June 8th 2015.

[28] KRAWCZYK, H., PATERSON, K., AND WEE, H. On the security
of the TLS protocol: A systematic analysis. In Advances in Cryp-
tology – CRYPTO 2013, vol. 8042 of Lecture Notes in Computer
Science. Springer, 2013, pp. 429–448.

[29] MEYER, C., AND SCHWENK, J. SoK: Lessons learned from
SSL/TLS attacks. In Information Security Applications, Y. Kim,
H. Lee, and A. Perrig, Eds., Lecture Notes in Computer Science.
Springer, 2014, pp. 189–209.

[30] MEYER, C., SOMOROVSKY, J., WEISS, E., SCHWENK, J.,
SCHINZEL, S., AND TEWS, E. Revisiting SSL/TLS imple-
mentations: New bleichenbacher side channels and attacks.
In
23rd USENIX Security Symposium (USENIX Security 14) (2014),
USENIX Association, pp. 733–748.

[31] MORRISSEY, P., SMART, N., AND WARINSCHI, B. A modular
security analysis of the TLS handshake protocol. In Advances in
Cryptology – ASIACRYPT 2008, J. Pieprzyk, Ed., vol. 5350 of
Lecture Notes in Computer Science. Springer, 2008, pp. 55–73.

[32] OGATA, K., AND FUTATSUGI, K. Equational approach to for-
mal analysis of TLS. In Distributed Computing Systems, 2005.
ICDCS 2005. Proceedings. 25th IEEE International Conference
on (2005), IEEE, pp. 795–804.

[33] PAULSON, L. C. Inductive analysis of the internet protocol TLS.

ACM Trans. Inf. Syst. Secur. 2, 3 (1999), 332–351.

[34] RAFFELT, H., STEFFEN, B., AND BERG, T. LearnLib: a library
for automata learning and experimentation.
In Formal methods
for industrial critical systems (FMICS’05) (2005), ACM, pp. 62–
71.

[35] SASSAMAN, L., PATTERSON, M. L., AND BRATUS, S. A patch
for Postel’s robustness principle. Security & Privacy, IEEE 10, 2
(2012), 87–91.

[36] SEGGELMANN, R., TUEXEN, M., AND WILLIAMS, M. Trans-
port Layer Security (TLS) and Datagram Transport Layer Secu-
rity (DTLS) Heartbeat Extension. RFC 6520, Internet Engineer-
ing Task Force, 2012.

[37] TURNER, S., AND POLK, T. Prohibiting Secure Sockets Layer
(SSL) version 2.0. RFC 6176, Internet Engineering Task Force,
2011.

[38] WHEELER, D. Preventing Heartbleed. Computer 47, 8 (2014),

80–83.

206  24th USENIX Security Symposium 

USENIX Association

14

