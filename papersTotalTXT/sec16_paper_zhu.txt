The Cut-and-Choose Game and Its Application  

to Cryptographic Protocols

Ruiyu Zhu and Yan Huang, Indiana University; Jonathan Katz, University of Maryland;  

Abhi Shelat, Northeastern University

 https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/zhu

This paper is included in the Proceedings of the 25th USENIX Security SymposiumAugust 10–12, 2016 • Austin, TXISBN 978-1-931971-32-4Open access to the Proceedings of the 25th USENIX Security Symposium is sponsored by USENIX The Cut-and-Choose Game and its Application to Cryptographic Protocols

Ruiyu Zhu

Indiana University

Yan Huang

Indiana University

Jonathan Katz

University of Maryland

abhi shelat

Northeastern University

Abstract

The cut-and-choose technique plays a fundamental role
in cryptographic-protocol design, especially for secure
two-party computation in the malicious model. The basic
idea is that one party constructs n versions of a message
in a protocol (e.g., garbled circuits); the other party ran-
domly checks some of them and uses the rest of them in
the protocol. Most existing uses of cut-and-choose ﬁx in
advance the number of objects to be checked and in opti-
mizing this parameter they fail to recognize the fact that
checking and evaluating may have dramatically different
costs.

In this paper, we consider a reﬁned cost model and
formalize the cut-and-choose parameter selection prob-
lem as a constrained optimization problem. We analyze
“cut-and-choose games” and show equilibrium strategies
for the parties in these games. We then show how our
methodology can be applied to improve the efﬁciency
of three representative categories of secure-computation
protocols based on cut-and-choose. We show improve-
ments of up to an-order-of-magnitude in terms of band-
width, and 12–106% in terms of total time. Source
code of our game solvers is available to download at
https://github.com/cut-n-choose.

1

Introduction

Most efﬁcient
implementations for secure two-party
computation in the semi-honest setting rely on garbled
circuits. One party, acting as circuit generator, prepares a
garbled circuit for the function of interest and sends it to
the other party along with garbled values corresponding
to its input. The second party, who will serve as the cir-
cuit evaluator, obtains garbled values for its own inputs
using oblivious transfer, and then evaluates the garbled
circuit to obtain the result.

The primary challenge in handling malicious adver-
saries is to ensure that the garbled circuit sent by the

ﬁrst party is constructed correctly. The cut-and-choose
paradigm is a popular and efﬁcient mechanism for doing
so. The basic idea is that the circuit generator produces
and sends several garbled circuits; the circuit evaluator
checks a random subset of these, and evaluates the rest to
determine the ﬁnal result. Since its formal treatment by
Lindell and Pinkas [16], numerous works have improved
various aspects of the cut-and-choose methodology and
used it to design secure protocols [28, 18, 24, 25, 26, 17,
14, 6, 15, 10, 27, 4, 2, 19, 11, 1, 20]. These prior works
fall roughly into three categories:
1. MajorityCut. Here the circuit evaluator determines
its output by taking the majority value among the
evaluated garbled circuits. Thus, security holds as
long as a majority of the evaluated circuits are cor-
rect. This is the classic approach adopted by many pa-
pers [16, 28, 18, 17] and implementations [25, 26, 14].
2. SingleCut. Here the circuit evaluator is able to ob-
tain the correct output as long as at least one of the
evaluated circuits are correctly generated. Schemes
adopting this approach include [15, 10, 4, 2].

3. BatchedCut. This considers a slightly different set-
ting in which the parties repeatedly evaluate some
function, and the goal is to obtain good amortized
efﬁciency by batching the cut-and-choose procedure
either across multiple instances of secure computa-
tion [19, 11], or at the gate level [24, 6].

Although SingleCut is asymptotically better than Ma-
jorityCut, some SingleCut protocols [15] require using
MajorityCut on a smaller circuit as a sub-routine, and
therefore optimizations to MajorityCut can result in efﬁ-
ciency improvements to SingleCut. In addition, Majori-
tyCut works better for applications with long outputs as
its cost does not grow with output length.

When setting parameters for cut-and-choose proto-
cols,
in order to optimize efﬁciency for some target
level of security, state-of-the-art approaches treat circuit
checking roughly as expensive as circuit evaluation, and
hence strive to optimize the total number of garbled cir-

USENIX Association  

25th USENIX Security Symposium  1085

Table 1: Bandwidth cost ratios r in various settings.

Sortc

6800

4300

2866

AESa

Ratio r

4533

# AND
gates

Floating
pt multb

ORAM
R/Wd
350 K 6.3× 109
233 K 4.2× 109
To be conservative in estimating r, ﬁgures assume 128-
bit labels. aOne-block AES128 with 128-bit wire labels.
(Non-free gate counts, 6800, reported in [3, 31], hence
bA single multiplica-
6800 × 256/(256 + 128) ≈ 4533).
tion of two 64-bit IEEE-754 ﬂoating-point numbers [21].
cSecurely compute an oblivious access to an ORAM of one
million 32-bit numbers [21]. dSorting one million 32-bit
numbers [21].

cuits involved. Although some researchers [15, 7, 2] ob-
served the asymmetry in the cost of checking and eval-
uation, they did not explore the cost asymmetry further,
and did not investigate the possibility of optimizing cut-
and-choose parameters based on this asymmetry.

As evidenced by many recent prototypes [21, 29, 20,
5, 9, 26, 25, 14, 13], network communication has be-
come the most prominent bottleneck of garbled-circuit
protocols, especially when exploiting dedicated hard-
ware [3, 8] or parallelism [5, 23, 13] for faster gar-
bling/evaluation. However,
the bandwidth costs are
markedly different for checking and evaluating circuits:
garbled circuits that are evaluated must be transmitted in
their entirety, but checking garbled circuits can be done
by generating the circuit from a short seed and commit-
ting to the circuit using a succinct commitment [7, 14, 2].
Table 1 presents, in the context of a few example appli-
cations, the bandwidth costs for sending an entire circuit
(i.e. the costs for an evaluated circuit) versus the cost for
committing to the circuit (which, for simplicity, requires
only one SHA256 hash), and thus a sample ratio r that
we use in this paper as a variable.

Based on these observations, we propose a new ap-
proach to optimizing parameters in cut-and-choose pro-
tocols. Our approach casts the interaction between the
circuit generator and circuit evaluator as a game, com-
putes the optimal strategies in this game (which, inter-
estingly, turn out to be mixed strategies), and then sets
parameters while explicitly taking into account the rela-
tive costs of circuit checking and circuit evaluation. Our
optimizations result in cut-and-choose approaches that
can be easily integrated into prior protocols, and can re-
duce the bandwidth in these protocols by an order-of-
magnitude in some settings.

1.1 Prior Work
The protocol of Lindell and Pinkas [16] checks exactly
half the circuits, an idea followed in many subsequent
works [25, 17]. They showed that by generating n cir-
cuits and checking a random subset of size n/2, a cheat-
ing generator succeeds in convincing the evaluator to ac-
cept an incorrect output with probability at most 2−0.311n.
Thus, to achieve (statistical) security level 2−40, their
protocol requires 128 garbled circuits. Shen and She-
lat [26] slightly improved the bound to 2−0.32s by open-
ing roughly 60% (instead of one half) of the circuits; this
reduces the number of garbled circuits needed to 125 for
2−40 security. These protocols belong to the MajorityCut
category in our terminology.

The idea of using SingleCut protocols was subse-
quently introduced [15, 4, 2]. Here, the evaluator chooses
whether to check each circuit with independent prob-
ability 1/2; now n circuits sufﬁce to achieve security
level 2−n.

Most recently, several works [19, 11, 20] have pro-
posed to amortize the cost of cut-and-choose across mul-
tiple evaluations of the same function. Along with the
LEGO family of protocols [6, 24] that amortize checks
at the gate level (rather than the circuit level), they all fall
in the class of BatchedCut protocols. These works show
that cut-and-choose can be very efﬁcient in an amortized
sense, requiring fewer than 8 circuits per execution to
achieve 2−40 security when amortizing over 1000 exe-
cutions. A brief explanation of the BatchedCut idea is
given at the beginning of Section 3.3.

1.2 Contributions
We introduce a game-theoretic approach to study cut-
and-choose in the context of secure-protocol design. The
simplest version of cut-and-choose can be treated as
a zero-sum game (where the utilities are 0/1 for the
loser/winner) between the evaluator and the generator in
which the generator wins if it can produce enough in-
correct circuits to skew the protocol without being de-
tected. Finding an optimal strategy for the evaluator can
be cast as solving a linear-program and results in a ran-
domized strategy for choosing the number of circuits to
check. This linear program can be further reﬁned to take
into consideration the different cost of checking vs eval-
uating (i.e., the ratio r). Analyzing the equilibrium of
this game leads to a constrained optimization problem
that can be used to derive more efﬁcient protocols meet-
ing a targeted security bound (e.g. ε = 2−40 as per many
published implementations).

Our techniques enable optimization based on the pre-
cise relative costs of checking and evaluating, which in
turn may depend on the function being computed as well

1086  25th USENIX Security Symposium 

USENIX Association

2

as characteristics of speciﬁc deployment settings, such as
software, hardware conﬁguration and network condition,
etc. This provides the ability to “tune” protocols to spe-
ciﬁc applications in a much more ﬁne-grained way than
before. We demonstrate that doing so can lead to band-
width savings of 1.2–10×.
We concretely apply our methodology to three
representative types of cut-and-choose-based secure-
computation protocols, and show a signiﬁcant overall
improvement in the bandwidth usage. For example, we
are able to reduce the network trafﬁc by up to an order-
of-magnitude in comparison with the state-of-the-art Sin-
gleCut (see Figure 5) and MajorityCut (see Figure 2) pro-
tocols, and savings of 20% ∼ 80% for state-of-the-art (al-
ready highly optimized) BatchedCut protocols (see Fig-
ure 8). Our improvements do not require any additional
cryptographic assumptions and come with little develop-
ment overhead.

2 Overview

Notation. Throughout this paper, we implicitly ﬁx the
semantic meaning for a few frequently-used variables
(unless explicitly noted otherwise) as in Table 2.

Table 2: Frequently-used variables

Failure probability of the cut-and-choose game
Cost ratio between circuit evaluation and checking
Total number of circuit copies (n = k + e)
Number of circuit copies used for checking
Number of circuit copies used for evaluation

ε
r
n
k
e
b Number of bad circuit copies generated

T
B
τ

Total number of circuits used in BatchedCut.
Bucket size in BatchedCut.
Evaluator’s detection rate checking a bad gate/circuit

2.1 Problem Abstraction
Let e and k be the numbers of evaluate-circuits and
check-circuits, respectively. Let r be the ratio between
the costs of evaluating and checking a circuit.
In the
case when the parameters e,k are set deterministically
and public, the cut-and-choose parameter optimization
problem can be expressed as the following non-linear
programming problem:

subject to

argmin

e,k

r· e + k

maxb Pra(e,k,b) ≤ ε,

3

where ε,r are known input constants; Pra(e,k,b) is the
probability of a successful attack; and b is the total num-
ber of bad circuits generated by the malicious generator.
In the case when at least one of the two parameters (e
and k) is randomly picked by the circuit evaluator from
some public distributions (but sampled values remain se-
cret to the circuit generator at the time of circuit gen-
eration), the optimization problem takes a more general
form

argmin

SE

E[cost(r,SE )]

subject to

E [Pra(SE ,SG)] ≤ ε, ∀ SG

where SE and SG are the circuit evaluator’s and the circuit
generator’s strategies, respectively; cost is the cut-and-
choose cost function, and E[·] denotes the expectation
function. Note that the cost function does not need to
account for pre-maturely terminated protocol executions
(due to detected cheating activity). Our goal is to iden-
tify the best SE for the evaluator. We leave the notion
of SE and SG abstract for now but will give more con-
crete representations when analyzing speciﬁc protocols
in Section 3.

We stress that, in contrast to the common belief used in
the state-of-the-art cost analysis of cut-and-choose proto-
cols, the cost of cut-and-choose is usually not best rep-
resented by n—the total number of circuits generated,
but rather by a cost ratio r between checking and eval-
uation which depends on many factors such as (1) the
kind of cost (e.g., bandwidth or computation); (2) the
deployment environment (e.g., network condition, dis-
tribution of computation power on the players, buffer-
ing, etc.) (3) the speciﬁc cryptographic primitives and
optimization techniques (e.g., the garbling scheme) used
in a protocol. Therefore, the best practice would be al-
ways micro-benchmarking the ratio between the per cir-
cuit cost of evaluation and checking before running the
protocol, and then select the best cut-and-choose strate-
gies accordingly.

2.2 Summary of Our Results
The main thesis of this work is,

Cut-and-choose protocols should be appropri-
ately conﬁgured based on the security require-
ment (ε) and the cost ratio (r) benchmarked at
run-time. Such practice can bring signiﬁcant
cost savings to many cut-and-choose based
cryptographic protocols.

To support our thesis, we have formalized the cut-and-
choose-based protocol conﬁguration problem into a con-
strained optimization problem over a reﬁned cost model.

USENIX Association  

25th USENIX Security Symposium  1087

Our solutions to the constrained optimization problem
imply randomized strategies are optimal. We show how
to support randomized strategies in the state-of-the-art
cut-and-choose-based cryptographic protocols with only
small changes. We applied this methodology to analyze
three major types of cut-and-choose schemes and the ex-
perimental results corroborate our thesis. We have im-
plemented a search tool for each category of schemes to
output the optimal parameters. The tool is available at
https://github.com/cut-n-choose.

3 Case Studies

In this section, we show how our general idea can be
applied to three main types of two-party secure com-
putation protocols that are based on the cut-and-choose
method to substantially improve their performance. We
assume that n is ﬁxed and public, while e will be selected
from some distribution and remain hidden to the genera-
tor until all circuits are generated and committed.

3.1 MajorityCut Protocols
MajorityCut strategy stems from an intuitive folklore
idea: the circuit evaluator randomly selects k (out of a
total n circuits) to check for correctness, evaluates the re-
maining e = n−k circuits, and outputs the majority of the
e evaluation results. All previous work assumed the use
of ﬁxed and public n,e,k parameter values, which grants
a malicious generator unnecessary advantages. For ex-
ample, knowing e, a malicious generator can choose to
generate (cid:30)e/2(cid:29) bad circuits to maximize the chance that
an honest evaluator outputs a wrong result. Thanks to its
simplicity, it is the scheme the most widely adopted by
implementations thus far.

In the following, we show how to apply our observa-
tions to MajorityCut protocols, which involves delaying
the revelation of cut-and-choose parameters and employ-
ing a mixed strategy (instead of a pure one) to minimize
the total cost of cut-and-choose.
Analysis. We represent the evaluator’s strategy by a vec-
tor xxx = (x0,x1, . . . ,x n) where xi is the probability that the
evaluator evaluates i uniform-randomly chosen circuits
and checks the remaining n − i. The expected cost of
MajorityCut is

n

∑

i=0

[xi · (i· r + (n− i))] = n + (r− 1)

n

∑

i=0

xi · i

If the generator produces b incorrect circuits and the
evaluator evaluates i circuits, the probability that the

evaluator’s check passes is (cid:31)n−b
n−i(cid:30). After a suc-
cessful check, the evaluator loses the security game if
and only if 2b ≥ i, i.e., there is no majority of correct

n−i(cid:30)(cid:29)(cid:31) n

evaluation circuits. Hence, when the evaluator uses strat-
egy xxx, the expected failure probability of the MajorityCut
scheme is

∑
i≤2b
Since i ≤ n and (cid:31)n−b

xi ·(cid:28)n− b
n−i(cid:30) = 0 for all i < b, this sum can
n−i(cid:30). The se-

n− i(cid:27)
n− i(cid:27)(cid:26)(cid:28) n
n−i(cid:30)(cid:29)(cid:31) n
xi ·(cid:31)n−b

be further reduced to ∑min(n,2b)
curity requirement stipulates that for every choice of b
by the malicious generator, the resulting cut-and-choose
failure probability should be less than ε. In other words,
the goal of picking optimal cut-and-choose parameters
can be achieved by solving the following linear program:

i=b

min
xxx

n + (r− 1)

subject to

n

∑

i=0

xi · i

n

xi ≥ 0
xi = 1,

i=0

∑
i(cid:27) < ε, ∀b ∈ {1, . . . ,n}.

min(n,2b)

∑

i=b

xi ·(cid:28)n− b

i− b(cid:27)(cid:26)(cid:28)n

Solving this linear program provides us an equilibrium
strategy for every ﬁxed n,ε,r. Using standard LP solvers,
such programs can be solved exactly for n that ranges
into the thousands (i.e., all practical settings).

With this capability, we can identify, for a given target
ε and ratio r, the optimal n (that leads to the least overall
cost) by solving the linear programs for all feasible n val-
ues. While this leads to the search algorithm described
in Figure 1, we note several important observations that
speedup the search:
1. We begin our search at n0 = (cid:21)ε(cid:20) and consider n =
n0,n0 + 1, . . .. After solving each LP, we identify a
current best cost c∗. Observe that c∗ − (r − 1) is an
upper-bound of the best n (noted n∗), since any feasi-
ble strategy with n > c∗ − (r− 1) will cost at least c∗
(the evaluator need to evaluate at least one circuit ex-
cept with at most ε probability). Thus, as our search
continues, we update c∗, and terminate the search as
soon as all values of n between n0 and c∗− (r−1) are
examined.
2. When the value of r is beyond moderate (i.e., r > tr
for some constant tr like 128 with our laptop), search-
ing for the optimal cost becomes time-consuming as it
involves solving the above linear programming prob-
lem for many relatively large n values (e.g., n > 500).
In these settings, however, we opt to live with a sub-
optimal pure strategy, based on the observation that
the standard deviation of e is already so small (less

1088  25th USENIX Security Symposium 

USENIX Association

4

than 0.6 and only keeps decreasing as r grows) that
the cost of a sub-optimal pure strategy (i.e. a combi-
nation of n and e) approximates the theoretical opti-
mal pretty well (Figure 3b).

3. We note that when r > tr (step 2), it sufﬁces to search
all e less than e0 (recall (e0,n0,c0) is the starting
point of our search, simply derived from the tradi-
tional setup with MajorityCut) instead of the inﬁ-
nite range because any strategy with e = e0 + 1 that
is more efﬁcient than one with e = e0 has to use at
least r− 1 fewer check circuits. Since tr = 128, such
strategy would have used at least 127 fewer check-
circuits, which will contradict with n0 = 128 (assum-
ing ε = 2−40).

Results. We have implemented the search algorithm of
Figure 1 and run it with a wide range of practically pos-
sible r values (see Figure 2). For r values ranging from
5000 to 109, which are typical regarding the cost in net-
work trafﬁc, we can achieve 6 to 16 times savings com-
pared to traditional MajorityCut protocols. Even when r
is small, such as 8 ∼ 128 which are representative when
considering only the timing cost, our approach brings
about 1.45 to 3 times savings. When circuit-level paral-
lelism is exploited like in the work of [14, 13, 5], where r
typically ranges from 50 to 500 (see Table 5), we are able
to speedup the best existing works by 2.3 ∼ 3.9 times.
Table 3 gives two example optimal strategies for
achieving ε = 2−40 security when r = 10 and r = 100,
respectively. We observe that the solution mixes fewer
pure strategies (which is consistent to the decrease of
variance) as r grows. Also note that all pure strategies
with even es are dominated by ones with odd es. In con-
trast to current implementations, these strategies suggest
that the generator produce a few hundred circuits, but
only send roughly 13–21 of them. (Such a scheme is for
example quite feasible when using the GPU to produce
and commit to garbled circuits.) In comparison, the best
protocols that use BatchedCut need to amortize 1000s
of protocol executions to achieve security when sending
roughly 10 circuits.

In Figure 2, the cross-marked solid curve delineates
the optimal cost of mixed strategies (among all strate-
gies with public ﬁxed n), while the dot-marked dashed
curve delineates pure-strategy approximation of the op-
timal mixed strategies (efﬁciently computed as a result
of step 2 of Figure 1 search algorithm). We observe that
the pure-strategy approximation actually improves as r
get bigger. But when r is relatively small (100 ≥ r ≥ 1),
our optimization-based approach can indeed bring about
1% ∼ 11% extra improvement (Figure 2). Last, the
curves for two different ε values have similar shape but
the improvement as a result of our approach is signiﬁ-
cantly larger for smaller ε values.

We also observe from Figure 2 that the performance

Table 3: Example optimal strategies for MajorityCut pro-
tocols. (ε = 2−40, only non-zero xis are listed.)

r = 10

r = 100

n

514

i

3
5
7
9
11
13
15

xi as %
4· 10−6
2.04· 10−4
7.44· 10−3

0.21
4.86
94.73
0.19

n

361

i

7
9
11
13
15
17
19
21
23

xi as %
1· 10−4
9· 10−4
7· 10−3
4.54· 10−2

0.25
1.23
5.36
20.9
72.2

Saves 13.5% b/w

Saves 65.3% b/w

boost seems to be upper-bounded by some value related
to ε, no matter how big r becomes. This makes some in-
tuitive sense because the cost of our optimized protocols
will be upper-bounded by a linear function of r (as the
solution comes out of solving the linear programming
problem where r constitutes the coefﬁcients of the un-
knowns). We leave the formal proof of this intuition as
an interesting future work.

To examine the characteristic of our solution more
closely for 1 ≤ r ≤ 128, we have plotted the compari-
son of overall cost of the optimal strategy with respect
to best prior works (Figure 3a), the standard deviation of
the overall cost (Figure 3b, recall the optimal strategy is
a randomized strategy), and the best n used in every opti-
mal strategy (Figure 3c). Note that the standard deviation
of the overall cost is also exactly the standard deviation
of e because the randomness in cost all comes from the
randomness in selecting e. The fact that the standard de-
viation quickly drops to less than 0.3 (when r ≥ 100) and
strictly decreases justiﬁes the accuracy of pure strategy
approximation for large r.
Changes to Existing Protocols. Our approach to Major-
ityCut applies to many published cut-and-choose based
two-party computation protocols; in particular, it applies
directly to those protocols in which the generator ﬁrst
commits to n garbled circuits, and later, after a coin-
tossing protocol between generator and evaluator, opens
each check circuit by sending either (a) both the 0 and 1
labels for all of its input wires, or (b) the random coins
used to construct the circuit. Goyal, Smith and Mohas-
sel [7] were the ﬁrst to use this technique and the second

USENIX Association  

25th USENIX Security Symposium  1089

5

Input: ε,r.
Output: c∗,n∗,xxx∗.
1. If r ≤ tr,
(a) Initialize n0 := (cid:29)logε(cid:28) and c∗ := +∞.
(b) For n := n0 to c∗ − (r− 1)(1− ε),

i. Solve the MajorityCut linear programming problem for (n,ε,r) to obtain (c,xxx) where c is the minimal cost of

LP(n,ε,r) and xxx represents the corresponding strategy to achieve c.
ii. If (c,xxx) is a feasible solution and c∗ > c, then (c∗,xxx∗,n∗) := (c,xxx,n).

(c) Output (c,n∗,xxx∗).

2. If r > tr,
(a) Initialize n0 := 3(cid:29)logε(cid:28),e0 = n0/2,c0 := 3(cid:29)logε(cid:28) + (r− 1)e0 and c∗ = c0,n∗ = n0.
(b) For i := 1 to +∞ until ei−1 = 1,

i. Set ei = ei−1 − 1 and compute the smallest (ci,ni) that satisﬁes the security constraints.
ii. If c∗ > ci, then (c∗,n∗,e∗) := (ci,ni,ei).

(c) Output(c,n∗,{x0, . . . ,x n}) where xi = 1 if i = e∗, and xi = 0 otherwise.

Figure 1: Search the most efﬁcient strategy (n,xxx) for MajorityCut protocols. log(·) is base-2. c is the minimal cost,
n is the ﬁxed total number of circuits and xxx = (x0, . . . ,x n) stands for the evaluator’s best strategy to sample e. While
the value of tr depends on hardware and users’ tolerance of performance. tr = 128 works well on a MacBook Air for
ε = 2−40.

pure strategies
mixed strategies

)

×

(

s
g
n
i
v
a
S
d
e
t
c
e
p
x
E

16
14
12
10
8
6
4
2
0

pure strategies
mixed strategies

50

)

×

(

40

s
g
n
i
v
a
S
d
e
t
c
e
p
x
E

30

20

10

0

100

102

104

106

108

100

102

104

106

108

Cost Ratio r

(a) ε = 2−40

Cost Ratio r

(b) ε = 2−20

Figure 2: Our savings for MajorityCut protocols

(“I + 2C”) protocol from Kreuter, Shelat, Shen [14] also
operates in this way. In these cases, no modiﬁcations to
the security analysis are needed. For every speciﬁc ε and
r, our solver outputs a particular n and a distribution xxx for
picking e. Roughly speaking, the only changes needed in
the protocol are straightforward: the evaluator announces
this n beforehand and the result of the coin-tossing pro-
tocol ρ is used to sample e according to xxx using stan-
dard methods (instead of the 1/2 or 3/5 fractions as be-
fore). The simulation of a malicious evaluator proceeds
as in the original security proof with the exception that
the simulator ﬁrst samples e according to xxx using random
tape ρ and then (as before), uses a simulated coin-tossing
to ensure the outcome of the toss induces ρ. (The coin-
tossing method is a simple and effective method to prove
security; other proofs may also exist.)

Similarly, the ﬁrst protocol of Lindell and Pinkas [16]

can be modiﬁed to adopt this idea: step (3) should send
commitments to garbled circuits, modify step (4) to use
the random tape from coin-tossing to sample e, modify
step (8) so that the garbler sends the entire garbled cir-
cuits for the evaluation specimens as well as openings to
the commitments so that the evaluator can check consis-
tency.

The idea seems applicable to many protocols which
have the property that the set of checked circuits becomes
publicly veriﬁable. For example, Mohassel and Riva [22]
use a different idea in their protocol to allow the same
output labels to be used across all n copies of the garbled
circuit. In their original protocol, the evaluator and gen-
erator then use coin-tossing to select the open circuits,
but then proceed to evaluate the remaining circuits ﬁrst,
perform some checks, and then the evaluator commits to
the output labels. Finally, the generator opens the check

1090  25th USENIX Security Symposium 

USENIX Association

6

×103

best prior works
this work

d
a
e
h
r
e
v
o
h
t
d
i
w
d
n
a
B

6
5
4
3
2
1
0

0

50

100

Cost ratio r

(a)

n
o
i
t
a
i
v
e
d

d
r
a
d
n
a
t
S

8
7
6
5
4
3
2
1
0

×102

n
l
a
m

i
t
p
O

5

4

3

2

1

0

50

100

0

50

100

Cost ratio r

(b)

Cost ratio r

(c)

Figure 3: Characteristics of optimal mixed-strategy solutions for MajorityCut protocols (ε = 2−40. The bandwidth
overhead is measured in units. A unit cost is that of evaluating a evaluation-circuit. The standard deviation chart
applies to both the overall cost and e.)

circuits for the evaluator to check, and if all succeed, the
evaluator opens a commitment to the output. Although
a different order, the modiﬁcations noted above seem to
apply without the need to modify the security proof.

The protocols of Lindell and Pinkas [17] and she-
lat and Shen [27], however, seem to require more sub-
tle modiﬁcations and new security arguments to use our
technique.
In both cases, the protocols use a special
oblivious transfer (instead of coin-tossing) to allow the
evaluator to independently choose the set of check cir-
cuits.
In the case of [17], the fact that the size of the
set of checked circuits is ﬁxed, and therefore veriﬁable
by the garbler, is needed in the security proof. This re-
striction can be lifted with a variant of cut-and-choose
oblivious transfer proposed and used in Lindell’s Single-
Cut protocol [15]. For a different reason, a new security
argument will also be needed for shelat and Shen [27].

3.2 SingleCut Protocols
With SingleCut protocols, extra cryptographic mech-
anisms (e.g., a second-stage fully secure computation
as in [15] or an additive homomorphic commitment as
in [2]) are employed in order to weaken the requirement
for the soundness property.
In particular, in such pro-
tocols, it sufﬁces to ensure that at least one evaluation
circuit selected by the evaluator is not corrupted. If one
evaluation circuit is properly formed, then the evaluator
will either receive the same output from all of the evalu-
ated circuits (in which case it can accept the output since
one circuit is good), or it receives two different outputs.
In the latter case, the evaluator uses the two different au-
thenticated output labels to recover the garbler’s input,
and then evaluate the function itself.

The state-of-the-art SingleCut protocols implicitly as-
sume r = 1, in which case an honest evaluator’s best

strategy is to evaluate each garbled circuit with prob-
ability 1/2, as there is only a single way for the mali-
cious generator to win the cut-and-choose game. In real-
ity, however, r is not necessarily equal to 1. In order to
achieve ε statistical security, this strategy will lead to an
expected (cid:29)logε(cid:28)· (r + 1)/2 units of cost.
Analysis. As before, let i be the number of evalua-
tion circuits and xi is the probability that the evaluator
chooses to evaluate i circuits. An evaluator’s strategy is
denoted by xxx = {x0, . . . ,x n}. Then the cost of the cut-
and-choose scheme is n + (r− 1)∑n
Fix b, the number of incorrect circuits chosen by the
generator. The ﬁrst observation is that when the evaluator
picks e (cid:24)= b, then the generator certainly loses the game.
When e = b, recall that there are(cid:31)n
b(cid:30) different ways to
select b evaluation circuits (out of n circuits in total). As-
suming the evaluator uniform-randomly picks one of the
b(cid:30) ways, then the generator looses the cut-and-choose
(cid:31)n
b(cid:30) because it happens only
game with probability 1(cid:29)(cid:31)n

if the generator guesses all n of the evaluator’s check-
or-evaluate decisions correctly. Since the event that the
evaluator picks e = b is independent of the event that the
generator guessed all decisions correctly, the overall fail-

i=0 xi · i.

b(cid:30). As a result, the security re-

quirement can be dramatically simpliﬁed in comparison
to MajorityCut. In particular, we need that every pure
strategy for the generator, i.e., every choice of b, wins

ure probability is xb(cid:29)(cid:31)n
with probability at most ε: xb/(cid:31)n

Therefore, ﬁxing n, r and ε, the original cut-and-
choose game conﬁguration problem can be translated
into the following linear programming problem:

b(cid:30) < ε.

min
xxx

n + (r− 1)

7

n

∑

i=0

xi · i

USENIX Association  

25th USENIX Security Symposium  1091

Input: ε,r.
Output: c∗,n∗,xxx∗
1. Initialize n0 := (cid:30)logε(cid:29) and c∗ := n0 · (r + 1)/2.
2. For n := n0 to c∗ − (r− 1)(1− ε),
(a) Solve the SingleCut linear programming prob-
lem for (n,ε,r) to obtain (c,xxx) where c is the
minimal cost of LP(n,ε,r) and xxx represents the
corresponding strategy to achieve c.

(b) If (c,xxx) (cid:26)= ⊥ and c∗ > c, then (c∗,xxx∗,n∗) :=
3. Output (c,n∗,xxx∗).

(c,xxx,n).

Figure 4: Search the optimal strategy (n,xxx) for SingleCut
protocols. log(·) is base-2. c is the minimal cost, n is the
ﬁxed total number of circuits and xxx = (x0, . . . ,x n) stands
for the evaluator’s best strategy to sample e.

subject to

n

xi ≥ 0,
xi = 1,

i=0

∑
xb(cid:31)(cid:30)n
b(cid:29) < ε,

∀i ∈ {0, . . . ,n}

∀b ∈ {0, . . . ,n}.

2. If ∑i

(b) If ∑i

Next, we show that the linear programming problem
above can actually be solved highly efﬁciently thanks to
its special form. The key observation is that this linear
programming problem is in essence a special continuous
knapsack program (where the weight wi = i). In order
to minimize ∑n
i=0 xi · i, we aim to maximize xi (which is
i(cid:27) and collectively constrained by
∑n
i=0 xi = 1) for all small i’s. This leads to the following
simple greedy algorithm that solves the problem in linear
time (of n).
1. For i = 0 to n,

upper-bounded by ε ·(cid:28)n

j=0 x j, x j := 0 for

i(cid:27).
(a) Set xi := ε ·(cid:28)n
j=0 x j ≥ 1 then set xi := 1−∑i−1
all j > i, and return {xi|0 ≤ i ≤ n}.
j=0 x j < 1, return ⊥ (i.e., the problem has no fea-
sible solution); otherwise, return {xi|0 ≤ i ≤ n}.
As with the MajorityCut setting, we scan all possible
values of n to identify the best n leading to the smallest
overall cost (Figure 4). Fortunately, thanks to this highly
efﬁcient special solver, we are always able to identify the
best n within seconds for r as large as 1010.
Results. Using the search algorithm described above,
we are able to compute the ﬁxed-n, variating e optimal
randomized strategies for every ε and r. We summa-
rize the performance gains in Figure 5a. The savings
due to our approach rise steadily for r < 104 and can get
to about 10X for reasonably large r (e.g., r = 7 × 107,
which roughly corresponds to the bandwidth-based cost-
ratio for privately computing the edit distance between

two 1000-character strings). Generally, it appears that
the improvement-curves (Figure 5) for different ε share
some similarity in their shape but smaller ε results in big-
ger improvements.

Table 4 shows two example optimal strategies of Sin-
gleCut protocols for r = 10 and r = 100, respectively. We
observe that the optimal strategy exhibit some pattern:
the number of evaluation circuits with positive support
falls within [0,g] where g < n and g shrinks as r grows.
An interesting note is that e = 0 (i.e., checking all n cir-
cuits) has positive support, albeit with probability less
than 2−40 (note the “%” sign), hence preserving security.
Instead of artiﬁcially preventing e = 0 as Lindell did [15],
our solution indicates that a rational evaluator should set
e = 0 with some negligible probability to maximize its
chance to win (while keeping the expected cost low).

Table 4: Example optimal strategies for SingleCut proto-
cols. (ε = 2−40, only non-zero xis are listed)

r = 10

r = 100

n

180

i

0
1
2
3
4
5
6
7

xi as %
9· 10−11
1.64· 10−8
1.47· 10−6
8.69· 10−5
3.85· 10−3

0.14
3.95
95.91

n

65

i

0
1
2
3
4
5
6
7
8
9
10
11

xi as %
9· 10−11
5.91· 10−9
1.89· 10−7
3.97· 10−6
6.16· 10−5
7.51· 10−4
7.51· 10−3
6.33· 10−2

0.46
2.91
16.28
80.28

Saves 26.4% b/w

Saves 57.0% b/w

Figure 6 presents a closer look at various character-
istics of the optimal strategies, including expected costs
(Figure 6a), the standard deviation of the costs (which
also applies to e, Figure 6b), and the best ns associated
with those optimal strategies (Figure 6c). We note in Fig-
ure 6b that the standard deviation for SingleCut optimal
strategies are generally smaller (about half) than that for
MajorityCut strategies (Figure 3b). In addition, the ns
for the optimal strategies also exhibit a staircase effect
like in MajorityCut. This is because for any ﬁxed ε, it
does not make sense to trade in a larger n for a smaller e,

1092  25th USENIX Security Symposium 

USENIX Association

8

10

8

6

4

2

)

×

(

s
g
n
i
v
a
S
d
e
t
c
e
p
x
E

10

8

6

4

2

)

×

(

s
g
n
i
v
a
S
d
e
t
c
e
p
x
E

100

102

104

106
Cost Ratio r

108

(a) ε = 2−40

100

102

104

106
Cost Ratio r

108

(b) ε = 2−20

Figure 5: Bandwidth savings for SingleCut protocols

unless r exceeds certain discrete threshold values.
Changes to Existing Protocols. The changes needed in
protocol 3.2 of Lindell (CRYPTO, 2013) to support our
technique are standard:

• Add a step 0 to [15, Protocol 2], where an n is ﬁxed

in advance based on ε and r.

• Change step 2(b) of [15, Protocol 2] to: P2 picks
the check-set J at random so that |J| = k, where k is
randomly sampled from the distribution computable
(from n,r,ε) by the 2-step algorithm given above.

Afshar et al. [2] present a conceptually simple and ele-
gant non-interactive secure computation protocol; it uses
a cut-and-choose technique and achieves security 2−40
by sending 40 garbled circuits. Surprisingly, this can be
done in just one round. Like Lindell, they create a trap-
door which allows an evaluator to recover the garbler’s
inputs with high probability if inconsistent but valid out-
put wire-labels are obtained. However, since their proto-
col is only 1 round, the cut-and-choose is implemented
through oblivious transfer; speciﬁcally, the evaluator re-
covers a seed for all of the check circuits through OT, and
the garbler sends all circuits in its one message. In or-
der to apply our technique, we need to add extra rounds
(in order to save substantial communication costs). In-
stead of sending the full circuits in the ﬁrst message,
we change the protocol to send succinct commitments of
the circuits (thereby committing the sender) which keeps
the ﬁrst message short. In the next message, the evalua-
tor asks the garbler to send the evaluation circuits only;
and the evaluator uses its previous messages to continue
running the original protocol. We believe these modiﬁ-
cations are consistent with the security proof implicitly
given in [2]. As a result, we can run this protocol with
signiﬁcantly less communication when r > 1.

3.3 BatchedCut Protocols
The basic idea of BatchedCut is to amortize the cost of
cut-and-choose across either many protocol executions
(of the same circuit) [11, 19] or many basic gates [12, 6,
24] of a big circuit. Without loss of generality, we fo-
cus on the setting of batched execution of a single func-
tionality. Roughly speaking, the evaluator randomly se-
lects and checks k out of T circuits in total and randomly
groups the remaining circuits in buckets of size B. The
state-of-the-art can ensure correctness as long as at least
one good circuit is included in every bucket. This can ef-
fectively reduce the number of circuit copies to less than
8 (c.f. the optimal 40 without amortization [2, 15]) per
execution to ensure 2−40 security. However, optimality
of this result holds only if r = 1.
In this section, we
present our approach to optimize BatchedCut protocols
for general r values.

We note one technical complication in this setting: in
the checking stage, a bad circuit (or gate) might only be
detected by the evaluator with probability τ. Although
τ = 1 for most protocols, it can be less than 1 for some
other protocols, e.g., τ = 1/2 for [12] and τ = 1/4 for
MiniLEGO [6]. Our analysis below is generalized to ac-
count for any 0≤ τ ≤ 1. State-of-the-art BatchedCut pro-
tocols [19, 11, 12] only require one object in each bucket
to evaluate being correct, hence the focus of our analysis.
Analysis. Let N be the number of times a particular func-
tionality will be executed, T be the total number of cir-
cuits generated to realize the N executions, and let B de-
note the bucket size.

With any positive r, we want to identify parame-
ters (T,B) such that cost(T,B) is minimized over all
(T,B) conﬁgurations that satisfy the security constraint.
That is, Prfail, the overall failure probability of cut-and-
choose, should be no more than ε. Therefore, the prob-
lem reduces to the following constrained optimization

USENIX Association  

25th USENIX Security Symposium  1093

9

×109

best prior works
this work

d
a
e
h
r
e
v
o
h
t
d
i
w
d
n
a
B

1.5

1

0.5

0

n
o
i
t
a
i
v
e
d

d
r
a
d
n
a
t
S

3

2

1

0

n
l
a
m

i
t
p
O

106

104

102

0

2

4

6
Cost ratio r

8
×107

(a)

100

106

103
Cost ratio r

(b)

100

106

103
Cost ratio r

(c)

Figure 6: Characteristics of optimal mixed-strategy solutions for SingleCut protocols (ε = 2−40. The bandwidth
overhead is measured in units. A unit cost is that of evaluating a evaluation-circuit. The standard deviation chart
applies to both the overall cost and e.)

problem:

subject to

min T + (r− 1)BN

Prfail(N,B,T,τ,b) =

b

∑

i=0

Prc(N,B,T,τ,b,i)Pre(N,B,b− i)

1 and phase 2 are independent, we conclude that

Prfail(N,T,B,τ,b) < ε,

∀b ∈ {0, . . . ,T }

where b is the number of bad circuits a malicious gener-
ator chooses to inject.

Note that Prfail describes the failure across all N ex-
ecutions as follows: In the ﬁrst move of the game, the
evaluator picks T − BN circuits to open and veriﬁes all
are correct. In the second move, the evaluator randomly
partitions the BN unopened circuits into buckets of B
circuits. A failure occurs if (i) the adversary is able to
corrupt b circuits such that the ﬁrst check passes, and
(ii) there is some bucket containing only corrupted cir-
cuits. We let Prc(N,B,T,τ,b,i) denote the probability of
(i) and Pre(N,B,b) denote that of (ii).

First, as before, when i circuits are opened in the ﬁrst

phase, the garbler succeeds with probability

i(cid:30)(cid:31) T − b
T − BN − i(cid:30)(cid:29)(cid:31) T

T − BN(cid:30) .
Prc(N,B,T,τ,b,i) = (1− τ)i(cid:31)b
Here the extra (1−τ) term reﬂects the case when check-
ing a circuit can succeed with some chance even if it is
corrupt. There are T total circuits, and T − BN − i of
them can be checked. The next term, Pre reﬂects the
probability that conditioned on the ﬁrst phase passing,
the evaluator randomly assigns the remaining circuits to
buckets, and one bucket of size B contains all corrupted
circuits.
Pre(N,B,b) =0,

(1)

Pre(N,B,b) =(cid:31)b

∀0 ≤ b ≤ B
B(cid:30)(cid:29)(cid:31)BN
B(cid:30) +
b−1
∑

i=0

The ﬁrst equation holds because a garbler who corrupts
fewer than B circuits never succeeds. Finally, since phase

Pre(N − 1,B,b− i)·(cid:28) b

B−i(cid:27)(cid:28)BN−b
i (cid:27)
(cid:28)BN
B(cid:27)

(2)

The summation over i occurs because every check only
succeeds with probability τ, and thus even after i checks
on corrupted circuits, b−i corrupted circuits may remain
in the second phase.

Having explained the constraint, Figure 7 describes
our search algorithm to solve the BatchedCut parame-
ter optimization problem. The basic idea is simple—for
every B = 2,3, . . ., ﬁnd the least T such that the security
constraint is satisﬁed for every b ∈ {0, . . . ,T }. Our main
contribution here is to make the search efﬁcient enough
for realistic r,N, and ε, which is achieved based on a new
efﬁcient and accurate way to calculate Prfail and the fol-
lowing observations to ensure efﬁciency and complete-
ness of the search:
1. For every B, the cost cost(T,B) strictly increases with
T while the failure rate Prfail strictly decreases with
T . So the best T for a given B can be identiﬁed ef-
ﬁciently using a combination of exponential backoff
and binary search.

2. The constraint that Prfail < ε regardless of the at-
tacker’s strategy can be veriﬁed by computing Prfail
for every b ∈ {1, . . . ,T } (where b is the number of
corrupted circuits generated by the attacker), which, if
naively implemented, would require computing Prfail
T · T times for every B. We can leverage the idea of
generating functions to reduce it to T +T inexpensive
operations (we will detail this in a bit).

3. Assuming c = (T − BN)/T > c0 (where c0 is a small
positive constant determined solely by the evalua-
tor), it does not make sense for a malicious gener-
ator to insert more than bu = −(s + 1)/log(c0/2 +
2/(1−c0)−i0/N ) bad circuits. We shall prove this obser-

2

1094  25th USENIX Security Symposium 

USENIX Association

10

vation as Claim 2. This observation further reduces
T + T down to bu + bu inexpensive operations.

4. Assuming (T − BN)/T > c0, a smaller feasible T
identiﬁed during the search stipulates an upper-bound
on the Bs that needs to be examined.

Compute Prfail Efﬁciently. For every N,B,T,τ,b, the
probability of a malicious generator’s successful attack
can be described by equations described above. How-
ever, for most N,T values (e.g., N > 215), it is infea-
sible to compute Prc (which involves calculating large
binomial coefﬁcients) and Pre (which involves exponen-
tial number of slow recursions) accurately based on (3.3)
and (2).

Hence, we propose an efﬁcient way to compute Pre

and Prc with provable accuracy.
1. Compute Pre(N,B,b). The idea is to use generating
functions to efﬁciently calculate Pre as the ratio be-
tween the number of ways to group garbled circuits
into buckets that will result a failure (i.e., at least
one bucket is ﬁlled with all B bad circuits) and the
total number of ways to group the garbled circuits.
First, we use function g(x,y) = (1 + x)B + (y− 1)xB
to model the circuit assignment process for a sin-
gle bucket, where ‘x’ denotes a “bad” gate and ‘1’
denotes a “good” gate, thus the coefﬁcient of xi in
g(x,y) equals to the number of ways to assign i bad
gates to a bucket. Note that the symbol ‘y’ we in-
tentionally introduce as the coefﬁcient of xB term
of g(x,y) denotes the event that “all B gates in a
bucket are bad”. Next, we use the generating func-
tion G(x,y) =g(x ,y)N to model the circuit assign-
ment process over all of the N buckets:
the coefﬁ-
cient of xi (which is a polynomial in y, hence writ-
ten as fi(y)) in G(x,y) denotes the number of assign-
ments involving i bad gates. Let fi(y) = ∑∞
j=0 c jy j
(where c j are constants efﬁciently computable from
G(x,y)), then fb(1) = ∑∞
j=0 c j is the total number of
assignments with b bad gates used in the evaluation
stage; and fb(1)− fb(0) = ∑∞
j=1 c j is the number of
assignments (among all with b bad circuits) that re-
sult in at least one broken bucket. Hence, we compute
Pre(N,B,b) = ( fb(1)− fb(0))/ fb(1). Further, we can
dramatically reduce the cost of computing the coef-
ﬁcients of G(x,y) by not distinguishing any terms y j1
and y j2 for any j1, j2 ≥ 1. That is, multiplying (u+vy)
and (w +ty) yields uw + (ut + vw + vt)y, hence, how-
ever big N and B are, fi(y)s are linear formulas in y.
2. Compute Prc(N,B,T,τ,b,i). Recall that typically
T,N are large while b,i are far smaller than N. So
the dominating cost in computing Prc is to calcu-

T−BN−i(cid:30)(cid:29)(cid:31) T

late(cid:31) T−b
Prc(N,B,T,τ,b,i) using (cid:31) T−BN

T−BN(cid:30). To this end, we approximate
(cid:30)i(cid:31) BN
T−i(cid:30)b−i, whose

high accuracy is formally proved in Claim 1.

T

To illustrate the precision of the above calculation, e.g.,
when s = 40, if N = 50,000, the overall error in our cal-
culation of logPrfail(N,B,T,τ,b) is less than 1. Note the
error only decreases as N grows (following Claim 1 and
Claim 2).

Claim 1 Let T,B,N,b,i be deﬁned as above. Then

lim

T − i(cid:27)b−i

Claim 2 Let Prfail(N,B,T,τ,b) be the probability that
the cut-and-choose game fails in a BatchedCut scheme
For every ε, c0 =
(with b bad circuits up-front).

T (cid:27)i(cid:28) BN

T−BN−i(cid:30)
N→∞(cid:31) T−b
T−BN(cid:30) =(cid:28) T − BN
(cid:31) T
(T − BN)/T,τ > 0, if N > i0(cid:29)(cid:26) B
b > −((cid:28)logε(cid:27) + 1)(cid:29)log(cid:26)(1− τ)c0 +

then Prfail(N,B,T,τ,b) < ε.

1−(1−τ)c0(cid:25) and
B/(1−c0)−i0/N(cid:25) ,

1−c0 −

.

B

B

Last, we also considered employing mixed strategies
for BatchedCut protocols (i.e., ﬁxing T to some public
value up-front while randomizing the selection of B) to
further reduce the cost. However, our analysis show that
the extra improvement brought by randomized strate-
gies is very small in this setting. This is consistent with
our intuition: (1) It only makes sense to alternate B be-
tween two consecutive integers, which can be derived
as a corollary of [12, Lemma 9]; (2) The strategy with
smaller B is almost dominated by the one with larger B
such that mixing them brings little extra beneﬁt. There-
fore, we opt to avoid using randomized strategies for
BatchedCut protocols.
Results. Figure 8 depicts the improvements induced by
the reﬁned cost model for cut-and-choose. In this sce-
nario, our search algorithm is able to identify the optimal
pure strategies for r up to 105, assuming the check rate c
is always larger than 0.02. We note that the optimal strat-
egy (characterized by (T,B) pairs) does not change much
for 105 < r (cid:26) ∞. Experimental results show that roughly
20 ∼ 80% performance gain can be achieved (while the
exact improvement depends on r, ε and N). Note the ef-
fects of the bad circuits detection rate τ on the beneﬁts
of our approach (through comparing Figure 8a and 8b).
Changes to Existing Protocols. In this case, because we
do not use randomized strategies, our proposal applied
to the BatchedCut scenario requires no protocol changes
other than setup the public parameters to the suggested
value output by our search algorithm.

4 Beneﬁts in Time

Recall that circuit checking will result in negligible net-
work trafﬁc because only a short circuit seed and a circuit

USENIX Association  

25th USENIX Security Symposium  1095

11

Input: ε,N, c0.
Output: T∗,B∗
1. Choose bu and Bu.

2 +

2/(1−c0)−i0/N )

(a) Let s = (cid:30)logε(cid:29). Compute i0 := s + 2 and bu := −(s + 1)(cid:31)log( c0
(b) Set T∗ := ∞ and Bu := ∞.
2. For B ranging from 2 to Bu,
(a) Precompute Pre(N,B,b) =1 − fb(0)/ fb(1) for every b ∈ [B,bu].
(b) Find the smallest T , call it TB, such that T < T∗ and Prfail(N,B,TB,τ,b) < ε for all b ≤ bu, using exponential
backoff and binary search. (Note that Prfail(N,B,T,τ,b) monotonically decreases with T while the cost T +
NB(r− 1) monotonically increases with T .)

(c) If T∗ + NB∗(r− 1) > TB + NB(r− 1), then update T∗ := TB, B∗ := B, and Bu := (cid:30)(1− c0)TB/N(cid:29).
3. Output T∗,B∗.

2

)

×

(

s
g
n
i
v
a
S
d
e
t
c
e
p
x
E

1.8

1.6

1.4

1.2

1

Figure 7: Find cost-efﬁcient (T,B) for BatchedCut protocols.

N = 100
N = 200
N = 10000

)

×

(

s
g
n
i
v
a
S
d
e
t
c
e
p
x
E

1.6

1.4

1.2

1

N = 100
N = 200
N = 10000

101

102
103
Cost Ratio r

104

105

101

102
103
Cost Ratio r

104

105

(a) τ = 1 (applicable to [15, 4])

(b) τ = 1/2 (applicable to [12])

Figure 8: Bandwidth savings for BatchedCut protocols (ε = 2−40 and the check ratio c ≥ 0.02)

hash needs to be transferred. This gap in bandwidth over-
head also leads to a substantial gap in execution speeds,
due to the signiﬁcant difference in the throughputs of gar-
bling/checking (about 50 ns/gate on a single-core proces-
sor) and that of network transmission (typically a wide
range of 50∼3000 ns/gate).
To evaluate the beneﬁt of our technique in terms of
time, we modiﬁed OblivC [29] to measure the ratios of
speed for circuit evaluation and circuit checking tasks
in various network settings. Our test implementation
utilizes Intel AES-NI instructions and the half-gate gar-
bling technique [30] to minimize bandwidth usage, and
SHA256 implementation provided by Libgcrypt for cir-
cuit hashing. In circuit checking tasks, the circuit gen-
erator garbles a number of circuits but sends only a
(Seed,Hash) pair for each garbled circuit, while the cir-
cuit veriﬁer re-computes the hash from the seed for each
circuit. We record the per circuit time cost for this task
as Tc. For circuit evaluation tasks, the circuit generator
garbles a number of circuits and sends the garbled gates
to the evaluator, who not only evaluates, but also com-
putes the hash of the received circuit. We record the per
circuit time cost for this task as Te. (In both tasks, the two

ends work in a pipelined fashion.) Thus, the time cost ra-
tios between evaluation and checking can be calculated
as (Tc + Te)/(2Tc) (recall that every circuits will be gen-
erated twice, once for commiting their hashes and once
for check/evaluate to avoid storing the typically gigantic
circuits).

We used a benchmark circuit (provided by OblivC)
with 31× 106 non-free gates. Our exepriments were run
on two Amazon EC2 boxes (instance type: c4.large,
$0.105/hour,
Intel Xeon E5-2666, 2.9GHz, 3.75GB
memory) with Ubuntu 14.04 Server edition in the VA re-
gion.

We detail our experimental results in Table 5. The r
values (in terms of wall-clock time) range from a lit-
tle over 1 (with high speed connection) to 30 (with
ordinary home-to-home connections). Such time gaps
can be well-explained by the difference in the through-
puts of computation and communication. The observed
speedups of the proposed cut-and-choose technique can
range from 12% up to 106%. Note that our approach
yields no noticeable time savings for the settings of run-
ning SingleCut or BatchedCut protocols in a 1 Gbps
LAN with single-core processors (compared to the their

1096  25th USENIX Security Symposium 

USENIX Association

12

state-of-the-art couterparts), because the cost ratio r is
already very close to 1.

We note that due to the use of SHA256 in computing
circuit hashes, we observe only 2.23× 106 gates/second
for circuit veriﬁcation while 1.30× 106 gates/second for
circuit evaluation.
It would be interesting to replace
SHA256 with some hashing algorithm that leverages
AES-NI instructions to match up with the speed of AES-
NI based garbling (more than 109 gates/second, as was
reported in [3]). That will imply a time ratio up to 100×
larger than we observe in our experiments.

Table 5: Timing gaps between circuit evaluation and ver-
iﬁcation and our speedup beneﬁts (measurements taken
from 10 runs with 0.1% relative standard deviation) for a
31m gate circuit.

LAN
1 Gbps

WAN

100 Mbps

WAN

10 Mbps

Te (seconds)
Tc (seconds)

r

p
u
d
e
e
p
S

MajorityCut
SingleCut
BatchedCut

24.1
13.9
1.37

12%
0%
0%

103.5
13.9
4.22

26%
13%
14%

818
13.9
29.9

106%
76%
41%

5 Conclusion

The state-of-the-art design of cut-and-choose protocols
considers an overly simpliﬁed cost model, and does not
exploit the opportunity of dynamically variating e to
thwart cheating adversaries. We have shown, through
experiments, the dramatic gap in the bandwidth costs be-
tween circuit evaluation and circuit veriﬁcation. We re-
visit the cut-and-choose protocol design problem in a re-
ﬁned cost model and give three highly efﬁcient solvers,
one for each class of cut-and-choose protocols, that out-
put the best strategy for a particular cost ratio in our
model. Simulation results show that our approach bring
signiﬁcant savings in bandwidth cost, as well as sub-
stantial speedups (especially when running secure com-
putation protocols outside idealized laboratory environ-
ments). Most importantly, the beneﬁts require very small
changes to existing protocols and come completely from
formal proofs that do not depend on any unprovable as-
sumptions.

6 Acknowledgments

We thank Yuan Zhou (MIT) and Zhilei Xu (MIT) for in-
spiring discussions on cut-and-choose. We also appre-

ciate Xiao Wang (Maryland)’s advice on benchmarking
state-of-the-art garbled circuit implementations. Work
of Ruiyu Zhu and Yan Huang was supported by NSF
award #1464113. Work of Jonathan Katz was supported
in part by NSF award #1111599. Work of shelat was sup-
ported in part by NSF grants TC-0939718, TC-1111781,
and 1618559, a Microsoft Faculty Fellowship, and a
Google Faculty Research Award.

References

[1] A. Afshar, Z. Hu, P. Mohassel, and M. Rosulek.
How to efﬁciently evaluate RAM programs with
malicious security. EUROCRYPT, 2015.

[2] A. Afshar, P. Mohassel, B. Pinkas, and B. Riva.
Non-interactive secure computation based on cut-
and-choose. EUROCRYPT, 2014.

[3] M. Bellare, V. T. Hoang, S. Keelveedhi, and P. Ro-
gaway. Efﬁcient garbling from a ﬁxed-key block-
cipher. IEEE Symposium on Security and Privacy,
2013.

[4] L. T. A. N. Brand˜ao. Secure two-party compu-
tation with reusable bit-commitments, via a cut-
and-choose with forge-and-lose technique. ASI-
ACRYPT, 2013.

[5] N. Buescher and S. Katzenbeisser. Faster secure
computation through automatic parallelization. In
USENIX Security Symposium, Aug. 2015.

[6] T. K. Frederiksen, T. P. Jakobsen, J. B. Nielsen, P. S.
Nordholt, and C. Orlandi. MiniLEGO: Efﬁcient se-
cure two-party computation from general assump-
tions. EUROCRYPT, 2013.

[7] V. Goyal, P. Mohassel, and A. Smith. Efﬁcient two
party and multi party computation against covert
adversaries. Cryptology EUROCRYPT, 2008.

[8] S. Gureron, Y. Lindell, A. Nof, and B. Pinkas. Fast
garbling of circuits under standard assumptions.
Computer and Communications Security, 2015.

[9] Y. Huang, D. Evans, J. Katz, and L. Malka. Faster
secure two-party computation using garbled cir-
cuits. In USENIX Security Symposium, 2011.

[10] Y. Huang, J. Katz, and D. Evans. Efﬁcient se-
cure two-party computation using symmetric cut-
and-choose. CRYPTO, 2013.

[11] Y. Huang, J. Katz, V. Kolesnikov, R. Kumaresan,
and A. J. Malozemoff. Amortizing garbled circuits.
CRYPTO, 2014.

[12] Y. Huang and R. Zhu. Revisiting LEGOs: Op-
timizations, analysis, and their limit. Cryptology
ePrint Archive, Report 2015/1038, 2015. http:
//eprint.iacr.org/2015/1038.

USENIX Association  

25th USENIX Security Symposium  1097

13

[13] N. Husted, S. Myers, A. Shelat, and P. Grubbs.
Gpu and cpu parallelization of honest-but-curious
secure two-party computation. Annual Computer
Security Applications Conference, 2013.

[14] B. Kreuter, A. Shelat, and C. hao Shen. Billion-gate
secure computation with malicious adversaries. In
USENIX Security Symposium, 2012.

[15] Y. Lindell. Fast cut-and-choose based protocols for
malicious and covert adversaries. CRYPTO, 2013.
[16] Y. Lindell and B. Pinkas. An efﬁcient protocol
for secure two-party computation in the presence
of malicious adversaries. EUROCRYPT, 2007.

[17] Y. Lindell and B. Pinkas. Secure two-party compu-
tation via cut-and-choose oblivious transfer. Jour-
nal of Cryptology, 25(4):680–722, Oct. 2012.

[18] Y. Lindell, B. Pinkas, and N. P. Smart. Implement-
ing two-party computation efﬁciently with security
against malicious adversaries. Security in Commu-
nication Networks, 2008.

[19] Y. Lindell and B. Riva. Cut-and-choose Yao-based
secure computation in the online/ofﬂine and batch
settings. CRYPTO, 2014.

[20] Y. Lindell and B. Riva. Blazing fast 2pc in the of-
ﬂine/online setting with security for malicious ad-
versaries. Computer and Communication Security,
2015.

[21] C. Liu, X. S. Wang, K. Nayak, Y. Huang, and
E. Shi. ObliVM: A programming framework for
secure computation. In IEEE Symposium on Secu-
rity and Privacy, 2015.

[22] P. Mohassel and B. Riva. Garbled circuits check-
ing garbled circuits: More efﬁcient and secure two-
party computation. CRYPTO, 2013.

[23] K. Nayak, X. S. Wang, S. Ioannidis, U. Weinsberg,
N. Taft, and E. Shi. GraphSC: Parallel secure com-
putation made easy. In IEEE Symposium on Secu-
rity and Privacy, 2015.

[24] J. B. Nielsen and C. Orlandi. LEGO for two-party
secure computation. Theory of Cryptography Con-
ference, 2009.

[25] B. Pinkas, T. Schneider, N. P. Smart, and S. C.
Williams. Secure two-party computation is prac-
tical. ASIACRYPT, 2009.

[26] a. shelat and C.-H. Shen. Two-output secure com-
putation with malicious adversaries. EUROCRYPT,
2011.

[27] a. shelat and C.-H. Shen. Fast two-party secure
computation with minimal assumptions. Computer
and Communications Security, 2013.

[28] D. P. Woodruff. Revisiting the efﬁciency of mali-
cious two-party computation. EUROCRYPT, 2007.
[29] S. Zahur and D. Evans. Obliv-c: A language for

extensible data-oblivious computation.

[30] S. Zahur, M. Rosulek, and D. Evans. Two halves
make a whole - reducing data transfer in garbled
circuits using half gates. EUROCRYPT, 2015.

[31] N. Smart.

https://www.cs.bris.ac.uk/
Research/CryptographySecurity/MPC/. Ac-
cessed on Feb 13, 2016.

1098  25th USENIX Security Symposium 

USENIX Association

14

A Proofs

Claim 1 Let T,B,N,b,i be deﬁned as above. Then

Proof

There exists N0 such that if N > N0,

(cid:31) T−b
T−BN−i(cid:30)
(cid:31) T
T−BN(cid:30) =

T (cid:28)i(cid:29) BN

T − i(cid:28)b−i

.

lim

T−BN−i(cid:30)
N→∞(cid:31) T−b
T−BN(cid:30) =(cid:29) T − BN
(cid:31) T
(T − b)!(T − BN)!(BN)!

·

=

=

(T − b + 1)···T

T !(T − BN − i)!(BN − b + i)!
((T − BN − i + 1)···(T − BN))((BN − b + i + 1)···BN )
(BN − b + i + 1)···BN
(T − BN − i + 1)···(T − BN)
(T − b + 1)···(T − i)
(T − i + 1)···T
T (cid:28)i(cid:29) BN
≤(cid:29) T − BN
T − i(cid:28)b−i
(cid:31) T−b
T−BN−i(cid:30)
T−BN(cid:30) ≥(cid:29) T − BN − i + 1
(cid:31) T

T − i + 1 (cid:28)i(cid:29) BN − b + i + 1

T − b + 1 (cid:28)b−i

(cid:31) U.

(cid:31) L.

Similarly, we have, there exists N1 such that if N > N1,

So, we know that, for sufﬁciently large N,

U(cid:27)(cid:31) T−b
T−BN−i(cid:30)
(cid:31) T
T−BN(cid:30)

T − b + 1

T − i (cid:28)b−i

≤

U
L

T − BN

=(cid:29)

T − BN − i + 1 ·

(cid:28)i(cid:29)
T − i + 1
(cid:25)i
= (cid:26) (T − BN)T − (i− 1)T + (i− 1)BN

T

BN

BN − b + i + 1 ·
·

(BN − b + i + 1)(T − i)

(T − BN)T − (i− 1)T
(cid:25)b−i
(cid:26) (BN − b + i + 1)(T − i) + (b− i− 1)(T − BN − i)
(T − BN)T − (i− 1)T )(cid:25)i(cid:26)1 +
(BN − b + i + 1)(T − i)(cid:25)b−i
= (cid:26)1 +
(i− 1)BN
(b− i− 1)(T − BN − i)
T − BN − i + 1(cid:28)i(cid:29)1 +
≤ (cid:29)1 +
T − BN − i + 1(cid:28)i(cid:29)1 +
≤ (cid:29)1 +
T−BN−i+1(cid:30)i(cid:31)1 + b−1
BN−b+1(cid:30)b

BN − b + i + 1(cid:28)b−i
BN − b + 1(cid:28)b

b− i− 1

b− 1

i− 1

i− 1

i−1

= 1.

Note that the inequality (3) holds because T > BN. Thanks to the upper-bound of b (Claim 2) and hence on i (recall

Claim 2 Let Prfail(N,B,T,τ,b) be the probability that the cut-and-choose game fails in a BatchedCut scheme (with

i ≤ b), limN→∞(cid:31)1 +
b bad circuits up-front). For every ε, c0 = (T − BN)/T,τ > 0, if N > i0(cid:24)(cid:23) B
1)(cid:24)log(cid:23)(1− τ)c0 +

1−(1−τ)c0(cid:22) and b > −((cid:26)logε(cid:25) +
Let 0 < τ ≤ 1 be the probability that P2 detects the abnormality in checking garbled gate g conditioned on g

1−c0 −

B

Proof
is indeed bad. We have

B

B/(1−c0)−i0/N(cid:22) , then Prfail(N,B,T,τ,b) < ε.
i(cid:30)(cid:31) T−b
T−BN−i(cid:30)
(cid:31) T
T−BN(cid:30)

(1− τ)i(cid:31)b

Prfail(N,b) =

∑

i=0

b

Pre(N,b− i)

15

USENIX Association  

25th USENIX Security Symposium  1099

(3)

(4)

where (1−τ)i(cid:31)b
stage with i bad gates selected for veriﬁcation (but P2 fails to detect any of them). Because there exists i0 such that
(1− τ)i0 < ε/2,

T−BN−i(cid:30)(cid:29)(cid:31) T
i(cid:30)(cid:31) T−b

Prfail(N,b) =

=

≤

≤

≤

≤

≤

≤

≤

i=0

i=0

i=0

i=0

b

∑
i0∑
i0∑
i0∑
i0∑
i0∑
i0∑
i0∑
i0∑

i=0

i=0

i=0

i=0

i=0
b

b

b

b

b

ε
2

∑
i=i0+1

Pre(N,b− i)

Pre(N,b− i)

Pre(N,b− i)

Pre(N,b− i) +

Pre(N,b− i) +

Pre(N,b− i) +

i(cid:30)(cid:31) T−b
T−BN−i(cid:30)
(1− τ)i(cid:31)b
T−BN(cid:30)
(cid:31) T
i(cid:30)(cid:31) T−b
T−BN−i(cid:30)
i=i0+1(cid:31)b
∑
Pre(N,b− i) + (1− τ)i0
T−BN(cid:30)
(cid:31) T
i(cid:30)(cid:31) T−b
i=i0+1(cid:31)b
T−BN−i(cid:30)
∑
T−BN(cid:30)
(cid:31) T
i=1(cid:31)b
T−BN−i(cid:30)
i(cid:30)(cid:31) T−b
∑
T−BN(cid:30)
(cid:31) T
ε
2 · 1

T−BN(cid:30) is the probability that P1 who generates b bad gates survives the gate veriﬁcation
(1− τ)i(cid:31)b
i(cid:30)(cid:31) T−b
T−BN−i(cid:30)
(cid:31) T
T−BN(cid:30)
(1− τ)i(cid:31)b
i(cid:30)(cid:31) T−b
T−BN−i(cid:30)
T−BN(cid:30)
(cid:31) T
(1− τ)i(cid:31)b
i(cid:30)(cid:31) T−b
T−BN−i(cid:30)
T−BN(cid:30)
(cid:31) T
(1− τ)i(cid:31)b
i(cid:30)(cid:31) T−b
T−BN−i(cid:30)
T−BN(cid:30)
(cid:31) T
(1− τ)i(cid:31)b
i(cid:30)(cid:31) T−b
T−BN−i(cid:30)
T−BN(cid:30)
(cid:31) T
(1− τ)i(cid:31)b
i(cid:30)(cid:31) T−b
T−BN−i(cid:30)
Pre(N,b− i) +
(cid:31) T
T−BN(cid:30)
T (cid:27)i(cid:28) BN
(1− τ)i(cid:28)b
i(cid:27)(cid:28) T − BN
T (cid:27)i(cid:28) BN
(1− τ)i(cid:28)b
i(cid:27)(cid:28) T − BN
T (cid:27)i(cid:28) BN
i(cid:27)(cid:28) T − BN
(1− τ)i(cid:28)b
T (cid:27)i(cid:28) BN
(1− τ)i(cid:28)b
i(cid:27)(cid:28) T − BN
T − i0(cid:27)b
T − BN
T − i0(cid:27)b

Pre(N,b− i) +
ε
2
ε
2
ε
2

T − i(cid:27)b−i
T − i(cid:27)b−i
T − i0(cid:27)b−i
T − i0(cid:27)b−i

Pre(N,b) +

Pre(N,b) +

Pre(N,b) +

Pre(N,b) +

[Claim 3]

ε
2

ε
2

ε
2

B

T

T

+

+

+

i=0

≤

BN

BN

ensures

1−c0 −

T − BN
1−(1−τ)c0(cid:25)

∑
=(cid:28)(1− τ)
≤(cid:28)(1− τ)
B/(1−c0)−i0/N(cid:25) ensures (cid:26)(1− τ) T−BN
T−BN−i(cid:30)
(cid:31) T−b
T−BN(cid:30) ≤(cid:28) T − BN
(cid:31) T
(T − b)!(T − BN)!(BN)!

.

ε
2
(1 − τ) T−BN
T−i0(cid:25)b
T + BN

T (cid:27)i(cid:28) BN

T − i(cid:27)b−i

.

Thus,

N > i0(cid:29)(cid:26) B

B

1)(cid:29)log(cid:26)(1− τ)c0 +
Prfail(N,B,T,τ,b) < ε.
Claim 3 If T,N,b,i are non-negative integers such that T > BN, T ≥ b, and i ≤ b, then

T + BN
T−i0
2 ≤ 2−s.

+ ε

< 1,

while

b > −(s +
Hence, we conclude that

Proof

T−BN−i(cid:30)
(cid:31) T−b
(cid:31) T
T−BN(cid:30) =

=

T !(T − BN − i)!(BN − b + i)!
(T − BN − i + 1)···(T − BN)

(T − i + 1)···T

=(cid:24)(T − BN − i + 1)···(T − BN)(cid:23)(cid:24)(BN − b + i + 1)···BN )(cid:23)
(T − b + 1)···(T − i) ≤(cid:28) T − BN
(BN − b + i + 1)···BN

(T − b + 1)(T − b + 2)···T
T (cid:27)i(cid:28) BN

T − i(cid:27)b−i

·

1100  25th USENIX Security Symposium 

USENIX Association

16

