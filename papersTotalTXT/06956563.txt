2014 IEEE Symposium on Security and Privacy

Automated analysis of security protocols with global state

Steve Kremer

INRIA Nancy - Grand’Est & Loria, France

Robert Künnemann

Department of Computer Science, TU Darmstadt, Germany

INRIA Paris - Rocquencourt, France

Abstract—Security APIs, key servers and protocols that need
to keep the status of transactions, require to maintain a global,
non-monotonic state, e.g., in the form of a database or register.
However, existing automated veriﬁcation tools do not support
the analysis of such stateful security protocols – sometimes
because of fundamental reasons, such as the encoding of the
protocol as Horn clauses, which are inherently monotonic. An
exception is the recent tamarin prover which allows specifying
protocols as multiset rewrite (msr) rules, a formalism expressive
enough to encode state. As multiset rewriting is a “low-level”
speciﬁcation language with no direct support for concurrent
message passing, encoding protocols correctly is a difﬁcult and
error-prone process.

We propose a process calculus which is a variant of the
applied pi calculus with constructs for manipulation of a global
state by processes running in parallel. We show that this
language can be translated to msr rules whilst preserving all
security properties expressible in a dedicated ﬁrst-order logic
for security properties. The translation has been implemented
in a prototype tool which uses the tamarin prover as a backend.
We apply the tool to several case studies among which a
simpliﬁed fragment of PKCS#11, the Yubikey security token,
and an optimistic contract signing protocol.

I. INTRODUCTION

Automated analysis of security protocols has been ex-
tremely successful. Using automated tools, ﬂaws have been
for instance discovered in the Google Single Sign On
Protocol [1], in commercial security tokens implementing
the PKCS#11 standard [2], and one may also recall Lowe’s
attack [3] on the Needham-Schroeder public key protocol
17 years after its publication. While efﬁcient tools such as
ProVerif [4], AVISPA [5] or Maude-NPA [6] exist, these
tools fail to analyze protocols that require non-monotonic
global state, i.e., some database, register or memory location
that can be read and altered by different parallel threads. In
particular ProVerif, one of the most efﬁcient and widely used
protocol analysis tools, relies on an abstraction that encodes
protocols in ﬁrst-order Horn clauses. This abstraction is
well suited for the monotonic knowledge of an attacker
(who never forgets), makes the tool extremely efﬁcient for
verifying an unbounded number of protocol sessions and
allows to build on existing techniques for Horn clause
resolution. However, Horn clauses are inherently monotonic:
once a fact is true it cannot be set to false anymore. As
a result, even though ProVerif’s input language, a variant

The full version of this paper including all proofs is available at http:

//sapic.gforge.inria.fr/

© 2014, Steve Kremer. Under license to IEEE.
DOI 10.1109/SP.2014.18

163

of the applied pi calculus [7], allows a priori encodings of
a global memory, the abstractions performed by ProVerif
introduce false attacks. In the ProVerif user manual [8,
Section 6.3.3] such an encoding of memory cells and its
limitations are indeed explicitly discussed: “Due to the
abstractions performed by ProVerif, such a cell is treated
in an approximate way: all values written in the cell are
considered as a set, and when one reads the cell, ProVerif
just guarantees that the obtained value is one of the written
values (not necessarily the last one, and not necessarily one
written before the read).”

A prominent example where non-monotonic global state
appears are security APIs, such as the RSA PKCS#11
standard [9], IBM’s CCA [10] or the trusted platform module
(TPM) [11]. They have been known to be vulnerable to
logical attacks for some time [12], [13] and formal analysis
has shown to be a valuable tool to identify attacks and
ﬁnd secure conﬁgurations. One promising paradigm for
analyzing security APIs is to regard them as a participant
in a protocol and use existing analysis tools. However, Her-
zog [14] already identiﬁed not accounting for mutable global
state as a major barrier to the application of security protocol
analysis tools to verify security APIs. Apart from security
APIs many other protocols need to maintain databases: key
servers need to store the status of keys, in optimistic contract
signing protocols a trusted party maintains the status of a
contract, RFID protocols maintain the status of tags and
more generally websites may need to store the current status
of transactions.

Our contributions: We propose a tool for analyzing
protocols that may involve non-monotonic global state, rely-
ing on Schmidt et al.’s tamarin tool [15], [16] as a backend.
We designed a new process calculus that extends the applied
pi calculus by deﬁning, in addition to the usual constructs
for specifying concurrent processes, constructs for explicitly
manipulating global state. This calculus serves as the tool’s
input language. The heart of our tool is a translation from
this extended applied pi calculus to a set of multiset rewrite
rules that can then be analyzed by tamarin which we use
as a backend. We prove the correctness of this translation
and show that it preserves all properties expressible in a
dedicated ﬁrst order logic for expressing security properties.
As a result, relying on the tamarin prover, we can analyze
protocols without bounding the number of sessions, nor
making any abstractions. Moreover it allows to model a

tamarin may not

terminate. However,

wide range of cryptographic primitives by the means of
equational theories. As the underlying veriﬁcation problem
is undecidable,
it
offers an interactive mode with a GUI which allows to
manually guide the tool in its proof. Our speciﬁcation lan-
guage includes support for private channels, global state and
locking mechanisms (which are crucial to write meaningful
programs in which concurrent threads manipulate a common
memory). The translation has been carefully engineered in
order to favor termination by tamarin. We illustrate the tool
on several case studies: a simple security API in the style
of PKCS#11, a complex case study of the Yubikey security
device, as well as several examples analyzed by other tools
that aim at analyzing stateful protocols. In all of these case
studies we were able to avoid restrictions that were necessary
in previous works.

Related work: The most closely related work is the
StatVerif tool by Arapinis et al. [17]. They propose an
extension of the applied pi calculus, similar to ours, which
is translated to Horn clauses and analyzed by the ProVerif
tool. Their translation is sound but allows for false attacks,
limiting the scope of protocols that can be analyzed. More-
over, StatVerif can only handle a ﬁnite number of memory
cells: when analyzing an optimistic contract signing protocol
this appeared to be a limitation and only the status of a
single contract was modeled, providing a manual proof to
justify the correctness of this abstraction. Finally, StatVerif is
limited to the veriﬁcation of secrecy properties. As illustrated
by the Yubikey case study, our work is more general and
we are able to analyze complex injective correspondance
properties.

Mödersheim [18] proposed a language with support for
sets together with an abstraction where all objects that
belong to the same sets are identiﬁed. His language, which is
an extension of the low level AVISPA intermediate format, is
compiled into Horn clauses that are then analyzed, e. g., us-
ing ProVerif. His approach is tightly linked to this particular
abstraction limiting the scope of applicability. Mödersheim
also discusses the need for a more high-level speciﬁcation
level which we provide in this work.

There has also been work tailored to particular applica-
tions. In [19], Delaune et al. show by a dedicated hand proof
that for analyzing PKCS#11 one may bound the message
size. Their analysis still requires to artiﬁcially bound the
number of keys. Similarly in spirit, Delaune et al. [20] give
a dedicated result for analyzing protocols based on the TPM
and its registers. However, the number of reboots (which
reinitialize registers) needs to be limited.

Guttman [21] also extended the strand space model by
adding support for state. While the protocol execution is
modeled using the classical strand spaces model, state is
modeled by a multiset of facts, and manipulated by multiset
rewrite rules. The extended model has been used for analyz-
ing by hand an optimistic contract signing protocol. As of

now, protocol analysis in the strand space model with state
has not been mechanized yet.

In the goal of relating different approaches for protocol
analysis Bistarelli et al. [22] also proposed a translation from
a process algebra to multiset rewriting: they do however
not consider private channels, have no support for global
state and assume that processes have a particular structure.
These limitations signiﬁcantly simplify the translation and
its correctness proof. Moreover their work does not include
any tool support for automated veriﬁcation.

Obviously any protocol that we are able to analyze can
be directly analyzed by the tamarin prover [15], [16] as the
rules produced by our translation could have been given
directly as an input to tamarin. Indeed, tamarin has already
been used for analyzing a model of the Yubikey device [23],
the case studies presented with Mödersheim’s abstraction, as
well as those presented with StatVerif. It is furthermore able
to reproduce the aforementioned results on PKCS#11 [19]
and the TPM [20] – moreover, it does so without bounding
the number of keys, security devices, reboots, etc. Contrary
to ProVerif, tamarin sometimes requires additional typing
lemmas which are used to guide the proof. These lemmas
need to be written by hand (but are proved automatically).
In our case studies we also needed to provide a few such
lemmas manually. In our opinion, an important disadvan-
tage of tamarin is that protocols are modeled as a set
of multiset rewrite rules. This representations is very low
level and far away from actual protocol implementations,
making it very difﬁcult to model a protocol adequately.
Encoding private channels, nested replications and locking
mechanisms directly as multiset rewrite rules is a tricky
and error prone task. As a result we observed that,
in
practice,
the protocol models tend to be simpliﬁed. For
instance, locking mechanisms are often omitted, modeling
protocol steps as a single rule and making them effectively
atomic. Such more abstract models may obscure issues in
concurrent protocol steps and increase the risk of implicitly
excluding attacks in the model that are well possible in a real
implementation, e. g., race conditions. Using a more high-
level speciﬁcation language, such as our process calculus,
arguably eases protocol speciﬁcation and overcomes some
of these risks.

II. PRELIMINARIES

Terms and equational theories: As usual in symbolic
protocol analysis we model messages by abstract terms.
Therefore we deﬁne an order-sorted term algebra with the
sort msg and two incomparable subsorts pub and fresh. For
each of these subsorts we assume a countably inﬁnite set
of names, FN for fresh names and PN for public names.
Fresh names will be used to model cryptographic keys and
nonces while public names model publicly known values.
We furthermore assume a countably inﬁnite set of variables
for each sort s, Vs and let V be the union of the set of

164

variables for all sorts. We write u : s when the name or
variable u is of sort s. Let Σ be a signature, i.e., a set of
function symbols, each with an arity. We write f /n when
function symbol f is of arity n. We denote by TΣ the set
of well-sorted terms built over Σ, PN , FN and V. For a
term t we denote by names(t), respectively vars(t) the set
of names, respectively variables, appearing in t. The set of
ground terms, i.e., terms without variables, is denoted by
MΣ. When Σ is ﬁxed or clear from the context we often
omit it and simply write T for TΣ and M for MΣ.

We equip the term algebra with an equational theory
E, that is a ﬁnite set of equations of the form M = N
where M, N ∈ T . From the equational theory we deﬁne
the binary relation =E on terms, which is the smallest
equivalence relation containing equations in E that is closed
under application of function symbols, bijective renaming
of names and substitution of variables by terms of the same
sort. Furthermore, we require E to distinguish different fresh
names, i. e., ∀a, b ∈ FN : a (cid:4)= b ⇒ a (cid:4)=E b.
Example. Symmetric encryption can be modelled using a
signature

Σ = { senc/2, sdec/2, encCor /2, true/0}

and an equational theory deﬁned by

sdec(senc(m, k), k) = m encCor (senc(x, y), y) = true

The last equation allows to check whether a term can be
correctly decrypted with a certain key.

For the rest of the paper we assume that E refers to
some ﬁxed equational theory and that the signature and
equational
theory always contain symbols and equations
for pairing and projection, i.e., {(cid:6)., .(cid:7), fst, snd} ⊆ Σ and
equations fst((cid:6)x, y(cid:7)) = x and snd((cid:6)x, y(cid:7)) = y are in E.
We will sometimes use (cid:6)x1, x2, . . . , xn(cid:7) as a shortcut for
(cid:6)x1,(cid:6)x2,(cid:6). . . ,(cid:6)xn−1, xn(cid:7) . . .(cid:7).
We also use the usual notion of positions for terms. A
position p is a sequence of positive integers and t|p denotes
the subterm of t at position p.

Facts: We also assume an unsorted signature Σfact,

disjoint from Σ. The set of facts is deﬁned as

F := {F (t1, . . . , tk) | ti ∈ TΣ, F ∈ Σfact of arity k}.

Facts will be used both to annotate protocols, by the means
of events, and for deﬁning multiset rewrite rules. We par-
into linear and persistent fact
tition the signature Σfact
symbols. We suppose that Σfact always contains a unary,
persistent symbol !K and a linear, unary symbol Fr. Given
a sequence or set of facts S we denote by lfacts(S) the
multiset of all linear facts in S and pfacts(S) the set of all
persistent facts in S. By notational convention facts whose
identiﬁer starts with ‘!’ will be persistent. G denotes the set
of ground facts, i.e., the set of facts that does not contain

165

variables. For a fact f we denote by ginsts(f ) the set
of ground instances of f. This notation is also lifted to
sequences and sets of facts as expected.

i.e.,

Substitutions: A substitution σ is a partial function
from variables to terms. We suppose that substitutions
are well-typed,
they only map variables of sort s
to terms of sort s, or of a subsort of s. We denote by
σ = {t1 /x1 , . . . ,tn /xn} the substitution whose domain is
D(σ) = {x1, . . . , xn} and which maps xi to ti. As usual
we homomorphically extend σ to apply to terms and facts
and use a postﬁx notation to denote its application, e.g., we
write tσ for the application of σ to the term t. A substitution
σ is grounding for a term t if tσ is ground. Given function
g we let g(x) = ⊥ when x (cid:4)∈ D(x). When g(x) = ⊥
we say that g is undeﬁned for x. We deﬁne the function
f := g[a (cid:10)→ b] with D(f ) = D(g) ∪ { a} as f (a) := b and
f (x) := g(x) for x (cid:4)= a.
Sets, sequences and multisets: We write Nn for the
set {1, . . . , n}. Given a set S we denote by S
∗ the set
of ﬁnite sequences of elements from S and by S# the
set of ﬁnite multisets of elements from S. We use the
superscript # to annotate usual multiset operation, e.g.
S1 ∪# S2 denotes the multiset union of multisets S1, S2.
Given a multiset S we denote by set(S) the set of elements
in S. The sequence consisting of elements e1, . . . , en will be
denoted by [e1, . . . , en] and the empty sequence is denoted
by []. We denote by |S| the length, i.e., the number of
elements of the sequence. We use · for the operation of
adding an element either to the start or to the end, e.g.,
e1 · [e2, e3] = [e1, e2, e3] = [e1, e2] · e3. Given a sequence
S, we denote by idx (S) the set of positions in S, i.e., Nn
when S has n elements, and for i ∈ idx (S) Si denotes the
ith element of the sequence. Set membership modulo E is
denoted by ∈E and deﬁned as e ∈E S if ∃e
=E e.
⊂E and =E are deﬁned for sets in a similar way. Application
of substitutions are lifted to sets, sequences and multisets
as expected. By abuse of notation we sometimes interpret
sequences as sets or multisets.

(cid:3) ∈ S. e

(cid:3)

III. A CRYPTOGRAPHIC PI CALCULUS

WITH EXPLICIT STATE

A. Syntax and informal semantics

Our calculus is a variant of the applied pi calculus [7].
In addition to the usual operators for concurrency, repli-
cation, communication and name creation, it offers several
constructs for reading and updating an explicit global state.
The grammar for processes is described in Figure 1.
0 denotes the terminal process. P | Q is the parallel
execution of processes P and Q and !P the replication of
P , allowing an unbounded number of sessions in protocol
executions. The construct νn; P binds the name n in P and
models the generation of a fresh, random value. Processes
out(M, N); P and in(M, N); P represent the output, respec-
tively input, of message N on channel M. Readers familiar

f(M1,. . . ,Mn) (f ∈ Σ of arity n)

(cid:6)M,N(cid:7) ::= x, y, z ∈ V
| p ∈ PN
| n ∈ FN
|
(cid:6)P ,Q(cid:7) ::= 0
| P | Q
|
|
|
|
|
|
|
|
|
|
|
|

! P
νn; P
out(M, N); P
in(M, N); P
if M=N then P [else Q]
(F ∈ F)
event F ; P
insert M,N; P
delete M; P
lookup M as x in P [else Q]
lock M; P
unlock M; P
[L] −[A]→ [R]; P

(L, R, A ∈ F∗)

Figure 1. Syntax

with the applied pi calculus [7] may note that we opted for
the possibility of pattern matching in the input construct,
rather than merely binding the input to a variable x. The
process if M=N then P else Q will execute P if M =E N
and Q otherwise. The event construct is merely used for
annotating processes and will be useful for stating security
properties. For readability we sometimes omit to write else
Q when Q is 0, as well as trailing 0 processes.

The remaining constructs are used for manipulating state
and are new compared to the applied pi calculus. We offer
two different mechanisms for state. The ﬁrst construct is
functional and allows to associate a value to a key. The
construct
insert M,N binds the value N to a key M.
Successive inserts allow to change this binding. The delete
M operation simply “undeﬁnes” the mapping for the key M.
The lookup M as x in P else Q allows to retrieve the value
associated to M, binding it to the variable x in P . If the
mapping is undeﬁned for M the process behaves as Q. The
lock and unlock constructs allow to gain exclusive access
to a resource M. This is essential for writing protocols
where parallel processes may read and update a common
memory. We additionally offer another kind of global state
in form of a multiset of ground facts, as opposed to the
previously introduced functional store. This multiset can
be altered using the construct [L] −[A]→ [R]; P , which
tries to match each fact in the sequence L to facts in the
current multiset and, if successful, adds the corresponding
instance of facts R to the store. The facts A are used as
annotations in a similar way to events. The purpose of this
construct is to provide access to the underlying notion of
state in tamarin, but we stress that it is distinct from the
previously introduced functional state, and its use is only

166

advised to expert users. We allow this “low-level” form of
state manipulation in addition to the functional state, as it
offers a great ﬂexibility and has shown useful in one of our
case studies. This style of state manipulation is similar to
the state extension in the strand space model [21] and the
underlying speciﬁcation language of the tamarin tool [15],
[16]. Note that, even though those stores are distinct (which
is a restriction imposed by our translation), data can be
moved from one to another, for example as follows: lookup
’store1’ as x in [] −[ ]→ [store2(x)].

In the following example, which will serve as our running
example, we model a security API that, even though much
simpliﬁed, illustrates the most salient issues that occur in
the analysis of security APIs such as PKCS#11 [19], [2].
Example. We consider a security device that allows the
creation of keys in its secure memory. The user can access
the device via an API. If he creates a key, he obtains a
handle, which he can use to let the device perform operations
on his behalf. For each handle the device also stores an
attribute which deﬁnes what operations are permitted for this
handle. The goal is that the user can never gain knowledge
of the key, as the user’s machine might be compromised. We
model the device by the following process (we use out(m)
as a shortcut for out(c, m) for a public channel c):

!Pnew | !Pset | !Pdec | !Pwrap, where

Pnew := νh; νk; event NewKey(h,k);

insert (cid:6)‘key’ ,h(cid:7),k;
insert (cid:6)‘ att ’ ,h(cid:7), ‘dec’; out(h)

In the ﬁrst line, the device creates a new handle h and a key
k and, by the means of the event NewKey(h, k), logs the
creation of this key. It then stores the key that belongs to
the handle by associating the pair (cid:6)‘key’, h(cid:7) to the value of
the key k. In the next line, (cid:6)‘att’, h(cid:7) is associated to a public
constant ‘dec’. Intuitively, we use the public constants ‘key’
and ‘att’ to distinguish two databases. The process
Pset := in(h); insert (cid:6)‘att’,h(cid:7), ‘wrap’
allows the attacker to change the attribute of a key from the
initial value ‘dec’ to another value ‘wrap’. If a handle has
the ‘dec’ attribute set, it can be used for decryption:
Pdec := in((cid:6)h,c(cid:7)); lookup (cid:6)‘att’,h(cid:7) as a in

The ﬁrst lookup stores the value associated to (cid:6)‘att’, h(cid:7) in
a. The value is compared against ‘dec’. If the comparison
and another lookup for the associated key value k succeeds,
we check whether decryption succeeds and, if so, output the
plaintext.

if a=‘dec’ then

lookup (cid:6)‘key’ ,h(cid:7) as k in

if encCor(c,k)=true then

event DecUsing(k,sdec(c,k));
out(sdec(c,k))

If a key has the ‘wrap’ attribute set, it might be used to
encrypt the value of a second key:
Pwrap := in((cid:6)h1,h2(cid:7)); lookup (cid:6)‘att’,h1(cid:7) as a1 in

if a1=‘wrap’ then

lookup (cid:6)‘key’ , h2(cid:7) as k2 in

lookup (cid:6)‘key’ ,h1(cid:7) as k1 in
event Wrap(k1,k2);
out(senc(k2,k1))

The bound names of a process are those that are bound
by νn. We suppose that all names of sort fresh appearing
in the process are under the scope of such a binder. Free
names must be of sort pub. A variable x can be bound in
three ways: (i) by the construct lookup M as x, or (ii) x ∈
vars(N ) in the construct in(M, N) and x is not under the
scope of a previous binder, (iii) x ∈ vars(L) in the construct
[L] −[A]→ [R] and x is not under the scope of a previous
binder. While the construct lookup M as x always acts as a
binder, the input and [L] −[A]→ [R] constructs do not rebind
an already bound variable but perform pattern matching. For
instance in the process

P = in(c,f (x)); in(c,g(x))

x is bound by the ﬁrst input and pattern matched in the
second. It might seem odd that lookup acts as a binder,
while input does not. We justify this decision as follows:
as Pdec and Pwrap in the previous example show, lookups
appear often after input was received. If lookup were to use
pattern matching, the following process

P = in(c, x); lookup ‘store’ as x in P

(cid:3)

might unexpectedly perform a check if ‘store’ contains the
message given by the adversary,
instead of binding the
content of ‘store’ to x, due to an undetected clash in the
naming of variables.

A process is ground if it does not contain any free
variables. We denote by P σ the application of the homo-
morphic extension of the substitution σ to P . As usual we
suppose that the substitution only applies to free variables.
We sometimes interpret the syntax tree of a process as a term
and write P|p to refer to the subprocess of P at position p
(where |, if and lookup are interpreted as binary symbols,
all other constructs as unary).
B. Semantics

Frames and deduction: Before giving the formal se-
mantics of our calculus we introduce the notions of frame
and deduction. A frame consists of a set of fresh names ˜n
and a substitution σ and is written ν ˜n.σ. Intuitively a frame
represents the sequence of messages that have been observed
by an adversary during a protocol execution and secrets ˜n
generated by the protocol, a priori unknown to the adversary.
Deduction models the capacity of the adversary to compute
new messages from the observed ones.

Deﬁnition 1 (Deduction). We deﬁne the deduction relation
ν ˜n.σ (cid:15) t as the smallest relation between frames and terms
deﬁned by the deduction rules in Figure 2.

Example. If one key is used to wrap a second key, then, if
the intruder learns the ﬁrst key, he can deduce the second.
For ˜n = k1, k2 and σ = { senc(k2,k1)/x1 ,k1 /x2 }, ν ˜n.σ (cid:15) k2,
as witnessed by the proof tree given in Figure 3.

Operational semantics: We can now deﬁne the opera-
tional semantics of our calculus. The semantics is deﬁned by
a labelled transition relation between process conﬁgurations.
A process conﬁguration is a 6-tuple (E,S,S MS,P, σ,L)
where
• E ⊆ FN is the set of fresh names generated by the
processes;
• S : MΣ → MΣ is a partial function modeling the
functional store;
• S MS ⊆ G# is a multiset of ground facts and models
the multiset of stored facts;
• P is a multiset of ground processes representing the
processes executed in parallel;
• σ is a ground substitution modeling the messages
output to the environment;
• L ⊆ MΣ is the set of currently acquired locks.
The transition relation is deﬁned by the rules described in
Figure 4. Transitions are labelled by sets of ground facts.
For readability we omit empty sets and brackets around
{ f }−→. We
singletons, i.e., we write → for
write →∗ for the reﬂexive, transitive closure of → (the
transitions that are labelled by the empty sets) and write
f⇒ for →∗ f→→∗. We can now deﬁne the set of traces, i.e.,
possible executions, that a process admits.
Deﬁnition 2 (Traces of P ). Given a ground process P we
deﬁne the set of traces of P as

∅−→ and f−→ for

(cid:2)

traces pi (P ) =

[F1, . . . , Fn] | (∅,∅,∅,{P},∅,∅)
(cid:3)

,P1, σ1,L1)

Fn=⇒ (En,Sn,S MS

n ,Pn, σn,Ln)

F1=⇒ (E1,S1,S MS
F2=⇒ . . .

1

Example. In Figure 5 we display the transitions that illus-
trate how the ﬁrst key is created on the security device in
)] ∈
(cid:3)
our running example and witness that [NewKey(h
traces pi (P ).

, k

(cid:3)

IV. LABELLED MULTISET REWRITING

We now recall

the syntax and semantics of labelled
multiset rewriting rules, which constitute the input language
of the tamarin tool [15].
Deﬁnition 3 (Multiset rewrite rule). A labelled multiset
rewrite rule ri is a triple (l, a, r), l, a, r ∈ F∗, writ-
ten l −[a]→ r. We call
l = prems(ri ) the premises,

167

a ∈ FN ∪ PN a /∈ ˜n

DNAME

ν ˜n.σ (cid:15) a
x ∈ D(σ)
ν ˜n.σ (cid:15) xσ

DFRAME

ν ˜n.σ (cid:15) t

(cid:3)

t =E t

ν ˜n.σ (cid:15) t
(cid:3)
ν ˜n.σ (cid:15) t1 ··· ν ˜n.σ (cid:15) tn

ν ˜n.σ (cid:15) f (t1, . . . , tn)

DEQ
f ∈ Σk

DAPPL

Figure 2. Deduction rules.

x1 ∈ D(σ)

x2 ∈ D(σ)
ν ˜n.σ (cid:15) k1
ν ˜n.σ (cid:15) senc(k2, k1)
ν ˜n.σ (cid:15) sdec(senc(k2, k1), k1)

sdec(senc(k2, k1), k1) =E k2

ν ˜n.σ (cid:15) k2

Figure 3. Proof tree witnessing that ν ˜n.σ (cid:2) k2

Standard operations:

(E,S,S MS,P ∪# {0}, σ,L)
(E,S,S MS,P ∪# {P|Q}, σ,L)
(E,S,S MS,P ∪# {!P}, σ,L)
(E,S,S MS,P ∪# {νa; P}, σ,L)

−→
−→
−→
−→

(E,S,S MS,P, σ,L)
(E,S,S MS,P ∪# {out(M, N ); P}, σ,L)

K(M )−−−−→
K(M )−−−−→

(E,S,S MS,P, σ,L)
(E,S,S MS,P ∪# {P, Q}, σ,L)
(E,S,S MS,P ∪# {!P, P}, σ,L)
/a}}, σ,L)
(E ∪ {a
(cid:3)},S,S MS,P ∪# {P{a
(cid:3)
(cid:3) is fresh
if a
if νE.σ (cid:15) M

(E,S,S MS,P, σ,L)
(E,S,S MS,P ∪# {P}, σ ∪ {N /x},L)

if x is fresh and νE.σ (cid:15) M

(E,S,S MS,P ∪# {out(M, N ); P, in(M

(E,S,S MS,P ∪# {in(M, N ); P}, σ,L)
); Q}, σ,L)
(E,S,S MS,P ∪ {if M = N then P else Q}, σ,L)
(E,S,S MS,P ∪ {if M = N then P else Q}, σ,L)
(E,S,S MS,P ∪ {event(F ); P}, σ,L)

, N

(cid:3)

(cid:3)

if M =E M

if ∃τ. τ is grounding for N, νE.σ (cid:15) M, νE.σ (cid:15) N τ
−→
(cid:3)

K((cid:5)M,N τ(cid:6))
−−−−−−−→ (E,S,S MS,P ∪# {P τ}, σ,L)
(E,S,S MS,P ∪ {P, Qτ}, σ,L)
(E,S,S MS,P ∪ {P}, σ,L)
(E,S,S MS,P ∪ {Q}, σ,L)
(E,S,S MS,P ∪ {P}, σ,L)

τ and τ grounding for N
if M =E N
if M (cid:4)=E N

(cid:3) and ∃τ. N =E N

−→
−→
F−→

(cid:3)

Operations on global state:

(E,S,S MS,P ∪# {insert M, N; P}, σ,L) −→ (E,S[M (cid:10)→ N ],S MS,P ∪# {P}, σ,L)
(E,S,S MS,P ∪# {delete M; P}, σ,L) −→ (E,S[M (cid:10)→ ⊥],S MS,P ∪# {P}, σ,L)

(E,S,S MS,P ∪# {lookup M as x in P else Q }, σ,L) −→ (E,S,S MS,P ∪# {P{V /x}}, σ,L)
(E,S,S MS,P ∪# {lookup M as x in P else Q }, σ,L) −→ (E,S,S MS,P ∪# {Q}, σ,L)

(E,S,S MS,P ∪# {lock M; P}, σ,L) −→ (E,S,S MS,P ∪# {P}, σ,L ∪ { M })
(cid:3) | M

(E,S,S MS,P ∪# {unlock M; P}, σ,L) −→ (E,S,S MS,P ∪# {P}, σ,L \ { M
(E,S,S MS,P ∪# {[l −[a]→ r]; P}, σ,L)
(cid:3)
.

a(cid:2)−→ (E,S,S MS \ lfacts(l
) ∪# r
(cid:3)
(cid:3)
]→ r
(cid:3) −[a
τ grounding for l −[a]→ r, l
(cid:3)
) ⊂ S MS
) ⊆# S MS, pfacts(l
(cid:3)
lfacts(l

if ∃τ, l

, a

, r

(cid:3)

(cid:3)

(cid:3)

if S(N ) =E V is deﬁned and N =E M
if S(N ) is undeﬁned for all N =E M
if M(cid:4)∈EL
=E M })
,P ∪# { P τ }, σ,L)
=E (l −[a]→ r)τ,
(cid:3)

(cid:3)

Figure 4. Operational semantics

168

(cid:7)
(∅,∅,∅,{ !Pnew , !Pset |!Pdec |!Pwrap

(cid:5)(cid:6)

(cid:4)

=:P(cid:2)

}#

,∅,∅) → (∅,∅,∅,{ Pnew }# ∪# P(cid:3)

,∅,∅)

→ (∅,∅,∅,{ νh; νk; event NewKey(h, k); . . .}# ∪# P(cid:3)
,∅,∅)
({ h
); . . .}# ∪# P(cid:3)
,∅,∅)
→∗
(cid:3)
(cid:3)
NewKey(h(cid:2),k(cid:2))
; . . .}# ∪# P(cid:3)
−−−−−−−−−→ ({ h
,∅,∅)
(cid:3)
→∗
({ h
,∅,∅) →∗
({ h
(cid:3)
(cid:3)
, k
(cid:3)(cid:7)) = ‘dec’.
where S((cid:6)‘key’,h

(cid:3) },∅,∅,{ event NewKey(h
(cid:3) },∅,∅,{ insert (cid:6)‘key’, h
(cid:3) },S,∅,{ out(h

(cid:3)
, k
(cid:3)(cid:7), k
(cid:3)
); 0}# ∪# P(cid:3)
(cid:3)

and S((cid:6)‘att’,h

(cid:3)
(cid:3)(cid:7)) = k

, k

, k

, k

(cid:3) },S,∅,P(cid:3)

,{ h(cid:2)

/x1

},∅)

Figure 5. Example of transitions modelling the creation of a key on a PKCS#11-like device

a = actions(ri ) the actions, and r = conclusions(ri ) the
conclusions of the rule.
Deﬁnition 4 (Labelled multiset rewriting system). A la-
belled multiset rewriting system is a set of labelled multiset
rewrite rules R, such that each rule l −[a]→ r ∈ R satisﬁes
the following conditions:

• l, a, r do not contain fresh names
• r does not contain Fr-facts

A labelled multiset rewriting system is called well-formed,
if additionally
(cid:3) ∈E ginsts(l −[a]→ r) we have
]→ r
• for each l
) ∩ FN ⊆ ∩l(cid:2)(cid:2)=E l(cid:2) names(l
) ∩
that ∩r(cid:2)(cid:2)=E r(cid:2) names(r
(cid:3)(cid:3)
FN .

(cid:3) −[a

(cid:3)(cid:3)

(cid:3)

We deﬁne one distinguished rule FRESH which is the only

rule allowed to have Fr-facts on the right-hand side

FRESH : [] −[]→ [Fr(x : fresh)]

The semantics of the rules is deﬁned by a labelled

S

transition relation.
Deﬁnition 5 (Labelled transition relation). Given a multiset
rewriting system R we deﬁne the labeled transition relation
→R⊆ G# × P(G) × G# as
a−→R ((S \#

lfacts(l)) ∪#

if and only if l −[a]→ r ∈E ginsts(R∪FRESH), lfacts(l) ⊆#
S and pfacts(l) ⊆ S.
(cid:2)
Deﬁnition 6 (Executions). Given a multiset rewriting system
R we deﬁne its set of executions as

∅ A1−→R . . .
∀a, i, j : 0 ≤ i (cid:4)= j < n.

(Si+1 \# Si) = {Fr(a)} ⇒ (Sj+1 \# Sj) (cid:4)= {Fr(a)}(cid:8)

An−→R Sn |

execmsr (R) =

r)

The set of executions consists of transition sequences that
respect freshness, i. e., for a given name a the fact Fr(a) is
only added once, or in other words the rule FRESH is at
most ﬁred once for each name. We deﬁne the set of traces
in a similar way as for processes.

169

(cid:2)

Deﬁnition 7 (Traces). The set of traces is deﬁned as

traces msr (R) =

(cid:3)
[A1, . . . , An] | ∀ 0 ≤ i ≤ n. Ai (cid:4)= ∅

and ∅ A1=⇒R . . .

An=⇒R Sn ∈ execmsr (R)

where A

=⇒R is deﬁned as

∅−→∗

R

A−→ R

∅−→∗
R.

Note that both for processes and multiset rewrite rules the

set of traces is a sequence of sets of facts.

V. SECURITY PROPERTIES

In the tamarin tool [15] security properties are described
in an expressive two-sorted ﬁrst-order logic. The sort temp
is used for time points, Vtemp are the temporal variables.
Deﬁnition 8 (Trace formulas). A trace atom is either false
⊥, a term equality t1 ≈ t2, a timepoint ordering i (cid:2) j, a
= j, or an action F @i for a fact F ∈ F
.
timepoint equality i
and a timepoint i. A trace formula is a ﬁrst-order formula
over trace atoms.

As we will see in our case studies this logic is expressive
enough to analyze a variety of security properties, including
complex injective correspondence properties.
To deﬁne the semantics, let each sort s have a domain
D(s). D(temp) = Q, D(msg) = M, D(fresh) = FN , and
D(pub) = PN . A function θ : V → M∪Q is a valuation if
it respects sorts, that is, θ(Vs) ⊂ D(s) for all sorts s. If t is
a term, tθ is the application of the homomorphic extension
of θ to t.

Deﬁnition 9 (Satisfaction relation). The satisfaction relation
(tr , θ) (cid:2) ϕ between trace tr, valuation θ and trace formula

ϕ is deﬁned as follows:
(tr , θ) (cid:2) ⊥
never
(tr , θ) (cid:2) F @i
iff
(tr , θ) (cid:2) i (cid:2) j
iff
(tr , θ) (cid:2) i
.
iff
= j
(tr , θ) (cid:2) t1 ≈ t2
iff
(tr , θ) (cid:2) ¬ϕ
iff not (tr , θ) (cid:2) ϕ
(tr , θ) (cid:2) ϕ1 ∧ ϕ2
iff
(tr , θ) (cid:2) ∃x : s.ϕ iff

θ(i) ∈ idx (tr) and F θ ∈E tr θ(i)
θ(i) < θ(j)
θ(i) = θ(j)
t1θ =E t2θ
(tr , θ) (cid:2) ϕ1 and (tr , θ) (cid:2) ϕ2
there is u ∈ D(s) such that
(tr , θ[x (cid:10)→ u]) (cid:2) ϕ

A trace formula ϕ is said to be satisﬁable for Tr, written
ϕ, if there exist a trace tr ∈ Tr and a valuation θ

When ϕ is a ground formula we sometimes simply write
tr (cid:2) ϕ as the satisfaction of ϕ is independent of the
valuation.
Deﬁnition 10 (Validity, satisﬁability). Let Tr ⊆ (P(G))
∗ be
a set of traces. A trace formula ϕ is said to be valid for Tr,
ϕ, if for any trace tr ∈ Tr and any valuation
written Tr (cid:2)∀
θ we have that (tr , θ) (cid:2) ϕ.
Tr (cid:2)∃
such that (tr , θ) (cid:2) ϕ.
Note that Tr (cid:2)∀
rewriting system R we say that ϕ is valid, written R (cid:2)∀
if traces msr (R) (cid:2)∀
written R (cid:2)∃
a ground process P we say that ϕ is valid, written P (cid:2)∀
if traces pi (P ) (cid:2)∀
P (cid:2)∃
Example. The following trace formula expresses secrecy of
keys generated on the security API, which we introduced in
Section III.
¬(∃h, k : msg, i, j : temp. NewKey(h, k)@i ∧ K(k)@j)
VI. A TRANSLATION FROM PROCESSES INTO MULTISET

ϕ iff Tr (cid:4)(cid:2)∃ ¬ϕ. Given a multiset
ϕ,
ϕ. We say that ϕ is satisﬁed in R,
ϕ. Similarly, given
ϕ,
ϕ, and that ϕ is satisﬁed in P , written

ϕ, if traces msr (R) (cid:2)∃

ϕ, if traces pi (P ) (cid:2)∃

ϕ.

REWRITE RULES

ϕ if and only if (cid:2)P (cid:3) |=

In this section we deﬁne a translation from a process P
into a set of multiset rewrite rules (cid:2)P (cid:3) and a translation on
trace formulas such that P |=
∀ (cid:2)ϕ(cid:3).
∀
Note that the result also holds for satisﬁability, as an imme-
diate consequence. For a rather expressive subset of trace
formulas (see [15] for the exact deﬁnition of the fragment),
checking whether (cid:2)P (cid:3) |=
∀ (cid:2)ϕ(cid:3) can then be discharged to
the tamarin prover that we use as a backend.

A. Deﬁnition of the translation of processes

To model the adversary’s message deduction capabilities,

we introduce the set of rules MD deﬁned in Figure 6.

In order for our translation to be correct, we need to make
some assumptions on the set of processes we allow. These
assumptions are however, as we will see, rather mild and
most of them without loss of generality. First we deﬁne a

170

set of reserved variables that will be used in our translation
and whose use we therefore forbid in the processes.
Deﬁnition 11 (Reserved variables and facts). The set of
reserved variables is deﬁned as the set containing the
elements na for any a ∈ FN and lock l for any l ∈ N.
The set of reserved facts Fres
is deﬁned as the set
containing facts f (t1, . . . , tn) where t1, . . . , tn ∈ T and
f ∈ { Init, Insert, Delete, IsIn, IsNotSet, state, Lock, Unlock,
Out, Fr, In, Msg, ProtoNonce, Eq, NotEq, Event, InEvent }.
Similar to [17], for our translation to be sound, we require
that for each process,
there exists an injective mapping
assigning to every unlock t in a process a lock t that
precedes it in the process’ syntax tree. Moreover, given a
process lock t; P the corresponding unlock in P may not
be under a parallel or replication. These conditions allow
us to annotate each corresponding pair lock t, unlock t
with a unique label l. The annotated version of a process
P is denoted P . The formal deﬁnition of P is given in
Appendix A. In case the annotation fails, i.e., P violates
one of the above conditions, the process P contains ⊥.
Deﬁnition 12 (well-formed). A ground process P is well-
formed if

• no reserved variable nor reserved fact appear in P ,
• any name and variable in P is bound at most once and
• P does not contain ⊥.
• For each action l −[a]→ r that appears in the pro-
]→ r
(cid:3) ∈E
cess, the following holds: for each l
ginsts(l −[a]→ r) we have that ∩r(cid:2)(cid:2)=E r(cid:2) names(r
) ∩
(cid:3)(cid:3)
FN ⊆ ∩l(cid:2)(cid:2)=E l(cid:2) names(l

) ∩ FN .

(cid:3) −[a

(cid:3)(cid:3)

(cid:3)

A trace formula ϕ is well-formed if no reserved variable nor
reserved fact appear in ϕ.

The two ﬁrst restrictions of well-formed processes are not
a loss of generality as processes and formulas can be consis-
tently renamed to avoid reserved variables and α-converted
to avoid binding names or variables several times. Also note
that the second condition is not necessarily preserved during
an execution, e.g. when unfolding a replication, !P and P
may bind the same names. We only require this condition to
hold on the initial process for our translation to be correct.
The annotation of locks restricts the set of protocols we
can translate, but allows us to obtain better veriﬁcation
results, since we can predict which unlock is “supposed”
to close a given lock. This additional information is helpful
for tamarin’s backward reasoning. We think that our locking
mechanism captures all practical use cases. Using our cal-
culus’ “low-level” multiset manipulation construct, the user
is also free to implement locks himself, e.g., as

[NotLocked()] → []; code; [] → [NotLocked()]

(In this case the user does not beneﬁt from the optimisation
we put into the translation of locks.) Obviously, locks can be

−[ ]→ !K(x)
Out(x)
!K(x) −[K(x)]→ In(x)
−[ ]→ !K(x : pub)
−[ ]→ !K(x : fresh)
−[ ]→ !K(f (x1, . . . , xk)) for f ∈ Σk

Fr(x : fresh)
!K(x1), . . . , !K(xk)

(MDOUT)
(MDIN)
(MDPUB)
(MDFRESH)
(MDAPPL)

Figure 6. The set of rules MD.

modelled both in tamarin’s multiset rewriting calculus (this
is actually what the translation does) and Mödersheim’s set
rewriting calculus [18]. However, protocol steps typically
consist of a single input, followed by several database
lookups, and ﬁnally an output. In practice, they tend to be
modelled as a single rule, and are therefore atomic. Real
implementations are however different, as several entities
might be involved, database lookups could be slow, etc.
In this case, such simpliﬁed models could, e. g., miss race
conditions. To the best of our knowledge, StatVerif is the
only comparable tool that models locks explicitly and it has
stronger restrictions.
Deﬁnition 13. Given a well-formed ground process P we
deﬁne the labelled multiset rewriting system (cid:2)P (cid:3) as

MD ∪ {INIT} ∪ (cid:2)P , [], [](cid:3)

• where the rule INIT is deﬁned as

INIT : [] −[Init()]→ [state[]()]

∗ and sequence of variables ˜x in Figure 7.

• (cid:2)P, p, ˜x(cid:3) is deﬁned inductively for process P , position
p ∈ N
• For a position p of P we deﬁne statep to be persistent
if P|p = !Q for some process Q; otherwise statep is
linear.

In the deﬁnition of (cid:2)P, p, ˜x(cid:3) we intuitively use the family
of facts statep to indicate that the process is currently at
position p in its syntax tree. A fact statep will indeed be
true in an execution of these rules whenever some instance
of Pp (i.e. the process deﬁned by the subtree at position
p of the syntax tree of P ) is in the multiset P of the
process conﬁguration. The translation of the zero-process,
parallel and replication operators merely use statep-facts.
For instance (cid:2)P | Q, p, ˜x(cid:3) deﬁnes the rule

[statep(˜x)] → [statep·1(˜x), statep·2(˜x)]

which intuitively states that when a process is at position
p (modelled by the fact statep(˜x) being true) then the
process is allowed to move both to P (putting statep·1(˜x)
to true) and Q (putting statep·2(˜x) to true). The translation
of (cid:2)P | Q, p, ˜x(cid:3) also contains the set of rules (cid:2)P, p · 1, ˜x(cid:3) ∪
(cid:2)Q, p · 2, ˜x(cid:3) expressing that after this transition the process
may behave as P and Q, i.e., the processes at positions
p · 1, respectively p · 2, in the process tree. Also note that
the translation of !P results in a persistent fact as !P always

remains in P. The translation of the construct ν a translates
the name a into a variable na, as msr rules must not contain
fresh names. Any instantiation of this rule will substitute na
by a fresh name, which the Fr-fact in the premise guarantees
to be new. This step is annotated with a (reserved) action
ProtoNonce, used in the proof of correctness to distinguish
adversary and protocol nonces. Note that the fact statep·1
in the conclusion carries na, so that the following protocol
steps are bound to the fresh name used to instantiate na.
The ﬁrst rules of the translation of out and in model the
communication between the protocol and the adversary,
and vice versa. In the case of out,
the adversary must
know the channel M, modelled by the fact In(M ) in the
rule’s premisse, and learns the output message, modelled
by the fact Out(N ) in the conclusion. In the case of in,
the knowledge of the message N is additionally required
and the variables of the input message are added to the
parameters of the state fact to reﬂect that these variables
are bound. The second and third rules of the translations
of out and in model an internal communication, which is
synchronous. For this reason, when the second rule of the
translation of out is ﬁred, the state-fact is substituted by
an intermediate, semi-state fact, statesemi, reﬂecting that the
sending process can only execute the next step if the message
was successfully received. The fact Msg(M, N ) models that
a message is present on the synchronous channel. Only with
the acknowledgement fact Ack(M, N ), resulting from the
second rule of the translation of in, is it possible to advance
the execution of the sending process, using the third rule
in the translation of out, which transforms the semi-state
and the acknowledgement of receipt into statep·1(. . .). Only
now the next step in the execution of the sending process
can be executed. The remaining rules essentially update the
position in the state facts and add labels. Some of these
labels are used to restrict the set of executions. For instance
the label Eq(M,N) will be used to indicate that we only
consider executions in which M =E N. As we will see
in the next section these restrictions will be encoded in the
trace formula.

Example. Figure 8 illustrates the above translation by pre-
senting the set of msr rules (cid:2)!Pnew (cid:3) (omitting the rules in
MD already shown in Figure 6).

A graph representation of an example trace, generated
by the tamarin tool, is depicted in Figure 9. Every box in
this picture stands for the application of a multiset rewrite

171

(cid:2)0, p, ˜x(cid:3) = {[statep(˜x)] → []}

(cid:2)P | Q, p, ˜x(cid:3) = {[statep(˜x)] → [statep·1(˜x), statep·2(˜x)]}

∪(cid:2)P, p · 1, ˜x(cid:3) ∪ (cid:2)Q, p · 2, ˜x(cid:3)

(cid:2)!P, p, ˜x(cid:3) = {[!statep(˜x)] → [statep·1(˜x)]} ∪ (cid:2)P, p · 1, ˜x(cid:3)

(cid:2)νa; P, p, ˜x(cid:3) = {[statep(˜x), Fr(na : fresh)] −[ProtoNonce(na : fresh)]→

[statep·1(˜x, na : fresh)]} ∪ (cid:2)P, p · 1, (˜x, na : fresh)(cid:3)

(cid:2)Out(M, N ); P, p, ˜x(cid:3) = {[statep(˜x), In(M )] −[InEvent(M )]→ [Out(N ), statep·1(˜x)],

[statep(˜x)] → [Msg(M, N ), statesemi
[statesemi

(˜x), Ack(M, N )] → [statep·1(˜x)]} ∪ (cid:2)P, p · 1, ˜x(cid:3)

(˜x)],

p

p

(cid:2)In(M, N ); P, p, ˜x(cid:3) = {[statep(˜x), In((cid:6)M, N(cid:7))] −[InEvent((cid:6)M, N(cid:7))]→

(cid:2)if M = N then P else Q, p, ˜x(cid:3) = {[statep(˜x)] −[Eq(M, N )]→ [statep·1(˜x)],

[statep·1(˜x ∪ vars(N ))], [statep(˜x), Msg(M, N )] →
[statep·1(˜x ∪ vars(N )), Ack(M, N )]}
∪(cid:2)P, p · 1, ˜x ∪ vars(N )(cid:3)

[statep(˜x)] −[NotEq(M, N )]→ [statep·2(˜x)]}
∪(cid:2)P, p · 1, ˜x(cid:3) ∪ (cid:2)Q, p · 2, ˜x(cid:3)

(cid:2)event F ; P, p, ˜x(cid:3) = {[statep(˜x)] −[Event(), F ]→ [statep·1(˜x)]} ∪ (cid:2)P, p · 1, ˜x(cid:3)
(cid:2)insert s, t; P, p, ˜x(cid:3) = {[statep(˜x)] −[Insert(s, t)]→ [statep·1(˜x)]} ∪ (cid:2)P, p · 1, ˜x(cid:3)
(cid:2)delete s; P, p, ˜x(cid:3) = {[statep(˜x)] −[Delete(s)]→ [statep·1(˜x)]} ∪ (cid:2)P, p · 1, ˜x(cid:3)

(cid:2)lookup M as v in P else Q, p, ˜x(cid:3) = {[statep(˜x)] −[IsIn(M, v)]→ [statep·1( ˜M , v)],
[statep(˜x)] −[IsNotSet(M )]→ [statep·2(˜x)]}
∪(cid:2)P, p · 1, (˜x, v)(cid:3) ∪ (cid:2)Q, p · 2, ˜x(cid:3)

(cid:2)lockl

s; P, p, ˜x(cid:3) = {[Fr(lockl), statep(˜x)] −[Lock(lock l, s)]→ [statep·1(˜x, lock l)]}

s; P, p, ˜x(cid:3) = {[statep(˜x)] −[Unlock(lock l, s)]→ [statep·1(˜x)]} ∪ (cid:2)P, p · 1, ˜x(cid:3)

(cid:2)unlockl
(cid:2)[l −[a]→ r]; P , p, ˜x(cid:3) = {[statep(˜x), l] −[Event(), a]→ [r, statep·1(˜x ∪ vars(l))]}

∪(cid:2)P, p · 1, ˜x(cid:3)

∪(cid:2)P, p · 1, ˜x ∪ vars(l)(cid:3)

Figure 7. Translation of processes: deﬁnition of (cid:2)P, p, ˜x(cid:3)

rule, where the premises are at the top, the conclusions at
the bottom, and the actions (if any) in the middle. Every
premise needs to have a matching conclusion, visualized by
the arrows, to ensure the graph depicts a valid msr execution.
(This is a simpliﬁcation of the dependency graph repre-
sentation tamarin uses to perform backward-induction [15],
[16].) Note that the machine notation for statep() predicates
omits brackets [ ] in the position p and denotes the empty
sequence by ‘0’. We also note that in the current example
!state[1]() is persistent and can therefore be used multiple
times as a premise. As Fr( ) facts are generated by the
FRESH rule which has an empty premise and action, we
omit instances of FRESH and leave those premises, but only
those, disconnected.

Remark 1. One may note that, while for all other operators,
the translation produces well-formed multiset rewriting rules
(as long as the process is well-formed itself), this is not
the case for the translation of the lookup operator, i. e.,
it violates the well-formedness condition from Deﬁnition 4.
Tamarin’s constraint solving algorithm requires all rules,
with the exception of FRESH, to be well-formed. We show
however that, under these speciﬁc conditions, the solution
procedure is still correct. See Appendix C in the full version
for the proof.

B. Deﬁnition of the translation of trace formulas
We can now deﬁne the translation for formulas.

Deﬁnition 14. Given a well-formed trace formula ϕ we

172

−[Init()]→

−[ ]→
−[ ]→
−[ ]→

[state[]()]
[]
[!state[1]()]
[state[]()]
[!state[1](), Fr(h)]
[state[11](h)]
[state[11](h), Fr(k)]
[state[111](k, h)]
[state[111](k, h)] −[Event(), NewKey(h, k)]→ [state[1111](k, h)]
[state[1111](k, h)] −[Insert((cid:6)’key’, h(cid:7), k)]→ [state[11111](k, h)]
[state[11111](k, h)] −[Insert((cid:6)’att’, h(cid:7), ’dec’)]→ [state[111111](k, h)]
[state[111111](k, h)]

−[ ]→

[Out(h), state[1111111](k, h)]

Figure 8. The set of multiset rewrite rules (cid:2)!Pnew (cid:3) (omitting the rules in MD)

0[Init( )]

state_0( )

state_0( )

!state_01( )

!state_01( )

Fr( h )

!state_01( )

Fr( h' )

state_011( h )

state_011( h' )

state_011( h )

Fr( k )

state_011( h' )

Fr( k' )

state_0111( k, h )

state_0111( k', h' )

state_0111( k, h )

state_0111( k', h' )

Event( ),NewKey( h, k )

Event( ),NewKey( h', k' )

state_01111( k, h )

state_01111( k', h' )

state_01111( k, h )

Insert( <'key', h>, k )

state_011111( k, h )

state_01111( k', h' )

Insert( <'key', h'>, k' )

state_011111( k', h' )

state_011111( k, h )

state_011111( k', h' )

Insert( <'att', h>, 'dec' )

Insert( <'att', h'>, 'dec' )

state_0111111( k, h )

state_0111111( k', h' )

state_0111111( k, h )

state_0111111( k', h' )

Out( h )

state_01111111( k, h )

Out( h' )

state_01111111( k', h' )

Figure 9.

Example trace for the translation of !Pnew .

deﬁne

(cid:2)ϕ(cid:3)∀ := α ⇒ ϕ

and

(cid:2)ϕ(cid:3)∃ := α ∧ ϕ

where α is deﬁned in Figure 10.

The formula α uses the actions of the generated rules to

ﬁlter out executions that we wish to discard:

• αinit ensures that the init rule is only ﬁred once.
• αeq and αnoteq ensure that we only consider traces

where all (dis)equalities hold.

• αin and αnotin ensure that a successful lookup was
preceded by an insert that was neither revoked nor

overwritten while an unsuccessful lookup was either
never inserted, or deleted and never re-inserted.

• αlock checks that between each two matching locks
there must be an unlock. Furthermore, between the ﬁrst
of these locks and the corresponding unlock, there is
neither a lock nor an unlock.

i. e.,

• αinev ensures that whenever an instance of MDIN is
required to generate an In-fact, it is generated as late
as possible,
there is no visible event between
the action K(t) produced by MDIN, and a rule that
requires In(t).

We also note that Tr (cid:2)∀ (cid:2)ϕ(cid:3)∀ iff Tr (cid:4)(cid:2)∃ (cid:2)¬ϕ(cid:3)∃.
The axioms in the translation of the formula are designed
to work hand in hand with the translation of the process
into rules. They express the correctness of traces with
respect to our calculus’ semantics, but are also meant to
guide tamarin’s constraint solving algorithm. αin and αnotin
illustrate what kind of axioms work well: when a node with
the action IsIn is created, by deﬁnition of the translation, this
corresponds to a lookup command. The existential translates
into a graph constraint that postulates an insert node for the
value fetched by the lookup, and three formulas assuring that
a) this insert node appears before the lookup, b) is uniquely
deﬁned, i. e., it is the last insert to the corresponding key,
and c) there is no delete in between. Due to these conditions,
αnotin only adds one Insert node per IsIn node – the
case where an axiom postulates a node, which itself allows
for postulating yet another node needs to be avoided, as
tamarin runs into loops otherwise. Similarly, a naïve way
of implementing locks using an axiom would postulate that
every lock is preceeded by an unlock and no lock or unlock
in between, unless it is the ﬁrst lock. This again would cause
tamarin to loop, because an unlock is typically preceeded
by yet another lock. The axiom αlock avoids this caveat
because it only applies to pairs of locks carrying the same
annotations.

The interaction between the αlock axiom and tamarin’s
constraint solving algorithm is described in more detail in
the full version.
C. Correctness of the translation

The correctness of our translation is stated by the follow-

ing theorem.

173

α := αinit ∧ αeq ∧ αnoteq ∧ αin ∧ αnotin ∧ αlock ∧ αinev and
Init()@i ∧ Init()@j =⇒ i = j
Eq(x, y)@i =⇒ x ≈ y
NotEq(x, y)@i =⇒ ¬(x ≈ y)
IsIn(x, y)@t3 =⇒ ∃t2. Insert(x, y)@t2 ∧ t2 (cid:2) t3

αinit :=∀i, j.
αeq :=∀x, y, i.
αnoteq :=∀x, y, i.
αin :=∀x, y, t3.

∧ ∀t1, y. Insert(x, y)@t1 =⇒ (t1 (cid:2) t2 ∨ t1
= t2 ∨ t3 (cid:2) t1)
.
∧ ∀t1. Delete(x)@t1 =⇒ (t1 (cid:2) t2 ∨ t3 (cid:2) t1)

(∃t1. Delete(x)@t1 ∧ t1 (cid:2) t3

∧ ∀t2, y. (Insert(x, y)@t2 ∧ t2 (cid:2) t3) =⇒ t2 (cid:2) t1)

αnotin :=∀x, y, t3.

IsNotSet(x)@t3 =⇒ (∀t1, y. Insert(x, y)@t1 =⇒ t3 (cid:2) t1)∨

αlock :=∀x, l, l

(cid:3)

αinev :=∀t, i.

, i, j. Lock(l, x)@i ∧ Lock(l

(cid:3)

, x)@j ∧ i (cid:2) j

=⇒ ∃k. Unlock(l, x)@k ∧ i (cid:2) k ∧ k (cid:2) j

(cid:3)

(cid:3)
(cid:3)

∧ (∀l
∧ (∀l

, x)@m =⇒ ¬(i (cid:2) m ∧ m (cid:2) k))
, x)@m =⇒ ¬(i (cid:2) m ∧ m (cid:2) k))
(cid:3)
InEvent(t)@i =⇒ ∃j. K(t)@j ∧ (∀k. Event()@k =⇒ (k (cid:2) j ∨ i (cid:2) k))
)@k =⇒ (k (cid:2) j ∨ i (cid:2) k ∨ k ≈ j))

, m. Lock(l
, m. Unlock(l

∧ (∀k, t

(cid:3)

(cid:3)
. K(t

Figure 10. Deﬁnition of α.

Theorem 1. Given a well-formed ground process P and a
well-formed trace formula ϕ we have that

traces pi (P ) (cid:2)(cid:4)

ϕ iff traces msr ((cid:2)P (cid:3)) (cid:2)(cid:4) (cid:2)ϕ(cid:3)(cid:4)

where (cid:8) is either ∀ or ∃.

We here give an overview of the main propositions and
lemmas needed to prove Theorem 1. To show the result we
need two additional deﬁnitions. We ﬁrst deﬁne an operation
that allows to restrict a set of traces to those that satisfy the
trace formula α as deﬁned in Deﬁnition 14.
Deﬁnition 15. Let α be the trace formula as deﬁned in
Deﬁnition 14 and Tr a set of traces. We deﬁne
ﬁlter (Tr ) := {tr ∈ Tr | ∀θ.(tr , θ) (cid:2) α}

The following proposition states that if a set of traces
satisﬁes the translated formula then the ﬁltered traces satisfy
the original formula.
Proposition 1. Let Tr be a set of traces and ϕ a trace
formula. We have that

Tr (cid:2)(cid:4) (cid:2)ϕ(cid:3)(cid:4) iff ﬁlter (Tr ) (cid:2)(cid:4)

ϕ

where (cid:8) is either ∀ or ∃.

(cid:9)

Deﬁnition 16 (hide). Given a trace tr and a set of facts F
we inductively deﬁne hide([]) = [] and

hide(F · tr ) :=

hide(tr )

(F \ Fres ) · hide(tr )

if F ⊆ Fres
otherwise

Given a set of traces Tr we deﬁne hide(Tr ) = {hide(t) |
t ∈ Tr}.

As expected well-formed formulas that do not contain
reserved facts evaluate the same whether reserved facts are
hidden or not.
Proposition 2. Let Tr be a set of traces and ϕ a well-formed
trace formula. We have that

Tr (cid:2)(cid:4)

ϕ iff hide(Tr ) (cid:2)(cid:4)

ϕ

where (cid:8) is either ∀ or ∃.

We can now state our main lemma which is relating the set
of traces of a process P and the set of traces of its translation
into multiset rewrite rules (proven in the full version).
Lemma 1. Let P be a well-formed ground process. We have
that

traces pi (P ) = hide(ﬁlter (traces msr ((cid:2)P (cid:3)))).

The proof (detailed in the full version) follows directly
from the deﬁnitions. Next we deﬁne the hiding operation
which removes all reserved facts from a trace.

Our main theorem can now be proven by applying

Lemma 1, Proposition 2 and Proposition 1.

174

Proof of Theorem 1:
traces pi (P ) (cid:2)(cid:4) ϕ

⇔ hide(ﬁlter (traces msr ((cid:2)P (cid:3)))) (cid:2)(cid:4) ϕ
⇔ ﬁlter (traces msr ((cid:2)P (cid:3))) (cid:2)(cid:4) ϕ
⇔ traces msr ((cid:2)P (cid:3)) (cid:2)(cid:4) (cid:2)ϕ(cid:3)(cid:4)

by Lemma 1
by Proposition 2
by Proposition 1

VII. CASE STUDIES

In this section we brieﬂy overview some case studies we
performed. These case studies include a simple security API
similar to PKCS#11 [9], the Yubikey security token, the
optimistic contract signing protocol by Garay, Jakobsson and
MacKenzie (GJM) [24] and a few other examples discussed
in Arapinis et al. [17] and Mödersheim [18]. The results are
summarized in Figure 11. For each case study we provide
the number of typing lemmas that were needed by the
tamarin prover and whether manual guidance of the tool
was required. In case no manual guidance is required we
also give execution times. We do not detail all the formal
models of the protocols and properties that we studied,
and sometimes present slightly simpliﬁed versions. All ﬁles
of our prototype implementation and our case studies are
available at http://sapic.gforge.inria.fr/.

Example

Security API à la PKCS#11
Yubikey Protocol [23], [25]

GJM protocol [17], [24]
Mödersheim’s example

(locks/inserts) [18]

Mödersheim’s example

(embedded msr rules) [18]

Security Device [17]

Needham-Schroeder-Lowe [3]

Typing
Lemmas

1
3
0

0

Automated

Run∗
yes (51s)

yes (36s)

no

no∗∗

0
1
1

yes (1s)
yes (21s)
yes (5s)

∗ (Running times on Intel Core2 Duo 2.66Ghz with 4GB RAM)
∗∗ (little interaction: 7 manual rule selections)

Figure 11. Case studies.

A. Security API à la PKCS#11

This example illustrates how our modelling might be
useful for the analysis of Security APIs in the style of
the PKCS#11 standard [9]. We expect studying a complete
model of PKCS#11, such as in [19], to be a straightforward
extension of this example. In addition to the processes pre-
sented in the running example in Section III the actual case
study models the following two operations: (i) encryption:
given a handle and a plain-text, the user can request an
encryption under the key the handle points to. (ii) unwrap
given a ciphertext senc(k2, k1), and a handle h1, the user
can request the ciphertext to be unwrapped, i.e. decrypted,

175

under the key pointed to by h1. If decryption is successful
the result is stored on the device, and a handle pointing to
k2 is returned. Moreover, contrary to the running example,
at creation time keys are assigned the attribute ‘init’, from
which they can move to either ‘wrap’, or ‘unwrap’, see the
following snippet:
1 in((cid:6)‘ set_dec ’ ,h(cid:7)); lock (cid:6)‘ att ’ ,h(cid:7);

lookup (cid:6)‘ att ’ ,h(cid:7) as a in
if a=‘ init ’ then
insert (cid:6)‘ att ’ ,h(cid:7), ‘dec’; unlock (cid:6)‘ att ’ ,h(cid:7)

2
3
4

Note that, in contrast to the running example, it is necessary
to encapsulate the state changes between lock and unlock.
Otherwise an adversary can stop the execution after line
3, set the attribute to ‘wrap’ in a concurrent process and
produce a wrapping. After resuming operation at line 4,
he can set the key’s attribute to ‘dec’, even though the
attribute is set to ‘wrap’. Hence, the attacker is allowed to
decrypt the wrapping he has produced and can obtain the
key. Such subtleties can produce attacks that our modeling
allows to detect. If locking is handled correctly, we show
secrecy of keys produced on the device, proving the property
introduced in Example 5. If locks are removed the attack
described before is found.
B. Yubikey

The Yubikey [25] is a small hardware device designed to
authenticate a user against network-based services. Manu-
factured by Yubico, a Swedish company, the Yubikey itself
is a low cost ($25), thumb-sized USB device. In its typical
conﬁguration,
it generates one-time passwords based on
encryptions of a secret value, a running counter and some
random values using a unique AES-128 key contained in
the device. The Yubikey authentication server accepts a one-
time password only if it decrypts under the correct AES key
to a valid secret value containing a counter larger than the
last counter accepted. The counter is thus used as a means
to prevent replay attacks. To date, over a million Yubikeys
have been shipped to more than 30,000 customers includ-
ing governments, universities and enterprises, e.g. Google,
Microsoft, Agfa and Symantec [26].

Besides the counter values used in the one-time password,
the Yubikey stores three additional pieces of information:
the public id pid that is used to identify the Yubikey, a
secret id secretid that is transmitted as part of the one-time
password and only known to the server and the Yubikey, as
well as the AES key k, which is also shared with the server.
The following process PYubikey models a single Yubikey,
as well as its initial conﬁguration, where an entry in the
server’s database for the public id pid is created. This entry
contains a tuple consisting of the Yubikey’s secret id, AES
key, and an initial counter value.

PYubikey =
ν k; ν pid; ν secretid ;

insert (cid:6)‘Server’ , pid(cid:7) , (cid:6) secretid , k, ‘zero’(cid:7);
insert (cid:6)‘Yubikey’, pid(cid:7) , ‘zero’+‘one’;
out(pid);
!PPlugin | !PButtonPress
Here, the processes !PPlugin and !PButtonPress model the
Yubikey being unplugged and plugged in again (possibly
on a different computer), and the emission of the one-time
password. We will only discuss PButtonPress here. When the
user presses the button on the Yubikey, the device outputs
a one-time password consisting of a counter tc, the secret
id secretid and additional randomness npr encrypted using
the AES key k.

To this end, our modelling employs a feature added to the
development version of tamarin as of October 2012, a union
operator ∪# for multisets of message terms. The operator
is denoted with a plus sign (“+”). We model the counter as
a multiset only consisting of the symbols “one” and “zero”.
The multiplicity of ‘one’ in the multiset is the value of the
counter. A counter value is considered smaller than another
one, if the ﬁrst multiset is included in the second. A test
a < b is included by adding the event Smaller(a, b) and an
axiom that requires that a is a subset of b:

αSmaller :=∀i : temp, a, b : msg. Smaller(a, b)@i

⇒ ∃z : msg. a + z = b

PButtonPress =
lock pid;
lookup (cid:6)‘Yubikey’,pid(cid:7) as tc in

insert (cid:6)‘Yubikey’,pid(cid:7) ,
ν nonce; ν npr;
event YubiPress(pid , secretid ,k, tc );
out((cid:6)pid ,nonce,senc((cid:6) secretid , tc ,npr(cid:7),k)(cid:7));

tc + ‘one’;

unlock pid
The one-time password senc((cid:6)secretid, tc, npr(cid:7), k) can be
used to authenticate against a server that shares the same
secret key, which we model in the process PServer . The
process receives the encrypted one-time password along with
the public id pid of a Yubikey and a nonce that is part of
the protocol, but is irrelevant for the authentication of the
Yubikey on the server.

The server looks up the secret id and the AES key associ-
ated to the public id, i. e., to the Yubikey sending the request,
as well as the last recorded counter value otc. If the key and
secret id used in the request match the values retrieved from
the database, then the event Smaller(otc, tc) is logged along
with the event Login(pid , k, tc), which marks a successful
login of the Yubikey pid with key k for the counter value
tc. Afterwards, the old tuple (cid:6)secretid , k, otc(cid:7) is replaced by
(cid:6)secretid , k, tc(cid:7), to update the latest counter value received.
PServer =
! in((cid:6)pid ,nonce,senc((cid:6) secretid , tc ,npr(cid:7),k)(cid:7));
lock pid;
lookup (cid:6)‘Server’ , pid(cid:7) as tuple in

if

fst ( tuple )= secretid then
fst (snd( tuple ))=k then
if
event Smaller(snd(snd( tuple )) ,
event Login(pid,k, tc );
insert (cid:6)‘Server’ , pid(cid:7) , (cid:6) secretid ,k, tc(cid:7);

tc )

unlock pid
Note that, in our modelling, the server keeps one lock per
public id, which means that it is possible to have several
active instances of the server thread in parallel as long as
all requests concern different Yubikeys.

An important part of the modelling of the protocol is to
determine whether one counter value is smaller than another.

We incorporate this axiom into the security properties just
like in Deﬁnition 14. Intuitively, we are only interested in
traces where a is indeed smaller than b.

The process we analyse models a single authentication
server (that may run arbitrary many threads) and an arbitrary
number of Yubikeys, i. e., PServer | !PYubikey. Among other
properties, we show by the means of an injective correspon-
dence property that an attacker that controls the network
cannot perform replay attacks, and that each successful login
was preceded by a user “pressing the button”, formally:

∀ pid , k, x, t2.Login(pid , k , x )@t2 ⇒

∃sid , t1.YubiPress(pid , sid , k , x )@t1 ∧ t1 (cid:2) t2

∧ ∀t3 .Login(pid , k , x )@t3 ⇒ t3 = t2

Besides injective correspondence, we show the absence of
replay attacks and the property that a successful
login
invalidates previously emitted one-time passwords. All three
properties follow more or less directly from a stronger
invariant, which itself can be proven in 295 steps. To ﬁnd
theses steps, tamarin needs some additional human guidance,
which can be provided using the interactive mode. This
mode still allows the user to complement his manual efforts
with automated backward search. The example ﬁles contain
the modelling in our calculus, the complete proof, and the
manual part of the proof which can be veriﬁed by tamarin
without interaction.

Our analysis makes three simpliﬁcations: First, in PServer ,
we use pattern matching instead of decryption as demon-
strated in the process Pdec we introduced in Section III.
Second, we omit the CRC checksum and the time-stamp
that are part of the one-time password in the actual protocol,
since they do not add to the security of the protocol in
the symbolic setting. Third, the Yubikey has actually two
counters instead of one, a session counter, and a token
counter. We treat
the session and token counter on the
Yubikey as a single value, which we justify by the fact
that the Yubikey either increases the session counter and
resets the token counter, or increases only the token counter,
thereby implementing a complete lexicographical order on
the pair (session counter , token counter ).

176

the model

A similar analysis has already been performed by Kün-
nemann and Steel, using tamarin’s multiset rewriting cal-
culus [23]. However,
in our new calculus is
more ﬁne-grained and we believe more readable. Security-
relevant operations like locking and tests on state are written
out in detail, resulting in a model that is closer to the
real-life operation of such a device. The modeling of the
Yubikey takes approximately 38 lines in our calculus, which
translates to 49 multiset rewrite rules. The model of [23]
contains only four rules, but they are quite complicated,
resulting in 23 lines of code. More importantly, the gap
between their model and the actual Yubikey protocol is
larger – in our calculus, it becomes clear that the server
can treat multiple authentication requests in parallel, as long
as they do not claim to stem from the same Yubikey. An
implementation on the basis of the model from Künnemann
and Steel would need to implement a global lock acces-
sible to the authentication server and all Yubikeys. This
is however unrealistic, since the Yubikeys may be used at
different places around the world, making it unlikely that
there exist means of direct communication between them.
While a server-side global lock might be conceivable (albeit
impractical for performance reasons), a real global
lock
could not be implemented for the Yubikey as deployed.

C. Further Case Studies

We also investigated the case study presented by Möder-
sheim [18], a key-server example. We encoded two models
of this example, one using the insert construct, the other
manipulating state using the embedded multiset rewrite
rules. For this example the second model turned out to
be more natural and more convenient allowing for a direct
automated proof without any additional typing lemma.

We furthermore modeled the contract signing protocol by
Garay et al. [24] and a simple security device which both
served as examples in [17]. In the contract signing protocol
a trusted party needs to maintain a database with the current
status of all contracts (aborted, resolved, or no decision
has been taken). In our calculus the status information is
naturally modelled using our insert and lookup constructs.
The use of locks is indispensable to avoid the status to be
changed between a lookup and an insert. Arapinis et al. [17]
showed the crucial property that the same contract can never
be both aborted and resolved. However, due to the fact that
StatVerif only allows for a ﬁnite number of memory cells,
they have shown this property for a single contract and
provide a manual proof to lift the result to an unbounded
number of contracts. We directly prove this property for an
unbounded number of contracts. Finally we also illustrate
the tool’s ability to analyze classical security protocols, by
analyzing the Needham Schroeder Lowe protocol [3].

VIII. CONCLUSION

We present a process calculus which extends the applied
pi calculus with constructs for accessing a global, shared
memory together with an encoding of this calculus in la-
belled msr rules which enables automated veriﬁcation using
the tamarin prover as a backend. Our prototype veriﬁcation
tool, automating this translation, has been successfully used
to analyze several case studies. As future work we plan
to increase the degree of automation of the tool by auto-
matically generating helping lemmas. To achieve this goal
we can exploit the fact that we generate the msr rules, and
hence control their form. We also plan to use the tool for
more complex case studies including a complete model of
PKCS#11 and a study of the TPM 2.0 standard, currently
in public review. Finally, we wish to investigate how our
constructs for manipulating state can be used to encode
loops, needed to model stream protocols such as TESLA.

Acknowledgements: The research leading to these re-
sults has received funding from the European Research
Council under the European Union’s Seventh Framework
Programme (FP7/2007-2013) / ERC grant agreement no
258865, project ProSecure and was supported by CASED
(http://www.cased.de).

REFERENCES

[1] A. Armando, R. Carbone, L. Compagna, J. Cuellar, and L. T.
Abad, “Formal analysis of saml 2.0 web browser single sign-
on: Breaking the saml-based single sign-on for google apps,”
in Proc. 6th ACM Workshop on Formal Methods in Security
Engineering (FMSE’08), 2008, pp. 1–10.

[2] M. Bortolozzo, M. Centenaro, R. Focardi, and G. Steel,
“Attacking and ﬁxing PKCS#11 security tokens,” in Proc.
17th ACM Conference on Computer and Communications
Security (CCS’10). ACM Press, 2010, pp. 260–269.

[3] G. Lowe, “Breaking and ﬁxing the Needham-Schroeder
public-key protocol using FDR,” in Proc. 2nd International
Workshop on Tools and Algorithms for Construction and
Analysis of Systems (TACAS’96), ser. LNCS, vol. 1055.
Springer, 1996, pp. 147–166.

[4] B. Blanchet, “An Efﬁcient Cryptographic Protocol Veriﬁer
Based on Prolog Rules,” in Proc. 14th Computer Security
Foundations Workshop (CSFW’01).
IEEE Press, 2001, pp.
82–96.

[5] A. Armando, D. A. Basin, Y. Boichut, Y. Chevalier,
L. Compagna, J. Cuéllar, P. H. Drielsma, P.-C. Héam,
O. Kouchnarenko, J. Mantovani, S. Mödersheim, D. von
Oheimb, M. Rusinowitch, J. Santiago, M. Turuani, L. Viganò,
and L. Vigneron, “The AVISPA tool for the automated
validation of internet security protocols and applications.”
in Proc. 17th International Conference on Computer Aided
Veriﬁcation (CAV’05), ser. LNCS. Springer, 2005, pp. 281–
285.

[6] S. Escobar, C. Meadows, and J. Meseguer, “Maude-npa:
Cryptographic protocol analysis modulo equational proper-
ties,” in Foundations of Security Analysis and Design V, ser.
LNCS, vol. 5705. Springer, 2009, pp. 1–50.

177

[7] M. Abadi and C. Fournet, “Mobile values, new names,
and secure communication,” in Proc. 28th ACM Symp. on
Principles of Programming Languages (POPL’01). ACM
Press, 2001, pp. 104–115.

[22] S. Bistarelli, I. Cervesato, G. Lenzini, and F. Martinelli,
“Relating multiset rewriting and process algebras for security
protocol analysis,” Journal of Computer Security, vol. 13,
no. 1, pp. 3–47, 2005.

[8] B. Blanchet, B. Smyth, and V. Cheval, ProVerif 1.88: Au-
tomatic Cryptographic Protocol Veriﬁer, User Manual and
Tutorial, 2013.

[9] PKCS #11: Cryptographic Token Interface Standard., RSA

Security Inc., v2.20, June 2004.

[10] CCA Basic Services Reference and Guide, Oct. 2006, avail-

able online.

[11] Trusted Computing Group, “TPM Speciﬁcation version 1.2.
Parts 1–3, revision 103,” http://www.trustedcomputinggroup.
org/resources/tpm_main_speciﬁcation, 2007.

[12] D. Longley and S. Rigby, “An automatic search for security
ﬂaws in key management schemes,” Computers and Security,
vol. 11, no. 1, pp. 75–89, March 1992.

[13] M. Bond and R. Anderson, “API level attacks on embedded
systems,” IEEE Computer Magazine, pp. 67–75, October
2001.

[14] J. Herzog, “Applying protocol analysis to security device
interfaces,” IEEE Security & Privacy Magazine, vol. 4, no. 4,
pp. 84–87, July-Aug 2006.

[15] B. Schmidt, S. Meier, C. Cremers, and D. Basin, “Automated
analysis of Difﬁe-Hellman protocols and advanced security
properties,” in Proc. 25th IEEE Computer Security Founda-
tions Symposium (CSF’12).
IEEE Press, 2012, pp. 78–94.

[16] ——, “The tamarin prover for the symbolic analysis of
security protocols,” in Proc. 25th International Conference
on Computer Aided Veriﬁcation (CAV’13), ser. LNCS, vol.
8044. Springer, 2013, pp. 696–701.

[17] M. Arapinis, E. Ritter, and M. Ryan, “Statverif: Veriﬁcation
of stateful processes.” in Proc. 24th IEEE Computer Security
Foundations Symposium (CSF’11).
IEEE Press, 2011, pp.
33–47.

[18] S. Mödersheim, “Abstraction by set-membership: verifying
security protocols and web services with databases,” in Proc.
17th ACM Conference on Computer and Communications
Security (CCS’10). ACM, 2010, pp. 351–360.

[19] S. Delaune, S. Kremer, and G. Steel, “Formal analysis of
PKCS#11 and proprietary extensions,” Journal of Computer
Security, vol. 18, no. 6, pp. 1211–1245, Nov. 2010. [Online].
Available: http://www.lsv.ens-cachan.fr/Publis/PAPERS/PDF/
DKS-jcs09.pdf

[20] S. Delaune, S. Kremer, M. D. Ryan, and G. Steel, “For-
mal analysis of protocols based on TPM state registers,” in
Proc. 24th IEEE Computer Security Foundations Symposium
(CSF’11).

IEEE Press, 2011, pp. 66–82.

[21] J. D. Guttman, “State and progress in strand spaces: Proving
fair exchange,” J. Autom. Reasoning, vol. 48, no. 2, pp. 159–
195, 2012.

[23] R. Künnemann and G. Steel, “YubiSecure? Formal security
analysis results for the Yubikey and YubiHSM,” in Proc. 8th
Workshop on Security and Trust Management (STM’12), ser.
LNCS, vol. 7783, 2012, pp. 257–272.

[24] J. A. Garay, M. Jakobsson, and P. D. MacKenzie, “Abuse-
free optimistic contract signing,” in Advances in Cryptology—
Crypto’99, ser. LNCS, vol. 1666. Springer, 1999, pp. 449–
466.

[25] The YubiKey Manual - Usage, conﬁguration and introduction
of basic concepts (Version 2.2), available at: http://www.
yubico.com/documentation, Yubico AB, Kungsgatan 37, 111
56 Stockholm Sweden, June 2010.

[26] Yubico AB,

“Yubico customer

Wed 17 Jul 2013 11:40:50 CEST.
https://www.yubico.com/about/reference-customers/

list,” 2013,

accessed:
[Online]. Available:

APPENDIX

Deﬁnition 17 (Process annotation). Given a ground process
P we deﬁne the annotated ground process P as follows:

0 := 0

P|Q := P|Q
!P := !P

if t1 = t2 then P
else Q
lookup M as x
in P else Q

:= if t1 = t2 then P else Q

:=

lookup M as x
in P else Q

α; P := α; P

where α /∈ { lock t, unlock t : t ∈ T }
lock t; P := lock
where l ∈ N is a fresh label

t; au(P, t, l)

l

l

t; P := unlock

unlock
unlock t; P := ⊥

l

t; P

where au(P, t, l) annotates the ﬁrst unlock that has param-
eter t with the label l, i. e.:

au(P|Q, t, l) := ⊥
au(!P , t, l) := ⊥

au(if t1 = t2 then
P else Q, t, l)
au(lookup M as x
in P else Q, t, l)

:=

:=

if t1 = t2 then au(P, t, l)
else au(Q, t, l)
lookup M as x in
au(P, t, l) else au(Q, t, l)
where α (cid:4)= unlock t
t; P

au(α; P , t, l) := α; au(P, t, l)

l
au(unlock t; P , t, l) := unlock

au(0, t, l) := 0

178

