(Un)linkable Pseudonyms for Governmental Databases

Jan Camenisch

IBM Research – Zurich
jca@zurich.ibm.com

Anja Lehmann

IBM Research – Zurich
anj@zurich.ibm.com

ABSTRACT
When data maintained in a decentralized fashion needs to
be synchronized or exchanged between diﬀerent databases,
related data sets usually get associated with a unique iden-
tiﬁer. While this approach facilitates cross-domain data
exchange, it also comes with inherent drawbacks in terms
of controllability. As data records can easily be linked,
no central authority can limit or control the information
ﬂow. Worse, when records contain sensitive personal data,
as is for instance the case in national social security sys-
tems, such linkability poses a massive security and privacy
threat. An alternative approach is to use domain-speciﬁc
pseudonyms, where only a central authority knows the cross-
domain relation between the pseudonyms. However, current
solutions require the central authority to be a fully trusted
party, as otherwise it can provide false conversions and ex-
ploit the data it learns from the requests. We propose an
(un)linkable pseudonym system that overcomes those limi-
tations, and enables controlled yet privacy-friendly exchange
of distributed data. We prove our protocol secure in the UC
framework and provide an eﬃcient instantiation based on
discrete-logarithm related assumptions.

Categories and Subject Descriptors
D.4.6 [Security and Protection]: Cryptographic control;
H.2.7 [Database Administration]: Security,
integrity,
and protection; K.4.1 [Public Policy Issues]: Privacy

Keywords
pseudonyms; unique identiﬁer; unlinkability; databases

1.

INTRODUCTION

When data is collected and maintained on a large scale,
that data often does not reside in a single database but is
distributed over several databases and organisations, each
being responsible for a particular aspect in the overall sys-
tem. To still allow for collaborative operations and data

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS’15, October 12–16, 2015, Denver, Colorado, USA.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-3832-5/15/10 ...$15.00.
DOI: http://dx.doi.org/10.1145/2810103.2813658 .

exchange among the diﬀerent entities, related data is then
indexed with an identiﬁer that is unique in the entire system.
An important example of such a distributed setting is a
state-controlled social security system maintaining various
sets of personal data. Therein users can interact with diﬀer-
ent entities, such as diﬀerent health care providers, public
and private pension funds, or tax authorities. All these en-
tities can act autonomously in their respective domains and
keep individual records for the users they interact with. In
certain scenarios, the diﬀerent entities also have to exchange
data about particular users. For instance, assume a health
care provider oﬀers special discounts for people with low
income and tax authorities store information about users’
salaries. Then, to verify whether a user is eligible for a dis-
count, the health care system together with the tax author-
ity should be able to check if the user satisﬁes the criteria.
Global Identiﬁers.

Currently, the probably most prominent approach to en-
able such decentralized data management is to use unique
global identiﬁers among all entities.
In the context of so-
cial security systems, this is for instance implemented in the
US, Sweden, and Belgium. Here, each citizen gets assigned a
unique and nation-wide social security number. The advan-
tage of this approach is that it naturally allows all entities
within the system to correlate their individually maintained
records. However, having such a unique identiﬁer for each
user is also a signiﬁcant privacy threat: When data is lost
or stolen, also any adversary obtaining the data can use the
unique identiﬁer to link all the diﬀerent data sets together.
Also, interactions of users with diﬀerent entities become eas-
ily traceable.

Thus, the impact of security breaches is rather severe,
which in turn, makes the data maintained by the individual
entities a lucrative target for data thieves. In addition, as
all entities can trivially link their records, the data exchange
can hardly be controlled and authorized. However, in partic-
ular in the case of a social security system, a certain control
to supervise and, if necessary, limit the data ﬂow is usu-
ally desired. For instance in the Belgium system currently a
central authority called “crossroads bank for social security”
(CBSS) [13], serves as hub for all data exchange. Whenever
social and private entities want to exchange data based on
the global identiﬁcation number, they have to request ex-
plicit authorization from the CBSS, as enforced by national
law. From a privacy point of view, though, this added con-
trollability makes the system even worse, as now a central
authority learns which requests are made for which user. In a
social security system, those requests can reveal quite sensi-

1467tive information itself. For instance, in the example outlined
above, the central authority would learn from the requests
which persons suﬀer from health issues and probably have
low or no income, even if it has no access to the health and
tax records itself. Also in terms of security it still assumes
that all entities behave honestly and do not correlate their
records without approval of the central authority.
Pseudonyms & Controlled Conversion.

Having such a central authority actually allows for a more
privacy-friendly solution. Namely, a central authority (that
we call converter ) could derive and distribute entity-speciﬁc
identiﬁers (aka pseudonyms),
in a way that pseudonyms
known by diﬀerent entities can only be linked with the help
of the converter. Thus, it would then even be technically
enforced that diﬀerent entities have to request permission
from the converter, as without its help they would not be
able to connect their records anymore. Of course, the lat-
ter argument only holds if the data sets maintained by the
entities do not contain other unique identifying information
which allows linkage without using the pseudonyms.

Such a pseudonymous identiﬁcation system clearly im-
proves the controllability of the data exchanges and also
avoids imposing a unique identiﬁer that makes the user
traceable by default. Both are signiﬁcant advantages com-
pared with the solution where only a single global identi-
ﬁer is used throughout the entire system. However, as now
the converter is indeed required in every request it yields a
powerful entity that still must be trusted to not exploit the
information it gathers.
Existing Solutions.

In existing solutions, the need to fully trust the converter
seems in fact inherent. A similar pseudonymous frame-
work using a central converter is for instance described by
Galindo and Verheul [20]. Therein, the converter computes
a pseudonym nym i,A based on main identiﬁer uid i and for
server SA, as nym i,A = Enc(kA, uid i), where Enc is a block-
cipher and kA a symmetric key that the converter has cho-
sen for SA, but is only known to the converter. When
an entity SA then wishes to request some data for nym i,A
from another entity SB,
it sends the pseudonym to the
converter. The converter then decrypts nym i,A to obtain
uid i and derives the local pseudonym nym i,B by computing
nym i,B = Enc(kB, uid i) for the key kB it had chosen for SB.
Thus, here the converter is necessarily modeled as a trusted
third party, as it always learns the generated pseudonyms,
the underlying uid i and also has full control over the trans-
lations it provides (i.e., a corrupt converter could transform
pseudonyms arbitrarily).

Another example is the Austrian eID system [12], which
is one of the few eID solutions that allows one to derive
entity-speciﬁc pseudonyms from the unique social security
number. However, it currently only supports that unlink-
able pseudonyms are created by the users themselves, but
it does not consider a central authority that can provide a
conversion service on a large scale.
It is easy to imagine
though, how such a converter could be realized. Roughly, a
pseudonym nym i,A is computed as H(Enc(k, uid i)||SA), i.e.,
the encrypted main user identiﬁer uid i and the identiﬁer
of the respective entity SA are concatenated and the hash
value of both yields the pseudonym. Here, the key k is a
global key that is used for all pseudonyms, but is again only
known to the converter. In order to enable conversions be-

tween pseudonyms, the converter could simply keep a table
with the related hash values and then perform the conver-
sion based on looking up the corresponding value.

Hereby, the trust requirements for the converter can actu-
ally be reduced if one considers pseudonym generation and
conversion as two diﬀerent tasks. Then, only the entity re-
sponsible for pseudonym generation would have to know
the key k under which the user identiﬁers are encrypted,
whereas the converter merely keeps the hash table with the
related pseudonyms. The converter would then only know
which pseudonyms belong together, but can not determine
for which particular user they are standing for. Thus, also
during conversion, a malicious converter does not learn the
particular user for which a conversion is requested anymore,
but only his pseudonym.

However, the converter can still link all requests that are
made for the same (unknown) user. As each query usually
leaks some context information itself, being able to link all
that information together might still allow the converter to
fully identify the concrete user behind a pseudonym. For in-
stance, regular queries for the same pseudonym to the pen-
sion fund might indicate that the person behind the pseudo-
nym is older than 60 years, and queries to entities that are
associated with a certain region such as local municipalities
further reveal the place that person might live in.

Via the comparable CBSS authority in Belgium, several
hundreds of million messages are exchanged every year, with
a peak of 806 million messages in 2009. Using those values
as a reference for the social security use case, one has to
assume that a converter learning “only” the requests and
their relation would still obtain a signiﬁcant amount of con-
text data. How context information and meta data can be
leveraged to fully de-anonymize pseudonymized data sets,
was recently impressively demonstrated for “anonymized”
credit card transactions [15] and in the Netﬂix and AOL
incidents [21, 5].

Thus,

from a privacy and a security perspective it is
clearly desirable to minimize the information a converter
can collect as much as possible. This means, the con-
verter should not even learn which requests relate to which
pseudonyms.
Other Related Work.

There exists a line of work on reversible pseudonymiza-
tion of data records, in particular in the eHealth context,
aiming at de-sensitizing patient records
[1, 22, 14, 8, 24].
The main focus in these works is to derive pseudonyms from
unique patient identiﬁers, such that the pseudonyms do not
reveal any information about the patient anymore, yet al-
low de-anonymization by a trusted party (or a combination
of several semi-trusted parties). However, in all solutions,
pseudonym generation must be repetitively unambiguous to
preserve the correlation between all pseudonymized records.
Consequently, data exchange is trivial and does not require
a converter. Thus, pseudonyms are linkable by default,
whereas our approach is the opposite: pseudonyms should
be unlinkable by default, yet preserve the correlation which
allows to re-establish the linkage only if necessary via a (po-
tentially untrusted) converter.
Our Contribution.

In this paper we tackle the challenge of enabling privacy-
friendly yet controlled data exchange in a decentralized sys-
tem. That is, we propose an (un)linkable pseudonym system

1468where a converter serves as central hub to ensure controlla-
bility. The converter establishes individual pseudonyms for
each server derived from a unique main identiﬁer that ev-
ery user has, but without learning the derived pseudonyms.
The converter is still the only authority that can link dif-
ferent pseudonyms together, but it does not learn the par-
ticular user or pseudonym for which such a translation is
requested. The converter can not even tell if two data ex-
changes were done for the same pseudonym or for two dif-
ferent ones. Thus, the only information the converter still
learns is that a server SA wants to access data from a server
SB. We consider this to be the right amount of informa-
tion to balance control and privacy. For instance for the use
case of a social security system, it might be allowed that
the health care provider can request data from the tax au-
thority but should not be able to access the criminal records
of its registered users. Thus, there is no need to learn for
which particular user a request is made, or whether several
requests belong together.
In our system, the converter is
able to provide such access control but does not learn any
additional information from the queries.

We start by formally deﬁning the functional and security
properties such an (un)linkable pseudonym system should
ideally provide. Our deﬁnition is formulated in the univer-
sal composability framework, and thus comes with strong
guarantees when composed with other UC secure protocols.
We then describe our system using generic building blocks.
The idea of our solution to build pseudonyms by adding
several layers of randomness to the user identiﬁer, such that
they allow for consistent (and blind) conversions yet hide
the contained identiﬁer towards the servers. Roughly, to
generate a pseudonym nym i,A for a user uid i on server SA,
the converter ﬁrst applies a veriﬁable PRF on uid i and then
raises the derived value to a secret exponent that it assigns
for each server. The trick thereby is that those secret keys
are known only to the converter, but not to the servers.

Now, consider the blind conversion procedure.

It can
of course be realized with a generic multiparty protocol,
where the ﬁrst server SA inputs the pseudonym to be con-
verted and the converter inputs all its secret keys, and the
output of the second server SB would be the converted
pseudonym, provided that the input by SA was a indeed
a valid pseudonym. However, such a computation would be
rather ineﬃcient. We therefore aim to construct a speciﬁc
protocol that achieves this eﬃciently.

We propose a blind conversion protocol that performs the
conversion on encrypted pseudonyms, using a homomorphic
encryption scheme. To transform a pseudonym from one
server to another, the converter then exponentiates the en-
crypted pseudonym with the quotient of the secret keys of
the two servers. The challenge is to make that entire process
veriﬁable, ensuring that the conversion is done in a consis-
tent way but without harming the privacy properties.

To ensure controllability in the sense that a server can
only request conversions for pseudonyms it legitimately ob-
tained via the converter, we also make use of a novel build-
ing block which we call dual-mode signatures. Those allow
to obtain signatures on encrypted messages, which can then
be “decrypted” to a signature on the underlying plaintext
message. We also provide a concrete construction for those
signatures based on the recent signature scheme by Abe et
al. [2], which might be of independent interest. Our dual-
mode signatures can be seen as a spezialised variant of com-

muting signatures [19], and therefore allow for more eﬃcient
schemes.

Finally, we prove that our protocol realizes our ideal func-
tionality based on the security of the building blocks. We
also provide concrete instantiations for all generic building
blocks used in our construction which already come with op-
timizations and enhance the eﬃciency of our solution. When
instantiated with the suggested primitives, our protocol is
secure based on discrete-logarithm related assumptions.

2. SECURITY DEFINITION

In this section we ﬁrst informally discuss the main entities
and procedures in our (un)linkable pseudonym system and
then deﬁne the desired security properties by describing how
an ideal functionality would handle that task.

For the sake of simplicity, we will speak about user iden-
tiﬁer uid i, whenever we mean a unique identiﬁer to which
several distributed data sets should be related. However, it
should not be misunderstood that our system is restricted
to user data, as it can handle arbitrary related data sets dis-
tributed over several servers. The main entities in our sys-
tem are a converter X and a set of servers S = {SA,SB, . . .}.
The converter X is the central authority that blindly de-
rives and converts the (un)linkable pseudonyms. More pre-
cisely, for a user identiﬁer uid i and server identiﬁer SA,
the converter can establish the server-speciﬁc pseudonym
nym i,A. However, this must be done in a way that only SA
is privy of the resulted nym i,A.

All generated pseudonyms can also be veriﬁed by the
In particular, if a server SA does know the un-
servers.
derlying uid i, and the converter allows for veriﬁcation, it
can check that nym i,A is indeed derived from uid i. This is
crucial to allow for a secure migration from an existing in-
dexing system based on unique uid i’s to our pseudonymous
system. However, such a veriﬁcation must be explicitly al-
lowed by the converter. Without his approval, a server even
when knowing some uid i could not verify whether it belongs
to a certain pseudonym nym i,A or not.
A server SA can then maintain data for some user uid i
If SA wants to ac-
who is known to him as nym i,A.
cess some data for the same underlying user from another
server SB, it must initiate a conversion request via the con-
verter. The converter is the only entity that can transform
a pseudonym nym i,A into nym i,B. However, X executes the
conversion function in a blind manner, i.e., without learning
nym i,A, nym i,B, the underlying uid i or even if two requests
are made for the same pseudonym or not. If a conversion is
granted by X , only SB will learn the converted pseudonym
nym i,B. The subsequent data exchange between SA and SB
can be handled using the query identiﬁer qid that is used in
the request and is mapped to nym i,A on SA’s and to nym i,B
on SB’s domain.

Apart from all the privacy features it is of course crucial
that pseudonyms are generated and converted in a consis-
tent way. More precisely, the generated pseudonyms nym i,A
must be unique for each server domain SA and the conver-
sion must be transitive and consistent with the pseudonym
generation.
2.1 Ideal Functionality

We now formally deﬁne such an (un)linkable pseudonym
system with blind conversion by describing an ideal function-
ality in the universal composability (UC) framework [11],

1469which is a general framework for analyzing the security of
cryptographic protocols. Roughly, a protocol is said to se-
curely realize a certain ideal functionality F, if an environ-
ment can not distinguish whether it is interacting with the
real protocol or with F and a simulator. A protocol that is
proven to be secure in the UC framework then enjoys strong
security guarantees even under arbitrary composition with
other (UC secure) protocols. At the end of the section we
will also discuss how the aforementioned (informal) proper-
ties are enforced by our functionality.

In this paper, we assume static corruptions, meaning that
the adversary decides upfront which parties are corrupt and
makes this information known to the functionality. The
UC framework allows us to focus our analysis on a sin-
gle protocol instance with a globally unique session iden-
tiﬁer sid . Here we use session identiﬁers of the form sid =
(sid(cid:48),X , S, U, N), for some converter and server identiﬁers
X , S = {SA,SB, . . .} and a unique string sid(cid:48) ∈ {0, 1}∗.
Further, it must hold that |N| ≥ |U|, where U denotes the
space of user identiﬁers and N the pseudonym space. We
also assume unique query identiﬁers qid = (qid(cid:48),SA,SB)
for each conversion request, containing the identities of the
communicating servers SA and SB. Those unique session
and query identiﬁers can be established, e.g., by exchanging
random nonces between all involved parties and using the
concatenation of all nonces as sid(cid:48) and qid(cid:48) respectively.
The deﬁnition of our ideal functionality Fnym is presented
in detail in Figure 1. For simplicity, we refer to Fnym as F
from now on. We also use the following writing conventions
in order to reduce repetitive notation:
• At each invocation, F checks that sid has the form sid =
(sid(cid:48),X , S, U, N), with |N| ≥ |U|. When we say that F
receives input from or provides output to SA or X , we
mean the particular X or SA ∈ S speciﬁed in the sid .
• For the CONVERT and PROCEED interfaces, F checks
that qid = (qid(cid:48),SA,SB) and only considers the ﬁrst mes-
sage for each pair (sid , qid ). Subsequent messages for the
same (sid , qid ) are ignored.
• When we say that F outputs a message to a party, this
happens directly, i.e, the adversary neither sees the mes-
sage nor can delay it.
• When we say that F sends a message m to A and waits
for m(cid:48) from A, we mean that F chooses a unique exe-
cution identiﬁer, saves the local variables and other rele-
vant information for the current interface invocation, and
sends m together with the identiﬁer to A. When A then
invokes a dedicated resume interface with a message m(cid:48)
and an execution identiﬁer, F looks up the information
associated to the identiﬁer and continues processing the
request for input m(cid:48).
• When we say that F proceeds only under a certain condi-
tion, we implicitly assume that a failure message is sent
to the caller whenever that condition is not fulﬁlled.

We now describe the behaviour of all interfaces also in a
somewhat informal manner to clarify the security properties
that our functionality provides.

Pseudonym Generation.

The NYMGEN interface allows a converter to trigger the
generation of a pseudonym nym i,A for user uid i and server
SA. If no pseudonym for that combination of uid i,SA exists
in F, a new one is created. Thereby, if X or SA are hon-

est, the new pseudonym is chosen at random from N. (In
Figure 1 this is denoted by nym i,A ←$ N.) Only if both,
the converter and the server are corrupt, the adversary can
provide the pseudonym nym∗
i,A. All generated pseudonyms
are stored within F as (nym, sid , uid i,SA, nym i,A), i.e, the
records also include the underlying uid i.
The generated pseudonym nym i,A is then output directly
to SA. Thus, while the converter is the crucial entity to es-
tablish a server-speciﬁc pseudonym, it does not learn the
pseudonym itself. The converter can additionally spec-
ify whether the server output shall consist solely of the
pseudonym, or come in a veriﬁable manner. Veriﬁable means
that the server SA receives a pseudonym nym i,A together
with an underlying uid i, assuring that nym i,A indeed be-
longs to uid i. Such veriﬁcation is indicated with the ﬂag
anon = 0, whereas anon = 1 will hide the uid i from SA. The
reason to include the option anon = 0 and thus the “leakage”
of uid i is that a server might already know and use the uid i
and thus should be able to verify to which particular user a
new pseudonym belongs to (and ideally delete the uid i af-
terwards). Allowing this non-privacy-friendly option might
appear counter-intuitive at a ﬁrst glance. However, with-
out having the possibility to verify whether a pseudonym
indeed belongs to certain uid i, the pseudonyms would have
not much meaning. Thus, we consider the option anon = 0
crucial for bootstrapping such a system, but of course it
should be used with care. We discuss further interesting
strategies for pseudonym provisioning in Section 6.
When both X and SA are corrupt, we also allow the gen-
eration of pseudonyms without assigning a proper uid i ∈ U
Instead, the pseudonyms are stored for a “dummy”
yet.
identiﬁer uid i /∈ U. However, such unassigned pseudonyms
are only allowed as long as X does not wish to provide a
veriﬁable pseudonym, i.e., where anon = 1.

Assign UID.

The ASSIGN interface is only available when the converter
It allows the adversary to replace a “dummy”
is corrupt.
i ∈ U,
identiﬁer uid i /∈ U in all records with a proper uid(cid:48)
if uid(cid:48)
i is not used in any other pseudonym record. After
a pseudonym got a assigned a “proper” identiﬁer uid(cid:48)
i, the
converter can now also distribute the pseudonyms for uid(cid:48)
i
in a veriﬁable manner via the NYMGEN interface.

This reﬂects that, as long as no honest server has veriﬁed
the connection of a pseudonym to a particular user identiﬁer,
all F can guarantee is that pseudonyms that were derived
from each other, all belong together (including transitive re-
lations). However, the relation to a particular uid might still
be unassigned. Only when the converter provides a veriﬁable
pseudonym nym i,A, i.e., it links a pseudonym to its underly-
ing uid , this connection between nym i,A and uid i becomes
known, and must be guaranteed by the ideal functionality
from then on. Which is exactly what this interface does.

Conversion Request.

The CONVERT interface allows a server SA to initiate
a conversion for some pseudonym nym i,A towards another
server SB, and associated with query identiﬁer qid . The
request will only be processed if nym i,A is registered within
F. To ask for the converter’s approval, X is then notiﬁed
about the request. However, X only learns that SA wants to
run a conversion towards SB, but nothing else, in particular
not the pseudonym nym i,A the request was initiated for.

14701. Pseudonym Generation. On input of (NYMGEN, sid , uid i,SA, anon) from converter X :

• If X is honest, only proceed if uid i ∈ U, where U is taken from sid .
• If X is corrupt, also proceed if uid i /∈ U, but only if anon = 1.
• Send (NYMGEN, sid ,SA) to A and wait for (NYMGEN, sid ,SA, nym∗
• If a pseudonym record (nym, sid , uid i,SA, nym i,A) for uid i,SA exists, retrieve nym i,A, otherwise create a new record where

i,A) from A.

nym i,A is determined as follows:
– if X or SA are honest, set nym i,A ←$ N,
– if X and SA are corrupt, and no other pseudonym record for nym∗

• If anon = 1, output (NYMGEN, sid , nym i,A,⊥) to SA and output (NYMGEN, sid , nym i,A, uid i) otherwise.

i,A,SA exists, set nym i,A ← nym∗

i,A. Abort otherwise.

2. Assign UID. On input of (ASSIGN, sid , uid i, uid(cid:48)
• Proceed only if X is corrupt, uid i /∈ U and uid(cid:48)
• If no pseudonym record for uid(cid:48)
• Send (ASSIGN, sid ) to A.

(nym, sid , uid i,SA, nym i,A), abort otherwise.

i) from adversary A:
i ∈ U.

i exists yet, replace the current “dummy” uid i with the “real” uid(cid:48)

i

in all records

3. Conversion Request. On input of (CONVERT, sid , qid , nym i,A,SB) from server SA:
• Proceed only if a record (nym, sid , uid i,SA, nym i,A) for nym i,A,SA exists.
• Send (CONVERT, sid , qid ) to A and wait for response (CONVERT, sid , qid ) from A.
• Create a conversion record (convert, sid , qid , uid i,SA,SB), where uid i is taken from the pseudonym record for nym i,A,SA.
• Output (CONVERT, sid , qid ,SA,SB) to X .

4. Conversion Response. On input of (PROCEED, sid , qid ) from converter X :

• Proceed only if a conversion record (convert, sid , qid , uid i,SA,SB) for qid exists.
• Send (PROCEED, sid , qid ) to A and wait for (PROCEED, sid , qid , nym∗
• If a pseudonym record (nym, sid , uid i,SB, nym i,B) for uid i,SB exists, retrieve nym i,B, otherwise create a new record where

i,B) from A.

nym i,B is determined as follows:
– if X or SB are honest, set nym i,B ←$ N,
– if X and SB are corrupt, and no other pseudonym record for nym∗

• Output (CONVERTED, sid , qid ,SA, nym i,B) to SB.

i,B,SB exists, set nym i,B ← nym∗

i,B. Abort otherwise.

Figure 1: Ideal Functionality Fnym with sid = (sid(cid:48),X , S, U, N)

Conversion Response.
The PROCEED interface allows a converter to blindly
complete a conversion request towards SB. The converted
pseudonym nym i,B is either retrieved from an existing
record using the internal knowledge of the underlying uid i of
the requested nym i,A, or generated from scratch and stored
together with uid i in F. Again, as long as not both, X and
SB are corrupt, the new pseudonym is a random value in N.
Finally, SB (and only SB) receives the converted pseudonym
nym i,B. As F performs the conversion based on the under-
lying uid i, the desired consistency properties are naturally
guaranteed.

Discussion.

Overall, our ideal functionality deﬁned in Figure 1 guar-
antees the following security and privacy properties even in
the presence of corrupted entities.
Security against corrupt SA,SB: The pseudonyms re-
ceived by the servers do not leak any information about
the underlying user identiﬁer uid i, and can only be es-
tablished via the converter. That is, even if a server SA
is corrupt and knows a user identiﬁer uid i, it can not
predict the server-local pseudonym nym i,A himself. This
is enforced by F as it generates pseudonyms only when
requested or allowed (in a conversion) by X and produces
pseudonyms that are merely random values in N.

Further, for pseudonyms nym i,A and nym i,B held by two
corrupt servers SA and SB, the servers cannot tell – with-
out the help of the converter – whether they belong to the
same uid i or not (of course only if the servers do not both
know the underlying uid i from a veriﬁable pseudonym as
otherwise linkage is trivial). This follows again from the

randomness of the pseudonyms. If only one server SA or
SB is corrupt, then the corrupt server cannot use a con-
version to learn any information about the corresponding
pseudonym of the other honest server – even if the con-
verter is corrupt too: our functionality does not give any
output to SA, and SB only receives (qid , nym i,B), but
not the initial nym i,A.
Security against corrupt X : If the converter is corrupt,
it can trigger pseudonyms for uid i’s and servers SA of
its choice, however X can not determine or predict the
pseudonym values whenever they are generated for an
honest server (neither via pseudonym generation nor con-
version). This is guaranteed by our deﬁnition as F gener-
ates new pseudonyms as random values in N and outputs
them directly to the respective server, i.e, without the ad-
versary seeing them.

Further,
in a conversion request between two honest
servers SA and SB, a corrupt converter does not learn
any information about the pseudonym nym i,A or nym i,B,
or even whether two request where made for the same
pseudonym or not. This follows clearly from F, as the
only information X gets is that SA requested a conver-
sion towards SB. If the converter and one of the servers is
corrupt, the adversary can of course learn the pseudonym
If even both SA,SB are cor-
of the corrupted server.
rupt, then the adversary obviously learns all involved
pseudonyms, but this is unavoidable.

Our functionality also guarantees consistency, even in the
presence of a corrupt converter. That is, even when gen-
erated or converted by a corrupt X , honest servers are
ensured that pseudonym generation is injective, conver-
sion is transitive and both procedures generate consistent

1471pseudonyms. This is naturally enforced by our function-
ality as F is aware of the underlying uid i and uses that
knowledge to ensure consistent conversions and a unique
pseudonym for each (uid i,SA) combination.

3. BUILDING BLOCKS

Here, we introduce the building blocks for our construc-
tion. Apart from standard proof protocols, (veriﬁable) pseu-
dorandom functions and homomorphic encryption we also
need a new primitive which we call dual-mode signatures.
We provide a formal deﬁnition for those signature schemes
and also detail an instantiation based on the structure-
preserving signature scheme by Abe et al. [2].
3.1 Bilinear Maps
Let G, ˜G and Gt be groups of prime order q. A map
e : G × ˜G → Gt must satisfy bilinearity, i.e., e(gx, ˜gy) =
e(g, ˜g)xy; non-degeneracy, i.e., for all generators g ∈ G and
˜g ∈ ˜G, e(g, ˜g) generates Gt; and eﬃciency, i.e., there exists
an eﬃcient algorithm G(1τ ) that outputs the bilinear group
(q, G, ˜G, Gt, e, g, ˜g) and an eﬃcient algorithm to compute
e(a, b) for any a ∈ G, b ∈ ˜G. If G = ˜G the map is symmetric
and otherwise asymmetric.
3.2 Proof Protocols

When referring to the zero-knowledge proofs of knowl-
edge of discrete logarithms and statements about them,
we will follow the notation introduced by Camenisch and
Stadler [10] and formally deﬁned by Camenisch, Kiayias,
and Yung [9].
For instance, PK{(a, b, c) : y = gahb ∧ ˜y = ˜ga˜hc} de-
notes a “zero-knowledge Proof of Knowledge of integers a,
b and c such that y = gahb and ˜y = ˜ga˜hc holds,” where
y, g, h, ˜y, ˜g and ˜h are elements of some groups G = (cid:104)g(cid:105) = (cid:104)h(cid:105)
and ˜G = (cid:104)˜g(cid:105) = (cid:104)˜h(cid:105). Given a protocol in this notation, it is
straightforward to derive an actual protocol implementing
the proof [9]. SPK denotes a signature proof of knowledge,
that is a non-interactive transformation of a proof with the
Fiat-Shamir heuristic [18].
Often we use a more abstract notation for proofs, e.g., by
NIZK{(w) : statement(w)} we denote any zero-knowledge
proof protocol of knowledge of a witness w such that the
statement(w) is true. The idea is that when we use SPK
we have the concrete realization in mind whereas with
NIZK we mean any non-interactive zero-knowledge proof.
Sometimes we need witnesses to be online-extractable,
which we make explicit by denoting with NIZK{(w1, w2) :
statement(w1, w2)} the proof of witnesses w1 and w2, where
w1 can be extracted.
3.3 (Veriﬁable) Pseudorandom Functions

To generate pseudonyms and verify their correct gener-
ation, we require a pseudorandom function PRF that al-
lows for a proof that it was correctly computed.
Infor-
mally, a pseudorandom function PRF(x, i) with key gener-
ation (x, y) ←$ PRFKGen(1τ ) is veriﬁable if it allows for an
eﬃcient proof that a value z is a proper PRF output for input
i and secret key x: πz ←$ NIZK{(x) : z = PRF(x, i)}(i, z).
Dodis and Yampolskiy [16] have proposed such a function,
PRFG(x, i) = g1/(x+i), which works in a cyclic group G = (cid:104)g(cid:105)
of order q. The pseudorandomness of which is based on
the q-Decisional Diﬃe-Hellman Inversion problem [7]. The

algorithms for it are as follows (here we deviate from their
algorithms in the way we deﬁne the proof as we require that
the proof algorithm be zero-knowledge).
The key generation PRFKGenG(1τ ) generates a random
secret key x ∈ Zq with corresponding public key y ← gx.
The proof πz of correct computation of the PRF, i.e., z =
PRFG(logg y, i), does not need to be online extractable in our
construction, and thus is as follows: πz ←$ SPK{(x) : y =
gx ∧ g/zi = zx}(y, g, i, z).

We will also need a standard (i.e., non-veriﬁable) pseu-
dorandom permutation, which consists of a key generation
k ←$ PRPKGenG(1τ ), a function z ← PRPG(k, i) and its eﬃ-
ciently computable inverse i ← PRP−1G (k, z). For simplicity,
we assume PRPG to work in a group G as well.
3.4 Homomorphic Encryption Schemes

We require an encryption scheme (EncKGenG, EncG, DecG)
that is semantically secure and that has a cyclic group G
as message space. It consists of a key generation algorithm
(epk , esk ) ←$ EncKGenG(1τ ), where τ is a security parameter,
an encryption algorithm C ←$ EncG(epk , m), with m ∈ G,
and a decryption algorithm m ← DecG(esk , C). Sometimes
we will make the randomness used in the encryption process
explicit, in which case we will write C ← EncG(epk , m, r),
where r encodes all the randomness, i.e., EncG(·,·,·) is a
deterministic algorithm.

We require further that the encryption scheme has an
appropriate homomorphic property, namely that there is
an eﬃcient operation (cid:12) on ciphertexts such that, if C1 ∈
EncG(epk , m1) and C2 ∈ EncG(epk , m2), then C1 (cid:12) C2 ∈
EncG(epk , m1 · m2). We will also use exponents to denote
the repeated application of (cid:12), e.g., C 2 to denote C (cid:12) C.

ElGamal Encryption (with a CRS Trapdoor).

We use the ElGamal encryption scheme, which is homo-
morphic and chosen plaintext secure. The semantic security
is suﬃcient for our construction, as the parties always prove
to each other that they formed the ciphertexts correctly. Let
(G, g, q) be system parameters available as CRS such that
the DDH problem is hard w.r.t. τ , i.e., q is a τ -bit prime.
EncKGenG(1τ ) : Pick random ¯x from Zq , compute ¯y ← g ¯x,

and output esk ← ¯x and epk ← ¯y.

EncG(epk , m) : To encrypt a message m ∈ G under epk =
¯y, pick r ←$ Zq and output the ciphertext (C1, C2) ←
(¯yr, grm).

.

−1/¯x
1

DecG(esk , C) : On input the secret key esk = ¯x and a ci-

phertext C = (C1, C2) ∈ G2, output m(cid:48) ← C2 · C
In our concrete instantiation we will use a variation of
ElGamal encryption with a CRS trapdoor, which allows
to make proofs for correct ciphertexts eﬃciently online ex-
tractable. That is, we assume that the CRS additionally
contains a public key ˆy. For encryption, each ciphertext
gets extended with an element C0 ← ˆyr, which will be ig-
nored in normal decryption.
In our security proof of the
overall scheme, the simulator will be privy to ˆx = logg ˆy as
it can set the CRS appropriately and thus is able to decrypt
as m(cid:48) ← C2 · C
3.5 Signatures Schemes
We require two diﬀerent kinds of signature schemes: One
signature scheme is needed for server SA to sign a request

−1/ˆx
0

.

1472to the converter so that later a server SB can verify that
what it gets from the converter stems indeed from server SA.
For this, any standard signature scheme (SigKGen, Sign, Vf)
is suﬃcient. Such as scheme consists of a key generation
algorithm (spk , ssk ) ←$ SigKGen(1τ ), a signing algorithm
σ ←$ Sign(ssk , m), with m ∈ {0, 1}∗, and a signature ver-
iﬁcation algorithm {0, 1} ← Vf(spk , σ, m). The security def-
initions are standard and we thus do not repeat them here.
The second signature scheme we require is for the con-
verter to sign pseudonyms. This scheme needs to sup-
port the signing of plain pseudonyms as well as encrypted
pseudonyms. Also it needs to allow for (eﬃcient) proofs of
knowledge of a signature on a pseudonym that is encrypted.
Commuting signatures [19] would ﬁt our bill here. How-
ever, because of their generality, their use would make our
construction much less eﬃcient than what we present. The
reason for that is that almost all inputs and outputs in the
construction come with non-interactive proofs that they are
well deﬁned. As the deﬁnitions for commuting signatures
also include these proofs, we cannot use (a subset of) these
either. Blazy et al. [6] deﬁne signature schemes that can sign
(randomizable) ciphertexts. Such schemes are a special case
of commuting signatures and much closer to what we need.
However, the security deﬁnition they give requires that the
keys for the encryption scheme be honestly generated and
the decryption key be available in the security game. This
means that when using such a scheme in a construction,
the decryption keys need to be extractable from adversar-
ial parties and correct key generation enforced, which would
lead to less eﬃcient schemes. We therefore need to provide
our own deﬁnition that does not suﬀer from the drawbacks
discussed. We call this a dual-mode signature scheme as it
allows one to sign messages in the plain as well as when they
are contained in an encryption.

Finally, we point out that the dual-mode signatures are
similar to blind signature schemes, where the signer also
signs “encrypted” messages. Now the typical security deﬁ-
nition for blind signatures requires only that an adversary
be not able to produce more signatures than he ran sign-
ing protocols with the signer. That kind of deﬁnition would
not be good enough for us – for our construction we need
to be sure that the signer indeed only signs the message
that is contained in the encryption. Further, the setting for
which we will use those dual-mode signatures would not be
in our protocol a server SA
realizable by blind signatures:
encrypts a message under a public key of a server SB, the
converter then signs a derivation of the ciphertext, and SB
ﬁnally decrypts the signature.

Dual-Mode Signature Schemes.

A dual-mode signature scheme consists of the algorithms
(SigKGenG, SignG, EncSignG, DecSignG, VfG and also uses an
encryption scheme (EncKGenG, EncG, DecG) that has the
group G as message space.
In particular, the algorithms
working with encrypted messages or signatures also get the
keys (epk , esk ) ←$ EncKGenG(1τ ) of the encryption scheme
as input.

SigKGenG(1τ ) : On input the security parameter and be-
ing parameterized by G, this algorithm outputs a public
veriﬁcation key spk and secret signing key ssk .
m ∈ G outputs a signature σ.

SignG(ssk , m) : On input a signing key ssk and a message

EncSignG(ssk , epk , C) : On input a signing key ssk , a public
encryption key epk , and ciphertext C = EncG(epk , m),
outputs an “encrypted” signature σ of C.

DecSignG(esk , spk , σ) : On input an “encrypted” signature
σ, secret decryption key esk and public veriﬁcation key
spk , outputs a standard signature σ.

VfG(spk , σ, m) →$ {0, 1} : On input a public veriﬁcation key
spk , signature σ and message m, outputs 1 if the signa-
ture is valid and 0 otherwise.
For correctness, we require that for all (spk , ssk ) ←$
SigKGenG(1τ ),
all
m ∈ G,
in
EncG(·,·), and EncSignG(·,·,·), we have that VfG(spk ,
SignG(ssk , m), m) = 1 and VfG(spk , DecSignG(esk , spk ,
EncSignG(ssk , epk , EncG(epk , m))), m) = 1

EncKGenG(1τ ),
in Sign(·,·),

(epk , esk ) ←$

all

and all

random choices

In terms of security, we extend the standard unforgeabil-
ity deﬁnition to allow the adversary to also get signatures
on encrypted messages. Thereby, the oracle OEncSign will
only sign correctly computed ciphertexts, which is modeled
by providing an additional encryption oracle OEnc and only
sign ciphertexts that were generated via OEnc. When using
the scheme, this can easily be enforced by asking the signa-
ture requester for a proof of correct ciphertext computation,
and, indeed, in our construction such a proof is needed for
other reasons as well. Note that we do not require that the
“encrypted” signature output by EncSignG does not leak any
information about the signature contained in it.

A,DMSIG,EncG (G, τ ):

Experiment ExpDMSIG-forge
(spk , ssk ) ←$ SigKGen(1τ )
L ← ∅; C ← ∅
(m∗, σ∗) ←$ AOSign(ssk ,·),OEnc(·,·),OEncSign(ssk ,·,·)(spk )
where OSign on input (mi):
add mi to the list of queried messages L ← L ∪ mi
return σ ←$ SignG(ssk , mi)
where OEnc on input (epk i, mi):
run Ci ←$ EncG(epk i, mi) and add (epk i, Ci, mi) to C
return Ci
where OEncSign on input (epk i, Ci):
retrieve (epk i, Ci, mi) from C, abort if it doesn’t exist;
add mi to the list of queried messages L ← L ∪ mi
return σ ←$ EncSignG(ssk , epk i, Ci)

return 1 if VfG(spk , σ∗, m∗) = 1 and m∗ /∈ L

Figure 2: Unforgeability experiment for dual-mode
signatures

Definition 3.1. (Unforgeability of Dual-Mode
Signatures). We say a dual-mode signature scheme is
unforgeable if for any eﬃcient algorithm A the probability
that the experiment given in Figure 2 returns 1 is negligible
(as a function of τ ).

AGOT+ (Dual-Mode) Signature Scheme.

To instantiate the building block of dual-mode signa-
tures we will use an extension of the structure-preserving
signature scheme by Abe et al. [2], which we denote as
AGOT+ scheme. First, we recall the original AGOT scheme
(SigKGenG, SignG, Vf G) slightly adapted to our notation, and
then we describe how to instantiate the additional algo-
rithms EncSignG and DecSignG with respect to a homomor-
phic encryption scheme (EncKGenG, EncG, DecG).

1473consisting

AGOT assumes

the

availability

of
crs = (q, G, ˜G, Gt, e, g, ˜g, x)

system pa-
rameters
of
(q, G, ˜G, Gt, e, g, ˜g) ←$ G(1τ ) and an additional random
group element x ←$ G, that is, the key generation is split
in two parts, one that generates the public parameters and
one that generates the public and secret keys for the signer.
For our construction, the former part will also generate
the group G that will also be the message space of the
encryption scheme. Thus, SigKGenG becomes that second
part of the AGOT key generation, abusing notation, we
give it the public parameters as input instead of the security
parameter τ . For all other algorithms, we assume that the
public parameters, in particular the group G, are given as
implicit input.
SigKGenG(q, G, ˜G, Gt, e, g, ˜g, x) : Choose a random v ←$ Zq ,

compute y ← ˜gv, and return spk = y and ssk = v.

SignG(ssk , m) : On input a message m ∈ G and key ssk = v,
q , and output the signature σ =

choose a random u ←$ Z∗
(r, s, t, w) including the randomization token w where:
t ← (sv · g)1/u, w ← g1/u.
r ← ˜gu,
VfG(spk , σ, m) : Parse σ = (r, s, t, w(cid:48)) and spk = y and ac-

s ← (mv · x)1/u,

cept if and only if m, s, t ∈ G, r ∈ ˜G, and

e(s, r) = e(m, y) · e(x, ˜g),

e(t, r) = e(s, y) · e(g, ˜g).

Note that for notational simplicity, we consider w part of
the signature, i.e., σ = (r, s, t, w), but that the veriﬁcation
equation does not perform any check on w. As pointed out
by Abe et al., a signature σ = (r, s, t) can be randomized
using the randomization token w to obtain a signature σ(cid:48) =
(r(cid:48), s(cid:48), t(cid:48)) by picking a random u(cid:48) ←$ Z∗

q and computing

(cid:48) ← ru(cid:48)

r

,

(cid:48) ← s1/u(cid:48)

s

,

(cid:48) ← (tw(u(cid:48)−1))1/u(cid:48)2

t

.

This randomization feature is useful to eﬃciently prove
knowledge of a signature on an encrypted message, which is
needed in our protocol. We show in Section 5 how such a
proof can be constructed.

Now, we present the additional algorithms that allow to

obtain signatures on encrypted messages M 1.

EncSignG(ssk , epk , M ) : On input a proper encryption M =
EncG(epk , m) of a message m ∈ G under epk , and secret
keyssk = v, choose a random u ←$ Z∗
q , and output the
(partially) encrypted signature ¯σ = (r, S, T, w):
r ← ˜gu, S ← (M v (cid:12) EncG(epk , x))1/u,
T ← (Sv (cid:12) EncG(epk , g))1/u, w ← g1/u.

DecSignG(esk , spk , σ) : Parse σ = (r, S, T, w), compute
s ← DecG(esk , S), t ← DecG(esk , T ) and output σ =
(r, s, t, w).
It is not hard to see that σ = (r, s ← DecG(esk , S), t ←
DecG(esk , T ), w) is a valid signature on m ← DecG(esk , M ),
and that the distribution of these values is the same as
when m was signed directly. More formally, we prove
that the AGOT scheme extended with the above algorithms
EncSignG, DecSignG yields an unforgeable dual-mode signa-
ture scheme. The proof is given in the full paper.

1In the AGOT+ scheme, we write M to denote the encryp-
tion of a message m, instead of C. Likewise, capital letters
S, T denote the encrypted versions of the values s, t that
would be computed in a standard AGOT signature.

Theorem 3.2

(Unforgeability of AGOT+). If the
AGOT signature scheme (SigKGenG, SignG, VfG) is an un-
forgeable signature scheme then, together with the algorithms
EncSignG, DecSignG described above, the AGOT+ scheme
(SigKGenG, SignG, EncSignG, DecSignG, Vf G) is an unforge-
able dual-mode signature scheme.

For our construction, we also require the signer to prove
that it computed the signature on an encrypted message
correctly.
In Section 5 we describe how such a proof can
be done. (Intuitively, one would think that one could just
decrypt and then verify whether the result is a valid signa-
ture. However, we cannot do this in the security proof of
our pseudonym scheme where we reduce to the security of
the homomorphic encryption scheme, as then we don’t have
a decryption oracle.)

4. OUR PROTOCOL

In this section we present our protocols for an (un)linkable
pseudonym system. We ﬁrst give a high-level idea and then
explain the detailed construction.

Roughly, the computation of pseudonyms is done in sev-
eral layers, each adding randomness to the process such
that the ﬁnal pseudonym nym i,A is indistinguishable from
a random value (if not both, X and SA, are corrupt) as
required by our ideal functionality. At the same time, the
pseudonyms must still have some (hidden) structure, which
allows the consistent transformation of pseudonyms by the
converter.
The main idea is to let the converter ﬁrst derive a pseu-
dorandom “core identiﬁer” zi ← PRFG(xX , uid i) from uid i
and for secret key xX . From the unique core identiﬁer zi,
the converter then derives its pseudonym contribution using
a secret exponent xA that it chooses for each server SA ∈ S,
but never reveals to them.
For the blind conversion, we use homomorphic encryption
so that the ﬁrst server SA can encrypt the pseudonym for
the second server SB hand this encryption to the converter,
who, using the homomorphic properties of the encryption
scheme, raises the encrypted pseudonym to the quotient of
the two servers’ secret keys, thereby transforming the en-
crypted pseudonym.

The tricky part is to make this whole pseudonym gener-
ation and conversion process veriﬁable and consistent, but
without harming the unlinkability and blindness properties.
In particular, for pseudonym generation a server SA must be
ensured that it receives correctly formed pseudonyms. For
conversion, SA needs to prove to the converter that it en-
crypted a valid pseudonym, and the converter needs to prove
to the server SB that it applied the conversion correctly.
This is achieved by a careful composition of nested encryp-
tion, dual-mode signatures which allow signing of plain and
encrypted messages, and zero-knowledge proofs.

In the following we give the detailed description of our
protocol and also provide some intuition for the protocol
design.
4.1 Detailed Description
We now describe our protocol assuming that a certiﬁcate
authority functionality FCA, a secure message transmission
functionality FSMT (enabling authenticated and encrypted
communication), and a common reference string function-
ality FCRS are available to all parties. For details of those

1474functionalities we refer to [11]. FCRS provides all parties
with the system parameters, consisting of the security pa-
rameter τ and a cyclic group G = (cid:104)g(cid:105) of order q (which is a
τ -bit prime). In the description of the protocol, we assume
that parties call FCA to retrieve the necessary key material
whenever they use a public key of another party. Further,
if any of the checks in the protocol fails, the protocol ends
with a failure message.

Converter Setup:
(epkX , eskX ) ←$ EncKGenG(1τ )
(xX , yX ) ←$ PRFKGenG(1τ )
for each server SA ∈ S:

(spkX ,A, sskX ,A) ←$ SigKGenG(1τ )
choose a random xA ←$ Zq and compute yA ← gxA

store skX ← (eskX , xX ,{xA, sskX ,A}∀SA∈S)
register pkX ← (epkX , yX ,{yA, spkX ,A}∀SA∈S) with FCA
Server Setup (by each server SA ∈ S):
(epk A, esk A) ←$ EncKGenG(1τ )
(spk A, ssk A) ←$ SigKGen(1τ )
kA ←$ PRPKGenG(1τ )
store sk A ← (esk A, ssk A, kA)
register pk A ← (spk A, epk A) with FCA

Figure 3: Setup of Converter and Servers

Setup.

Before starting a new instance of our

(un)linkable
pseudonym system, we assume that the converter and all
servers use standard techniques [11, 4] to agree on a session
identiﬁer sid = (sid(cid:48),X , S, U, N) where sid(cid:48) is a fresh and
unique string, X and S = {SA,SB, . . .} denote the identities
of the communicating parties, and U = Zq and N = G deﬁne
the domain of user identiﬁers and pseudonyms respectively.
Then, whenever a new sid has been agreed on, all speciﬁed
entities X and S generate their keys as described in Fig-
ure 3. For simplicity, we assume that the converter setup
is trusted and discuss in the full paper how this assumption
can be relaxed (e.g., by adding NIZKs proving knowledge of
the secret keys, or distributed key generation).

Pseudonym Generation.
A pseudonym nym i,A for main identiﬁer uid i and server
SA is jointly computed by the server and the converter
X , as depicted in Figure 4. The generation is initiated
by the converter and starts by applying a pseudorandom
function to uid i obtaining a secret “core identiﬁer” zi ←
PRFG(xX , uid i). As xX is a secret key known only to the
converter, the servers are not privy of the mapping between
uid i and zi. From the core identiﬁer zi – which is the same
for all servers in S – the converter then derives a server-
speciﬁc “inner pseudonym” xnym i,A ← zxA
for a secret con-
version value xA that X chooses internally for every server
SA, but never reveals to them. By using a veriﬁable PRF
and proving correctness of the computation in πnym , the en-
tire process of deriving the inner pseudonym xnym i,A can
be veriﬁed by the server. If anon = 0, i.e., the pseudonym
should be veriﬁably derived from a particular uid i that is
also given to the server, the proof is done w.r.t. that uid i,
whereas for anon = 1, πnym only shows that the pseudonym
was formed correctly for some uid i. In the latter case, the
proof actually shows that the pseudonym is of the correct

i

i

for some zi ∈ G and also allows for
form xnym i,A = zxA
extraction of zi as this will be required in the security proof.
The inner pseudonym xnym i,A gets also accompanied with
a server-speciﬁc signature σnym generated by the converter
(using a dedicated signing key for each server). This signa-
ture will be crucial in a conversion request to ensure that
only the server SA, for which the pseudonym was intended
for, can subsequently use it in a conversion. We use the dual-
mode signature for that purpose, as the converter needs to
sign pseudonyms also in a blind way when they are gener-
ated via a conversion request.
When receiving a correctly signed and derived xnym i,A,
the server SA then adds the ﬁnal pseudonym layer by apply-
ing a pseudorandom permutation to xnym i,A for secret key
kA as nym i,A ← PRPG(kA, xnym i,A). This ensures that the
server’s output nym i,A cannot be linked to xnym i,A or uid i
by a corrupt converter.

Conversion Request.
When a server SA wishes to convert a pseudonym nym i,A
towards a server SB, it sends a conversion request to X , as
described in Figure 5. Each request also comes with a unique
query identiﬁer qid (which can be established through the
same standard techniques as sid ). To achieve blindness of
the request towards X , the server encrypts the unwrapped
inner pseudonym xnym i,A under SB’s public key. We also
add a second layer of encryption using X ’s public key. This
nested encryption is necessary to allow X to later prove cor-
rectness of a conversion towards the target server SB, but
without SB learning the value xnym i,A. The signature σC of
SA on the nested encryption serves the same purpose. Both,
the signature and proof are thereby bound to the query iden-
tiﬁer qid , such that a corrupt X cannot reuse the values in
a diﬀerent session.
Finally, we also want to ensure that SA can only trig-
ger conversions of correct pseudonyms that “belong” to the
server. Therefore, SA has to prove in πA that the ciphertext
sent in the request contains a pseudonym xnym i,A that is
signed under the correct key of the converter (but without
revealing the signature).
When the converter X receives such a request, it ﬁrst veri-
ﬁes the signature σC and proof πA. If both are valid, X asks
the environment whether it shall proceed. This is the hook
to some external procedure which decides if the conversion
from SA to SB shall be granted or not.

Conversion Response.
If the converter gets the approval to proceed, X and SB
complete the conversion as depicted in Figure 5. First, X
uses the homomorphic property of the encryption scheme
and raises the encrypted pseudonym to the quotient xB/xA
of the two servers’ secret conversion keys, thereby blindly
transforming the encrypted inner pseudonym into xnym i,B.
The converter also re-randomizes the ciphertext by multi-
plying an encryption of “1” which is crucial for prooﬁng un-
linkability. To allow SB to subsequently use the obtained
pseudonym, the converter also “blindly” signs the encrypted
xnym i,B with the dual-mode signature scheme. For ensur-
ing consistency of a conversion (even in the presence of a
corrupt converter), X proves correctness of the transforma-
tion in πX . The converter then sends the encrypted inner
pseudonym xnym i,B as C(cid:48)(cid:48) with encrypted signature σnym
to SB, and also forwards the received tuple (C, σC , πA).

1475Step1. Upon input (NYMGEN, sid , uid i,SA, anon), converter X generates its pseudonym contribution:
a) Check that uid i ∈ Zq, and if so compute xnym i,A ← PRFG(xX , uid i)xA and σnym ← SignG(sskX ,A, xnym i,A).
b) Prove correctness of the pseudonym generation in the proof πnym :

if anon = 0 :

if anon = 1 :

πnym ←$ NIZK{(xA, xX , zi) : xnym i,A = zxA
πnym ←$ NIZK{(xA, zi) : xnym i,A = zxA

i

i

∧ yA = gxA ∧ zi = PRFG(xX , uid i)}(sid ) .

∧ yA = gxA ∧ zi ∈ G}(sid ),

and set uid i ← ⊥ .

c) Send (sid , xnym i,A, σnym , πnym , uid i) via FSMT to SA, end with no output.
Step2. Upon receiving (sid , xnym i,A, σnym , πnym , uid i) from X , SA veriﬁes input and derives ﬁnal pseudonym:
a) Verify that VfG(spkX ,A, σnym , xnym i,A) = 1 and that the proof πnym is correct w.r.t. yA and yX , uid i (if uid i (cid:54)= ⊥).
b) Compute nym i,A ← PRPG(kA, xnym i,A), store (sid , nym i,A, σnym ) and end with output (NYMGEN, sid , nym i,A, uid i).

Figure 4: Pseudonym Generation

When SB receives a conversion request, it ﬁrst checks that
σC , πA are valid, ensuring that the request indeed was trig-
gered by SA for query qid and for the pseudonym contained
in C. When SB also veriﬁed the correctness of the conver-
sion via πX , it decrypts xnym i,B and corresponding signa-
ture σnym . The ﬁnal pseudonym nym i,B is again derived
using the PRPG.
It stores the pseudonym and signature,
and outputs nym i,B together with the query identiﬁer qid .
4.2 Security and Efﬁciency

Our protocol described above securely realizes the ideal
functionality Fnym deﬁned in Section 2. The detailed proof
of the following theorem is given in the full paper.

Theorem 4.1. The (un)linkable pseudonym system de-
scribed in Section 4 securely implements the ideal function-
ality Fnym deﬁned in Section 2 in the (FCA,FCRS,FSMT)
hybrid-model, provided that

– (EncKGenG, EncG, DecG) is a semantically secure homomor-

phic encryption scheme,

– (SigKGenG, SignG, EncSignG, DecSignG, VfG) is an unforge-

able dual-mode signature scheme (as deﬁned in Def. 3.1),

– (SigKGen, Sign, Vf) is an unforgeable signature scheme,
– (PRFKGenG, PRFG) is a secure and veriﬁable pseudorandom

function,

– (PRPKGenG, PRPG) is a secure pseudorandom permutation,
– the proof
zero-knowledge,
simulation-sound and online-extractable (for the underlined
values), and

system used for NIZK is

– the DDH-assumption holds in group G.

for

When

signatures

[25,

23]

scheme

the ElGamal

instantiated with

(EncKGenG, EncG, DecG),

encryp-
with
tion
(SigKGen, Sign, Vf),
Schnorr
for
with the AGOT+ dual-mode
(SigKGenG, SignG, EncSignG, DecSignG, VfG), with the Dodis-
Yampolskiy-PRF [16] for (PRFKGenG, PRFG), and with the
proof-protocols and “lazy” PRPG described in Section 5,
then by the security of the underlying building blocks we
have the following corollary:

for
signature

scheme

Efﬁciency.

With the primitives instantiated as stated above, we ob-
tain the following eﬃciency ﬁgures, where expG denotes an
exponentiation in group G and pair stands for a pairing com-
putation. Many of these exponentiations can be merged into
multi-base exponentiations which allows to substantially op-
timize the computational complexity.
Converter X

PseudonymGeneration :
ConversionRequest :
ConversionResponse :

Server (SA or SB)

10(+1)expG + 1 exp˜G

7 expG + 4 expGt + 8 pair

34 expG + 2 exp˜G

PseudonymGeneration :
ConversionRequest :
ConversionResponse :

4(+1)expG + 4 pair

8 expG + 4 expGt + 8 pair
30 expG + 5 expGt + 12 pair

4.3 Honest-but-Curious Converter

Our protocol achieves very strong security against active
attacks, tolerating even a fully corrupt converter. One might
argue though that a converter in our system is at most of
the honest-but-curious type, i.e., the converter will always
perform the protocol correctly but might aim at exploiting
the information it sees or loose its data. Then, it will be suf-
ﬁcient to consider a weaker model where the converter will
either be non-corrupted or of such honest-but-curious type.
Regarding servers, considering active attacks is less debat-
able, however. Indeed, our pseudonym system can be used
by a multitude of servers, possibly from private and public
domains, and thus security should hold against servers that
behave entirely malicious (as in our notion).

If one is willing to assume the weaker honest-but-curious
adversary model for the converter, one can easily derive a
more light-weight version from our protocol. Roughly, all
parts where the converter proves correctness of its compu-
tations can be omitted. We now brieﬂy sketch the necessary
changes to our protocol and their impact on the eﬃciency
numbers.

Corollary 4.1. The (un)linkable pseudonym system de-
scribed in Section 4 and instantiated as described above, se-
curely realizes Fnym in the (FCA,FCRS,FSMT)-hybrid model
under the Symmetric eXternal Decision Diﬃe-Hellman
(SXDH) assumption [3], the q-Decisional Diﬃe-Hellman In-
version assumption [7], and the unforgeability of the AGOT
scheme (which holds in the generic group model).

Pseudonym Generation.

In the pseudonym generation, the proof generation πnym
by the converter and the veriﬁcation of πnym and received
signature σnym by the server SA can be omitted. This re-
duces the complexity of the converter’s part to 6expG+1 exp˜G
and SA has to perform no exponentiation or pairing any-
more.

1476ConversionRequest : The server SA requests a conversion of pseudonym nym i,A towards server SB.
Step1. Upon input (CONVERT, sid , qid , nym i,A,SB), Server SA computes and sends request:
a) Retrieve (sid , nym i,A, σnym ) for nym i,A and abort if no such record exists.
b) Compute xnym i,A ← PRP−1G (kA, nym i,A), C ←$ EncG(epkX , EncG(epk B, xnym i,A)), and σC ← Sign(ssk A, (sid , qid , C)).
c) Prove knowledge of a converter’s signature σnym on the underlying xnym i,A and under key spkX ,A:

πA ←$ NIZK{(xnym i,A, σnym ) : VfG(spkX ,A, σnym , xnym i,A) = 1 ∧ C = EncG(epkX , EncG(epk B, xnym i,A))}(sid , qid ).

d) Send (sid , qid , C, πA, σC ,SB) via FSMT to X and end with no output.
Step2. Upon receiving (sid , qid , C, πA, σC ,SB) from SA, X veriﬁes request and asks for permission to proceed:
a) Verify that Vf(spk A, σC , (sid , qid , C)) = 1 and πA is correct w.r.t. spkX ,A and the received ciphertext C.
b) Store (convert, sid , qid , C, πA, σC ,SA,SB) and output (CONVERT, sid , qid ,SA,SB)

ConversionResponse : The converter X and server SB blindly convert the encrypted pseudonym into nym i,B.
Step1. Upon input (PROCEED, sid , qid ), X blindly derives the encrypted pseudonym xnym i,B for SB:
a) Retrieve the conversion record (convert, sid , qid , C, πA, σC ,SA,SB) for qid and abort if no such record exists.
b) Compute C(cid:48) ← DecG(eskX , C) and C(cid:48)(cid:48) ←$ (C(cid:48) (cid:12) EncG(epk B, 1))∆ where ∆ ← xB/xA (mod q) .
c) Sign the encrypted pseudonym using the secret key sskX ,B for SB as σnym ←$ EncSignG(sskX ,B, epk B, C(cid:48)(cid:48)).
d) Prove correctness of the computation of C(cid:48)(cid:48) and σnym in πX :

πX ←$ NIZK{(∆, C

(cid:48)

, sskX ,B, eskX ) : σnym = EncSignG(sskX ,B, epk B, C

(cid:48)(cid:48)

) ∧

(cid:48)

C

= DecG(eskX , C) ∧ C

(cid:48)(cid:48)
e) Send (sid , qid , C, C(cid:48)(cid:48), σC , σnym, πA, πX , SA) via FSMT to SB.
Step2. Upon receiving (sid , qid , C, C(cid:48)(cid:48), σC , σnym, πA, πX , SA) from X , SB derives its local pseudonym nym i,B:
a) Verify that Vf(spk A, σC , (sid , qid , C)) = 1, πA is correct w.r.t. spkX ,A, C and πX is correct w.r.t. C(cid:48)(cid:48).
b) Compute xnym i,B ← DecG(esk B, C(cid:48)(cid:48)) and σnym ← DecSignG(esk B, spkX ,B, σnym).
c) Verify that VfG(spkX ,B, σnym, xnym i,B) = 1 and derive the ﬁnal pseudonym as nym i,B ← PRPG(kB, xnym i,B).
d) Store (sid , nym i,B, σnym ) and end with output (CONVERTED, sid , qid ,SA, nym i,B).

(cid:48) (cid:12) EncG(epk B, 1))∆ ∧ y∆

A = yB}(sid , qid ).

= (C

Figure 5: Conversion Request and Response Protocol

Conversion Request.
The changes to the conversion protocol are slightly more
complex. When SA prepares its request, we can remove the
outer encryption layer of C and omit the signature σC . Both
allowed X to forward SA’s request in a blind yet veriﬁable
manner to SB. Relying on an honest-but-curious converter,
this is not needed anymore. Overall, the complexity in the
conversion request decreases to 5 expG + 4 expGt + 8 pair for
SA and 3 expG + 4 expGt + 8 pair for X .
Conversion Response.
When the converter computes its conversion response, we
can omit the proof πX . Further, X does not have to forward
the proof πA to SB as this was needed in the security proof
only when the converter was corrupt. Also the ciphertext
C needs no longer to be forwarded to SB and in fact should
not be forwarded, as we just changed C to be a direct en-
cryption of nym i,A under S(cid:48)
Bs key. Overall, the only values
sent from X to SB are now (sid , qid , C(cid:48)(cid:48), σnym, SA). Conse-
quently, also the part of the receiving server SB gets more
it does neither have to verify πA, πX , or σC
light-weight:
anymore. SB’s veriﬁcation of the decrypted signature σnym
on the converted pseudonym becomes obsolete, too. This
signiﬁcantly reduces the overall complexity of the response
protocol to 23 expG + 1 exp˜G for X and 3 expG for SB.

5. CONCRETE INSTANTIATIONS

In this section we describe how to instantiate the diﬀer-
ent proofs used in our protocol, assuming that the ElGa-
mal encryption scheme [17] is used for (EncKGenG, EncG,
DecG), AGOT+ signatures (as deﬁned in Section 3.5) for
(SigKGenG, SignG, EncSignG, DecSignG, VfG) and the Dodis-
Yampolskiy [16] construction for the veriﬁable pseudoran-
dom function (PRFKGenG, PRFG). The concrete instantia-
tions of the standard signature and the PRP have no in-
ﬂuence on the proofs, as they don’t appear in any of the
proven statements. We also describe some optimisations for
computing the nested encryption C and derivation of the
ciphertext C(cid:48)(cid:48) which enhance the eﬃciency of our scheme.
Our instantiation requires that FCRS provides all parties
instead of the single group G with three groups G = (cid:104)g(cid:105),
˜G = (cid:104)˜g(cid:105), Gt of prime order q, and a bilinear map e : G× ˜G →
Gt. Those are generated as (q, G, ˜G, Gt, e, g, ˜g) ←$ G(1τ ).
For the system parameters of the AGOT(+) scheme also an
additional random group element x ←$ G is included in the
CRS. Finally, to achieve online extractability for the NIZK
proofs, we require that the CRS further contains a random
public key ˆy ∈ G. In the security proof, the simulator will
choose a random ˆx ∈ Zq and set ˆy ← g ˆx, which allows to
eﬃciently extract the necessary values as described in the
preliminaries.

1477Overall, the CRS in our scheme then has the form crs =
(q, G, ˜G, Gt, e, g, ˜g, x, ˆy). The converter’s keys for the dual-
mode signature (for each server SA ∈ S) have the form
(spkX ,A = yX ,A, sskX ,A = vX ,A) and for the ElGamal en-
cryption we have (epkX = ¯yX , eskX = ¯xX ).
5.1 Pseudonym Generation

In πnym a converter has to prove that it has gener-
ated its pseudonym contribution xnym i,A correctly. If the
pseudonym is not anonymous (anon = 0), it also includes
a proof that the core identiﬁer zi = PRFG(xX , uid i) was
computed correctly.

A

A

A

nym ←$ SPK{(x
(cid:48)

If the ﬂag anon = 1, the proof πnym is instantiated as
follows: ﬁrst compute an ElGamal encryption of zi under
the CRS key as Z = (Z1, Z2) ← (ˆyr, zigr) with a randomly
chosen r ←$ Zq . Then compute the proof π(cid:48)
i,A ∧
π
A }(sid , g, yA, xnym i,A, Z1, Z2)
nym ). For the analysis of this proof

A, r) : Z1 = ˆyr ∧ Z2 = grxnym x(cid:48)
(cid:48)

g = yx(cid:48)
and output πnym ← (Z, π(cid:48)
notice that zi = xnym 1/xA

i,A = xnym x(cid:48)
i,A.

nym :

X y

−x(cid:48)
AX

A ∧

If the ﬂag anon = 0, then πnym is instantiated as:
∧ g = yx(cid:48)
X ) : 1 = gx(cid:48)
πnym ←$ SPK{(x
(cid:48)
(cid:48)
A, x
A xnym x(cid:48)
i,A )x(cid:48)
X
g = (xnym uid i

i,A}(sid , g, yA, xnym i,A, yX , uid i)
where yX is part of the converter’s public key. Let us analyse
the latter proof. The ﬁrst term established that x(cid:48)
AxX ,
the second one that x(cid:48)
A = 1/xA and the third term that
xnym i,A = (g1/(uid i+xX ))xA .
5.2 Conversion Request

In a conversion request, the server SA has to prove that
it knows a converter’s signature on the inner pseudonym
xnym i,A, which it provided in double encrypted form C =
EncG(epkX , EncG(epk B, xnym i,A)).

X = x(cid:48)

We start with the description of how the double encryp-
tion C = EncG(epkX , EncG(epk B, xnym i,A)) is instantiated.
We already apply some optimizations and extend the ci-
phertext such that it allows for the online extraction of the
pseudonym and its signature in the proof πA.

A

Let eskX = ¯xX and epkX = ¯yX be the encryption key
pairs of the converter and esk B = ¯xB and epk B = ¯yB for
server SB. Let ˆy be the public key in the CRS. Then C is
computed as an extended ElGamal encryption as
C := (C0, C1, C2, C3) ← (ˆyr1+r2 , ¯yr1
B , ¯yr2X , gr1+r2 xnym i,A)
with r1, r2 ←$ Zq . Let (r, s, r, w) be the converter’s signature
on xnym i,A.
Then, the proof πA if realized as follows: First the server
SA randomizes the signature σ = (r, s, t, w) for key spkX ,A =
yX ,A by picking a random u(cid:48) ←$ Z∗
q and computes σ(cid:48) =
(r(cid:48), s(cid:48), t(cid:48), w(cid:48)) as
(cid:48) ← ru(cid:48)

(cid:48) ← (tw(u(cid:48)−1))1/u(cid:48)2

(cid:48) ← s1/u(cid:48)
Then it computes the proof

A ←$ SPK{(r1, r2, ν1, ν2) : C0 = ˆyr1+r2 ∧
(cid:48)
C1 = ¯yr1

B ∧ C2 = ¯yr2X ∧ S1 = ˆyν1 ∧ T1 = ˆyν2 ∧
−ν1 ∧
)
−ν2

) = e(g, yX ,A)r1+r2 e(g, r
(cid:48)
) = e(g, yX ,A)ν1 e(g, r

e(g, ˜g)e(S2, yX ,A)/e(T2, r

e(x, ˜g)e(C3, yX ,A)/e(S2, r

π

s

r

)

t

,

.

,

(cid:48)

(cid:48)

(cid:48)

}(sid , qid , crs, C, r

(cid:48)

, S, T, w, yX ,A, ¯yX , ¯yB),

where S = (S1, S2) = (ˆyν1 , gν1 s(cid:48)) and T = (T1, T2) =
(ˆyν2 , gν2 t(cid:48)) are (ordinary) ElGamal encryptions under the
It out-
CRS key that make this proof online extractable.
puts πA = (π(cid:48)
A, S, T, r(cid:48)). The analysis of this proof is given
in the full version of the paper.
5.3 Conversion Response

Let us now detail how the converter computes the cipher-
2 ) and the proof πX in which X proves
text C(cid:48)(cid:48) = (C(cid:48)(cid:48)
that it derived and signed C(cid:48)(cid:48) (containing the translated
pseudonym) correctly.

1 , C(cid:48)(cid:48)

1

2

2

, C(cid:48)(cid:48)

2 ← (C(cid:48)

Given the ciphertext C = (C0, C1, C2, C3), the con-
2 ← C3/C 1/¯xX
verter computes C(cid:48)
xB /xA )gr,
1 ← C xB /xA
B, with r ←$ Zq . Let ∆ = xB/xA
and C(cid:48)(cid:48)
¯yr
(mod q). Notice that (C1, C(cid:48)
2) is an encryption of xnym i,A
under ¯yB (provided SA computed C honestly) and that we
have C(cid:48)(cid:48)
2 ) is an
encryption of xnym i,B under ¯yB.
Now, the converter computes the signature on the ci-
phertext (C(cid:48)(cid:48)
2 ) and for signing key sskX ,B = vX ,B
(with public key spkX ,B = yX ,B) . Choose a random
u, ρ1, ρ2 ←$ Z∗
q , and compute the (partially) encrypted sig-
nature ¯σ = (r, S, T, w):

)∆gr. Thus, C(cid:48)(cid:48) = (C(cid:48)(cid:48)

2 = (C3/C 1/¯xX

1 , C(cid:48)(cid:48)

1 , C(cid:48)(cid:48)

2

r ←˜gu,
S1 ←C
(cid:48)(cid:48)
vX ,B /u ¯yρ1
B ,
1
T1 ←S
vX ,B /u
¯yρ2
B ,
1

w ←g1/u
S2 ←(C
(cid:48)(cid:48)
vX ,B x)1/ugρ1 ,
2
T2 ←(S
vX ,B
g)1/ugρ2 .
2

(T1, T2) are encryptions under SB’s public key ¯yB.

Output ¯σ = (r, (S1, S2), (T1, T2), w), where (S1, S2) and
Then, the proof πX that X computed and signed (C(cid:48)(cid:48)
1 , C(cid:48)(cid:48)
2 )
, ρ1, ρ2, ∆, r, p) : ˜g = ru(cid:48) ∧ w = gu(cid:48) ∧

correctly and is as follows:
πX ←$ SPK{(u

, v

(cid:48)

(cid:48)

1 = y

v(cid:48)

(cid:48)(cid:48)
1

−u(cid:48)
X ,B ˜gv(cid:48) ∧ S1 = C

v(cid:48)
xu(cid:48)
gρ1 ∧
B ∧ S2 = C
¯yρ1
T1 = Sv(cid:48)
2 gu(cid:48)
B ∧ T2 = Sv(cid:48)
gρ2 ∧ yB = y∆
A ∧
1 ¯yρ2
2 gr ∧ 1 = g∆ ¯ypX
B ∧ C
(cid:48)(cid:48)
(cid:48)(cid:48)
3 C p
1 = C ∆
2 = C ∆
1 ¯yr
C
}(sid , qid , crs, r, S, T, w, C
(cid:48)(cid:48)
(cid:48)(cid:48)
2 , C, yX ,B, ¯yX , ¯yB) .
1 , C

(cid:48)(cid:48)
2

The last term establishes that p = −∆/¯xX . The last four
terms show that the ciphertext (C(cid:48)(cid:48)
2 ) was computed cor-
rectly from (C0, C1, C2, C3) whereas all other terms show
that the “encrypted” signature was computed correctly.
5.4 Instantiating PRPG via Lazy Sampling

1 , C(cid:48)(cid:48)

Our scheme makes use of a pseudorandom permutation
PRPG to let each server derive its ﬁnal pseudonym nym i,A as
nym i,A ← PRPG(kA, xnym i,A) and also re-obtain xnym i,A
via PRP−1G in a conversion request. However, we mainly in-
troduced the PRPG for notational convenience. In fact, it is
suﬃcient to choose a random nym i,A ←$ G whenever a fresh
xnym i,A is received, and to keep a list Lnym of the mapping
(nym i,A, xnym i,A). Then, whenever xnym i,A appears again,
SA simply retrieves nym i,A from Lnym and vice-versa.

6. CONCLUSION AND EXTENSIONS

We have presented a protocol that allows to maintain
and exchange data in a decentralized manner, based on
pseudonyms which are per se unlinkable but can be trans-
formed from one server to another with the help of a central

1478converter. Our protocol overcomes the typical privacy bot-
tleneck of such a system as it performs the pseudonym gen-
eration and conversion only in a blind way. It also provides
strong guarantees in terms of consistency and controllability
even if the converter is corrupt.

An interesting area for future work is to detail the diﬀerent
approaches on how to securely provision the pseudonyms.
For instance, one possibility would be to combine our system
with privacy-enhancing credentials that contain the unique
identiﬁer uid i and are given to the users. That could allow a
user to obtain a particular pseudonym contribution xnym i,A
from the converter, and later prove towards SA that she is
indeed the correct “owner” of xnym i,A.

Roughly, the idea would be to modify the pseudonym
generation to output also a commitment com to uid i,
e.g., com = guid hr for the random opening information r.
The proof πnym (for anon = 1) that is generated by the
converter to ensure correctness of the pseudonym would be
modiﬁed accordingly to
πnym ←$ NIZK{(xX , xA, uid i, r) : zi = PRFG(xX , uid i) ∧
i ∧ yA = gxA ∧ com = guid i hr}(sid , com).
xnym i,A = zxA
Then, a user could register with a server SA by providing
xnym i,A, the proof πnym and then prove to the server that
she owns a credential with the same uid i that is contained
in the commitment com without revealing uid i.

Another interesting extension are audit capabilities. In a
pseudonym system with a fully trusted converter, the con-
verter could keep a log ﬁle of all server requests and allow
the user (or a trusted auditor) to monitor which entities cor-
related or exchanged his data. With the blind conversions in
our system, such a central audit is not immediately possible
anymore. It is an interesting open problem how to add such
audit capabilities without harming the privacy properties of
our system.

In a similar vein,

it would be desirable to combine
our pseudonym system with policy enforcement tools in a
privacy-preserving manner. That is, allowing the user to
specify which data exchanges are permitted and enable the
converter to blindly check whether a received conversion re-
quest violates any user constraints.

Acknowledgements
This work was supported by the European Commission
through the Seventh Framework Programme, under grant
agreements #321310 for the PERCY grant and #318424
for the project FutureID.

7. REFERENCES
[1] H. Aamot, C. D. Kohl, D. Richter, and

P. Knaup-Gregori. Pseudonymization of patient
identiﬁers for translational research. BMC Medical
Informatics and Decision Making 13:75, 2013.

[2] M. Abe, J. Groth, M. Ohkubo, and M. Tibouchi.

Uniﬁed, minimal and selectively randomizable
structure-preserving signatures. TCC 2014.

[3] G. Ateniese, J. Camenisch, S. Hohenberger, and

B. de Medeiros. Practical group signatures without
random oracles. ePrint Archive, Report 2005/385.

[4] B. Barak, Y. Lindell, and T. Rabin. Protocol

initialization for the framework of universal
composability. ePrint Archive, Report 2004/006.

[5] M. Barbaro and T. Zeller. A face is exposed for aol

searcher no. 4417749. New York Times, 2006.
[6] O. Blazy, G. Fuchsbauer, D. Pointcheval, and

D. Vergnaud. Signatures on randomizable ciphertexts.
PKC 2011.

[7] D. Boneh and X. Boyen. Eﬃcient selective-ID secure

identity based encryption without random oracles.
EUROCRYPT 2004.

[8] B. Elger, J. Iavindrasana, L. Iacono, H. Muller,

N. Roduit, P. Summers, and J. Wright. Strategies for
health data exchange for secondary, cross-institutional
clinical research. Comput Methods Programs Biomed:
99(3), 2010.

[9] J. Camenisch, A. Kiayias, and M. Yung. On the

portability of generalized schnorr proofs.
EUROCRYPT 2009.

[10] J. Camenisch and M. Stadler. Eﬃcient group

signature schemes for large groups. CRYPTO 1997.
[11] R. Canetti. Universally composable security: A new

paradigm for cryptographic protocols. ePrint Archive,
Report 2000/067.

[12] Austrian Citizen Card.

http://www.a-sit.at/de/dokumente_
publikationen/flyer/buergerkarte_en.php.

[13] Belgian Crossroads Bank for Social Security.

http://www.ksz.fgov.be/.

[14] F. de Meyer, G. de Moor, and L. Reed-Fourquet.
Privacy protection through pseudonymisation in
ehealth. Stud Health Technol Inform: 141, 2008.
[15] Y.-A. de Montjoye, L. Radaelli, V. K. Singh, and

A. Pentland. Unique in the shopping mall: On the
reidentiﬁability of credit card metadata. Science
30:347, 2015.

[16] Y. Dodis and A. Yampolskiy. A veriﬁable random

function with short proofs and keys. PKC 2005.
[17] T. ElGamal. A Public Key Cryptosystem and a

Signature Scheme Based on Discrete Logarithms.
CRYPTO 1984.

[18] A. Fiat and A. Shamir. How to prove yourself:

Practical solutions to identiﬁcation and signature
problems. CRYPTO 1986.

[19] G. Fuchsbauer. Commuting signatures and veriﬁable

encryption. EUROCRYPT 2011.

[20] D. Galindo and E. R. Verheul. Microdata sharing via

pseudonymizatio. Joint UNECE/Eurostat work
session on statistical data conﬁdentiality, 2007.

[21] A. Narayanan and V. Shmatikov. Robust

de-anonymization of large sparse datasets. IEEE
Symposium on Security and Privacy, 2008.

[22] T. Neubauer and J. Heurix. A methodology for the

pseudonymization of medical data. Int J Med Inform:
80(3), 2010.

[23] D. Pointcheval and J. Stern. Security proofs for

signature schemes. EUROCRYPT 1996.

[24] K. Pommerening, M. Reng, P. Debold, and S. Semler.

Pseudonymization in medical research - the generic
data protection concept of the tmf. GMS Medizinische
Informatik 1:17, 2005.

[25] C.-P. Schnorr. Eﬃcient identiﬁcation and signatures

for smart cards. CRYPTO 1990.

1479