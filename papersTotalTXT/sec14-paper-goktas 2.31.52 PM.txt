Size Does Matter: Why Using Gadget-Chain Length 

to Prevent Code-Reuse Attacks is Hard

Enes Göktaş, Vrije Universiteit Amsterdam; Elias Athanasopoulos, FORTH-ICS;  

Michalis Polychronakis, Columbia University; Herbert Bos, Vrije Universiteit Amsterdam; 

Georgios Portokalidis, Stevens Institute of Technology

https://www.usenix.org/conference/usenixsecurity14/technical-sessions/presentation/goktas

This paper is included in the Proceedings of the 23rd USENIX Security Symposium.August 20–22, 2014 • San Diego, CAISBN 978-1-931971-15-7Open access to the Proceedings of  the 23rd USENIX Security Symposium is sponsored by USENIXWhy Using Gadget-Chain Length to Prevent Code-Reuse Attacks is Hard

Size Does Matter

Enes Gökta¸s

Vrije Universiteit

Amsterdam, The Netherlands

Elias Athanasopoulos

FORTH-ICS

Heraklion, Crete, Greece

Michalis Polychronakis
Columbia University
New York, NY, USA

Herbert Bos

Vrije Universiteit

Amsterdam, The Netherlands

Georgios Portokalidis

Stevens Institute of Technology

Hoboken, NJ, USA

Abstract
Code-reuse attacks based on return oriented program-
ming are among the most popular exploitation tech-
niques used by attackers today. Few practical defenses
are able to stop such attacks on arbitrary binaries with-
out access to source code. A notable exception are the
techniques that employ new hardware, such as Intel’s
Last Branch Record (LBR) registers, to track all indirect
branches and raise an alert when a sensitive system call is
reached by means of too many indirect branches to short
gadgets—under the assumption that such gadget chains
would be indicative of a ROP attack. In this paper, we
evaluate the implications. What is “too many” and how
short is “short”? Getting the thresholds wrong has seri-
ous consequences. In this paper, we show by means of
an attack on Internet Explorer that while current defenses
based on these techniques raise the bar for exploitation,
they can be bypassed. Conversely, tuning the thresholds
to make the defenses more aggressive, may ﬂag legit-
imate program behavior as an attack. We analyze the
problem in detail and show that determining the right val-
ues is difﬁcult.

1

Introduction

Modern protection mechanisms like data execution pro-
tection (DEP) [2], address space layout randomization
(ASLR) [26] and stack smashing protection (SSP) [9] are
now available on most general-purpose operating sys-
tems. As a result, exploitation by injecting and executing
shellcode directly in the victim process has become rare.
Unfortunately, these defenses are not sufﬁcient to stop
more sophisticated attacks.

Nowadays, attackers typically use memory disclo-
sures to ﬁnd exactly the addresses ASLR is trying to
hide [30, 34, 36]. Likewise, there is no shortage of tu-
torials on how to evade state-of-the-art defenses [14,28].
Attackers are able to hijack control ﬂow and bypass DEP

by reusing code that is already available in the binary it-
self, or in the libraries linked to it. There are several vari-
ations of this exploitation method: return-to-libc [37],
return-oriented programming (ROP) [31], jump-oriented
programming [3,6], and sigreturn oriented programming
(SROP) [4]. Code reuse attacks, and especially ROP,
may be the most popular exploitation method used by
attackers today, bypassing all popular defense mecha-
nisms. Even additional and explicit protection against
ROP attacks over and beyond DEP, ASLR and SSP, such
as provided by Microsoft’s Enhanced Mitigation Expe-
rience Toolkit (EMET), do not stop the attacks in prac-
tice [14].

ROP attacks start when an attacker gains control of the
stack and diverts the control to a gadget: a short sequence
of instructions that performs a small subset of the desired
functionality and ends with a ret instruction. Since the
attackers control the return addresses on the stack, they
can make the ret of one gadget jump to the start of an-
other gadget, daisy chaining the desired functionality out
of a large set of small gadgets.

It is no wonder, then, that the security community has
scrambled to ﬁnd alternative methods to defend software
assets. For instance, over the past decade or so, there has
been a tremendous amount of research interest in control
ﬂow integrity (CFI) [1]—a technique to prevent any ﬂow
of control not intended by the original program. Unfor-
tunately, CFI is fairly expensive. Moreover, research has
shown that attempts to make it faster and more practical
by employing looser notions of integrity, make it vulner-
able to exploitation again [16].

KBouncer and friends Perhaps the main and most
practical defense mechanism proposed against ROP at-
tacks nowadays is the one pioneered by kBouncer [25]—
grand winner of the Microsoft Blue Hat Prize in 2012.
The technique has become quite successful and despite
its recent pedigree, it is already used in commercial prod-
ucts like HitmanPro’s new Alert 3 service [18].

USENIX Association  

23rd USENIX Security Symposium  417

1

KBouncer and related approaches like ROPecker [8]
use a new set of registers, known as the Last Branch
Record (LBR), available in modern Intel CPUs. The
registers can be used to log the last n indirect branches
taken by the program. Using the LBR, kBouncer checks
whether the path that lead to a sensitive system call
(like VirtualProtect) contains “too many” indirect
branches to “short” gadgets—which would be indicative
of a ROP chain.

The two obvious questions that we need to ask are:

what is “too many,” and how short is “short”?

Speciﬁcally, suppose the defensive mechanism has
thresholds TC and TG, such that it raises an alarm when
it sees a chain of TC or more gadgets of at most TG in-
structions each.
If the attackers can ﬁnd just a single
gadget greater than TG that they can simply squeeze in
between the others to break the sequence, the defensive
mechanism would not detect it. Conversely (and more
worryingly), if a program itself exhibits TC gadgets of
at most TG instructions during normal execution, the de-
fense mechanism would erroneously ﬂag it as an attack.
Implemented carefully, the protection offered by this
method is quite powerful, but picking the right values
for TG and TC is a delicate matter. After all, the former
scenario suggests that TG is too small. However, incre-
menting TG may lead to more false positives (FPs) be-
cause benign execution paths are more likely to contain
TC such gadgets.

Contributions
In this paper, we investigate the prob-
lem of picking the right values for these two thresh-
olds. We also evaluate whether the solutions proposed
today are sufﬁcient to stop exploitation in real soft-
ware. Speciﬁcally, we show that while they raise the
bar for exploitation signiﬁcantly, they can be bypassed.
As a demonstration, we discuss a proof of concept
exploit against Internet Explorer that bypasses current
kBouncer-based defenses. We then analyze the prob-
lem by considering the availability of gadgets of differ-
ent lengths and determining the sequences of gadgets en
route to sensitive system calls.

While this work does not fully explore the possibil-
ity of FPs with the thresholds used in literature, it shows
that deﬁning restrictive thresholds, which do not allow
the composition of ROP payloads, is extremely compli-
cated and may not be possible for many applications due
to FPs. Finally, we discuss various avenues for amelio-
rating these techniques and provide evidence that setting
the thresholds based on the application at-hand can sig-
niﬁcantly encumber attackers.

Outline The remainder of this paper is organized as
follows. Section 2 provides some background informa-
tion regarding code-reuse attacks and defenses that use

0xffffffff

ESP

0x00000000

0x0010bb80
0x41414141
0x0000002d
0x02215f80
0x08501154
0x00000024
0x0000000e
0x0800ab00

pop ecx
pop eax
ret

add eax, ecx
ret

pop ecx
pop ebx
ret

sub eax, ecx
ret

Figure 1: A very simple ROP chain that calculates 0xe +
0x24− 0x2d. Result is in the eax register.

gadget-chain length for detection. Section 3 discusses
the weaknesses of such approaches, and in Sec. 4 we
present the process of creating an exploit that can cir-
cumvent them. We propose countermeasures and discuss
possible obstacles for their adoption in Sec. 5. In Sec. 6,
we present the results of our experiments that indicate
that one of the proposed countermeasure can improve
detection. Related work is in Sec. 7 and we conclude
in Sec. 8.

2 Background

2.1 ROP and Code-reuse Attacks
ROP attacks are the most common vector for launch-
ing code-reuse attacks and require that the attacker gains
control of the program’s stack. By corrupting the return
address of the executing function, upon its return, control
is diverted to a gadget of the attacker’s choosing. Gad-
gets are small sequences of code that end with a ret.
By carefully positioning data on the stack, the attacker
can make the program jump from one gadget to another,
chaining together pieces of already existing code that im-
plement the desirable payload, as shown in Fig. 1. While
the gadgets that the attacker chains together are usually
short in length (i.e., in number of instructions) and lim-
ited in functionality, previous work has shown that the
attack is Turing complete [31]. That is, applications con-
tain enough gadgets to perform arbitrary computations.
Creating a working ROP exploit is often a complex,
multi-step process. It typically starts with a memory dis-
closure that allows the attacker to obtain code pointers.
Next, the attack may require a variety of further prepa-
rations, such as advanced heap feng shui [35] to pave
the way for a dangling pointer exploit, stack pivoting,
and/or buffer overﬂows. In addition, the attacker needs
to identify useful gadgets and construct a ROP program
out of them by setting up the appropriate addresses and

418  23rd USENIX Security Symposium 

USENIX Association

2

...
pop | mov | add | or | ...
ret | jmp *(ptr) | call *(ptr)

...
...
pop | mov | add | or | ...
ret | jmp *(ptr) | call *(ptr)

...
pop | mov | add | or | ...
ret | jmp *(ptr) | call *(ptr)

...
...
...
pop | mov | add | or | ...
ret | jmp *(ptr) | call *(ptr)

Sequences of

  TG or less instructions 

ending with an

indirect branch are 
considered gadgets

h
t
g
n
e
l
 
n
i
a
h
c
-
t
e
g
d
a
G

A gadget chain of 
TC or more gadgets 
constitutes an attack

...
pop | mov | add | or | ...
ret | jmp *(ptr) | call *(ptr)

CHECK

Figure 2: Example of a gadget chaining pattern used to
identify code-reuse attacks.

arguments on the (possibly new) stack. Finally, a control
ﬂow diversion should start off the ROP chain.

ROP is popular despite its complexity because it pro-
vides a way for attackers to bypass defenses like DEP [2].
As a result, many recent works have focused on pre-
venting ROP and other forms of code-reuse attacks [7,
8, 13, 23–25, 31, 33]. Other works have shown that a
similar attack can also be performed with gadgets that
end with indirect jump or call instructions instead of re-
turns [3, 6, 21].

2.2 Monitoring Gadget Chains to Detect

Attacks

kBouncer [25] and ROPecker [8] are two of the most
easy to deploy solutions to stop ROP-like attacks. They
employ a recent feature of Intel CPUs, known as the Last
Branch Record (LBR), that logs the last branches taken
by a program in a new set of registers [20, Sec. 17.4].
Intel introduced LBR for both the x86 and x86-64 ar-
chitectures, so that, with the right conﬁguration, the op-
erating system (OS) is able to log the targets of indi-
rect branches (including calls, jumps, and returns) in
16 machine-speciﬁc registers (MSR) registers with lit-
tle overhead. These registers are accessible only from
the OS kernel and are continuously overwritten as new
branches occur.

A key observation for detecting ROP attacks, in both
kBouncer and ROPecker, is that the attacks need to chain
together a signiﬁcant number of small gadgets to per-
form any useful functionality, like in the example shown
in Fig. 2. From a high-level perspective, they include
two parameters: the ﬁrst controls what is the longest se-
quence of instructions ending with an indirect branch that

will be considered a gadget, and the second speciﬁes the
number of successively chained gadgets that indicates an
attack. We will refer to these two thresholds as TG and
TC. These two parameters control the level of difﬁculty
for performing an attack under these solutions. Increas-
ing TG or reducing TC makes the construction of ROP
payloads harder. However, overdoing it can lead to false
positives (FP), due to legitimate execution paths being
misclassiﬁed as attacks at run time.
In the remainder
of this section, we will brieﬂy highlight kBouncer and
ROPecker.

2.2.1 kBouncer

kBouncer kicks in every time a sensitive API call, like
VirtualProtect(), CreateProcess(), etc., is
executed by inserting hooks through the Detours [19]
framework for Windows. It then scans the LBR regis-
ters to detect if the API call was made by a malicious
ROP gadget chain, and terminates the running process if
it was.

Two mechanisms are used to determine if there is an
attack. The ﬁrst mechanism aims to identify abnormal
function returns. It is based on the observation that ROP
chains manipulate control-ﬂow to redirect control to ar-
bitrary points in the program, where the attacker-selected
gadgets reside. This constitutes a deviation from legiti-
mate behavior, where returns transfer control to instruc-
tions immediately following a call. kBouncer checks the
targets of all return instructions in the LBR to ensure that
they are preceded by a call instruction. In x86 architec-
tures where unaligned instructions are permissible, this
call instruction does not necessarily need to be one ac-
tually intended by the program and emitted by the com-
piler. Any executable byte with the value of 0xE8, one
of the opcodes for the call instruction, can be actually
considered as an unintended call instruction and attack-
ers can use the gadget following it.

Recently, even just using gadgets following intended
calls was shown to be sufﬁcient to compose ROP pay-
loads [16]. In anticipation of the possibility of such at-
tacks, kBouncer introduced a second mechanism, based
on gadget-chain length, to detect and prevent attacks.
First, all potential gadgets are identiﬁed through ofﬂine
analysis of an application. Every uninterrupted sequence
of at most 20 instructions ending in an indirect branch
is treated as a potential gadget. At run time, kBouncer
checks that there is no uninterrupted chain of eight or
more such gadgets as targets in the LBR. In this case,
the maximum gadget length of TG = 20 was selected ar-
bitrarily [25, Sec. 3.2], while through experimentation
with a set of Windows applications, it was determined
that a safe choice for the gadget-chain length threshold is
TC = 8 [25, Sec. 3.2, Fig. 7].

USENIX Association  

23rd USENIX Security Symposium  419

3

2.2.2 ROPecker

Similarly to kBouncer, ROPecker [8] utilizes LBR to de-
tect ROP attacks. However, instead of only checking
LBR registers upon entry to sensitive API calls, it in-
troduces a new mechanism for triggering checks more
often. It maintains a sliding window of code that is exe-
cutable, while all other code pages are marked as non-
executable. Checks are made each time a permission
fault is triggered because control ﬂow is transferred out-
side the sliding window. The intuition behind this ap-
proach is that due to code locality page faults are not
triggered very often and ROP attacks are unlikely to use
only gadgets contained within the sliding window (be-
tween 8 and 16 KB), so a check will be triggered before
the attack completes.

Attack detection occurs primarily by checking gadget-
chain length, like in kBouncer. However, ROPecker also
checks for attacks in future returns by inspecting the re-
turn addresses stored in the stack. Potential gadgets are
collected ofﬂine by statically analyzing applications, but
they are deﬁned differently from kBouncer. In particular,
a gadget is a sequence of no more than six instructions
that ends with an indirect branch, but does not contain
any direct branches. Experiments were conducted with
various Linux applications and benchmarks to determine
a safe choice for the gadget-chain length threshold that
will indicate an attack. The results varied, but a chain of
at least 11 gadgets was determined to be a safe choice.
However, using a per-application threshold, if possible,
is recommended. To summarize, the maximum length of
a gadget is set to TG = 6 and is selected arbitrarily [8,
Sec. VII.B], while the safe choice for the gadget-chain
length threshold is TC = 11 [8, Sec. VII.A].

In the presence of multiple smaller gadget chains, in-
tentionally created by mixing long and short gadgets to
evade the mechanism, ROPecker also proposes accumu-
lating the lengths of the smaller chains across multiple
windows and using that instead, to gain a certain degree
of tolerance to such attacks. Accumulation is done every
three windows, and experimental results showed that an
acceptable threshold for cumulative gadget-chain length
is TCC = 14.

3 The Problem

Both systems we study in this paper heavily depend on
two parameters, namely TC (the chain length) and TG (the
gadget length). In this section, we discuss the problem
of picking the right values for TC and TG, and the way
attackers can bypass the defenses proposed by kBouncer,
ROPecker, and similar approaches.

What Is the Right Size? Mechanisms like kBouncer
and ROPecker rely on deﬁning gadgets based on the size
of instruction sequences ending in indirect branches, and
detect attacks based on the size of gadget chains. The
problem with such measures is that while they do raise
the bar, they are also their own Achilles’ heel. By in-
terspersing their ROP code with an occasional longer se-
quence of instructions (ending with an indirect branch)
that will not be registered as a gadget, an attacker can
reduce the length of gadget chains, as observed by these
systems, and avoid detection.

Figure 3 shows a high-level overview of such an at-
tack. After receiving control through an exploit, an at-
tacker ﬁrst uses up to TC − 1 detectable gadgets (DG).
Then, he employs at least one longer undetectable gad-
get (UG), that is, a sequence of more than TG instruc-
tions. To be precise, an attacker may need to use an UG
earlier for the ﬁrst time because a chain of TC legitimate
application gadgets may already exist before he receives
control, leading to a longer chain of DGs. If a check is
triggered while this chain is still visible in the LBR, the
attack will be detected. kBouncer only conducts checks
on certain API calls, so an attacker needs to only worry
about the number of DGs in the LBR when performing
such calls. On the other hand, ROPecker triggers checks
more frequently, but, exactly due to this fact, uses less
restrictive TC and TG parameters. In the worst case, an
attacker needs to use an UG ﬁrst in his ROP chain.

Weak Control-Flow Enforcement
kBouncer per-
forms an additional check to ensure that the targets of
all return instructions in the LBR point to instructions
preceded by calls. However, recent work [16] has shown
that it is possible to build a ROP payload using such call-
preceded (CP) gadgets and evade even stricter control-
ﬂow restrictions. As a result, the effectiveness of de-
fenses like kBouncer depends entirely on the TC and TG
parameters. In the example shown in Fig. 2, the attacker
would not be able to link gadgets that are not preceded
by calls using function returns.

Accumulating Gadget-Chain Lengths ROPecker
proposes an extension to tackle exactly the problem of
mixing long and short gadgets. They deﬁne another
parameter, TCC, which is the threshold for the cumulative
length of gadget chains in three successive windows
and, hence, checks. This extension aims to prevent
attacks following the pattern shown in Fig. 3. However,
ROPecker does not consider
instruction sequences
including direct branches as gadgets, so an attacker can
employ those as alternative shorter UGs. Furthermore,
attackers can carefully construct attacks that consist of a
small number of gadgets and then inject code, as it was

420  23rd USENIX Security Symposium 

USENIX Association

4

Chain length less than TC

Chain length less than TC

Attacker 
hijacks

 control flow

...

...

...

TG

Undetectable gadgets longer than TG

Figure 3: Mixing shorter and longer gadgets to avoid detection. Gadgets larger than TG instructions are not considered
as gadgets by both kBouncer and ROPecker. The latter also ignores gadgets that contain direct branch instructions.

done in previous work [16]. Details follow in the next
section.

4 Proof-of-Concept Attack

In this section, we describe the construction of a proof-
of-concept (PoC) exploit, which can compromise a vul-
nerable binary running under kBouncer. We have se-
lected kBouncer, since we consider it the hardest to evade
of the two systems examined in this paper. Recall that
kBouncer is based on restricting ret instructions, so that
they can only redirect control ﬂow to gadgets preceded
by an intended or unintended call instruction, and on a
heuristic that scans for long chains of consecutive gad-
gets, as they are deﬁned by kBouncer. The constructed
exploit is generic, because it uses gadgets solely from
the shell32.dll library which is shared among many
widely used applications in Windows, and it is also effec-
tive against similar approaches, like ROPecker [8].

Previous work [16] has already shown that it is possi-
ble to compose attacks using an even more limited set of
gadgets, that is, only gadgets following intended call in-
structions and starting at function entry points. We build
on this prior knowledge to collect the gadgets that are
available under kBouncer and show that we can build
an exploit that remains undetectable. More importantly,
we show that we can construct a very short payload that
could not be easily detected unless TC and TG are set to
considerably more restrictive values.

4.1 Preparation
The vulnerability we use to build our exploit is based on a
real heap overﬂow in Internet Explorer [27] and has been
also used in multiple other works [16,34] in the past. The
ﬁrst part of the exploit deals with disclosing information
to bypass ASLR and then controlling the target address
of an indirect jump instruction. Details of the preparation
phase can also be found in previous work [16]. Here, we
summarize the initial steps that are common with previ-
ous work and introduce new actions that are necessary
for completing this exploit.

The vulnerability is triggered by accessing the span
and width attributes of an HTML table’s column

through JavaScript. A great feature of the vulnerability
is that it can be triggered repeatedly to achieve different
tasks. First, it can be triggered to overwrite the size at-
tribute of a string object, which consequently allows the
substring() method of the string class to read data
beyond the boundary of the string object, as long as we
know the relative offset of that data from the string ob-
ject. The substring() method serves as a memory
disclosure interface for us. Second, it can be triggered to
overwrite the virtual function table (VFT) pointer within
a button object. Later, when we access the button object
from within carefully prepared JavaScript code, the pro-
gram will operate on the overwritten data and will even-
tually grant us control over an indirect jump instruction.
Due to ASLR being in use, we need to exploit the
string object to “learn” where shell32.dll is loaded
at run time, i.e., its base address. Before anything else,
we use heap Feng Shui [35] to position the vulnerable
buffer, and the string and button objects in the right or-
der, so that we can overﬂow in the string object without
concurrently receiving control of the indirect jump. The
following steps are taken to locate shell32.dll, the
ﬁrst two steps have been also part of prior work, while
the latter was added to achieve our end goal:

1. This vulnerability allows us

to easily locate
mshtml.dll. The button object’s VFT contains a
pointer to a ﬁxed offset within the DLL. After heap
Feng Shui, the button object follows the string ob-
ject in memory at a ﬁxed distance, so we use the
controlled string object to read that pointer and re-
veal the location of the DLL. mshtml.dll con-
tains pointers directly to shell32.dll, however,
they are located in its Delayed Import Address Ta-
ble (IAT), so they are not available at the time of
exploitation.

2. In contrast to mshtml.dll, ieframe.dll do
contain pointers to shell32.dll in its normal
IAT, which gets loaded during the initiation of li-
braries. So ieframe.dll has the pointers to
shell32.dll we are looking for available at
the time of exploitation. As a result, by learn-
ing the base address of ieframe.dll, we can
achieve our end goal. mshtml.dll has pointers

USENIX Association  

23rd USENIX Security Symposium  421

5

to ieframe.dll available in its Delayed IAT, but
to read that, we ﬁrst need to calculate its relative off-
set from the string. Since we already know the base
address of mshtml.dll, we just need to ﬁnd out
the address of the string object, so we can calculate
offsets within the DLL. Fortunately, the button ob-
ject contains an address that has a constant distance
from the beginning of the string object, so by ﬁrst
exﬁltrating that, we can calculate the base address
of ieframe.dll.

3. Since we now know the base

address of
ieframe.dll, we exploit
the string object
once more to read a pointer to shell32.dll,
thus revealing its base address. shell32.dll
also allows us to locate VirtualProtect()
through its own IAT.

Finally, we need to also determine the location of a
buffer we control, which we use to store the ROP pay-
load, shellcode, etc. We use heap spraying [11] to create
many copies of such a buffer in the process’ memory,
which has the effect of placing one of the copies at an
address that can be reliably determined. Heap spraying
is not foolproof, however, it works consistently in this
particular case.

4.2 Collecting Gadgets
When kBouncer and friends are active the ret instruc-
tion can only target gadgets that are preceded by a call
instruction. Previous work has referred to such gadgets
as call-site (CS) gadgets [16], we will use this term to
refer to them. CS gadgets are a subset of all the gadgets
available in traditional ROP and JOP attacks, and include
gadgets deﬁned by intended and unintended call instruc-
tions. So any bytes in the program that could be inter-
preted as a call instruction, subsequently introduce a CS
gadget. Note that the entire set of gadgets is still present
in the application, but it can now only be targeted by in-
direct jump and call instructions. Generally, we will use
the CS preﬁx with gadgets that are call preceded and the
type of indirect branch ending the gadget as sufﬁx (e.g.,
RET or CALL *).

To ﬁnd usable gadgets, we disassemble the target bi-
nary multiple times. We start disassembling from each
individual byte in the code segment of each image, un-
til we encounter a stop condition, which can be an in-
direct control ﬂow transfer, or an invalid or privileged
instruction. This is similar to the static analysis phase of
kBouncer that determines the locations of gadgets. Like
kBouncer, we follow direct branches and calculate the
length of a gadget using the shortest number of instruc-
tions that can execute from the beginning of the gadget
till an indirect branch. This means that in the presence of

Gadgets already in the LBR
11
32

19 24

12 34

99

15

10

8

Initially controlled
indirect jump

5

*-JMP *

*-RET

CS-RET

kBouncer

check

VirtualProtect()

CS-CALL *

CS-RET

Gadget
size

7

2

33

3

5

SHELLCODE

Made
executable

Undetectable

Detectable

Only kBouncer

Figure 4: PoC exploit that bypasses both kBouncer
and ROPecker. This ﬁgure focuses more on the de-
tails related with kBouncer, since it uses stricter detec-
tion thresholds. Gadgets receiving control through a re-
turn are all call-preceded, depicted using the CS preﬁx
in the ﬁgure. The exploit uses one heuristic breaking
gadget to keep the chain of detectable gadgets small and
calls VirtualProtect() which triggers a kBouncer
check. Note that kBouncer and ROPecker fail to detect
gadgets longer than 20 and 6 instructions, respectively.

conditional branches, we follow both paths and use the
shortest one as the length of the gadget.

4.3 Heuristic Breakers
Since our exploit should ﬂy under kBouncer’s defen-
sive radar, we have to ensure that we do not use se-
quences of more than seven short gadgets at any time
(i.e., kBouncer-gadgets with 20 instructions or less). We
avoid doing so by using a long gadget that performs min-
imal work (i.e., only sets a single register) as part of the
exploit. Generally, to avoid the detection an attacker
needs to intersperse the ROP chain with long gadgets.
We call such gadgets heuristic breakers (HBs). The best
properties for heuristic breaker gadgets are:

• Use a small number of registers. Such gadgets
that preserve the values of registers allow us to chain
multiple gadgets to carefully set the CPU and mem-
ory state to perform an operation like a call.

• Used registers are loaded from memory or as-
signed constant values. Long gadgets can have
various side effects like loading and writing to

422  23rd USENIX Security Symposium 

USENIX Association

6

memory, etc.. When the registers used in such op-
erations are set within the gadget, it is easier to pre-
pare the gadgets so that the gadget does not cause a
fatal fault.

• Registers are loaded from memory. Gadgets in-
cluding the epilogue of functions frequently restore
the values of various registers from the stack, allow-
ing us to set multiple registers from the controlled
stack.

• Intended gadgets. Long sequences of unintended
gadgets tend to translate to unusual sequences of
instructions. As a result, they are not as useful as
intended gadgets. Our exploit, uses only a single
small unintended gadget of two instructions, while
another one only uses an unintended call instruction
so it is call preceded.

Finally, we have to be ﬂexible when a HBs cannot be
included at a desired position in the gadget-chain. Con-
sider for example a chain of seven gadgets. Ideally, we
would insert a HB after the ﬁrst ﬁve gadgets to break the
sequence in two smaller ones, of ﬁve and two gadgets re-
spectively. Since this is not always possible, due to the
exploit’s semantics, we may need to insert a HB sooner,
for example after the ﬁrst three gadgets.

4.4 Putting It All Together
Figure 4 provides a high-level graphical representation of
our PoC exploit. We obtain control by exploiting the but-
ton object’s VFT pointer, which grants us control of an
indirect jump instruction. This instruction is actually part
of a gadget (Appendix A, listing 1), as far as kBouncer
is concerned, however it is not a gadget for ROPecker
because it contains a conditional branch. The end goal
is to invoke VirtualProtect() to mark the buffer
we control and contains shellcode as executable. We can
then transfer control to it, effectively bypassing DEP and
performing a code-injection attack.

Our ﬁrst task is to point the stack pointer (i.e., ESP)
to the buffer we control, so we can perform ROP, a pro-
cess commonly referred to as stack pivoting. After re-
ceiving control, eax points to our buffer, so we use an
unintended gadget that exchanges the values of eax and
esp, and terminates with a ret, to achieve this (Ap-
pendix A, listing 2).

to

prepare

for

Next,

we want

calling
VirtualProtect(). Before doing so, we need
to interpose a HB gadget, so that the kBouncer check,
triggered by entering the API function, will not detect
our exploit. At this point, we know that the LBR
contains two gadget addresses, the one for the stack
pivoting gadget and the one before that, which is part

of the program’s legitimate control ﬂow. We know that
these two gadgets are not enough to cause detection, but
there may be other entries in the LBR preceding these
that could trigger kBouncer. Using a HB at this point
ensures that the gadget-chain length in the LBR is reset.
Moreover, using a HB at this point makes the payload
generic, allowing us to use it with other vulnerabilities,
as it will always break the gadget chain in the LBR,
as long as TG is less than its length. We use a HB
gadget of 33 instructions that sets the ESI and EDI
registers, which we use later on, and most importantly
does not depend on any register being set up on entry
(Appendix A, listing 3).

We perform the call to VirtualProtect() using
a gadget that includes an indirect call (Appendix A, list-
ing 4). This gadget only requires the ESI register to be
prepared, which we set with the previous gadget. Also,
it does not push any arguments to the stack, so the ar-
guments to the call can be prepared in our buffer in ad-
vance. This is also the point where kBouncer kicks in
and checks the LBR for an attack. By consulting Fig. 4,
we notice that kBouncer cannot detect the attack at this
point. When VirtualProtect() returns, control is
transferred where it is expected to, that is, the instruction
following the call. The next gadget executing is essen-
tially the code following the indirect call (Appendix A,
listing 5). The ret at the end of it transfers control to
our shellcode, which is now executable. To ensure that
we do not trigger any alarms in the future, we make sure
that the ﬁrst instruction in our shellcode is preceded by a
fake, unused, call instruction.

Having managed to inject code into the process, we
can now execute code without the risk of triggering
kBouncer. Notice that this exploit will keep working
even if TG is raised to 31 and TC reduced to 6.

5 Countermeasures

In this section, we discuss countermeasures, as well as
fundamental boundaries in the use of gadget-chain length
for preventing code-reuse attacks. While we mainly fo-
cus on kBouncer and ROPecker, we are conﬁdent that
our analysis of their weaknesses and the proposed coun-
termeasures will be of use to future works that plan to
explore comparable methodologies.

5.1 Tweaking the TG and TC Parameters
An obvious improvement to both these techniques in-
volves increasing TG, i.e., the parameter that determines
whether a sequence of instructions ending with an indi-
rect branch is a gadget or not. Looking back at Fig. 4, it
is clear that, in the case of kBouncer, increasing TG to 33

USENIX Association  

23rd USENIX Security Symposium  423

7

instructions would neutralize our exploit. However, in-
creasing the length of gadgets is not straightforward, as
it has various side effects.

Increasing TG will unavoidably lead to longer gad-
get chains that belong to legitimate, innocuous code.
As we consider longer code sequence as potential gad-
gets, inevitably more application execution paths will be
identiﬁed as gadgets, leading to observing longer gadget
chains at run time. Consequently, to avoid false positives,
TC also needs to be increased to avoid misclassifying le-
gitimate control ﬂows as attacks. Unfortunately, raising
TC presents opportunities to attackers for using more gad-
gets. Both kBouncer and ROPecker assume that attack-
ers cannot use longer gadgets due to the side effects that
such gadgets have, something that both this paper and
previous work [16] disproves. Defenders also face an
asymmetry, as usual, because attackers need only ﬁnd a
handful of long gadgets to masquerade their payload. To
maximize the effect of the parameters, what needs to be
optimized is the fraction TG
. While this is probably an
TC
oversimpliﬁcation, it provides a useful rule of thumb.

5.1.1 Per-Application Parameters

Acceptable settings for TG and TC vary depending on the
application being examined [8]. The nature of the ap-
plication itself, the compiler it was built with, and the
shared libraries it uses, inﬂuence the generated binary
code and what parameter values can be used to avoid FPs
and concurrently detect attacks consistently.

We can exploit this observation to use different val-
ues based on the application. This would ensure that the
strictest rules are applied every time. However, doing
so is also not without difﬁculty because both the defense
and the attack depend greatly on the application in ques-
tion. For example, after analyzing an application, we can
determine that a very strict set of TC and TG can be used
without FPs. However, the application may contain gad-
gets much larger than TG that can be directly chained
together, so no gadget chains are identiﬁed. This sce-
nario is obviously ideal for the attacker. Further research
is required to establish a metric that quantiﬁes the ef-
fect of selecting a particular set of parameters. Using
per-application parameters can be also challenging in the
presence of dynamically loaded (DL) libraries (i.e., li-
braries loaded at times other than program start up), as
new, potentially unknown code is introduced in the ap-
plication.

5.1.2 Per-Call Parameters

A novel idea to further customize the parameters is to
use different gadget-chain thresholds (TC) based on the
part of the code executing. kBouncer that triggers check

on certain API calls, would greatly beneﬁt from this ap-
proach. Certain APIs may be normally called through
limited executions paths that exhibit very particular char-
acteristics. For instance, a Windows native API call
(win32) is frequently called by higher-level frameworks.
This approach has the beneﬁt of both avoiding FPs,
hence providing better stability, and improving security
guarantees.

5.1.3 Cumulative Chain-Length Calculation
ROPecker also accumulates the lengths of smaller
gadget-chain segments and uses a different parameter
TCC to detect attacks. While this heuristic is not effec-
tive with our exploit, it would be interesting to explore
whether incorporating it in kBouncer, which checks for
attacks less frequently and in a more controlled manner,
would further raise the bar for attackers.

5.1.4 Obstacles
Recursive functions can cause signiﬁcant problems with
techniques based on counting gadget chains. Due to their
nature, they can generate a large number of consecutive
returns when they reach their end condition (e.g., when
their computation has ﬁnished). If the returns within the
recursive function lead to gadgets, then it is extremely
hard to ﬁnd any value of TC that would not cause FPs,
unless the recursion is very shallow (relative to the value
of TC). kBouncer seems to avoid such conditions because
it only checks the LBR when an API call is made. In a
sense, it performs checks at the boundary between ap-
plication and kernel, and the intuition is that the checks
are made “far” away from the algorithms in the core of
applications. However, it is not an uncommon scenario
that a recursive algorithm requires to allocate memory or
write into a ﬁle. In such cases, lowering the maximum
gadget length (TG) is the only option for avoiding FPs.
On the other hand, ROPecker performs checks far more
frequently and whenever execution is transferred to new
pages, so we expect that it is even more fragile in the
presence of recursive algorithms.

the exploit we describe in Sec. 4.

5.2 Combining with CFI
CFI [1] enforces control-ﬂow integrity and can pre-
vent
In par-
ticular, recent CFI approaches like CCFIR [39] and
binCFI [40] prevent the use of unintended gadgets, such
as the two-instruction gadget we use for stack pivot-
ing (Appendix A, listing 2). CCFIR, in particular,
also disallows indirect calls to certain API calls like
VirtualProtect(), so it prevents two gadgets used
by our exploit. These CFI approaches also incur low per-
formance overhead, making them a good candidate for

424  23rd USENIX Security Symposium 

USENIX Association

8

Gadgets already in the LBR
5
19

12 34

11

99

15

10

Gadget
size

*-JMP *

EP-CALL *

EP-CALL *

CS-R

CS-R

CS-R

7

34

21

2

28

50

8 CS-CALL
CS-RET
18

29 CS-R

2

8

CS-F

CS-R

CODE
AREA

r
e
c
n
u
o
B
k
 
y
l
n
O

e
l
b
a
t
c
e
t
e
D

e
l
b
a
t
c
e
t
e
d
n
U

Initially controlled
indirect jump

EP-R

32

kBouncer

check

VirtualProtect()

Make
writable

memcpy()

Copy
shellcode

PoC exploit

that bypasses kBouncer,
Figure 5:
ROPecker, and CCFIR. All the gadgets used are intended
call-site (CS) or entry-point (EP) gadgets.

coupling with kBouncer. Unfortunately, recent work [16]
has shown that they are still vulnerable to attack. So is a
combination of CFI and kBouncer still vulnerable?

To answer the above question, we begin from the ex-
ploit used to bypass CFI in previous work [16, Sec. IV]
and replace the smaller gadgets with longer HB gadgets
that are also allowable by CFI. Similarly to prior work,
we assume that CCFIR is in place, as it is stricter than
binCFI. Because CFI does not allow transfers to new
code, the goal of this payload is to mark existing code
as writable and overwrite it with our shellcode. Before
proceeding to describe the exploit, we summarize the ad-
ditional restrictions imposed by CCFIR below.

Under CCFIR, return instructions can no longer trans-
fer control to unintended gadgets, so only CS gadgets
that were originally emitted by the compiler can be used
when constructing a payload. Indirect call and jump in-
structions are also restricted and can only transfer control
to function entry points, deﬁning a new type of entry-
point (EP) gadget. Indirect calls to sensitive API calls are
prohibited, so any such calls need to be made using di-
rect call instructions, contained within otherwise allow-
able gadgets. Finally, CCFIR introduces a new level of
randomization through the use of springboard sections

that proxy indirect control transfers. The location of
these sections is randomized at load time and all indirect
branches can only proceed through them.

To prepare the new payload, we need to replicate the
steps described in Sec. 4, as well as a couple of additional
steps required for bypassing CCFIR. Because of the ran-
domized springboard sections, we need to reveal the sec-
tions that hold call and return stubs to the gadgets we plan
to use. Fortunately, this can be achieved by exploiting the
string object to leak code and meta-data from the DLLs
of interest [16, Sec. IV.C]. VirtualProtect() and
memcpy() are now called through gadgets that contain
a direct call to these functions, so we do not need to ex-
plicitly locate them in the target process.

Figure 5 depicts a high-level overview of our sec-
ond PoC exploit that overcomes the restrictions imposed
by both kBouncer and CCFIR. We notice that because
of CCFIR, we cannot use the same gadget to perform
stack pivoting and, furthermore, we can only jump to an
EP gadget. We resort to using a series of ﬁve gadgets
to achieve the same goal (Appendix B, listings 6-10).
Speciﬁcally, we ﬁrst use three EP gadgets to corrupt the
stack, so we can control a return instruction. This is simi-
lar to [16], however we use different, longer gadgets that
are not detected by kBouncer. The fourth gadget loads
EBP with our data and completes the switch to chaining
through returns. We then use the ﬁfth gadget, consisting
of 28 instructions, to perform stack pivoting by copying
EBP to ESP through the leave instruction.

For calling VirtualProtect() and memcpy(),
we reuse the same gadgets used against CFI (Ap-
pendix B, listings 12-13 and 15-16 respectively). The
last gadget’s ret transfers control to our shellcode that
has been copied to the code section of the binary and
has been preceded by a call to also foil future kBouncer
checks. However, we replace the gadgets used to pre-
pare the function-calling gadgets with the ones shown in
listings 11 and 14 respectively, in Appendix B.

The exploit depicted in Fig. 5 demonstrates that even
if we combine kBouncer and a loose CFI defense, it is
still possible to devise attacks that can go undetected.
Moreover, it shows that even if TC and TG are signiﬁ-
cantly tweaked, gadgets much larger than 21 instructions
are available to partition an exploit to smaller, possibly
undetectable, chains. In the particular exploit, setting TG
to 33 and TC to 5 would still not have any effect.

6 Evaluation

6.1 Gadget Availability
The existence of long gadgets determines the potential to
ﬁnd HB gadgets that can be used to break long gadget
chains. It is also an indicator on whether, we can poten-

USENIX Association  

23rd USENIX Security Symposium  425

9

IE8
IE9
Acrobat
Excel
Flash

PowerPoint
Windows Media Player
Word

 1e+07

 1e+06

 100000

s
t
e
g
d
a
G

 1e+06

 100000

 10000

 1000

s
t
e
g
d
a
G

IE8
IE9
Acrobat
Excel
Flash

PowerPoint
Windows Media Player
Word

 10000

 0

 10

 20

 30

Gadget Length

(a) All gadgets.

 40

 50

 60

 100

 0

 10

 20

 30

Gadget Length

 40

 50

 60

(b) Call-preceded gadgets available to link using a ret.

Figure 6: Distribution of gadgets available to attackers under kBouncer based on their length, as recorded for multiple
popular applications. We notice that there are numerous gadgets, even for gadgets of 60 instructions.

Application
Windows
Media Player
Internet Explorer 9
Adobe Flash Player
Microsoft Word
Microsoft PowerPoint
Adobe Reader XI

Workload
Music playback for approximately
30 secs
Surf to google.com
Watch a YouTube video
Browse a Word document
Browse a PowerPoint presentation
Browse a PDF ﬁle

Table 1: Applications used in the evaluation.

tially use many different HB gadgets with varying func-
tionality. We analyze the applications listed in Tab. 1,
along with all their DLLs, to determine how many gad-
gets of different sizes they contain. In addition, we an-
alyze Internet Explorer 8, which we used in our PoC.
We follow the same methodology we used for collecting
gadgets for the PoC exploit (Sec. 4.2). Speciﬁcally, we
developed a gadget extraction tool in Python, using the
popular distorm disassembler [15].

The process begins by disassembling from each byte
in the code segment of each target binary, recursively fol-
lowing conditional branches, direct calls and jumps to
locate instruction paths that end with a return or an indi-
rect call or jump. That is, potential gadgets. As we dis-
assemble, we count the number of instructions on each
of the traversed paths, while we also keep track of the
nodes we visit to avoid counting the same instructions
more than once, due to loops. If we ﬁnd more than one
path starting from a particular byte and ending in an in-
direct branch, we keep the shortest path, and consider its
length to be the length of the gadget at that byte. This is
in accordance to how kBouncer identiﬁes gadgets.

Figure 6 draws our results. We notice that even for

relatively large gadget sizes, there are tens of thousands
of gadgets. While we cannot make any assumptions on
how usable they are, these results are an indication that
there is a signiﬁcant pool of gadgets to choose from. We
attribute their large number to the fact that unintended
gadgets are basically allowed by kBouncer.

6.2 Per-Application Parameters
In this section, we evaluate the feasibility of our per-
application parameter scheme described in Sec. 5.1.1. To
determine if, indeed, different applications can beneﬁt
from using tighter parameters, we run the six applica-
tions listed in Tab. 1 performing simple tasks, such as
browsing. These applications were also used to perform
a similar evaluation in kBouncer. We follow the same
methodology to measure gadget-chain length.

We use a run-time monitoring tool based on Intel’s
Pin [22] to emulate the operation of LBR. We moni-
tor every indirect branch instruction, including returns,
jumps, and calls, and log the running thread ID, the ad-
dress of the branch, and its target. To locate kBouncer
gadgets, we borrowed the scripts used by kBouncer to
disassemble the application images and their DLLs and,
at the same time, locate the sensitive API calls where
checks are injected by kBouncer [25, Appendix]. We
combine the statically and dynamically collected infor-
mation to match gadgets with control transfers observed
at run time and calculate the length of gadget chains that
would be checked by kBouncer.

Figure 7 shows the size of gadget chains (for TG = 20),
as they would be stored in LBR when entering a sensi-
tive API call and for different applications. We observe
that among the tested applications, only Adobe Reader

426  23rd USENIX Security Symposium 

USENIX Association

10

 100000

 10000

 1000

 100

 10

 1

s
e
c
n
a

t
s
n

I
 
f

o

 
r
e
b
m
u
N

 0.1

 0

 1

Acrobat
IE (Google)
IE (YouTube)
Excel
Word
PowerPoint
WMPlayer

 2

 3

Gadget-chain length

 4

 5

Figure 7: Length of chains for TG = 20 for different ap-
plications, when entering a protected API function call.
We run seven workloads using six applications, replicat-
ing the experiment in kBouncer [25, Sec. 3.2].

exhibits relatively long chains of ﬁve gadgets. This is
in accordance with previously reported results [25]. All
other tested applications include chains of up to two gad-
gets.
In principle, this implies that we could use very
strict values of TC for all these applications. For ex-
ample, using TC = 3 with Internet Explorer would de-
tect our long ﬁve-gadget sequence preceding the call to
VirtualProtect() (Fig. 4).

This experiment shows that application-speciﬁc pa-
rameters can make it very hard for attackers to evade de-
tection, at least with the methodology followed by our
PoC exploit. However, we remain cautious, as run-time
analysis can have limited coverage, even when divergent
workloads are used, so using such strict values for TC
could cause FPs. In fact, recent works [12,29] report FPs
with applications other than the ones originally tested
in kBouncer [25], and when more restrictive parameters
are employed. Nonetheless, establishing viable values
for these parameters through dynamic and static analysis
calls for additional research. The above serve as an indi-
cator that per-application parameter ﬁtting is necessary.

7 Related Work

Code reuse is the dominant form of exploitation since
the wide adoption of stack canaries [9] and data exe-
cution prevention [2], which provide protection against
stack smashing and code injections respectively. Return-
to-libc attacks [37] is one of the simplest
types of
code reuse,
involving the redirection of control to a
libc function after setting up its arguments in the
stack. Usually, this involves invoking functions like
system() or exec() to launch another program (e.g.,
to spawn a shell). Short gadgets were also used in reg-

ister springs [10] to load a register with the address of
the attacker-controlled buffer located in the randomized
stack or heap.

Return-Oriented Programming [31] generalizes the
task of leveraging existing code to compromise a pro-
gram. Short snippets of code, called gadgets, are chained
together to introduce a new, not initially intended, con-
trol ﬂow. ROP is particularly effective on instruction sets
like CISC, where there are no instruction alignment re-
quirements and the instruction number is high, because
any sequence of executable bytes in memory can poten-
tially become a gadget. Nevertheless, RISC architectures
are also vulnerable to ROP [5].

Diversiﬁcation approaches like Address-Space Lay-
out Randomization (ASLR) [26] can be effective against
ROP attacks and are already present in most OSs. ASLR
randomizes the layout of a program when it is executed
by loading the binary and its dynamic libraries on dif-
ferent base addresses each time. ASLR can be brute-
forced [32], but the difﬁculty of doing so increases as
more entropy becomes available, like in 64-bit systems.
Recent attacks bypassing ASLR [30] rely on memory
disclosure bugs that leak enough data from the targeted
process to infer where the binary and/or its libraries are
loaded at run time.

Finer-grained randomization approaches [17, 24, 38]
have been proposed to further diversify programs and
limit the effectiveness memory leaks.
In-place ran-
domization [24] relies on randomizing the sequence of
instructions and replacing instructions with others of
equivalent effect to further diversify the image of a run-
ning process.
ILR [17] attempts to break the linearity
of the address space, and binary stirring [38] random-
izes a binary in the basic block level. However, recent
research [34] has demonstrated that bugs that allow an
attacker to read almost arbitrary memory locations can
be used to bypass the above solutions as well.

CFI [1] enforces control-ﬂow integrity preventing the
malicious control ﬂows that are part of ROP attacks,
and it is not affected by memory leaks. CFI requires
an accurate control-ﬂow graph of the target program,
which usually implies access to source code, but recent
works [39, 40] have made steps towards addressing this
limitation by applying a loose version of CFI on bina-
ries. However, it has been recently shown [16] that these
loose-CFI approaches are still vulnerable to attack in the
presence of memory leaks. This work builds on the latter,
borrowing the notion of call-site and entry-point gadgets,
which are also the only kind of accessible gadgets under
kBouncer and friends, and uses the same IE vulnerability
as a starting point. However, the attack described in [16]
is not effective against kBouncer. In this work we build
an attack that is again effective. We also show that us-
ing the LBR and a set of heuristics is not sufﬁcient to

USENIX Association  

23rd USENIX Security Symposium  427

11

prevent ROP attacks and reveal the inherent limitations
of solutions based on gadget and chain length for detec-
tion. Finally, we propose various extensions that could
alleviate the situation.

Compile-time solutions have been also proposed to al-
ter the produced binary, so it is impervious to code reuse
attacks. For example, producing a kernel that does not
include any return instructions [21] cannot be exploited
using ROP. However, variations of ROP that use indirect
jumps instead of returns [3, 6] can be used to circum-
vent the above. G-Free [23] attempts to restrict control
ﬂow by using function cookies saved in a shadow stack
at run time and inserts NOPs to destroy unintended gad-
gets. Because it is only loosely enforcing control ﬂow, it
is potentially vulnerable to the same attacks as CFI [16].
Additionally, compile-time approaches require that a bi-
nary and all of its libraries are recompiled.

Concurrently with our work, other efforts have also
dealt with evaluating kBouncer and related approaches.
Schuster et al. [29] take a slightly different approach and
focus on ﬁnding gadgets that could be used to ﬂush the
LBR before performing any API call. The presence of
such gadgets in the application nulliﬁes any LBR-based
defense, however, it leads to the same value being re-
peated in the LBR, which could potentially be used to
detect such attacks. Moreover, the addition of CFI could
restore the effectiveness of kBouncer.

On the other hand, Davi et al. [12] take an approach
closer to ours. First, they show that there are enough
small gadgets under loose CFI to perform any computa-
tion. Then, they introduce a long gadget of 23 instruc-
tions that does not perform any useful functionality and
has limited side effects. They use this as a NOP gad-
get for breaking long gadget chains. Registers are not
preserved, so additional gadgets need to be introduced
to save any registers that need to be preserved. Larger
NOP gadgets are not investigated, so unlike our approach
their approach is more prone to detection when choos-
ing stricter thresholds.
Interestingly enough, both ap-
proaches test kBouncer, albeit with a different set of ap-
plications, and report false positives with the current, as
well as with stricter thresholds.

8 Conclusion

In this paper we explored the feasibility of bypassing
state-of-the-art ROP defenses based on monitoring pro-
cesses (by means of Intel’s new Last Branch Record) to
detect control ﬂows that resemble the execution of ROP
chains [8, 25]. Essentially, these defenses check whether
a sensitive API call was reached via a sequence of indi-
rect branches to short, gadget-like, instruction sequences.
Evading such detection is perceived as a hard task. First,
all exploitation should be carried out using call-preceded

gadgets, since otherwise the ROP chain will be easily
detectable. Second, exploitation should ﬁnd and then
carefully insert long gadgets, in the middle of a series of
shorter gadgets, in order to ﬂy under the defense’s ROP
radar. The long gadgets should be long enough to make
the ROP chain look like a legitimate control ﬂow of the
running process. Finding such long gadgets and gluing
them in the actual ROP chain is not trivial, since it is pos-
sible that these long series of instructions interfere with
the state of the exploit (e.g., modify a valuable register).
Nevertheless, in this paper, we successfully constructed
two real exploits, which utilizes the long gadgets to evade
detection. With this work we stress that the selection
of critical parameters, such as the length of a series of
instructions that should be considered a gadget, as well
as the gadget-chain length is not trivial. Until we solve
these problems, the defenses are prone to false negatives
and false positives. Finally, we discuss various counter-
measures and provide evidence, through an experimental
evaluation, that deﬁning parameters on a per-application
basis, can alleviate these concerns.

Acknowledgment
We want to express our thanks to the anonymous review-
ers for their valuable comments. In particular, we want
to thank our shepherd, Kevin Fu, who helped us give this
paper its ﬁnal form. This work was supported by the US
Air Force through Contract AFRL-FA8650-10-C-7024.
Any opinions, ﬁndings, conclusions or recommendations
expressed herein are those of the authors, and do not nec-
essarily reﬂect those of the US Government, or the Air
Force. This work was also supported in part by the ERC
StG project Rosetta, the FP7-PEOPLE-2010-IOF project
XHUNTER, No. 273765, the Prevention of and Fight
against Crime Programme of the European Commission
– Directorate-General Home Affairs (project GCC), and
EU FP7 SysSec, funded by the European Commission
under Grant Agreement No. 257007.

References
[1] ABADI, M., BUDIU, M., ERLINGSSON, U., AND LIGATTI, J.

Control-ﬂow integrity. In Proc. of the 12th ACM CCS (2005).

[2] ANDERSEN, S., AND ABELLA, V. Changes to functionality in
Microsoft Windows XP Service Pack 2, part 3: Memory protec-
tion technologies, Data Execution Prevention. Microsoft TechNet
Library, September 2004. http://technet.microsoft.
com/en-us/library/bb457155.aspx.

[3] BLETSCH, T., JIANG, X., FREEH, V. W., AND LIANG, Z.
Jump-oriented programming: a new class of code-reuse attack.
In Proc. of the 6th ACM ASIACCS (2011).

[4] BOSMAN, E., AND BOS, H. We got signal. a return to portable

exploits. In Proc. of the 35th IEEE S&P (2014).

[5] BUCHANAN, E., ROEMER, R., SHACHAM, H., AND SAVAGE,
S. When good instructions go bad: Generalizing return-oriented
programming to RISC. In Proc. of the 15th ACM CCS (2008).

428  23rd USENIX Security Symposium 

USENIX Association

12

[6] CHECKOWAY, S., DAVI, L., DMITRIENKO, A., SADEGHI, A.-
R., SHACHAM, H., AND WINANDY, M. Return-oriented pro-
gramming without returns. In Proc. of the 17th ACM CCS (2010).
[7] CHEN, P., XIAO, H., SHEN, X., YIN, X., MAO, B., AND
XIE, L. DROP: Detecting return-oriented programming mali-
cious code. In Proc. of the 5th ICISS (2009).

[8] CHENG, Y., ZHOU, Z., YU, M., DING, X., AND DENG,
R. H. ROPecker: A generic and practical approach for defending
against ROP attacks. In Proc. of the 21st NDSS (2014).

[9] COWAN, C., PU, C., MAIER, D., HINTON, H., WALPOLE, J.,
BAKKE, P., BEATTIE, S., GRIER, A., WAGLE, P., ZHANG, Q.,
ET AL. StackGuard: Automatic adaptive detection and prevention
of buffer-overﬂow attacks. In Proc. of the 7th USENIX Security
Symposium (1998).

[10] DARK SPYRIT. Win32 buffer overﬂows (location, exploitation,

and prevention). Phrack magazine 9, 55 (1999).

[11] DARKREADING.

Heap
latest
weapon of choice.
http://www.darkreading.com/
security/vulnerabilities/showArticle.jhtml?
articleID=221901428, November 2009.

Attackers’

spraying:

[12] DAVI, L., LEHMANN, D., SADEGHI, A.-R., AND MONROSE,
F. Stitching the gadgets: On the ineffectiveness of coarse-grained
control-ﬂow integrity protection. In Proc. of the 23rd USENIX
Security Symposium (August 2014).

[13] DAVI, L., SADEGHI, A.-R., AND WINANDY, M. ROPdefender:
A detection tool to defend against return-oriented programming
attacks. In Proc. of the 6th ACM ASIACCS (2011).

[14] DEMOTT, J. Bypassing emet 4.1. http://bromiumlabs.
files.wordpress.com/2014/02/bypassing-emet-
4-1.pdf, February 2014.

[15] DISTORM.

Powerful disassembler library for x86/AMD64.

https://code.google.com/p/distorm/.

[16] GÖKTA ¸S, E., ATHANASOPOULOS, E., BOS, H., AND POR-
TOKALIDIS, G. Out of control: Overcoming control-ﬂow in-
tegrity. In Proc. of the 35th IEEE S&P (May 2014).

[17] HISER, J., NGUYEN-TUONG, A., CO, M., HALL, M., AND
DAVIDSON, J. W. ILR: Where’d my gadgets go? In Proc. of the
33rd IEEE S&P (2012).

[18] HITMANPRO.

Real-time exploit mitigation and intru-
sion detection. http://dl.surfright.nl/Alert-3/
HitmanPro-Alert-3-Datasheet.pdf, February 2014.
[19] HUNT, G., AND BRUBACHER, D. Detours: Binary interception
of Win32 functions. In Proc. of the 3rd Conference on USENIX
Windows NT Symposium (1999).

[20] INTEL.

Intel 64 and IA-32 architectures software developer’s
manual, volume 3B: System programming guide, part 2. http:
//www.intel.com.

[21] LI, J., WANG, Z., JIANG, X., GRACE, M., AND BAHRAM,
S. Defeating return-oriented rootkits with return-less kernels. In
Proc. of the 5th EuroSys (2010).

[22] LUK, C.-K., COHN, R., MUTH, R., PATIL, H., KLAUSER, A.,
LOWNEY, G., WALLACE, S., REDDI, V. J., AND HAZELWOOD,
K. Pin: Building Customized Program Analysis Tools with Dy-
namic Instrumentation. In Proc. of the 26th PLDI (2005).

[23] ONARLIOGLU, K., BILGE, L., LANZI, A., BALZAROTTI, D.,
AND KIRDA, E. G-Free: Defeating return-oriented programming
through gadget-less binaries. In Proc. of the 26th ACSAC (2010).
[24] PAPPAS, V., POLYCHRONAKIS, M., AND KEROMYTIS, A. D.
Smashing the gadgets: Hindering return-oriented programming
using in-place code randomization.
In Proc. of the 33rd IEEE
S&P (2012).

[25] PAPPAS, V., POLYCHRONAKIS, M., AND KEROMYTIS, A. D.
Transparent ROP exploit mitigation using indirect branch tracing.
In Proc. of the 22nd USENIX Security Symposium (2013).

[26] PAX TEAM. Address Space Layout Randomization, 2003.

http://pax.grsecurity.net/docs/aslr.txt.

[27] PELLETIER, A. Advanced exploitation of Internet Explorer heap
overﬂow (Pwn2Own 2012 exploit). VUPEN Vulnerability Re-
search Team (VRT) Blog, July 2012. http://www.vupen.
com/blog/20120710.Advanced_Exploitation_of_
Internet_Explorer_HeapOv_CVE-2012-1876.php.
[28] PORTNOY, A. Bypassing all of the things. EXODUS INTEL-
LIGENCE. https://www.exodusintel.com/files/
Aaron_Portnoy-Bypassing_All_Of_The_Things.
pdf.

[29] SCHUSTER, F., TENDYCK, T., PEWNY, J., MAASS, A., STEEG-
MANNS, M., CONTAG, M., AND HOLZ, T. Evaluating the ef-
fectiveness of current anti-ROP defenses. In Proc. of the Interna-
tional Conference on RAID (September 2014).

[30] SERNA, F. J. CVE-2012-0769, the case of the perfect info
leak. http://zhodiac.hispahack.com/my-stuff/
security/Flash_ASLR_bypass.pdf.

[31] SHACHAM, H. The geometry of innocent ﬂesh on the bone:
Return-into-libc without function calls (on the x86). In Proc. of
the 14th ACM CCS (October 2007).

[32] SHACHAM, H., PAGE, M., PFAFF, B., GOH, E.-J.,
MODADUGU, N., AND BONEH, D. On the effectiveness of
address-space randomization.
In Proc. of the 11th ACM CCS
(2004).

[33] SKOWYRA, R., CASTEEL, K., OKHRAVI, H., ZELDOVICH, N.,
AND STREILEIN, W. Systematic analysis of defenses against
return-oriented programming. In Proc. of the 16th RAID (2013).
[34] SNOW, K. Z., DAVI, L., DMITRIENKO, A., LIEBCHEN, C.,
MONROSE, F., AND SADEGHI, A.-R. Just-in-time code reuse:
On the effectiveness of ﬁne-grained address space layout random-
ization. In Proc. of the 34th IEEE S&P (May 2013).

[35] SOTIROV, A. Heap feng shui in javascript. Black Hat Europe

(2007).

[36] STRACKX, R., YOUNAN, Y., PHILIPPAERTS, P., PIESSENS, F.,
LACHMUND, S., AND WALTER, T. Breaking the memory se-
crecy assumption. In Proc. of the 2nd EuroSec (2009).

[37] TRAN, M., ETHERIDGE, M., BLETSCH, T., JIANG, X., FREEH,
V., AND NING, P. On the expressiveness of return-into-libc at-
tacks. In Proc. of the 14th RAID (2011).

[38] WARTELL, R., MOHAN, V., HAMLEN, K. W., AND LIN, Z.
Binary stirring: Self-randomizing instruction addresses of legacy
x86 binary code. In Proc. of the 2012 ACM CCS (2012).

[39] ZHANG, C., WEI, T., CHEN, Z., DUAN, L., SZEKERES, L.,
MCCAMANT, S., SONG, D., AND ZOU, W. Practical control
ﬂow integrity and randomization for binary executables. In Proc.
of the 34th IEEE S&P (2013).

[40] ZHANG, M., AND SEKAR, R. Control ﬂow integrity for cots

binaries. In 22nd USENIX Security Symposium (2013).

A PoC Exploit Gadgets

; library: mshtml.dll
; offset:
0x001BC907
; type:
intended, *-JMP *
1 mov
2 test
3 js

eax, [ecx+1Ch]
al,
loc1

al

USENIX Association  

23rd USENIX Security Symposium  429

13

ecx, dword ptr [ecx+24h]
eax, dword ptr [ecx]
edx, dword ptr [eax+24h]
edx

loc1:
4 mov
5 mov
6 mov
7 jmp
; edx points to 1st gadget
Listing 1: The exploitation of the vulnerability in
Internet Explorer 8 gives us control of an indirect
jump. The target address of the indirect jump is loaded
from the sprayed buffer, by dereferencing values in the
overwritten button object. After this code sequence,
ecx contains a pointer to the overwritten button object,
eax contains a pointer to our sprayed buffer, and edx
contains the address of the ﬁrst gadget.

0x00146FB2
unintended, *-RET

; library: shell32.dll
; offset:
; type:
1 xchg esp, eax
2 retn
Listing 2: This is the ﬁrst executed gadget after the
control of the indirect jmp instruction. The gadget
performs the stack pivoting operation. Essentially, the
values in the eax and the esp registers are swapped.
On entry, eax points to the sprayed buffer, which
contains the rest of the ROP chain.

; library: shell32.dll
; offset:
; sort:

0x0007AACD
intended instructions, unintended CS-RET
esi, 738AD720h
edi, 73BCC3C0h

1 mov
2 mov
3 movsd

...
7 mov
8 mov
9 movsd

...
13 mov
14 mov
15 movsd

...
19 mov
20 mov
21 movsd

...
25 mov
26 mov
27 movsd

esi, 738AD710h
edi, 73BCC3D4h

esi, 738AD730h
edi, 73BCC3E8h

esi, 738AD700h
edi, 73BCC3FCh

esi, 7387A2CCh
edi, 73BCC410h

edi
esi

...
31 pop
32 pop
33 retn
Listing 3: This is a heuristic-breaker gadget, i.e., an
undetectable long gadget. First, it is used to reset the
chain of detectable gadgets in the ROP chain. Second,
it will prepare the esi register, which is required by
the next gadget that will call VirtualProtect().
Upon entry, it does not require any registers to be
already set up, but it alters two registers: esi and edi,
loading them with values from our buffer.

; library: shell32.dll
; offset:
; type:
1 lea
2 mov

0x0039C0E5
intended, CS-CALL *
ecx, [esi+28h]
edi, eax

eax, [ecx]
dword ptr [eax+44h]

3 mov
4 call
Listing 4: An indirect function call that we use to
call VirtualProtect() and change the memory
permissions of the region occupied by the injected
shellcode, which also resides in the sprayed buffer. The
gadget does not push values, so the arguments for the
called function can be prepared in advance in the ROP
chain, and it also saves EAX in EDI before calling.

0x0039C0EF
intended, CS-RET

eax, edi
edi
esi
ebp
0Ch

; library: shell32.dll
; offset:
; type:
1 mov
2 pop
3 pop
4 pop
5 retn
Listing 5: The instructions following the indirect call in
listing 4 also constitute a gadget. This gadget restores
EAX from EDI, thus restoring to the value it had before
entering the previous gadget, and returns using the
next value in our ROP chain transferring control to our
shellcode.
B CFI-resistant PoC Exploit Gadgets

; library: ieframe.dll
; offset:
; type:

0x00216C0E
EP
edi, edi
ebp
ebp, esp
esp, 2C8h
eax, ___security_cookie
eax, ebp
[ebp-4], eax
eax, [ebp+0Ch]
ebx
esi
edi
edi, [ebp+8]
[ebp-290h], eax
eax, eax
3
[ebp-280h], eax
[ebp-284h], eax
[ebp-288h], eax
[ebp-2A0h], eax
[ebp-2A4h], eax
eax
esi, ecx
[ebp-2B8h], ax
eax, [esi+24h]
edx, [ebp-2C8h]
edx
[ebp-2B0h], eax
eax, [esi+1Ch]
ecx, [eax]
edx, [ebp-2B8h]
edx
eax
[ebp-294h], edi
dword ptr [ecx+1Ch]

1 mov
2 push
3 mov
4 sub
5 mov
6 xor
7 mov
8 mov
9 push
10 push
11 push
12 mov
13 mov
14 xor
15 push
16 mov
17 mov
18 mov
19 mov
20 mov
21 pop
22 mov
23 mov
24 mov
25 lea
26 push
27 mov
28 mov
29 mov
30 lea
31 push
32 push
33 mov
34 call
Listing 6: By pushing a pointer to the sprayed buffer
as an argument (see Line 32), this gadget prepares the
gadget (see Listing 7) that will call the stack smasher
(see Listing 8).

430  23rd USENIX Security Symposium 

USENIX Association

14

1 mov
2 push
3 mov
4 push
5 mov
6 push
7 mov
8 push
9 mov

; library: mshtml.dll
; offset:
0x004A959F
EP
; type:
edi, edi
ebp
ebp, esp
dword ptr [ebp+30h]
eax, [ebp+8]
dword ptr [ebp+2Ch]
ecx, [eax+4]
dword ptr [ebp+28h]
ecx, [ecx]
dword ptr [ebp+24h]
dword ptr [ebp+20h]
dword ptr [ebp+1Ch]
dword ptr [ebp+18h]
dword ptr [ebp+14h]
dword ptr [eax+0Ch]
dword ptr [eax+8]
dword ptr [ebp+10h]
dword ptr [ebp+0Ch]
eax
dword ptr [ecx]
dword ptr [ecx+10h]

10 push
11 push
12 push
13 push
14 push
15 push
16 push
17 push
18 push
19 push
20 push
21 call
Listing 7: This gadget will push the address of the call
site gadget (see Line 15) we want to be executed later in
the chain (see Listing 10). Once we get to this desired
call site gadget, the switch from Entry Point to Call Site
gadgets is complete.

; library: ieframe.dll
; offset:
; type:

0x000A98B5
EP
edi, edi
ebp
ebp, esp
eax, [ebp+8]
ecx, [eax+140h]
ebx
ebx, [ebp+14h]
esi
esi, [ebp+0Ch]
[esi], ecx
ecx, [eax+144h]
edx, [ecx]
edi
edi, [ebp+10h]
[edi], edx
edx, [eax+148h]
edi, [edx]
[ebx], edi
edi, edi
[eax+140h], edi
[ecx], edi
[edx], edi
eax, [esi]
eax
eax, eax
edi
eax, 7FFFBFFBh
esi
eax, 80004005h
ebx
ebp
10h

1 mov
2 push
3 mov
4 mov
5 mov
6 push
7 mov
8 push
9 mov
10 mov
11 lea
12 mov
13 push
14 mov
15 mov
16 lea
17 mov
18 mov
19 xor
20 mov
21 mov
22 mov
23 mov
24 neg
25 sbb
26 pop
27 and
28 pop
29 add
30 pop
31 pop
32 retn
Listing 8: This is a long gadget that moves data and
does not harm the status of our ROP chain. Also, it will
break the calling assumptions of the caller gadget (see
Listing 7).

; library: mshtml.dll
0x004A95D6
; offset:
EP
; type:
ebp

1 pop

2 retn

2Ch

Listing 9: The instructions following the indirect call in
listing 7 also constitute a gadget. The return instruction
in this gadget will use the address of the call site
gadget that was pushed before (see Listing 7). Also,
in this gadget ebp is prepared with a pointer to our
sprayed buffer. The value in this register will be moved
to the esp register in the stack pivoting gadget (see
Listing 10).

; library: mshtml.dll
0x00305202
; offset:
CS
; type:
ecx, [ebp+30h]
edx, [ebp+40h]
[ecx], eax
eax, [ebp+34h]
ecx, [ebp+3Ch]
esi, 6
esi, 1
dword ptr [ebp+8], 0
[eax], esi
eax, [ebp-0Ch]
[ecx], eax
eax, [ebp-4]
ecx, [eax]
ecx, [ecx+88h]
[edx], ecx
ecx, [eax]
ecx, [ecx+30h]
edx, [ebp+44h]
[edx], ecx
ecx, [ebp+38h]
[ecx], eax
next_ins
eax, [ebp+8]
edi
esi
ebx

1 mov
2 mov
3 mov
4 mov
5 mov
6 shr
7 and
8 and
9 mov
10 mov
11 mov
12 mov
13 mov
14 mov
15 mov
16 mov
17 mov
18 mov
19 mov
20 mov
21 mov
22 jmp
23 mov
24 pop
25 pop
26 pop
27 leave
28 retn
Listing 10: This is a stack pivoting gadget. This gadget
will load esp with a pointer to our sprayed buffer at
Line 27.

40h

; library: mshtml.dll
0x0021FDF4
; offset:
CS
; type:
eax, [ebp+0Ch]
[ebx], eax
7
ecx
esi, [eax+228h]

1 mov
2 mov
3 push
4 pop
5 lea
6 rep movsd
7 mov
8 mov
9 mov
10 mov
11 mov
12 mov
13 mov
14 mov
15 mov
16 mov
17 mov
18 mov
19 mov
20 mov
21 mov
22 mov
23 mov
24 mov
25 mov

ecx, [eax+244h]
[ebx+20h], ecx
ecx, [eax+260h]
[ebx+24h], ecx
ecx, [eax+264h]
[ebx+28h], ecx
ecx, [eax+268h]
[ebx+2Ch], ecx
ecx, [eax+26Ch]
[ebx+30h], ecx
ecx, [eax+270h]
[ebx+34h], ecx
ecx, [eax+274h]
[ebx+38h], ecx
ecx, [eax+278h]
[ebx+3Ch], ecx
ecx, [eax+27Ch]
[ebx+40h], ecx
ecx, [eax+280h]

USENIX Association  

23rd USENIX Security Symposium  431

15

26 mov
27 mov
28 mov
29 mov
30 mov
31 mov
32 mov
33 mov
34 mov
35 mov
36 mov
37 mov
38 mov
39 mov
40 mov
41 mov
42 mov
43 mov
44 pop
45 mov
46 pop
47 mov
48 pop
49 pop
50 retn

[ebx+44h], ecx
ecx, [eax+284h]
[ebx+48h], ecx
ecx, [eax+288h]
[ebx+4Ch], ecx
ecx, [eax+28Ch]
[ebx+50h], ecx
ecx, [eax+290h]
[ebx+54h], ecx
ecx, [eax+2CCh]
[ebx+58h], ecx
ecx, [eax+2D0h]
[ebx+5Ch], ecx
ecx, [eax+2D4h]
[ebx+60h], ecx
ecx, [eax+2D8h]
[ebx+64h], ecx
eax, [eax+2DCh]
edi
[ebx+68h], eax
esi
eax, ebx
ebx
ebp
8

Listing 11: This is a long Heuristic Breaker gadget.
It will also prepare the ebp and ebx registers which
are required by the VirtualProtect calling function (see
Listing 12).

; library: ieframe.dll
; offset:
; type:

1 and
2 lea
3 push
4 push
5 push
6 mov
7 push
8 call

0x0006FBAE
CS
dword ptr [ebp-0Ch], 0
eax, [ebp-0Ch]
eax
40h
ebx
ebx, [ebp-8]
ebx
ds:VirtualProtect

; address

; old protection
; new protection
; size

14h

18 retn
Listing 13: Gadget that makes program code writeable,
whereto inject a shellcode later. The part after the
call instruction is considered as a separate gadget
as it is the target of an indirect branch (i.e., return
instruction of the VirtualProtect function)

; library: mshtml.dll
0x000DA72B
; offset:
; type:
CS
eax, [ebp+10h]
[ebx+108h], esi
esi, [ebp+8]
edi, [ebx+110h]

1 mov
2 mov
3 mov
4 lea
5 movsd

...
9 mov

esi, [ebp+0Ch]
0Dh
ecx
edi, [ebx+120h]

[ebx+154h], eax
eax, [ebp+1Ch] !!
ecx, [eax]
0Dh
[ebx+0C0h], ecx
ecx
esi, [eax+18h]
edi, [ebx+0C4h]

10 push
11 pop
12 lea
13 rep movsd
14 mov
15 mov
16 mov
17 push
18 mov
19 pop
20 lea
21 lea
22 rep movsd
23 mov
24 pop
25 pop
26 mov
27 pop
28 pop
29 retn
Listing 14: Another Heuristic Breaker gadget and at the
same time it will prepare eax for the memcpy calling
gadget.

eax, [eax+4Ch]
edi
esi
[ebx+0F8h], eax
ebx
ebp
18h

0x001ADCC2
CS
eax
memcpy

; library: ieframe.dll
; offset:
; type:
1 push
2 call
Listing 15: Gadget for calling of memcpy for copying
the shellcode to existing program code.

; destination

0x001ADCC8
CS

; library: ieframe.dll
; offset:
; type:
1 add
2 xor
3 jmp
4 pop
5 pop
6 pop
7 pop
8 retn
Listing 16: The call site part of the memcpy calling
gadget.

esp, 0Ch
eax, eax
short loc_7672DCE7
ebx
edi
esi
ebp
8

Listing 12: Gadget that makes program code writeable,
whereto inject a shellcode later. The part after the
call instruction is considered as a separate gadget
as it is the target of an indirect branch (i.e., return
instruction of the VirtualProtect function).

; library: ieframe.dll
; offset:
; type:
1 test
2 jz
3 mov
4 and
5 mov
6 mov
7 mov
8 mov
9 mov
10 mov
11 mov
12 mov
13 xor
14 pop
15 pop
16 pop
17 leave

0x0006FBC3
CS
eax, eax
loc_766E9531 ; if eax==0: handle error
eax, [ebp+8]
dword ptr [edi+4], 0
[edi+8], eax
[edi+10h], esi
[edi+0Ch], ebx
eax, [ebp-0Ch]
[edi+14h], eax
eax, dword_768E2CCC
[edi], eax
dword_768E2CCC, edi
eax, eax
edi
ebx
esi

; == mov esp, ebp and pop ebp

16

432  23rd USENIX Security Symposium 

USENIX Association

