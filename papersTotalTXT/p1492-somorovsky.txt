Systematic Fuzzing and Testing of TLS Libraries

Juraj Somorovsky

Horst Görtz Institute for IT Security

Ruhr University Bochum

Hackmanit GmbH

juraj.somorovsky@rub.de

Abstract
We present TLS-Attacker, an open source framework for
evaluating the security of TLS libraries. TLS-Attacker al-
lows security engineers to create custom TLS message ﬂows
and arbitrarily modify message contents using a simple in-
terface in order to test the behavior of their libraries.

Based on TLS-Attacker, we present a two-stage fuzzing
approach to evaluate TLS server behavior. Our approach
automatically searches for cryptographic failures and bound-
ary violation vulnerabilities. It allowed us to ﬁnd unusual
padding oracle vulnerabilities and overﬂows/overreads in
widely used TLS libraries, including OpenSSL, Botan, and
MatrixSSL.

Our ﬁndings motivate developers to create comprehensive
test suites, including positive as well as negative tests, for the
evaluation of TLS libraries. We use TLS-Attacker to create
such a test suite framework which ﬁnds further problems in
Botan.

1.

INTRODUCTION

Transport Layer Security (TLS) [27] is used to secure the
connection to websites, Web services, or to create Virtual
Private Networks (VPNs) and connect LANs from diﬀerent
locations. Diﬀerent application scenarios and protocol ex-
tensions quickly raised the complexity of this standard. Its
complexity led to various designs as well as implementation
failures in various attack scenarios.
In the last few years,
we saw attacks targeting improper encryption algorithms
and conﬁgurations [12, 13, 44], complex state machines [17,
25, 39], extension speciﬁcations [19, 47], or attacks target-
ing implementation failures with buﬀer overﬂows and over-
reads [49].

The large number of recent attacks has motivated re-
searchers to provide further security analyses of TLS and
to develop novel security evaluation tools. In recent scien-
tiﬁc studies authors have considered the proper evaluation
of TLS state machines [25, 17], and they have also developed
tools for sending protocol messages in an arbitrary order [25]

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’16, October 24 - 28, 2016, Vienna, Austria
c(cid:13) 2016 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ISBN 978-1-4503-4139-4/16/10. . . $15.00
DOI: http://dx.doi.org/10.1145/2976749.2978411

and even tools for modifying speciﬁc message ﬁelds [17].
The message ﬁeld modiﬁcations provided by these tools are
rather static, i.e., a developer only has the ability to ex-
plicitly deﬁne values of speciﬁc message ﬁelds; however, he
cannot execute dynamic ﬁeld modiﬁcations given precom-
puted values in TLS message ﬂows, which is very important
for dynamic fuzzing. In view of the shortcomings of previous
approaches, and with intentions for extending the test cov-
erage of existing TLS libraries, it was necessary to develop a
new TLS testing framework – TLS-Attacker. TLS-Attacker
is able to create arbitrary TLS protocol ﬂows and execute
dynamic modiﬁcations in TLS messages based on precom-
puted values.

Impact and applicability. Our approach allowed us to
ﬁnd new vulnerabilities in widely used TLS libraries. These
include padding oracle vulnerabilities in OpenSSL [8], Ma-
trixSSL [6] and Botan [1], or boundary violations in Botan
and the ﬁrst pre-release of OpenSSL-1.1.0. Furthermore,
with this approach we exposed the fact that GnuTLS [10]
does not verify speciﬁc message variables but instead silently
proceeds the TLS handshake. The vulnerabilities have been
reported to the developers and ﬁxed in the newest versions.

TLS-Attacker and modiﬁable variables. Our frame-
work relies on a construct called modiﬁable variable. A mod-
iﬁable variable is a container for basic data types like integers
or byte arrays. By accessing these data types, the modiﬁable
variable can dynamically modify the content of the original
variable value. For example, it is possible to increase or de-
crease an integer value or to execute an XOR operation on
a given byte array. We use modiﬁable variables to construct
TLS messages and TLS records. This allows us to dynami-
cally modify any byte at any time in the TLS protocol ﬂow.
The main goal of TLS-Attacker is to provide an easy-to-
use framework with a simple user interface, allowing devel-
opers to create custom TLS protocol ﬂows in order to dis-
cover state machine attacks [25, 17] or test countermeasures
against cryptographic attacks [55, 23]. This is possible di-
rectly in Java, using the TLS-Attacker interface. Further-
more, it is even possible to deﬁne custom protocol ﬂows and
modiﬁcations using simple XML messages.

Two-stage fuzzing approach. To prove the practica-
bility of TLS-Attacker, we use it to construct a two-stage
fuzzing approach. In the ﬁrst stage, we introduce crypto-
graphic fuzzing for known vulnerabilities like padding ora-
cle attacks [55] or Bleichenbacher attacks [23]. In the second
stage, we then systematically modify protocol message vari-

1492ables and protocol ﬂows to trigger speciﬁc implementation
bugs or buﬀer boundary violations.

TLS test suite. The padding oracle vulnerability we dis-
covered in OpenSSL [9] (CVE-2016-2107) was introduced by
writing a constant-time patch that should have mitigated
the Lucky 13 attack [13]. Unfortunately, a missing length
check for suﬃcient HMAC length turned the OpenSSL server
from a rather complex timing oracle to a direct padding or-
acle since the server responded with a diﬀerent TLS alert.
This issue went unnoticed for nearly three years even though
OpenSSL became the primary TLS target library of the se-
curity research community. We observed a similar problem
in the MatrixSSL library. The impact of the insuﬃcient
padding check, however, was worse than in OpenSSL; the
developers introduced a buﬀer overﬂow vulnerability by at-
tempting to patch the Lucky 13 attack.

These two cases clearly show that writing and maintain-
ing critical cryptographic libraries is of huge importance.
New security critical functionalities must be validated with
proper test suites. These test suites should not only include
positive tests, they must include negative tests verifying cor-
rect library behavior when sending invalid messages or in-
correctly formatted data.

We use TLS-Attacker to create a test suite concept for val-
idating TLS libraries. With our concept, the developers can
create valid and invalid TLS message ﬂows containing arbi-
trary messages. The TLS responses can be validated with
predeﬁned assertions which check for the correct message
contents. For example, it is possible to validate the correct-
ness of TLS alert message types or proper cryptographic
properties. The ﬁrst test cases in our test suite already
showed insuﬃciencies in the Botan cipher suite support.

Contributions. This work makes the following contribu-
tions:

• TLS-Attacker: We provide a novel framework for the
evaluation of TLS libraries, which can be used by secu-
rity researchers or developers. The code is on GitHub:
https://github.com/RUB-NDS/TLS-Attacker.

• Novel fuzzing approach for TLS: Based on TLS-
Attacker, we implement a two-stage fuzzing approach
for the evaluation of TLS servers. Our approach al-
lows us to ﬁnd diﬀerent vulnerabilities in widely used
libraries.

• Modiﬁable variables: We present a concept of mod-
iﬁable variables which provide a high ﬂexibility for the
implementation of arbitrary cryptographic protocols
beyond TLS.

• TLS test suite: We also create a concept for testing
TLS libraries which is easily extensible with positive
and negative tests.

In our work we do not attempt to claim TLS-Attacker is
complete or that it detects every vulnerability. Our ﬁndings,
however, show that such a tool is necessary for the devel-
opment of secure TLS libraries. TLS-Attacker is currently
being integrated into Botan and MatrixSSL test suites.

2. TRANSPORT LAYER SECURITY

In the TCP/IP reference model, the TLS protocol is lo-
cated between the transport layer and the application layer.

Figure 1: TLS protocol. After performing a TLS
handshake, the peers can communicate securely and
exchange Application or Heartbeat messages.

Its main purpose is to protect application protocols like
HTTP or IMAP. The ﬁrst (unoﬃcial) version was devel-
oped in 1994 by Netscape, and was named Secure Sockets
Layer. In 1999, SSL version 3.1 was oﬃcially standardized
by the IETF Working Group and renamed Transport Layer
Security [26]. The current version is 1.2 [27]. Version 1.3
is currently under development [28].
In addition to TLS,
which acts over reliable TCP channels, the working group
standardized DTLS [48] (Datagram TLS), which works on
the top of UDP.

TLS is complex and allows communication peers to choose
from a large number of diﬀerent algorithms for various cryp-
tographic tasks (key agreement, authentication, encryption,
integrity protection). A cipher suite is a concrete selection of
algorithms for the required cryptographic tasks. For exam-
ple, TLS_RSA_WITH_AES_128_CBC_SHA deﬁnes RSA-PKCS#1
v1.5 public-key encryption in order to exchange a premaster
secret, and it also deﬁnes symmetric AES-CBC encryption
with a 128-bit key and SHA-1-based HMACs.
2.1 The Handshake Protocol

In order to establish a TLS connection between two peers
and exchange application data, a TLS handshake is executed
(cf. Figure 1). A TLS handshake is initiated by a TLS
client with a ClientHello message. This message contains
information about the TLS version and a list of supported
cipher suites. The server now responds with a ServerHello
message containing the selected cipher suite. Furthermore,
it sends its certiﬁcate in the Certificate message and in-
dicates the end of transmission with the ServerHelloDone
message. The client then sends a ClientKeyExchange mes-
sage, which contains an encrypted premaster secret. Based
on the premaster secret, all further connection keys are de-
rived. Finally, both parties send the ChangeCipherSpec and
Finished messages. The former notiﬁes the receiving peer
that subsequent TLS messages will use the newly negotiated
cipher suite. The Finished message contains an HMAC
computed over all the previous handshake messages based
on a key derived from the premaster secret. Thereby, both
peers are authenticated and can exchange application data
or Heartbeat messages [50].

Note that this is an example of a TLS handshake with an
RSA cipher suite. The speciﬁcation also supports (EC)DH

ClientClientServerServerClientHelloServerHello, Certificate, (ServerKeyExchange), ServerHelloDone(Certificate), ClientKeyExchange, (CertificateVerify), ChangeCipherSpec, FinishedChangeCipherSpec, FinishedApplicationData / HeartbeatApplicationData / Heartbeat1493Figure 2: When processing ﬁve plaintext bytes with
AES-CBC and HMAC-SHA, the encryptor needs
to append 20 bytes of the HMAC-SHA output and
seven bytes of padding.

cipher suites or usage of preshared keys. In addition, it is
possible for the client to authenticate with a certiﬁcate or to
use a session resumption to resume previous sessions. These
methods result in TLS handshakes with slightly diﬀerent
structures with additional protocol messages. For exam-
ple, if a client-authentication is used, the client additionally
sends Certificate and CertificateVerify messages.

The exchanged messages have strict structures. For ex-
ample, an RSA-based ClientKeyExchange message consists
of a handshake type identiﬁer (0x10), 3-byte long length in-
dication and an encrypted premaster secret.

Diﬀerent messages and ﬂows result in a complex protocol
making the design of TLS state machines and the proper
veriﬁcation of protocol message structures very challenging.

2.2 The Record Layer

The record layer is used to transmit protocol messages.
Basically, it wraps the protocol messages and adds the in-
formation about the TLS protocol version, message type,
and message length. The contents of the TLS records are
encrypted after ChangeCipherSpec messages are exchanged.
In order to encrypt TLS records, it is possible to use diﬀer-
ent cryptographic primitives. One of them is a MAC com-
bined with AES in CBC mode of operation.
It uses the
MAC-then-Pad-then-Encrypt mechanism [27]. This means
that the encryptor ﬁrst computes a MAC over the plain-
text, then it pads the message to achieve a multiple of block
length, and ﬁnally it uses AES-CBC to encrypt the cipher-
text. For example, if the encryptor attempts to encrypt ﬁve
bytes of data and uses HMAC-SHA (with 20 bytes long out-
put), we end up with two blocks. The second block needs to
be padded with seven bytes 0x06, see Figure 2. Note that
the encryptor can also choose a longer padding and append
23, 39, ...or 247 padding bytes.

For the description of our work, it is also crucial that one
record message can include one protocol message or several
messages at once. It is even possible to split one protocol
message into several records. This adds to the complexity
of the TLS standard.

2.3 TLS Extensions

Diﬀerent application scenarios and cryptographic usages
have resulted in deﬁnition of various extensions to the TLS
protocol. The extensions can add cryptographic abilities of
TLS peers (supported elliptic curves [22, 42]), deﬁne new
protocol messages (heartbeat [50]), or change the maximum
number of bytes transmitted in one TLS record (Maximum
Fragment Length [31]). Protocol extensions are negotiated
in the ClientHello and ServerHello messages and their
correct processing is also crucial for securing a TLS protocol
execution.

2.4 TLS Libraries

There are several widely used libraries supporting TLS,
ranging from open source libraries like OpenSSL to closed
source libraries like Microsoft’s SChannel (Secure Channel).
In this paper, we analyze the following TLS server imple-
mentations: Botan [1], GnuTLS [10], Java Secure Socket Ex-
tension [5], MatrixSSL [6], mbedTLS [7], and OpenSSL [8].

3. ATTACK CATEGORIZATION

Recent years have shown that despite the wide usage of
TLS, TLS libraries suﬀer from severe security vulnerabili-
ties. In this section we concentrate on the description of the
attacks relevant to our paper since they are necessary to de-
scribe our ﬁndings. Further attacks and their categorization
can be found in [43, 51].

We have organized the relevant attacks into three basic

categories.
3.1 Cryptographic Attacks

Padding oracle attacks. One of the main design failures
in SSLv3 and TLS is the speciﬁcation of the MAC-then-
Pad-then-Encrypt scheme in CBC cipher suites.
In 2002
Vaudenay showed that this scheme makes security protocols
potentially vulnerable to padding oracle attacks [55]. These
attacks are based on the malleability of the CBC mode of
operation. CBC allows an attacker to ﬂip speciﬁc bits in
the plaintext without knowing the secret key.
If a server
allows the attacker to distinguish between valid and invalid
padding bytes (e.g., by sending diﬀerent error messages), the
attacker can decrypt the message as follows. He starts with
decrypting the last message byte. To this end, he iteratively
ﬂips bits in this byte and sends the message to the server.
Once he receives a valid padding response, he knows he has
correctly guessed the 0x00 byte. This allows him to decrypt
the last plaintext byte. Afterwards, he can proceed with
further padding bytes and decrypt the whole message [55].
In order to mitigate this attack, the implementation must
not allow an attacker to distinguish valid from invalid padding
structures in the decrypted messages. In 2013 AlFardan and
Paterson presented the Lucky 13 attack [13] and showed
that implementing countermeasures against padding oracle
attacks in TLS is very challenging. Lucky 13 exploits a tim-
ing side-channel arising from the countermeasures described
in the TLS recommendation [27].

TLS implementations attempt to implement various coun-
termeasures to make padding oracle attacks impossible. How-
ever, recent evaluations and scientiﬁc studies show that TLS
implementations still contain insuﬃcient padding veriﬁca-
tions [24, 41] or are vulnerable to variants of the Lucky 13
attack [11, 35].

Bleichenbacher’s attack. One of the most important at-
tacks in TLS history is Bleichenbacher’s million message at-
tack [23]. The attack targets the RSA PKCS#1 v1.5 encryp-
tion scheme, which is used in the TLS protocol to encrypt
a shared secret between both TLS peers. Essentially, Ble-
ichenbacher’s attack is also a padding oracle attack. The
attack is based on the malleability of the RSA encryption
scheme and assumes the existence of an oracle that responds
with “valid” or “invalid” according to the PKCS#1 v1.5 va-
lidity of the decrypted message.

A server defending against this attack must not allow for

1494the distinction between valid and invalid ciphertexts. How-
ever, recent studies show insuﬃciencies in the application
of this countermeasure, in the Java TLS implementation
(JSSE) and the Cavium accelerator chips [44]. Further stud-
ies show how to improve eﬃciency of this attack or how to
apply it to diﬀerent protocols and standards [16, 15, 36].
3.2 State Machine Attacks

TLS is a complex protocol containing diﬀerent message
ﬂows. This results in complex state machine implementa-
tions which can contain severe security bugs. The ﬁrst rel-
evant security vulnerability was discovered in 2014 and was
named Early CCS, or CCS injection vulnerability [39]. This
vulnerability allows an attacker to inject an early Change-
CipherSpec message into the TLS handshake and force the
TLS peer to derive a shared key based on a null secret. If a
Man-in-the-Middle (MitM) attacker and both TLS peers use
vulnerable OpenSSL versions, the attacker can force both
peers to establish a connection using a null secret and thus
read the whole communication.

The Early CCS vulnerability prompted researchers to
search for state machine vulnerabilities. They found dif-
ferent unexpected state transitions in widely used TLS li-
braries [17, 25]. For example, the Java TLS implementa-
tion contained a serious vulnerability which allowed one to
ﬁnish the TLS handshake without ChangeCipherSpec mes-
sages. This resulted in a plaintext communication between
the client and the server.
3.3 Overﬂows and Overreads

The Heartbleed bug in OpenSSL [49] has shown cryptog-
raphy engineers how critical a simple buﬀer overread can
be. Heartbleed allowed an attacker to read random bytes
from a server’s memory, for example, private cryptographic
keys [53]. The reason was a buﬀer overread vulnerability
in the OpenSSL heartbeat processing implementation.
It
forced major servers to renew their private keys and certiﬁ-
cates.

In the recent years, additional problems in various TLS
libraries like buﬀer overﬂows or integer overﬂows have ap-
peared [29, 9, 2]. These buﬀer boundary violations moti-
vated us to execute further security evaluations of TLS im-
plementations.

4. REQUIREMENTS AND RELATED WORK

The recent development in the area of TLS and the high
number of memory and state machine attacks motivated us
to construct an enhanced evaluation of TLS implementa-
tions. In the following section we ﬁrst describe requirements
for a ﬂexible TLS library. We analyze diﬀerent approaches
to achieve these requirements, discussing their advantages
and disadvantages.
4.1 Requirements for a Flexible TLS Testing

Framework

Given the recent TLS attacks, we can summarize the fol-

lowing requirements for a new, ﬂexible analysis tool.

Flexible stateless TLS handshake execution. Flexible
protocol execution is necessary for state machine validations
as well as for diﬀerent fuzzing strategies. It is important that
the framework does not derive the current state from the
exchanged protocol messages. The security developer has to

be able to set the protocol execution state at an arbitrary
point of time, after an arbitrary number of messages have
been exchanged. For example, he is able to deﬁne speciﬁc
state transitions, or the exact point when the messages will
be encrypted.

Flexible modiﬁcation of arbitrary TLS variables. The
security developer has to be able to execute arbitrary mod-
iﬁcations to TLS variables. This includes various variables
used in the TLS protocol ﬂow, for example, length variables
indicating the length of TLS messages and extensions, as
well as speciﬁc cryptographic keys and secrets.
It is not
only necessary to simply set these variables, but the secu-
rity developer has to perform variable modiﬁcations at run-
time. For example, by evaluating the POODLE vulnerabil-
ity [45] in a TLS server library, a security engineer analyzes
whether a correct padding validation has been implemented.
For this purpose, he needs to execute modiﬁcations in spe-
ciﬁc plaintext bytes before the message gets encrypted in
the record layer. More precisely, if the plaintext message
consists of data||M AC||pad (data concatenated with MAC
and padding), the security developer is only interested in the
modiﬁcation of speciﬁc padding bytes (e.g., he wants to ap-
ply an XOR operation on the ﬁrst padding byte). The rest
of the plaintext message has to stay untouched, otherwise a
MAC failure can be triggered.

Systematic fuzzing of message variables. In order to
trigger speciﬁc vulnerabilities, the TLS testing framework
has to provide a list of variables given in the TLS protocol
and be able to systematically modify these variables.

Easy to use interface. The TLS testing framework has
to provide a simple interface to create new protocol ﬂows
and modiﬁcations. The security developer has to be able
to deﬁne new protocol sets or protocol fuzzings and execute
them automatically with the tested TLS library.

Detection of crashes and invalid protocol ﬂows. The
TLS testing framework has to provide an ability in order
to detect TLS server crashes or invalid protocol ﬂows. If a
failure is detected, the protocol ﬂow has to be recorded and
the developer has to be able to execute the same protocol
ﬂow to re-analyze the discovered issue (e.g., after triggering
a buﬀer overﬂow).
4.2 Approaches and Related Work

The ﬁrst trivial approach is to patch an existing TLS li-
brary. However, patching every variable in the TLS protocol
ﬂow could be complicated. The code would need to be modi-
ﬁed at diﬀerent places, nested in several function levels. This
would result in a huge overhead, especially when considering
the complex code of open source libraries like OpenSSL.

Another possible approach is to use a TLS library and
control its ﬂow using a debugging interface. For example,
the Java Platform Debugger Architecture (JPDA) [4] pro-
vides a programming interface that allows a developer to
create software agents which can monitor and control Java
applications. The developer could use the JSSE library and
write a fuzzing extension within a Java agent. The agent
would modify only the needed variables directly during TLS
protocol ﬂow. This would allow one to execute correct TLS
message ﬂows and modify only speciﬁc variables. This ap-
proach, however, has a signiﬁcant drawback. TLS libraries
are constructed to execute correct TLS protocol ﬂows. In

1495order to trigger the Early CCS vulnerability or other state
machine attacks, an invalid TLS protocol ﬂow has to be
constructed.

A possible approach to execute fuzzing attacks is to take
a fuzzing framework (e.g., Peach Fuzzer1 or American Fuzzy
Lop2) and initialize it with an intercepted TLS protocol ﬂow.
The fuzzer generates its messages based on the given proto-
col messages and sends them to the server. This approach
could be applied to several plaintext messages in the TLS
handshake. However, the TLS protocol ﬂow also contains
messages that are encrypted and authenticated using freshly
generated keys. For example, in order to send a Heartbeat
message, the complete TLS handshake must be executed
ﬁrst [50].3

De Ruiter and Poll implemented a customized tool to eval-
uate TLS state machines [25]. Their tool, however, does
not allow one to modify custom protocol message variables.
Berdouche et al. designed a novel TLS tool – FLEXTLS [18].
FLEXTLS was previously used to develop many prominent
attacks (e.g., Triple Handshake [19]) and to discover state
machine attacks [17]. This tool allows one to construct new
protocol message ﬂows and set custom variable values. How-
ever, in FLEXTLS the variables can only be initialized with
explicit values. The tool is not intended to perform dynamic
variable modiﬁcations. This means that more diﬃcult mod-
iﬁcations of variables with XOR or ADD operations are not
supported. Furthermore, no TLS fuzzing is supported.

Very recently, two novel TLS testing frameworks have
been developed:
tlsfuzzer and Scapy-SSL/TLS [38, 46].
These TLS frameworks support stateless protocol executions
and variable modiﬁcations. They are useful for developing
new attacks and protocol modiﬁcations. Currently, they do
not contain any consistent fuzzing strategies, nor dynamic
variable modiﬁcations.

5. TLS-ATTACKER: DESIGN AND IMPLE-

MENTATION

The state-of-the-art of TLS evaluations motivated us to
develop a novel ﬂexible TLS framework. The main goal of
this framework is to oﬀer developers and security engineers
a simple and accessible approach to evaluate their TLS im-
plementations.

TLS-Attacker is implemented in Java with the support of

the Maven project management tool.4
5.1 Modiﬁable Variables

At the heart of our framework, we implement a construct
called ModifiableVariable. A ModifiableVariable is a
wrapper for simple data types like integers or byte arrays.
This wrapper contains the original value of a speciﬁc variable
and provides its value by a getter method. While accessing
the variable, the ModifiableVariable container is able to
apply predeﬁned modiﬁcations.

1http://peachfuzzer.com
2http://lcamtuf.coredump.cx/aﬂ
3We note that the Heartbleed bug could have been triggered
by sending an unencrypted Heartbeat message during the
TLS handshake since the vulnerable OpenSSL version incor-
rectly accepted the Heartbeat message before the Change-
CipherSpec message.
4https://maven.apache.org

A simpliﬁed example of this construct provided for integer

data types gives the following listing:
c l a s s M o d i f i a b l e I n t e g e r {

p u b l i c

p r i v a t e i n t o r i g V a l u e ;
p r i v a t e M o d i f i c a t i o n m o d i f i c a t i o n ;
p u b l i c i n t g e t V a l u e ( ) {

(mod != n u l l ) {
r e t u r n m o d i f i c a t i o n . modify ( o r i g V a l u e ) ;

i f
}
r e t u r n o r i g V a l u e ;

}

}

ModifiableInteger contains two variables: a wrapped
origValue and a modification. The origValue is used to
hold the original integer value computed during a program
execution. While accessing the variable over getValue(),
this method is able to execute speciﬁc modiﬁcations before
the original value is returned.

Usage of modiﬁable variables. The best way to present
the functionality of this concept is by means of a simple
example:

M o d i f i a b l e I n t e g e r
i . s e t O r i g i n a l V a l u e ( 3 0 ) ;
i . s e t M o d i f i c a t i o n ( new A d d M o d i f i c a t i o n ( 2 0 ) ) ;
System . ou t . p r i n t l n ( i . g e t V a l u e ( ) ) ;

i = new M o d i f i a b l e I n t e g e r ( ) ;

// 50

In this example, we deﬁne a new ModifiableInteger and
set its value to 30. Next, we deﬁne a new modiﬁcation –
AddModification – which simply returns a sum of two in-
tegers. We set its value to 20.
If we execute the above
program, the result 50 is printed. This is because by ac-
cessing the original integer value, its value gets increased by
20.

A similar concept is applied for all basic data types: in-
tegers, bytes, or byte arrays. ModifiableInteger contains,
for example, these modiﬁcations: add, explicitValue, xor,
shift, or subtract. Similar modiﬁcations are accessible to
other numeric types. ModifiableByteArray is a container
for byte arrays and contains, for example, the following mod-
iﬁcations: delete, insert, or xor. It is worth mentioning
that the modiﬁcations can be concatenated and executed
successively.

Modiﬁable variables in protocol messages. All rele-
vant protocol messages and record data are stored in modiﬁ-
able variables. An example is shown in the following
ClientHello protocol message:

p u b l i c

c l a s s C l i e n t H e l l o M e s s a g e {

M o d i f i a b l e I n t e g e r c o m p r e s s i o n L e n g t h ;
M o d i f i a b l e B y t e A r r a y c o m p r e s s i o n s ;
M o d i f i a b l e I n t e g e r c i p h e r S u i t e L e n g t h ;
M o d i f i a b l e B y t e A r r a y c i p h e r S u i t e s ;
. . .

}

The ClientHello message is used in the TLS protocol ﬂow
and the variable values are computed dynamically. Before
executing the protocol ﬂow, the modiﬁable variables allow
us to set arbitrary variable modiﬁcations or to deﬁne ex-
plicit variable values. The variables are then dynamically
modiﬁed during the protocol execution. For example, the
developer can use 2 cipher suites and set the explicit value
of cipherSuitesLength to 5. TLS-Attacker then uses an
invalid length value while serializing the ClientHello mes-
sage, which could possibly trigger an overﬂow.

14965.2 High-Level Overview

TLS-Attacker is divided into several Maven modules
(cf. Figure 3). The concept of modiﬁable variables is lo-
cated in a separate ModifiableVariable module so that
further applications can proﬁt from its functionality. The
Transport module contains transport handling utilities for
TCP and UDP. The core module is TLS, which contains a
TLS protocol implementation. This is divided into further
packages. The protocol package contains protocol messages
and their handlers. The workflow package contains a ﬂexi-
ble protocol ﬂow implementation which allows one to deﬁne
arbitrary message order. Further relevant packages are de-
picted in Figure 3. The Attacks and Fuzzer modules are
based on the TLS functionalities and deﬁne several TLS at-
tacks and fuzzing techniques. The TestSuite module deﬁnes
an extensible TLS test suite.

TLS-Attacker currently implements the TLS 1.0, 1.1, 1.2
and DTLS 1.2 protocol versions and the client-side func-
tionality, including client-side authentication. Furthermore,
it implements these features:

• Key exchange algorithms: RSA, ECDH(E), DH(E)
• Encryption algorithms: AES-CBC, 3DES-CBC
• Extensions: EC, EC point format [22], Heartbeat [50],
Maximum fragment length [31], Server name indica-
tion [31], Signature and hash algorithms

This allows us to cover the majority of the relevant TLS
attacks. Further features are in development.
5.3 The TLS Module

TLS is the core module of TLS-Attacker. It implements
the complete TLS functionality, using modiﬁable variables
and the transport handlers from the Transport module. It
solely relies on the cryptographic functionality provided by
the standard Java cryptographic providers and the Bouncy
Castle library (version 1.54).

The TLS module is divided into several packages. The
config package contains classes for TLS protocol conﬁgu-
ration. TLS constants (cipher suites, key exchange algo-
rithms, alerts) are deﬁned in the constants package. The
crypto package contains TLS speciﬁc cryptographic func-
tionalities which extend the basic behavior of Java crypto-
graphic providers.

The protocol package implements the TLS protocol mes-
sages and their handlers. Each protocol message is deﬁned
by a handler (responsible for message processing) and a mes-
sage state (representing the current state of the TLS mes-
sage). For example, the handshake package contains the
HandshakeMessageHandler and HandshakeMessage classes
(see Figure 3). The abstract HandshakeMessage class con-
tains general handshake variables used by all handshake
messages, e.g., the handshake message type. ClientHel-
loMessage extends HandshakeMessage and includes Clien-
tHello speciﬁc variables like an array of cipher suites or the
cipher suite length. Note that all these variables are modiﬁ-
able to achieve high ﬂexibility. Processing of handshake mes-
sages is provided by the HandshakeMessageHandler classes.
Each handler implements two functions: prepareMessage
used while sending TLS message and parseMessage used
while parsing incoming messages.

A similar concept of handlers and messages is implemented
for the TLS record handling deﬁned in the record package.

The workflow package contains TLS protocol executors.
The TLS protocol execution solely depends on the deﬁned
TLS messages. A TLS executor takes a list of protocol
messages as an input, searches for proper message handlers,
and lets them process the deﬁned messages. This approach
presents two notable advantages:

1. It makes it very convenient for a TLS-Attacker user to
deﬁne custom TLS protocol ﬂows with arbitrary mes-
sage ordering just by setting speciﬁc TLS messages.

2. The processed TLS protocol ﬂows can be stored for

further analysis or even for a repeatable execution.

5.4 Using TLS-Attacker Interfaces

In the following section we present how TLS-Attacker in-
terfaces can be used to construct a custom protocol message
ﬂow detecting vulnerability to Bleichenbacher’s attack. We
chose this attack as an example since it requires a deep in-
tervention in the TLS protocol functionality, including mod-
iﬁcation of the plain padded premaster secret.
Detecting Bleichenbacher’s oracle with ≈ 10 lines of
code. The design of TLS-Attacker supports simple deﬁni-
tions of new attacks. The following example shows a custom
protocol ﬂow by explicitly setting the plaintext value of a
padded premaster secret. This code can be used to evaluate
the correctness of countermeasures against Bleichenbacher’s
attack [23].

T l s C o n t e x t c o n t e x t = i n i t i a l i z e T l s C o n t e x t ( c o n f i g ) ;
WorkflowExecutor e x e c u t o r =

i n i t i a l i z e W o r k f l o w E x e c u t o r ( c o n t e x t ) ;

// S e t t i n g e x p l i c i t m o d i f i c a t i o n o f

t h e p r e m a s t e r

s e c r e t

RSAClientKeyExchangeMessage r s a = new

RSAClientKeyExchangeMessage ( ) ;

M o d i f i a b l e V a r i a b l e <b y t e [ ] > pms = new

M o d i f i a b l e V a r i a b l e <>() ;

pms . s e t M o d i f i c a t i o n ( new E x p l i c i t V a l u e M o d i f i c a t i o n (

VALUE ) ) ;

r s a . s e t P l a i n P a d d e d P r e m a s t e r S e c r e t ( pms ) ;

// C o n s t r u c t i n g p r o t o c o l message f l o w
L i s t <P r o t o c o l M e s s a g e > m = c o n t e x t .

g e t P r o t o c o l M e s s a g e s ( ) ;

m. add ( new C l i e n t H e l l o M e s s a g e ( ) ) ;
m. add ( new S e r v e r H e l l o M e s s a g e ( ) ) ;
m. add ( new C e r t i f i c a t e M e s s a g e ( ) ) ;
m. add ( new S e r v e r H e l l o D o n e M e s s a g e ( ) ) ;
m. add ( r s a ) ;
m. add ( new ChangeCipherSpecMessage ( ConnectionEnd .

CLIENT) ) ;

m. add ( new F i n i s h e d M e s s a g e ( ConnectionEnd . CLIENT) ) ;
m. add ( new A l e r t ( ConnectionEnd .SERVER) ) ;

// P r o t o c o l e x e c u t i o n
e x e c u t o r . e x e c u t eW o r k f l o w ( ) ;

By setting a custom premaster secret, the security en-
gineer enforces TLS-Attacker to execute a TLS handshake
with this custom value. The execution of TLS handshakes
with diﬀerent premaster secret values can trigger diﬀerent
server behaviors and thus reveal an oracle which can be used
to perform Bleichenbacher’s attack.

Note that constructing such a protocol ﬂow with a com-
mon TLS library would need a deep knowledge of the library.
On the other hand, with TLS-Attacker, security engineers
can easily use the TLS-Attacker interfaces to deﬁne new pro-
tocol ﬂows with speciﬁc message modiﬁcations and embed
them into their test suites.

1497Figure 3: TLS-Attacker is divided into several Maven modules. The core module is TLS implementing the
protocol functionality and ﬂexible protocol execution. All protocol messages use modiﬁable variables.

Not only for Java developers. Convenient XML se-
rialization.
It is not necessary to develop Java in order
to construct arbitrary protocol ﬂows with custom modiﬁca-
tions. Instead, we decided to use JAXB (Java Architecture
for XML Binding) [3] for serialization and deserialization of
TLS protocol ﬂows. This allows a developer to deﬁne the
same protocol ﬂow as above using a simple XML document:

<w o r k f l o w T r a c e>

<p r o t o c o l M e s s a g e s>

<C l i e n t H e l l o>

<m e s s a g e I s s u e r>CLIENT</ m e s s a g e I s s u e r>
<s u p p o r t e d C o m p r e s s i o nM e t h o d s>

<CompressionMethod>NULL</ CompressionMethod>

</ s u p p o r t e d C o m p r e s s i o n M e t h o d s>
<s u p p o r t e d C i p h e r S u i t e s>

<C i p h e r S u i t e>TLS RSA WITH AES 128 CBC SHA</

C i p h e r S u i t e>

<C i p h e r S u i t e>TLS RSA WITH 3DES EDE CBC SHA</

C i p h e r S u i t e>

. . .

</ s u p p o r t e d C i p h e r S u i t e s>

</ C l i e n t H e l l o>
<S e r v e r H e l l o>

<m e s s a g e I s s u e r>SERVER</ m e s s a g e I s s u e r>

</ S e r v e r H e l l o>
< C e r t i f i c a t e>

<m e s s a g e I s s u e r>SERVER</ m e s s a g e I s s u e r>

</ C e r t i f i c a t e>
<S e r v e r H e l l o D o n e>

<m e s s a g e I s s u e r>SERVER</ m e s s a g e I s s u e r>

</ S e r v e r H e l l o D o n e>
<RSAClientKeyExchange>

<m e s s a g e I s s u e r>CLIENT</ m e s s a g e I s s u e r>
<p l a i n P a d d e d P r e m a s t e r S e c r e t>

<b y t e A r r a y E x p l i c i t V a l u e M o d i f i c a t i o n>

<e x p l i c i t V a l u e>

00 02 8B 2B FC 66 ED 21

07 9A F8 5F 92 8E 34 38

. . . .

81 51 B5 91 E6 B3 1D F8 BB 98 48 31 8F 73 A2 CE
60 0A 31 CC 34 D7 0D 42 F6 3F D1 59 20 53 71 5E

</ e x p l i c i t V a l u e>

</ b y t e A r r a y E x p l i c i t V a l u e M o d i f i c a t i o n>

</ p l a i n P a d d e d P r e m a s t e r S e c r e t>

</ RSAClientKeyExchange>
<ChangeCipherSpec>

<m e s s a g e I s s u e r>CLIENT</ m e s s a g e I s s u e r>

</ ChangeCipherSpec>
<F i n i s h e d>

<m e s s a g e I s s u e r>CLIENT</ m e s s a g e I s s u e r>

</ F i n i s h e d>
<A l e r t>

<m e s s a g e I s s u e r>SERVER</ m e s s a g e I s s u e r>

</ A l e r t>

</ p r o t o c o l M e s s a g e s>

</ w o r k f l o w T r a c e>

6. FUZZING WITH TLS-ATTACKER

TLS-Attacker provides a suitable framework for perform-
ing fuzzing attacks. Based on our observations about the
previous TLS attacks and vulnerabilities, we designed an
extensible approach for performing a systematic evaluation
of TLS libraries. Our approach is divided into two stages,
see Figure 4.

In the following sections we ﬁrst describe the basics behind
our fuzzing strategies and vulnerability detection, and then
we describe both fuzzing stages.
6.1 Fuzzing Strategies

We employed several fuzzing strategies from the mutators
used in Peach Fuzzer5 and American Fuzzy Lop,6 which are
relevant for TLS fuzzing. We implemented these strategies
using our modiﬁable variables.

5http://community.peachfuzzer.com/v3/Mutators.html
6http://lcamtuf.coredump.cx/aﬂ/technical details.txt

 ClientHelloHandler prepareMessage() parseMessage() ClientHelloMessage cipherSuites: ModifiableByteArray cipherSuiteLength: ModifiableInteger  ... getCipherSuites() setCipherSuites() ...TLS AttackerTLS AttackerModifiableVariableAttacksTLSTransportFuzzerModulesPackagesconfigconstantscryptoprotocolrecordworkflowalertapplicationheartbeathandshakeTestSuite HandshakeMessage type: ModifiableByte  ... getType() ... HandshakeMessageHandler prepareMessage() parseMessage() ClientHelloMessage cipherSuites: ModifiableByteArray cipherSuiteLength: ModifiableInteger  ... getCipherSuites() setCipherSuites() ... ClientHelloMessage cipherSuites: ModifiableByteArray cipherSuiteLength: ModifiableInteger  ... getCipherSuites() setCipherSuites() ... ClientHelloHandler prepareMessage() parseMessage() ClientHelloHandler prepareMessage() parseMessage()1498above cases is detected, TLS-Attacker stores the protocol
ﬂow in an XML ﬁle. This ﬁle can later be used for further
analysis.

6.3 Two-Stage Fuzzing

Cryptographic Attacks.

In the ﬁrst stage, we investigate the cryptographic be-
havior of the analyzed TLS server. We attempt to trigger
diﬀerent error messages by sending invalid padding bytes or
forcing the server to accept invalid elliptic curve points [21,
37]. TLS-Attacker can dynamically collect the server re-
sponses and store them for further analysis.

Currently, TLS-Attacker implements checks for Bleichen-
bacher’s attack [23], padding oracle attacks [55], invalid curve
attacks [37], and POODLE [45].

Fuzzing for Buffer Boundary Violations.

TLS-Attacker allows one to execute random variable mod-
iﬁcations or to construct invalid messages. We use these
features in the second stage where we attempt to trigger an
invalid server behavior and ﬁnd buﬀer boundary violations.
This stage is divided into three phases.

The starting point for each phase is a set of known TLS
protocol ﬂows. This includes correct TLS protocol ﬂows as
depicted in Figure 1, as well as several invalid TLS protocol
ﬂows identiﬁed in the previous years [39, 17, 25]. At the
beginning of the fuzzing process, TLS-Attacker attempts to
execute these protocol ﬂows and stores correctly executed,
complete protocol ﬂows for further executions in the next
phases. These are described below.

Phase 1: Searching for “inﬂuencing variables”. A
TLS protocol ﬂow and its messages contain a huge amount
of variables: message length values, derived keys, or cer-
tiﬁcates. Not all of these variables are suitable for fuzzing.
For example, it is not necessary to fuzz random values (e.g.,
client random) or variables which are not validated. There-
fore, our framework allows one to use an explicit blacklist
of variables that should be omitted during the fuzzing pro-
cess. In addition, in the ﬁrst phase, TLS-Attacker iteratively
changes all variables from the TLS protocol ﬂow and ana-
lyzes whether those variables inﬂuence the correct protocol
ﬂow.

For example, we found that some TLS libraries do not
validate speciﬁc length variables at all. See the following
section.

Phase 2: Fuzzing with variable modiﬁcations. In the
second phase, we continue only with the variables from the
ﬁrst phase that were identiﬁed as inﬂuencing the TLS proto-
col ﬂow. We execute correct protocol ﬂows with randomly
modiﬁed variables.
In this phase, more variables can be
modiﬁed at once or the modiﬁcations can be chained.

As discussed in Section 2.2, a TLS record can contain one
protocol message, several protocol messages (this is the de-
fault behavior of TLS-Attacker), or even one protocol mes-
sage can be sent in several records. The distribution of pro-
tocol messages in a diﬀerent number of records could po-
tentially trigger an invalid server behavior. Therefore, in
addition to the variable modiﬁcations, in this phase we at-
tempt to split protocol messages into diﬀerent numbers of
TLS records with randomly chosen record lengths.

Figure 4: Fuzzing with TLS-Attacker is divided
into two stages; ﬁrst various cryptographic attacks
are executed, then a systematic protocol fuzzing is
started.

For example, TLS-Attacker generates the following mod-
iﬁcations during fuzzing with integers. The original integer
value can be XORed with random bits, shifted left or right,
and increased or decreased by a random value. In addition,
speciﬁc values can be returned based on a dictionary consist-
ing of a zero value and values causing overﬂows in speciﬁc
number representations. Similar strategies are employed by
modiﬁcation of further numeric data types.

Byte arrays are modiﬁed by applying additional strategies.
TLS-Attacker automatically generates modiﬁcations which
duplicate arrays, remove or insert speciﬁc bytes, or shuﬄe
the given byte array. The dictionary with explicit values
contains an empty array or arrays consisting of 0x00 and
0xFF values.

Note that the design of modiﬁable variables allows TLS-

Attacker to chain generated modiﬁcations as well.
6.2 Vulnerability Detection

In order to detect buﬀer boundary violations, integer over-
ﬂows, or other memory corruptions [34, 33], the runtime
behavior of the TLS library has to be observed. For this
purpose, we use AddressSanitizer (ASan).7 ASan is a mem-
ory error detector which can be enabled at compile time in
recent versions of LLVM or GCC compilers. It is typically
used while fuzzing C and C++ applications. If a fuzzer ﬁnds
a memory error in an application compiled with ASan, the
application crashes, prints an error message, and exits with
a non-zero code.

We use Asan to compile C and C++ TLS libraries before
we start TLS-Attacker fuzzing. If a memory error or a dif-
ferent bug in a TLS server compiled with ASan is triggered,
the server crashes and outputs an error message describing
the cause of the detected boundary violation.

ASan is of course not suitable for TLS applications devel-
oped in diﬀerent languages, like Java. For anomaly detection
in Java servers and other servers which cannot be compiled
with ASan, we analyze the protocol ﬂows with a TLS context
analyzer. The TLS context analyzer investigates whether a
TLS protocol ﬂow has been executed correctly, contains an
invalid protocol ﬂow with an additional protocol message,
or whether a message in a valid protocol ﬂow is modiﬁed by
a speciﬁc modiﬁcation.

In case a runtime error or an invalid protocol ﬂow in the

7http://clang.llvm.org/docs/AddressSanitizer.html

Stage 2: FuzzingStage 2: FuzzingStage 1: Crypto- Bleichenbacher Attack- Padding Oracle Attack- POODLE- Invalid Curve Attack- ...Stage 1: Crypto- Bleichenbacher Attack- Padding Oracle Attack- POODLE- Invalid Curve Attack- ... Phase 1:  Variable Detection Phase 2:  Random Variable Fuzzing  Record modification Phase 3:  Random Protocol Flow  Random Variable Fuzzing  Record modification1499Phase 3: Fuzzing with random protocol ﬂows.
In
the last phase, we continue the fuzzing process with addi-
tional randomized protocol ﬂows. For this purpose, we add
or remove random protocol messages from the conﬁgured
protocol sequences.
7. TLS FUZZING EVALUATION

The number of fuzzing attempts in Stage 2 can be con-
ﬁgured by the developer. Depending on the performance of
the tested library, the number of TLS protocol ﬂows and the
resulting duration varies. For example, for OpenSSL-1.1.0-
pre3, we were able to execute 166,000 ﬂows in one hour,
resulting in about 46 protocol ﬂows per second. The tests
were executed on a laptop with an Intel Core i7 5600U CPU.
Note that it is not our intention to fully analyze the im-
pact of the detected vulnerabilities or describe complete at-
tacks. Our contribution is to prove the practicability of our
fuzzing approach by ﬁnding novel vulnerabilities and their
sources. The presented vulnerabilities have been reported
and patched by the library developers, proving their rele-
vance.
7.1 Padding Oracle Attacks

In recent years we observed several scientiﬁc results prov-
ing the padding oracle exploitation possibilities in widely
used TLS libraries. Irazouqui et al. showed how to exploit
cache access times in co-located virtual machines in cloud en-
vironments to gain suﬃcient timing diﬀerences for executing
the Lucky 13 attack [35]. Almeida et al. and Albrecht and
Paterson showed that an extended version of the Lucky 13
timing attack is still applicable to the s2n library provided
by Amazon [14, 11].

Surprisingly, it is not always necessary to execute complex
timing attacks. As we show in the following section promi-
nent TLS libraries are vulnerable to direct padding oracle
attacks, where servers respond with diﬀerent alert messages.
The vulnerabilities result from incorrect sanity checks of the
decrypted CBC ciphertexts [13].

Unusual padding oracle in Botan.

By evaluating Botan 1.11.21, we observed diﬀerent re-
sponse messages sent by the analyzed TLS server. Further
analysis revealed that directly after the record data is de-
crypted, the implementation evaluates the length of the un-
padded data record_len and whether this data has enough
length
using
TLS_RSA_WITH_AES_128_CBC_SHA, the HMAC is 20-byte long):
i f ( r e c o r d l e n < m a c p a d i v s i z e )

for HMAC validation

while

(e.g.,

throw D e c o d i n g E r r o r ( ”Record s e n t w i t h i n v a l i d

l e n g t h ” ) ;

In order

to trigger

the DECODE_ERROR alert

If there is not enough data for MAC validation, the server
responds with a DECODE_ERROR alert. This alert diﬀers from
a typical case when an invalid padding is used (cf. Figure 5).
for a
TLS_RSA_WITH_AES_128_CBC_SHA cipher suite (20-byte long
HMAC output, 16-byte long AES block cipher), the de-
crypted message has to consist of at least 32 bytes (two
blocks), and it has to contain at least 13 valid padding bytes.
This means that the attacker has to set at least 13 bytes to
trigger the alert and use padding oracle attacks. This is
possible in scenarios where the attacker knows parts of the
plaintext, for example, if the victim uses a browser which
sends known HTTP headers to the website [30].

Figure 5: Direct padding oracle provided by Botan
1.11.21.
In case of an invalid padding, Botan
responds with BAD_RECORD_MAC. In case of a valid
padding, Botan attempts to process the HMAC. It
responds with a DECODE_ERROR if the number of re-
maining bytes is insuﬃcient for HMAC validation.

The vulnerability was ﬁxed after our disclosure in version

1.11.22 and has been labeled CVE-2015-7824.

Unlucky patch of Lucky 13 in OpenSSL.

OpenSSL relies on two versions of AES: software imple-
mentation provided directly by OpenSSL and hardware im-
plementation relying on AES-NI [32].8 For each of these
AES versions, a diﬀerent CBC functionality in OpenSSL is
implemented. The following vulnerability was present only
in the CBC functionality implemented for the hardware ver-
sion of AES (AES-NI). This version is enabled by default on
machines with recent CPUs. We performed our tests with
OpenSSL 1.0.2g.

In order to patch the Lucky 13 attack, OpenSSL develop-
ers have introduced new code validating padding bytes and
HMAC in constant-time. The code attempts to implement a
very delicate CBC sanity checking countermeasure provided
by AlFardan and Paterson [13]. The OpenSSL validation is
implemented in methods aesni_cbc_hmac_sha1_cipher and
aesni_cbc_hmac_sha256_cipher and works follows:

1. It veriﬁes whether the ciphertext can provide enough
data for HMAC and minimal padding. For example,
ciphertexts consisting of 16 bytes are directly rejected
by OpenSSL because they do not provide enough data
for HMAC validation.

2. It decrypts the AES-CBC ciphertext into a message m
of length lm and interprets the last byte of the mes-
sage as a padding byte lpad. Furthermore, it internally
computes the maximum padding value: maxpad =
lm − lhmac (where lhmac represents the HMAC output
length).

3. For validation purposes, it computes an HMAC hmac(cid:48)
over the TLS record header and lm − lpad − lhmac −
It constructs
1 bytes of the decrypted message m.
hmac(cid:48)||pad(cid:48) where pad(cid:48) consists of lpad + 1 padding
bytes.

4. At the end, it validates whether the last (maxpad +
lhmac) bytes of the message m are equal to hmac(cid:48)||pad(cid:48).
8AES-NI is an extended set of instructions available in re-
cent Intel and AMD CPUs.

0c0c0c0c0c0c0c0c0c0c0c0c0cBAD_RECORD_MAC DECODING_ERROR0c0c0c0c0c0c0c0c0c0c0c0c0c4344414245MMMMMMMMMMMMMMMMMMMMM0606060606060605MMMMMMMMMMMMMMMMMMMMM1500Figure 6: When OpenSSL 1.0.2g decrypts two full
padding blocks,
it creates an internal structure
for constant-time HMAC and padding validation:
hmac(cid:48)||pad(cid:48). However, only the padding bytes are
validated.

Unfortunately, the code is missing one important sanity
check. According to [13], directly after decrypting the ci-
phertext in the second step, the implementation must check
whether there is enough plaintext data. If lhmac + lpad + 1 >
lm, there are not enough plaintext bytes to validate both
HMAC and padding. Therefore, the padding validation
should run over 256 dummy padding bytes and the HMAC
should be validated over the record header and the ﬁrst
lm − lhmac bytes of m [13].

Because the OpenSSL code does not validate the decrypted
message length, it is possible to completely skip the HMAC
validation. Consider a vulnerable server using HMAC-SHA
that processes a CBC ciphertext. The CBC ciphertext de-
crypts to 32 valid padding bytes 0x1F. After the message is
decrypted in the second step, the server computes maxpad =
lm − lhmac = 12.
In the third step, it computes hmac(cid:48)
over the TLS record header and an empty message. It con-
structs hmac(cid:48)||pad(cid:48) where pad(cid:48) consists of 32 0x1F bytes.
In the fourth step, it uses hmac(cid:48)||pad(cid:48) to validate contents
of the decrypted message. The validation is, however, per-
formed only over (maxpad + lhmac) = 32 decrypted bytes.
Even though OpenSSL internally computes an HMAC value
hmac(cid:48), this value is completely ignored during the valida-
tion process, the HMAC validation step succeeds, and the
decrypted message is processed further.9 See Figure 6.

in

the

is

processed

The above described functionality obviously results in a
diﬀerent timing behavior. However, further message pro-
cessing results even in a diﬀerent TLS alert message. The de-
crypted message
function
ssl3_get_record, which attempts to remove the padding
and HMAC bytes and computes the new plain message length
rr->length = lm − lhmac − lpad − 1, which is declared as
an unsigned integer. Note that in our case, the decrypted
message consists of 32 bytes, lhmac = 20 and lpad = 31.
Thus, the computation results in an integer underﬂow of
rr->length. This underﬂow is further caught by the valida-
tion of the maximum plaintext length in the same OpenSSL
method:

( r r−>l e n g t h > SSL3 RT MAX PLAIN LENGTH) {

i f

a l = SSL AD RECORD OVERFLOW ;
S S L e r r ( SSL F SSL3 GET RECORD ,

SSL R DATA LENGTH TOO LONG) ;

g o t o f e r r ;

}

This if branch results in a diﬀerent alert message, namely:
RECORD_OVERFLOW. TLS-Attacker detected that this alert mes-
9Note that the same behavior can be observed by sending 32
equal padding bytes pad where lpad > 0x1F. Even though the
padding is incomplete, the implementation only validates
the equality of the 32 decrypted message bytes.

sage diﬀered from the typical BAD_RECORD_MAC alert, and re-
ported a problem after executing the ﬁrst evaluation stage.
In order to trigger the RECORD_OVERFLOW alert, the at-
tacker needs to send a ciphertext which decrypts to 32 equal
bytes. The attacker can exploit this behavior in speciﬁc
BEAST scenarios [30] by controlling 31 bytes of the plaintext
data. In comparison to the previous Botan vulnerability, the
attacker is only able to recover at most 16 subsequent plain-
text data at most because of the CBC mode of operation
properties [52, 54].

The vulnerability was ﬁxed after our disclosure in OpenSSL

1.0.2h / 1.0.1t. It has been labeled CVE-2016-2107.10

Unlucky patch of Lucky 13 in MatrixSSL.

A similar problem with patching the Lucky 13 attack
could be observed in the MatrixSSL library. The develop-
ers of MatrixSSL, however, introduced a much more serious
buﬀer overﬂow vulnerability while attempting to implement
a Lucky 13 countermeasure.

The vulnerability has been patched after our disclosure in

MatrixSSL 3.8.2.

7.2 Bleichenbacher’s Attack on MatrixSSL

In 2014 Meyer et al. [44] analyzed vulnerabilities of TLS
libraries to Bleichenbacher attacks. Most libraries were only
vulnerable to timing attacks at that time.

In this work we could ﬁnd a direct Bleichenbacher vulner-
ability in MatrixSSL. The vulnerable server responds with
a diﬀerent TLS alert (ILLEGAL_PARAMETER) in case the de-
crypted ClientKeyExchange message is correctly formatted
but contains an invalid TLS version number. Otherwise, the
server responds with a DECRYPT_ERROR alert. This kind of
vulnerability was in a fact ﬁrst described by Klima et al. in
2003 [40].

The vulnerability has been patched after our disclosure in

MatrixSSL 3.8.2.

7.3 Missing Length Checks

Our analysis in phase 1 of the second stage revealed inter-
esting results regarding the checks of diﬀerent length vari-
ables. For example, GnuTLS 3.4.9 does not strictly check
the length variables in the following extensions: max frag-
ment length, elliptic curves, EC point format extension, and
signature and hash algorithms extension.

If an invalid length variable is contained in one of these
ﬁelds in the ClientHello message, GnuTLS just proceeds
with the TLS handshake without further message parsing.
We assume this behavior is caused by performance op-
timizations included in the evaluated library. An attacker
could use it for ﬁngerprinting of TLS server library. More-
over, this behavior becomes interesting in light of the very
recent SLOTH attack [20]. By performing this attack, the
attacker attempts to ﬁnd hash collisions for a transcript of
protocol messages. Thereby, he tampers selected handshake
message ﬁelds so that the messages remain valid. Not vali-
dating speciﬁc message ﬁelds gives the attacker more modi-
ﬁcation freedom and improves the attack.

10Commit
https://github.com/openssl/openssl/commit/
70428eada9bc4cf31424d723d1f992baﬀeb0dfb

70428eada9bc4cf31424d723d1f992baﬀeb0dfb:

MMMMMMMMMMMMMMMMMMMMM1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f1f15017.4 Overﬂows and Overreads

By fuzzing the variables in the ﬁrst and second phases, we

were also able to ﬁnd array boundary vulnerabilities.

Stack overﬂow in OpenSSL-1.1.0-pre1. By fuzzing the
ﬁrst pre-version of the OpenSSL 1.1.0 library (OpenSSL-
1.1.0-pre1), ASan reported a stack overﬂow vulnerability
and the server crashed. Our analysis of the vulnerability
revealed that the stack overﬂow is caused by sending an
overlong DH parameter in the DHClientKeyExchange mes-
sage. TLS-Attacker triggered this bug by a left shift of the
original BigInteger value, as we found in the resulting pro-
tocol ﬂow conﬁguration document:

<w o r k f l o w T r a c e>

<p r o t o c o l M e s s a g e s>
. . .
<DHClientKeyExchange>

<y>

<b i g I n t e g e r S h i f t L e f t M o d i f i c a t i o n>

< s h i f t>41</ s h i f t>

</ b i g I n t e g e r S h i f t L e f t M o d i f i c a t i o n>

</y>

</ DHClientKeyExchange>
. . .
</ p r o t o c o l M e s s a g e s>

</ w o r k f l o w T r a c e>

When we found this vulnerability (February 2016),
OpenSSL has already published a new version, OpenSSL-
1.1.0-pre2, which did not include this vulnerability. The
OpenSSL security team mentioned in our email correspon-
dence that they knew about this vulnerability internally.11
Since the security vulnerabilities in OpenSSL pre-releases
are not public, we were not aware of this fact.

The vulnerability is not present in any of the newest

OpenSSL release versions (1.0.2g).

Potential buﬀer overread in Botan 1.11.28. Further-
more, we found a buﬀer overread vulnerability in Botan
1.11.28. This vulnerability was found by executing the sec-
ond phase of the fuzzing stage by modifying bytes in the
underlying record layer:

<w o r k f l o w T r a c e>

<p r o t o c o l M e s s a g e s>

. . .
<ChangeCipherSpec>

<m e s s a g e I s s u e r>CLIENT</ m e s s a g e I s s u e r>
<r e c o r d s>
<r e c o r d>

<maxRecordLengthConfig>0</
maxRecordLengthConfig>

</ r e c o r d>
</ r e c o r d s>

</ ChangeCipherSpec>
. . .

</ p r o t o c o l M e s s a g e s>

</ w o r k f l o w T r a c e>

The resulting protocol ﬂow revealed that by sending an
empty TLS record, the server attempts to use an invalid
array index. The failure is triggered by a randomly selected
conﬁguration of the maximum record length, which is set to
zero with maxRecordLengthConfig.

Even though Botan 1.11.28 does not directly verify the
length of the incoming TLS records, further handshake han-
dlers can successfully reject the message and throw an error.

11The vulnerability has been ﬁxed in the
commit:
e2b420fdd708e14a0b43a21cd2377cafb0d54c02

following
https://github.com/openssl/openssl/commit/

These subsequent veriﬁcations turn the resulting vulnerabil-
ity into a rather harmless buﬀer overread, which only con-
ﬁrms the functionality of TLS-Attacker.

We reported the issue to Botan developers. It has been

patched in Botan 1.11.29.

8. BUILDING A TLS TEST SUITE

The uncovered vulnerabilities have strongly motivated de-
velopers to build TLS test suites with negative tests to val-
idate correct TLS behavior in speciﬁc cases. TLS negative
tests could then have mitigated several vulnerabilities found
in this paper. For example, a padding oracle test suite could
have sent encrypted records with modiﬁed padding contents
to trigger diﬀerent TLS alerts. Developers introducing new
functionality (e.g., Lucky 13 countermeasures) would have
been warned about invalid message processing before releas-
ing new library versions.

We have managed to extend TLS-Attacker with a Test-
Suite module allowing TLS developers to easily build pos-
itive and negative test suites.
In the following section we
describe the usage of assertions with our framework and
present an experimental test suite for cipher suite usage
across TLS protocols. Note that the TLS test suite is a work-
in-progress and this section aims at describing the suitability
of TLS-Attacker for this purpose.
8.1 Usage of Assertions

In order to build comprehensive TLS test suites, we have
extended the TLS-Attacker functionality with assertions. In
particular, we have extended modiﬁable variables with as-
serting values that allow developers to validate resulting con-
tents of modiﬁable variable ﬁelds after the TLS protocol is
executed.

The following listing gives an example of a TLS protocol
ﬂow containing assertions which detect the OpenSSL vul-
nerability:

<w o r k f l o w T r a c e>

<p r o t o c o l M e s s a g e s>

. . .
<F i n i s h e d>

<m e s s a g e I s s u e r>CLIENT</ m e s s a g e I s s u e r>
<r e c o r d s>
<Record>

<p l a i n R e c o r d B y t e s>

<b y t e A r r a y E x p l i c i t V a l u e M o d i f i c a t i o n>

<e x p l i c i t V a l u e>

3F 3F 3F 3F 3F 3F 3F 3F 3F 3F 3F 3F 3F 3F 3F 3F
3F 3F 3F 3F 3F 3F 3F 3F 3F 3F 3F 3F 3F 3F 3F 3F

</ e x p l i c i t V a l u e>

</ b y t e A r r a y E x p l i c i t V a l u e M o d i f i c a t i o n>

</ p l a i n R e c o r d B y t e s>

</ Record>
</ r e c o r d s>
</ F i n i s h e d>
<A l e r t>

<m e s s a g e I s s u e r>SERVER</ m e s s a g e I s s u e r>
< l e v e l>

<a s s e r t E q u a l s>2</ a s s e r t E q u a l s>

</ l e v e l>
<d e s c r i p t i o n>

<a s s e r t E q u a l s>20</ a s s e r t E q u a l s>

</ d e s c r i p t i o n>

</ A l e r t>

</ p r o t o c o l M e s s a g e s>

</ w o r k f l o w T r a c e>

In this listing we can see a TLS protocol ﬂow setting the
explicit value of the plain padded TLS record to 32 0x3F
bytes. Thus, it potentially triggers a RECORD_OVERFLOW alert
in vulnerable OpenSSL implementations (CVE-2016-2107).

1502After executing the protocol ﬂow, we expect to receive a TLS
alert message. This TLS alert message contains assertions
for the level (2) and description (20) values. This ensures
that the protocol ﬂow only succeeds if the server correctly
responds with a BAD_RECORD_MAC alert message.

Similar test cases can be deﬁned for other cryptographic

attacks or protocol behaviors.
8.2 Experimental Test Suite for Correct Ci-

pher Suite Handling

We have created a proof-of-concept test suite for the val-
idation of correct cipher suite support in TLS protocols.
The test suite takes the available cipher suites and checks
whether they are available for correct protocol versions. For
example, TLS_RSA_WITH_AES_256_CBC_SHA256 must only be
accepted in TLS 1.2 but rejected in other protocol versions.
We also executed the tests with the analyzed frameworks,
detecting that Botan (1.11.30) is not standard-compliant
and that it incorrectly accepts TLS 1.2 cipher suites in TLS
1.0 and 1.1 protocols. This does not pose a direct security
risk. However, using secure cipher suites in older protocols
could possibly undermine their security and should be cor-
rectly handled with the TLS framework.

We notiﬁed Botan developers about this issue. They in-

tend to ﬁx this issue in the next Botan version.

9. DISCUSSION

In this paper we showed that widely used TLS libraries
can include critical vulnerabilities which can be exposed by
systematic fuzzing. The case of the OpenSSL stack overﬂow
shows that a critical vulnerability can be introduced in a
speciﬁc library version, for example, by code restructuring.
More interestingly, new vulnerabilities can be introduced by
implementing countermeasures against known attacks. The
cases of padding oracle attacks in OpenSSL and MatrixSSL
showed that an incorrect countermeasure can turn a server
oﬀering a timing oracle into a direct oracle or even into a
server with a buﬀer overﬂow vulnerability.

We conclude that similar fuzzing technologies, as intro-
duced in our paper, should be included into library test
suites and should be included into continuous integration, or
should be run before the new library versions are released.
MatrixSSL and Botan libraries are in a phase of including
TLS-Attacker into their test suite.

In future work, TLS-Attacker fuzzing could be extended
to include new fuzzing strategies or compile-time instrumen-
tation to observe new code paths at runtime. The concepts
of TLS-Attacker fuzzing could also be extended to validate
TLS clients or even to test security protocols beyond TLS,
e.g., IPSec or SSH.

Acknowledgments
We would like to thank Hanno B¨ock, Robert Gawlik,
Thorsten Holz, Tibor Jager, Ren´e Korthaus, Felix Lange,
Christian Mainka, Robert Merget, Daniel Neus, Florian
Pf¨utzenreuter, Philip Riese, J¨org Schwenk, and Aaron Za-
uner for their helpful discussions and additional contribu-
tions. We also extend our thanks to our reviewers for their
insightful comments and suggestions.

This work was partially supported by the European Com-
mission through the FutureTrust project (grant 700542-
Future-Trust-H2020-DS-2015-1) and by the Federal Oﬃce

for Information Security through project 197 (Sichere Im-
plementierung einer allgemeinen Kryptobibliothek).

10. REFERENCES
[1] Botan: Crypto and TLS for C++11.

http://botan.randombit.net/.

[2] Gnutls security advisory.

http://www.gnutls.org/security.html.
[3] Java Architecture for XML Binding.

https://jaxb.java.net/.

[4] Java platform debugger architecture. http:

//docs.oracle.com/javase/1.5.0/docs/guide/jpda/.

[5] Java Secure Socket Extension (JSSE).

https://docs.oracle.com/javase/8/docs/technotes/
guides/security/jsse/JSSERefGuide.html.

[6] matrixSSL. Compact Embedded SSL/TLS stack.

http://www.matrixssl.org/.

[7] mbed TLS. https://tls.mbed.org/.
[8] OpenSSL – Cryptography and SSL/TLS Toolkit.

https://www.openssl.org.

[9] OpenSSL security advisory.

https://www.openssl.org/news/vulnerabilities.html.

[10] The GnuTLS Transport Layer Security Library.

http://www.gnutls.org.

[11] Albrecht, M. R., and Paterson, K. G. Lucky

microseconds: A timing attack on amazon’s s2n
implementation of TLS. In Advances in Cryptology -
EUROCRYPT 2016 - 35th Annual International
Conference on the Theory and Applications of
Cryptographic Techniques, Vienna, Austria, May 8-12,
2016, Proceedings, Part I (2016), pp. 622–643.

[12] AlFardan, N., and Paterson, K.

Plaintext-Recovery Attacks Against Datagram TLS.
In Network and Distributed System Security
Symposium (NDSS 2012) (Feb. 2012).

[13] AlFardan, N. J., and Paterson, K. G. Lucky

Thirteen: Breaking the TLS and DTLS Record
Protocols. 2013 IEEE Symposium on Security and
Privacy 0 (2013), 526–540.
http://www.isg.rhul.ac.uk/tls/TLStiming.pdf.

[14] Almeida, J. B., Barbosa, M., Barthe, G., and
Dupressoir, F. Veriﬁable side-channel security of
cryptographic implementations: constant-time
MEE-CBC. In Fast Software Encryption - 23rd
International Conference, FSE (2016).

[15] Aviram, N., Schinzel, S., Somorovsky, J.,

Heninger, N., Dankel, M., Steube, J., Valenta,
L., Adrian, D., Halderman, J. A., Dukhovni, V.,
K¨asper, E., Cohney, S., Engels, S., Paar, C.,
and Shavitt, Y. DROWN: Breaking TLS Using
SSLv2. In 25th USENIX Security Symposium
(USENIX Security 16) (Aug. 2016).

[16] Bardou, R., Focardi, R., Kawamoto, Y., Steel,

G., and Tsay, J.-K. Eﬃcient Padding Oracle
Attacks on Cryptographic Hardware. In Advances in
Cryptology – CRYPTO (2012), Canetti and
R. Safavi-Naini, Eds.

[17] Beurdouche, B., Bhargavan, K.,

Delignat-Lavaud, A., Fournet, C., Kohlweiss,
M., Pironti, A., Strub, P.-Y., and Zinzindohoue,
J. K. A messy state of the union: taming the
composite state machines of TLS. In IEEE Symposium
on Security & Privacy 2015 (Oakland’15) (2015),
IEEE.

[18] Beurdouche, B., Delignat-Lavaud, A., Kobeissi,
N., Pironti, A., and Bhargavan, K. FLEXTLS: A
Tool for Testing TLS Implementations. In 9th
USENIX Workshop on Oﬀensive Technologies
(WOOT 15) (Washington, D.C., Aug. 2015), USENIX
Association.

1503[19] Bhargavan, K., Delignat-Lavaud, A., Fournet,

C., Pironti, A., and Strub, P.-Y. Triple
Handshakes and Cookie Cutters: Breaking and Fixing
Authentication over TLS. In IEEE Symposium on
Security & Privacy 2014 (Oakland’14) (2014), IEEE.

[20] Bhargavan, K., and Leurent, G. Transcript

Collision Attacks: Breaking Authentication in TLS,
IKE, and SSH. In Proceedings of the ISOC Network
and Distributed System Security Symposium (NDSS
’16) (Feb 2016).

[21] Biehl, I., Meyer, B., and M¨uller, V. Diﬀerential

fault attacks on elliptic curve cryptosystems. In
Proceedings of the 20th Annual International
Cryptology Conference on Advances in Cryptology
(London, UK, UK, 2000), CRYPTO ’00,
Springer-Verlag, pp. 131–146.

[22] Blake-Wilson, S., Bolyard, N., Gupta, V.,

Hawk, C., and Moeller, B. Elliptic Curve
Cryptography (ECC) Cipher Suites for Transport
Layer Security (TLS). RFC 4492 (Informational), May
2006. Updated by RFCs 5246, 7027.

[23] Bleichenbacher, D. Chosen ciphertext attacks

against protocols based on the RSA encryption
standard PKCS #1. In Advances in Cryptology —
CRYPTO ’98, vol. 1462 of Lecture Notes in Computer
Science. Springer Berlin / Heidelberg, 1998.

[24] B¨ock, H. A little POODLE left in GnuTLS (old

versions), Nov. 2015. https://blog.hboeck.de/archives/
877-A-little-POODLE-left-in-GnuTLS-old-versions.
html.

[25] de Ruiter, J., and Poll, E. Protocol State Fuzzing

of TLS Implementations. In 24th USENIX Security
Symposium (USENIX Security 15) (Washington,
D.C., Aug. 2015), USENIX Association, pp. 193–206.

[26] Dierks, T., and Allen, C. The TLS Protocol

Version 1.0. RFC 2246 (Proposed Standard), Jan.
1999. Obsoleted by RFC 4346, updated by RFCs
3546, 5746, 6176, 7465, 7507.

[27] Dierks, T., and Rescorla, E. The Transport Layer

Security (TLS) Protocol Version 1.2. RFC 5246
(Proposed Standard), Aug. 2008. Updated by RFCs
5746, 5878, 6176, 7465, 7507, 7568, 7627, 7685.

[28] Dierks, T., and Rescorla, E. The Transport Layer

Security (TLS) Protocol Version 1.3.
draft-ietf-tls-tls13-04, Jan. 2015.

[29] Dietz, W., Li, P., Regehr, J., and Adve, V.

Understanding integer overﬂow in c/c++. In
Proceedings of the 2012 International Conference on
Software Engineering (Piscataway, NJ, USA, 2012),
ICSE 2012, IEEE Press, pp. 760–770.
[30] Duong, T., and Rizzo, J. Here come the ⊕ Ninjas.

Unpublished manuscript, 2011.

[31] Eastlake, D. Transport Layer Security (TLS)

Extensions: Extension Deﬁnitions. RFC 6066
(Proposed Standard), Jan. 2011.

[32] Gueron, S. Intel Advanced Encryption Standard
(AES) New Instructions Set, Revision 3.01, 2012.

[33] Haller, I., Slowinska, A., Neugschwandtner,
M., and Bos, H. Dowsing for overﬂows: A guided
fuzzer to ﬁnd buﬀer boundary violations. In Presented
as part of the 22nd USENIX Security Symposium
(USENIX Security 13) (Washington, D.C., 2013),
USENIX, pp. 49–64.

[34] Haugh, E. Testing c programs for buﬀer overﬂow

vulnerabilities. In In Proceedings of the Network and
Distributed System Security Symposium (NDSS)
(2003).

[35] Irazoqui, G., Inci, M. S., Eisenbarth, T., and
Sunar, B. Lucky 13 strikes back. In Proceedings of
the 10th ACM Symposium on Information, Computer
and Communications Security (New York, NY, USA,
2015), ASIA CCS ’15, ACM, pp. 85–96.

[36] Jager, T., Schinzel, S., and Somorovsky, J.

Bleichenbacher’s attack strikes again: breaking
PKCS#1 v1.5 in XML Encryption. In Computer
Security - ESORICS 2012 - 17th European Symposium
on Research in Computer Security, Pisa, Italy,
September 10-14, 2012. Proceedings (2012), S. Foresti
and M. Yung, Eds., LNCS, Springer.

[37] Jager, T., Schwenk, J., and Somorovsky, J.

Practical Invalid Curve Attacks on TLS-ECDH. 20th
European Symposium on Research in Computer
Security (ESORICS) (2015).

[38] Kario, H. Testing TLS. Ruxcon, Oct. 2015.

https://github.com/tomato42/tlsfuzzer.

[39] Kikuchi, M. CCS Injection Vulnerability, 2014.

http://ccsinjection.lepidum.co.jp.

[40] Kl´ıma, V., Pokorn´y, O., and Rosa, T. Attacking

RSA-Based Sessions in SSL/TLS. In Cryptographic
Hardware and Embedded Systems - CHES 2003,
vol. 2779 of Lecture Notes in Computer Science.
Springer Berlin / Heidelberg, Sept. 2003.

[41] Langley, A. The POODLE bites again, Nov. 2014.

https://www.imperialviolet.org/2014/12/08/
poodleagain.html.

[42] Merkle, J., and Lochter, M. Elliptic Curve

Cryptography (ECC) Brainpool Curves for Transport
Layer Security (TLS). RFC 7027 (Informational), Oct.
2013.

[43] Meyer, C. 20 Years of SSL/TLS Research : An

Analysis of the Internet’s Security Foundation. PhD
thesis, Ruhr-University Bochum, Feb. 2014.

[44] Meyer, C., Somorovsky, J., Weiss, E., Schwenk,
J., Schinzel, S., and Tews, E. Revisiting SSL/TLS
Implementations: New Bleichenbacher Side Channels
and Attacks. In 23rd USENIX Security Symposium,
San Diego, USA (August 2014).

[45] M¨oller, B., Duong, T., and Kotowicz, K. This

POODLE bites: exploiting the SSL 3.0 fallback, 2014.

[46] Moneger, A. Penetration Testing Custom TLS

Stacks. ShmooCon, Feb. 2016.
https://github.com/tintinweb/scapy-ssl tls.

[47] Ray, M., and Dispensa, S. Renegotiating TLS.

Tech. rep., PhoneFactor, Inc., Nov. 2009.

[48] Rescorla, E., and Modadugu, N. Datagram
Transport Layer Security Version 1.2. RFC 6347
(Proposed Standard), Jan. 2012. Updated by RFC
7507.

[49] Riku, Antti, Matti, and Mehta. Heartbleed,

cve-2014-0160, 2015. http://heartbleed.com/.

[50] Seggelmann, R., Tuexen, M., and Williams, M.

Transport Layer Security (TLS) and Datagram
Transport Layer Security (DTLS) Heartbeat
Extension. RFC 6520 (Proposed Standard), Feb. 2012.

[51] Sheffer, Y., Holz, R., and Saint-Andre, P.
Summarizing Known Attacks on Transport Layer
Security (TLS) and Datagram TLS (DTLS). RFC
7457 (Informational), Feb. 2015.

[52] Somorovsky, J. Curious Padding oracle in OpenSSL
(CVE-2016-2107). http://web-in-security.blogspot.de/
2016/05/curious-padding-oracle-in-openssl-cve.html.
[53] Sullivan, N. The results of the cloudﬂare challenge.

https://blog.cloudﬂare.com/
the-results-of-the-cloudﬂare-challenge.

[54] Valsorda, F. Yet Another Padding Oracle in

OpenSSL CBC Ciphersuites.
https://blog.cloudﬂare.com/
yet-another-padding-oracle-in-openssl-cbc-ciphersuites.

[55] Vaudenay, S. Security Flaws Induced by CBC

Padding — Applications to SSL, IPSEC, WTLS... In
Advances in Cryptology — EUROCRYPT 2002,
vol. 2332 of Lecture Notes in Computer Science.
Springer Berlin / Heidelberg, Apr. 2002.

1504