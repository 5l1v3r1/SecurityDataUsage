Practical Anonymous Password Authentication and TLS

with Anonymous Client Authentication ∗

Zhenfeng Zhang

Trusted Computing and Information Assurance

Laboratory, SKLCS, Institute of Software,

Chinese Academy of Sciences
zfzhang@tca.iscas.ac.cn

Xuexian Hu

Institute of Software, Chinese Academy of
Sciences & State Key Lab of Mathematical

Engineering and Advanced Computing

xuexian_hu@hotmail.com

†
Kang Yang

Trusted Computing and Information Assurance

Laboratory, Institute of Software,
Chinese Academy of Sciences
yangkang@tca.iscas.ac.cn

Yuchen Wang

Trusted Computing and Information Assurance

Laboratory, Institute of Software,
Chinese Academy of Sciences

wangyuchen@tca.iscas.ac.cn

ABSTRACT
Anonymous authentication allows one to authenticate her-
self without revealing her identity, and becomes an impor-
tant technique for constructing privacy-preserving Internet
connections. Anonymous password authentication is high-
ly desirable as it enables a client to authenticate herself
by a human-memorable password while preserving her pri-
vacy.
In this paper, we introduce a novel approach for
designing anonymous password-authenticated key exchange
(APAKE) protocols using algebraic message authentication
codes (MACs), where an algebraic MAC wrapped by a pass-
word is used by a client for anonymous authentication, and
a server issues algebraic MACs to clients and acts as the
veriﬁer of login protocols. Our APAKE construction is se-
cure provided that the algebraic MAC is strongly existential-
ly unforgeable under random message and chosen veriﬁca-
tion queries attack (suf-rmva), weak pseudorandom and tag-
randomization simulatable, and has simulation-sound ex-
tractable non-interactive zero-knowledge proofs (SE-NIZKs).
To design practical APAKE protocols, we instantiate an
algebraic MAC based on the q-SDH assumption which sat-
isﬁes all the required properties, and construct credential
presentation algorithms for the MAC which have optimal ef-
ﬁciency for a randomize-then-prove paradigm. Based on the
algebraic MAC, we instantiate a highly practical APAKE
protocol and denote it by APAKE, which is much more eﬃcien-

∗The work is supported by National Basic Research Program

of China (No.2013CB338003) and National Natural Science
Foundation of China (No.U1536205, 61572485, 61502527).

†Corresponding author

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’16, October 24-28, 2016, Vienna, Austria
c(cid:13) 2016 ACM. ISBN 978-1-4503-4139-4/16/10. . . $15.00
DOI: http://dx.doi.org/10.1145/2976749.2978354

t than the mechanisms speciﬁed by ISO/IEC 20009-4. An
eﬃcient revocation mechanism for APAKE is also proposed.

We integrate APAKE into TLS to present an anonymous
client authentication mode where clients holding passwords
can authenticate themselves to a server anonymously. Our
implementation with 128-bit security shows that the aver-
age connection time of APAKE-based ciphersuite is 2.8 ms.
With APAKE integrated into the OpenSSL library and us-
ing an Apache web server on a 2-core desktop computer,
we could serve 953 ECDHE-ECDSA-AES128-GCM-SHA256 HTTP-
S connections per second for a 10 KB payload. Compared
to ECDSA-signed elliptic curve Diﬃe-Hellman ciphersuite
with mutual authentication, this means a 0.27 KB increased
handshake size and a 13% reduction in throughput.
1.

INTRODUCTION

Privacy protection has become a major concern with the
rapid growth of cloud computing, big data and internet of
things. For example, contact details of 1.5 million customers
of Verizon Enterprise were put up for sale on a Dark Web fo-
rum recently [1]. Most people typically associate the loss of
privacy with a feeling of invasion or loss of control [45]. The
importance of user privacy in authentication systems has
been emphasized by the European privacy standard [31] and
by the US government in the National Strategy for Trust-
ed Identities in Cyberspace [52]. NIST has developed three
privacy engineering objectives - predictability, manageabili-
ty, and disassociability [47], where disassociability captures
one of the essential elements of privacy-enhancing systems
that the system actively protects or “blinds” an individual’s
identity or associated activities from unnecessary exposure.
Authentication of participants is usually required in com-
puter systems-based applications to establish trust relations.
An eﬀective approach to protect users’ privacy in authentica-
tion systems is anonymous authentication which achieves se-
cure authentication and anonymity simultaneously [45], i.e.,
no unauthorized user can fool a server into granting it ac-
cess, and the server should not know which user it is in-
teracting with. As stated in [21], privacy-conscious service
providers (SPs) have a strong incentive to adopt anonymous
authentication, and it is in their best interest to keep client
information private on technical unavailability grounds.

1179Password-based authentication systems have been wide-
ly deployed in information systems to guarantee authorized
access to desktop, mobile and web applications, as pass-
words have advantages of being memorable, avoiding com-
prehensive public key infrastructure for distributing client
certiﬁcates and dedicated hardware for storing secret keys.
Password-based authentication with key exchange protocols
have been extensively explored [7, 4, 14, 44, 49, 8] and widely
standardized [39, 57, 40]. The TLS ciphersuite using secure
remote password protocol [57] is provided in OpenSSL.

In traditional password-based authentication systems, a
user keeps a password conﬁdential but pays no attention
to privacy protection of herself [2], since the identity infor-
mation is usually transmitted explicitly so that the server
can determine which password should be used. Therefore,
anonymous authentication that can work with password-
based technology are highly desirable [45].

Anonymous password authentication protocols have been
proposed by Viet et al. [58] via integrating an oblivious
transfer protocol within a two-party password-authenticated
key exchange protocol, and later improved in [60, 54]. Such
protocols allow a client holding a password to authenticate
herself to the server, while preserving her privacy. However,
these protocols have an inherent limitation for computation
eﬃciency, i.e., a server performs O(N ) computations per
protocol execution, where N is the total number of users.

Another approach for anonymous password authentica-
tion was proposed in [61, 62], where a user obtains a (CL
[17] or BBS [12]) signature from a server, wraps the signa-
ture with her password and stores it on some extra storage,
such as a smartphone, a tablet (e.g., iPad), a USB ﬂash
memory, or even in a public directory (e.g., cloud). The ex-
tra storage is only needed to be integrity-protected, which
is weaker than a dedicated hardware. To login the server,
the user recovers the signature from a password-wrapped
credential using her password, and then proves possession
of the signature. In these schemes, the server’s cost is in-
dependent of the scale of user set. However, homomorphic
encryption is needed in [61, 62] to resist oﬀ-line dictionary
attacks. For 80-bit security level, a user with a 2.53GHz
notebook costs 385 ms and a server with a 3.0GHz desktop
computer costs 430 ms per login protocol run.

Anonymous password authentication also attracts the in-
terest of industry standard organizations. In a standard for
anonymous entity authentication, the mechanisms based on
weak secrets are named as ISO/IEC 20009-4 and developed
by ISO/IEC JTC 1, SC 27, IT Security techniques. Three
mechanisms have been included in ISO/IEC 20009-4 [43].

For the Transport Layer Security (TLS) protocol [28],
there are three modes supported: mutual authentication,
server authentication (with no client authentication), and
total anonymity. The ﬁrst mode needs client certiﬁcates to
oﬀer authentication, and thus provides no client-anonymity.
The last two modes do not provide any authentication of
clients, and the mode of total anonymity is inherently vul-
nerable to man-in-the-middle attacks and strongly discour-
aged. A TLS mode of anonymous client authentication is
of great interest, where clients can authenticate to a server
without revealing their identities, the server is assured that
only authorized clients can provide secure authentication.

In CCS 2015, Cassola et al.

[21] consider a practical s-
cenario of anonymous authentication for Wi-Fi connectivity
using open hotspots hosted on untrusted Access Points (AP-

s). A dishonest ISP may track which APs a client connects
to and when, revealing clients’ mobility patterns and other
sensitive information. A protocol was proposed in [21] that
allows SPs to authenticate their clients, but hides clients’
identities from APs and SPs at the time of authentication.
1.1 Our Contributions

In this paper, we propose a novel approach for design-
ing anonymous password authentication protocols by using
algebraic MACs which are constructed using only group op-
erations rather than block ciphers or hash functions [24].
Speciﬁcally, an algebraic MAC is issued by a server to a us-
er, and then used as a credential for authentication. The
algebraic MAC is protected by a user’s password and stored
on some extra storage with integrity-protection. The under-
lying algebraic MAC is required to be weak pseudorandom
in order to resist oﬀ-line dictionary attacks, and admits ef-
ﬁcient zero-knowledge proofs so that a user can prove pos-
session of a credential. Thus, only registered users owning
algebraic MACs can authenticate themselves to the server
while preserving their privacy. This approach suﬃciently
incorporates the symmetric feature of algebraic MACs with
that of anonymous password authentication, eliminates the
dependence of homomorphic encryption, and yields concep-
tually simple and provably secure constructions.

To construct practical APAKE protocols, we instantiate
an algebraic MAC scheme based on the q-SDH assump-
tion [11], and show that it is suf-rmva secure, weak pseudo-
random and tag-randomization simulatable, and allows la-
beled SE-NIZKs. For credential presentation, the Show algo-
rithm costs one exponentiation and one multi-exponentiation
to generate a presentation proof and the ShowVerify algorith-
m costs one multi-exponentiation for veriﬁcation, which are
optimal for the randomize-then-prove paradigm.

Based on the instantiated algebraic MAC scheme, we ob-
tain a highly practical APAKE protocol, which is denot-
ed by APAKE. Compared with the mechanisms speciﬁed by
ISO/IEC 20009-4 [43], APAKE provides signiﬁcant perfor-
mance advantages, and may invoke interest of the standard
community. An eﬃcient revocation mechanism for APAKE is
proposed, and the resulting protocol is denoted by APAKEr.
We integrate APAKE and APAKEr into the TLS protocol to
provide a mode of anonymous client authentication. For an
ECDSA-signed elliptic curve Diﬃe-Hellman ciphersuite, we
denote the ciphersuite with anonymous client authentication
by ECDHE3, and denote the ciphersuite with only server au-
thentication (resp., mutual authentication) by ECDHE1 (resp.,
ECDHE2). Let ECDHE4 be the ECDHE3 supporting revocation.
Based on OpenSSL library, we implemented in C the ECDHEi
ciphersuite at a 128-bit security level for i = 1,··· 4. HTTPS
connections per second supported by the server are report-
ed in Figure 1. When using the secp256r1 elliptic curve
and an Apache web server on a 2-core desktop computer,
the server can handle 953 ECDHE-ECDSA-AES128-GCM-SHA256
HTTPS connections with anonymous client authentication
per second for a 10 KB payload, and a factor 1.13x fewer
than ECDHE2. While the average connection time of ECDHE3
ciphersuite is 2.8 ms, that of ECDHE4 ciphersuite is 3.4 ms.
1.2 Related Work

To enhance users’ privacy, anonymous signature schemes,
such as group signatures [27], blind signatures [25] and Di-
rect Anonymous Attestation (DAA) [15] have been exten-

1180) for x $←

q-DDHI Assumption [10]. Given (g, gx, . . . , gxq
Z∗
p, it is hard to distinguish g1/x from a random element.
DDH Assumption. Given (g, gx, gy) for x, y $← Z∗
hard to distinguish gxy from a random element in G∗.
2.2 Non-Interactive Zero-Knowledge Proofs
Non-interactive zero-knowledge proofs (NIZKs) enable a
prover to prove in zero-knowledge that a statement x is in
a given language L deﬁned by an NP-relation R, i.e., L =
{x| ∃w s.t. R(x, w) = 1}. An NIZK could also be extended to
support (optional) labels, meaning that both a prover and
a veriﬁer are given a label (cid:96) as input.

p, it is

Figure 1: HTTPS connections per second supported by
the server at a 128-bit security level

sively investigated. DAA has been adopted by the Trusted
Computing Group and standardized by ISO/IEC [41, 42].

Anonymous credentials are introduced by Chaum [26],
and a series of schemes [19, 18, 16] have been proposed. Sev-
eral privacy-enhancing attribute-based credential systems
[51] have been developed, including IBM’s Idemix system
[38], and Microsoft’s U-Prove system [48].

In CCS’14, Chase et al. [24] constructed keyed-veriﬁcation
anonymous credentials based on two algebraic MACs, where
one is uf-cmva secure [29] in the generic group model [55],
and the other is uf-cmva secure under the DDH assumption.
Cesena et al. [22] proposed a solution for anonymous au-
thentication via integrating DAA into TLS, and obtained
a ciphersuite which has a factor about 25x fewer HTTPS
connections per second than ECDHE2, even if the compu-
tations of TPM are performed on a PC. Walker and Li [59]
presented a key exchange protocol with anonymous authen-
tication by combining DAA and the SIGMA family of key
exchange protocols from IPsec and IKE.

In CCS’15, Fett et al. [32] proposed the ﬁrst privacy-
respecting Single Sign-On system (SPRESSO) for users to
login web sites, and prove that it enjoys strong authenti-
cation and privacy properties. SPRESSO is a new system
built from scratch and involves a forwarder (FWD) to for-
ward messages from Identity Providers to Relying Parties.

2. BUILDING BLOCKS

In this section, we present the building blocks used in our
APAKE construction. Firstly, we describe the notation and
the assumptions used in this paper.

Notation. Throughout this paper, λ denotes the security
parameter, x $← S denotes x is sampled uniformly at random
from a set S, [n] denotes the set {1, . . . , n}. For an algorith-
m A, (y1, y2, . . . ) ← A(x1, x2, . . . ) denotes the process of
running A on input (x1, x2, . . . ) and getting (y1, y2, . . . ) as
output. A function f : N → [0, 1] is negligible if for any
positive c, we have f (λ) < 1/λc for suﬃcient large λ.
Let G be a multiplicative group of prime order p generated
by g, 1 be the identity element of G and G∗ denote G\{1}.
2.1 Assumptions
q-SDH Assumption [11]. Given (g, gx, . . . , gxq
Z∗

p, it is hard to output a pair(cid:0)c, g1/(x+c)(cid:1) for c ∈ Zp\{−x}.

) for x $←

A labeled NIZK should satisfy soundness and unbounded
zero-knowledge, where the former requires that no adversary
can prove any false statement, and the latter means that
there exists a simulator which is able to simulate any proof
for any statement x and any label (cid:96) without knowing the
witness w. If a labeled NIZK also provides simulation-sound
extractability, then it is called a labeled simulation-sound
extractable non-interactive zero-knowledge proof (SE-NIZK)
[36], where there exists an online extractor [34] works even if
the adversary sees simulated proofs and information about
previously extracted values. In this paper, we consider la-
beled SE-NIZKs in the random oracle model (ROM) [6], and
refer to [9] for a formal deﬁnition.
We adopt the notations of [20] to abstract labeled NIZKs.
Let Σ ← SPK{(witness) : statement}((cid:96)) denote a labeled
SE-NIZK on a label (cid:96), π ← NIZK{(witness) : statement}
be an NIZK. We write VerifySPK(statement, Σ, (cid:96)) for the pro-
cedure that veriﬁes a labeled SE-NIZK proof Σ, and write
VerifyNIZK(statement, π) for verifying an NIZK proof π.
2.3 Algebraic MAC
Following [24], an algebraic MAC scheme MAC is deﬁned
as a triple of algorithms MAC = (KeyGen, MAC, Verify) with
associated message space Mc and tag space T .
• KeyGen(1λ) : On input a security parameter 1λ, the key
generation algorithm outputs a secret key sk and a set of
parameters parmac which is an implicit input in the follow-
ing algorithms.

• MAC(sk, m) : On input the secret key sk and a message
m, the MAC algorithm outputs an authentication tag σ.
• Verify(sk, m, σ) : On input the secret key sk, a message
m and a tag σ, the deterministic veriﬁcation algorithm
outputs 1 if σ is valid on m under sk and 0 otherwise.

We assume that the key generation algorithm KeyGen satis-
ﬁes the key-parameter consistency [24], meaning that there
does not exist two keys sk and sk(cid:48) such that (parmac, sk) ∈
KeyGen(1λ), (parmac, sk(cid:48)) ∈ KeyGen(1λ) and sk (cid:54)= sk(cid:48).
Given the parameters parmac and a message-tag pair (m, σ),
we assume that there exists a proof system NIZK{(sk) :
Verify(sk, m, σ) = 1∧(parmac, sk) ∈ KeyGen(1λ)} proving that
σ is a valid tag on m under sk associated with parmac.

Unforgeability. Based on the security notions of algebra-
ic MACs [29, 24], we deﬁne a security notion of algebraic
MACs, i.e., strongly existentially unforgeable under random
message and chosen veriﬁcation queries attack (suf-rmva).
Deﬁnition 1. An algebraic MAC scheme MAC is said to
be suf-rmva secure if for any probabilistic polynomial time

0500100015002000250010B1KB10KB100KBECDHE1ECDHE2ECDHE3ECDHE4Connections per secondHTTP payloadsize1181(PPT) adversary A, there exists a negligible function ν such
that Advsuf-rmvaMAC

(A) def=

 (parmac, sk) ← KeyGen(1λ);

(m∗, σ∗) ← Amac(sk),verify(sk,·,·)(parmac) :
(m∗, σ∗) /∈ Q ∧ Verify(sk, m∗, σ∗) = 1

 ≤ ν(λ),

Pr

• Encpw(M ): On input a password pw ∈ D and a mes-
sage M ∈ Me, the encryption algorithm outputs a
ciphertext C ∈ C, which is also denoted by [M ]pw.

• Decpw(C): On input pw and a ciphertext C ∈ C, the

decryption algorithm outputs a plaintext M for C.

where for each query mac returns m $← Mc and σ ←
MAC(sk, m) and adds (m, σ) to the set Q which is initially
empty, for each query (m, σ) verify returns Verify(sk, m, σ).

We deﬁne a security notion of password-based encryption
called indistinguishability under equality test (IND-ET), where
an equality test oracle is used to model an adversary’s ability
deciding whether an online password guess is correct.

Weak pseudorandomness. Based on the deﬁnition of
weak pseudorandom functions (wPRFs) [46], we deﬁne a no-
tion of weak pseudorandomness of algebraic MACs. For sim-
plicity, we assume that the size of Mc is super-polynomial.
Deﬁnition 2. An algebraic MAC scheme MAC is said to
be weak pseudorandom if for any PPT adversary A, there
exists a negligible function ν, such that AdvwprMAC(A) def=

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12) (parmac, sk) ← KeyGen(1λ); b $← {0, 1};

m $← Mc; σ0 ← MAC(sk, m); σ1
b(cid:48) ← Amac(sk)(parmac, m, σb)

$← T ;

 − 1

b = b

(cid:48)

2 Pr

≤ ν(λ), where for each query, the mac oracle returns a ran-
dom m ∈ Mc and σ ← MAC(sk, m).

Credential Presentation. A tag σ is used as a creden-
tial in this paper. The credential presentation consisting
of (Show, ShowVerify) algorithms, is a procedure of proving
possession of a valid message-tag pair (m, σ), and is gener-
ally constructed via the randomize-then-prove paradigm.

In the randomize-stage, there are two algorithms Rerand
and Derand such that Rerand(σ) returns a randomized cre-
dential T and a randomness a, and Derand(T, a) returns σ.
For algebraic MACs, both a prover and a veriﬁer can com-
pute the same value V = fp(parmac, T, m, a) = fv(T, sk) us-
ing (m, a) and sk respectively, where fp and fv are eﬃciently
computable functions speciﬁed by a concrete mechanism.

In the prove-stage, the prover proves knowledge of (m, a)
such that fp(parmac, T, m, a) = V using a labeled SE-NIZK.
• Show(parmac, m, σ, (cid:96)) : On input parmac, a message-tag pair
(m, σ) and a label (cid:96) ∈ {0, 1}∗, the Show algorithm runs
(T, a) ← Rerand(σ), then computes V ← fp(parmac, T, m, a),
and executes Σ ← SPK{(m, a) : fp(parmac, T, m, a) = V }((cid:96)).
Finally, it outputs a presentation proof σC ← (T, V, Σ).
• ShowVerify(parmac, σC , (cid:96), sk) : On input parmac, a presen-
tation proof σC = (T, V, Σ), a label (cid:96) and the secret key
sk, algorithm ShowVerify computes ˜V ← fv(T, sk). If T
is correctly formed and VerifySPK((parmac, T, V ), Σ, (cid:96)) = 1
and V = ˜V , then ShowVerify returns 1, else it returns 0.

We say that the tag-randomization is simulatable, if there ex-
ists an eﬃcient algorithm TVSim that takes as input parmac,
and returns a pair (T (cid:48), V (cid:48)) such that V (cid:48) = fv(T (cid:48), sk) and T (cid:48)
has the same distribution as T produced by Rerand(σ).
2.4 Password-based Encryption

Let Me be a message space of super-polynomial size, C
be a ciphertext space. A password-based encryption scheme
PE with a password pw drawn uniformly at random from a
dictionary D, is deﬁned as PE = (Enc, Dec).

− 1

(cid:48)

(cid:34)

(cid:35)

b = b

Deﬁnition 3. A password-based encryption scheme PE is
said to be IND-ET secure, if for any PPT adversary A, there
exists a negligible function ν, we have Advind-etPE,D(A) def=
$← C;
C1 ← Encpw(M ); b(cid:48) ← AOet(M,·)(Cb)

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12) b $← {0, 1}; pw $← D; M $← Me; C0

2 Pr
≤ qet/|D| + ν(λ),
where Oet(M,·) takes as input a M(cid:48) ∈ Me and outputs 1 if
M = M(cid:48) and 0 otherwise, qet is the number of oracle queries.
2.5 Digital Signature
A digital signature scheme DS is deﬁned as a triple of
algorithms DS = (Gen, Sign, Ver). The key generation algo-
rithm Gen(1λ) returns the public and secret keys (pk, sk).
The signing algorithm Sign(sk, M ) returns a signature σ on
a message M . The veriﬁcation algorithm Ver(pk, M, σ) re-
turns 1 if σ is valid on M under pk and 0 otherwise.

The security notion of digital signatures is existential un-
forgeability under adaptive chosen message attacks (EUF-
CMA) [35], which states that for any PPT adversary A,
(A)
there exists a negligible function ν, such that Adveuf-cma

(cid:20) (pk, sk) ← Gen(1λ); (M∗, σ∗) ← ASign(sk,·)(pk) :

Ver(pk, M∗, σ∗) = 1 ∧ M∗ /∈ Q

def= Pr
≤ ν(λ), where for each query M , Sign returns a signature
σ on M and adds M to the set Q which is initially empty.

(cid:21)

DS

3. SECURITY MODEL

We formalise a security model for APAKE protocols in
the extra-storage setting, meaning that a client needs to
memorize a password and store a password-wrapped cre-
dential on some extra storage. The deﬁnitions of authen-
ticated key exchange (AKE) security and client authentica-
tion combine the security model for PAKE protocols by Bel-
lare, Pointcheval and Rogaway [4] and the model for anony-
mous authentication by Lindell [45]. The security model for
anonymity is based on indistinguishability-based deﬁnition
of anonymity for group signatures [3].
3.1 AKE Security and Client Authentication
Protocol participants. The participants of an APAKE
protocol P involve a set of clients C = {C1,··· , CN} and a
set of servers S. For simplicity, we assume that C is ﬁxed
and S contains only one server S, i.e., S = {S}.
Long-lived keys. The server S holds a long-term secret
SK for issuing credentials and authenticating himself and
publishes the system parameters params which are publicly
available for all parties. Each client Ci ∈ C holds a pass-
word pwi that is drawn independently and uniformly from

1182a dictionary D, and a password-protected credential credCi
generated by wrapping a credential issued by S with pwi.
Protocol execution. Each participant U ∈ C ∪ S is mod-
eled as a PPT Turing machine, and the δ-th instance of U is
denoted by U δ. An adversary A is given a set of password-
protected credentials Cred = {credi}i∈C and params, and is
assumed to have full control of the communication network.
Adversary A is a PPT algorithm with a distinguished query
tape. Queries written on this tape are answered according
to the description of P. The allowed queries are as below:
• Send(U, δ, M ): causes message M to be sent to instance
U δ for U ∈ C ∪ S. The instance U δ computes what the
protocol says to, and sends back the computation result
to A. If this query causes U δ to accept or terminate, it
will also be made visible to A.

• Execute(Ci, ρ, S, δ): carries out an honest execution of P
between a client instance C ρ
i and a server instance Sδ
and outputs the transcript of the execution. Although
this queries could be simulated with Send queries, sepa-
rate Execute queries are essential for dealing with oﬀ-line
dictionary attacks [4].

• Reveal(U, δ): returns the session key held by instance U δ.
• Test(U, δ): If instance U δ for U ∈ C ∪ S has accepted
and holds a session key skδ
U , the following happens. A bit
b ∈ {0, 1} is picked uniformly at random. If b = 1, skδ
is returned to A. Otherwise, a string picked at random
U
from the space of session keys is returned. Adversary A
is allowed to ask the Test query only once.

U , a session identiﬁer sidδ

Partnering. Since the anonymity property implies that
the server can only know that a client is a legitimate entity
from a group C, a partner identiﬁer of the server is the group
C. An instance U δ that accepts, holds a partner identiﬁer
pidδ
U (which is the transcript of the
whole protocol) and a session key skδ
U . A client instance
C ρ
i and a server instance Sδ are said to be partnered if both
accept, they hold (pidρ
S, skδ
S)
Ci
respectively, with sidρ
= S,
Ci
S = C and Ci ∈ C, and no other instance accepts with
pidδ
session identiﬁer equal to sidρ
Ci

S, sidδ
S, pidρ
Ci

, sidρ
Ci
= sidδ

, skρ
Ci
S, skρ
Ci

) and (pidδ

= skδ

.

Freshness. An instance U δ is said to be fresh unless either
a Reveal(U, δ) query occurs or a Reveal(V, ρ) query occurs,
where V ρ is the partner of U δ (if exists).
AKE security. Let SuccAKEP,D (A) be the event that A makes
a single Test(U, δ) query such that the instance U δ has ter-
minated and is fresh, and eventually outputs a bit b(cid:48) such
that b = b(cid:48), where b is chosen in the Test query. A protocol
P is said to be AKE secure, if for any PPT adversary A,
there exists a negligible function ν such that

AdvAKEP,D (A) def= 2 Pr[SuccAKEP,D (A)] − 1 ≤ qse/|D| + ν(λ),

where qse is the number of Send(S,·,·) queries.
Client authentication. Due to the anonymity require-
ment, an adversary against client authentication is declared
successful if it impersonates any client in the group C to the
server while the server fails to detect.
To capture the security of client authentication, A is pro-
vided the same information and abilities as that in the AKE

experiment, except that the Test query is ignored. Let
SuccC2SP,D(A) be the event that some server instance Sδ ac-
cepts but has no partner instance. We say that a protocol
P achieves clients-to-server authentication if for any PPT
adversary A, there exists a negligible function ν such that

AdvC2SP,D(A) def= Pr[SuccC2SP,D(A)] ≤ qse/|D| + ν(λ),

where qse is the number of Send(S,·,·) queries.
3.2 Anonymity

The anonymity property requires that the server cannot
determine whether two key exchange transactions are made
by the same client. To model anonymity against the server,
an adversary is given the server’s secret key as in [24].1 A Reg
oracle is also provided to model the registration protocol.
Protocol participants. The participants of a protocol P
consist of a set of clients C = {C1,··· , CN} and a server S.
Long-lived keys. An adversary A impersonating as the
server S is given the system parameters params and the se-
cret key SK . Each client Ci ∈ C holds a password pwi. Her
password-protected credential credCi is initiated as ⊥ and
will be generated in the execution of the protocol.

Protocol execution. At the beginning of the protocol, a
random bit b is chosen. A is provided the following queries:
• Reg(U, M ): If U ∈ C and credU = ⊥, the following hap-
pens. Message M is sent to client U , and the client com-
putes what the registration protocol says to and send-
s back the computation result to A.
If U accepts, a
password-protected credential is generated by U and as-
signed to credU which is sent to A.

• Send(U, δ, M ): causes message M to be sent to instance
U δ for U ∈ C and credU (cid:54)= ⊥. U δ computes what the
protocol says to, and the computation result is sent to A.
If i0, i1 ∈ C, credi0 (cid:54)= ⊥, credi1 (cid:54)= ⊥
• CH(i0, i1, δ, M ):
δ nor i1
δ is used, the following happens.
and neither i0
δ with password pwib and credib computes
The instance ib
what the protocol says to, and sends back the output of
the computation to A.

For any above query, if this query causes the client or the
instance to accept or terminate, this will also be shown to A.
A is allowed to make arbitrary number of queries to CH.
(A) be the event that A outputs
Anonymity. Let SuccanonP
a bit b(cid:48) such that b = b(cid:48), where the bit b was picked at the
beginning of the protocol. An APAKE protocol P is said to
be anonymous if for any PPT adversary A, there exists a
negligible function ν such that

AdvanonP

(A) def= 2 Pr[SuccanonP

(A)] − 1 ≤ ν(λ).

4. OUR APAKE PROTOCOL

In this section, we present a new APAKE protocol in the
extra-storage setting. It employs an algebraic MAC scheme
MAC = (KeyGen, MAC, Verify) with credential presentation
1A model allowing A to generate the server’s public key
is applicable if the domain parameters are selected from a
standard.
It does not undermine anonymity if a proof of
knowledge of SK is published.

1183algorithm (Show, ShowVerify), a password-based encryption
scheme PE = (Enc, Dec) and a digital signature scheme
DS = (Gen, Sign, Ver), which are described in Section 2. We
prove that our construction achieves AKE security, client
authentication and anonymity in the random oracle model.
4.1 Our Construction

Our construction consists of the following phases.

Setup. Given a security parameter λ, a server chooses a set
of domain parameters (G, p, g), where G is a group of prime
order p and generated by g. The server runs (parmac, sk)
← KeyGen(1λ) and (pk, sk) ← Gen(1λ). Let H1 : {0, 1}∗ →
Mc and H2 : {0, 1}∗ → {0, 1}κ be cryptographic hash func-
tions, where κ is the length of session keys. The server
publishes params ← (G, p, g, parmac, pk) as the set of system
parameters and sets SK = (sk, sk) as his secret key.

Registration. Each client needs to register to the server in
advance. The registration phase is executed over a secure
channel, which can be established, e.g., using TLS with the
server’s public key pk. The registration protocol is shown
in Figure 2, and details are described as follows.

1. A client sends her identity ID to the server and authenti-
cates herself to the server according to the server’s policy.

2. If the server accepts the registration request from client
ID, he does the following. The server computes a message
m ← H1(ID), and generates an authentication tag σ on
message m using sk. Then he generates an NIZK proof
π proving knowledge of sk such that Verify(sk, m, σ) = 1
and (parmac, sk) ∈ KeyGen(1λ) hold. Finally, the server
sends a credential σ and its proof π to the client.

3. When receiving a pair (σ, π), the client computes m ←
H1(ID), and veriﬁes if π is valid on statement (parmac, m, σ).
If π is valid, the client encrypts the credential σ with
her password pw into a ciphertext [σ]pw, and puts the
password-protected credential cred ← (ID, [σ]pw) to her
preferred storage with integrity-protection.

Login. To login the server, a client authenticates herself
to the server and establishes a session key with the server.
Suppose that the client has already obtained her password-
protected credential cred = (ID, [σ]pw). The login protocol
is shown in Figure 3, and details are described as follows.
1. Upon a login request, the server picks y $← Z∗

p and com-
putes Y ← gy. Then, he generates a signature σS on
message Y using sk, and sends (Y, σS) to the client.

2. When receiving a pair (Y, σS), the client veriﬁes whether
σS is valid on message Y under pk. If she accepts σS,
she computes m ← H1(ID), and decrypts ciphertext [σ]pw
with her password pw to recover credential σ. Then she
chooses x $← Z∗
p and calculates X ← gx. Next, the client
runs algorithm Show on input parmac, (m, σ) and a label
(cid:96) = (X, Y, σS) to generate a presentation proof σC =
(T, V, Σ). Finally, the client sends (X, σC ) to the server.
3. Upon receiving a pair (X, σC ), the server executes the
ShowVerify algorithm on input parmac, a presentation proof
σC , a label (cid:96) = (X, Y, σS) and sk to verify if σC is valid.
4. If they both do not abort, then the client and the server
can compute the same session key K via H2(Y, σS, X, σC ,
Y x) and H2(Y, σS, X, σC , X y) respectively.

4.2 Security Proofs
(denoted by P) in Theorems 1, 2, and 3 respectively.

We prove the security of the proposed APAKE protocol

Theorem 1

(AKE security). If MAC is suf-rmva se-
cure and weak pseudorandom, the tag-randomization is sim-
ulatable, SPK is a labeled SE-NIZK, PE is IND-ET secure,
DS is EUF-CMA secure, the DDH assumption holds in G,
and both H1 and H2 are random oracles, then our APAKE
protocol guarantees the AKE security. In particular, we have
AdvAKEP,D (A) ≤ qse/|D| + O
+ Advsuf-rmvaMAC
O (N|D|/|Me|) + Adveuf-cma

(cid:17)
(cid:16)
(cid:17)
s /p + N AdvwprMAC(B4)+
(B7)

Advuzk
(B3) + N 2/|Mc| + q2
(B6) + O

SPK(B1) + Advss-ext

SPK (B2)

(cid:16)

DS

N qcqsAdvDDHG

,

where qc is the maximum number of sessions per client, qs
is the maximum number of server sessions, Advuzk
SPK (resp.,
Advss-ext
SPK ) is the advantage for the unbounded zero-knowledge
(resp., simulation-sound extractability) of SPK,and AdvDDHG
is the advantage for the DDH assumption.

Proof. Firstly, we construct an algorithm CredSim who
can generate presentation proofs without knowledge of sk
and any credential using a zero-knowledge simulator Sim
for SPK. We also construct an algorithm CredExt who can
extract a message-tag pair from any presentation proof pro-
duced by A using an online extractor Ext for SPK.
CredSim(parmac, (cid:96)) : Given parmac and a label (cid:96), CredSim runs
(T (cid:48), V (cid:48)) ← TVSim(parmac) and Σ(cid:48) ← Sim((parmac, T (cid:48), V (cid:48)), (cid:96))
and outputs a presentation proof σC ← (T (cid:48), V (cid:48), Σ(cid:48)), where
TVSim is deﬁned in Section 2.3.

CredExt(parmac, σC , (cid:96)) : Given parmac, σC = (T, V, Σ) and a
label (cid:96), CredExt runs Ext((parmac, T, V ), Σ, (cid:96)).
If T is not
correctly formed or Ext returns invalid,2 CredExt outputs
invalid. Otherwise (Ext returns witness (m, a)), CredExt
computes σ ← Derand(T, a) and outputs (m, σ).
Let A be an adversary who aims at breaking the AKE secu-
rity of our APAKE protocol P. This proof will proceed via
a sequence of games G0, G1, . . . , G7. We will bound the de-
crease in A’s advantage between two successive games, and
use Advi(A) to denote the advantage of A in game Gi.
Game G0. This is the real game. Recall that A is given ac-
cess to Cred = {credi = (IDi, [σi]pwi )}N
i=1, params, and all
the oracles speciﬁed in the security model, where σi is a cre-
dential on mi = H1(IDi). We have AdvAKEP,D (A) = Adv0(A).
Game G1 (Simulate and Extract). This game is the same
as game G0, except that using CredSim to generate presen-
tation proofs for client instances, for each presentation proof
σC created by A, rejecting σC if CredExt outputs invalid
or Verify(sk, m, σ) = 0 for (m, σ) ← CredExt(parmac, σC , (cid:96)),
and accepting σC otherwise, where (cid:96) = (X, Y, σS).
Analysis. When CredExt(parmac, (T, V, Σ), (cid:96)) outputs (m, σ),
Verify(sk, m, σ) = 1 if and only if V = fv(T, sk). Moreover,
simulated T (cid:48) has the same distribution as real T . Thus, G1
has the same distribution as G0, except that the proofs of
SPK are simulated by Sim and Ext fails for extraction. Let B1
(resp., B2) be an algorithm that breaks the unbounded zero-
knowledge (resp., simulation-sound extractability) of SPK
by interacting with A. Then, we have
2If VerifySPK((parmac, T, V ), Σ, (cid:96)) = 0, Ext returns invalid.

1184Client (params, pw)

m ← H1(ID)

Abort if VerifyNIZK((parmac, m, σ), π) = 0

[σ]pw ← Encpw(σ)

Store cred ← (ID, [σ]pw)

secure channel
−−−−−−−−−→

ID

(σ, π)

←−−−−−−−−−

Server (params, SK )

m ← H1(ID), σ ← MAC(sk, m)

π ← NIZK(cid:8)(sk) : Verify(sk, m, σ) = 1 ∧
(parmac, sk) ∈ KeyGen(1λ)(cid:9)

Figure 2: Registration Protocol of Our APAKE Protocol

Client (params, pw, cred = (ID, [σ]pw))

Abort if Ver(pk, Y, σS) = 0

m ← H1(ID), σ ← Decpw([σ]pw)

x $← Z∗

p, X ← gx

σC ← Show(parmac, m, σ, (X, Y, σS))

K ← H2(Y, σS, X, σC , Y x)

(Y, σS)

←−−−−−−−−−−

Server (params, SK )

y $← Z∗
p, Y ← gy
σS ← Sign(sk, Y )

(X, σC )

−−−−−−−−−−→ Abort if ShowVerify(parmac, σC , (X, Y, σS), sk) = 0

K ← H2(Y, σS, X, σC , X y)

Figure 3: Login Protocol of Our APAKE Protocol

Adv0(A) = Adv1(A) + O

(cid:16)

Advuzk

SPK(B1) + Advss-ext

SPK (B2)

.

(cid:17)

i=1.

Game G2 (MAC Forgery). This game is the same as G1,
except that rejecting any presentation proof σC produced
by A such that CredExt(parmac, σC , (cid:96)) outputs (m, σ) and
(m, σ) /∈ {(mi, σi)}N
Analysis. We bound the decrease in A’s advantage from G1
to G2 using a reduction from the suf-rmva security of MAC.
Let B3 be an algorithm that has access to parmac, an oracle
mac and a veriﬁcation oracle verify. B3 executes just as in
G1 and interacts with A, with the following exceptions:
• B3 generates the system parameters params using parmac.
Then B3 makes N queries to oracle mac and obtains
$← Mc. For each i ∈ [N ], B3 pro-
{(mi, σi)}N
grams random oracle H1 such that H1(IDi) = mi.

i=1 for mi

• For each (m, σ) ← CredExt(parmac, σC , (cid:96)), B3 accepts σC

if and only if oracle verify(sk, m, σ) returns 1.

If A behaves diﬀerently between G1 and G2, there exists
a pair (m∗, σ∗) ← CredExt(parmac, σ∗
C , (cid:96)∗) such that oracle
verify(sk, m∗, σ∗) returns 1 and (m∗, σ∗) /∈ {(mi, σi)}N
i=1.
Then B3 can output (m∗, σ∗) as its forgery. Thus, we have

Adv1(A) = Adv2(A) + Advsuf-rmvaMAC

(B3).

Game G3 (Exclude Collisions). This game is the same
as G2, except that aborting if the event abort1 that mi = mj
for some i, j ∈ [N ] and i (cid:54)= j occurs, for each (m, σ) ←
CredExt(parmac, σC , (cid:96)) such that m = mi for some i ∈ [N ],
accepting σC iﬀ σ = σi, aborting if the event abort2 that the
messages from server instances encounter a collision occurs.
Analysis. Since H1 is a random oracle, Pr[abort1] ≤ N 2/|Mc|.
Clearly, Pr[abort2] ≤ q2

s /p. So we have

Adv2(A) ≤ Adv3(A) + N 2/|Mc| + q2

s /p.

Game G4 (Randomize Credentials). This game is the
same as G3, except that replacing [σi]pwi with [Ri]pwi for
each i ∈ [N ] where Ri
$← T , for each (m, σ) ← CredExt(parmac,

σC , (cid:96)) such that m = mi for some i ∈ [N ], accepting σC if
and only if σ = Ri.
Analysis. We bound the decrease in A’s advantage from
G3 to G4 using a reduction from the weak pseudorandom-
ness of MAC. We use a hybrid argument to complete the
reduction. For each j ∈ [N ] ∪ {0}, let game G3,j be the
same as G3, except that setting credi ← (IDi, [Ri]pwi ) for
each i ∈ [j] where Ri
$← T , and using {Ri}i∈[j] to veri-
fy the presentation proofs produced by A. It is clear that
G3,0 and G3,N are the same as G3 and G4 respectively. If
A behaves diﬀerently between G3 and G4 with probabili-
ty , then A must behave diﬀerently between G3,j−1 and
G3,j for some j ∈ [N ] with probability at least /N . We
can construct an algorithm B4 which breaks the weak pseu-
dorandomness of MAC with probability at least /N via
interacting with A. B4 is given parmac, a challenge (m∗, σ∗),
and an oracle mac. B4 makes N − j mac queries and ob-
i=j+1. Then, B4
tains N − j message-tag pairs {(mi, σi)}N
programs random oracle H1 such that H1(IDj) = m∗ and
H1(IDi) = mi for each i ∈ {j + 1, . . . , N}. B4 also picks
i=1 in T . Next, B4 executes as
j − 1 random values {Ri}j−1
in G3, except that B4 sets credi ← (IDi, [Ri]pwi ) for each
(cid:1)
i ∈ [j − 1], credj ← (IDj, [σ∗]pwj ) and credi ← (IDi, [σi]pwi )
to verify the presentation proofs produced by A. If σ∗ =
MAC(sk, m∗), B4 behaves exactly as in G3,j−1. Otherwise
(i.e., σ∗ is uniformly random in T ), B4 behaves exactly as
in G3,j. Then, Adv3,j−1(A) = Adv3,j(A) + AdvwprMAC(B4).
Thus, we have Adv3(A) ≤ Adv4(A) + N AdvwprMAC(B4).
Game G5 (Randomize Ciphertexts). This game is the
same as G4, except that replacing [Ri]pwi with a random
ciphertext Ci ∈ C for each i ∈ [N ], and rejecting all client
messages created by A.
Analysis.
In game G4, since Ri is uniform at random in
Me = T for each i ∈ [N ] and presentation proofs for client
instances are simulated by CredSim, the only way for guess-
ing passwords is to amount on-line dictionary attacks by
making Send queries to the server. Thus, we can bound
the decrease in A’s advantage from G4 to G5 using a re-

for each i ∈ [N ]\[j], and B4 uses (cid:0){Ri}j−1

i=1 , σ∗,{σi}N

i=j+1

1185duction from the IND-ET security of PE. The reduction is
completed via a hybrid argument. For each j ∈ [N ] ∪ {0},
let game G4,j be the same as G4, except that replacing
[Ri]pwi with a random ciphertext Ci ∈ C for each i ∈ [j],
and rejecting any client message (X, σC ) produced by A if
(m, σ) ← CredExt(parmac, σC , (cid:96)) and m ∈ {mi}j
i=1, where
(cid:96) = (X, Y, σS). Clearly, G4,0 and G4,N are the same as
If A behaves diﬀerently between
G4 and G5 respectively.
G4,j−1 and G4,j for some j ∈ [N ] with probability j, then
we can construct an algorithm B5,j that breaks the IND-
ET security of PE via interacting with A with almost the
same probability. Speciﬁcally, B5,j is given a challenge ci-
phertext C and an equality test oracle Oet(M,·), where M
$← C for
is a random message in Me. Then B5,j picks Ci
$← Me for each i ∈ [N ]\[j]. B5,j
each i ∈ [j − 1] and Ri
executes just as in game G4, with the following exceptions:
• For each i ∈ [N ], B5,j sets the ciphertext in credi as Ci if

i ∈ [j − 1], C if i = j, and [Ri]pwi if i ∈ [N ]\[j].
• For each (m, σ) ← CredExt(parmac, σC , (cid:96)) such that m =
mi for some i ∈ [N ] where σC is produced by A, B5,j
rejects σC if i ∈ [j − 1], or i = j ∧ Oet(M, σ) = 0, or
i ∈ [N ]\[j] ∧ σ (cid:54)= Ri, and accepts σC otherwise.

If C = Encpw(M ) where pw acts as the password pwj of client
IDj, then B5,j behaves exactly as in game G4,j−1. Otherwise
(i.e., C is uniform at random in C), Oet(M,·) returns 0 for all
queries with probability at least 1 − (|D| + 1)/|Me|, since C
is independent from M and the probability that there exists
a pw(cid:48) ∈ D such that Decpw(cid:48) (C) = M is at most |D|/|Me|.
Thus, B5,j behaves exactly as in game G4,j with probability
at least 1 − (|D| + 1)/|Me|. As a result, we have

Adv4(A) − Adv5(A) =

(Adv4,j−1(A) − Adv4,j(A)) ≤

N(cid:88)

(cid:19)

(cid:18)

N(cid:88)

j=1

Advind-etPE,D(B5,j) +

j=1

|D| + 1
|Me|

≤ qse|D| + O

(cid:19)

(cid:18) N|D|

|Me|

,

where the total number of queries to Oet is bounded by qse.
Game G6 (Signature Forgery). This game is the same
as G5, except for aborting if the event abort3 that the ﬁrst
time some client instance accepts after receiving a signature
S on Y ∗ that was not output by a server instance occurs.
σ∗
Analysis. Game G6 has the same distribution as G5 if
abort3 does not occur. Thus, the diﬀerence between G5
and G6 can be bounded by a reduction from the EUF-
CMA security of DS. Let B6 be an algorithm that break-
s the EUF-CMA security of DS via interacting with A.
B6 is given a public key pk∗, and sets pk∗ as the serv-
er’s public key. B6 simulates the protocol execution as in
G5, except that B6 generates signatures for all server in-
If abort3 occurs,
stances by querying the signing oracle.
B6 outputs (Y ∗, σ∗
S) as its forgery for DS. Thus, we have
Adv5(A) = Adv6(A) + Adveuf-cma
Game G7 (Randomize Session Key). This game is the
same as G6, except for replacing session key in test session
˜U ˜δ and its partner ˜V ˜ρ with an independently random string.
Analysis. In this game, all client messages created by A are
rejected, and A cannot replay presentation proofs from client
instances since a message (Y, σS) from any server instance

(B6).

DS

could act as a nonce and collision of the nonces is excluded in
game G3. Thus, we can bound the decrease in A’s advantage
from G6 to G7 using a reduction from the DDH assumption
as follows. We construct an algorithm B7 that breaks the
DDH assumption by interacting with A. B7 is given an
instance (g, gu, gv, W ) of DDH and aims to distinguish W =
guv from a random element W ∈ G∗. B7 simulates the
protocol execution as in G6 with the following exceptions.
B7 distinguishes two cases. For case 1 that the test session
is a server session, B7 picks i∗ $← [qs] and aborts if i∗ (cid:54)= ˜δ.
If B7 does not abort, it sets Y = gv and X = gu as the
ephemeral Diﬃe-Hellman (DH) values for ˜U ˜δ and its partner
˜V ˜ρ respectively. For case 2 that the test session is a client
session, B7 picks ( ˆU , ˆδ, j∗) $← [N ] × [qc] × [qs], and aborts
if ( ˆU , ˆδ) (cid:54)= ( ˜U , ˜δ) or client instance ˜U ˜δ receives the message
that is not the output of the j∗-th session of the server. If B7
does not abort, it sets X = gu as the ephemeral DH value
for ˆU ˆδ and Y = gv as the one for the j∗-th server session.
In both cases, B7 can respond all Reveal queries (including
the sessions for Y = gv) by computing the session keys using
ephemeral DH exponents at the client side, since all accepted
messages from clients are generated by B7. For both cases,
B7 returns H2(Y, σS, X, σC , W ) as the session key of the test
session. If B7 does not abort, then B7 behaves exactly as
in G6 if W = guv, and behaves exactly as in G7 if W is
uniformly random in G∗ since H2 is a random oracle. Thus,

Adv6(A) = Adv7(A) + O

N qcqsAdvDDHG

(B7)

.

(cid:16)

(cid:17)

Overall, we obtain the bound claimed in the theorem.

Theorem 2

(Client authentication). Our APAKE
protocol P obtains clients-to-server authentication, provided
that MAC is suf-rmva secure and weak pseudorandom, the
tag-randomization is simulatable, SPK is a labeled SE-NIZK,
PE is IND-ET secure, and H1 is modeled as a random ora-
cle. In particular, we have
AdvC2SP,D(A) ≤ qse/|D| + O
+ Advsuf-rmvaMAC
+ O (N|D|/|Me|) .

(cid:17)
SPK (B2)
s /p + N AdvwprMAC(B4)

Advuzk
(B3) + N 2/|Mc| + q2

SPK(B1) + Advss-ext

(cid:16)

Proof. (Sketch) This proof is proceeded by a series of
games G0, G1, . . . , G5, where G0 is the real game for client
authentication, and G1, . . . , G5 are essentially the same as
that in the proof of Theorem 1. In game G5, all client mes-
sages produced by A are rejected, and A cannot replay pre-
sentation proofs from client instances since a message (Y, σS)
from any server instance could act as a nonce and collision
of the nonces is excluded in game G3. Thus, A cannot au-
thenticate itself to the server in game G5.

Theorem 3

(A) = Advsound

(Anonymity). If NIZK is sound, SPK is
unbounded zero-knowledge, the tag-randomization is simu-
latable, and KeyGen satisﬁes key-parameter consistency, then
our protocol P is anonymous. In particular, we have
SPK(B2).

AdvanonP
NIZK is the advantage for the soundness of NIZK.
Proof. Let A be an adversary that breaks anonymi-
ty of P. This proof will proceed via a series of games
G0, G1, G2, G3, where G0 is the real game. By Advi(A) we
denote A’s advantage in Gi, and AdvanonP

NIZK (B1) + Advuzk

(A) = Adv0(A).

where Advsound

1186Game G1 (Soundness). This game is the same as G0, ex-
cept for aborting if the ﬁrst time some client accepts a proof
π on a statement (parmac, m, σ) such that Verify(sk, m, σ) = 0.
Analysis. Since KeyGen satisﬁes key-parameter consistency,
there exists the unique secret key sk such that (parmac, sk) ∈
KeyGen(1λ). Thus, if Verify(sk, m, σ) = 0, then (parmac, m, σ)
is a false statement on NIZK. Then, we can construct an
algorithm B1 that breaks the soundness of NIZK by inter-
acting with A.
If A behaves diﬀerently between G0 and
G1, then B1 can ﬁnd a valid proof π on a false statement
(parmac, m, σ) such that Verify(sk, m, σ) = 0. Thus, we have
Adv0(A) = Adv1(A) + Advsound
Game G2 (Simulate Proofs). This game is the same as
G1, except for using the zero-knowledge simulator Sim to
generate a proof w.r.t. SPK for each challenge query.

NIZK (B1).

Analysis. G2 behaves exactly like G1, except for the sim-
ulation of the proofs for SPK. From the unbounded zero-
knowledge property of SPK, we have Adv1(A) = Adv2(A) +
SPK(B2), where B2 is an algorithm that breaks the un-
Advuzk
bounded zero-knowledge of SPK by interacting with A.

Game G3 (Simulate Tag-Randomization). This game
is the same as G2, except that for each challenge query re-
placing (T, V ) with (T (cid:48), V (cid:48)) ← TVSim(parmac).
Analysis. In G3, any message-tag pair (m, σ) accepted by
any client ID satisﬁes Verify(sk, m, σ) = 1 where m = H1(ID).
Thus, (T (cid:48), V (cid:48)) simulated by TVSim has the same distribu-
tion as real (T, V ). Then, we have Adv2(A) = Adv3(A).
Overall, we obtain the bound claimed in the theorem.

5.

INSTANTIATION OF APAKE

In this section, we instantiate the building blocks used
in our APAKE construction. In particular, we give an ex-
ample of suf-rmva secure and weak pseudorandom algebraic
MACs with eﬃcient labeled SE-NIZKs, which is a pairing-
free variant of the weak Boneh-Boyen signature scheme [11].
We denote the algebraic MAC scheme by MACSDH. The
password-based encryption scheme PE is instantiated with
an example recommended by Bellare and Rogaway [5] for
the AuthA mechanism of IEEE P1363.2 standard [39], which
satisﬁes the IND-ET security in the ROM. We use ECDSA
to instantiate digital signature scheme DS. Our instantia-
tion assumes that MACSDH, PE, DS and key exchange use
the same domain parameters par = (G, p, g).

When applying the instantiations of the building blocks to
the APAKE construction described in Section 4, we obtain a
highly-eﬃcient APAKE protocol, which is denoted by APAKE.
5.1 An SDH-based Algebraic MAC

The construction of MACSDH is described as follows.

KeyGen(1λ) takes as input a security parameter 1λ, chooses
the group parameters (G, p, g) such that p is a 2λ-bit prime,
picks γ $← Z∗
p, computes w ← gγ, and outputs sk = γ
and parmac = (G, p, g, w). We assume that (G, p, g) is an
implicit input in all the following algorithms.
MAC(sk, m) takes as input sk = γ and a message m ∈
Zp\{−γ}, computes A ← g1/(γ+m), and outputs σ ← A.
Verify(sk, m, σ) takes as input sk = γ, a message m and a

tag σ = A, and outputs 1 if Aγ+m = g and 0 otherwise.

Using the techniques in [11], we can prove that MACSDH
is suf-rmva secure under the q-SDH assumption. Using the
techniques in [11, 30], we can also prove that MACSDH is
weak pseudorandom under the q-DDHI assumption. The
detailed proofs can be found in Appendix A.

It is easy to see that KeyGen satisﬁes the key-parameter
consistency, as (g, w) uniquely determines the secret key γ.
The MACSDH allows an eﬃcient proof system NIZK{(γ) :
Aγ = A−mg ∧ gγ = w}, which is constructed using the Fiat-
Shamir heuristic [33] to transform the corresponding Sigma
protocol, and is shown as follows.
• On input a statement (g, w, m, A) and a witness γ, the
prover picks r $← Zp, computes R1 ← Ar, R2 ← gr, c ←
H3(g, w, m, A, R1, R2) and s ← r + cγ mod p. Finally, it
outputs a proof π = (c, s).

• The veriﬁcation algorithm VerifyNIZK takes as input a state-
ment (g, w, m, A) and a proof π = (c, s), and calculates
c(cid:48) ← H3(g, w, m, A, As+cmg−c, gsw−c). Then it outputs 1
if c = c(cid:48) and 0 otherwise.

Using the techniques in [50], one can prove that the NIZK is
sound and unbounded zero-knowledge in the ROM.

Credential Presentation. The credential presentation al-
gorithms Show and ShowVerify for MACSDH are constructed
by SPK{(m, a) : T −mga = V }((cid:96)) for T = Aa, and the SPK
is instantiated by Fiat-Shamir transformed Sigma protocol.
• Show(m, σ, (cid:96)) : On input a message m, a credential σ = A
and a label (cid:96), Show picks a $← Z∗
p and computes T ← Aa.
$← Zp, computes R ← T −rm gra , c ←
Then it picks rm, ra
H4(g, T, R, (cid:96)), sm ← rm + cm mod p and sa ← ra + ca
mod p, and sets Σ = (c, sm, sa). Finally, Show outputs a
presentation proof σC = (T, Σ).

• ShowVerify(σC , (cid:96), sk) : On input a presentation proof σC =
(T, (c, sm, sa)), a label (cid:96) and sk = γ, ShowVerify computes
V ← T γ, R(cid:48) ← T −sm gsa V −c and c(cid:48) ← H4(g, T, R(cid:48), (cid:96)).
ShowVerify returns 1 if T (cid:54)= 1 and c = c(cid:48), and 0 otherwise.

It is easy to see that Rerand, Derand, fp and fv are spec-
iﬁed as follows: Rerand(A) picks a $← Z∗
p, computes T ←
Aa, and outputs (T, a); Derand(T, a) outputs A ← T 1/a;
fp(parmac, T, m, a) = T −mga and fv(T, sk) = T γ.

The simulator TVSim is constructed as follows: given
parmac = (G, p, g, w), TVSim chooses t
p, computes
T (cid:48) ← gt and V (cid:48) ← wt, and outputs (T (cid:48), V (cid:48)). Note that
V (cid:48) = wt = (T (cid:48))γ and T (cid:48) has the same distribution as T
generated by Rerand(A).

$← Z∗

To obtain better eﬃciency, we do not involve V to σC
following [24]. The reason behind this is that an online ex-
tractor Ext for SPK without knowing V can be obtained in
the combined random oracle and generic group model fol-
lowing along the lines of [53, 56, 24]. The zero-knowledge
simulator Sim for SPK can be constructed as follows: giv-
en a statement (g, T, V ) and a label (cid:96), Sim randomly picks
c, sm, sa ← Zp and programs the random oracle H4 such
that H4(g, T, R, (cid:96)) = c with R = T −sm gsa V −c, and outputs
Σ ← (c, sm, sa). Overall, the SPK is a labeled SE-NIZK.
Eﬃciency of Credential Presentation. For anonymous
credentials, a presentation proof is usually generated using

1187Table 1: Comparison of APAKE Protocols

APAKE

[60]
[54]

[62]

APAKE

Computation overhead
Server
Client

4EG

5EG + 1Dec
8EG1 + 1E2G1
1E5G1
+ 2P
3EG + 2E2G

+

(N + 3)EG

(N +5)EG +N Enc
3EG1 + 3E2G1
+
1E5G1
+ 2P
3EG + 1E2G

Comm.

N + 4
2N + 8

18

8

Legend: N is the total number of users, EG denotes one expo-
nentiation in G, EnG denotes a multi-exponentiation of n values in
G, P represents a bilinear pairing operation, Enc (resp., Dec) de-
notes a symmetric-key encryption (resp., decryption) operation,
and Comm. denotes the communication overhead.

the randomize-then-prove paradigm, where a credential is
ﬁrst randomized, and the randomized credential is then pre-
sented with a zero-knowledge proof. In general, the ﬁrst step
costs at least one exponentiation and the second step cost-
s at least one multi-exponentiation, and the veriﬁcation of
presentation proofs costs at least one multi-exponentiation.
Note that R(cid:48) can be computed via T −(sm+cγ)gsa in an ex-
ecution of ShowVerify. Therefore, the eﬃciency of MACSDH-
based credential presentation is optimal.
5.2 An Example Password-Based Encryption
Let H : D → G∗ be a cryptographic hash function mod-
eled as a random oracle. An example of password-based
encryption PE is described as follows.
Encpw(M ) takes as input pw and a message M ∈ G∗, com-
putes C ← M · H(pw), and outputs C.
Decpw(C) takes as input pw and a ciphertext C ∈ G, com-
putes M ← C/H(pw), and outputs M .
One can easily prove this example of PE is IND-ET secure,
since the outputs of H are uniformly random.
5.3 Comparison of APAKE Protocols

We compare our protocol APAKE with the mechanisms spec-
iﬁed by ISO/IEC 20009-4 in Table 1. For computation over-
head, we only list the most time-consuming operations, and
count the number of group elements in the login protocol.
The output size of a hash function or a MAC algorithm is
counted as a group element.

Table 1 shows that APAKE is much more eﬃcient than the
mechanisms [60, 54] in the password-only setting in terms
of computation cost at the server side and communication
overhead, and APAKE is also much more eﬃcient than the
mechanism [62] in the extra-storage setting.

6. SUPPORT OF REVOCATION

We present an accumulator-based revocation mechanism
for APAKE, which enables non-membership proofs to be ver-
iﬁed by a server with a secret key ˜γ.
p, computes ˜w ← g ˜γ, and
A server picks a random ˜γ ∈ Z∗
adds ˜w to params and ˜γ to sk. The server maintains a
for a revoked user IDi and ˜Vi = g1/((cid:81)i
revocation list RL = {(mi, ˜Vi)}r
i=1, where mi = H1(IDi)
j=1(˜γ+mj )) for each
i ∈ [r]. Let ˜V0 = g. For a registration request from a client
ID, the server issues a witness Wr ← ˜V 1/(˜γ+m)
along with
∧ g ˜γ = ˜w}, and the client
˜π ← NIZK{(˜γ) : W ˜γ
stores (ID, [A]pw, Wr), where m = H1(ID).

r = ˜VrW −m

r

r

Client
ClientHello

Server

-------->

ServerHello
Certificate(cid:63)
ServerKeyExchange(cid:63)
CertificateRequest(cid:63)
ServerHelloDone

<--------

Certificate(cid:63)
ClientKeyExchange
CertificateVerify(cid:63)
[ChangeCipherSpec]
Finished

Application Data

-------->

[ChangeCipherSpec]
Finished

<--------
<-------> Application Data

Figure 4: TLS Message Flows

Witness Update. Given the current revocation list RL =
{(mi, ˜Vi)}r(cid:48)
i=1, an un-revoked user ID can update oﬀ-line her
witness Wr iteratively with m = H1(ID) as follows:
Wj+1 ← (Wj/ ˜Vj+1)1/(mj+1−m), for each r ≤ j ≤ r

(cid:48) − 1.

r with a random z ∈ Z∗

Non-membership Proof. To prove that she has not been
revoked, the client computes m ← H1(ID), randomizes the
witness as ˜T ← W z
p, and generates
˜Σ ← SPK{(m, z) : ˜T −m ˜V z
Note that a revoked user IDj+1 (r ≤ j < r(cid:48)) cannot update
her witness, as the denominator mj+1 − m = 0. Using the
technique in [11, Lemma 3.2], we can prove that no revoked
user can forge a witness under the q-SDH assumption.

r = ˆV }, where ˆV = ˜T ˜γ.

To support revocation, we extend the Show and ShowVerify
algorithms in Section 5.1 by replacing the underlying SPK
r = ˆV }((cid:96)). By
with SPK(cid:48){(m, a, z) : T −mga = V ∧ ˜T −m ˜V z
APAKEr we denote the APAKE protocol with above revocation.

7. APPLICATION OF APAKE TO TLS

We integrate APAKE into the TLS protocol to provide a
TLS mode of server authentication with anonymous client
authentication, where a client holding a password-wrapped
credential and the password can authenticate herself to the
server without revealing her identity, and denote the ECDSA-
signed elliptic curve Diﬃe-Hellman ciphersuite with anony-
mous client authentication by ECDHE3.

Since a labeled SE-NIZK is also a signature of knowledge
[23] where a label (cid:96) is the message to be signed, we consider
Show and ShowVerify for MACSDH as a signing algorithm
and a veriﬁcation algorithm respectively, where (m, A) is
the secret key for generating signatures, and a signature σC
on message (cid:96) is veriﬁed using sk. We refer to the “signature
algorithm” as SigMAC, where SigMAC = (Show, ShowVerify).
We also integrate APAKEr into TLS in the same way as
APAKE except for using the extended (Show, ShowVerify) to
support revocation and additionally publishing Sign(sk, ˜w).
We denote the resulting ciphersuite by ECDHE4.
7.1 Integration into TLS

Assume that the server holds a certiﬁcate certS on his
ECDSA public key pk. The set of domain parameters par =

1188Table 2: Performance of HTTPS using Apache with OpenSSL

Connections / second

10 B payload
2043.678 (1.06)
1133.08 (1.50)
1007.308 (2.25)

1 KB payload
2022.282 (1.61)
1129.442 (1.69)
999.994 (1.74)

10 KB payload
1833.658 (1.80)
1075.69 (0.48)
953.698 (1.28)

100 KB payload
943.266 (1.09)
718.736 (0.21)
661.652 (1.02)

time (ms)
1.54 (0.05)
2.39 (0.05)
2.80 (0.01)

Connection Handshake Client
Auth.
None

(bytes)

Ciphersuite

ECDHE1

ECDHE2

ECDHE3

ECDHE4

2200
3806
4078

plain sigs
anon. sigs
anon. sigs
w/revoc.

863.712 (1.49)

860.364 (1.32)

826.032 (0.92)

602.928 (0.24)

3.40 (0.02)

4179

Legend: mean, (std. dev.) in columns 2-6; Client Auth. represents the type of signatures used to provide client authentication.

(G, p, g) is selected from a trusted published source such as
a standard, and its identiﬁer is denoted by parid. The serv-
er acts as a Certiﬁcation Authority to generate an ECDSA
signed certiﬁcate certmac on a dummy entity “apake” and
public key w. Then certmac is published and used by all
clients who provide anonymous authentication with SigMAC.
In the registration phase, each client should ﬁrst check the
validity of certS and certmac, and then stores certmac along
with a password-wrapped credential (ID, [A]pw).

When using the X.509 certiﬁcate with ASN.1 data type,

the certiﬁcate certmac is deﬁned as follows:

Certificate ::= SEQUENCE {
toBeSigned TBSCertificate,
algorithmIdentifier {ECDSA},
encrypted certsig,
... }
TBSCertificate ::= SEQUENCE { ...
subjectPublicKeyInfo SubjectPublicKeyInfo,
... }
SubjectPublicKeyInfo ::= SEQUENCE {
algorithm {SigMAC},
subjectPublicKey parid||w,
... },
where SigMAC speciﬁes the SigMAC = (Show, ShowVerify)
algorithm, parid||w denotes the bit-string of (parid, w),
certsig = Sign(sk, TBSCertificate), and the omitted ﬁeld-
s are speciﬁed following the X.509 speciﬁcation.

Below, we show how to integrate the APAKE into TLS [28].
We assume that a client has already recovered the “secret
key” (m = H1(ID), A) from a password-protected creden-
tial (ID, [A]pw) with her password pw, before initiating the
TLS protocol. The ciphersuite ECDHE3 is the same as the
ECDSA-signed elliptic curve Diﬃe-Hellman ciphersuite with
client authentication using ECDSA signatures, except that
the messages marked with rectangles in Figure 4 are dif-
ferent. The server adds apake and (SigMAC, SHA256) to the
ﬁelds of CertificateRequest, which is showed as follows:

struct {
ClientCertificateType {...,apake};
SignatureAndHashAlgorithm {...,(SigMAC, SHA256)};
... } CertificateRequest;

A client then utilizes certmac in Certificate, and invokes
the SigMAC to sign the handshake messages with the “secret
key” (m, A) and generates CertificateVerify. The server
can check the validity of certmac, and verify the validity of
a “signature” σC using SigMAC and his secret key sk.
7.2 Implementation

We implemented in C the ECDHE3 and ECDHE4, based on
the OpenSSL v1.0.2g. For comparison, we also implemented

the ECDSA-signed elliptic curve Diﬃe-Hellman ciphersuite
with only server authentication (resp., mutual authentica-
tion), which is denoted by ECDHE1 (resp., ECDHE2) and is
included in TLSv1.2. Our implementation take places at a
128-bit security level, and uses the secp256r1 curve. Apart
from digital signature algorithms for client authentication,
the ciphersuites ECDHE1, ECDHE2, ECDHE3 and ECDHE4 share
the same ingredients, i.e., ECDHE-ECDSA-AES128-GCM-SHA256,
where AES128-GCM denotes authenticated encryption (with
associated data) using AES-128 in GCM (Galois Counter
Mode). In the implementation of ECDHE4, we assume that
the client has already updated oﬀ-line her witness Wr.

Experiment environment. Our experimental results are
obtained in two desktop computers. The “client” computer
has an Intel i5-3470 processor with 4 cores running at 3.2
GHz each. The “server” computer has an Intel Core2 Duo
E7300 processor with 2 cores running at 2.66 GHz each.
Both computers run the operating system of Ubuntu 15.04.
Our softwares were both complied for the x86 64 architec-
ture with -O2 optimizations using g++ 4.9.2.
7.3 Performance Evaluation

The performance of ECDHE1, ECDHE2, ECDHE3 and ECDHE4
within the context of an HTTPS connection is shown in
Table 2. The approach for analyzing the performance in
TLS/HTTPS follows that of Gupta et al. [37]. Besides, we
follow the method of [13] to achieve the experimental data.
The client and server computation platforms were connected
over an isolated local area network with less than 1 ms ping
time. The server was running Apache httpd 2.4.20 with the
prefork multi-threading module.

The ﬁrst section of Table 2 shows the number of simulta-
neous connections supported by the server. The client com-
puter was running siege 4.0.1 tool3 to create many HTTP
connections in parallel for TLS. We did separate tests in the
diﬀerent HTTP payloads (10 bytes, 1 KB=1024 bytes, 10
KB, and 100 KB), so that simulating a variety of web page
sizes. Each test was run for 100 seconds, and the results
reported in Table 2 are the average of 5 runs with standard
deviation listed in parentheses. During all tests, the client
computer and network conﬁguration was enough to ensure
that the server’s processor had at least 95% utilization. Note
that session resumption was disabled. The second section of
this table reports the average time which is required for a
client to establish a connection, and is measured by using
Wireshark from when the client opens the TCP connection
to the server’s IP address to when the client starts to re-
ceive the ﬁrst packet of application data. The third section
of Table 2 reports the size of the handshakes.

3http://download.joedog.org/siege/siege-4.0.1.tar.gz

1189Table 2 shows that ECDHE3 obtains between a factor 1.43-
2.03x fewer HTTPS connections per second than ECDHE1,
and between a factor 1.09-1.13x fewer HTTPS connections
per second than ECDHE2. The ECDHE4 obtains between a
factor 1.10-1.17x fewer HTTPS connections per second than
ECDHE3. The average connection time and the size of the
handshakes for ECDHE3 and ECDHE4 are attractive.
8. REFERENCES
[1] https://krebsonsecurity.com/2016/03/crooks-steal-

sell-verizon-enterprise-customer-data/.

[2] M. Abdalla. Password-based authenticated key exchange:

An overview. In Provable Security 2014, volume 8782 of
LNCS, pages 1–9. Springer, 2014.

[3] M. Bellare, D. Micciancio, and B. Warinschi. Foundations

of group signatures: Formal deﬁnitions, simpliﬁed
requirements, and a construction based on general
assumptions. In EUROCRYPT 2003, pages 614–629.

[4] M. Bellare, D. Pointcheval, and P. Rogaway. Authenticated

key exchange secure against dictionary attacks. In
EUROCRYPT 2000, pages 139–155. Springer.

[5] M. Bellare and P. Rogaway. The AuthA protocol for

password-based authenticated key exchange. Contribution
to IEEE P1363.

[6] M. Bellare and P. Rogaway. Random oracles are practical:

A paradigm for designing eﬃcient protocols. In ACM
CCS’93, pages 62–73. ACM Press, 1993.

[7] S. M. Bellovin and M. Merritt. Encrypted key exchange:

password-based protocols secure against dictionary attacks.
In IEEE Computer Society Symposium on Research in
Security and Privacy, pages 72–84, 1992.

[8] F. Benhamouda, O. Blazy, C. Chevalier, D. Pointcheval,

and D. Vergnaud. New techniques for SPHFs and eﬃcient
one-round PAKE protocols. In CRYPTO 2013, volume
8042 of LNCS, pages 449–475. Springer, 2013.

[9] D. Bernhard, M. Fischlin, and B. Warinschi. Adaptive

proofs of knowledge in the random oracle model. In
Public-Key Cryptography - PKC 2015, pages 629–649.

[10] D. Boneh and X. Boyen. Eﬃcient selective-ID secure
identity based encryption without random oracles. In
EUROCRYPT 2004, pages 223–238. Springer-Verlag.

[11] D. Boneh and X. Boyen. Short signatures without random

oracles. In EUROCRYPT 2004, pages 56–73.

[12] D. Boneh, X. Boyen, and H. Shacham. Short group

signatures. In M. Franklin, editor, CRYPTO 2004, volume
3152 of LNCS, pages 41–55. Springer-Verlag, 2004.
[13] J. W. Bos, C. Costello, M. Naehrig, and D. Stebila.

Post-quantum key exchange for the TLS protocol from the
ring learning with errors problem. In 2015 IEEE
Symposium on Security and Privacy, 2015.

[14] V. Boyko, P. MacKenzie, and S. Patel. Provably secure

password-authenticated key exchange using Diﬃe-Hellman.
In EUROCRYPT 2000, pages 156–171.

[15] E. Brickell, J. Camenisch, and L. Chen. Direct anonymous

attestation. In ACM CCS 2004, pages 132–145. ACM Press.

[16] J. Camenisch, M. Dubovitskaya, K. Haralambiev, and

M. Kohlweiss. Composable and modular anonymous
credentials: Deﬁnitions and practical constructions. In
ASIACRYPT 2015, pages 262–288. Springer.

[17] J. Camenisch and A. Lysyanskaya. A signature scheme with

eﬃcient protocols. In SCN 2002, pages 268–289. Springer.
[18] J. Camenisch and A. Lysyanskaya. Signature schemes and

anonymous credentials from bilinear maps. In CRYPTO
2004, volume 3152 of LNCS, pages 56–72. Springer-Verlag.
[19] J. Camenisch and A. Lysyanskaya. An eﬃcient system for

non-transferable anonymous credentials with optional
anonymity revocation. In EUROCRYPT 2001, volume 2045
of LNCS, pages 93–118. Springer-Verlag, 2001.

[20] J. Camenisch and M. Stadler. Eﬃcient group signature

schemes for large groups. In CRYPTO 1997, pages 410–424.

[21] A. Cassola, E.-O. Blass, and G. Noubir. Authenticating

privately over public Wi-Fi hotspots. In ACM CCS, pages
1346–1357. ACM, 2015.

[22] E. Cesena, H. L¨ohr, G. Ramunno, A.-R. Sadeghi, and
D. Vernizzi. Anonymous authentication with TLS and
DAA. In TRUST 2010, pages 47–62. Springer.

[23] M. Chase and A. Lysyanskaya. On signatures of knowledge.

In CRYPTO 2006, pages 78–96. Springer-Verlag.

[24] M. Chase, S. Meiklejohn, and G. Zaverucha. Algebraic

MACs and keyed-veriﬁcation anonymous credentials. In
ACM CCS 2014, pages 1205–1216. ACM Press. Full version
is available at http://eprint.iacr.org/2013/516.

[25] D. Chaum. Blind signatures for untraceable payments. In

CRYPTO 1982, pages 199–203, 1982.

[26] D. Chaum. Security without identiﬁcation: Transaction

systems to make big brother obsolete. Communications of
the ACM, pages 1030–1044, 1985.

[27] D. Chaum and E. van Heyst. Group signatures. In

EUROCRYPT 1991, pages 257–265. Springer-Verlag.

[28] T. Dierks and E. Rescorla. The transport layer security

(TLS) protocol version 1.2. RFC 5246 (Proposed
Standard), August 2008.

[29] Y. Dodis, E. Kiltz, K. Pietrzak, and D. Wichs. Message
authentication, revisited. In EUROCRYPT’12, volume
7237 of LNCS, pages 355–374. Springer-Verlag, 2012.

[30] Y. Dodis and A. Yampolskiy. A veriﬁable random function
with short proofs and keys. In Public Key Cryptography –
PKC 2005, pages 416–431. Springer-Verlag, 2005.

[31] European Parliament and Council of the European Union.

Directive 2009/136/EC. Oﬃcial Journal of the European
Union, 2009.

[32] D. Fett, R. K¨usters, and G. Schmitz. SPRESSO: A secure,

privacy-respecting single sign-on system for the web. In
ACM CCS 2015, pages 1358–1369.

[33] A. Fiat and A. Shamir. How to prove yourself: Practical

solutions to identiﬁcation and signature problems. In
CRYPTO 1986, pages 186–194. Springer-Verlag.

[34] M. Fischlin. Communication-eﬃcient non-interactive proofs

of knowledge with online extractors. In CRYPTO 2005,
volume 3621 of LNCS, pages 152–168. Springer-Verlag.

[35] S. Goldwasser, S. Micali, and R. L. Rivest. A digital

signature scheme secure against adaptive chosen-message
attacks. SIAM Journal on Computing, pages 281–308, 1988.

[36] J. Groth. Simulation-sound NIZK proofs for a practical

language and constant size group signatures. In
ASIACRYPT 2006, pages 444–459. Springer-Verlag.

[37] V. Gupta, D. Stebila, S. Fung, S. C. Shantz, N. Gura, and

H. Eberle. Speeding up secure web transactions using
elliptic curve cryptography. In NDSS, 2004.

[38] IBM. Speciﬁcation of the Identity Mixer Cryptographic

Library. IBM Research Report RZ 3730, 2010.

[39] IEEE 1363.2. IEEE standard speciﬁcations for password

based public-key cryptographic techniques. IEEE Std
1363.2-2008, pages 1–127, 2009.

[40] ISO/IEC 11770-4. Information technology – Security

techniques – Key management – Part 4: Mechanisms based
on weak secrets, 2006.

[41] ISO/IEC 11889:2015. Information technology - Trusted

Platform Module Library, 2015.

[42] ISO/IEC 20008. Information technology - Security

techniques - Anonymous digital signatures, 2013.

[43] ISO/IEC DIS 20009-4. Information technology – Security

techniques – Anonymous entity authentication – Part 4:
Mechanisms based on weak secrets, 2015.

[44] J. Katz, R. Ostrovsky, and M. Yung. Eﬃcient

password-authenticated key exchange using human
memorable passwords. In EUROCRYPT 2001, volume
2045 of LNCS, pages 475–494. Springer-Verlag.

[45] Y. Lindell. Anonymous authentication. Journal of Privacy

and Conﬁdentiality, 2(2):4, 2007.

[46] M. Naor and O. Reingold. Synthesizers and their

1190application to the parallel construction of pseudo-random
functions. Computer and Systems Sciences, 58(2):336–375,
April 1999.

[47] NISTIR 8062. Privacy risk management for federal

information systems, May 2015.

[48] C. Paquin and G. Zaverucha. U-Prove Cryptographic

Speciﬁcation V1.1 (Revision 3). Microsoft, 2013.

[49] D. Pointcheval. Password-based authenticated key
exchange. In PKC 2012, pages 390–397. Springer.

[50] D. Pointcheval and J. Stern. Security arguments for digital

signatures and blind signatures. Journal of Cryptology,
13(3):361–396, 2000.

[51] K. Rannenberg, J. Camenisch, and A. Sabouri.

Attribute-based Credentials for Trust - Identity in the
Information Society. Springer, 2015.

[52] H. A. Schmidt. National strategy for trusted identities in
cyberspace. Cyberwar Resources Guide, Item 163, 2010.

[53] C. Schnorr. Security of blind discrete log signatures against

interactive attacks. In Information and Communications
Security, volume 2229 of LNCS, pages 1–12. 2001.

[54] S. Shin and K. Kobara. Anonymous password

authenticated key exchange: New construction and its
extensions. IEICE, 93(1):102–115, 2010.

[55] V. Shoup. Lower bounds for discrete logarithms and related

problems. In EUROCRYPT 1997, pages 256–266.

[56] N. P. Smart. The exact security of ECIES in the generic
group model. In Cryptography and Coding, pages 73–84.
Springer, 2001.

[57] D. Taylor, T. Wu, N. Mavrogiannopoulos, and T. Perrin.

Using the secure remote password (SRP) protocol for TLS
authentication. RFC 5054, 2007.

[58] D. Q. Viet, A. Yamamura, and H. Tanaka. Anonymous

password-based authenticated key exchange. In
INDOCRYPT 2005, volume 3797 of LNCS, pages 244–257.

[59] J. Walker and J. Li. Key exchange with anonymous

authentication using DAA-SIGMA protocol. In Trusted
Systems, volume 6802 of LNCS, pages 108–127. 2011.

[60] J. Yang and Z. Zhang. A new anonymous password-based

authenticated key exchange protocol. In INDOCRYPT
2008, volume 5365 of LNCS, pages 200–212. Springer.

[61] Y. Yang, J. Zhou, J. Weng, and F. Bao. A new approach
for anonymous password authentication. In ACSAC 2009,
pages 199–208. IEEE.

[62] Y. Yang, J. Zhou, J. W. Wong, and F. Bao. Towards

practical anonymous password authentication. In ACSAC
2010, pages 59–68. ACM.

APPENDIX
A. SECURITY PROOFS OF MACSDH

In this section, we prove that MACSDH is suf-rmva secure

in Theorem 4 and weak pseudorandom in Theorem 5.

Theorem 4. If the q-SDH assumption holds in G, then

the MACSDH scheme is suf-rmva secure.

Proof. If there exists an adversary A that makes qm
queries to oracle mac and qv queries to oracle verify, and
breaks the suf-rmva security of MACSDH with probability ,
then we can construct an algorithm B that breaks the q-SDH
assumption with probability /(qv + 1) by interacting with
A, where q = qm + 1.
) ∈ (G∗)q+1 for some
unknown γ ∈ Z∗
p, B aims to output a solution (c, g1/(γ+c))
for some c ∈ Zp\{−γ}. B picks i∗ $← [qv + 1] as the guess
that the ﬁrst fresh and valid forgery appears in the i∗-th
veriﬁcation query if 1 ≤ i∗ ≤ qv or the ﬁnal output of A if
i∗ = qv + 1. Then B chooses m1, m2, . . . , mq−1
$← Zp. Let

Given a q-SDH instance (g, gγ, . . . , gγq

j=1(gγj

j=0(gγj

j=0(gγj

Using the tuple (g, gγ, . . . , gγq

j=1(x + mj) =(cid:80)q−1
j=1,j(cid:54)=i(x + mj) =(cid:80)q−2

f (x) =(cid:81)q−1
mi) =(cid:81)q−1
Boyen [11, Lemma 3.2], B can compute g(cid:48) =(cid:81)q−1
gf (γ), w = (cid:81)q
(cid:81)q−2

j=0 αjxj and fi(x) = f (x)/(x +
j=0 βi,jxj for each i ∈ [q − 1].
) and the technique of Boneh-
)αj =
)αj−1 = gγf (γ) = (g(cid:48))γ, and Ai =
)βi,j = gfi(γ) = gf (γ)/(γ+mi) = (g(cid:48))1/(γ+mi) for
each i ∈ [q − 1]. Next, B returns parmac = (G, p, g(cid:48), w) to A
and responds the queries made by A as below:
For i-th MAC query, B returns (mi, Ai) to A.
For i-th veriﬁcation query (m(cid:48)
i, A(cid:48)
• If i = i∗, B sets (m, A) = (m(cid:48)
i) and aborts.
• Otherwise (i.e., i < i∗), B returns 1 if (m(cid:48)

i), B responds as follows:
i, A(cid:48)

i, A(cid:48)
(mj, Aj) for some 1 ≤ j ≤ q − 1 and 0 otherwise.

Finally, if B does not abort, A outputs a forgery (m∗, A∗).
In this case (i∗ = qv + 1), B sets (m, A) = (m∗, A∗).
If B guesses correctly with probability 1/(qv + 1), B’s sim-
ulation is perfect, and (m, A) is a fresh and valid forgery,
i.e., (m, A) /∈ {(mi, Ai)}q−1
i=1 and Aγ+m = g(cid:48). Thus, we have
m /∈ {m1, . . . , mq−1}, since for any valid message-tag pair
( ˜m, ˜A) under g(cid:48) and γ, ˜A is uniquely determined by ˜m. Let
(cid:80)q−2
f (x) = f(cid:48)(x)(x + m) + η for some η ∈ Z∗
p, and write f(cid:48)(x) =
j=0 δjxj. Note that A = (g(cid:48))1/(γ+m) = gf (γ)/(γ+m) =
gf(cid:48)(γ) =(cid:81)q−2
with

gf(cid:48)(γ)+η/(γ+m). B computes g1/(γ+m) =

A/gf(cid:48)(γ)(cid:17)1/η
(cid:16)

)δj , and outputs (m, g1/(γ+m)) as a solu-

i) =

j=0(gγj

tion of the q-SDH problem.

Theorem 5. If the q-DDHI assumption holds in group

G, then MACSDH is weak pseudorandom.

Given (g, gα, . . . , gαq

Proof. If there exists an adversary A that makes qm
queries to oracle mac and breaks the weak pseudorandom-
ness of MACSDH with probability , then we can construct an
algorithm B that breaks the q-DDHI assumption with prob-
ability at least  − (q − 1)/p via interacting with A, where
q = qm + 1.
, T ) ∈ (G∗)q+2 for some unknown
p, B aims to distinguish T = g1/α from a random ele-
α ∈ Z∗
ment T . Firstly, B picks m1, . . . , mq−1, m $← Zp. Using the
Binomial Theorem, B can compute the tuple (g, gγ, . . . , gγq
)
where γ = α − m. Then, as in the proof of Theorem 4, B
generates g(cid:48) = gf (γ), w = (g(cid:48))γ, and Ai = (g(cid:48))1/(γ+mi) for
j=1(x + mj). Next, B
returns parmac = (G, p, g(cid:48), w) to A. For i-th query to or-
acle mac, B returns a pair (mi, Ai) to A.
If m is equal
to one of m1, . . . , mq−1, B aborts. Otherwise, the poly-
In this case, we
nomial f (x) is not divisible by (x + m).
have f (x) = q(x)(x + m) + η for some η (cid:54)= 0, and write
)δj .
Next, B returns (m, σ = gq(γ) · T η) to A as the challenge.
Finally, A outputs a guess b(cid:48), and B outputs b(cid:48).

j=0 δjxj. Then, B computes gq(γ) =(cid:81)q−2

each i ∈ [q − 1], where f (x) = (cid:81)q−1

q(x) =(cid:80)q−2

j=0(gγj

It is easy to see that the simulation of oracle mac is per-

fect. If T = g1/α, then

σ = gq(γ)T η = gq(γ)gη/(γ+m) = gf (γ)/(γ+m) = (g
)1/(γ+m).
If T is uniformly distributed in G∗, then so is σ. If B does

not abort, B succeeds if A wins. As Pr(cid:2)∃i ∈ [q − 1] s.t. m =
(cid:3) ≤ (q−1)/p, we have the claimed bound.

mi

(cid:48)

1191