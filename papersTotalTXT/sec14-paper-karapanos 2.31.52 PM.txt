On the Effective Prevention of TLS Man-in-the-

Middle Attacks in Web Applications

Nikolaos Karapanos and Srdjan Capkun, ETH Zürich

https://www.usenix.org/conference/usenixsecurity14/technical-sessions/presentation/karapanos

This paper is included in the Proceedings of the 23rd USENIX Security Symposium.August 20–22, 2014 • San Diego, CAISBN 978-1-931971-15-7Open access to the Proceedings of  the 23rd USENIX Security Symposium is sponsored by USENIXOn the Effective Prevention of TLS Man-In-The-Middle Attacks

in Web Applications

Nikolaos Karapanos and Srdjan Capkun

Department of Computer Science, ETH Zurich

{ﬁrstname.lastname}@inf.ethz.ch

Abstract

In this paper we consider TLS Man-In-The-Middle
(MITM) attacks in the context of web applications,
where the attacker is able to successfully impersonate
the legitimate server to the user, with the goal of imper-
sonating the user to the server and thus compromising
the user’s online account and data. We describe in detail
why the recently proposed client authentication protocols
based on TLS Channel IDs, as well as client web authen-
tication in general, cannot fully prevent such attacks.

Nevertheless, we show that strong client authentica-
tion, such as Channel ID-based authentication, can be
combined with the concept of server invariance, a weaker
and easier to achieve property than server authentica-
tion, in order to protect against the considered attacks.
We speciﬁcally leverage Channel ID-based authentica-
tion in combination with server invariance to create a
novel mechanism that we call SISCA: Server Invariance
with Strong Client Authentication. SISCA resists user
impersonation via TLS MITM attacks, regardless of how
the attacker is able to successfully achieve server imper-
sonation. We analyze our proposal and show how it can
be integrated in today’s web infrastructure.
1

Introduction

Web applications increasingly employ the TLS pro-
tocol to secure HTTP communication (i.e., HTTP over
TLS, or HTTPS) between a user’s browser and the web
server. TLS enables users to securely access and inter-
act with their online accounts, and protects, among other
things, common user authentication credentials, such as
passwords and cookies. Such credentials are considered
weak; they are transmitted over the network and are sus-
ceptible to theft and abuse, unless protected by TLS.

Nevertheless, during TLS connection establishment, it
is essential that the server’s authenticity is veriﬁed.
If
an attacker successfully impersonates the server to the
user, she is then able to steal the user’s credentials and
subsequently use them to impersonate the user to the le-
gitimate server. This way, the attacker gains access to the
user’s account and data which can be abused for a vari-

ety of purposes, such as spying on the user [18, 48]. This
attack is known as TLS Man-In-The-Middle (MITM).

TLS server authentication is commonly achieved
through the use of X.509 server certiﬁcates. A server cer-
tiﬁcate binds a public key to the identity of a server, des-
ignating that this server holds the corresponding private
key. The browser accepts a certiﬁcate if it bears the signa-
ture of any trusted Certiﬁcate Authority (CA). Browsers
are typically conﬁgured to trust hundreds of CAs.

An attacker can thus successfully impersonate a legit-
imate server to the browser by presenting a valid certiﬁ-
cate for that server, as long as she holds the correspond-
ing private key. In previous years, quite a few incidents
involving mis-issued certiﬁcates [2, 9, 11, 48, 49] were
made public. Even in the case where the attacker simply
presents an invalid (e.g., self-signed) certiﬁcate not ac-
cepted by the browser, she will still succeed in her attack
if the user deﬁes the browser’s security warning.

In order to thwart such attacks, various proposals have
emerged. Some proposals focus on enhancing the certiﬁ-
cate authentication model. Their objective is to prevent
an attacker possessing a mis-issued, yet valid certiﬁcate,
from impersonating the server (e.g., [20, 33, 36, 52]).

Other proposals focus on strengthening client authen-
tication. Strong client authentication prevents user cre-
dential theft or renders it useless, even if the attacker
can successfully impersonate the server to the user. One
such prominent proposal is Channel ID-based client au-
thentication, introduced in 2012. TLS Channel IDs [4]
are experimentally supported in Google Chrome and are
planned to be used in the second factor authentication
standard U2F, proposed by the FIDO alliance [22].

In this paper we show that Channel ID-based ap-
proaches, as well as web authentication solutions that
focus solely on client authentication are vulnerable to
an attack that we call Man-In-The-Middle-Script-In-The-
Browser (MITM-SITB), and is similar to dynamic pharm-
ing [32] (see Section 4). This attack bypasses Channel
ID-based defenses by shipping malicious JavaScript to
the user’s browser within a TLS connection with the at-
tacker, and using this JavaScript in direct connections

USENIX Association  

23rd USENIX Security Symposium  671

with the legitimate server to attack the user’s account.

Nevertheless, we show that TLS MITM attacks where
the attacker’s goal is user impersonation can still be pre-
vented by strong client authentication, such as Channel
ID-based authentication, provided that it is combined
with the concept of server invariance, that is, the re-
quirement that the client keeps communicating with the
same entity (either the legitimate server, or the attacker)
across multiple connections intended for the same server.
Server invariance is a weaker requirement than server au-
thentication, and thus, it is easier to achieve as no ini-
tial trust is necessary. Building on this observation, we
propose a solution called SISCA: Server Invariance with
Strong Client Authentication, that combines Channel ID-
based client authentication and server invariance.

SISCA can resist TLS MITM attacks that are based
on mis-issued valid certiﬁcates, as well as invalid certiﬁ-
cates, requiring no user involvement in the detection of
the attack (i.e., no by-passable security warnings when
server invariance violation occurs). SISCA also thwarts
attackers that hold the private key of the legitimate server.
Contributions.
In this work we analyze TLS MITM
attacks whose goal is user impersonation and make the
following contributions.
(i) We show, by launching a
MITM-SITB attack, that Channel ID-based client au-
thentication solutions do not fully prevent TLS MITM
attacks; (ii) we further argue that effective prevention
of MITM-based user impersonation attacks requires
strong user authentication and (at least) server invariance;
(iii) we propose a novel solution that prevents MITM-
based user impersonation, based on the combination of
strong client authentication and server invariance; (iv) we
implement and evaluate a basic prototype of our solution.
2 Channel ID-based Authentication and

MITM Attacks

2.1 Attacker Model and Goals
Attacker Goals. The attacker’s goal in a MITM attack
is typically to impersonate the user (victim) to the legit-
imate server (e.g., a social networking, webmail, or e-
banking website) in order to compromise the user’s on-
line account and data. This is indeed the case where the
attacker wishes for example to spy on the user [18, 48],
or abuse his account for nefarious purposes, e.g., perform
fraudulent ﬁnancial transactions. Alternatively, the at-
tacker could aim to only impersonate the server to the
user (and not the user to the server), such that she serves
the user with fake content (e.g., fake news). In this paper,
we focus on the ﬁrst, more impactful, scenario.
Attacker Model. We adopt the attacker model consid-
ered by Channel IDs [4]. The adversary is able to posi-
tion herself suitably on the network and perform a TLS
MITM attack between the user and the target web server.

In other words, the attacker is able to successfully imper-
sonate the server to the user. We distinguish between two
types of MITM1 attackers.

The MITM+certiﬁcate attacker holds (i) a valid cer-
tiﬁcate for the domain of the target web server, binding
the identity of the server to the public key, of which she
holds the corresponding private key. The attacker, how-
ever, has no access to the private key of the target web
server. This, for example, can happen if the attacker com-
promises a CA or is able to force a CA issue such a cer-
tiﬁcate. Such attacks have been reported in the recent
years [2, 9, 11, 48]. Moreover, in this category we also
consider a weaker attacker that only holds (ii) an invalid
(e.g., self-signed) certiﬁcate.
In this case, the attacker
will still succeed in impersonating the server to the user
if the latter ignores the security warnings of the browser2,
which is a common phenomenon [51].

The MITM+key attacker holds the private key of the
legitimate server. While we are not aware of publicized
incidents involving server key compromise, such attacks
are feasible, as the Heartbleed vulnerability in OpenSSL
has shown [1], and can be very stealthy, remaining unno-
ticed. Thus, they are well worth addressing [28, 30, 35].
From the above it follows that the attacker is able to ob-
tain the user’s weak credentials, namely passwords and
HTTP cookies. She is not, however, able to compromise
the user’s browser or his devices (e.g., mobile phones).
2.2 TLS Channel IDs

Channel IDs is a recent proposal for strengthening
client authentication.
It is a TLS extension, originally
proposed in [15] as Origin-Bound Certiﬁcates (OBCs).
A reﬁned version has been submitted as an IETF Internet-
Draft [4]. Currently, Channel IDs are experimentally sup-
ported by Google’s Chrome browser and Google servers.
In brief, when the browser visits a TLS-enabled web
server for the ﬁrst time, it creates a new private/public
key pair (on-the-ﬂy and without any user interaction)
and proves possession of the private key, during the TLS
handshake. This TLS connection is subsequently iden-
tiﬁed by the corresponding public key, which is called
the Channel ID. Upon subsequent TLS connections to
the same web server, or more precisely, to the same web
origin, the browser uses the same Channel ID. This en-
ables the web server to identify the same browser across
multiple TLS connections.
2.2.1 Channel ID-Based Authentication

By Channel ID-based authentication we refer to the
use of Channel IDs throughout the user authentication
process, designed to thwart both types of MITM attack-
ers presented in Section 2.1 [4, §6], [13, §3].

1We use the terms “TLS MITM” and “MITM” interchangeably.
2We use the term “browser” to refer to any “user agent” in general.

672  23rd USENIX Security Symposium 

USENIX Association

PhoneAuth

Auth.)Protocol

Auth.)Protocol

TLS

TLS

Channel)ID)of)the)
browser:

≠

Channel)ID)witnessed)
by)the)server:

,

: TLS Channel IDs

Figure 1: PhoneAuth and FIDO U2F; leveraging Channel IDs
to secure the initial login against MITM attacks.

TLS

TLS

Channel ID

Set$Cookie)

TLS

,

: TLS Channel IDs

Initial Login. When the user attempts to login to
his online account for the ﬁrst time from a particular
browser, the web server requires that the user authenti-
cates using a strong second factor authentication device,
as in PhoneAuth [13] and FIDO Universal 2nd Factor
(U2F) [22] protocols. These protocols leverage Chan-
nel IDs to secure the intial login process against MITM
attacks. In brief, as part of the authentication protocol,
the second factor device compares the Channel ID of the
browser to the Channel ID of the TLS connection that the
server witnesses. If they are equal, then the browser is di-
rectly connected to the web server through TLS (because
they share the same view of the connection), and thus
there is no MITM attack taking place. On the other hand,
if the Channel IDs differ, then the server is not directly
connected to the user’s browser. Instead, as shown in Fig-
ure 1, there is an attacker in the middle, and the device
aborts the authentication protocol, stopping the attack.
Subsequent Logins. Upon successful initial authentica-
tion the server sets a cookie to the user’s browser, and
binds it to the Channel ID of the browser. As proposed
in [15], a server may create a channel-bound cookie as
follows: (cid:31)v, HMAC(k,v|cid)(cid:29), where v is the original
cookie value, cid is the browser Channel ID and k is a
secret key only known to the server, used for computing
a MAC over the concatenation of v and cid. The channel-
bound cookie is considered valid only if it is presented
over that particular Channel ID. Therefore, subsequent
interaction with the server from that particular browser is
protected by the channel-bound cookie. An attacker that
manages to steal a channel-bound cookie, e.g., through
a MITM attack, cannot use it to impersonate the user to
the web server, since she does not know the private key
of the correct Channel ID. Figure 2 illustrates this con-
cept. Note that at this stage, the second factor device is
not required for authenticating the user [12].

2.3 MITM Attack on Channel ID-Based

Authentication

Figure 2: Binding authentication tokens (e.g., cookies) to the
browser’s Channel ID (green). A MITM attacker who steals
such a cookie, cannot use it to impersonate the user, since the
attacker has a different Channel ID (red).

user. This is due to the way web applications are run
and interact with the servers, which differs from other
internet client-server protocols (e.g., IMAP over TLS).

In particular, web servers are allowed to send script-
ing code to the browser, which the latter executes within
the security context of the web application (according
to the rules deﬁned by the same-origin policy [5]).
In
fact, client-side scripting and especially JavaScript, is the
foundation of dynamic, rich web applications that vastly
improve user experience, and its presence is ubiquitous.
Moreover, a browser can establish multiple TLS con-
nections with the same server. In addition, a typical web
application loads resources, such as images and scripts,
from multiple domains (cross-origin network access [5]).
Assuming that all communication is TLS-protected, this
means that the browser needs to establish TLS connec-
tions with multiple servers while loading a web page.

Given the above, there is a conceptually simple attack
that a MITM+certiﬁcate or MITM+key attacker can per-
form, which bypasses the security offered by Channel
IDs. We assume that the user tries to access the target
web server, say www.example.com. The attacker then
proceeds as follows:

1. She intercepts a single TLS connection attempt
made by the browser to www.example.com, and by
presenting a valid certiﬁcate (or invalid with the user
ignoring the browser’s warning), she successfully
impersonates the legitimate server to the browser.

2. Through the established connection, the browser
makes an HTTP request to the server. The attacker
replies with an HTTP response, which includes a
malicious piece of JavaScript code. This script will
execute within the origin of www.example.com.

We show how Channel ID-based authentication still
allows a MITM attacker to successfully impersonate the

3. The attacker closes the intercepted TLS connection.
This forces the browser to initiate a new TLS con-

USENIX Association  

23rd USENIX Security Symposium  673

Phone Auth / U2F Attack

1. Intercept connection!
2. Push malicious script!
3. Close connection!
4. Gain control

Auth.)Protocol

1
HTTP

3

2

TLS

TLS

Channel)ID)of)the)
browser:

Channel)ID)witnessed)
by)the)server:

4

=

Figure 3: MITM-SITB attack on Channel ID-based PhoneAu-
th/U2F, used for the initial login. The attacker’s JavaScript code
is executed within the origin of the target server (shown by the
dotted arrow).

nection in order to transmit subsequent requests, or
use another existing one, if any (this behavior con-
forms with the HTTP speciﬁcation [23]). At the
same time, the attacker allows subsequent TLS con-
nection attempts to pass through, without interfer-
ing with them. As a result, once the attacker closes
that single intercepted connection, all other connec-
tions, existing and new, are directly established be-
tween the browser and the legitimate server.

4. The attacker gains full control over the user’s ses-
sion in that particular web application. Her script
has unrestricted access over the web documents be-
longing to www.example.com and can monitor all
the client-side activity of the web application. More-
over, she can issue arbitrary malicious requests to
the target server using the XMLHttpRequest ob-
ject [3], in order to perform a desired action or
extract sensitive user information. The malicious
code can upload any extracted data to an attacker-
controlled server. As another example, if the web
application is Ajax-based, the attacker can perform
Prototype Hijacking [46]. This allows her to eaves-
drop and modify on-the-ﬂy all the HTTP requests
made through XMLHttpRequest.

In summary, the MITM attacker “transfers” herself
(via the malicious script) within the user’s browser, and
continues her attack from there. We call this attack Man-
In-The-Middle-Script-In-The-Browser (MITM-SITB).

is about

Figure 3 illustrates the MITM-SITB attack in the
case when the user
to initially authenti-
cate to www.example.com using PhoneAuth or U2F.
The attacker intercepts a TLS connection, pushes her
JavaScript code to the user’s browser, and terminates
the connection. The browser then establishes a new
TLS connection for subsequent communication, only
this time with the legitimate server; the attacker will not

Channel ID Attack

1. Intercept connection!
2. Push malicious script!
3. Close connection!
4. Gain control

1

3

2

TLS

4

TLS

Figure 4: MITM-SITB attack on Channel ID-based authentica-
tion after the initial login, where requests are protected with a
channel-bound cookie.

hijack it. This ensures that the user authentication is per-
formed over a direct connection between the browser and
the server, but with the attacker’s code running in the
browser. The view of the TLS channel will be the same
for the browser and the server, and the Channel ID com-
parison made by the second factor device will pass.

Figure 4 shows how the attack works in the case when
the user has already logged in on www.example.com in
the past, and the server has set a channel-bound cookie
in the user’s browser. Like before, the attacker ships ma-
licious JavaScript code to the browser by intercepting a
TLS connection to www.example.com. She then termi-
nates the intercepted connection. This forces the browser
to establish a new TLS connection, which is not inter-
cepted by the attacker. This ensures that any subsequent
requests, either legitimate or malicious (issued by the
attacker’s script) are accepted by the legitimate server,
since they will carry the channel-bound cookie, which
authenticates the user, over the correct Channel ID.

From the above attack description there are various
details that remain unclear. For example, which TLS
connection the attacker should intercept, whether to
“hit and run” or persist as much as possible, etc. De-
pending on the scenario, there are various alternatives,
which are mostly implementation decisions. The at-
tacker can for example choose the following strategy.
She intercepts the very ﬁrst TLS connection, i.e., the
one that the browser initiates once it is directed to
www.example.com. Depending on the situation, the
attacker’s HTTP response could contain the expected
HTML document of the website’s starting page, together
with the appropriately injected malicious script, or it
could only contain the malicious script, which will take
care of loading the starting page in the browser. Then, as
described before, the attacker closes this ﬁrst connection
and subsequent communication (malicious or not) takes
place through a direct connection to the legitimate server.
The Cross-Origin Communication Case. Visiting a sin-
gle web page typically involves cross-origin communica-
tion with different domains in the background. For exam-

674  23rd USENIX Security Symposium 

USENIX Association

1. Fetch main page!
2. Fetch external script!
3. Intercept connection!

4. Forward request!
5. Inject malicious script!
6. Gain control
GET)/),)Cookie:)

200)OK)

www.example.com

1

TLS

…<script)src=“https://
static.example.com)
script.js”></script>…

static.example.com

2

6

GET)/script.js)

3

4

GET)/script.js)

5

TLS

TLS

TLS

Figure 5: MITM-SITB attack on Channel ID-based authentica-
tion leveraging cross-origin communication. Channel IDs for
static.example.com are of no use.

ple a typical network optimization technique is to have
the browser load the static resources of the website, such
as images, style sheets and scripts, from so-called cook-
ieless domains (e.g., Google websites usually load static
resources from gstatic.com [24]). These domains, as
their name suggests, do not set any cookies, so as to min-
imize network latency. As a matter of fact, on such do-
mains, client authentication does not apply at all, as they
are just used to serve static resources, which anyone, in-
cluding the attacker, can access. Hence in those cases,
the attacker can perform a conventional MITM attack
against a cookieless domain, and inject her malicious
code at the moment when the target web server requests
a legitimate JavaScript ﬁle from that domain (Figure 5).
2.4 Proof of Concept Attack

We validate our attack against Channel IDs through a
proof of concept implementation. We use two Apache
TLS-enabled servers (one for the attacker, one for the
legitimate server) and an interception proxy that can se-
lectively forward TLS connections to either server. The
legitimate server uses a patched OpenSSL version that
supports Channel IDs and leverages them for creating
channel-bound cookies. We use Google Chrome as the
user’s browser, since it supports Channel IDs, and ensure
that it accepts the certiﬁcates of both servers. We are then
able to inject JavaScript code to the user’s browser from
the attacker’s server and issue HTTP requests that are ac-
cepted and processed by the legitimate server.
2.5 Scope and Implications of the Attack

The MITM-SITB attack presented in Section 2.3 is not
speciﬁc to Channel ID-based client authentication proto-
cols. In fact, it applies to any web client authentication
method. This attack demonstrates that, in the context of

web applications, it does not seem possible to prevent
TLS MITM attacks via client authentication alone.

We provide the following informal reasoning for the
above claim. Client authentication does not prevent an
attacker from impersonating the legitimate server. This
allows her to intercept a server-authenticated (i.e., TLS)
connection and ship her JavaScript code to the user’s
browser. The browser, treating the attacker’s code as
trusted (as it came through a server-authenticated connec-
tion), executes it within the target server’s origin. The at-
tacker accesses the user’s account through requests initi-
ated by her code and transmitted over another, direct con-
nection between the browser and the legitimate server.

As a result, schemes such as traditional TLS client au-
thentication [14] and TLS Session Aware User Authenti-
cation [42, 43] are still susceptible to TLS MITM attacks,
via MITM-SITB. The attacker succeeds in impersonating
the user to the web server and compromising his account.
3 Addressing TLS MITM Attacks

As shown in Section 2, strong client authentication
alone is not sufﬁcient to prevent MITM attacks that lead
to user impersonation in web applications. So, how can
we effectively prevent such attacks? In this section we
show that there are two orthogonal solutions; (i) the
known solution of preventing the attacker from imper-
sonating the legitimate server at all, i.e., ensuring correct
server authentication; (ii) our novel approach of combin-
ing strong client authentication with server invariance.
3.1 Prevent Server Impersonation

The known and straightforward solution to the prob-
lem at hand is to prevent the attacker from impersonating
the server in the ﬁrst place. This way, the attacker can
neither steal weak user credentials in order to mount a
conventional MITM attack, nor ship malicious Javascript
in order to mount a MITM-SITB attack. Note that in
this case, strong client authentication (e.g., Channel ID-
based) is not necessary for preventing MITM attacks (it
is, however, still useful for preventing other attacks, such
as phishing and server password database compromise).
The solutions that try to prevent server impersonation
essentially address the issue of forged server certiﬁcates
(and thus defeating MITM+certiﬁcate attacks), by per-
forming enhanced certiﬁcate veriﬁcation. Such solutions
are mainly based on pinning [20, 38], multi-path prob-
ing [33, 36, 37, 52] and hybrid approaches [19, 29] (a
thorough survey can be found in [10]).
3.2 Our Proposal: SISCA
3.2.1 Main Concept

The fact that strong client authentication alone cannot
effectively prevent MITM attacks in web applications,

USENIX Association  

23rd USENIX Security Symposium  675

SISCA Overview

Conventional)MITM)
prevented)by)strong)
client)auth.)(e.g.,)
Channel)ID$based)

MITM$SITB)prevented)
by)server)invariance

Figure 6: TLS MITM attacks in web applications can be
thwarted by combining strong client authentication with server
invariance.

raises the following question.
Is there a way to some-
how still beneﬁt from strong client authentication with
respect to addressing MITM attacks?

To answer, we make the following observation. In the
context of web applications, a MITM attacker can per-
form user impersonation via two approaches:

1. The conventional MITM attack, in which the at-
tacker compromises the user’s credentials and uses
them for impersonation. This attack can be effec-
tively prevented by strong client authentication e.g.,
using Channel ID-based protocols (Figures 1, 2).

2. The MITM-SITB attack, presented in Section 2.3
(Figures 3, 4, 5). As discussed in Section 2.5, client
authentication alone cannot prevent this attack.

For the MITM-SITB attack to be successful, the user’s
browser needs to communicate with two different enti-
ties, namely the attacker and the target web server. Com-
municating with the attacker is, of course, necessary for
injecting the attacker’s script to the browser through the
intercepted TLS connection. In addition, communication
with the target server is essential, so that the attacker ac-
cesses the user’s account and data, through her script.

As a result, we can prevent MITM-SITB by making
sure that the browser communicates only with one entity,
either the legitimate server, or the attacker, but not with
both, during a browsing session (a browsing session is
terminated when the user closes the browser). In other
words, we need to enforce server invariance. When com-
bined with strong client authentication (e.g., Channel ID-
based), which stops the conventional MITM approach,
this technique manages to effectively thwart MITM at-
tacks. Figure 6 illustrates the concept.

In the remaining section we present a novel solution,
called Server Invariance with Strong Client Authentica-
tion (SISCA), which stems from the above result. SISCA
is able to resist MITM+certiﬁcate attacks, offering ad-
vantages compared to existing solutions that focus at pre-
venting server impersonation (see Section 3.2.9), as well

as MITM+key attacks under the assumption that the at-
tacker does not persistently compromise the server (see
Section 3.2.2). The details of our solution follow below.
3.2.2 Design Goals and Assumptions

(i)

incremental deployment,

In SISCA we seek to satisfy the following require-
ments:
(ii) scalability,
(iii) minimal overhead, (iv) account for cross-origin com-
munication, assuming that the involved origins belong to,
and are administered by the same entity, (v) mitigation of
MITM+key attacks (besides MITM+certiﬁcate attacks).
We make the following assumptions. First, strong
client authentication, which prevents the conventional
way of implementing MITM attacks (Figures 1, 2) is
in place. Speciﬁcally, we assume that SISCA-enabled
servers implement Channel ID-based client authentica-
tion. As mentioned before, Channel IDs are already ex-
perimentally supported in Google Chrome. Moreover,
FIDO U2F leverages Channel IDs, as metiononed in Sec-
tion 2.2.1, so it is likely that Channel ID-based authenti-
cation will become available in the foreseeable future.

Second, we assume that SISCA-enabled servers sup-
port TLS with forward secrecy by default [28, 30, 35].
As we discuss below, this is only required for preventing
MITM+key attacks (not relevant for MITM+certiﬁcate
attacks). Moreover, we assume that TLS is secure and
cannot be broken by cryptographic attacks, such as those
surveyed in [10].

We ﬁnally assume that the MITM+key attacker does
not persistently compromise the target web server. As we
discuss later, this enables SISCA to resist server key com-
promise (i.e., MITM+key attackers) through frequent ro-
tation of the server secrets that are used in SISCA (see
Section 3.2.8). We also note that if an attacker gained
persistent control over the target server, she would prob-
ably not need to resort to MITM attacks to compromise
the users’ accounts, but at the same time she would in-
crease the probability of being detected.
3.2.3 Server Invariance Versus Authentication

As stated above, our goal is to combine strong client
authentication with server invariance.
Invariance is a
weaker property than authentication, and thus, easier to
achieve, as no a priori trust is necessary. In contrast, au-
thentication requires some form of initial trust so that the
client can correctly authenticate the server [17].

Consequently, we stress the following very important
difference. Server authentication (and solutions that try
to enforce it, like those mentioned in Section 3.1) implies
that every single TLS connection should be established
with the legitimate server. If the attacker attempts to in-
tercept such a connection, she should be detected by the
browser, i.e., no server impersonation should be possible.
In contrast, server invariance, embraces the fact that

676  23rd USENIX Security Symposium 

USENIX Association

the attacker can successfully impersonate the server.
As such, we distinguish two scenarios concerning the
browser’s ﬁrst connection to a particular server: (i) The
ﬁrst connection is not intercepted by the attacker. Then,
server invariance implies that the attacker is allowed to in-
tercept none of the subsequent connections to that server.
(ii) The ﬁrst connection is intercepted by the attacker.
Then, server invariance implies that the attacker has to
intercept all subsequent connections to that server.
In
either scenario, if the attacker violates server invariance,
she will be detected.

We consider server invariance as a transient property
whose scope is one browsing session. Server invariance
is reset whenever the browser restarts, i.e., the attacker is
allowed again to choose whether to intercept or not the
ﬁrst connection to the server.

3.2.4 Towards Implementing Server Invariance

In order to implement server invariance, it is impor-
tant to understand the implications of the fact that the
attacker is allowed to impersonate the server. Namely,
the attacker can intercept the ﬁrst connection and inﬂu-
ence the entire HTTP response, which clearly cannot be
blindly trusted. Therefore, techniques that assume the
attacker is able to inﬂuence only a part of the HTTP re-
sponse, such as Content Security Policy (CSP) [50] for
mitigating Cross-Site-Scripting (XSS) [44], as well as
techniques that assume the ﬁrst connection is trusted (i.e.,
not intercepted by the attacker), such as pinning, cannot
be directly applied for implementing server invariance.

Instead, a server invariance protocol should consist
of two phases, namely invariance initialization and in-
variance veriﬁcation – initialization and veriﬁcation for
brevity.
In the initialization phase, which is executed
in the ﬁrst connection to the server during a browsing
session (and could be intercepted by the attacker), the
browser establishes a point of reference. Then, in sub-
sequent connections to the same server, the veriﬁcation
phase is executed, where the browser veriﬁes that the
point of reference remains unchanged, i.e., the browser
keeps connecting to the same entity.
Server Public Keys. Assuming that we only consider
MITM+certiﬁcate attackers, we can leverage the servers’
public keys as the point of reference. Even if the attacker
intercepts the ﬁrst connection, she will not be able to let
any subsequent connections reach the legitimate server,
because the server’s public key will be different from the
attacker’s. Nevertheless, servers of the same domain may
use different public keys and also, cross-origin interact-
ing domains will have different keys. To solve this issue,
we need to “tie” all the involved public keys together, to
reﬂect the fact that they belong to the same entity and
thus server invariance should hold across all these do-
mains and keys. We sketch the following technique for

implementing server invariance.

During initialization (ﬁrst connection),

the server
sends a list of all the involved domains and all their pub-
lic keys to the browser, and the latter uses the witnessed
key as well as the list as the point of reference. Then, in
subsequent connections, the browser veriﬁes (i) that the
public key which the server presents is contained in the
list which was received during initialization, and (ii) that
the server agrees on the legitimacy of the public key that
was originally witnessed by the browser during initializa-
tion. Notice how this differs from pinning, which oper-
ates under the assumption that the initial connection is
trusted, and thus does not seek to verify the legitimacy of
the initial connection, and consequently of the received
pins, upon subsequent connections.

The above technique is indeed useful when consider-
ing MITM+certiﬁcate attacks and can be used to imple-
ment the server invariance protocol in SISCA. Neverthe-
less, in the following sections we present an alternative
approach that does not leverage server public keys, and
aims to mitigate MITM+key attacks, as well. We note
that the security analysis as well as most of the design
patterns that are discussed in the approach that follows
(e.g., how to prevent downgrade attacks and allow for
partial support and exceptions – Section 3.2.6, how to
secure resource caching – Section 3.2.7, etc) would simi-
larly apply to the previously sketched technique, too.
Our High-Level Approach. In SISCA we choose to im-
plement server invariance as a simple challenge/response
protocol. In the initialization phase (ﬁrst connection) the
browser sets up a fresh challenge/response pair (which
acts as the point of reference) with the server. Then,
in the veriﬁcation phase (subsequent connections) the
browser challenges the server to verify server invariance,
i.e., that it is the same entity with which the browser exe-
cuted the initialization.

SISCA has to be executed before any HTTP trafﬁc in-
ﬂuenced by the attacker is processed by the browser or
the server. We choose to implement the protocol at the
application layer, over established TLS sessions via an
HTTP header, named X-Server-Inv, and transmitted
together with the ﬁrst HTTP request/response pair over a
particular TLS connection. For the protocol to be secure,
on the client side this header is controlled solely by the
browser. It cannot be created or accessed programmati-
cally via scripts (similar to cookie-related headers [3]).

Alternatively, we could implement the server invari-
ance protocol in SISCA as a TLS extension, i.e., at the
transport layer. We deem the application layer more ap-
propriate, since server invariance encompasses semantics
that are naturally offered by the application layer, such as
cross-origin interaction and content inclusion.

Figure 7 depicts a simple example of how a protocol
In this example

based on our approach can look like.

USENIX Association  

23rd USENIX Security Symposium  677

Server Invariance - state at the server

Server Invariance

1. Initialization!
2. Veriﬁcation

1a, 2a: First HTTP request!
1b, 2b: First HTTP response
1

1. Initialization!
2. Veriﬁcation

1a, 2a: First HTTP request!
1b, 2b: First HTTP response
1

rb

rs

rs ≟ r′s

1a

TLS
cidb

2a

TLS
cidb

‘Init’, rb

rs

2

‘Verify’, rb

r′s

1b

2b

rs
store: [rb, cidb, rs]

lookup: r′s from [rb, cidb]

‘Init’, rb
rs, t1, t2

2

‘Verify’, rb, rs, t1

t′2

Keys ks1, ks2

rs
t1 = MAC(ks1,‘1’|rb|rs|cidb)
t2 = MAC(ks2,‘2’|rb|rs|cidb)

(forget t1, t2, rb, rs, cidb)
t1 ≟ MAC(ks1,‘1’|rb|rs|cidb)
t′2 = MAC(ks2,‘2’|rb|rs|cidb)

1b

2b

rb

1a

rs, t1, t2

t2 ≟ t′2

TLS
cidb

2a

TLS
cidb

Figure 7: An example challenge/response-based server invari-
ance protocol requiring per-client server state.

Figure 8: Basic SISCA protocol.

protocol, during the initialization phase the browser and
server generate random numbers rb and rs, which they
both store (the server also stores the browser’s Chan-
nel ID cidb). The browser subsequently uses rb as a
challenge during the veriﬁcation phase, expecting the re-
sponse rs by the server. The latter looks up rs by using rb
and cidb. For the shake of brevity, we do not analyze this
example, but we make the following important remarks.
First, this example requires the server to store per-
client state. This may be undesirable and it also makes it
harder for multiple servers belonging to the same entity
to share the common state which is needed in order to
be able to correctly execute the protocol. For this reason,
SISCA uses symmetric cryptography (MAC), in order to
securely ofﬂoad the state to the clients.

Second, during the veriﬁcation phase,

the server
should process the incoming HTTP request, only if the
lookup succeeds.
If it fails, it means that the attacker
intercepted the ﬁrst connection (initialization phase) and
that the incoming request may be malicious. We explain
this concept further in the analysis of the SISCA protocol.
We note that due to this fact, SISCA uses a second MAC
tag in order to enable the server perform this check.
3.2.5 Basic Protocol

We now describe the server invariance protocol of
SISCA in detail. We follow a structural approach, mean-
ing that we start with a basic version of our protocol, de-
scribed in this section. Then, in subsequent sections, we
incrementally add features.

Prior to the protocol execution,

Figure 8 illustrates the protocol, assuming no at-
tack.
the server,
www.example.com, generates two keys ks1 and ks2,
called SISCA keys. The same SISCA keys are used for
all protocol executions (i.e., not for a speciﬁc client) and
are never disclosed to other parties. Moreover, recall that
the server and client deploy Channel ID-based authentica-
tion. Each TLS connection will therefore have a Channel
ID cidb, that is created by the user’s browser. As already

The

initilization

mentioned, the protocol consists of two phases.
Initialization.
occurs
phase
once the browser establishes a TLS connection to
www.example.com, for the ﬁrst time in a browsing
session (upper connection in Figure 8). The browser
picks a random number rb. It then sends (cid:31)‘Init’,rb(cid:30) to
the server (‘Init’ is a string constant), within the ﬁrst
HTTP request3 over that connection. Upon receiving
this message, the server chooses a random number rs and
computes the following message authentication tags:

t1 = MAC(ks1,‘1’|rb|rs|cidb)
t2 = MAC(ks2,‘2’|rb|rs|cidb)

(1)
(2)

where ‘1’ and ‘2’ are strings constants. Notice that the
server binds the computed tags to the browser’s Channel
ID cidb. rb, rs and the MAC tags will be used in subse-
quent TLS connections to verify server invariance.

Finally,

the server sends (cid:31)rs,t1,t2(cid:30) to the browser
within its ﬁrst HTTP response. The browser stores
(cid:31)rb,rs,t1,t2(cid:30), while the server does not store any client-
speciﬁc information. At this point, the initialization
phase is complete. Subsequent HTTP requests and re-
sponses over that particular TLS connection do not in-
clude an X-Server-Inv header.
Veriﬁcation. The veriﬁcation phase takes place upon ev-
ery subsequent TLS connection to www.example.com,
which occurs within the same browsing session (lower
connection in Figure 8).
Like in the ﬁrst phase,
the protocol messages are exchanged within the ﬁrst
HTTP request/response pair.
The browser sends
(cid:31)‘Veri f y’,rb,rs,t1(cid:30) to the server, as part of the ﬁrst re-
quest. After receiving the request, and before processing
it, the server ﬁrst checks if

t1

?

= MAC(ks1,‘1’|rb|rs|cidb).

(3)

Here, cidb corresponds to the Channel ID of the TLS
session within which the protocol is currently being exe-

3Note that this is a request that browser would anyway submit, i.e.,

required for loading the web page. It is not an extra request.

678  23rd USENIX Security Symposium 

USENIX Association

Server Invariance - attacker second

Server Invariance - attacker ﬁrst

1. Initialization!
2. Veriﬁcation

1a, 2a: First HTTP request!
1b, 2b: First HTTP response
1

‘Init’, rb

rs, t1, t2

1b

Keys ks1, ks2

rs
t1 = MAC(ks1,‘1’|rb|rs|cidb)
t2 = MAC(ks2,‘2’|rb|rs|cidb)

rb

1a

rs, t1, t2

TLS
cidb

1. Initialization!
2. Veriﬁcation

1a, 2a: First HTTP request!
1b, 2b: First HTTP response
1

Keys ka1, ka2

‘Init’, rb

ra, t1, t2

1b

ra
t1 = …
t2 = …

(Relaying  computations to 
server doesn’t help, 
different Channel ID        )

rb

1a

ra, t1, t2

TLS
cidb

X$Server$Inv)header)out)
of)attacker’s)control

2

‘Verify’, rb, rs, t1

2a

Keys ka1, ka2

t′2 = …

(cannot compute 

correct t′2)

t2 ≠ t′2

t′2

2b

TLS
cidb
(a) Attacker intercepts the veriﬁcation phase.

(cannot relay t′2  computation to 
server, different Channel ID         )

2

‘Verify’, rb, ra, t1

2a

Keys ks1, ks2

t1 ≠ MAC(ks1,‘1’|rb|ra|cidb)

‘Alert’

2b

TLS
cidb
(b) Attacker intercepts the initialization phase.

Figure 9: Resilience of SISCA to MITM-SITB (conventional MITM is prevented by Channel-ID based authentication).

cuted, which, if under attack, might differ from the Chan-
nel ID that was used in the initialization phase. If the
check passes, the server computes

t(cid:31)2 = MAC(ks2,‘2’|rb|rs|cidb),

(4)
processes the received request, and passes (cid:29)t(cid:31)2(cid:28) within
the HTTP response to the browser. Finally, the browser
?
checks if t(cid:31)2
= t2 and if it succeeds, it means that server
invariance holds for this TLS connection.
Analysis When Under Attack. Figure 9 illustrates
how the protocol prevents MITM attacks. Recall that,
due to the usage of Channel ID-based authentication,
the attacker cannot perform the conventional attack (Fig-
ures 1, 2) – the attacker’s TLS sessions will have a differ-
ent Channel ID than the client’s and will thus be rejected.
Instead, she has to execute a MITM-SITB attack.

In Figure 9 we illustrate two possible attack scenarios
(based on the discussion of Section 3.2.3) and we show
why the attacker fails in both. In Figure 9a the attacker
intercepts the veriﬁcation phase of SISCA. Since the at-
tacker didn’t participate in the initialization phase of the
protocol, she does not know the correct MAC response
t2 to the client’s challenge. Moreover, since she does not
have access to ks2, she cannot calculate the correct t2 ei-
ther (Eq. (4)). As a result, the user’s browser rejects the
attacker’s response and terminates the session, notifying
the user (no user decision is required). Even if the at-
tacker pushes a malicious script in her response, it will
not get a chance of being executed.

In the second scenario, depicted in Figure 9b,
the attacker intercepts the ﬁrst TLS connection to
www.example.com. She thus executes the initialization
phase with the browser and injects her script, which is ex-
ecuted within the web origin of www.example.com. To
successfully complete her attack, the attacker needs to let
a subsequent TLS connection reach the legitimate server,
and access the user’s account via that connection.

After the browser establishes a connection with the
legitimate server, the two of them execute the veriﬁca-
tion phase, as part of the ﬁrst HTTP request/response
pair. The server, before processing the HTTP request
(which might as well be malicious), checks whether Con-
dition (3) is true. Since the attacker does not have ac-
cess to key ks1, she could not have computed the cor-
rect t1 (Eq. (1)). Thus, during the initialization phase,
she sends a t1 value to the browser that is not the cor-
rect one. Consequently, Condition (3) will not be sat-
isﬁed.
In this case the server does not process the
request, and instead notiﬁes the browser by sending
an empty HTTP response containing (cid:29)‘Alert’(cid:28) in the
X-Server-Inv header. This indicates violation of the
server invariance and the browser aborts the session.

We remark that in the second scenario, it is the legit-
imate server that checks server invariance, detects the
ongoing MITM attack and notiﬁes the browser. This is
important in order to prevent even a single malicious re-
quest from being accepted and processed by the server.
We conclude our analysis, with a few remarks that are
relevant for both of the scenarios described above. First,
note that the attacker cannot relay any of the necessary
MAC computations to the legitimate server.
In other
words, she cannot manipulate the server to compute for
her the values needed for cheating in the protocol. This is
because the server binds all its computations to the chan-
nel ID of the client with whom it communicates (the at-
tacker’s channel ID will be different from the user’s).

Second, note that the protocol is secure so long as the
attacker cannot “open” already established TLS connec-
tions between the browser and the legitimate server (i.e.,
connections that she chose not to intercept). If she could
do that, she would be able to extract the correct values
of both t1 and t2 and successfully cheat. Recall that, the
MITM+key attacker holds the private key of the legiti-
mate server. Therefore, in order to prevent such an at-

USENIX Association  

23rd USENIX Security Symposium  679

tacker from eavesdropping on already established TLS
connections, it is essential that these connections have
TLS forward secrecy enabled.

Third, when considering MITM+key attacks it is rea-
sonable to assume that the attacker can also extract the
SISCA keys, similar to the private key of the server. As
stated in the assumptions (Section 3.2.2) and explained
in Section 3.2.8, SISCA keys, unlike the private key, can
be frequently rotated. SISCA can thus resist MITM+key
attacks, assuming no persistent server compromise.

Finally, the attacker can choose not to reply at all,
when executing SISCA with the user. This essentially
leads to a Denial of Service (DoS) attack. However, such
attacks can already be achieved even by attackers less
powerful that those considered here. That is, attackers
that cannot perform TLS MITM attacks, but can block
network trafﬁc between the browser and the server.
Different Origins. The SISCA protocol execution is
guided by the same-origin policy [5].
In particular,
SISCA is executed independently, i.e., different proto-
col instances, when loading web pages and documents
that belong to different origins. For example, assume
that the browser navigates to www.example.com for the
ﬁrst time in the current browsing session. Then, a new
instance of SISCA will be created for this origin and
its initialization phase will be executed on the ﬁrst TLS
connection. If the browser further navigates to pages be-
longing to www.example.com, and this triggers the cre-
ation of new TLS connections by the browser, then for
those connections the browser will execute the veriﬁca-
tion phase of the previously created SISCA instance cor-
responding to www.example.com (same origin). When
the browser navigates to another website (different ori-
gin), say www.another.com, then a new instance of
SISCA will be created and used for the loading of docu-
ments from that origin (assuming that this is the ﬁrst visit
to www.another.com in that browsing session). Also
any HTTP redirections during navigation that lead to dif-
ferent origins will cause the corresponding SISCA in-
stances for those origins to be created and used.
3.2.6 Cross-Origin Communication

In the previous section we assumed that accessing the
web pages of www.example.com involves communica-
tion only with that domain, i.e., web origin. However,
this is not a realistic scenario in today’s web applica-
tions. Many websites perform cross-origin requests, e.g.,
to load resources. SISCA can accommodate for such
scenarios so long as all the involved domains belong to,
and are administered by the same entity, such that the re-
quired SISCA keys, ks1 and ks2, can be shared across all
relevant servers.

Therefore,

cross-origin communication the
browser uses the SISCA instance corresponding to

for

Server Invariance - Different channel ID

1. Initialization!
2. Veriﬁcation

1a, 2a: First HTTP request!
1b, 2b: First HTTP response
1

rb

1a

‘Init’, rb

rs, t1, t2

rs, t1, t2

1b

TLS

cidb (pkb, skb)

…<img)src=“https://
examplestatic.com/

a.png”/>…

2a

‘Verify’, rb, rs, t1, sig, 

2

cidb

t2 ≟ t′2

TLS

t′2
cid′b  (pk′b, sk′b)

2b

sig = Sign(skb, |rb|rs|t1|cid′b)

Same)Keys

www.example.com

Keys ks1, ks2

rs
t1 = MAC(ks1,‘1’|rb|rs|cidb)
t2 = MAC(ks2,‘2’|rb|rs|cidb)

examplestatic.com

Keys ks1, ks2

cidb ⇔ pkb
Verify(pkb, sig)
t1 ≟ MAC(ks1,‘1’|rb|rs|cidb)
t′2 = MAC(ks2,‘2’|rb|rs|cidb)

Figure 10:
SISCA adapted for cross-origin communi-
cation (the origins share the same SISCA keys), when
the browser uses a different Channel ID for each origin.
Here, www.example.com performs a cross-origin request to
examplestatic.com.

the initiating origin. For example, assume that a page
loaded from www.example.com performs a cross-origin
request to static.example.com. The browser will
create a TLS connection to static.example.com and
will execute the veriﬁcation phase of the SISCA instance
that corresponds to www.example.com. Any potential
HTTP redirections will also use the SISCA instance of
the initiating origin, www.example.com.
Different Channel IDs. The basic protocol we de-
scribed in Section 3.2.5 also works in the cross-origin
communication scenario, provided that the Channel ID
used by the browser is the same. The Channel ID speci-
ﬁcation draft already recommends using the same Chan-
nel ID for a domain and its subdomains [4, 15] (to ac-
count for cookies that have the Domain attribute set).
For example, the browser should use the same Channel
ID for www.example.com and static.example.com.
Nevertheless, for privacy reasons, the speciﬁcation rec-
ommends using different Channel IDs for unrelated do-
mains. In such cases, SISCA has to account for using
different Channel IDs across domains, when cross-origin
communication takes place.

Figure 10 depicts how the protocol works in such a
scenario. The browser navigates to www.example.com,
and starts a new SISCA instance for that origin. The
browser uses Channel ID cidb (with public key pkb, and
private key skb). At some later point in time, the page
loaded from www.example.com performs a cross-origin
request to examplestatic.com, which is controlled by
the same entity. Nevertheless, since it corresponds to
a different domain (i.e., not a subdomain), the browser
uses a different Channel ID, say cid(cid:31)b (with pk(cid:31)b, sk(cid:31)b be-
ing the corresponding public/private key pair).
In this
case, although the initialization phase of SISCA was ex-

680  23rd USENIX Security Symposium 

USENIX Association

ecuted using cidb, the veriﬁcation phase will have to be
executed over a TLS connection with Channel ID cid(cid:31)b.
As Figure 10 shows, the browser needs to tell the
server (examplestatic.com) to use cidb instead of cid(cid:31)b,
but do so in a secure way. To achieve this, the browser
endorses cid(cid:31)b, by signing it with skb, and thus proving
to the server that it owns the private keys of both Chan-
nel IDs cidb and cid(cid:31)b. The browser extends the ‘Veri f y’
message by appending cidb and a signature over cid(cid:31)b (i.e.,
the Channel ID of that TLS connection) and the rest of
the message parameters using skb. The server, before
processing the request, veriﬁes the signature on cid(cid:31)b us-
ing the supplied cidb (i.e., pkb).
If it passes, then the
server uses cidb for the subsequent steps of the veriﬁca-
tion phase, which remain unchanged.
Overlapping Cross-Origin Access. Browsers typically
send multiple HTTP requests over the same network con-
nection (persistent connections [23]). Due to the ex-
istence of cross-origin communication, a TLS connec-
tion to a particular domain, say static.example.com,
can be used by the browser to transmit cross-origin re-
quests to static.example.com made by different ini-
tiating origins. For example, the browser uses the same
TLS connection to static.example.com, to transmit,
ﬁrst, a request originating from a document belong-
ing to www.example.com and then, a request originat-
ing from a document belonging to shop.example.com
(we still assume that all three domains belong to the
same entity).
the TLS connection to
static.example.com has to be veriﬁed using SISCA
for both initiating domains, independently.

In this case,

above

scenario,

In the

the browser

executes
the veriﬁcation phase with the SISCA instance of
www.example.com, upon establishing the TLS con-
nection to static.example.com and sending the ﬁrst
HTTP request, originating from www.example.com.
Subsequently, when the browser wants to reuse the
same connection to send a cross-origin request from
shop.example.com to static.example.com, it once
again executes the veriﬁcation phase, only this time with
the SISCA instance of shop.example.com. This takes
place upon transmitting the ﬁrst HTTP request, which
originates from shop.example.com.
Origin Change. A web page is allowed to change
its own origin (effective origin) to a sufﬁx of its
domain, by programmatically setting the value of
document.domain [40]. This allows two pages be-
longing to different subdomains, but presumably to
the same entity,
their origin to a common
value and enable interaction between them4. For ex-
ample, a page from www.example.com and a page
from shop.example.com can both set their origin to

to set

4Both pages have to explicitly set document.domain.

In such a case, the attacker can attack
example.com.
the user account at shop.example.com, by intercepting
the ﬁrst connection to www.example.com (or any other
example.com subdomain), or vice versa.

To prevent such an attack, the browser has to verify
that server invariance holds across each pair of origins
that change their effective origin to a common value, be-
fore allowing any interaction between them. Each origin
has its own SISCA instance established, and we must en-
sure that both SISCA instances were initialized with the
same remote entity. This can be achieved by running the
veriﬁcation phase of both instances over the same TLS
connection (established to either origin). The browser
can reuse an already established and veriﬁed connection
with one origin, and just verify the connection with the
SISCA instance of the other origin. If no such connec-
tion exists at that time, then the browser can create a new
one to either origin and execute the veriﬁcation phase of
both SISCA instances. If there is no actual HTTP request
to be sent at that time, the browser can make use of an
HTTP OPTIONS request.
Partial Support and Downgrade Attacks. SISCA must
be incrementally deployable, which means that it must
maintain compatibility with legacy web servers, without
compromising the security of the SISCA-enabled servers.
Moreover, websites must be able to opt for partial sup-
port. As an example, a domain implements SISCA but
still needs to perform cross-origin requests to another do-
main, called incompatible, that either does not support
SISCA, or supports it but belongs to a 3rd party, i.e., it
has different SISCA keys (we discuss on the security of
such design choices at the end of this section).

The above can be achieved by allowing exceptions. If
a particular domain does not support SISCA (including
legacy servers that are not aware of SISCA at all), then
it can simply ignore the X-Server-Inv header, sent dur-
ing the initialization phase, and reply without including
any SISCA-related information. This will be received by
the browser as an exception claim. Moreover, if a domain
supports SISCA but performs cross-origin communica-
tion with one or more incompatible domains, then it can
append an exception list in its response, during the initial-
ization phase, designating the incompatible domains.

However, we note that if the attacker intercepts the ini-
tialization phase of the protocol, then she could perform
a protocol downgrade attack, by providing false excep-
tion claims or exception lists in her response.

To prevent downgrade attacks, the browser should ver-
ify any exception that was received during the initializa-
tion phase, upon every subsequent connection.
If the
attacker intercepted the initialization phase and replied
with fake exception claims, then if any of the subsequent
connections reaches the legitimate server, the browser,
with the help of the legitimate server, would detect the

USENIX Association  

23rd USENIX Security Symposium  681

Exception claim
2a: Verify exception claim!
2b: Invariance violation

1a: Init message!
1b: Exception claim

www.example.com

rb

1a

‘Init’, rb

exception 

claim

TLS
cidb

1b

Exception)claim:)“I)don’t)

support)SISCA”
“www.example.com)do)you)
really)not)support)SISCA?”

2a

‘Verify’, …

‘Alert’

2b

TLS
cidb

www.example.com
Keys ks1, ks2

“False,)I)
do)support)

SISCA”

Figure 11: Preventing downgrade attacks (same-origin case).

attack. This scenario is illustrated in Figure 11.

Regarding cross-origin communication, in order to
help SISCA-enabled legitimate servers detect fake excep-
tion lists previously received by the browser, SISCA pro-
tocol messages should include (in the X-Server-Inv
header) the origin associated with the SISCA instance.
Suppose for example,
that the browser executes the
initialization phase with www.example.com which sup-
ports SISCA (executes the protocol normally), but also
includes an exception list stating that it performs cross-
origin requests to shop.example.com which does not
support SISCA. Whenever the browser connects to
shop.example.com to perform a cross-origin request
from www.example.com, the browser includes the ori-
gin of the SISCA instance (www.example.com) and asks
shop.example.com whether it indeed does not sup-
port SISCA with respect to that origin. Assuming that
the connection was not intercepted, shop.example.com
can leverage the supplied origin information to decide
whether the exception reported by the browser is valid.
If not, then it should abort processing the request and
notify the browser of the detected attack. Note that the
above assumes that each SISCA-enabled server is aware
of all the domains that is compatible to execute SISCA
with (i.e., domains with which it shares the same SISCA
keys), which is not difﬁcult to implement.
3rd Party Content Inclusion. As mentioned above, a
domain, say www.example.com, implementing SISCA
can still perform cross-origin requests to incompatible
3rd party domains as long as it designates those domains
as exceptions for the protocol. This of course means that
TLS connections to those domains will not be protected
by SISCA, and could be MITM-ed by the attacker to per-
form a user impersonation attack on www.example.com.
This can be indeed the case if www.example.com in-
cludes active content [39] (in particular, JavaScript and
CSS) from those domains. Embedding JavaScript from
3rd party sites is generally not recommended, and usu-

ally there are ways of avoiding it [41]. Furthermore, de-
pending on the use case, it may be possible to use iframes
to isolate active 3rd party content, instead of directly em-
bedding it within the target origin, in order to mitigate
the risk (the sandbox attribute can help even further).

The embedding of passive content only, such as im-
ages, does not give the attacker the ability to execute
her code within the target origin. Hence, with respect to
preventing user impersonation, such embeddings are safe
and do not undermine the security offered by SISCA.
3.2.7 Resource Caching

Caching of static resources, such as scripts and images,
helps reduce web page loading times as well as server
resource consumption. However, the way caching is cur-
rently implemented [23, 25] can give a MITM attacker
the opportunity to subvert SISCA.

In brief, during one browsing session, the attacker in-
tercepts all TLS connections and ensures that a legiti-
mate, yet maliciously modiﬁed script that is required by
the target web server is cached by the browser. Then, dur-
ing a second browsing session, the attacker lets all con-
nections pass through. When the legitimate web page
asks for the inclusion of the aforementioned script, the
browser will load it from cache, essentially enabling the
execution of the attacker’s malicious code. The attacker
will thus be able to access the target web server.

To prevent the above attack, we need to change the
way caching is performed for active content that would
enable this attack (JavaScript and CSS ﬁles). We need to
make sure that the browser always communicates with
the server in order to verify that the cached version is
the most recent and also the correct one (i.e., not mali-
ciously modiﬁed). Thus, caching of such ﬁles should be
performed only using Entity Tags (ETags) [23], but in a
more rigorous way than speciﬁed in the current HTTP
speciﬁcation. In particular, if a web server wishes to in-
struct a browser to cache a JavaScript or CSS ﬁle, the
server should use an ETag header which always contains
a cryptographic hash of the ﬁle. The browser, before us-
ing, and caching the ﬁle should verify that the supplied
hash is correct. Subsequently, before the browser uses
the cached version of the ﬁle, it ﬁrst veriﬁes that the lo-
cal version matches the version of the server (using the
If-None-Match header, as currently done).
3.2.8 Key Rotation

In SISCA, the server has a pair of secret keys, ks1 and
ks2. To resist key compromise (i.e., MITM+key attack-
ers), these keys, unlike the server’s private key, can be
easily rotated. This is because the SISCA keys need not
undergo any certiﬁcation process, and can thus be rotated
frequently, e.g., weekly, daily, or even hourly. The more
frequent the rotation the smaller the attacker’s window of

682  23rd USENIX Security Symposium 

USENIX Association

opportunity to successfully mount MITM attacks.

The key transition, of course, has to be performed such
that it does not break the execution of active browser
SISCA instances that rely on the previous keys. At a
high level, one way of achieving this, is to have the server
keep previous keys for a certain period of time (i.e., allow
partial overlap of keys). This can enable browsers with
active SISCA instances that rely on the previous keys
to securely transition to new protocol parameters, i.e., t1
and t2, computed using the new server SISCA keys.

For domains served by a single machine, this is only a
matter of implementing the corresponding functionality
in the web server software (e.g., Apache). For multiple
domains controlled by the same entity and served by mul-
tiple machines, located in the same data center or even in
different data centers across the world, arguably more ef-
fort is required in order to distribute the ever-changing
keys and keep the machines in sync. Nevertheless, a sim-
ilar mechanism is needed for enabling TLS forward se-
crecy while supporting TLS session tickets [34]. Accord-
ing to Twitter’s ofﬁcial blog [30], Twitter engineers have
implemented such a key distribution mechanism.

3.2.9 SISCA Beneﬁts and Drawbacks

SISCA offers the following advantages regarding
MITM+certiﬁcate attack prevention. Compared to multi-
path probing solutions, SISCA does not rely on any third
party infrastructure, trusted or not. Since SISCA is built
on top of Channel ID-based authentication, it has to as-
sume that no MITM attack takes place during user en-
rollment. Nevertheless, after this step, no “blind” trust
is required when the user uses a new or clean browser,
contrary to pinning solutions (except preloaded pins), as
discussed in Section 3.2.4. Moreover, in SISCA no user
decision is necessary whenever server invariance viola-
tion is detected. This can occur either due to an attack,
or due to an internal server fault, thus the browser can
abort (possibly after retrying) the session. SISCA is
scalable since it can be deployed incrementally by web
providers (assuming browser support). Finally, SISCA
resists MITM+key attacks, assuming that the attacker
does not persistently compromise the server.

The main disadvantage of SISCA is that it only pro-
tects against MITM attackers whose goal is to imperson-
ate the user to the server. This is arguably the most com-
mon and impactful attacker goal. SISCA does not pro-
tect against attackers whose objective is to provide fake
content to the user. In such cases the attacker can sim-
ply intercept all connections and interact with the user
by serving her own, fake content. In contrast, the tech-
niques that focus on ensuring the correctness of server
authentication (Section 3.1) can protect against such at-
tacks (MITM+certiﬁcate attackers). As a result, a recom-
mended strategy would be to use SISCA in conjunction

with any of these techniques. Finally, SISCA requires co-
ordination between an entity’s different domains, in the
sense they must have access to the same SISCA keys.
This is needed for securing cross-origin communication
and, depending on the scale of the entity, can be challeng-
ing from an engineering perspective to set up.
3.2.10
SPDY. SPDY [6] multiplexes concurrent HTTP requests
over the same TLS connection to improve network per-
formance.
In order for SISCA to be compatible with
the general SPDY functionality, the browser must ensure
that before the SISCA protocol is completed successfully
(i.e., the ﬁrst request/response pair is exchanged), no fur-
ther requests are sent through the SPDY connection.

Interaction With Other Web Technologies

Furthermore, SPDY IP Pooling allows, under certain
circumstances, HTTP sessions from the same browser to
different domains (web origins) to be multiplexed over
the same connection. Version 3 of SPDY is compatible
with Channel IDs (recall that different Channel IDs may
need to be used for different origins, but now there is
only one TLS connection). SISCA is compatible with IP
Pooling, as long as the browser manages the multiplexed
HTTP sessions independently, with respect to the execu-
tion of the SISCA protocol.
WebSocket. SISCA is compatible with the WebSocket
protocol [21], when the latter is executed over TLS. This,
of course assumes that (i) Channel IDs are used for the
WebSocket TLS connections, (ii) the SISCA protocol is
executed during the WebSocket handshake (i.e., ﬁrst re-
quest/response pair), and (iii) JavaScript is not be able to
manipulate the X-Server-Inv header.
Web Storage. Web Storage [27] is an HTML5 feature
that allows a web application to store data locally in the
browser. SISCA can protect code.sessionStorage
(temporary storage), but does not prevent a MITM
in
attacker
so
window.localStorage
no sensitive information should be stored there.
Ofﬂine Web Applications. HTML5 offers Ofﬂine Web
Applications [26] which allow a website to create an of-
ﬂine version, stored locally in the browser. As with reg-
ular ﬁle caching (see Section 3.2.7), this feature can be
leveraged by the attacker to bypass SISCA. Making this
feature secure requires the introduction of design con-
cepts similar to what we proposed for regular caching.
Other Client-Side Technologies. The attacker might at-
tempt to leverage various active client-side technologies
besides JavaScript, such as Flash, Java and Silverlight.
Such technologies allow the attacker to create direct TLS
connections to the legitimate server. Some of the APIs
offered by those technologies also allow the attacker to
forge and arbitrarily manipulate HTTP headers, includ-
ing cookie-related headers or the X-Server-Inv header.

stored
storage),

(permanent

from accessing

information

USENIX Association  

23rd USENIX Security Symposium  683

However, provided that Channel IDs and SISCA are not
integrated with these technologies5, the attacker will not
be able to impersonate the user and compromise his ac-
count on the legitimate server.
3.3 Prototype SISCA Implementation

We created a proof of concept implementation of the
basic SISCA protocol, with additional support for cross-
origin communication, provided that the same Channel
ID is used. On the server side we use Apache 2.4.7
with OpenSSL 1.0.1f, patched for Channel ID support.
SISCA is implemented as an Apache module and con-
sists of 313 lines of C code. On the client side we imple-
ment SISCA by modifying the source code of Chromium
35.0.1849.0 (252194) and the WebKit (Blink) engine.
We make a total of 319 line modiﬁcations (insertion-
s/deletions) in existing ﬁles and we add 6 new ﬁles con-
sisting of 418 lines of C++ code.

We use Base64 encoding for binary data transmis-
sion. When using 128-bit random values (rb and rs)
and HMAC-SHA256 (i.e., 256-bit tags, t1 and t2), the
client’s lengthiest message is 114 bytes long, plus the ori-
gin of the SISCA instance that has to be sent as well. The
server’s lengthiest message is 132 bytes long.

We ﬁnally veriﬁed that our implementation success-

fully blocks our proof of concept MITM-SITB attack.
Performance Evaluation. To assess the performance
overhead imposed by SISCA (the server invariance part,
not the overhead due to Channel IDs), we measured
the latency of HTTP request/response roundtrips, with
SISCA enabled and disabled. For the measurements we
used a 4KB HTML page, as well as an 84KB jQuery
compressed ﬁle, retrieved over a domain that we set up
as being “cookieless”. Chromium ran on a Macbook Pro
laptop (2.3GHz CPU, 8GB RAM) and Apache ran on
a typical server machine (six core Intel Xeon 2.53GHz,
12GB RAM), connected through the campus network.

We found that the overhead of the basic SISCA proto-
col is negligible, as no increase in latency was measured
(averaged over 300 repetitions). Moreover, the HTTP re-
quest to the cookieless domain was able to ﬁt in a single
outgoing packet (a typically desired objective).

Regarding cross-origin communication over different
Channel IDs (see Section 3.2.6), approximately 180
bytes are further added to the request (one ECDSA pub-
lic key and signature in Base64 encoding), which can still
ﬁt in a single packet (for cookieless domain requests).
Furthermore, the server has to perform one ECDSA sig-
nature veriﬁcation. This overhead could be minimized,
if the browser used the same Channel ID, not only for
subdomains of the same domain, but also for domains be-

5This, for example, means that a TLS connection created by such
an API will have to create and use its own Channel IDs, and that the
browser will not execute SISCA over those connections.

longing to the same entity. Although we do not elaborate
on this idea here, this could be heuristically determined
by the browser, based on which domains are involved in
the execution of the same SISCA instance.

Finally, recall that a SISCA instance is executed only
once per TLS connection and not on every HTTP re-
quest/response.
4 Related Work

A signiﬁcant amount of research in the past years sur-
rounds the security of the TLS protocol, in the context
of web applications (i.e., HTTPS), as well as web server
and client authentication. A comprehensive overview is
provided in [10], which, among others, surveys existing
primitives that try to enhance the CA trust model in order
to more effectively address MITM attacks.

The use of server impersonation for the compromise
of the user’s account by serving the attacker’s script to
the victim’s browser was ﬁrst introduced in [32]. In this
attack, called dynamic pharming, the attacker exploits
DNS rebinding vulnerabilities in browsers, by dynami-
cally manipulating DNS records for the target server, in
order to force the user’s browser to connect either to the
attacker (to inject her script) or to the legitimate server.
MITM-SITB is therefore very similar to dynamic
pharming in that it leverages server impersonation to
serve the script to the victim’s browser. Dynamic pharm-
ing focuses on the attacker’s ability to control the client’s
network trafﬁc via DNS attacks, while in this paper we
do not make such assumptions.
Instead, MITM-SITB
can leverage any form of MITM where the attacker con-
trols the communication to the client (e.g., an attacker sit-
ting on a backbone) and relies only on the behavior of the
browser to re-establish a connection (with the legitimate
server) once the attacker closes the connection within
which she injected her script to the browser. Dynamic
pharming can equally be used to successfully attack
Channel ID-based solutions. Recently, the act of leverag-
ing script injection via server impersonation against TLS
client authentication was also discussed in [47].

We note that MITM-SITB (as well as dynamic pharm-
ing) differs from Man-In-the-Browser (MITB) [45]. The
latter implies that the attacker is able to take full control
of the browser by exploiting some vulnerability, or in-
stalling a malicious browser plugin. In MITM-SITB, the
attacker runs normal JavaScript code within the target
web origin and only within the boundaries established
by the JavaScript execution environment. Therefore, no
browser exploitation is required. Similarly, MITM-SITB
is different from XSS [44]. In XSS the attacker is able
to inﬂuence only parts of the served document (by ex-
ploiting a script injection vulnerability), while in MITM-
SITB she is able to impersonate the server and thus in-
ﬂuence the entire HTTP response sent to the browser.

684  23rd USENIX Security Symposium 

USENIX Association

SISCA does not prevent MITB or XSS and addressing
these attacks is orthogonal to our work.

To prevent dynamic pharming, the locked same-origin
policy (SOP) was proposed [32]. Weak locked SOP
considers attackers with invalid certiﬁcates, while strong
locked SOP also defends against attackers with valid,
mis-issued certiﬁcates. Strong locked SOP reﬁnes the
concept of origin by including the public key of the
server and can also accommodate for multiple server
keys. Strong locked SOP isolates web objects coming
from connections with not endorsed server public keys in
a separate security context (i.e., different origin). Strong
locked SOP per se does not prevent a MITM attacker
from mounting a conventional MITM attack in order to
impersonate the user. A strong client authentication solu-
tion should be used in conjunction, as with SISCA.

Locked SOP does not resist MITM+key attacks, as
SISCA does. Moreover, locked SOP is not able to se-
cure cross-origin active content inclusion. The risks in-
volved when a web page imports active content, such as
JavaScript, that can be intercepted and modiﬁed by an
attacker are discussed in [31]. SISCA can secure cross-
origin inclusions as long as the involved domains belong
to the same entity and thus share the same SISCA keys.
The current Channel ID speciﬁcation [4] was recently
found to be vulnerable to triple handshake attacks [7],
which affect TLS client authentication in general. The
mitigation proposed in [7] has already been implemented
in the version of Chromium that we used in this work.
SISCA assumes that Channel IDs work as expected, so
eliminating triple handshake attacks is essential for its
security. However, we note that addressing triple hand-
shake attacks does not prevent MITM-SITB attacks.

Recent work has proposed leveraging Channel ID-
based authentication to strengthen federated login [16]
and Cloud authorization credentials [8], against MITM
attacks and credential theft in general. However, such
proposals fail to address MITM attacks, as they are sus-
ceptible to MITM-SITB, unless augmented with server
invariance, as we propose in this paper with SISCA.

Server invariance is based on sender invariance which
was formally deﬁned in [17]. SISCA is inspired by this
notion, assuming that the server’s authenticity cannot be
established via server certiﬁcate veriﬁcation and instead
trying to enforce the weaker property of invariance.
5 Conclusion

In this paper we discussed the requirements to effec-
tively preventing TLS MITM attacks in the context of
web applications, when the attacker’s goal is to imper-
sonate the user to the legitimate server and gain access to
the user’s account and data. Striving to defeat this type
of attack is essential, especially given the recent revela-
tions about government agencies (e.g., the NSA) mount-

ing such attacks in order to perform mass surveillance
against users of major internet services [18, 48].

We showed that strong client authentication alone,
such as the recently proposed Channel ID-based authenti-
cation, cannot prevent such attacks. Instead, strong client
authentication needs to be complemented with the con-
cept of server invariance, which is a weaker and easier
to enforce property than server authentication. Our so-
lution, SISCA, shows that server invariance can be im-
plemented with minimal additional cost on top of the
proposed Channel ID-based approaches, and can be de-
ployed incrementally, thus making it a scalable solution.
Given its security beneﬁts, we believe that SISCA can
act as an additional, strong protection layer in conjunc-
tion with existing proposals that focus on amending to-
day’s server authentication issues, towards the effective
prevention of TLS MITM attacks.
Acknowledgements

We thank our shepherd Dan Wallach, the anonymous
reviewers, as well as Kari Kostiainen, Arnis Parsovs,
Hubert Ritzdorf, Mario Strasser and Der-Yeuan Yu for
their valuable feedback and insights. Some of the icons
that are used in this work were taken and adapted from
opensecurityarchitecture.org.
References
[1] The Heartbleed Bug. http://heartbleed.com/.
[2] ADKINS, H.

An update on attempted man-in-the-middle
http://googleonlinesecurity.blogspot.ch/

attacks.
2011/08/update-on-attempted-man-in-middle.html.

[3] AUBOURG, J., SONG, J., STEEN, H. R. M., AND VAN
KESTEREN, A. XMLHttpRequest (W3C Working Draft). http:
//www.w3.org/TR/2012/WD-XMLHttpRequest-20121206/.
Transport Layer
v01 (IETF Internet-Draf).

[4] BALFANZ, D., AND HAMILTON, R.

Security (TLS) Channel
http://tools.ietf.org/html/draft-balfanz-tls-
channelid-01, 2013.

IDs,

[5] BARTH, A. The web origin concept (RFC 6454).

//tools.ietf.org/html/rfc6454, 2011.

http:

[6] BELSHE, M., AND PEON, R. SPDY protocol (IETF Internet-
http://tools.ietf.org/html/draft-mbelshe-

Draf).
httpbis-spdy-00, 2012.

[7] BHARGAVAN, K., DELIGNAT-LAVAUD, A., FOURNET, C.,
PIRONTI, A., AND STRUB, P.-Y. Triple handshakes and cookie
cutters: Breaking and ﬁxing authentication over TLS. In IEEE
SP (Oakland), 2014.

[8] BIRGISSON, A., POLITZ, J. G., ERLINGSSON, U., TALY, A.,
VRABLE, M., AND LENTCZNER, M. Macaroons: Cookies with
contextual caveats for decentralized authorization in the Cloud.
In NDSS, 2014.

[9] BRIGHT, P.

ity for Comodo Hack.
comodo_hack/.

Independent Iranian Hacker Claims Responsibil-
http://www.wired.com/2011/03/

[10] CLARK, J., AND VAN OORSCHOT, P. C. SoK: SSL and HTTPS:
Revisiting past challenges and evaluating certiﬁcate trust model
enhancements. In IEEE SP (Oakland), 2013.

USENIX Association  

23rd USENIX Security Symposium  685

[11] COATES, M.

in two TurkTrust certiﬁ-
cates.
https://blog.mozilla.org/security/2013/01/
03/revoking-trust-in-two-turktrust-certficates/.

Revoking trust

[12] CZESKIS, A., AND BALFANZ, D. Protected login.

2012.

In USEC,

[13] CZESKIS, A., DIETZ, M., KOHNO, T., WALLACH, D., AND
BALFANZ, D. Strengthening user authentication through oppor-
tunistic cryptographic identity assertions. In CCS, 2012.

[14] DIERKS, T., AND RESCORLA, E. The Transport Layer Security
(TLS) protocol, version 1.2 (RFC 5246). http://tools.ietf.
org/html/rfc5246, 2008.

[15] DIETZ, M., CZESKIS, A., BALFANZ, D., AND WALLACH,
D. S. Origin-bound certiﬁcates: A fresh approach to strong client
authentication for the web. In USENIX Security, 2012.

[16] DIETZ, M., AND WALLACH, D. S. Hardening Persona – Im-

proving federated web login. In NDSS, 2014.

[17] DRIELSMA, P. H., M ¨ODERSHEIM, S., VIGAN `O, L., AND
BASIN, D. Formalizing and analyzing sender invariance. In FAST,
2006.

[18] ECKERSLEY, P. A Syrian MITM attack against Facebook.

https://www.eff.org/deeplinks/2011/05/syrian-
man-middle-against-facebook.

[19] ECKERSLEY, P. The Sovereign Keys project. https://www.

eff.org/sovereign-keys.

[20] EVANS, C., PALMER, C., AND SLEEVI, R.

Public
key pinning extension for HTTP (IETF Internet-Draf).
http://tools.ietf.org/html/draft-ietf-websec-
key-pinning-09, 2013.

[21] FETTE, I., AND MELNIKOV, A. The WebSocket protocol (RFC

6455). http://tools.ietf.org/html/rfc6455, 2011.

[22] FIDO ALLIANCE. Universal 2nd Factor (U2F) overview, Ver-
sion 1.0 (review draft). http://fidoalliance.org/specs/
fido-u2f-overview-v1.0-rd-20140209.pdf.

[23] FIELDING, R., GETTYS, J., MOGUL, J., FRYSTYK, H., MAS-
INTER, L., LEACH, P., AND BERNERS-LEE, T. Hypertext Trans-
fer Protocol – HTTP/1.1 (RFC 2616). http://tools.ietf.
org/html/rfc2616, 1999.

[24] GOOGLE DEVELOPERS.

Minimize

request overhead.

https://developers.google.com/speed/docs/best-
practices/request.

[25] GOOGLE DEVELOPERS.

Optimize caching.

https:

//developers.google.com/speed/docs/best-
practices/caching.

[26] HICKSON,
ing draft).
current-work/multipage/offline.html.

Ofﬂine web applications (HTML 5 work-
http://www.whatwg.org/specs/web-apps/

I.

[27] HICKSON, I. Web storage (W3C Recommendation). http://

www.w3.org/TR/webstorage/.

[28] HIGGINS, P.

Pushing for perfect

important web privacy protection.
org/deeplinks/2013/08/pushing-perfect-forward-
secrecy-important-web-privacy-protection.

forward secrecy, an
https://www.eff.

[29] HOFFMAN, P., AND SCHLYTER, J. The DNS-Based Authen-
tication of Named Entities (DANE) Transport Layer Security
(TLS) protocol: TLSA (RFC 6698). http://tools.ietf.
org/html/rfc6698, 2012.

[30] HOFFMAN-ANDREWS,

J.

Forward secrecy at Twitter.

https://blog.twitter.com/2013/forward-secrecy-
at-twitter-0.

[31] JACKSON, C., AND BARTH, A. Beware of ﬁner-grained origins.

In Web 2.0 Security and Privacy, 2008.

[32] KARLOF, C., SHANKAR, U., TYGAR, J. D., AND WAGNER, D.
Dynamic pharming attacks and locked same-origin policies for
web browsers. In CCS, 2007.

[33] KIM, T. H.-J., HUANG, L.-S., PERRIG, A., JACKSON, C., AND
GLIGOR, V. Accountable Key Infrastructure: A proposal for a
public-key validation infrastructure. In WWW, 2013.

[34] LANGLEY, A.

How to botch TLS forward secrecy.

https://www.imperialviolet.org/2013/06/27/
botchingpfs.html.

[35] LANGLEY, A. Protecting data for the long term with forward
secrecy.
http://googleonlinesecurity.blogspot.ch/
2011/11/protecting-data-for-long-term-with.html.
[36] LAURIE, B., LANGLEY, A., AND KASPER, E. Certiﬁcate
transparency (RFC 6992). http://tools.ietf.org/html/
rfc6962, 2013.

[37] MARLINSPIKE, M. Convergence. http://convergence.io/.
[38] MARLINSPIKE, M., AND PERRIN, T. Trust Assertions for Cer-
tiﬁcate Keys (TACK) (IETF Internet-Draft). http://tack.io/
draft.html, 2013.

[39] MOZILLA DEVELOPER NETWORK.

Mixed
https://developer.mozilla.org/en-US/docs/
Security/MixedContent.

content.

[40] MOZILLA DEVELOPER NETWORK.

Same-origin policy.

https://developer.mozilla.org/en-US/docs/Web/
JavaScript/Same_origin_policy_for_JavaScript.

[41] NIKIFORAKIS, N.,

INVERNIZZI, L., KAPRAVELOS, A.,
VAN ACKER, S., JOOSEN, W., KRUEGEL, C., PIESSENS, F.,
AND VIGNA, G. You are what you include: Large-scale evalua-
tion of remote Javascript inclusions. In CCS, 2012.

[42] OPPLIGER, R., HAUSER, R., AND BASIN, D. SSL/TLS session-
aware user authentication - Or how to effectively thwart the man-
in-the-middle. Computer Communications 29, 12 (2006), 2238–
2246.

[43] OPPLIGER, R., HAUSER, R., AND BASIN, D. SSL/TLS session-
aware user authentication revisited. Computers & Security 27,
3-4 (2008), 64–70.

[44] OWASP. Cross-site Scripting (XSS). https://www.owasp.

org/index.php/Cross-site_Scripting_(XSS).

[45] OWASP. Man-in-the-browser attack. https://www.owasp.

org/index.php/Man-in-the-browser_attack.

[46] PAOLA, S. D., AND FEDON, G. Subverting Ajax. 23rd Chaos

Communication Congress, 2006.

[47] PARSOVS, A. Practical issues with TLS client certiﬁcate authen-

tication. In NDSS, 2014.

[48] SCHNEIER, B. New NSA leak shows MITM attacks against
major Internet services. https://www.schneier.com/blog/
archives/2013/09/new_nsa_leak_sh.html.

[49] SOGHOIAN, C., AND STAMM, S. Certiﬁed lies: Detecting and
In FC,

defeating government interception attacks against SSL.
2011.

[50] STERNE, B., AND BARTH, A. Content Security Policy 1.0 (W3C
Candidate Recommendation). http://www.w3.org/TR/CSP/.
[51] SUNSHINE, J., EGELMAN, S., ALMUHIMEDI, H., ATRI, N.,
AND CRANOR, L. F. Crying wolf: An empirical study of SSL
warning effectiveness. In USENIX Security, 2009.

[52] WENDLANDT, D., ANDERSEN, D. G., AND PERRIG, A. Per-
spectives: Improving SSH-style host authentication with multi-
path probing. In USENIX ATC, 2008.

686  23rd USENIX Security Symposium 

USENIX Association

