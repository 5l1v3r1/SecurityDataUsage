Smart and Secure Cross-Device Apps for the

Internet of Advanced Things

Christoph Busold1, Stephan Heuser1, Jon Rios1, Ahmad-Reza Sadeghi2, and

N. Asokan3

1 Intel CRI-SC, TU Darmstadt

2 TU Darmstadt/CASED

3 Aalto University and University of Helsinki

{christoph.busold,stephan.heuser,rios.jon,ahmad.sadeghi}@trust.cased.de,

asokan@acm.org

Abstract. Today, cross-device communication and intelligent resource
sharing among smart devices is limited and inÔ¨Çexible: Typically devices
cooperate using Ô¨Åxed interfaces provided by custom-built applications,
which users need to install manually. This is tedious, time consuming,
bears security and privacy risks, and contrasts the idea of Internet of
Things (IoT) where intelligent devices operate in concert to enrich the
overall user experience by sharing resources and capabilities.
We present Xapp, a context-aware service mobility framework for An-
droid. Our goal is to enable users to securely distribute the functionality
of applications to mutually untrusted smart devices, e.g., to enable a
smartphone to use a nearby Android TV screen as a display for a video
call, let a smartphone navigation app direct an autonomous vehicle, or
let it use the vehicle for an object-recognition task rather than using
a cloud service with the attendant privacy risks. We built a prototype
for Android as the Ô¨Årst step towards this goal. Our system is a set of
extensions to the existing Remote-OSGi service platform, an emerging
industry standard which unfortunately does not secure the communica-
tions between devices. This paper describes our proposal for the required
security architecture. We designed and implemented an authentication
protocol suite, where trust is bootstrapped using NFC for the sake of
usability. On top of this we built a Ô¨Åne-grained access control system
so that mutually mistrustful Xapp apps can be used simultaneously in
the same neighborhood and even on the same devices. Hence, with Xapp
users can run an Android app across multiple devices without having to
install it on each of them individually. As proof of concept we present
the implementation and evaluation of a video call app.

1

Introduction

Advanced embedded devices have been undergoing a dramatic development in
the last decade: diÔ¨Äerent classes of devices in diÔ¨Äerent form factors, ranging
from personal information and entertainment devices (e.g., smartphones, tablets,

smart TVs, wearables, automotive head units for smart cars to industrial au-
tomation systems and sensors in smart factories, are being equipped with increas-
ing computing, storage and wireless communication capabilities. The Internet of
Things (IoT) promises to intelligently interconnect these devices where applica-
tions adapt to available resources in the environment and share their capabilities
to improve the user-experience and maintainability signiÔ¨Åcantly: Consider for in-
stance placing a video call from a smartphone using a nearby Android TV [2]
as a display; a smartphone navigation app using the more precise GPS sen-
sors and larger display of the head unit available in a modern vehicle; letting
a navigation app direct an autonomous vehicle, or resource-constrained devices
outsourcing computationally expensive tasks (e.g., object recognition) to other
more powerful devices.

However, today the ability for such intelligent and adaptive device collabo-
ration falls short. Current network discovery and media sharing protocols, like
UPnP [47], DLNA [16], Apple Airplay [5] or Samsung AllShare [40], limit them-
selves to a set of pre-deÔ¨Åned services. More sophisticated use-cases for advanced
device collaboration, be it in the area of smart vehicles, smart buildings or per-
sonal entertainment, require custom software components that have to be in-
stalled, managed and conÔ¨Ågured individually on each device. This is tedious,
time consuming, and poses security and privacy risks. Moreover, existing solu-
tions for collaboration among devices based on migrating code from one device
to another (e.g., [37,20]) do not adequately address the security and privacy
risks.
Our goal and contributions. We present Xapp, a context-aware service mo-
bility framework for Android, which aims at enhancing resource sharing among
advanced IoT devices. Our main contributions are as follows:

1. The design of a framework that enables users to securely run an Android
app across multiple devices without having to install it on each of them
individually.

2. The design and implementation of an authentication protocol suite where

trust is bootstrapped using NFC for the sake of usability (Section 3).

3. A prototype of this framework on the service-based R-OSGi [36,39] software
stack, an emerging industry standard which we extended with mechanisms
for Ô¨Åne-grained access control and secure communication (Section 4).

4. A proof-of-concept evaluation of a video calling application built using Xapp

(Section 5 and 6).

Xapp diÔ¨Äers from prior work (Section 7) on distributed cross-device functionality
in two major aspects. First, it provides Ô¨Åne-grained access control on sensitive
resources using a lightweight token-based authentication and authorization sys-
tem. Second, it allows users to keep sensitive assets on their trusted devices. By
adopting standard technologies where possible, Xapp supports multiple COTS
operating systems and can be deployed either as a system-centric platform com-
ponent or be installed as an app without changes to the underlying operating
system.

Fig. 1. System Model: Entities and Interaction

2 System Model

2.1 Entities and Interactions

its screen, camera and microphone).

Our system model, presented in Figure 1, involves the following entities:
‚Äì The Host H provides resources R to other devices (e.g., a smart TV sharing
‚Äì The Manager M grants access to resources R on H to other devices (e.g.,
‚Äì The Client C initiates the communication and distributes parts of its appli-

the smartphone of the smart TV‚Äôs owner).
cation to H in order to use resources R.
In our model entities are devices in a network, identiÔ¨Åed by their IP addresses
resolved by using service discovery (cf. Section 7). Applications are partitioned
into a set of modules M, which represent diÔ¨Äerent tasks implemented by the
application and depend on a set of available resources R. This module-based
approach is in line with recent component-based programming models used,
for instance, Android (cf. Section 4.1). We use cryptographic access tokens T to
authenticate a client C to a host H and to deÔ¨Åne C‚Äôs privileges to access resources
R on H. Consider a video call where a user wants to access the resources of a
smart TV with her smartphone. In Figure 1 the client C1 (user‚Äôs smartphone)
requests an access token T for H (smart TV) as well as resources RA and RB (e.g.,
camera and microphone to place a video call) from M (TV owner‚Äôs smartphone).
The owner authorizes this request using a graphical user interface on M. Client
C2 similarly requests an access token T for H and RC (e.g., Internet connection).
They upload their respective application modules M1,3, M2,3 and M2,4 to H.
After access tokens have been issued, M does not have to be involved at runtime
anymore. The modules on the clients C1 and C2 and the modules on H form the
distributed applications App1 and App2.

2.2 Threat Model

External Adversary. The main security objective of our solution is to prevent
unauthorized access from one device to sensitive resources R of another device.

 Host H1 (Smart TV)  Host H1 (Smart TV) Client C2 (e.g., Smartphone)  Manager M (e.g., Owner‚Äòs  Smartphone)  Host H  (e.g., Owner‚Äòs  Smart TV) Client C1 (e.g., Smartphone)  M1,1 M1,2 M2,1 M2,2 Deploys Modules Deploys Modules Provides Access Token T to Client Access Control Layer M1,3 M2,4 M2,3 RA RB RC ùê¥ùëùùëù1 ùê¥ùëùùëù2 Provides Access Token T to Client External attackers Aext are classical Dolev-Yao adversaries [17]: They do not
have access to any of the devices or application modules M involved, but have
full control over the network and thus can eavesdrop, manipulate, inject and
replay messages. Such an attack could be used, for example, to inject malicious
code into an application module, which is transmitted to another device.
Internal Adversary. Each client C, host H or application module can poten-
tially be an internal attacker Aint, resulting in two possible scenarios. First, a
malicious C can send a malicious module to H in order to gain unauthorized
access to resources R and sensitive information, or even infect the platform or
other modules M on H. Xapp should mitigate attacks from the malicious module
on H or any other application modules M running on it.
Second, a malicious host H, hosting application modules M, may attempt to
compromise the client application, for example by tampering with modules M
running on H. Xapp should support the developer in protecting his application
against such attacks by storing and processing sensitive data only on the user‚Äôs
trusted device (e.g., his smartphone acting as client C).

2.3 Objectives and Assumptions
Assumptions. Every host H trusts its manager M and vice versa. This means,
H defers to M as the authority who deÔ¨Ånes access control policies for local
resources R, and M trusts H to enforce these access control policies correctly.
Moreover, the operating system and deployed software on H provide sound pro-
tection against privilege escalation attacks, i.e., we assume that a module de-
ployed by Aint cannot bypass existing access control mechanisms.
Security Objectives. Given our assumptions our main security objective is
that a user‚Äôs sensitive data, applications and modules M on the user‚Äôs own de-
vice (client C), are protected from the internal adversary Aint on a host H. Fur-
thermore, Aint can neither compromise other sensitive applications nor modules
M and their data on a connected host H. An external attacker Aext cannot
gain access to any resource R by eavesdropping on or manipulating the network
channel.
Functional Objectives. The performance overhead should be low, meaning
minor user interaction and the capability to automatically move modules M
to a host H. Moreover, application modules M should run independently of
the underlying hardware and operating system. This requires compatibility with
common operating systems. Ideally Xapp should run as a third party application.

3 Design of Xapp

In this section we present the design of our cross-device application framework
Xapp. It comprises a security architecture for sandboxing modules of diÔ¨Äerent
applications and stakeholders (cf. Section 3.1) and a generic resource control
concept (cf. Section 3.2). Furthermore, Section 3.3 describes the token-based
authentication and authorization system.

Fig. 2. Xapp Architecture

3.1 Architecture Overview and High-Level Idea

Our generic architecture is shown in Figure 2. On every host H a component
called Loader L manages the modules M running on H and their privileges to
access resources R on H. L is initially installed and conÔ¨Ågured on each host,
either by the owner or by the device vendor. The owner takes ownership of L
by establishing a shared symmetric key KM between the manager M (e.g., his
smartphone) and L. For our implementation we use a key agreement protocol
over NFC due to the required physical proximity [23]. This approach is similar
to the resurrecting duckling model [45], where physical contact creates a binding
between two entities.
Xapp enables the developer to encapsulate the functionality of an application
on a client C into a set of modules M, which potentially use resources on a remote
host H. We implemented an adaptation of the extended duckling model [44] to
control which clients may upload modules to H, and which resources may be
used by a client C. When a client C wants to use resources R of H, it Ô¨Årst
requests an access token [TL] from H‚Äôs manager M (Step 1) using the Token
Issuing protocol (TI). C authenticates to L using the Secure Channel Establish-
ment protocol (SCE) with this access token (Step 2), which is forwarded to the
Resource Controller (RC) (Step 3). The relevant protocols will be explained later
in Section 3.3. Next, L creates a restricted execution environment IC (Step 4)
for modules M uploaded by C (Step 5). Modules which trust each other (e.g.,
modules belonging to the same application) may share an instance. Modules run
inside their instance IC, which provides life-cycle management. L is executed
inside a privileged instance IL with access to all resources.
In Xapp instances are created on demand and removed when they are no
longer needed, e.g., because their modules are removed. To protect H from ma-
licious modules of the internal adversary Aint, instances IC follow the principle
of least privilege, meaning that direct access to resources is limited to what is
basically required by their modules. When a module aims to access shared re-
sources on H, it queries RC located inside IL (Step 6). RC mediates access to
resources R based on a Policy PC,H included in the token [TL], as described in
the following section.

Module SystemOperating SystemModule SystemM3LLoader Instance ILInstance ICM4RCModule SystemOperating SystemClient CHost HM1M2SCE3.5. Upload Modules6.Module SystemOperating SystemManager MMMTI1.Token[TL]2.Connect4. Create InstanceSCE3.2 Resource Control Concept
When the manager M creates an authentication token [TL] for the client C, it can
bind a Policy PC,H to this token. Policies are forwarded by the Loader L to the
Resource Controller RC, which is responsible for their enforcement on H. A Pol-
icy consists of a set of individual privileges. Each privilege Privilege(R,C,H, S) =
Yes| No| Ask describes whether the instance IC may access resource R on H,
optionally limited to a given state S (e.g., time of day). The Ask value speci-
Ô¨Åes that H should consult M at runtime when IC tries to access this resource.
Policies can further contain optional lifecycle constraints to address possible re-
source starvation attacks by malicious modules. For example, M can deÔ¨Åne that
a shared resource is only accessible for a speciÔ¨Åed amount of time, or that IC
should be removed after a certain time span.
Consider the video call use case, where M creates a policy restricting the
access of C‚Äôs instance IC to the camera, microphone and screen of the smart TV
H, thereby protecting the privacy of the smart TV‚Äôs owner. Modules installed
by C are denied access to other sensitive resources, such as photos accessible by
the TV. Finally, M uses a state-aware policy to allow IC to access the camera
and microphone only when the video call module is running in the foreground
on H, and to automatically remove IC after one hour.

3.3 Authentication and Authorization Protocols

Our design includes a Ô¨Çexible and secure protocol suite providing for authenti-
cation of clients, authorization for resource access and security on the communi-
cation links. This protocol suite is based on standard cryptographic primitives
and due to space constraints we moved its details in Appendix A. Our protocol
suite also provides oÔ¨Ñine veriÔ¨Åcation, i.e., the access control token is veriÔ¨Åable
by H if its manager M is not available. OÔ¨Ñine veriÔ¨Åcation can be achieved
by token-based protocols such as Kerberos [34]. However, Kerberos requires a
database with known clients, which is managed outside the protocol. Therefore
we designed a custom token protocol, which can handle both ad-hoc as well as
long-term clients and at the same time reduces the complexity of Kerberos.
Overview. Our protocol consists of two parts (cf. Figure 2). During the Token
Issuing Protocol (TI) M issues a Token [TL] to C. [TL] is bound to a key KC,
which is computed through a DiÔ¨Ée-Hellman key agreement scheme DH between
M and C. C uses [TL] to authenticate itself to L and to establish a secure channel
using the Secure Channel Establishment Protocol (SCE). It proceeds to request
a new execution instance IC. Finally, C uses the SCE protocol to connect to IC
by creating a new token [TIC ] encrypted by KC and with a randomly chosen key
KI inside. The only setup requirement is a shared symmetric secret key between
M and H, denoted KM, which is used to authenticate and encrypt tokens with
the help of an authenticated encryption scheme AE. As noted in Section 3.1 KM
has been established during the initial pairing between M and H.
Interactive Privilege Evaluation. As described in Section 3.3, resources pro-
tected by an Ask privilege require runtime consultation of the manager M. For

Fig. 3. Architecture of the Implementation

that purpose, the relevant host H sends the identity of C and the identiÔ¨Åer of the
requested resource R together with a nonce N to M. To secure the authenticity
of M‚Äôs responses, M computes a message authentication code (MAC) over the
decision value and the original request including the nonce N using the shared
secret key KM. If H fails to verify this MAC or does not receive a response at
all within a certain time frame, it defaults to deny the request.
Revocation. Since our solution focuses on time-limited deployment of cross-
device applications via lifecycle constrains (cf. Section 3.2) we do not consider
revocation in our current implementation. However, token revocation could be
added to Xapp by means of revocation lists. The integrity and authenticity of
revocation lists can be assured using MACs based on a key derived from KM.
Alternatively, we could adopt a token status protocol comparable to OCSP [41],
but since Xapp is designed for oÔ¨Ñine token validation we deem revocation lists
to be better suited.

4

Implementation

Our implementation is based on the Apache Felix OSGi [3,36] framework and the
R-OSGi RPC layer [39]. We run our framework on Android, which serves as an
example of a modern operating system for advanced IoT devices. We highlight
the technical challenges we had to tackle and describe several security extensions
we developed for R-OSGi. Figure 3 shows the instantiated components.

4.1 Platform Considerations

Module System. We implemented the module system is on the OSGi plat-
form [36], a widely-deployed platform-independent industry standard for soft-
ware modularization. OSGi allows us to easily integrate existing solutions that
can extend our framework with further desired functionality (such as service
discovery protocols [29,47,4]), which is orthogonal to our work. OSGi divides ap-
plications into modules, called bundles. A bundle is a collection of self-contained
Java packages, arbitrary data and a manifest Ô¨Åle. This manifest contains meta
data about the bundle along with its platform requirements, provided services

OSGiAndroid OSSCLoader Instance ILInstance ICR-OSGiAndroid OSClient CHost HRCIPCLOSGiIPCR-OSGiRC-PSCR-OSGiM2-PM1M2ISLegend:IPCIPC ChannelISInstallation ServiceLLoaderM1Module 1M2Module 2M2-PProxy for M2RCResource ControllerRC-PProxy for RCSCSecure ChannelOSGiSCand dependencies on other bundles. At runtime, bundles interact via services,
which can be published to and consumed by other bundles.
Remote OSGi. The adoption of OSGi enables us to seamlessly connect mod-
ules on diÔ¨Äerent devices using the remote service layer of Remote OSGi (R-
OSGi) [39]. R-OSGi extends the concept of services in OSGi to remote services,
which can be published to and accessed from other framework instances, pos-
sibly running on diÔ¨Äerent machines. At runtime, R-OSGi can connect to other
hosts running R-OSGi and search them for available remote services.
Target Operating System. The platform independence of OSGi allows us to
instantiate our framework on a wide range of operating systems for advanced
IoT devices with diÔ¨Äerent capabilities, ranging from mobile devices and auto-
motive head units to desktop PCs and virtual machines in cloud environments.
Individual security aspects of the target operating system (most importantly
application isolation and access control) must be considered when adopting our
framework. For example, Android relies on process-level permissions and per-app
sandboxes.4

For our prototype implementation we selected Android as the target plat-
form not only because it is the most popular platform for smartphones and
tablets [19], but also because it is deployed in other IoT market segments, e.g.,
automotive [1] and home entertainment [2]. While documentation on Android
Auto is currently limited, Android TV is a standard Android distribution opti-
mized for large screens and thus allows the deployment of Xapp without further
modiÔ¨Åcations. Android is based on a Linux kernel and executes every app inside
a Java virtual machine running within a separate process under its own Linux
User Id (UID), which is set at installation time. Hence diÔ¨Äerent applications
are sandboxed at operating system level. Furthermore, Android enforces a per-
mission framework on processes, which restricts access to system services and
resources like network, Ô¨Åle system or sensors.

4.2 Loader
The Loader L (see Figure 3) is H‚Äôs interface to an external client C and exposes
its functionality to remote and local application modules via R-OSGi remote
services. This allows clients to create, remove, start and stop their instances on
a host and to deploy application modules, as explained in the following. The
Loader is implemented as a set of OSGi bundles running inside a privileged
instance IL.
Installer Service. The Installer Service (IS, cf. Figure 3) is used by L to create
and remove client instances on H. While the implementation of IS is platform-
speciÔ¨Åc, it communicates using a standardized OSGi service interface with the

4 On PCs, IBM‚Äôs Java JVM 8 provides a multi-tenancy environment [26], which eÔ¨É-
ciently isolates Java applications executed in one Java VM and uses the Java Secu-
rity Manager [27] for access control. Another approach particularly interesting in the
context of cloud-based environments is the GuestVM project [46], which provides
isolated Java runtime environments on top of the Xen hypervisor.

platform-agnostic Loader component. On Android, instances are implemented
as Android applications and isolated by Android‚Äôs sandboxing mechanism (cf.
Section 4.1). Our Installer Service IS for Android uses a base template applica-
tion in the form of an Android Application Package (APK), which includes the
OSGi framework and required bundles to communicate with C (e.g., R-OSGi).
Android apps are identiÔ¨Åed by a unique package name. Accordingly, IS rewrites
the package Ô¨Åle with a new name and conÔ¨Ågures parameters speciÔ¨Åc to the new
instance IC, such as the listening port of R-OSGi.
The Loader L can be distributed by the device manufacturer as an Android
system app or installed by the user as a standard Android app on a host H.
When app modules are deployed by a client C, the installation of the client-
speciÔ¨Åc instance IC is ideally performed silently without user interaction once H
has validated C‚Äôs access token. Due to Android-speciÔ¨Åc limitations this is only
possible when L is an Android system app: For security reasons third-party apps
cannot install or uninstall other applications silently on stock Android. Thus, if
the Loader is installed as a standard third-party app on a stock Android device,
our framework requires minimal user interaction, since the user has to approve
the installation of IC by clicking a button on H.
Resource Controller. The Resource Controller (RC) exposes resources of the
host H to a client‚Äôs instance IC using a R-OSGi service. It is executed inside the
privileged Loader instance IL, which holds all permissions required to access the
resources R (e.g., contacts or camera) exposed to instances I. Access to resources
is mediated according to the instance-speciÔ¨Åc access control policy deÔ¨Åned by M
and contained in the token [TL]. The implementation of the Resource Controller
is platform-speciÔ¨Åc, while its interface is the same on diÔ¨Äerent operating systems.
In general, there are two possible approaches to implement access control on
resources: Either the Resource Controller RC uses the existing platform-speciÔ¨Åc
access control mechanisms, or RC implements the required access control hooks
itself. Both approaches have advantages and disadvantages:

In the former case, RC maps privileges to operating system speciÔ¨Åc access
control mechanisms. For example, Android uses permissions for access control on
APIs as well as discretionary and mandatory access control [43] for kernel-level
resources. More advanced architectures [9,24] provide interfaces to programmat-
ically inÔ¨Çuence system-level access control decisions at runtime and could po-
tentially be integrated with Xapp. However, such an integration would limit our
solution and violate our interoperability requirements.

In the latter case, RC implements access control on resources itself, also
considering Ô¨Åne-grained and state-aware access control policies. We opted for
this approach in our implementation, since it does not require changes to the
underlying operating system.

4.3 Our Extensions to Remote OSGi

Our implementation provides several security extensions to the Remote OSGi
(R-OSGi) framework, as described in the following.

Secure Network Channel. The R-OSGi middleware (cf. Section 4.1) oÔ¨Äers by
default only TCP communication and provides no protection against an exter-
nal attacker Aext. To enable secure communication between the Loader instance
IL, the client C and his remote instance IC, we extended R-OSGi with a secure
network channel (SC), which provides both conÔ¨Ådentiality and integrity using au-
thenticated encryption with a symmetric key (see SCE protocol in Appendix A).

Local IPC Channel. To provide eÔ¨Écient communication between diÔ¨Äerent
OSGi frameworks in separate sandboxed instances on the same host H (e.g., IC
and IL), we implemented an IPC communication channel using domain sockets.

Channel Filter. Since the original design of R-OSGi does not diÔ¨Äerentiate
between diÔ¨Äerent network channels, a service can only decide whether it wants
to be published to remote hosts or not, and in that case it is always registered on
all available channels. This is insuÔ¨Écient, if one wants to expose a service only
via IPC to local instances executed on the same host H. Therefore, we modiÔ¨Åed
the R-OSGi implementation to include a Ô¨Ålter on communication channels, so
that services can choose the channels they are available on.

Endpoint IdentiÔ¨Åcation. Another challenge is that services do not know over
which channel and from which endpoint they were called (i.e., remotely or lo-
cally), because this connection between the function call and the originating
channel endpoint is hidden by the abstraction of R-OSGi. In our model, this
information is crucial in order to decide whether access to a service should be
granted or not, depending on the identity of the caller (i.e., modules M of a
client C executed in instance IC). Thus we implemented a function to retrieve
the identity of the current caller from R-OSGi. For the IPC channel we get the
Linux UID of the connected process and in case of the secure network chan-
nel we extract the identity from the token that was used during the channel
establishment protocol.

4.4 Xapp Development Model

To support Xapp, apps need to adhere to the (R-)OSGi programming model,
since Xapp is not limited to one speciÔ¨Åc operating system. SpeciÔ¨Åcally, develop-
ers need to integrate an OSGi runtime environment into their applications, such
as the open-source implementation Apache Felix [3], on top of which the Xapp
bundles (mainly R-OSGi and the Loader) as well as application-speciÔ¨Åc bundles
are executed. Consequently, application modules which should migrate between
hosts need to be implemented as OSGi bundles. These bundles at runtime com-
municate with other bundles on the local or remote host via OSGi services. OSGi
services are comparable to Android services in that they adhere to the same RPC
communication paradigm. To ease the work of developers who want to adopt our
solution, Xapp provides a set of service deÔ¨Ånitions for common resources, such
as contacts information, camera and microphone.

Fig. 4. Performance Evaluation (Basic Instance)

5 Evaluation

To evaluate our implementation we used two Samsung Galaxy S3 I9300 smart-
phones running Android 4.0.4 (client and manager) and a Nexus 10 Tablet run-
ning Android 4.2.1 (host) connected over a 802.11bgn wireless network. We use
the industry standard algorithms AES-256 in EAX mode as authenticated en-
cryption scheme AE and ECDH-256 as key exchange protocol DH.
Performance. We evaluated the performance of diÔ¨Äerent components in our
solution. For the Android-based implementation of the token issuing protocol
we measured the elapsed time between starting the communication with the
manager and receiving the token [TL]. Overall the protocol takes 308.28 ¬± 27.73
milliseconds on average over 20 runs.

For our framework we Ô¨Årst performed microbenchmarks to measure the time
required for creating a basic instance containing no bundles. This includes all
steps starting from verifying the access token [TL], creating the application pack-
age, installing and Ô¨Ånally starting the instance I. The results are presented in
Figure 4 and show the average and the standard deviation of the time required
to perform all steps over 20 runs. These numbers are reasonable considering that
our implementation has not been optimized for performance yet, and we refer to
our case study below for further discussion of these results. Further, we veriÔ¨Åed
that the OSGi framework incurs no noticeable performance overhead at runtime
using the Java Linpack benchmark [32] both in a regular Android app and in a
Xapp module. The average performance over 20 runs is 143.15 ¬± 0.13 MFlops
and 137.41 ¬± 0.33 MFlops respectively, which shows a small diÔ¨Äerence of 4.18%.
We also performed microbenchmarks to measure the performance impact in-
troduced by our access control architecture. In our Android-based implementa-
tion we query the contacts database to retrieve a single contact both in a regular
Android app and in a Xapp module. The process takes on average 17.47 ¬± 4.41
and 65.50 ¬± 3.86 milliseconds respectively over 1000 runs. The high standard
deviation is caused by varying system load. The diÔ¨Äerence of around 48 millisec-
onds introduced by the redirection of calls via the Resource Controller RC and
the access control enforcement is partially caused by marshalling the data over

0 ms200 ms400 ms600 ms800 ms1.000 ms1.200 msPackagingSignature UpdatingInstanceInstallationInstance Startingthe domain socket. The overhead can be reduced by mapping the memory into
the process, for example using Binder IPC, instead of copying it.
Interoperability and Portability. Our design enables the isolation of mod-
ules deployed on any operating system and hardware platform which provide
adequate sandboxing and privilege separation capabilities. Since our framework
operates on the application level, it requires no changes to the operating system,
as demonstrated by our implementation on Android. When an Android device
vendor deploys Xapp, it is even possible to install new instances without user
interaction by installing the Loader as a system app (see Section 4.1).

It should be noted that while we instantiated our framework on Android, our
architecture only requires a standard-compliant Java Runtime Environment with
an OSGi framework and a platform-dependent isolation and privilege separation
mechanism (cf. Section 4.1). Java is used on a variety of operating systems and
platforms, from smart mobile devices to mainframes, and open-source implemen-
tations of the Java Virtual Machine and a of diÔ¨Äerent OSGi implementations are
available.
Usability. Pairing of devices via NFC has been adopted for a wide range of
consumer devices, such as printers and Bluetooth speakers. Our performance
measurements (cf. Figure 4) indicate that the time required to deploy app mod-
ules on one or more hosts (cf. Figure 4) is reasonable considering the alternative,
which is to manually search, install and later uninstall an app on each host.
While the deÔ¨Ånition of access control rules in the manager app is straightfor-
ward, one possible limitation is that with a growing number of rules a user might
be tempted to always allow any requests for access to privileges by a client [18].
However, since the functionality of app modules is limited and tailored to speciÔ¨Åc
use cases, they only need access to a very limited set of resources, which limits
the number of privileges a manager has to consider.
Proof of Concept: Video Call Application. To demonstrate the advantages
and feasibility of our solution we implemented the video calling use case, where
Alice uses her smartphone (Client C) and Hector‚Äôs Smart TV (Host H) to place a
video phone call to Bob. This use case highlights an advantage of app partitioning
over just connecting the TV to the phone: The video stream does not have to
be routed through Alice‚Äôs smartphone, but can be processed and sent to the TV
directly by Bob‚Äôs smartphone. Furthermore, Xapp protects Alice‚Äôs privacy in
case the TV is untrusted, since Alice does not have to enter her login credentials
on the potentially malicious smart TV. Instead, she can keep sensitive data (e.g.,
login credentials or contact information) on her trusted device (her smartphone).
During the implementation and evaluation of Xapp we involved a team of
eight students and staÔ¨Ä members who performed preliminary usability tests by
initiating a call between two Android smartphones using a nearby smart TV
(represented by a Nexus 10 tablet, see Section 5). Currently we are working on
a more extensive and representative usability study.

Table 1 presents the performance measurement results for creating an in-
stance within this use case. In contrast to the basic instance above, these num-
bers contain a transmission phase, where modules with an overall size of 34.2

Average Time (ms)
Step
330.86 ¬±
12.86
Signature Updating
Instance Installation 1,122.16 ¬±
32.47
2,228.47 ¬±
Instance Startup
48.49
Bundle Transmission 1,837.77 ¬±
49.79
1,271.20 ¬±
Repackaging
81.16
6,790.46 ¬± 106.43
Total

Table 1. Performance Evaluation (Case Study)

KByte are sent to the host and added to the installation package, which increases
the startup time. The total time of our unoptimized case study implementation
takes about 6.79 seconds to deploy the relevant app modules on a host H, which
is comparable to downloading and installing apps via an app market. Note that
a client C can deploy modules on multiple hosts in parallel and in contrast to
classic applications our cross-device apps do not require any further lifecycle
management such as updates and conÔ¨Åguration on the involved devices.

6 Security Considerations

In this section we discuss how Xapp achieves the previously deÔ¨Åned security
goals (cf. Section 2.3).
External Adversary. An external adversary Aext needs valid access tokens to
gain access to either the loader L on host H or an instance IC deployed by a client
C. The initial pairing between H and the manager M, during which a shared
symmetric key KM is established, is performed through conÔ¨Ådential and authen-
ticated communication. In our implementation we establish this key over NFC
which is resistant against man-in-the-middle attacks due to the required physical
proximity [23]. Without knowledge of the cryptographic key KM, Aext cannot
generate a valid access token [TL] for L. Similarly the properties of NFC also
protect the authenticity of M and C when M issues a conÔ¨Ådentiality-protected
token [TL] to C. Without access to the key KC stored in the token [TL] Aext
is unable to deploy modules on H. At runtime, C and IC communicate through
authenticated and end-to-end encrypted channel. These properties are boot-
strapped from the access token [TL] issued to C by M, which prevents Aext from
communicating with the deployed instance.
Internal Adversary. As noted in Section 2.2 either a client C or a host H can
act as an internal adversary Aint. On the one hand, H has to be protected from
a malicious module deployed by C. To this end, we designed an access control
model that mediates which modules M may access sensitive resources R on H.
To implement this model the host operating system needs to run modules M
deployed in C‚Äôs instance IC in an isolated least-privilege container. Our Android-
based implementation uses the default UID-based sandboxing mechanism (cf.
Section 4.1), which eÔ¨Äectively prevents modules M from accessing sensitive re-
sources R directly. Instead, Xapp modules M use the Resource Controller RC

as a deputy who enforces the access control policy deÔ¨Åned by the manager M.
The policy is protected by our token-based authentication and access control
scheme, which ensures that it cannot be forged or modiÔ¨Åed by an internal ad-
versary Aint. Dynamic access control queries evaluated by M at runtime are
protected against impersonation, modiÔ¨Åcation and replay by message authenti-
cation codes with nonces.
On the other hand, sensitive resources R of a client C need to be protected
from a malicious host H. Xapp‚Äôs module system encourages developers to enclose
sensitive operations in separate modules. A client can decide where these mod-
ules are executed. Thus Xapp allows clients to ensure that modules accessing
or storing sensitive data, such as long-term credentials or contact information,
remain on their trusted devices. Of course the adversary could still exploit soft-
ware errors, hidden backdoors or bad application design, but this risk is not
higher than for traditional applications.
Discussion. To implement our access control model we rely on the integrity and
security of (system) software on the host (see Section 2.3). This requirement is
inherent to the solutions that operate purely on the application layer. Obviously
the internal adversary Aint could extend its privileges at runtime if he could
compromise any privileged system services. Furthermore, access control solutions
at the application layer, such as Xapp, cannot provide resilience against confused
deputy [22] or collusion [42] attacks. For example, malicious modules deployed
by diÔ¨Äerent stakeholders could combine their privileges and use inter-process
communication (IPC) to exchange sensitive assets. Reliable control on IPC would
require an extension of the underlying operating system [24,9], which is possible
but does not conform to our interoperability requirement. Moreover, we note
that attacks using side channels (e.g., [42]) are out of scope of our framework.
We stress that these limitations apply to manually deployed applications as well.

7 Related Work

Service-based Frameworks. Related work has proposed service-based archi-
tectures to orchestrate components of distributed applications on mobile and
embedded devices [13] [30] [6] [14], which mainly focus on aspects we consider
orthogonal to our work, such as context-aware service composition and discov-
ery. While Rellermeyer et al describe the general applicability of their R-OSGi
framework [39] in IoT scenarios [38], Preuveneers et al [37] propose a service mo-
bility framework for mobile devices, which enables dynamic service migration.
Their approach considers state transfer and synchronization, service discovery
and resource constraints, while Xapp focuses on security by allowing modules to
migrate between platforms in a controlled fashion subject to strict access control.
Goncalves et al [20] propose a service mobility framework for Android, which
focuses on QoS and realtime requirements for the migration of stateful services.
They extend standard Android application components to be applicable in dis-
tributed systems and enable component migration between devices. While their
approach is limited to the Android OS and requires developers to split apps

a-priori into separate packages, Xapp assembles platform-speciÔ¨Åc instances au-
tomatically at runtime and supports Ô¨Åne-grained access control on resources.
Computation OÔ¨Ñoading. Cuervo et al [11] and Kosta et al [31] use application
partitioning to oÔ¨Ñoad computational tasks from mobile devices to the cloud to
speed up computations and reduce battery consumption. In both system models,
the cloud is inherently trusted, and security aspects are out of scope. Haerick et
al [21] propose an OSGi-based platform designed to outsource energy-intensive
computations from mobile devices to other platforms.

Xapp is a more general approach, designed to allow diÔ¨Äerent devices to col-
laborate and use resources and services in a distributed environment, where com-
putation oÔ¨Ñoading is only one possible use case. Xapp provides better usability
by adopting ad-hoc NFC-based trust establishments. Furthermore, our solution
is designed to consider the security requirements of diÔ¨Äerent stakeholders by
isolating application components and by controlling access to shared resources.
Fine-Grained Access Control. Our access control scheme is similar to the
approach presented by Jeon et al [28]. Their solution redirects calls to APIs via a
proxy app which enforces its own Ô¨Åne-grained access control model, while Xapp
binds capabilities to cryptographic tokens in a distributed environment.

Several system-centric security extensions have been proposed for Android,
ranging from enhancements to the coarse-grained permission system [33,10],
mocking privacy-sensitive data at runtime [48,7,25] to integrating mandatory
access control [9,8,35,24]. A combination of extensible system centric security
solutions (e.g., Flaskdroid [9] or ASM [24]) with Xapp would allow developers
to adhere to Android‚Äôs standard permission system and APIs. However, these
solutions require modiÔ¨Åcations to the operating system.

8 Conclusion

Computing in personal, commercial and industrial environments is undergoing a
paradigm shift. The advent of the Internet of Things (IoT) enables new use cases,
in which classical computing platforms, smartphones and tablets, wearables and
further electronic devices operate in concert. Application lifecycle management
and secure resource sharing become increasingly important aspects in this area.
To address these new challenges, we present the design and implementation
of Xapp, a framework for smart and secure cross-device IoT applications for
Android. With Xapp, Android apps can run distributed on diÔ¨Äerent devices
without the need to install them manually on each device. We present a proof-of-
concept implementation for a video call use case, and are currently extending this
work in several directions, such as prototyping other use cases, and incorporating
automatic code-partitioning techniques to provide Ô¨Çexible tools to developers.

Acknowledgements

This work has been co-funded by the European Project FutureID. We would like
to thank Ross Anderson for his feedback that guided the paper‚Äôs Ô¨Ånal revisions.

References

1. Android Auto. http://www.android.com/auto/.
2. Android TV. http://www.android.com/tv/.
3. Apache Felix. http://felix.apache.org/.
4. Apache Felix UPnP. http://felix.apache.org/site/apache-felix-upnp.html.
5. Apple Airplay. http://www.apple.com/de/airplay/.
6. S. Arbanowski, P. Ballon, K. David, O. Droegehorn, H. Eertink, W. Kellerer, H. van
Kranenburg, K. Raatikainen, and R. Popescu-Zeletin. I-centric communications:
personalization, ambient awareness, and adaptability for future mobile services.
Communications Magazine, IEEE, 42(9):63‚Äì69, Sept 2004.

7. A. R. Beresford, A. Rice, N. Skehin, and R. Sohan. MockDroid: Trading Privacy

for Application Functionality on Smartphones. In HotMobile, 2011.

8. S. Bugiel, L. Davi, A. Dmitrienko, S. Heuser, A.-R. Sadeghi, and B. Shastry. Prac-

tical and Lightweight Domain Isolation on Android. In SPSM, 2011.

9. S. Bugiel, S. Heuser, and A.-R. Sadeghi. Flexible and Ô¨Åne-grained mandatory
access control on Android for diverse security and privacy policies. In USENIX
Security, 2013.

10. M. Conti, V. T. N. Nguyen, and B. Crispo. CRePE: Context-Related Policy En-

forcement for Android. In ISC, 2010.

11. E. Cuervo, A. Balasubramanian, D.-k. Cho, A. Wolman, S. Saroiu, R. Chandra,
In

and P. Bahl. MAUI: Making Smartphones Last Longer with Code OÔ¨Ñoad.
MobiSys, 2010.

12. Q. Dang. Recommendation for Existing Application-SpeciÔ¨Åc Key Derivation Func-

tions. NIST, 2010.

13. S. de Deugd, R. Carroll, K. Kelly, B. Millett, and J. Ricker. Soda: Service oriented

device architecture. Pervasive Computing, IEEE, 5(3):94‚Äì96, July 2006.

14. L. de Souza, P. Spiess, D. Guinard, M. Khler, S. Karnouskos, and D. Savio.
In C. Flo-
Socrades: A web service based shop Ô¨Çoor integration infrastructure.
erkemeier, M. Langheinrich, E. Fleisch, F. Mattern, and S. Sarma, editors, The
Internet of Things, volume 4952 of Lecture Notes in Computer Science, pages 50‚Äì
67. Springer Berlin Heidelberg, 2008.

15. W. DiÔ¨Ée and M. Hellman. New Directions in Cryptography. Information Theory,

IEEE, 1976.

16. Digital Living Network Alliance. http://www.dlna.org/.
17. D. Dolev and A. C. Yao. On the Security of Public Key Protocols. Information

Theory, IEEE, 1983.

18. A. P. Felt, E. Ha, S. Egelman, A. Haney, E. Chin, and D. Wagner. Android
permissions: User attention, comprehension, and behavior. In Proceedings of the
Eighth Symposium on Usable Privacy and Security, SOUPS ‚Äô12, pages 3:1‚Äì3:14,
New York, NY, USA, 2012. ACM.

19. Gartner Says Worldwide Tablet Sales Grew 68% in 2013. http://www.gartner.

com/newsroom/id/2674215.

20. J. Goncalves, L. L. Ferreira, L. M. Pinho, and G. Silva. Handling Mobility on a

QoS-Aware Service-based Framework for Mobile Systems. In EUC, 2010.

21. W. Haerick, T. Wauters, C. Develder, F. D. Turck, and B. Dhoedt. Transparent
resource sharing framework for internet services on handheld devices. Annals of
Telecommunications, 2010.

22. N. Hardy. The confused deputy: (or why capabilities might have been invented).

SIGOPS Oper. Syst. Rev., 22(4):36‚Äì38, Oct. 1988.

23. E. Haselsteiner and K. Breitfuss. Security in Near Field Communication. RFIDSec,

2006.

24. S. Heuser, A. Nadkarni, W. Enck, and A.-R. Sadeghi. Asm: A programmable

interface for extending android security. In USENIX Security Symposium, 2014.

25. P. Hornyack, S. Han, J. Jung, S. Schechter, and D. Wetherall. These Aren‚Äôt the
Droids You‚Äôre Looking For: RetroÔ¨Åtting Android to Protect Data from Imperious
Applications. In ACM CCS, 2011.

26. Introduction to Java multitenancy. http://www.ibm.com/developerworks/java/

library/j-multitenant-java/index.html.

27. SecurityManager (Java Platform SE 7).

http://docs.oracle.com/javase/7/

docs/api/java/lang/SecurityManager.html.

28. J. Jeon, K. K. Micinski, J. A. Vaughan, A. Fogel, N. Reddy, J. S. Foster, and
T. Millstein. Dr. Android and Mr. Hide: Ô¨Åne-grained permissions in android ap-
plications. In SPSM, 2012.

29. jSLP - Java SLP (Service Location Protocol) Implementation. http://jslp.

sourceforge.net/.

30. J. King, R. Bose, H.-I. Yang, S. Pickles, and A. Helal. Atlas: A service-oriented sen-
sor platform: Hardware and middleware to enable programmable pervasive spaces.
In Local Computer Networks, Proceedings 2006 31st IEEE Conference on, pages
630‚Äì638, Nov 2006.

31. S. Kosta, A. Aucinas, P. Hui, R. Mortier, and X. Zhang. ThinkAir: Dynamic Re-
source Allocation and Parallel Execution in the Cloud for Mobile Code OÔ¨Ñoading.
In INFOCOM, 2012.

32. Linpack Benchmark ‚Äì Java Version.

http://www.netlib.org/benchmark/

linpackjava/.

33. M. Nauman, S. Khan, and X. Zhang. Apex: Extending Android Permission Model

and Enforcement with User-deÔ¨Åned Runtime Constraints. In AsiaCCS, 2010.

34. B. C. Neuman and T. Tso. Kerberos: an authentication service for computer

networks. Communications Magazine, IEEE, 1994.

35. M. Ongtang, S. McLaughlin, W. Enck, and P. McDaniel. Semantically Rich

Application-Centric Security in Android. In ACSAC, 2009.

36. OSGi Alliance. OSGi Service Platform Release 4. http://www.osgi.org/Main/

HomePage.

37. D. Preuveneers and Y. Berbers. Context-driven migration and diÔ¨Äusion of perva-

sive services on the OSGi framework. IJAACS, 2010.

38. J. Rellermeyer, M. Duller, K. Gilmer, D. Maragkos, D. Papageorgiou, and
G. Alonso. The software fabric for the internet of things.
In C. Floerkemeier,
M. Langheinrich, E. Fleisch, F. Mattern, and S. Sarma, editors, The Internet of
Things, volume 4952 of Lecture Notes in Computer Science, pages 87‚Äì104. Springer
Berlin Heidelberg, 2008.

39. J. S. Rellermeyer, G. Alonso, and T. Roscoe. R-OSGi: distributed applications

through software modularization. In Middleware, 2007.

40. Samsung Allshare.

http://developer.samsung.com/allshare-framework/

technical-docs/FAQ.

41. S. Santesson, M. Myers, R. Ankney, A. Malpani, S. Galperin, and C. Adams. X.509
Internet Public Key Infrastructure Online CertiÔ¨Åcate Status Protocol - OCSP.
RFC 6960 (Proposed Standard), June 2013.

42. R. Schlegel, K. Zhang, X. Zhou, M. Intwala, A. Kapadia, and X. Wang. Sound-
comber: A stealthy and context-aware sound trojan for smartphones. In NDSS.
The Internet Society, 2011.

43. S. Smalley and R. Craig. Security Enhanced (SE) Android: Bringing Flexible MAC

to Android. In Proceedings of NDSS, 2013.

44. F. Stajano. The resurrecting duckling ‚Äì what next? In Revised Papers from the 8th
International Workshop on Security Protocols, pages 204‚Äì214, London, UK, UK,
2001. Springer-Verlag.

45. F. Stajano and R. J. Anderson. The resurrecting duckling: Security issues for
In Proceedings of the 7th International Workshop on

ad-hoc wireless networks.
Security Protocols, pages 172‚Äì194, London, UK, UK, 2000. Springer-Verlag.

46. The Guest VM Project. https://kenai.com/projects/guestvm.
47. Universal Plug-and-Play. http://www.upnp.org/.
48. Y. Zhou, X. Zhang, X. Jiang, and V. W. Freeh. Taming Information-Stealing

Smartphone Applications (on Android). In TRUST, 2011.

A Protocols

As explained in Section 3.3, the protocols assume a shared symmetric secret
key between M and H, denoted KM ‚àà {0, 1}n, which is used to authenticate
and encrypt tokens with the help of an authenticated encryption scheme AE =
(AEnc, ADec), where n is a security parameter.

(a) TI

(b) SCE

Fig. 5. Token Issuing Protocol (TI) and Secure Channel Establishment Protocol (SCE)

Token Issuing Protocol. The Token Issuing Protocol (TI) is shown in Fig-
ure 5(a). Both M and C generate a new asymmetric key pair. C sends its public
key pkC to M over an out-of-band channel. Generally we require that this chan-
nel is integrity-protected at least in one direction (C to M), so that it is immune
to man-in-the-middle attacks where an attacker attempts to replace pkC with a
diÔ¨Äerent public key. We use Near-Field Communication (NFC), which directly
allows M to verify the identity of C due to the physical proximity required for
NFC. However, alternative implementations are also feasible, for example using
QR codes. M creates a new Token [TL], which contains the client key KC, as
well as a description of C‚Äôs privileges on H, denoted by the Policy PC,H. KC is
derived using a key agreement scheme DH (e.g., DiÔ¨Ée-Hellmann [15]) between
C and M. Finally, M sends the token to C together with its public key pkM.

ùëùùëòM,ùë†ùëòM‚ÜêGenkey(1k) ùëùùëòC,ùë†ùëòC‚ÜêGenkey(1k) ùêæM ùëùùëòC ùêæC‚ÜêDHùëùùëòC,ùë†ùëòM ùëáL‚Üê(ùêæC,ùëÉC,H) [ùëáL] ‚ÜêAEnc(ùêæM;ùëáL) [ùëáL],ùëùùëòM ùêæC‚ÜêDH(ùëùùëòM,ùë†ùëòC) Store([ùëáL],ùêæC) Client C  Manager M ùëÅC‚ààùëÖ0,1ùëõ ùêæM ùêæùëÜ‚ÜêKDF(ùêæC,ùëÅL,ùëÅC) ùëá‚ÜêADecùêæM;[ùëáL]  ùêæC,ùëÉC,H‚Üê T SendPolicy(C,ùëÉC,H) ùêæùëÜ‚ÜêKDF(ùêæC,ùëÅL,ùëÅC) Client C Loader L      on Host H [ùëáL],ùêæC ùëÅL‚ààùëÖ0,1ùëõ [ùëáL],ùëÅC ùëÅL Secure Channel Establishment. The client C uses the Secure Channel Es-
tablishment Protocol (SCE) to connect to the Loader L as shown in Figure 5(b):
C sends [TL] and a randomly chosen nonce NC to L. L decrypts [TL] using KM,
thereby verifying its integrity due to the authenticated encryption. Next, L ex-
tracts KC and the Policy PC,H, which is forwarded to the Resource Controller
RC. L stores KC securely in a database and later provides a decryption service
to instances of C, so that KC cannot be exÔ¨Åltrated by modules in IC. Then, L
generates a random nonce NL, which it sends back to C. Finally, both sides com-
pute a shared secret session key KS = KDF(KC || NL || NC) using a suitable key
derivation function KDF [12]. In our implementation we use an HMAC/SHA1-
based key derivation function. After this step, the secure channel establishment
is completed and KS will be used to protect all further communication.
C also uses SCE to connect to IC. Therefore C creates a new token [TIC ] with
a randomly chosen key KI . Since no policy is established between the client and
the host it attaches an empty dummy policy and encrypts the complete token
[TIC ] with KC. On the client side, IC decrypts [TIC ] using the decryption service
provided by L.

