USENIX Association

Supplement to the Proceedings of the 
22nd USENIX Security Symposium

August 14–16, 2013
Washington, D.C.

Message from the

22nd USENIX Security Symposium Program Chair

and USENIX Executive Director

In this supplement to the Proceedings of the 22nd USENIX Security Symposium, we are pleased to announce the 
publication of the paper, “Dismantling Megamos Crypto: Wirelessly Lockpicking a Vehicle Immobilizer,” by Roel 
Verdult, Flavio D. Garcia, and Baris Ege. This paper, which was accepted by the USENIX Security ’13 Program 
Committee, was withdrawn from publication by its authors in response to the imposition of an injunction by the 
High Court of Justice in the United Kingdom prohibiting the authors, their institutions, and anyone who assists 
them, from publishing key sections of the paper. We now join the authors in their delight that USENIX may now 
publish their paper in this supplement to the original Proceedings. Verdult and Garcia will present the paper in a 
special evening session during the 24th USENIX Security Symposium. Although two years have passed, this work 
remains important and relevant to our community.

Sam King, USENIX Security ’13 Program Chair 
Casey Henderson, USENIX Executive Director

Dismantling Megamos Crypto: Wirelessly Lockpicking a

Vehicle Immobilizer

Roel Verdult

Flavio D. Garcia

Institute for Computing and Information Sciences,
Radboud University Nijmegen, The Netherlands.

School of Computer Science,

University of Birmingham, UK.

rverdult@cs.ru.nl

f.garcia@cs.bham.ac.uk

Barıs¸ Ege

Institute for Computing and Information Sciences,
Radboud University Nijmegen, The Netherlands.

b.ege@cs.ru.nl

Abstract

1 Introduction

The Megamos Crypto transponder is used in one of the
most widely deployed electronic vehicle immobilizers.
It is used among others in most Audi, Fiat, Honda, Volk-
swagen and Volvo cars. Such an immobilizer is an anti-
theft device which prevents the engine of the vehicle
from starting when the corresponding transponder is not
present. This transponder is a passive RFID tag which is
embedded in the key of the vehicle.

In this paper we have reverse-engineered all propri-
etary security mechanisms of the transponder, including
the cipher and the authentication protocol which we pub-
lish here in full detail. This article reveals several weak-
nesses in the design of the cipher, the authentication pro-
tocol and also in their implementation. We exploit these
weaknesses in three practical attacks that recover the 96-
bit transponder secret key. These three attacks only re-
quire wireless communication with the system. Our ﬁrst
attack exploits weaknesses in the cipher design and in
the authentication protocol. We show that having ac-
cess to only two eavesdropped authentication traces is
enough to recover the 96-bit secret key with a computa-
tional complexity of 256 cipher ticks (equivalent to 249
encryptions). Our second attack exploits a weakness in
the key-update mechanism of the transponder. This at-
tack recovers the secret key after 3 × 216 authentication
attempts with the transponder and negligible computa-
tional complexity. We have executed this attack in prac-
tice on several vehicles. We were able to recover the key
and start the engine with a transponder emulating device.
Executing this attack from beginning to end takes only 30
minutes. Our third attack exploits the fact that some car
manufacturers set weak cryptographic keys in their vehi-
cles. We propose a time-memory trade-off which recov-
ers such a weak key after a few minutes of computation
on a standard laptop.

Electronic vehicle immobilizers have been very effec-
tive at reducing car theft. Such an immobilizer is an
electronic device that prevents the engine of the vehi-
cle from starting when the corresponding transponder is
not present. This transponder is a low-frequency RFID
chip which is typically embedded in the vehicle’s key.
When the driver starts the vehicle, the car authenticates
the transponder before starting the engine, thus prevent-
ing hot-wiring. In newer vehicles the mechanical igni-
tion key has often been removed and replaced by a start
button, see Figure 1(a).
In such vehicles the immobi-
lizer transponder is the only anti-theft mechanism that
prevents a hijacker from driving away.

A distinction needs to be made between the vehicle
immobilizer and the remotely operated central locking
system. The latter is battery powered, operates at an
ultra-high frequency (UHF), and only activates when the
user pushes a button on the remote to (un)lock the doors
of the vehicle. Figure 1(b) shows a disassembled car key
where it is possible to see the passive Megamos Crypto
transponder and also the battery powered remote of the
central locking system.

The Megamos Crypto transponder is the ﬁrst crypto-
graphic immobilizer transponder manufactured by [19]
and is currently one of the most widely used. The manu-
facturer claims to have sold more than 100 million im-
mobilizer chips including Megamos Crypto transpon-
ders [22]. Figure 2 shows a list of vehicles that use
or have used Megamos Crypto at least for some ver-
sion/year. As it can be seen from this list, many Audi,
Fiat, Honda, Volkswagen and Volvo cars used Megamos
Crypto transponders at the time of this research (fall
2012).

The transponder uses a 96-bit secret key and a propri-
etary cipher in order to authenticate to the vehicle. Fur-
thermore, a 32-bit PIN code is needed in order to be able
to write on the memory of the transponder. The con-

USENIX Association  

22nd USENIX Security Symposium  703

1

(a) Keyless ignition with start button

(b) Megamos Crypto transponder in a car key

Figure 1: Megamos Crypto integration in vehicular systems

crete details regarding the cipher design and authentica-
tion protocol are kept secret by the manufacturer and lit-
tle is currently known about them.

From our collaboration with the local police it was
made clear to us that sometimes cars are being stolen
and nobody can explain how. They strongly suspect the
use of so-called ‘car diagnostic’ devices. Such a device
uses all kind of custom and proprietary techniques to by-
pass the immobilizer and start a car without a genuine
key. This motivated us to evaluate the security of vehi-
cle immobilizer transponders. There are known attacks
for three of the four widely used immobilizer transpon-
ders, namely DST40, Keeloq and Hitag2. Although, at
the time of this research, little was known about the se-
curity of the Megamos Crypto transponder.

1.1 Our contribution

In this paper we have fully reverse-engineered all crypto-
graphic mechanisms of Megamos Crypto which we pub-
lish here in full detail. For this we used IDA Pro1 to de-
compile the software package that comes with the Tango
Programmer2.

Furthermore, we have identiﬁed several weaknesses in
Megamos Crypto which we exploit in three attacks. Our
ﬁrst attack consists of a cryptanalysis of the cipher and
the authentication protocol. Our second and third attack
not only look at the cipher but also at the way in which it
is implemented and poorly conﬁgured by the automotive
industry.

Our ﬁrst attack, which comprises all vehicles using

Megamos Crypto, exploits the following weaknesses.

• The transponder lacks a pseudo-random number
generator, which makes the authentication protocol
vulnerable to replay attacks.

1https://www.hex-rays.com/products/ida/
2http://www.scorpio-lk.com

Make

Alfa Romeo

Audi

Buick

Cadillac
Chevrolet

Citro¨en
Daewoo

DAF
Ferrari

Fiat

Holden

Honda

Isuzu
Iveco
Kia

Lancia
Maserati

Opel

Pontiac
Porsche

Seat
Skoda

Ssangyong

Tagaz

Volkswagen

Volvo

Models

147, 156, GT
A1, A2, A3, A4 (2000), A6, A8, Allroad, Cabrio, Coup´e,
Q7, S2, S3, S4, S6, S8, TT (2000)
Regal
CTS-V, SRX
Aveo, Kalos, Matiz, Nubira, Spark, Evanda, Tacuma
Jumper (2008), Relay
Kalos, Lanos, Leganza, Matiz, Nubira, Tacuma
CF, LF, XF
California, 612 Schaglietti
Albea, Dobl`o, Idea, Mille, Multipla, Palio, Punto (2002),
Seicento, Siena, Stilo, Ducato (2004)
Barina, Frontera
Accord, Civic, CR-V, FR-V, HR-V, Insight, Jazz (2002),
Legend, Logo, S2000, Shuttle, Stream
Rodeo
Eurocargo, Daily
Carnival, Clarus, Pride, Shuma, Sportage
Lybra, Musa, Thesis, Y
Quattroporte
Frontera
G3
911, 968, Boxster
Altea, C´ordoba, Ibiza, Leon, Toledo
Fabia (2011), Felicia, Octavia, Roomster, Super, Yeti
Korando, Musso, Rexton
Road Partner
Amarok, Beetle, Bora, Caddy, Crafter, Cross Golf,
Dasher, Eos, Fox, Gol, Golf (2006, 2008), Individual,
Jetta, Multivan, New Beetle, Parati, Polo, Quantum,
Rabbit, Saveiro, Santana, Scirocco (2011), Touran,
Tiguan, Voyage, Passat (1998, 2005), Transporter
C30, S40 (2005), S60, S80, V50, V70, XC70, XC90,
XC94

Figure 2: Vehicles that used Megamos Crypto for some
version/year [39]. Boldface and year indicate speciﬁc

vehicles we experimented with.

• The internal state of the cipher consists of only 56
bits, which is much smaller than the 96-bit secret
key.

• The cipher state successor function can be inverted,
given an internal state and the corresponding bit of
cipher-text it is possible to compute the predecessor
state.

• The last steps of

the authentication protocol

704  22nd USENIX Security Symposium 

USENIX Association

2

provides and adversary with 15-bits of known-
plaintext.

We present two versions of this attack. First we introduce
a simple (but more computationally intensive) attack that
recovers the secret key of the transponder with a compu-
tational complexity of 256 encryptions. Then we opti-
mize this attack, reducing its computational complexity
to 249 by using a time-memory trade-off. For this trade-
off, a 12 terabyte lookup table needs to be pre-computed.
This optimized version of the attack takes advantage of
the fact that some of the cipher components can be run
quite autonomously.

Our second attack exploits the following weaknesses.

• Currently, the memory of many Megamos Crypto
transponders in the ﬁeld is either unlocked or locked
with a publicly known default PIN code [17]. This
means that anybody has write access to the memory
of the transponder. This also holds for the secret
key bits.

• The 96-bit secret key is written to the transponder
in blocks of 16 bits instead of being an atomic op-
eration.

This attack recovers the 96-bit secret key of such a
transponder within 30 minutes. This time is necessary to
perform 3 × 216 authentication attempts to the transpon-
der and then recover the key with negligible computa-
tional complexity. We have executed this attack in prac-
tice and recovered the secret key of several cars from var-
ious makes and models. Having recovered the key we
were able to emulate the transponder and start the vehi-
cles.

Our third attack is based on the following observation.
Many of the keys that we recovered using the previous
attack had very low entropy and exhibit a well deﬁned
pattern, i.e., the ﬁrst 32 bits of the key are all zeros. This
attack consists of a time-memory trade-off that exploits
this weakness to recover the secret key, within a few min-
utes, from two authentication traces. This attack requires
storage of a 1.5 terabyte rainbow table.

We propose a simple but effective mitigating measure
against our second attack. This only involves setting a
few bits on the memory of the transponder and can be
done by anyone (even the car owners themselves) with a
compatible RFID reader.

Finally, we have developed an open source library for
custom and proprietary RFID communication schemes
that operate at an frequency of 125 kHz. We used this
library to provide eavesdropping, emulation and reader
support for Megamos Crypto transponders with the Prox-
mark III device3. The reader functionality allows the

3http://www.proxmark.org/

user to send simple commands like read and write to the
transponder. In particular, this library can be used to set
the memory lock bit and a random PIN code as a mitiga-
tion for our second attack, as described in Section 8.

1.2 Related work

In the last decades, semiconductor companies introduced
several proprietary algorithms speciﬁcally for immobi-
lizer security. Their security often depends on the se-
crecy of the algorithm. When their inner-workings are
uncovered, it is often only a matter of weeks before the
ﬁrst attack is published. There are several examples in
the literature that address the insecurity of proprietary
algorithms. The most prominent ones are those break-
ing A5/1 [31], DECT [45, 47], GMR [18], WEP [24]
and also many RFID systems like the MIFARE Clas-
sic [16, 26, 29, 46], CryptoRF [30] and iClass [27, 28].

Besides Megamos Crypto, there are only three other
major immobilizer products being used. The DST
transponder which was reverse-engineered and attacked
by Bono et.al. in [9]; KeeLoq was ﬁrst attacked by Bog-
danov in [6] and later this attack was improved in [12,
36, 38]; Hitag2 was anonymously published in [60] and
later attacked in [8, 13, 35, 52, 53, 57, 58].

With respect to vehicle security, Koscher et. al. at-
tracted a lot of attention from the scientiﬁc community
when they demonstrated how to compromise the board
computer of a modern car [11, 40]. They were able to
remotely exploit and control many car features such as
tracking the car via GPS and adjust the speeding of the
car.
In 2011, Francillon et. al. [25] showed that with
fairly standard equipment it is possible to mount a relay-
attack on all keyless-entry systems that are currently de-
ployed in modern cars.

The scientiﬁc community proposed several alterna-
tives [43, 44, 59, 61, 62] to replace the weak proprietary
ciphers and protocols. There are several commercial ve-
hicle immobilizer transponders that makes use of stan-
dard cryptography, like AES [14]. Examples include
the Hitag Pro transponder from NXP Semiconductors
and ATA5795 transponder from Atmel. To the best of
our knowledge, only Atmel made an open protocol de-
sign [1] and published it for scientiﬁc scrutiny. The secu-
rity of their design was analyzed by Tillich et. al. in [54].

2 Technical background

This section brieﬂy describes what a vehicle immobilizer
is and how it is used by the automotive industry. Then we
describe the hardware setup we use for our experiments.
Finally we introduce the notation used throughout the pa-
per.

2.1 Immobilizer

To prevent a hijacker from hot-wiring a vehicle, car man-
ufacturers incorporated an electronic car immobilizer as

USENIX Association  

22nd USENIX Security Symposium  705

3

an extra security mechanism. In some countries, having
such an immobilizer is enforced by law. For example, ac-
cording to European Commission directive (95/56/EC)
it is mandatory that all cars sold in the EU from 1995
are ﬁtted with an electronic immobilizer. Similar reg-
ulations apply to other countries like Australia, New
Zealand (AS/NZS 4601:1999) and Canada (CAN/ULC
S338-98). Although in the US it is not required by law,
according to the independent organization Insurance In-
stitute for Highway Safety (IIHS), 86 percent of all new
passenger cars sold in the US had an engine immobilizer
installed [55].

An electronic car immobilizer consists of three main
components: a small transponder chip which is embed-
ded in (the plastic part of) the car key, see Figure 1(b);
an antenna coil which is located in the dashboard of the
vehicle, typically around the ignition barrel; and the im-
mobilizer unit that prevents the vehicle from starting the
engine when the transponder is absent.

The immobilizer unit communicates through the an-
tenna coil and enumerates all transponders that are in
proximity of ﬁeld. The transponder identiﬁes itself and
waits for further instructions. The immobilizer chal-
lenges the transponder and authenticates itself ﬁrst. On
a successful authentication of the immobilizer unit, the
transponder sends back its own cryptographic response.
Only when this response is correct, the immobilizer unit
enables the engine to start.

The immobilizer unit is directly connected to the in-
ternal board computer of the car, also referred to as Elec-
trical Control Unit (ECU). To prevent hot-wiring a car,
the ECU blocks fuel-injection, disables spark-plugs and
deactivates the ignition circuit if the transponder fails to
authenticate.

2.2 Hardware setup

We used the Proxmark III to eavesdrop and com-
municate with the car and transponder.
This is a
generic RFID protocol analysis tool [56] that sup-
ports raw data sampling at a frequency of 125 kHz.
We implemented a custom
ﬁrmware and FPGA design
that supports the modulation
and encoding schemes of
Megamos Crypto transpon-
ders.
The design samples
generic analog-digital con-
(ADC) values and
verter
interpret
them in real-time
in the micro-controller. We
have
com-
mands to eavesdrop, read and emulate a transponder.
Our library is able to decode ﬁeld and transponder
modulation simultaneously and is very precise in timing.

Figure 3: Proxmark 3

implemented

2.3 Notation

Throughout this paper we use the following mathemat-
ical notation. Let F2 = {0, 1} be the set of Booleans.
The symbol ⊕ denotes exclusive-or (XOR), 0n denotes
a bitstring of n zero-bits. ε denotes the empty bitstring.
Given two bitstrings x and y, xy denotes their concatena-
tion. Sometimes we write this concatenation explicitly
with x · y to improve readability. x denotes the bitwise
complement of x. Given a bitstring x ∈ Fk
2, we write xi to
denote the i-th bit of x. For example, given the bitstring
x = 0x03 = 00000011 ∈ F8
2, x0 = 0 and x6 = x7 = 1.

3 Megamos Crypto

This section describes Megamos Crypto in detail. We
ﬁrst describe the Megamos Crypto functionality, mem-
ory structure, and communication protocols, this comes
from the product datasheet [21] and the application
note [23]. Then we brieﬂy describe how we reverse-
engineered the cryptographic algorithms and protocols
used in Megamos Crypto. Finally, we describe these al-
gorithms and protocols in detail.

3.1 Memory

There are two types of Megamos Crypto transponders,
in automotive industry often referred to as Magic I
(V4070) [20] and Magic II (EM4170) [21]. The EM4170
transponder is the newer version and it has 16 memory
blocks of 16-bit words. The contents of these mem-
ory blocks are depicted in Figure 4. The older version
(V4070) supports exactly the same read and write oper-
ations and cryptographic algorithms, but it only has 10
memory blocks. The blocks 10 to 15, which store 64
bits of additional user memory and a 32-bit PIN code are
simply not readable. The EM4170 transponder uses the
same communication and is therefore backwards com-
patible with the V4070 transponder. Note that in some
cars the new revision is deployed as replacement for the
V4070 without making use of, or even initializing the
additional user memory blocks and PIN code. The whole
memory is divided in three sections with different access
rights, see Figure 4.

The transponder identiﬁer id is always read-only. The
write access over the other memory blocks is determined
by the value of the lock-bit l0. Just as speciﬁed, the value
of lock-bit l1 does not have any inﬂuence the memory
access conditions. Similarly, a successful or failed au-
thentication has no effect on the access conditions.

• When l0 = 0, all memory blocks (except id) of a
Megamos Crypto transponder are still writable. The
key k, PIN code pin are write-only and the user
memory um blocks (which includes the lock-bits l)
are read-write. However, after a successful write in
block 1, the new value of l0 determines the access
condition for future write operations.

706  22nd USENIX Security Symposium 

USENIX Association

4

• When l0 = 1, all writing is disabled. However, it
does not affect the read access conditions. This
means that the key k, PIN code pin can not be read
out and the user memory um becomes read-only.
Because the lock-bits l are stored in a user memory
block they can always be read out.

The EM4170 allows to set the lock-bit l0 back to zero
using a PIN code pin. A valid PIN code resets the access
conditions and enables again writing of k, pin, um and
l. The PIN code has to be known or overwritten to the
transponder before it is locked, otherwise an exhaustive
search of the PIN code is required.

Block Content

0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15

user memory
user memory, lock bits
device identiﬁcation
device identiﬁcation
crypto key
crypto key
crypto key
crypto key
crypto key
crypto key
pin code
pin code
user memory
user memory
user memory
user memory

Denoted by
um0 . . . um15
um16 . . .um 29l0l1
id0 . . . id15
id16 . . .id 31
k0 . . . k15
k16 . . . k31
k32 . . . k47
k48 . . . k63
k64 . . . k79
k80 . . . k95
pin0 . . . pin15
pin16 . . . pin31
um30 . . .um 45
um46 . . .um 61
um62 . . .um 77
um78 . . .um 93

read-only

write-only

read-write

Figure 4: Megamos Crypto transponder memory layout

3.2 Functionality and communication

The Megamos Crypto transponder supports four dif-
ferent operations:
read, write, reset and
authenticate.

• read operations are performed by three dif-
ferent commands, each returns multiple blocks.
The transponder
returns the concatenation of
these blocks in one bitstring. The three avail-
able bitstrings are id31 . . . id0, l1l0um29 . . . um0 and
um93 . . . um30.

• write stores a 16-bit memory block in the mem-
ory of the transponder. The arguments for this com-
mand are the block number and the data. After
receiving the command, the transponder stores the
data in memory if the access conditions allow the
requested write operation.

• reset takes the id and 32-bit PIN code as an ar-
gument. If the PIN code matches the value that is
stored in pin, then the lock-bit l0 is reset, see Sec-
tion 3.1 for more details about l0.

• authenticate takes three arguments. The ﬁrst
one is a 56-bit car nonce nC. The second argument

is a bitstring of 7 zero bits. The datasheet [21] refers
to them as “divergency bits”.
It seems that these
bit-periods are used to initialize the cipher. In Sec-
tion 3.6 we show that the authentication protocol ex-
actly skips 7 cipher steps before it starts generating
output. The third argument is a 28-bit authentica-
tor from the car aC. If successful, the transponder
responds with its 20-bit authenticator aT .

When the driver turns on the ignition, several back-
and-forward messages between the car and transponder
are exchanged.
It starts with the car reading out the
transponder memory blocks that contains the identity,
user memory and lock-bits. Next, the car tries to authen-
ticate using the shared secret key k. If the authentication
fails, the car retries around 20 times before it reports on
the dashboard that the immobilizer failed to authenticate
the transponder. Figure 5 shows an eavesdropped trace
of a German car that initializes and authenticates a Meg-
amos Crypto transponder.

To the best of our knowledge, there is no publicly
available document that describes the structure of Meg-
amos Crypto cipher. However, a simpliﬁed representa-
tion of the authentication protocol is presented in the
EM4170 application note [23] as shown in Figure 6.
It does not specify any details beyond the transmitted
messages and the checks which the car and transpon-
der must perform. The car authenticates by sending a
nonce nC = Random and the corresponding authentica-
tor aC = f (Rnd, K). When the car successfully authenti-
cated itself, the Megamos Crypto transponder sends the
transponder authenticator aT = g(Rnd, f , K) back to car.







 
 









































 
 



















Figure 6: Authentication procedure excerpt from [23]

For communication the Megamos Crypto transponder
uses a low frequency wave of 125 kHz and applies am-
plitude shift keying (ASK) modulation by putting a small
resistance on the electro magnetic ﬁeld. It utilizes a cus-

USENIX Association  

22nd USENIX Security Symposium  707

5

Message
3

Origin
Car
Transponder A9 08 4D EC
Car
Transponder 80 00 95 13
Car
Transponder AA AA AA AA AA AA AA AA
Car
Transponder 60 9D 6

6 | 3F FE 1F B6 CC 51 3F | 07 | F3 55 F1 A

5

F

Description
Read identiﬁer
Identﬁer id31 . . . id0
Read user memory and lock-bits
First user memory l1l0um29 . . .um 0
Read large user memory (EM4170)
Second user memory um93 . . . um30
Authentication, nC55 . . . nC0 , 07, aC
Car authenticated successful, send back aT

Figure 5: Eavesdropped Megamos Crypto authentication using the 96-bit key 000000000000010405050905.

The structure of the secret key of the car suggests that it has an entropy of only 24 bits.

tom encoding scheme for status bits and a Manchester
encoding scheme for transmitting data bits. The Meg-
amos Crypto immobilizer unit signals the transponder to
receive a command by dropping the ﬁeld two consecutive
times in a small time interval. Then it drops the ﬁeld a
few microseconds to modulate a zero and leaves the ﬁeld
on to modulate a one.

This way of modulation introduces the side-effect that
the immobilizer unit and the transponder could get out-
of-sync. When the immobilizer unit sends a bitstring
of contiguous ones, there are no ﬁeld drops for almost
15 milliseconds. The manufacturer realized this was a
problem, but instead of proposing an alternative com-
munication scheme they suggest to choose random num-
bers with more zeros’s than ones and especially avoid se-
quential ones [23]. From a security perspective it sounds
like a bad idea to suggest to system integrators that they
should effectively drop entropy from the used random
numbers.

To get a fair estimate of communication timings we
did some experiments. With our hardware setup we were
able to reach the highest communication speed with the
transponder that is possible according to the datasheet.
It allows us to read out the identiﬁer id in less than 14
milliseconds and successfully authenticate within 34 mil-
liseconds. These timings conﬁrm that an adversary can
wirelessly pickpocket the identiﬁer and all its user mem-
ory in less than a second from a distance of one inch.
Standing close to a victim for only a fraction of a second
enables the adversary to gather the transponder identiﬁer.
When this identiﬁer is emulated to the corresponding
car, it is possible to gather partial authentication traces.
Because the transponder lacks a random generator, this
partial traces can later be used to retrieve the responses
from the transponder which extends them to successful
authentication traces. With a number of successful au-
thentication traces it is possible to recover the secret key
as described in Section 5.

3.3 Reverse-engineering the cipher

Recent articles point out the lack of security [11, 40, 41]
in modern cars. The software in existing cars is designed
with safety in mind, but is still immature in terms of se-
curity. Legacy protocols and technologies are often vul-
nerable to a number of remote and local exploits.

Most car keys need to be preprogrammed, which is
also referred to as pre-coded, before they can be asso-
ciated to a car. During this initialization phase the user
memory blocks are ﬁlled with manufacturer speciﬁc data
to prevent mixing of keys. This step adds no security, it
just restricts the usage of keys that were meant a speciﬁc
car make or model.

There are several car locksmith tools456 in the after
market that can initialize or change such transponder
data. Such tools fully support the modulation/encoding
schemes and communication protocol of
the Meg-
amos Crypto transponder. They implement some pub-
licly available functionality like the read, write and
reset commands. However, they do not implement
the authentication protocol. To perform a successful au-
thentication, knowledge of the Megamos Crypto cipher
is necessary to compute the authentication messages aC
and aT .

More advanced car diagnostic tools like AVDI7 and
Tango Programmer8 offer functionality that goes beyond
“legitimate” usage. These devices are able to dump the
board-computer memory, recover the dealer code, and
add a new blank transponder to the car. For this the tools
do not require a genuine key to be present but they do
need physical access to the can bus.

These diagnostic tools use the Megamos Crypto au-
thentication functionality to speed up the process of
adding new transponders to the car. For this, the tool
needs the Megamos Crypto algorithm to compute valid

4http://www.istanbulanahtar.com
5http://www.advanced-diagnostics.co.uk
6http://www.jmausa.com
7http://www.abritus72.com
8http://www.scorpio-lk.com

6

708  22nd USENIX Security Symposium 

USENIX Association

authentication attempts. We would like to emphasize
that non of these tools is able to recover the secret key
of a transponder or perform any kind of cryptanalysis. In
fact, within the legitimate automotive industry Megamos
Crypto is believed to be unclonable.

The software package that comes with the Tango Pro-
grammer implements all cryptographic operations of the
transponder including the Megamos Crypto cipher. We
have analyzed the software thoroughly and extracted the
algorithm from it.

Since the application implements several counter mea-
sures against reverse-engineering, this task was not triv-
ial at all. It is highly protected with an executable ob-
fuscator that runs a custom virtual machine, as described
in [51], and a number of advanced anti-debugging tricks
to avoid exposure of its inner workings. To perform our
security evaluation of the Megamos Crypto cipher we
bypassed all these measures and reverse engineered the
cipher in a semi-automatic way by observing the mem-
ory state changes and guessing the intermediate crypto-
graphic calculations.

Furthermore, we observed every Megamos Crypto re-
lated function call from the program instructions mem-
ory segment. When the program counter entered a suspi-
cious memory segment, we invoked our clean-up routine
that automatically grouped and dropped all unnecessary
instructions (unconditional re-routings, sequential oper-
ations on the same variables, random non-inﬂuential cal-
culations). After analysing this at run-time, the actual
working of the algorithm was quickly deduced from the
optimized and simpliﬁed persistent instruction set.

3.4 Cipher

This section describes the Megamos Crypto cipher in
detail. The cipher consists of ﬁve main components:
a Galois Linear Feedback Shift Register, a non-linear
Feedback Shift Register, and three 7-bit registers. A
schematic representation of the cipher is depicted in Fig-
ure 7.

Deﬁnition 3.1 (Cipher state). A Megamos Crypto cipher
state s = �g, h, l, m, r� is an element of F57
2 consisting of
the following ﬁve components:

1. the Galois LFSR g = (g0 . . .g 22) ∈ F23
2 ;
2. the non-linear FSR h = (h0 . . . h12) ∈ F13
2 ;
3. the ﬁrst output register l = (l0 . . .l 6) ∈ F7
2;

4. the second output register m = (m0 . . .m 6) ∈ F7
2;

5. the third output register r = (r0 . . . r6) ∈ F7
2.

The following deﬁnitions describe the successor or

feedback functions for each of these components.

Deﬁnition 3.2. The successor function for the Galois lin-
ear feedback shift register G : F23
2 is de-
ﬁned as

2 × F2 × F2 → F23

G(g0 . . . g22, i, j) = ( j⊕g22)g0g1g2(g3⊕g22)(g4⊕i)

(g5⊕g22)(g6⊕g22)g7 . . .g 12(g13⊕g22)g14g15
(g16⊕g22)g17 . . .g 21

We also overload the function G to multiple-bit input
string G : F23

2 × F2 × Fn+1

2 → F23

2 as

G(g, i, j0 . . . jn) = G(G(g, i, j1 . . . jn), i, j0)

Deﬁnition 3.3. The successor function for the non-linear
feedback shift register H : F13

2 is deﬁned as

2 → F13

H(h0 . . .h 12) = ((h1 ∧ h8) ⊕ (h9 ∧ h11) ⊕ h12)h0 . . . h11

Deﬁnition 3.4. The feedback function for the ﬁrst output
register fl : F6

2 → F2 is deﬁned as

fl(x0 . . . x5) =(x0 ∧ x2 ∧ x3) ∨ (x2 ∧ x4 ∧ x5)∨
(x5 ∧ x1 ∧ x3) ∨ (x0 ∧ x1 ∧ x4).

Deﬁnition 3.5. The feedback function for the second out-
put register fm : F6

2 → F2 is deﬁned as

fm(x0 . . . x5) =(x4 ∧ x1 ∧ x2) ∨ (x5 ∧ x1 ∧ x3)∨
(x0 ∧ x2 ∧ x3) ∨ (x4 ∧ x5 ∧ x0).

Deﬁnition 3.6. The feedback function for the third out-
put register fr : F6

2 → F2 is deﬁned as

fr(x0 . . .x 5) =(x5 ∧ x0 ∧ x2) ∨ (x5 ∧ x3 ∧ x1)∨
(x2 ∧ x3 ∧ x4) ∨ (x0 ∧ x4 ∧ x1).

With every clock tick the cipher steps to its successor
state and it (potentially) outputs one bit of keystream.
The following precisely deﬁnes the successor state and
the output of the cipher.

Deﬁnition 3.7 (Successor state). Let s = �g, h, l, m, r� be
a cipher state and i ∈ F2 be an input bit. Then, the suc-
cessor cipher state s′ = �g′, h′, l′, m′, r′� is deﬁned as

g′ := G(g, i, l1⊕m6⊕h2⊕h8⊕h12)
h′ := H(h)
l′ := al0 . . . l5
m′ := bm0 . . . m5
r′ := cr0 . . . r5

where

a = fl(g0g4g6g13g18h3) ⊕ g22 ⊕ r2 ⊕ r6
b = fm(g1g5g10g15h0h7) ⊕ l0 ⊕ l3 ⊕ l6
c = fr(g2(g3⊕i)g9g14g16h1) ⊕ m0 ⊕ m3 ⊕ m6

We deﬁne the successor function suc : F57
2 × F2 → F57
2
which takes a state s and an input i ∈ F2 and outputs
the successor state s′. We overload the function suc on
multiple-bit input which takes a state s and an input i ∈
Fn+1

as

2

suc(s, i0 . . .i n) = suc(s′, in)

where s′ = suc(s, i0 . . .i n−1)

USENIX Association  

22nd USENIX Security Symposium  709

7

g

input

⊕

0 1 2

⊕

3

⊕

4

⊕

5

⊕

6 7 8 9 10 11 12

⊕

13 14 15

⊕

16 17 18 19 20 21 22

h

⊕

⊕

0 1 2 3 4 5 6 7 8 9 10 11 12

⊕

⊕

j = l1 ⊕ m6

fl

g22

⊕

fm

fr

input

l

⊕

⊕

⊕

m

⊕

⊕

⊕

r

⊕

0 1 2 3 4 5 6

0 1 2 3 4 5 6

0 1 2 3 4 5 6

fo

output

Figure 7: Schematic representation of the cipher

Deﬁnition 3.8. The non-linear output ﬁlter function
fo : F20
2 → F2 has been deliberately omitted in this pa-
per.

3.9

(Output). Deﬁne

Deﬁnition
function
output: F57
2 × F2 → F2 which takes as input an in-
ternal state s = �g, h, l, m, r� and an input i ∈ F2 and
returns the bit

the

fo(abcl0l2l3l4l5l6m0m1m3m5r0r1r2r3r4r5r6)

where

a = fl(g0g4g6g13g18h3) ⊕ g22 ⊕ r2 ⊕ r6
b = fm(g1g5g10g15h0h7) ⊕ l0 ⊕ l3 ⊕ l6
c = fr(g2(g3⊕i)g9g14g16h1) ⊕ m0 ⊕ m3 ⊕ m6

We also overload the function output on multiple-bit in-
put which takes a state s and an input i ∈ Fn+1

as

2

output(s, i0 . . . in) = output(s, i0) · output(s′, i1 . . . in)

where s′ = suc(s, i0).

3.5 Cipher initialization

The following sequence of deﬁnitions describe how the
cipher is initialized.

Deﬁnition 3.10. Let init : F23
ﬁned as

2 × Fn+1

2 → Fn+24

2

be de-

init(g, ε) := g

init(g, x0 . . .x n) := init(G(g, 0, xn), x0 . . . xn−1) · g22

Deﬁnition 3.11. Let p ∈ F56

2 , q ∈ F44

2 and t ∈ F43

2 be de-

ﬁned as

p := nC0 . . .n C55 + k40 . . .k 95 mod 256
q := (p2 . . . p45) ⊕ (p8 . . . p51) ⊕ (p12 . . . p55)
t := init(q20 . . . q42, q0 . . .q 19)

Then, the initial cipher state s0 = �g, h, l, m, r� is deﬁned
as

g := t0 . . .t22
h := 0p0 . . . p11
l := t23 . . . t29
m := t30 . . . t36
r := t37 . . . t42q43

3.6 Authentication protocol

This section describes the authentication protocol be-
tween a Megamos Crypto transponder and the vehicle
immobilizer. This protocol is depicted in Figure 8. An
annotated example trace is shown in Figure 5.

Deﬁnition 3.12. Given a key k = k0 . . . k95 ∈ F96
2 and an
initial state s0 as deﬁned in Deﬁnition 3.11, the internal
state of the cipher at step i is deﬁned as

si := suc(si−1, k40−i)

si+41 := suc(si+40, 0)

∀i ∈ [1 . . .40]
∀i ∈ N

During authentication, the immobilizer starts by send-
ing an authenticate command to the transponder. This
command includes a 56-bit nonce nC and the 28 bits aC
output by the cipher from state s7. Then, the transponder
responds with the next 20 output bits aT , i.e., produced
from state s35.

710  22nd USENIX Security Symposium 

USENIX Association

8

−−−−−−−−−−−−−−−−−−−−→

nC · output(s7, k32 . . .k 5)
output(s35, k4 . . .k 0 · 015)

←−−−−−−−−−−−−−−−−−−−−

Figure 8: Megamos Crypto authentication protocol

4 Cipher Properties

This section describes several properties of the Megamos
Crypto cipher which will be later used in the attacks.

4.1 Rollback

Given a cipher state it is possible to recover its previous
state when this exists. Rolling-back the cipher is non-
trivial due to the non-linear operations in the suc func-
tion. Next we describe precisely how to rollback the ci-
pher to recover a predecessor state.

We start by rolling-back registers g and h. This com-
putation is straightforward as described in the following
deﬁnitions.

Deﬁnition 4.1. The predecessor function for the non-
linear feedback shift register H−1 : F13
2 is deﬁned
as
H−1(h0 . . . h12) = h1 . . . h11((h2 ∧ h9) ⊕ (h10 ∧ h12) ⊕ h0)

2 → F13

Deﬁnition 4.2. The predecessor function for the Galois
linear feedback shift register G−1 : F23
2 × F2 × F2 → F23
2
is deﬁned as
G−1(g0 . . .g 22, i, j) = g1g2(g3⊕b)(g4⊕i)(g5⊕b)(g6⊕b)

g7 . . . g12(g13⊕b)g14g15(g16⊕b)g17 . . . g22b

where b = g0 ⊕ j

Next we describe how to rollback registers l, m and
r. A difﬁculty in doing that arises from the fact that m6
in the predecessor state is not determined. To circumvent
this issue, we need to ﬁrst guess the bit m6 and then check
whether this guess is consistent with the rest of the state.
For 18.75% of the states this condition is not met for nei-
ther m6 = 0 nor m6 = 1, which means that the state has
no predecessor. For 62.5% of the states there is only one
value of m6 satisfying this condition, which means that
they have only one predecessor state. Finally, 18.75%
of the states have two possible predecessor states, one
for m6 = 0 and one for m6 = 1. In this case both states
have to be considered as potentially being the predeces-
sor state. Given the fact that the average probability of
having two predecessors equals the probability of having
none the list of candidate predecessor states remains of a
constant size.

A precise description of how to compute a predecessor

state follows.

4.3

(Predecessor

s′ =
Deﬁnition
�g′, h′, l′, m′, r′� be a cipher state and i ∈ F2 be an
input bit. Then, s = �g, h, l, m, r� is a predecessor cipher
state of s′ if it satisﬁes

state).

Let

h = H−1(h′)
g = G−1(g′, i, h12 ⊕ h8 ⊕ h2 ⊕ l′
l = l′
m6 = r′
m = m′
r = r′

1 . . . l′
0 ⊕ fr(g2(g3⊕i)g9g14g16h1) ⊕ m′
1 . . . m′
6m6
0 ⊕ fl(g0g4g6g13g18h3) ⊕ r′
1 . . . r′
6(l′

0 ⊕ fm(g1g5g10g15h0h7h) ⊕ l′
4 ⊕ m′

2 ⊕ m6)

6(m′

1

3 ⊕ g22).

4 ⊕ l′
1)

4.2 Undoing cipher initialization

In this section we show that the cipher initialization pro-
cedure can be reverted. This means that given an initial
state it is possible to recover the part of the secret key that
was used for initialization. The following describes ex-
actly how this can be achieved. We ﬁrst introduce some
auxiliary functions.

Deﬁnition 4.4. Let init−1 : F23
ﬁned as

2 × Fn+1

2 → Fn+1

2

be de-

init−1(g, x0) := g

init−1(g, x0 . . .x n) := b · init−1(G−1(g, 0, b), x1 . . .x n)

where b = g0 ⊕ x0

Deﬁnition 4.5. Let Q−1 : Fn+12

2 → Fn

2 be deﬁned as

Q−1(p0 . . . p11) := ε
Q−1(p0 . . . pn) := (p2 ⊕ p8 ⊕ p12) · Q−1(p1 . . . pn)

Proposition 4.6. Given an initial state s0 = �g, h, l, m, r�
it is possible to compute secret key bits k40 . . .k 95.

The computation of the key bits is as follows.

t := g · l · m · r
q := init−1(t0 . . .t22,t23 . . .t42) · t43
p := h · Q−1(h · q)

k40 . . .k 95 := p − nC mod 256.

4.3 Entropy of the non-linear feedback shift register

First and foremost, the initialization of the 13-bit non-
linear feedback shift register (NLFSR) h is far from ideal.
The NLFSR is initialized with only 12 bits by an almost
linear function of the random nonce and the secret key.
Adding upon the fact that, naturally, as the NLFSR h is
not affected by other registers and the input, it is trivial
to compute all successor states for a given h. Therefore,
the search space for the 13-bit h register drops down to
212. Moreover, careful observation of the nC value on the
communication channel can leak information on whether
the same value has been previously used for initializing
h. For instance if the ﬁrst 13 bits of nC is the same for
two different authentication attempts, depending on the

USENIX Association  

22nd USENIX Security Symposium  711

9

rest of the bits, the attacker can conclude with a certain
conﬁdence that the same state is used for initializing h.
This weakness can be later exploited in a differential at-
tack.

5 Cryptanalysis of Megamos Crypto

This section describes a cryptanalysis of the Megamos
Crypto cipher. We ﬁrst introduce a simple cryptanaly-
sis which is easier-to-grasp and recovers the 96-bit se-
cret key with a computational complexity of 256. Then,
in Section 5.1 we reduce its computational complexity
down to 248.

traces

T

requires

two

C, output(s′

7, k32 . . . k5), output(s′

analysis
authentication

internal states s40 ∈ F56
2

This
suc-
=
cessful
�nC, output(s7, k32 . . .k 5), output(s35, k4 . . . k0 · 015)� and
T ′ = �n′
35, k4 . . . k0 · 015)�.
Discarding from all
those
guesses which produce different 15 output bits than the
trace T which leaves 256−15 = 241 candidate states for
s40. Rolling the cipher backwards for each candidate
up to state s7, as shown in Section 4.1,
leaves—on
average—the same number of candidate states for s7,
namely 241. Each step requires guessing one input bit
ki but at the same time the output provides one bit of
information. Note that this determines a guess for key
bits k0 . . . k32. Rolling further the cipher backwards up to
state s0 requires guessing of k33 . . . k39 while no output
bits are produced. This brings the number of candidate
states for s0 to 241+7 = 248. For each candidate s0,
the remaining key bits k40 . . . k95 can be recovered by
undoing the initialization of the cipher as described in
Section 4.2. This produces 248 candidate keys k0 . . . k95.
there is only one candidate secret key
On average,
k0 . . . k95 that together with n′
C produces the trace T ′.
This is because there are only 248 candidates keys and
48 bits of information on the trace.

Time complexity on average, the aforementioned al-
gorithm has a computational complexity of approxi-
mately 256 encryptions. We have simulated an FPGA
implementation of the algorithm on a Xilinx ISE 10.1
for synthesis and place & route. The results show that
our implementation of a Megamos Crypto core covers
approximately 1% of the Xilinx Spartan 3-1000 FPGA,
the exact same chip that is employed in the COPA-
COBANA [42]. The maximum frequency that the core can
run at is 160.33 MHz, which means we can test a single
bit output in 6.237ns. Given this performance and area
ﬁgures, a rough estimation suggests we can ﬁt at least
50 Megamos Crypto cores in a Spartan 3-1000 FPGA.
Considering that there are 120 such FPGA in a COPA-
COBANA, and since we can run them at 160.33MHz, we
can run approximately 239.8 tests per second. After every
cycle, half of the candidate states are discarded, which
means that a search takes less than two days on a COPA-

COBANA.

5.1 Reducing the computational complexity

Most of the computational complexity of the cryptanal-
ysis described in Section 5 comes from iterating over all
256 internal states s40. In the following analysis we lower
this complexity to 248 by splitting the cipher state into
two and using a time-memory trade-off. The main idea
behind this optimization is to exploit the fact that com-
ponents g and h are quite independent from components
l, m and r. In fact, at each cipher step, there is only one
bit of information from l, m, r which affects g, h, namely
l1 ⊕ m6. Conversely, there are only three bits of infor-
mation from g, h that have an inﬂuence on components
l, m, r.

In order reduce the complexity of the cryptanalysis an

adversary A proceeds as follows.

2 and j ∈ F8

1. Pre-computation: only once, and for each 212 possi-
ble values of h, the adversary computes a table Th as
follows. For each g ∈ F23
2 the adversary
runs cipher components g and h one step forward.
For this, A uses j0 as a guess for l1 ⊕ m6. At this
stage A computes f0 := fl(·) fm(·) fr(·). From the
resulting g and h, A repeats this procedure another
7 times, using ji as a guess at step i and computing
a three bit value fi. At the end, she creates an entry
in the table Th of the form < f0 . . . f7, j0 . . . j7, g >.
When the table is completed A sorts the table (on
f , j).

2. As before A ﬁrst eavesdrops one authentication
trace between a legitimate transponder and an im-
mobilizer. Thus A learns nC, output(s7, k32 . . . k5)
and output(s35, k4 . . . k0 · 015).

3. Choose h.

4. Next the adversary will try to recover state s40. For
each l, m, r ∈ F7
2 the adversary runs these compo-
nents 8 steps forward. At each step i she needs
to guess 3 bits fi := fl(·) fm(·) fr(·) but she will be
able to immediately discard half of these guesses
as they will not produce the correct output bit
output(s40+i, 0). At each step A will also compute
ji : l1 ⊕ m6. At the end A has 221+16 = 237 bitstrings
of the form < f0 . . . f7, j0 . . . j7, l, m, r >.

5. For each of these bitstrings A performs a lookup on
f0 . . . f7, j0 . . . j7 in the table Th and recovers g. On
average, half of these lookups will not have a match
in Th. In that case the candidate state is discarded,
leaving only 236 full candidate states.

6. Each of these candidate states are then rolled for-
ward another 7 steps. Only 236−7 = 229 of these
states will produce the correct output(s48, 07) bits
and the rest are discarded.

712  22nd USENIX Security Symposium 

USENIX Association

10

7. For each of these 229 states the adversary proceeds
as in Section 5, undoing the initialization and check-
ing against a second trace.

Time and resource complexity

• Pre-computation:

for building the tables Th the
adversary needs to run components g and h of
the cipher 8 steps.
This has a computational
complexity of 223+12+3 = 238 cipher steps. The
generated tables can be conveniently stored in
memory using a structure for compression like
/n/ f0/ f1/ . . . / f7/ j/g.dat. Storing all these ta-
bles require 12 terabyte of memory.

• As before, this cryptanalysis requires two success-
ful authentication traces to recover the secret key.
The most time intensive operation of this analysis is
performing the 237 lookups in the table for each of
the 212 values of h, i.e., 249 table lookups.

The time-memory trade-off proposed in this section re-
quires many indirect memory lookups and is therefore
difﬁcult to mount in practice with ordinary consumer
hardware.

6 Partial Key-Update Attack

As it was described in Section 3.2, when the transponder
is not locked, the Megamos Crypto transponder does not
require authentication in order to write to memory. This
makes it vulnerable to a trivial denial of service attack.
An adversary just needs to ﬂip one bit of the secret key
of the transponder to disable it.

Besides this obvious weakness, there is another weak-
ness regarding the way in which the secret key is written
to the transponder. The secret key of Megamos Crypto is
96 bits long. As described in Section 3.1, these 96 bits
are stored in 6 memory blocks of 16 bits each (blocks 4
to 9), see Figure 4. It is only possible to write one block
at a time to the transponder. This constitutes a serious
weakness since a secure key-update must be an atomic
operation.

Next, we mount an attack which exploits this weak-
ness to recover the secret key. For this attack we assume
that an adversary A is able communicate with the car
and transponder. She proceeds as follows.

1. The adversary ﬁrst eavesdrops a successful authen-

tication trace, obtaining nC and aC from the car.

2. Then, for k = 0 to 216 − 1 the adversary writes k
on memory block 4 of the transponder, where key
bits k0 . . . k15 are stored. After each write com-
mand A initiates an authentication attempt with the
transponder, replaying nC and aC (remember that
the transponder does not challenge the car). For one
value of k the transponder will accept aC and give
an answer. Then A knows that k0 . . .k 15 = k.

3. The adversary proceeds similarly for blocks 5 . . .9

thus recovering the complete secret key.

Attack complexity this attack requires 6 × 216 key-
updates and the same amount of authentication attempts.
This takes approximately 25 minutes for each block
which adds up to a total of two and a half hours.

6.1 Optimizing the attack

The above attack is very powerful, in the worst case, the
attacker needs to update the key on the transponder and
make an authentication attempt 216 times. However, the
same attack can be applied with only one key-update and
216 authentication attempts, by choosing carefully the
value of nC. The optimized attack can be mounted as
follows:

1. As before, the adversary ﬁrst eavesdrops a success-

ful authentication trace, obtaining nC, aC and aT .

2. then, she writes 0x0000 on memory block 9 which

contains key bits k80 . . . k95.

3. The adversary then increments the observed nC

value and attempts an authentication for each
nC + inc (mod 256), where 0 ≤ inc < 216.

4. Repeating step 3) at most 216 times, the transponder
will accept one aC value for a particular increment
value inc and give an answer. Then A knows that
k80 . . .k 95 = inc.

5. The adversary proceeds similarly for blocks 8 and
7. At this point the adversary has recovered key bits
k48 . . .k 95.

6. Next, the adversary guesses 15 key bits k33 . . . k47.
7. Having k33 . . .k 95 the adversary is now able to ini-
tialize the cipher, obtain the initial state s0 and run
it forward up to state s7. At this point the adversary
has 215 candidates for state s7.

8. For each of these candidates, she runs the cipher for-
ward 33 steps up to state s40. While running the
cipher forward the adversary is able to determine
input bits k32 . . . k0 by comparing the output bits to
aC and aT from the trace.

9. Then, forward each candidate state at s40 to s55 and
produce another 15 output bits to test on, although
this time, with the known input of 15 zero bits. On
average only one candidate survives this test. The
adversary has now recovered the complete key.

Attack complexity This attack requires only one suc-
cessful authentication trace. In total, we need to write
three times on the memory of the transponder and per-
form 3 × 216 authentications with the transponder. This
can be done within 30 minutes using a Proxmark III. The
computational complexity of the last three steps is 215
encryptions which takes less than a second on a laptop.

USENIX Association  

22nd USENIX Security Symposium  713

11

7 Weak-Key Attack

During our experiments we executed the previous attack
on several cars of different make and model. Many of the
keys we recovered were of the form k0 = · · · = k31 = 0
and more or less random looking bits for k32 . . . k96 (al-
though we have found keys where only ten of the 96 bits
were ones). In the remainder of this paper we call such a
key weak. Figure 9 shows some examples of weak keys
we found during our experiments (on the vehicles indi-
cated in Figure 2). To avoid naming concrete car models
we use A, B,C . . . to represent car makes. We write num-
bers X.1, X.2, X.3 . . . to represent different car models of
make X .

Car
A.1
A.2
B.1

Secret key

00000000d8 b3967c5a3c3b29
00000000d9 b79d7a5b3c3b28
0000000000 00010405050905

Figure 9: Recovered keys from our own cars. Besides
the evident 32 leading zero bits, every second nibble

seems to encode a manufacturer dependant value, which

further reduces the entropy of the key.

Apparently, the automotive industry has decided to use
only 64 bits of the secret key, probably due to compati-
bility issues with legacy immobilizer systems. If a Meg-
amos Crypto transponder uses such a weak key it is pos-
sible to recover this key quickly, even when the memory
of the transponder is locked with a PIN code. To be con-
crete, a weak secret key with the bits k0 . . . k31 ﬁxed by
the car manufacturer allows an adversary know the input
bits of the cipher states s8 . . .s 55.

With known input to the cipher at states s8 . . . s55, it
is possible to pre-compute and sort on a 47 contiguous
output bits for each internal state at s8. However, such a
table with 256 entries requires a huge amount of storage.
There are many time-memory tradeoff methods proposed
in the literature over the last decades [2–5, 10, 33, 34, 49].
For example, a rainbow table shrinks the storage signiﬁ-
cantly, while requiring only a modest amount of compu-
tation for a lookup.

Concretely, in order to mount such an attack, an ad-

versary A proceeds as follows.

1. Pre-computation: only once, the adversary com-
putes the following rainbow table.
First, she
chooses n random permutations R0 . . .R n−1 of
F56
2 → F56
2 which she uses as reduction functions
(colors). To compute a chain, the intermediate states
are generated by

si+1 = R j(output(si, 056)).

12

The chain begins with the ﬁrst reduction function
R0. When a distinguished point (i.e., a state with a
speciﬁc pattern like a preﬁx of z zero bits) is reached
then the next reduction function R j+1 is used, in or-
der to prevent chain merges. The chain is completed
once a distinguished point is reached while using
the last reduction function Rn−1, see Figure 10. The
start and end values of each chain are stored in the
rainbow table which is sorted on end values.

R0(·)
sp0 (cid:31)

R1(·)
d1 (cid:31)

Rn−2(·)
· · · (cid:31)

...

Rn−1(·)
dn−1 (cid:31)
...

dn = ep0

R0(·)
spm (cid:31)

R1(·)
(cid:31)

d′
1

Rn−2(·)
· · · (cid:31)

Rn−1 (·)
(cid:31)

d′
n−1

d′
n = epm

Figure 10: Construction of the rainbow table

2. As before A ﬁrst eavesdrops one authentication
trace between a legitimate transponder and an im-
Thus A learns the car nonce nC
mobilizer.
and 47 output bits o0 . . .o 46 = output(s7, k32 . . . k5) ·
output(s35, k4 . . .k 0 · 015).

3. For each value of u0 . . . u8 ∈ F9

2 and each reduction
function R j the adversary looks up o0 . . .o 46u0 . . . u8
in the Rainbow table. In order to look up such a
value she sets it as a state and runs the chain until
the last distinguished point is reached at the last re-
duction function. Then, it performs n lookups in the
rainbow table (one for each reduction function) to
ﬁnd the corresponding end point ep.

4. When the end point is found then the correspond-
ing start point sp is used to ﬁnd the previous inter-
nal state which generates o0 . . . o46u0 . . . u8 as out-
put. Since we guessed the last 9 bits u0 . . . u8, we
should consider this as a candidate state.

5. Then, the adversary rolls back each of those states
seven steps, guessing the input k32 . . . k39. This pro-
duces 28 candidate states for s0. As before, for each
candidate s0 she undoes the initialization of the ci-
pher and recovers the remaining key bits k40 . . . k95.
These need to be tested with another trace.

6. If the test is passed then we have recovered the se-
cret key. Otherwise the next u0 . . . u8 should be con-
sidered at step 3).

Attack complexity This attack requires two success-
ful authentication traces. This attack allows for a trade-
off between memory and computational complexity. The
longer the chains the smaller the table gets but more com-
putation is needed for each lookup. Just to give an im-
pression of the feasibility of the attack we consider the
following conﬁguration. Take z to be 10 bits, therefore
our distinguished states have 10 zero bits followed by

714  22nd USENIX Security Symposium 

USENIX Association

2

other 46 bits. We also take 64 = 26 random permutations
R0 . . .R 63. Then, following the computations of Oech-
slin [49], we get that the size of the rainbow table is
3 ≈ 237 entries of 12 bytes which is 1.5 TB. Regard-
(256)
ing its computational complexity, we need to compute
at step 3) 29 candidates for which we compute, for all
26 reduction functions and for all offsets, the end point.
Since a chain has length at most 216, this takes at most
29 × 26 × 26 × 216 = 237 encryptions. This can be com-
puted within a few minutes on a laptop.

For building the rainbow table (needed only once),
computation of the chains is sped up considerably by us-
ing FPGAs. Recently Kalenderi et. al. showed in [37]
that a single FPGA (similar to the ones used in the CO-
PACOBANA) computes chains 2824 times faster than a
single 3GHz processor. They computed rainbow tables
for the A5/1 cipher, which is reasonably similar to the
Megamos Crypto cipher. Although the internal state of
A5/1 is with 64 bits considerably larger than the 56 bits
of Megamos Crypto, they are both designed for hardware
implementation and both embed a non-linear component
that causes some internal states to merge. Their experi-
mental setup generates 345 chains for A5/1 in 830 mil-
liseconds, which is roughly 345
0.830 ≈ 415 chains per sec-
ond. If we compute an estimate with respect to the differ-
ence in complexity, the COPACOBANA with a 120 FPGA-
3 × 120 ≈ 218.3 chains per
array can compute 415 × (28)
second. That means it takes only 237−18.3 ≈ 218.7 sec-
onds, which is less than 5 days, to build the complete
rainbow table.

1

8 Practical considerations and mitigation

Our attacks require close range wireless communication
with both the immobilizer unit and the transponder. It is
not hard to imagine real-life situations like valet parking
or car rental where an adversary has access to both for
a period of time. It is also possible to foresee a setup
with two perpetrators, one interacting with the car and
one wirelessly pickpocketing the car key from the vic-
tims pocket.

As mitigating measure, car manufacturers should set
uniformly generated secret keys and for the devices
which are not locked yet, set PIN codes and write-lock
their memory after initialization. This obvious measures
would prevent a denial of service attack, our partial key-
update attack from Section 6 and our weak-key attack
from Section 7.

Car owners can protect their own vehicles against a
denial of service and the partial key-update attack, de-
scribed in Section 6. These attacks only work if the ad-
versary has write access to the memory of the transpon-
der, which means that the lock-bit l0 is set to zero. It
is possible for a user to test for this property with any
compatible RFID reader, like the Proxmark III, using

our communication library. If l0 = 0, then you should set
the lock-bit l0 to one. It is possible to set this bit with-
out knowing the secret key or the PIN code. When deal-
ing with the more recent version of the Megamos Crypto
transponder (EM4170), users should also update the PIN
code to a random bit-string before locking the transpon-
der.

On the positive side, our ﬁrst (cryptographic) attack
is more computationally intensive than the attacks from
Section 6 and 7 which makes it important to take the
aforementioned mitigating measures in order to prevent
the more inexpensive attacks. Unfortunately, our ﬁrst at-
tack is also hard to mitigate when the adversary has ac-
cess to the car and the transponder (e.g., Valet and car
rental). It seems infeasible to prevent an adversary from
gathering two authentication traces. Furthermore, this
attack exploits weaknesses in the core of the cipher’s
design (e.g., the size of the internal state).
It would
require a complete redesign of the cipher to ﬁx these
weaknesses. To that purpose, lightweight ciphers like
Grain [32], Present [7] and KATAN [15] have been pro-
posed in the literature and could be considered as suit-
able replacements for Megamos Crypto. Also, immobi-
lizer products implementing AES are currently available
in the market.

9 Conclusions

The implications of the attacks presented in this paper
are especially serious for those vehicles with keyless ig-
nition. At some point the mechanical key was removed
from the vehicle but the cryptographic mechanisms were
not strengthened to compensate.

We want to emphasize that it is important for the au-
tomotive industry to migrate from weak proprietary ci-
phers like this to community-reviewed ciphers such as
AES [14] and use it according to the guidelines. For a
few years already, there are contactless smart cards on
the market [48, 50] which implement AES and have a
fairly good pseudo-random number generator. It is sur-
prising that the automotive industry is reluctant to mi-
grate to such transponders considering the cost differ-
ence of a better chip (≤ 1 USD) in relation to the prices
of high-end car models (≥ 50, 000 USD). Since most car
keys are actually fairly big, the transponder design does
not really have to comply with the (legacy) constraints of
minimal size.

Following the principle of responsible disclosure, we
have notiﬁed the manufacturer of our ﬁndings back in
November 2012. Since then we have an open commu-
nication channel with them. We understand that mea-
sures have been taken to prevent the weak-key and partial
key-update attacks when the transponder was improperly
conﬁgured.

USENIX Association  

22nd USENIX Security Symposium  715

13

10 Acknowledgments

The authors would like to thank Bart Jacobs for his ﬁrm
support.

References

[1] Embedded avr microcontroller including rf trans-
mitter and immobilizer lf functionality for remote
keyless entry - ATA5795C. Product Datasheet,
November 2011. Atmel Corporation.

[2] AVOINE, G., JUNOD, P., AND OECHSLIN, P.
Characterization and improvement of time-memory
trade-off based on perfect tables. ACM Transac-
tions on Information and System Security (TISSEC
2008) 11, 4 (2008), 1–22.

[3] BABBAGE, S. A space/time tradeoff in exhaustive
search attacks on stream ciphers. In European Con-
vention on Security and Detection (1995), vol. 408
of Conference Publications, IEEE Computer Soci-
ety, pp. 161–166.

[4] BIRYUKOV, A., MUKHOPADHYAY, S., AND
SARKAR, P.
Improved time-memory trade-offs
with multiple data. In 13th International Workshop
on Selected Areas in Cryptography (SAC 2006)
(2006), vol. 3897 of Lecture Notes in Computer Sci-
ence, Springer-Verlag, pp. 110–127.

[5] BIRYUKOV, A., AND SHAMIR, A. Cryptanalytic
time/memory/data tradeoffs for stream ciphers. In
6th International Conference on the Theory and
Application of Cryptology and Information Secu-
rity, Advances in Cryptology (ASIACRYPT 2000)
(2000), vol. 1976 of Lecture Notes in Computer Sci-
ence, Springer-Verlag, pp. 1–13.

[6] BOGDANOV, A. Linear slide attacks on the KeeLoq
In 3rd International Conference on
block cipher.
Information Security and Cryptology (INSCRYPT
2007) (2007), vol. 4990 of Lecture Notes in Com-
puter Science, Springer, pp. 66–80.

[7] BOGDANOV, A., KNUDSEN, L. R., LEAN-
DER, G., PAAR, C., POSCHMANN, A., ROB-
SHAW, M. J., SEURIN, Y., AND VIKKELSOE, C.
PRESENT: An ultra-lightweight block cipher.
In
Cryptographic Hardware and Embedded Systems-
CHES 2007. Springer, 2007, pp. 450–466.

[8] BOGDANOV, A., AND PAAR, C. On the secu-
rity and efﬁciency of real-world lightweight au-
thentication protocols.
In 1st Workshop on Se-
cure Component and System Identiﬁcation (SECSI
2008) (2008), ECRYPT.

[9] BONO, S. C., GREEN, M., STUBBLEFIELD, A.,
JUELS, A., RUBIN, A. D., AND SZYDLO, M.
Security analysis of a cryptographically-enabled
RFID device. In 14th USENIX Security Symposium
(USENIX Security 2005) (2005), USENIX Associ-
ation, pp. 1–16.

[10] BORST, J., PRENEEL, B., VANDEWALLE, J.,
AND V, J. On the time-memory tradeoff between
exhaustive key search and table precomputation.
In 19th Symposium in Information Theory in the
Benelux (1998), pp. 111–118.

[11] CHECKOWAY, S., MCCOY, D., KANTOR, B.,
ANDERSON, D., SHACHAM, H., SAVAGE, S.,
KOSCHER, K., CZESKIS, A., ROESNER, F., AND
KOHNO, T. Comprehensive experimental analyses
of automotive attack surfaces. In 20th USENIX Se-
curity Symposium (USENIX Security 2011) (2011),
USENIX Association, pp. 77–92.

[12] COURTOIS, N. T., BARD, G. V., AND WAGNER,
D. Algebraic and slide attacks on KeeLoq. In 15th
International Workshop on Fast Software Encryp-
tion (FSE 2008) (2008), vol. 5086 of Lecture Notes
in Computer Science, Springer-Verlag, pp. 97–115.
AND
Practical algebraic at-
QUISQUATER,
In 12th
tacks on the Hitag2 stream cipher.
Information Security Conference
(ISC 2009)
(2009), vol. 5735 of Lecture Notes in Computer
Science, Springer-Verlag, pp. 167–176.

[13] COURTOIS, N. T., O’NEIL,

J.-J.

S.,

[14] DAEMEN, J., AND RIJMEN, V. The Design of Ri-
jndael: AES - The Advanced Encryption Standard.
Springer-Verlag, 2002.

[15] DE CANNIERE, C., DUNKELMAN, O., AND
KNE ˇZEVI ´C, M. KATAN and KTANTANa family
of small and efﬁcient hardware-oriented block ci-
phers. In Cryptographic Hardware and Embedded
Systems-CHES 2009. Springer, 2009, pp. 272–288.
[16] DE KONING GANS, G., HOEPMAN, J.-H., AND
GARCIA, F. D. A practical attack on the MIFARE
Classic. In 8th Smart Card Research and Advanced
Applications Conference (CARDIS 2008) (2008),
vol. 5189 of Lecture Notes in Computer Science,
Springer-Verlag, pp. 267–282.

[17] DIAGNOSTICS, A. AD900Pro transponder dupli-
cating system, operation manual, unlocking tech-
nology, March 2011.

[18] DRIESSEN, B., HUND, R., WILLEMS, C., PAAR,
C., AND HOLZ, T. Don’t trust satellite phones: A
security analysis of two satphone standards. In 33rd
IEEE Symposium on Security and Privacy (S&P
2012) (2012), IEEE Computer Society, pp. 128–
142.

[19] EM Microelectronic-Marin

SA.

www.emmicroelectronic.com.
Marin/Switzerland.

http://
CH-2074

[20] Crypto contactless identiﬁcation device, V4070.
Product Datasheet, Oct 1997. EM Microelectronic-
Marin SA.

[21] 125khz crypto read/write contactless identiﬁcation
device, EM4170. Product Datasheet, Mar 2002.

716  22nd USENIX Security Symposium 

USENIX Association

14

EM Microelectronic-Marin SA.

[22] Custom automotive.

retrieved at December
12th, 2014, from http://www.datasheetarchive.com/
EM+MICROELECTRONIC-MARIN-datasheet.html,
September 2002. EM Microelectronic-Marin SA.

[23] EM4170 application note, AN407. RFID Appli-
cation Note 407, Sep 2002. EM Microelectronic-
Marin SA.

[24] FLUHRER, S., MANTIN, I., AND SHAMIR, A.
Weaknesses in the key scheduling algorithm of
RC4.
In 8th International Workshop on Se-
lected Areas in Cryptography (SAC 2001) (2001),
vol. 2259 of Lecture Notes in Computer Science,
pp. 1–24.

[25] FRANCILLON, A., DANEV, B., AND ˇCAPKUN, S.
Relay attacks on passive keyless entry and start sys-
tems in modern cars.
In 18th Network and Dis-
tributed System Security Symposium (NDSS 2011)
(2011), The Internet Society.

[26] GARCIA, F. D., DE KONING GANS, G., MUIJR-
ERS, R., VAN ROSSUM, P., VERDULT, R., WICH-
ERS SCHREUR, R., AND JACOBS, B. Dismantling
MIFARE Classic. In 13th European Symposium on
Research in Computer Security (ESORICS 2008)
(2008), vol. 5283 of Lecture Notes in Computer Sci-
ence, Springer-Verlag, pp. 97–114.

[27] GARCIA, F. D., DE KONING GANS, G., AND
VERDULT, R. Exposing iClass key diversiﬁcation.
In 5th USENIX Workshop on Offensive Technolo-
gies (WOOT 2011) (2011), USENIX Association,
pp. 128–136.

[28] GARCIA, F. D., DE KONING GANS, G., VER-
DULT, R., AND MERIAC, M. Dismantling iClass
and iClass Elite. In 17th European Symposium on
Research in Computer Security (ESORICS 2012)
(2012), vol. 7459 of Lecture Notes in Computer Sci-
ence, Springer-Verlag, pp. 697–715.

[29] GARCIA, F. D., VAN ROSSUM, P., VERDULT, R.,
AND WICHERS SCHREUR, R. Wirelessly pick-
pocketing a MIFARE Classic card. In 30th IEEE
Symposium on Security and Privacy (S&P 2009)
(2009), IEEE Computer Society, pp. 3–15.

[30] GARCIA, F. D., VAN ROSSUM, P., VERDULT, R.,
AND WICHERS SCHREUR, R. Dismantling Se-
cureMemory, CryptoMemory and CryptoRF.
In
17th ACM Conference on Computer and Com-
munications Security (CCS 2010) (2010), ACM,
pp. 250–259.

[31] GOLI ´C, J. D. Cryptanalysis of alleged A5 stream
cipher.
In 16th International Conference on the
Theory and Application of Cryptographic Tech-
niques, Advances in Cryptology (EUROCRYPT
1997) (1997), vol. 1233 of Lecture Notes in Com-
puter Science, Springer-Verlag, pp. 239–255.

[32] HELL, M., JOHANSSON, T., AND MEIER, W.
Grain: a stream cipher for constrained environ-
ments. International Journal of Wireless and Mo-
bile Computing 2, 1 (2007), 86–93.

[33] HELLMAN, M. E. A cryptanalytic time-memory
trade-off. IEEE Transactions on Information The-
ory 26, 4 (1980), 401–406.

[34] HONG, J., AND MOON, S. A comparison of crypt-
analytic tradeoff algorithms. Journal of Cryptology
(2010), 1–79.

[35] IMMLER, V. Breaking hitag 2 revisited. Secu-
rity, Privacy, and Applied Cryptography Engineer-
ing (SPACE 2012) 7644 (2012), 126–143.

[36] INDESTEEGE, S., KELLER, N., DUNKELMANN,
O., BIHAM, E., AND PRENEEL, B. A practi-
cal attack on KeeLoq. In 27th International Con-
ference on the Theory and Application of Crypto-
graphic Techniques, Advances in Cryptology (EU-
ROCRYPT 2008) (2008), vol. 4965 of Lecture
Notes in Computer Science, Springer-Verlag, pp. 1–
8.

[37] KALENDERI, M., PNEVMATIKATOS, D., PA-
PAEFSTATHIOU, I., AND MANIFAVAS, C. Break-
ing the gsm a5/1 cryptography algorithm with
wainbow tables and high-end FPGAS.
In 22nd
International Conference on Field Programmable
Logic and Applications (FPL 2012) (2012), IEEE
Computer Society, pp. 747–753.

[38] KASPER, M., KASPER, T., MORADI, A., AND
Breaking KeeLoq in a ﬂash: on
PAAR, C.
extracting keys at lightning speed.
In 2nd In-
ternational Conference on Cryptology in Africa,
Progress in Cryptology (AFRICACRYPT 2009)
(2009), vol. 5580 of Lecture Notes in Computer Sci-
ence, Springer-Verlag, pp. 403–420.

[39] KEYLINE. Transponder guide. http://www.keyline.it/

ﬁles/884/transponder guide 16729.pdf, 2012.

[40] KOSCHER, K., CZESKIS, A., ROESNER, F., PA-
TEL, F., KOHNO, T., CHECKOWAY, S., MCCOY,
D., KANTOR, B., ANDERSON, D., SHACHAM,
H., AND SAVAGE, S. Experimental security analy-
sis of a modern automobile. In 31rd IEEE Sympo-
sium on Security and Privacy (S&P 2010) (2010),
IEEE Computer Society, pp. 447–462.

[41] KOUSHANFAR, F., SADEGHI, A.-R., AND
SEUDIE, H. Eda for secure and dependable cyber-
cars: Challenges and opportunities. In 49th Design
Automation Conference (DAC 2012) (2012), ACM,
pp. 220–228.

[42] KUMAR, S., PAAR, C., PELZL, J., PFEIFFER,
G., AND SCHIMMLER, M. Breaking ciphers with
COPACOBANA—a cost-optimized parallel code
breaker. In Cryptographic Hardware and Embed-
ded Systems (CHES 2006) (2006), vol. 4249 of Lec-

USENIX Association  

22nd USENIX Security Symposium  717

15

ture Notes in Computer Science, Springer-Verlag,
pp. 101–118.

[43] LEMKE, K., SADEGHI, A.-R., AND ST ¨UBLE,
C. Anti-theft protection: Electronic immobilizers.
Embedded Security in Cars (2006), 51–67.

[44] LEMKE, K., SADEGHI, A.-R., AND STBLE, C.
An open approach for designing secure electronic
immobilizers. In Information Security Practice and
Experience (ISPEC 2005) (2005), vol. 3439 of Lec-
ture Notes in Computer Science, Springer-Verlag,
pp. 230–242.

[45] LUCKS, S., SCHULER, A., TEWS, E., WEIN-
MANN, R.-P., AND WENZEL, M. Attacks on the
DECT authentication mechanisms.
In 9th Cryp-
tographers’ Track at the RSA Conference (CT-RSA
2009) (2009), vol. 5473 of Lecture Notes in Com-
puter Science, Springer-Verlag, pp. 48–65.

[46] NOHL, K., EVANS, D., STARBUG, AND PL ¨OTZ,
H. Reverse engineering a cryptographic RFID
tag.
In 17th USENIX Security Symposium
(USENIX Security 2008) (2008), USENIX Associ-
ation, pp. 185–193.

[47] NOHL, K., TEWS, E., AND WEINMANN, R.-P.
Cryptanalysis of the DECT standard cipher. In 17th
International Workshop on Fast Software Encryp-
tion (FSE 2010) (2010), vol. 6147 of Lecture Notes
in Computer Science, Springer-Verlag, pp. 1–18.

[48] MIFARE DESFire EV1

contactless multi-
application IC, MF3ICDx21. Product short data
sheet, December 2010. NXP Semiconductors.

[49] OECHSLIN, P. Making a faster cryptanalytic time-
memory trade-off. In 23rd International Cryptol-
ogy Conference, Advances in Cryptology (CRYPTO
2003) (2003), vol. 2729 of Lecture Notes in Com-
puter Science, Springer-Verlag, pp. 617–630.
[50] Smart MX secure smart card controller

IC,
P5CC018. Objective Speciﬁcation, Revision 1.0,
April 2003. Philips Semiconductors.

[51] ROLLES, R. Unpacking virtualization obfuscators.
In 3rd USENIX Workshop on Offensive Technolo-
gies (WOOT 2009) (2009).

[52] SOOS, M., NOHL, K., AND CASTELLUCCIA, C.
Extending SAT solvers to cryptographic problems.
In 12th International Conference on Theory and
Applications of Satisﬁability Testing (SAT 2009)
(2009), vol. 5584 of Lecture Notes in Computer Sci-
ence, Springer-Verlag, pp. 244–257.

[53] SUN, S., HU, L., XIE, Y., AND ZENG, X. Cube
cryptanalysis of Hitag2 stream cipher. In 10th In-
ternational Conference on Cryptology and Network
Security (CANS 2011) (2011), vol. 7092 of Lec-
ture Notes in Computer Science, Springer-Verlag,
pp. 15–25.

[54] TILLICH, S., AND W ´OJCIK, M. Security analysis
of an open car immobilizer protocol stack. In 10th
International Conference on Applied Cryptograpy
and Network Security (ACNS 2012) (2012).

[55] VAN OURS, J. C., AND VOLLAARD, B. The
engine immobilizer: a non-starter for car thieves,
2011.

[56] VERDULT, R., DE KONING GANS, G., AND GAR-
CIA, F. D. A toolbox for RFID protocol analysis.
In 4th International EURASIP Workshop on RFID
Technology (EURASIP RFID 2012) (2012), IEEE
Computer Society, pp. 27–34.

[57] VERDULT, R., GARCIA, F. D., AND BALASCH, J.
Gone in 360 seconds: Hijacking with Hitag2.
In
21st USENIX Security Symposium (USENIX Secu-
rity 2012) (2012), USENIX Association, pp. 237–
252.

[58] ˇSTEMBERA, P., AND NOVOTN ´Y, M.

Break-
ing Hitag2 with reconﬁgurable hardware.
In
14th Euromicro Conference on Digital System De-
sign (DSD 2011) (2011), IEEE Computer Society,
pp. 558–563.

[59] WANG, P.-C., HOU, T.-W., WU, J.-H., AND
CHEN, B.-C. A security module for car appli-
ances.
International Journal of World Academy
Of Science, Engineering and Technology 26 (2007),
155–160.
[60] WIENER,

Hitag2
PCF7936/46/47/52
reference
implementation. http://cryptolib.com/ciphers/hitag2/,
2007.

stream cipher

I.

Philips/NXP

[61] WOLF, M., WEIMERSKIRCH,

AND
WOLLINGER, T.
State of the art: Embed-
ding security in vehicles. EURASIP Journal on
Embedded Systems 2007 (2007), 074706.

A.,

[62] WU, J.-H., KUNG, C.-C., RAO, J.-H., WANG,
P.-C., LIN, C.-L., AND HOU, T.-W. Design of
an in-vehicle anti-theft component.
In 8th Inter-
national Conference on Intelligent Systems Design
and Applications (ISDA 2008) (2008), vol. 1, IEEE

718  22nd USENIX Security Symposium 

USENIX Association

16

