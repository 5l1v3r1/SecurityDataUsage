Frodo: Take off the Ring!

Practical, Quantum-Secure Key Exchange from LWE

Joppe Bos

NXP Semiconductors
joppe.bos@nxp.com

Craig Costello
Microsoft Research

craigco@microsoft.com

Ilya Mironov
Google Inc.

mironov@google.com

Michael Naehrig
Microsoft Research

mnaehrig@microsoft.com

Léo Ducas

CWI

l.ducas@cwi.nl

∗

Valeria Nikolaenko
Stanford University

valerini@stanford.edu

Ananth Raghunathan

Google Inc.

pseudorandom@google.com

Douglas Stebila
McMaster University

stebilad@mcmaster.ca

ABSTRACT
Lattice-based cryptography oﬀers some of the most attrac-
tive primitives believed to be resistant to quantum com-
puters. Following increasing interest from both companies
and government agencies in building quantum computers, a
number of works have proposed instantiations of practical
post-quantum key exchange protocols based on hard prob-
lems in ideal lattices, mainly based on the Ring Learning
With Errors (R-LWE) problem. While ideal lattices facil-
itate major eﬃciency and storage beneﬁts over their non-
ideal counterparts, the additional ring structure that en-
ables these advantages also raises concerns about the as-
sumed diﬃculty of the underlying problems. Thus, a ques-
tion of signiﬁcant interest to cryptographers, and especially
to those currently placing bets on primitives that will with-
stand quantum adversaries, is how much of an advantage
the additional ring structure actually gives in practice.

Despite conventional wisdom that generic lattices might
be too slow and unwieldy, we demonstrate that LWE-based
key exchange is quite practical: our constant time imple-
mentation requires around 1.3ms computation time for each
party; compared to the recent NewHope R-LWE scheme,
communication sizes increase by a factor of 4.7×, but remain
under 12 KiB in each direction. Our protocol is competitive
when used for serving web pages over TLS; when partnered
with ECDSA signatures, latencies increase by less than a fac-
tor of 1.6×, and (even under heavy load) server throughput
only decreases by factors of 1.5× and 1.2× when serving typ-
ical 1 KiB and 100 KiB pages, respectively. To achieve these
practical results, our protocol takes advantage of several in-
∗
Large parts of this work were done when Valeria Nikolaenko was
an intern at Google.

Permission to make digital or hard copies of part or all of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for third-party components of this work must be honored.
Request permissions from Permissions@acm.org.
CCS’16 October 24–28, 2016, Vienna, Austria
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-4139-4/16/10...15.00
DOI: http://dx.doi.org/10.1145/2976749.2978425

novations. These include techniques to optimize communi-
cation bandwidth, dynamic generation of public parameters
(which also oﬀers additional security against backdoors),
carefully chosen error distributions, and tight security pa-
rameters.

Keywords
Post-quantum cryptography; learning with errors; key ex-
change; OpenSSL; TLS

1.

INTRODUCTION

Recent advances in quantum computing (cf. [26, 39]) have
triggered widespread interest in developing practical post-
quantum cryptographic schemes [48]. Subsequently, stan-
dards bodies and government agencies have announced their
intentions to transition to cryptographic standards that of-
fer quantum-resistance; this includes the National Institute
of Standards and Technology (NIST) [50], the National Se-
curity Agency (NSA) [51], and the PQCRYPTO project [9]
funded by the European Union.

Traditional number-theoretic cryptographic problems such
as the integer factorization problem and the discrete loga-
rithm problem (over both multiplicative groups modulo a
prime p and elliptic curve groups) are vulnerable to polyno-
mial-time quantum attacks [60, 56]. Lattice-based cryptog-
raphy, beginning with Ajtai’s seminal work [4] (cf. the recent
survey [54] for a comprehensive list of relevant references), is
an exciting ﬁeld of research that, in addition to providing a
richer diversity of underlying primitives, oﬀers the potential
to build practical quantum-resistant cryptography.
1.1 Key Exchange and Forward Secrecy

Although large-scale quantum computers are likely to af-
fect all of the cryptographic building blocks used to secure
the internet, the threat of quantum computing to each spe-
ciﬁc primitive diﬀers signiﬁcantly. On the symmetric side,
the cryptanalytic speedups (using Grover’s algorithm [32])
aided by a quantum computer are well-understood.
It is
currently believed that it will suﬃce to double the secret
key sizes of symmetric encryption algorithms and MACs to
defend against quantum computers.

1006On the asymmetric side, cryptographers are currently ex-
amining the potential of a new range of mathematical prob-
lems (like those based on lattices) for post-quantum secu-
rity. While there are several interesting candidates for post-
quantum signature schemes, a more pressing concern to prac-
titioners is the deployment of post-quantum public key en-
cryption and key exchange protocols: the secrecy of today’s
communications can be compromised by a quantum com-
puter that is built decades into the future (by an attacker
who stores these communications until then); on the other
hand, authentication can only be forged at connection time.
In this paper, we focus on the most pressing issue in pub-
lic key post-quantum cryptography: the development of a
secure, practical key exchange protocol that can be used to
secure internet traﬃc in anticipation of a quantum adver-
sary. This focus on (quantum-secure) key exchange aligns
with the notion of forward secrecy [27] deployed in TLS and,
for example, the notion of long-term security used for classi-
ﬁed documents by government agencies (see Table 4 in [11]).

1.2 Generic vs. Ideal Lattices

Public-key cryptography is built on the presumed diﬃ-
culty of hard computational problems. Whenever such a
problem is introduced and has potential as a cryptographic
primitive, cryptographers naturally study whether there are
special instances of the problem that oﬀer practical beneﬁts,
and in particular, whether they do so without compromis-
ing the presumed hardness. There are several historic exam-
ples of special instances that have proven to be a disastrous
choice compared to suitably chosen random instances, e.g.,
the use of supersingular curves in elliptic curve cryptography
(ECC) [46, 28]. In some cases, special instances introduce
well-understood security issues that can be weighed against
potential beneﬁts, e.g., the use of small public exponents in
RSA [22]. In many scenarios, however, the size of such a se-
curity gap, or whether there is a gap at all, remains unclear.
One example of an unknown security gap currently exists
in lattice-based cryptography. Five years after Regev’s pa-
per introducing the Learning With Errors (LWE) problem
was published [57], Lyubashevsky, Peikert and Regev [45]
introduced a specialized version of the problem called Ring
Learning With Errors (R-LWE), which oﬀers signiﬁcant stor-
age and eﬃciency improvements. LWE is a mature and well-
studied [7, 44, 47, 16] cryptographic primitive that relies
only on the worst-case hardness of a shortest vector problem
in generic lattices. R-LWE has additional algebraic struc-
ture and relies on the (worst-case) hardness of problems in
ideal lattices. Ideal lattices correspond to ideals in certain
algebraic structures, such as polynomial rings. NTRU lat-
tices [34], which are a class of lattices with some structure
(but diﬀerent from R-LWE lattices) have also been used to
build cryptosystems.

The hardness of lattice problems on regular lattices as
well as ideal lattices merits more study. Although the al-
gebraic structure of R-LWE (and NTRU) makes for more
practical key-sizes and protocol communication, this alge-
braic structure might inspire less conﬁdence in the under-
lying security. Currently, the best algorithms to solve hard
problems in ideal lattices [21, 43] are the same as those that
target regular lattices (modulo small polynomial speedups),
and it is not known whether the R-LWE problem is signiﬁ-
cantly easier than the LWE problem for the same parameter
sizes. Certain sieving algorithms obtain a constant factor

time and/or space improvement in the ideal case [59, 15],
but (at best) this only shaves a few bits oﬀ of the known
bit-security. At the very least, however, the additional ring
structure might introduce subtleties in the choice of error
distribution [55].

Several recent papers [53, 14, 64, 6] have proposed and
implemented key exchange variants that rely on the hard-
ness of the R-LWE problem [45]. In contrast, in this paper
we develop and evaluate a secure and practical key exchange
protocol from the original LWE problem [58], the security of
which is based on hard problems in lattices that do not pos-
sess any ring structure. While both academic [9] and govern-
ment [19, 49] bodies are currently exploring candidates for
post-quantum cryptography, we believe it prudent to give a
concrete evaluation of a lattice-based scheme that is invoked
without the additional structure, and to draw comparisons
to previous ring-based implementations. The design of our
implementation and its accompanying security analysis was
performed with a view towards real-world (and in particu-
lar, internet) deployment. To our knowledge, there has not
yet been a practical implementation of key exchange based
on the original LWE problem.
1.3 Our Contributions

We demonstrate the feasibility of LWE-based key exchange
with a new key exchange protocol which we call “Frodo,”
and we provide a proof of its security based on the original
LWE problem. We give parameter sets for LWE at several
security levels, including “recommended” parameters that
achieve 128-bit security against quantum adversaries (using
the best known attacks that incorporate recent advances in
lattice cryptanalysis), and “paranoid” parameters that are
based on lower bounds for sieving algorithm complexities.
Our protocol incorporates several innovations:
• Eﬃciently sampleable noise distribution. We present
four discrete noise distributions that are more eﬃcient
to sample than previously used discrete Gaussian dis-
tributions (without increasing the lattice dimensions);
the safety of using these in place of rounded continu-
ous Gaussians follows from analyzing the correspond-
ing R´enyi divergence.
• Eﬃcient and dynamic generation of public parameters.
We generate the LWE public matrix A for every key
exchange from a small random seed, which has two
beneﬁts. Using a new A with every connection avoids
the use of global parameters that can lead to “all-for-
the-price-of-one” precomputation attacks, such as the
Logjam attack on ﬁnite-ﬁeld Diﬃe–Hellman [1] (we
note that these attacks have the potential to be even
more devastating in the context of lattices – see [6]).
Furthermore, in LWE this approach gives rise to signif-
icant bandwidth savings, since we avoid the transmis-
sion of the large matrix A by instead transmitting the
small seed. While this approach was already explored
in the context of R-LWE in [6], in the context of LWE
it becomes more challenging due to the large amount
of randomness that is required. A signiﬁcant step to-
wards achieving high performance was optimizing this
pseudorandom generation of A, since in our case it still
consumes around 40% of the total computation time
for each party. In order to target a large number of
platforms and applications, we optimized this step for
memory-access patterns; pseudorandom construction

1007of A from a small random seed is done component-wise
so that devices with memory constraints can generate
blocks of A, use them, and discard them.

Implementation. We provide an open-source implemen-
tation of our protocol in the C language that provides pro-
tection against simple timing and cache-timing attacks. We
have integrated our implementation, as well as publicly avail-
able implementations of several other post-quantum key ex-
change protocols [14, 6, 63, 24], to allow a direct compar-
ison of post-quantum candidates in a common framework.
We have also integrated our framework into OpenSSL, al-
lowing it to be used with Apache for performance testing in
real-world settings. In addition, we implemented and eval-
uated the hybrid version of each ciphersuite; this partners
each of the proposed post-quantum key exchange primitives
with ECDHE in order to mitigate the potential of (classical)
cryptanalytic advances against the newer primitives.

The implementation of our protocol and parameter ﬁnding
scripts are available at https://github.com/lwe-frodo/. Our
framework for comparing post-quantum algorithms and in-
tegration into OpenSSL is available at https://github.com/
open-quantum-safe/.

Performance comparison and evaluation in TLS. We
evaluate the performance of our protocol, along with the
other post-quantum protocols mentioned above, in two ways:
• Microbenchmarks. These measure the performance of
standalone cryptographic operations. Using LWE key
exchange at the “recommended” security level, each
party’s operations run in around 1.3ms. As expected,
this is slower but still comparable to ideal lattice-based
schemes (they have runtimes between 0.15ms—2.15ms
per party), but it is signiﬁcantly faster than the post-
quantum software based on supersingular isogenies [24],
and is comparable to traditional elliptic curve Diﬃe–
Hellman using nistp256 (which takes about 0.7ms per
party). Table 4 contains detailed comparisons.
• Performance within HTTPS/TLS. To measure the real-
world impact of using generic lattices, we measure the
connection time and server throughput when using
post-quantum ciphersuites in TLS. This includes their
performance under heavy sustained load while serving
hundreds of connections every second. In this realis-
tic scenario, the performance gap between ideal and
generic lattices shrinks considerably. When ECDSA
certiﬁcates are used, the time to establish a connec-
tion using our LWE key exchange ciphersuite is just
18.3ms (or 23ms when deployed in a hybrid mode with
ECDHE). The handshake size is around 23.1 KiB. Com-
pared to NewHope [6] (which is a very fast R-LWE
based scheme), we see that using generic lattices in
our case gives rise to just a factor 1.5× increase in la-
tency (12.1ms or 16.5ms in hybrid mode), and a factor
4.7× increase in handshake size (4.9 KiB). Given that
modern web pages load with latencies of hundreds of
milliseconds and with sizes of a megabyte or more, the
overhead of LWE key exchange is manageable in many
cases and unnoticeable in many more. We measured
connections per second at a variety of page sizes (see
Table 5): at 100 KiB, the throughput of LWE is only
1.2× less than that of NewHope, and this drops to just
1.15× when each ciphersuite is deployed in a hybrid
mode with ECDHE.

Ultimately, the size and speed of our protocol shows that
we need not rely exclusively on ideal lattices to construct
practical lattice-based key exchange: LWE-based key ex-
change is indeed a viable candidate for a practical quantum-
resistant scheme.

2. RELATED WORK

Regev [58] introduced the LWE problem accompanied by
a (quantum) reduction to certain worst-case lattice prob-
lems and demonstrated how to build a public-key encryption
scheme based on the hardness of this problem. Peikert [52]
gave the ﬁrst classical reduction from LWE to standard lat-
tice problems, however this reduction required moduli that
were exponential in the size of the lattice dimension. Sub-
sequently, Brakerski et al. [16] then showed that for moduli
that are polynomial in the size of the lattice dimension, stan-
dard, worst-case problems in lattices are classically reducible
to the LWE problem. Constructions based on LWE have led
to a large variety of public-key cryptosystems [38, 52, 31, 18,
3, 2, 17]. Its ring analogue, R-LWE [45], yields more eﬃcient
constructions of public-key cryptosystems [53].

Based on the key encapsulation mechanism described by
Peikert [53], Bos et al. [14] presented a Diﬃe-Hellman-like
key exchange protocol whose security is based on the R-LWE
problem. They demonstrated the feasibility of the protocol
by integrating their implementation into the TLS protocol
in OpenSSL, reporting a slight performance penalty over
classically secure key exchange (using elliptic curves). Soon
after, Alkim et al. [6] presented a range of improvements
over the implementation in [14]. In particular, the in-depth
security analysis performed in [6] paved the way for a su-
perior set of parameters to those used in [14]: Alkim et al.
showed that higher security could be achieved with a smaller
modulus and a new, more eﬃciently samplable noise distri-
bution. Moreover, their improved error reconciliation and
more aggressive implementation culminated in R-LWE key
exchange software that was more than an order of magnitude
faster than the software presented by Bos et al..

Previously, Ding et al. [37] had proposed an alternative
instantiation of lattice-based key exchange that builds on
Regev’s public-key cryptosystem [58], giving a Diﬃe-Hellman-
like protocol from both LWE and R-LWE. The deduced
shared key in their scheme is not uniform random, and they
subsequently suggest to use an extractor; however, this re-
duces the eﬀective length of the key. Our protocol is based
on similar ideas to the LWE protocol in [37], but as in the R-
LWE schemes in [14] and [6], we incorporate (and extend)
Peikert’s reconciliation technique [53] and further modify
the protocol to conserve bandwidth. Moreover, the analysis
in [37] was performed for single-bit key exchange, and [37]
did not include a concrete proposal for quantum-secure key
exchange or an implementation of the scheme.

3. KEY EXCHANGE FROM LWE

Notation. If χ is a probability distribution over a set S,
then x $← χ denotes sampling x ∈ S according to χ. If S is
a set, then U(S) denotes the uniform distribution on S, and
we denote sampling x uniformly at random from S either
with x $← U (S) or sometimes x $← S. Matrices are denoted
If χ is a distribution over a
by bold face capital letters.
set S, then X $← χ(Sn×m) denotes generating an n × m

1008Bob

Using the protocol in TLS. To integrate our LWE key
exchange protocol into TLS, we have the server play the
role of Alice and the client play the role of Bob. Alice’s ﬁrst
ﬂow is sent as the ServerKeyExchange message, and Bob’s
response is sent as the ClientKeyExchange message. Alice
and Bob use K as the premaster secret.

Alice
$← U ({0, 1}s)
seedA
A ← Gen(seedA)
S, E $← χ(Zn×n
)
B ← AS + E

q

K ← rec(B(cid:48)S, C)

seedA, B

∈ {0, 1}s × Zn×n

q

B(cid:48), C

∈ Zm×n

q

× Zm×n

2

q

A ← Gen(seedA)
S(cid:48), E(cid:48) $← χ(Zm×n
)
B(cid:48) ← S(cid:48)A + E(cid:48)
E(cid:48)(cid:48) $← χ(Zm×n
)
V ← S(cid:48)B + E(cid:48)(cid:48)
C ← (cid:104)V(cid:105)2B

q

K ← (cid:98)V(cid:101)2B

q

q

and B(cid:48)S ∈ Zm×n

Hybrid ciphersuites. As lattice-based cryptography is
undergoing a period of intense development and scrutiny, a
conservative approach towards deployment of lattice-based
key exchange is to pair it with legacy schemes such as elliptic
curve Diﬃe-Hellman (ECDH). Since the message ﬂow of our
proposed solution is identical to the existing ECDH(E) key
exchange protocol, the two can be run concurrently as part
of the same “hybrid” ciphersuite, with both outputs mixed
in into the premaster secret via a KDF (as was done in [14]);
see §7 for performance results.
3.2 A generalized reconciliation mechanism
In the protocol in Figure I, Alice and Bob compute the
secret matrices V ∈ Zm×n
, respectively.
Each of the mn entries in V is approximately equal in Zq to
the corresponding entry in B(cid:48)S. To modify such an approxi-
mate key agreement into an exact key agreement, Bob sends
C = (cid:104)V(cid:105)2B to Alice which allows both parties to reconcile
the same shared key K. In this section we describe the rec-
onciliation mechanism that allows such exact agreement to
be achieved, i.e., we detail the function (cid:104)·(cid:105)2B used in line
6 of Bob’s ﬂow, and the functions (cid:98)·(cid:101)2B and rec used when
Alice and Bob compute their respective shared keys. Our
reconciliation mechanism is a generalized version of Peik-
ert’s mechanism [53] that, for every approximate agreement
in Zq, allows the extraction of more (exact) shared bits.
This increased extraction comes at the cost of an increased
probability of failed reconciliation, but we argue that the
resulting probability is still small enough for practical ap-
plication. Previous works that used Peikert’s mechanism
(e.g., [14, 6]) have not needed to extract more than one bit
per approximate agreement in Zq, since the number of such
agreements far exceeded the number of shared bits required
to form a secure session key. As we discussed in §3.1, we need
m · n · B ≥ 256 for our desired level of quantum security, so
a larger B (the number of bits extracted per approximate
agreement) means we can achieve smaller m and n, which
in turn means sending smaller LWE matrices.

We focus on the case when the modulus q is a power of
2; this can be generalized to an arbitrary modulus using
techniques described in [53]. Let the number B of bits that
we are aiming to extract from one coeﬃcient in Zq be such
that B < (log2 q) − 1. Let ¯B = (log2 q) − B. For any
v ∈ Zq, represented as a unique integer in [0, q), we deﬁne the
following functions. The rounding function (cid:98)·(cid:101)2B is deﬁned
as

(cid:98)·(cid:101)2B : v (cid:55)→(cid:106)

(cid:109)

− ¯Bv

2

mod 2B,

i.e., (cid:98)v(cid:101)2B ∈ [0, 2B). Note that (cid:98)·(cid:101)2B outputs the B most
signiﬁcant bits of (v + 2 ¯B−1) mod q. This means that (cid:98)·(cid:101)2B
partitions Zq into 2B intervals of integers with the same
B most signiﬁcant bits, up to a cyclic shift of the values
that centers these intervals around 0. The cross-rounding
function (cid:104)·(cid:105)2B is deﬁned as

(cid:104)·(cid:105)2B : v (cid:55)→(cid:106)

(cid:107)

− ¯B+1v

2

mod 2,

Figure I: The LWE-based key exchange protocol
with LWE parameters (n, q, χ), and protocol speciﬁc
parameters n, m, B ∈ Z. The matrix A ∈ Zn×n
is gener-
ated from seedA via a pseudo-random function Gen.

q

matrix X by sampling each of its entries independently from
S according to χ. If A is a probabilistic algorithm, y $← A(x)
denotes running A on input x with randomly chosen coins
and assigning the output to y.

The LWE problem is characterized by three parameters:
the modulus q, the dimension of the matrix n, and the error
distribution χ. Given an integer modulus q, denote by Zq
the ring of integers modulo q. The distribution χ is typically
taken to be a rounded continuous or discrete Gaussian dis-
tribution over Z with center zero and standard deviation σ.
However, as we discuss in detail in §3.3, alternative choices
are possible and have advantages over such distributions.
The concrete choice of the LWE parameters q, n, σ deter-
mines the security level of the protocol, and their selection
is described in §4.
3.1 The new key exchange protocol

q

q

In this section we describe an unauthenticated key ex-
change protocol based on the LWE problem. The protocol
is shown in Figure I .
In the key exchange protocol in Figure I, both Alice and
Bob generate the same large matrix A ∈ Zn×n
that is com-
bined with the LWE secrets to compute their public keys as
instances of the LWE problem. Alice’s n LWE instances and
Bob’s m LWE instances are combined to compute a secret
matrix in Zm×n
, where B uniform bits are extracted from
each entry to form the session key K. Thus, the dimensions
n and m should be chosen such that K has (at least) the
number of required bits for the target security level. For
example, in targeting 128 bits of post-quantum security, it
should be the case that n · m · B ≥ 256. This condition en-
sures that we obtain a uniform 256-bit secret for the session
key and even an exhaustive key search via Grover’s quantum
algorithm would take 2128 operations. The protocol in Fig-
ure I allows for the ratio between n and m to be changed, in
order to trade-oﬀ between Bob’s amount of uploaded data
for Alice’s computational load. This could be useful in mo-
bile devices, where energy eﬃciency of uploads is at most
half that of downstream traﬃc [62, 35].

1009which divides Zq into two subsets according to their (B +1)-
th most signiﬁcant bit, splitting up each interval above into
two equally sized subintervals. Replacing (cid:98)·(cid:101)2B by (cid:98)·(cid:99)2B
would amount to simply taking the B most signiﬁcant bits
of v. However, using (cid:98)·(cid:101)2B ensures that the size of the error
introduced by rounding is unbiased with respect to the sets
induced by the cross-rounding function.
We are now in a position to deﬁne the reconciliation func-
tion, rec, following [53]. On input of w ∈ Zq and b ∈ [0, 2B),
rec(w, b) outputs (cid:98)v(cid:101)2B , where v is the closest element to w
such that (cid:98)v(cid:101)2B = b. The two claims below are the general-
izations of the claims in [53], the proofs of which are analo-
gous. They demonstrate that releasing (cid:104)v(cid:105)2B does not reveal
any information about (cid:98)v(cid:101)2B , but it can serve as a hint for
the two parties that are trying to agree on B bits, based on
suﬃciently close numbers w and v. Claim 3.2 means that,
if corresponding elements of B(cid:48)S and V are within 2 ¯B−2 of
one another, the key agreement in Fig. I is exact.
Claim 3.1. If v ∈ Zq is uniformly random, then (cid:98)v(cid:101)2B is
uniformly random given (cid:104)v(cid:105)2B .
Claim 3.2. If |v − w| < 2 ¯B−2, then rec(w,(cid:104)v(cid:105)2B ) = (cid:98)v(cid:101)2B .

Round-and-truncate. We observe that the lower-order
bits of B and B(cid:48) exchanged by the parties have vanishingly
small inﬂuence on the negotiated key. To conserve band-
width, a version of the protocol could be used in which en-
tries of B and B(cid:48) are rounded to multiples of 2C , and the
lower C bits, which are now zeros, are truncated and never
transmitted. Since B and B(cid:48) are now transmitted with lower
accuracy, this introduces another source of error in the rec-
onciliation process. Although our implementation does not
currently exploit this option, we note that if it were to be
used, Bob should sample uniform noise and add it back to
the lower order bits. This is to ensure that truncation does
not aﬀect the proof of security.
3.3 Error distributions

The key exchange protocol in Figure I is described in
terms of an unspeciﬁed error distribution χ over a set S.
We now describe the concrete choice of error distribution
used in our implementation, which is an instantiation of in-
version sampling that uses a precomputed table correspond-
ing to a discrete cumulative density function (CDF) over a
small interval. The four distributions we use are deﬁned by
the discrete probability density functions (PDFs) in Table 1.
We use the ﬁrst distribution, D1, as an example to illustrate
how the sampling routine works. Modifying the correspond-
ing PDF into a CDF gives the table T = [43, 104, 124, 127].
We then sample 8 bits uniformly at random; the ﬁrst 7 bits
correspond to a uniform random integer y ∈ [0, 127] which
is used to return the smallest index ˜x ∈ [0, 3] such that
y ≤ T [˜x], and the last (eighth) bit is used to determine the
sign s ∈ {−1, 1} of the sampled value x = s · ˜x.

For each distribution in Table 1, performing inversion
sampling can be done eﬃciently using at most seven pre-
computed values of at most 16 bits each; thus, the precom-
puted look-up tables required for sampling any of the above
distributions are at most 14 bytes each. Obtaining a single
sample amounts to accessing an element from one of these
small look-up tables; this can be done in a memory and
timing sidechannel-resistant manner by always scanning all

dist. bits
req.

var.
(ς 2)

0

D1
D2
D3
D4

8
12
12
16

1

1.25

88
1570
1206

20
990 248
1
1.75
919 406 104 15
1.75 19304 14701 6490 1659 245

Probability of
±1 ±2 ±3 ±4 ±5 ±6 order
20.0
61
5.0

3
24

R´enyi

1
20

100.0
500.0

1

diverg.

1.002082
1.000024
1.000301
1.000028

Table 1: The discrete PDFs (and the number of bits
required to obtain one sample from them) for the
four noise distributions used in this work, which are
approximations to rounded continuous Gaussian dis-
tributions of the given variance ς 2; the closeness of
these approximations is speciﬁed by the given R´enyi
divergence and its order.

elements and performing comparisons with branchless arith-
metic operations.

The four distributions D1, D2, D3, D4, are the result of an
exhaustive search for combinations of discrete probabilities
that closely approximate the rounded continuous Gaussians
of the variances speciﬁed in Table 1. Here the measure of
“closeness” is the R´enyi divergence of the orders speciﬁed
in Table 1. We refer to [10] for more details on the R´enyi
divergence, but for our purposes it suﬃces to say that the
nearer the divergence is to 1, the tighter the security reduc-
tion is (when replacing the rounded Gaussian distribution
with our discrete approximation to it), which gives rise to
either higher (provable) security, or better parameters.

4. SECURITY ASSESSMENT AND PARAM-

ETER SELECTION

In this section, we explain our methodology to provide
conservative security estimates against both classical and
quantum attacks, and subsequently, we propose parameters
for the protocol in the previous section. The methodology
is similar to the one proposed in [6], with slight modiﬁca-
tions that take into account the fact that some quasi-linear
accelerations [59, 15] over sieving algorithms [12, 42] are not
available without the ring structure. We restate this analysis
for self-containment.

We remark that our methodology is signiﬁcantly more
conservative than what is usually used in the literature [5].
Our goal is not just to demonstrate feasibility, but to pro-
vide long-term and real-world security. To that end, we ac-
knowledge that lattice cryptanalysis is far less mature than
the cryptanalysis against schemes based on the hardness
of factoring and computing discrete logarithms, for which
the best-known attack can safely be considered as a best-
possible attack.
4.1 Methodology: the core-SVP hardness

Due to the (very) limited number m of LWE samples avail-
able to an attacker (m = n + m or m = n + n), we are not
concerned with BKW-like attacks [40], nor are we concerned
with linearization attacks [8]. This essentially leaves us with
two BKZ-style [21] attacks, which are usually referred to as
primal and dual attacks; we review both below.

The BKZ algorithm with block-size b requires up to poly-
nomially many calls to an SVP oracle in dimension b. How-
ever, using some heuristics essentially allows the number of
oracle calls to be decreased to a linear number [20]. To ac-
count for further improvement, we only count the cost of
one such call to the SVP oracle, i.e., the core-SVP hardness.

1010Such precaution seems reasonable, especially in the case of
the dual attack that involves running BKZ several times, in
which case it is plausible that most of the lattice reduction
cost may be amortized.

Even the concrete cost of a single SVP computation in di-
mension b is problematic to evaluate. This is due to the fact
that the numerically optimized pruned enumeration strategy
does not yield a closed formula [30, 21]. Even with pruning,
enumeration is asymptotically super-exponential, while siev-
ing algorithms have exponential complexity 2cb+o(b) (where
the constant c in the exponent is well-understood). A sound
and simple strategy is therefore to determine a lower bound
for the cost of an attack by 2cb vector operations (i.e., about
b2cb CPU cycles1), and to make sure that the block-size b
lies in a range where enumeration is more expensive than
2cb. From the estimate of [21], it is argued in [6] that this is
the case (both classically and quantumly) when b ≥ 200.

(cid:112)3/2 ≈
(cid:112)13/9 ≈ 0.265 (see §14.2.10 in [42]).

0.292, which is provided by the sieve algorithm of [12]; and,
in the context of quantum attacks, the best known con-
stant is cQ = log2
Since all variants of the sieving algorithm require a list of
= 20.2075b vectors to be built, it also seems plausi-
ble that cP = 0.2075 can serve as a worst-case lower bound.
(Here the subscripts C, Q and P diﬀerentiate between the
sieving constants used to obtain “classical”, “quantum” and
“paranoid” estimates on the concrete bit-security given by a
particular set of parameters.)
4.2 Primal attack

Classically, the best known constant is cC = log2

(cid:112)4/3

b

× Zm×1

The primal attack constructs a unique-SVP instance from
the LWE problem and solves it using BKZ. We examine how
large the block dimension b is required to be for BKZ to
ﬁnd the unique solution. Given the matrix LWE instance
(A, b = As + e) ∈ Zm×n
, one builds the lattice Λ =
{x ∈ Zm+n+1 : (A | Im | −b)x = 0 mod q} of dimension
d = m+n+1 and volume qm. The vector v = (s, e, 1) ∈ Λ is
√
a unique-SVP solution of norm λ ≈ ς
n + m, where ς is the
standard deviation of the error distribution used to sample
e.
In our case, the number of samples used, m, may be
chosen between 0 and n + m (or n + n), and we numerically
optimize this choice.

q

q

Using the typical models of BKZ (under the geometric
series assumption and the Gaussian heuristic [20, 5]), one
√
concludes that the primal attack is successful if and only if
b ≤ δ2b−d−1 · qm/d, where δ = ((πb)1/b · b/2πe)1/2(b−1).
ς
4.3 Dual attack

In the dual attack, one searches for a short vector (v, w)
in the dual lattice ˆΛ = {(x, y) ∈ Zm×Zn : Atx = y mod q},
with the aim of using it as a distinguisher for the decision-
LWE problem. The BKZ algorithm with block-size b will
output such a vector of length (cid:96) = δd−1qn/d.
Having found (x, y) ∈ ˆΛ of length (cid:96), an attacker computes
z = vt · b = vtAs + vte = wts + vte mod q. If (A, b) is
indeed an LWE sample, then z is distributed as a Gaussian,
centered around 0 and of standard deviation (cid:96)ς, otherwise z
is distributed uniformly modulo q. The maximal variation

1Due to the presence of the ring-structure, [6] chose to ignore this
factor b in order to aﬀord the adversary the advantage of assuming
that the techniques in [59, 15] can be adapted to more advanced
sieve algorithms [6]. However, for plain-LWE, we include this
factor.

distance between these two distributions is bounded by  ≈
4 exp(−2π2τ 2), where τ = (cid:96)ς/q: thus, given such a vector
of length (cid:96), the attacker may distinguish LWE samples from
random with advantage at most .

It is important to note that a small distinguishing advan-
tage  does not provide appreciable help to an adversary that
is attacking a key exchange protocol: since the agreed key is
to be used to derive a symmetric cipher key, any advantage
below 1/2 does not signiﬁcantly decrease the search space in
a brute force search for the symmetric cipher key. (Recall
that the reconciled key is processed with a random oracle
before it is used for any other purposes.)

We therefore require an attacker to amplify his success
probability by ﬁnding approximately 1/2 such short vec-
tors. Since the sieve algorithms provide 20.2075b vectors, the
attack must be repeated at least R = max(1, 1/(20.2075b2))
times. We again stress that we are erring on the conservative
side, since the other vectors that are output by the sieving
algorithm are typically a little larger than the shortest one.
4.4 Proposed parameters

Our proposed parameters are summarized in Table 2, and

their security detailed in Table 3.

Challenge parameters. We provide a set of challenge pa-
rameters as a target that should be reasonably accessible
within the current cryptanalytic state-of-the-art. Attacking
these parameters may even be feasible without subtle opti-
mizations such as pruned enumeration. We do not provide
hardness claims for those parameters because the required
BKZ block-size for breaking them is far below 200, and since
our analysis only considers sieving algorithms, it is not valid
in that range.

Classical parameters. We also propose a classical param-
eter set that provides 128-bits of security against classical
attacks. We do not recommend these parameters in practice
since they fail to achieve a high enough protection against
quantum attacks, but provide them to ease the comparison
with other proposals from the literature.

Recommended parameters. The last two parameter sets
are the ones we recommend if a scheme like the one described
in this paper is to be deployed in the real-world. The ﬁrst
(Recommended) set conservatively oﬀers 128 bits of secu-
rity against the best known quantum attack. The second
(Paranoid) set would resist an algorithm reaching the com-
plexity lower bound for sieving algorithms we mentioned in
§ 4.1, and could even remain quantum-secure if signiﬁcant
improvements towards solving SVP are achieved.

Failure rate estimation. Recall from Claim 3.2 that Alice
and Bob’s reconciliation of B bits (per approximate agree-
ment in Zq) will work with probability 1 if the distance be-
tween their two Zq elements is less than q/2B+2. On the
other hand, if this distance is greater than 3q/2B+2, the
reconciliation will work with probability 0, and the success
probability decreases linearly from 1 to 0 in the range be-
tween these two extremes. To determine the overall failure
rate of our protocol, we combine this relationship with the
probability distribution of the distance. In the continuous
case, it is easy to check that the distribution of this distance
has variance σ2 = 2nς 4 + ς 2, where ς 2 is the variance of
the continuous Gaussian distribution. However, using more
computationally-intensive but tighter analysis, we can com-
pute the distribution of the distance corresponding to our

1011Scheme

n

q

dist. B · m2 = B · n2

352 211 D1
Challenge
592 212 D2
Classical
Recommended 752 215 D3
864 215 D4
Paranoid

1 · 82 = 64
2 · 82 = 128
4 · 82 = 256
4 · 82 = 256

failure bandwidth
2−41.8
2−37.2
2−36.5
2−35.8

7.75 KB
14.22 KB
22.57 KB
25.93 KB

Table 2: Proposed parameter sets with dimension
n, modulus q, and noise distribution (which is an
approximation to the rounded Gaussian – see Ta-
ble 1), showing the size of the shared key in bits as
the product of the number B of bits agreed upon
per coeﬃcient and the number of coeﬃcients m · n,
the failure rate and the total size of key exchange
messages.

Scheme Attack

Rounded Gaussian

Challenge

Classical

Recomm.

Paranoid

Primal
Dual

Primal
Dual

Primal
Dual

Primal
Dual

m

335
341

549
544

737
718

825
785

b

301
297

442
438

532
528

630
626

C

–
–

138
136

164
163

193
192

Q

–
–

126
124

150
149

176
175

P

–
–

100
99

119
118

140
139

Post-reduction
C
P

Q

–
–

132
130

157
156

192
191

–
–

120
119

143
142

175
174

–
–

95
94

113
112

139
138

Table 3: Runtime for the best attacks on the pro-
posed parameter sets according to our analysis. The
rounded Gaussian columns capture security of the ideal,
rounded Gaussian noise distribution; the post-reduction
columns correspond to lower bound on security of the dis-
cretized distribution. The best classical attack takes 2C op-
erations, the best quantum attack 2Q, and 2P is the worst-
case lower bound runtime imposed by the list size in sieving
algorithms. Bold face numbers indicate the “security claim”
for the speciﬁc parameter set, e.g.
the Classical parame-
ter set provides 128 bits of classical security, whereas the
Recommended set has 128 bits of post-quantum security.

discrete approximation directly. The union bound gives an
upper bound on the total failure probability, which is sum-
marized for our chosen parameter sets in Table 2.

Numbers of samples and bits per coeﬃcient. We
opted to choose m = n, i.e., an equal division of band-
width to Alice and Bob. The new reconciliation mechanism
from §3.2 drives down both bandwidth and computation
costs by extracting more random bits from a single ring el-
ement. Compared to the previous reconciliation mechanism
of Peikert [53] that extracts a single bit per element, we
extract 4 bits per element (when using our Recommended
parameter set), which reduces the total amount of commu-
nication and computation by approximately a factor of 2.

5. PROOF OF SECURITY

The security of our key exchange protocol can be reduced
to the learning with errors problem. Our proof uses a variant
with short secrets and matrices (instead of vectors) that is
equivalent to the original LWE problem.
5.1 The LWE problem and variants

Deﬁnition 5.1 (Decision LWE problem). Let n and q be

positive integers. Let χ be a distribution over Z. Let s $←
U(Zn

q ). Deﬁne the following two oracles:
• Oχ,s: a $← U(Zn
• U : a $← U (Zn

q ), u $← U (Zq); return (a, u).

q ), e $← χ(Zq); return (a, as + e).

The decision LWE problem for (n, q, χ) is to distinguish Oχ,s
from U . In particular, for algorithm A, deﬁne the advantage
q : AOχ,s () = 1) − Pr(AU () = 1)|.
Advdlwe

n,q,χ(A) = |Pr(s $← Zn

The proof of security of our key exchange protocol relies
on a variant of the LWE problem stated below, where secrets
s are drawn from χ. It was shown by Applebaum et al. [7]
that the short secret variant has a tight reduction to the
decision LWE problem.

q

Matrix form. We use an extended form of the problem in
which the secrets and errors are also matrices. Let n, q, χ
be as above, let m and n be positive integers, and let S $←
χ(Zn×n

). Deﬁne

q

q

q

q

E).

); return (A, U).

); return (A, AS+

), E $← χ(Zm×n

), U $← U (Zm×n

• Oχ,S: A $← U (Zm×n
• U : A $← U (Zm×n
We call this the (m, n)-matrix decision LWE problem. A
standard hybrid argument shows that any adversary distin-
guishing these two distributions with advantage  can be
used to construct an eﬃcient adversary breaking the deci-
sion LWE problem with advantage at least /n. We can
similarly deﬁne a short secrets version.
5.2 Security of the key exchange protocol

To prove security of the key exchange protocol, consider
an LWE key-exchange adversary that tries to distinguish
the session key K from a uniformly random key K(cid:48) given
the transcript of the key exchange protocol. Formally, we
deﬁne the advantage of such an adversary A as:

n,n,m,B,q,χ(A) =(cid:12)(cid:12)Pr(cid:2)A(cid:0)A, B, B
−Pr(cid:2)A(cid:0)A, B, B

(cid:48)

(cid:48)

, C, K(cid:1) = 1(cid:3)

(cid:48)(cid:1) = 1(cid:3)(cid:12)(cid:12) ,

Advddh-like

, C, K

where A, B, B(cid:48), C, and K are as in Figure I, with LWE
parameters n, q, and χ, additional parameters n, m, B, and
K(cid:48) is a uniform bit string of length n · m · B.

The following theorem implies that under the decision
LWE assumption (with short secrets) for parameters n, q,
and α, eﬃcient adversaries have negligible advantage against
the key exchange protocol of §3.

Theorem 5.1. Let n, n, m, B, and q be positive inte-
gers, and let χ be a distribution on Zq. If Gen is a secure
pseudorandom function and the decision LWE problem is
hard for (n, q, χ), then the key exchange protocol in Figure I
yields keys indistinguishable from random. More precisely,
n,q,χ(A◦B1) + m·
n,n,m,B,q,χ(A) ≤ Advprf
Advddh-like
n,q,χ(A ◦ B2) where B1 and B2 are the reduction algo-
Advdlwe
rithms given in Figure III, and B0 is implicit in the proof.
The runtimes of B0, A ◦ B1, and A ◦ B2 are essentially the
same as that of A.

Gen(B0) + n· Advdlwe

Proof. The proof closely follows Peikert’s proof of IND-CPA
security of the R-LWE KEM; see Lemma 4.1 of [53], and Bos
et al.’s proof of R-LWE DH key exchange [14]. It proceeds
by the sequence of games shown in Figure II. Let Si be the
event that the adversary guesses the bit b∗ in Game i.

1012Game 0:

Game 1:

q

q

q

)

)

1: A $← U (Zn×n
)
2: S, E $← χ(Zn×n
3: B ← AS + E
4: S(cid:48), E(cid:48) $← χ(Zm×n
5: B(cid:48) ← S(cid:48)A + E(cid:48)
6: E(cid:48)(cid:48) $← χ(Zm×n
)
7: V ← S(cid:48)B + E(cid:48)(cid:48)
8: C ← (cid:104)V(cid:105)2B
9: K ← (cid:98)V(cid:101)2B
10: K(cid:48) $← U ({0, 1}n·m·B )
11: b∗ $← U ({0, 1})
12: if b∗ = 0

q

13: else

return (A, B, B(cid:48), C, K)
return (A, B, B(cid:48), C, K(cid:48))

q

q

q

)

)

1: A $← U (Zn×n
)
2: B $← U (Zn×n
3: S(cid:48), E(cid:48) $← χ(Zm×n
4: B(cid:48) ← S(cid:48)A + E(cid:48)
5: E(cid:48)(cid:48) $← χ(Zm×n
)
6: V ← S(cid:48)B + E(cid:48)(cid:48)
7: C ← (cid:104)V(cid:105)2B
8: K ← (cid:98)V(cid:101)2B
9: K(cid:48) $← U ({0, 1}n·m·B )
10: b∗ $← U ({0, 1})
11: if b∗ = 0

q

12: else

return (A, B, B(cid:48), C, K)
return (A, B, B(cid:48), C, K(cid:48))

Game 2:
1: A $← U (Zn×n
2: B $← U (Zn×n
)
3: S(cid:48) $← χ(Zm×n

q

q

)

q

)

4: (cid:2)E(cid:48)(cid:107)E(cid:48)(cid:48)(cid:3) $← χ(Zm×(n+n)
5: (cid:2)B(cid:48)(cid:107)V(cid:3) ← S(cid:48)(cid:2)A(cid:107)B(cid:3) +(cid:2)E(cid:48)(cid:107)E(cid:48)(cid:48)(cid:3)

)

q

6: C ← (cid:104)V(cid:105)2B
7: K ← (cid:98)V(cid:101)2B
8: K(cid:48) $← U ({0, 1}n·m·B )
9: b∗ $← U ({0, 1})
10: if b∗ = 0

11: else

return (A, B, B(cid:48), C, K)
return (A, B, B(cid:48), C, K(cid:48))

Game 3:

q

)

1: A $← U (Zn×n
2: B $← U (Zn×n

3: (cid:2)B(cid:48)(cid:107)V(cid:3) $← U (Zm×(n+n)

)

q

q

)

4: C ← (cid:104)V(cid:105)2B
5: K ← (cid:98)V(cid:101)2B
6: K(cid:48) $← U ({0, 1}n·m·B )
7: b∗ $← U ({0, 1})
8: if b∗ = 0

return (A, B, B(cid:48), C, K)
return (A, B, B(cid:48), C, K(cid:48))

9: else

Figure II: Sequence of games for proof of Theorem 5.1.

B1(A, B):

q

q

)

1: S(cid:48), E(cid:48) $← χ(Zm×n
2: B(cid:48) ← S(cid:48)A + E(cid:48)
3: E(cid:48)(cid:48) $← χ(Zm×n
)
4: V ← S(cid:48)B + E(cid:48)(cid:48)
5: C ← (cid:104)V(cid:105)2B
6: K ← (cid:98)V(cid:101)2B
7: K(cid:48) $← U ({0, 1}n·m·B )
8: b∗ $← U ({0, 1})
9: if b∗ = 0

10: else

return (A, B, B(cid:48), C, K)
return (A, B, B(cid:48), C, K(cid:48))

B2(Y, Z):

(cid:21)
(cid:20)A(cid:62)
(cid:20)B(cid:48)(cid:62)
(cid:21)

B(cid:62)

1:

← Y

V(cid:62)

← Z
2:
3: C ← (cid:104)V(cid:105)2B
4: K ← (cid:98)V(cid:101)2B
5: K(cid:48) $← U ({0, 1}n·m·B )
6: b∗ $← U ({0, 1})
7: if b∗ = 0

return (A, B, B(cid:48), C, K)
return (A, B, B(cid:48), C, K(cid:48))

8: else

Figure III: Reductions for proof of Theorem 5.1.

Game 0. This is the original game, where the messages
are generated honestly as in Figure I. We want to bound
Pr(S0). Note that in Game 0, the LWE pairs are: (A, B)
with secret S; and (A, B(cid:48)) and (B, V) both with secret S(cid:48).
Hence, Advddh-like

n,n,m,B,q,χ(A) = |Pr(S0) − 1/2|.

Game 1. In this game, the public matrix A is generated
uniformly at random, rather than being generated pseudo-
randomly from seedA using Gen.

Diﬀerence between Game 0 and Game 1. An ad-
versary that can distinguish these two games immediately
leads to a distinguisher B0 for Gen:
|Pr(S0) − Pr(S1)| ≤
Advprf

Gen(B0).
Game 2.
In this game, Alice’s ephemeral public key B
is generated uniformly at random, rather than being gen-
erated from a sampler for the (n, n)-matrix decision LWE
problem. Note that in Game 2, the (remaining) LWE pairs
are: (A, B(cid:48)) and (B, V) both with secret S(cid:48).

q

q

) × U (Zn×n

Diﬀerence between Game 1 and Game 2. In Game
1, (A, B) is a sample from Oχ,S. In Game 2, (A, B) is a
sample from U(Zn×n
). Under the decision LWE
assumption for (n, q, χ), these two distributions are indistin-
guishable with a factor of n.
More explicitly, let B1 be the algorithm shown in Fig-
ure III which takes as input a pair (A, B). When (A, B) is
a sample from Oχ,S where S $← χ(Zn×n
), then the output
of B1 is distributed exactly as in Game 1. When (A, B) is a

q

q

) × U (Zn×n

sample from U(Zn×n
), then the output of B1 is
distributed exactly as in Game 2. Thus, if A can distinguish
Game 1 from Game 2, then A ◦ B1 can distinguish samples
from Oχ,S from samples from U(Zn×n
). Thus,
|Pr(S1) − Pr(S2)| ≤ n · Advdlwe-ss

n,q,χ (A ◦ B1).

) × U(Zn×n

q

q

q

Game 3. Game 3 is a simple rewrite of Game 2. Bob’s
ephemeral public key B(cid:48) and shared secret V are simultane-
ously generated from S(cid:48) rather than sequentially. In Game
with secret S(cid:48)(cid:62) is an
3, the single LWE pair

(cid:18)(cid:20)A(cid:62)

(cid:20)B(cid:48)(cid:62)

(cid:21)(cid:19)

(cid:21)

,

B(cid:62)

V(cid:62)

instance of the (n + n, m)-matrix decision LWE problem.

Diﬀerence between Game 2 and Game 3. Since Game
3 is just a conceptual rewrite of Game 2, we have that
Pr(S2) = Pr(S3).

q

q

) × U(Z(n+n)×m

Game 4.
In Game 4, there are no LWE pairs. Bob’s
ephemeral public key B(cid:48) and shared secret V are generated
uniformly at random, rather than simultaneously from S(cid:48).

Diﬀerence between Game 3 and Game 4. In Game 3,

(cid:0)(cid:2)A(cid:107)B(cid:3) ,(cid:2)B(cid:48)(cid:107)V(cid:3)(cid:1) is (the transpose of) a sample from ora-
In Game 4, (cid:0)(cid:2)A(cid:107)B(cid:3) ,(cid:2)B(cid:48)(cid:107)V(cid:3)(cid:1) is (the transpose of) a sam-

cle Oχ,S(cid:48) in the ((n + n), m)-matrix decision LWE problem.
ple from U(Z(n+n)×n
). Under the decision
LWE assumption for (n, q, χ), these two distributions are
indistinguishable with a factor of m.
More explicitly, let B2 be the algorithm shown in Fig-
ure III that takes as input (Y, Z) ∈ Z(n+n)×n
. When
(Y, Z) is a sample from Oχ,S(cid:48)(cid:62) in the (n + n, m)-matrix de-
cision LWE problem, where S(cid:48) $← χ(Zn×m
), then the output
of B2 is distributed exactly as in Game 3. When (Y, Z) is
a sample from U(Z(n+n)×n
), the output of B2 is
distributed exactly as in Game 4. If A can distinguish Game
3 from Game 4, then A ◦ B2 can distinguish samples from
Oχ,S(cid:48) from samples from U(Z(n+n)×n
). Thus,
|Pr(S3) − Pr(S4)| ≤ m · Advddh-like

n,q,χ (A ◦ B2).

) × U (Zn×m

) × U (Zn×m

×Zn×m

q

q

q

q

q

q

q

Analysis of Game 4. In Game 4, the adversary is asked
to guess b∗ and thereby distinguish between K and K(cid:48). In
Game 4, K(cid:48) is clearly generated uniformly at random from
{0, 1}n·m·B. K is generated from rounding V, and V is
uniform, so K is too. The adversary is also given C, but by
Claim 3.1 we have that, for uniform V, K = (cid:98)V(cid:101)2B remains

1013uniform even given C = (cid:104)V(cid:105)2B . Thus, the adversary has no
information about b∗, and hence Pr(S4) = 1/2.
5.3 Security when used in TLS

The accepted model for security of secure channel proto-
cols such as TLS is Jager et al.’s authenticated and conﬁ-
dential channel establishment (ACCE) model [36]. Bos et
al. [14] show that a TLS ciphersuite that uses signatures for
authentication and a key exchange mechanism that satis-
ﬁes the ddh-like security property (§5.2) achieves the ACCE
security notion. Since our Theorem 5.1 shows that the LWE-
based protocol has ddh-like-security, we immediately (mod-
ulo a small change of notation) inherit ACCE security of
the resulting signed-DH-like ciphersuite using LWE key ex-
change. Bos et al. note that their result requires that a
change be made in the TLS protocol: the server’s signature
must be moved later in the handshake and must include
the full transcript. This is to be able to rely on a plain
decisional assumption, rather than an “oracle” assumption
(PRF-ODH) that was required in Jager et al.’s proof; we
inherit this requirement as well.

Alternatively, one could leave the signature in place and
use an IND-CCCA-secure key encapsulation mechanism fol-
lowing Krawczyk et al. [41], constructed via standard con-
structions such as [29], albeit at the expense of increasing
the number of bits transmitted.

6.

IMPLEMENTATION

In this section we discuss two aspects of our implementa-
tion: representing matrix elements and generating the public
matrix A. Matrix operations in our implementation use the
straightforward approach, i.e., the product of an n × m ma-
trix and an m × p matrix incurs nmp multiplications and
O(nmp) additions. We make this choice because our matrix
dimensions are not large enough for the asymptotically faster
methods [61, 23] to oﬀer a worthwhile trade-oﬀ (see [25]).

Representing matrix elements. All parameter sets in
Table 2 have q = 2x < 216. To facilitate an eﬃcient imple-
mentation, we use a redundant representation: matrix en-
216 = Z/(216−xq)Z
tries are represented as elements from Z
instead of Zq. This has the advantage that, when elements
are stored in 16-bit datatypes, all arithmetic is performed
modulo 216 for free (implicitly). Converting from this re-
dundant representation to elements in Zq is as simple as
ignoring the 16 − x most signiﬁcant bits, which amounts to
a single bitwise AND instruction.
The exchanged matrices B, B(cid:48), and C are packed down to
their optimal representation. The computational overhead
due to packing and unpacking is outweighed by savings in
communication complexity.
Generating the matrix A. The matrix A ∈ Zn×n
is a
public parameter used by both parties in the key exchange.
It could be taken as a ﬁxed system parameter, saving this
communication eﬀort between parties. This approach was
taken in [14] in the ring setting, where the polynomial a was
ﬁxed system wide. However, as discussed in Section 3 of [6],
such a choice raises questions about possible backdoors and
all-for-the-price-of-one attacks. Therefore, the scheme in [6]
generates a fresh polynomial a from a uniformly random
seed for every instantiation of the key exchange.

q

Here we adopt a similar approach and propose that the
server choose a fresh seed for every new key exchange in-

stance, and that A be generated pseudorandomly from this
seed. The seed is sent to the client in the ServerKeyExchange
message (see Figure I) and allows the client to pseudoran-
domly generate the same A. The matrix A is generated from
a 16-byte seed using AES128 in the ECB mode. Substitut-
ing a randomly sampled matrix with the one derived in this
manner can be justiﬁed by appealing to the random oracle
heuristic; exploring its applicability in our context against a
quantum adversary is an interesting open question.

Depending on the architecture, particularly for memory-
constrained embedded devices, storing the matrix A in its
entirety and loading it into memory for matrix multiplica-
tion might be too costly. In such scenarios, we propose to
generate, use and discard parts of the matrix A on-the-ﬂy.

To facilitate on-the-ﬂy matrix generation by both the client
and the server, we pursue the following approach. The ma-
trix A is derived by applying AES128-ECB to pre-ﬁlled ma-
trix rows with guaranteed uniqueness.2 The matrix thus
deﬁned can be computed either by rows, one row at a time,
or by columns, 8 columns at a time, depending on whether
A is multiplied by S on the right (client-side) or on the left
(server-side). The cost of this pseudorandom generation can
be a signiﬁcant burden and can be amortized by relaxing the
requirement for a fresh A in every new key exchange (e.g.,
by allowing A to be cached on the server for a limited time).

7. EVALUATION

We evaluate the performance of LWE-based key exchange
on the following characteristics: 1) speed of standalone cryp-
tographic operations; 2) speed of HTTPS connections; 3)
communication costs. Our LWE implementation is written
in C and the implementation is as described in §6. In this
section, we report the results of our implementation of LWE-
based key exchange and compare our results with several
other post-quantum primitives.

publicly available implementations:

We selected the following post-quantum algorithms with
• BCNS R-LWE key exchange, C implementation [14];
• NewHope R-LWE key exchange, C implementation [6];
• NTRU public key encryption key transport using pa-
• SIDH (supersingular isogeny Diﬃe–Hellman) key ex-

rameter set EES743EP1, C implementation [63]; and

change, C implementation [24].

The implementation of Bernstein et al.’s “McBits” high-speed
code-based cryptosystem [13] was not publicly available at
the time of writing. We also included OpenSSL’s implemen-
tation of ECDH (on the nistp256 curve) and RSA with a
3072-bit modulus for comparisons against widely deployed
non-post-quantum key exchange at the 128-bit classical se-
curity level. The compiler is gcc version 4.8.4 and software
is compiled for the x86_64 architecture.

We integrated our C implementation of our LWE proto-
col, as well as all the other implementations, into OpenSSL
v1.0.1f following Stebila’s OpenSSL v1.0.1f fork for the R-
LWE experiments in [14], to allow for comparison of all algo-
rithms in the same context and to facilitate the HTTPS per-
formance evaluation.3 Our implementation includes a com-

2Our implementation uses the AES-NI instruction set where sup-
ported.
3While §5.3 notes that moving the server’s signature to later in
the handshake is required to achieve provable security of the full
LWE-based ciphersuite under the decision LWE assumption, our

1014mon API for post-quantum key exchange methods, making
it easier to add and compare new candidates as they become
available. Finally, our implementation and evaluation uses
AES256 GCM authenticated encryption and SHA384 to en-
sure post-quantum security for symmetric key operations.

We use a common hardware platform for all measure-
ments. Standalone cryptographic operations were measured
on the same computer, which acted as the server for mea-
suring speed of TLS connections. This is an n1-standard-4
Google Cloud VM instance4 with 15 GB of memory, which
has 4 virtual CPUs; in our instance, each of these was imple-
mented as a single hardware hyper-thread on a 2.6GHz Intel
Xeon E5 (Sandy Bridge). Clients for measuring the through-
put of TLS connections were run on an n1-standard-32
Google Cloud VM instance with 120 GB of memory and 32
virtual CPUs, which ensured that we could fully load the
server. Although some implementations included optimiza-
tions using the AVX2 instruction set, the cloud servers we
used did not support AVX2; while vectorization of matrix
operations using AVX2 will improve performance, our re-
sults may be more indicative of performance on widespread
non-AVX2 hardware.
7.1 Standalone cryptographic operations

Table 4 reports the performance of standalone post-quan-
tum cryptographic operations, as well as standard crypto-
graphic operations for comparison. We obtained these re-
sults by integrating their implementations into OpenSSL
as discussed above, and in particular using the openssl
speed command. In the table, Alice0 denotes Alice’s initial
ephemeral key and message generation (e.g., Alice’s opera-
tions up to and including her message transmission in Fig-
ure I); Bob denotes Bob’s full execution, including ephemeral
key and message generation and key derivation (all of Bob’s
operations in Figure I); and Alice1 denotes Alice’s ﬁnal
key derivation (e.g., Alice’s operations upon receiving Bob’s
message in Figure I).

Discussion. Microbenchmarks of LWE-based key exchange
are very promising when compared with other protocols. At
approximately 1.3ms for each party, the runtime of Frodo
is orders of magnitude faster than SIDH, faster than NTRU
(on the server side), about 1.8× slower than ECDH nistp256,
and about 9× slower than R-LWE (NewHope). While there
is a large gap between the microbenchmark performance of
LWE against R-LWE, we recall that LWE has the increased
conﬁdence of using generic rather than ideal lattices, and we
will observe in the next section that this gap is signiﬁcantly
narrowed when measured in an application that uses TLS.
Additionally, we observe that the runtime of our paranoid
parameters requires a slight (between 14% and 19%) over-
head in bandwidth and compute in return for much higher
security.

Our modiﬁcations to openssl speed allowed us to bench-
mark the impact of freshly generating the matrix A for each

prototype implementation does not make this complex change
in OpenSSL as the purpose of our implementation is to measure
performance, which would be the same regardless of where the sig-
nature is in the handshake. This would be required for deployed
implementations to match the security theorem; fortunately cur-
rent TLS 1.3 drafts include this change, so eventually TLS 1.3
implementations will provide this.
4https://cloud.google.com/compute/docs/machine-types#
standard machine types

connection versus using a precomputed A. For our rec-
ommended parameters, the time to generate A was 0.54ms
± 0.01, which is 42% of Alice’s total runtime (similarly for
Bob). This is substantial, and means that optimization of
this step is valuable (see §6 for more details); our original
naive implementation was several times slower. This also
highlights the beneﬁt that could come from caching A: a
busy TLS server might reuse the same A for an hour or a
day while still limiting the risk of global all-for-the-price-of-
one attacks.

Embedded system. We also performed micro-benchmarks
on the low-cost, community-supported BeagleBone Black
development platform which has a AM335x 1GHz ARM
Cortex-A8. We measured the standalone functionality using
the GNU/Linux perf infrastructure with gcc version 4.6.3;
measurements are averages over thousands of runs. For the
Frodo recommended parameters, Alice0 takes 77.5M cycles;
Bob takes 80.22M cycles; and Alice1 takes 1.09M cycles.
7.2 HTTPS connections

Table 5 reports the performance of a TLS-protected web
server using the various key exchange mechanisms, follow-
ing the methodology of Gupta et al. [33] that was used by
Bos et al. [14]. The methodology reports performance with
HTTP payloads of 4 diﬀerent sizes (1 byte, 1 KiB, 10 KiB,
and 100 KiB), to demonstrate the diminishing importance of
key exchange performance on TLS performance as payload
size increases in realistic workloads. For each key exchange
primitive, we measured performance using RSA signatures
(with 3072-bit keys) and ECDSA signatures (with nistp256
keys): as noted in the introduction, future quantum adver-
saries would be able to retroactively decipher information
protected by a non-quantum-safe key exchange, but not be
able to retroactively impersonate parties authenticated us-
ing non-quantum-safe digital signatures.
(We omit TLS-
level benchmarks of Frodo-Paranoid since its microbench-
marks are similar to Frodo-Recommended, and similarly
omit SIDH since its performance is on the order of a handful
of connections per second.)

For the server, we used Apache httpd version 2.4.20, com-
piled against our customized OpenSSL library above, and
using the prefork module for multi-threading. The client
and server were connected over the standard data center
network with a ping time of 0.62ms ± 0.02ms which did not
achieve saturation during any of our experiments.

Connections/second (throughput). Multiple client con-
nections were generated by using the http_load tool5 ver-
sion 09Mar2016, which is a multi-threaded tool that can gen-
erate multiple http or https fetches in parallel. We found
that we could sometimes achieve better performance by run-
ning multiple http_load processes with fewer threads in each
process. As we increase loads beyond the point at which we
report throughput, there is very little increase in connec-
tions/sec but a signiﬁcantly larger increase in mean connec-
tion time. At this point, we posit that the bottleneck in
serving TLS requests shifts to the Apache process schedul-
ing and request buﬀer management rather than ciphersuite
performance. Our client machine had suﬃcient power to en-
sure our server computer reached at least 90% CPU usage
throughout the test. Results reported are the mean of ﬁve
executions, each of which was run for thirty seconds.

5http://www.acme.com/software/http load/

1015Scheme

RSA 3072-bit
ECDH nistp256

BCNS
NewHope
NTRU EES743EP1
SIDH

Alice0

(ms)

Bob
(ms)

Alice1

(ms)

—

0.366 ± 0.006
1.01 ± 0.006
0.112 ± 0.003
2.00 ± 0.055
135 ± 1.91
1.13 ± 0.09
1.25 ± 0.02

0.09 ± 0.004
0.698 ± 0.014
1.59 ± 0.007
0.164 ± 0.001
0.281 ± 0.047
464 ± 6.74
1.34 ± 0.02
1.64 ± 0.03

4.49 ± 0.005
0.331 ± 0.01
0.174 ± 0.001
0.034 ± 0.001
0.148 ± 0.005
301 ± 0.97
0.13 ± 0.01
0.15 ± 0.01

Communication (bytes)
A→B
387 / 0∗

B→A
384
32

32

4,096
1,824
1,027
564

4,224
2,048
1,022
564

Claimed security

classical quantum

128
128

163
229
256
192

—
—

76
206
128
128

Frodo Recomm.
Frodo Paranoid
Table 4: Performance of standalone cryptographic operations, showing mean runtime (± standard deviation)
in milliseconds of standalone cryptographic operations, communication sizes (public key / messages) in bytes,
and claimed security level in bits. ∗In TLS, the RSA public key is already included in the server’s certiﬁcate message,
so RSA key transport imposes no additional communication from server to client.

11,377
13,057

11,296
12,976

156
191

142
174

Connections/second

Connection time (ms) Handshake

1B
1187 ± 61
814 ± 3.5

1 KiB
1107 ± 103
810 ± 5.2

10 KiB 100 KiB
961 ± 68
710 ± 12

1088 ± 103
790 ± 5.9

Ciphersuite

Key exchange

Sig.

ECDHE

BCNS

NewHope

NTRU

ECDSA
RSA

ECDSA
RSA

ECDSA
RSA

ECDSA
RSA

922 ± 89
722 ± 4.2
1616 ± 166
983 ± 61
725 ± 3.4
553 ± 20

907 ± 83
710 ± 9.7
1413 ± 39
970 ± 67
723 ± 8.8
534 ± 7.3

892 ± 59
700 ± 6.2

893 ± 16
716 ± 2.7
1351 ± 148
949 ± 36
708 ± 17
548 ± 1.4

819 ± 83
638 ± 3.7
985 ± 77
771 ± 41
612 ± 31
512 ± 4.9

Frodo Recomm.

ECDSA 923 ± 49
703 ± 4.2
RSA

878 ± 70
698 ± 1.8

843 ± 68
635 ± 16

18.3 ± 0.5
20.7 ± 0.6

Hybrid ciphersuites

BCNS+ECDHE

NewHope+ECDHE

NTRU+ECDHE

Frodo+ECDHE

ECDSA
RSA

ECDSA
RSA

ECDSA
RSA

ECDSA
RSA

736 ± 19
567 ± 1.7
1095 ± 54
776 ± 1.4
590 ± 1.0
468 ± 0.3

735 ± 12
552 ± 0.5

735 ± 3.8
567 ± 1.0
1075 ± 58
775 ± 3.7
589 ± 1.0
467 ± 0.4

716 ± 1.5
551 ± 1.9

728 ± 6.4
559 ± 2.4
1017 ± 16
765 ± 2.4
578 ± 3.2
456 ± 3.6

701 ± 20
544 ± 1.6

664 ± 7.3
503 ± 3.2
776 ± 1.4
686 ± 8.6
539 ± 5.4
424 ± 24

667 ± 7
516 ± 1.8

23.1 ± 0.28
24.6 ± 0.09
16.5 ± 0.79
18.13 ± 0.85
22.5 ± 0.2
24.2 ± 0.21

22.9 ± 0.5
24.5 ± 0.3

w/o load
14.2 ± 0.25
16.1 ± 0.89

18.8 ± 0.48
20.5 ± 0.51
12.1 ± 0.12
13.1 ± 1.5
20.0 ± 0.96
19.9 ± 0.91

w/load

size (B)

22.2
24.7

35.8
36.9

18.6
20.0

27.2
29.6

31.5
32.7

37.7
40.2

25.2
28.0

34.3
36.8

36.4
39.9

1,264
1,845

9,455
9,964

5,005
5,514

3,181
3,691

23,725
24,228

9,595
10,177

5,151
5,731

3,328
3,908

23,859
24,439

Table 5: Performance of Apache HTTP server using post-quantum key exchange, measured in connections
per second, connection time in milliseconds, and handshake size in bytes. Connection time under load is reported
as the 75th percentile value across 20 measurements. Values measured across experiments were within 2× the reported value.
All TLS ciphersuites used AES256-GCM authenticated encryption with SHA384 in the MAC and KDF. Note that diﬀerent key
exchange methods are at diﬀerent security levels; see Table 4 for details.

Connection time and handshake size. Wireshark was
used to measure the time for the client to establish a TLS
connection on an otherwise unloaded server, measured from
when the client opens the TCP connection to when the client
starts to receive the ﬁrst packet of application data, and the
size in bytes of the TLS handshake as observed. Connections
were initiated using the openssl s_client command.

We considered two scenarios in this measurement. In sce-
nario 1, client-server connections were initiated when the
server was under no load. The results reported under the

column “w/o load” in Table 5 were the average of ten execu-
tions. In scenario 2, client-server connections were initiated
when the server was under approximately 70% CPU load
(also due to concurrent TLS connections). Connection time
naturally had a larger variance under load and we report
the 75th percentile results over twenty experiments under
the column “w/load” in Table 5.

Discussion. Due to HTTPS loads imposing stress on many
diﬀerent parts of the system, slower compute time of LWE
compared to R-LWE (NewHope) has a much lower impact

1016on overall performance. This is especially true when con-
sidering hybrid ciphersuites. Our results are not necessarily
generalizable to all applications, but do provide a good indi-
cation of how TLS-based applications with a variety of load
proﬁles are aﬀected.

Since establishing a TLS connection involves several round
trips as well as other cryptographic operations, the connec-
tion times (for a server without load) for all ciphersuites we
tested all range between 12ms and 21ms, which are an or-
der of magnitude smaller than the load times of typical web
pages, so perceived client load times will be minimally im-
pacted in many applications. Even under reasonable load,
the increase in connection times for LWE follows similar in-
creases across the diﬀerent ciphersuites proﬁled.

Our key exchange does aﬀect server throughput, but the
gap between LWE and R-LWE is smaller and (naturally)
decreases as page size increases. For 1 KiB pages, LWE can
support 1.6× fewer connections than R-LWE (NewHope),
but this gap narrows to 1.2× fewer for 100 KiB pages, and
outperforms NTRU. When measuring server throughput with
hybrid ciphersuites, the overhead of LWE is further reduced
to just about 15% for 100 KiB pages when compared to
NewHope.

While LWE does have an impact on both TLS client and
server performance and on the handshake size, the complex
nature of TLS connections and various system bottlenecks
when serving webpages mute the perceived gap seen between
LWE and R-LWE in the microbenchmarks. For many appli-
cations, such as web browsing and secure data transfers, the
LWE latency and communication size are small compared
to typical application proﬁles.

Going forward, if we choose to deploy a post-quantum
ciphersuite that combines LWE and ECDHE instead of a
(non-post-quantum) ECDHE ciphersuite, the additional over-
head in serving typical webpages between 10 KiB and 100 KiB
will only decrease server throughput by less than a factor of
two. This might be a small price to pay for long-term post-
quantum security based on generic lattices without any ring
structure, in order to avoid the possibility of attacks that
this structure gives rise to.

Acknowledgments
JB and LD were supported in part by the Commission of the
European Communities through the Horizon 2020 program
under project number 645622 (PQCRYPTO). DS was sup-
ported in part by Australian Research Council (ARC) Dis-
covery Project grant DP130104304 and a Natural Sciences
and Engineering Research Council of Canada (NSERC) Dis-
covery Grant. The authors would like to thank Adam Lan-
gley, Eric Grosse, and ´Ulfar Erlingsson for their inputs. A
large part of this work was done when VN was an intern
with the Google Security and Privacy Research team.

8. REFERENCES
[1] D. Adrian, K. Bhargavan, Z. Durumeric, P. Gaudry,

M. Green, J. A. Halderman, N. Heninger, D. Springall,
E. Thom´e, L. Valenta, B. VanderSloot, E. Wustrow, S. Z.
B´eguelin, and P. Zimmermann. Imperfect forward secrecy:
How Diﬃe-Hellman fails in practice. ACM CCS 2015,
pages 5–17.

[2] S. Agrawal, D. Boneh, and X. Boyen. Eﬃcient lattice

(H)IBE in the standard model. In EUROCRYPT 2010,
volume 6110 of LNCS, pages 553–572.

[3] S. Agrawal, D. Boneh, and X. Boyen. Lattice basis

delegation in ﬁxed dimension and shorter-ciphertext
hierarchical IBE. In CRYPTO 2010, volume 6223 of LNCS,
pages 98–115.

[4] M. Ajtai. Generating hard instances of lattice problems.

Quaderni di Matematica, 13:1–32, 2004. Preliminary
version in ACM STOC 1996.

[5] M. R. Albrecht, R. Player, and S. Scott. On the concrete

hardness of learning with errors. J. Mathematical
Cryptology, 9(3):169–203, 2015.

[6] E. Alkim, L. Ducas, T. P¨oppelmann, and P. Schwabe.

Post-quantum key exchange — a new hope. In USENIX
Security 2016.

[7] B. Applebaum, D. Cash, C. Peikert, and A. Sahai. Fast
cryptographic primitives and circular-secure encryption
based on hard learning problems. In CRYPTO 2009,
volume 5677 of LNCS, pages 595–618.

[8] S. Arora and R. Ge. New algorithms for learning in

presence of errors. In ICALP 2011, Part I, volume 6755 of
LNCS, pages 403–415.

[9] D. Augot, L. Batina, D. J. Bernstein, J. W. Bos,

J. Buchmann, W. Castryck, O. Dunkelman, T. G¨uneysu,
S. Gueron, A. H¨ulsing, T. Lange, M. S. E. Mohamed,
C. Rechberger, P. Schwabe, N. Sendrier, F. Vercauteren,
and B.-Y. Yang. Initial recommendations of long-term
secure post-quantum systems, 2015.
http://pqcrypto.eu.org/docs/initial-recommendations.pdf.

[10] S. Bai, A. Langlois, T. Lepoint, D. Stehl´e, and R. Steinfeld.

Improved security proofs in lattice-based cryptography:
Using the R´enyi divergence rather than the statistical
distance. In ASIACRYPT 2015, Part I, volume 9452 of
LNCS, pages 3–24.

[11] E. Barker, W. Barker, W. Burr, W. Polk, and M. Smid.
Recommendation for key management – part 1: General
(rev 3), 2012. Available at
http://csrc.nist.gov/publications/nistpubs/800-57/
sp800-57 part1 rev3 general.pdf.

[12] A. Becker, L. Ducas, N. Gama, and T. Laarhoven. New

directions in nearest neighbor searching with applications
to lattice sieving. In ACM-SIAM SODA 2016, pages 10–24.

[13] D. J. Bernstein, T. Chou, and P. Schwabe. McBits: Fast
constant-time code-based cryptography. In CHES 2013,
volume 8086 of LNCS, pages 250–272.

[14] J. W. Bos, C. Costello, M. Naehrig, and D. Stebila.

Post-quantum key exchange for the TLS protocol from the
ring learning with errors problem. In IEEE Symposium on
Security and Privacy 2015, pages 553–570.

[15] J. W. Bos, M. Naehrig, and J. van de Pol. Sieving for

shortest vectors in ideal lattices: a practical perspective.
International Journal of Applied Cryptography, 2016.

[16] Z. Brakerski, A. Langlois, C. Peikert, O. Regev, and

D. Stehl´e. Classical hardness of learning with errors. In
ACM STOC 2013, pages 575–584.

[17] Z. Brakerski and V. Vaikuntanathan. Eﬃcient fully

homomorphic encryption from (standard) LWE. SIAM J.
Comput., 43(2):831–871, 2014.

[18] D. Cash, D. Hofheinz, E. Kiltz, and C. Peikert. Bonsai
trees, or how to delegate a lattice basis. J. Cryptology,
25(4):601–639, Oct. 2012.

[19] L. Chen, S. Jordan, Y.-K. Liu, D. Moody, R. Peralta,

R. Perlner, and D. Smith-Tone. Report on post-quantum
cryptography. NISTIR 8105, DRAFT, 2016.
http://csrc.nist.gov/publications/drafts/nistir-8105/nistir
8105 draft.pdf.

[20] Y. Chen. Lattice reduction and concrete security of fully
homomorphic encryption. PhD thesis, l’Universit´e Paris
Diderot, 2013. Available at
http://www.di.ens.fr/˜ychen/research/these.pdf.

[21] Y. Chen and P. Q. Nguyen. BKZ 2.0: Better lattice

security estimates. In ASIACRYPT 2011, volume 7073 of
LNCS, pages 1–20.

1017[22] D. Coppersmith. Finding a small root of a univariate

modular equation. In EUROCRYPT’96, volume 1070 of
LNCS, pages 155–165.

[43] T. Laarhoven. Sieving for shortest vectors in lattices using
angular locality-sensitive hashing. In CRYPTO 2015, Part
I, volume 9215 of LNCS, pages 3–22.

[23] D. Coppersmith and S. Winograd. Matrix multiplication

[44] R. Lindner and C. Peikert. Better key sizes (and attacks)

via arithmetic progressions. In ACM STOC’87, pages 1–6.
[24] C. Costello, P. Longa, and M. Naehrig. Eﬃcient algorithms

for supersingular isogeny Diﬃe-Hellman. In CRYPTO,
volume 9814 of LNCS, pages 572–601.

[25] P. D’Alberto and A. Nicolau. Adaptive Strassen and
ATLAS’s DGEMM: a fast square-matrix multiply for
modern high-performance systems. In IEEE
High-Performance Computing in Asia-Paciﬁc Region 2005,
pages 45–52.

[26] M. H. Devoret and R. J. Schoelkopf. Superconducting
circuits for quantum information: an outlook. Science,
339(6124):1169–1174, 2013.

for LWE-based encryption. In CT-RSA 2011, volume 6558
of LNCS, pages 319–339.

[45] V. Lyubashevsky, C. Peikert, and O. Regev. On ideal
lattices and learning with errors over rings. J. ACM,
60(6):43:1–35, Nov. 2013. Preliminary version in Eurocrypt
2010.

[46] A. Menezes, S. A. Vanstone, and T. Okamoto. Reducing
elliptic curve logarithms to logarithms in a ﬁnite ﬁeld. In
ACM STOC’91, pages 80–89.

[47] D. Micciancio and C. Peikert. Hardness of SIS and LWE

with small parameters. In CRYPTO 2013, Part I, volume
8042 of LNCS, pages 21–39.

[27] W. Diﬃe, P. C. Van Oorschot, and M. J. Wiener.

[48] M. Mosca. Cybersecurity in an era with quantum

Authentication and authenticated key exchanges. Designs,
Codes and cryptography, 2(2):107–125, 1992.

computers: will we be ready? Cryptology ePrint Archive,
Report 2015/1075, 2015. http://eprint.iacr.org/2015/1075.

[28] G. Frey and H.-G. R¨uck. A remark concerning

m-divisibility and the discrete logarithm in the divisor class
group of curves. Math. Comp., 62(206):865–874, 1994.

[49] National Security Agency (NSA). Cryptography today.

https://www.nsa.gov/ia/programs/suiteb cryptography/,
August 2015.

[29] E. Fujisaki and T. Okamoto. Secure integration of
asymmetric and symmetric encryption schemes. In
CRYPTO’99, volume 1666 of LNCS, pages 537–554.

[30] N. Gama, P. Q. Nguyen, and O. Regev. Lattice

enumeration using extreme pruning. In
EUROCRYPT 2010, volume 6110 of LNCS, pages 257–278.

[31] C. Gentry, C. Peikert, and V. Vaikuntanathan. Trapdoors
for hard lattices and new cryptographic constructions. In
ACM STOC 2008, pages 197–206.

[32] L. K. Grover. A fast quantum mechanical algorithm for

database search. In ACM STOC’96, pages 212–219.

[33] V. Gupta, D. Stebila, S. Fung, S. C. Shantz, N. Gura, and

H. Eberle. Speeding up secure web transactions using
elliptic curve cryptography. In NDSS 2004.

[34] J. Hoﬀstein, J. Pipher, and J. H. Silverman. NTRU: A

ring-based public key cryptosystem. In ANTS’98, volume
1423 of LNCS, pages 267–288.

[35] J. Huang, F. Qian, A. Gerber, Z. M. Mao, S. Sen, and

O. Spatscheck. A close examination of performance and
power characteristics of 4G LTE networks. In The 10th
International Conference on Mobile Systems, Applications,
and Services, MobiSys’12, pages 225–238, 2012.

[36] T. Jager, F. Kohlar, S. Sch¨age, and J. Schwenk. On the

security of TLS-DHE in the standard model. In
CRYPTO 2012, volume 7417 of LNCS, pages 273–293.

[37] X. L. Jintai Ding, Xiang Xie. A simple provably secure key

exchange scheme based on the learning with errors
problem. Cryptology ePrint Archive, Report 2012/688,
2012. http://eprint.iacr.org/2012/688.

[38] A. Kawachi, K. Tanaka, and K. Xagawa. Multi-bit

cryptosystems based on lattice problems. In PKC 2007,
volume 4450 of LNCS, pages 315–329.

[39] J. Kelly, R. Barends, A. G. Fowler, A. Megrant, E. Jeﬀrey,
T. C. White, D. Sank, J. Y. Mutus, B. Campbell, Y. Chen,
Z. Chen, B. Chiaro, A. Dunsworth, I.-C. Hoi, C. Neill,
P. J. J. O’Malley, C. Quintana, P. Roushan, A. Vainsencher,
J. Wenner, A. N. Cleland, and J. M. Martinis. State
preservation by repetitive error detection in a
superconducting quantum circuit. Nature, 519:66–69, 2015.

[40] P. Kirchner and P.-A. Fouque. An improved BKW

algorithm for LWE with applications to cryptography and
lattices. In CRYPTO 2015, Part I, volume 9215 of LNCS,
pages 43–62.

[41] H. Krawczyk, K. G. Paterson, and H. Wee. On the security

of the TLS protocol: A systematic analysis. In
CRYPTO 2013, Part I, volume 8042 of LNCS, pages
429–448.

[42] T. Laarhoven. Search problems in cryptography. PhD

thesis, Eindhoven University of Technology, 2015.

[50] NIST. http://www.nist.gov/itl/csd/ct/

post-quantum-crypto-workshop-2015.cfm.

[51] NIST Suite B. https://www.nsa.gov/ia/programs/suiteb

cryptography/index.shtml.

[52] C. Peikert. Public-key cryptosystems from the worst-case

shortest vector problem. In ACM STOC 2009, pages
333–342.

[53] C. Peikert. Lattice cryptography for the Internet. In

PQCrypto 2014, volume 8772 of LNCS, pages 197–219.

[54] C. Peikert. A decade of lattice cryptography. Foundations

and Trends in Theoretical Computer Science,
10(4):283–424, 2016.

[55] C. Peikert. How (not) to instantiate Ring-LWE. Cryptology

ePrint Archive, Report 2016/351, 2016.
http://eprint.iacr.org/2016/351.

[56] J. Proos and C. Zalka. Shor’s discrete logarithm quantum

algorithm for elliptic curves. Quantum Info. Comput.,
3(4):317–344, 2003.

[57] O. Regev. On lattices, learning with errors, random linear

codes, and cryptography. In ACM STOC 2005, pages
84–93.

[58] O. Regev. On lattices, learning with errors, random linear

codes, and cryptography. J. ACM, 56(6):34, 2009.

[59] M. Schneider. Sieving for shortest vectors in ideal lattices.

In AFRICACRYPT 13, volume 7918 of LNCS, pages
375–391.

[60] P. Shor. Polynomial-time algorithms for prime factorization

and discrete logarithms on a quantum computer. SIAM J.
Comput., 26(5):1484–1509, 1997. Preliminary version in
STOC 1994.

[61] V. Strassen. Gaussian elimination is not optimal.

Numerische Mathematik, 13(4):354–356, 1969.

[62] N. Thiagarajan, G. Aggarwal, A. Nicoara, D. Boneh, and

J. P. Singh. Who killed my battery: Analyzing mobile
browser energy consumption. In ACM WWW 2012, pages
41–50.

[63] W. Whyte, M. Etzel, and P. Jenney. Open source NTRU

public key cryptography algorithm and reference code.
https://github.com/NTRUOpenSourceProject/ntru-crypto,
2013.

[64] J. Zhang, Z. Zhang, J. Ding, M. Snook, and ¨O. Dagdelen.

Authenticated key exchange from ideal lattices. In
EUROCRYPT 2015, Part II, volume 9057 of LNCS, pages
719–751.

1018