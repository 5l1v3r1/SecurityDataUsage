Fully Secure and Fast Signing from Obfuscation

Kim Ramchen

University of Texas at Austin
kramchen@cs.utexas.edu

Brent Waters

University of Texas at Austin
bwaters@cs.utexas.edu

ABSTRACT
In this work we explore new techniques for building short
signatures from obfuscation. Our goals are twofold. First,
we would like to achieve short signatures with adaptive se-
curity proofs. Second, we would like to build signatures with
fast signing, ideally signiﬁcantly faster than comparable sig-
natures that are not based on obfuscation. The goal here
is to create an “imbalanced” scheme where signing is fast at
the expense of slower veriﬁcation.

We develop new methods for achieving short and fully
secure obfuscation-derived signatures. Our base signature
scheme is built from punctured programming and makes a
novel use of the “preﬁx technique” to guess a signature. We
ﬁnd that our initial scheme has slower performance than
comparable algorithms (e.g. EC-DSA). We ﬁnd that the
underlying reason is that the underlying PRG is called ≈ (cid:96)2
times for security parameter (cid:96).

To address this issue we construct a more eﬃcient scheme
by adapting the Goldreich-Goldwasser-Micali [16] construc-
tion to form the basis for a new puncturable PRF. This
puncturable PRF accepts variable-length inputs and has the
property that evaluations on all preﬁxes of a message can be
eﬃciently pipelined. Calls to the puncturable PRF by the
signing algorithm therefore make fewer invocations of the
underlying PRG, resulting in reduced signing costs.

We evaluate our puncturable PRF based signature schemes
using a variety of cryptographic candidates for the underly-
ing PRG. We show that the resulting performance on mes-
sage signing is competitive with that of widely deployed sig-
nature schemes.

Categories and Subject Descriptors
E.3 [Data Encryption]: Public key cryptosystems

General Terms
Security, Design, Theory

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’14, November 3–7, 2014, Scottsdale, Arizona, USA.
Copyright 2014 ACM 978-1-4503-2957-6/14/11 ...$15.00.
http://dx.doi.org/10.1145/2660267.2660306 .

Keywords
punctured programming; obfuscation; adaptive security; dig-
ital signature scheme
1.

INTRODUCTION

Obfuscation deals with the problem of how to protect
a program from reverse engineering while preserving func-
tionality. Traditionally constructing secure obfuscation in a
mathematically sound way has been a very challenging prob-
lem. While there have been numerous ad hoc approaches to
obfuscation, in practice these have nearly all broken, point-
ing to the need for a cryptographically grounded solution.
This state of aﬀairs changed dramatically with the introduc-
tion of candidate indistinguishability obfuscation by Garg,
Gentry, Halevi, Raykova, Sahai and Waters [12].

Recently, starting with [26] there has been much interest
in investigating what can be built from indistinguishability
obfuscation, since this model leads to poly-time obfuscation
of unrestricted program classes, circumventing the known
impossibility results of [1]. Roughly, this body of work can
be divided into two classes. The ﬁrst seeks to discover new
applications that were not achievable prior to introduction of
secure obfuscation. The second seeks to re-explore the con-
struction of existing cryptographic primitives, but through
the lens of obfuscation.

The latter direction is important for several reasons. First,
re-exploration leads to qualitatively diﬀerent ways of ap-
proaching cryptographic problems. For example, the Sahai-
Waters [26] public key scheme was obtained by application of
obfuscation to symmetric key encryption, thereby matching
Diﬃe and Hellman’s original vision that public key encryp-
tion be obtainable by scrambling a private key enciphering
program [9]. Moreover the techniques that were used to
build cryptographic primitives for which there were already
candidates, led to new and unexpected results. For example
the technique of “punctured programming”, which was used
to construct public key encryption in turn, led to the ﬁrst
construction of deniable encryption. Second, such schemes
have unique and interesting properties in their own right.
For example, decryption in the SW public key cryptosystem
involves only a symmetric key operations and is therefore
quite fast. Likewise the signing algorithm from their signa-
ture scheme is also fast due to only applying symmetric key
primitives.

This work.

In this paper we explore building new signature systems
from obfuscation. Our goals are twofold. First, we would

659like to achieve short signatures with adaptive security proofs
(matching the GMR deﬁnition [17]).

Second, we would like to build signatures with fast signing—

ideally signiﬁcantly faster than comparable signatures that
are not based on obfuscation. The goal here is to create an
“imbalanced” scheme where signing is fast at the expense
of slower veriﬁcation. Such imbalance could be useful in
applications where signing must be done by low power de-
vices such as sensors, while veriﬁcation can be done by well
equipped machines. We note that employing imbalanced
schemes has a long history. For example, an earlier feature
of low-exponent RSA [21] (e.g. e = 3) was that veriﬁca-
tion was very fast. In addition, recent work on delegation of
computation (e.g., [14, 23, 13, 18, 25] ) works on a similar
principle of saving resources of a weaker client.

Although current obfuscation candidates will admit pro-
hibitively slow veriﬁcation, the work of obfuscation is in its
nascent stages and it is plausible that systems with rea-
sonable performance will be realized in the not too distant
future. This future seems even more possible if one con-
siders that obfuscation candidates might be designed and
optimized for implementing particular functionalities.

We begin by overviewing the techniques of the SW signa-
ture system [26] which builds signatures from puncturable
pseudorandom functions (PRFs). We brieﬂy recall that a
puncturable PRF is a type of constrained pseudo random
function [3, 4, 20] where a key K{x∗} can be given out
that allows one to evaluate the (keyed) function FK (·) at
all inputs x except when x = x∗. In this scheme the Setup
algorithm chooses a puncturable PRF key at random. A
message is signed by evaluating the puncturable PRF on it.
The veriﬁcation key is an indistinguishability obfuscation
that on input a message and signature pair, veriﬁes that the
signature is the correct output of the PRF on the message.
One signiﬁcant limitation of this scheme is that it only sat-
isﬁes unforgettability against a selective attacker.
In this
notion of security, the attack algorithm is forced to select
the message M∗ it will attempt to forge on at the beginning
of the security game, before seeing the veriﬁcation key and
before he gets to query for signatures on other messages.

We are therefore interested in designing signature systems
to accommodate stronger attacks on security - in particular
the standard notion of security where the attacker can adap-
tively choose which message it will forge on. To construct a
signature scheme satisfying this notion of security, we em-
ploy the preﬁx-guessing technique of Hohenberger-Waters
[19]. Here the signature scheme challenger uses the list of
pre-committed message queries to guess the shortest diﬀer-
ing preﬁx between these messages and the forgery. This pre-
ﬁx is used to embed a challenge in the veriﬁcation key, which
a successful forger must answer with noticeable probability.
We note that this “preﬁx technique” has been successfully
employed in other contexts [6, 5, 11, 24, 8, 2, 27].

The Hohenberger-Waters technique provides a method to
build a scheme against an attacker that adaptively chooses
the forged message, but where the signature queries must
be declared before seeing the veriﬁcation key. In [19] they
transform this notion into a fully adaptive secure scheme
by using the well-known technique of applying a chameleon
hash [22] to the message before running the base signature
scheme. Here we wish to avoid this transformation ﬁrstly to
meet the goal of constructing fully secure signatures using
purely obfuscation-based techniques and secondly to keep

signing costs low compared to deployed signature schemes
such as EC-DSA, necessitates avoiding discrete-log based
systems.

To achieve adaptive security from the preﬁx-embedded
scheme, we do something akin1 to publishing a signature tag
t and building a one-time signature using the tag t as the
verifcation key for the message. This part of the signature is
secure provided that no tag t is ever re-used more than once.
We can then sign the tag with the preﬁx-guessing scheme,
generating a second signature part. The structure of our sig-
nature scheme is such that we can xor these parts together,
with a suitable modiﬁcation to the veriﬁcaion circuit.

Our construction in a nutshell.

We now describe the main two pieces of our construction.
Firstly we construct a one-time like signature scheme as fol-
lows. We generate a tag t of λ bits. Our ﬁrst “signature
piece” is s1 = ⊕l
i=1F1(K1, t(cid:107)i(cid:107)M (i)), where F1(K1,·) is a
puncturable PRF with appropriate input length. Our veriﬁ-
cation key is an obfuscated circuit that on input (M, (t, s1))
checks that s1 is of the above form. The security property is
that an adversary on seeing a signature for a message M that
uses tag t, cannot construct a signature on M∗ (cid:54)= M , that
uses the same tag t. To argue security, we use a Lamport-
like proof. If M∗ (cid:54)= M then there exists some index ˆi where
M∗(ˆi) (cid:54)= M (ˆi). Let bit ˆb = M∗(ˆi). The reduction algo-
rithm can guess the position ˆi and bit ˆb = M∗(ˆi) with no-
ticeable probability. The reduction ﬁrst punctures K1 on
τ = t(cid:107)ˆi(cid:107)ˆb. Then it evaluates an injective one way function
evaluated on the punctured value F1(K1, τ ), yielding an im-
age z. This image is embedded inside the veriﬁcation key,
VK, and is used to test validity of message M∗, while the
punctured key can still be used to verify all other messages.
VK is sent to the adversary. Now suppose an adversary pro-
duces a valid forgery (t, s∗
1). The reduction can extract the
1 ⊕i(cid:54)=ˆi F1(K1{τ}, t(cid:107)i(cid:107)M∗(i)), yielding
punctured value as s∗
a pre-image of z. This breaks the security guarantee of the
one way function.

Our second piece is the ability to sign the tag t accord-
ing to the [19] preﬁx-guessing technique. To sign a tag t,
a puncturable PRF F2,i(K2,i,·) is evaluated on every pre-
ﬁx. Here F2,i for i = 1, . . . , (cid:96) takes in inputs of i bits. The
signature piece is thus s2 = ⊕λ
i=1F2,i(K2,i, t(i)), where the
length-i preﬁx of t is denoted t(i). A veriﬁcation key is an
obfuscated circuit that on input (t, s2), checks that s2 is of
the above form. The security property is as follows. The
attacker commits to a list of tags (tj)q
j=1. The challenger
sends veriﬁcation key VK, as well as signatures (σj)q
j=1 cor-
responding to the above tags. The attacker should not be
able to construct a signature on a tag t∗ not contained in the
queried list. We argue security as follows. Since t∗ is distinct
from all queried tags, there exists some tag tj(cid:48) and index i(cid:48)
such that t∗ and tj(cid:48) agree on the ﬁrst i(cid:48) − 1 bits, diﬀering
at the i(cid:48)th bit. The reduction algorithm guesses the tag tj(cid:48)
and index i(cid:48). The reduction punctures K2,i(cid:48) on the diﬀering
preﬁx p and generates an equivalent veriﬁcation circuit, us-
ing an injective one way function is to hide the punctured

1Our construction uses the primitive a little diﬀerently. In
a standard one-time signature scheme, anyone can generate
a veriﬁcation key and sign with the corresponding private
key. In our scheme some secret information is needed even
to sign with tag t.

660value F2,i(cid:48) (K2,i(cid:48) , p). This image is embedded inside the ver-
iﬁcation key, VK, which is sent to the adversary. Suppose
the adversary now submits a valid forgery s∗
2. The reduc-
2 ⊕i(cid:54)=i(cid:48) F2,i(K2,i, t(i)),
tion extracts the punctured value as s∗
again breaking the one way function.

Our complete scheme merges these two ideas to gener-
ate concise signatures. The signatures s1 and s2 are xor-
ed together yielding a single signature s. The complete
signature is thus (t, s). The veriﬁcation circuit on input
(M, (t, s)) computes s1 = ⊕l
i=1F1(K1, t(cid:107)i(cid:107)M (i)) and s2 =
⊕λ
i=1F2,i(K2,i, t(i)) and checks that s = s1 ⊕ s2.
In the
proof of security, the reduction will deal with the case that
a forgery tag t is repeated, or not, separately.

Fast Signing.

While the scheme above achieves our goal of getting short
signatures that are fully secure, it does not meet our goal of
getting fast signing. The primarily culprit is that in the gen-
eration of the second signature piece, (cid:96) diﬀerent punctured
PRF systems must be evaluated leading to a O((cid:96)2) calls to
the underlying psuedorandom generator when using current
constructions based on GGM [16] trees.

We address this problem by giving a slightly modiﬁed sec-
ond construction. The primary change is that instead of us-
ing (cid:96) diﬀerent punctured PRF systems, each with a diﬀerent
domain size, we will use one punctured PRF with a variable
length domain {0, 1}1≤i≤(cid:96). That is the input to the function
can be a string of any length up to (cid:96). We can then plug this
into our main construction.

At ﬁrst glance it might seem that this modiﬁcation brings
us nothing since the construction still needs to XOR together
(cid:96) diﬀerent PRF values. However, as we will show that it is
possible to create a variable length punctured PRF where
the cost of evaluating the PRF on all preﬁxes of an (cid:96) bit
message M is the same as computing the GGM tree once on
M . The main modiﬁcation is that, following Goldreich [15],
we now need a length tripling PRG G : {0, 1}λ → {0, 1}3·λ
that goes from λ bits to 3· λ bits. In practice, this will likely
consume more computation per pseudo random generator
invocation call more than using a length doubling one, but
in total should result in signiﬁcantly faster signatures than
the prior approach.

Evaluation.

We evaluate the cost of the selectively secure Sahai-Waters
scheme and our adaptively secure scheme in terms of the cost
of the underlying PRGs used by the puncturable PRFs. We
compute concrete signing costs at the 128-bit security level
using a several cryptographic hash functions and ciphers to
instantiate the PRGs. These costs are compared to the RSA
and EC-DSA signature schemes at the same security level.
For appropriate choices of the underlying PRG, our adap-
tively secure construction is signiﬁcantly faster than EC-
DSA. For example, at the 128-bit level, the EC-DSA algo-
rithm takes 348 microseconds. When the ChaCha stream
cipher is used to instantiate the PRGs, the selectively se-
cure Sahai-Waters scheme takes 25 microseconds and the
adaptively secure scheme takes 81 microseconds. Timings
were performed on a quad-core Intel Xeon E3-1270 v2 work-
station with 16Gb RAM, clocked @3.50GHz.

2. SIGNATURE SCHEME PRELIMINARIES

A signature scheme is a tuple of PPT algorithms:

Setup(1λ) The setup algorithm outputs a pair (VK, SK)
where VK is the veriﬁcation key and SK is the secret key.
Sign(SK, M ) The signing algorithm takes in secret key SK
and message M ∈ M and outputs a signature σ.
Verify(VK, M, σ) The veriﬁcation algorithm takes in a ver-
iﬁcation key VK, a message M and a claimed signature σ.
The algorithm returns 1 if the signature is valid and ⊥
otherwise.

Correctness. ∀M ∈ M
Pr[Verify(VK, M, Sign(SK, M )) = 1 : (VK, SK) ← Setup(1λ)]
= 1 − negl(λ)
In what follows will assume M is an l-bit message space.
2.1 Unforgeability against Adaptive Attacks
We extend the above notion of a secure signature scheme
to accommodate adaptive attacks, according to the formal-
ization by Goldwasser, Micali and Rivest [17]. Here an at-
tacker may adaptively make an arbitrary (polynomial) num-
ber of signature queries on messages, even after it has re-
ceived the veriﬁcation key. The attacker must then output
a message on which it did not receive a signature, and a
valid signature corresponding to that message.

Setup The challenger runs the algorithm Setup(1λ) to ob-
tain (VK, SK). The challenger sends VK to the adversary.
Queries Proceeding adaptively, the adversary requests a
signature on any message M ∈ M and the challenger re-
sponds with σ ← Sign(SK, M ). Let Q be the set of mes-
sages queried by the adversary.
Output Eventually the adversary outputs a pair (M∗, σ∗)
and is said to win the game if M (cid:54)∈ Q and Verify(VK, M∗, σ∗)
= 1.
We deﬁne Adveuf-cma

to be the probability that adversary

A wins in the above game.

A,Π

Definition 1. A signature scheme Π = (Setup, Sign, Verify)

is existentially unforgeable with respect to adaptive chosen
message attacks if for all PPT algorithms A

Adveuf-cma

A,Π ≤ negl(λ)

3. OBFUSCATION PRELIMINARIES

Definition 2

(Indistinguishability Obfuscation).
A uniform PPT machine iO is called an indistinguishabil-
ity obfuscator for a circuit class {Cλ}λ∈N if it satisﬁes the
following conditions:

• Functionality preserving For all security parame-
ters λ ∈ N, for all C ∈ Cλ, for all inputs x, we have
that C(cid:48)(x) = C(x) where C(cid:48) ← iO(λ, C).
• Indistinguishability of obfuscation For any not
necessarily uniform PPT distinguisher (Samp, D), there
exists a negligible function negl(·) such that the follow-
ing holds: if for all security parameters λ ∈ N

Pr[∀x, C0(x) = C1(x) : (C0; C1; τ ) ← Samp(1λ)]
> 1 − negl(λ),

661then
| Pr[D(τ, iO(λ, C0)) = 1 : (C0; C1; τ ) ← Samp(1λ)]−
Pr[D(τ, iO(λ, C1)) = 1 : (C0; C1; τ ) ← Samp(1λ)]|
≤ negl(λ).

3.1 Puncturable PRFs
A pseudorandom function (PRF) is a function F : K ×
M → Y such that the function F (K,·) is indistinguishable
from random when K $← K.

A constrained PRF [3] is a PRF F (K,·) with the function-
ality to enable evaluation of the PRF at certain portions of
the input space and nowhere else. A puncturable PRF [3, 26]
is a type of contrained PRF that enables evaluation at the
complement of a single arbitrary polynomial-sized subset of
the input space. That is, PRF F (K,·) is equipped with ad-
ditional PPT algorithms (EvalF , PunctureF ) such that the
following properties hold

• Functionality preserved under puncturing For
every PPT algorithm A which on input 1λ outputs a
set S ⊆ {0, 1}n, for all x ∈ {0, 1}n\S, we have
Pr[EvalF (K{S}, x) = F (K, x) : K $← K,
K{S} ← PunctureF (K, S)] = 1

• Pseudorandom at punctured points For every pair
of PPT algorithms (A1,A2) and polynomial m(λ) such
that A1(1λ) outputs a set S ⊆ {0, 1}n of cardinality
m(λ) and a state σ it holds that

| Pr[A2(σ, K{S}, F (K, S)) = 1 : (S, σ) ← A1(1λ),
K{S} ← PunctureF (K, S)]
− Pr[A2(σ, K{S}, Y ) = 1 : (S, σ) ← A1(1λ),
K{S} ← PunctureF (K, S), Y $← {0, 1}m·|S|
]|
≤ negl(λ)

For notational convenience we will denote the output of
PunctureF (K, S) by K{S}, with the former occasionally sup-
pressed.

4. OUR ADAPTIVELY SECURE SIGNATURE

SCHEME

In this section we describe our adaptively secure signa-
ture scheme. Our signature scheme consists of two main
pieces. Our ﬁrst piece is a one-time like signature scheme.
We generate a tag t of λ bits. The security property is
that an adversary on seeing a signature for a message M
that uses tag t, cannot construct a signature on M∗ (cid:54)= M ,
that uses the same tag t. Our signature piece is s1 =
⊕l
i=1F1(K1, t(cid:107)i(cid:107)M (i)), where F1(K1,·) is a puncturable PRF
with appropriate input length. Our veriﬁcation key is an
obfuscated circuit that on input (M, (t, s1)) checks that s1
is of the correct form. To argue security, the simulator
guesses the position ˆi where M∗(ˆi) (cid:54)= M (ˆi) and the bit
ˆb = M∗(ˆi). The simulator punctures K1 on τ = t(cid:107)ˆi(cid:107)ˆb,
and generates an equivalent one-time veriﬁcation circuit us-
ing the punctured key, making use of an (injective) one-
way function to hide the punctured value. Now suppose an
adversary produces a valid forgery (t, s∗
1). Then the sim-
ulator can extract the punctured value as s∗
1 xor-ed with

{F1(K1{τ}, t(cid:107)i(cid:107)M∗(i)) : i (cid:54)= ˆi}. This can be shown to break
the security of the one-way function.

Our second piece is the ability to sign the tag t according
to the [19] preﬁx-guessing technique. The security prop-
erty is as follows. The attacker commits to a list of tags
(tj)q
j=1. The challenger sends veriﬁcation key VK, as well
as signatures (σj)q
j=1 corresponding to the above tags. The
attacker should not be able to construct a signature on a tag
t∗ not contained in the queried list. Let F2,i for i = 1, . . . , (cid:96)
be puncturable PRFs taking in inputs of i bits. The sec-
ond signature piece is s2 = ⊕λ
i=1F2,i(K2,i, t(i)), where the
length-i preﬁx of t is denoted t(i). A veriﬁcation key is an
obfuscated circuit that on input (t, s2), checks that s2 is of
the above form. To argue security, the simulator guesses the
tag tj(cid:48) and position i(cid:48) such that t∗ and tj(cid:48) have common
preﬁx of length i(cid:48) − 1. The simulator punctures K2,i(cid:48) on
diﬀering preﬁx p and generates an equivalent verﬁcation cir-
cuit using the punctured key, the one way function is used to
hide the punctured value. Suppose the adversary now sub-
mits a valid forgery s∗
2. Then the simulator can extract the
2 xor-ed with {F2,i(K2,i, t(i)) : i (cid:54)= i(cid:48)},
punctured value as s∗
again breaking the one-way function.

To combines these pieces, the signatures s1 and s2 are
xor-ed together. A signature is simply (t, s). The verﬁcation
circuit on input (M, (t, s)) computes s1 and s2 as above and
checks that s = s1⊕s2. In the proof of security, the simulator
will deal with the case that a forgery tag t is repeated, or not,
separately. In the former case, the simulator will extract a
punctured value as s∗⊕s∗
2⊕i(cid:54)=ˆi F1(K1{τ}, t(cid:107)i(cid:107)M∗(i)), where
s∗
2 is computed using non-punctured PRF key K2. In the
case of the no repeat, the simulator will extract a punctured
value as s∗ ⊕ s∗
1 is computed
using non-punctured PRF key K1. To complete the proof
of security, the simulator guesses ahead of time which case
it will have to deal with it, reducing its success probability
by at most one half, hence remaining non-negligible. Our
complete scheme follows.

1 ⊕i(cid:54)=i(cid:48) F2,i(K2,i, t(i)), where s∗

4.1 The Scheme

The message space of the signature scheme is {0, 1}l. For
l-bit message M , let M (i) denote the i-th bit of M . For λ-bit
string t, let t(i) denote the ﬁrst i bits of t. Let F1(K1,·) be
a puncturable PRF mapping lt-bit inputs to λ-bit outputs.
Here lt = λ + (cid:100)lg l(cid:101) + 1. Let F2,i(K2,i,·) be a puncturable
PRF mapping i-bit inputs to λ-bit outputs, for each i ∈
[1, λ]. Let f be an injective one way function mapping λ-bit
inputs to w-bit outputs. Our signature scheme is as follows.

Setup(1λ) : Pick puncturable PRF keys K1

$← K2,i : i ∈ [1, λ]. The secret key is (K1, (K2,i)λ

$← K1 and
K2,i
i=1).
Let the veriﬁcation key VK be an indistinguishability ob-
fuscation of the program SigCheck deﬁned below.

Sign(SK, M ) : Choose t $← {0, 1}λ. Let s1 = ⊕l
t(cid:107)i(cid:107)M (i)). Let s2 = ⊕λ
s1 ⊕ s2. Output σ = (t, s).

i=1F1(K1,
i=1F2,i(K2,i, t(i)). Compute s =

Verify(VK, M, σ) : Output VK(M, σ).

662SigCheck :
Inputs : M, σ
Constants : PRF keys K1 and (K2,i)λ
(t, s) ← σ
s1 ← ⊕l
s2 ← ⊕λ
if s = s1 ⊕ s2 then output 1 else output ⊥

i=1F1(K1, t(cid:107)i(cid:107)M (i))
i=1F2,i(K2,i, t(i))

i=1

Theorem 1. The above signature scheme is existentially
unforgeable with respect to chosen message attacks as speci-
ﬁed in Deﬁnition 1, assuming the existence of secure indis-
tinguishability obfuscators and secure puncturable PRFs.

Proof. Suppose that A is a PPT adversary that outputs
a valid forgery (M∗, σ∗) with non-negligible probability .
We will construct an adversary B that inverts the one way
function f with non-neligible probability. We may split the
forgery submitted by A into two cases. Let σ∗ = (t∗, s∗).
The ﬁrst case is that t∗ = tj for some signature σj returned
by the challenger in response to the jth message query Mj ∈
Q. The other case is that t∗ (cid:54)= tj for all signatures σj
returned by the challenger on Mj ∈ Q, where j ranges from
1 to n. We will call the ﬁrst case a type I forgery and the
second case, where t∗ (cid:54)= tj for all tj, a type II forgery. We
prove that in both cases, there exists PPT B which uses A
to invert f . In practice simulator B guesses ahead of time
which type of forgery A will make and errs with probability
at most one half. In what follows we will let |Q| = n. Also
deﬁne ei = 0i−11.

Lemma 1. Suppose that adversary A in the adaptive se-
curity game makes a type I forgery with probability I . Then
we can construct B that inverts the one way function f with
probability I /(2nl) − negl(λ).

Proof. To prove this lemma, we deﬁne the following se-

quence of hybrids.

Game 1. This is the original security game in which the at-
tacker receives the veriﬁcation key, and then queries for sig-
natures on messages adaptively. Let Q be the set of queried
In the ﬁnal step an attacker outputs (M∗, σ∗).
messages.
Here σ∗ = (t∗, s∗) and t∗ = tj for some signature σj on
Mj ∈ Q.

$← {0, 1}λ for all j ∈ [1, n].

$← K1 and K2

1. Let tj
2. Pick K1
3. Let VK = iO(λ, SigCheck). Here the circuit SigCheck
is padded if necessary, such that its size is equal to
that of later inputs to the obfuscator.

$← K2.

4. Output VK.
5. While Mj ∈ Q is received:

i=1F1(K1, tj(cid:107)i(cid:107)M (i)) and s2j = ⊕λ
j ).

(a) Let s1j = ⊕l
F2,i (K2,i, t(i)
(b) Compute sj = s1j ⊕ s2j. Let σj = (tj, sj).
(c) Output σj.
6. Receive (M∗, σ∗).

i=1

A succeeds if M∗ (cid:54)∈ Q and VK(M∗, σ∗) = 1.

Game 2. In this hybrid we change the winning condition.
First the challenger choose indices (ˆi, ˆj) in [1, l] × [1, n] and

a bit ˆb in {0, 1} at random. Suppose an attacker in the ﬁnal
step outputs (M∗, σ∗). The winning condition enforces an
additional check that t∗ = tˆj and M∗(ˆi) = ˆb and ˆb (cid:54)= Mˆj(ˆi).

$← {0, 1}λ for all j ∈ [1, n].

1. Let tj
2. Choose (ˆi, ˆj) in [1, l]× [1, n] and ˆb in {0, 1} at random.

Let τ = tˆj(cid:107)ˆi(cid:107)ˆb.

$← K1 and K2,i

$← K2,i : i ∈ [1, λ].

3. Pick K1
4. Let VK = iO(λ, SigCheck). Here the circuit SigCheck
is padded if necessary, such that its size is equal to
that of later inputs to the obfuscator.

5. Output VK.
6. While Mj ∈ Q is received:

(K2,i, t(i)

i=1F1(K1, tj(cid:107)i(cid:107)M (i)) and s2j = ⊕λ

(a) Let s1j = ⊕l
j ).
(b) Compute sj = s1j ⊕ s2j. Let σj = (tj, sj).
(c) Output σj.
7. Receive (M∗, σ∗).

i=1F2,i

A succeeds if M∗ (cid:54)∈ Q and VK(M∗, σ∗) = 1 and if t∗ = tˆj
and M∗(ˆi) = ˆb and ˆb (cid:54)= Mˆj(ˆi).
Game 3. In this game the challenger creates the veriﬁca-
tion key as an obfuscation of an alternate veriﬁcation circuit
SigCheckA. First the challenger computes a puncturing of
the secret key K1 at string τ . Let y = F1(K1, τ ). The chal-
lenger uses the punctured key K1{τ}, punctured value y and
the injective OWF f to generate SigCheckA.

$← {0, 1}λ for all j ∈ [1, n].

1. Let tj
2. Choose (ˆi, ˆj) in [1, l]× [1, n] and ˆb in {0, 1} at random.

3. Pick K1

Let τ = (tˆj,ˆi, ˆb).
: i ∈ [1, λ]. Let
K1{τ} ← PunctureF1 (K1, τ ). Let y = F1(K1, τ ). Let
z = f (y).

$← K1 and K2,i

$← K2,i

4. Let VK = iO(λ, SigCheckA).
5. Output VK.
6. While Mj ∈ Q is received:

(K2,i, t(i)

i=1F1(K1, tj(cid:107)i(cid:107)M (i)) and s2j = ⊕λ

(a) Let s1j = ⊕l
j ).
(b) Compute sj = s1j ⊕ s2j. Let σj = (tj, sj).
(c) Output σj.
7. Receive (M∗, σ∗).

i=1F2,i

i=1.

SigCheckA :
Inputs : M, σ
Constants : Punctured PRF key K1{τ}, keys (K2,i)λ
Strings ˆi, τ, z.
(t, s) ← σ
s2 ← ⊕λ
if t(cid:107)ˆi(cid:107)M (ˆi) = τ then
output 1 else output ⊥
else
if s ⊕ s2 = ⊕l
1 else output ⊥
end if

i=1F2,i(K2,i, t(i))
f (s ⊕ s2 ⊕i(cid:54)=ˆi F1(K1{τ}, t(cid:107)i(cid:107)M (i))) = z

i=1F1(K1{τ}, t(cid:107)i(cid:107)M (i)) then output

then

if

A succeeds if M∗ (cid:54)∈ Q and VK(M∗, σ∗) = 1 and if t∗ = tˆj
and M∗(ˆi) = ˆb and ˆb (cid:54)= Mˆj(ˆi).

663Game 4. In this game the constant y, used to create z
in SigCheckA, is replaced with a random λ-bit string. The
other parts of the game do not change.

$← {0, 1}λ for all j ∈ [1, n].

1. Let tj
2. Choose (ˆi, ˆj) in [1, l]× [1, n] and ˆb in {0, 1} at random.

3. Pick K1

Let τ = tˆj(cid:107)ˆi(cid:107)ˆb.
: i ∈ [1, λ]. Let
K1{τ} ← PunctureF1 (K1, τ ). Choose y at random in
{0, 1}λ. Let z = f (y).

$← K1 and K2,i

$← K2,i

4. Let VK = iO(λ, SigCheckA).
5. Output VK.
6. While Mj ∈ Q is received:

(K2,i, t(i)

i=1F1(K1, tj(cid:107)i(cid:107)M (i)) and s2j = ⊕λ

(a) Let s1j = ⊕l
j ).
(b) Compute sj = s1j ⊕ s2j. Let σj = (tj, sj).
(c) Output σj.
7. Receive (M∗, σ∗).

i=1F2,i

A succeeds if M∗ (cid:54)∈ Q and VK(M∗, σ∗) = 1 and if t∗ = tˆj
and M∗(ˆi) = ˆb and ˆb (cid:54)= Mˆj(ˆi).

Claim 1. Suppose there exists a PPT adversary A mak-
ing a type I forgery such that AdvGame1A,Π = . Then the ad-
vantage of A in Game 2, i.e. AdvGame2A,Π , is bounded below by
/(2nl).

Proof. For any message M∗ submitted by A, since σ∗
is a type I forgery, there exists Mj ∈ Q such that the
signature σj satisﬁes tj = t∗. On the other hand, since
M∗ (cid:54)= Mj, there exists some bit position i ∈ [1, l] for which
M∗(i) (cid:54)= Mj(i). Since the challenger chooses (ˆi, ˆj, ˆb) ran-
domly in [1, l]×[1, n]×{0, 1}, the event (ˆi, ˆj, ˆb) ?= (i, j, M∗(i))
occurs with probability 1/(2nl). The claim then follows from
the fact the view of A in Game 1 is identical to its view in
Game 2.

Claim 2. Suppose there exists a PPT adversary A for
which AdvGame2A,Π −AdvGame3A,Π =  is non-negligible. Then we can
construct an attacker B with advantage  in distinguishing
the output of the indistinguishability obfuscator.

Proof. We ﬁrst demonstrate the functional equivalence
of circuits SigCheck and SigCheckA. Consider a claimed
signature (M, σ) which is input to the latter circuit.
If
it holds that t(cid:107)ˆi(cid:107)M (ˆi) (cid:54)= τ , then since the 2nd compo-
nent of τ is ˆi, t(cid:107)i(cid:107)M (i) (cid:54)= τ for all i ∈ [1, l]. Therefore
F1(K1{τ}, t(cid:107)i(cid:107)M (i)) = F1(K1, t(cid:107)i(cid:107)M (i)) for all i ∈ [1, l],
since the punctured PRF key preserves functionality outside
i=1F1(K1, t(cid:107)i(cid:107)M (i)) ⊕ s2
the punctured point. Thus s = ⊕l
⇔ s ⊕ s2 = ⊕l
i=1F1(K1{τ}, t(cid:107)i(cid:107)M (i)). On the other hand,
if t(cid:107)ˆi(cid:107)M (ˆi) = τ , then s = ⊕l
i=1F1(K1, t(cid:107)i(cid:107)M (i)) ⇔ s ⊕
s2 ⊕i(cid:54)=ˆi F1(K1{τ}, t(cid:107)i(cid:107)M (i)) = F1(K1, τ ) ⇔ f (s ⊕ s2 ⊕i(cid:54)=ˆi
F1(K1{τ}, t(cid:107)i(cid:107)M (i))) = f (y), since f is injective. Consider
the adversary B = (Samp, D). The algorithm Samp on 1λ
$← {0, 1}λ for j ∈ [1, n]. Next it picks random
chooses tj
(ˆi, ˆj, ˆb) in [1, l] × [1, n] × {0, 1}, computes string τ and out-
puts C0 = SigCheck and C1 = SigCheckA.
It sets state
i=1,ˆi, ˆj, b). Now the distingisher D
δ = ((tj)n
on input (δ, iO(λ, Cz)) sends VK = iO(λ, Cz) as well as a

i=1, K1, (K2,i)λ

signature σj on each message Mj received from A. If A out-
puts a pair (M∗, σ∗) for which M∗ (cid:54)∈ Q, VK(M∗, σ∗) = 1
and M∗(ˆi) = ˆb and ˆb (cid:54)= Mˆj(ˆi) then D outputs 1, otherwise
⊥. If z = 0 then B simulates Game 2. Otherwise B simulates
Game 3. The claim follows.

Claim 3. Suppose there exists a PPT adversary A for
which AdvGame3A,Π −AdvGame4A,Π =  is non-negligible. Then we can
construct an attacker B with advatange  in distinguishing
the output of the puncturable PRF F1(K1,·).

Proof. Simulator B interacts with the puncturable PRF
challenger while acting as a challenger to A. First B chooses
$← {0, 1}λ for j ∈ [1, n]. Next it chooses (ˆi, ˆj, ˆb) at random
tj
from [1, l]× [1, n]×{0, 1} and computes string τ . B submits
point τ to the PRF challenger and receives punctured key
K1{τ} and PRF challenge y(cid:48) in return. B then computes
z = f (y(cid:48)) and computes an obfuscation of SigCheckA.
It
sends VK = iO(λ, SigCheckA) and a signature σ on every
received message Mj. If A submits (M∗, σ∗) which meets
the winning condition, then B outputs 1, otherwise ⊥.
If
y(cid:48) = F1(K1, τ ) then B simulates Game 3. Otherwise y(cid:48) is
a random w-bit string and B simulates Game 4. The claim
follows.

Claim 4. Suppose there exists a PPT adversary A such
that AdvGame4A,Π =  is non-negligible. Then we can construct
an adversary B with advantage  in inverting the one way
function.

Proof. Simulator B interacts with the one way func-
tion challenger while acting as a challenger to A. First
B receives the challenge z(cid:48) = f (a) as an input, where a
$← {0, 1}λ
is a λ-bit random string. Then it chooses tj
for j ∈ [1, n]. Next it chooses (ˆi, ˆj, ˆb) at random from
[1, l] × [1, n] × {0, 1} and computes string τ .
It computes
punctured key K1{τ} and an obfuscation of SigCheckA with
z(cid:48) hardwired in place of z. Since z(cid:48) is identically distributed
to z, the view of A is identical to its view in Game 4. It sends
VK and signatures on every received message Mj. Then
with probability , A outputs (M∗, σ∗) such that M∗ (cid:54)∈ Q,
VK(M∗, σ∗) = 1 and t∗(cid:107)ˆi(cid:107)M∗(ˆi) = τ . Thus B can com-
pute a∗ = s∗ ⊕ s∗
2 ⊕i(cid:54)=ˆi F1(K1{τ}, t(cid:107)i(cid:107)M∗(i)) which satisﬁes
a∗ = f−1(z(cid:48)).

Suppose that there exists a PPT adversary A with non-
negligible advantage  in breaking the adaptive security of
the signature scheme, i.e. in winning Game 1. Let the maxi-
mal advantage of any adversary in distinguishing the output
of the indistinguishability obfuscator and in distinguishing
the output of the puncturable PRF be iO and P RF re-
spectively. Claims 1 - 4 then imply that A has probability
atleast /(nl)− iO − P RF in inverting the one way function
f . Since n and l are polynomially bounded, the ﬁrst term
is non-negligible and since iO is a secure indistinguishabil-
ity obfuscator and F1 is a secure puncturable PRF the sec-
ond and third terms are negligible. This contradicts the
It follows that the advantage of A
non-invertibility of f .
in Game 1 must be negligible. This concludes the proof of
Lemma 1.

Lemma 2. Suppose that adversary A in the adaptive se-
curity game makes a type II forgery with probability II .

664Then we can construct B that inverts the one way function
f with probability II /(nλ) − negl(λ).

Proof. Similar to the proof of Lemma 1, we proves this

result by a hybrid argument.

Game 1. This is the original security game in which the at-
tacker receives the veriﬁcation key, and then queries for sig-
natures on messages adaptively. Let Q be the set of queried
In the ﬁnal step an attacker outputs (M∗, σ∗).
messages.
Here σ∗ = (t∗, s∗) and t∗ (cid:54)= tj for all signatures σj on
Mj ∈ Q.

$← {0, 1}λ for all j ∈ [1, n].

$← K1 and K2

1. Let tj
2. Pick K1
3. Let VK = iO(λ, SigCheck). Here the circuit SigCheck
is padded if necessary, such that its size is equal to
that of later inputs to the obfuscator.

$← K2.

4. Output VK.
5. While Mj ∈ Q is received:

(K2,i, t(i)

i=1F1(K1, tj(cid:107)i(cid:107)M (i)) and s2j = ⊕λ

(a) Let s1j = ⊕l
j ).
(b) Compute sj = s1j ⊕ s2j. Let σj = (tj, sj).
(c) Output σj.
6. Receive (M∗, σ∗).

$← K1 and K2,i

$← K2,i

: i ∈ [1, λ]. Let

3. Pick K1

K2,i(cid:48){p} ← PunctureF2,i(cid:48) (K2,i(cid:48) , p). Let y = F2,i(cid:48) (K2,i(cid:48) , p).

Let z = f (y).

4. Let VK = iO(λ, SigCheckB).
5. Output VK.
6. While Mj ∈ Q is received:

(K2,i, t(i)

i=1F1(K1, tj(cid:107)i(cid:107)M (i)) and s2j = ⊕λ

(a) Let s1j = ⊕l
j ).
(b) Compute sj = s1j ⊕ s2j. Let σj = (tj, sj).
(c) Output σj.
7. Receive (M∗, σ∗).

i=1F2,i

SigCheckB :
Inputs : M, σ
Constants : PRF keys K1, (K2,i)i(cid:54)=i(cid:48) , punctured key
K2,i(cid:48){p}. Strings i(cid:48), p, z.

i=1F1(K1, t(cid:107)i(cid:107)M (i))

(t, s) ← σ
s1 ← ⊕λ
if t(i(cid:48)) = p then
else output ⊥
else
then output 1 else output ⊥
end if

i=1F2,i

if f (s ⊕ s1 ⊕i(cid:54)=i(cid:48) F2,i(K2,i, t(i))) = z then output 1

if s⊕s1 = ⊕i(cid:54)=i(cid:48) F2,i(K2,i, t(i))⊕F2,i(cid:48) (K2,i(cid:48){p}, t(i(cid:48)))

A succeeds if M∗ (cid:54)∈ Q and VK(M∗, σ∗) = 1.

Game 2. In this hybrid we change the winning condition.
First the challenger choose indices (i(cid:48), j(cid:48)) in [1, λ] × [1, n]
at random. Suppose an attacker in the ﬁnal step outputs
(M∗, σ∗). The winning condition enforces an additional
check that t∗ and tj(cid:48) have shortest diﬀering preﬁx of length
i(cid:48).

$← {0, 1}λ for all j ∈ [1, n].

1. Let tj
2. Choose (i(cid:48), j(cid:48)) in [1, λ]×[1, n] at random. Let p = t(i(cid:48))
3. Pick K1
4. Let VK = iO(λ, SigCheck). Here the circuit SigCheck
is padded if necessary, such that its size is equal to
that of later inputs to the obfuscator.

$← K2,i : i ∈ [1, λ].

$← K1 and K2,i

j(cid:48) ⊕ ei(cid:48) .

5. Output VK.
6. While Mj ∈ Q is received:

(K2,i, t(i)

i=1F1(K1, tj(cid:107)i(cid:107)M (i)) and s2j = ⊕λ

(a) Let s1j = ⊕l
j ).
(b) Compute sj = s1j ⊕ s2j. Let σj = (tj, sj).
(c) Output σj.
7. Receive (M∗, σ∗).

i=1F2,i

A succeeds if M∗ (cid:54)∈ Q and VK(M∗, σ∗) = 1 and if t∗(i(cid:48)) = p.

Game 3. In this game the challenger creates the veriﬁca-
tion key as an obfuscation of an alternate veriﬁcation circuit
SigCheckB. First the challenger computes a puncturing of
the secret key K2,i(cid:48) at string p. Let y = F2,i(K2,i, p). The
challenger uses the punctured key K2,i(cid:48){p}, punctured value
y and the injective OWF f to generate SigCheckB.

$← {0, 1}λ for all j ∈ [1, n].

1. Let tj
2. Choose (i(cid:48), j(cid:48)) in [1, λ] × [1, n] at random. Let p =

t(i(cid:48))
j(cid:48) ⊕ ei(cid:48) .

A succeeds if M∗ (cid:54)∈ Q and VK(M∗, σ∗) = 1 and if t∗(i(cid:48)) = p.

Game 4. In this game the constant y, used to create z
in SigCheckB, is replaced with a random λ-bit string. The
other parts of the game do not change.
$← {0, 1}λ for all j ∈ [1, n].

1. Let tj
2. Choose (i(cid:48), j(cid:48)) in [1, λ] × [1, n] at random. Let p =

$← K1 and K2,i

ti(cid:48)
j(cid:48) ⊕ ei(cid:48) .
: i ∈ [1, λ]. Let
3. Pick K1
K2,i(cid:48){p} ← PunctureF2,i(cid:48) (K2,i(cid:48) , p). Choose y at ran-
dom in {0, 1}λ. Let z = f (y).
4. Let VK = iO(λ, SigCheckB).
5. Output VK.
6. While Mj ∈ Q is received:

$← K2,i

(K2, t(i)

i=1F1(K1, tj(cid:107)i(cid:107)M (i)) and s2j = ⊕λ

(a) Let s1j = ⊕l
(b) Compute sj = s1j ⊕ s2j. Let σj = (tj, sj).
(c) Output σj.
7. Receive (M∗, σ∗).

j ).

i=1F2

A succeeds if M∗ (cid:54)∈ Q and VK(M∗, σ∗) = 1 and if t∗(i(cid:48)) = p.
Claim 5. Suppose there exists a PPT adversary A mak-
ing a type II forgery such that AdvGame1A,Π = . Then the ad-
vantage of A in Game 2, i.e. AdvGame2A,Π , is bounded below by
/(nλ).

Proof. For any message t∗ submitted by A in Game 1,
there exists a shortest common preﬁx of t∗ with the tj : j ∈
[1, n]. Also, since σ∗ is a type II forgery, t∗ (cid:54)= tj, for all
tj. Thereore the length of this preﬁx is at most λ − 1. In
particular there exists some string tj and a preﬁx of length
j ⊕ ei. Since the challenger
i, at most λ, for which t∗(i) = t(i)

665chooses (i(cid:48), j(cid:48)) uniformly at random from [1, λ] × [1, n], the
event (i(cid:48), j(cid:48)) ?= (i, j) occurs with probability 1/(nλ). The
claim then follows from the fact the view of A in Game 1 is
identical to its view in Game 2.

Claim 6. Suppose there exists a PPT adversary A for
which AdvGame2A,Π −AdvGame3A,Π =  is non-negligible. Then we can
construct an attacker B with advantage  in distinguishing
the output of the indistinguishability obfuscator.

Proof. We demonstrate the functional equivalence of cir-
cuits SigCheck and SigCheckB as follows. Consider a claimed
signature (M, σ) which is input to the latter circuit. If it
holds that t(i(cid:48)) (cid:54)= p, then F2,i(cid:48) (K2,i(cid:48){p}, t(i(cid:48))) = F2,i(cid:48) (K2,i(cid:48) ,
t(i(cid:48))), since the punctured PRF key preserves functionality
outside the punctured point. Thus s = s1⊕i(cid:54)=i(cid:48) F2,i(K2,i, t(i))⊕
F2,i(cid:48) (K2,i(cid:48) , t(i(cid:48))) ⇔ s⊕s1 = ⊕i(cid:54)=i(cid:48) F2,i(K2,i, t(i))⊕F2,i(cid:48) (K2,i(cid:48){p},
t(i(cid:48))). On the other hand, if t(i(cid:48)) = p, then s = s1 ⊕λ
F2,i(K2,i, t(i)) ⇔ s ⊕ s1 ⊕i(cid:54)=i(cid:48) F2,i(K2,i, t(i)) = F2,i(cid:48) (K2,i(cid:48) , p)
⇔ f (s ⊕ s1⊕i(cid:54)=i(cid:48) F2,i(K2,i, t(i))) = f (y), since f is injec-
tive. Consider the adversary B = (Samp, D). The algo-
$← {0, 1}λ for j ∈ [1, n]. Next
rithm Samp on 1λ chooses tj
it picks random (i(cid:48), j(cid:48)) in [1, λ] × [1, n], computes string p
and outputs C0 = SigCheck and C1 = SigCheckB. It sets
i=1, i(cid:48), j(cid:48)). Now the distingisher
state δ = ((tj)n
D on input (δ, iO(λ, Cz)) sends VK = iO(λ, Cz) as well as
a signature σj on each message Mj received from A. If A
outputs a pair (M∗, σ∗) for which M∗ (cid:54)∈ Q, VK(M∗, σ∗) = 1
and t∗(i(cid:48)) = p then D outputs 1, otherwise ⊥. If z = 0 then
B simulates Game 2. Otherwise B simulates Game 3. The
claim follows.

i=1, K1, (K2,i)λ

i=1

Claim 7. Suppose there exists a PPT adversary A for
which AdvGame3A,Π −AdvGame4A,Π =  is non-negligible. Then we can
construct an attacker B with advatange  in distinguishing
the output of the puncturable PRF F2(K2,·).

Proof. Simulator B interacts with the puncturable PRF
challenger while acting as a challenger to A. First B chooses
$← {0, 1}λ for j ∈ [1, n]. Next it chooses (i(cid:48), j(cid:48)) at ran-
tj
dom from [1, λ] × [1, n] and computes string p. B submits
point p to the PRF challenger and receives punctured key
K2,i(cid:48){p} and PRF challenge y(cid:48) in return. B then computes
z = f (y(cid:48)) and computes an obfuscation of SigCheckB.
It
sends VK = iO(λ, SigCheckB) and a signature σ on every
received message Mj. If A submits (M∗, σ∗) which meets
the winning condition, then B outputs 1, otherwise ⊥.
If
y(cid:48) = F2,i(cid:48) (K2,i(cid:48) , p) then B simulates Game 3. Otherwise y(cid:48)
is a random w-bit string and B simulates Game 4. The claim
follows.

Claim 8. Suppose there exists a PPT adversary A such
that AdvGame4A,Π =  is non-negligible. Then we can construct
an adversary B with advantage  in inverting the one way
function.

Proof. Simulator B interacts with the one way function
challenger while acting as a challenger to A. First B receives
the challenge z(cid:48) = f (a) as an input, where a is a λ-bit ran-
$← {0, 1}λ for j ∈ [1, n]. Next
dom string. Then it chooses tj

it chooses (i(cid:48), j(cid:48)) at random from [1, λ]× [1, n] and computes
string p. It computes punctured key K2,i(cid:48){p} and an obfus-
cation of SigCheckB with z(cid:48) hardwired in place of z. Since
z(cid:48) is identically distributed to z, the view of A is identical
to its view in Game 4. It sends VK and signatures on every
received message Mj. Then with probability , A outputs
(M∗, σ∗) such that M∗ (cid:54)∈ Q, VK(M∗, σ∗) = 1 and t∗(i(cid:48)) = p.
1 ⊕i(cid:54)=i(cid:48) F2,i(K2,i, t(i)) which
Thus B can compute a∗ = s∗ ⊕ s∗
satisﬁes a∗ = f−1(z(cid:48)).

Suppose that there exists a PPT adversary A with non-
negligible advantage  in breaking the adaptive security of
the signature scheme. Similar to the proof of Lemma 1,
Claims 5-8 imply that A has probability /(nλ) − negl(λ)
in inverting the one way function. As before, since n is
polynomially bounded, this contradicts its non-invertibility.
It follows that the advantage of A is negligible.

Given Lemmas 1 and 2 we can conclude Theorem 1 as
follows. Simulator B guesses ahead of time which forgery A
will make. Thus B has advantage at least (1/2)· (I /(2nl) +
II /(nλ) − negl(λ)) ≥ AdvA,Π/(2n · max{2l, λ}) − negl(λ).
Since B has negligible advantage in inverting f , it follows
that A has negligible advantage in breaking the signature
scheme.

5.

IMPROVING EFFICIENCY

One drawback of our previous construction is that it does
not meet our goal of achieving fast signing.
(We will see
some concrete end-to-end comparisons in Section 6.) Rela-
tive to the selectively secure Sahai-Waters scheme the pri-
mary drawback is that a punctured PRF must be evaluated
(cid:96) diﬀerent times. If we use the GGM implementation each
call results is around (cid:96) applications of the underlying pseudo
random generator,2 resulting in an O((cid:96)2) applications.

In this section we demonstrate an idea to lower the cost of
our fully secure scheme. The primary change is that instead
of using (cid:96) diﬀerent punctured PRF systems, each with a
diﬀerent domain size, we will use one punctured PRF with
a variable length domain {0, 1}1≤i≤(cid:96). That is the input to
the function can be a string of any length up to (cid:96). We can
then plug this into our main construction.

At ﬁrst glance it might seem that this modiﬁcation brings
us nothing since the construction still needs to XOR together
(cid:96) diﬀerent PRF values. However, as we will show that it is
possible to create a variable length punctured PRF where
the cost of evaluating the PRF on all preﬁxes of an (cid:96) bit
message M is the same as computing the GGM tree once on
M . The main modiﬁcation is that, following Goldreich [15],
we now need a length tripling PRG G : {0, 1}λ → {0, 1}3·λ
that goes from λ bits to 3 · λ bits. In practice, this could be
more than using a length doubling one, but should result in
signiﬁcantly faster signatures than the prior approach.

Below we ﬁrst give the modiﬁed punctured PRF construc-

tion. Then we show the changes to our scheme.
5.1 Puncturable PRFs for Variable Length

Do-main

Let the puncturable PRF have variable message size v bits
and output size λ bits. Here v ≤ l. Let G be a PRG with
2The exact number of applications will depend on the length
of the input. In Section 6 we work out the details.

666input size λ bits and output size 3λ bits. Deﬁne auxiliary
functions G0, G1 and G⊥ mapping λ bits to λ bits as follows:
G(x) = G0(x)(cid:107)G1(x)(cid:107)G⊥(x).

Construction.

• Setup(1λ) : Let K be a random λ-bit string. Output
• Puncture(K, x) :

key K.

Write x as b1 . . . bv, where v ≤ l.
for i = 1 to v − 1 do

FK,i ← Gbi
(Gbi−1 (. . . (Gb1 (K)) . . .))
FK,i,⊥ ← G⊥(Gbi . . . (Gb1 (K)) . . .)

end for
FK,v ← Gbv
(Gbv−1 (. . . (Gb1 (K)) . . .))
FK,v+1,0 ← G0(Gbv (. . . (Gb1 (K)) . . .))
FK,v+1,1 ← G1(Gbv (. . . (Gb1 (K)) . . .))

Let K{x} = (FK,i, FK,i,⊥)i∈[1,v−1], FK,v, (FK,v+1,b)b∈[0,1].
Output key K{x}.

• Eval(K{x}, y) :
if y = x then
output ⊥

else

Let x = b1 . . . bv.
Write y = b1 . . . bib(cid:48)
if i < v and u = i then

i+1 . . . b(cid:48)

u, where u ≤ l.

Output FK,i,⊥.

else if i < v and u > i then

Output G⊥(Gb(cid:48)

u

else

Output G⊥(Gb(cid:48)

u

end if

end if

(. . . Gb(cid:48)

i+2

(FK,i+1) . . .)).

(. . . Gb(cid:48)

v+2

(FK,v+1,b(cid:48)

v+1

) . . .)).

Cost.
To evaluate this puncturable PRF on a u-bit message re-
quires u − i calls to G, where i is the length of the longest
common preﬁx with the punctured point. Even more sig-
niﬁcantly, to evaluate the PRF on every preﬁx of a u-bit
message still only requires u − i calls, because evaluations
on successive preﬁxes corresponds to pipelined calls to G,
with each evaluation terminated by a single application of
G⊥. We will see that this leads to signiﬁcant savings in our
signature scheme.

Security.

We defer the proof of security of this puncturable PRF to

the Appendix.
5.2 Modiﬁed Scheme

The message space of the signature scheme is {0, 1}l. For
l-bit message M , let M (i) denote the i-th bit of M . For λ-bit
string t, let t(i) denote the ﬁrst i bits of t. Let F1(K1,·) be
a puncturable PRF mapping lt-bit inputs to λ-bit outputs.
Here lt = λ +(cid:100)lg l(cid:101) + 1. Let F2(K2,·) be a puncturable PRF
mapping {0, 1}1≤i≤(cid:96) to λ-bit outputs. Let f be an injective
one way function mapping λ-bit inputs to w-bit outputs.
Our signature scheme is as follows.

Setup(1λ) : Pick puncturable PRF keys K1

$← K1 and
$← K2. The secret key is (K1, K2). Let the veriﬁca-

K2

tion key VK be an indistinguishability obfuscation of the
program SigCheck deﬁned below.
Sign(SK, M ) : Choose t $← {0, 1}λ. Let s1 = ⊕l
t(cid:107)i(cid:107)M (i)). Let s2 = ⊕λ
s2. Output σ = (t, s).

i=1F1(K1,
i=1F2(K2, t(i)). Compute s = s1 ⊕

Verify(VK, M, σ) : Output VK(M, σ).

SigCheck :
Inputs : M, σ
Constants : PRF keys K1 and K2
(t, s) ← σ
s1 ← ⊕l
s2 ← ⊕λ
if s = s1 ⊕ s2 then output 1 else output ⊥

i=1F1(K1, t(cid:107)i(cid:107)M (i))
i=1F2(K2, t(i))

We omit the proof of this scheme since it follows extremely

close to the base scheme of Section 4.

6. ANALYSIS AND EVALUATION

In this section we evaluate the cost of the (selectively
secure) Sahai-Waters construction and the proposed adap-
tively secure construction in terms of the cost of the punc-
turable PRFs. We begin by expressing the cost of each
scheme in terms of the underlying length-doubling and length-
tripling PRGs. Next we show costs on a common architec-
ture assuming 128-bit security and compare this against the
RSA and elliptic curve DSA signature schemes.
6.1 Analysis of Costs

Let gD be the cost of the length-doubling PRG and gT be
the cost of the length-tripling PRG. We assume the messages
to be signed are l-bits.

Sahai-Waters [26].

This scheme makes a single call to the puncturable PRF
on an l-bit message. This call traverses the GGM tree ac-
cording to the message bits, requring l invocations of the
length-doubling PRG. The cost is therefore gD · l.

Adaptively secure scheme.

Our adaptively secure scheme calls the ﬁxed-length punc-
turable PRF once on each of l inputs, where each input is λ+
(cid:100)lg l(cid:101) + 1 bits. However each input has the same λ-bit suﬃx,
diﬀering only in the remaining bits. Therefore the GGM tree
can be traversed to a depth of λ, before a depth-ﬁrst search
is performed to an additional (cid:100)lg l(cid:101)+1 depth. Thus λ+2l−1
calls are made to the length-doubling PRG. Additionally the
scheme evaluates the variable-length puncturable PRF once
on a λ-bit input, outputting pipelined evaluations on each
preﬁx. Therefore the modiﬁed GGM tree is traversed to
a depth of λ, requiring λ calls to the length-tripling PRG.
Therefore the total cost is gD · (λ + 2l − 1) + gT · λ.
6.2 Comparison of Signature Computation for

128-bit Security

To achieve a security level of 128 bits, we consider sig-
natures on 256-bit messages. In practice such messages are
produced by application of a collision-resistant hash func-
tion, we disregard this cost here. For our analysis we con-
sidered several diﬀerent candidates for the PRG. These in-

667ChaCha : The input is zero-padded to 384 bits. We then
extract the ﬁrst 384 bits of the 512 pseudorandom bits
produced by an update operation and xor these with
the input.3 The cost to seed is 0.03µs. The amortized
invocation cost is 0.27µs.

AES (software only) : The input is extended to 384 bits.
We then apply the AES cipher in CTR mode. The cost
to seed is 0.17µs. The invocation cost is 0.42µs.

AES (hardware accelerated) : The input is extended
to 384 bits. We then apply the AES cipher in CTR
mode. The cost to seed is 0.16µs. The invocation cost
is 0.12µs.

RC5 : The input is extended to 384 bits. We then apply
the RC5 cipher in CTR mode. The cost to seed is
1.11µs. The invocation cost is 0.54µs.

Optimizations.

Exploiting the stream property of ChaCha and CTR mode
of operation for the above block ciphers allows some ef-
ﬁciency gains.
In a call to the ﬁxed domain puncturable
PRF, only one output block need be computed at each level
of the GGM tree, halving the invocation cost of the length-
doubling PRG. Likewise in a call to the variable-domain
puncturable PRF, only two out of three output blocks need
be computed at each level of the modiﬁed GGM tree, re-
ducing the invocation cost of the length-tripling PRG by a
factor of 2/3.

Pulling it Together.

Our measurements show some interesting features. For
all pseudo random generator candidates considered, signing
in the Sahai-Waters scheme is signiﬁcantly faster than EC-
DSA. Using the AES (software) or ChaCha based solutions
it is around ten to ﬁfteen times faster.

Our adaptively secure scheme adds an overhead of about

2.5, relative to the selectively secure Sahai-Waters.

Finally, we note that our scheme is conducive to leveraging
parallelism. In Appendix A we describe a slight generaliza-
tion to larger width GGM trees. For small increases in width
it is feasible to utilize certain PRG structures that allow for
computing multiple bits of the PRG output in parallel.

Acknowledgements
We thank Amit Sahai for observing that a wider tree struc-
ture in tandem with a parallelizable PRG could be conducive
to leveraging parallelism.

Brent Waters is supported by NSF CNS-0952692, CNS-
1228599 and CNS-1414082, DARPA through the U.S. Of-
ﬁce of Naval Research under Contract N00014-11-1-0382,
Google Faculty Research award, the Alfred P. Sloan Fellow-
ship, Microsoft Faculty Fellowship, and Packard Foundation
Fellowship.

clude the SHA-256 cyptographic hash function, the ChaCha
stream cipher, the RC5 block cipher and AES-256 (software
and hardware). We compare this against the cost of elliptic
curve DSA signatures. All primitives are implemented using
v1.0.1 of the OpenSSL library, excepting the ChaCha stream
cipher which uses a C implementation available here [7]. The
AES hardware implementation is based upon the Intel AES-
NI instruction set which is available via the EVP wrapper of
the OpenSSL library. All timings were performed on a quad-
core Intel Xeon E3-1270 v2 workstation with 16Gb RAM,
clocked @3.50GHz.

Primitives.

SHA-256 : The SHA-256 compression function maps 512-

bits to 256-bits.

ChaCha : The ChaCha stream cipher is seeded via a 256-
bit key and 64-bit IV. It generates 512-bit psuedoran-
dom bits per update operation of the internal state.

AES (software only) : The AES-256 block cipher is seeded

via a 256-bit key and 64-bit IV. It operates on 128-bit
blocks.

AES (hardware accelerated) : The AES-256 block ci-
pher is seeded via a 256-bit key and 64-bit IV. It op-
erates on 128-bit blocks.

RC5 : The RC5 block cipher has a variable key/block size.
The default implementation uses a 128-bit key and op-
erates on 64-bit blocks.

RSA : The RSA algorithm (PKCS #1 v2.0) is used to
generate signatures on a 3072-bit modulus. The cost
is 3400µs.

EC-DSA : The elliptic curve DSA algorithm is used to
generate signatures on a 256-bit curve. The cost is
348µs.

Length-doubling PRG.

SHA-256 : The input is zero-padded to 512 bits. The
SHA-256 compression function is then applied. The
cost of this routine is 0.52µs.

ChaCha : The input is zero-padded to 256 bits. We then
extract the ﬁrst 256 bits of the 512 pseudorandom bits
produced by an update operation and xor these with
the input.3 The cost to seed is 0.03µs. The amortized
invocation cost is 0.18µs.

AES (software only) : The input is extended to 256 bits.
We then apply the AES cipher in CTR mode. The cost
to seed is 0.17µs. The invocation cost is 0.28µs.

AES (hardware accelerated) : The input is extended
to 256 bits. We then apply the AES cipher in CTR
mode. The cost to seed is 0.16µs. The invocation cost
is 0.08µs.

RC5 : The input is extended to 256 bits. We then apply
the RC5 cipher in CTR mode. The cost to seed is
1.11µs. The invocation cost is 0.36µs.

Length-tripling PRG.

SHA-256 : The input is extended to 1024 bits. The SHA-
256 compression function is then applied on each 512-
bit block and the ﬁrst 384 bits of the output extracted.
The cost of this routine is 1.04µs.

3The remaining bits are cached for the next invocation.

668PRG
[26]

Adapt. scheme

RSA

EC-DSA

SHA-256 ChaCha AES AES (hardware) RC5
47
162

133
465

23
81

10
36

36
125

3400
348

Table 1: Signature cost on 256-bit messages. By PRG, we mean the appropriate choice of length-doubling
PRG or length-tripling PRG. All times given in microseconds.

7. REFERENCES

[1] Boaz Barak, Oded Goldreich, Russell Impagliazzo,

Steven Rudich, Amit Sahai, Salil Vadhan, and
Ke Yang. On the (im)possibility of obfuscating
programs. In Lecture Notes in Computer Science,
pages 1–18. Springer-Verlag, 2001.

[2] Florian B¨ohl, Dennis Hofheinz, Tibor Jager, Jessica

Koch, and Christoph Striecks. Conﬁned guessing: New
signatures from standard assumptions. Journal of
Cryptology, pages 1–33, 2014.

[3] Dan Boneh and Brent Waters. Constrained

pseudorandom functions and their applications.
Cryptology ePrint Archive, Report 2013/352, 2013.
http://eprint.iacr.org/.

[4] Elette Boyle, Shaﬁ Goldwasser, and Ioana Ivan.

Functional signatures and pseudorandom functions. In
Hugo Krawczyk, editor, Public-Key Cryptography –
PKC 2014, volume 8383 of Lecture Notes in Computer
Science, pages 501–519. Springer Berlin Heidelberg,
2014.

[5] Elette Boyle, Gil Segev, and Daniel Wichs. Fully

leakage-resilient signatures. In Kenneth G. Paterson,
editor, Advances in Cryptology – EUROCRYPT 2011,
volume 6632 of Lecture Notes in Computer Science,
pages 89–108. Springer Berlin Heidelberg, 2011.

[6] David Cash, Dennis Hofheinz, Eike Kiltz, and Chris

Peikert. Bonsai trees, or how to delegate a lattice
basis. In Henri Gilbert, editor, Advances in Cryptology
– EUROCRYPT 2010, volume 6110 of Lecture Notes
in Computer Science, pages 523–552. Springer Berlin
Heidelberg, 2010.

[7] ChaCha stream cipher implementation, May 2014.

http:
//cr.yp.to/streamciphers/timings/estreambench/
submissions/salsa20/chacha8/ref/chacha.c.

[8] Melissa Chase and Markulf Kohlweiss. A new

hash-and-sign approach and structure-preserving
signatures from DLIN. In Proceedings of the 8th
International Conference on Security and
Cryptography for Networks, SCN’12, pages 131–148,
Berlin, Heidelberg, 2012. Springer-Verlag.

[9] Whitﬁeld Diﬃe and Martin E. Hellman. New

directions in cryptography. IEEE Transactions on
Information Theory, 22(6):644–654, 1976.

[10] Cynthia Dwork and Moni Naor. An eﬃcient

existentially unforgeable signature scheme and its
applications. In Proceedings of the 14th Annual
International Cryptology Conference on Advances in
Cryptology, CRYPTO ’94, pages 234–246, London,
UK, UK, 1994. Springer-Verlag.

[11] Dario Fiore and Dominique Schr¨oder. Uniqueness is a

diﬀerent story: Impossibility of veriﬁable random
functions from trapdoor permutations. In Proceedings
of the 9th International Conference on Theory of
Cryptography, TCC’12, pages 636–653, Berlin,
Heidelberg, 2012. Springer-Verlag.

[12] Sanjam Garg, Craig Gentry, Shai Halevi, Mariana

Raykova, Amit Sahai, and Brent Waters. Candidate
indistinguishability obfuscation and functional
encryption for all circuits. Cryptology ePrint Archive,
Report 2013/451, 2013.

[13] Sanjam Garg, Craig Gentry, Shai Halevi, Amit Sahai,

and Brent Waters. Attribute-based encryption for
circuits from multilinear maps. In Ran Canetti and
Juan A. Garay, editors, Advances in Cryptology –
CRYPTO 2013, volume 8043 of Lecture Notes in
Computer Science, pages 479–499. Springer Berlin
Heidelberg, 2013.

[14] Rosario Gennaro, Craig Gentry, and Bryan Parno.
Non-interactive veriﬁable computing: Outsourcing
computation to untrusted workers. In Proceedings of
the 30th Annual Conference on Advances in
Cryptology, CRYPTO’10, pages 465–482, Berlin,
Heidelberg, 2010. Springer-Verlag.

[15] Oded Goldreich. Foundations of Cryptography:

Volume 1. Cambridge University Press, New York,
NY, USA, 2006.

[16] Oded Goldreich, Shaﬁ Goldwasser, and Silvio Micali.

How to construct random functions. J. ACM,
33(4):792–807, August 1986.

[17] Shaﬁ Goldwasser, Silvio Micali, and Ronald L. Rivest.

A digital signature scheme secure against adaptive
chosen-message attacks. SIAM J. Comput.,
17(2):281–308, April 1988.

[18] Sergey Gorbunov, Vinod Vaikuntanathan, and

Hoeteck Wee. Attribute-based encryption for circuits.
In Proceedings of the 45th annual ACM symposium on
Symposium on theory of computing, STOC ’13, pages
545–554, New York, NY, USA, 2013. ACM.

[19] Susan Hohenberger and Brent Waters. Short and

stateless signatures from the RSA assumption. In Shai
Halevi, editor, Advances in Cryptology – CRYPTO
2009, volume 5677 of Lecture Notes in Computer
Science, pages 654–670. Springer Berlin Heidelberg,
2009.

[20] Aggelos Kiayias, Stavros Papadopoulos, Nikos

Triandopoulos, and Thomas Zacharias. Delegatable
pseudorandom functions and applications. In
Proceedings of the 2013 ACM SIGSAC Conference on
Computer & Communications Security, CCS ’13,
pages 669–684, New York, NY, USA, 2013. ACM.

669[21] Donald E. Knuth. The Art of Computer Programming,

Volume 2 (2nd Ed.): Seminumerical Algorithms.
Addison-Wesley Longman Publishing Co., Inc.,
Boston, MA, USA, 1981.

[22] Hugo Krawcyzk and Tal Rabin. Chameleon signatures.

In Network and Distributed Systems Security
Symposium, 2000.

[23] Allison Lewko and Brent Waters. New proof methods
for attribute-based encryption: Achieving full security
through selective techniques. In Reihaneh Safavi-Naini
and Ran Canetti, editors, Advances in Cryptology –
CRYPTO 2012, volume 7417 of Lecture Notes in
Computer Science, pages 180–198. Springer Berlin
Heidelberg, 2012.

[24] Daniele Micciancio and Chris Peikert. Trapdoors for
lattices: Simpler, tighter, faster, smaller. In Advances
in Cryptology–EUROCRYPT 2012, pages 700–718.
Springer, 2012.

[25] B. Parno, J. Howell, C. Gentry, and M. Raykova.

Pinocchio: Nearly practical veriﬁable computation. In
Security and Privacy (SP), 2013 IEEE Symposium on,
pages 238–252, May 2013.

[26] Amit Sahai and Brent Waters. How to use

indistinguishability obfuscation: Deniable encryption,
and more. In Proceedings of the 46th Annual ACM
Symposium on Theory of Computing, STOC ’14, pages
475–484, New York, NY, USA, 2014. ACM.

[27] Jae Hong Seo. Short signatures from diﬃe-hellman,
revisited: Sublinear public key, CMA security, and
tighter reduction. Cryptology ePrint Archive, Report
2014/138, 2014. http://eprint.iacr.org/.

APPENDIX
A. PUNCTURABLE PRF FROM LARGE

WIDTH GGM

There have been several prior constructions [3, 4, 20] of
puncturable PRFs from the tree-based construction of [16].
In this section we show a simple extension to a 2c-ary tree
for some constant c. One can view this as an application
of the Dwork-Naor [10] put into the [16] context. The pri-
mary motivation of this construction is in the construction
of PRFs from PRGs which have a large cost to seed, how-
ever then transform input relatively quickly. In this case is
it reasonable to consider a value c > 1.
A.1 Puncturable PRFs from [16] via [10]

Let the puncturable PRF have message size l bits and
output size λ bits. Consider a construction where an input
message is broken into l/c words each of size c-bits. Thus
we can write x = w1 . . . wd where wi ∈ {0, 1}c and d =
l/c.4. Let G be a PRG with input size λ bits and output
size λ · 2c bits. Clearly c should be a small constant, due
to the exponentially dependency in the output size. We
deﬁne auxiliary functions Gw : {0, 1}λ → {0, 1}λ as follows:
G(x) = G1(x)(cid:107)G2(x)(cid:107) . . .(cid:107)G2c (x).

Construction.

4Note that inputs can always be zero padded to ensure l is
a multiple of c

• Setup(1λ) : Let K be a random λ-bit string. Output

key K.

• Puncture(K, x) :

Write x ∈ {0, 1}l as w1 . . . wd.
for i = 1 to d do
for w ∈ {0, 1}c\{wi} do

FK,i,w ← Gw(Gwi−1 . . . Gw2 (Gw1 (K)) . . .))

end for

end for
Let K{x} = (FK,i,w)i∈[1,d],w∈{0,1}l\{wi}. Output key
K{x}.

• Eval(K{x}, y) :
if y = x then
output ⊥

else

Let x = w1 . . . wd.
Write y = w1 . . . wi−1ww(cid:48)
Output Gw(cid:48)

(Gw(cid:48)

(. . . Gw(cid:48)

d

d−1

i+1 . . . w(cid:48)

d where w (cid:54)= wi.

(FK,i,w) . . .)).

i+1

end if

Security.

Theorem 2. The above scheme is a selectively secure punc-

turable PRF if G is a secure PRG stretching λ bits to λ · 2c
bits.

Proof. We prove the above theorem by deﬁning the fol-

lowing sequence of hybrids.

Hybrid 1

1. Choose K at random in {0, 1}λ.
2. Receive an l-bit message x, to be punctured on.
3. Puncture K on x as follows

Let x = w1 . . . wd.
for i = 1 to d do

for w ∈ {0, 1}c\{wi} do

FK,i,w ← Gw(Gwi−1 . . . Gw2 (Gw1 (K)) . . .))

end for

end for

Let K{x} = (FK,i,w)i∈[1,d],w∈{0,1}l\{wi}.

4. Send key K{x}.
5. Send Gwd (Gwd−1 (. . . Gw1 (K) . . .)).

Hybrid 2[j] : j ∈ [0, d]

1. Choose K at random in {0, 1}λ.
2. Receive an l-bit message x, to be punctured on.
3. Puncture K on x as follows

Let x = w1 . . . wd.
for i = 1 to j do

for w ∈ {0, 1}c\{wi} do

$← {0, 1}λ

FK,i,w

end for

end for
Let y $← {0, 1}λ.
for i = j + 1 to d do

for w ∈ {0, 1}c\{wi} do

FK,i,w ← Gw(Gwi−1 . . . Gwj+1 (y)) . . .))

end for

end for

Let K{x} = (FK,i,w)i∈[1,d],w∈{0,1}l\{wi}.

6704. Send key K{x}.
5. Send Gwd (Gwd−1 (. . . Gwj+1 (y) . . .)).

Hybrid 3

1. Choose K at random in {0, 1}λ.
2. Receive an l-bit message x, to be punctured on.
3. Puncture K on x as follows

Let x = w1 . . . wd.
for i = 1 to d do

for w ∈ {0, 1}c\{wi} do

$← {0, 1}λ

FK,i,w

end for

end for

Let K{x} = (FK,i,w)i∈[1,d],w∈{0,1}l\{wi}.

4. Send key K{x}.
5. Let y(cid:48) $← {0, 1}λ. Send y(cid:48).

Hybrid 4[j] : j ∈ [0, d]

1. Choose K at random in {0, 1}λ.
2. Receive an l-bit message x, to be punctured on.
3. Puncture K on x as follows

Let x = w1 . . . wd.
for i = 1 to d − j do

for w ∈ {0, 1}c\{wi} do

$← {0, 1}λ

FK,i,w

end for

end for
Let y $← {0, 1}λ.
for i = d + 1 − j to d do

for w ∈ {0, 1}c\{wi} do

FK,i,w ← Gw(Gwi−1 . . . Gwj+1 (y)) . . .))

end for

end for

Let K{x} = (FK,i,w)i∈[1,d],w∈{0,1}l\{wi}.

4. Send key K{x}.
5. Let y(cid:48) $← {0, 1}λ. Send y(cid:48).

Hybrid 5

1. Choose K at random in {0, 1}λ.
2. Receive an l-bit message x, to be punctured on.
3. Puncture K on x as follows

Let x = w1 . . . wd.
for i = 1 to d do

for w ∈ {0, 1}c\{wi} do

FK,i,w ← Gw(Gwi−1 . . . Gw2 (Gw1 (K)) . . .))

end for

end for

Let K{x} = (FK,i,w)i∈[1,d],w∈{0,1}l\{wi}.

4. Send key K{x}.
5. Let y(cid:48) $← {0, 1}λ. Send y(cid:48).
Claim 9. Suppose there exists a PPT adversary A such
=  for j ∈ [1, d]. Then the
that AdvHybrid2[j−1]
advantage of A in distinguishing the output of G is at least
.

− AdvHybrid2[j]

Proof. B receives point x = w1 . . . wd from A. B receives
PRG challenge z = z1 . . . z2c , where z is either the output
of G on string y, or is a truly random string of length λ · 2c.

A

A

$← {0, 1}λ : i < j. B sets FK,j,w = zw : w ∈
B sets FK,i,w
{0, 1}l\{wj}. B sets FK,i,w = Gw(Gwi−1 (. . . Gwj+1 (zw) . . .)) :
i > j, w ∈ {0, 1}l\{wi}. Lastly B sends Gwd (Gwd−1 ( . . .
Gwj+1 (zw) . . . )). If z = G(y), then B is in Hybrid 2[j − 1],
otherwise if z is truly random, then B is in Hybrid 2[j]. It
follows the advantage of B in distinguishing the output of G
is .

Claim 10. Suppose there exists a PPT adversary A such
=  for j ∈ [1, d]. Then the
that AdvHybrid4[j−1]
advantage of A in distinguishing the output of G is at least
.

− AdvHybrid4[j]

A

A

Proof. B receives point x = w1 . . . wd from A. B re-
ceives PRG challenge z = z1 . . . z2c , where z is either the
output of G on string y, or is a truly random string of
length λ · 2c. B sets FK,i,w
$← {0, 1}λ : i > d − j. B
sets FK,d−j,w = zw : w ∈ {0, 1}l\{wd−j}. B sets FK,i,w =
Gw(Gwi−1 (. . . Gwd+1−j (zw) . . .)) : i > d−j, w ∈ {0, 1}l\{wi}.
Lastly B sends Gwd (Gwd−1 (. . . Gwd+1−j (zw) . . .)).
If z =
G(y), then B is in Hybrid 4[j − 1], otherwise if z is truly
random, then B is in Hybrid 4[j]. It follows the advantage
of B in distinguishing the output of G is .

First observe that the Hybrids in each of the following
pairs of are identical: (1, 2[0]), (2[d], 3), (3, 4[0]) and (4[d], 5).
Thus claims 5 and 6 imply that the advantage of any PPT
adversary in distinguishing Hybrids 1 and 5 is at most 2d ·
P RG, where P RG is the maximal distinguishing adversary
of any adversary in distinguishing the output of the PRG.
On the other hand, any adversary distinguishing Hybrids
1 and 5 distinguishes the output of the puncturable PRF.
Since P RG is neglgible by assumption, it follows that no
adversary has more than a negligible advantage in distin-
guishing the output of the puncturable PRF.

B. PROOF OF SECURITY OF VARIABLE-
LENGTH DOMAIN PUNCTURABLE PRF

Theorem 3. The scheme given in Section 5 is a selec-
tively secure puncturable PRF if G is a secure PRG stretch-
ing λ bits to 3λ bits.

Proof. We prove the above theorem by deﬁning the fol-

lowing sequence of hybrids.

Hybrid 1

1. Choose K at random in {0, 1}λ.
2. Receive an v-bit message x, to be punctured on.
3. Puncture K on x as follows

Write x as b1 . . . bv, where v ≤ l.
for i = 1 to v − 1 do

FK,i ← Gbi
(Gbi−1 (. . . (Gb1 (K)) . . .))
FK,i,⊥ ← G⊥(Gbi . . . (Gb1 (K)) . . .)

end for
FK,v ← Gbv
(Gbv−1 (. . . (Gb1 (K)) . . .))
FK,v+1,0 ← G0(Gbv (. . . (Gb1 (K)) . . .))
FK,v+1,1 ← G1(Gbv (. . . (Gb1 (K)) . . .))

Let K{x} = (FK,i, FK,i,⊥)i∈[1,v−1], FK,v, (FK,v+1,b)b∈[0,1].

4. Send key K{x}.
5. Send G⊥(Gbv (. . . (Gb1 (K)) . . .)).

671Hybrid 2[j] : j ∈ [0, v]

1. Choose K at random in {0, 1}λ.
2. Receive an v-bit message x, to be punctured on.
3. Puncture K on x as follows

Write x as b1 . . . bv, where v ≤ l.
for i = 1 to j do
$← {0, 1}λ
yi,0
$← {0, 1}λ
yi,1
yi,⊥ $← {0, 1}λ

end for
for i = 1 to j do
FK,i ← yi,0
FK,i,⊥ ← yi,⊥

end for
for i = j + 1 to v − 1 do

FK,i ← Gbi
(Gbi−1 . . . (yj,1) . . .)
FK,i,⊥ ← G⊥(Gbi (. . . (yj,⊥) . . .))

end for
FK,v ← Gbv
(Gbv−1 (. . . (yj,1) . . .))
FK,v+1,0 ← G0(Gbv (. . . (yj,1) . . .))
FK,v+1,1 ← G1(Gbv (. . . (yj,1) . . .))

Let K{x} = (FK,i, FK,i,⊥)i∈[1,v−1], FK,v, (FK,v+1,b)b∈[0,1].

Hybrid 5

4. Send key K{x}.
5. Send G⊥(Gbv (. . . (yj,1) . . .)).

Hybrid 3

1. Choose K at random in {0, 1}λ.
2. Receive an v-bit message x, to be punctured on.
3. Puncture K on x as follows

Write x as b1 . . . bv, where v ≤ l.
for i = 1 to v − 1 do

$← {0, 1}λ
yi,1
yi,⊥ $← {0, 1}λ

end for
for i = 1 to v + 1 − j do

FK,i ← yi,0
FK,i,⊥ ← yi,⊥

end for
for i = v + 2 − j to v − 1 do

FK,i ← Gbi
(Gbi−1 . . . (yv+1−j,1) . . .)
FK,i,⊥ ← G⊥(Gbi (. . . (yv+1−j,⊥) . . .))

end for

(Gbv−1 (. . . (yv+1−j,1) . . .))

FK,v ← Gbv
yv+1,⊥ $← {0, 1}λ
FK,v+1,0 ← G0(Gbv (. . . (yv+1−j,1) . . .))
FK,v+1,1 ← G1(Gbv (. . . (yv+1−j,1) . . .))

Let K{x} = (FK,i, FK,i,⊥)i∈[1,v−1], FK,v, (FK,v+1,b)b∈[0,1].

4. Send key K{x}.
5. Send yv+1,⊥.

1. Choose K at random in {0, 1}λ.
2. Receive an v-bit message x, to be punctured on.
3. Puncture K on x as follows

Write x as b1 . . . bv, where v ≤ l.
for i = 1 to v − 1 do

FK,i ← Gbi
(Gbi−1 (. . . (Gb1 (K)) . . .))
FK,i,⊥ ← G⊥(Gbi . . . (Gb1 (K)) . . .)

end for

FK,v ← Gbv
(Gbv−1 (. . . (Gb1 (K)) . . .))
yv+1,⊥ $← {0, 1}λ
FK,v+1,0 ← G0(Gbv (. . . (Gb1 (K)) . . .))
FK,v+1,1 ← G1(Gbv (. . . (Gb1 (K)) . . .))

Let K{x} = (FK,i, FK,i,⊥)i∈[1,v−1], FK,v, (FK,v+1,b)b∈[0,1].

A

A

4. Send key K{x}.
5. Send yv+1,⊥.
Claim 11. Suppose there exists a PPT adversary A such
=  for j ∈ [1, v]. Then the
that AdvHybrid2[j−1]
advantage of A in distinguishing the output of G is at least
.

− AdvHybrid2[j]

Proof. Simulator B receives point x = b1 . . . bv from A.
B sets yi,0
$← {0, 1}λ, yi,⊥ $← {0, 1}λ, FK,i ← yi,0, FK,i,⊥ ←
yi,⊥ : i < j. B is given z = yj,0(cid:107)yj,1(cid:107)yj,⊥ as input which
is either the output of G on a random λ-bit input, or is
a truly random 3λ-bit string. B sets FK,i ← Gbi
(Gbi−1
. . . (yj,1) . . . ), FK,i,⊥ ← G⊥(Gbi (. . . (yj,⊥) . . .)) : i ∈ [j, v −
1]. B sets FK,v ← Gbv
(Gbv−1 ( . . . (yj,1) . . . )), FK,v+1,0 ←
G0(Gbv (. . . (yj,1) . . .)), FK,v+1,1 ← G1(Gbv (. . . (yj,1) . . .)). B
sends K{x} and G⊥(Gbv ( . . . (yj,1) . . . )).
If B is given
G(yj−1,1) for random yj−1,1 then it is in Hybrid 2[j − 1],
otherwise if z is truly random, it is in Hybrid 2[j]. The
claims follows.

A

Claim 12. Suppose there exists a PPT adversary A such
= . Then the advantage of A

that AdvHybrid2[v]
in distinguishing the output of G is at least .

− AdvHybrid3A

Proof. Simulator B receives point x = b1 . . . bv from A.
$← {0, 1}λ, yi,⊥ $← {0, 1}λ, FK,i ← yi,0, FK,i,⊥ ←

B sets yi,0

$← {0, 1}λ
yi,0
$← {0, 1}λ
yi,1
yi,⊥ $← {0, 1}λ

end for
for i = 1 to v − 1 do

FK,i ← yi,0
FK,i,⊥ ← yi,⊥
$← {0, 1}λ

end for
yv,0
$← {0, 1}λ
yv+1,0
$← {0, 1}λ
yv+1,1
yv+1,⊥ $← {0, 1}λ
FK,v ← yv,0
FK,v+1,0 ← yv+1,0
FK,v+1,1 ← yv+1,1

Let K{x} = (FK,i, FK,i,⊥)i∈[1,v−1], FK,v, (FK,v+1,b)b∈[0,1].

4. Send key K{x}.
5. Send yv+1,⊥.

Hybrid 4[j] : j ∈ [1, v + 1]

1. Choose K at random in {0, 1}λ.
2. Receive an v-bit message x, to be punctured on.
3. Puncture K on x as follows
Write x as b1 . . . bv, where v ≤ l.
for i = 1 to v + 1 − j do

$← {0, 1}λ

yi,0

672yi,⊥ : i ∈ [1, v]. B is given z = yv+1,0(cid:107)yv+1,1(cid:107)yv+1,⊥ as
input which is either the output of G on a random λ-bit
input, or is a truly random 3λ-bit string. B sets FK,v ←
yv,0, FK,v+1,0 ← yv+1,0, FK,v+1,1 ← yv+1,1. B sends K{x}
and yv+1,⊥. If B is given G(yv,1) for random yv,1 then it is
in Hybrid 2[v], otherwise if z is truly random, it is in Hybrid
3. The claims follows.

Claim 13. Suppose there exists a PPT adversary A such
= . Then the advantage of A

that AdvHybrid3A
in distinguishing the output of G is at least .

− AdvHybrid4[1]

A

Proof. Simulator B receives point x = b1 . . . bv from A.
$← {0, 1}λ, yi,⊥ $← {0, 1}λ, FK,i ← yi,0, FK,i,⊥ ←
B sets yi,0
yi,⊥ : i ∈ [1, v]. B is given z = yv+1,0(cid:107)y(cid:48)
v+1,1(cid:107)yv+1,⊥ as
input which is either the output of G on a random λ-bit
input, or is a truly random 3λ-bit string. B sets FK,v ←
yv,0, FK,v+1,0 ← yv+1,0, FK,v+1,1 ← yv+1,1. B sends K{x}
and yv+1,⊥ $← {0, 1}λ. If B is given G(yv,1) for random yv,1
then it is in Hybrid 4[1], otherwise if z is truly random, it is
in Hybrid 3. The claims follows.

Claim 14. Suppose there exists a PPT adversary A such
=  for j ∈ [2, v + 1]. Then
that AdvHybrid4[j−1]
the advantage of A in distinguishing the output of G is at
least .

− AdvHybrid4[j]

A

A

Proof. Simulator B receives point x = b1 . . . bv from A.
B sets yi,0
$← {0, 1}λ, yi,⊥ $← {0, 1}λ, FK,i ← yi,0, FK,i,⊥ ←
yi,⊥ : i > v+1−j. B is given z = yv+1−j,0(cid:107)yv+1−j,1(cid:107)yv+1−j,⊥
as input which is either the output of G on a random λ-bit
input, or is a truly random 3λ-bit string. B sets FK,i ←
(Gbi−1 . . . (yv+1−j,1) . . .), FK,i,⊥ ← G⊥(Gbi ( . . . (yv+1−j,⊥)
Gbi
. . . )) : i ∈ [v + 1 − j, v − 1]. B sets FK,v ← Gbv
(Gbv−1 (
. . . (yv+1−j,1) . . . )), FK,v+1,0 ← G0(Gbv ( . . . (yv+1−j,1) . . .
)), FK,v+1,1 ← G1(Gbv ( . . . (yv+1−j,1) . . . )). B sends K{x}
and G⊥(Gbv ( . . . (yv+1−j,1) . . . )). If B is given G(yv−j,1) for
random yv−j,1 then it is in Hybrid 2[j − 1], otherwise if z is
truly random, it is in Hybrid 2[j]. The claims follows.

Observe that Hybrid 1 is identical to Hybrid 2[0]. Simil-
iarly Hybrid 4[v + 1] is identical to Hybrid 5. Thus claims 8
- 11 imply that the advantage of any PPT adversary in dis-
tinguishing Hybrids 1 and 5 is at most 2(v + 1)· P RG, where
P RG is the maximal distinguishing adversary of any adver-
sary in distinguishing the output of the PRG. On the other
hand, any adversary distinguishing Hybrids 1 and 5 distin-
guishes the output of the puncturable PRF. Since P RG is
negligible by assumption, it follows that no adversary has
more than a negligible advantage in distinguishing the out-
put of the puncturable PRF.

673