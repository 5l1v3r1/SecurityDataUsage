EdgeMiner: Automatically Detecting Implicit

Control Flow Transitions through the Android Framework

Yinzhi Cao§, Yanick Fratantonio†, Antonio Bianchi†, Manuel Egele‡,
†University of California, Santa Barbara

Christopher Kruegel†, Giovanni Vigna† and Yan Chen¶
‡Boston University

§Columbia University
¶Northwestern University
yzcao@cs.columbia.edu, {yanick, antoniob, chris, vigna}@cs.ucsb.edu, megele@bu.edu, ychen@northwestern.edu

Abstract—A wealth of recent research proposes static data
ﬂow analysis for the security analysis of Android applications.
One of the building blocks that these analysis systems rely
upon is the computation of a precise control ﬂow graph. The
callback mechanism provided and orchestrated by the Android
framework makes the correct generation of the control ﬂow
graph a challenging endeavor. From the analysis’ point of view,
the invocation of a callback is an implicit control ﬂow transition
facilitated by the framework. Existing static analysis tools
model callbacks through either manually curated lists or ad-hoc
heuristics. This work demonstrates that both approaches are
insufﬁcient, and allow malicious applications to evade detection
by state-of-the-art analysis systems.

To address the challenge of implicit control ﬂow transitions
(i.e., callbacks) through the Android framework, we are the ﬁrst
to propose, implement, and evaluate a systematic treatment of
this aspect. Our implementation, called EDGEMINER, statically
analyzes the entire Android framework to automatically generate
API summaries that describe implicit control ﬂow transitions
through the Android framework. We use EDGEMINER to analyze
three major versions of the Android framework. EDGEMINER
identiﬁed 19,647 callbacks in Android 4.2, suggesting that a
manual treatment of this challenge is likely infeasible. Our
evaluation demonstrates that the current insufﬁcient treatment of
callbacks in state-of-the-art analysis tools results in unnecessary
imprecision. For example, FlowDroid misses a variety of leaks
of privacy sensitive data from benign off-the-shelf Android
applications because of its inaccurate handling of callbacks. Of
course, malicious applications can also leverage this blind spot in
current analysis systems to evade detection at will. To alleviate
these drawbacks, we make our results publicly available and
demonstrate how these results can easily be integrated into
existing state-of-the-art analysis tools. Our work allows existing
tools to comprehensively address the challenge of callbacks and
identify previously undetected leakage of privacy sensitive data.

I.

INTRODUCTION

Mobile smart devices, such as smart phones, media players,
and tablets, have become ubiquitous.
Industry reports the
total number of sales of Android-powered smart phones at
over six hundred million in 2013 alone [6]. The application
ecosystem that developed around the mobile platform is a key
contributing factor to the huge success of mobile smart devices.

Permission to freely reproduce all or part of this paper for noncommercial
purposes is granted provided that copies bear this notice and the full citation
on the ﬁrst page. Reproduction for commercial purposes is strictly prohibited
without the prior written consent of the Internet Society, the ﬁrst-named author
(for reproduction of an entire paper only), and the author’s employer if the
paper was prepared within the scope of employment.
NDSS ’15, 8-11 February 2015, San Diego, CA, USA
Copyright 2015 Internet Society, ISBN 1-891562-38-X
http://dx.doi.org/10.14722/ndss.2015.23140

Android users can choose from over one million applications
(apps) offered through the ofﬁcial Google Play marketplace.
Furthermore, a wealth of alternative sources for Android
applications is available for users to choose from. These
range from curated stores, such as Amazon’s Appstore to less
legitimate sources that offer pirated content. The sheer number
of mobile applications prompted researchers from academia and
industry to develop static analysis techniques that scrutinize
these applications for vulnerabilities and malicious functionality.

Android applications always execute in the context of
the Android framework — a comprehensive collection of
functionality that developers can conveniently use from their
applications. The proliﬁc use of the framework poses unique
challenges for the analysis of Android applications.

analysis

systems

static

State-of-the-art

for Android
applications (e.g., [9, 11, 17, 18, 23]) reconstruct an application’s
control ﬂow graph as part of their analysis. However, imprecision
in the control ﬂow graph (CFG) permeates throughout the
analysis and can cause false alarms as well as missed detections
for malware and vulnerability scanners. One common, but
insufﬁciently addressed cause of such imprecision are callbacks.
A callback is a method implemented by the application but
invoked by the Android framework. This implies that
the
callback method does not have an incoming control ﬂow edge
contained in the application itself. Instead, control is implicitly
transferred to the callback by the framework.

Intuitively, the existence of a callback must be communicated
to the framework before an invocation can happen. In Android,
this can be accomplished in two different ways. The ﬁrst one con-
sists in deﬁning and implementing a well-known Android com-
ponent, such as an Activity. The callbacks associated with these
components are strictly related to their life-cycles, as described
in the Android documentation. In this case, the developer would
communicate to the Android framework the existence of the com-
ponent by specifying it in the so-called manifest, the application’s
main conﬁguration ﬁle. Then, when the application is started, the
framework parses the manifest and becomes aware of the com-
ponent, and it can thus properly invoke all the deﬁned callbacks.

The second way through which the existence of a callback
can be communicated to the framework is by using a so-called
registration method. A classic example is the onClick callback
method that applications bind to a user interface element (e.g., a
button) with the setOnClickListener registration method.
Once the user taps the button, the framework automatically
invokes the speciﬁed onClick callback. Similarly, a call to
the sort registration method of a Collection will result in
multiple calls to the compare callback method implemented

by the Comparator class (see Section II).1

Because these interactions are entirely provided by the
framework, an analysis that solely considers the application’s
code cannot identify these implicit control ﬂow transitions
(ICFTs). That is, systems that analyze applications in isolation
from the framework necessarily generate incomplete control
ﬂow graphs. As we will show in Section VII, this omission
allows malicious applications to evade detection and moreover
jeopardizes the correct analysis of benign applications.

The proliﬁc use of these callback mechanisms in real-world
Android applications mandates that analysis systems model
the corresponding ICFTs accordingly. Existing systems use a
variety of techniques in an attempt to address ICFTs. Callbacks
related to the application’s life-cycle are well documented and
understood. Thus, current analysis systems model such callbacks
by means of a manually curated list of conﬁguration entries.
For example, the authors of FlowDroid describe how they were
able to properly model the life-cycle of the main components
after Android’s documentation. As these are well-known and
well-documented methods, we believe that this manual effort is
sufﬁcient to correctly handle these life-cycle related callbacks.
Where existing systems fall short, is in modeling callbacks
that are not as well documented as those related to the
application life-cycle. These callbacks are modeled based
on either manually curated lists [9, 18] or heuristics [23].
Unfortunately, in this case, neither approach is a sufﬁcient
treatment of ICFTs as the resulting control ﬂow graphs lack
edges that are not explicitly modeled or captured by the
heuristics. In the next section, we provide two concrete examples
of this concept, while in Section VII-F we demonstrate how this
imprecision directly leads to undetected malicious functionality.
The main goal of our work is to remove the unnecessary
imprecision that this second category of callbacks introduce in
current analysis systems. We propose a novel static analysis
approach and its implementation − EDGEMINER − as the ﬁrst
work to systematically address the challenge of ICFTs. EDGEM-
INER applies automated program analysis techniques to identify
the callbacks and their registration methods in the Android
framework. To this end, we implement a scalable inter-procedural
backward data ﬂow analysis that ﬁrst identiﬁes callbacks and
then links these callbacks with their corresponding registration
functions. In Section VII-F, we show how the results produced
by EDGEMINER (i.e., pairs of registrations and callbacks) can
be used to signiﬁcantly improve state-of-the-art Android analysis
systems, such as FlowDroid [9]. In particular, we show that
before the integration of our results, FlowDroid fails to detect
privacy leaks in applications that use ICFTs (i.e., false negatives).
We used EDGEMINER to analyze the codebase of three
major Android versions. In the spirit of open science we make
our results and implementation publicly available.2 In this way,
existing and future static analysis tools can beneﬁt from our
work, and researchers will be able to independently conduct
analysis on other versions of the Android framework. In addition,
we note that EDGEMINER only needs to run once per framework

1As we will discuss later in the paper, certain callbacks (e.g., onClick)
can be implicitly registered through an XML conﬁguration ﬁle. However, this
is only possible for a very limited set of well-known callbacks.

2The implementation and the results for Android 4.2 alias KitKat are

available at this URL: http://edgeminer.org.

• We design a novel automated analysis

version, as the extracted information pertaining to callbacks
and registrations is invariant for all applications executing on
a given framework version. This observation also implies that
the results of EDGEMINER remain valid regardless of any
obfuscation attempts made by individual Android applications.
In summary, this paper makes the following novel contributions:
• We identify the challenge of implicit control ﬂow transfers
provided by the Android framework as a source for
imprecision in state-of-the-art static analysis systems.
(§IV) and
corresponding implementation (EDGEMINER §V)
to
analyze multiple versions of the Android framework for
the callbacks and their registrations. Our results (§VII)
indicate that modern Android versions feature nearly
20,000 registration and callback methods.
• To demonstrate that our results can easily be incorporated
into existing analysis systems, we extend the popular Flow-
Droid framework with support for the newly detected ICFTs
(§VII-F). This extension allows FlowDroid to detect infor-
mation leaks that previously eluded the tool’s capabilities.
• Finally, we make our results and implementation publicly
available to allow existing and future analysis systems to
beneﬁt from our research.

II. MOTIVATING EXAMPLES

In this section we present two examples (that we will use
throughout the paper) that illustrate the importance of implicit
control ﬂow transitions for the static analysis of Android
applications. The main role of these examples is to show how
a malicious application could leak private information through
the usage of implicit control ﬂow transitions. In particular, as
we discuss at the end of this section, these simple examples
are sufﬁcient to evade detection from all existing static analysis
tools, including FlowDroid [9], the current state-of-the-art taint
analysis system.

Our ﬁrst example (Figure 1) uses a synchronous ICFT. An
ICFT is synchronous if the callback method is synchronously
invoked as soon as its associated registration method is invoked.
Our second example (Figure 2) uses an asynchronous ICFT. An
ICFT is asynchronous if the invocation of the callback method
is delayed to some time after its associated registration method
is invoked. Both our examples consist of two parts: application
space code (Figure 1a and Figure 2a), which is written by the
application developer, and framework space code (Figure 1b and
Figure 2b), which is deﬁned within the Android framework itself.
Let us ﬁrst focus on the application space code in Figure 1a.
At
lines 10-17 the MalComp class is deﬁned. This class
implements the Comparator Java interface and its mandated
compare method. During execution, this method stores the
current GPS coordinates into the MainClass.value static
ﬁeld (Line 14). Then, the main method (of the MainClass
class) is deﬁned (Lines 3-8). This method ﬁrst creates an
instance (mal) of the MalComp object (Line 4) and then
sets the MainClass.value static ﬁeld to an integer
constant (Line 5). Subsequently,
invokes the
Collections.sort method and passes the mal instance
as a second argument. Finally, main transmits the value stored
in the MainClass.value ﬁeld to the network (Line 7).

in Line 6 it

2

}

static int value = 0;
static void main(String[] args) {

MalComp mal = new MalComp();
MainClass.value = 42;
Collections.sort(list, mal);
sendToInternet(MainClass.value);

1 class MainClass {
2
3
4
5
6
7
8
9 }
10 class MalComp implements Comparator {
11
12
13
14
15
16
17 }

MainClass.value = getGPSCoords();
return 0;

Object arg0,
Object arg1) {

int compare(

}

public int compare(T lhs, T rhs);

public static <T> void sort(

1 public interface Comparator<T> {
2
3 }
4
5 public class Collections {
6
7
8
9
10
11
12
13 }

}

List<T> list,
Comparator<? super T> comparator) {

...
comparator.compare(element1, element2);
...

(b) Framework Space

(a) Application Space

Fig. 1: An example that shows that without properly linking the sort method (invoked at (a) Line 6) to the compare method (deﬁned at
(a) Line 11) and invoked at (b) Line 10, existing static analyzers would not detect the privacy leak. Note that the framework space code is
simpliﬁed for understanding.

}

static int value = 0;
onCreate(Bundle bundle) {

MalListener mal = new MalListener();
MainActivity.value = 42;
// get a reference to a button GUI widget
Button b = [...]
b.setOnClickListener(mal);

1 class MainActivity extends Activity {
2
3
4
5
6
7
8
9
10 }
11 class FinalActivity extends Activity {
12
13
14
15
16
17 }
18 class MalListener implements OnClickListener {
19
20
21
22
23 }

// This activity is reached towards the
// end of the application’s execution.
onCreate(Bundle bundle) {

MainActivity.value = getGPSCoords();
...

sendToInternet(MainActivity.value);

void onClick(View v) {

}

}

case EVENT:

switch (msg.what) {

mView.mOnClickListener.onClick();

1 public class ViewRootImpl extends Handler {
2
public void handleMessage (Message msg) {
3
4
5
6
7
8
9 }
10 public class View {
11
12

OnClickListener mOnClickListener;
public void

...

}

}

setOnClickListener (OnClickListener li) {

mOnClickListener = li;

}
interface OnClickListener {

void onClick(View v);

}

13
14
15
16
17
18 }

(b) Framework Space

(a) Application Space

Fig. 2: An example that shows that without properly linking the setOnClickListener method (invoked at (a) Line 8) to the onClick
method (deﬁned at (a) Line 19) and invoked at (b) Line 5, existing static analyzers would not detect the privacy leak. Note that the framework
space code is simpliﬁed for understanding.

The implicit control ﬂow transition in this example is pro-
vided by the framework code illustrated in Figure 1b. The sort
method implemented in the Collections base class (Line 6)
implements a variety of sorting algorithms (mergesort, quicksort,
and insertion sort). Regardless of the chosen implementation,
each algorithm repeatedly invokes the compare method (Line
10) of the provided Comparator object to assess the ordering
of two elements in the collection. Thus, a call to the sort
method implicitly invokes the compare callback method im-
plemented in the application. Consequently, the value transmitted
to the Internet at Line 7 of the main function corresponds to
the sensitive GPS information as opposed to the constant value.
Note that the ICFT in this example is synchronous. That is, the
callback method (compare) is invoked before the execution
of the registration method (sort) returns to application space.

Similarly, the example provided in Figure 2 shows how a
malicious application could leak sensitive information through
an asynchronous
application

In particular,

ICFT.

this

invoking

an OnClickListener (by

the
registers
setOnClickListener registration method, Line 8),
and it associates it to a speciﬁc GUI Button. Once the user
clicks on this button, the associated onClick method will
be invoked, and the current GPS coordinates are stored in
the MainActivity.value static ﬁeld. Then, when the
FinalActivity activity is reached,
the recorded GPS
coordinates will be leaked.

A static analysis that analyzes applications in isolation from
the framework will miss these implicit control ﬂows. This
implies that systems that analyze applications for privacy leaks
will incorrectly label the examples in Figure 1 and Figure 2
as benign (i.e., false negatives).

indeed,

To demonstrate that,

these examples constitute
false negatives, we augmented the DroidBench [4] benchmark
suite with a variety of test cases similar to the presented
example. In Section VII-F, we show how the technique that
we described in these two examples can be used by a malicious

3

Before the framework can invoke an application callback
the framework must be made aware of the callback’s existence.
This is accomplished through so-called registration methods.

Deﬁnition 3 A registration method is a method implemented
in framework space that communicates the availability of an
application callback to the framework itself.

to the framework space. Clearly,

Intuitively, registration methods are the methods through
which an application space object implementing an application
callback ﬂows
these
registration methods are necessary for the realization of the
callback mechanism.
the sort method
in Figure 1a (Line 6) is a registration method, because it
passes the MalComp instance with its compare application
callback to the framework. Another popular pair
is the
setOnClickListener registration method (Figure 2a,
Line 8) and an object implementing the OnClickListener
interface with its onClick callback (Figure 2a, Lines 18–23).

In our example,

Based on the above deﬁnitions, our goal is to automatically
determine all pairs of registration and callback methods that
result in implicit control ﬂow transfers. For an ICFT to occur, the
object on which a callback is invoked must be the same object
that is communicated to the framework in a previous registration
call. Thus, a ﬁnal requirement is that registrations and callbacks
are connected through a data ﬂow of the corresponding object.
Clearly such a data ﬂow is present in the examples in Figure 1
and Figure 2 facilitated by the respective mal objects. However,
passing an object that implements a callback to the framework
through a method other than a registration, does not result
in the required data ﬂow. For example, adding an object that
implements the OnClickListener interface to a container
(e.g., a Vector, java.util.Vector.addElement(mal))
does not result in an ICFT. The reason is that the Android
framework does not contain code that invokes the onClick
method of objects stored in a Vector.

IV. APPROACH

As explained in the previous section, our approach takes as
input the Android framework, and extracts all implicit control
ﬂow transitions throughout its codebase. The output of the
system is a list of registration-callback pairs.

To identify these pairs of method calls, EDGEMINER ﬁrst
extracts a list of potential callbacks and identiﬁes all callsites
in the framework that can invoke these potential callbacks.
Subsequently, for each identiﬁed callsite, EDGEMINER performs
an inter-procedural backward data ﬂow analysis to trace the
origin of the object used at the callsite. If this analysis reveals that
the object is used as an argument to a registration method, then
this object could ﬂow from application to framework space and,
consequently, EDGEMINER outputs a registration-callback pair.

In the remainder of this section, we explain the details of our
approach. In particular, as Figure 3 shows, the analysis needs to
perform several preprocessing steps, before the actual backward
data ﬂow analysis can identify the resulting registration-callback
pairs.

5

A. Preprocessing

The initial phase of the analysis consists of a series of
preprocessing steps. First, EDGEMINER transforms each
method of the framework into an intermediate representation
that
is particularly well-suited for performing data ﬂow
analysis. Then, EDGEMINER extracts the class hierarchy and
interface deﬁnitions from the Android framework. Subsequently,
EDGEMINER extracts an over-approximation of the framework’s
call graph. At the same time EDGEMINER labels all potential
callbacks in the generated call graph. The ﬁnal preprocessing
step collects meta-information pertaining to ﬁeld (i.e., Java
classes’ ﬁelds) accesses in the framework.

Intermediate Representation (IR). The ﬁrst preprocessing
step consists of transforming the individual methods implemented
in the Android framework into Static Single Assignment [12]
(SSA) form. Code in SSA form has the property that each
variable is assigned exactly once. Different assignments to the
same variable are represented as distinct versions. Representing
the methods of the framework in SSA signiﬁcantly eases the
implementation of the backward data ﬂow analysis, which we
describe in detail in the next section.

Class Hierarchy. The class hierarchy is a tree data structure
that represents the inheritance relationships between individual
classes deﬁned in the framework. Similar to the Java class
hierarchy, the Android framework class hierarchy is rooted at
the Object node. That is, all classes deﬁned and used by
the Android framework (directly, or indirectly) inherit from
Object. The class hierarchy also stores information about
interfaces and attributes classes to the interfaces they implement.
As this information is needed for generating an over-
approximation of the call graph, our approach reconstructs the
class hierarchy of all classes and interfaces deﬁned in the Android
framework. This is done by retrieving, for each class and inter-
face, which class they directly extend and which interfaces they
directly implement, if any. Then, EDGEMINER computes the tran-
sitive closure to have the complete information readily available.
Call Graph Construction. The goal of this step is to con-
struct the framework’s call graph, which is necessary to perform
the inter-procedural data ﬂow analysis. We use the following
conservative approach to extract an over-approximation of the
framework’s call graph. For each invoke instruction (i.e., method
call), the analysis determines all possible targets. This is achieved
by combining the information of the static type of the receiving
object (which is easily accessible through the invoke instruction)
and information available from the class hierarchy analysis. As
common for object-oriented languages, the target of a method
call depends on the dynamic type of the receiving object. At
runtime, the dynamic dispatch mechanism is responsible to
identify and call the correct implementation of a polymorphic
method. Unfortunately, it is an undecidable problem, in general,
to identify the precise dynamic type at a callsite statically.

To address this problem, our analysis conservatively
identiﬁes all potential methods (i.e., callees) that can be invoked
at a callsite as follows. EDGEMINER ﬁrst retrieves the static
type T of the receiving object, which is available from the
framework’s code directly. Then, since subtype polymorphism
as implemented by Dalvik mandates that the dynamic type S
of an object is the same as its static type T or one its subtypes
(i.e., S <: T ), EDGEMINER can process the subtree of the class

hierarchy that is rooted at T to identify all possible method
implementations. For each method deﬁned in a non-abstract
class in that subtree, EDGEMINER then checks whether it
matches the name and type signature of the method at the
callsite. All methods that match these criteria are connected
to the callsite with an edge in the call graph. Furthermore, if
the static type of the receiving object at the callsite (i.e., T )
is an interface, EDGEMINER repeats the previous steps for all
classes in the framework that implement this interface.

This technique will result in an over-approximation of the
call graph for regular Dalvik code. Note that instead of using
this approach, more sophisticated algorithms could be used to
generate a more precise call graph. However, the size of the
Android framework codebase (i.e., more than 8M LOC) places
stringent requirements on scalability and performance of the
employed algorithms. Thus, expensive ﬁne-grained analyses can
quickly become prohibitively costly.

Another challenging point is that the Android framework
codebase mixes Dalvik code with components compiled to native
(binary executable) code. In addition, the above-mentioned
technique does not take reﬂective method calls into account
when constructing the call graph. In principle, imprecisions
due to native code or reﬂective calls could affect the results
of our approach. For this reason, we analyzed the prevalence
of these techniques in the Android framework. In particular,
as we will discuss in Section V, we found that the framework
only contains a small number of native or reﬂective method
invocations (36 and 46 respectively). As it is possible to reliably
enumerate these cases, we were able to model these edges
through manual annotations in the resulting call graph.

The

that

remaining aspect

could render our over-
approximation incorrect is related to exceptions. It is well
understood that exceptions are notoriously hard to model
correctly. However, while we would expect malicious
applications to use exceptions to evade detection, we do not
expect the Android framework to use exceptions to implement
the callback mechanism at the focus of our analysis.

Potential Callback Callsites. Deﬁnition 2 deﬁnes frame-
work callbacks. However, to automatically identify callbacks,
the textual description must be translated into a description
that can be checked through automated analysis. Although we
cannot easily translate the precise deﬁnition, we can translate
Deﬁnition 2 into a sequence of automatically checkable necessary
(but not sufﬁcient) properties. Thus, evaluating these properties
on all callsites in the framework will result in a superset of
all framework callbacks (i.e., the set of potential callbacks).

Deﬁnition 4 A potential callback is a framework method that
can be overridden by an application space method. To this end,
a method must satisfy the following necessary conditions:

or protected modiﬁer.

• The method is public or protected.
• The class in which the method is declared has a public
• The method is not ﬁnal or static.
• The class in which the method is declared does not have
• The class in which the method is declared is an interface
or has at least one explicitly or implicitly declared, public
or protected constructor.

the ﬁnal modiﬁer.

The ﬁrst four criteria are necessary so that the speciﬁed
method can be overridden. The ﬁfth criterion states that a
class implementing the callback in application space can be
instantiated.

We perform the evaluation of the above ﬁve properties during
the generation of the call graph to avoid duplication of effort (e.g.,
identifying invoke instructions, consulting the class hierarchy).
The resulting list of callsites constitutes all possible locations
in the framework where a callback can be invoked. Thus, these
are precisely the locations where we start our backwards data
ﬂow analysis to conﬁrm whether the object at a given callsite is
passed to the framework as an argument to a registration method.
Metainformation Collection. To aid the subsequent data
ﬂow analysis, this step extracts additional meta-information
about
the framework. In particular, EDGEMINER extracts
accesses (read and write) to ﬁelds and their corresponding
classes. To this end, EDGEMINER maps each ﬁeld to all its
deﬁnition sites in the framework (i.e., put_field instructions).
Similarly, EDGEMINER maps all ﬁelds to the get_field
instructions that retrieve the value of a given ﬁeld. Because ﬁelds
are deﬁned in classes, we address the challenge of dynamic
subtype polymorphism analogously to the above discussion
in the call graph paragraph. In addition, we incorporate the
insights that methods in an inner class can access private ﬁelds
in the outer class, and methods of a class can access package
private ﬁelds deﬁned by other classes in the same package.

B. Backward Data Flow Analysis

Based on the information extracted by the preprocessing steps,
we now describe how we use our inter-procedural backward data
ﬂow analysis to identify registration-callback pairs. EDGEMINER
starts the analysis at each callsite to a potential callback.
Intuitively, the analysis determines whether the object used at the
callsite originates from application space (i.e., whether the object
is passed to the framework as a method argument). To this end,
the analysis leverages the fact that use-def chains are explicitly
captured in the SSA representation of the framework. Thus, start-
ing at a callsite to a potential callback, the analysis recursively tra-
verses the use-def chains backwards until one of the stopping con-
ditions (discussed in the next paragraph) is met. While traversing
the use-def chains within a method (i.e., intra-procedurally), four
families of instructions can inﬂuence how the analysis proceeds.
• Method Parameter Passing. If the analysis reaches the
beginning of the current method (M) and the use-def chain
references a parameter (P) of M, the analysis consults
the call graph and recursively continues at all callsites
that can invoke M. (Note that we consider the reference
to the this object implicitly passed to every non-static
method, as it were an explicit parameter to method M.)
When continuing at each callsite, the analysis will track
the argument that maps to parameter P in method M.
• Method Call. If the analysis encounters an invoke
instruction (i.e., a method call) while traversing the use-def
chain, it consults the call graph and recursively continues
at the return instruction for all possible callees.
• Field Access. If the analysis encounters a get_field
instruction, the meta-information is consulted. The analysis
continues recursively from all put_field instructions
that deﬁne the speciﬁed ﬁeld (Section IV-A details how

6

least

we address the challenge of polymorphic subtyping for
ﬁeld accesses).
Note how it would be possible, at
in principle,
to use a more precise analysis to handle data ﬂows
through ﬁelds. However, scalability considerations dictate
a tradeoff between precision and analysis target size (the
Android framework codebase has over eight million LOC).
Furthermore, our results indicate that this conservative
choice does not result in prohibitively many false positives.
More precisely, 90% of all ﬁelds accessed through
get_field have at most
three subtype compatible
put_field statements in the entire framework.
• Static Deﬁnitions. Two classes of instructions stop the
processing along the current branch of the recursion. The
ﬁrst one is the new_instance, which creates a new
object of the given type. Similarly, the move_const
family of instructions stores a constant value in the target
operand. These instructions unconditionally overwrite any
previous values stored in the target operand with values
solely determined by the framework. Thus, a use-def chain
that includes such instructions can never link a registration
to a callback method.
Outputting Criteria. Our analysis outputs a registration-
callback pair if a ﬂow is found from the receiving object at a
callback’s callsite to a parameter P of a potential registration. A
potential registration is a method implemented by the framework
that satisﬁes the following two conditions: 1) The method can
be invoked from application space; 2) The class of parameter P
deﬁnes a method that corresponds to a framework callback (i.e.,
the method has a signature that is compatible to a framework
callback).

Stopping Criteria. The recursive backward analysis stops
when one of the two following conditions is met: 1) The analysis
reaches the entry node of a method with no callers (i.e., the
call graph has no incoming edge); 2) As discussed before, the
receiving object of the callback is deﬁned, within the framework,
by a new-instance or a move-const instruction.

Handling Data Flow Loops. For the backward analysis
EDGEMINER unrolls loops once. Note how this choice does
not affect the results of our analysis, as multiple iterations of
the same loop do not inﬂuence the presence of a data ﬂow
from a registration to a callback.

Type Checking. At each step of the backward tracing,
our system checks that the occurring types are compatible.
More precisely, if the type of the object at the callsite where
the backward tracing started is not in a subtype relation with
the operand considered at the current step, this incompatible
operand does not need to be traced further.

C. Discussion on Completeness

EDGEMINER detects registration-callback pairs that are
linked through data ﬂows in Java code. Due to the conservative
nature of our data ﬂow analysis in Java code, we anticipate false
positives but should not observe false negatives. However, false
negatives could still arise from the limitations of our analysis
related to the unsound handling of exceptions. Note that while
malicious applications may use exceptions to evade detection,
we did not ﬁnd the Android framework using exceptions to
implement the callback mechanism.

Another potential source of false negatives is related to the
usage of native code and reﬂective calls. However, as discussed
earlier in this section, this does not pose a problem, as we were
able to manually model these aspects of the Android framework.

D. Results Utility

In this section we discuss how the results of our analysis can
be used by existing static analyzers. Our results (i.e., the pairs
of registration and callback methods) are directly applicable
to improve the generation of Android application control ﬂow
graphs. Note, however, that our deﬁnition of registration method
does not specify how this information should be included in
an application’s control ﬂow graph. In particular, our deﬁnition
does not specify if a callback associated with a given registration
method is invoked immediately (i.e., synchronously), or in a de-
layed (i.e., asynchronous) manner. Similarly, our deﬁnition does
not specify the temporal relation among the detected callbacks.
For example, the aforementioned Collections.sort
example synchronously invokes the Comparator.compare
method. In this (and similar cases), a static analyzer can directly
link the registration to its associated callback in the control
ﬂow graph. However, in the popular setOnClickListener
– onClick registration-callback pair the onClick callback
is only invoked once the user taps the corresponding user
interface element (e.g., button). Existing Android application
analysis systems (e.g., [9]) model asynchronous callbacks by
randomly invoking the callbacks from their manually curated
lists whenever the application is in idle state. While this
approach is intuitive, application analysis systems can leverage
our results in a variety of different ways.

Even if our deﬁnition of ICFT does not mention that a
callback could be invoked in a synchronous or asynchronous
fashion, our analysis is able to differentiate between the two
cases. In particular, if a direct data ﬂow is found between
a registration and a callback, then the ICFT is considered
synchronous. To allow consumers of our results to handle the
identiﬁed callbacks as precisely as possible, each registration-
callback pair in our results is annotated with the category for
that pair. In Section VII-F we demonstrate that our results can
be readily used to improve the precision of FlowDroid [9], the
state-of-the-art Android application analysis framework with
minimal code changes and minimal performance impact.

V.

IMPLEMENTATION

We implemented the approach presented in the previous
section in a system called EDGEMINER. All analysis steps
implemented in EDGEMINER operate on the ROP intermediate
representation (IR). ROP is the IR that Google’s dx compiler
uses internally. dx is developed by Google as part of the
Android Open Source Project (AOSP) [2], and it forms one
of the core components of the Android SDK. In particular, dx
is responsible for translating Java bytecode to Dalvik bytecode.
Thus, every one of the thousands of Android developers
who uses the Android SDK to compile her application uses
dx. Similarly, system images for Android, whether they are
provided by Google, phone manufacturers, or third party
after market versions, are all compiled with dx too. As a
consequence, we are conﬁdent that the dx compiler, and its
ROP intermediate representation are thoroughly battle-tested and

7

reliable. Moreover, as the dx tool performs optimization-related
analyses, its ROP IR is well-suited to perform data ﬂow analysis.
For example, ROP is in SSA form, and most of the information
required for our analysis (e.g., use-def registers for each
instruction) is readily available in the provided data structures.
The backward data ﬂow analysis is implemented as a
recursive procedure. The analysis proceeds backward from each
callsite of a potential callback, and traces the origin of the
object that receives the method call (i.e., the object that actually
provides a concrete implementation of the callback). Intuitively,
this step of the analysis aims to establish whether an object
can ﬂow, through an invocation of a registration method, from
application space to the framework space. In other words, it aims
to understand whether an application can register code within the
framework, which is later called as a consequence. The analysis
works on top of the over-approximation of the call graph built dur-
ing preprocessing, and it consults the meta-information related to
the ﬁelds, as mentioned in the previous section. While recursively
traversing the over approximation of the call graph is straightfor-
ward, we needed to take into consideration a number of additional
aspects, which we describe in the remainder of this section.

Call Graph Construction. As a ﬁrst step, we focus on
method invocations that are performed through the invoke
instruction. Similar to Dalvik, ROP provides an invoke
instruction with the same semantics (i.e., dispatch a method call).
As discussed previously, an over-approximation of the call graph
for regular (i.e., managed) code can be determined with the help
of the class hierarchy. However, the Android framework codebase
has several aspects that need to be taken into account: reﬂective
calls and native code components. Although these mechanisms
are rarely used in the Android framework, they threaten to render
the over-approximation incorrect if not handled appropriately.
We discuss these aspects in the following two paragraphs.

is

to
the

implemented

Reﬂective Calls.

Identically
by

Java,
reﬂection
in Android
reﬂection API.
Reﬂective method calls are exclusively handled by the
java.lang.reflect.Method.invoke API call. By ana-
lyzing the Android framework source code we can reliably detect
all reﬂective method calls based on this method’s signature. Note
how all reﬂection-related calls that lead to a method invocation
must use this interface. Our analysis of the Android framework
codebase revealed 36 invocations of this method. In all cases, it
was possible to determine the target method, as its class name
and method name are hardcoded in the source code. By adding
the corresponding edges to the generated call graph, we preserve
the call graph’s property of being an over-approximation.

Native Code Components. We now describe how we
handled native code in the Android framework. The Android
framework consists of a mix of components authored in Java
(which are then compiled to Dalvik bytecode), and components
authored in a lower-level languages (such as C and C++), which
form the so-called native code components. In the context of
our work, the challenge is that a native code method can invoke
regular methods implemented in the Android framework. This,
in turn, can affect the over-approximation of the call graph. In
fact, as the dx compiler, and thus our analysis, solely considers
Java code, our analysis would miss native method calls which
would render the generated call graph incomplete.

To properly handle this aspect, we investigate how and

8

why native code invokes methods implemented in the managed
Dalvik environment. We found that native code can invoke
regular Android methods only through the dvmCallMethod
(and similar) C++ functions. We manually analyzed the
native code components of
the Android framework, and
identiﬁed 46 callsites where native code calls regular Android
methods. We took all 46 instances into consideration and
augmented the generated call graph accordingly to preserve the
over-approximation. Furthermore, we perform an investigation
to categorize the functionality of these native-to-managed code
calls. Our ﬁndings are summarized by the following list.

provided) is invoked during class loading.

• The <init> and finalize methods of a class are
implicitly invoked upon the execution of a new and
destroy operation, respectively. In particular, after the
native code allocates/releases memory for a new object,
the native code will call the object’s constructor/destructor
(i.e., its <init> and finalize methods).
• A custom implementation of the loadClass method (if
• The Thread.start method invokes the Thread.run
• Network packet arrival is signalled to a private dispatch
• A customized implementation of

the printStack-
Trace, getMessage, and incaughtException
methods (if provided) can be invoked when an exception
is raised.

method of a thread.

method.

Note how two characteristic features of reﬂective and native
calls make this manual assessment possible. First, all
the
occurrences of invocation of reﬂective and native APIs can be
easily enumerated. Second, the number of calls (i.e., 36 and 46
respectively) is small enough to warrant the one-time manual
analysis effort. It is worth noting that, for our analysis, the
important aspect is not the number of native code components
in the Android framework. Instead, we only need to identify
all transition points from native code to managed code. These
observations and ﬁndings give us strong conﬁdence that the
call graph on top of which the data ﬂow analysis step operates
is indeed an over-approximation.

VI. DISCUSSION

In this section, we discuss some aspects of the Android
framework that could affect our analysis. In particular, we
discuss how we handle the fact that callbacks can be (implicitly)
registered through XML conﬁguration ﬁles, and we discuss
the role played by the Android Looper and the Binder IPC
mechanism – two well-known challenges in Andorid analysis.
Callbacks Registered through XML Resources. EDGEM-
INER detects pairs of registration and callback method calls. So
far, we discussed callbacks that are registered explicitly through
registration methods. However, Android applications can also
register callbacks through XML resource ﬁles. For example, a
developer could associate an OnClickListener to a speciﬁc
Button by setting the android:onClick attribute in the as-
sociated layout XML resource ﬁle. These callbacks are implicitly
attributed to their corresponding object (e.g., a user interface
button) when the framework renders the element described by
the resource ﬁle. As this technique of specifying a callback does
not follow the traditional registration-callback pattern, our data

ﬂow analysis would not ﬁnd these registration methods. For
this reason, we conducted a manual investigation on how this
mechanism works, and determined that this feature of specifying
a callback method through XML attributes is only available for
a very limited set of well-documented callbacks. Intuitively,
this makes sense. In fact, for each of these callbacks, the
Android framework codebase must explicitly implement support
for parsing the appropriate XML attribute and invoking, on
behalf of the application, the associated registration method. For
this reason, the developers of the Android framework are fully
aware of each of these special callbacks, and are therefore able to
fully and properly document the usage of each of these callbacks.
Furthermore, we note that existing analysis approaches, such as
FlowDroid [9] or CHEX [23] already handle callbacks deﬁned in
resource ﬁles. In summary, resource ﬁles must precisely deﬁne
the involved callbacks, and, therefore, no additional analysis of
the framework is necessary to support this functionality.

Android Looper. One of the well-known components that,
in principle, makes the analysis of the Android framework
challenging, is the Android Looper. This component is in charge
of processing all the asynchronous events received by the
framework. For example, when the user clicks on a button, the
OnClick event is generated by the framework, and inserted in a
queue. The Android Looper is implemented as an inﬁnite loop
(hence, the term looper) that waits for such events and processes
them as soon as they arrive. The main Looper’s method that
implements this functionality is the handleMessage method,
which acts as a generic dispatcher of events. In particular,
this method dispatches events to their corresponding handlers
according to the value of their msg.what ﬁeld. For the events
for which a callback is deﬁned, the handleMessage method
is in charge of retrieving the correct object (which is stored
in a ﬁeld), and invoking the method corresponding to the event.
In these cases, the object has previously been set (i.e., stored
in the ﬁeld) by means of one of the registration method.

Clearly, the precise modeling of the Looper component is a
challenging task [20]. However, we found that our current data
ﬂow analysis successfully determines registration-callback pairs,
even for those cases where the Android Looper is involved
(e.g., onClick). We now explain why this is the case.

The event message that is received by the Android Looper
only contains information about the event’s type (e.g., OnClick).
The Looper will then parse this message, and, depending on the
event, will retrieve a reference to the object that implements the
callback, which is then invoked. As no code is speciﬁed in the
event itself, the Looper retrieves the reference to the appropriate
object from a ﬁeld (for example, the mOnClickListener
ﬁeld contains the listener for each object that inherits from View).
To make use of a click listener, this ﬁeld must be properly set
by one of the registration methods. The key observation is the
following: the data ﬂow from the registration method to the
callback invocation is through a ﬁeld. Since our analysis already
conservatively handles data ﬂows through ﬁelds, a precise model-
ing of the Looper class is not required to have complete results.
Binder IPC Mechanism. Another well-known aspect of
the Android framework that is known to be challenging to
model
is the Binder IPC mechanism. The Binder is used
both for communicating within the same application, and to
communicate between distinct apps.

To understand to which extent this component interferes
with our analysis, we manually investigated how Binder is used
by the Android framework. We determined that Binder can
cause a set of callbacks to be implicitly invoked. Unsurprisingly,
these callbacks are all related to intra- and inter-application
communication, and are related to the life-cycle of application
components. For example, when an Activity A invokes the
startActivity method to start Activity B, a Binder IPC
transaction is generated and, as a consequence, B’s methods
related to its life-cycle (such as onCreate, onStart, etc.)
are implicitly invoked. Since these ﬂows do not follow the
usual registration-callback pattern, our data ﬂow analysis does
not detect this kind of implicit control ﬂow transfers.

However, while, ideally, a more sophisticated analysis could
be performed to detect this category of edges, we believe this
is not necessary. In fact, we found that these implicit transfers
are all related to the application’s life-cycle. State-of-the-art
static analysis tools, such as FlowDroid [9], already model
the application life cycle based on the thorough Android
documentation [3], which precisely deﬁnes the state machine that
prescribes an application’s life cycle and all involved callbacks.
In summary, we believe that this aspect of the framework is
already properly modeled by existing state-of-the-art systems,
and that a manual effort is enough, as the number of these
callbacks is limited and well-documented. In other words, even
if we do not model the inherently dynamic parts of the Binder,
we believe this aspect does not threaten the completeness of
the registration-callback pairs our analysis discovers.

Temporal Relationship between Different Callbacks.
One thing worth noticing is that EDGEMINER captures data
ﬂows between registrations and callbacks, but it is currently
not capable of extracting the temporal relationship among
callbacks belonging to the same registration method. For
example, for the AsyncTask object, EDGEMINER correctly
identiﬁes eight callbacks (such as onPreExecute() and
doInBackground()), but it does not extract the temporal
ordering between them. In other words, our analysis does not
establish that onPreExecute() is always executed before
doInBackground(). Automatically extracting this temporal
aspect, while an interesting avenue for future work, is outside
the scope of this work.

VII. EVALUATION

In this section we discuss and analyze the results we
obtained by evaluating our implementation of EDGEMINER.
First, in Section VII-A, we describe the experimental setup.
Then, in Section VII-B, we present an overview of the results
we obtained by running EDGEMINER on three different versions
of the Android framework. In Section VII-C we present several
insights related to the registration-callback pairs we found.
Next, we evaluate EDGEMINER’s performance (Section VII-D)
and accuracy (Section VII-E). In Section VII-F, we present
a case study where we demonstrate how our results can be
used to improve FlowDroid [9], a state-of-the-art static analyzer
for Android applications. In particular, we ﬁrst show how
incomplete support of ICFTs leads to undetected malicious
functionality (i.e.,
false negatives). Then, we show how
FlowDroid can be easily extended to incorporate the results that
EDGEMINER generates, to detect the malicious functionality
that leverages ICFTs. Finally, in Section VII-G, we discuss how

9

callback methods fall into this category. In total, our results con-
tain 672 pairs that satisfy this naming convention. As expected,
all setOn-Listener methods implemented in the framework are
detected by EDGEMINER as registration methods. Note how
existing approaches heuristically identify callbacks based on such
naming conventions. This experiment shows that these heuristics
lead to vastly incomplete results, as the number of pairs that
conform to this naming convention is several orders of magnitude
smaller than the number of pairs found by EDGEMINER.

D. Performance Evaluation

We evaluated EDGEMINER on a quad core 2.80GHz Intel(R)
Xeon(R) X5560 CPU and 36GB of memory. To analyze Android
4.2, the system requires 8GB of memory to load the intermediate
representation of the whole Android framework, and it then
requires 4GB of additional memory to compute the framework
call graph and perform the backward data ﬂow analysis.
In
total
this framework version contains 24,089 classes and
196,252 methods. Furthermore, the resulting call graph contains
161,229 vertices and 4,519,965 edges. The analysis of the entire
Android framework completes in under 4 hours. Note that a
speciﬁc version of the Android framework remains invariant for
all applications running on top of it. Thus, EDGEMINER only
needs to be run once per Android version, as the generated
results, too, remain valid for that framework version.

E. Accuracy Evaluation

One key challenge of our work is to evaluate the correctness
of our ﬁndings. Since, to the best of our knowledge, we are the
ﬁrst to systematically approach the challenge of implicit control
ﬂow transitions in Android, we lack authoritative ground truth
to compare our results against. Moreover, the large number of
registration-callback pairs found by EDGEMINER renders the
manual analysis of all results impractical. Thus, we discuss in
this section how we assessed false positives and false negatives
among our results.
False Positives. To estimate false positives, we performed
manual analysis of a random sample of 200 detected
registration-callback pairs. For each of these 200 pairs returned
by EDGEMINER, we manually veriﬁed whether it was possible
to register a given callback through an invocation of its
associated registration method. We found that 192 pairs out
of 200 are indeed true positives. That is, for 96% of the pairs,
it was possible to register a given callback by invoking its
associated registration method. In the remaining eight cases
(i.e., 4%) manual analysis did not conﬁrm the ﬁndings of
EDGEMINER. We consider these eight samples false positives.

To increase conﬁdence in our manual assessment, we
chose 10 registration-callback pairs and embedded each in a
distinct toy Android application. Executing the application in
the Android emulator revealed that all callbacks are implicitly
invoked by the framework as expected. We limited this analysis
to 10 pairs, as the manual effort to satisfy all requirements to
trigger the callback can be signiﬁcant. The reason is that many
classes that provide callbacks implement interfaces or extend
abstract classes. This implies that the developer must provide
implementations for additional methods that are not directly
related to the callback functionality.

We also manually investigated the source of the false
positives. We determined that all eight false positives are because
our analysis is based on an over-approximation of the call graph.
This is expected, as the algorithms and data structures used
by EDGEMINER are designed conservatively to strictly favor
false positives over false negatives. However, we acknowledge
that a more precise call graph that still maintains the over-
approximation property could help reduce false positives further.
Originally, we anticipated containers (e.g., sets, maps,
etc.) to be a source for false positives. In fact, containers are
well-known to pose signiﬁcant challenges for static analysis.
Interestingly, a detailed analysis of our results revealed that
no containers are used in any of the data ﬂows that connect
registrations to callbacks. At ﬁrst, this was surprising, as we
expected the Android framework to coalesce a variety of
callbacks in container data structures. However, an analysis
of the framework revealed that callbacks are rather directly
attributed to the speciﬁc element they operate on. For example,
the OnClickListener object implementing an onClick
callback is stored in a dedicated ﬁeld for the View class.
False Negatives. In this section we describe how we evaluated
EDGEMINER for false negatives. In particular, we try to
answer the following question: Does EDGEMINER detect all
registration-callback pairs? As we lack authoritative ground
truth, answering this question conclusively is challenging.

Thus, for this evaluation, we designed an experiment based
on dynamic analysis. Dynamic analysis has the advantage that
the gained results are precise. That is, every ICFT identiﬁed
dynamically, is guaranteed to be correct and witnessed by the
application that produced it. However, the disadvantage of
limited coverage implies that dynamic analysis results are also
incomplete. Nonetheless, our conﬁdence in EDGEMINER rises
if we can show that a large-scale dynamic analysis experiment
with real-world Android applications does not result in any
ICFTs that EDGEMINER did not detect.

To dynamically extract ICFTs used by an application, we
instrumented the Dalvik virtual machine to output a detailed
execution trace of all the methods that are invoked during the
execution of a given application. These traces contain information
about the called methods, as well as the arguments and return
values. Similar to our approach described in Section IV, we
label potential registrations and potential callbacks. Note that,
in a dynamic analysis setting, it is trivial to precisely label
method calls that cross the application-framework boundary.

We identify an ICFT in a dynamic trace if and only if:
1) A potential callback (i.e., method implemented in application
space) is directly invoked by the framework, and 2) the object
implementing the callback was passed to the framework in a
previous registration call. We collected the execution traces for
8,195 randomly selected real-world Android applications by
running each in an Android emulator for 120 seconds. During
this time, we simulated user interaction with the help of The
Monkey [5]. Analyzing the resulting execution traces revealed
6,906 distinct registration-callback pairs.

We then compared this dynamically-generated list of pairs
against the pairs extracted by EDGEMINER: All pairs that we
found dynamically were already included in EDGEMINER’s out-
put. In other words, according to this experiment, our approach
is not affected by false negatives. Although we acknowledge

11

that this is not a conclusive answer to the above stated question,
this experiment instills signiﬁcant conﬁdence in EDGEMINER’s
results, especially because this experiment has been conducted
completely independently from the backward data ﬂow analysis.
Moreover, this is not surprising as EDGEMINER is designed
to produce one-sided errors (i.e., false positives) only.

An additional interesting aspect of this experiment is that
the 8,195 applications we dynamically made use of only 6,906
distinct registration-callback pairs, out of the more than ﬁve
million identiﬁed by EDGEMINER. This is due to the fact the vast
majority of ICFTs identiﬁed by our approach are not documented,
and, as a consequence, benign apps are likely not to use them.
However, such non-documented ICFTs could be easily used by
malicious applications for evasive purposes. For this reason, it
is important that static analysis tools take all the ICFTs detected
by EDGEMINER into account, even if only a small subset of
them is actually used by real-world, benign applications.

F. Case Study - FlowDroid

EDGEMINER is motivated by the observation that existing
static Android application analysis systems do not address the
challenge of implicit control ﬂow transitions systematically.
Thus, the success of our work can be judged by the suitability
of the results to improve existing analysis systems. To this end,
we conducted the following case study.

FlowDroid [9] is an open source, static Android application
analysis framework. The system performs static taint analysis
of off-the-shelf Android applications to identify leaks of
privacy sensitive information. The same authors also released
DroidBench [4], a suite of benchmark applications to evaluate
static Android analysis systems, especially those that perform
data ﬂow analysis.

In a ﬁrst step of this case study, we extended the DroidBench
benchmark suite with six additional sample applications: Three
applications use asynchronous pairs to leak privacy sensitive
information (e.g., GPS positional information) to the network,
while the remaining three samples achieve the same goal by
using synchronous registration-callback pairs (e.g., the pair of
Collection.sort and Comparator.compare). Once
we veriﬁed that the sample applications correctly transmit the
sensitive information, we evaluated whether FlowDroid could
detect the privacy leaks in any of these samples. Unsurprisingly,
FlowDroid did not detect any privacy leaks.

As a second step of this case study, we show how existing
static analysis tools would directly beneﬁt from our results. In par-
ticular, this study has two goals: we show that FlowDroid fails to
detect the privacy leak because of its incomplete modeling of the
callback mechanism; we show how our results can be used from
a practical point of view. We ﬁrst investigated how FlowDroid
supports the callback mechanism. In particular, FlowDroid ships
with a conﬁguration ﬁle (called AndroidCallbacks.txt)
that holds a list of 181 callbacks. We veriﬁed that EDGEMINER
automatically found all 181 callbacks. This further reinforces
our belief that EDGEMINER is not affected by false negatives.
Table II presents a breakdown of the 181 callbacks used in
FlowDroid with respect to common naming patterns. The table
also shows the number of callbacks identiﬁed by EDGEMINER
for the same patterns. This indicates, once again, that manual

Pattern

*Listener*

*Callback*

*On*

None of the above

Total

# FlowDroid

# EDGEMINER

155

19

3

4

181

576

319

509

18,243

19,647

TABLE II: Patterns of callbacks used by FlowDroid and identiﬁed by
EDGEMINER

Furthermore, we noticed two additional

or heuristic approaches to identify and handle callbacks are
insufﬁcient. In the remainder of this section, we describe how
we integrated our ﬁndings with FlowDroid.
Integration of Asynchronous Callbacks. Augmenting
FlowDroid with the information about asynchronous callbacks
was straightforward, as it did not require any source code
modiﬁcation. We only needed to append the 19,647 callbacks
identiﬁed by EDGEMINER to FlowDroid’s conﬁguration ﬁle. We
then analyze the three applications that leak sensitive information
through an asynchronous callback. With our modiﬁcations,
FlowDroid successfully identiﬁed privacy leaks in all three appli-
cations. This clearly shows that the missing detection was indeed
caused by the incomplete modeling of the callback mechanism.
imprecisions
in FlowDroid’s modeling of the callback mechanism. First,
FlowDroid invokes callbacks regardless of whether a previous
registration occurred or not.
In other words, FlowDroid
will incorrectly analyze a callback (e.g., onClick), if it is
implemented by an application but never registered with the
framework. Second, FlowDroid exclusively relies on the method
name to match callbacks to entries in the conﬁguration ﬁle. These
imprecisions can lead to false positives, as well as false negatives.
We note that EDGEMINER outputs the pairs of registration and
callback methods along with their type signatures, making a
more precise handling of the callback mechanism possible. In
summary, FlowDroid could prevent false negatives resulting
from ICFTs, and reduce false positives by taking the additional
information of the registration method into account.
Integration of Synchronous Callbacks. Once synchronous
callbacks are identiﬁed with the help of EDGEMINER, integrating
them with FlowDroid is straight forward. It is sufﬁcient to
augment the call graph of an application with a new edge for
each registration and callback pair detected by EDGEMINER.
To this end, we modiﬁed FlowDroid’s source code in two ways.
First, we add a routine at the beginning of the analysis that
parses the registration-callback pairs extracted by EDGEMINER
into a map data structure. This functionality was implemented by
adding 36 lines of code to the FlowDroid codebase. The second
modiﬁcation augments the call graph generated by FlowDroid
with the corresponding edges identiﬁed by EDGEMINER. More
precisely, the call graph is traversed and for each callsite that
is compatible with the invocation of a registration method, we
add an additional edge to the corresponding callback method.
This functionality is implemented with 28 lines of code.

We then used this modiﬁed version of FlowDroid to
analyze our benchmark applications that evade detection by the
unmodiﬁed FlowDroid through the use of synchronous ICFTs.

12

apps, does not imply that the statically-identiﬁed privacy leaks
are false positives. Because of its dynamic nature, TaintDroid
also suffers from limited coverage. With advanced dynamic
testing based approaches achieving roughly 33% coverage [27],
it is possible and even likely that the corresponding privacy leak
was not triggered in this experiment. In summary, we showed
how the incomplete handling for ICFTs is the root cause of false
negatives when detecting privacy leaks in real-world applications.
As another interesting data point, note how the absolute number
of detected privacy leaks increased by roughly 10% (from 46,586
to 51,418) after we integrated EDGEMINER’s results.

Finally, we measured the impact of our work on the
performance of FlowDroid. We found that, on average, our
modiﬁcation requires 34.7 seconds to load EDGEMINER’s results
in the map data structure on startup. As this step simply parses
a conﬁguration ﬁle (that is invariant from the application to be
analyzed), the cost of this step can be amortized by loading
the data only once when processing multiple applications. We
also measured how the analysis time changed as a result of
augmenting the call graph generated by FlowDroid. We found
that the modiﬁed version of FlowDroid is 1.85% (± 0.3%) slower
than the original unmodiﬁed version. This clearly shows how the
overhead introduced by augmenting FlowDroid with information
related to ICFTs is negligible. Furthermore, this corroborates
the intuition that, even if the number of pairs we found is really
high, real-world applications only use a small number of them.

VIII. RELATED WORK

In this section we discuss scientiﬁc publications that are
related to our work. Most relevant are the works that aim to
summarize different aspects of the Android framework and
other platforms, such as the Java framework. Furthermore, we
discuss works that apply static analysis techniques to analyze
Android applications.
Automatic Extraction of Library Summaries. Recent works
in Android security proposed approaches to summarize certain
aspects of the Android framework. Felt et al. [16] develop
Stowaway, where the authors aim to extract a mapping between
Android APIs and the permissions they require to be executed.
In their work, the authors use an approach based on dynamic
analysis to extract these mappings, and they then use the results
to discover over privileged applications. Au et al. developed
PScout [10] to achieve the same goal, by applying static
analysis techniques (e.g., reachability analysis) to the Android
framework codebase. More recently, Rasthofer et al. developed
SuSi [26], a tool that analyzes the Android framework codebase
to automatically identify sources and sinks in the Android
framework. In particular, they use a combination of machine
learning and static analysis techniques.

Other works that relate to ours are those that applied similar
techniques to the codebase of other libraries, such as the JDK
library, or the Scala standard libraries. For example, Yan et
al. [28] use the SOOT [22] framework to analyze JDK library
for alias analysis, while Probst [25] developed a tool to extract a
summary of the control ﬂow graphs of the JDK library. Similarly
to our work, Zhang et al. [29] perform static analysis on the
Java standard library to model callbacks. However, their work is
limited to handling synchronous callbacks, while asynchronous
callbacks are ignored. As shown in Figure 2 of Section II, there

is no direct path in the call graph from the registration method
(setOnClickListener())
to its associated callback
method (onClick()). In fact, in the case of asynchronous
callbacks, the ﬂow is implemented via assignments to internal
ﬁelds. Such ﬂows are not considered by Zhang et al. [29].
Thus, their approach cannot handle asynchronous callbacks
implemented by ﬁelds. Furthermore, Zhang et al. only match
type signatures of callbacks and disregard the data ﬂow
dependency between registration and callback, which can lead
to a signiﬁcant number of false positives.

Our work is complementary to all these works. In fact,
while we share the same of goal of summarizing the Android
framework (or a different
library) to allow existing static
analysis tools to perform a better analysis, we focused on a
completely different security-related problem – the modeling of
implicit control ﬂow transitions through the Android framework.
Approximation of Libraries. Researchers also propose
approaches to over-approximate the call graph of an application
without considering the library code. Ali et al. [7] construct a
partial call graph of a Java application that over-approximates the
set of targets of every call site in the analysis scope. Similarly,
Madsen et al. [24] combine pointer analysis and use analysis
to over-approximate the call graph of a JavaScript applications.
Instead of considering all methods of a class a viable
callback, EDGEMINER leverages conservative data ﬂow analysis
to narrow down the set of possible callbacks. For example, in
our motivating example of Figure 1, EDGEMINER precisely
identiﬁes that only compare is invoked implicitly when sort
is called. Instead, previous solutions that over-approximate
without taking framework information into account will wrongly
consider all possible methods of the object mal, such as
toString, as potential callbacks.
Static Analysis on Android Applications. Enck et al. develop
ded [14], a tool that retargets Dalvik bytecode to Java bytecode,
they decompile Android applications into source code, and
they then use commercial off-the-shelf control-ﬂow and data
ﬂow analysis to ﬁnd mis-use of phone or personal identiﬁers
and establish the prevalence of advertising networks among
Android applications. Several other works apply a combination
of techniques based on static analysis, machine learning, and
heuristics to detect malicious Android applications [8, 15, 19, 31].
Jeon et al. [21] propose ReﬁneDroid, a static analysis tool to
infer the ﬁne-grained permissions suitable for existing Android
applications, and then enforcing them without affecting the
applications’ original functionality. Others have applied static
analysis techniques to discover vulnerabilities in Android appli-
cations. For example, Zhou et al. [30] developed ContentScope
to automatically ﬁnd content leak vulnerabilities, while Grace
et al. [18] developed Woodpecker, to ﬁnd capability leaks.

Finally, FlowDroid [9] leverages on-demand algorithms to
perform static taint analysis on Android applications. The goal
of FlowDroid is to identify applications that incidentally or
maliciously leak privacy sensitive information. FlowDroid’s
website states that FlowDroid “needs a complete modeling
of Android’s callbacks”. While the conﬁguration distributed
with FlowDroid is not comprehensive, the conservative analysis
employed by EDGEMINER identiﬁes all callback and registration
pairs in the Android framework. The results of EDGEMINER
can be directly used by the above-mentioned analysis systems

14

to create more precise Android application control ﬂow graphs.

IX. CONCLUSION

In this paper, we designed and implemented a novel analysis
tool, called EDGEMINER, that automatically generates API sum-
maries describing implicit control ﬂow transitions through the
Android framework. Our approach works by statically analyzing
the Android framework codebase. In particular, EDGEMINER
performs inter-procedural backward data ﬂow analysis to extract
a list of registration-callback pairs throughout the framework.
We evaluate EDGEMINER on several versions of the Android
framework, and we automatically reconstructed several million
implicit control ﬂow transitions. Moreover, we show how these
implicit transitions can be used by malicious applications to
evade static analysis tools, including FlowDroid – a state-of-the-
art static analysis tool for Android applications. Our evaluation
demonstrates how existing analysis tools can easily take
advantage of our results to increase their precision and eradicate
ICFTs as the root cause for a whole class of false negatives.
Finally, in the spirit of open science we make our results and
implementation available online at http://edgeminer.org.

ACKNOWLEDGEMENTS

We thank the anonymous reviewers and our shepherd Heng
Yin for their valuable feedback. The work is supported by
National Science Foundation (NSF) under grant CNS-1408790.
This work is also sponsored by DARPA under agreement
number FA8750-12-2-0101. The U.S. Government is authorized
to reproduce and distribute reprints for Governmental purposes
notwithstanding any copyright notation thereon. The views
and conclusions contained herein are those of the authors and
should not be interpreted as necessarily representing the ofﬁcial
policies or endorsements, either expressed or implied, of NSF,
DARPA, or the U.S. Government.

REFERENCES

[1] Android-apktool: a tool for reverse engineering Android APK ﬁles. https:

//code.google.com/p/android-apktool/.

[2] Android Open Source Project (AOSP). https://source.android.com/.
[3] Documentation related to the Activity component. http://developer.android.

com/reference/android/app/Activity.html.

[4] DroidBench. http://sseblog.ec-spride.de/tools/droidbench/.
[5] UI/Application Exerciser Monkey. http://developer.android.com/tools/

help/monkey.html.

[6] Worldwide Smartphone Shipments Top One Billion Units for the First

Time. https://www.idc.com/getdoc.jsp?containerId=prUS24645514.

[7] K. Ali and O. Lhot´ak. Application-Only Call Graph Construction.
In Proceedings of the 26th European Conference on Object-Oriented
Programming (ECOOP), 2012.

[8] D. Arp, M. Spreitzenbarth, M. Hubner, H. Gascon, and K. Rieck. Drebin:
Effective and Explainable Detection of Android Malware in Your Pocket.
In Proceedings of the Annual Symposium on Network and Distributed
System Security (NDSS), 2014.

[9] S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel, J. Klein, Y. le Traon,
D. Octeau, and P. McDaniel. FlowDroid: Precise Context, Flow, Field,
Object-sensitive and Lifecycle-aware Taint Analysis for Android Apps. In
Proceedings of the Annual ACM SIGPLAN Conference on Programming
Language Design and Implementation (PLDI), 2014.

[10] K. W. Y. Au, Y. F. Zhou, Z. Huang, and D. Lie. PScout: analyzing the
Android permission speciﬁcation. In Proceedings of the ACM Conference
on Computer and Communications Security (CCS), 2012.

[11] P. P. Chan, L. C. Hui, and S. M. Yiu. DroidChecker: Analyzing Android
Applications for Capability Leak. In Proceedings of the ACM Conference
on Security and Privacy in Wireless and Mobile Networks (WISEC), 2012.

15

[12] R. Cytron, J. Ferrante, B. K. Rosen, M. N. Wegman, and F. K. Zadeck.
Efﬁciently Computing Static Single Assignment Form and the Control
Dependence Graph. ACM Trans. Program. Lang. Syst., 13(4):451–490,
Oct. 1991.

[13] W. Enck, P. Gilbert, B.-G. Chun, L. P. Cox, J. Jung, P. McDaniel, and A. N.
Sheth. TaintDroid: an Information-Flow Tracking System for Realtime
Privacy Monitoring on Smartphones. In Proceedings of the USENIX Con-
ference on Operating Systems Design and Implementation (OSDI), 2010.
[14] W. Enck, D. Octeau, P. McDaniel, and S. Chaudhuri. A Study of
Android Application Security. In Proceedings of the USENIX Security
Symposium, 2011.

[15] W. Enck, M. Ongtang, and P. McDaniel. On Lightweight Mobile Phone
In Proceedings of the ACM Conference on

Application Certiﬁcation.
Computer and Communications Security (CCS), 2009.

[16] A. P. Felt, E. Chin, S. Hanna, D. Song, and D. Wagner. Android
In Proceedings of the ACM Conference on

permissions demystiﬁed.
Computer and Communications Security (CCS), 2011.

[17] A. P. Fuchs, A. Chaudhuri, and J. S. Foster. SCanDroid: Automated
Technical Report,

Security Certiﬁcation of Android Applications.
University of Maryland, 2009.

[18] M. Grace, Y. Zhou, Z. Wang, and X. Jiang. Systematic Detection of Capa-
bility Leaks in Stock Android Smartphones. In Proceedings of the Annual
Symposium on Network and Distributed System Security (NDSS), 2012.
[19] M. Grace, Y. Zhou, Q. Zhang, S. Zou, and X. Jiang. RiskRanker: Scalable
In Proceedings
and Accurate Zero-day Android Malware Detection.
of the International Conference on Mobile Systems, Applications, and
Services (MobiSys), 2012.

[21]

[20] C.-H. Hsiao, C. L. Pereira, J. Yu, G. a. Pokam, S. Narayanasamy, P. M.
Chen, Z. Kong, and J. Flinn. Race Detection for Event-Driven Mobile
In Proceedings of the ACM SIGPLAN Conference on
Applications.
Programming Language Design and Implementation (PLDI), 2014.
J. Jeon, K. K. Micinski, J. A. Vaughan, A. Fogel, N. Reddy, J. S. Foster,
and T. Millstein. Dr. Android and Mr. Hide: Fine-Grained Permissions
in Android Applications. In In Proceedings of The ACM Workshop on
Security and Privacy in Smartphones and Mobile Devices (SPSM), 2012.
[22] P. Lam, E. Bodden, O. Lhot´ak, and L. Hendren. The Soot Framework for
Java Program Analysis: a Retrospective. In Cetus Users and Compiler
Infrastructure Workshop, 2011.

[23] L. Lu, Z. Li, Z. Wu, W. Lee, and G. Jiang. CHEX: Statically Vetting An-
droid Apps for Component Hijacking Vulnerabilities. In Proceedings of the
ACM Conference on Computer and Communications Security (CCS), 2012.
[24] M. Madsen, B. Livshits, and M. Fanning. Practical Static Analysis of
JavaScript Applications in the Presence of Frameworks and Libraries. In
Proceedings of the 2013 9th Joint Meeting on Foundations of Software
Engineering (ESEC/FSE), 2013.

[25] C. W. Probst. Modular Control Flow Analysis for Libraries. In Proceedings

of the International Symposium on Static Analysis (SAS), 2002.

[26] S. Rasthofer, S. Arzt, and E. Bodden. A Machine-learning Approach for
Classifying and Categorizing Android Sources and Sinks. In Proceedings
of the Annual Symposium on Network and Distributed System Security
Symposium (NDSS), 2014.

[27] V. Rastogi, Y. Chen, and W. Enck. AppsPlayground: Automatic Security
In Proceedings of the ACM
Analysis of Smartphone Applications.
Conference on Data and Application Security and Privacy (CODASPY),
pages 209–220, New York, NY, USA, 2013. ACM.

[28] D. Yan, G. Xu, and A. Rountev. Rethinking Soot for Summary-Based
the ACM SIGPLAN
Whole-Program Analysis.
International Workshop on State of the Art in Java Program Analysis
(SOAP), 2012.

In Proceedings of

[29] W. Zhang and B. G. Ryder. Constructing Accurate Application Call
Graphs For Java To Model Library Callbacks. In the IEEE International
Workshop on Source Code Analysis and Manipulation (SCAM), 2006.
[30] Y. Zhou and X. Jiang. Detecting Passive Content Leaks and Pollution
in Android Applications. In Proceedings of the Annual Symposium on
Network and Distributed System Security (NDSS), 2013.

[31] Y. Zhou, Z. Wang, W. Zhou, and X. Jiang. Hey, You, Get Off of My
Market: Detecting Malicious Apps in Ofﬁcial and Alternative Android
In Proceedings of the Annual Symposium on Network and
Markets.
Distributed System Security (NDSS), 2012.

