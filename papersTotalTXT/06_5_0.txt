NSEC5: Provably Preventing
DNSSEC Zone Enumeration

Sharon Goldberg∗, Moni Naor†, Dimitrios Papadopoulos∗, Leonid Reyzin∗, Sachin Vasant∗ and Asaf Ziv†

∗Boston University, Department of Computer Science

Email: {goldbe,dipapado,reyzin,sachinv}@cs.bu.edu

†Weizmann Institute of Science, Department of Computer Science and Applied Mathematics

Email:{moni.naor,asaf.ziv}@weizmann.ac.il

Abstract—We use cryptographic techniques to study zone enu-
meration in DNSSEC. DNSSEC is designed to prevent attackers
from tampering with domain name system (DNS) messages. The
cryptographic machinery used in DNSSEC, however, also creates
a new vulnerability, zone enumeration, enabling an adversary
to use a small number of online DNSSEC queries combined
with ofﬂine dictionary attacks to learn which domain names are
present or absent in a DNS zone.

We prove that the current DNSSEC standard, with NSEC
and NSEC3 records, inherently suffers from zone enumeration:
speciﬁcally, we show that security against (1) attackers that
tamper with DNS messages and (2) privacy against zone enu-
meration cannot be satisﬁed simultaneously, unless the DNSSEC
nameserver performs online public-key cryptographic operations.
We then propose a new construction that uses online public-
key cryptography to solve the problem of DNSSEC zone enu-
meration. NSEC5 can be thought of as a variant of NSEC3, in
which the unkeyed hash function is replaced with a deterministic
RSA-based keyed hashing scheme. With NSEC5, a zone remains
protected against network attackers and compromised name-
servers even if the secret NSEC5-hashing key is compromised;
leaking the NSEC5-hashing key only harms privacy against zone
enumeration, effectively downgrading the security of NSEC5 back
to that of the current DNSSEC standard (with NSEC3).

I.

INTRODUCTION

DNSSEC was introduced in the late 1990s to protect the
Domain Name System (DNS) from network attacks. With
DNSSEC, the response to a DNS query is authenticated with a
digital signature; in this way, the resolver that issues the DNS
query (“What is the IP address for www.example.com?”)
can be certain that the response (“155.41.24.251”) was sent
by the authoritative nameserver, rather than an arbitrary at-
tacker. The road to DNSSEC deployment has been rocky,
and a variety of technical
issues have forced the Internet
community to rewrite the DNSSEC standard several times.
One of the most interesting of these issues is the problem
of zone enumeration [2], [9], [11]. Zone enumeration allows

Permission to freely reproduce all or part of this paper for noncommercial
purposes is granted provided that copies bear this notice and the full citation
on the ﬁrst page. Reproduction for commercial purposes is strictly prohibited
without the prior written consent of the Internet Society, the ﬁrst-named author
(for reproduction of an entire paper only), and the author’s employer if the
paper was prepared within the scope of employment.
NDSS ’15, 8-11 February 2015, San Diego, CA, USA
Copyright 2015 Internet Society, ISBN 1-891562-38-X
http://dx.doi.org/10.14722/ndss.2015.23211

an adversary to learn the IP addresses of all hosts in a zone
(including routers and other devices), creating a toehold from
which it can launch more complex attacks. While a number
of standards (RFC 4470 [43], RFC 5155 [27]) have tried to
ﬁx the zone enumeration problem, a complete solution to the
problem has remained mysteriously elusive. In this paper, we
use cryptographic lower bounds to explain why all previous
techniques based on hashing failed to solve the problem.
Our result shows that achieving privacy guarantees in this
setting (while preserving the security properties of DNSSEC)
necessitates the use of public-key cryptographic operations in
the online phase of the protocol. Moreover, we present NSEC5,
a new cryptographic construction that solves the problem of
zone enumeration while remaining faithful to the operational
realities of DNSSEC.

A. DNSSEC.

For the purpose of understanding the zone enumeration
problem, we can partition the functionalities of DNSSEC into
two distinct parts. The ﬁrst is to provide an authenticated
positive response to a DNS query. (For example, query:
“What is the IP address for www.example.com?”; answer:
“www.example.com is at 155.41.24.251.”)

to provide

second is

The
existence, when

of
available.
address
“aWa2j3.example.com is
DNSSEC deals with these functionalities in different ways.

no
example,
aWa2j3.example.com?”;
non-existent

response
query:

to
“What

an authenticated denial
is
query
IP
the
answer:
domain.”)

the

is

(For
for

a

For positive responses, the authoritative nameserver for
the zone (i.e., the nameserver that is authorized to answer
DNS queries for domains ending in example.com) keeps
a ﬁnite set R of signed resource records; each record contains
a mapping from one domain name to its IP address(es) and is
signed by the zone’s secret keys. Importantly, these signatures
need not be computed online in response to live DNS queries,
but instead are precomputed ahead of time and stored at the
nameserver. This has the twin advantages of (1) reducing the
computational
the nameserver, and (2) eliminating
the need to trust
the nameserver (since it need not store
the zone signing key). This second advantage is especially
important because most zones have more than one authoritative
nameserver, and some nameservers might even be operated by
entirely different organizations than the one that administers

load at

the zone1. In what follows, we will use the term primary
nameserver (or simply primary) to describe nameservers that
are trusted, and secondary nameservers (or simply secondary)
to describe those that are not.

B. The DNSSEC Zone Enumeration Problem

The zone enumeration problem becomes an issue when
we consider DNSSEC negative responses. The trivial idea of
responding to every query for a non-existent domain with the
precomputed signed message “Non-existent domain” opens the
system up to replay attacks. Another trivial idea of precom-
puting signed responses of the form “
is a non-existent
domain” also fails, since the number of possible queries that
deserve such a response is inﬁnite, making precomputation of
signed responses infeasible. Instead, RFC4034 [5] provided a
solution for precomputed denial-of-existence, by deﬁning the
NSEC record as follows: a lexicographic ordering of the names
present in a zone is prepared, and every consecutive pair of
names is signed; each pair of names is an NSEC record. Then,
to prove the non-existence of a name (x.example.com),
the nameserver returns the precomputed NSEC record for
the pair of existent names that are lexicographically be-
fore and after the non-existent name (w.example.com and
z.example.com), as well as its associated DNSSEC sig-
natures. 2 While this solution elegantly eliminates the need to
trust the nameserver and allows for precomputation, it unfortu-
nately allows for trivial zone enumeration attacks; namely, an
adversary can use NSEC records to enumerate all the domain
names present in the zone.

Why is zone enumeration a problem? This question has
created some controversy, with many in the DNS community
initially arguing that it is actually not a problem (e.g., RFC
4033 [3]), before eventually arriving at consensus that it is a
problem for some zones (RFC 5155 [27]). Zone enumeration
allows an adversary to learn the IP addresses of all hosts in
a zone (including routers and other devices); this information
can then be used to launch more complex attacks, some of
which are mentioned in RFC 5155:

[T]he NSEC RR ... introduces a side-effect in that the
contents of a zone can be enumerated. This property
introduces undesired policy issues. ... An enumerated
zone can be used, for example, as a source of
probable e-mail addresses for spam, or as a key for
multiple WHOIS queries to reveal registrant data that
many registries may have legal obligations to protect.
Many registries therefore prohibit the copying of
their zone data; however, the use of NSEC RRs
renders these policies unenforceable.

Indeed, some zones (e.g., .de, .uk) require protection against
zone enumeration in order to comply with European data
protection laws [39], [1, pg. 37].

Thus, RFC 5155 [27] suggested NSEC3, a precomputed
denial of existence technique, designed to make zone enumer-

1For example,

the zone umich.edu has

two authoritative name-
servers run by the University of Michigan (dns1.itd.umich.edu and
dns2.itd.umich.edu) and one run by the University of Wisconsin
(dns.cs.wisc.edu) [37].

2For simplicity of exposition, we ignore the issues of wildcard records and

enclosers in our descriptions of NSEC and NSEC3; see RFC 7129 [22].

ation more difﬁcult. With NSEC3, each domain name present
in a zone is cryptographically hashed, and then all the hash
values are lexicographically ordered. Every consecutive pair of
hashes is an NSEC3 record, and is signed by the authority for
the zone. To prove the non-existence of a name, the nameserver
returns the precomputed NSEC3 record (and the associated
DNSSEC signatures) for the pair of hashes lexicographically
before and after the hash of the non-existent name.3

While hashing does make zone enumeration more difﬁcult,
NSEC3 is still vulnerable to zone enumeration via ofﬂine
dictionary attacks. An adversary can query several random
non-existent names, obtain a number of NSEC3 records, and
then use rainbow tables or other ofﬂine dictionary attacks
(for hash cracking) to determine the names that are present
in the zone from the hashes in the NSEC3 records. Indeed,
Bernstein’s nsec3walker tool [11] does just that, effectively
checking up to 234 hash value guesses in one day, using a
standard laptop and existing cryptographic libraries, and recent
work [42] used a GPU to reverse 64% of the NSEC3 hashes
in the .com zone in 4.5 days. The zone enumeration attacks
are also acknowledged in RFC 5155 (Sec. 12.1.1).

NSEC3 does use a salt value (using the NSEC3PARAM
record) to blunt the impact of ofﬂine dictionary attacks; how-
ever, in contrast to password-hashing applications that assign
unique salt to each user’s password, RFC 5155 states that
“there MUST be at least one complete set of NSEC3 [records]
for the zone using the same salt value.” This is necessary
to ensure that every possible query for a non-existent name
properly maps to an NSEC3 record; if a different salt is used
for each NSEC3 record, a query for a non-existent name might
not map to any NSEC3 record. Moreover, since changing the
salt requires re-computing the signatures for the entire zone,
RFC 6781 [26] recommends updating the salt only when key-
rollover takes place (an infrequent—monthly, or even yearly—
event), which makes the salt a fairly weak defense against
dictionary attacks. Moreover, once an adversary has collected
a number of NSEC3 records and the salt for the zone, it can
use ofﬂine dictionary attacks to learn the records present in
the zone, even after the salt changed.

C. Our Model

Today, DNSSEC deployments

support NSEC and/or
NSEC3 and remain vulnerable to zone enumeration attacks.
In this paper, we use cryptographic lower bounds to explain
why zone enumeration attacks could not be addressed by
previous designs, and propose a new solution, called NSEC5,
that protects against them.

Our ﬁrst contribution is the following cryptographic model:

Model. We have a trustworthy source, called a primary
nameserver, which is trusted to determine the set R of names
(www.example.com) present in the zone and their mapping
to corresponding values (“155.41.24.251”). Secondary name-
servers receive information from the primary nameserver, and
respond to DNS queries for the zone, made by resolvers.

3There was also an Internet Draft [21] (that expired without becoming an
RFC) proposing NSEC4. NSEC4 combines NSEC and NSEC3, allowing zones
to opt-out from hashed names to unhashed names. Like NSEC3, NSEC4 is
vulnerable to zone enumeration via ofﬂine dictionary attacks.

2

Our denial-of-existence mechanism should achieve:

(1) Soundness. The primary nameserver is trusted to deter-
mine the set R of names in the zone, and to respond correctly
to DNS queries. However, secondary nameservers and network
adversaries are not trusted to respond correctly to DNS queries.
Soundness ensures that bogus responses by secondaries or
network adversaries will be detected by the resolver. This is
the traditional DNSSEC security requirement of “data integrity
and ... origin authentication” from RFC 3833 [7]; we require
it to hold even if secondary nameservers are compromised.

(2) Privacy. Both primary and secondary nameservers are
trusted to keep the contents of R private. (If they don’t, there
is nothing we can do, since they already know R.) However,
resolvers are not. The privacy property must ensure that the
response to a query by a resolver must only reveal information
about the queried domain name, and no other names. Our
main deﬁnitional contribution is formalizing the requirement
of avoiding zone enumeration per RFC 5155 [27].

The formal cryptographic model and security deﬁnitions are
in Section II. We call a system satisfying these deﬁnitions a
Primary-Secondary-Resolver (PSR) system.

D. Cryptographic Lower Bound

Section IV proves (in the random oracle model) that if
the resolvers send queries in the clear (as they currently
do in DNSSEC), then satisfying both soundness and privacy
implies that nameservers must necessarily compute a public-
key cryptographic signature for each negative response. This
explains why NSEC and NSEC3, which limit
the online
computation at nameservers to cryptographic hashes, cannot
prevent zone enumeration.

We also show that this problem cannot be solved on the
resolver’s end of the protocol: we show that even if the
resolvers pre-process the query, then resolver-to-secondary-
nameserver protocol is necessarily a secure public-key au-
thentication (PKA) protocol [17, Sec. 3.5], for which the best
known solution is a cryptographic signature anyway. Moreover,
we show that a weakening of the soundness requirements—
requiring soundness only against network attackers, but not
against malicious or compromised secondary nameservers—
still requires a secure PKA protocol. In Section IV-C we
discuss whether our privacy requirements are “too strong”, and
argue that any meaningful relaxation, from a security stand-
point, still implies PKA. Thus we conclude that preventing
zone enumeration requires substantial (“public-key”) online
computation, rather than just private-key computation, e.g.,
evaluating a cryptographic hash as in NSEC3.

E. NSEC5: A Denial-of-existence Mechanism

Armed with the knowledge that privacy necessitates one
online public-key computation for every negative response,
Section III-A presents NSEC5, a construction that matches
our lower bound by requiring one online RSA computation for
each negative response. NSEC5 provably achieves soundness
(even in the presence of compromised secondary nameservers)
and privacy against zone enumeration.

In designing NSEC5, our key observation is that we can
“separate” our two security goals (soundness and privacy)
using two separate cryptographic keys. To achieve soundness,
we follow the traditional approach used in NSEC and NSEC3,
and allow only the primary nameserver to know the primary
secret key SKP ; this zone-signing key ensures the soundness
of the zone. However, we now make the crucial observation
that, while the soundness deﬁnition does not allow us to trust
the secondary nameserver, our privacy deﬁnition does (because
if the secondary nameserver is untrusted, then privacy is lost
anyway, since it knows the entire zone). Thus, we achieve
privacy by introducing a secondary key SKS, that is known
to both the primary and secondary namesevers. The secondary
key is only used to prevent zone enumeration by resolvers,
and will have no impact on the soundness of the zone. The
public keys P KP and P KS corresponding to SKP and SKS
will, naturally, be provided to the resolver, using the standard
mechanisms used to transmit public keys in DNSSEC.

Construction. Our NSEC5 construction is extremely similar
to NSEC3: we just replace the unkeyed hash used in NSEC3
with a new “keyed hash” F that uses the secondary keys
P KS, SKS. Our solution is as follows.

The secondary keys P KS = (NS, eS) and SKS =
(NS, dS) are an RSA key pair. For each record x present in
the zone R, the primary nameserver computes a deterministic
RSA signature on x using h1 (where h1 is a hash function,
modeled as random oracle [10], that produces outputs one bit
shorter than the bit-length of NS, and can be implemented e.g.,
by the industry-standard MGF [8, Sec. 10.2])

S(x) = (h1(x))dS mod NS

(1)
and hashes it to a short string with another hash function h2
(e.g., SHA-256, also modeled as random oracle)

F (x) = h2(S(x)) .

The resulting F values are lexicographically ordered, and each
pair is signed by the primary nameserver using its key SKP
(as in NSEC and NSEC3). The resulting pair of F values is
an NSEC5 record.

To prove the non-existence of a name q queried by the
the secondary nameserver computes the “proof”
resolver,
value π = S(q) using SKS, and responds with (1) an
NSEC5PROOF record containing proof π and (2) the signed
NSEC5 record for the pair of hashes lexicographically before
and after h2(π).

The resolver can then validate the response by (1) conﬁrm-
ing that the NSEC5 record is validly signed by SKP (using
P KP ), (2) using P KS to preform an RSA veriﬁcation on the
proof value π in the NSEC5PROOF, i.e., checking that

πeS mod NS = h1(q)

and (3) checking that h2(π) (from the NSEC5PROOF) is
lexicographically between the hashes in the NSEC5 record.
Thus,
the proof value π = S(q) maintains soundness by
proving that F (q) is the correct “keyed hash” of q.

Note that the keyed hash F (q) must be a deterministic
and veriﬁable function of q. Our speciﬁc choice of the RSA
signature algorithm used to compute S in equation (1) is thus

3

crucial; in contrast, any secure signature algorithm can be used
to sign the NSEC5 record using SKP .
Privacy.
In Section III-C we prove that our construction sat-
isﬁes soundness and privacy as deﬁned in Section II. Roughly,
privacy follows because the resolver does not know the sec-
ondary secret key SKS. This eliminates zone enumeration via
ofﬂine dictionary attacks, since the resolver cannot compute
the “keyed hash value” F (q) on its own; the only way it can
learn F (q) is by asking online queries to the nameserver (or
by breaking RSA!). The resolver’s knowledge of the secondary
public RSA key P KS don’t help either, since NSEC5 records
do not contain RSA values, but rather hashes of RSA values.
Secret keys at nameservers? NSEC5 requires secondary
nameservers to hold a secret secondary key SKS. Fortunately,
SKS only needs to be as secure as the records whose the
privacy it protects, since leaking SKS does not compromise
soundness in any way. Speciﬁcally, if SKS is leaked or the
secondary nameserver becomes adversarial, the soundness of
the zone is not compromised; all that is lost is privacy against
zone enumeration, effectively downgrading the security of
NSEC5 to that of NSEC3. (See Section III-C.)

Soundness is maintained because only the primary name-
server can sign NSEC5 records;
the resolver can use the
secondary public key P KS to verify that the secondary name-
server correctly computed S(q) in the NSEC5PROOF, and
responded with the right NSEC5 record. If an adversary wanted
to send a bogus non-existence record, it would not be able to
produce a properly-signed NSEC5 record covering F (q), even
if it knew the secret secondary key SKS.
Deployment. Because NSEC5 is structurally very similar to
NSEC3, it can incorporate performance or policy optimizations
developed for DNSSEC,
including opt-out and the space-
saving techniques of NSEC4 [21]. Moreover, NSEC5 allows
resolvers to verify using the same technologies they always
used: hashing and validation of RSA signatures. We discuss
other practical issues in Section III-B.
NSEC5 vs existing solutions.
NSEC5 requires a single
online RSA computation at the secondary nameserver, making
it computationally heavier than NSEC and NSEC3. However,
our lower bounds prove this extra computation is necessary to
eliminate zone enumeration. In fact, online signing for denial
of existence has already been standardized in RFC 4470 [43],
further discussed in RFC 4471 [40], and implemented in name-
server software like powerDNS [36, Sec. 4] and Phreebird [25].
Existing online signing solutions require every nameserver
(even the secondary) to be given the primary key for the zone,
and use it to produce online signatures to responses of the form
“q is a non-existent domain”. However, some criticize these
solutions for compromising soundness (when a secondary
nameserver is hacked or leaks its key,
the adversary can
send false DNS responses). In contrast, NSEC5 has the same
computational overhead as existing online-signing solutions
but without the same risks to soundness; NSEC5 preserves
soundness even when the secret secondary key SKS is leaked,
since online signing is used only to look up the correct NSEC5
record, but cannot be used to produce a false negative response.
Summary. Our lower bounds show that a solution that
provides both privacy against zone enumeration and a weak

notion of soundness (where secondary nameservers are trusted)
necessarily requires one online public-key cryptographic oper-
ation per query for a non-existent domain name. Our NSEC5
construction precisely matches our lower bound, and also
provides strong soundness (even if secondary nameservers
are malicious or compromised). We therefore believe NSEC5
presents an attractive alternative to NSEC3 and existing on-
line signing solutions (e.g., RFC 4470 [43]) for those zones
requiring both strong soundness and privacy guarantees. Of
course, requiring online public-key operations at nameservers
increases computational overhead and the risk that nameservers
will be targeted by denial-of-service attacks (seeking to exhaust
computational resources). Thus, individual zone operators will
need to decide if our strong privacy and soundness guarantees
are sufﬁciently important to justify the deployment of NSEC5.

F. Other related work

There are several tools and primitives in the cryptographic
is zero-
literature that are related to our work. The ﬁrst
knowledge sets (ZKS) and their generalizations [28], [34].
They provide a primitive where a prover can commit to a
database, and later open and prove the value in the database
to a veriﬁer in a zero-knowledge fashion. One can use ZKS in
our setting, where the resolver is the ZKS veriﬁer, the primary
nameserver is the ZKS prover that creates the commitment
to the set, the secondary namesever is the online ZKS prover
that provides online proofs to the veriﬁer. However, we can’t
use the existing ZKS solutions as is, because even the best-
known constructions of ZKS [15] are too inefﬁcient to be
practical for DNSSEC4. On the other hand, the requirements
in a ZKS are very stringent, in that one does not trust even the
primary nameserver (i.e., the commitment to the database). In
the DNSSEC setting, where the primary nameserver is trusted,
this property is not necessary. By working in this less stringent
setting, we are able to obtain more efﬁcient constructions.

Outsourced data structures that come with soundness guar-
antees are also relevant (see e.g. [12], [30], [31], [41]). These
data structures return an answer along with a proof that
the answer is sound; “soundness” means that the answer is
consistent with some trusted external information. We add
a privacy requirement to ensure no information leaks about
questions that were not asked. Privacy in this setting was also
considered by [20], but for queries that ask about order of
existing elements; in particular, no privacy is provided by [20]
in case the queried element does not exist.

II. MODEL AND SECURITY DEFINITIONS

We deﬁne the new primitive, Primary-Secondary-Resolver
Membership Proof system (PSR), with the goal of secure
denial of existence while preventing zone enumeration. A PSR
is an interactive proof system consisting of three parties. The
primary nameserver (or simply primary) sets up the zone by
specifying a set R ⊆ U, where R represents the existing
domain names in the zone and U represents the universe of all
possible domain names. In addition to R, the primary speciﬁes
a value v(x) ∈ V for every x ∈ R (where v(x) represents
4The veriﬁer in [15] must verify log |U| mercurial commitments, where
U is the universe of elements, and each veriﬁcation involves a ‘public-key
computation’.

4

e.g.,
the IP address corresponding to domain name x). It
then publishes public parameters P K for the zone, which are
distributed via the usual DNSSEC mechanisms. The secondary
nameservers (or secondaries) get P K and extra information
IS necessary to produce response to queries made by resolvers.
The resolvers get P K. After the setup phase is complete,
the secondaries and resolvers act as provers and veriﬁers of
statements of the form “x ∈ R and v(x) = y” or “x /∈ R”.

Following DNSSEC, we consider only two-round proto-
cols, where a query is sent from the resolver to the secondary
and a response is returned. More interaction is possible, but we
do not consider it here. DNSSEC has resolvers send queries
in the clear (i.e., send x and get v(x)), which is also what
our NSEC5 construction does (Section III-A). However, for
generality, when deﬁning our model and proving our lower
bound in Section IV, we allow resolvers to transform the query
x before sending; in particular, our model allows resolvers
to keep state between query issuance and answer veriﬁcation
(although our NSEC5 construction does not need this).

A. Algorithms for the Parties in PSR Systems

A PSR system consists of four algorithms.
The Setup algorithm is used by the primary nameserver to
generate the public parameters P K, which it publishes to all
parties in the protocol, and the information IS, delivered to
secondary nameservers. A resolver uses the Query algorithm
to generate a query for elements in the universe; it then sends
this query to a secondary, who replies to a query using the
Answer algorithm. The resolver ﬁnally uses Verify to validate
the response from the secondary.
Deﬁnition II.1. Let U be a universe of elements and V a
set of possible values. A Primary-Secondary-Resolver system
is speciﬁed by four probabilistic polynomial-time algorithms
(Setup, Query, Answer, V erif y):
Setup(R, v(·), 1k) On input k the security parameter, a set
R ⊆ U, a value function5 v : R → V , this algorithm outputs
two strings: public parameters P K and the information IS
given to the secondaries.
Query(x, P K) On input x ∈ U and the public parameters
P K, this algorithm outputs a query q. It also leaves state
information for the Verify algorithm.

Answer(q, IS, P K) The algorithm gets as input a query q for
some element x ∈ U, the information IS produced by Setup,
and the public parameters. If x ∈ R then the algorithm outputs
a bit b = ‘yes’, the value v(x), and a proof π for x ∈ R and
v(x). Else it outputs b = ‘no’, an empty v, and a proof π for
x /∈ R.

V erif y(b, v, π) The algorithm, which is given state informa-
tion from the Query algorithm, including x and P K, gets a bit
b, a value v (empty if b = ‘no’), and the proof π. If b = ‘yes’
then it checks that the proof π validates that x ∈ R and the
value is v(x). If b = ‘no’ it checks to validate that x /∈ R. If
the proof is correct it returns 1 and otherwise 0.

5This function e.g., maps domain names to their corresponding IP addresses.

For simplicity, our deﬁnition above considers only the case
where the set R is static; R is chosen when the primary sets
up the zone and does not change afterwards.6

We will require the above four algorithms to satisfy three

properties: Completeness, Soundness, and Privacy.

B. Functionality and Soundness

The requirement that the system be functional is called, as
is traditional in interactive proof systems, completeness. When
the different parties are honest and follow the protocol, then
the system should work properly; that is, resolvers will learn
whether names are in the set R or not. Moreover, even if the
queries are chosen adversarially by someone who has access
to all the secret information, the answers should be veriﬁable,
except with negligible probability.
Deﬁnition II.2. Completeness: For all probabilistic polyno-
mial time adversaries A, for all R ⊆ U and ∀x ∈ U,



Pr

(P K, IS) R← Setup(R, v(·), 1k);
x R← A(P K, IS);
q R← Query(x, P K);
(b, v, π) R← Answer(q, IS, P K) :
V erif y(b, v, π) = 1

 ≥ 1 − µ(k)

for a negligible function µ(k).

Soundness is the traditional DNSSEC notion of security;
we require that even a malicious secondary cannot convince
an honest resolver of a false statement with more than a
negligible probability. This must hold even when the malicious
secondary gets to choose R and v, then gets (P K, IS), and
ﬁnally chooses element x ∈ U it wishes to cheat on, and its
deceitful proof π.
Deﬁnition II.3. Soundness: for all probabilistic polynomial
time stateful adversaries A we have



Pr

(R, v(·)) R← A(1k);
(P K, IS) R← Setup(R, v(·), 1k);
x R← A(P K, IS);
q R← Query(x, P K);
(b(cid:48), v(cid:48), π) R← A(P K, IS) :
V erif y(b(cid:48), v(cid:48), π) = 1 ∧
((x ∈ R ∧ (b(cid:48) = ‘no’ ∨ v(cid:48) (cid:54)= v(x))) ∨
(x /∈ R ∧ b(cid:48) = ‘yes’))



≤ µ(k)

for a negligible function µ(k).

Our deﬁnition is strong because it ensures (up to negligible
probability) that an adversary cannot ﬁnd x ∈ U violating
completeness or soundness even if it has IS, the information
given to the secondaries.

6There are methods for handling changes to R that borrow from the
CRL world (e.g., [31]) but we chose not to concentrate on this here. Our
completeness, soundness, and privacy deﬁnitions and proofs would need to
change to accommodate dynamic and possibly adversarial changes to R.
Our NSEC5 construction can, however, use techniques similar to NSEC and
NSEC3 to deal with dynamic changes to R.

5

C. Privacy: Preventing Zone Enumeration

In our setting, privacy means preventing zone enumeration.
We want to make sure that resolvers do not learn too much
about the elements in the set R, apart from the responses
to their queries. We formulate this requirement with a strong
notion that we call f-zero-knowledge (f-zk for short), where
f (R) is some information about the set which we can tolerate
leaking to the resolvers. For example, our NSEC5 construction
has f (R) = |R| (the number of names in the set R).

We formulate f-zk by requiring every PSR system to have
its own simulator algorithm, who can fool a resolver into
thinking that it is communicating with a real secondary in
a PSR system. The simulator must do this without access to
the set R; instead it is only given f (R), and limited oracle
access to R—the simulator may only ask the oracle if element
x is in R if the resolver explicitly queries the simulator for
x. Despite these limitations, the simulator must still be able
to “forge” a satisfactory response to every query sent by the
resolver, such that the resolver cannot distinguish between (1)
an interaction with a secondary in a real PSR system (who
knows R), and (2) an interaction with the simulator (who only
knows f (R) and those elements x queried by the resolver).
It follows that the resolver learns nothing about R from its
interaction with the secondaries, apart from f (R) and whether
the elements x that it queried are in R or not; this further
implies privacy against zone enumeration. We note that the
use of simulators to prove that a protocol is zero knowledge is
standard in cryptography; see [23, Ch. 4] for a comprehensive
treatment. Later, in Section II-D we show that our f-zk notion
implies a more “intuitive” security deﬁnition.
PSR Simulator. More formally, we deﬁne a PSR Simulator.
Let SIM be a probabilistic polynomial time algorithm with
limited oracle access to R, meaning that SIM can only ask the
R-oracle if x ∈ R (and if so, what is v(x)) when the adversary
explicitly queries the simulator for x. Upon initializing, SIM
receives f (R) and outputs fake public parameters P K∗, fake
secret information SKSIM and the leaked information f (R).
Next, SIM receives queries from the resolver and needs to
output a (simulated) proof of either x /∈ R or of x ∈ R plus
v(x); to do this, SIM is allowed to query the R-oracle for
the element x. The simulator’s output (public parameters and
proofs) should be computationally indistinguishable from the
output generated by a real PSR system.

We divide this process into two phases. In the ﬁrst phase,
we refer to the resolver as “the adversary” (since the resolver
is the adversary that wishes to enumerate the zone). This ﬁrst
phase requires the adversary to take part in an interactive
protocol with either the simulator or a PSR system;
the
adversary does not know if it is talking to the real PSR system
or the simulator. The interactive protocol starts by giving the
adversary the public parameters, either generated by the real
PSR system:

(P K, IS, f (R)) R← Setup(R, v(·), 1k)
or by the simulator that generates fake parameters:
(P K∗, SKSIM , f (R)) R← SIM R(f (R), 1k)

Next, the adversary starts issuing queries qi (adaptively), based
on the public parameters and previous responses to queries

6

it received. If the adversary is talking to the simulator, the
simulator responds to the queries with the answers (bi, vi, πi)
using the fake public parameters P K∗ and the fake secret
information SKSIM . If the adversary is talking to the real PSR
system, it responds to the queries with the answers (bi, vi, πi)
using the real parameters and information (P K, IS). The
adversary can verify responses using the public parameters.

The second phase starts after the interactive protocol ends;
here, “a distinguisher” is required to distinguish whether the
adversary was interacting with the simulator, or with the real
PSR protocol.

We say that the system is f-zk if there exists a simulator
such that for every adversary, there is no distinguisher who
knows R and can distinguish with more than a negligible
advantage between the two views containing the public pa-
rameters, f (R), queries and responses which were generated
by either the system or the simulator.
Deﬁnition II.4. Let the leaked info f () be some function from
2U to some domain and let (Setup, Query, Answer, V erif y)
be a PSR system. We say that it is f-zero knowledge (f-zk
for short) if it satisﬁes the following property for a negligible
function µ(k):

There exists a simulator SIM such that for every proba-
bilistic polynomial time algorithms Adv and distinguisher D
a set R ⊆ U and v : R → V the distinguisher D cannot
distinguish between the following two views:
viewreal = {P K, f (R), q1, (b1, v1, π1), q2, (b2, v2, π2), ...}
2), ...}
viewSIM = {P K∗, f (R), q1, (b1, v1, π∗
with an advantage greater than µ(k), even for D that knows R
and v (the two views are generated by the protocols described
above).

1), q2, (b2, v2, π∗

D. Zero-knowledge Implies Hardness of Zone Enumeration

Next, we argue formally that our f-zero-knowledge prop-
erty indeed prevents zone enumeration; that is, that a resolver
in a PSR system cannot learn anything about the elements in R
(i.e., the domain names that are present in the zone R) except
for those elements for which it explicitly queried. In fact, we
now prove that our deﬁnition of f-zk implies even a very weak
version of privacy against zone enumeration; speciﬁcally, we
show that a resolver whose goal is to learn whether one of two
known elements (i.e., domain names) is in the zone R, cannot
succeed if he is not allowed to explicitly query for those two
elements. We call this security property selective membership
security, and deﬁne it using a game-based security deﬁnition
where the resolver wins if it guesses a bit correctly.
Deﬁnition II.5. PSR security against selective membership.
A PSR protocol is said to be ε-secure against selective mem-
bership under an adaptive chosen message attack if every
probabilistic polynomial time algorithm A playing against a
challenger wins the following game with probability at most
2 + ε:
1
1)

The adversary A starts by sending the challenger a
set S ⊆ U, two target elements x0, x1 /∈ S and a

value function v for the elements in S(cid:83){x0, x1}.

The challenger deﬁnes R = S(cid:83){x0} with prob-
2 and R = S(cid:83){x1} otherwise. Next the

ability 1
challenger runs algorithm Setup(R, v(·), 1k), sends
the output P K to the adversary A and keeps IS
secret to himself.
Algorithm A mounts an adaptive chosen message
attack by sending queries to the elements y1, .., ym,
where the queries are qi = Query(yi, P K) and
yi /∈ {x0, x1}. The challenger responds with proper
answers to all the queries: A1, .., Aq.
Finally A outputs one bit g, with g = 0 if A believes
that x0 ∈ R and g = 1 if it believes x1 ∈ R.

2)

3)

4)

We say that A won the game if the bit g is the correct guess,
i.e., if xg ∈ R.

We show that a PSR that is f-zk for f (R) = |R| is also
secure against selective membership attacks for a negligible ε.
Theorem II.6. Suppose that we have an f-zk PSR system
(Setup, Query, Answer, V erif y) for f (R) = |R| and µf
is the bound on the advantage of the distinguisher in f-zk.
Then, it is also ε-secure against selective membership under
an adaptive chosen message attack, where ε = 2 · µf

Proof: We will show that the two possible views the
adversary can witness in the security game, the one where

R = S(cid:83){x0} and the other where R = S(cid:83){x1}, are

computationally indistinguishable.

For any choice of (S, v : R → V, x0, x1) we deﬁne four
views. We will show that all four views are indistinguishable
from one another and that two of them correspond to the two
views of the adversary in the security game (either x0 ∈ R
or x1 ∈ R). Thus we can conclude that an adversary cannot
ﬁnd the additional element xg ∈ R with a non-negligible
advantage; if it could, the adversary could also distinguish
between the two views.

For j ∈ {0, 1} denote the view of an adversary in the
security game when xj ∈ R as viewreal
(S, v(·), x0, x1) and
denote the view when we switch from a secondary to the
simulator as viewsim

(S, v(·), x0, x1).

j

j

j

j

First

let us see that

the views viewreal

(S, v(·), x0, x1)
(S, v(·), x0, x1) are indistinguishable for j ∈
and viewsim
{0, 1}. According to the f-zk assumption, for every choice of
(R, v(·)) the view of any adversary communicating with the
simulator is indistinguishable from that of the same adversary
communicating with the real system, when both are given
f (R) = |R|. The adversary chooses S and knows that
|R| = |S| + 1 and the simulator and real system also know
the size of R by that same logic. So an adversary playing
the security game cannot distinguish between cases where
it is communicating with the simulator and ones where it
communicates with the real system with advantage greater than
µf , according to the deﬁnition of the f-zk property, which
makes those views indistinguishable.

Now we notice that the views viewsim
1

(S, v(·), x0, x1) and
(S, v(·), x0, x1) are not only indistinguishable, but
viewsim
identical. This is true because the simulator SIM doesn’t know
the full set R—SIM only knows |R|, and has limited access
to an R-oracle that SIM may query for an element x only

0

R = {x1, . . . , xr}

Set of domain names in the zone

U Universe of domain names
V Universe of IP addresses

v : R → V

P KP , SKP
Sig(·)
P KS = (NS, eS)
SKS = (NS, dS)

Function mapping domain names
in the zone to IP addresses
Primary (zone-signing) keys
Signature using primary key
Secondary RSA public key
Secondary RSA secret key
h1 : U → {0, 1}|NS|−1 Hash function (e.g., MGF)
Function (h1(·))dS mod NS
Function h2(S(·))

h2 : ZNS → {0, 1}n Hash function (e.g., SHA-256)

S : U → ZNS
F : U → {0, 1}n

Fig. 1. Table of notation.

when the adversary explicitly queries SIM on x, but not for
any other elements. Since the adversary may not query SIM
for x0, x1 (because it is his target challenge), the adversary can
send identical queries to SIM and get identical answers in both
views. Moreover, both views are identically distributed during
the key generation, since SIM gets the same f (R) and cannot
query its R-oracle. Thus, both views are identically distributed
and cannot be distinguished.

Combining it all, we get that viewreal
1

(S, v(·), x0, x1) and
(S, v(·), x0, x1) cannot be distinguished with prob-
viewreal
ability greater than 2µf . This means that any probabilistic
polynomial time adversary can win the selective security game
with only a negligible advantage of 2 · µf .

0

III. NSEC5 CONSTRUCTION AND SECURITY PROOF
Here we show why our NSEC5 construction is a secure
PSR system, and prove its security. A high-level discussion of
our NSEC5 construction was already provided in Section I-E.
Section III-A presents NSEC5 in the context of our formal
model of a PSR (per Section II), and Section III-C proves the
security of NSEC5 in the random oracle model (per [14]). Ta-
ble 1 summarizes our notation. Section III-B discusses practi-
cal considerations, including computational requirements, and
the DNSSEC record types required by NSEC5.

A. NSEC5 as a PSR System

We specify our NSEC5 construction within the model of a

PSR system in Section II.
Building blocks. Our NSEC5 construction is based on an
RSA permutation, two hash functions, and a signature scheme.
The RSA permutation has a key generation function that gener-
ates an RSA key pair P KS = (NS, eS) and SKS = (NS, dS).
We also use two cryptographic hash functions: h1 produces
outputs one bit shorter than the bit-length of NS (and can,
e.g., be the industry-standard MGF [8, Sec. 10.2]), and h2
produces outputs of length n (n needs to be only as big as the
security level we wish to achieve; see discussion of key length
in Section III-C). Our security proofs model both h1 and h2 as
random oracles per [14]. Finally, we use any signature scheme
that provides existential unforgeability against chosen message
attacks [24].
PSR algorithms. We now map our NSEC5 construction to
the four PSR algorithms described in Section II.

7

(cid:122)
(cid:124)
Fig. 2.

IS

(cid:125)(cid:124)

(cid:125)

(cid:124)

(cid:123)(cid:122)

(cid:123)

SKS

(cid:125)

y1, . . . , yr

Sig(y0 , y1), . . . , Sig(yr , yr+1)

(x1 , v(x1)), . . . , (xr , v(xr ))

Sig(x1 , v(x1)), . . . , Sig(xr , v(xr ))

(cid:123)(cid:122)

Records for present names
Denial-of-existence records
IS, the extra information given to the secondaries.

Setup: The primary nameserver runs the setup algorithm
Setup(R, v(·), 1k), taking in the set R (e.g., domain names
in the zone) and its associated values v (e.g., the IP addresses
corresponding to those domain names), and security parameter
k. It generates the public parameters P K and the information
for the secondary nameservers IS as follows.

It chooses the hash functions h1 and h2 and generates a key
pair (P KP , SKP ) for the existentially-unforgeable signature
(the “primary keys”) and an RSA key pair (P KS, SKS)
(the “secondary keys”). The public parameters are P K =
(P KP , P KS, h1, h2).

Next, it constructs IS, the information given to the sec-
ondary nameservers as follows: First, it signs the names that
are present in the zone: using the primary secret key SKP
and the existentially-unforgeable signature algorithm, it obtains
Sig(x, v(x)) for each element x ∈ R (domain name) and its
corresponding values v(x) (IP address). Next, it constructs the
authenticated denial-of-existence records: it uses the secondary
secret RSA key SKS = (dS, NS) and the “full-domain” hash
function h1 to compute a deterministic RSA signature on each
x ∈ R as

π = S(x) = (h1(x))dS mod NS

(2)

which is then hashed to a shorter string using h2

y = F (x) = h2(π)

(3)
The y values are lexicographically ordered as y1, . . . , yr, and
y0 = 0n and yr+1 = 1n are added. For j ∈ {0, . . . , r}, each
pair (yj, yj+1) is signed using the existentially-unforgeable
signature algorithm with the primary secret key SKP to obtain
Sig(yj, yj+1).

Finally, the secondary nameserver is given the following
information as IS: the secondary secret key SKS, the pairs
(x, v(x)) and their signatures Sig(x, v(x)) for every x ∈ R
present in the zone, and the denial-of-existence pairs (yj, yj+1)
and their signatures Sig(yj, yj+1) for j = 0 . . . r, see Figure 2.
clear:
Query(x, P K) outputs element x (a domain name) as
the query q.

Query: Resolvers

queries

send

in

the

Answer: Secondary nameservers run Answer(q, IS, P K)
to respond to queries by resolvers. First, the secondary checks
if q ∈ R. If so, it returns the corresponding signed records

‘yes’, (q, v(q)), Sig(q, v(q))

Otherwise, it uses the secondary secret key SKS to compute
the RSA signature πy = S(q) per equation (2), hashes this
down to y = h2(πy) per equation (3), ﬁnds the appropriate
denial-of-existence record7 by locating index j for which yj <

7 There is a negligible chance that such a record will not exist due to a hash
collision; if that is the case, return “failure”; the same approach is used when a
hash collision occurs in NSEC3 [27, Section 7.2.9]. We bound the probability
of such an occurrence in Section III-C, where we evaluate the completeness
of NSEC5.

8

y < yj+1, and returns

‘no’, (yj, yj+1), (πy, Sig(yj, yj+1)) where πy = S(q)

Verify: The
V erif y(b, v, π).

resolvers

verify

the

response with

If the response had b = ‘yes’, they use the primary public
key P KP to verify that Sig(q, v(q)) is a valid signature on
(q, v(q)). If so, return ‘1’ for success; else return ‘0’.

Otherwise, b = ‘no’. Resolvers then: (a) use the primary
public key P KP to verify that Sig(yj, yj+1) is a valid
signature on (yj, yj+1) (b) use h2 and πy to check that

yj < h2(πy) < yj+1

and (c) use the secondary key P KS = (eS, NS) to verify that
πy is a deterministic RSA signature on q, i.e., that

h1(q) = πeS

y mod NS

(4)

If all three checks pass, return ‘1’; else return ‘0’.

B. Practical Considerations and Compatibility with DNSSEC
We highlight the similarities and differences between our
construction and the existing DNSSEC standard with NSEC3.
To do this, we map the description in Sections I-E,III-A to
DNSSEC record types, and discuss computational overheads.
Before we move on to less straightforward details of our
construction, we note that the primary public key P KP from
Section III-A is the usual DNSSEC zone-signing key (ZSK),
stored in a DNSKEY record and securely distributed using the
usual DNSSEC mechanisms. Each pair (x, v(x)) of domain
name x ∈ R and IP addresses v(x) present in the zone is
the usual DNS A records; their signatures Sig(x, v(x)) are
the usual DNSSEC RRSIG records. Each of our new NSEC5
records contains a pair (yj, yj+1) of lexicographically-adjacent
hash values (see equations (2) and (3) above); each NSEC5
record is signed using the primary key (the ZSK) and its
signature is stored in a DNSSEC RRSIG record. Observe that
our NSEC5 records are almost identical to NSEC3 records.

Computational overhead. The main computational overhead
of our approach over NSEC3 is online signing at the secondary
nameservers. Speciﬁcally, we require secondaries to compute a
deterministic RSA signature S(q) online for every query q that
requires a negative response (see equation (2)). Note, however,
that online signing has been standardized (RFC 4470 [43])
and implemented in commercial DNSSEC systems [36, Sec.
4], [25]. Moreover, in Section IV we will prove that online
signing is necessary to satisfy our security deﬁnitions.

We also require resolvers to verify the RSA signature S(q)
(equation (4)). This is no slower than actually verifying the
signature on an NSEC record itself, representing no more than
a 2x increase in computational overhead. Moreover, comparing
this extra overhead to its analogous computation in NSEC3—
namely, computing multiple iterations of a hash (e.g., SHA-
256) on the query q—suggests that NSEC3 and NSEC5 can
have similar computational overhead at the resolver; specif-
ically, RFC 5155 [27, Sec 10.3] speciﬁes that the iterative
NSEC3 hash computation can have up to the same cost as

an RSA signature veriﬁcation (e.g., 500 SHA1 iterations for a
2048-bit RSA signature).

Finally, the primary nameserver also needs to compute
some extra signatures when setting up the zone—an additional
r = |R| RSA signing computations (to compute the yj’s) in
addition to the 2r + 1 signatures needed to sign the NSEC5
records. This represents a 2x increase over NSEC3, which
requires |R| + 1 signatures on the NSEC3 records.

Secrets at the nameservers. Secondary nameservers must
hold the secret secondary key SKS, which can be transmitted
from the primary to the secondaries over some external secure
channel. Fortunately, SKS only needs to be as secure as the
records whose privacy it protects, since leaking SKS does not
compromise soundness in any way (Section III-C).

New DNSSEC record types. Our NSEC5 solution requires
the secondary to respond to queries for non-existent names
with NSEC5 records (pairs (yj, yj+)), as well as the RSA
value S(q). In contrast to the information in the NSEC5 record,
which is computed during setup and signed by SKP , the RSA
value S(q) is computed online and is not signed. We therefore
propose transmitting S(q) from secondary to resolver in a new
unsigned record type (NSEC5PROOF).

We must also consider how the primary nameserver can
authentically transmit the secondary public key P KS and hash
functions h1, h2 to the resolver and secondary nameserver.
An analogous issue arises in NSEC3, when transmitting the
salt and hash function to the resolver; NSEC3 deals with
this by including the salt and an “algorithm identiﬁer” for
the hash in the NSEC3 record itself, and having the entirety
of the NSEC3 record signed using the primary secret key
SKP [27]. We could analogously include the secondary public
key P KS and algorithm identiﬁers for the hash functions
h1 and h2 in each NSEC5 record, and then sign the entire
NSEC5 record using SKP .8 However, we may want to avoid
including P KS in each NSEC5 record (since a 2048-bit public
RSA key is much larger than the 24-bit NSEC3 salt). NSEC3
uses the NSEC3PARAM record to transmit the NSEC3 salt
and hash function to the secondary nameservers; we could
similarly distribute P KS, h1, h2 in an NSEC5PARAM records.
Alternatively, we might use a signed DNSKEY record with
ﬂag bits set to indicate that P KS is not a signing key for the
zone9. The DNSKEY or NSEC5PARAM would be signed by
the primary key and their signatures stored in RRSIG records.

Opt-out. Finally, the structural similarity of NSEC5 with
NSEC3 and NSEC allows for easy adoption of existing
DNSSEC mechanisms such as wildcards, Opt-out [21], [27]
and Opt-in [6]. We will address these details in future work.10

8Notice that by signing the entire NSEC5 record with SKP , which is
only known to the primary, we ensure that P KS , h1, h2 are authentically
communicated from the primary to the resolver.

9This approach complies with RFC 4035 [4]’s discussion on the use of the

DNSKEY record for non-zone signing keys.

10Using the wildcard optimization devised for NSEC4 [21], our denial-of-
existence response will contain two NSEC5 records and two NSEC5PROOF
records in the worst case. This makes it only about one RSA-value (2048 bits)
longer than today’s unoptimized NSEC3 standard with 2048-bit RSA, which
contains three NSEC3 records in the worst case.

C. Proof of Security for NSEC5

We show that our system is complete, sound, and leaks
nothing more than the size of the set R. Our proof is in
the random oracle model (using “programmable” random
oracles [14], [33]). Note that we assume that the set R is
chosen independently of the random oracles—that is, hash
values did not inﬂuence the set names in the zone R (this
assumption can be removed at the cost of slightly complicating
the proof and making the reduction less tight).
Theorem III.1. The four algorithms described above consti-
tute an f-zk PSR for the function f (R) = |R|.

Proof: We need to show the three properties in Deﬁni-

tions II.2, II.3 and II.4.
Completeness. The only way completeness can be violated
is if there is a collision F (x) = yj for some x /∈ R (see
Footnote 7). For every R ⊆ U we will show that after we
run Setup(R, v(·), 1k) to get (P K, IS) and let the adversary
A pick and query x, the V erif y algorithm will output 0 with
probability at most (qh +2)(r+2)2−n, where qh is the number
of hash (random oracle) queries made by A.

Let us assume that A makes an h1-query on x and an h2-
query on S(x) before asking for a query on x (any A can be
easily modiﬁed to do so, at the cost of at most two additional
random oracle queries, because A knows SKS). Denote by
qh1 and qh2 the numbers of queries A makes to its h1 and h2
oracles, respectively, after this modiﬁcation. Consider every
query A makes to h1 for any x /∈ R. The probability that the
output of this query is equal to h1(xj) for some xj ∈ R is
at most r2−|NS|+1 (recall that r = |R|). The probability that
there exists an h1 query that caused this event to happen is
at most qh1 r2−|NS|+1. Suppose such an event did not happen.
Now consider every query A makes to h2 on input S(x) for
any x /∈ R. Since RSA is a permutation and h1 collisions did
not occur, S(x) (cid:54)= S(xj) for any xj ∈ R. So the probability
h2(S(x)) collides with any yj is at most (r + 2)2−n. Hence,
the probability of a collision is at most qh1r2−|NS|+1 +qh2(r+
2)2−n ≤ (qh + 2)(r + 2)2−n.
Remark. We can also consider a weaker adversary who
is not given SKS but can make qS queries to a secondary
instead. Such an adversary cannot obtain S(x) on his own
without forging an RSA signature and is thus forced to perform
an on-line, instead of an off-line, attack. We can therefore
show (using the full-domain-hash reduction of [16]) that, under
the (t, ε) RSA assumption (Appendix A), the probability such
an adversary violates completeness in time t is approximately
qS(ε + r2−n), where qS is the number of active queries to the
secondary. Passive random oracle queries are of no value to
such an adversary.
Soundness. The soundness of our proposal follows via a tight
reduction from the existential unforgeability of the underlying
signature scheme that is used to sign records with the primary
key SKP . More formally, given an adversary A that breaks
soundness with probability ε (per Deﬁnition II.3), we can
construct a forging adversary B that, given a public key
P KP , can forge digital signatures (or, more formally, win
the existential unforgeability game) with probability ε, where
both algorithms have similar running times. In the existential

9

unforgeability game for digital signatures, the forger B can
ask a signing oracle for signatures on arbitrary messages and
must forge a signature on a new message.

We construct the forger B as follows. Initially the forger
B receives the public key P KP (and the security parameter
k) from the challenger. It then starts running adversary A that
breaks soundness of our NSEC5 scheme. First, the forger B
obtains the set R and the function v(·) that is output by A
(See Deﬁnition II.3). Next, it needs to compute IS that it will
return to A. To do this, the forger B runs the NSEC5 Setup
algorithm in Section III-A, with the following modiﬁcations:

•

•

The forger B no longer generates the primary keys;
instead, P KP (that B was given as input) is used as
the primary public key.
The forger B does not have the private primary key
SKP . Instead, it queries its signing oracle to obtain
signatures on pairs (yj, yj+1) for j ∈ {0, . . . ,|R| + 1}
and pairs (x, v(x)) for all x ∈ R.

The forger then gives A the output of the Setup algorithm.
A then outputs the value x that it wishes to cheat on, and
corresponding values b(cid:48), v(cid:48), π. Suppose V erif y(b(cid:48), v(cid:48), π) = 1.
Suppose that b(cid:48) = ‘yes’ but x (cid:54)∈ R or v(x) (cid:54)= v(cid:48) so
that adversary A wins the soundness game for the NSEC5
scheme. B can output the message (x, v(cid:48)) and its signature as
the forgery; B wins the game because this signature was not
requested by B during setup.

1, y(cid:48)

1, y(cid:48)

1 < h2(πy) < y(cid:48)

Suppose now that A wins the soundness game because
b(cid:48) = ‘no’ but x ∈ R. Since π passes veriﬁcation, it contains
πy that satisﬁes equation (4). Also, π contains a signature σ
computed using the primary key on some pair (y(cid:48)
2), such
that y(cid:48)
2. We need to show that the forger
B did not request the signature σ when it ran its’ modiﬁed
NSEC5 Setup algorithm; thus the forger B can win the game
by outputting message (y(cid:48)
2) and σ as its forged signature.
First, observe that x ∈ R, so it follows that when B ran its
modiﬁed NSEC5 Setup algorithm, it computed the RSA value
S(x) per equation (2). Next, because the RSA function S(·)
(see equation (2)) is deterministic, it follows that πy = S(x).
Therefore, value y = h2(πy) must be one of the values in the
sequence y0, . . . , y|R|+1 that were used to construct denial-of-
existence records during setup. Since y(cid:48)
2 > y, it
follows that (y(cid:48)
2) are not adjacent values. We conclude that
the forger B never queried its signing oracle for a signature
on (y(cid:48)

1, y(cid:48)
Therefore, we see that B succeeds whenever A succeeds

1, y(cid:48)

2) during setup.

1 < y and y(cid:48)

in breaking soundness, i.e., with probability ε.
Privacy. In order to show that NSEC5 is f-zk for f (R) = |R|,
we need to construct a suitable simulator, for which no
probabilistic polynomial
time distinguisher can distinguish
between an interaction with the simulator and one with the real
NSEC5 system. The indistinguishability of our simulator will
follow via a tight reduction from the (t, ε)-RSA assumption
(Appendix A).

The simulation relies on the veriﬁable pseudorandomness
of the function F in equation (3), which is captured in the
following lemma.

10

Lemma III.2. For every x ∈ U, the value F (x) is pseudo-
random over {0, 1}n in the following sense: no probabilistic
polynomial-time adversary, who gets the public key (NS, es)
and the value x, and can ask for F (xi) and S(xi) on any
sequence of points x1, x2 . . . not containing x, can distinguish
F (x) from a random value in {0, 1}n with non-negligible
advantage. More precisely, an adversary who has advantage ε
in distinguishing F (x) from random in time t can be used to
break the (t(cid:48), ε) RSA assumption (stated in Appendix A) with
t(cid:48) ≈ t.

Note that this means that the function F () combined with
S() constitutes a selective VRF, as deﬁned in [29]. This is
a very simple and efﬁcient implementation of the primitive
(albeit, only in the random oracle model); see also [32].

Proof: Assume to the contrary that there exists such an
adversary A that has non-negligible advantage ε. Because h2
is random and F (x) = h2(S(x)), A has zero advantage unless
it queries h2 on S(x), either directly or through one of its F
queries. Hence, the probability that h2(S(x)) is queried during
the attack by A is at least ε. It remains to show that S(x) is
hard for A to compute, which we do similarly to [10].

Speciﬁcally, we show that, using A, we can invert the RSA
permutation with probability ε, violating the RSA hardness
assumption as stated in Appendix A. Recall that we get to
determine (“program”) the random oracle outputs, as long as
they are uniform.

We are given a public RSA key (N, e) and challenge z that
we wish to invert. If the bit-length of z is strictly less than the
bit-length of N, set z(cid:48) = z. Else, repeatedly try a random
α ∈ Z∗
N until z(cid:48) = zαe mod N has bit-length less than the
bit-length of N (the expected number of tries is less than 2).
Observe that if we invert RSA on z(cid:48), we will also invert it on
z by dividing the answer by α.

Assume wlog that A makes at most Q queries, that it does
not repeat queries, and that for every xi (cid:54)= x for which A
asks the random oracle to evaluate h1(xi), it also asks to see
(F (xi), S(xi)). Before running A, we do the following for
each i between 1 and Q: draw a uniformly random c ∈ ZN
and check if the bit-length of ce mod N is strictly less than
the bit-length of N. If not, try a fresh random c (the expected
number of attempts is less than two). If yes, let ci = c and
zi = ce mod N. Now we run A on the public key (N, e)
and any x. Every time A queries the h1 random oracle on
xi (cid:54)= x, we answer with zi (i.e., program h1(xi) = zi); we
also return S(xi) = ci, draw a uniformly-random value ri,
return F (xi) = ri, and program h2(ci) = ri.

When h1 is queried on x, we answer with z(cid:48). This ensures
that z(cid:48) = S(x)e mod n. Queries to h2 are answered consis-
tently if h2 has already been programmed on that query, and
randomly otherwise. The distribution A witnesses is identical
to the real distribution. Hence, the probability that the h2 table
contains S(x), which is the RSA inverse of z(cid:48), is ε.
Corollary III.3. For every set R ⊂ U, an adversary who
gets (N, e) as input, runs in time t and has advantage ε in
distinguishing {F (x)|x ∈ R} from a set of |R| random values
in {0, 1}n can be used to break the (t(cid:48), ε(cid:48))-RSA assumption,
where ε(cid:48) = ε − |R|/N and t(cid:48) ≈ t. This holds even if the

adversary can query for any xi /∈ R to obtain F (xi) and
S(xi).

This corollary follows because of random self-reducibility
of RSA: inverting RSA on any value in a set of r random val-
ues is essentially as hard as inverting it on a single element (see
Appendix A). Here we use speciﬁc properties of RSA; if we
had used a generic trapdoor permutation in our construction,
we would have lost a factor r in the advantage due to a hybrid
argument (the only other place we use speciﬁc properties of
RSA is in the proof of Lemma III.2, where we save a factor
of 2 by rerandomizing z so it has the correct bit-length).

We now show the simulator. Recall from Section II-C that
the simulator is given oracle access to R (i.e., the set of domain
names in the zone). Our simulator algorithm SIM R(1k, 1|R|)
is as follows. Like the primary nameserver, SIM chooses
the hash functions h1 and h2, generates the primary keys
(P KP , SKP ) and the secondary keys (P KS, SKS), and
outputs P K∗ = (P KP , P KS, h1, h2). SIM then selects a
list of |R| uniformly random values in {0, 1}n, sorts them
lexicographically to obtain y1, . . . , y|R|, and adds the values
y0 = 0n and yr+1 = 1n. For j ∈ {0, . . . ,|R|}, each pair
(yj, yj+1) is signed using SKP to obtain Sig(yj, yj+1).

Next, SIM receives queries from the resolver and outputs
a (simulated) proof for either x /∈ R or x ∈ R plus v(x)
as follows. For each received query xi, SIM uses his oracle
access to the set R to check if either xi /∈ R or xi ∈ R and if
so to obtain v(xi). If xi ∈ R, SIM uses the secret key SKP
and the existentially-unforgeable signature scheme to produce
a signature Sig(xi, v(xi)), and outputs

‘yes’, (xi, v(xi)), Sig(xi, v(xi)) .

SIM remembers the answer and outputs the same answer in
case of repeated queries. Otherwise xi /∈ R, and SIM does
the same as the NSEC5 secondary nameserver: it uses the
secondary secret key SKS to compute the RSA signature π =
S(xi) according to equation (2) and the hash value y = h2(π)
per equation (3); it then searches for an index j for which
yj < y < yj+1. If such an index j is found, SIM returns

‘no’, (yj, yj+1), (π, Sig(yj, yj+1))

If no such index j is found, i.e., a collision has occurred, SIM
returns “failure,” just like the real NSEC5.

Now we need to show that the view of the adversary
communicating with SIM is indistinguishable from that of
the adversary communicating with the real NSEC5 system.
The only difference between the outputs of SIM and the
outputs of real NSEC5 system is in the values yj, which are
random for the simulator rather than computed by applying
equations (2),(3) to the elements of R. Fortunately, the adver-
sary cannot query for F (x) and S(x) for x ∈ R (because those
queries give positive, rather than negative, proofs, and positive
proofs do not use F () and S()). Thus Corollary III.3 can be
used to conclude the proof.

Key Length. We discuss key lengths requirements for the
security of NSEC5. First, observe that RSA modulus NS for
the secondary key must be long enough to withstand attacks
for as long as the privacy of the zone is important. Even
if the secondary key is rolled frequently, it cannot be too

short, because zone privacy may be important for a period
longer than the lifetime of the key. Meanwhile, the primary
key (P KP , SKP ) (i.e.,
the zone-signing key) is used for
authentication, but not privacy; thus, it needs to remain secure
only during its lifetime.

Next, consider n, the length of the output of the hash
function h2, which impacts the length of the NSEC5 response
and storage (of IS) at the secondary nameservers. Length
n does not affect soundness or privacy, but it does affect
completeness, i.e., the probability that the secondary returns
“failure” rather than a proof for x /∈ R. Since secondaries can
fail for a variety of non-NSEC5-related reasons, n needs to
be only large enough to make completeness violations much
less likely than other server failures. The choice of n thus
depends on the security model for completeness. If everyone
is honest and there are at most qS online queries to the
nameserver, completeness will be violated with probability
about |R|qS2−n, so even n = 80 could sufﬁce. On the other
hand, if the adversary can inﬂuence R (i.e., can control the
names that go in the zone) and also knows SKS, then it will
H 2−n
be able to violate completeness with probability at most q2
by a standard birthday bound argument. (Other threat models
are discussed in the full version.) Thus, a conservative choice
is n large enough to prevent birthday attacks (e.g., letting h2
be SHA-256 with n = 256 for a security level of 128 bits).
However, this may be overkill; since the choice of n only
affects completeness it may be worthwhile to design for a
weaker threat models that results in a smaller choice of n.

Perfect completeness. We could get perfect completeness for
NSEC5 by adding proofs for the special case of collisions
in the hash functions h1 and h2. If x /∈ R collides with
x∗ ∈ R (F (x) = F (x∗)) then a valid proof for x /∈ R would
be (‘no’, (S(x), S(x∗), x∗, v(x∗), Sig(x∗, v(x∗)))). A resolver
would verify this proof by checking that F (x) = F (x∗) and
verifying the signature Sig(x∗, v(x∗)). Changing the scheme
in this way would leak information about R (i.e., that x∗ ∈ R
and v(x∗)), but would not violate privacy since collisions occur
with negligible probability for large n.

IV. ONLINE PUBLIC-KEY OPERATIONS ARE NECESSARY
We now show that secondary nameservers in a PSR system
must perform a public-key computation on every query for
a non-existent name. We do so by showing that any PSR
system can be used to construct a public-key signature scheme,
where the complexity of the signer in the signature scheme is
roughly equal to the complexity of the secondary nameserver
(plus the complexity of the query algorithm) in the PSR. The
signature scheme will be secure as long as the PSR system
is complete, sound, and private—even if it satisﬁes only (1)
the weaker privacy notion of Deﬁnition II.5 rather than full-
ﬂedged zero-knowledge of Deﬁnition II.4, and (2) a weaker
notion of soundness that robust to network attackers but not to
compromised secondary nameservers. (This weak soundness
adversary is an attacker that can ask secondary nameservers
to respond to queries, but does not have the information IS
stored at secondary nameservers.)

In a public-key signature system, signers must perform
a public-key operation for each message they sign; thus, by
constructing a signature scheme from a PSR system, we have

11

shown that the same holds for a PSR. Of course, a limited num-
ber of signatures can be precomputed in any signature scheme,
and the same holds for a PSR (e.g., all positive responses may
be precomputed, as in most existing constructions, including
NSEC5). The rest—and, in particular, negative responses to
unexpected queries—must be done online.

We obtain signatures only when the PSR system satisﬁes
the following property:
the query algorithm is either (1)
deterministic or, (2) randomized such that soundness holds
even when the adversary has the knowledge of the random
values used to generate the query q. Note that this property
is trivially satisﬁed by systems like NSEC5 and the current
DNS/DNSSEC standards where q = x (i.e., the query is
identical to the queried name).

However, we also show that a more complicated query
algorithm will not help much. Even when the PSR system
does not satisfy this property, we obtain an interactive protocol
that is very similar to signatures: namely a public-key au-
thentication protocol (PKA), in which the sender transmits an
authenticated message to the receiver using some interaction.
Again, in our obtained PKA protocol, the complexity of the
sender is similar to that of the secondary nameserver in a
PSR system. Since such a PKA protocol is not known to
have any implementation that is much more efﬁcient than a
digital signature scheme, we can conclude that a non-trivial
computational task is required of secondaries in PSR systems.
This explains why approaches like NSEC3—that provide
strong soundness (robust to compromised secondary name-
servers), but avoid online “public-key” computations—cannot
prevent zone enumeration. It also explains why zones requiring
strong privacy still have to use online signing (e.g., RFC
4470 [43]) even if they require only weak soundness (robust
to network attackers but not compromised nameservers).

Section IV-A presents results on transforming PSR schemes
to PKA schemes, and Section IV-B extends this to signatures
when the constraints on the query algorithm are satisﬁed.
Both our transformations are in the random oracle model.
Section IV-C argues that any meaningful relaxation to our
privacy requirement still implies PKA.

A. Public-Key Authentication from PSR

Deﬁning Public-key Authentication Security Public-key
authentication (PKA; see [17, Section 3.5]) can be seen as
a relaxation of signature schemes in which we tolerate inter-
action between the sender and the receiver, and we give up the
transferability property (i.e., the receiver is no longer able to
convince a third party that the signature is valid).

PKA schemes are related to, but are harder to build than
identiﬁcation protocols, in which there isn’t even a message;
instead the prover (sender) convinces the veriﬁer that he is
present. (Such protocols can be used, e.g., for access control
where key cards act as provers.) Identiﬁcation protocols can be
constructed from any zero-knowledge proof of knowledge [18]
for a computationally-hard problem, but in practice, there is
no known PKA or identiﬁcation protocol where the efﬁciency
of the prover is better than a signer in a signature scheme.

We now deﬁne selective and existential security for PKA.

public-key

authentication

is

IV.1.

Selectively-secure
(PKA)

Deﬁnition
PKA.
A
protocol
said
to
(P KA Setup, P KA P rove, P KA V erif y)
be ε-secure against selective forgery under an adaptive chosen
message attack if every polynomial time probabilistic forging
algorithm B playing against a challenger wins the following
game with probability at most ε:

1)

2)

3)

4)

The forger B picks a target message m and sends it
to the challenger.
The challenger runs the setup algorithm for the PKA,
sends P K to the forger B and keeps SK secret.
The forger B mounts an adaptive chosen message
attack: B selects messages m1, . . . , m(cid:96), where ∀i :
(cid:54)= m; for each mi, the challenger (acting as
mi
prover) and B (acting as veriﬁer) engage in an
authentication session.
At some point of the forger B’s choosing, B (acting
as prover) attempts to authenticate the target mes-
sage m to the challenger (acting as veriﬁer). The
authentication sessions for the mi’s may be running
concurrently.

We say that the forger B wins the game if the challenger

accepts the authentication on m.
Deﬁnition IV.2. Existentially-secure PKA. A PKA protocol
(P KA Setup, P KA P rove, P KA V erif y) is said to be ε-
secure against existential forgery under an adaptive chosen
message attack if the same conditions as in Deﬁnition IV.1
hold, except that the forger B can pick the target message m
at any point in the game.

From PSR to Selectively-secure PKA.
We construct
a selectively-secure PKA protocol
from a PSR system
(P SR Setup, P SR Query, P SR Answer, P SR V erif y)
that is selectively secure against polynomial-time adversaries
(per Deﬁnition II.5) as follows:
PKA Setup. Select a uniformly random message m∗ ∈ U,
deﬁne R = {m∗} and denote v(·) as the function that returns
1 on m∗ and ⊥ otherwise. Run the PSR setup algorithm
P SR Setup(R, v(·), 1k), and return (P K, IS) as the public
and secret keys for the PKA.

PKA Prover. The PKA prover has the public and secret keys
(P K, IS) for the PKA, and must authenticate message mi. To
do this, the PKA prover acts as the secondary in the PSR sys-
tem, and proves that mi (cid:54)∈ R; that is, the PKA prover receives
q, and returns the output of P SR Answer(q, IS, P K).

PKA Veriﬁer. The PKA veriﬁer has the public key P K, and
acts as the resolver in the PSR system. The PKA veriﬁer runs
P SR Query(x, P K) to obtain q and sends q to the PKA
prover; upon receiving the response, the PKA veriﬁer accepts
if P SR V erif y(b, v, π) accepts.
Remark IV.3. Note that our PKA construction does not satisfy
perfect completeness (if the veriﬁer happens to choose m∗,
the nameserver cannot authenticate that message). If the PSR
system has perfect completeness (note: NSEC5 doesn’t have
prefect completeness due to hash collisions), then we can also
get a PKA system with perfect completeness. To do this, we
add a bit to each element in the universe, indicating whether it

12

is a real or dummy element. We choose the message m∗ to be a
dummy element, by prepending a 0 as its ﬁrst bit. Then, when a
resolver wants to query on message m, it asks for 1m instead;
in this way, all messages in the universe can be authenticated.
Thus, if the PSR system has perfect completeness, then the
constructed selectively-secure PKA does as well.
Theorem IV.4. Suppose we have a PSR system that is ε-
secure against selective membership under an adaptive-chosen-
message attack and µS-secure against soundness attackers.
The PKA scheme constructed above is ε(cid:48)-secure against selec-
tive forgery under an adaptive-chosen-message attack, where
ε(cid:48) = 2ε + µs

This theorem also holds with a notion of PSR soundness
that is weaker than that of Deﬁnition II.3; instead of requiring
soundness even in the face of compromised nameservers, with
weak soundness we trust secondary nameservers and only
require that other network adversaries cannot produce false
DNS responses. The weak soundness adversary has knowledge
of P K but not IS, and has oracle access to an honest secondary
nameserver.

thus,

and the PKA adversary B has to forge a proof that target
message m is such that m /∈ R;
in this case the
PKA adversary B witnesses the exact same view as in a real
execution. Thus, with probability at least ε(cid:48), the PKA forger
B wins his game, and A correctly identiﬁes that B succeeded
in forging the authentication on message m. So the probability
A wins in this case is at least ε(cid:48) (by correctly guessing g = 1).
In the second case, R = {m} and the PKA adversary
B has to forge a proof that target message m is such that
m /∈ R; in this case it is no longer true that the PKA adversary
B witnesses the exact same view as in a real execution.
Indeed, the PKA adversary B is now asked to prove a false
statement (namely, that m /∈ R where R = {m}), so the
PSR’s soundness property, through a straightforward reduction,
ensures that B cannot generate a proof for a false statement
with probability larger than µs. (Note that the full-ﬂedged
soundness property of PSR is not needed here—it sufﬁces for
PSR to be sound against adversaries who can issue queries,
but do not have the data IS.) Thus, the probability that the
PSR adversary A wins (by correctly guessing the bit g = 0)
is at least (1 − µs).

Proof of Theorem IV.4:

there exists a
polynomial-time PKA forger B which manages to win the
selective forgery security game (Deﬁnition IV.1) for the con-
structed PKA scheme with non-negligible probability ε(cid:48). We
describe a polynomial-time PSR adversary A that uses the
PKA forger B as a subroutine to win the PSR selective-
membership security game (Deﬁnition II.5) with a non-
negligible advantage ε = ε(cid:48)
2 . The PSR adversary A is
as follows:

Suppose that

2 − µs

1)

2)

3)

4)

elements in S(cid:83){m, m∗} where v(m) = v(m∗) = 1

The PSR adversary A starts by obtaining the target
message m that is output by the PKA forger B. A
then draws a random message m∗ (cid:54)= m and sends
the PSR challenger two target elements m, m∗, an
empty target set S = φ, and a value function v for the
and ⊥ otherwise.
The PSR challenger selects either R = {m} or
R = {m∗}, each with probability 1
2. Next, the PSR
challenger runs P SR Setup(R, v(·), 1k), sends the
output P K to the PSR adversary A, and keeps IS
secret.
The PSR adversary A now emulates the PKA forger
B as it mounts its adaptive chosen message attack.
A relays each message m1, . . . , m(cid:96) sent by the PKA
forger B for authentication to the (PSR) challenger;
A then relays the answers produced by the challenger
back to the PKA forger B.
At this point, the PSR adversary A needs to output a
bit g, with g = 0 if A believes that m ∈ R and g = 1
if A believes m∗ ∈ R. To do this, A waits until the
PKA forger B is ready to forge an authentication for
its target message m; when this happens, the PKA
forger B (acting as prover) authenticates m to the
PSR adversary A (acting as veriﬁer). If A accepts the
authentication, it returns g = 1; otherwise, it returns
g = 0.

To analyze the success probability of the above PSR
adversary A we have two cases: In the ﬁrst case, R = {m∗}

2 (ε(cid:48)) + 1

Since both cases are equally likely, the PSR adversary A
2 (1 − µs) =
2 − µs
2 .

wins the game with probability at least 1
2 + ε(cid:48)
1
From selective to existential security. Now, we show that
in the random oracle model, a PKA that is selectively secure
(Deﬁnition IV.1) can be used to construct a PKA scheme which
is existentially secure (Deﬁnition IV.2). In combination with
Theorem IV.4, this shows that a PSR system implies a strong
notion of security for a PKA scheme.

To do this, we simply use the random oracle to hash
each PKA message before we authenticate it (and modify the
other PKA algorithms appropriately). Call this scheme “hashed
PKA”. The running time of the resulting PKA prover will be
greater than the running time of the secondary nameserver
in the PSR by just one random-oracle query. We prove the
following theorem in the full version:
Theorem IV.5. Suppose that we have a PKA scheme
(Setup, P rove, V erif y) which is ε(cid:48)-secure against selective
forgery under an adaptive-chosen-message attack. Then, in the
random oracle model, the “hashed PKA” scheme is ε-secure
against existential forgery under an adaptive-chosen-message
attack, where ε(cid:48) = ε/q(k) and q is some polynomial in k.

B. Digital Signatures from PSR with Simple Query Algorithms
We have seen that PSR systems can be used to construct
public-key authentication schemes of the same computational
complexity. We now point out that PSR systems that satisfy
some restrictions on their query algorithm can actually be used
to construct signature schemes of about the same complexity.
This shows that secondary nameservers in any PSR (whose
query algorithm satisﬁes these restrictions) must inherently
perform online public-key operations.

Consider any PSR system where the Query algorithm
is deterministic (as in our NSEC5 construction). Now apply
the transformation of Section IV-A to obtain a PKA scheme.
Observe that
interaction is not necessary in the resulting

13

PKA scheme, because the PKA prover can compute the PKA
veriﬁer’s ﬁrst message on its own. Thus, the resulting PKA
scheme is actually a signature scheme. The complexity of the
signer is the same as the complexity of the Query and Answer
algorithms in the PSR schemes.

Now suppose the PSR Query algorithm is randomized.
The transformation of Section IV-A above does not work,
because the PKA prover cannot be trusted to choose, or even
to know, the randomness that the Query algorithm uses. We
get around this problem of choosing randomness by using
the approach of Fiat and Shamir [19]: namely, apply the
transformation of Section IV-A, but let the randomness for the
Query algorithm be h(x), where h is a random oracle. This
allows the PKA prover to know the randomness and thus to
compute the PKA veriﬁer’s ﬁrst message q. However, now the
security proof for the resulting signature scheme works only
if soundness for the PSR schemes holds against an adversary
who knows the randomness used in the Query algorithm.

Thus, we obtain the following theorem.

Theorem IV.6. Consider any PSR system (Setup, Query,
Answer, V erif y) for which the Query algorithm is determin-
istic, or for which the randomness of the Query can be given
to the adversary without harming soundness. Such a system
implies an existentially-unforgeable digital-signature scheme
with signing complexity equal to the complexity of Query plus
Answer (plus at most two random oracle queries).

Other PSR models? Although our PSR model separates
nameservers into two parties (primary and secondary), we
still obtain a signature scheme even without this separation
i.e., if we have just a primary nameserver that commits to R
and v(·) and honest secondaries, or when the trusted primary
nameserver itself responds directly to resolvers. This means
that even without the separation of nameservers into trusted
primary and untrusted secondary, a nameserver still have
to generate signatures online in order to both prevent zone
enumeration and maintain soundness.

C. Weaker notions of privacy?

We have shown that we can use a PSR system satisfying
both weak soundness, and our deﬁnition of privacy against
zone enumeration, namely the selective membership require-
ment (Deﬁnition II.5), in order to build signatures and public-
key authentication (PKA) schemes. We therefore want to claim
that we demonstrated that
the work involved in a secure
PSR must be non-trivial, thus explaining why a protocol like
NSEC3, which only uses hashing, inherently cannot prevent
zone enumeration. However, one could protest and argue that
our privacy deﬁnitions are too strong, and that it may be
possible to have a more relaxed deﬁnition of privacy that still
prevents zone enumeration. We argue that this is not the case.
Suppose we modify the f-zk privacy deﬁnition while still
protecting against a resolver that produces an answer for an
element that it did not explicitly query on (i.e., the essence
of zone enumeration). A little more formally, suppose that
there is some distribution on the set R. We require that for
every probabilistic polynomial time adversary A, there exists
a simulator A(cid:48) with oracle access to the set R, such that if A
interacts with a PSR system as a resolver and outputs, at the

end of the interaction, an element x he believes to be in the
set R which A has not explicitly queried (this is ‘success’ if
x ∈ R), there is a simulator A(cid:48) that interacts with an oracle to
the set R, which is successful as well with similar probability.
(Here similar means that the difference is negligible.) We can
show that under this requirement we may obtain a notion
related to selective membership, where instead of two elements
chosen by the adversary, the two elements of the challenge are
chosen at random, by applying a similar reduction to the one in
Theorem II.6. We can also show that the latter implies public-
key identiﬁcation, under a similar reduction to Section IV-A.
Therefore we claim that we have demonstrated that preventing
zone enumeration requires non-trivial computation.

V. FURTHER WORK

In a companion paper [32] we generalize the constructions
of this paper and show how to obtain PSR systems without
random oracles. In [32] we suggest a general construction
based on a weaker variant of veriﬁable random/unpredictable
functions [29]. We describe a construction based on hierar-
chical identity based encryption, and in particular the one
by Boneh, Boyen and Goh [13], which does not reveal any
information about the set R, not even its cardinality. Lastly
we present an interesting construction which uses the unique
structure of cuckoo hashing [35] to construct a PSR that is
based on factoring and the discrete logarithm assumption.

We are also working towards designing and testing practi-

cal implementations of NSEC5.

VI. ACKNOWLEDGEMENTS

We thank Casey Deccio, Paul Hoffman, Daniel Kahn
Gillmor, Ben Laurie, Ondrej Sury, Jared Mauch, Matthijs
Mekking, Benno Overeinder, Jan Vcelak, Wouter Wijngaards,
various other attendees of IETF’90, IETF’91 and the DNS
OARC Fall 2014 workshop, and the anonymous NDSS’15
reviewers for useful discussions and comments.

This material is based upon work supported by the US
National Science Foundation under Grants 017907, 1347525,
1012798, and 1012910, the Israel Science Foundation, BSF
and Israeli Ministry of Science and Technology, and from the
I-CORE Program of the Planning and Budgeting Committee
and the Israel Science Foundation.

REFERENCES

[1] B. Aitken,

“Interconnect

communication MC / 080:DNSSEC
Deployment Study,” http://stakeholders.ofcom.org.uk/binaries/internet/
domain-name-security.pdf, 2011.

[2] P. Albitz and C. Liu, DNS and Bind. O’Reilly Media, Inc., 2001.
[3] R. Arends, R. Austein, M. Larson, D. Massey, and S. Rose, “DNS
Security Introduction and Requirements,” IETF, RFC 4033, Mar. 2005.
[4] ——, “Protocol Modiﬁcations for the DNS Security Extensions,” IETF,

RFC 4035, Mar. 2005.

[5] ——, “Resource Records for the DNS Security Extensions,” IETF, RFC

4034, Mar. 2005.

[6] R. Arends, M. Kosters, and D. Blacka, “DNS Security (DNSSEC) Opt-

In,” IETF, RFC 4956, Jul. 2007.

[7] D. Atkins and R. Austein, “Threat Analysis of the Domain Name

System (DNS),” IETF, RFC 3833, Aug. 2004.
J. S. B. Kaliski, RFC 2437: PKCS #1: RSA Cryptography Speciﬁcations,
Version 2.0.

Internet Engineering Task Force (IETF), 1998.

[8]

14

[40] G. Sisson and B. Laurie, “Derivation of DNS Name Predecessor and

Successor,” IETF, RFC 4471, Sep. 2006.

[41] R. Tamassia and N. Triandopoulos, “Certiﬁcation and authentication of

data structures,” in AMW, 2010.

[42] M. Wander, L. Schwittmann, C. Boelmann, and T. Weis, “GPU-Based
NSEC3 Hash Breaking,” in IEEE Symp. Network Computing and
Applications (NCA), 2014.

[43] S. Weiler and J. Ihren, “Minimally Covering NSEC Records and

DNSSEC On-line Signing,” IETF, RFC 4470, Apr. 2006.

APPENDIX
A. RSA and Trapdoor Permutations

We use the following properties of RSA [38].

RSA is a permutation over all of ZN. Every value x ∈ ZN
is mapped by the RSA forward algorithm to some unique y ∈
ZN ; the RSA inverse algorithm maps y back to x (note that
this holds even when x is not relatively prime to N).

The RSA hardness assumption with respect to exponent e
and security parameter k. The (t, ε) RSA assumption states
that for any adversary whose description size and running time
add up to t, for a random k-bit product N of two primes P, Q
such that e is relatively prime to P −1 and Q−1, for a random
y ∈ ZN , Pr[A(y, N, e) = x and xe ≡ y mod N ] ≤ ε. (The
asymptotic form of this assumption states that there exists a
negligible function ε(k) for every polynomial t(k).)

RSA random self-reducibility Succeeding in ﬁnding the
RSA inverse of any element of a set of r random challenges
is just as hard as succeeding in ﬁnding the inverse of a
single ﬁxed challenge. Speciﬁcally, under (t, ε − r/N ) RSA
assumption, no adversary running in time t(cid:48) ≈ t can ﬁnd the
RSA inverse of any element in a set of r random challenges
in ZN with probability greater than ε. This follows because if
we have an algorithm A that ﬁnds the RSA inverse of some
element in a set of r random challenges, then given a single
challenge z, we can ﬁnd its inverse is follows. In the unlikely
case z = 0, then the inverse is 0; else, in the unlikely case
gcd(z, N ) > 1, ﬁnding the inverse is easy since gcd(z, N )
gives us factorization of N. Else (in the likely case), select
random wi ∈ ZN for 1 ≤ i ≤ r, generate zi = z · we
i mod N,
and run A on the set {zi}r
i=1 (note that this set has r random
elements in ZN since z is coprime with N). Assume no
wi = 0 (else, abort; this will happen with probability at most
r/N). Upon obtaining the RSA inverse of some zi, divide the
result by wi to get the RSA inverse of z (division will fail in
the unlikely case when gcd(wi, N ) > 1, but if it fails, then
gcd(wi, N ) will give us the factorization of N and will allow
us to invert RSA on z, anyway, since wi (cid:54)= 0).

[9]

J. Bau and J. C. Mitchell, “A security evaluation of dnssec with nsec3,”
in NDSS, 2010.

[10] M. Bellare and P. Rogaway, “Random oracles are practical: A paradigm

for designing efﬁcient protocols,” in ACM CCS, 1993.

[11] D. J. Bernstein, “Nsec3 walker,” http://dnscurve.org/nsec3walker.html,

2011.

[12] M. Blum, W. S. Evans, P. Gemmell, S. Kannan, and M. Naor, “Checking

the correctness of memories,” Algorithmica, vol. 12, no. 2/3, 1994.

[13] D. Boneh, X. Boyen, and E.-J. Goh, “Hierarchical

identity based

encryption with constant size ciphertext,” in EUROCRYPT, 2005.

[14] R. Canetti, O. Goldreich, and S. Halevi, “The random oracle method-

ology, revisited,” J. ACM, vol. 51, no. 4, pp. 557–594, 2004.

[15] M. Chase, A. Healy, A. Lysyanskaya, T. Malkin, and L. Reyzin,
“Mercurial commitments with applications to zero-knowledge sets,” in
EUROCRYPT. Springer, 2005.
J. Coron, “On the exact security of full domain hash,” in CRYPTO,
2000.

[16]

[17] D. Dolev, C. Dwork, and M. Naor, “Nonmalleable cryptography,” SIAM

J. Comput., vol. 30, no. 2, pp. 391–437, 2000.

[18] U. Feige, A. Fiat, and A. Shamir, “Zero knowledge proofs of identity,”

in STOC. ACM, 1987, pp. 210–217.

[19] A. Fiat and A. Shamir, “How to prove yourself: Practical solutions to

identiﬁcation and signature problems,” in CRYPTO, 1986.

[20] E. Ghosh, O. Ohrimenko, and R. Tamassia, “Veriﬁable order queries and
order statistics on a list in zero-knowledge,” IACR Cryptology ePrint
Archive, no. 2014/632, 2014.

[21] R. Gieben and W. Mekking, “DNS Security (DNSSEC) Authenticated
Denial of Existence,” IETF DNSEXT Internet Draft http://tools.ietf.org/
html/draft-gieben-nsec4-00, January 2012.

[22] ——, “Authenticated Denial of Existence in the DNS,” IETF, RFC

7129, Feb. 2014.

[23] O. Goldreich, The Foundations of Cryptography - Volume 1, Basic

Techniques. Cambridge University Press, 2001.

[24] S. Goldwasser, S. Micali, and R. L. Rivest, “A digital signature scheme
secure against adaptive chosen-message attacks,” SIAM J. Comput.,
vol. 17, no. 2, pp. 281–308, 1988.

[25] D. Kaminsky, “Phreebird,” http://dankaminsky.com/phreebird/, 2011.
[26] O. Kolkman, W. Mekking, and R. Gieben, “DNSSEC Operational

Practices, Version 2,” IETF, RFC 6781, Dec. 2012.

[27] B. Laurie, G. Sisson, R. Arends, and D. Blacka, “DNS Security
(DNSSEC) Hashed Authenticated Denial of Existence,” IETF, RFC
5155, Mar. 2008.

[28] S. Micali, M. O. Rabin, and J. Kilian, “Zero-knowledge sets,” in FOCS.

IEEE Computer Society, 2003, pp. 80–91.

[29] S. Micali, M. O. Rabin, and S. P. Vadhan, “Veriﬁable random functions,”

in FOCS.

IEEE Computer Society, 1999, pp. 120–130.

[30] A. Miller, M. Hicks, J. Katz, and E. Shi, “Authenticated data structures,

generically,” in POPL. ACM, 2014.

[31] M. Naor and K. Nissim, “Certiﬁcate revocation and certiﬁcate update,”

IEEE J. on Selected Areas in Communications, vol. 18, no. 4, 2000.

[32] M. Naor and A. Ziv, “Primary-secondary-resolver membership proof

systems,” IACR Cryptology ePrint Archive, no. 2014/905, 2014.
J. B. Nielsen, “Separating random oracle proofs from complexity
theoretic proofs: The non-committing encryption case,” in CRYPTO.
Springer, 2002.

[33]

[34] R. Ostrovsky, C. Rackoff, and A. Smith, “Efﬁcient consistency proofs

for generalized queries on a committed database,” in ICALP, 2004.

[35] R. Pagh and F. F. Rodler, “Cuckoo hashing,” in Algorithms - ESA, 2001.
[36] PowerDNS, PowerDNS manual, December 2013.
[37] V. Ramasubramanian and E. G. Sirer, “Perils of transitive trust in the

domain name system,” in ACM IMC, 2005.

[38] R. L. Rivest, A. Shamir, and L. M. Adleman, “A method for obtain-
ing digital signatures and public-key cryptosystems,” Commun. ACM,
vol. 21, no. 2, pp. 120–126, 1978.

[39] M. Sanz, “Dnssec and the zone enumeration,” European Internet
Forum: http://www.denic.de/ﬁleadmin/public/events/DNSSEC testbed/
zone-enumeration.pdf, October 2004.

15

