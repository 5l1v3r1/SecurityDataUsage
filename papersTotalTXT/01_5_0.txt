I Do Not Know What You Visited Last Summer:
Protecting Users from Third-party Web Tracking

with TrackingFree Browser

Xiang Pan

Northwestern University

xiangpan2011@u.northwestern.edu

Yinzhi Cao

Columbia University

yzcao@cs.columbia.edu

Yan Chen

Northwestern University
ychen@northwestern.edu

Abstract—Stateful third-party web tracking has drawn the
attention of public media given its popularity among top Alexa
web sites. A tracking server can associate a unique identiﬁer
from the client side with the private information contained in the
referer header of the request to the tracking server, thus recording
the client’s behavior. Faced with the signiﬁcant problem, existing
works either disable setting tracking identiﬁers or blacklist third-
party requests to certain servers. However, neither of them can
completely block stateful web tracking.

In this paper, we propose TrackingFree, the ﬁrst anti-tracking
browser by mitigating unique identiﬁers. Instead of disabling
those unique identiﬁers, we isolate them into different browser
principals so that the identiﬁers still exist but are not unique
among different web sites. By doing this, we fundamentally cut off
the tracking chain for third-party web tracking. Our evaluation
shows that TrackingFree can invalidate all the 647 trackers found
in Alexa Top 500 web sites, and we formally veriﬁed that in
TrackingFree browser, a single tracker can at most correlate user’s
activities on three web sites by Alloy.

I.

INTRODUCTION

Stateful third-party web tracking, the practice by which third-
party web sites collect private information about web users, has
been adopted by more than 90% of Alexa Top 500 web sites [34].
To track a web user, a third-party tracking1 site ﬁrst needs to
identify the user by a unique string stored in client-side state.
Then, the tracking site associates the identiﬁer of the user with
the private information, such as ﬁrst-party web site domain name,
contained in the referer header of the third-party request.

Faced with the signiﬁcance of third-party tracking in the
wild, researchers have proposed solutions targeting the two
steps of third-party tracking: mitigating the unique identiﬁer like
disabling third-party cookies, or cutting off requests with private
information like blacklisting known tracking servers. However,

1In this paper, unless otherwise stated, third-party tracking refers to stateful

third-party tracking.

Permission to freely reproduce all or part of this paper for noncommercial
purposes is granted provided that copies bear this notice and the full citation
on the ﬁrst page. Reproduction for commercial purposes is strictly prohibited
without the prior written consent of the Internet Society, the ﬁrst-named author
(for reproduction of an entire paper only), and the author’s employer if the
paper was prepared within the scope of employment.
NDSS ’15, 8-11 February 2015, San Diego, CA, USA
Copyright 2015 Internet Society, ISBN 1-891562-38-X
http://dx.doi.org/10.14722/ndss.2015.23163

neither of the approaches can completely protect users from
third-party tracking: in addition to browser cookies, a tracker
can store user’s unique identiﬁer into many other places on
client-side state, such as Flash ﬁles [4] [26] [17] and browser
caches [26] [4] [17]; meanwhile, blacklist tools highly depend
on all the records in the database and a tracking company can
always adopt new domains to track users.

To address the shortcomings of existing anti-tracking ap-
proaches, a third-party tracking defense system should achieve
the following goals:
• Complete blocking. The system can completely block all
existing stateful third-party tracking techniques, such as those
tracked by browser cookies, caches, HTML5 localStorage and
Flash ﬁles.
• High function preservation. While blocking third-party
tracking, the system should be compatible to existing web
sites and web services.
• Low performance overhead. The system should incur afford-
able overhead compared with that of normal browsing.

In this paper, we propose TrackingFree, the ﬁrst anti-tracking
browser that can completely protect users from stateful third-
party tracking practice. Instead of disabling places that store
third-party unique identiﬁers, such as browser cookies and ﬂash
ﬁles, TrackingFree automatically partitions client-side state into
multiple isolation units (a.k.a., browser principals) so that the
identiﬁers still exist but are not unique any more. Therefore, third-
party tracking web sites cannot correlate a user’s requests sent
from different principals with those identiﬁers. As a comparison,
all existing multi-principal browsers [5], [8], [10], [15], [28],
[38] aim to protect users from memory attacks and cannot defend
against tracking practices. To summarize, we make the following
contributions:
• Anti-tracking Content Allocation Mechanism. To obtain
the completeness of anti-tracking capability, TrackingFree
partitions client-side state into different browser principals
through a novel content allocation mechanism. TrackingFree
ﬁrst allocates initial server-side contents based on the regis-
tered domain names, and then allocates derivative server-side
contents, such as user-navigated windows/frames and pop-up
windows, based on a dynamically generated in-degree-bounded
graph with its nodes as browser principals.
• Privacy-preserving Communication. TrackingFree is the
ﬁrst multi-principal browser with isolated client-side state
that enables communication among different principals. The

on the kernel, has isolated persistent storage so the third-party
contents in different principals cannot share the same identiﬁers.
We adopt proﬁle based isolation mechanism [9] [31] because
of its completeness in isolating client-side state and minimum
overhead. Proﬁle will also isolate user preferences, so we propose
preference conﬁgure to synchronize all user-initiated preferences
among all principals. See Section III-D for details.

In addition to isolation mechanism, another key factor for
TrackingFree is content allocation mechanism. In TrackingFree,
the principal manager handles how to allocate contents from
the server into different browser principals. Speciﬁcally, it
dynamically determines how to put different frames into different
principals based on user activities, frame properties and principal
organization. Principal organization is maintained by principal
backend as a directed graph with maximum in-degree set as two.
We claim that TrackingFree’s content allocation mechanism can
strike a good balance between privacy and compatibility. We
will discuss it in details in Section III-B.

Principal communication also plays an important role for
browser’s privacy and compatibility. They can be classiﬁed
as two categories: explicit communication (e.g., postMessage)
and implicit communication (e.g., history information sharing).
In TrackingFree, message policy enforcer and public history
manager handle all the principal communication: the former
restricts the range of explicit communication for privacy-
preserving purpose and the latter proposes a secure history
sharing channel. We will discuss principal communication in
Section III-C.

TrackingFree also gives user the ﬂexibility of controlling the
balance between anti-tracking capability and user experience.
Speciﬁcally, the two components of domain data manager can
decrease the number of principals and share speciﬁed domains’
sessions among multiple principals, while still achieving expected
privacy. Domain data manager will be discussed in Section III-E.

B. Content Allocation

TrackingFree’s content allocation mechanism is composed
of two parts: initial content allocation and derivative content
allocation. Initial content allocation handles top frames that are
navigated by user directly, that is, the web pages opened through
address bar and command line parameters. Derivative content
allocation handles frames that are generated due to other frames’
contents, such as pop-up window and iframe. We refer to these
frames as child frame.

1) Initial Content Allocation: Initial content allocation is
based on the registered domain name (e.g., google.com and
sina.com.cn) of the top frames directly navigated by users.
For these frames, TrackingFree will group them in the same
principal if and only if they have the same registered domain.
For example, in Fig. 1, web pages mail.a.com and news.a.com,
though belonging to different subdomains, are located in the
same principal. Isolating subdomains will bring little extra
privacy beneﬁts, but can break the functionality of a large
amount of web sites: two subdomains, say, www.google.com
and gmail.google.com, with the same parent domain would not
be able to set cookie for each other, which, however, is a very
common practice for many web sites.

Plugin objects, such as Flash or SilverLight ﬁles, are
embedded in web pages and can also be utilized by trackers

Algorithm 1 Principal Switch Determination Algorithm
Input:

target : F rame
source : F rame
domain : Domain
isU serT riggered : Boolean

. target frame
. source frame
. the domain of the principal

(source.isM ainF rame() and isN avigation(source, target))

Output:
1: isCrossSiteReq ( (not equal(target.domain, domain))
2: isM ainF rameN av (
3:
4: if isM ainF rameN av & isCrossSiteReq then
5:
6: else if isCrossSiteReq & isU serT riggered then
7:
8: else
9:
10: end if

return switch-principal

return switch-principal

return non-switch

to store identiﬁers [35] [4]. We treat plugin objects like other
HTML objects: putting them in the same principal as their
embedding frames to cut off the identiﬁer sharing channels
provided by plugin objects.

2) Derivative Content Allocation: Once a frame is placed
in a principal, TrackingFree needs to decide how to allocate
its child frames. There are two steps in allocating those child
frames. First, TrackingFree decides whether those child frames
should stay in the same principal as their parent frames. A short
answer is that TrackingFree keeps all non-user-triggered child
frames in the principals that their parent frames reside in, and
moves all user-triggered cross-site frames to other principals.
This process is deﬁned as principal switch. Each frame can
at most be switched once in its creation phase. Second, for
those frames that need to be moved out of current principal,
TrackingFree selects an existing principal or creates a new
one to render them. This process is deﬁned as principal selection.

Principal Switch. There are two intuitive yet extreme
principal switch algorithms: keeping all child frames in current
principal (no switch) and making a switch for every child frame.
However, keeping all child frames in the same principal allows
trackers to collect user’s browsing history; making a switch all
the time causes serious compatibility issues.

Therefore, TrackingFree should make principal switch as
little as possible, while still preserving user’s privacy. We propose
a switching algorithm in Algorithm 1. Whenever a new child
frame is about to generate, TrackingFree will run Algorithm 1
to determine if it needs to be switched out. For convenience,
we refer to the newly-created child frame as target frame, its
URL as target URL and the frame that generates target frame as
source frame. We also denote the ﬁrst frame of each principal
as main frame.

if target frame is about

Main frame’s domain should always be consistent with
principal’s domain. Therefore,
to
replace main frame, which we denote as main frame navigation,
TrackingFree will move the target principal out as long as it is
a cross-site navigation. In other cases (e.g., navigation on child
frame, new popup window), whether or not to switch principal
also depends on if the target principal is user-triggered. For
example, in Fig. 1, iframe online.b.com/m resides in principal
a.com because it is not generated from user’s activity; if a user
clicks a link toward online.b.com/n in this frame, TrackingFree
will put the target frame in a new page and render them in

3

a different principal (principal b.com in Fig. 1). The reason
we handle these two frames differently is that
third-party
trackers in this principal do not know a user’s real intention for
online.b.com/m: it will be automatically visited if the user visits
news.a.com. On the other hand, child-frame online.b.com/n is
generated by the user and thus shows the user’s preferences.
Keeping it in the original principal would leak out user’s
privacy at least to trackers embedded in frames news.a.com
and online.b.com/n.

A key for Algorithm 1 is to dynamically monitor whether a
target frame is user-triggered. In TrackingFree, we adopt an
approximation approach to do this efﬁciently: TrackingFree
hooks up all the click events and keyboard events in any frames.
Once an event is triggered, it will label the frame on which the
event happens as user-activated frame. In Fig. 1, every frame
has a property to indicate whether it is a user-activated frame.
When a new frame gets created, TrackingFree can determine if
it is user-triggered by checking its source frame’s user-activated
ﬂag. This approach can result in false positive (mistakenly label
an automatically generated target frame as user-triggered), but
TrackingFree’s privacy-preserving capability is still guaranteed
because of no false negative.

Principal Selection. We propose an in-degree-bounded
graph approach for principal selection to strike a balance between
compatibility and privacy-preserving ability. In TrackingFree,
the principal backend (Fig. 1) maintains a graph to organize
principals, in which each principal is a node. A directed edge
from principal A to principal B exists if and only if at least
one principal switch from A to B has occurred before. The
principal graph may contain several mutually disconnected
sub-graphs. Each sub-graph contains a starting point principal,
which is created based on initial content allocation mechanism,
and possibly many derivative principals, based on derivative
content allocation mechanism. TrackingFree is conﬁgured with
a maximum in-degree value3 and enforces the number of
any principal’s parents never exceeding this value. The value
determines tracker’s tracking capability. If we let P denote the
number of principals a tracker can correlate (tracking range) in
worst case, k denotes the maximum in-degree value of principal
graph, their relationship is given by:

P = (k + 1) ⇤ (c + 1),

(1)

where c denotes the number of non-tracking sites willing to
relay tracking identiﬁers for trackers. We have not found such
non-tracking web sites in practice, which will be discussed in
details in Section VI-A4. Currently, it is safe to say in most
cases, c equals to zero. We choose the value of k as two because
it can achieve a good balance between privacy and compatibility:
setting it to one leads to serious compatibility issues, while any
number larger than two extends tracker’s tracking range without
making further contributions to compatibility. When k equals to
two and c equals to zero, we formally verify that TrackingFree
can limit tracker’s tracking range no more than three principal
instances using Alloy and experimentally demonstrate 67 out
of 68 third-party services from Alexa Top 50 web sites work

3In directed graph, the number of head endpoints adjacent to a node is called
the in-degree of the node. The maximum in-degree of a graph is the in-degree
of the node with largest in-degree in the graph.

Algorithm 2 Target Principal Selection Algorithm
Input:

manager : P rincipalM anager
cause : EventCause
source : P rincipal
request : HT T P Request

manager.f indStartingP ointP rincipal(request.domain)

source, request.domain)

current ( candidates.getN ext()
if equal(current, N U LL) then

break

target (
if not equal(target, N U LL) then

return target

Output:
1: target ( N U LL
2: if equal(cause, AddressBar) or equal(cause, Argument) then
3:
4:
5:
6:
7:
end if
8:
target ( manager.buildP rincipal(request.domain)
9: manager.appendStartingP ointP rincipal(target)
10:
return target
11: end if
12: candidates (
13: manager.breadthF irstSearchP rincipalGraphReversely(
14:
15: loop
16:
17:
18:
19:
20:
21:
22:
23:
24:
end if
25: end loop
26: if equal(target, N U LL) then
27:
28:
29:
30:
31:
32:
33: manager.appendChildP rincipal(source, target)
34: end if
35: manager.appendParentPrincipal(target, source)
36: return target

end if
parents_num ( manager.getP arentsN umber(current)
if less(parents_num, 2) then

end if
target ( manager.buildP rincipal(request.domain)

target (
if not equal(target, N U LL) then

return target

manager.f indChildP rincipal(source, request.domain)

target ( current
break

properly in TrackingFree. Fig. 2 shows an example of principal
graph.

Algorithm 2 illustrates how TrackingFree selects target
principals. Line 2-11 shows that if a web page is opened
through address bar or command line argument, TrackingFree
will put it in a starting point principal. Line 12-36 indicates
when a principal switch occurs, TrackingFree ﬁrst looks up
appropriate target principal from source principal’s ancestors.
If there exists an ancestor principal that meets the following
two conditions: 1). its domain is same as that of the target
URL, and 2). the number of the principal’s parents (the node’s
in-degree) is less than two, TrackingFree will set it as the
target principal (line 12-25). Only if TrackingFree fails to
ﬁnd target principal from ancestors, would a child principal
with the appropriate domain be selected. If there is no such
child principal, TrackingFree will construct a new one. After
selecting the target principal, TrackingFree needs to update
the parent-child relationship on principal organization graph
maintained by principal backend (line 35).

C. Principal Communication

Another important topic for any multi-principal browser
is principal communication, which can be classiﬁed into two
categories: explicit communication and implicit communication.
On one hand, principal communication can be abused by

4

communications; (4). if authentication succeeds, the user will
be redirected back to yahoo.com with access token and several
other parameters from facebook.com and SSO process ﬁnishes.
When using TrackingFree, principal switch occurs in step (2)
and (4). As we adopt two-in-degree-bounded graph algorithm,
two different principals, one for Yahoo and the other for Face-
book, get involved in the SSO scenario and the user will ﬁnally
be redirected to the original Yahoo principal. More importantly,
all necessary information from one principal to another are all
passed through URL parameters, which TrackingFree allows.
These two conditions guarantee TrackingFree not breaking
this SSO scenario. There exist a few SSO scenarios that are
more complicated than Facebook SSO service. For example,
login sears.com using user’s Google account, which we have
discussed in Section III-E1, involves four different principals, but
since information are still exchanged through URL’s parameters,
TrackingFree does not break its functionality either.

We have analyzed all

the 36 SSO scenarios found in
Alexa Top 50 web sites and conﬁrmed that 34 of them
only use URL parameter to exchange information. The rest
two cases, login ask.com with user’s Facebook and LinkedIn
accounts, also use postMessage API to pass data among involved
principals. TrackingFree supports this communication channel,
so theoretically, TrackingFree does not break any of the SSO
scenarios. In practice, this version of TrackingFree did fail one
SSO scenario (login pinterest.com with Facebook account) due
to implementation issue, but user can still use this service with
the help of TrackingFree’s domain data migration component
(see Section VI-B3).

B. Cross-site Contents Sharing

With online social network (OSN) getting more and more
popular, sharing one site’s contents to the user’s OSN accounts
becomes increasingly popular. We will use the example of
sharing a Youtube video to user’s Twitter web page to show
how TrackingFree works for these services.

When a user clicks ”Share to Twitter“ button below a Youtube
video, a navigation request URL toward twitter.com, carrying all
the information about the video on its parameters, is generated.
Instead of directly sending the request, TrackingFree switches to
another principal, where the request gets sent out. After receiving
the request, Twitter authenticates the user and shares the video
to user’s account if authentication succeeds. In the process, the
communication channel used by the two principals is navigation
URL’s parameters. As we allow this channel, TrackingFree does
not break cross-site contents sharing’s functionalities. Some other
third-party services, including third-party online payment and
OSN like/+1 button, have similar working scenarios, so they all
work as expected on TrackingFree, which has been conﬁrmed
by our evaluation results on all 32 non-SSO third-party services
found on Alexa Top 50 web sites.

Though not breaking functionalities of third-party services,
we admit that TrackingFree does affect user experiences: when
a user wants to share contents from several different web sites
(e.g., Pinterest and Youtube) to the same OSN (e.g., Facebook),
the user might need to login her OSN account several times
if that has not been done before. We provide domain data
synchronization component to give user the option of choosing
between privacy and user experience, which will be discussed

in Section IV-C. Moreover, as all the principals adopt persistent
client-side storage, a user only needs to login once for each
third-party service. For example, the user does not need to login
again when she wants to share the second video from Youtube
to her Facebook account.

C. Working on Multiple Principals of a Single Site

TrackingFree can create several different principals for a
single web site in order to preserve user’s privacy, which might
lead to inconsistency. We use the example of shopping on
Amazon to demonstrate the issue. When a user visits amazon.com
through address bar and puts a book into shopping cart,
TrackingFree uses amazon.com’s starting point principal, whose
cookie stores the cart’s contents. Then, the user opens another
web page of amazon.com by clicking a link on google.com.
As the new page is opened through different visiting path,
TrackingFree renders the page in another principal. This time,
the user puts a chocolate into her shopping cart and the cookie
records the product. Since the two shopping carts’ contents are
stored in different cookie storages, the user has to checkout
in both principals to purchase the book and chocolate, which
affects user experience.

TrackingFree takes two approaches to address the incon-
sistency. First, when a principal gets activated, TrackingFree
checks if there exist other principals with the same domain and
if so, pops up a notice reminding the user and encourages her to
work on one of them. Secondly, the domain data synchronization
(DDS) of domain data manager component allows users to decide
the balance between privacy and user experience according to
there own needs. DDS enables multiple principals to synchronize
client-side data (e.g., cookies, HTML5 local storage) belonging
to domains that the user speciﬁes, while still achieving the same
anti-tracking capability for all the other domains. DDS is disabled
by default as TrackingFree gives privacy and compatibility
the highest priority. To enable it, a user needs to register 1).
one or several synchronizing domains and 2). principals to be
synchronized for each of the domains, which we refer to as
synchronization scope. DDS monitors and synchronizes each
speciﬁed domain’ data among corresponding synchronization
scope. In this example, synchronizing domain should be set as
amazon.com while synchronization scope set as all principals
with domain of amazon.com. In the contents sharing scenario
discussed in Section IV-B, they should be set as facebook.com,
then the user only needs to login her Facebook account once
when sharing contents from various other web sites.

Once domain data synchronization is enabled, the overall
formally-proven privacy-preserving capability of TrackingFree
cannot be guaranteed. In the example discussed above, trackers
belonging to amazon.com can correlate user’s activities on at
most 3 ⇤ N principals without collaborating with other sites,
where N is the number of Amazon principals. In practice, this
is hard to achieve because the condition for the worst case
is not easy to meet. Moreover, since it only synchronizes the
data belonging to amazon.com, TrackingFree still protects user
against trackers from other domains.

V.

IMPLEMENTATION

We implemented a proof-of-concept TrackingFree in
Chromium with around 1,800 lines of codes. We changed

7

Chromium’s proﬁle mechanism to isolate different principal.
Each principal resides in a unique directory,
in which all
the persistent storages (e.g., cookie jars, cache storages), user
preferences and plugin ﬁles are stored. TrackingFree maintains a
table to map principals to these directories, which guarantees that
no two principals correspond to the same directory. Moreover, we
hooked WebUIImpl::ProcessWebUIMessage and PrefService::Set
methods to monitor user-initiated preference change.

For better efﬁciency, we modiﬁed Chromium’s render and
asked TrackingFree to determine principal switch directly in
render process. If a principal switch is required, TrackingFree
passes the request information to browser kernel, where principal
manager determines target principal. We hooked all the click
events to record whether there are user activities on each frame.
All cross-site messages will be intercepted and sent back to
browser kernel, where TrackingFree’s message policy enforcer
checks if each message is permitted based on our policies
and, if it is, sends these messages to target principal through
IPC messages. We also implemented a history manager object
for each principal (proﬁle) and it monitors the principal’s
HistoryService, DownloadManagerImpl and BookmarkModel
objects. Whenever there is a change, the history manager will
inform it to public history manager object, which is running
on an isolated daemon principal and responsible for updating
browser UI.

As for domain data manager, the current implementation only
supports cookie migration and synchronization, but it can be
easily extended to support other storages. We hooked all cookie
message handlers, such as OnSetCookie and OnDeleteCookie
in class RenderMessageFilter, to monitor and update cookie
changes in different principals.

VI. EVALUATION

We evaluate TrackingFree in two ways. First, we perform
a formal analysis for its anti-tracking capability. Then we
experimentally assess the system’s anti-tracking effectiveness,
performance overhead and compatibility. In this section, unless
otherwise stated, both domain data migration and domain data
synchronization are disabled.

A. Formal Analysis & Discussion

We use model-checking tool to formally analyze Track-
ingFree’s anti-tracking ability. To compare TrackingFree with
browsers adopting other content allocation mechanisms, we
further evaluate browsers that adopt top-frame based and same-
origin-policy (SOP) based content allocation mechanism. The
model-checking framework we adopt is Alloy [16], a declarative
modeling language based on ﬁrst-order relational logic. Alloy has
been used in a wide range of applications to ﬁnd vulnerabilities
in security mechanisms, among which, Akhawe et al. [3] have
proposed a complete web model in Alloy. Our evaluation is
based on the client/server model described in [3], whose client-
side is redesigned according to TrackingFree’s architecture. In
formal analysis, we assume that non-tracking web sites do not
relay identiﬁers for tracking sites and different tracking sites do
not exchange a user’s identiﬁer with each other. We will discuss
tracker’s tracking range in Section VI-A4 if the assumptions do
not hold.

1) TrackingFree Evaluation:

Security Goal. The broader security goal of TrackingFree
is to defend against cross-site web tracking. We distill two more
concrete goals, both of which are modeled by Alloy assertions.
• For any two HTTP requests toward tracking servers while
sent from different principals, we denote the identiﬁers carried
by each of them as setA and setB, then the following formula
should always hold:
(setA\setB 6= ;) implies ((setA ✓ setB)or(setB ✓ setA))
• The tracking identiﬁers carried in any HTTP request toward
tracking servers are at most stored in the client-side states of
three different principals.

identiﬁers,

these must exist at

The ﬁrst goal shows that if tracking servers can correlate
several different
least one
request carrying all of these identiﬁers. The second indicates
the maximum principals that can be correlated by tracking
companies through one request. Therefore, the two goals, if
met, illustrate the extent a TrackingFree user can be tracked in
the worst case.

Modeling TrackingFree. In Alloy, we model TrackingFree
through Alloy signature, which represents a set of objects. Every
Alloy signature has zero to several properties, which, from the
view of set theory, are relations. We also describe the two
goals discussed above as two Alloy assertions, which will be
checked by Alloy in a speciﬁed scope. Alloy tries to ﬁnd counter
examples for these assertions. If it does not ﬁnd one, we say
that the assertions hold up to the scope size we speciﬁed since
Alloy will not miss any counter examples in the speciﬁed space.
When searching for counter examples, Alloy follows the facts
described by users. In our model, we describe the behaviors of
TrackingFree and tracking servers in twenty-three facts.

persistentStorage :

set PersistentStorageUnit,

1 one sig TrackingFreeKernel extends Browser{
startingPoints: Origin -> lone Principal
2
3 }
4 sig Principal{
5
6
7
8
9
10
11
12
13 }

parent : set Principal,
browser : one TrackingFreeKernel,
mainFrame : one ScriptContext

domain : Origin,
childPrincipal :

Origin -> lone Principal,

Code 1: TrackingFree Signatures

Code 1 describes the signature of TrackingFree. Each
TrackingFree is composed of one TrackingFreeKernel object and
multiple Principal objects. The relation startingPoints deﬁned
in signature TrackingFreeKernel maps each TrackingFreeKernel
object to a set of relations, which then relates each Origin to
its Principal, if there is one. Through the set of relations, we
can get all the TrackingFree’s starting point principals by their
Origins. The relations in Principal are also straightforward. The
persistentStorage relates each principal to its client-side state,
where tracking identiﬁers assigned to this principal are stored;
domain illustrates the principal’s Origin, which is the origin
of main frame, accessed by relation mainFrame; childPrincipal

8

Tracking Host

b.scorecardresearch.com
ad.doubleclick.ne
ib.adnxs.com
p.twitter.com
cm.g.doubleclick.net
ad.yieldmanager.com
bs.serving-sys.com
cdn.api.twitter.com
secure-us.imrworldwide.com
adfarm.mediaplex.com
d.adroll.com
img.mediaplex.com
ds.serving-sys.com
hm.baidu.com
pixel.mathtag.com

Prevalance
(# Domains)

133
117
75
70
56
52
40
40
38
31
30
29
27
27
23

Tracking
Token(s)
UIDR

id, __gads

__utma

anj

id
bx
A4

__utmz
IMRID

svid

__adroll

svid

u2, __qca,A4

BAIDUID
uuid,HRL8

Table I: Top 15 Cross-site Trackers on Alexa Top 500 web sites

the tracking range of host web site i, N denote the number of
host web sites, and functions max and secondmax calculate
the largest value and second largest value of a set respectively,
tracking site’s tracking range is given by:
P = max{ R1 . . . RN} + secondmax{ R1 . . . RN} + 1 (2)
So the tracking site’s tracking range is the sum of the top two
host sites’ tracking ranges plus one. Host web sites’ tracking
ranges remain the same. If host sites are not trackers (only
track users within their own domains), tracking site’s tracking
range is still limited to three. If host web sites also serve as
third-party trackers, tracking site’s ability is restricted within
seven principals, were host sites not exchanging identiﬁers with
others.

B. Experiments with Real World Web Sites

1) Anti-tracking Capability:

In order to measure Track-
ingFree’s ability in defending against cross-site third-party
tracking, we ﬁrst gather trackers on Alexa Top web sites by
strictly following the tracker detection methodology presented
by existing work [34], and then evaluate how many of them
can be invalidated by TrackingFree. This approach, involving
both manual and automatic workloads, can only give a lower
bound of trackers, but the evaluation can still be a good indicator
showing TrackingFree’s anti-tracking ability.

Speciﬁcally, we conduct the experiment on Alexa Top 500
web sites. In each site, we randomly visit four more pages. As
some links are broken or redirect to the same link, we ﬁnally
get 2,032 valid URLs as our dataset. We visit these URLs
and capture all the HTTP(S) trafﬁcs. This process is repeated
twice: once starting with a clean browser and once more after
priming the client-side state. After that, we analyze the captured
trafﬁcs and identify cross-site trackers based on their behaviors
summarized by work [34].

We ﬁrst conduct the experiment in standard Chromium. We
ﬁnd a total of 647 trackers, appearing in 5,814 requests, which
we refer to as tracking requests. Table I lists the top 15 prevalent
cross-site tracking hosts ordered by the number of domains they
appear. Then we repeat this experiment with TrackingFree. The
results show that we do not ﬁnd any trackers. TrackingFree
block all of the 647 trackers found in vanilla Chromium.

11

Source
Principal Construction

Persistent State Construction
In-memory State Construction

Extra IPC
Render/JS Engine Instrumentation

Cost (ms)
322.36
98.03
224.33
349.06
139.21

Table II: Cost of TrackingFree

We also ﬁnd that blacklist-based tracking prevention products
can not effectively protect users from tracking. We use the
blacklist tool Ghostery [13] for comparison, which is one of
the most effective privacy protection extensions based on open
source measurement project “Are We Private Yet” [1], Through
examining the 5,814 tracking requests on Ghostery’s blacklist,
we ﬁnd the blacklist missing 1,057 requests, belongs to 53
tracking hosts.

2) Performance: We measure the impact of our architecture
on browser performance. All experiments are done in 1.3GHz
dual-core Intel Core i5 processor, 4GB memory, 128GB ﬂash
storage, running OSX Mavericks operating system. To evaluate
TrackingFree’s performance, we have measured page loading
time, memory usage and disk usage.

Latency. The latency cost of TrackingFree comes from
three sources: 1). principal construction, 2). extra inter-process
communication (IPC) and 3). render and JavaScript engine
(render/JS engine) instrumentation. Principal construction refers
to the extra cost used to build a principal in TrackingFree,
compared with the cost for creating a new render process in
Chromium; extra IPC cost only exists in cross-site navigation, in
which the navigation request will be passed to browser process
from source render process and then sent back to target render
process after new principal has been constructed; render/JS
engine instrumentation cost results from extra instrumentations
on WebKit engine and JS engine, such as hooking all mouse
and message events, existing in all the navigation practices.

We evaluate the costs of principal construction (1) and
render/JS engine instrumentation (3) by browsing Alexa Top 25
web sites with TrackingFree and calculating their average cost.
To measure extra IPC cost (2), we visit Alexa Top 25 web sites
and then randomly click a cross-site link from each of the site.
Table II shows the average of each cost. Note that not all the
browsing scenarios will suffer from all the overhead listed above.
Speciﬁcally, cross-site navigation is the only scenario that might
experience all the three costs, so on average, compared with
vanilla browser, TrackingFree incurs ⇠810 ms extra overhead
for cross-site navigation. In other scenarios, the average costs
range from ⇠140 ms to ⇠460 ms.
To measure the overall impact of our architecture on browser
performance, we further conduct the following four experiments,
spanning browsing scenarios from lowest latency case (within-
site navigation) to highest latency case (cross-site navigation).
Each experiment is repeated ﬁve times to reduce the disturbance
from networking delay. Fig. 7 is based on the median values of
the ﬁve-round results.
• Address Bar Navigation without Principal: Experiment
a is to evaluate the overall latency of visiting web pages
whose principals have not been created. In this experiment, a
web page’s loading time is calculated from the time pressing

Memory
1 Domain
4 Domains
12 Domains

Chromium TrackingFree
477.1(MB)
623.6(MB)
434.6(MB)

505(MB)
702.8(MB)
642.5(MB)

Increase
27.9(MB)
79.2(MB)
207.9(MB)

Table III: Memory Overhead

Disk
1 Domain
4 Domains
12 Domains

Chromium TrackingFree
21.3(MB)
22.5(MB)
23.7(MB)

21.8(MB)
25.9(MB)
29.4(MB)

Increase
0.5(MB)
3.4(MB)
5.7(MB)

Table IV: Disk Overhead

user’s conﬁguration ﬁle as the maximum disk space that can
be allocated. Once the threshold is achieved, TrackingFree will
delete those least frequently used principals.

3) Compatibility: We evaluate TrackingFree’s compatibility
through three experiments. The ﬁrst experiment is to evaluate
whether TrackingFree is backward compatible to existing ﬁrst-
party web sites. We manually run TrackingFree on Alexa Top 50
web sites. For each site, we open its main page through address
bar. Once it has been fully loaded, we continue to perform a
within-site navigation and a cross-site navigation, if there is one.
In this period, we check the visual appearance of each web
page and the stability of TrackingFree. The results show that
TrackingFree is completely backward compatible to these 50
web sites.

The second experiment is to measure TrackingFree’s com-
patibility toward third-party services. In this experiment, we
ﬁnd 68 third-party services from Alexa Top 50 web sites and
manually test them on TrackingFree. The third-party services we
have found can be classiﬁed into three categories: 1). cross-site
online payment; 2). cross-site content sharing; and 3). single
sign-on (SSO). The evaluation results show that 67 out of
68 third-party services work properly on TrackingFree. We
discuss in details why TrackingFree preserves these services’
functionalities in Section IV. The failed case is a SSO service,
logging pinterest.com through user’s Facebook account. Through
analysis, we believe it resulting from implementation issue: a
JavaScript error leads to a post request not sent out, and thus
not able to ﬁnish the last login step. User can still use this failed
SSO service with little privacy cost and user burden through
TrackingFree’s domain data migration component: performing
SSO login activity in transient principal and switching back to
regular principal after login succeeds.

The third experiment is to evaluate whether the two commu-
nication restriction rules are reasonable. The ﬁrst rule regulates
that in the scenario of user visiting web site A, then opening web
site B from A, and then site C from B, communication between
web sites A and C is not allowed. In order to measure whether
the forbidden cases are rare, we ﬁnd and test 70 browsing
practices in this scenario (A ) B ) C) from Alexa Top 500
web sites and evaluate the number of communications among
web site A, B and C. The results show that the number of
message events between A and B, as well as B and C is 3,119,
which TrackingFree allows, while the number of message events
between A and C is zero. The second rule forbids third-party
elements, embedded in A, communicating with elements in sites
other than A. In this experiment, we evaluate the number of

message events between site B and C, in the scenario that
there exists a site A, which embeds an iframe of site B and
a cross-site link toward site C. We ﬁnd and test 58 browsing
practices in this scenario from Alexa Top 500 web sites. The
results show that the number of message events between site A
and B, which TrackingFree allows is 4,852 and the number of
message events between B and C is 6. All of the six messages
are communicated between stubhub.com (C) and doubleclick.net
(B), one of the largest tracking companies. In sum, among all the
7,971 communications allowed in regular browser, TrackingFree
only forbids 6 of them.

VII. RELATED WORK

Measurement of Web Tracking. The practice of web
tracking has been studied extensively. Mayer and Mitchell give
the most comprehensive discussion about third-party tracking,
including tracking techniques, business models, defense choices
and policy debates [26]. Another important measurement work
is proposed by Roesner et al., in which the authors propose
a comprehensive classiﬁcation framework for different web
tracking practices [34]. Soltani et al. and Ayenson et al.
measure the prevalence of non-cookie based stateful tracking
and show how tracking companies use multiple client-side
states to respawn deleted identiﬁers [35] [4]. Yen et al. and
Nikiforakis et al. discuss the techniques of stateless tracking
in their works [41] [32]. In addition to tracking behaviors and
techniques, Krishnamurthy et al. [20] [19] [18] [21] focus on
the risk of harm resulted from web tracking, showing that not
only user’s browsing history, but also other sensitive personal
information, such as name and email, can be leaked out.

Existing Anti-tracking Mechanisms. Although web track-
ing has garnered much attention, no effective defense system
has been proposed. Most commercial anti-tracking tools ( [2],
[13], [30]) are based on blacklists, which will
leave user
unprotected were the trackers not collected by their databases;
Roesner et al. [34] proposed a tool called ShareMeNot, but
it can only defeat against social media button tracking, a
small subset of tracking practices. Private browsing mode [40]
signiﬁcantly affects user experience as user can not persistently
save anything on client-side state and users can still be tracked
before closing the browser. The Do Not Track(DNT) [39] header
and legislation require tracker compliance and cannot effectively
protect users from tracking in reality [34] [26]. Disabling third-
party cookie, which is supported by most browsers [29] [14]
[27], can be easily bypassed through non-cookie-based tracking
approaches [17] [34] [35] [4] and also suffer from compatibility
issues5. According to existing work [34], among all the 476
cross-site trackers found in Alexa Top 500 web sites, DNT can
only block 27 (5.7%) of them, while disabling third-party cookie
can block 367 (77.1%) of them.

Existing Multi-principal Browsers. A number of re-
searchers and companies have proposed browsers with different
isolation mechanisms [5] [28] [15] [38] [10] [15] [7] [6]
[23] [8] [12] or utilities that facilitate browsing with multiple
browsers [11] [25]. Gazelle [38], WebShield [23], Chromium [5],
Internet Explorer 8 (IE8) [28], VirtualBrowser [6], COP [7]
and OP browser [15] adopt different isolation policies, but

5For example, when disabling third-party cookies, user will fail login sears.com

with Facebook.com account

13

Browser

Isolation Mechanism

Contents Allocation Mechanism Stateful Anti-tracking

Capability

No
No
No
No
No
No

Incomplete
Incomplete
Incomplete
Incomplete
Complete

Gazelle [38], WebShield [23]

Chromium [5]

COP [7]

IE8 [28]
OP [15]

VirtualBrowser [6]
AppIsolation [8]

Stainless [12]
Tahoma [10]
TrackingFree

Fluid [11], MultiFirefox [25]

Proﬁle

In-memory Isolation
In-memory Isolation
In-memory Isolation
In-memory Isolation
In-memory Isolation
In-memory Isolation

Technique-speciﬁc Storage

Technique-speciﬁc Storage

Virtual Machine

Top-frame based

Server Conﬁguration based

Same-origin-policy (SOP) based

Tab based

Web Page based

User Conﬁguration based
User Conﬁguration based
User Conﬁguration based
User Conﬁguration based
User Conﬁguration based

In-degree-bounded Graph based
Table V: Multi-principal Browser Anti-tracking Capability Comparison

Proﬁle

only isolate browser’s in-memory state. AppIsolation [8] and
Tahoma [10], aiming to protect sensitive web applications from
untrusted ones, isolate sensitive application’s in-memory and
persistent states. AppIsolation adopts a light-weighted isolation
mechanism implemented on Chromium, while Tahoma utilizes
heavy-weighted virtual machines (VM) to isolate principals.
Stainless [12] is another multi-process browser but with a feature
of parallel sessions. Fluid [11] and MultiFirefox [25] are two
popular site-speciﬁc browser utilities, facilitating user to visit
different sites with different browsers. We compare these works’
anti-tracking abilities with TrackingFree from two aspects: 1).
isolation mechanism and 2). contents allocation policy. Table V
lists the comparison details.

Tab based contents allocation policy is adopted by IE8.
When a cross-site navigation occurs, this policy will not switch
principal and allow multiple web sites using the same principal.
Chromium’s process-per-site mode adopts top-frame based policy,
in which all the web pages and their contents, including third-
party iframes, are kept in the same principal if and only if they
are from the same site. SOP based policy, adopted by Gazelle
and WebShield, strictly follows same-origin policy and puts all
the child frames with different origins into different principals.
We formally evaluate the anti-tracking ability of top-frame based
and SOP based contents allocation policy with Alloy and the
results show that they cannot protect user’s privacy: in the worst
case, tracker can correlate user’s activities on unlimited number
of web sites (see Section VI for details). User conﬁguration based
and server conﬁguration based allocation mechanism require user
or server to manually deﬁne allocation policy. The most privacy-
preserving conﬁguration a user can achieve is to assign each site
a principal, similar to top-frame based allocation mechanism
and therefore suffering from the same privacy issue. Server
conﬁguration based mechanism requires server-side collaboration,
which is unlikely to happen. OP browser, adopting web page
based policy, will always open a new web page instance whenever
navigation occurs, which is not necessary and suffers from
serious compatibility issues.

As for isolation mechanism, most browsers do not iso-
late client-side state and cannot prevent web tracking at
all. Technique-speciﬁc storage (TSS) mechanism, adopted by
AppIsolation and Stainless, can isolate some or even all of
web data storages (e.g., cookie jar, HTML local storage, cache
store), but it can still be bypassed when trackers abuse those
client-side state that do not belong to web data storages, (e.g.,
user preference) [22]. Among the browsers or utilities that
adopt complete isolation mechanisms, i.e., proﬁle and virtual

machine, TrackingFree is the only one that allows principal
communication.

VIII. CONCLUSION

In this paper, we design and implement TrackingFree, the
ﬁrst anti-tracking browser that can completely block stateful
third-party tracking practice. To strike a balance between anti-
tracking ability and compatibility, we propose a novel content
allocation mechanism and a secure principal communication
channel. Our evaluation shows that TrackingFree can block all the
647 trackers we found in Alexa Top 500 web sites with affordable
overhead. Moreover, we formally prove TrackingFree’s anti-
tracking ability with Alloy, theoretically showing that even in
the worst scenario, trackers can at most correlate TrackingFree
user’s online behaviors on three sites.

REFERENCE

[1] Are We Private Yet? An Open Source Project. http://www.areweprivate

yet.com/.

[2] Abine Inc. Donottrackme. https://www.abine.com/dntdetail.php.
[3] Devdatta Akhawe, Adam Barth, Peifung E Lam, John Mitchell, and Dawn
Song. Towards a formal foundation of web security. In Computer Security
Foundations Symposium (CSF), 2010 23rd IEEE, pages 290–304. IEEE,
2010.

[4] Mika Ayenson, Dietrich Wambach, Ashkan Soltani, Nathan Good, and
Chris Hoofnagle. Flash cookies and privacy ii: Now with html5 and etag
respawning. Available at SSRN 1898390, 2011.

[5] Adam Barth, Collin Jackson, Charles Reis, and TGC Team. The security

architecture of the chromium browser, 2008.

[6] Yinzhi Cao, Zhichun Li, Vaibhav Rastogi, Yan Chen, and Xitao Wen.
Virtual browser: a virtualized browser to sandbox third-party javascripts
with enhanced security. In Proceedings of the 7th ACM Symposium on
Information, Computer and Communications Security, pages 8–9. ACM,
2012.

[7] Yinzhi Cao, Vaibhav Rastogi, Zhichun Li, Yan Chen, and Alexander
Moshchuk. Redeﬁning web browser principals with a conﬁgurable origin
policy. In Dependable Systems and Networks (DSN), 2013 43rd Annual
IEEE/IFIP International Conference on, pages 1–12. IEEE, 2013.

[8] Eric Yawei Chen, Jason Bau, Charles Reis, Adam Barth, and Collin
Jackson. App isolation: get the security of multiple browsers with just
one.
In Proceedings of the 18th ACM conference on Computer and
communications security, pages 227–238. ACM, 2011.

[9] Chromium. Creating and using proﬁles. http://www.chromium.org/devel

opers/creating-and-using-profiles.

[10] R.S. Cox, J.G. Hansen, S.D. Gribble, and H.M. Levy. A safety-oriented
In IEEE Symposium on Security and

platform for web applications.
Privacy. Citeseer, 2006.

[11] Todd Ditchendorf. Fluid: Turn your favorite web apps into real mac apps.

http://ﬂuidapp.com/.

14

[12] Danny Espinoza. Stainless: A multi-process browser alternative to google

chrome. http://www.stainlessapp.com/.

[13] Ghostery. Ghostery. http://www.ghostery.com/.
[14] Google. Manage your cookies and site data. https://support.google.com/c

hrome/answer/95647?hl=en.

[15] Chris Grier, Shuo Tang, and Samuel T King. Secure web browsing with
In Security and Privacy, 2008. SP 2008. IEEE

the op web browser.
Symposium on, pages 402–416. IEEE, 2008.

[16] Daniel Jackson. Alloy: a lightweight object modelling notation. ACM
Transactions on Software Engineering and Methodology (TOSEM),
11(2):256–290, 2002.

[17] Samy Kamkar. Evercookie. http://samy.pl/evercookie/.
[18] Balachander Krishnamurthy, Konstantin Naryshkin, and Craig Wills.
In

Privacy leakage vs. protection measures: the growing disconnect.
Web 2.0 Security and Privacy Workshop, 2011.

[19] Balachander Krishnamurthy and Craig Wills. Privacy diffusion on the
web: a longitudinal perspective. In Proceedings of the 18th international
conference on World wide web, pages 541–550. ACM, 2009.

[20] Balachander Krishnamurthy and Craig E Wills. Generating a privacy
footprint on the internet. In Proceedings of the 6th ACM SIGCOMM
conference on Internet measurement, pages 65–70. ACM, 2006.

[21] Balachander Krishnamurthy and Craig E Wills. Characterizing privacy in
online social networks. In Proceedings of the ﬁrst workshop on Online
social networks, pages 37–42. ACM, 2008.

[22] Teddy Leva. Sts design questions around probing what sites a user has

been to. http://code.google.com/p/chromium/issues/detail?id=33445.

[23] Zhichun Li, Yi Tang, Yinzhi Cao, Vaibhav Rastogi, Yan Chen, Bin Liu,
and Clint Sbisa. Webshield: Enabling various web defense techniques
without client side modiﬁcations. In NDSS, 2011.

[24] ROBERT S Liverani and Nick Freeman. Abusing Firefox Extensions.

Defcon17, July, 2009.

[25] Dave Martorana. Multiﬁrefox. http://davemartorana.com/multifirefox/.
[26]
Jonathan R Mayer and John C Mitchell. Third-party web tracking: Policy
and technology. In Security and Privacy (SP), 2012 IEEE Symposium
on, pages 413–427. IEEE, 2012.

[27] Microsoft. Description of cookies.

/260971.

http://support.microsoft.com/kb

[28] Microsoft.

IE8 Security Part V: Comprehensive Protection.

[28] Microsoft.

IE8 Security Part V: Comprehensive Protection.

http://blogs.msdn.com/b/ie/archive/2008/07/02/ie8-security-part-v-
comprehensive-protection.aspx?Redirected=true.

[29] Mozilla. Disable third-party cookies in ﬁrefox to stop some types of
tracking by advertisers. http://support.mozilla.org/en-US/kb/disable-third-
party-cookies.

[30] Mozilla. Lightbeam for Firefox. http://www.mozilla.org/en-US/lightbeam/.
[31] Mozilla. Use the Proﬁle Manager to Create and Remove Firefox
Proﬁles. https://support.mozilla.org/en-US/kb/profile-manager-create-and-
remove-ﬁrefox-profiles.

[32] Nick Nikiforakis, Alexandros Kapravelos, Wouter Joosen, Christopher
Kruegel, Frank Piessens, and Giovanni Vigna. Cookieless monster:
Exploring the ecosystem of web-based device ﬁngerprinting. In IEEE
Symposium on Security and Privacy, 2013.

[33] M Perry, E Clark, and S Murdoch. The design and implementation of

the tor browser [draft][online], united states, 2011.

[34] Franziska Roesner, Tadayoshi Kohno, and David Wetherall. Detecting
and defending against third-party tracking on the web. In Proceedings
of the 9th USENIX Conference on Networked Systems Design and
Implementation, NSDI’12, pages 12–12, Berkeley, CA, USA, 2012.
USENIX Association.

[35] Ashkan Soltani, Shannon Canty, Quentin Mayo, Lauren Thomas, and
In AAAI Spring

Chris Jay Hoofnagle. Flash cookies and privacy.
Symposium: Intelligent Information Privacy Management, 2010.

[36] The World Wide Web Consortium. W3C editor’s draft: HTML5.

http://www.w3.org/html/wg/drafts/html/master/browsers.html#unit-of-
related-browsing-contexts.

[37] W3C. HTTP ETag. http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.

html.

[38] Helen J Wang, Chris Grier, Alexander Moshchuk, Samuel T King, Piali
Choudhury, and Herman Venter. The multi-principal os construction of
the gazelle web browser. In USENIX Security Symposium, pages 417–432,
2009.

[39] Wikipedia. Do Not Track Policy. http://en.wikipedia.org/wiki/Do_Not_T

rack_Policy.

[40] Wikipedia. Privacy Mode. http://en.wikipedia.org/wiki/Privacy_mode.
[41] Ting-Fang Yen, Yinglian Xie, Fang Yu, Roger Peng Yu, and Martın
Abadi. Host ﬁngerprinting and tracking on the web: Privacy and security

implications. In Proceedings of NDSS, 2012.

15

