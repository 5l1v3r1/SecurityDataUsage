Protecting Encrypted Cookies from
Compression Side-Channel Attacks

Janaka Alawatugoda1, Douglas Stebila1,2, and Colin Boyd3

1 School of Electrical Engineering and Computer Science,

2 School of Mathematical Sciences,

Queensland University of Technology, Brisbane, Australia
janaka.alawatugoda@qut.edu.au, stebila@qut.edu.au

3 Department of Telematics,

Norwegian University of Science and Technology, Trondheim, Norway

colin.boyd@item.ntnu.no

Abstract. Compression is desirable for network applications as it saves
bandwidth; however, when data is compressed before being encrypted,
the amount of compression leaks information about the amount of redun-
dancy in the plaintext. This side channel has led to successful CRIME
and BREACH attacks on web traﬃc protected by the Transport Layer
Security (TLS) protocol. The general guidance in light of these attacks
has been to disable compression, preserving conﬁdentiality but sacri-
ﬁcing bandwidth. In this paper, we examine two techniques—heuristic
separation of secrets and ﬁxed-dictionary compression—for enabling com-
pression while protecting high-value secrets, such as cookies, from attack.
We model the security oﬀered by these techniques and report on the
amount of compressibility that they can achieve.

1

Introduction

To save communication costs, network applications often compress data before
transmitting it; for example, the Hypertext Transport Protocol (HTTP) [1, §4.2]
has an optional mechanism in which a server compresses the body of an HTTP
response, most commonly using the gzip algorithm. When encryption is used to
protect communication, compression must be applied before encryption (since
ciphertexts should look random, they should have little apparent redundancy
that can be compressed). In fact, to facilitate this, the Transport Layer Security
(TLS) protocol [2, §6.2.2] has an optional compression mode that will compress
all application data before encrypting it.

While compression is useful for reducing the size of transmitted data, it has
had a negative impact when combined with encryption, because the amount of
compression acts as a side channel. Most research considers side-channels such
as timing [3,4] or power consumption [5], which can reveal information about
cryptographic operations and secret parameters.

Compression-based leakage. In 2002, Kelsey [6] showed how compression can act
as a form of side-channel leakage. If plaintext data is compressed before being
encrypted, the length of the ciphertext reveals information about the amount of
compression, which in turn can reveal information about the plaintext. Kelsey
notes that this side channel diﬀers from other types of side channels in two key
ways: “it reveals information about the plaintext, rather than key material”, and
“it is a property of the algorithm, not the implementation”.

Kelsey’s most powerful attack is an adaptive chosen input attack : if an attacker
is allowed to choose inputs x that are combined with a target secret s and the
concatenation x(cid:107)s is compressed and encrypted, observing the length of the
outputs can eventually allow the attacker to extract the secret s. For example,
to determine the ﬁrst character of s, the attacker could ask to have the string
x = prefix*prefix combined with s, then compressed and encrypted, for every
possible character *; in one case, when * = s1, the amount of redundancy is
higher and the ciphertext should be shorter. Once each character of s is found,
the attack can be carried out on the next character. The attack is somewhat
noisy, but succeeds reasonably often.

Key to this attack is the fact that most compression algorithms (such as
the deflate algorithm underlying gzip) are adaptive: they adaptively build
and maintain a dictionary of recently observed strings, and replace subsequent
occurrences of that string with a code.

The CRIME and BREACH attacks. In 2012, Rizzo and Duong [7] showed how
to apply Kelsey’s adaptive chosen input attack against gzip compression as used
in TLS, in what they called the Compression Ratio Info-leak Mass Exploitation
(CRIME) attack. The primary target of the CRIME attack was the user’s cookie
in the HTTP header. If the victim visited an attacker-controlled web page, the
attacker could use Javascript to cause the victim to send HTTP requests to
URLs of the attacker’s choice on a speciﬁed server. The attacker could adaptively
choose those URLs to include a preﬁx to carry out Kelsey’s adaptive chosen input
attack. Some care is required to ensure the padding does not hide the length
with block ciphers, but this can be dealt with. The CRIME attack also applies
to compression as used in the SPDY protocol [8].

As a result of the CRIME attack, it was recommended that TLS compression
be disabled, and the Trustworthy Internet Movement’s SSL Pulse report for
December 2014 ﬁnds that just 7.2% of websites have TLS compression enabled
[9]; moreover, all major browsers have disabled it.

However, compression is also built into the HTTP protocol: servers can
optionally compress the body of HTTP responses. While this excludes the cookie
in the header, this attack can still succeed against secret values in the HTTP body,
such as anti-cross-site request forgery (CSRF) tokens. Suggested by Rizzo and
Duong, this was demonstrated by Gluck et al. [10] in the Browser Reconnaissance
and Exﬁltration via Adaptive Compression of Hypertext (BREACH) attack.

Mitigation techniques. Gluck et al. [10] discussed several possible mitigation
techniques against the BREACH attack, listed in decreasing order of eﬀectiveness:

1. Disabling HTTP compression
2. Separating secrets from user input
3. Randomizing secrets per request
4. Masking secrets (eﬀectively randomizing by XORing with a random nonce)
5. Length hiding (by adding a random number of bytes to the responses)
6. Rate-limiting the requests

Despite the demonstrated practicality of the BREACH attack, support for
and use of HTTP compression remains widespread, due in large part to the value
of decreasing communication costs and time. In fact, compression is even more
tightly integrated into the proposed HTTP version 2 [11] than previous versions.
Techniques 2–4 generally require changes to both browsers and web servers.
For example, masking secrets such as anti-CSRF tokens requires new mark-up
for secrets, which browsers and servers can interpret to apply the randomized
masking technique. Techniques 5–6 can be unilaterally applied by web servers,
though length hiding can be defeated with statistical averaging, and rate-limiting
must ﬁnd a balance between legitimate requests and information leakage.

Related work. There has been little academic study of compression and encryption.
Besides Kelsey’s adaptive chosen input attack and the related CRIME and
BREACH attacks, the only relevant work we are aware of is that of Kelley
and Tamassia [12]. They give a new security notion called entropy-restricted
semantic security (ER-IND-CPA) for keyed compression functions which combine
both encryption and compression: compared with the normal indistinguishability
under chosen plaintext attack (IND-CPA) security notion, in ER-IND-CPA the
adversary should not be able to distinguish between the encryption of two
messages that compress to the same length. Kelley and Tamassia then show how
to construct a cipher based on the LZW compression algorithm by rerandomizing
the compression dictionary. Unfortunately, the ER-IND-CPA notion does not
capture the CRIME and BREACH attacks, which depend on observing messages
that compress to diﬀerent lengths.

In leakage-resilient security deﬁnitions [13,14,15,16], leakage of the secret key
is addressed. This diﬀers from the setting in compression-based side-channel
attacks, which addresses leakage of the plaintext. Thus, previous leakage-resilient
approaches are not suitable to model compression-based side-channel attacks.

Our contributions. In this work, we study symmetric-key compression-encryption
schemes, characterizing the security properties that can be achieved by various
mitigation techniques in the face of CRIME- and BREACH-like attacks.

To some extent, the side channel exposed by compression is fundamentally
unavoidable: if transmission of data is decreased, nothing can hide the fact that
some redundancy existed in the plaintext. Hence, we focus our study on the ability
of the attacker to learn speciﬁc “high value” secrets embedded in a plaintext,
such as cookies or anti-CSRF tokens. In our models, we imagine there is a secret
value ck, and the adversary can adaptively obtain encryptions

Enck(m(cid:48)(cid:107)ck(cid:107)m(cid:48)(cid:48))

(1)

for preﬁx m(cid:48) and suﬃx m(cid:48)(cid:48) of its choice; the attacker’s goal is to learn about ck.
The ﬁrst mitigation technique we consider is that of separating secrets. During
compression/encryption, an application-aware ﬁlter is applied to the plaintext to
separate out any potential secret values from the data, the remaining plaintext
is compressed, then the secrets and compressed plaintext are encrypted; after
decryption, the inverse of the ﬁlter is used to reinsert the secret values in the
decompressed plaintext. Assuming the ﬁlter fully separates out all secret values,
we show that the separating secrets technique is able to achieve a strong notion of
protection, which we call chosen cookie indistinguishability (CCI): the adversary
cannot determine which of two cookies ck0 and ck1 of the adversary’s choice was
encrypted with messages of the adversary’s choice given ciphertexts as in (1).

The second mitigation technique we consider is the use of a ﬁxed-dictionary
compression scheme, where the dictionary used for compression does not adapt
to the plaintext being compressed, but instead is preselected in advance based on
the expected distribution of plaintext messages, for example including common
English words like “the” and “and”. We show that, if the secret values are
suﬃciently high entropy, then ﬁxed-dictionary compression is able to achieve
cookie recovery (CR) security: if the secret cookie is chosen uniformly at random,
the adversary cannot recover the entire secret cookie even given an adaptive
message attack as in (1). While cookie recovery security does not meet the “gold
standard” of indistinguishability notions for encryption, it may be suﬃcient for
some settings, for example protecting compressed HTTP traﬃc from CRIME
and BREACH attacks that try to recover cookies and anti-CSRF tokens.

We also characterize the relationship among the CCI and CR security notions,
as well as an intermediate notion called random cookie indistinguishability (RCI)
and the ER-IND-CPA notion of Kelley and Tamassia [12].

In the separating secrets technique, if the number of secrets extracted by the
separating ﬁlter is relatively small, then the compressibility generally remains
close to that of normal compression of the full plaintext. In the ﬁxed-dictionary
compression technique, compressibility suﬀers quite a bit compared to adaptive
techniques on the full plaintext, although if the dictionary is constructed from a
corpus of text similar to the plaintext, then some compression can be achieved.
Figure 1 summarizes experimental results comparing compression ratios for
these two techniques on the HTML, CSS, and Javascript source code of the
top 10 global websites as reported by Alexa Top Sites (http://www.alexa.com/
topsites). On average, the compression ratio (uncompressed : compressed size)
of gzip applied to the full source code was 5.42×; applying a separation ﬁlter
that extracted all values following value= in the HTML source code yielded
an average compression ratio of 5.20×; compression of each page using a ﬁxed
dictionary trained on all 10 pages yielded an average compression ratio of 1.55×.

2 Deﬁnitions

Notation. If x is a string, then xi denotes the ith character of x; xi:(cid:96) denotes the
length-(cid:96) substring of x starting at position i: xi:(cid:96) = xi(cid:107) . . .(cid:107)xi+(cid:96)−1. If x and y

o
i
t
a
r

n
o
i
s
s
e
r
p
m
o
C

10

8

6

4

2

0

9
1
.
1
1

7
1
.
1
1

gzip full page

separating-secrets/gzip

ﬁxed-dictionary compression

1
5
.
3

1
5
.
3

5
.
3

4
0
.
3

3
2
.
1

7
3
.
1

8
3
.
5

3
3
.
5

8
5
.
2

8
2
.
4

3
2
.
4

3
3
.
4

1
1
.
4

1
6
.
4

8
4
.
3

5
0
.
5

8
9
.
4

7
2
.
4

7
1
.
4

4
.
1

4
3
.
1

6
2
.
1

6
4
.
1

1
2
.
1

5
5
.
1

2
1
.
8

4
0
.
8

6
0
.
2

Google

Facebook Youtube

Yahoo

Baidu Wikipedia Twitter

Qq

Amazon

Taobao

Fig. 1. Compression ratios of full page compression versus mitigation techniques

are strings, then x (cid:22) y denotes that x is a substring of y. The index of x in y is
the smallest i such that yi:|x| = x and is denoted by indy(x); if x (cid:54)(cid:22) y, we denote
indy(x) = ⊥. The empty string is denoted by .

2.1 Encryption and compression schemes

Recall the standard deﬁnition of an encryption scheme:

Deﬁnition 1 (Symmetric-key encryption). A symmetric-key encryption
scheme Π for message space M and ciphertext space C is a tuple of algorithms:
– KeyGen() $→ k: A probabilistic key generation algorithm that generates a

random key k in the keyspace K.

– Enck(m) $→ c: A possibly probabilistic encryption algorithm that takes as
input a key k ∈ K and a message m ∈ M and outputs a ciphertext c ∈ C.
– Deck(c) → m(cid:48) or ⊥: A deterministic decryption algorithm that takes as input
a key k ∈ K and a ciphertext c ∈ C, and outputs either a message m(cid:48) ∈ M
or an error symbol ⊥.

Correctness of symmetric-key encryption is deﬁned in the obvious way: for

all k $← KeyGen() and all m ∈ M, we require that Deck(Enck(m)) = m.

Deﬁnition 2 (Compression scheme). A compression scheme Γ for message
space M with output space O is a pair of algorithms:
– Comp(m) $→ o: A possibly probabilistic compression algorithm that takes as
input a message m ∈ M and outputs an encoded value o ∈ O.
– Decomp(o) → m(cid:48) or ⊥: A decompression algorithm that takes as input an
encoded value o ∈ O and outputs a message m(cid:48) ∈ M or an error symbol ⊥.
Note that |Comp(m)| may not necessarily be less than |m|; Shannon’s coding
theorem implies that no algorithm can encode every message with shorter length,
so not all messages may actually be “compressed”: some may increase in lenth.

Correctness of a compression scheme is again deﬁned in the obvious way: for

all m ∈ M, we require that Decomp(Comp(m)) = m.

In this paper, we are interested in symmetric-key compression-encryption
schemes, which formally are just symmetric-key encryption schemes as in Deﬁ-
nition 1, but usually have the goal of outputting shorter ciphertexts via some
form of compression. Of course, every symmetric-key encryption scheme is also a
symmetric-key compression-encryption scheme, with “compression” being the
identity function. We will often deal with the following speciﬁc, natural composi-
tion of compression and symmetric-key encryption:

Deﬁnition 3 (Composition of compression and encryption). Let Γ =
(Comp, Decomp) be a compression scheme with message space M and output
space O. Let Π = (KeyGen, Enc, Dec) be a symmetric-key encryption scheme
with message space O and ciphertext space C. The symmetric-key compression-
encryption scheme Π ◦ Γ constructed from Γ and Π is the following tuple:

(Π ◦ Γ ).KeyGen() = Π.KeyGen()
(Π ◦ Γ ).Enck(m) = Π.Enck(Γ.Comp(m))
(Π ◦ Γ ).Deck(c) = Γ.Decomp(Π.Deck(c))

Note that Π ◦ Γ is itself a symmetric-key encryption scheme with message
space M and ciphertext space C. If Γ and Π are both correct, then so is Π ◦ Γ .

2.2 Existing security notions

The standard security notion for symmetric-key encryption is indistinguishability
of encrypted messages. In this paper, we focus on chosen plaintext attack. The
(A) for indistinguishability under chosen plaintext
security experiment ExpIND-CPA
attack (IND-CPA) of a symmetric-key encryption scheme Π against a stateful
adversary A is given in Figure 2. The advantage of A in breaking the IND-CPA
experiment for Π is AdvIND-CPA

(A) = 1

(A) =

Π

(cid:12)(cid:12)(cid:12).
(cid:17) − 1

(cid:16)

(cid:12)(cid:12)(cid:12)2 Pr

Π

ExpIND-CPA

Π

Kelley and Tamassia [12] give a deﬁnition of entropy-restricted IND-CPA
security which applies to keyed compression schemes Π, and demands indistin-
guishability of encryptions of messages from the same class L ⊆ M; typically, L
is the class of messages that encrypt (compress) to the same length under Π.Enc,
such as:

L(cid:96) = {m ∈ M : |Π.Enc(m)| = (cid:96)} .

The ER-IND-CPA security experiment is given in Figure 2; the corresponding
advantage is deﬁned similarly. Kelley and Tamassia note that any IND-CPA-secure
symmetric-key encryption scheme Π, combined with any compression scheme Γ , is
immediately ER-IND-CPA-secure. As well, it is easily seen that if a symmetric-key
encryption scheme is ER-IND-CPA-secure for the class L(cid:96) = {m ∈ M : |m| = (cid:96)},
then that scheme is also an IND-CPA-secure symmetric-key encryption.

(A)

Π

ExpIND-CPA
1: k $← Π.KeyGen()
2: b $← {0, 1}
3: (m0, m1, st) $← AE()
4: if |m0| (cid:54)= |m1|, then return ⊥
5: c ← Π.Enck(mb)
6: b(cid:48) $← AE(c, st)
7: return (b(cid:48) = b)
E(m)
1: return Π.Enck(m)

(A)

Π,L

ExpER-IND-CPA
1: k $← Π.KeyGen()
2: b $← {0, 1}
3: (m0, m1, st) $← AE()
4: if m0 (cid:54)∈ L or m1 (cid:54)∈ L, then return ⊥
5: c ← Π.Enck(mb)
6: b(cid:48) $← AE(c, st)
7: return (b(cid:48) = b)
E(m)
1: return Π.Enck(m)

Fig. 2. Security experiments for indistinguishability under chosen plaintext attack
(IND-CPA, left) and entropy-restricted IND-CPA (ER-IND-CPA, right)

2.3 New security notions

In this paper, we focus on the ability of an attacker to learn about a secret
piece of data inside a larger piece of data, where the attacker controls everything
except the secret data. We use the term cookie to refer to the secret data; in
practice, this could be an HTTP cookie in a header, an anti-CSRF token, or some
piece of personal information. We will allow the attacker to adaptively obtain
encryptions of compressions of data of the form m(cid:48)(cid:107)ck(cid:107)m(cid:48)(cid:48) for a secret cookie ck
and adversary-chosen message preﬁx m(cid:48) and suﬃx m(cid:48)(cid:48).

We now present three notions for the security of cookies in the context of

compression-encryption schemes:

– Cookie recovery (CR) security: A simple, but relatively weak, security notion
for symmetric-key compression-encryption schemes: it should be hard for the
attacker to fully recover a secret value, even given adaptive access to an oracle
that encrypts plaintexts of its choosing with the target cookie embedded.

– Random cookie indistinguishability (RCI) security: The adversary has to
decide which of two randomly chosen cookies was embedded in the encrypted
plaintext, given adaptive access to an oracle that encrypts plaintexts of its
choosing with the target cookie embedded.

– Chosen cookie indistinguishability (CCI) security: Here, the adversary has
to decide which of two cookies of the adversary’s choice was embedded in
the encrypted plaintext, given adaptive access to an oracle that encrypts
plaintexts of its choosing with the target cookie embedded.

These security notions are formalized in the following deﬁnition, which refers

to the security experiments shown in Figure 3.

Deﬁnition 4 (CR, RCI, CCI security). Let Ψ be a symmetric-key compression-
encryption scheme. Let A denote an algorithm. Let CK denote the cookie space.
Let xxx ∈ {CR, RCI, CCI} be a security notion. Consider the security experiment

Ψ,CK(A)

ExpCR
1: k $← Ψ.KeyGen()
2: ck $← CK
3: ck(cid:48) $← AE1,E2 ()
4: return (ck(cid:48) = ck)
E1(m(cid:48), m(cid:48)(cid:48))
1: return Ψ.Enck(m(cid:48)(cid:107)ck(cid:107)m(cid:48)(cid:48))
E2(m)
1: return Ψ.Enck(m)

(ck0, ck1) $← CK s.t. |ck0| = |ck1|; st ← ⊥
(ck0, ck1, st) $← AE2 () s.t. |ck0| = |ck1|

Ψ,CK (A)

ExpRCI/CCI
1: k $← Ψ.KeyGen()
2: if RCI then
3:
4: else if CCI then
5:
6: b $← {0, 1}
7: b(cid:48) $← AE1,E2 (ck0, ck1, st)
8: return (b(cid:48) = b)
E1(m(cid:48), m(cid:48)(cid:48))
1: return Ψ.Enck(m(cid:48)(cid:107)ckb(cid:107)m(cid:48)(cid:48))
E2(m)
1: return Ψ.Enck(m)

Fig. 3. Security experiments for cookie recovery (left) and random cookie indistin-
guishability and chosen cookie indistinguishability (right) attacks

(cid:16)

(cid:17)

Ψ,CK(A) in Figure 3. Deﬁne AdvCR

Ψ,CK(A) = (cid:12)(cid:12)2 Pr(cid:0)Expxxx

Expxxx
as the
probability that A wins the cookie recovery experiment for Ψ and CK. Simi-
larly, deﬁne Advxxx
the advantage that A has in winning the random cookie and chosen cookie indis-
tinguishability experiments.

Ψ,CK(A) = 1(cid:1) − 1(cid:12)(cid:12), xxx ∈ {RCI, CCI}, as

Ψ,CK(A) = Pr

ExpCR

Ψ,CK(A) = 1

Remark 1. The CR, RCI, and CCI security notions intentionally include only the
conﬁdentiality of the cookie as a security goal, and not the conﬁdentiality of
any non-cookie data in the rest of the message. In most applications it would
be desirable to obtain conﬁdentiality of non-cookie data as well, and in many
real-world situations, the application layer’s cookie and non-cookie data are
jointly sent to the security layer (such as SSL/TLS) for encryption. Our notions
do not preclude the scheme from encrypting the non-cookie data as well (and
in fact our constructions in Sections 3 and 4 do so). However, it is not possible
in general to require conﬁdentiality of the non-cookie data while still allowing
it to be compressed, as that brings us back around to the original problem
that motivated the work—compression of adversary-provided data can lead to
ciphertexts of diﬀerent lengths that break indistinguishability. This cycle can be
broken by demanding some length restriction on the separated non-cookie data,
such as in the ER-IND-CPA notion described in Section 2.2, but we omit that
complication to focus solely on the security of the high-value secret cookies.

2.4 Relations and separations between security notions

Cookie recovery, being a computational problem rather than a decisional problem,
is a weaker security notion. Keeping CR as an initial step, the RCI and CCI notions
gradually increase the security aﬀorded to the cookie.

The following relations exist between security notions for symmetric-key

compression-encryption schemes:

CCI =⇒ RCI =⇒ CR .

In other words, every scheme that provides chosen cookie indistinguishability
provides random cookie indistinguishability, and so on. Moreover, these notions
are distinct, and we can show separations between them:

CR (cid:54)=⇒ RCI

(cid:54)=⇒ CCI .

Additionally, we can connect our new notions with existing notions:

ER-IND-CPA =⇒ IND-CPA =⇒ CCI

and

CCI

(cid:54)=⇒ IND-CPA .

These last relations should be interpreted as follows. A standard (non-compressing)
IND-CPA-secure symmetric-key encryption scheme is also CCI-secure. This is
not to say, however, that an IND-CPA-secure symmetric-key encryption scheme
combined with a compression scheme, such as Π ◦ Γ in Deﬁnition 3, is CCI-secure.
The proofs of these relations and counterexamples for the separations appear
in the full version of the paper [17]. A brief discussion of the intuition for each
appears in Appendix A.

3 Technique 1: Separating secrets from user inputs

In this section we analyze a mitigation technique against attacks that recover
secrets from compressed data: separating secrets from user inputs. The basic
idea of separating secrets from user inputs is: given an input, use a ﬁlter to
separate all the secrets from the rest of the content, including user inputs. Then
the rest of the content is compressed, while the secrets are kept uncompressed.
This mitigation technique is a generic mitigation technique against a whole class
of compression-based side-channel attacks.

3.1 The scheme
Deﬁnition 5 (Filter). A ﬁlter is an invertible (eﬃcient) function f : {0, 1}∗ →
{0, 1}∗ × {0, 1}∗.

Given a ﬁlter f and a compression scheme Γ , the separating-secrets scheme

SSf,Γ is given in Figure 4.

Our results will make use of the following two conditions on ﬁlters. Intuitively,
a ﬁlter is eﬀective if it removes cookies from an input string, and is safe if no
preﬁx/suﬃx can fool the ﬁlter into separating out one cookie but not another.
Deﬁnition 6 (Eﬀective ﬁlter). Let CK be a cookie space, and let f be a ﬁlter.
We say that f is eﬀective at separating out CK if, for all ck ∈ CK and all m(cid:48), m(cid:48)(cid:48),
we have that ck (cid:54)(cid:22) y, where (x, y) = f (m(cid:48)(cid:107)ck(cid:107)m(cid:48)(cid:48)).

SSf,Γ .Comp(m)
1: (pts, ptns) ← f (m)

2: (cid:103)ptns ← Γ.Comp(ptns)
3: return pts(cid:107)(cid:103)ptns

SSf,Γ .Decomp(pt)

1: Parse pts(cid:107)(cid:103)ptns ← pt
2: ptns ← Γ.Decomp((cid:103)ptns)

3: m ← f−1(pts, ptns)
4: return m

Fig. 4. Abstract separating-secrets compression scheme SS

Deﬁnition 7 (Safe ﬁlter). Let CK be a cookie space, and let f be a ﬁlter. We
say that f is safe for CK if, for all ck0, ck1 ∈ CK such that |ck0| = |ck1| and all
m(cid:48), m(cid:48)(cid:48), we have that |x0| = |x1| and y0 = y1, where (x0, y0) = f (m(cid:48)(cid:107)ck0(cid:107)m(cid:48)(cid:48))
and (x1, y1) = f (m(cid:48)(cid:107)ck1(cid:107)m(cid:48)(cid:48)).
Example cookie space and ﬁlter. Let λ ∈ N and let CK be the set of alphanumeric
strings starting with the literal “secret” and starting and ending with a space
(denoted by ), i.e., strings matched by the regular expression

secret[A-Za-z0-9]λ

Let f be a ﬁlter that uses the above regular expression to separate out secrets.
Consider a string of the form m = m0 ck1 m1 ck2 m2 . . . ckn mn, where
mi contains no substring matching the above regular expression and cki is a
string completely matching the above regular expression (excluding the initial
and terminal space ). Then f (m) = (pts, ptns), where pts = ck1(cid:107) . . .(cid:107)ckn and
ptns = m0(cid:107)τ(cid:107)m1(cid:107)τ(cid:107) . . .(cid:107)mn, and τ represents a ﬁxed replacement token that
can not appear as a substring of any m ∈ M. The above ﬁlter f is eﬀective at
separating out and safe for the above CK. The intuitive reason for this is that,
since each cookie begins and ends with a character which does not appear
within the cookie, no preﬁx or suﬃx can cause the ﬁlter to not separate a cookie.

3.2 CCI security of basic separating-secrets technique

In this section we analyze the security of separating-secrets mitigation technique
according to CCI notion. Let Π = (KeyGen, Enc, Dec) be an IND-CPA-secure
symmetric-key encryption scheme and SSf,Γ be the separating-secrets compression
scheme given in Figure 4. We consider the security of the resulting symmetric-key
compression-encryption scheme Π ◦ SSf,Γ , showing that, if the ﬁlter f safely
separates out cookies, then breaking chosen cookie indistinguishability of Π◦SSf,Γ
is as hard as breaking indistinguishability (IND-CPA) of encryption scheme Π.
The proof of Theorem 1 appears in Appendix B.

Theorem 1. Let Π be a symmetric-key encryption scheme and let Γ be a
compression scheme. Let CK be a cookie space, and let f be a ﬁlter that is safe
for CK. Let A be any adversary against the CCI security of the separating-secrets
symmetric-key compression-encryption scheme Π ◦ SSf,Γ , and let q denote the
number of queries that A makes to its E1 oracle. Then AdvCCI
Π◦SSf,Γ ,CK(A) ≤

q · AdvIND-CPA
(BA) , where B is an algorithm, constructed using the adversary
A as described in the proof, against the IND-CPA security of the symmetric-key
encryption scheme Π.

Π

3.3 Separating secrets in HTML

Separating secrets from user inputs is a realistic mitigation technique against the
BREACH attack: in the application layer, some ﬁelds which contain secrets (such
as anti-CSRF tokens) can be identiﬁed and separated from the HTTP response
body. In order to implement separating secrets from user inputs in HTML we
need to describe a ﬁlter fHTML.

One possible method to separate secrets in HTML is to separate the content
assigned to the value attribute of HTML elements. Among other uses, the value
attribute deﬁnes the value of a speciﬁc ﬁeld in a form. The HTML code segment
of Figure 5 shows inclusion of a secret anti-CSRF token as a hidden input ﬁeld
in a web form, which will appear in a HTML response body. By separating the
content in the value attribute, we separate the anti-CSRF token.

< form action = " / m o n e y _ t r a n s f e r " method = " post " >
< input type = " hidden " name = " c s r f t o k e n "

value = " O W T 4 N m Q l O D E 4 O D R j N 2 Q 1 N T l h M m Z l Y W E ... " >

...
</ form >

Fig. 5. HTML code segment showing inclusion of anti-CSRF token in a web form

The following (case-insensitive) regular expression can be used to separate

out quoted anti-CSRF tokens in the value attribute of HTML elements:

value\s*=\s*"[A-Za-z0-9]+"|value\s*=\s*’[A-Za-z0-9]+’

This ﬁlter is eﬀective at separating out and safe for the implied set of cookies, in
the sense of Deﬁnitions 6 and 7.

However, the above regular expression is not perfect, highlighting the chal-

lenges of using heuristic techniques to separate out secrets.

First, the above regular expression will also capture the value attribute of
HTML elements other than hidden input elements, such as option, which may
not need to be treated as secret, so it is not as eﬃcient as it could be.

Second, the above regular expression does not capture anti-CSRF tokens
in unquoted value attributes, such as value=OWT4NmQl, which are allowed by
the HTML speciﬁcation. While it is easy to add an additional term such as
|value\s*=\s*[A-Za-z0-9]+ to the regular expression to capture unquoted
attributes, this ﬁlter would no longer be eﬀective in the sense of Deﬁnition 6: if
a cookie is value=OWT4NmQl, and the adversary constructs m(cid:48) = value=, then
m(cid:48)(cid:107)ck = value=value=OWT4NmQl, and the ﬁlter applied to m(cid:48)(cid:107)ck would separate
out value=value as the cookie and leave =OWT4NmQl unprotected.

Table 1. Compression performance (ﬁle size in bytes and compression ratio) for
separating secrets (Section 3) and ﬁxed dictionary (Section 4) techniques

Website

Uncompressed

Google.com
Facebook.com
Youtube.com
Yahoo.com
Baidu.com
Wikipedia.org
Twitter.com
Qq.com
Amazon.com
Taobao.com

145 599
48 226
467 928
444 408
74 979
48 548
57 777
626 297
234 609
192 068

gzip full page
41 455 (3.51×)
13 785 (3.50×)
41 813 (11.19×)
82 572 (5.38×)
17 519 (4.28×)
11 217 (4.33×)
12 520 (4.61×)
124 108 (5.05×)
54 922 (4.27×)
23 658 (8.12×)

Separating secrets
41 502 (3.51×)
15 863 (3.04×)
41 893 (11.17×)
83 342 (5.33×)
17 727 (4.23×)
11 809 (4.11×)
16 618 (3.48×)
125 747 (4.98×)
56 278 (4.17×)
23 898 (8.04×)

Fixed dictionary
117 794 (1.23×)
35 036 (1.37×)
181 676 (2.58×)
318 386 (1.40×)
55 950 (1.34×)
38 406 (1.26×)
39 712 (1.46×)
519 830 (1.21×)
150 924 (1.55×)
93 410 (2.06×)

3.4 Experimental results on separating-secrets in HTML

Table 1 shows the result of applying the above regular expression to separate
secrets on the top 10 global websites of Alexa Top Sites. As most pages contain
little data in value attributes, the total amount of space required to transmit
the separated secrets plus the remaining data is not much more than when the
full page is compressed. (Table 1 also contains performance results of the ﬁxed
dictionary technique, to be discussed in Section 4.)

3.5 Discussion

The main drawback of the separating secrets technique is that the separation
ﬁlter must be application-dependent. We noted already the challenges in using the
heuristic regular expression above to capture anti-CSRF tokens: it may separate
out non-secrets as well as secrets (which yields suboptimal compression) and it
does not capture unquoted tokens (which is a problem for security).

Moreover, this HTML ﬁlter also only captures secrets in a value attribute,
which does not necessarily capture all values that might be considered sensitive.
For example, should the titles of books in a search results page on an shopping
site be considered secret? If so, an alternative separation ﬁlter would have to
be developed. To provide complete certainty, secret separation would require
additional markup with which the developer clearly identiﬁes which data should
be treated as secret. Otherwise, any sensitive values which are not separated may
be compressed together with user inputs and other application data, and hence
remain open to the compression-based side-channel.

4 Technique 2: Fixed-dictionary compression

The CRIME and BREACH attacks work because the dictionary constructed
by the deflate compression algorithm is adaptive: if the attacker injects a
substring of the target secret into the plaintext nearby the secret itself, then
the plaintext will compress more because of the repeated substring. Some early

compression algorithms were non-adaptive, using a ﬁxed dictionary mechanism.
For example, Pike [18] used a ﬁxed dictionary of 205 popular English words and
a variable length coding mechanism to compress typical English text at a rate
of less than 4 bits per character. Another recent algorithm, Smaz [19], similarly
uses a ﬁxed dictionary consisting of common digrams and trigrams from English
and HTML source code, allowing it to compress even very short strings. Because
the CRIME and BREACH attacks rely on the adaptivity of the compression
dictionary, ﬁxed-dictionary algorithms can oﬀer resistance to such attacks while
still providing some compression, albeit not as good as adaptive compression.

In this section, we investigate the use of ﬁxed-dictionary compression in the
context of encryption. We describe the basic idea of ﬁxed-dictionary compression.
We show that ﬁxed-dictionary compression-encryption schemes can satisfy cookie
recovery security for suﬃciently large cookies. We then present an example of a
modern ﬁxed-dictionary compression algorithm and report on the compression
ratios achieved by our algorithm.

4.1 The scheme

In general, ﬁxed-dictionary compression schemes work by advancing through the
string x and looking to see if the current substring appears in the dictionary D:
if it does, then an encoding of the index of the substring is recorded, otherwise
an encoding of the current substring is recorded. The compression scheme must
specify the encoding rules in a way that unambiguously discriminates between
the two cases to allow for correct decompression.

An abstract version of a ﬁxed-dictionary ﬁxed-width compression algorithm
FD is given in Figure 6. FD checks if the current substring of length w appears
in the dictionary D. If it does, it records the index of the substring in D and
advances w characters. If it does not, it records the next (cid:96) characters directly,
then advances. (Using (cid:96) > 1 but (cid:96) < w may be more eﬃcient when it comes to
encodings.) One could treat D either as a set of strings (recording which element
is matched) or a long string (recording the starting and ending position of the
matching substring); we will use the latter in the rest of this section.
For example, if D =“cookierecoveryattack”, then FDD,4,2.Comp(“recover

the cookie”) yields 7ver the 1ie.

Suppose the cookie space is binary strings of length 8λ, or equivalently byte

4.2 CR security of basic ﬁxed-dictionary technique
Let Π be a symmetric-key encryption scheme. Let D be a dictionary of length d
and FDD,w,(cid:96) be the abstract ﬁxed-dictionary compression scheme in Figure 6.
strings of length λ: CK = {0x00, . . . , 0xFF}λ.
If Π is a secure encryption scheme, then, intuitively, the only way the adversary
can learn information about the cookie from seeing ciphertexts Enck(·(cid:107)ck(cid:107)·) and
Enck(·) is from the length of the ciphertext: if some substring of ck appears
in the dictionary D, then ck will compress, and that length diﬀerence tells the
adversary that the secret cookie is restricted to some subset of CK matching D.

if xi:w (cid:22) D then

FDD,w,(cid:96).Comp(x)
1: y ← 
2: i ← 1
3: while i ≤ |x| − w + 1 do
4:
5:
6:
7:
8:
9:
10: return y

y ← y (cid:107) encoding of indD(xi:w)
i ← i + w
y ← y (cid:107) encoding of xi:(cid:96)
i ← i + (cid:96)

else

FDD,w,(cid:96).Decomp(y)
1: x ← 
2: i ← 1
3: while i ≤ |y| do
4:
5:
6:
7:
8:
9:
10: return x

else

if yi encodes an index then

x ← x (cid:107) Dyi:w
i ← i + 1
x ← x (cid:107) decoding of yi:(cid:96)(cid:48)
i ← i + (cid:96)(cid:48)

Fig. 6. Abstract ﬁxed-dictionary ﬁxed-width compression scheme FD

Note the simpliﬁcation that (cid:96) characters of x are encoded as (cid:96)(cid:48) characters of y.

The situation is subtler in the full CR experiment: the attacker can provide
m(cid:48) and m(cid:48)(cid:48) and get Enck(Comp(m(cid:48)(cid:107)ck(cid:107)m(cid:48)(cid:48))). If the last few bytes of m(cid:48) followed
by the ﬁrst few bytes of ck appear in D, then the string will compress more. This
allows the attacker to carry out a CRIME-like attack on the ﬁrst few bytes of ck.
For example, let w = 4 and suppose D = 1234567890ABCDEFGHIJKLMNOPQRST
UVWXYZ and CK = [0-9A-F]λ. The attacker can query m(cid:48) = 890, m(cid:48) = 90A,
m(cid:48) = 0AB, . . . . In exactly one case, the adversary’s m(cid:48) combined with the cookie’s
ﬁrst byte will be in the dictionary, telling the adversary ck1. For example, if
ck1 = B, then when the adversary queries m(cid:48) = 90A, the value that is compressed
and then encrypted is m(cid:48)(cid:107)ck(cid:107)m(cid:48)(cid:48) = 90AB . . . , which is a substring of D.

While this allows the attacker to recover the ﬁrst byte or two of the secret
cookie with decent probability, it drops oﬀ exponentially; a similar argument
applies to the last few bytes of the secret cookie. Theorem 2 captures this
issue. Theorem 2 only provides quantiﬁable security when the cookie length n
is signiﬁcantly bigger than the compression window w. Additionally, this type
of attack on the ﬁrst/last few bytes of the cookie precludes indistinguishable
security, which is why we focus on cookie recovery here. (Admittedly, in some
settings recovering the ﬁrst/last few cookie bytes may still be quite damaging.)
Theorem 2. Let Π be a symmetric-key encryption scheme. Let D be a dictionary
of d words, each of length (cid:96). Let w be positive integer. Let CK = Ωn. Let A be any
adversary against the cookie recovery security of the ﬁxed-dictionary symmetric-
key compression-encryption scheme Π ◦ FDD,w,(cid:96). Then AdvCR
(A) ≤
(B) + 2−∆ , where B is an algorithm, constructed using adversary A,
AdvIND-CPA
against the IND-CPA security of the symmetric-key encryption scheme Π, and

Π◦FDD,w,(cid:96)

Π

(cid:32)

∆ ≥

1 − d

1 −

1 − 1
|Ω|w

(cid:18)

1 − 1
|Ω|w

(cid:19)n−3w+1(cid:33)(cid:33)

.

(cid:18)

(cid:32)
(cid:32)

(cid:19)n−3w+1(cid:33)(cid:33)
(cid:32)

· log2

|Ω|n−2w − |Ω|n−2w · d

1 −

For example, for cookies of n = 16 bytes, with a dictionary of d = 4000 words
each of length w = 4, we have ∆ ≥ 63.999695. Doubling d gives ∆ ≥ 63.999391.

The derivation of the formula in Theorem 2 appears in Appendix C.

4.3 Experimental results on ﬁxed-dictionary technique

Table 1 shows the result of applying a ﬁxed-dictionary based compression algo-
rithm to the top 10 global websites of Alexa Top Sites. The 4000-byte dictionary
was built from the most common 8-, 16-, and 32-character substrings of the pages.
The compression algorithm was based in part on the Smaz [19] algorithm and was
adapted slightly from Figure 6, to allow for variable-length words to be matched.
Speciﬁcally, when attempting to encode the substring at the current position at
line 4 in Figure 6, we ﬁrst try variable length words in order of decreasing length,
checking to see if w = 18, then w = 16, then . . . , then w = 4 characters can be
found in the dictionary. This requires the encoding to include both index and
length of the dictionary substring.
– To encode a dictionary word at index 0 ≤ j < 4096 of length w = 2w(cid:48) + 4, 0 ≤
– To encode 2 lower-ASCII characters z1z2, store 16 bits: 00 (cid:107) [7-bit encoding
– To encode 1 byte z, store 16 bits: 01000000 (cid:107) [8-bit encoding of z]

w(cid:48) ≤ 7, store 16 bits: 1 (cid:107) [12-bit encoding of j] (cid:107) [3-bit encoding of w(cid:48)]
of z1] (cid:107) [7-bit encoding of z2]

4.4 Discussion

The main drawback of the ﬁxed dictionary mitigation technique is that in practice
it achieves relatively poor—albeit non-zero—compression compared with adaptive
compression techniques. However, it does not rely on application-dependent or
heuristic techniques for separating secrets.

Acknowledgements

The authors acknowledge support by Australian Research Council (ARC) Dis-
covery Project DP130104304.

References

1. Fielding, R., Reschke, J.: Hypertext Transfer Protocol (HTTP/1.1): Message Syntax

and Routing. RFC 7230 (Proposed Standard) (2014)

2. Dierks, T., Rescorla, E.: The Transport Layer Security (TLS) Protocol Version 1.2.

RFC 5246 (Proposed Standard) (2008) Updated by RFCs 5746, 5878, 6176.

3. Kocher, P.C.: Timing attacks on implementations of Diﬃe-Hellman, RSA, DSS, and
other systems. In Koblitz, N., ed.: CRYPTO’96. Volume 1109 of LNCS., Springer
(1996) 104–113

4. Kelsey, J., Schneier, B., Wagner, D., Hall, C.: Side channel cryptanalysis of product
In Quisquater, J.J., Deswarte, Y., Meadows, C., Gollmann, D., eds.:

ciphers.
ESORICS’98. Volume 1485 of LNCS., Springer (1998) 97–110

5. Hutter, M., Mangard, S., Feldhofer, M.: Power and EM attacks on passive 13.56
mhz RFID devices. In Paillier, P., Verbauwhede, I., eds.: CHES 2007. Volume 4727
of LNCS., Springer (2007) 320–333

6. Kelsey, J.: Compression and information leakage of plaintext. In Daemen, J.,

Rijmen, V., eds.: FSE 2002. Volume 2365 of LNCS., Springer (2002) 263–276

7. Rizzo, J., Duong, T.: The CRIME attack (2012) Presented at ekoparty ’12. http:

//goo.gl/mlw1X1.

8. The Chromium Projects: (SPDY) http://dev.chromium.org/spdy.
9. Trustworthy

Internet Movement:

SSL Pulse

(2014)

https://www.

trustworthyinternet.org/ssl-pulse/.

10. Gluck, Y., Harris, N., Prado, A.: SSL, gone in 30 seconds: A BREACH beyond

CRIME. In: Black Hat USA 2013. (2013)

11. Belshe, M., Peon, R., Thomson, M.: Hypertext Transfer Protocol version 2 (2014)

Internet-Draft. http://tools.ietf.org/html/draft-ietf-httpbis-http2-16.

12. Kelley, J., Tamassia, R.: Secure compression: Theory & practice. Cryptology ePrint

Archive, Report 2014/113 (2014) http://eprint.iacr.org/2014/113.

13. Akavia, A., Goldwasser, S., Vaikuntanathan, V.: Simultaneous hardcore bits and
cryptography against memory attacks. In Reingold, O., ed.: TCC 2009. Volume
5444 of LNCS., Springer (2009) 474–495

14. Alwen, J., Dodis, Y., Wichs, D.: Leakage-resilient public-key cryptography in the
bounded-retrieval model. In Halevi, S., ed.: CRYPTO 2009. Volume 5677 of LNCS.,
Springer (2009) 36–54

15. Dziembowski, S., Pietrzak, K.: Leakage-resilient cryptography. In: 49th FOCS,

IEEE Computer Society Press (2008) 293–302

16. Naor, M., Segev, G.: Public-key cryptosystems resilient to key leakage. In Halevi,

S., ed.: CRYPTO 2009. Volume 5677 of LNCS., Springer (2009) 18–35

17. Alawatugoda, J., Stebila, D., Boyd, C.: Protecting encrypted cookies from compres-
sion side-channel attacks (full version) (2014) Cryptology ePrint Archive, Report
2014/724. http://eprint.iacr.org/2014/724.

18. Pike, J.: Text compression using a 4 bit coding scheme. The Computer Journal 24

(1980) 324–330

19. Sanﬁlippo, S.: Smaz: Small strings compression library (2009) https://github.

com/antirez/smaz.

A Relations and separations between security notions

This section brieﬂy gives the intuition for the proofs of the relations and separa-
tions of the security notions; details appear in the full version [17].
– IND-CPA =⇒ CCI: A (non-compressing) IND-CPA-secure symmetric-key
encryption scheme provides indistinguishability of any pair of equal-length
chosen messages, including messages involving a cookie. The proof proceeds
by a hybrid argument, making the cookie used in each query made by the
adversary to its E1 oracle independent of the secret bit b.
(cid:54)=⇒ IND-CPA: A degenerate scheme that uses a separating-secrets ﬁlter
to extract secret cookies then encrypt the cookies but not the non-cookie
data is CCI-secure but not IND-CPA-secure for the whole message.

– CCI

– RCI

– CCI =⇒ RCI: A straightforward simulation: an adversary who cannot
distinguish between encryptions of equal-length cookies of its choosing can
also not distinguish between encryptions of randomly chosen equal-length
cookies.
(cid:54)=⇒ CCI: A counterexample is constructed that uses a separating-secrets
ﬁlter: an extra ciphertext component c2 is added, consisting of a point function
applied to the separated secrets, where the point function is 1 on a single,
publicly known cookie value z. With high probability, two randomly chosen
cookies will not match z, so c2 carries no useful information and the scheme
is RCI-secure, but a CCI adversary can choose one cookie that matches z and
one that does not, so c2 allows distinguishing of the chosen cookies.
– RCI =⇒ CR: A straightforward simulation: an adversary who recovers a
– CR (cid:54)=⇒ RCI: A counterexample is constructed: an extra ciphertext compo-
nent c2 is added, consisting of a random oracle applied to the message. The
adversary gets encryptions of m(cid:48)(cid:107)ck(cid:107)m(cid:48)(cid:48) for m(cid:48), m(cid:48)(cid:48) of its choice; without
querying the random oracle on exactly m(cid:48)(cid:107)ck(cid:107)m(cid:48)(cid:48), c2 provides no information
to the adversary, so the scheme is CR-secure. However, an RCI adversary
can check the random oracle on the two given random cookies, so c2 allows
distinguishing of the given random cookies.

cookie given only ciphertexts easily distinguishes encryptions of cookies.

B Proof of CCI security of separating-secrets technique

Proof of Theorem 1. The proof proceeds in a sequence of games, using a hybrid
approach. Each Game i proceeds as in the original CCI security experiment,
except that the queries to E1 are answered as in Figure 7. Let Advi denote the
probability that game i outputs 1.

E1(m(cid:48), m(cid:48)(cid:48))
1: if query # ≤ i then
2:
3: else if query # > i then
4:

return Π.Enck(SSf,Γ (m(cid:48)(cid:107)ck0(cid:107)m(cid:48)(cid:48)))
return Π.Enck(SSf,Γ (m(cid:48)(cid:107)ckb(cid:107)m(cid:48)(cid:48)))

Fig. 7. Oracle E1 used in Game i in proof of Theorem 1.

Π◦SSf,Γ ,CK(A) = Adv0 .

Game 0. This is the original CCI security game for Π. By deﬁnition,
AdvCCI
Transition from Game (i − 1) to Game i, 1 ≤ i ≤ q. Each hybrid transition
changes how one query is answered; if the adversary’s behaviour diﬀers because of
the change in answering the query, we can construct a simulator Bi that wins the
IND-CPA game for Ψ , as shown in Figure 8. When the IND-CPA challenger uses

i

()

BA,E
1: (ck0, ck1, st) $← AE2 ()

s.t. |ck0| = |ck1|

2: ˆb $← {0, 1}
3: b(cid:48) $← AE1,E2 (ck0, ck1, st)
4: return b(cid:48)

return E(SSf,Γ .Comp(m(cid:48)(cid:107)ck0(cid:107)m(cid:48)(cid:48)))

E1(m(cid:48), m(cid:48)(cid:48))
1: if query # < i then
2:
3: else if query # = i then
4:
5:

pt(cid:107)(cid:103)ptns ← SSf,Γ .Comp(m(cid:48)(cid:107)ckˆb(cid:107)m(cid:48)(cid:48))
pt(cid:48)(cid:107)(cid:103)ptns
(cid:48) ← SSf,Γ .Comp(m(cid:48)(cid:107)ck0(cid:107)m(cid:48)(cid:48))

6: Give (pt(cid:107)(cid:103)ptns, pt(cid:48)(cid:107)(cid:103)ptns

(cid:48)

) to IND-CPA chal-

E2(m)

1: return

E(SSf,Γ .Comp(m))

lenger
Receive c∗ from IND-CPA challenger
return c∗
return E(SSf,Γ .Comp(m(cid:48)(cid:107)ckˆb(cid:107)m(cid:48)(cid:48)))

7:
8:
9: else if query # > i then
10:

Fig. 8. Simulator Bi used in the proof of Theorem 1

b = 0, c∗ is the encryption of the separating-secrets compression of m(cid:48)(cid:107)ckˆb(cid:107)m(cid:48)(cid:48),
so Bi is playing game (i − 1) with A. When the IND-CPA challenger uses b = 1,
c∗ is the encryption of the separating-secrets compression of m(cid:48)(cid:107)ck0(cid:107)m(cid:48)(cid:48), so Bi is
playing game i with A. Since f is safe for CK, the separating-secrets compressions
of m(cid:48)(cid:107)ck0(cid:107)m(cid:48)(cid:48) and m(cid:48)(cid:107)ck1(cid:107)m(cid:48)(cid:48) have the same length, and thus the pair of chosen
messages given from the simulator in E1 to the IND-CPA challenger is valid ac-
i ) .

cording to the IND-CPA experiment. Thus,(cid:12)(cid:12)Advi−1 − Advi(cid:12)(cid:12) ≤ AdvIND-CPA

(BA

Ψ

Analysis of Game q. Since the adversary’s view is independent of b in Game q,
we have Advq = 0 .

Ψ,CK(A) ≤(cid:80)q

Conclusion. Combining the above results, we have
AdvCCI
of notation in creating a single B from the disparate Bi).

i ) = q · AdvIND-CPA

i=1 AdvIND-CPA

(BA

Ψ

Ψ

(BA) (with a small abuse

C Analysis of security of ﬁxed-dictionary technique

C.1 Probability bounds, no preﬁx/suﬃx

In this section, we compute the amount of information given to the adversary
from knowing the length of the compressed cookie, without any adversarially
chosen preﬁx or suﬃx. This can be computed by calculating the amount of
information given by knowing how many substrings of the cookie appear in the
dictionary. For the analysis, we treat D as a set of strings. Proofs for results in
this section appear in the full version of the paper [17].

First we calculate the probability that a given string is a substring of a

randomly chosen cookie.
Lemma 1. Let x ∈ Ωw be a word, and let ck $← Ωn = CK be a random string

of n characters. Then Pr(x (cid:22) ck) ≤ 1 −(cid:16)

(cid:17)n−w+1

.

1 − 1|Ω|w

We now compute that probability that one of a set of given strings is a

substring of a randomly chosen cookie:
Lemma 2. Let D ⊆ Ωw with |D| = d be a dictionary of d words of w characters.
Let ck $← Ωn = CK be a random string of n characters. Then

(cid:32)

(cid:18)

(cid:19)n−w+1(cid:33)

.

Pr(∃x ∈ D : x (cid:22) ck) ≤ d

1 −

1 − 1
|Ω|w

Recall the deﬁnition of conditional entropy for random variables X and Y :
H(Y | X) =

Pr(X = x)H(Y | X = x)

x∈supp(X)

(cid:88)
= − (cid:88)
· (cid:88)

x∈supp(X)

y∈supp(Y )

Pr(X = x)

Pr(Y = y | X = x) log2 Pr(Y = y | X = x) .

We now compute the amount of entropy about the cookie given knowledge

about the number of substrings of the cookie that appear in the dictionary:
Lemma 3. Fix D. Let #SUB(ck) denote the number of substrings of ck that
appear in D. Suppose CK is a uniform random variable on CK. Then
H(CK | #SUB(CK)) ≥

1 − d

(cid:32)

(cid:18)

1 −

1 − 1
|Ω|w

(cid:19)n−w+1(cid:33)(cid:33)
(cid:32)
(cid:18)

(cid:32)
(cid:32)

(cid:19)n−w+1(cid:33)(cid:33)

.

· log2

|CK| − |CK| · d

1 −

1 − 1
|Ω|w

For example, if we have 16-byte cookies (CK = {0x00, . . . , 0xFF}16), and the

dictionary D is a set of d = 4096 words of length w = 4 bytes, then

H(CK | #SUB(CK)) ≥ 127.998395 .

Concluding our analysis of the information learned given to the adversary
without any adversarially chosen preﬁx or suﬃx, we give a bound on the amount
of entropy about the cookie given the length of the compressed cookie:
Lemma 4. Fix D with d words of length w over character set Ω. Denote
the length of a cookie ck compressed with dictionary D by COMPLEN(ck) =
|FDD,w,(cid:96).Comp(ck)|. Suppose CK is a uniform random variable on CK. Then

H(CK | COMPLEN(CK)) ≥ H(CK | #SUB(CK))

(cid:32)

(cid:18)

(cid:32)
(cid:32)

≥

1 − d

1 −

1 − 1
|Ω|w

(cid:19)n−w+1(cid:33)(cid:33)
(cid:32)
(cid:18)

· log2

|CK| − |CK| · d

1 −

1 − 1
|Ω|w

(cid:19)n−w+1(cid:33)(cid:33)

.

Lemma 4 follows from the data processing inequality and Lemma 3.

C.2 Probability bounds, preﬁx/suﬃx
Suppose CK is a uniform random variable on CK = Ωn. We know that H(CK) =
n log2(|Ω|). Trivially, H(CK | CK1) = (n − 1) log2(|Ω|), where CK1 is the ﬁrst
character of CK. Similarly, H(CK | CK1:a) = (n − a) log2(|Ω|) and ﬁnally
H(CK | CK1:a, CKn−b:b) = (n − a − b) log2(|Ω|).
Consider the following CRIME-like attack on the beginning of the cookie. Let
D be a dictionary with d words of length w over character set Ω. Let ck ∈ Ωn.
Let O(·) be an oracle that, upon input a of length w − m, with 1 ≤ m ≤ w − 1,
returns 1 if and only if a(cid:107)ck1:m ∈ D.

The CRIME-like attack works as follows:

1. For each x ∈ D, query x1:w−1 to the oracle. If a query for x1:w−1 returns 1,
then it is known that ck1:1 ∈ Z1 = {z : x1:w−1(cid:107)z ∈ D}. If no query returns 1,
then return ∅.
2. For m = 2, . . . , w − 1: For each x ∈ D such that xw−m ∈ Zm−1, query
x1:w−m to the oracle. If a query for x1:w−m returns 1, then it is known that
ck1:m ∈ Zm = {z1z2 . . . zm : x1:w−m(cid:107)z1z2 . . . zm ∈ D}. If no query returns 1,
then return Z1, . . . , Zm−1.

3. Return Z1, . . . , Zw−1.

A corresponding attack on the suﬃx is obvious.
Let CRIMEpre(ck) denote the output obtained from running the above preﬁx
CRIME attacks on ck, CRIMEsuf(ck) denote the output from the corresponding
suﬃx attack. Let CRIME(ck) = (CRIMEpre(ck), CRIMEsuf(ck)).
Noting that in the best case the CRIME attack allows the attacker to learn
the ﬁrst w − 1 and the last w − 1 characters of the cookie, some trivial lower
bounds are:

H(CK1:w−1 | CRIME(CK)) ≥ 0
H(CKn−w+1:w−1 | CRIME(CK)) ≥ 0

However, the CRIME attack provides no information about the remaining char-
acters, so I(CK1:w−1, CKw:n−w+1) = 0 and I(CK1:n−w+1, CKn−w+1:w−1) = 0,
and thus H(CKw:n−w+2 | CRIME(CK), COMPLEN(CK)) = H(CKw:n−w+2 |
COMPLEN(CK)).

Finally, we have that

H(CK | CRIME(CK), COMPLEN(CK))

≥ H(CK1:w−1 | CRIMEpre(CK)) + H(CKw:n−w+2 | COMPLEN(CK))

+ H(CKn−w+1:w−1 | CRIMEsuf(CK))

≥ 0 + H(CKw:n−w+2 | COMPLEN(CK)) + 0

and we can obtain a lower bound on H(CKw:n−w | COMPLEN(CK)) using
Lemma 4.

