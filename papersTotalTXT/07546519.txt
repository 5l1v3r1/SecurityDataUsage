2016 IEEE Symposium on Security and Privacy
2016 IEEE Symposium on Security and Privacy

Multiple Handshakes Security

of TLS 1.3 Candidates

Xinyu Li∗†, Jing Xu∗, Zhenfeng Zhang∗, Dengguo Feng∗, Honggang Hu†

∗Trusted Computing and Information Assurance Laboratory, SKLCS,
Institute of Software, Chinese Academy of Sciences, Beijing, China

†CAS Key Laboratory of Electromagnetic Space Information,
University of Science and Technology of China, Hefei, China

Email: {lixinyu, xujing, zfzhang, feng}@tca.iscas.ac.cn, hghu2005@ustc.edu.cn

Abstract—The Transport Layer Security (TLS) protocol is by
far the most widely deployed protocol for securing communica-
tions and the Internet Engineering Task Force (IETF) is currently
developing TLS 1.3 as the next-generation TLS protocol. The
TLS standard features multiple modes of handshake protocols
and supports many combinational running of successive TLS
handshakes over multiple connections. Although each handshake
mode is now well-understood in isolation, their composition in
TLS 1.2 remains problematic, and yet it is critical to obtain
practical security guarantees for TLS.

In this paper, we present the ﬁrst formal treatment of multiple
handshakes protocols of TLS 1.3 candidates. First, we introduce
a multi-level&stage security model, an adaptation of the Bellare-
Rogaway authenticated key exchange model, covering all kinds
of compositional interactions between different TLS handshake
modes and providing reasonably strong security guarantees. Next,
we prove that candidate handshakes of TLS 1.3 draft meet
our strong notion of multiple handshakes security. Our results
conﬁrm the soundness of TLS 1.3 security protection design.
Such a multi-level&stage approach is convenient for analyzing
the compositional design of the candidates with different session
modes, as they establish dependencies of multiple sessions.

We also identify the triple handshake attack of Bhargavan et
al. on TLS 1.2 within our multiple handshakes security model.
We show generically that the proposed ﬁxes (RFC 7627) for TLS
1.2 offer good protection against multiple handshakes attacks.

I. INTRODUCTION

TLS [1][2] is the Internet’s most widely used cryptographic
protocol to provide secure communications between a client
and a server. As the successor of SSL protocol, TLS now
is a general provider of secure communications to a variety
of applications such as web browsers, electronic mail, VPN
and more. TLS has two main constituents: the TLS handshake
protocol, which allows a client and a server to authenticate
each other and to agree on security parameters and a session
key, and the TLS record protocol, which provides a secure
channel for communication of application data. In spite of
its fundamental role in the Internet security infrastructure,
we have witnessed frequent successful attacks against TLS,
such as the weakness in RC4 [3], the Lucky 13 attack [4],
the triple handshake attack [5], and the Heartbleed attack
[6], which have been addressed with occasional and ad-hoc
“patches”. Partly due to these security weaknesses, but also

Jing Xu and Zhenfeng Zhang are the corresponding authors.

2375-1207/16 $31.00 © 2016 IEEE
© 2016, Xinyu Li. Under license to IEEE.
DOI 10.1109/SP.2016.36
DOI 10.1109/SP.2016.36

486
486

because of additional performance requirements such as low
handshake latency, the Internet Engineering Task Force (IETF)
is currently developing the next version of the TLS, named
TLS version 1.3. As of November 2015, the draft candidate in
discussion is draft-ietf-tls-tls13-10 [7]. Different from previous
TLS versions, the standardization process of TLS 1.3 is fully
transparent, which makes its comprehensive cryptographic
analysis feasible prior to adoption.

In addition to the updated version, the protocol design in
TLS 1.3 draft includes several cryptographic changes that are
substantially different from TLS 1.2, including: (1) removing
renegotiation protocol; (2) providing 0-RTT option, in which
clients can send protected information on the ﬁrst message
ﬂow in case that the client has a previously retrieved or cached
public key of the server, thus reducing handshake latency; (3)
encrypting some handshake data such as the client certiﬁcate
with an intermediated session key; (4) including hashes of
handshake messages in a variety of key calculations; (5) using
a different key to encrypt the ﬁnal Finished messages than is
used to encrypt the application data.

For both TLS 1.3 draft and its earlier versions, TLS features
dependencies of multiple runs of the handshake protocols.
For instance,
in TLS 1.3 draft, a client connection may
ﬁrstly run a full handshake, then run a second 0-RTT session
using a ServerConﬁguration message transmitted in the full
handshake, ﬁnally using a parallel connection, the client may
run a third resumption handshake, re-using the resumption
master secret of 0-RTT to derive new keys. Also note that
despite each mode in TLS 1.2 handshake protocols is now
independently proven secure, their composition has been the
cause of several practical attacks on TLS. In 2009, Ray and
Dispensa [8] demonstrated how TLS renegotiation allows an
attacker to inject trafﬁc into a legitimate client-server exchange
such that the TLS server will accept it as if it came from
the honest client. Subsequently, the IETF TLS working group
provided countermeasures to link the renegotiation handshake
with its preceding epoch and developed RFC 5746 [9] as a
mandatory extension for all versions of TLS. However, this
guarantee does not carry over to link different connections
that resume the original session, and in 2014, Bhargavan et al.
[5] presented a triple handshake attack on TLS 1.2 exploiting
the unexpected composition of triple modes of the hand-

shake protocols. Concretely, the malicious server performs
a man-in-the-middle attack on three successive handshakes
(full handshake, resumption and renegotiation) between the
honest client and server, and succeeds in impersonating the
client on the third handshake. Their attacks can be mounted
on popular web browsers, VPN applications, and HTTPS
libraries, and a number of vendors,
including the major
browser vendors Apple, Google and Microsoft, which have
implemented a patch or some mitigation. Recently, Bhargavan
et al. [10] uncovered new compound authentication attacks on
TLS renegotiation, SSH re-exchange, IKEv2 resumption, and
a number of other channel binding proposals. These attacks
stress the need to model multiple related sessions of handshake
protocols. Therefore, compositional security in TLS handshake
protocols is critical to obtain practical security guarantees for
TLS, especially for the upcoming TLS 1.3 though no similar
ﬂaw has been announced up to now. This is in sharp contrast
with prior work on the provable security of TLS, which focus
on a ﬁxed run of the protocol.

A. Related Work

Given the paramount importance of TLS, formal under-
standing of its security is an important goal of cryptography.
However, the progress on formally modeling the security of
TLS handshake protocols has been slow. A main obstacle
is that the design of TLS 1.2 and earlier versions violates
the basic cryptographic principles of key indistinguishability
in standard authenticated key exchange (AKE) models. More
precisely, the ﬁnal handshake Finished message of TLS 1.2
protocol is encrypted under the session key, so an adversary
can distinguish the session key from a random key by trying
to verify the Finished message. Therefore, it is impossible
to prove security of the TLS 1.2 handshake protocol in any
classic AKE model. In 2012, Jager et al. [11] put forth a
new security notion, called Authenticated and Conﬁdential
Channel Establishment (ACCE), which captures the desired
security guarantees when the TLS handshake protocol and
record protocol are combined together, and then they gave
the ﬁrst full security proof of unmodiﬁed TLS-DHE in ACCE
model.

Subsequent efforts have shown that most other TLS hand-
shake protocols are also ACCE secure. Kohlar et al. [12]
studied the ACCE security of TLS-RSA when instantiated
with an IND-CCA secure key transport encryption scheme.
Krawczyk et al. [13] used a key-encapsulation mechanism
(KEM) abstraction for the cryptographic core of TLS, and
gave the ﬁrst proof of security of TLS-RSA and server-only
authentication, without having to assume IND-CCA security
for RSA PKCS#1v1.5. Giesen et al. [14] extended the ACCE
model to analyze the renegotiation security of TLS in light
of the attack of Ray and Dispensa [8], while Li et al. [15]
extended the ACCE model to cover protocols with pre-shared
keys, and proved the security of TLS-PSK ciphersuites.

In 2014, Bhargavan et al. [16] gave a comprehensive analy-
sis of TLS 1.2 handshake protocol in the agile setting, covering
the various ciphersuite options in TLS 1.2, and applying the

results to a miTLS implementation [17][18]. This work can
overcome the issue that the session key is already used in the
ﬁnal part of the handshake protocol at the cost of introducing
a cunning approach to release the record layer key early.

Recently, Dowling et al. [19] showed that both of the two
earlier candidates of TLS 1.3 handshake protocol, draft-05 [20]
and draft-dh [21], are proven secure under the modiﬁed multi-
stage key exchange model introduced by Fischlin and G¨unther
[22]. In addition, the authors treated session resumption in TLS
1.3 drafts as a separate symmetric-key protocol and showed
that the resumption master secrets output by the full handshake
can be safely composed with the session resumption by
using the compositional approach under certain conditions, and
further made some comments on the TLS 1.3 design. However,
they omitted the security analysis of 0-RTT which has not been
speciﬁed until TLS 1.3 draft-07 [23].

Concurrently to our work, Krawczyk et al. [24] presented
OPTLS, a key exchange protocol, serving as a basis for
analyzing handshake protocol of TLS 1.3 draft, and also
presented an analysis of its four primary modes which can
be applied to TLS 1.3 under Canetti-Krawczyk model [25].
Although the security of 0-RTT was considered, their work
focused on server authentication only and did not analyze the
interactions between the different protocol modes.

TLS 1.3 borrows from a similar mechanism namely QUIC
[26] for supporting the 0-RTT case, and thus we can refer
to the analysis of QUIC. Fischlin and G¨unther [22] analyzed
the key exchange of QUIC 0-RTT, and showed that QUIC
satisﬁes a reasonable multi-stage security, however, for the
desirable security of the composition with data exchange
protocol, QUIC has to be slightly modiﬁed. In parallel with
their work, Lychev et al. [27] provided a provable-security
analysis for the complete QUIC under the modiﬁed ACCE
model with treating HMAC as the random oracle, and they
also gave a quantitative analysis of the performance properties
of QUIC under adversarial settings.

However, previous security results on TLS focus on analyz-
ing either each handshake mode in isolation, or partial com-
position such as full handshake and renegotiation [14] only,
which is not enough to comprehensively analyzing a complex
TLS speciﬁcation. Moreover, in practice TLS also supports
many combinational running of successive TLS handshakes
over multiple connections, which leaves a gap between single
handshake security result and real-world security.

B. Our Contributions

While we have a good understanding of the security that
each mode in TLS handshake protocols is executed in a stand-
alone way,
there are no rigorously demonstrated, or even
deﬁned, guarantees for their interaction between the different
modes. Our work ﬁlls this gap.
Security model for multiple handshakes protocols. Our goal
is to deﬁne a sufﬁciently rich model for multiple handshakes
protocols, covering all kinds of compositional
interactions
between the different TLS handshake modes and providing
reasonably strong security guarantees. Our starting point is the

487487

Bellare-Rogaway model [28], as it is liberal enough to capture
many key exchange protocols. In order to cover the various
modes of TLS multiple handshakes, we introduce a Multi-
Level&Stage security model. Essentially, each node in some
level corresponds to a handshake session, and each session can
have multiple stages. A multiple handshakes protocol running
is represented by the nodes on the path from the root level
to the leaf level. On this path the session in some level is
dependent on the session in its last level, and more specially,
one session may cache and use the key materials established
or transmitted during its last level session.

A primary difference with the single handshake case lies
in the dependencies of the different levels. In particular, the
property of level key dependence is considered, which means
that the session key in some stage of level i is used to derive
the session key of level i + 1, and thus in this case we cannot
allow the adversary to reveal the corresponding session key
of level i before the key of the next level is established. In
addition, we deﬁne match security by additionally introducing
collision-freeness of session identiﬁers across different hand-
shake modes and across different levels. Also note that, to
capture the attacks similar to the triple handshake attack, we
treat the property that sessions with different session identiﬁers
have different session keys explicitly in the security deﬁnition,
which has not been included in the security deﬁnition of [22]
and [19], probably due to that both in QUIC and TLS 1.3
draft this property can be achieved implicitly by including
the hash of all messages exchanged so far in the derivation
of the session keys, however, as a general security model
for single handshake or multiple handshakes protocols, this
property should be included to capture the corresponding
attack explicitly.

Another important point is that we introduce the semi-static
key, a key between ephemeral keys and static keys. TLS 1.3
draft suggests that in a 0-RTT handshake mode, the server
provides a ServerConﬁguration message containing the semi-
static key gs associated with an unique Conﬁguration id,
so that on future connections to the same server, the client
can use that share to send early application data. This means
that semi-static keys are not bound to a single session, so
our model allows the adversary to learn gs, as well as the
secret s through Corrupt query with the restriction that only
after the handshake is ﬁnished. In addition, in order to cover
various authenticity properties of handshake protocols, we also
allow the adversary to determine the type of authentication,
i.e., unauthenticated, unilaterally authenticated, or mutually
authenticated. We also allow executions of different authen-
tication types to run concurrently, even within a single party.
In summary, the basic goal of a secure multiple handshakes
protocol is that (a) whenever parties successfully ﬁnish the
protocol, they should have match security guarantees such as
identical keys in partnered sessions, authenticity of the partner
(if needed), and collision-freeness of session identiﬁers, and
(b) the adversary should not be able to distinguish between
the real session key produced by the protocol and a random
key drawn from the same distribution. Moreover, our multiple

handshakes security model can be applied to analyze the
compositional security of other key exchange protocols with
different running modes.
Security of multiple handshakes protocols in TLS 1.3 draft.
One of our main contributions is the ﬁrst formal security
analysis of multiple handshakes of TLS 1.3 candidates in
combinational running setting, covering the various interac-
tions of handshake modes. We show that TLS 1.3 multiple
handshakes protocol achieves the main goal of providing
secure authenticated key exchange in the Multi-Level&Stage
security model.

Our approach for proving the multiple handshakes security
of TLS 1.3 draft is modular. We cannot make use of existing
security results via some kind of the compositional framework
of Brzuska et al. [29] or the subsequent works such as
[22] and [19], because 0-RTT cannot be seen as a secure
symmetric-key protocol while PSK/resumption as a secure
key exchange protocol cannot provide forward secrecy, neither
of which satisﬁes the condition of the composition theorem.
Instead, via an induction approach, we show that if a multiple
handshakes protocol Π is secure in the Multi-Level&Stage
(cid:2),
security model, then new multiple handshakes protocol Π
by combining Π with a handshake session whose mode may
be any kind of handshake mode allowed in TLS 1.3 draft,
is still Multi-Level&Stage-secure, thus we can prove the
multiple handshakes security in TLS 1.3 draft. And by doing
so, our study details the exact level of security the multiple
handshakes protocol provides, for instance, by combining Π
with 0-RTT protocol, we can prove the new added session
is secure in a key-independent and stage-2-forward-secrecy
manner.

Also note that we just focus on the permitted composi-
tion according to the TLS 1.3 draft-10. Specially, the draft
disallows a new ServerConﬁguration to be provided in a
PSK-based resumption handshake, and thus 0-RTT handshakes
cannot be dependent on PSK-based resumption handshakes
and we will leave out this case.

In summary, our work sheds light on important design of
TLS 1.3 draft that would be helpful for its standardization.
On a high level, our provable security analysis conﬁrms the
soundness of TLS 1.3 security protection design.
Multiple handshakes (In)security of TLS 1.2. By recall-
ing the triple handshake attack of Bhargavan et al. [5], we
discuss how TLS 1.2 without countermeasures is not secure
in our multiple handshakes security model. We subsequently
analyze the security of TLS 1.2 with the extended master
secret extension of RFC 7627 [30] and show that TLS 1.2
with countermeasures offers good protection against multiple
handshakes attack. Our analysis of TLS 1.2 again conﬁrms the
soundness of multiple handshakes security model.

II. THE TLS 1.3 DRAFT-10 HANDSHAKE PROTOCOL
In TLS 1.3 draft, there are four primary handshake modes:
full handshake mode, 0-RTT mode, PSK based resumption (P-
SK/resumption) mode, and PSK based resumption combining
with (EC)DHE (PSK/resumption-(EC)DHE) mode.

488488

ǆ^(cid:3)(cid:1370) (cid:11)(cid:14)(cid:7)(cid:9)(cid:484) (cid:8)(cid:154)(cid:150)(cid:148)(cid:131)(cid:133)(cid:150)(cid:4666)(cid:882)(cid:481) (cid:8)(cid:22)(cid:4667)(cid:3)
ǆ^^(cid:3)(cid:1370) (cid:11)(cid:14)(cid:7)(cid:9)(cid:484) (cid:8)(cid:154)(cid:150)(cid:148)(cid:131)(cid:133)(cid:150)(cid:4666)(cid:882)(cid:481) (cid:22)(cid:22)(cid:4667)(cid:3)

(cid:150)(cid:141)(cid:1860)(cid:1871) (cid:1370) (cid:11)(cid:14)(cid:7)(cid:9)(cid:484) (cid:8)(cid:154)(cid:146)(cid:131)(cid:144)(cid:134)(cid:4666)(cid:154)(cid:8)(cid:22)(cid:481) (cid:142)(cid:131)(cid:132)(cid:135)(cid:142)(cid:883)(cid:481) (cid:11)(cid:883)(cid:4667)(cid:3)

(cid:149)(cid:150)(cid:131)(cid:137)(cid:135) (cid:883)(cid:3)

^ĞƌǀĞƌ(cid:3)^

^ĞƌǀĞƌ,ĞůůŽ͗(cid:3) (cid:1870)(cid:1871) (cid:1370) (cid:836)(cid:4668)(cid:882)(cid:481)(cid:883)(cid:4669)(cid:1864)(cid:3)
н<ĞǇ^ŚĂƌĞ͗(cid:3) (cid:28) (cid:1370) (cid:1859)(cid:1877) (cid:3)
(cid:22)(cid:22)(cid:481) (cid:8)(cid:22) (cid:1370) (cid:27)(cid:1877) (cid:3)

(cid:3) ΂ŶĐƌǇƉƚĞĚǆƚĞŶƐŝŽŶƐ΃(cid:3)
΂(cid:22)(cid:135)(cid:148)(cid:152)(cid:135)(cid:148)(cid:6)(cid:145)(cid:144)(cid:136)(cid:139)(cid:137)(cid:151)(cid:148)(cid:131)(cid:150)(cid:139)(cid:145)(cid:144)(cid:1499)(cid:4669)(cid:3)
΂^ĞƌǀĞƌ(cid:6)(cid:135)(cid:148)(cid:150)(cid:139)(cid:136)(cid:139)(cid:133)(cid:131)(cid:150)(cid:135)(cid:1499)΃(cid:3)
΂(cid:6)(cid:135)(cid:148)(cid:150)(cid:139)(cid:136)(cid:139)(cid:133)(cid:131)(cid:150)(cid:135)(cid:21)(cid:135)(cid:147)(cid:151)(cid:135)(cid:149)(cid:150)(cid:1499)΃(cid:3)
΂^ĞƌǀĞƌ(cid:6)(cid:135)(cid:148)(cid:150)(cid:139)(cid:136)(cid:139)(cid:133)(cid:131)(cid:150)(cid:135)(cid:25)(cid:135)(cid:148)(cid:139)(cid:136)(cid:155)(cid:1499)΃(cid:3)
^s(cid:3)(cid:1370) (cid:22)(cid:139)(cid:137)(cid:144)(cid:4666)(cid:1871)(cid:1863)(cid:1845)(cid:481) (cid:11)(cid:884)(cid:4667)(cid:3)
΂(cid:22)(cid:135)(cid:148)(cid:152)(cid:135)(cid:148)(cid:9)(cid:139)(cid:144)(cid:139)(cid:149)(cid:138)(cid:135)(cid:134)΃(cid:3)
^&(cid:3) (cid:1370) (cid:11)(cid:16)(cid:4)(cid:6)(cid:4666)(cid:9)(cid:22)(cid:481) (cid:142)(cid:131)(cid:132)(cid:135)(cid:142)(cid:885)(cid:481) (cid:11)(cid:885)(cid:4667)(cid:3)

ůŝĞŶƚ(cid:3)
ůŝĞŶƚ,ĞůůŽ͗(cid:3) (cid:1870)(cid:1855) (cid:1370) (cid:836)(cid:4668)(cid:882)(cid:481)(cid:883)(cid:4669)(cid:1864)(cid:3)
н<ĞǇ^ŚĂƌĞ͗(cid:3) (cid:27) (cid:1370) (cid:1859)(cid:1876) (cid:3)

^^͕(cid:8)(cid:22) (cid:1370) (cid:28)(cid:1876)(cid:3)

&^(cid:3) (cid:1370) (cid:11)(cid:14)(cid:7)(cid:9)(cid:484) (cid:8)(cid:154)(cid:146)(cid:131)(cid:144)(cid:134)(cid:4666)(cid:154)(cid:22)(cid:22)(cid:481) (cid:142)(cid:131)(cid:132)(cid:135)(cid:142)(cid:884)(cid:481) (cid:11)(cid:885)(cid:4667)(cid:3)

sĞƌŝĨǇ(cid:4666)(cid:1868)(cid:1863)(cid:1845)(cid:481) (cid:22)(cid:6)(cid:25)(cid:481) (cid:11)(cid:884)(cid:4667)(cid:3)
ŚĞĐŬ(cid:3)^&с(cid:11)(cid:16)(cid:4)(cid:6)(cid:4666)(cid:9)(cid:22)(cid:481) (cid:142)(cid:131)(cid:132)(cid:135)(cid:142)(cid:885)(cid:481) (cid:11)(cid:885)(cid:4667)(cid:3)
΂ůŝĞŶƚ(cid:6)(cid:135)(cid:148)(cid:150)(cid:139)(cid:136)(cid:139)(cid:133)(cid:131)(cid:150)(cid:135)(cid:1499)΃(cid:3)
΂ůŝĞŶƚ(cid:6)(cid:135)(cid:148)(cid:150)(cid:139)(cid:136)(cid:139)(cid:133)(cid:131)(cid:150)(cid:135)(cid:25)(cid:135)(cid:148)(cid:139)(cid:136)(cid:155)(cid:1499)΃(cid:3)
(cid:6)(cid:6)(cid:25) (cid:1370) (cid:22)(cid:139)(cid:137)(cid:144)(cid:4666)(cid:1871)(cid:1863)(cid:1829)(cid:481) (cid:11)(cid:886)(cid:4667)(cid:3)
΂(cid:6)(cid:142)(cid:139)(cid:135)(cid:144)(cid:150)(cid:9)(cid:139)(cid:144)(cid:139)(cid:149)(cid:138)(cid:135)(cid:134)΃(cid:3)
&с(cid:11)(cid:16)(cid:4)(cid:6)(cid:4666)(cid:9)(cid:22)(cid:481) (cid:142)(cid:131)(cid:132)(cid:135)(cid:142)(cid:886)(cid:481) (cid:11)(cid:887)(cid:4667)(cid:3)

sĞƌŝĨǇ(cid:4666)(cid:1868)(cid:1863)(cid:1829)(cid:481) (cid:6)(cid:6)(cid:25)(cid:481) (cid:11)(cid:886)(cid:4667)(cid:3)
ŚĞĐŬ(cid:3)&с(cid:11)(cid:16)(cid:4)(cid:6)(cid:4666)(cid:9)(cid:22)(cid:481) (cid:142)(cid:131)(cid:132)(cid:135)(cid:142)(cid:886)(cid:481) (cid:11)(cid:887)(cid:4667)(cid:3)

(cid:143)(cid:8)(cid:22) (cid:1370) (cid:11)(cid:14)(cid:7)(cid:9)(cid:484) (cid:8)(cid:154)(cid:146)(cid:131)(cid:144)(cid:134)(cid:4666)(cid:154)(cid:8)(cid:22)(cid:481) (cid:142)(cid:131)(cid:132)(cid:135)(cid:142)(cid:887)(cid:481) (cid:11)(cid:885)(cid:4667)(cid:3)
ŵ^^(cid:3) (cid:1370) (cid:11)(cid:14)(cid:7)(cid:9)(cid:484) (cid:8)(cid:154)(cid:146)(cid:131)(cid:144)(cid:134)(cid:4666)(cid:154)(cid:22)(cid:22)(cid:481) (cid:142)(cid:131)(cid:132)(cid:135)(cid:142)(cid:888)(cid:481) (cid:11)(cid:885)(cid:4667)(cid:3)

D^(cid:3) (cid:1370) (cid:11)(cid:14)(cid:7)(cid:9)(cid:484) (cid:8)(cid:154)(cid:150)(cid:148)(cid:131)(cid:133)(cid:150)(cid:4666)(cid:143)(cid:22)(cid:22)(cid:481) (cid:143)(cid:8)(cid:22)(cid:4667)(cid:3)

(cid:150)(cid:141)(cid:1853)(cid:1868)(cid:1868) (cid:1370) (cid:11)(cid:14)(cid:7)(cid:9)(cid:484) (cid:8)(cid:154)(cid:146)(cid:131)(cid:144)(cid:134)(cid:4666)(cid:16)(cid:22)(cid:481) (cid:142)(cid:131)(cid:132)(cid:135)(cid:142)(cid:889)(cid:481) (cid:11)(cid:887)(cid:4667)(cid:3)
ZD^(cid:3) (cid:1370) (cid:11)(cid:14)(cid:7)(cid:9)(cid:484) (cid:8)(cid:154)(cid:146)(cid:131)(cid:144)(cid:134)(cid:4666)(cid:16)(cid:22)(cid:481) (cid:142)(cid:131)(cid:132)(cid:135)(cid:142)(cid:890)(cid:481) (cid:11)(cid:887)(cid:4667)(cid:3)
D^(cid:3) (cid:1370) (cid:11)(cid:14)(cid:7)(cid:9)(cid:484) (cid:8)(cid:154)(cid:146)(cid:131)(cid:144)(cid:134)(cid:4666)(cid:16)(cid:22)(cid:481) (cid:142)(cid:131)(cid:132)(cid:135)(cid:142)(cid:891)(cid:481) (cid:11)(cid:887)(cid:4667)(cid:3)

(cid:149)(cid:150)(cid:131)(cid:137)(cid:135) (cid:884)(cid:3)
(cid:149)(cid:150)(cid:131)(cid:137)(cid:135) (cid:885)(cid:3)
(cid:149)(cid:150)(cid:131)(cid:137)(cid:135) (cid:886)(cid:3)
΀EĞǁ^ĞƐƐŝŽŶdŝĐŬĞƚ΁(cid:3)

Fig. 1. The full handshake protocol in TLS 1.3 draft-10. {XXX} indicates a
message XXX encrypted using AEAD encryption with handshake trafﬁc key
tkhs. [XXX] indicates a message XXX encrypted using AEAD encryption
with application trafﬁc key tkapp. XXX∗ indicates a message that can
be transmitted optionally. Hi denotes the hash of the handshake messages
containing the messages starting at ClientHello up to the present time with
the exception of the Finished message.

A. draft-10 Full Handshake

Figure 1 shows the message ﬂow and relevant cryptographic
computations as well as the key schedule for the full hand-
shake in draft-10.

The handshake messages are as follows:

. ClientHello/ServerHello contain the supported versions

and ciphersuites for negotiation, as well as random nonces
rc resp. rs. Both messages can also include HelloExtension
ﬁeld.

. KeyShare contains the ephemeral Difﬁe-Hellman shares
X = gx resp. Y = gy for the group selected by
ClientHello/ServerHello. These messages are included in
HelloExtension ﬁeld.
. EncryptedExtension is the ﬁrst message that is encrypted
. ServerConﬁguration contains the semi-static (EC)DHE

under tkhs.

share for 0-RTT in the future,

identiﬁed by an unique

Conﬁguration id .

authentication using a certiﬁcate.

certiﬁcate of the respective party.

. ServerCertiﬁcate/ClientCertiﬁcate contain the public-key
. CertiﬁcateRequest indicates the server requests for client
. ServerCertiﬁcateVerify/ClientCertiﬁcateVerify contain a
. ClientFinished/ServerFinished contain the HMAC evalu-
. NewSessionTicket creates a pre-shared key (PSK) binding

ation on the session hash under the ﬁnished key FS.

digital signature over the session hash.

between the resumption master secret and the ticket label
for PSK/resumption in the future.
In full handshake protocol, both parties can negotiate ci-
phersuites and key-exchange parameters, and compute the key
at the corresponding stage which has been listed in Figure 1.
At the end of the handshake, both parties can compute the
application trafﬁc key tkapp, the resumption master key RMS,
and the exporter master key EMS. Moreover, key derivation
is done using the HKDF extract-then-expand key derivation
function [31][32], rather than the TLS PRF.

B. draft-10 0-RTT Handshake

Figure 2 shows the message ﬂow and relevant cryptographic
computations as well as the key schedule for the 0-RTT
handshake in draft-10. In 0-RTT handshake protocol, within
the ClientHello message the client sends its EarlyDataIndi-
cation message containing the conﬁguration id informa-
tion to request a 0-RTT handshake. The server accepts the
EarlyDataIndication extension only if the conﬁguration id
matches a known ServerConﬁguration, and then both the
parties use the server’s semi-static key share S = gs to run 0-
RTT, otherwise the handshake will fall back to 1-RTT, where
gs and conﬁguration id contained in a ServerConﬁguration
message are provided by the server in its last session.

The main difference from the full handshake is that SS
would not be equal to ES any more, and the client can send
the application data as well as its Certiﬁcate and Certiﬁcat-
eVerify (if client authentication is required) on its ﬁrst ﬂight
under the key Eadk.

C. draft-10 PSK/resumption and PSK/resumption-(EC)DHE
handshake

Figure 3 shows the message ﬂow and relevant crypto-
graphic computations as well as the key schedule for the
PSK/resumption in draft-10, where ClientHello includes a
PreSharedKeyExtension to indicate the identity of the pre-
shared key of some previously established session. The client
and server set the SS and ES to previous session’s resumption
master secret RMS (denoted by PSK in Figure 3), which has
been authenticated, so they do not exchange key shares or
signatures, and only exchange fresh nonces to derive the new
keys quickly.

Note that PSK/resumption mode does not achieve forward
secrecy, but can be augmented with a (EC)DHE exchange to
provide forward secrecy in combination with the shared keys,
namely PSK/resumption-(EC)DHE mode.

489489

^ĞƌǀĞƌ(cid:3)^

ůŝĞŶƚ(cid:3)
ůŝĞŶƚ,ĞůůŽ͗(cid:3) (cid:1870)(cid:1855) (cid:1370) (cid:836)(cid:4668)(cid:882)(cid:481)(cid:883)(cid:4669)(cid:1864)(cid:3)
нWƌĞ^ŚĂƌĞĚ<ĞǇǆƚĞŶƐŝŽŶ(cid:3)

ǆ(cid:22)(cid:22) (cid:1370) (cid:11)(cid:14)(cid:7)(cid:9)(cid:484) (cid:8)(cid:154)(cid:150)(cid:148)(cid:131)(cid:133)(cid:150)(cid:4666)(cid:882)(cid:481) (cid:22)(cid:22)(cid:4667)(cid:3)

ĂĚŬ(cid:3)(cid:1370) (cid:11)(cid:14)(cid:7)(cid:9)(cid:484) (cid:8)(cid:154)(cid:146)(cid:131)(cid:144)(cid:134)(cid:4666)(cid:154)(cid:22)(cid:22)(cid:481) (cid:142)(cid:131)(cid:132)(cid:135)(cid:142)(cid:883)(cid:481) (cid:11)(cid:883)(cid:4667)(cid:3)

(cid:22)(cid:22) (cid:1370) (cid:27)(cid:1871)

(cid:149)(cid:150)(cid:131)(cid:137)(cid:135) (cid:883)(cid:3)

^^͕(cid:8)(cid:22) (cid:1370) (cid:19)(cid:22)(cid:14)(cid:3)

^ĞƌǀĞƌ(cid:3)^

^ĞƌǀĞƌ,ĞůůŽ͗(cid:3) (cid:1870)(cid:1871) (cid:1370) (cid:836)(cid:4668)(cid:882)(cid:481)(cid:883)(cid:4669)(cid:1864)(cid:3)
(cid:3) нWƌĞ^ŚĂƌĞĚ<ĞǇǆƚĞŶƐŝŽŶ(cid:3)
(cid:22)(cid:22)(cid:481) (cid:8)(cid:22) (cid:1370) (cid:19)(cid:22)(cid:14)(cid:3)

ůŝĞŶƚ(cid:3)
ůŝĞŶƚ,ĞůůŽ͗(cid:3) (cid:1870)(cid:1855) (cid:1370) (cid:836)(cid:4668)(cid:882)(cid:481)(cid:883)(cid:4669)(cid:1864)(cid:3)
н<ĞǇ^ŚĂƌĞ͗(cid:3) (cid:27) (cid:1370) (cid:1859)(cid:1876) (cid:3)
нĂƌůǇĂƚĂ/ŶĚŝĐĂƚŝŽŶ(cid:3)
(cid:22)(cid:22) (cid:1370) (cid:22)(cid:1876)(cid:3)

(cid:3) ;ŶĐƌǇƉƚĞĚǆƚĞŶƐŝŽŶƐ(cid:4667)(cid:3)
;(cid:6)(cid:142)(cid:139)(cid:135)(cid:144)(cid:150)(cid:6)(cid:135)(cid:148)(cid:150)(cid:139)(cid:136)(cid:139)(cid:133)(cid:131)(cid:150)(cid:135)(cid:1499)Ϳ(cid:3)
;(cid:6)(cid:142)(cid:139)(cid:135)(cid:144)(cid:150)(cid:6)(cid:135)(cid:148)(cid:150)(cid:139)(cid:136)(cid:139)(cid:133)(cid:131)(cid:150)(cid:135)(cid:25)(cid:135)(cid:148)(cid:139)(cid:136)(cid:155)(cid:1499)Ϳ(cid:3)
s(cid:3)(cid:1370) (cid:22)(cid:139)(cid:137)(cid:144)(cid:4666)(cid:1871)(cid:1863)(cid:1829)(cid:481) (cid:11)(cid:884)(cid:4667)(cid:3)
;ƉƉůŝĐĂƚŝŽŶ(cid:3)ĂƚĂͿ(cid:3)

ǆ^(cid:3)(cid:1370) (cid:11)(cid:14)(cid:7)(cid:9)(cid:484) (cid:8)(cid:154)(cid:150)(cid:148)(cid:131)(cid:133)(cid:150)(cid:4666)(cid:882)(cid:481) (cid:8)(cid:22)(cid:4667)(cid:3)
ǆ^^(cid:3)(cid:1370) (cid:11)(cid:14)(cid:7)(cid:9)(cid:484) (cid:8)(cid:154)(cid:150)(cid:148)(cid:131)(cid:133)(cid:150)(cid:4666)(cid:882)(cid:481) (cid:22)(cid:22)(cid:4667)(cid:3)

(cid:150)(cid:141)(cid:1860)(cid:1871) (cid:1370) (cid:11)(cid:14)(cid:7)(cid:9)(cid:484) (cid:8)(cid:154)(cid:146)(cid:131)(cid:144)(cid:134)(cid:4666)(cid:154)(cid:8)(cid:22)(cid:481) (cid:142)(cid:131)(cid:132)(cid:135)(cid:142)(cid:883)(cid:481) (cid:11)(cid:883)(cid:4667)(cid:3)

(cid:149)(cid:150)(cid:131)(cid:137)(cid:135)(cid:3)(cid:883)(cid:3)

(cid:3) ΂ŶĐƌǇƉƚĞĚǆƚĞŶƐŝŽŶƐ΃

&^(cid:3) (cid:1370) (cid:11)(cid:14)(cid:7)(cid:9)(cid:484) (cid:8)(cid:154)(cid:146)(cid:131)(cid:144)(cid:134)(cid:4666)(cid:154)(cid:22)(cid:22)(cid:481) (cid:142)(cid:131)(cid:132)(cid:135)(cid:142)(cid:884)(cid:481) (cid:11)(cid:884)(cid:4667)(cid:3)

΂(cid:22)(cid:135)(cid:148)(cid:152)(cid:135)(cid:148)(cid:9)(cid:139)(cid:144)(cid:139)(cid:149)(cid:138)(cid:135)(cid:134)΃
^&(cid:3) (cid:1370) (cid:11)(cid:16)(cid:4)(cid:6)(cid:4666)(cid:9)(cid:22)(cid:481) (cid:142)(cid:131)(cid:132)(cid:135)(cid:142)(cid:885)(cid:481) (cid:11)(cid:884)(cid:4667)

ŚĞĐŬ(cid:3)^&с(cid:11)(cid:16)(cid:4)(cid:6)(cid:4666)(cid:9)(cid:22)(cid:481) (cid:142)(cid:131)(cid:132)(cid:135)(cid:142)(cid:885)(cid:481) (cid:11)(cid:884)(cid:4667)(cid:3)
&с(cid:11)(cid:16)(cid:4)(cid:6)(cid:4666)(cid:9)(cid:22)(cid:481) (cid:142)(cid:131)(cid:132)(cid:135)(cid:142)(cid:886)(cid:481) (cid:11)(cid:884)(cid:4667)(cid:3)

ŚĞĐŬ(cid:3)&с(cid:11)(cid:16)(cid:4)(cid:6)(cid:4666)(cid:9)(cid:22)(cid:481) (cid:142)(cid:131)(cid:132)(cid:135)(cid:142)(cid:886)(cid:481) (cid:11)(cid:884)(cid:4667)(cid:3)

(cid:143)(cid:8)(cid:22) (cid:1370) (cid:11)(cid:14)(cid:7)(cid:9)(cid:484) (cid:8)(cid:154)(cid:146)(cid:131)(cid:144)(cid:134)(cid:4666)(cid:154)(cid:8)(cid:22)(cid:481) (cid:142)(cid:131)(cid:132)(cid:135)(cid:142)(cid:887)(cid:481) (cid:11)(cid:884)(cid:4667)(cid:3)
ŵ^^(cid:3) (cid:1370) (cid:11)(cid:14)(cid:7)(cid:9)(cid:484) (cid:8)(cid:154)(cid:146)(cid:131)(cid:144)(cid:134)(cid:4666)(cid:154)(cid:22)(cid:22)(cid:481) (cid:142)(cid:131)(cid:132)(cid:135)(cid:142)(cid:888)(cid:481) (cid:11)(cid:884)(cid:4667)(cid:3)
D^(cid:3) (cid:1370) (cid:11)(cid:14)(cid:7)(cid:9)(cid:484) (cid:8)(cid:154)(cid:150)(cid:148)(cid:131)(cid:133)(cid:150)(cid:4666)(cid:143)(cid:22)(cid:22)(cid:481) (cid:143)(cid:8)(cid:22)(cid:4667)(cid:3)

(cid:150)(cid:141)(cid:1853)(cid:1868)(cid:1868) (cid:1370) (cid:11)(cid:14)(cid:7)(cid:9)(cid:484) (cid:8)(cid:154)(cid:146)(cid:131)(cid:144)(cid:134)(cid:4666)(cid:16)(cid:22)(cid:481) (cid:142)(cid:131)(cid:132)(cid:135)(cid:142)(cid:889)(cid:481) (cid:11)(cid:884)(cid:4667)(cid:3)
ZD^(cid:3) (cid:1370) (cid:11)(cid:14)(cid:7)(cid:9)(cid:484) (cid:8)(cid:154)(cid:146)(cid:131)(cid:144)(cid:134)(cid:4666)(cid:16)(cid:22)(cid:481) (cid:142)(cid:131)(cid:132)(cid:135)(cid:142)(cid:890)(cid:481) (cid:11)(cid:884)(cid:4667)
D^(cid:3) (cid:1370) (cid:11)(cid:14)(cid:7)(cid:9)(cid:484) (cid:8)(cid:154)(cid:146)(cid:131)(cid:144)(cid:134)(cid:4666)(cid:16)(cid:22)(cid:481) (cid:142)(cid:131)(cid:132)(cid:135)(cid:142)(cid:891)(cid:481) (cid:11)(cid:884)(cid:4667)(cid:3)

(cid:149)(cid:150)(cid:131)(cid:137)(cid:135)(cid:3)(cid:884)(cid:3)
(cid:149)(cid:150)(cid:131)(cid:137)(cid:135)(cid:3)(cid:885)(cid:3)

(cid:149)(cid:150)(cid:131)(cid:137)(cid:135)(cid:3)(cid:886)(cid:3)
΀EĞǁ^ĞƐƐŝŽŶdŝĐŬĞƚ΁

The PSK/resumption handshake protocol

Fig. 3.
in TLS 1.3 draft-10.
P SK comes from the resumption master secret RMS during the established
connection between the same two parties. (XXX) indicates a message XXX
encrypted using AEAD encryption with early data trafﬁc key Eadk, and other
messages can be deﬁned similarly to that in Figure 1.

and Rogaway [28]. The formalization of our notions is inspired
by the notation used by Dowling et al. [19].

A. Overview

Before diving into the technical details, let us ﬁrst describe
the hierarchical architecture for multiple handshakes protocols.
The hierarchical architecture consists of multiple levels, and
in each level, there can be multiple nodes, where each node
denotes one handshake session, and particularly the node in the
ﬁrst level (root level) only denotes session of full handshake
mode.

More speciﬁcally, we also assume in the same level, dif-
ferent sessions are running independently and concurrently,
however they can share the same PSK (the PSK/resumption
case), and sessions in some level can exist only based on the
session in its last level. We will describe this formally later.
A multiple handshakes protocol running is represented by
the nodes on the path from the root level to the leaf level. On
this path the session in some level is dependent on the session
in the last level, and more specially, one session may use the
key materials established or transmitted during its last session.
For example, as shown in Figure 4, in a three-level hier-
archy, the bold line indicates a “full handshake + 0-RTT +
PSK/resumption” multiple handshakes running. In this case
the ServerConﬁguration used in 0-RTT comes from the full

(cid:8)(cid:22) (cid:1370) (cid:28)(cid:1876) (cid:3)

ǆ^(cid:3)(cid:1370) (cid:11)(cid:14)(cid:7)(cid:9)(cid:484) (cid:8)(cid:154)(cid:150)(cid:148)(cid:131)(cid:133)(cid:150)(cid:4666)(cid:882)(cid:481) (cid:8)(cid:22)(cid:4667)(cid:3)

(cid:150)(cid:141)(cid:1860)(cid:1871) (cid:1370) (cid:11)(cid:14)(cid:7)(cid:9)(cid:484) (cid:8)(cid:154)(cid:146)(cid:131)(cid:144)(cid:134)(cid:4666)(cid:154)(cid:8)(cid:22)(cid:481) (cid:142)(cid:131)(cid:132)(cid:135)(cid:142)(cid:884)(cid:481) (cid:11)(cid:885)(cid:4667)(cid:3)

sĞƌŝĨǇ(cid:4666)(cid:1868)(cid:1863)(cid:1829)(cid:481) (cid:6)(cid:6)(cid:25)(cid:481) (cid:11)(cid:884)(cid:4667)
^ĞƌǀĞƌ,ĞůůŽ͗(cid:3) (cid:1870)(cid:1871) (cid:1370) (cid:836)(cid:4668)(cid:882)(cid:481)(cid:883)(cid:4669)(cid:1864)(cid:3)
нĂƌůǇĂƚĂ/ŶĚŝĐĂƚŝŽŶ
н<ĞǇ^ŚĂƌĞ͗(cid:3) (cid:28) (cid:1370) (cid:1859)(cid:1877) (cid:3)

(cid:8)(cid:22) (cid:1370) (cid:27)(cid:1877)

(cid:149)(cid:150)(cid:131)(cid:137)(cid:135) (cid:884)(cid:3)
(cid:3) ΂ŶĐƌǇƉƚĞĚǆƚĞŶƐŝŽŶƐ΃
΂(cid:22)(cid:135)(cid:148)(cid:152)(cid:135)(cid:148)(cid:6)(cid:145)(cid:144)(cid:136)(cid:139)(cid:137)(cid:151)(cid:148)(cid:131)(cid:150)(cid:139)(cid:145)(cid:144)(cid:1499)(cid:4669)(cid:3)
΂(cid:22)(cid:135)(cid:148)(cid:152)(cid:135)(cid:148)(cid:6)(cid:135)(cid:148)(cid:150)(cid:139)(cid:136)(cid:139)(cid:133)(cid:131)(cid:150)(cid:135)(cid:1499)΃(cid:3)
΂(cid:6)(cid:135)(cid:148)(cid:150)(cid:139)(cid:136)(cid:139)(cid:133)(cid:131)(cid:150)(cid:135)(cid:21)(cid:135)(cid:147)(cid:151)(cid:135)(cid:149)(cid:150)(cid:1499)΃
΂(cid:22)(cid:135)(cid:148)(cid:152)(cid:135)(cid:148)(cid:6)(cid:135)(cid:148)(cid:150)(cid:139)(cid:136)(cid:139)(cid:133)(cid:131)(cid:150)(cid:135)(cid:25)(cid:135)(cid:148)(cid:139)(cid:136)(cid:155)(cid:1499)΃
^s(cid:3)(cid:1370) (cid:22)(cid:139)(cid:137)(cid:144)(cid:4666)(cid:1871)(cid:1863)(cid:1845)(cid:481) (cid:11)(cid:886)(cid:4667)
΂(cid:22)(cid:135)(cid:148)(cid:152)(cid:135)(cid:148)(cid:9)(cid:139)(cid:144)(cid:139)(cid:149)(cid:138)(cid:135)(cid:134)΃
^&(cid:3) (cid:1370) (cid:11)(cid:16)(cid:4)(cid:6)(cid:4666)(cid:9)(cid:22)(cid:481) (cid:142)(cid:131)(cid:132)(cid:135)(cid:142)(cid:886)(cid:481) (cid:11)(cid:887)(cid:4667)

&^(cid:3) (cid:1370) (cid:11)(cid:14)(cid:7)(cid:9)(cid:484) (cid:8)(cid:154)(cid:146)(cid:131)(cid:144)(cid:134)(cid:4666)(cid:154)(cid:22)(cid:22)(cid:481) (cid:142)(cid:131)(cid:132)(cid:135)(cid:142)(cid:885)(cid:481) (cid:11)(cid:887)(cid:4667)(cid:3)

sĞƌŝĨǇ(cid:4666)(cid:1868)(cid:1863)(cid:1845)(cid:481) (cid:22)(cid:6)(cid:25)(cid:481) (cid:11)(cid:886)(cid:4667)(cid:3)
ŚĞĐŬ(cid:3)^&с(cid:11)(cid:16)(cid:4)(cid:6)(cid:4666)(cid:9)(cid:22)(cid:481) (cid:142)(cid:131)(cid:132)(cid:135)(cid:142)(cid:886)(cid:481) (cid:11)(cid:887)(cid:4667)(cid:3)
΂(cid:6)(cid:142)(cid:139)(cid:135)(cid:144)(cid:150)(cid:9)(cid:139)(cid:144)(cid:139)(cid:149)(cid:138)(cid:135)(cid:134)΃(cid:3)
&(cid:3) (cid:1370) (cid:11)(cid:16)(cid:4)(cid:6)(cid:4666)(cid:9)(cid:22)(cid:481) (cid:142)(cid:131)(cid:132)(cid:135)(cid:142)(cid:887)(cid:481) (cid:11)(cid:887)(cid:4667)(cid:3)
(cid:3)

ŚĞĐŬ(cid:3)&с(cid:11)(cid:16)(cid:4)(cid:6)(cid:4666)(cid:9)(cid:22)(cid:481) (cid:142)(cid:131)(cid:132)(cid:135)(cid:142)(cid:887)(cid:481) (cid:11)(cid:887)(cid:4667)(cid:3)

(cid:143)(cid:8)(cid:22) (cid:1370) (cid:11)(cid:14)(cid:7)(cid:9)(cid:484) (cid:8)(cid:154)(cid:146)(cid:131)(cid:144)(cid:134)(cid:4666)(cid:154)(cid:8)(cid:22)(cid:481) (cid:142)(cid:131)(cid:132)(cid:135)(cid:142)(cid:888)(cid:481) (cid:11)(cid:887)(cid:4667)(cid:3)
ŵ^^(cid:3) (cid:1370) (cid:11)(cid:14)(cid:7)(cid:9)(cid:484) (cid:8)(cid:154)(cid:146)(cid:131)(cid:144)(cid:134)(cid:4666)(cid:154)(cid:22)(cid:22)(cid:481) (cid:142)(cid:131)(cid:132)(cid:135)(cid:142)(cid:889)(cid:481) (cid:11)(cid:887)(cid:4667)(cid:3)

D^(cid:3) (cid:1370) (cid:11)(cid:14)(cid:7)(cid:9)(cid:484) (cid:8)(cid:154)(cid:150)(cid:148)(cid:131)(cid:133)(cid:150)(cid:4666)(cid:143)(cid:22)(cid:22)(cid:481) (cid:143)(cid:8)(cid:22)(cid:4667)(cid:3)

(cid:150)(cid:141)(cid:1853)(cid:1868)(cid:1868) (cid:1370) (cid:11)(cid:14)(cid:7)(cid:9)(cid:484) (cid:8)(cid:154)(cid:146)(cid:131)(cid:144)(cid:134)(cid:4666)(cid:16)(cid:22)(cid:481) (cid:142)(cid:131)(cid:132)(cid:135)(cid:142)(cid:890)(cid:481) (cid:11)(cid:887)(cid:4667)(cid:3)
ZD^(cid:3) (cid:1370) (cid:11)(cid:14)(cid:7)(cid:9)(cid:484) (cid:8)(cid:154)(cid:146)(cid:131)(cid:144)(cid:134)(cid:4666)(cid:16)(cid:22)(cid:481) (cid:142)(cid:131)(cid:132)(cid:135)(cid:142)(cid:891)(cid:481) (cid:11)(cid:887)(cid:4667)(cid:3)
D^(cid:3) (cid:1370) (cid:11)(cid:14)(cid:7)(cid:9)(cid:484) (cid:8)(cid:154)(cid:146)(cid:131)(cid:144)(cid:134)(cid:4666)(cid:16)(cid:22)(cid:481) (cid:142)(cid:131)(cid:132)(cid:135)(cid:142)(cid:883)(cid:882)(cid:481) (cid:11)(cid:887)(cid:4667)(cid:3)

(cid:149)(cid:150)(cid:131)(cid:137)(cid:135) (cid:885)(cid:3)
(cid:149)(cid:150)(cid:131)(cid:137)(cid:135) (cid:886)(cid:3)

(cid:149)(cid:150)(cid:131)(cid:137)(cid:135) (cid:887)(cid:3)

΀EĞǁ^ĞƐƐŝŽŶdŝĐŬĞƚ΁

Fig. 2. The 0-RTT handshake protocol in TLS 1.3 draft-10. S = gs comes
from the ServerConﬁguration message transmitted during the established
connection between the same two parties. (XXX) indicates a message XXX
encrypted using AEAD encryption with early data trafﬁc key Eadk, and other
messages can be deﬁned similarly to that in Figure 1.

similar

PSK/resumption-(EC)DHE handshake is

to P-
SK/resumption handshake, with the exception that the Clien-
tHello (resp. ServerHello) contains an extra (EC)DHE pa-
rameter ClientKeyShare (resp. ServerKeyShare) message
gx (resp. gy) to provide forward secrecy. Similar to P-
the client and the server set SS to PSK,
SK/resumption,
however set ES to gxy. Also note that PSK/resumption mode
cannot be used to provide a new ServerConﬁguration as
described in [7], thus this composition would be prohibited
in our model.

III. SECURITY MODEL FOR MULTIPLE HANDSHAKES

PROTOCOL

In this section, we model the security of multiple hand-
shakes protocol along the lines of the seminal paper of Bellare

490490

(cid:266)(cid:266)

(cid:266)(cid:266)

(cid:266)(cid:266) >ĞǀĞů(cid:3)ϭ

(cid:266)(cid:266) >ĞǀĞů(cid:3)Ϯ

(cid:266)(cid:266)

>ĞǀĞů(cid:3)ϯ

/ŶŝƚŝĂů(cid:3)ĨƵůů(cid:3)ŚĂŶĚƐŚĂŬĞ
W^<ͬƌĞƐƵŵƉƚŝŽŶ

ϬͬZdd

W^<ͬƌĞƐƵŵƉƚŝŽŶ(cid:882);Ϳ,

Fig. 4. TLS 1.3 multiple handshakes protocols

handshake, while the pre-shared key used in PSK/resumption
comes from the resumption master key in 0-RTT.

As in the basic setting, the adversary can interact with ses-
sions via oracle queries NewSession, Send, Reveal, Corrupt
and Test in order to initiate a new session, send messages to
that session, reveal the session key, corrupt the long-term or
semi-static secret key of a party, and test a session key against
a random key, respectively. We model the security according
to two games, one for session match security, and one for key
secrecy. The former gives straightforward security guarantees,
such as identical keys in partnered sessions, authenticity of the
partner, and collision-freeness of session identiﬁers. The key
secrecy property is a classic notion of random-looking keys,
providing secrecy guarantees of the session key.

Similarly, as in [19], we allow the communication partner of
a session to be unknown at the start of the protocol, in other
words we allow for “post-speciﬁed peers” as introduced by
Canetti and Krawczyk [33], which is captured in our model by
letting the adversary initialize a session with a wildcard ‘*’ as
the intended partner. We also allow Test queries for sessions
with unauthenticated partners if an honest partner exists. In
addition, we also adopt the notion of contributive identiﬁers
identifying sessions of honest parties which are currently not
partnered according to full session identiﬁers, but indicating
that the key is entirely based on an honest peer’s contribution
as in [19]. For example, one should be allowed to test such
a server even if the adversary does not deliver the server’s
ﬁnal message to the honest client session during TLS 1.3 full
handshake. This key should already be considered secure since
the client at this point has already completed his contribution
to the session key on the server side. In contrast to session
identiﬁers, a contributive identiﬁer can be updated several
times instead of being set only once, e.g., to eventually match
the session identiﬁer.

One difference in our model, owed to the fact

that an
execution includes multiple sessions of different handshake

491491

is revealed,

modes, is more complex and more comprehensive replies to
oracle queries. In particular, for the NewSession query, the
association between new session and last session should be
considered; for the Reveal query, given that a session key
of some stage in some level
the security of
future session keys of later stages and later levels should be
concerned; for the Corrupt query, given that a pre-shared
resumption master key is corrupted, resumption handshakes
that use the same resumption master keys should also be
considered corrupted; for the Test query, since a session key
may be used to derive the subsequent one in the next level,
the session considered fresh should be carefully devised in the
sense that they are not trivially available to the adversary.

Another difference, motivated by 0-RTT mode in TLS 1.3,
is the introduction of so-called semi-static keys. These keys
are somewhat in between ephemeral keys and static keys. TLS
1.3 draft suggests the server provides a ServerConﬁguration
message containing the semi-static key gs associated with an
unique Conﬁguration id, so that on future connections to
the same server, the client can use that share to send early
application data in a 0-RTT mode. This draft also speaks of
a life span of not more than 7 days in which the same key is
used in each session of this server. Thus, this semi-static key,
analogous to static key, is not bound to a single session, and
our model allows the adversary to learn gs, as well as the secret
s only after the handshake is ﬁnished. However, our model
does not allow the adversary to learn session state information,
as we do not aim to capture such ﬂaw in implementation. Also
note that here gs and s can be handled just like the traditional
long-term key pair with certiﬁcate in Bellare-Rogaway model
for simplicity.

A major difference in our model lies in the dependencies
of the different levels. In particular, while TLS 1.3 draft-10
achieves stage key independence in the multi-stage setting
(recall that stage key independence is the property that one can
reveal a session key without endangering the later-stage keys.),
we make the distinction between level key dependence and
stage key independence, where level key dependence means
that the session key in some stage of level i is used to derive
the session key of level i + 1. “full handshake (stage j = 4,
level i) + PSK/resumption(level i + 1)” in TLS 1.3 draft is an
example of level key dependence, as the pre-shared resumption
key in level i + 1 are derived from the resumption master
key(RMS) of stage 4 in level i. Key dependence property
directly affects the adversary’s capabilities in the sense that
we should deﬁne the advantage cautiously when the adversary
reveals the session key of level (stage) i before the key of level
(stage) i + 1 is established. We will discuss this formally later.
Finally, in order to cover various authenticity properties
of the TLS 1.3 multiple handshakes, our model captures
unauthenticated, unilaterally authenticated, or mutually au-
thenticated runs. We also allow executions of different au-
thentication types to run concurrently, even within a single
party. In order to give comprehensive security guarantees for
multiple handshakes, we deﬁne match security by additional-
ly introducing collision-freeness of session identiﬁers across

different handshake modes and across different levels, and we
deﬁne key secrecy by distinguishing different levels of forward
secrecy, authentication types and level (stage) key dependence.
B. Preliminaries
We denote by U the set of identities used to model the
participants in the system, each identiﬁed by some U ∈ U
and associated with a long-term public key pkU and corre-
sponding secret key skU . In addition, each party may also
hold temporary key pairs, identiﬁed by a key identiﬁer kid.
Sessions of a protocol are uniquely identiﬁed using a label
label ∈LABELS = N × N × U × U × N × N × N, where (
lid, prelid, U, V , lev, mode, t) indicates the t− th session in
level lev of identity U (the session owner) running in mode
mode with V as the intended communication partner, with
label identiﬁer lid and its last session label identiﬁer prelid.
More speciﬁcally:

. label(cid:2).prelid = label.lid if and only if some key materials
used in label(cid:2) are derived from label,
. If label(cid:2).prelid = label.lid, then label(cid:2).lev = label.lev + 1;
. If there exists two labels label, label(cid:2) such that label(cid:2).prelid
= label.prelid, then label(cid:2).lev = label.lev.
For example,

in the “full handshake + 0-RTT + P-
SK/resumption” multiple handshakes running in Figure 4,
we can use label and label(cid:2)
to identify the 0-RTT and
thus label(cid:2).prelid = label.lid
PSK/resumption respectively,
since the pre-shared resumption key in label(cid:2) is derived from
label and label(cid:2).lev = label.lev + 1.

For each session, a tuple with the following information is
maintained as an entry in the session list ListS, where values
in square brackets indicate the default/initial value.

. label ∈ LABELS: the (administrative) session label
. U ∈ U: the session owner
. V ∈ (U ∪ {∗}): the intended communication partner, where
‘*’ stands for “unknown identity” and can be set to a speciﬁc
identity in U once by the protocol
. role ∈ {initiator, responder}: the session owner’s role in
this session
. mode ∈ {full handshake, 0-RTT, PSK/resumption,
PSK/resumption-(EC)DHE}: the handshake mode in this
session and can be denoted by M1, M2, M3 and M4
respectively in brief.
. lev: the level where the session label is running.
. kidU : the key identiﬁer of the temporary public/secret key
. kidV : the key identiﬁer of the temporary public/secret key
. psidU,V,k: the unique pre-shared key identiﬁer of the k-th
. stexe ∈ (RUNNING ∪ ACCEPTED ∪ REJECTED):
the state of execution [running], where RUNNING=
{runningi|i ∈ N0}, ACCEPTED={acceptedi|i ∈ N},
REJECTED={rejectedi|i ∈ N}
. stage ∈ {0, ...,M}: the current stage[0], where M is the
maximum stage and stage is incremented to i when stexe
reaches acceptedi resp. rejectedi

pair (tpk,tsk) used by the communication partner

pre-shared key psk between parties U and V

pair (tpk,tsk) used by the session owner

identiﬁer in stage i > 0

pired authentication type of each stage from the set of
supported properties AUTH, where M is the maximum stage
and authi indicates the authentication level in stage i > 0
indicates the session

. sid ∈ ({0, 1}∗ ∪ {⊥})M: sidi[⊥]
. cid ∈ ({0, 1}∗ ∪ {⊥})M: cidi[⊥] indicates the contributive
. K ∈ ({0, 1}∗ ∪ {⊥})M: Ki[⊥] indicates the established
. stkey ∈ {fresh, revealed}M: stkey,i[fresh] indicates the state
. tested ∈ {true, false}M: test indicator testedi[false], where

of the session key in stage i > 0

session key in stage i > 0

identiﬁer in stage i > 0

. auth ∈ AUTH ⊆ {unauth, unilateral, mutual}M: the as-

true means that Ki has been tested
By convention, if we add a partly speciﬁed tuple (label, U,
V , role, mode, lev, kidU , kidV , psidU,V,k, auth) to ListS, then
the other tuple entries are set to their default value. As labels
are unique, we write as a shorthand, e.g., label.sid for the
element sid in the tuple with label in ListS, and analogously
for other entries.

C. Adversary Model
We consider a probabilistic polynomial-time (PPT) adver-
sary A which controls the communication between all parties,
enabling interception, injection, and dropping of messages. As
in [22] and [19] we distinguish different levels of the following
three (orthogonal) security aspects of a multiple handshakes
protocol: forward secrecy, authentication, and key dependence.
Forward Secrecy. In our model, stage-j forward secrecy
indicates that the session keys Ki established at some stage
i ≥ j remain secure when the involved long-term secrets get
exposed, whereas keys at stages i < j become insecure.
Authentication. As above, we capture the authenticity
properties by a vector (auth1,··· , authM ) ∈ AUTH ⊆
{unauth, unilateral, mutual}M specifying for each stage i in
a session whether it is unauthenticated (authi = unauth),
unilaterally authenticated (authi = unilateral), or mutually
authenticated (authi = mutual). Moreover, we treat all au-
thenticity variants of a protocol concurrently in our model: we
allow concurrent executions of the different key exchange sub
protocols, simultaneously covering all potential unauthenticat-
ed, unilaterally, or mutually authenticated runs. Given that the
authenticity of keys is a strictly non-decreasing property with
progressing stage, we also use the following simpler notation:

. no authentication: the keys of all stages are unauthenti−
. stage-k unilateral authentication: the keys of stage i are
unauthenticated for i < k and unilaterally unauthenticated
for i ≥ k
. stage-l mutual authentication: the keys of stage i are
unauthenticated for i < l and mutually authenticated for
i ≥ l
. stage-k unilateral stage-l mutual authentication: the keys
of stage i are unauthenticated for i < k, unilaterally
authenticated for k ≤ i ≤ l, and mutually authenticated
for i ≥ l.

cated.

492492

Key Dependence. In our model, stage key dependence
means that the session key Ki+1 of the stage i + 1 depends
on the session key Ki of the previous stage i in a way that
disclose of Ki compromises Ki+1.
Similarly, we say the session label(cid:2) has level key depen-
dence on label in stage j when label.lev= i, label(cid:2).lev = i+1,
label(cid:2).prelid = label.lid, such that the disclose of label.Kj
compromises label(cid:2).K1. And the case for key in later stage
may depend on whether the label(cid:2) is stage-key-independent.
Like in [19], we also add a ﬂag lost to the experiment to
capture admissible adversarial interaction which is initialized
to false. This ﬂag will later specify in the deﬁnition of Test
query if the adversary loses due to trivial attacks, such as
revealing the session key of a partner session to a tested
session. And we set the ﬂag during the execution and oracle
calls in some cases but also check a-posteriori for other
conditions.

The adversary interacts with the protocol via the following

queries:

. NewSession (U, V , role, auth, kidU , kidV , k, mode,

label): Creates a new session for participant identity U
with role role and key identiﬁer kidU having V with key
identiﬁer kidV as intended partner, with the pre-shared
psidU,V,k and its last level session label label
, aiming
at authentication type auth and handshake mode mode.
Generate a new session label label(cid:2) such that label(cid:2).lev =
label.lev + 1 and label(cid:2).prelid = label.lid, and add the entry
(label(cid:2), U, V , role, mode, lev, kidU , kidV , psidU,V,k, auth)
to ListS.
Note that some of the domains may be empty, for example,
label would be empty if ﬁrst level, and kidU , kidV would
be empty if PSK/resumption mode.

. Send (label, m): Sends a message m to the session with
label label. If there is no tuple (label, U, V , role, mode,
lev, kidU , kidV , psidU,V,k, stexe, stage, auth, sid, cid, K,
stkey, tested) in ListS, return ⊥. Otherwise, run the protocol
on behalf of U on message m and return the response and
the updated state of execution stexe. As a special case, if role
= initiator and m = init, the protocol is initiated (without
any input message). If, during the protocol execution, the
state of execution changes to acceptedi for some stage
i,
the protocol execution is immediately suspended and
acceptedi is returned to the adversary.
If the state of the execution changes to acceptedi for
some stage i and there is a tuple (label(cid:2), V , U, role(cid:2), mode,
exe, stage(cid:2), auth(cid:2), sid(cid:2), cid(cid:2),
lev, kidV , kidU , psd(cid:2)
K(cid:2), st(cid:2)
key,i =
revealed, then stkey,i is set to revealed, whereas for stage
(cid:2) ≥ i are set to revealed.
key dependence, all stkey,i(cid:2) for i
The former corresponds to the case that session keys of
partnered sessions should be considered revealed as well,
the latter implements that for stage key dependence all
subsequent keys are potentially available to the adversary,
too. Similarly, in the case of level key dependence, if label(cid:2)(cid:2)
has key dependence on label or label(cid:2) in stage i, then

key, tested(cid:2)) in ListS with sidi = sid(cid:2)

V,U,k, st(cid:2)

i and st(cid:2)

i and tested(cid:2)

set label(cid:2)(cid:2).stkey,1 = revealed. Also, for the partner session
label(cid:2)(cid:2)(cid:2) of session label(cid:2)(cid:2) , set label(cid:2)(cid:2)(cid:2).stkey,1 = revealed.
If the state of execution changes to acceptedi for some
stage i and there is a tuple (label(cid:2), V , U, role(cid:2), mode, lev,
V,U,k, st(cid:2)
kidV , kidU , psid(cid:2)
exe, stage(cid:2), auth(cid:2), sid(cid:2), cid(cid:2), K(cid:2),
st(cid:2)
key, tested(cid:2)) in ListS with sidi = sid(cid:2)
i = true,
then set label.Ki = label(cid:2).K(cid:2)
i and label.testedi = true. This
ensures that, if the partnered session has been tested before,
this session’s key Ki is set consistently and subsequently
Test queries for the session here are answered accordingly.
for
some stage i and the intended communication partner V
is corrupted, then st(cid:2)
. NewTempKey (U): Creates a new temporary key pair
. NewPreshareKey (U, V ): Creates a new pre-shared key

If the state of execution changes to acceptedi

(tpk,tsk), and returns an identiﬁer kid for it.

key,i = revealed.

psk, and returns an identiﬁer psidU,V,k for it, where k is
the key index. This query is mainly for PSK/resumption
mode and PSK/resumption-(EC)DHE mode.

. Reveal (label, i): Reveals label.Ki, the session key of stage

i in the session with label label.

If there is no tuple (label, U, V , role, mode, lev,
kidU , kidV , psidU,V,k, stexe, stage, auth, sid, cid, K, stkey,
tested) in ListS, or i > stage, or testedi = true, then
return ⊥. Otherwise, set stkey,i to revealed and provide the
adversary with Ki.
If there is a tuple (label(cid:2), V , U, role(cid:2), mode, lev, kidV ,
kidU , psd(cid:2)
V,U,k, st(cid:2)
key,
i and stage(cid:2) ≥ i, then
tested(cid:2)) in ListS with sidi = sid(cid:2)
st(cid:2)
key,i is set to revealed as well. This means the i-th session
keys of all partnered sessions (if already established) are
considered revealed too.

exe, stage(cid:2), auth(cid:2), sid(cid:2), cid(cid:2), K(cid:2), st(cid:2)

As above, in the case of stage key dependency, since
subsequent keys in the same session label depend on the
revealed key, we cannot ensure their security anymore (nei-
ther in this session in question, nor in partnered sessions).
Therefore, if label.stkey,i = revealed, set label.stkey,j =
revealed for all j > i, as they depend on the revealed
key. For the same reason, if a partnered session label(cid:2) with
label.sidi = label(cid:2).sidi, then set label(cid:2).stkey,j = revealed
for all j > i. Note that if however label(cid:2).stage > i, then
keys label(cid:2).Kj for j > i derived in the partnered session are
not considered to be revealed by this query since they have
been accepted previously, i.e., prior to Ki being revealed in
this query.
Similarly, in the case of level key dependency, if label(cid:2)
has key dependence on label in stage i and label.stkey,i =
revealed, then set label(cid:2).stkey,1 = revealed. Also, for the
partner session label(cid:2)(cid:2) of session label(cid:2), set label(cid:2)(cid:2).stkey,1 =
revealed.
. Corrupt (U, V , k): Provides (semi) long-term secret key or

pre-shared key to the adversary.

In the case of full handshake mode, V and k will be empty,
and the secret key skU will be provided to the adversary.
No further queries are allowed to sessions owned by U.

In the case of 0-RTT mode, V will be empty, and the

493493

leakage of semi-static key s after the handshake is allowed,
so skU and the k-th semi-static key s will be provided to
the adversary. No further queries are allowed to sessions
owned by U.

In the case of PSK/resumption and PSK/resumption-
(EC)DHE modes, the k-th pre-shared key by U and V will
be provided to the adversary. No further queries are allowed
to resumed sessions owned by U and V .

In the case of not providing forward secrecy, for each
session label owned by U and each stage i, set label.stkey,i
to revealed. In this case, all previous and future session
keys are considered to be disclosed. Speciﬁcally, if the
pre-shared resumption master key is corrupted in some
PSK/resumption session label owned by U and V , then
for each PSK/resumption session label(cid:2) owned by U and
V such that label(cid:2).prelid = label.prelid which means they
share the same resumption master key, and for each stage
i, set label(cid:2).stkey,i = label.stkey,i = revealed.

In the case of stage-j forward secrecy, label.stkey,i is set
to revealed only if i < j or if i >stage. This means that
session keys before the j-th stage as well as keys that have
not yet been established are potentially disclosed.

. Test (label,i): Tests the session key of stage i in the session

with label label. In the security game this oracle is given
a uniformly random test bit btest as state which is ﬁxed
throughout the game.

exe

U,V,k, st(cid:2)

i, but st(cid:2)

exe, stage(cid:2), auth(cid:2), sid(cid:2), cid(cid:2), K(cid:2), st(cid:2)

If there is no tuple (label, U, V , role, mode, lev,
kidU , kidV , psidU,V,k, stexe, stage, auth, sid, cid, K, stkey,
tested) in ListS or if label.stexe (cid:9)= acceptedi, return ⊥. If
there is a tuple (label(cid:2), V , U, role(cid:2), mode, lev, kidV , kidU ,
psid(cid:2)
key, tested(cid:2))
(cid:9)= acceptedi, set the
in ListS with sidi = sid(cid:2)
ﬂag lost = true. This ensures that keys can only be tested
if they have just been accepted but not used yet, including
ensuring that keys can only be tested if they have already
established this key but not used yet.
If label.authi = unauth or if label.authi = unilateral and
label.role = responder, but there is no tuple (label(cid:2), V ,
U, role(cid:2), mode, lev, kidV , kidU , psid(cid:2)
exe, stage(cid:2),
key, tested(cid:2)) (for label (cid:9)= label(cid:2)) in
auth(cid:2), sid(cid:2), cid(cid:2), K(cid:2), st(cid:2)
ListS with cidi = cid(cid:2)
i, then set lost = true. This ensures
that having an honest contributive partner is a prerequisite
for testing responder sessions in an unauthenticated or
unilaterally authenticated stage and for testing an initiator
session in an authenticated stage.

V,U,k, st(cid:2)

to true. If the test bit btest

If label.testedi = true, return Ki, ensuring that repeat-
ed queries will be answered consistently. Otherwise, set
label.testedi
is 0, sample
$←− D at random from the session key distribution
label.Ki
D. This means that we substitute the session key by a
random and independent key which is also used for future
deployments within the key exchange protocol. Moreover, if
there is a tuple (label(cid:2), V , U, role(cid:2), mode, lev, kidV , kidU ,
psid(cid:2)
key, tested(cid:2))
i, also set label(cid:2). Ki ← label. Ki and
in ListS with sidi = sid(cid:2)

exe, stage(cid:2), auth(cid:2), sid(cid:2), cid(cid:2), K(cid:2), st(cid:2)

V,U,k, st(cid:2)

label(cid:2). tested(cid:2)
i = true to ensure consistency in the special
case that both label and label(cid:2) are in stage acceptedi and,
hence, either of them can be tested ﬁrst. Return label.Ki.
Remark 1: Note that in TLS 1.3 tkapp is used to encrypt
the NewSessionTicket, which may violate the key indis-
tinguishability property as in TLS 1.2. However, our model
allows the adversary to test the accepted key only before it
has been used as described above, and thus tkapp used later
can be consistent with the key tested before, which can capture
that problem.

D. Security Deﬁnition

The security properties for multiple handshakes protocols
are split in two games, following Fischlin et al. [22] and
Brzuska et al. [29][34], match security and key secrecy.

Match Security ensures that

the session identiﬁers sid

effectively match the partnered sessions in the sense that

Same mode and same level

1. sessions with the same session identiﬁer for some stage

hold the same session key at that stage,

2. sessions with the different session identiﬁers for some stage

hold the different session keys at that stage,

3. sessions with the same session identiﬁer for some stage

agree on the authentication mode of the stage,

4. sessions with the same session identiﬁer for some stage

share the same contributive identiﬁer at that stage,

5. sessions are partnered with the intended (authenticated)
participant and share the same key index for mutual au-
thentication,

6. session identiﬁers do not match across different stages,
7. at most two sessions have the same session identiﬁer at any

stage,
Across modes

8. session identiﬁers do not match across different protocol

modes, and
Across levels

(semi-static)

9. session identiﬁers do not match across different levels.
Deﬁnition 1 (Match Security). Let MH be a multiple hand-
shakes protocol and A a PPT adversary interacting with MH
via the queries deﬁned in III − C within the following game
MH,A:
GMatch
Setup. The challenger generates
long-term
public/private-key pairs for each participant U ∈ U.
Query. The adversary A receives the generated public
keys and has access to the queries NewSession, Send,
NewTempKey, NewPreshareKey, Reveal, and Corrupt.
Stop. At some point, the adversary stops with no output.

We say that A wins the match security game, denoted by
GMatch
MH,A = 1, if at least one of the following conditions hold:
1 There exists two distinct labels label, label(cid:2) such that la-
bel.lev = label(cid:2).lev, label.mode = label(cid:2).mode, label.sidi
= label(cid:2).sidi (cid:9)= ⊥ for some stage i, label.stexe (cid:9)= rejectedi,
(cid:9)= label(cid:2).Ki.
and label(cid:2).stexe (cid:9)= rejectedi, but
(Different session keys in some stage of partnered sessions.)

label.Ki

494494

label,

label(cid:2)

labels label,

2 There

exists

4 There exists two distinct

(cid:9)= ⊥ for some stage i,

two distinct
label.lev = label(cid:2).lev,

labels
such
label.mode = label(cid:2).mode,
that
label.sidi (cid:9)= ⊥, label(cid:2).sidi (cid:9)= ⊥,
label.sidi (cid:9)= label(cid:2).sidi
for some stage i, label.stexe (cid:9)= rejectedi, and label(cid:2).stexe
(cid:9)= rejectedi, but label.Ki = label(cid:2).Ki. (Same session keys
in some stage of non-partnered sessions.)
label(cid:2) such that
labels label,
3 There exists two distinct
label.lev = label(cid:2).lev, label.mode = label(cid:2).mode,
and
(cid:9)= ⊥ for some stage i, but
label.sidi = label(cid:2).sidi
label.authi (cid:9)= label(cid:2).authi. (Different authentication types
in some stage of partnered sessions.)
label(cid:2) such that
label.lev = label(cid:2).lev, label.mode = label(cid:2).mode,
and
label.sidi = label(cid:2).sidi (cid:9)= ⊥ for some stage i, but label.cidi
(cid:9)= label(cid:2).cidi or label.cidi = label(cid:2).cidi = ⊥. (Different
or unset contributive identiﬁers in some stage of partnered
sessions.)
5 There exists two distinct labels label, label(cid:2) such that la-
bel.lev = label(cid:2).lev, label.mode = label(cid:2).mode, label.sidi
= label(cid:2).sidi
label.authi =
label(cid:2).authi ∈ {unilateral,mutual}, label.role = initiator,
and label(cid:2).role = responder, but label.V (cid:9)= label(cid:2)
.U, or
label.U (cid:9)= label(cid:2)
.V (only when label.authi = mutual), or
label.psidU,V,k (cid:9)= label(cid:2).psidV,U,k (only when label.authi
= mutual). (Different
intended authenticated partner or
different key indexes in some stage of partnered sessions.)
label(cid:2) such that
label.mode = label(cid:2).mode, and
label.lev = label(cid:2).lev,
label.sidi = label(cid:2).sidj (cid:9)= ⊥ for some stage i and j with i
(cid:9)= j. (Different stages share the same session identiﬁer.)
7 There exists three distinct labels label, label(cid:2), label(cid:2)(cid:2) such
label.mode =
that
label(cid:2).mode = label(cid:2)(cid:2).mode, and label.sidi = label(cid:2).sidi =
label(cid:2)(cid:2).sidi (cid:9)= ⊥ for some stage i. (More than two sessions
share the same session identiﬁer.)
8 There exists two labels label, label(cid:2) such that label.mode
(cid:9)= label(cid:2).mode and label.sidi = label(cid:2).sidj (cid:9)= ⊥ for some
stage i and j. (Different protocol modes share the same
session identiﬁer.)
label(cid:2) such that label.lev
(cid:9)= label(cid:2).lev, label.mode = label(cid:2).mode, and label.sidi =
label(cid:2).sidj (cid:9)= ⊥ for some stage i and j. (Different protocol
levels share the same session identiﬁer.)1
We say MH is Match-secure, if for all PPT adversaries A the
MH,A = 1] is negligible
advantage function AdvMatch
in the security parameter.

label.lev = label(cid:2).lev = label(cid:2)(cid:2).lev,

9 There exists two labels label,

6 There exists two distinct

MH,A = Pr [GMatch

labels label,

Next, we deﬁne the key secrecy for multiple handshakes

protocols.

Deﬁnition 2 (Key Secrecy). Let MH be a multiple hand-
shakes protocol with key distribution D and authenticity prop-
erties AUTH, and a PPT adversary A interacting with MH
1Note that, during the description of the last goal, the case that label.lev (cid:3)=
label(cid:3).lev, label.mode (cid:3)= label(cid:3).mode has been contained in the eighth case
and thus can be omitted.

:

(semi-static)

via the queries deﬁned in III − C within the following game
Key−Secrecy,D
MH,A
G
Setup. The challenger generates
long-term
public/private-key pairs for each participant U ∈ U, chooses
$←− {0, 1} at random, and sets lost ← false.
the test bit btest
Query. The adversary A receives the generated public
keys and has access to the queries NewSession, Send,
NewTempKey, NewPreshareKey, Reveal, Corrupt, and
Test.
Guess. At some point, A stops and outputs a guess b.
Finalize. The challenger sets the ‘lost’ ﬂag to lost ← true
if there exist two labels label, label(cid:2) such that label.sidi
= label(cid:2).sidi, label.stkey,i = revealed, and label(cid:2).testedi =
true. (Adversary has tested and revealed the key in a single
session or in two partnered sessions.). 2
We say that A wins the game, denoted by GKey−Secrecy,D
= 1,
if b = btest and lost = false. Then a multiple handshakes
protocol MH is secure against key secrecy, if for all PPT
adversaries A the advantage function AdvKey−Secrecy,D
=
Pr [GKey−Secrecy,D
2 is negligible in the security
MH,A
parameter.

= 1] − 1

MH,A

MH,A

Deﬁnition 3 (Multi-Level&Stage Security). We say a
multiple handshakes protocol MH is Multi-Level&Stage-
secure in a level (stage)-key-dependent resp. level (stage)-key-
independent and non-forward-secret resp. stage-j-forward-
secret manner with concurrent authentication types AUTH if
MH satisﬁes both Match Security and Key Secrecy.
(cid:2)
Remark 2. Note that when limited to a single level and mode,
our execution environment
security experiment is equivalent
to the original security model and deﬁnition of Dowling et al.
[19].

IV. SECURITY OF THE DRAFT-10 MULTIPLE HANDSHAKES
In this section, we analyze the security of multiple
handshakes speciﬁed in TLS 1.3 draft-10 under the Multi-
Level&Stage security model. Also, we analyze the reason
why our proof cannot make use of existing security results in
a black-box compositional way [22][19].

A. Multi-Level&Stage Security of TLS 1.3 draft-10

Firstly, we deﬁne the session identiﬁers and contributive i-
dentiﬁers for the stages in different running modes as speciﬁed
in TLS 1.3 draft-10 to be the unencrypted messages sent and
received excluding the Finished messages:

Mode1 (full handshake):

sid1 = (ClientHello‘+’KeyShare, ServerHello‘+’KeyShare);
sid2 = (sid1, EncryptedExtensions,

ServerConﬁguration∗, ServerCertiﬁcate∗,
CertiﬁcateRequest∗, ServerCertiﬁcateVerify∗,
ClientCertiﬁcate∗, ClientCertiﬁcateVerify∗ );

2In the security game, the winning conditions are independent of key
dependency, forward secrecy, and authentication properties of MH, as those
are directly integrated in the affected (Reveal and Corrupt) queries and the
ﬁnalization step of the game. For example, Corrupt is deﬁned differently for
non-forward-secrecy versus stage-j forward secrecy.

495495

sid3 = (sid2, “RMS”);
sid4 = (sid2, “EMS”).

Concerning the contributive identiﬁers, we let the client
(resp. server) on sending (resp. receiving) the ClientHel-
lo‘+’KeyShare messages set
cid1 = (ClientHello‘+’KeyShare), and subsequently, on re-
ceiving(resp. sending) the ServerHello‘+’KeyShare mes-
sages, extend it to
cid1 = (ClientHello‘+’KeyShare, ServerHello‘+’KeyShare),
the other contributive identiﬁers are set to cid2 = sid2, cid3 =
sid3 and cid4 = sid4 by each party on sending its respective
Finished message.
Mode2 (0-RTT):
sid1 = (ServerConﬁguration−1,ServerCertiﬁcate−1,

sid2 = (sid1, EncryptedExtensions, ClientCertiﬁcate∗,

ClientHello‘+’KeyShare
‘+’EarlyDataIndication);
ClientCertiﬁcateVerify∗,
ServerHello‘+’KeyShare‘+’EarlyDataIndication);
ServerConﬁguration∗, ServerCertiﬁcate∗,
CertiﬁcateRequest∗, ServerCertiﬁcateVerify∗);

sid3 = (sid2, EncryptedExtensions,

sid4 = (sid3, “RMS”);
sid5 = (sid3, “EMS”).

Concerning the contributive identiﬁers, we just

list

the

speciﬁc cid and its updating:
cid1 = sid1;
cid2 = (sid1, EncryptedExtensions, ClientCertiﬁcate∗,

cid4 = sid4; cid5 = sid5.

ClientCertiﬁcateVerify∗); cid2 = sid2; cid3 = sid3;
Note that ServerConﬁguration−1, ServerCertiﬁcate−1
denotes the corresponding message derived from the last
session.

Mode3 (PSK/resumption)

sid1 = (ClientHello‘+’PreSharedKeyExtension,

ServerHello‘+’PreSharedKeyExtension,
“Stage1”);

sid2 = (ClientHello‘+’PreSharedKeyExtension,

ServerHello‘+’PreSharedKeyExtension,
“Stage2”);

sid3 = (sid2, “RMS”);
sid4 = (sid2, “EMS”).

Concerning the contributive identiﬁers, we just

list

the

speciﬁc cid and its updating:
cid1 = (ClientHello‘+’PreSharedKeyExtension);
cid1 = sid1; cid2 = sid2; cid3 = sid3; cid4 = sid4.

Mode4 (PSK/resumption-(EC)DHE):

sid1 = (ClientHello‘+’KeyShare‘+’PreSharedKeyExtension,
ServerHello‘+’KeyShare‘+’PreSharedKeyExtension,

“Stage1”);

sid2 = (ClientHello‘+’KeyShare‘+’PreSharedKeyExtension,
ServerHello‘+’KeyShare‘+’PreSharedKeyExtension,

“Stage2”);

sid3 = (sid2, “RMS”);
sid4 = (sid2, “EMS”).

Concerning the contributive identiﬁers, we just

list

the

speciﬁc cid and its updating:
cid1 = (ClientHello‘+’KeyShare‘+’PreSharedKeyExtension);
cid1 = sid1; cid2 = sid2; cid3 = sid3; cid4 = sid4.
Theorem 1 (Multi-Level&Stage Security of TLS 1.3 draft-
10). Assume that pseudo-random function PRF is secure,
the signature scheme is secure against existential forgeries
under adaptive chosen-message attacks, the hash function is
collision resistant, the DDH problem and Gap-DH problem
are hard in the group G, then the TLS 1.3 draft-10 multiple
handshakes protocol is Multi-Level&Stage-secure.

Proof. Without loss of generality, we assume that the multiple
handshakes protocol Π consists of n successive sessions. We
prove this by induction on the number n. The sketch of the
proof is described by the following steps:
Step 1. First, we prove the theorem holds for the base case
of n = 1, i.e. Π just consists of a session label such
that label.mode = M1 and label.lev = 1, which has
been proved in [19]. (Lemma 1)
Step 2. Next, we prove that if a multiple handshakes protocol
Π consisting of n − 1 successive sessions is Multi-
(cid:2) combin-
Level&Stage-secure, then the protocol Π
ing Π with a session label(cid:2) is Match-secure, where
label(cid:2).mode = M2, M3 or M4. (Lemma 2)
Step 3. Finally, we prove that if a multiple handshakes pro-
tocol Π consisting of n − 1 successive sessions
(cid:2)
is Multi-Level&Stage-secure, then the protocol Π
combining Π with a session label(cid:2) is secure against
Key Secrecy, where label(cid:2).mode = M2, M3 or M4.
(Lemma 3, Lemma 4 and Lemma 5)

[19]

Lemma 1 (
).3 The TLS 1.3 draft-10 full hand-
shake is Multi-Level&Stage-secure in a key-independent
and stage-1-forward-secret manner with concurrent authen-
tication properties AUTH = (unauth,unauth,unauth), (u-
nauth,unilateral,unilateral), (unauth,mutual,mutual). For-
mally, for any efﬁcient adversary A, the Multi-Level&Stage-
security can be broken with advantage AdvMulti−Level&Stage,D
such that
H + 2nu.AdvEUF−CMA

AdvMulti−Level&Stage,D

≤ 4ns.

draft−10,A

draft−10,A

(cid:3)

3AdvColl
+ ns.(AdvDDH

Sig

+ 2AdvPRF−sec
(cid:4)
,
HKDF.Expand)

+ 2AdvPRF−sec

G

HKDF.Extract

Where ns is the maximum number of sessions and nu is

the maximum number of users.

Lemma 2. If a multiple handshakes protocol Π is Multi-
(cid:2) combining Π
Level&Stage-secure,
then the protocol Π
with a session label(cid:2)
is Match-secure, where the session
label(cid:2) can support all possible primary handshake modes of

3[19] proved that the draft-05 full handshake is Multi-Stage-secure, which
can imply the Match security according the model deﬁnition, and we can
conclude this property for the full handshake in draft-10 since they own the
similar structures, with some minor changes such as key derivation function
from PRF to HKDF, and the keys during computation will be replaced as in
Figure 1.

496496

TLS 1.3 draft-10.

Proof. We need to show the nine properties of Match Security,
and for the ﬁrst seven ones (the case of same mode and same
level), we only need to show that the session label(cid:2) satisﬁes
the properties since Π is already Multi-Level&Stage-secure.

1. Sessions with the same session identiﬁer for some stage

hold the same session key.
Note that for stage i, if two parties share the identical
session identiﬁer namely sidi for some mode, and note
that the sidi contains the full sidj for all j < i, implying
that the parties share the identical session identiﬁers sidj,
then they both use the same input to the key derivation
functions such as HKDF.Extract and HKDF.Expand, and
hence derive the same session keys in the i-th stage.

2. sessions with the different session identiﬁers for some stage

hold the different session keys.
Note that
in TLS 1.3 draft-10, all protocols include a
hash of all messages exchanged so far in the derivation
of all session keys, thus we can conclude that sessions
with different session identiﬁers have different session keys
based on the collision-resistant property of the secure hash
function.

3. Sessions with the same session identiﬁer for some stage

agree on the authentication mode of the stage.
Note that, sessions with the same session identiﬁer for
stage i implies the same session identiﬁer for stage j such
that j < i, and the exchanged messages except for the
ﬁnished messages contained in sidi uniquely determines
the authenticity property for this stage and the previous
stages. For example in mode M1, obviously auth1 =
unauth. If sid2 additionally contains the ServerCertiﬁcate
and ServerCertiﬁcateVerify messages, they will agree on
auth2 = unilateral. If sid2 moreover contains Certiﬁ-
cateRequest, ClientCertiﬁcate, and ClientCertiﬁcateV-
erify, they will agree on auth2 = mutual.

4. Sessions with the same session identiﬁer for some stage

share the same contributive identiﬁer.
This holds since the contributive identiﬁer cid is ﬁnal once
the session identiﬁer is set.

5. Sessions are partnered with the intended (authenticated)

participant and share the same key index.
First of all note that this case only applies to unilaterally
or mutually authenticated stages only. In TLS, the client
obtains the server’s identity within the ServerCertiﬁcate
or ServerCertiﬁcate−1 (for 0-RTT case) message and the
server obtains the client’s identity (in case of mutual au-
thentication) within the ClientCertiﬁcate message. More-
over, honest clients and servers will not send a certiﬁcate
(cid:3)
attesting an identity different from their own.
For the PSK/resumption
, honest sessions are
assured of the peer’s identity and the key index via the
pre-shared key identiﬁer psidU,V,k, which is included in the
session identiﬁer for all stages. Specially, in the ClientHello
extension, PreSharedExtension identifying the PSK may

-(EC)DHE

(cid:4)

497497

be included. In other words, since each party knows the
unique mapping between pre-shared key identiﬁers and key
indices, a party can determine the peer’s identity from the
psidU,V,k and the mapping.
Thus, agreement on sid implies agreement on the partner’s
identity and the key index used.

6. Session identiﬁers do not match across different stages.

This holds trivially as session identiﬁers monotonically
grow with each stage.

7. At most two sessions have the same session identiﬁer at

any stage.
Note that for each mode, a random nonce of both the
initiator and the responder enters the session identiﬁers.
Therefore, in order to have a threefold collision among
session identiﬁers of honest parties, the third session would
need to pick the same nonce as one of the other two
sessions. The probability that there exists such a collision
−|nonce| where
can hence be bounded from above by n2
|nonce| is the nonce length.
For modes that use Difﬁe-Hellman key, the group element
for that key also enters the session identiﬁers. Similarly,
the probability that there exists a third session picking the
same group element as one of the other two sessions can
hence be bounded by n2
s.1/q where q denotes the group
order.

s.2

8. Session identiﬁers do not match across different modes.

Note that, the exchanged message included in sid1, u-
niquely identiﬁes the handshake mode Mi, for example the
EarlyDataIndication included in sid1 identiﬁes the mode
M2, and sid1 is included in the session identiﬁers of the
later stages. Therefore, we can assert that any sessions with
different modes cannot share the same identiﬁers.

9. Session identiﬁers do not match across different levels.

Since Π is Multi-Level&Stage-secure which implies
Match-secure, we only need to prove that session label(cid:2)
and any session label included in Π such that label(cid:2).lev
(cid:9)= label.lev, cannot share the same session identiﬁers.
Let us assume that label(cid:2).mode = label.mode, as the
case of across different modes has been proved in the
eighth property. Note that, label(cid:2).lev (cid:9)= label.lev, which
implies that label.prelid (cid:9)= label(cid:2).prelid. Moreover, the key
materials in label and label(cid:2) are derived from label.prelid
and label(cid:2).prelid respectively. Hence, session identiﬁers
cannot match between label and label(cid:2).

Lemma 3. If a multiple handshakes protocol Π is Multi-
(cid:2) combining Π with
Level&Stage-secure, then the protocol Π
a session label(cid:2) such that label(cid:2).mode = M2 is secure against
Key Secrecy. Formally, for any efﬁcient adversary A, the Key
Secrecy can be broken with advantage AdvKey−Secrecy,D
such
that

Π(cid:2),A

AdvKey−Secrecy,D

Π(cid:2),A

≤ AdvKey−Secrecy,D
4AdvColl

(cid:3)
Π,A
+ 5ns.
+ ns.(3AdvGap−DH

G

H + 4nu.AdvEUF−CMA
+ 5AdvPRF−sec

+ 2AdvPRF−sec
(cid:4)
,
HKDF.Expand)

HKDF.Extract

Sig

Where ns is the maximum number of sessions and nu is

the maximum number of users.

Proof Sketch. We only sketch the main steps of the proof
here due to space restrictions, and the complete proof of this
lemma can be found in Appendix A.
First, we describe a dependence relation between Π and the
new added label label(cid:2). During the session label included in Π,
where label(cid:2).prelid = label.lid, the client obtained the server’s
ServerConﬁguration containing gs associated with an unique
Conﬁguration id, together with the server’s ServerCertiﬁ-
cate and ServerCertiﬁcateVerify message for authentication.
Then the client can use the gs and Conﬁguration id to
interact with the server in 0-RTT labeled by label(cid:2). Note that
since Π is Multi-Level&Stage-secure, s can only be known
to the authenticated server, unless the adversary would make a
Corrupt query. Thus, we can now focus on the Key Secrecy
of label(cid:2).

Our subsequent security analysis separately considers two

cases:
1. s is never compromised. We consider the three (disjoint)
cases: the adversary tests a server session without honest
contributive partner in the ﬁrst stage; the adversary tests a
client session without honest contributive partner in the sec-
ond stage; and the tested session has an honest contributive
partner in the second stage. The common game-hopping
techniques are adopted in the proof of all three cases to
bound the adversary’s success probability.

2. s is compromised after handshake. Even though Eadk
in the ﬁrst stage is known to the adversary due to the
compromised s, Key Secrecy of label(cid:2) can still be sat-
isﬁed. Specially, tkhs in the second stage is secure since it
never depends on s; tkapp, RMS and EMS are all secure
since they depend on both mSS and mES, where mSS is
compromised since the compromise of s, however, mES is
still unknown to the adversary. Also, we use the common
game-hopping techniques.
Also, we discuss the privacy property of the early applica-
tion data transmitted on the ﬁrst ﬂight and show this property
can be guaranteed in the security model.

Finally, the Key Secrecy of the protocol Π

(cid:2) follows.

Lemma 4. If a multiple handshakes protocol Π is Multi-
(cid:2) combining Π with
Level&Stage-secure, then the protocol Π
a session label(cid:2) such that label(cid:2).mode = M3 is secure against
Key Secrecy. Formally, for any efﬁcient adversary A, the Key
Secrecy can be broken with advantage AdvKey−Secrecy,D
such
that
(cid:4)
Π,A
AdvColl
HKDF.Extract + 2AdvPRF−sec
HKDF.Expand)
,
Where ns is the maximum number of sessions and nu is

≤ AdvKey−Secrecy,D
+ ns.(3AdvPRF−sec

AdvKey−Secrecy,D

Π(cid:2),A
(cid:3)

+ 4ns.

Π(cid:2),A

H

the maximum number of users.

Proof. Since Π is Multi-Level&Stage-secure, we just need
to show the key secrecy of the added session label(cid:2). Before
giving the detailed proof we need to show the relation between

498498

label(cid:2) and label, where the session label is included in Π,
and label(cid:2).prelid = label.lid. In TLS 1.3 draft 10, the original
session resumption provided by “session resumption” and
“session tickets” in TLS 1.2 has been replaced with a new
mechanism called PSK mode, where once a handshake has
completed, the server can send the client a PSK identity which
corresponds to a key derived during this handshake. Then the
client can use that PSK identity in future PSK/resumption
to negotiate use of the PSK mode. During PSK/resumption
label(cid:2), both the static secret SS and the ephemeral secret
ES are equal to the pre-shared resumption master secret(Pre-
RMS) derived from label and there may be several sessions
share the same Pre-RMS for PSK/based resumption. Thus we
can conﬁdently replace the pre-shared resumption master key
Pre-RMS with a uniformly selected (cid:2)Pre − RMS which will
only be shared between the two honest parties in label(cid:2) based
on the Key Security of label, and now we can focus on the
security of label(cid:2) with (cid:2)Pre − RMS indexed by psidU,V,k as
follows.
(The result for label(cid:2)): PSK/resumption is secure against
Key Secrecy in a key-independent manner with concurrent
authentication properties AUTH = (mutual, mutual, mutual,
mutual).

To prove this result, note that, [19] shows the Multi-stage
security of TLS 1.3 draft-05 session resumption handshake,
here we will explain that their result also adapts to the TLS
1.3 draft-10 PSK/resumption handshake. In each draft when
resumption, either sid or PreSharedKeyExtension will be
contained in both the ClientHello and ServerHello extension-
s.

Compared with TLS 1.3 draft-05, the resumption mode in

TLS 1.3 draft-10 makes the following minor changes:
1. The sid message included in ServerHello message for
the resumption in later connection is replaced with the
NewSessionTicket
transmitted under the protection of
tkapp.

2. Both the resumption master secret RMS and exporter
master secret EMS for export can also be generated during
resumption handshake.
Thus the proof is similar to that in [19] and due to space
limitations, here we provide a proof sketch in Table I listing
the modiﬁcations in each game.

Up to now, the proof for Lemma 4 has been completed.

Lemma 5. If a multiple handshakes protocol Π is Multi-
(cid:2) combining Π with
Level&Stage-secure, then the protocol Π
a session label(cid:2) such that label(cid:2).mode = M4 is secure against
Key Secrecy. Formally, for any efﬁcient adversary A, the Key
Secrecy can be broken with advantage AdvKey−Secrecy,D
such
that
(cid:4)

Π(cid:2),A
(cid:3)
+ 4ns.
Π,A
2AdvColl
HKDF.Extract + 4AdvPRF−sec
,
HKDF.Expand)
Where ns is the maximum number of sessions and nu is

≤ AdvKey−Secrecy,D
+ 5AdvPRF−sec

AdvKey−Secrecy,D
Π(cid:2),A
+ ns.(2AdvDDH

H

G

the maximum number of users.

OVERVIEW OF THE GAMES WITHIN THE PROOF OF LEMMA 4

TABLE I

OVERVIEW OF THE GAMES WITHIN THE PROOF OF LEMMA 5

TABLE II

Games
Game0

Probability loss

—

Game1

a factor of 1/4ns

Description
Initial game
A makes only
a single Test query

Game2

Game3

Game4

Game5

AdvCOLL

H

a factor of 1/ns
AdvPRF−sec
AdvPRF−sec

HKDF.Extract

HKDF.Extract

Game6

AdvPRF−sec

HKDF.Expand

Game7

AdvPRF−sec

HKDF.Extract

Game8

AdvPRF−sec

HKDF.Expand

no collision in
hash function H

guess the PSK that the
tested session will use

replace xSS with

random (cid:2)xSS

replace xES with
random (cid:2)xES

replace mES,tkhs,
mSS,FS with random

(cid:3)mES, (cid:2)tkhs,
(cid:2)mSS, (cid:2)F S,

replace MS with

random (cid:2)M S
replace tkapp,
RMS,EMS with
random (cid:3)tkapp,
(cid:3)RM S,(cid:3)EM S

Reduction to

—

security of

the single session
tested in stage i
Second-Preimage
Resistance of H
security of the
right guess case

security of

HKDF.Extract

security of

HKDF.Extract

security of

HKDF.Expand

security of

HKDF.Extract

security of

HKDF.Expand

Games
Game0

Probability loss

—

Game1

a factor of 1/4ns

Description
Initial game
A makes only
a single Test query

Game2

Game3

Game4

Game5

Game6

AdvCOLL

H

a factor of 1/ns
AdvPRF−sec

HKDF.Extract

G

AdvDDH
AdvPRF−sec

HKDF.Extract

Game7

AdvPRF−sec

HKDF.Expand

Game8

AdvPRF−sec

HKDF.Extract

Game9

AdvPRF−sec

HKDF.Expand

no collision in
hash function H

guess the PSK that the
tested session will use

replace xSS with

random (cid:2)xSS
replace ES with

random (cid:2)ES

replace xES with
random (cid:2)xES

replace mES,tkhs,
mSS,FS with random

(cid:3)mES, (cid:2)tkhs,
(cid:2)mSS, (cid:2)F S,

replace MS with

random (cid:2)M S
replace tkapp,
RMS,EMS with
random (cid:3)tkapp,
(cid:3)RM S,(cid:3)EM S

Reduction to

—

security of

the single session
tested in stage i
Second-Preimage
Resistance of H
security of the
right guess case

security of

HKDF.Extract

DDH problem

security of

HKDF.Extract

security of

HKDF.Expand

security of

HKDF.Extract

security of

HKDF.Expand

Proof. Since Π is Multi-Level&Stage-secure, we just need
to show the Key Secrecy of the added session label(cid:2). Before
giving the detailed proof we need to show the relation between
label(cid:2) and label, where the session label is included in Π, and
label(cid:2).prelid = label.lid. In TLS 1.3 draft 10, PSK/resumption
can also use PSK in combination with an (EC)DHE exchange
in order to provide forward secrecy. During PSK/resumption-
(EC)DHE, the static secret SS equals to Pre-RMS derived
from label and the ephemeral secret ES are negotiated through
an (EC)DHE exchange. Thus we can also conﬁdently replace
the pre-shared resumption master key Pre-RMS with a uni-
formly selected (cid:2)Pre − RMS which will only be shared between
the two honest parties in label(cid:2) based on the Key Security of
label, and now we can focus on the security of label(cid:2) with
(cid:2)Pre − RMS indexed by psidU,V,k as follows.
(The result for label(cid:2)): PSK/resumption-(EC)DHE is secure
against Key Secrecy in a key-independent and stage-1-
forward-secret manner with concurrent authentication prop-
erties AUTH = (unauth, mutual, mutual, mutual).

The proof sketch for the above result is similar to that for
Lemma 3 for 0-RTT. Again, we consider two parts in one of
which the pre-shared key has never been corrupted and the
other the pre-shared key can be corrupted after the handshake
has been completed.

Part 1: uncorrupted pre-shared key
Firstly we show that

the adversary cannot

test a client
(or a server) session without honest contributive partner in
the ﬁrst stage. In this case test query to the session in stage
1 with authentication level unauth should be prohibited to
avoid trivial attack according to the security model. In later
the authentication level are all mutual due to the
stages,
implicitly authenticated pre-shared key shared between the
two parties, which means the adversary cannot successfully

complete the handshake without pre-shared key (As in the
proof of Lemma 3, and here PSK plays the similar role as
the certiﬁcate for authentication). Thus, we can analyze the
Key Secrecy under the assumption that the tested client (or
server) session has an honest contributive partner in the ﬁrst
stage, and the games during proof are listed in Table II.

Part 2:
handshake

the pre-shared key is corrupted after the

If the pre-shared key is corrupted after the session has been
completed, we need to set the stkey of xSS, mSS and FS to
revealed due to the compromise of the pre-shared key. Here
we also assume the tested session has an honest contributive
partner in the ﬁrst stage just like in Part 1, thus Key Secrecy
of label(cid:2) is still be satisﬁed due to the secrecy of ES = gxy,
which is similar to the discussion in Part 2 of Lemma 3, and
will be omitted here.

The advantage of the adversary in this case can also be
bounded as in Table II, except that Game 4 and the replace-
ment of mSS and FS in Game 7 will not exist any more
since xSS has been known to the adversary, and the other
probability loss would be the same and will be included in
the stated security bound of Lemma 5.

Up to now, the proof for Lemma 5 has been completed.
Above all, we have accomplished the proof of Theorem 1.

B. Compositional Security

In [22] and [19],

the authors present a compositional
framework for Multi-Stage-secure key exchange protocols
such that QUIC and TLS 1.3 full handshake can be securely
composed with arbitrary symmetric-key protocols under the
following condition:

499499

The compositional framework is only supported between
a key exchange protocol with key-independent stage-j for-
ward secrecy for some stage j and an arbitrary symmetric-
key protocol.

It would be desirable to prove the multiple handshakes secu-
rity of TLS 1.3 draft via game-based compositional framework
[22][19]. Unfortunately, 0-RTT in TLS 1.3 draft-10 cannot
be seen as a secure symmetric-key protocol, and moreover
PSK/resumption in TLS 1.3 draft-10 as a secure key exchange
protocol does not provide forward secrecy (with respect to
corruption of the pre-shared resumption master key), neither
of which satisﬁes the condition of compositional framework.
Therefore, the compositional security cannot be adapted to
the multiple handshakes security analysis above.
Different from the notion of composition,

the relations
between two sessions have been considered in our analysis.
We can guarantee the security of the module by combining a
secure key exchange with a non-symmetric-key protocol like
0-RTT in a new security model, however we do not rely on
the forward secrecy property of the key exchange protocol. So
the security analysis in this paper can be more general.

V. (IN)SECURITY ANALYSIS OF TLS 1.2

In this section, we discuss how the triple handshake attack
of TLS 1.2 is captured in the multiple handshakes security
model. In TLS 1.2, there are three primary handshake modes,
full handshake (M1), session resumption (M2), and session
renegotiation (M3), where session resumption is similar to the
PSK/resumption in TLS 1.3 draft with little changes, and ses-
sion renegotiation handshake proceeds as the full handshake,
except that its messages are exchanged on the encrypted TLS
connection, for the purpose of authenticating the client without
privacy leakage or upgrading the ciphersuite. What’s more,
TLS 1.2 also features dependencies of multiple runs of the
handshake protocols.

As described in the introduction, it is impossible to prove
TLS 1.2 handshake protocol secure in any security model
based on key indistinguishability, like the multiple handshakes
security model from Section III, because the encryption and
MAC of the Finished messages provide a ‘check value’, that
can be exploited by an adversary to determine the bit btest
chosen by the Test oracle. Therefore, we consider a ‘truncated
TLS’ protocol as in [11] where the Finished messages are sent
in clear, and the truncated TLS full handshake has been proven
to be a secure AKE protocol.

Like TLS 1.3, we also view TLS 1.2 as a multi-stage key
exchange protocol, where in the ﬁrst stage the master secret
ms would be derived, and in the second stage the trafﬁc key
tkhs would be derived from ms. Then the Multi-Level&Stage
Security model can be applied to the truncated TLS 1.2 now.
Firstly, we recall the the triple handshake attack of TLS
1.2 proposed by Bhargavan et al. in 2014 [5]. Concretely, the
malicious server performs a man-in-the-middle attack on three
successive handshakes (full handshake, session resumption
and renegotiation) between the honest client and server, and

succeeds in impersonating the client on the third handshake.
The attack is described as follows:
Step 1. Synchronizing RSA/DHE. C deliberately connects to
a server A which malicious connects to the server
S. Due to the fact that only C contributes to the
key exchange in RSA and in DHE the attacker can
make C accept a group with non-prime order, A can
synchronize pms with C and S maliciously. Taking
RSA for example, A just takes the encrypted pms
generated by C and re-encrypt it to S. At the end of
this stage, A completes both handshakes to obtain two
new sessions, and these two sessions share the same
parameters (sid, ms).
Step 2. Synchronizing resumption. Once A has synchronized
the above two connections, suppose C attempts to
resume the session with A on a new connection,
and A can then resume its session with S on a new
connection and forward the abbreviated handshake
messages unchanged between C and S. Since the
abbreviated handshake only relies on the master secret
for authentication and does not mention client or
server identities, both handshakes complete success-
fully, resulting in the same session keys and the same
ﬁnished messages.

Step 3. Impersonating the client. Now, since the Renegotia-
tion Indication extension [9] in the Hello message
has been synchronized, if C or S initiates a client-
authenticated TLS renegotiation, A can simply for-
ward all messages between C and S. If C can accept
the new identity of the server, then, just like Ray and
Dispensa’s attack [8], A will successfully impersonate
C to S even though it has no idea about the connection
key in the renegotiation.

Note that, it is not difﬁcult to draw that this attack would
still be valid, though the ﬁnished messages are transmitted in
clear.

Formally, this attack is captured in our security model for
multiple handshakes protocol from Section III as follows.
We use Π to denote the composition of the full handshake,
resumption handshake, and the renegotiation handshake. Note
that Π is a multiple handshakes protocol with three levels
according the model deﬁnition. We assume during the attack
the client and the server both run a handshake protocol
label denoted by label and label(cid:2) respectively. Firstly, when
label.lev = label(cid:2).lev = 1, label.mode = label(cid:2).mode = M1,
label.sid1 (cid:9)= label(cid:2).sid1, label.sid2 (cid:9)= label(cid:2).sid2, however
label.K1 = label(cid:2).K1 and label.K2 = label(cid:2).K2, which means,
sessions with the different session identiﬁers for some stage
hold the same session keys at that stage. Thus, TLS 1.2 without
countermeasures is not a Multi-Level&Stage secure multiple
handshakes protocol.

Recently, IETF TLS working group developed RFC 7627
[30] to provide a countermeasure to the triple handshake
attack. This countermeasure contextually binds the master
secret to the full handshake by including a hash of handshake

500500

messages in the PRF computation. Intuitively, by such binding,
master secrets generated with different session identiﬁers
cannot be the same, and thus the triple handshake attack is
avoided. Due to the limited space, the detailed security proof
is omitted here.

VI. CONCLUSION

Although TLS handshake protocols for establishing secure
communications have been extensively studied in the literature
and are widely used in practice, this is the ﬁrst work to
consider the important practical issue of multiple handshakes,
in which parties run successive TLS handshakes over multiple
connections. The importance of correctly implementing multi-
ple handshakes was highlighted by the triple handshake attack
of Bhargavan et al. in 2014 [5].

We have developed a formal model for describing the securi-
ty of multiple handshakes protocol, covering all kinds of com-
positional interaction between the different TLS handshake
modes and providing reasonably strong security guarantees.
We have proved the security of multiple handshakes of TLS
1.3 candidates in combinational running setting, which further
conﬁrms the sound design of TLS 1.3 handshake protocol.
We have speciﬁcally analyzed TLS 1.2 handshake protocol
on a high level, identifying the triple handshake attack in our
model, and then showed that their countermeasure offers good
protection against multiple handshakes attack.

How to analyze the compositional security of other key
exchange protocols widely applied in practice such as SSH
protocol under our multiple handshakes security model is a
worthwhile direction. In addition, the overall security of TLS
1.3 still has many important open questions, including the
security of multi-ciphersuites and the formal analysis of other
complex functionality such as version negotiation.

ACKNOWLEDGMENT

This work was supported by the National Grand Fun-
damental Research (973) Program of China under Grant
2013CB338003, and the National Natural Science Foundation
of China (NSFC) under Grants U1536205, 61170279 and
61572485.

REFERENCES

[1] T. Dierks and E. Rescorla, “The Transport Layer Security (TLS) Protocol

Version 1.1,” IETF RFC 4346, April 2006.

[2] ——, “The Transport Layer Security (TLS) Protocol Version 1.2,” IETF

RFC 5246, August 2008.

[3] N. J. AlFardan, D. J. Bernstein, K. G. Paterson, B. Poettering, and
J. C. Schuldt, “On the Security of RC4 in TLS.” in USENIX Security.
USENIX, 2013, pp. 305–320.

and DTLS record protocols,” in IEEE S&P.

[4] N. J. Al Fardan and K. G. Paterson, “Lucky thirteen: Breaking the TLS
IEEE, 2013, pp. 526–540.
[5] K. Bhargavan, A. D. Lavaud, C. Fournet, A. Pironti, and P. Y. Strub,
“Triple handshakes and cookie cutters: Breaking and ﬁxing authentica-
tion over TLS,” in IEEE S&P.

IEEE, 2014, pp. 98–113.

[6] Codenomicon, “The Heartbleed Bug,” http://heartbleed.com, April 2014.
[7] E. Rescorla, “The Transport Layer Security (TLS) Protocol Version 1.3
- draft-ietf-tls-tls13-10,” https://tools.ietf.org/html/draft-ietf-tls-tls13-10,
October 2015.

[8] M. Ray and S. Dispensa, “Renegotiating TLS,” http://extendedsubset.

com/Renegotiating TLS.pdf, November 2009.

[9] E. Rescorla, M. Ray, S. Dispensa, and N. Oskov, “Transport Layer
Security (TLS) Renegotiation Indication Extension,” IETF RFC 5746,
February 2010.

[10] K. Bhargavan, A. Delignat-Lavaud, and A. Pironti, “Veriﬁed Contribu-
tive Channel Bindings for Compound Authentication,” in NDSS, 2015.
[11] T. Jager, F. Kohlar, S. Sch¨age, and J. Schwenk, “On the security of
Springer, 2012, pp.

TLS-DHE in the standard model,” in CRYPTO.
273–293.

[12] F. Kohlar, S. Sch¨age, and J. Schwenk, “On the Security of TLS-DH and
TLS-RSA in the Standard Model.” Cryptology ePrint Archive,Report
2013/367, 2013, https://eprint.iacr.org/2013/367.

[13] H. Krawczyk, K. G. Paterson, and H. Wee, “On the security of the
TLS protocol: A systematic analysis,” in CRYPTO. Springer, 2013, pp.
429–448.

[14] F. Giesen, F. Kohlar, and D. Stebila, “On the security of TLS renegoti-

ation,” in ACM CCS. ACM, 2013, pp. 387–398.

[15] Y. Li, S. Sch¨age, Z. Yang, F. Kohlar, and J. Schwenk, “On the Security
of the Pre-shared Key Ciphersuites of TLS,” in PKC. Springer, 2014,
pp. 669–684.

[16] K. Bhargavan, C. Fournet, M. Kohlweiss, A. Pironti, P.-Y. Strub, and
S. Zanella-B´eguelin, “Proving the TLS handshake secure (as it is),” in
CRYPTO 2014. Springer, 2014, pp. 235–255.

[17] C. Fournet, M. Kohlweiss, and P.-Y. Strub, “Modular code-based cryp-

tographic veriﬁcation,” in ACM CCS. ACM, 2011, pp. 341–350.

[18] K. Bhargavan, C. Fournet, M. Kohlweiss, A. Pironti, and P. Strub,
“Implementing TLS with veriﬁed cryptographic security,” in IEEE S&P.
IEEE, 2013, pp. 445–459.

[19] B. Dowling, M. Fischlin, F. G¨unther, and D. Stebila, “A cryptographic
analysis of the TLS 1.3 handshake protocol candidates,” in ACM CCS.
ACM, 2015, pp. 1197–1210.

[20] E. Rescorla, “The Transport Layer Security (TLS) Protocol Version 1.3
- draft-ietf-tls-tls13-05,” https://tools.ietf.org/html/draft-ietf-tls-tls13-05,
March 2015.

[21] ——,

“The Transport Layer Security (TLS) Protocol Version
1.3-draft-ietf-tls-tls13-dh-based,” https://github.com/ekr/tls13-spec/blob/
ietf92 materials/draft-ietf-tls-tls13-dh-based.txt, March 2015.

[22] M. Fischlin and F. G¨unther, “Multi-Stage Key Exchange and the Case of
Google’s QUIC Protocol,” in ACM CCS. ACM, 2014, pp. 1193–1204.
[23] E. Rescorla, “The Transport Layer Security (TLS) Protocol Version 1.3
- draft-ietf-tls-tls13-07,” https://tools.ietf.org/html/draft-ietf-tls-tls13-07,
July 2015.

[24] H. Krawczyk and H. Wee, “The OPTLS Protocol and TLS 1.3,”
Cryptology ePrint Archive, Report 2015/978, 2015, https://eprint.iacr.
org/2015/978.

[25] R. Canetti and H. Krawczyk, “Analysis of key-exchange protocols and
Springer,

their use for building secure channels,” in EUROCRYPT.
2001, pp. 453–474.

[26] A. Langley and W. Chang, “QUIC Crypto,” http://tinyurl.com/lrrjyjs,

June 2013.

[27] R. Lychev, S. Jero, A. Boldyreva, and C. Nita-Rotaru, “How secure and
quick is QUIC? Provable security and performance analyses,” in IEEE
S&P.

IEEE, 2015, pp. 214—231.

[28] M. Bellare and P. Rogaway, “Entity authentication and key distribution,”

in CRYPTO. Springer, 1993, pp. 232–249.

[29] C. Brzuska, M. Fischlin, B. Warinschi, and S. C. Williams, “Composabil-
ity of Bellare-Rogaway key exchange protocols,” in ACM CCS. ACM,
2011, pp. 51–62.

[30] K. Bhargavan, A. Delignat-Lavaud, A. Pironti, A. Langley, and M. Ray,
“Transport Layer Security (TLS) Session Hash and Extended Master
Secret Extension,” IETF RFC 7627, September 2015.

[31] H. Krawczyk, “Cryptographic extraction and key derivation: The HKDF

scheme,” in CRYPTO. Springer, 2010, pp. 631–648.

[32] H. Krawczyk and P. Eronen, “HMAC-based Extract-and-Expand Key

Derivation Function (HKDF),” IETF RFC 5869, May 2010.

[33] R. Canetti and H. Krawczyk, “Security analysis of IKE’s signature-based

key-exchange protocol,” in CRYPTO. Springer, 2002, pp. 143–161.

[34] C. Brzuska, “On the foundations of key exchange,” TU Darmstadt, 2013,

http://tuprints.ulb.tu-darmstadt.de/3414/.

501501

APPENDIX

A. The proof of Lemma 3

in the session label, so that

As Π is Multi-Level&Stage-secure, we just need to show
the Key Secrecy of the added session label(cid:2). Before giving
the detailed proof we need to show the relation between
label(cid:2) and label, where the session label
is included in
Π, and label(cid:2).prelid = label.lid. In order to enable 0-RTT
functionality of label(cid:2), TLS 1.3 draft suggests the server
sends a ServerConﬁguration message containing the semi-
static key gs associated with an unique Conﬁguration id
the client can
to the client
use that share in the 0-RTT handshake. Also,
the sever
also sends its ServerCertiﬁcate and ServerCertiﬁcateVerify
messages for authentication. Moreover, during 0-RTT hand-
shake, the concatenation of the ServerConﬁguration−1 and
ServerCertiﬁcate−1 messages are contained in the compu-
tation of handshake hash. Thus we can conﬁdently assert
that only the authenticated server knows the secret s since
the label is secure against Key Secrecy, unless the adversary
makes a Corrupt query. Above all, we can now focus on the
security of label(cid:2) as follows.
(The result for label(cid:2)): 0-RTT is secure against Key-Secrecy
in a key-independent and stage-2-forward-secret manner with
concurrent authentication properties AUTH = (unilateral,
unauth, unilateral, unilateral, unilateral), (unilateral, unilat-
eral, mutual, mutual, mutual) in the random oracle. Formal-
ly, for any efﬁcient adversary A against the Key Secrecy
there exist efﬁcient algorithms B1, ...,B10 described in later
games.
Remark 3: To prove the above result, we treat HKDF.Extract
as the random oracle when computing SS and ES and this
is a very common assumption for security analyses. While
it may not be appropriate in each case, the standard use of
HKDF.Extract with ﬁxed keys for the key derivation function
here seems ﬁne. In 0-RTT, it is important for the analysis
that the ﬁrst occurrence for SS is the random oracle. The
second one for ES may satisfy a weaker notion, but we treat
it as the random oracle for simplicity just like in the QUIC
security analysis [27].

Part 1: un-compromised s
In this part we consider the case that the secret s is never

compromised.

Just like the work in [22] and [19], we consider the case that
the adversary makes a single Test query only, by a factor at
most 1/5ns as there are ﬁve stages in each of the ns sessions.
Also, the same problem as in [19] we have to deal with is
that sid2 for the second stage and hence also sid3 are not
available in clear, but are partly encrypted. However, stage key
independence allows us to reveal the keys for stage 1 for the
consistent simulation for B in terms of identical answers for
partnered sessions, and at the same time without endangering
security of the following stage keys. We omit the hybrid details
which can be referred to [19].

From now on, we can therefore speak about the session
label(cid:2) tested at stage i and we also assume that we know
label(cid:2) in advance. Note that server authentication always exists
in all stages except stage 2 since only the server that has been
authenticated in label knows the secret s, no matter whether
there exists ServerCertiﬁcate and ServerCertiﬁcateVerify
messages in stage 3.

Note that if the server does not send its ServerCertiﬁcate
and ServerCertiﬁcateVerify messages in stage 3, then there
may exist an adversary that selects ServerHello ‘+’ KeyShare
on its own to interact with client in stage 2, and by our
deﬁnition of Test query,
in this case, Test query to the
client for stage 2 should be prohibited to avoid trivial attack.
However, if there is an honest unauthenticated (in stage 2)
server, then the key of stage 2 between these honest parties
should still be secure and Test queries to the client are still
allowed in this case.

Similarly, if client does not send its ClientCertiﬁcate and
ClientCertiﬁcateVerify messages in stage 2, then there may
exist an adversary that selects ClientHello ‘+’ KeyShare
during stage 1 on its own and then interacts with server in stage
2, and by our deﬁnition of Test query, in this case, Test query
to server for stage 1 and stage 2 should be prohibited to avoid
trivial attack. However, if there is an honest unauthenticated
(in stage 1) client, then the key of stage 1 and stage 2 between
these honest parties should still be secure and Test queries to
the server are still allowed in this case.

Above all, our subsequent security analysis separately con-

siders the three cases that:
1) the adversary tests a server session without honest con-
tributive partner in the ﬁrst stage (i.e., label(cid:2).role = re-
sponder for the test session label(cid:2) and there exists no
label(cid:2)(cid:2) (cid:9)= label(cid:2) with label(cid:2).cid1 = label(cid:2)(cid:2).cid1),
2) the adversary tests a client session without honest contribu-
tive partner in the second stage (i.e., label(cid:2).role = initiator
(cid:9)=
for the test session label(cid:2) and there exists no label(cid:2)(cid:2)
label(cid:2) with label(cid:2).cid2 = label(cid:2)(cid:2).cid2),
3) the tested session has an honest contributive partner
partner in the second stage(i.e., there exists label(cid:2)(cid:2) with
label(cid:2).cid2 = label(cid:2)(cid:2).cid2).
This allows us to bound the advantage into three cases:

Adv1−Key−Secrecy,server without partner
,
Adv2−Key−Secrecy,client without partner
,
and Adv2−Key−Secrecy,test with partner

draft−10,A
draft−10,A

draft−10,A

.

Case A: Test Server without Partner in stage 1

We ﬁrst consider the case that the tested session is a server
(responder) session without honest contributive partner in the
ﬁrst stage. Having an honest partner in the second or later stage
implies having also one in the ﬁrst, hence the tested session
must actually be without honest partner in all later stages.
Observe that, in this case no honest party has the same cid1 as
the tested session, then if the tested key is unauthenticated, the
adversary cannot win unless with trivial attack according to the
security model. Hence, we can assume that client will send its

502502

ClientCertiﬁcate and ClientCertiﬁcateVerify messages during
stage 2.

We proceed in the following sequence of games. Starting
from the original Key Secrecy game, we bound the
advantage difference of adversary A in successive games
by complexity-theoretic assumptions until we reach a game
where the advantage of A is at most 0.

AdvGA.0

draft−10,A

Game A.0. This initial game equals the Key Secrecy
game with a single Test query where A is restricted to test a
server session without honest contributive partner in stage 1.
Therefore,

draft−10,A = Adv1−Key−Secrecy,server without partner

Game A.1. The challenger in this game aborts the game if
any two honest sessions compute the same hash value for
different inputs in any evaluation of the hash function H. We
H to denote the advantage of an adversary B1 against
use AdvColl
the collision resistance of the hash function H. To this extent,
B1 acts as the challenger in Game A.0, using its description of
H to compute hash values, and running A as a subroutine. If
the challenger aborts, B1 outputs the two distinct input values
to H resulting in the same hash values as a collision. And thus

.

AdvGA.0

draft−10,A ≤ AdvGA.1

draft−10,A + AdvColl
H .

Sig

Game A.2. The challenger in this game aborts the game if
the tested session receives, within the ClientCertiﬁcateVerify
message, a valid signature under the public key pkU for some
user U ∈ U such that the hash value has not been signed by
any of the honest sessions. We use AdvEUF−CMA
to denote the
advantage of an adversary B2 against the EUF-CMA security
of the signature scheme Sig. In the reduction, B2 ﬁrst guesses
a user U ∈ U which it associates with the challenger public
∗ in the EUF-CMA game, then generates all long-term
key pk
(cid:2) ∈ U \ {U} and runs the Key
key pairs for the other U
Secrecy game GA.1 for A. For any signature to generate for
user U in honest sessions, B2 calls its signing oracle. If the
challenger aborts, B2 outputs the signature the tested server
received together with the hash value as a forgery.
If B2 correctly guessed the user under whose public key
the obtained signature veriﬁes, which happens with probability
1/nu (there are at most nu users), then as a forger, B2 can use
the signature received to break the EUF-CMA security in the
sense that its message was never queried to the EUF-CMA
oracle and thus

draft−10,A ≤ AdvGA.2

draft−10,A + nu. AdvEUF−CMA

Finally, if Game A.2 does not abort, we are assured that an
honest session outputs the signature obtained by the tested
server session within the ClientCertiﬁcateVerify message.
Specially, the tested server and the honest session outputting
the signature agree on sid1, so also on cid1 and hence
partnered in the ﬁrst stage.

The adversary A therefore cannot

test a server session
without honest ﬁrst-stage partner in Game A.2, resulting in
the test bit btest being unknown to A and hence

AdvGA.1

Sig

.

AdvGA.2

draft−10,A = 0.

Case B: Test Client without Partner in stage 2

We then consider the case that the tested session is a client
session without honest contributive partner in the second stage.
Since having an honest partner in the third or later stage
implies having also one in the second stage, hence the tested
session must actually be without honest partner in all later
stages. Observe that, in this case no honest party has the same
cid2 to the tested session, then if the tested keys in stage
2 and later stages are unauthenticated, the adversary cannot
win unless with trivial attack according to the security model.
Hence, we assume that in stage 3, server will authenticate itself
by sending its ServerCertiﬁcate and ServerCertiﬁcateVerify
messages.

We proceed in a sequence of games similar to the case A,
and the detail of the proof will be omitted here. Finally, for
two adversaries B3 and B4, we have

Adv2−Key−Secrecy,client without partner

draft−10,A

≤ AdvColl
+nu.AdvEUF−CMA

H

.

Sig

Case C: Test with Partner in stage 2

.

AdvGC.0

Now we analyze the case that the tested session has an
honest contributive partner in the second stage. Note that, in
this case, the Test query can be issued in any stage.
Game C.0. Again, we start with an initial game equal to
the Key Secrecy game with a single Test query where A is
restricted to test a session with an honest contributive partner
in stage 2. Therefore,

draft−10,A = Adv2−Key−Secrecy,test with partner

draft−10,A

AdvGC.0

draft−10,A.

Game C.1. This game is identical to Game C.0, except for the
following. The challenger guesses a session label(cid:2)(cid:2) (cid:9)= label(cid:2)
and aborts the game in case this session is not the honest
contributive partner of the tested session in stage 2. This
reduces the adversary’s advantage by a factor of at most 1/ns
and hence

From now on, we can speak of the session label(cid:2)(cid:2) partnered

draft−10,A ≤ ns.AdvGC.1
with the tested session label(cid:2) in stage 2.
Game C.2. In this game we add an abort rule. The chal-
lenger aborts if the adversary makes a random oracle query
HKDF.Extract(0,gxs). In addition, pick a uniformly random
string (cid:5)
xSS and implicitly program HKDF.Extract(0,gxs) to be
(cid:5)
xSS. We bound the abort probability by the advantage of an
adversary B5 against the Gap-DH assumption in group G.
B5 is given the security parameter (q, g, S = gs, X = gx) for
random x, y and the veriﬁcation oracle V(g, S, ., .). In simu-
lating the game for A, when A makes a new random oracle
query HKDF.Extract(0,SS(cid:2)) (repeated queries answered with
the previously recorded answer), B5 ﬁrst calls its veriﬁcation
(cid:2)) and outputs SS(cid:2) as its own output in
oracle on (g, S, X, SS
case the oracle returned 1. Otherwise, B5 returns to A the
corresponding previously stored xSS∗ if SS(cid:2) has ever been
queried before. If SS(cid:2) has never been queried, then B5 returns
with a random (cid:5)
xSS and records this information along with
the corresponding SS(cid:2). Hence, above all B5 provides a perfect
simulation for A, and we have
draft−10,A ≤ AdvGC.2

draft−10,A + AdvGap−DH

AdvGC.1

G

.

503503

AdvGC.2

Game C.3. Next, we replace the early data trafﬁc key Eadk,
the ﬁnished key FS and mSS derived in both the tested and
its partnered session by a uniformly random value (cid:3)Eadk, (cid:6)
and (cid:5)
FS
mSS .
We can bound the difference in A’s advantage introduced
in this game by the security of the HKDF.Expand function.
The reduction B6, uses its PRF oracle for the evaluations
of HKDF.Expand under the key (cid:5)
xSS in the tested and its
partnered session. Observe that if the oracle computes the
PRF, this equals Game C.2, whereas, if it computes a random
this equals Game C.3. The simulation is sound
function,
because (cid:5)
xSS is a random value. The advantage of B6 in the
PRF security game therefore bounds the advantage difference
such that

draft−10,A ≤ AdvGC.3

draft−10,A + AdvPRF−sec

HKDF.Expand.

Game C.4. In this game we add an abort rule. The chal-
lenger aborts if the adversary makes a random oracle query
HKDF.Extract(0,gxy). In addition, pick a uniformly random
string (cid:5)
xES and implicitly program HKDF.Extract(0,gxy) to be
(cid:5)
xES. We bound the abort probability of its occurrence by the
advantage of an adversary B7 against the Gap-DH assumption
in group G.
Similar to Game C.2, B7 is given the security parameter
(q, g, X = gx, Y = gy) for random x, y and the veriﬁcation or-
acle V(g, X, ., .). In simulating the game for A, when A makes
a new random oracle query HKDF.Extract(0, ES(cid:2)) (repeated
queries answered with the previously recorded answer), B7
(cid:2)) and outputs
ﬁrst calls its veriﬁcation oracle on (g, X, Y, ES
ES(cid:2) as its own output in case the oracle returned 1. Otherwise,
B7 returns to A the corresponding previously stored xES∗
if ES(cid:2) has ever been queried before. If ES(cid:2) has never been
queried, then B7 returns with a random (cid:5)
xES and records this
information along with the corresponding ES(cid:2). Hence, B7
provides a perfect simulation for A, and we have

draft−10,A + AdvGap−DH

draft−10,A ≤ AdvGC.4
tkhs and (cid:5)
mES.

AdvGC.3
Game C.5. In this game, we replace tkhs and mES derived
in both the tested and its partnered session by a uniformly
random value (cid:5)
Analogously to Game C.3, we can bound the difference
in A’s advantage introduced in this game by the security of
the HKDF.Expand function. The reduction B8, uses its PRF
oracle for the evaluations of HKDF.Expand with the random
key (cid:5)
xES in the tested and its partnered session. Depending on
the oracles behavior it again perfectly simulates either Game
C.4 or Game C.5. We can hence infer that

draft−10,A ≤ AdvGC.5

draft−10,A + AdvPRF−sec

HKDF.Expand.

Game C.6. In this game, we replace MS derived in both the
tested and its partnered session by a uniformly random value
(cid:6)
MS.
Analogously to Game C.5, we can bound the difference
in A’s advantage introduced in this game by the security of
the HKDF.Extract function. The reduction B9, uses its PRF
oracle for the evaluations of HKDF.Extract with the random
key (cid:5)
mES and (cid:5)
mSS in the tested and its partnered session. and
hence we have
AdvGC.5

draft−10,A + AdvPRF−sec

draft−10,A ≤ AdvGC.6

HKDF.Extract.

AdvGC.4

G

.

AdvGC.6

Game C.7. At last, we replace tkapp, RMS, and EMS derived
in both the tested and its partnered session by a uniformly
random value (cid:3)tkapp, (cid:3)RMS, and (cid:3)EMS.
Analogously to Game C.5, we can bound the difference
in A’s advantage introduced in this game by the security of
the HKDF.Expand function. The reduction B10, uses its PRF
oracle for the evaluations of HKDF.Expand with the random
key (cid:6)
MS in the tested and its partnered session, and hence we
have

draft−10,A ≤ AdvGC.7

draft−10,A + AdvPRF−sec

HKDF.Expand.

draft−10,A = 0.

In Game C.7, the session keys as well as the resumption
and exporter master secrets are now chosen independently and
uniformly at random. As the response to its Test query is
hence independent of the test bit btest, the adversary A cannot
distinguish whether it is given the real key or random values
and thus AdvGC.8
Remark 4: Note that the case that the adversary tests the
server session without honest contributive partner in stage 2
however with honest contributive partner in stage 1 has been
skipped, since we can assume two parties both have honest
contributive partners in the ﬁrst stage after case A, which
means that the contribution of the client to SS and ES is
honest even though auth2 = unauth, and thus on the server
side the client has completed his contribution namely gx to
the keys of each stage. In this case the secrecy of the session
keys can be guaranteed and proved just like in case C.

Part 2: s is compromised after handshake
In this part we consider the case where s is compromised
by the query Corrupt(U, V, k) only after the honest client has
received the honest gy and the handshake has been completed,
excluding the trivial case of the client impersonation.

As for the proof in Part 1, our security analysis is the same

three (disjoint) cases that
1) the adversary tests a server session without honest con-

tributive partner in the ﬁrst stage,

2) the adversary tests a client session without honest contribu-

tive partner in the second stage,

3) the tested session has an honest contributive partner part-

ner in the second stage.
The proof cases A and B are virtually identical to the re-
spective cases in the proof of part 1, though s is compromised
in this case.

Specially, the session key Eadk would be known the ad-
versary since it is not forward secure, and Test query to the
honest client for stage 1 should be prohibited to avoid trivial
attack which has been ruled in the deﬁnition of Corrupt query.
Then in case C, we will rely on the security of ES = gxy

for the privacy of tkhs, tkapp, RMS and EMS.

Case C: Test with Partner in stage 2

Firstly, we need to set the stkey of xSS, Eadk, mSS, FS

to revealed.
Game C.0. Same as Game C.0 in Part 1, therefore,
draft−10,A = Adv2−Key−Secrecy,test with partner

draft−10,A

AdvGC.0

.

504504

.

G

AdvGC.0

draft−10,A.

Game C.1. Same as Game C.1 in Part 1, and hence

From now on, we can speak of the session label(cid:2)(cid:2) partnered

draft−10,A ≤ ns.AdvGC.1
with the tested session label(cid:2) in stage 2.
Game C.2. Same as Game C.4 in Part 1,
the chal-
lenger aborts if the adversary makes a random oracle query
HKDF.Extract(0,gxy), and hence
draft−10,A ≤ AdvGC.2

draft−10,A + AdvGap−DH

AdvGC.1

AdvGC.2

HKDF.Expand.

tkhs and (cid:5)
mES, and hence
draft−10,A + AdvPRF−sec

Game C.3. Same as Game C.5 in Part 1, we replace tkhs,
mES derived in both the tested and its partnered session by a
uniformly random value (cid:5)
draft−10,A ≤ AdvGC.3
Game C.4. Same as Game C.6 in Part 1, we replace MS
derived in both the tested and its partnered session by a
uniformly random value (cid:6)
MS. The only difference that now
during the computation of MS = HKDF.Extract(mSS,mES)
only mES has been replaced by a random (cid:5)
mES, however,
without affecting the PRF property of HKDF.Extract. Hence
draft−10,A + AdvPRF−sec

draft−10,A ≤ AdvGC.4

Game C.5. Same as Game C.7 in Part 1, we replace tkapp,
RMS, and EMS derived in both the tested and its partnered
session by a uniformly random value (cid:3)tkapp, (cid:3)RMS, and (cid:3)EMS.
Hence,

HKDF.Extract.

AdvGC.3

draft−10,A ≤ AdvGC.5

draft−10,A + AdvPRF−sec

HKDF.Expand.

In Game C.5., the session keys as well as the resumption
and exporter master secrets are now chosen independently and
uniformly at random. As the response to its Test query is
hence independent of the test bit btest, the adversary A cannot
distinguish whether it is given the real key or random values
and thus AdvGC.5

draft−10,A = 0.

Above all, in the case of s is compromised after 0-RTT
has been completed, 0-RTT is secure against Key Secrecy,
however, the application data on the ﬁrst ﬂight will be public
to the adversary if there is application data to be transferred
during the ﬁrst ﬂight.

AdvGC.4

Note that

the privacy property of the early application
data transmitted on the ﬁrst ﬂight can be guaranteed by the
randomness of Eadk, and this property has been implied
implicitly in the deﬁnition of Key Secrecy which guarantees
the randomness of the key in each stage including Eadk.

Combining the various bounds implied by the above
sequence of game transitions yields the stated security
bound.

B. Preliminaries and Deﬁnitions
B.1 The Decisional Difﬁe-Hellman Assumption (DDH)

Let G be a group of prime order q and g be a generator
the experiment ExpDDH(A) associated
of G. Consider
with an adversary A and security parameter λ. A is given
for a, b, c ∈ Zq. The decisional Difﬁe-
(g, q, gc, ga, gb)
Hellman(DDH) assumption means that it is hard to decide
whether c = ab mod q. Formally, ExpDDH(A) returns 1
iff A can successfully decide whether c = ab mod q. We
= Pr [ExpDDH(A) = 1]. We say that the DDH
deﬁne AdvDDH
problem is hard if AdvDDH
is negligible in λ, for all efﬁcient

G

G

505505

adversaries A.

B.2 The Gap Difﬁe-Hellman Assumption(Gap-DH)
Let G be a group of prime order q and g be a generator
of G. Consider the experiment ExpGap−DH(A) associated
with an adversary A and security parameter λ. A is given
(g, q, ga, gb) for a, b are picked uniformly at random from
Zq. A is also given access to a DDH veriﬁcation oracle
V(g, ga, ., .), which returns 1 iff queried on gx, gax for some
x ∈ Zq. ExpGap−DH(A) returns 1 iff A outputs gab. We
= Pr [ExpGap−DH(A) = 1]. We say that
deﬁne AdvGap−DH
Gap-DH problem is hard if AdvGap−DH
is negligible in λ, for
all efﬁcient adversaries A.

G

G

B.3 Digital Signature Schemes

To deﬁne security consider the experiment ExpEUF−CMA

A digital signature scheme is a triple Sig = (Kg,Sign,Ver),
$←− Kg(λ)
consisting of a key generation algorithm (pk, sk)
$←−
where λ is the security parameter, signing algorithm σ
Sign(sk, m) generating a signature for message m, and ver-
iﬁcation algorithm Ver(pk, σ, m) returning 1, if σ is a valid
signature for m under the key pk, and 0 otherwise.
(A)
associated with an adversary A. First, a pair of keys is
$←− Kg(λ). Then A is given pk, the oracle
generated: (pk, sk)
Sign(sk, .), and it has to output a message and a forgery:
$←− ASign(sk,.)(pk). The adversary wins and the
(m, σ)
experiment returns 1 iff Ver(pk, σ, m) returns 1 and m was
never queried to Sign(sk, .) oracle. We say that Sig is secure
against existential forgeries under adaptive chosen-message
(A)
attacks (EUF-CMA) if AdvEUF−CMA
= 1] is negligible in λ, for all efﬁcient algorithm A.

= Pr [ExpEUF−CMA

Sig

Sig

Sig

B.4 Pseudo-Random Functions (PRF)

PRF

Consider the experiment ExpPRF−sec

A pseudo-random function PRF is a deterministic function
z = PRF(k, x), taking as input a key k and some bit string x,
and returning a string z.
(A) associated with
an adversary A. First, the challenger samples k uniformly
random. Then A is given the oracle PRF(k, .) for arbitrary
values x and obtain the corresponding z. Eventually, A
outputs value x that was never queried to PRF(k, .). The
challenger sets z0 = PRF(k, x) and samples z1 uniformly
$←− {0, 1} and returns zb to
random. Then it tosses a coin b
the adversary. Finally, A outputs a guess b
(cid:2). The adversary
(cid:2). We say that
wins and the experiment returns 1 iff b = b
PRF is a secure pseudo-random function if AdvPRF−sec
= Pr
(A) = 1] is negligible for all efﬁcient algorithm A.
[ExpPRF−sec

PRF

PRF

Consider the experiment ExpCOLL

B.5 Collision-resistant Hash Functions
adversary A. ExpCOLL
m and m
that a hash function H is collision resistant, if AdvCOLL
[ExpCOLL

(A) associated with an
(A) returns 1 iff A outputs two strings
(cid:2), such that m (cid:9)= m
). We say
= Pr
(A) = 1] is negligible for all efﬁcient algorithm A.

(cid:2) and H(m) = H(m

H

H

H

(cid:2)

H

