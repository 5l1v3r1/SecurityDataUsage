Multi-Stage Key Exchange

and the Case of Google’s QUIC Protocol

Cryptoplexity, Technische Universität Darmstadt

Cryptoplexity, Technische Universität Darmstadt

Marc Fischlin

Felix Günther

Darmstadt, Germany

marc.ﬁschlin@cryptoplexity.de

Darmstadt, Germany

guenther@cs.tu-darmstadt.de

ABSTRACT
The traditional approach to build a secure connection is to
run a key exchange protocol and, once the key has been
established, to use this key afterwards in a secure channel
protocol. The security of key exchange and channel proto-
cols, and to some extent also of the composition of both,
has been scrutinized extensively in the literature. However,
this approach usually falls short of capturing some key ex-
change protocols in which, due to practical motivation, the
originally separated phases become intertwined and keys are
established continuously. Two prominent examples of such
protocols are TLS (with resumption), and Google’s recently
proposed low-latency protocol QUIC.

In this work we revisit the previous security of model of
Brzuska et al. (CCS’11) and expand it into a multi-stage
key exchange model in the style of Bellare and Rogaway. In
our model, parties can establish multiple keys in diﬀerent
stages and use these keys between stages, even to establish
the next key. The advantage of using the formalization of
Brzuska et al. is that it has been designed with the aim to
provide compositional guarantees. Hence, we can, too, give
suﬃcient conditions under which multi-stage key exchange
protocols compose securely with any symmetric-key appli-
cation protocol, like a secure channel protocol.

We then exercise our model for the case of the QUIC pro-
tocol. Basically, we show that QUIC is an adequately secure
multi-stage key exchange protocol and meets the suggested
security properties of the designers. We continue by propos-
ing some slight changes to QUIC to make it more amenable
to our composition result and to allow reasoning about its
security as a combined connection establishment protocol
when composed with a secure channel protocol.

Categories and Subject Descriptors
F.0 [Theory of Computation]: General

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’14, November 3–7, 2014, Scottsdale, Arizona, USA.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-2957-6/14/11 ...$15.00.
http://dx.doi.org/10.1145/2660267.2660308.

General Terms
Security, Theory

Keywords
Key exchange; Bellare–Rogaway; composition; protocol anal-
ysis; QUIC

1.

INTRODUCTION

The classical deployment of authenticated key exchange
(AKE) protocols is to establish a secure key between two
parties and subsequently use this key to secure the actual
communication. From a security point of view this is often
connected with the understanding that the key exchange
step is executed once, at the beginning, and ceases as soon
as the key is established. The only information passed to
the following protocol ﬂow is a cryptographically strong key,
usually speciﬁed to look random to any adversary [1].

Practical needs, however, seem to impose a more ﬂexible
use of key exchange protocols by rather viewing the key es-
tablishing as a continuous process which can be arbitrarily
interleaved with the use of the key. Two prominent exam-
ples are SSL/TLS [11] and the recently introduced QUIC
protocol of Google [22].
In case of SSL/TLS, in the re-
sumption step of an already established session, the client
and the server generate a fresh session key from the master
secret. This master secret has been created in the initial
(full) handshake protocol execution and used to derive keys
for the record layer. Session resumption has been added to
SSL/TLS for eﬃciency reasons, in order to be able to skip
the more expensive public key operations.

Google’s recently proposed protocol QUIC (for “Quick
UDP Internet Connections”) is a Diﬃe-Hellman based con-
nection establishment protocol. It also aims at eﬃciency im-
provements, but focuses on reducing the round complexity
of the interactions. It starts with the client being able to de-
liver data to the server immediately—i.e., with zero round-
trip time (RTT), protected under an intermediate crypto-
graphic key. At some point, the server replies with its con-
tribution to the key exchange. Both parties then switch to
a stronger key and continue the interaction with that key.
The basic version of the protocol is displayed in Figure 1.
1.1 Multi-Stage Key Exchange

Both examples, SSL/TLS and QUIC, reveal that current
single-stage AKE models are inappropriate to capture de-
sirable construction strategies. For one, they do not allow
mixing key exchange steps with the channel protocol. Sec-

1193Client C

server’s static public key pkS

generate ephemeral key pair eskC, epkC

compute K1 = DH(eskC, pkS )

compute K2 = DH(eskC, epkS )

Server S

skS

compute K1 = DH(epkC, skS )

generate ephemeral key pair eskS , epkS

compute K2 = DH(epkC, eskS )

epkC

{data}K1
{epkS}K1
{data}K2

Figure 1: High-level protocol run description of Google’s QUIC with 0-RTT handshake.

ond, they do not consider key exchange steps in which keys
with increasing strengths are gradually derived and used in
between, possibly to derive the next key. The latter also
implies that one cannot simply view the stages as runs of
independent key exchange protocols, as, e.g., possible for
SSL/TLS renegotiation [13]. Hence, our goal here is to de-
ﬁne a suﬃciently rich model for multi-stage key exchange
protocols.

Our starting point will be the Bellare–Rogaway model, as
it is liberal enough to capture many protocols, but also pro-
vides reasonably strong security guarantees. We prudently
use the formalization in [5, 7], as we can then more eas-
ily argue about composability with arbitrary symmetric-key
protocols. A major diﬀerence with the single-stage case lies
in the dependencies of the diﬀerent stages. In QUIC, for in-
stance, the ﬁnal key is protected under the stage-one key by
sending the server’s ephemeral Diﬃe-Hellman key through
a secure channel. This example indicates that we need to
carefully devise and motivate when session keys should be
considered fresh (and thus indistinguishable from random)
in the sense that they are not trivially available to the ad-
versary. We also give deﬁnitions for both unilaterally and
mutually authenticated key exchange protocols to capture
cases like SSL/TLS and QUIC in which only the server au-
thenticates.

Another important point is the interplay of key exchange
steps with protocol steps using the keys. A viable strat-
egy, which is also used in QUIC, seems to be to run later
key exchange phases through channels secured by previous
keys, where the channel protocol is identical to the applica-
tion protocol (and is even based on the same session key).
This potentially introduces formal, yet somewhat contrived
vulnerabilities when both protocols are composed. We call
protocols like QUIC in which keys of some stage are used to
derive the next key session-key dependent (or simply: key
dependent), whereas protocols in which knowledge of the
session key alone does not endanger the security of the subse-
quent key are called (session-)key independent. An example
of a key-independent protocol is SSL/TLS with resumption,
as the session keys in all stages are derived from the master
secret in such a way that knowing some session keys but not
the master secret does not help to compute another session
key.

1.2 Composition

Providing compositional guarantees (as in the Bellare–
Rogaway model with session matching [7]) is one of addi-
tional goals here. It turns out that our notion of key inde-
pendence is a crucial aspect to give a general composition
result of multi-stage key exchange steps with symmetric-
key based application protocols like secure channels. We
prove that any multi-stage authenticated key exchange pro-

tocol, which is key-independent and forward-secure, can be
securely composed with any secure symmetric-key protocol.
Superﬁcially, the key-independence requirement for com-
position seems to be related to the insecurity of the SSL/TLS
handshake protocol in the Bellare–Rogaway model, due to
usage of the session key in the ﬁnished message. However,
SSL/TLS is not a secure (single-stage) key exchange pro-
tocol, independently of the question of composition.1
In
contrast, a multi-stage protocol should explicitly allow to
use a key to derive the next keys. In this sense, the model
should declare such protocols as secure; it is rather the “bad”
interplay with the application protocol we need to take care
of when proving our composition theorem.
1.3 Analysis of QUIC

The “test case” for our model will be Google’s QUIC proto-
col. This protocol is simpler than SSL/TLS and we are not
aware of any previous evaluations about its cryptographic
strength.2 Investigating QUIC also avoids the need to deal
with the problem of key deployment for the ﬁnished message,
which often leads researchers to use alternative approaches
for security analyses [14, 16, 6]. We show that QUIC is a
secure key exchange protocol, assuming idealized key deriva-
tion via random oracles, the Gap Diﬃe-Hellman assumption
[21], and use of a secure channel. Here we distinguish be-
tween the keys of the two stages, showing that the stage-one
key provides basic security, whereas the stage-two key even
yields forward security.

Note that our result about QUIC being a secure key ex-
change protocol shows that the protocol, as is, does not show
any weakness, although the security bounds are far from be-
ing tight. Ideally, though, we would like to argue that QUIC,
together with a secure channel protocol, provides a fully se-
cure connection. This is where the compositional properties
of our model and the composition result come into play. Re-
call that this result requires the key exchange protocol to be
(session-)key independent and forward-secure. Therefore,
we ﬁrst propose a slight modiﬁcation of QUIC to turn it
into a key-independent protocol, following the same idea as
in SSL/TLS resumption. We then can conclude that compo-
sitional security with any symmetric-key protocol using the
forward-secure second-stage session key is indeed achieved
by the modiﬁed version of QUIC.

In summary, our results show that QUIC can be analyzed
as a multi-stage key exchange protocol. It shows strong se-
curity properties, despite its low complexity. In particular,
the trade-oﬀ between 0-RTT performance and forward se-

1The Bellare–Rogaway model has been designed with com-
positional guarantees in mind, of course, but the problem
with SSL/TLS already appears when considered as a stand-
alone key exchange protocol.
2In an independent and concurrent work, Boldyreva et al. [3]
also investigated the security of QUIC.

1194curity is only one round trip which is indeed optimal. Still,
as we discuss, with little eﬀort QUIC can be strengthened
further to facilitate the compositional analysis.

2. MULTI-STAGE KEY EXCHANGE

We model security of multi-stage key exchange protocols
along the lines of the seminal paper of Bellare and Rog-
away [1]. The formalization of our notions is inspired by the
notation used by Brzuska et al. [5, 7].
2.1 Overview

Before diving into the technical details,

let us provide
an overview, especially about changes originating from the
multi-stage setting, and some motivation. The previous
single-stage model in [5, 7] kept lists of session information,
including values stexec about the state (accepted, running, or
rejected), the session key K, the status stkey of the key (fresh
or revealed), and a session identiﬁer sid. Here, we basically
take care of multiplicity by storing vectors of these entries
and a variable stage describing the stage a session is in.

As in the basic setting, the adversary can interact with
sessions via oracle queries NewSession, Send, Reveal, Corrupt,
and Test in order to initiate a new session, send messages
to that session, reveal the session key, corrupt the long-term
secret key of a party, and test a session key against a random
key, respectively. We note that we do not cover session-
state leakage in our model, as in the CK model [8] or in the
extended CK model [18]. One can augment our model with
such queries, though.

One diﬀerence in our model, owed to the fact that an
execution can continue after some session has accepted and
derived an intermediate key which can be potentially tested,
is that after acceptance the reply to such a Send command is
delayed. Also, in case of testing a session key and returning
the genuine or a random key to the adversary, we let the
subsequent key exchange step—which may now depend on
this session key in the multi-stage setting—use the genuine
or the random key. Otherwise, distinguishing the session
keys from random might be trivial.

Another diﬀerence, motivated by QUIC, is the introduc-
tion of so-called temporary keys. These keys are somewhat
in between ephemeral keys and static keys. QUIC suggests
to let the server use the short-term key in the second stage in
multiple sessions. The description [19] speaks of a life span
of about 60 seconds in which the same key is used in every
session of this server. Hence, temporary keys, analogous to
static keys, are not bound to a single session. At the same
time, they are too transient to be susceptible to cryptana-
lytic attacks, such that we do not reveal these key in case
of a Corrupt query. In the model, to avoid introduction of
timing events, we let the adversary decide when the parties
should switch to a new temporary key via a NewTempKey
command. We however stress that the NewTempKey query
can be omitted for analyses of protocols that do not comprise
temporary keys without aﬀecting our compositional results.
We also make the usual distinction between non–forward
security and forward security, where the latter protects ses-
sions that accepted before corruption took place.
In our
multi-stage setting, session keys can become forward-secure
starting from a certain stage on, such that we introduce the
notion of stage-j forward security. We also diﬀerentiate be-
tween (session-)key-dependent and (session-)key-independent
multi-stage protocols. The diﬀerence is basically that, for

key-dependent schemes, the session key of stage i is used to
derive the session key of stage i + 1, typically to enhance the
security properties of the session keys. QUIC is an example
of such a protocol. This property directly aﬀects the ad-
versary’s capabilities in the sense that we cannot allow the
adversary to reveal the session key of stage i before the key
of stage i + 1 is established. For key-independent protocols,
exposure of the preceding session key, in contrast, does not
weaken the next session key (e.g., SSL/TLS with resumption
is key-independent, as new keys are derived freshly from the
previous master secret, not from the previous session key).3
in order to be able to reason about protocols
where only one participant in a session is authenticated, our
model captures both unilateral as well as mutual authenti-
cation of participants.

Finally,

As in [5, 7], we model security according to two games,
one for key indistinguishability, and one for matching. The
former is the classical notion of random-looking keys, re-
ﬁned according to key (in)dependence, (stage-j-)forward se-
curity, and unilateral or mutual authentication. The Match-
property gives straightforward security guarantees, such as
identical keys in partnered sessions, authenticity of the part-
ner, and collision-freeness of session identiﬁers.
2.2 Preliminaries
We denote by U the set of identities used to model the
participants in the system, each identiﬁed by some U ∈ U
and associated with a long-term public key pkU and corre-
sponding secret key skU . Sessions of a protocol are uniquely
identiﬁed (on the administrative level of the model) using a
label label ∈ LABELS = U × U × N, where (U, V, k) indicates
the k-th local session of identity U (the session owner ) with
V as the intended communication partner.

For each session, a tuple with the following information is
maintained as an entry in the session list ListS, where val-
ues in square brackets indicate the respective default/initial
value:

• label ∈ LABELS: the (administrative) session label
• U ∈ U: the session owner
• V ∈ U : the communication partner
• role ∈ {initiator, responder}: the session owner’s role in

this session (initiator or responder)

• kidU : the key identiﬁer of the session owner (see below)
• kidV : the key identiﬁer of the communication partner
• stexec ∈ (RUNNING ∪ ACCEPTED ∪ REJECTED): the
state of execution [running0], where RUNNING =
{runningi | i ∈ N0}, ACCEPTED = {acceptedi | i ∈ N},
REJECTED = {rejectedi | i ∈ N}

• stage ∈ {0, . . . , M}: the current stage [0], where M
is the maximum stage4 and stage is incremented to i
when stexec reaches acceptedi resp. rejectedi

3One could even go further and consider key dependence
with respect to each stage individually. We do not do so in
order to keep the model simpler.
4We ﬁx a maximum stage M only for ease of notation. Note
that M can be arbitrary large in order to cover protocols
where the number of stages is not bounded a priori.

1195• sid ∈ ({0, 1}∗ ∪ {⊥})M: the session identiﬁers [(⊥)M],
where sidi indicates the session identiﬁer in stage i (cid:54)= 0

• K ∈ ({0, 1}∗ ∪ {⊥})M:

the established session keys
[(⊥)M], where Ki indicates the established session key
in stage i (cid:54)= 0

• stkey ∈ {fresh, revealed}M: the states of the session keys
[(fresh)M], where stkey,i indicates the state of the session
key in stage i (cid:54)= 0

• tested ∈ {true, false}M:

the test indicator [(false)M],

where testedi = true means that Ki has been tested

By convention, if we add a partly speciﬁed tuple (label, U, V,
role, kidU , kidV ) to ListS, then the other tuple entries are set
to their default value.

We identify key material used to interact within one or
several protocol executions by some unique, administrative
key identiﬁer kid, pointing to some entry in the key list ListK,
where the following associated information is stored:

• kid: the key identiﬁer
• U ∈ U: the identity associated with this key
• tpk: a temporary public key
• tsk: the corresponding temporary secret key

As labels and key identiﬁers are unique, we write as a
shorthand label.sid for the element sid in the tuple with label
label in ListS, and kid.tpk for the element tpk in the tuple with
key identiﬁer kid in ListK.
2.3 Adversary Model
We consider a probabilistic polynomial-time (PPT) adver-
sary A which controls the communication between all parties
involved, including interception, injection, and dropping of
messages. Moreover, as illustrated earlier, we distinguish
diﬀerent levels of the following three (orthogonal) security
aspects of a multi-stage key exchange scheme: key depen-
dence, forward security, and authentication unilateralism.

Key Dependence.

We distinguish key-dependent and key-independent pro-
tocols, where key dependence means that the session key
Ki+1 of some stage i + 1 depends on the session key Ki of
the previous stage i in a way that disclosure of Ki before
Ki+1 has been established compromises the latter. As men-
tioned earlier, Google’s QUIC protocol is an example of a
key-dependent scheme, whereas SSL/TLS with resumption
is key independent.

We reﬂect key dependence in our model by restricting the
disclosure of the current stage’s session key via Reveal queries
in the case of key-dependent security. Note that we however
allow compromises of a session key Ki after key Ki+1 of the
next stage has been established—even in combination with
simultaneous attacks (i.e., testing) on Ki+1. This models
the intuitive requirement that session keys in a multi-stage
key exchange can (or often should) become stronger with in-
creasing stage. In particular, Ki+1 should not depend triv-
ially on Ki as, e.g., in Ki+1 = Hash(Ki). We require that
in fact Ki+1 is still indistinguishable from random given the
revealed previous session key Ki or even all preceding session
keys Kj with j ≤ i.

Forward Security.

The well-established notion of forward security requires
that established (i.e., accepted) session keys remain secure
even if the long-term secrets are exposed. Classical for-
ward security is a binary notion: a single-stage key exchange
scheme can be either forward-secure or non-forward-secure.
In the setting of multi-stage key exchange, however, a proto-
col might achieve forward security only from a certain stage
onwards, i.e., session keys in lower stages become insecure
on exposure of long-term keys while keys of this stage (and
higher stages) remain secure.

Therefore, we diﬀerentiate in our model between non-
forward-secure and stage-j-forward-secure protocols, where
stage-j forward security indicates that session keys Ki estab-
lished at some stage i ≥ j remain secure when the involved
long-term secrets get exposed, whereas keys at stages i < j
become insecure.

Unilateral Authentication.

In order to capture key exchange protocols where only
one side is authenticated (as, e.g., in Google’s QUIC), we
apply the concept of distinguishing unilateral authentication
and mutual authentication in protocols, where the former
only authenticates one party, in our case the responder, and
the latter authenticates both communication partners. As a
consequence, in the unilateral case where only the respon-
der authenticates, we mainly aim for secrecy of session keys
of the initiator, or of the responder if it communicates with
an honest party and the adversary merely observes the in-
teraction. Since the adversary can trivially impersonate the
unauthenticated party, we cannot hope for key secrecy on
the responder’s side beyond that.

Adversarial Interaction.

The adversary interacts with the protocol via the following

queries:

• NewSession(U, V, role, kidU , kidV ): Creates a new ses-
sion for participant identity U with role role and key
identiﬁer kidU having V with key identiﬁer kidV as in-
tended partner.

If there is no tuple with key identiﬁer kidU or no tuple
with identiﬁer kidV in ListK, return an error symbol
⊥. Otherwise, generate a new label label and add the
entry (label, U, V, role, kidU , kidV ) to ListS.

• Send(label, m): Sends a message m to the session with

label label.

If there is no tuple (label, U, V, role, kidU , kidV , stexec,
stage, sid, K, stkey, tested) in ListS, return ⊥. Otherwise,
run the protocol on behalf of U on message m and
provide the adversary with the response and the up-
dated state of execution stexec. As a special case, if
role = initiator and m = init, the protocol is initiated
(without any input message).

If, during the protocol execution, the state of execution
changes to acceptedi for some i, the protocol execution
is immediately suspended and acceptedi is returned as
result to the adversary. The adversary can later trigger
the resumption of the protocol execution by issuing a
special Send(label, continue) query. For such a query,
the protocol continues as speciﬁed, with the party cre-
ating the next protocol message and handing it over

1196to the adversary together with the resulting state of
execution stexec. We note that this is necessary to al-
low the adversary to test such a key, before it may be
used immediately in the response and thus cannot be
tested anymore for trivial reasons.
If the state of execution changes to stexec = acceptedi
for some i and there is a tuple (label(cid:48), V, U, role(cid:48), kidV ,
kidU , st(cid:48)
sid(cid:48)
key,i = revealed, then, for key-independent
security, stkey,i is set to revealed as well, whereas for
key-dependent security, all stkey,i(cid:48) for i(cid:48) ≥ i are set to
revealed.

exec, stage(cid:48), sid(cid:48), K(cid:48), st(cid:48)

i and st(cid:48)

key, tested(cid:48)) in ListS with sidi =

• NewTempKey(U ): Generate a new temporary key pair
(tpk, tsk), add the entry (kid, U, tpk, tsk) to ListK, and
return kid.

Note that we do not invalidate old key identiﬁers of
the same identity U (as protocols would presumably
do), but keep the model instead as general as possible
at this point, especially since active protocol runs may
still rely on the previous keys.

• Reveal(label, i): Reveals the session key of stage i in

the session with label label.

If there is no tuple (label, U, V, role, kidU , kidV , stexec,
stage, sid, K, stkey, tested) in ListS, i > stage, or testedi =
true, return ⊥. Otherwise, set stkey,i to revealed and
provide the adversary with Ki.
If there is a tuple (label(cid:48), V, U, role(cid:48), kidV , kidU , st(cid:48)
exec,
stage(cid:48), sid(cid:48), K(cid:48), st(cid:48)
key, tested(cid:48)) in ListS with sidi = sid(cid:48)
i and
stage(cid:48) ≥ i, then st(cid:48)
key,i is set to revealed as well. This
means that the i-th session keys of all partnered ses-
sions (if already established) are considered revealed
as well.

In the case of key-dependent security, since future keys
depend on the revealed key, we cannot ensure their
security anymore (neither in this session in question,
nor in partnered sessions). Therefore, if i = stage,
set stkey,j = revealed for all j > i, as they depend on
the revealed key. For the same reason, if a partnered
session label(cid:48) with sidi = sid(cid:48)
i has stage(cid:48) = i, then set
st(cid:48)
key,j = revealed for all j > i.

• Corrupt(U ): Provide (skU , pkU ) to the adversary. No

further queries are allowed to sessions owned by U .

In the non-forward-secure case, for all sessions (label,
U, V, role, kidU , kidV , stexec, stage, sid, K, stkey, tested) and
all i ∈ {1, . . . , M}, set stkey,i to revealed. In this case,
all (previous and future) session keys are considered to
be disclosed.
In the case of stage-j forward security, stkey,i is set
to revealed only if i < j or if i > stage. This means
that sessions keys before the j-th stage (where forward
security kicks in) as well as keys that have not yet been
established are potentially disclosed.

Independent of the forward security aspect, in the case
of key-dependent security, setting the relevant key states
to revealed for some stage i is done by internally invok-
ing Reveal(label, i), ignoring the response as well as the
call restriction for i > stage. This ensures that follow-
up revocations of keys that depend on the revoked keys
are carried out correctly.

Note that we do not reﬂect leakage of temporary keys
here, which can be considered a possible extension of
our model. Concerning QUIC, though, disclosure of
the temporary keys indeed exposes all ephemeral key
material and thus trivially renders forward security un-
achievable.

• Test(label, i): Tests the session key of stage i in the

session with label label.

If there is no tuple (label, U, V, role, kidU , kidV , stexec,
stage, sid, K, stkey, tested) in ListS, label.stexec (cid:54)= acceptedi,
or label.testedi = true, return ⊥.
In the case of unilateral authentication, if label.role =
responder and there is no tuple (label(cid:48), V, U, role(cid:48), kidV ,
kidU , st(cid:48)
i and role(cid:48) = initiator, return ⊥. This means the
sid(cid:48)
adversary is not allowed to test responder (i.e., au-
thenticated) sessions that do not communicate with a
genuine initiator.

key, tested(cid:48)) in ListS with sidi =

exec, stage(cid:48), sid(cid:48), K(cid:48), st(cid:48)

Otherwise, set label.testedi to true. If the test bit btest
$←D at random, where D is the
is 0, sample label.Ki
session key distribution. This means that we substi-
tute the session key by a random and independent key
which is also used for future deployments within the
key exchange protocol. Return label.Ki.

2.4 Security of Multi-Stage Key Exchange

Protocols

We are now ready to state our security notions.
2.4.1 Match-Security
Following the approach of Brzuska et al. [7, 5] we split the
(security) requirements of matching sessions and Bellare–
Rogaway-like key secrecy into two games. Here, Match-
security ensures that the session identiﬁers sid eﬀectively
match the partnered sessions in the sense that

1. sessions with the same identiﬁer for some stage hold

the same key at that stage,

2. sessions are partnered with the intended (authenti-

cated) participant, and

3. at most two sessions have the same session identiﬁer

at any stage.

The Match-security game GMatch

KE,A thus is deﬁned as follows.

Definition 2.1

(Match-security). Let KE be a key ex-
change protocol and A a PPT adversary interacting with KE
via the queries deﬁned in Section 2.3 within the following
game GMatch
KE,A :

Setup. The challenger generates long-term public/private-

key pairs for each participant U ∈ U .

Query. The adversary A receives the generated public keys

and has access to the queries NewSession, Send,
NewTempKey, Reveal, and Corrupt.

Stop. At some point, the adversary stops with no output.
We say that A wins the game, denoted by GMatch
least one of the following conditions hold:

KE,A = 1, if at

1197KI,1-FS,M

KI,2-FS,M

KI,M-FS,M

KI,NFS,M

KI,1-FS,U

KI,2-FS,U

KI,M-FS,U

KI,NFS,U

KD,1-FS,M

KD,2-FS,M

KD,M-FS,M

KD,NFS,M

KD,1-FS,U

KD,2-FS,U

KD,M-FS,U

KD,NFS,U

Figure 2: Hierarchy of the Multi-Stage security ﬂavors key-independent (KI) and key-dependent (KD), stage-n-forward-secure
(n-FS) and non-forward-secure (NFS), as well as mutual authentication (M) and unilateral authentication (U) for a multi-stage
key exchange protocol with M stages. A solid arrow from A to B denotes that A implies B, the dotted arrows indicates that
intermediate ﬂavors are omitted.

1. There exist two distinct labels label, label(cid:48) and some
stage i ∈ {1, . . . , M} such that label.sidi = label(cid:48).sidi (cid:54)=
⊥, label.stage ≥ i, label(cid:48).stage ≥ i, label.stexec (cid:54)= rejectedi,
and label(cid:48).stexec (cid:54)= rejectedi, but label.Ki (cid:54)= label(cid:48).Ki.
(Distinct accepted session keys in some stage of part-
nered sessions.)

2. There exist two distinct labels label, label(cid:48) such that
label.sidi = label(cid:48).sidj (cid:54)= ⊥ for some stages i, j ∈ {1, . . . ,
M}, label.role = initiator, and label(cid:48).role = responder,
but label.V (cid:54)= label(cid:48).U or (only in the case of mutual
authentication) label.U (cid:54)= label(cid:48).V . (Distinct intended
authenticated responder.)

3. There exist at least three distinct labels label, label(cid:48),
label(cid:48)(cid:48) with label.sidi = label(cid:48).sidj = label(cid:48)(cid:48).sidk (cid:54)= ⊥
for some stages i, j, k ∈ {1, . . . , M}. (More than two
sessions share the same session identiﬁer.)

We say KE is Match-secure (with unilateral resp. mutual
authentication) if for all PPT adversaries A the following
advantage function is negligible in the security parameter:

(cid:104)

(cid:105)

AdvMatch

KE,A := Pr

GMatch

KE,A = 1

.

Note that we sometimes specify the notion of unilateral
security by speaking of initiator-authenticated or responder-
authenticated unilateral security.
2.4.2 Multi-Stage Security
The Multi-Stage security game GMulti-Stage,D

, which ensures

KE,A

Bellare–Rogaway-like key secrecy, is deﬁned as follows.

Definition 2.2

(Multi-Stage security). Let KE be a
key exchange protocol and A a PPT adversary interacting
with KE via the queries deﬁned in Section 2.3 within the
, where D is the distribution from
following game GMulti-Stage,D
which random keys are chosen in Test queries:

KE,A

Setup. The challenger generates long-term public/private-
key pairs for each participant U ∈ U and chooses the
test bit btest

$←{0, 1} at random.

Query. The adversary A receives the generated public keys

and has access to the queries NewSession, Send,
NewTempKey, Reveal, Corrupt, and Test.

Guess. At some point, the adversary stops and outputs a

guess b.

We say that A wins the game, denoted by GMulti-Stage,D
if all of the following conditions hold:

KE,A

= 1,

1. b = btest.

2. There do not exist two (not necessarily distinct) la-
bels label, label(cid:48) and some stage i ∈ {1, . . . , M} such
that label.sidi = label(cid:48).sidi, label.stkey,i = revealed, and
label(cid:48).testedi = true.
(Adversary has tested and re-
vealed the key in a single or two partnered sessions.)

Note that the winning conditions are independent of the key
dependency, forward security, and authentication properties
of KE, as they are directly integrated in the aﬀected (Reveal,
Corrupt, resp. Test) queries.

We say KE is Multi-Stage-secure in a key-dependent resp.

key-independent and non-forward-secure resp. stage-j-forward-
secure manner and with unilateral resp. mutual authentica-
tion if KE is Match-secure and for all PPT adversaries A
the following advantage function is negligible in the security
parameter:

AdvMulti-Stage,D

KE,A

:=

GMulti-Stage,D
KE,A

= 1

(cid:104)

(cid:12)(cid:12)(cid:12)(cid:12)Pr

(cid:105) − 1

2

(cid:12)(cid:12)(cid:12)(cid:12) .

We notice that the diﬀerent ﬂavors of Multi-Stage secu-
rity that a multi-stage key exchange protocol with M stages
can provide form an ordered hierarchy (according to their
strength) as depicted in Figure 2, where key-independent
stage-1-forward-security with mutual authentication is the
strongest and key-dependent non-forward-security with uni-
lateral authentication is the weakest notion.

3. COMPOSITION

Ideally, one would like to see a composition result for
Multi-Stage-secure key exchange protocols in the sense that
such protocols—potentially under some condition—can be
securely composed with arbitrary symmetric-key protocols,
as is the case with Bellare–Rogaway-secure key exchange
protocols [7]. In this section, we prove that indeed secure
composition with arbitrary symmetric-key protocols is pos-
sible for a speciﬁc ﬂavor of Multi-Stage-secure protocols,
namely those that provide key independence and stage-j-
forward-security, when composed with a symmetric-key pro-
tocol at a forward-secure stage. Unfortunately however,
for key-dependent or non-forward-secure multi-stage key ex-
change protocols, such a generic composition result seems
hard to achieve or even impossible.

Moreover, the authentication property of the multi-stage
key exchange inﬂuences the security guarantees our compo-
sition result is able to provide. While mutual authentica-
tion yields security for an unrestricted composition with a

1198symmetric-key protocol, in the case of unilateral authenti-
cation, security can only be guaranteed if the composition
with the symmetric-key protocol is not applied in the triv-
ial attack scenario, where the adversary impersonates the
unauthenticated initiator in the key exchange phase. We
state our composition result in terms of mutual authentica-
tion, and discuss afterwards how (and why) it extends to
the unilateral case.
3.1 Preliminaries

In order to reason about composition of key exchange and
symmetric-key protocol games, we employ the syntax for
composed games (adapted to the multi-stage setting) as well
as the notion of session matching introduced by Brzuska et
al. [7, 5], which we brieﬂy summarize in the following.

Composed Games for Multi-Stage Key Exchange.

Let GKE be a game modeling security for a (multi-stage)
key exchange protocol KE and GΠ a security game for some
symmetric-key protocol Π, then GKEi;Π is deﬁned as the se-
curity game for the composition KEi; Π of KE and Π where,
for every accepted session key Ki in stage i of KE, an in-
stance of Π is run with this key. In GKEi;Π, the adversary’s
task is to break the security of Π given access to both the
queries of GKE and GΠ, which the composed game essen-
tially just relays to the appropriate subgame. Exceptions to
this are the key initialization queries of GΠ (that are only
executed by the composed game to initialize instances of Π
after a key has been established), the Reveal query of GKE
(which the adversary is not allowed to query for stage-i keys
in the composed game5, as session key compromise for these
keys is—if at all—captured in GΠ), and the Test query of
GKE (being only of administrative purpose for GKE). The
adversary wins in the composed game, if it, via its queries,
succeeds in the subgame GΠ.

Session Matching.

For composability, an additional property named session
matching is required. A key exchange protocol KE allows
for session matching, if there exists an eﬃcient algorithm
that, when eavesdropping on the communication between
an arbitrary adversary A and the security game GKE, is able
to deduce which sessions are partnered at each point of the
communication. We refer to Brzuska et al. [7] for deﬁnitional
details and that (some form of) session matching is in fact
necessary for arguing about compositional security.
3.2 Compositional Security

We are now able to state our composition result. Infor-
mally, a multi-stage key exchange protocol KE composes se-
curely with an arbitrary symmetric-key protocol Π using
the session keys of some stage i, if the key exchange is key-
independent and stage-j-forward-secure for j ≤ i with mu-
tual authentication and allows for an eﬃcient session match-
ing. We denote such a composed protocol as KEi; Π.

Theorem 3.1

(Multi-Stage Composition). Let KE
be a key-independent stage-j-forward-secure Multi-Stage-
secure key exchange protocol with mutual authentication, key
distribution D, and an eﬃcient session matching. Let Π be
a secure symmetric-key protocol w.r.t. some game GΠ with a
5Note however that keys in stages diﬀerent from i, not being
used for Π, are still accessible via Reveal queries in GKEi;Π.

key generation algorithm that outputs keys with distribution
D. Then the composition KEi; Π for i ≥ j is secure w.r.t.
the composed security game GKEi;Π and for any eﬃcient ad-
versary A we have
GKEi ;Π

KEi;Π,A ≤ ns · AdvMulti-Stage,D

for some eﬃcient algorithms B and C, where ns is the max-
imum number of sessions in the game GKEi;Π.

+ AdvGΠ
Π,C

KE,B

Adv

Proof of Theorem 3.1. The proof proceeds similar as
the one for composition of classical Bellare–Rogaway-secure
key exchange protocols given by Brzuska et al. [7]. First, we
gradually replace each session key derived in stage i of KE
by a randomly chosen value and show that, if an adversary
is able to distinguish this, we can break the Multi-Stage-
security of KE. Once all keys are replaced by random ones,
the composed game is actually independent of the key ex-
change protocol, thus breaking it is equivalent to breaking
the symmetric-key protocol Π directly.

For the ﬁrst part, a hybrid argument is applied. Let
Gλ
KEi;Π denote a game that behaves like GKEi;Π, except that
for the ﬁrst λ accepting sessions in stage i (where the part-
nered session has not yet accepted this stage), instead of the
$←D is used in
real session key stkey,i a randomly chosen st(cid:48)
key,i
the subsequent execution of Π. Obviously, G0
KEi;Π = GKEi;Π
while Gns
KEi;Π denotes the game where all keys for the Π
subgame are chosen at random from D. By application of
Lemma 3.2, we have that both games are indistinguishable
due to the Multi-Stage-security of KE and it holds that

(cid:12)(cid:12)(cid:12)(cid:12) ≤ ns · AdvMulti-Stage,D

KE,B

.

G0

KEi;Π,A − Adv

KEi ;Π

Gns
KEi ;Π
KEi;Π,A

(cid:12)(cid:12)(cid:12)(cid:12)Adv

As Gns

KEi;Π uses only randomly chosen keys which are com-
pletely independent of the ones derived in the key exchange
protocol, we can, by Lemma 3.3, bound the advantage of A
in Gns
KEi;Π by the advantage of an adversary in the security
game GΠ of Π. Since Π is assumed to be secure w.r.t. GΠ,
we can conclude that KE; Π is secure w.r.t. GKEi;Π.

The following lemma establishes the hybrid argument.

Lemma 3.2. Let KE be a key-independent stage-j-forward-
secure Multi-Stage-secure key exchange protocol with mutual
authentication, key distribution D, and an eﬃcient session
matching. Let Π be a symmetric-key protocol with a key
generation that outputs keys with distribution D. Then for
i ≥ j, all λ = 1, . . . , ns (where ns is the maximum number
of sessions in GKEi;Π) and any eﬃcient adversary A we have

(cid:12)(cid:12)(cid:12)(cid:12)Adv

Gλ−1
KEi;Π,A − Adv
KEi ;Π

Gλ
KEi ;Π
KEi;Π,A

for some eﬃcient algorithm B.

(cid:12)(cid:12)(cid:12)(cid:12) ≤ AdvMulti-Stage,D

KE,B

.

For simplicity we provide B with λ as auxiliary input. As
already noted in [7] letting B pick λ at random in the interval
[1, ns] suﬃces to prove the hybrid argument.

Proof of Lemma 3.2. We construct algorithm B using
the adversary A against GKEi;Π in such a way that, if A has
a non-negligible diﬀerence between the advantage in Gλ−1
KEi;Π, then B will have a non-negligible advantage in
and Gλ
GMulti-Stage,D
KE,B
When simulating GKEi;Π for A, algorithm B forwards most
KE-related queries to its game GMulti-Stage,D
while answering

KEi;Π

.

KE,B

1199KE,B

queries to the GΠ subgame on its own, using the stage-i
. To this extent, B keeps a
keys received from GMulti-Stage,D
list with all stage-i session keys in use, denoted as a mapping
SKEY : LABELS → D, in order to simulate the Π instances
using these keys. Additionally, B keeps a counter c, initial-
ized as c = 0, indicating the number of session keys replaced
by random values so far. Queries related to KE issued by A
are handled by B as follows:

KE,B

• NewSession, NewTempKey, Reveal, and Corrupt queries
are forwarded to GMulti-Stage,D
and the responses sent
back to A. Note that, as KE is stage-j-forward-secure
for j ≤ i, session keys in stage i are established in
a forward-secure manner and thus Corrupt queries do
not aﬀect the security of spawned Π instances at that
stage. Moreover, as KE is key-independent, Reveal(label,
(cid:54)= i in the composed
i(cid:48)) queries allowed for stages i(cid:48)
game at no time aﬀect the state of session keys in
stage i.

KE,B

• Send(label, m) queries are forwarded to GMulti-Stage,D

as
well and the responses sent back to A. Additionally, if
GMulti-Stage,D
changes to state acceptedi, the following
KE,B
steps are taken.
First, B checks whether label is partnered with some
other label label(cid:48). This is eﬃciently computable as KE
allows for an eﬃcient session matching. In case label
is partnered, SKEY(label) is set to SKEY(label(cid:48)) and
A provided with an identiﬁer for SKEY(label) in GΠ.
Here, the Match-security of KE ensures that whenever
two partnered sessions accept, the established keys are
identical with overwhelming probability.
If label is not partnered, B increases the counter value c
by 1 and provides A with an identiﬁer for SKEY(label)
in GΠ, where this value is computed depending on the
counter c:

– If c < λ, then sample SKEY(label) $←D at ran-

dom.

– If c = λ, then issue a Test(label, i) query and store

the resulting value in SKEY(label).

– If c > λ, then issue a Reveal(label, i) query and

store the resulting value in SKEY(label).

KE,B

in Deﬁnition 2.2.

Note that B checks for partnered sessions in stage i and
thus never tests revealed keys (and vice versa). In this way,
it obeys condition 2 of GMulti-Stage,D
Eventually, A terminates. Algorithm B then terminates
as well and outputs 1 if A has won in the composed game
and 0 otherwise. That way, if the Test query made by B
returns the real session key, B perfectly simulates Gλ−1
for A, whereas, if a random key is returned, B perfectly
KEi;Π. In the case that btest = 0 in GMulti-Stage,D
simulates Gλ
,
KE,B
B thus outputs the wrong bit with probability Adv
Gλ
KEi ;Π
KEi;Π,A
while, if btest = 1, B outputs the right bit with probability
Gλ−1
KEi ;Π
Adv
KEi;Π,A. Therefore, we can conclude that the advantage
of B in winning the game GMulti-Stage,D

KEi;Π

is

AdvMulti-Stage,D

KE,B

≥

(cid:12)(cid:12)(cid:12)(cid:12)Adv

KE,B
Gλ−1
KEi;Π,A − Adv
KEi ;Π

Gλ
KEi ;Π
KEi;Π,A

(cid:12)(cid:12)(cid:12)(cid:12) .

It remains to show how an adversary in the hybrid game
Gns
KEi;Π, where all session keys in the GΠ subgame are re-
placed by random ones, can be reduced to an adversary in
security game GΠ of the symmetric-key protocol.

Lemma 3.3. Let KE be a multi-stage key exchange proto-
col. Let Π be a symmetric-key protocol with a key generation
that outputs keys with distribution D. Let ns be the maxi-
mum number of sessions in GKEi;Π. Then for any eﬃcient
adversary A we have

Adv

Gns

KEi;Π,A ≤ AdvGΠ
Π,C

KEi ;Π

for some eﬃcient algorithm C.

Proof of Lemma 3.3. We let algorithm B simulate the
KEi;Π for A, computing the outputs
entire composed game Gns
of the key exchange subgame on its own while forwarding
any Π-related query to its own game GΠ. This is possible,
as the keys established in the key exchange stage are inde-
pendent of the protocol part and thus B is indeed able to
provide a perfect simulation for A. In the end, if A wins in
the simulated game, B will have won in its game GΠ as well,
establishing the desired equation.
Formally, B only has to handle Send queries to the key
exchange game in a special way. Although all session keys
used in the protocol stage are uniformly distributed, B needs
to distinguish two cases when a session key is accepted in
the key exchange:

• If the accepting session is partnered, B instructs GΠ to
register the same key as for the partnered session and
returns the according key identiﬁer to A.

• Otherwise, B simply queries GΠ for an identiﬁer of a
new (randomly distributed) key chosen by GΠ, which
it relays to A.

All other queries are handled by B in an unmodiﬁed way,
either by simulating them on its own (in the case of key
exchange queries) or by forwarding them to GΠ (in the case
of protocol queries).
As GΠ samples keys randomly and B ensures consistency
in the cases of partnered sessions, its simulation of Gns
for A is perfect. Since B forwards all protocol queries of A
unaltered to GΠ, if A succeeds in the composed game, B
wins in GΠ.

KEi;Π

Composition with Unilateral Authentication.

As aforementioned, unilateral authentication in the key
exchange phase prevents our composition theorem to hold
unconditionally. The reason for this is that, when we are
gradually replacing real by random keys in our proof, we
depend on issuing Test queries for those keys. However,
a Test query is prohibited for responder sessions without
partners in the case of (responder-authenticated) unilateral
authentication, as such queries would trivially rule out secu-
rity in a scenario where the adversary can impersonate the
unauthenticated communication partner.

Since multi-stage key exchange protocols with unilateral
authentication do not provide protection against such at-
tacks, our composition cannot consequently provide any pro-
tection either in these cases. However, if one restricts the
composition in such a way that sessions of the symmetric-
key protocol cannot be spawned in the trivial attack scenario

1200(i.e., if the accepting session in stage i has role = responder,
but is not partnered with a genuine initiator), then Theo-
rem 3.1 is easily adaptable to such a composition. Partic-
ularly, in Lemma 3.2, the problematic Test queries are not
needed anymore as the reduction does not have to simulate
a protocol session in these cases. Therefore, our composition
result extends to this case straightforwardly.

4. SECURITY ANALYSIS

OF GOOGLE’S QUIC PROTOCOL

In this section we analyze the QUIC protocol from a cryp-
tographic point of view. Before, we give a more detailed
description of QUIC and describe how protocol steps are
reﬂected in our modeling of the protocol.
4.1 A QUIC Tour

Let us recall the typical protocol run of the QUIC hand-
shake shown in Figure 1 and in an expanded form in Fig-
ure 3. Recall that in the core protocol the client ﬁrst sends
an ephemeral Diﬃe–Hellman (DH) key from which the ﬁrst
session key K1 is derived with the static DH key of the server,
before the key K2 of the second stage is derived when the
server sends a temporary DH key over the K1-secured chan-
nel. The key K2 is then computed as the DH key of the two
ephemeral keys.

Channels.

Note that the key K1 may be used to transmit payload
data before it is used to establish K2.
In fact, the K1-
protected channel may still be used after the server has sent
its share for K2. The reason is the unreliable transmission
via UDP, i.e., the ephemeral key may be delivered later than
expected or even get lost. The actual channel protocol is not
speciﬁed in [22, 19], only references to possible authenticated
encryption algorithms are given, supporting the usefulness
of our composition theorem. We also remark that it turns
out that for the security of the key exchange protocol we only
need authenticity of the server’s hello message, not conﬁden-
tiality.

Certiﬁcation.

The main protocol is surrounded by some means to ensure
that the server’s static key pair is available and certiﬁed.
Binding of keys to server identities is ensured by certiﬁca-
tion of public keys, potentially including revocation mech-
anisms. For the sake of simplicity and in compliance with
various similar eﬀorts, we leave this part out of the security
proof.6 Hence, we presume that valid binding of static keys
is ensured as a part of the security game in the sense that
the assignment of public keys to parties is known by default.
If the client is currently not in possession of the server’s
public key it may start the interaction with an “inchoate”
client hello. Upon receiving such a message, the server for-
wards its public conﬁguration, possibly including the certiﬁ-
cate and further information. We omit this part of the key
retrieval in our modeling of the protocol, since we assume
known binding of public keys to servers anyway.

6There are only a few exceptions where the certiﬁcation pro-
cess has been considered to be an integral part of crypto-
graphic protocol, e.g. [2, 12, 4], where the latter one deals
with key exchange explicitly.

Format of Handshake Messages.

To prevent replay attacks, QUIC employs the common
countermeasure and uses nonces. However, because of the
restriction of zero round-trip time, one cannot expect the
server to contribute to the nonce, and must rely on the user
to generate good nonces. To sustain security, QUIC assumes
that the server uses a so-called “strike-register” in which pre-
viously seen nonces are stored. Several severs within a so-
called “orbit” are supposed to share such a register. A nonce
is thus assumed to consist of a time stamp, an orbit identi-
ﬁer, and 20 random bytes; the designers of QUIC estimate
that 32 bytes should be suﬃcient.

If a connection with a client-generated nonce fails, because
the server ﬁnds an entry in the strike register, then the server
rejects, but provides a server-generated nonce, encrypted
and authenticated under some private server key.
If the
server then recognizes such a server nonce in the subsequent
connection retry, it can check that it is authentic. We simply
write nonceC for the nonce eventually used by the client,
and [nonceS ] for the (optional) server nonce. Because of the
strike registers, we presume in our protocol abstraction that
any honest server accepts any client nonce only once.

Handshake messages are tagged, e.g., the client resp. server
hello message in the handshake phase carry special tags
CHLO and SHLO, and may contain further information like
the version numbers. However, many of these entries are
optional and do not directly contribute to the cryptographic
strength of the key exchange step (except that they enter
the key derivation step in a non-critical way, see below). We
thus simply write aux for these data, with a subscript for
the corresponding party.

Key Derivation.

Key derivation is performed via HMAC with SHA-256, as
speciﬁed by NIST SP800-56C [9]. This is a two-stage deriva-
tion process. In the ﬁrst extraction step via function KDFext
one computes a pseudorandom master key PRK from the cor-
responding Diﬃe-Hellman key, using the client nonce and
possibly the server nonce as a salt input.
In our security
proof we model this extraction function as a random oracle.
In the second expansion step, one derives client and server
write keys and IV values by expanding the PRK via KDFexp.
Here, the input are the client hello message, the (public)
server conﬁguration, and a label distinguishing the ﬁrst-
stage key (“QUIC key expansion”) from the second-stage key
(“QUIC forward secure key expansion”). We denote these
data by info1 and info2, respectively. Note that they are both
determined given the client’s ephemeral key, the nonces, the
auxiliary data and the stage number. We assume in our
analysis that KDFexp is a random oracle, too.

Session Identiﬁers and Partners.

For the analysis we also need to specify the intended part-
ners and the session identiﬁers. Since clients are not au-
thenticated in QUIC, we assume that the responder in an
execution, i.e., the server, sets the partner identity label.V
to ‘*’. The client on the other hand sets the partner entry
to the identity of the server speciﬁed through the public key.
As for session identiﬁers, for both parties we let sid1 = info1
and sid2 = (info1,{[nonceS ], auxS , tpkS}K1 ), where the latter
value is the ciphertext sent by the server. Note that the
session identiﬁers are only set to these values once the cor-
responding party accepts, and are ⊥ otherwise. We remark

1201Client C

server’s static public key pkS

Server S

skS

generate ephemeral keys eskC, epkC

generate nonceC

D1 = DH(eskC, pkS )

PRK1 = KDFext(D1, nonceC, [nonceS ])

K1 = KDFexp(PRK1, info1)

D2 = DH(eskC, tpkS )

PRK2 = KDFext(D2, nonceC, [nonceS ])

K2 = KDFexp(PRK2, info2)

nonceC, auxC, epkC

{[nonceS ], auxS , tpkS}K1

[generate nonceS ]
D1 = DH(epkC, skS )

PRK1 = KDFext(D1, nonceC, [nonceS ])

K1 = KDFexp(PRK1, info1)
use temporary keys tskS , tpkS

D2 = DH(epkC, tskS )

PRK2 = KDFext(D2, nonceC, [nonceS ])

K2 = KDFexp(PRK2, info2)

Figure 3: Expanded description of protocol run of Google’s QUIC with 0-RTT handshake.

that auxC, containing the used server conﬁguration’s ID, to-
gether with the veriﬁed certiﬁcation of the server conﬁgura-
tion uniquely identiﬁes the full conﬁguration used in the key
derivation. Furthermore, observe that info1 and info2 can be
derived mutually from another, as they only diﬀer in some
constant labels.
4.2 Cryptographic Analysis of QUIC

For the security proof we will rely on the random oracle
model and the Gap-Diﬃe-Hellman problem [21], like many
other DH-based key exchange protocols, e.g., [15, 17, 20,
10] to name a few. The property basically says that solving
the (computational) DH problem remains hard, even having
access to a decisional oracle DDH(X, Y, Z) which returns 1
if and only if DH(X, Y ) = Z. Formally, for an adversary A
the probability that A solves the
we denote by AdvGapDH
following problem: On input the description of the group
G of known prime order q, together with a generator g of
G, and random X, Y ← G, the task is to ﬁnd Z such that
Z = DH(X, Y ), when given access to oracle DDH(·,·,·).

G,A

Besides the underlying number-theoretic problem, we also
need security of the channel protocol which is used for the
server hello message. Since we only need authenticity, we
can simply deﬁne security as follows: We denote by AdvAuth
{·},A
the probability that adversary A, when allowed to query the
channel oracle {·}K for a random key K at most once, is able
to create a channel message (not returned by the oracle) such
that decryption under K yields a valid message. Note that
we merely require one-time authenticity because we analyze
QUIC as a key exchange protocol only, assuming that no
payload data are sent by the client in the ﬁrst stage. Full
security would ideally follow from our compositional result;
alas, QUIC is not key-independent. We note that one could
extend our analysis to a monolithic proof of the security
of the stage-two key if one assumes adaptive multi-query
authenticity of the channel protocol.

Theorem 4.1

(Match-Security of QUIC). For any
adversary A we have responder-authenticated unilateral
Match-security, i.e., AdvMatch
s/q, where ns is the
maximal number of initiated sessions and q denotes the size
of the group G.

QUIC,A ≤ n2

Proof of Theorem 4.1. We need to show the three
properties of Match-security. For the ﬁrst one, preventing
that two sessions accept with identical (and valid) session
identiﬁers label.sidi = label(cid:48).sidi, but diﬀerent session keys,
note that identical session identiﬁers in QUIC (at either
stage) imply that the input to the key derivation functions
are identical, too. Hence there cannot exist stages with iden-
tical session identiﬁers but diﬀerent keys.

The second property of Match-security describes the im-
possibility of having identical session identiﬁers but the
client thinking that it communicates with a diﬀerent server
(i.e., label.V (cid:54)= label(cid:48).U ). Note that the server’s public key in
QUIC is part of session identiﬁers and that the identity can
be deduced from the key by assumption, thus the property
holds.

Finally, for the third property, three sessions with iden-
tical session identiﬁers, note that the probability that two
sessions of honest clients create the same random ephemeral
key is at most n2
s/q by the birthday bound. Note that we
use here that corrupting a user terminates the interaction
with the session such that, in particular, that session does
not generate session identiﬁers. Given that no such collision
occurs, the three sessions in question must include two ses-
sions of honest servers. But the client nonce contains the
server’s orbit and this value also enters the session identi-
ﬁer, the two servers in the same orbit must have accepted
the same client nonce twice, contradicting our assumption
about the strike registers.

Theorem 4.2

(Multi-Stage-security). In the random
oracle model QUIC is a (responder-authenticated) unilateral,
key-dependent, stage-2-forward-secure key exchange protocol
such that for any eﬃcient adversary A there exist eﬃcient
algorithms B and C with
AdvMulti-Stage

QUIC,A ≤ ns ·(cid:0)(n2

s + nsnu) · AdvGapDH
− min{|PRK1|,|PRK2|}

G,B

+ ns · Advauth{·},C(cid:1),

+ 4qhns · 2

where ns is the maximal number of sessions, nu the maximal
number of users, and qh is the total number of random oracle
queries of the adversary.

Proof of Theorem 4.2 (Sketch). First, we may con-
sider the case that the adversary makes a single Test query
only. This can decrease the success probability by a factor
at most 1/ns by a hybrid argument. From now on we can
therefore speak of the tested session. Recall further that for
an admissible Test query in a responder-authenticated uni-
lateral protocol, the query must be either for an initiator
session (i.e., for a client in QUIC), or for a partnered server
session such that the client’s ephemeral public key originates
from a session of an honest client.

Consider ﬁrst the (non-forward) security of the session
keys of the ﬁrst stage. We can bound the adversary’s suc-
cess probability to distinguish the keys from random by (a)
the probability that the adversary queries the random or-
acle KDFext about the DH key (speciﬁed through the ses-
sion identiﬁer of the tested session), plus (b) the conditional
probability that A succeeds given that it has not queried
KDFext about the key before. In the latter case, the corre-

1202sponding value PRK1 is an unknown random value for the
adversary. Furthermore, since the adversary cannot reveal
the session key in partnered sessions and keys for other ses-
sion identiﬁers are distributed independently, distinguishing
the derived test session key from random is then given by
the (pseudo)randomness of KDFexp.

The former probability of making the query to KDFext
about the DH value can be bounded in terms of the GapDH
problem, along the arguments for similar protocols, e.g. [15,
17, 20, 10]. That is, one guesses two sessions, one being a
client session, the other one being a server session, and in-
jects the given challenge values X, Y of the GapDH problem
into the client’s ephemeral key and the server’s static pub-
lic key. The hope is that these sessions will correspond to
the Test query, which is either for a client session, or for a
server session, but which is then partnered to the (hopefully
correctly predicted) client session and key. If the adversary
makes the random oracle query about the DH key of the
two values, then we can solve the DH problem. Here, in the
course of the simulation, the server’s long-term key may be
used in another session, in which we could not derive the cor-
responding DH key. Using the same technique as in previous
works, we leverage the decisional DH oracle to simulate the
random oracle via implicit representation of DH tuples.

To show stage-2 forward security, we distinguish again
between the cases that the adversary queries the random
oracle about the DH key of stage 2, and that it does not (in
which case the randomness of PRK2 ensures security of the
session keys again). For the ﬁrst case, however, we have to
apply a more ﬁne-grained case distinction now. To this end,
we ﬁrst show that the adversary essentially cannot inject its
own temporary key into the server’s hello message; else this
would clearly violate security. For this we argue that the
ﬁrst stage key K1 of the tested client session with label label
still looked random to the adversary when the server hello
message has been sent. This follows as above and from the
following three properties:

1. Because of the key dependence, the adversary cannot
learn the key K1 via a Reveal(label, 1) query to the test
session; such queries are prohibited before the key K2
has been established.

2. For the same reason, key dependence, the adversary
cannot learn K1 by revealing the key of a session label(cid:48)
which is partnered according to the stage-one session
identiﬁer (label.sid1 = label(cid:48).sid1). Any such reveal re-
quest would make K1 and K2 in the tested session re-
vealed, according to the Reveal query in which keys for
partnered sessions are set to revealed for the current
and all subsequent stages.

3. Corruptions of the test session’s client could only have

happened after K2 has been established.

Since K1 has looked fresh, we can then argue along the au-
thenticity of the K1-channel. The adversary either gets to
see one or none channel message for the fresh key K1 (de-
pending on whether there is a partnered session to label),
and needs to break the authenticity if it manages to send a
new valid ciphertext. This is bounded by advantage Advauth{·},D
times the factor to guess the right sessions again.

The adversary can now only relay messages between an
honest client and an honest server. In such an execution we
can again inject the GapDH challenge X, Y into the client’s

ephemeral public key and the server’s temporary public key.
Only this time, we have to guess two sessions, instead of one
session and the right (long-term secret of a) user, yielding
s instead of ns · nu. Note that Corrupt queries for
a factor n2
the server only disclose the long-term secret, but not the
temporary key. Hence, we can carry out the same reduction
to the GapDH problem as above. The claim now follows.
4.3 QUICi — A Key-independent Version

Recall that our composition theorem (in the unilateral ver-
sion) only applies to key-independent schemes, where QUIC,
as is, does not satisfy this property. It is, however, quite easy
to change QUIC into a key-independent version. With the
modiﬁcation to QUICi we can then argue security of, say,
the composition of QUICi with a secure channel protocol
for the second stage.

Recall that, in the key-independent case, it is allowed to
Reveal the session key of a stage, before the session key of
the next stage has been established. The idea for QUIC is
similar to TLS, where the resumption key is derived from the
established master secret (from which the previous session
keys have been computed). For QUICi, one would simply
derive two secret values K1 and preK2 in the KDFexp step
of the key derivation in the ﬁrst stage, where K1 is still the
ﬁrst stage’s session key and preK2 is kept secret and later
input to the key derivation in the second stage. Any Reveal
query would then disclose the session keys, but not preK2.
It should thus be hard to compute the second-stage session
keys given only the previous session keys.7
4.4 A Note on 0-RTT Security

We highlight a speciﬁc security aspect of QUIC’s approach
to establish secure connections in 0-RTT which is, by its na-
ture, not coverable in our model. Remember that, for a
0-RTT connection establishment to be achievable, the client
has to speculate that the server still uses a previously known
public key. If this is not the case then the server will reply
with an updated server conﬁguration (and key), allowing the
client to retry the connection establishment. Note however
that, in order to beneﬁt from the 0-RTT key exchange, the
QUIC speciﬁcation states that the client indeed “must start
sending before waiting for the server’s reply” [19] and rekey-
ing with K2 takes place. In such a scenario, it therefore has
to be assumed that some data will be sent under a (non-
forward-secure) key K1 computed using the outdated server
public key.

So far, this is not surprising and, as our model treats
non–forward security including corruptions, it accurately in-
dicates that no security guarantees can be given for the data
encrypted under that K1 if the adversary learns the outdated
server public key (i.e., corrupts this server identity). What
we however cannot model in a precise cryptographic sense is
the following attack: Assume that an active adversary learns
a server’s static secret key, and that this security breach is
discovered, leading this server to generate a new conﬁgura-
tion and key pair. In the scenario depicted above, the client
aiming to talk to the server (referring to the server as a
real instance, not as the identity behind a public key) will

7Note that, if we allow session state reveals, then the key
PRK could still be disclosed, of course. The idea here there-
fore protects against bad usage of the session keys in the
channel (modeled through Reveal queries), but not against
disclosure of ephemeral randomness.

1203use the outdated public key for connection establishment.
Therefore, an active adversary will be able to impersonate
the server (in the real-world sense) using the corrupted static
key, which the client believes still belongs to this server.

We stress that the fact that our model cannot represent
this attack, although it constitutes a potential vulnerabil-
ity, is not a weakness of our model, but rather reﬂects a
mismatch between the real-world entity a client aims to
communicate with and the outdated cryptographic identity
employed for this purpose. This attack obviously can be
mitigated by employing strong binding between real-world
and cryptographic identities using, e.g., timely certiﬁcate
revocation. However, such means would naturally inﬂuence
the low-latency timing properties QUIC speciﬁcally aims for
with 0-RTT connections. At this point, we leave it open to
discussion whether or not the outlined potential vulnerabil-
ity is a fair price to pay to achieve this goal.

5. CONCLUSION

Our work introduces a model to reason about the security
of multi-stage key exchange protocols. The notion enables
us to assess Google’s new QUIC protocol and to conﬁrm
its intended security properties as a key exchange protocol.
This, in itself, is already a useful result to support the faith
in the cryptographic strength of QUIC. We continue to ar-
gue about compositional security of multi-stage protocols
in general, pointing out the importance of the new notion
of (session-)key independence, and how this could be easily
integrated into QUIC.

Clearly, one of the next steps would be to analyze SSL/TLS
with resumption as a multi-stage protocol. This, however,
would require to adapt the model ﬁrst, because, as discussed
earlier, SSL/TLS cannot even be shown to be secure as a
single-stage protocol in the Bellare–Rogaway sense. Another
interesting aspect would be to weaken the requirements for
our compositional theorem, or to prove that the require-
ments are indeed necessary.

Acknowledgments
We thank Hugo Krawczyk for proposing an improvement to
our modiﬁcation of QUIC for key independence, Christina
Brzuska for helpful discussions on the composition results,
and the anonymous reviewers for valuable comments. Marc
Fischlin is supported by the Heisenberg grant Fi 940/3-1 of
the German Research Foundation (DFG). Felix G¨unther is
supported by the German Federal Ministry of Education and
Research (BMBF) within EC SPRIDE. This work has been
funded by the DFG as part of the CRC 1119 CROSSING.

6. REFERENCES
[1] M. Bellare and P. Rogaway. Entity authentication and
key distribution. In CRYPTO’93, pages 232–249, 1993.

[2] A. Boldyreva, M. Fischlin, A. Palacio, and

B. Warinschi. A closer look at PKI: Security and
eﬃciency. In PKC 2007, pages 458–475, 2007.

[3] A. Boldyreva, R. Lychev, and C. Nita-Rotaru. How

Secure and Quick is QUIC in Presence of Malice?
Communicated through one of the authors.

[4] C. Boyd, C. Cremers, M. Feltz, K. G. Paterson,

B. Poettering, and D. Stebila. ASICS: Authenticated
key exchange security incorporating certiﬁcation
systems. In ESORICS 2013, pages 381–399, 2013.

[5] C. Brzuska. On the Foundations of Key Exchange.

PhD thesis, Technische Universit¨at Darmstadt,
Darmstadt, Germany, 2013.
http://tuprints.ulb.tu-darmstadt.de/3414/,
retrieved on 2014-05-14.

[6] C. Brzuska, M. Fischlin, N. P. Smart, B. Warinschi,

and S. C. Williams. Less is more: relaxed yet
composable security notions for key exchange. Int. J.
Inf. Sec., 12(4):267–297, 2013.

[7] C. Brzuska, M. Fischlin, B. Warinschi, and S. C.
Williams. Composability of Bellare-Rogaway key
exchange protocols. In ACM CCS 11, pages 51–62,
2011.

[8] R. Canetti and H. Krawczyk. Analysis of key-exchange
protocols and their use for building secure channels. In
EUROCRYPT 2001, pages 453–474, 2001.

[9] L. Chen. Recommendation for Key Derivation through

Extraction-then-Expansion. National Institute of
Standards and Technology, 2011.

[10] ¨O. Dagdelen and M. Fischlin. Security analysis of the
extended access control protocol for machine readable
travel documents. In ISC 2010, pages 54–68, 2010.

[11] T. Dierks and E. Rescorla. The Transport Layer
Security (TLS) Protocol Version 1.2. RFC 5246
(Proposed Standard), 2008. Updated by RFCs 5746,
5878, 6176.

[12] P. Farshim and B. Warinschi. Certiﬁed encryption

revisited. In AFRICACRYPT 09, pages 179–197, 2009.

[13] F. Giesen, F. Kohlar, and D. Stebila. On the security

of TLS renegotiation. In ACM CCS 13, pages
387–398, 2013.

[14] T. Jager, F. Kohlar, S. Sch¨age, and J. Schwenk. On
the security of TLS-DHE in the standard model. In
CRYPTO 2012, pages 273–293, 2012.

[15] M. Jakobsson and D. Pointcheval. Mutual

authentication for low-power mobile devices. In FC
2001, pages 178–195, 2001.

[16] H. Krawczyk, K. G. Paterson, and H. Wee. On the

security of the TLS protocol: A systematic analysis.
In CRYPTO 2013, Part I, pages 429–448, 2013.

[17] C. Kudla and K. G. Paterson. Modular security proofs

for key agreement protocols. In ASIACRYPT 2005,
pages 549–565, 2005.

[18] B. A. LaMacchia, K. Lauter, and A. Mityagin.

Stronger security of authenticated key exchange. In
ProvSec 2007, pages 1–16, 2007.

[19] A. Langley and W.-T. Chang. QUIC Crypto.

https://docs.google.com/document/d/1g5nIXAIkN_
Y-7XJW5K45IblHd_L2f5LTaDUDwvZ5L6g/, 2013.
retrieved on 2014-04-16.

[20] K. Lauter and A. Mityagin. Security analysis of KEA

authenticated key exchange protocol. In PKC 2006,
pages 378–394, 2006.

[21] T. Okamoto and D. Pointcheval. The gap-problems: A
new class of problems for the security of cryptographic
schemes. In PKC 2001, pages 104–118, 2001.

[22] J. Roskind. QUIC (Quick UDP Internet Connections):

Multiplexed Stream Transport Over UDP.
https://docs.google.com/document/d/1RNHkx_
VvKWyWg6Lr8SZ-saqsQx7rFV-ev2jRFUoVD34/, 2013.
retrieved on 2014-04-16.

1204