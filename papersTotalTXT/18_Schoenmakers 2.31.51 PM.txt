Explicit Optimal Binary Pebbling
for One-Way Hash Chain Reversal

Berry Schoenmakers

Dept of Mathematics & Computer Science

TU Eindhoven, The Netherlands

berry@win.tue.nl

Abstract. We present explicit optimal binary pebbling algorithms for reversing
one-way hash chains. For a hash chain of length 2k, the number of hashes performed
in each output round does not exceed (cid:100)k/2(cid:101), whereas the number of hash values
stored throughout is at most k. This is optimal for binary pebbling algorithms
characterized by the property that the midpoint of the hash chain is computed just
once and stored until it is output, and that this property applies recursively to both
halves of the hash chain.
We introduce a framework for rigorous comparison of explicit binary pebbling algo-
rithms, including simple speed-1 binary pebbles, Jakobsson’s binary speed-2 peb-
bles, and our optimal binary pebbles. Explicit schedules describe for each pebble
exactly how many hashes need to be performed in each round. The optimal sched-
ule turns out to be essentially unique and exhibits a nice recursive structure, which
allows for fully optimized implementations that can readily be deployed. In partic-
ular, we develop the ﬁrst in-place implementations with minimal storage overhead
(essentially, storing only hash values), and fast implementations with minimal com-
putational overhead. Moreover, we show that our approach is not limited to hash
chains of length n = 2k, but accommodates hash chains of arbitrary length n ≥ 1,
without incurring any overhead. Finally, we show how to run a cascade of pebbling
algorithms along with a bootstrapping technique, facilitating sequential reversal of
an unlimited number of hash chains growing in length up to a given bound.

1

Introduction

Originally introduced by Lamport to construct an identiﬁcation scheme resisting
eavesdropping attacks [Lam81,Hal94], one-way hash chains have become a truly
fundamental primitive in cryptography.1 The idea of Lamport’s asymmetric identi-
ﬁcation scheme is to let the prover generate a hash chain as a sequence of successive
iterates of a one-way hash function applied to a random seed value, revealing only
the last element of the hash chain to the veriﬁer upon registration. Later, during
successive runs of the identiﬁcation protocol, the remaining elements of the hash
chain are output by the prover in reverse order, one element on each run.

Due to the one-way property of the hash function, eﬃcient reversal of a hash
chain is non-trivial for long chains. In 2002, Jakobsson introduced a simple and
eﬃcient pebbling algorithm for reversal of one-way hash chains [Jak02], inspired

1 Bitcoin’s block chain is probably the best-known example of a hash chain nowadays, each
block containing a hash of the previous block in the chain. Unlike in our setting, however,
block chains are costly to generate due to the “proof of work” requirement for the hash values.

by the pebbling algorithm of [IR01] for eﬃcient key updates in a forward-secure
digital signature scheme. Pebbling algorithms for one-way hash chain reversal strike
a balance between storage requirements (measured as the number of hash values
stored) and computational requirements (measured as the maximum number of
hashes performed in any round). The performance constraint is that each next
element of the reversed hash chain should be produced within a limited amount of
time after producing the preceding element—without this performance constraint,
the problem would indeed be easy, see Appendix A. For a hash chain of length
n = 2k, Jakobsson’s algorithm stores O(log n) hash values only and the number of
hashes performed in each round is limited to O(log n) as well.

The problem of eﬃcient hash chain reversal was extensively studied by Copper-
smith and Jakobsson [CJ02]. They proved nearly optimal complexity for a binary
pebbling algorithm storing at most k + (cid:100)log2(k + 1)(cid:101) hash values and performing
at most (cid:98) k
2(cid:99) hashes per round. Later, it was observed by Yum et al. that a greedy
implementation of Jakobsson’s original algorithm actually stores no more than k
hash values, requiring no more than (cid:100) k

2(cid:101) hashes per round [YSEL09].

In this paper we consider the class of binary pebbling algorithms, covering
the best algorithms of [Jak02,CJ02,YSEL09] among others. A binary pebbling
algorithm is characterized by the property that the midpoint of the hash chain is
computed just once and stored until it is output; moreover, this property applies
recursively to both halves of the hash chain. In particular, this means that after
producing the last element of the hash chain as the ﬁrst output, a binary pebbling
algorithm stores the k elements at distances 2i − 1, for 1 ≤ i ≤ k, from the end of
the hash chain.

We introduce a simple yet general framework for rigorous analysis of eﬃcient
binary pebbling algorithms for hash chain reversal, and we completely resolve the
case of binary pebbling by constructing an explicit optimal algorithm. The storage
required by our optimal algorithm does not exceed the storage of k hash values
and the number of hashes performed in any output round does not exceed (cid:100) k
2(cid:101).
This matches the performance of the greedy algorithm of [YSEL09], which is an
optimal binary pebbling algorithm as well. However, we give an exact schedule for
all hashes performed by the algorithm (rather than performing these hashes in a
greedy fashion). We also believe that our approach is much more accessible than
previous ones, leading to high quality algorithms that can readily be deployed.

Our optimal schedule is deﬁned explicitly, both as a recursive deﬁnition and
as a closed formula, specifying exactly how many hashes should be performed
in a given round by each pebble. Furthermore, we will argue that the optimal
schedule is essentially unique. Apart from the insightful mathematical structure
thus uncovered, the explicit optimal schedule enables the development of fully
optimized solutions for one-way hash chain reversal. We construct the ﬁrst in-place
(or, in situ) hash chain reversal algorithms which require essentially no storage
beyond the hash values stored for the pebbles; at the same time, the computational
overhead for each round is limited to a few basic operations only beyond the
evaluation of the hash function. Finally, as another extreme type of solution, we

2

show how to minimize the computational overhead to an almost negligible amount
of work, at the expense of increased storage requirements.

Concretely, for hash chains of length 232 using a 128-bit one-way hash, our
in-place algorithm only stores 516 bytes (32 hash values and one 32-bit counter)
and performs, at most 16 hashes per round. Our results are therefore of particular
importance in the context of lightweight cryptography. See, e.g., the references in
[PCTS02,YSEL09,MSS13] for a glimpse of the extensive literature on hash chains,
covering an extensive range of lightweight devices such as wireless sensors, RFID
tags, and smart cards. Moreover, we note that our results are also interesting in
the context of post-quantum cryptography, as the security of one-way hash chains
is not aﬀected dramatically by the potential of quantum computers.

2 One-Way Hash Chains

the empty sequence. We use |A| = n to denote the length of A, and #A =(cid:80)n

Throughout, we will use the following notation for (ﬁnite) sequences. We write
A = {ai}n
i=1 = {a1, . . . , an} for a sequence A of length n, n ≥ 0, with {} denoting
i=1 ai
to denote the weight of A. We write A (cid:107) B for the concatenation of sequences A and
B, and A+B for element-wise addition of sequences A and B of equal length, where
+ takes precedence over (cid:107). Constant sequences are denoted by c = c∗n = {c}n
i=1,
suppressing the length n when it is understood from context; e.g., A + c denotes
the sequence obtained by adding c to all elements of A.
f∗
k(x) for a given seed value x is deﬁned as the following sequence:

Let f be a cryptographic hash function. The length-2k (one-way) hash chain

k(x) = {f i(x)}2k−1
f∗
i=0 .

For authentication mechanisms based on hash chains, we need an eﬃcient algo-
rithm for producing the sequence f∗
k(x) in reverse. The problem arises from the
fact that computation of f in the forward direction is easy, while it is intractable
in the reverse direction. So, given x it is easy to compute y = f (x), but given y
it is hard to compute any x at all such that y = f (x). For long hash chains the
straightforward solutions of either (i) storing f∗
k(x) and reading it out in reverse
or (ii) computing each element of f∗
k(x) from scratch starting from x are clearly
too ineﬃcient.

3 Binary Pebbling

We introduce a framework that captures the essence of binary pebbling algorithms
as follows. We deﬁne a pebble as an algorithm proceeding in a certain number of
rounds, where the initial rounds are used to compute the hash chain in the forward
direction given the seed value x, and the hash chain is output in reverse in the
remaining rounds, one element at a time.
For k ≥ 0, we deﬁne pebble Pk(x) below as an algorithm that runs for 2k+1 − 1
rounds in total, and outputs f∗
k(x) in reverse in its last 2k rounds. It is essential

3

round 1

−

x

initial
stage

round 2k

•yk
−

• yk−1

• yk−2• • y0•

Pk−1

Pk−2

output
stage

round 2k+1−1

−

Fig. 1. Binary pebble Pk(x), where yi = f 2k−2i

(x) for i = k, . . . , 0.

that we include the initial 2k−1 rounds in which no outputs are produced as an in-
tegral part of pebble Pk(x), as this allows us to deﬁne and analyze binary pebbling
in a fully recursive manner. In fact, in terms of a given schedule Tk = {tr}2k−1
with #Tk = 2k − 1, a binary pebble Pk(x) is completely speciﬁed by the following
recursive deﬁnition, see also Figures 1–2:
Rounds [1, 2k): Store yi = f 2k−2i
Round 2k: Output y0.
Rounds (2k, 2k+1): Run Pi−1(yi) in parallel for i = 1, . . . , k.

(x) for i = k, . . . , 0 using tr hashes in round r.

r=1

We will refer to rounds [1, 2k) as the initial stage of pebble Pk and to rounds
[2k, 2k+1) as its output stage. Running pebbles in parallel means that pebbles

4

take turns to execute for one round each, where the order in which this happens
within a round is irrelevant.
The behavior of pebbles P0 and P1 is ﬁxed since T0 = {} and T1 = {1},
respectively. Pebble P0(x) runs for one round only, in which y0 = x is output,
using no hashes at all. Similarly, P1(x) runs for three rounds, performing one
hash in its ﬁrst round to compute y1 = x and y0 = f (x), outputting f (x) in its
second round, and then running P0(y1) in the third round, which will output x.
More generally, the following theorem shows that correct behavior follows for any
pebble Pk independent of the particular schedule Tk, and furthermore that the
total number of hashes performed by Pk is ﬁxed as well.
Theorem 1. Pebble Pk(x) produces f∗
k(x) in reverse in its output stage, perform-
ing k2k−1 hashes (2k−1 in its initial stage and (k−2)2k−1+1 in its output stage).
Proof The proof is by induction on k. For k = 0, we have that P0(x) outputs
f∗
0(x) = x in its one and only round, using 0 hashes.
For k ≥ 1, we see that Pk(x) ﬁrst outputs y0 = f 2k−1(x) in round 2k, which is
the last element of f∗
k(x). Next, pebbles Pi−1(yi) run in parallel for i = 1, . . . , k.
The induction hypothesis yields that each Pi−1(yi) produces f∗
(x)) in
reverse in its last 2i−1 out of 2i − 1 rounds. Hence, in round 2k + 1, P0(y1) outputs
{y1} = f∗
1(f 2k−4(x)) in
reverse. And so on until ﬁnally Pk−1(yk) outputs f∗
(x)) in reverse in
the last 2k−1 rounds of Pk(x). The total number of hashes performed by Pk is
i=1(i− 1)2i−2 = k2k−1, using that Pi−1 performs (i− 1)2i−2 hashes per
(cid:3)

0(f 2k−2(x)). In the next two rounds, P1(y2) outputs f∗

i−1(f 2k−2i

2k − 1 +(cid:80)k

the induction hypothesis.

k−1(f 2k−1

Schedule Tk speciﬁes the number of hashes for the initial stage of Pk. To analyze
the work done by Pk in its output stage, we introduce sequence Wk of length 2k−1
to denote the number of hashes performed by Pk in each of its last 2k − 1 rounds—
noting that by deﬁnition no hashes are performed by Pk in round 2k. The following
recurrence relation for Wk will be used throughout our analysis.
Lemma 1. W0 = {}, Wk = Tk−1 + Wk−1 (cid:107) 0 (cid:107) Wk−1.
Proof Pebble P0 runs for 1 round only, so W0 = {}. For k ≥ 1, we see that
in the last 2k − 1 rounds of pebble Pk, a pebble Pk−1 runs in parallel to pebbles
Pi for i = 0, . . . , k − 2. In these rounds, pebble Pk−1 performs Tk−1 (cid:107) 0 (cid:107) Wk−1
hashes by deﬁnition, whereas pebbles Pi for i = 0, . . . , k− 2 perform Wk−1 (cid:107) 0∗2k−1
hashes in total, as this matches the number of hashes for a pebble Pk−1 in its last
2k−1 − 1 rounds (consider the output stage in Figure 1). Hence, in total Wk =
Tk−1 + Wk−1 (cid:107) 0 (cid:107) Wk−1 hashes.
(cid:3)

We have the following lower bound for max(Wk), the maximum number of
hashes performed by Pk in any round of its output stage. Interestingly, this lower
bound holds for any schedule Tk. In Section 5 we will present an optimal schedule
achieving the lower bound.
Theorem 2. max(Wk) ≥ (cid:100)k/2(cid:101), for k ≥ 2.

5

Proof Let k ≥ 2 and consider the average number of hashes per round during the
ﬁrst half of the output stage. From Theorem 1, Lemma 1, and |Tk−1| = |Wk−1| =
2k−1 − 1, we have

max(Wk) ≥ #Tk−1 + #Wk−1

|Tk−1 + Wk−1| =

(k − 1)2k−2
2k−1 − 1

k − 1

2

.

>

Hence, max(Wk) ≥ (cid:100)k/2(cid:101).

(cid:3)

To analyze the storage needed by Pk we will count the number of hash values
stored by Pk at the start of each round. We introduce sequence Sk = {sr}2k+1−1
to denote the total storage used by Pk in each round. For instance, s1 = 1 as Pk
only stores x at the start, and s2k = k + 1 as Pk stores y0, . . . , yk at the start of
round 2k independent of schedule Tk.

r=1

4 Speed-1 and Speed-2 Binary Pebbles

In this section we analyze the performance of speed-1 pebbles and speed-2 pebbles.
We use speed-1 pebbles to demonstrate our framework, whereas the analysis of
speed-2 pebbles, which correspond to Jakobsson’s original algorithm [Jak02], will
be used in the analysis of our optimal pebbles in the next section.
Speed-1 pebbles are deﬁned by setting Tk = 1∗2k−1, hence one hash evaluation
in each initial round of Pk. To deﬁne speed-2 pebbles we set T0 = {} and Tk =
0∗2k−1−1 (cid:107) 2∗2k−1−1 (cid:107) 1 for k ≥ 1, hence a speed-2 pebble is idle in the ﬁrst part
of the initial stage and then hashes twice in each round until the end of the initial
stage. As can be seen from Theorem 4 below, the storage requirements are reduced
by a factor of 2 for speed-2 pebbles over speed-1 pebbles.
Theorem 3. Both speed-1 and speed-2 pebbles Pk use up to max(Wk) = k − 1
hashes in any output round, for k ≥ 1.
Proof For a speed-1 pebble, Lemma 1 implies max(Wk) = k − 1 for k ≥ 1, as all
elements of Tk−1 are equal to 1.
For a speed-2 pebble we prove by induction on k that max(Wk) = k − 1. This
clearly holds for k = 1, 2. For k ≥ 3, we have, using Lemma 1,
(cid:107) 2∗2k−2−1 (cid:107) 1
Tk−1 =
Wk−1 = 0 (cid:107) Tk−2 + Wk−2 (cid:107) 0 (cid:107) Wk−2.

0∗2k−2−1

Therefore,

max(Wk) = max(Tk−1 + Wk−1) = max(Wk−1, 2 + Wk−2),

noting that the last element of Wk−2 = 0. Applying the induction hypothesis twice,
we conclude max(Wk) = max(k − 2, k − 1) = k − 1.
(cid:3)

6

Lemma 2.

S0 = {1},
Sk = (1∗2k (cid:107) Sk−1) + (0 (cid:107) 1∗2k−1−1 (cid:107) Sk−1 (cid:107) 0∗2k−1), for a speed-1 Pk,
Sk = (1∗2k (cid:107) Sk−1) + (0∗2k−1 (cid:107) Sk−1 (cid:107) 0∗2k−1),
for a speed-2 Pk.

Proof Pebble P0(x) only needs to store x during its one and only round, therefore
S0 = {1}. For k ≥ 1, any pebble Pk(x) also needs to store x throughout all of its
rounds, where pebble Pk−1(yk) = Pk−1(x) takes over the storage of x during the
output stage. This accounts for the term 1∗2k (cid:107) Sk−1.
In addition, a speed-1 pebble needs to store a hash value from round 2 until it
reaches yk−1 in round 2k−1. From thereon, the total additional storage corresponds
to running a speed-1 Pk−1(yk−1) pebble. This accounts for the term 0 (cid:107) 1∗2k−1−1 (cid:107)
Sk−1 (cid:107) 0∗2k−1.
A speed-2 pebble needs no additional storage during its ﬁrst 2k−1 rounds.
Then it needs to store an additional hash value from round 2k−1 + 1 on. By taking
0∗2k−1 (cid:107) Sk−1 (cid:107) 0∗2k−1 as additional term, we account for both the additional hash
value stored by a speed-2 pebble during rounds (2k−1, 2k−1 + 2k−2] and the storage
corresponding to a speed-2 Pk−1(yk−1) pebble, running from round 2k−1 + 1. (cid:3)
Theorem 4. A speed-1 pebble Pk uses up to max(Sk) = max(k+1, 2k−2) storage,
and a speed-2 pebble Pk uses up to max(Sk) = k + 1 storage.
Proof Using that s2k = k + 1, we write Sk = Ak (cid:107) k+1 (cid:107) Bk, where |Ak| = |Bk| =
2k − 1.
For a speed-1 pebble Pk, it can easily be checked that max(Sk) = max(k +
1, 2k − 2) holds for k = 0, 1. To prove this for k ≥ 2, we note that it suﬃces to
show max(Ak, Bk) = 2k − 2, as max(Sk) = max(Ak, k + 1, Bk). Lemma 2 implies

(cid:107) 1 + Ak−1
Ak =
Bk = Ak−1 + Bk−1 (cid:107) k (cid:107) Bk−1,

1 (cid:107) 2∗2k−1−1

so we have that max(Ak, Bk) = max(Ak−1 + Bk−1, k) = max(2k − 2, k) = 2k − 2
follows if we can show max(Ak + Bk) = 2k, for k ≥ 1. We prove the latter by
induction on k. For k = 1, it is clearly true as A1 = B1 = {1}. For k ≥ 2, we see
that max(Ak + Bk) = max(2 + Ak−1 + Bk−1, k + 2) = max(2k, k + 2) = 2k follows
from the induction hypothesis, also using that the ﬁrst element of Ak−1 + Bk−1 is
equal to k.

For a speed-2 pebble Pk, we note that max(Sk) = k + 1 follows from the fact
that Ak +Bk = k +1, which we show by induction on k. For k = 0, Ak +Bk = k +1
is vacuously true, as A0, B0 are empty sequences. For k ≥ 1, we see from Lemma 2
that

(cid:107) 1 + Ak−1
Ak =
Bk = Ak−1 + Bk−1 (cid:107) k (cid:107) Bk−1.

1∗2k−1

Thus, from the induction hypothesis we have Ak−1 + Bk−1 = k, hence Ak + Bk =
(cid:3)
k + 1.

7

5 Optimal Binary Pebbles
In this section, we will reduce the maximum number of hashes per round from k−1
for a speed-2 pebble Pk to (cid:100)k/2(cid:101) for an optimal pebble Pk, without increasing the
storage requirements. We do so by letting our optimal pebbles Pk be idle for the
ﬁrst 2k−1 − 1 rounds, just as speed-2 pebbles do. During rounds [2k−1, 2k), an
optimal pebble will work at varying speeds, roughly as follows: the average speeds
in each quarter are 2, 1, 2, and 3 hashes per round, respectively. To streamline
the presentation, we will at ﬁrst allow “ 1
2 hashes” in the deﬁnition of our optimal
schedule. At the end of this section, we will show how to round the schedule to
integer values without aﬀecting optimality.

We deﬁne the optimal schedule Tk as follows:

T0 = {}, Tk = 0∗2k−1−1 (cid:107) Uk (cid:107) Vk,

where

For example, T1 = {1}, T2 = {0, 3

U1 = {1}, Uk = 1
V1 = {},
Vk = 1
2}, and T3 = {0, 0, 0, 2, 1, 2, 2}.
2 , 3

2 + Uk−1 (cid:107) 1∗(cid:98)2k−3(cid:99),
2 + Uk−1 (cid:107) 1
2 + Vk−1.

Optimality is proved in the next two theorems. Subsequently, we will argue

that optimal schedule Tk is essentially unique.
Theorem 5. An optimal pebble Pk uses up to max(Wk) = k/2 hashes in any
output round, for k ≥ 2.
Proof We use Lemma 1 without explicitly referring to it.

Since max(Wk) = max(Tk−1 + Wk−1), we obtain max(Wk) = k/2, if we prove

by induction on k that

Tk + Wk = Tk−1 + Wk−1 (cid:107) k+1

2

∗2k−1

.

This property clearly holds for k = 1, 2. For k ≥ 3, the deﬁnition of Tk implies
that the property is in fact equivalent to

(Uk (cid:107) Vk) + (0 (cid:107) Wk−1) = k+1

2

∗2k−1

.

(1)

From the deﬁnition of Uk, Vk and the induction hypothesis for Tk−2 + Wk−2 we
obtain

Uk (cid:107) Vk =
0 (cid:107) Wk−1 = 0 (cid:107) Tk−3 + Wk−3 (cid:107) k−1

(cid:107) 1∗2k−3 (cid:107) 1
∗2k−3 (cid:107)

1
2 + Uk−1

2

2 + (Uk−1 (cid:107) Vk−1),

0 (cid:107) Wk−2.

Since 0 (cid:107) Tk−3 + Wk−3 is equal to the ﬁrst half of 0 (cid:107) Wk−2, we get from the
induction hypothesis that indeed all elements of (Uk (cid:107) Vk) + (0 (cid:107) Wk−1) are equal
(cid:3)
to k+1
2 .
Let len(x) = (cid:100)log2(x + 1)(cid:101) denote the bit length of nonnegative integer x. The
next two lemmas give closed formulas for the optimal schedule Tk and its partial
sums. Lemma 4 will be used to prove Theorem 6, but these formulas also provide
the basis for our eﬃcient in-place implementation of optimal binary pebbling.

8

Lemma 3. For optimal schedule Tk = {tr}2k−1

r=1 , we have for 2k−1 ≤ r < 2k:

(cid:16)

k + 1 − len(cid:0)(2r) mod 2len(2k−r)(cid:1)(cid:17)

.

tr = 1
2

Proof The proof is by induction on k. For 0 ≤ k ≤ 2, the formula is easily
checked. For k ≥ 3, we distinguish two cases.
Case 2k−1 ≤ r < 2k−1 + 2k−2. We ﬁrst note that (2r) mod 2len(2k−r) = 2r − 2k.
If r ≥ 2k−1 + 2k−3, we have tr = 1 by deﬁnition and we see the formula for tr
yields 1 as well as len(2r − 2k) = k − 1. Otherwise r < 2k−1 + 2k−3, hence we
have tr = tr+2k−2. So, this case reduces to the case below by noting that also
(2(r + 2k−2)) mod 2len(2k−(r+2k−2)) = 2r − 2k.
Case 2k−1 + 2k−2 ≤ r < 2k. From the deﬁnition of the optimal schedule we see
that in this case tr = 1
. From the induction
hypothesis we get:

r−2k−1, where Tk−1 = {t(cid:48)

z}2k−1−1

z=1

(cid:17)

2 + t(cid:48)
(cid:16)

(cid:16)

t(cid:48)
r−2k−1 = 1
2

k − len((2(r − 2k−1)) mod 2len(2k−1−(r−2k−1)))

.

Rewriting this formula for t(cid:48)

r−2k−1 we obtain
k − len((2r − 2k) mod 2len(2k−r))

tr = 1

2 + 1

2

(cid:17)

.

Noting that len(2k − r) ≤ k, we see that the formula holds for tr as well.
Lemma 4. For optimal schedule Tk = {tr}2k−1

r=1 , we have for 0 ≤ j ≤ 2k−1:

(cid:3)

2k−1(cid:88)

r=2k−j

tr = 1
2

(cid:16)

j(k − m) + (m + 3 − l)2l − 2m(cid:17) − 1,

(cid:17)

(cid:16)

where l = len(j) and m = len(2l − j).
Proof The proof is by induction on j. For j = 0, both sides are equal to 0.

For 1 ≤ j ≤ 2k−1, Lemma 3 implies that

tr = 1
2

.
Combined with the induction hypothesis for j − 1 we obtain

t2k−j = 1
2

k + 1 − len((−2j) mod 2l)

(cid:16)

j(k−m(cid:48)) + m(cid:48)+1 − len((−2j) mod 2l) + (m(cid:48)+3−l(cid:48))2l(cid:48) − 2m(cid:48)(cid:17) − 1,

2k−1(cid:88)

r=2k−j
where l(cid:48) = len(j − 1) and m(cid:48) = len(2l(cid:48) − j + 1). We distinguish two cases.
Case l(cid:48) = l − 1. This means that j = 2l−1, and hence m = l and m(cid:48) = 1. We are
done as both sides are equal to 1
Case l(cid:48) = l. This means that 2l−1 < j < 2l, hence 0 < 2l+1 − 2j < 2l. This implies
len((−2j) mod 2l) = m + 1, so we see that both sides are equal if m = m(cid:48). If
m(cid:48) = m + 1, we see that 2l − j = 2m − 1 and that therefore both sides are equal
(cid:3)
as well.

2 j(k + 4 − l) − 1.

9

2k−1(cid:88)

Theorem 6. An optimal pebble Pk uses up to max(Sk) = k + 1 storage.

Proof We prove that the storage requirements of an optimal pebble do not exceed
the storage requirements of a speed-2 pebble, hence that max(Sk) = k + 1 for an
optimal pebble as well.
Consider the rounds in which a speed-2 pebble and an optimal pebble store
the values yi = f 2k−2i
(x) for i = k, . . . , 1. We claim that an optimal pebble will
never store yi before a speed-2 pebble does. Clearly, a speed-2 pebble stores yi in
round 2k − 2i−1 for i = k, . . . , 1. However, in round 2k − 2i−1 an optimal pebble
still has to compute at least as many hashes as a speed-2 pebble needs to reach
y0:

r=2k−2i−1
using Lemma 4 for j = 2i−1.

tr = 2i−2(k + 4 − i) − 1 ≥ 2i − 1,

(cid:3)

The above analysis implies that the optimal schedule Tk is essentially unique.
That is, if we require that the bounds stated in Theorems 5 and 6 must be met,
optimal schedule Tk is basically the only solution within our framework for binary
pebbling. Clearly, like for any schedule in our framework, we have T0 = {} and
T1 = {1}. For k ≥ 2, we ﬁrst note that optimal schedule Tk must start with
2k−1− 1 zeros in order to meet the bound of Theorem 6. More precisely, by writing
Sk = Ak (cid:107) k+1 (cid:107) Bk with |Ak| = |Bk| = 2k − 1, as we also did in the proof of
Theorem 4, and noting that max(Bk) = k, we observe that this bound for Bk is met
only if optimal pebble Pk does not perform any hashes in its ﬁrst 2k−1 − 1 rounds.
Next, by reconsidering the proof of Theorem 5 we actually see that the number of
hashes performed by an optimal pebble Pk in each of the last 2k−1 rounds of its
initial stage is determined uniquely as well. A simple calculation shows that Eq. (1)
necessarily holds for any optimal schedule: #Uk + #Vk + #Wk−1 = (k + 1)2k−2
hashes to be performed in 2k−1 rounds requires exactly (k + 1)/2 hashes to be
performed in each of these rounds. Hence, using induction on k, we see that Uk
and Vk are determined uniquely by Eq. (1).
aﬀecting optimality. For example, we round T2 = {0, 3
In general, we make sure that if an element is rounded up then its neighbors are
rounded down, and vice versa. The rounding also depends on the parity of k to
alternate between rounding up and rounding down. Hence, we deﬁne the rounded
optimal schedule by:

As a ﬁnal step we will round the optimal schedule Tk to integer values, without
2} to {0, 1, 2} or to {0, 2, 1}.

2 , 3

(cid:16)

(cid:106) 1

2

tr =

(k + r) mod 2 + k + 1 − len((2r) mod 2len(2k−r))

,

(2)

for 2k−1 ≤ r < 2k. Accordingly, we see that optimal pebble Pk will use up to
max(Wk) = (cid:100)k/2(cid:101) hashes in any output round, matching the lower bound of
Theorem 2.

10

(cid:17)(cid:107)

6 Optimized Implementations

A hash chain is deployed as follows as part of an authentication mechanism like
Lamport’s asymmetric identiﬁcation scheme. Given a random seed value x, the
initial stage of any type of binary pebble Pk(x) is simply performed by iterating
the hash function f and storing the values yi = f 2k−2i
(x) for i = k, . . . , 0. The
value of y0 is then output, e.g., as part of the registration protocol for Lamport’s
scheme. The other hash values y1, . . . , yk are stored for the remainder of the output
stage, e.g., for use in later runs of Lamport’s identiﬁcation protocol.

The initial stage is preferably executed inside the secure device that will later
use the hash chain for identiﬁcation. However, for lightweight devices such as
smart cards, RFID tags, sensors, etc., the initial stage will typically be run on a
more powerful device, after which the hash values y1, . . . , yk will be inserted in the
lightweight device and the hash value y0 can be used for registration.

To implement the output stage of a pebble Pk one needs to handle potentially
many pebbles all running in parallel. The pseudocode in [Jak02,CJ02,YSEL09]
suggests rather elaborate techniques for keeping track of the (state of) pebbles.
On the contrary, we will show how to minimize storage and computational overhead
by exploiting speciﬁc properties of Jakobsson’s speed-2 pebbles and our optimal
pebbles. In particular, we present in-place hash chain reversal algorithms, where
the entire state of these algorithms (apart from the hash values) is represented
between rounds by a single k-bit counter only.

We introduce the following terminology to describe the state of a pebble Pk.
This terminology applies to both speed-2 pebbles and optimal pebbles. Pebble Pk
is said to be idle if it is in rounds [1, 2k−1), hashing if it is in rounds [2k−1, 2k],
and redundant if it is in rounds (2k, 2k+1). An idle pebble performs no hashes
at all, while a hashing pebble will perform at least one hash per round, except for
round 2k in which Pk outputs its y0 value. The work for a redundant pebble Pk is
taken over by its child pebbles P0, . . . , Pk−1 during its last 2k − 1 output rounds.
The following theorem provides the basis for our in-place algorithms by showing
precisely how the state of all pebbles running in parallel during the output stage
of a pebble Pk can be determined from the round number. Let xi ∈ {0, 1} denote
the ith bit of nonnegative integer x, 0 ≤ i < len(x).
Theorem 7. For a speed-2 pebble or optimal pebble Pk in output round 2k+1 − c,
1 ≤ c ≤ 2k, we have for every i, 0 ≤ i ≤ k, exactly one non-redundant pebble Pi
present if and only if bit ci = 1, and if present, Pi is in round 2i − (c mod 2i).
Proof The proof is by induction on c. For c = 2k, only ck = 1, which corresponds
to pebble Pk being the only pebble around. Also, Pk is in its 2kth round.
=
0. Hence c(cid:48)
i(cid:48) = 1. By the induction hypothesis for c(cid:48), pebble Pi(cid:48) is in its ﬁrst output
round 2i(cid:48)
. So, in the next round Pi(cid:48) becomes redundant, and is replaced by child
pebbles Pi(cid:48)−1, . . . , P0 which will all be in their ﬁrst round. As c = c(cid:48) − 1, this
corresponds to the fact that ci(cid:48) = 0 and ci(cid:48)−1 = ··· = c0 = 1, also noting that
2i − (c mod 2i) = 1 for i = i(cid:48) − 1, . . . , 0.

For 1 ≤ c < 2k, write c(cid:48) = c+1 and let i(cid:48) ≥ 0 be maximal such that c(cid:48) mod 2i(cid:48)

11

For i > i(cid:48), we have ci = c(cid:48)

i. All non-redundant pebbles in round 2k+1 − c(cid:48)
remain so in round 2k+1 − c, and for these pebbles the round number becomes
2i − (c(cid:48) mod 2i) + 1 = 2i − (c mod 2i), as required.
(cid:3)

As a corollary, we see that a non-redundant pebble Pi is hashing precisely when
ci−1 = 0, and Pi is idle otherwise, since for ci = 1 we have that ci−1 = 0 if and
only if 2i − (c mod 2i) ≥ 2i−1. This holds also for i = 0 if we put c−1 = 0.

6.1

In-Place Speed-2 Binary Pebbles

We present an in-place implementation of a speed-2 pebble Pk for which the overall
storage is limited to the space for k hash values and one k-bit counter c. As
explained above, we will assume that hash values y1, . . . , yk are given as input
and that y0 has been output already. Thus, Pk has exactly 2k − 1 output rounds
remaining. We use c to count down the output rounds.

The basis for our in-place algorithm is given by the next theorem.

Theorem 8. For a speed-2 pebble Pk in output round 2k+1 − c, 1 ≤ c ≤ 2k, each
non-redundant pebble Pi present stores e + 1 hash values, where e is maximal such
that ci−1 = . . . = ci−e = 0 with 0 ≤ e ≤ i.
Proof From Theorem 7 it follows that non-redundant pebble Pi is in round
r = 2i− (c mod 2i). Since 0 ≤ e ≤ i is maximal such that ci−1 = . . . = ci−e = 0, we
have that 2i − 2i−e < r ≤ 2i − 2i−e−1. This implies that Pi stores e + 1 hash values
in round r, as Lemma 2 says that for a speed-2 pebble Pi the storage requirements
throughout its ﬁrst 2i rounds are given by sequence Di, where D0 = {1} and
Di = 1∗2i−1 (cid:107) 1 + Di−1.
(cid:3)

Theorem 8 suggests an elegant approach to store the hash values for a speed-2
pebble Pk throughout its output stage. We use a single array z of length k to
store all hash values as follows. Initially, z[0] = y1, . . . , z[k − 1] = yk, and counter
c = 2k − 1. This corresponds to pebble Pk being at the start of its output stage,
where it starts to run pebbles Pi(yi+1) in parallel, for i = 0, . . . , k− 1, each of these
(non-redundant) pebbles Pi storing exactly one hash value in array z. In general,
in output round 2k+1 − c of Pk, we let each non-redundant pebble Pi store its hash
values in array z in segment z[i − e, i] (corresponding to ci−e = 0, . . . , ci−1 = 0
and ci = 1). As a result, the non-redundant pebbles jointly occupy consecutive
segments of array z, storing exactly len(c) hash values in total.
Algorithm 1 describes precisely what pebble Pk does in round r, 2k < r < 2k+1.
Note that we set c = 2k+1 − r at the start of round r. Based on Theorem 7, we
process the bits of c as follows, using operations pop0(c) and pop1(c) to count and
remove all trailing 0s and 1s from c, respectively.
= 0. Hence ci(cid:48) = 1. From Theorem 7,
we see that pebble Pi(cid:48) is in its ﬁrst output round 2i(cid:48)
, hence Pi(cid:48) becomes redundant
in the next round, and each of its children will take over one hash value. The hash
values y0, . . . , yi(cid:48) computed by Pi(cid:48) in its initial stage are stored in z[0], . . . , z[i(cid:48)]. So,

Let i(cid:48) ≥ 0 be maximal such that c mod 2i(cid:48)

12

(x) for i = 1, . . . , k.

Algorithm 1 In-place speed-2 binary pebble Pk(x).
Initially: array z[0, k) where z[i−1] = f 2k−2i
Round r, 2k < r < 2k+1:
1: output z[0]
2: c ← 2k+1 − r
3: i ← pop0(c)
4: z[0, i) ← z[1, i]
5: i ← i + 1; c ← (cid:98)c/2(cid:99)
6: q ← i − 1
7: while c (cid:54)= 0 do
z[q] ← f (z[i])
if q (cid:54)= 0 then z[q] ← f (z[q])
i ← i + pop0(c) + pop1(c)
q ← i

10:

11:

8:

9:

we output z[0] = y0 for Pi(cid:48) and move y1, . . . , yi(cid:48) to entries z[0], . . . , z[i(cid:48) − 1]. This
makes entry z[i(cid:48)] available. We distinguish two cases.
Case len(c − 1) = len(c) − 1. In this case no new hash values need to be stored,
and z[i(cid:48)] will be unused from this round on.
Case len(c − 1) = len(c). Let i(cid:48)(cid:48) ≥ i(cid:48) + 1 be maximal such that c mod 2i(cid:48)(cid:48)
= 2i(cid:48)
.
Hence ci(cid:48)(cid:48) = 1. We claim that pebble Pi(cid:48)(cid:48) is the unique pebble that needs to store
an additional hash value. Pebble Pi(cid:48)(cid:48) is in round 2i(cid:48)(cid:48) − (c mod 2i(cid:48)(cid:48)
, so
it is 2i(cid:48)
rounds from the end of its initial stage. We store its additional hash value
in z[i(cid:48)].
This explains Algorithm 1. In the ﬁrst iteration of the loop in lines 7–11, we
have that q = i(cid:48) holds at line 8. Each hashing pebble performs two hashes, except
when a pebble is at the end of its initial stage (corresponding to q = 0). Essentially
no processing is done for idle pebbles, due to the use of operation pop1(c) in line 10.

) = 2i(cid:48)(cid:48) − 2i(cid:48)

6.2

In-Place Optimal Binary Pebbles

In this section we turn the algorithm for speed-2 pebbles into one for optimal
pebbles by making three major changes. See Algorithm 2.

First, we make sure that the number of hashes performed by each hashing
pebble Pi is in accordance with Eq. (2). The actual hashing by Pi is done in the
loop in lines 14–18. Theorem 7 states that the round number for Pi is given by
2i − (c mod 2i), hence by 2i − j if we set j = (−r) mod 2i in line 10. By ensuring
that l = len(j) and m = len(2l − j) holds as well, we have that the number of
hashes as speciﬁed by Eq. (2) can be computed as (cid:98)(p + i + 1 − s)/2(cid:99), where
p = (i + j) mod 2 and s = (m + 1) mod (l + 1) (actually using that len((2l −
2j) mod 2l) = len(2l+1 − 2j) mod (l + 1) holds for j ≥ 1).

Second, we make sure that each hashing pebble Pi will store the correct hash
values for yi, . . . , y0. To this end, note that Lemma 4 tells precisely how many
hashes pebble Pi still needs to compute at the start of round j. Thus we set h to
this value (plus one) in line 12, and test in line 16 if the current hash value must
be stored (that is, whether h is an integral power of 2).

13

(x) for i = 1, . . . , k.

Algorithm 2 In-place optimal binary pebble Pk(x).
Initially: array z[0, k) where z[i−1] = f 2k−2i
Round r, 2k < r < 2k+1:
1: output z[0]
2: c ← 2k+1 − r
3: i ← pop0(c)
4: z[0, i) ← z[1, i]
5: i ← i + 1; c ← (cid:98)c/2(cid:99)
6: m ← i; s ← 0
7: while c (cid:54)= 0 do

l ← i
i ← i + pop0(c)
j ← (−r) mod 2i
p ← (i + j) mod 2
h ← (cid:98)(p + j(i − m) + (m + 3 − l)2l − 2m)/2(cid:99)
q ← len(h) − 1
for d ← 1 to (cid:98)(p + i + 1 − s)/2(cid:99) do

8:

9:

10:

11:

12:

13:

14:

15:

16:

17:

18:

20:

y ← z[q]
if h = 2q then q ← q − 1
z[q] ← f (y)
h ← h − 1

19: m ← i; s ← m + 1

i ← i + pop1(c)

Finally, we make sure that hashing pebble Pi will use the correct entries of
array z. Since h records the number of hashes that Pi still needs to compute (plus
one), it follows that the current hash value for Pi is stored in entry z[q], where
q = len(h) − 1. Hence, we set q to this value in line 13.

This explains the design of Algorithm 2. Note that only one bit length compu-

tation is used per hashing pebble (cf. line 13).

6.3 Optimal Binary Pebbles with Minimal Computational Overhead

Even though the computational overhead for our in-place implementation is small,
it may still be relatively large if hash evaluations themselves take very little time.
For instance, if the hash function is (partly) implemented in hardware. Using
Intel’s AES-NI instruction set one can implement a 128-bit hash function that
takes a few cycles only (e.g., see [B ¨OS11], noting that for one-way hash chains no
collision-resistance is needed such that one can use Matyas-Meyer-Oseas for which
the key is ﬁxed). Therefore, we also provide an implementation minimizing the
computational overhead at the expense of some additional storage.

We will keep some state for each pebble, or rather for each hashing pebble
only. Although an optimal pebble Pk will store up to k hash values at any time,
we observe that no more than (cid:100)k/2(cid:101) hashing pebbles will be present at any time.
As in our in-place algorithms we will thus avoid any storage (and processing) for
idle pebbles, as can be seen from Algorithm 3.

14

(x) for i = 1, . . . , k; array a[0,(cid:98)k/2(cid:99)), v = 0.

Algorithm 3 Fast optimal binary pebble Pk(x).
Initially: array z[0, k) where z[i−1] = f 2k−2i
Round r, 2k < r < 2k+1:
1: output z[0]
2: c ← 2k+1 − r
3: i ← pop0(c)
4: z[0, i) ← z[1, i]
5: i ← i + 1; c ← (cid:98)c/2(cid:99)
6: if c odd then a[v] ← (i, 0); v ← v + 1
7: u ← v
8: w ← (r mod 2) + i + 1
9: while c (cid:54)= 0 do

w ← w + pop0(c)
u ← u − 1; (q, g) ← a[u]
for d ← 1 to (cid:98)w/2(cid:99) do

10:

11:

12:

13:

14:

15:

16:

17:

18:

y ← z[q]
if g = 0 then q ← q − 1; g = 2q
z[q] ← f (y)
g ← g − 1

if q (cid:54)= 0 then a[u] ← (q, g) else v ← v − 1
w ← (w mod 2) + pop1(c)

A segment a[0, v) of an array a of length (cid:98)k/2(cid:99) suﬃces to store the relevant
hashing pebbles, where initially v = 0. In each round, at most one idle pebble Pi
will become hashing, and if this happens pebble Pi is added to array a, cf. line 6.
Later, once pebble Pi is done hashing, it will be removed again from array a,
cf. line 17.
For each hashing pebble we store two values called q and g such that q matches
the value of variable q in Algorithm 2 and g matches the value of h − 2q in Al-
gorithm 2. Hence, we use g to count down to zero starting from the appropriate
powers of 2, cf. line 14. Finally, variable w is introduced such that its value matches
the value of p + i + 1 − s in Algorithm 2. As a result, Algorithm 3 limits the com-
putations for each hashing pebble to a few elementary operations only.

Note that Algorithm 3 is actually quite intuitive and remarkable at the same
time. E.g., by focusing on variable w, one can easily see that the total number of
hashes performed by pebble Pk in any output round does not exceed (cid:100)k/2(cid:101).

7 Extensions

In this section we brieﬂy discuss three extensions, omitting details.
First, we show how to accommodate hash chains of arbitrary length n by gen-
eralizing the initialization of Algorithms 1–3 from n = 2k to any n ≥ 1, without
incurring any overhead. That is, given a seed value x, we will iterate the hash func-
tion f for exactly n− 1 times and output f n−1(x) (e.g., as part of the registration
protocol for Lamport’s scheme). At the same time, we will store precisely those
intermediate hash values in array z such that the state becomes equivalent to the
state of binary pebble Pk at round 2k+1 − (n − 1), where 2k−1 < n ≤ 2k.

15

We demonstrate this for in-place speed-2 pebbles, by extending Theorem 8 to
the following theorem, which exactly describes the state of speed-2 pebble Pk(x)
at round c = n − 1.
Theorem 9. For a speed-2 pebble Pk(x) in output round 2k+1 − c, 1 ≤ c ≤ 2k,
each idle pebble Pi stores the hash value f c−(c mod 2i)−2i(x) and each hashing pebble
Pi stores the following e + 1 hash values:

f c−(c mod 2i)−2i

(x), . . . , f c−(c mod 2i)−2i−e+1

(x), f c−max(1,3(c mod 2i))(x),

where e is maximal such that ci−1 = . . . = ci−e = 0 with 0 ≤ e ≤ i.
Based on this theorem array z can be initialized simply by inspecting the bits of c
(most-signiﬁcant to least-signiﬁcant) while iterating f . The remaining n−1 output
rounds are then executed exactly as in Algorithm 1. A slightly more complicated
approach applies to our optimal pebbles, for which we omit the details.
Next, we show how to construct a cascade of pebbles Pk(x), Pk(x(cid:48)), Pk(x(cid:48)(cid:48)), . . .,
for seed values x, x(cid:48), x(cid:48)(cid:48), . . ., such that the initial stage of Pk(x(cid:48)) is run in parallel to
the output stage of Pk(x) (more precisely, in parallel to rounds (2k, 2k+1) of Pk(x)),
and so on. Hence, as soon as Pk(x) is done, Pk(x(cid:48)) will continue with producing
k (x(cid:48)) in reverse. In general, this combination corresponds exactly to
hash chain f∗
running the output stage of a Pk+1 pebble over and over again. Therefore, the
maximum number of hashes in any round will be limited to max(Wk+1). Using
optimal pebbles Pk, we thus get no more than (cid:100)(k + 1)/2(cid:101) hashes per round.
Moreover, we only need to store a maximum of k + 1 hash values at any time
(conceptually, the value yk+1 that a Pk+1 pebble would store is not present), hence
essentially for free; this can even be reduced to (cid:100)k/2(cid:101) per round at the expense of
increasing the maximum storage to k + 2 hash values.
To make such a cascade useful, the hash values f 2k−1(x(cid:48)), f 2k−1(x(cid:48)(cid:48)), . . . need
to be authenticated. A straightforward way is to run the registration protocol once
f 2k−1(x(cid:48)) is output, and so on. A more reﬁned way is to apply known techniques
for “re-initializing” hash chains [Goy04,ZL05], hence using a one-time signature to
authenticate f 2k−1(x(cid:48)), for which the public key is incorporated in the seed x.

In fact, this approach can be extended to eliminate initialization altogether,
basically by starting with a Pk+1 pebble in its ﬁrst output round, where each yi is
assigned a seed value incorporating a one-time public key. Setting yi = f 2k(cid:48)−2i(x)
for i = k(cid:48), . . . , 0 for some small k(cid:48), and using such seed values for the remaining
yi’s, this bootstrapping technique can be tuned for optimal performance.
Finally, we show how to eliminate the shifting done in line 4 of Algorithms 1–3,
which forms a potential bottleneck as naively copying up to k − 1 hash values may
be relatively expensive. A standard technique to avoid such excessive copying is
to use an auxiliary array of “pointers” d[0, k) such that d[i] points to the entry in
z[0, k) that should actually be used, but this would break the in-place property.
Fortunately, it turns out that permutation d can be characterized nicely as a
function of the round number, thus allowing us to eﬃciently restore the in-place
property, without copying even a single hash value throughout our algorithms.

16

8 Concluding Remarks

We have completely resolved the case of binary pebbling of hash chains by con-
structing an explicit optimal schedule. A major advantage of our optimal schedule
is that it allows for very eﬃcient in-place pebbling algorithms. This compares
favorably with the greedy pebbling algorithms of [YSEL09], which require a sub-
stantial amount of storage beyond the hash values themselves. The pseudocode of
Algorithms 1–3 is readily translated into eﬃcient program code, applying further
optimizations depending on the target platform. 2

The security of one-way hash chains for use in authentication mechanisms such
as Lamport’s asymmetric identiﬁcation scheme does not depend on the collision
resistance of the hash function. Therefore, it suﬃces to use 128-bit hash values—
rather than 256-bit hash values, say. Using, for instance, the above mentioned
Matyas-Meyer-Oseas construction one obtains a fast and simple one-way function
f : {0, 1}128 → {0, 1}128 deﬁned as f (x) = AESIV(x) ⊕ x, where IV is a 128-bit
string used as ﬁxed “key” for the AES block cipher.3 Consequently, even for very
long hash chains of length 232, our in-place optimal pebbling algorithm will just
store 516 bytes (32 hash values and one 32-bit counter) and perform at most 16
hashes per identiﬁcation round. Similarly, long hash chains of length 216 would
allow devices capable only of lightweight cryptography to run 65535 rounds of
identiﬁcation (e.g., more than twice per hour over a period of three years), requiring
only 258 bytes of storage and using at most 8 hashes per round.

We leave as an open problem whether binary pebbling yields the lowest space-
time product. Reversal of a length-n hash chain using optimal binary pebbling
requires log2 n storage and 1
2 n as space-time
product. Coppersmith and Jakobsson [CJ02] derived a lower bound of approx.
4 log2
1
2 n for the space-time product.4 Whether this lower bound is achievable is
doubtful, because the lower bound is derived without taking into account that
the maximum number of hashes during any round needs to be minimized. As a
potential alternative we mention “Fibonacci” pebbling, considering hash chains of

2 log2 n time per round, yielding 1

2 log2

2 Sample code (in Python, Java, and C) available at www.win.tue.nl/~berry/pebbling/.
3 More precisely, function f should be one-way on its iterates [Lev85,Ped96].
4 Incidentally, this lower bound had been found already in a completely diﬀerent context
[GPRS96]. Without going into details, the problem studied in the area of algorithmic (au-
tomatic/computational) diﬀerentiation [GW08] is similar to the task for our pebble Pk(x) of
computing the hash chain f∗
k(x) and outputting this sequence in reverse. The critical diﬀerence,
however, is that in the context of algorithmic diﬀerentiation the goal is basically to minimize
the total time for performing this task. This contrasts sharply with the goal in the crypto-
graphic context, where we want to minimize the maximum time spent in each output round
while performing this task. See Appendix A, where we show how to achieve both logarithmic
amortized time and logarithmic space using a trivial kind of binary pebble. The latter result is
comparable to what is achieved in [Gri92]; in fact, without the performance constraint unique
for the cryptographic setting, as initiated by Jakobsson [Jak02,CJ02], it is even possible to at-
tain the lower bound of [GPRS96]. Therefore, the solutions achieved in the area of algorithmic
diﬀerentiation (and in related areas such as reversible computing [Per13], for that matter) do
not carry over to the cryptographic setting.

17

length n = Fk, the kth Fibonacci number (e.g., for even k, storing k/2 elements
at distances F2i − 1, for 1 ≤ i ≤ k/2, from the end of the hash chain).

As another direction for further research we suggest to revisit the problem of
eﬃcient Merkle tree traversal studied in [Szy04], which plays a central role in hash-
based signature schemes [Mer87,Mer89]; in particular, it would be interesting to see
whether algorithms for generating successive authentication paths can be done in-
place. More generally, research into optimal (in-place) algorithms for hash-based
signatures is of major interest both in the context of lightweight cryptography
(e.g., see [PCTS02,MSS13]; more references in [YSEL09]) and in the context of
post-quantum cryptography (e.g., see [BDE+13]).

Acknowledgments It is a pleasure to thank Niels de Vreede and Thijs Laarhoven
for many discussions on variants of the problem, and to thank Niels especially for
suggesting the bootstrapping approach (see Section 7). Moreover, the anonymous
reviewers are gratefully acknowledged for their comments.

References

CJ02.

B ¨OS11.

BDE+13. J. Buchmann, E. Dahmen, S. Ereth, A. H¨ulsing, and M. R¨uckert. On the security of the
Winternitz one-time signature scheme. International Journal of Applied Cryptography,
3(1):84–96, 2013.
J.W. Bos, O. ¨Ozen, and M. Stam. Eﬃcient hashing using the AES instruction set. In
Cryptographic Hardware and Embedded Systems (CHES 2011), volume 6917 of Lecture
Notes in Computer Science, pages 507–522, Berlin, 2011. Springer-Verlag.
D. Coppersmith and M. Jakobsson. Almost optimal hash sequence traversal. In Fi-
nancial Cryptography 2002, volume 2357 of Lecture Notes in Computer Science, pages
102–119, Berlin, 2002. Springer-Verlag.
Goy04.
V. Goyal. How to re-initialize a hash chain. eprint.iacr.org/2004/097, April 2004.
GPRS96. J. Grimm, L. Potter, and N. Rostaing-Schmidt. Optimal time and minimum space-time
product for reversing a certain class of programs. In M. Berz, C.H. Bischof, G. Corliss,
and A. Griewank, editors, Computational DiﬀerentiationTechniques, Applications, and
Tools, pages 95–106, Philadelphia, 1996. SIAM.
A. Griewank. Achieving logarithmic growth of temporal and spatial complexity in re-
verse automatic diﬀerentiation. Optimization Methods and Software, 1(1):35–54, 1992.
A. Griewank and A. Walther. Evaluating Derivatives: Principles and Techniques of
Algorithmic Diﬀerentiation. SIAM, Reading (MA), 2nd edition, 2008.
N. Haller. The S/KEY one-time password system. In Proceedings of the Symposium
on Network and Distributed System Security (NDSS), pages 151–157. Internet Society,
February 1994. See also en.wikipedia.org/wiki/S/KEY.
G. Itkis and L. Reyzin. Forward-secure signatures with optimal signing and verifying.
In Advances in Cryptology—CRYPTO ’01, volume 2139 of Lecture Notes in Computer
Science, pages 332–354, Berlin, 2001. Springer-Verlag.
M. Jakobsson. Fractal hash sequence representation and traversal.
In Proc. IEEE
International Symposium on Information Theory (ISIT ’02), page 437. IEEE Press,
2002. Full version eprint.iacr.org/2002/001.
L. Lamport. Password authentication with insecure communication. Communications
of the ACM, 24(11):770–772, 1981.
L. Levin. One-way function and pseudorandom generators. In Proc. 17th Symposium
on Theory of Computing (STOC ’85), pages 363–365, New York, 1985. A.C.M.
R. Merkle. A digital signature based on a conventional encryption function. In Advances
in Cryptology—CRYPTO ’87, volume 293 of Lecture Notes in Computer Science, pages
369–378, Berlin, 1987. Springer-Verlag.

Lam81.

Lev85.

Mer87.

Jak02.

Gri92.

GW08.

Hal94.

IR01.

18

Mer89.

R. Merkle. A certiﬁed digital signature. In Advances in Cryptology—CRYPTO ’89, vol-
ume 435 of Lecture Notes in Computer Science, pages 218–238, Berlin, 1989. Springer-
Verlag.

MSS13. N. Mourier, R. Stampp, and F. Strenzke. An implementation of the hash-chain sig-
nature scheme for wireless sensor networks. In Lightweight Cryptography for Security
and Privacy (LightSec 2013), volume 8162 of Lecture Notes in Computer Science, pages
68–80, Berlin, 2013. Springer-Verlag.

PCTS02. A. Perrig, R. Canetti, J.D. Tygar, and D. Song. The TESLA broadcast authentication

Ped96.

Per13.
Szy04.

protocol. RSA CryptoBytes, 5(2):2–13, 2002.
T. P. Pedersen. Electronic payments of small amounts. In Security Protocols, volume
1189 of Lecture Notes in Computer Science, pages 59–68, Berlin, 1996. Springer-Verlag.
K. Perumalla. Introduction to Reversible Computing. Chapman and Hall/CRC, 2013.
M. Szydlo. Merkle tree traversal in log space and time. In Advances in Cryptology—
EUROCRYPT ’04, volume 3027 of Lecture Notes in Computer Science, pages 541–554,
Berlin, 2004. Springer-Verlag.

YSEL09. Dae Hyun Yum, Jae Woo Seo, Sungwook Eom, and Pil Joong Lee. Single-layer fractal
hash chain traversal with almost optimal complexity. In Topics in Cryptology – CT-
RSA 2009, volume 5476 of Lecture Notes in Computer Science, pages 325–339, Berlin,
2009. Springer-Verlag.
Y. Zhao and D. Li. An improved elegant method to re-initialize hash chains. eprint.
iacr.org/2005/011, January 2005.

ZL05.

A Rushing Binary Pebbles

Below we show that it is easy to achieve logarithmic space and logarithmic amor-
tized time per output round for binary pebbling algorithms. This contrasts sharply
with the binary pebbling algorithms presented in this paper, which not only achieve
logarithmic space but also logarithmic worst case time per output round.

In fact, logarithmic amortized time per output round is achieved by any binary
pebble Pk as follows directly from Theorem 1: any pebble Pk performs #Wk =
(k−2)2k−1 +1 hashes in total during its output stage consisting of 2k rounds, hence
the amortized number of hashes per output round is equal to ((k−2)2k−1 +1)/2k ≈
k/2 − 1. This holds for any schedule Tk satisfying #Tk = 2k − 1.

To achieve logarithmic space as well, we choose Tk such that the storage re-
quirements for Pk are minimized. This can simply be done by postponing the
evaluation of all hashes to the last round of the initial stage of Pk. Concretely, we
deﬁne a rushing pebble Pk by setting T0 = {} and Tk = 0∗2k−2 (cid:107) 2k − 1 for k ≥ 1.
Hence, a rushing pebble performs all 2k − 1 hashes in the last round of its initial
stage; see also Figure 2.

As a consequence, a rushing pebble minimizes its storage requirements through-
out, at the cost of some computationally very expensive rounds. This is summarized
in the following results, which we state without proof.
Theorem 10. A rushing pebble Pk uses up to max(Wk) = 2k−1 − 1 hashes in any
output round, for k ≥ 1.
Lemma 5. For a rushing pebble Pk, we have:

S0 = {1}, Sk = (0∗2k−1 (cid:107) 1 (cid:107) Sk−1) + (1∗2k−1 (cid:107) Sk−1 (cid:107) 0∗2k−1
Theorem 11. A rushing pebble Pk uses up to max(Sk) = k + 1 storage.

).

19

T4S4
10
10
10
10
10
10
10
10
10
10
10
10
10
10
115
5W4
41
40
33
40
31
30
27
40
31
30
23
30
21
20
10

T4S4
10
10
10
10
10
10
10
12
22
22
22
22
32
32
41
5W4
41
42
41
42
43
42
41
40
31
32
31
30
21
20
10

r
1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

r
1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
• •
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
• •
•

rushing
pebble P4

• •
•

•
•
• •
•

•
•
•
•
•
•
• •
•

• •
•

speed-2
pebble P4

•
• •
•

•
•
•
•
• •
•

•

•
• •
•

•
•
•
•
•
•
•
•
•
•
• •
•

• •
•

•
•
• •
•

• •
•

•

•

•

•
• •
•

•
•
•
•
• •
•

•

•
• •
•

T4S4
11
21
21
21
21
21
21
21
21
31
31
31
31
41
41
5W4
43
62
52
51
42
51
41
40
32
41
31
30
21
20
10

T4S4
10
10
10
10
10
10
10
12
22
21
21
22
22
32
33
5W4
41
41
42
42
42
42
42
40
31
31
32
30
21
20
10

r
1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

r
1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

•
• •
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
• •
•
•
•
•
•
•
•
• •
•
•
•
• •
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
• •
•
•
• •
•

speed-1
pebble P4

•
• •
•
•
•
•
•
•
•
• •
•
•
•
• •
•

•

•

•
• •
•

•
• •
•
•
•
• •
•

•
• •
•

optimal
pebble P4

• •
•

•
•
•
• •
•

•

• •
•

•
•
•
•
•
•
• •
•
•
• •
•

•

•

•

•

•

•

•

•

•
• •
•

•
• •
•
•
•
• •
•

•
• •
•

•

•

•

•

•

•

• •
•

• •
•

• •
•
•
• •
•

Fig. 2. Schedule T4 resp. work W4 and storage S4 for binary pebbles P4 in rounds r = 1, . . . , 31.
Each bullet represents a stored value, arrows represent hashing, vertical lines represent copying.

20

