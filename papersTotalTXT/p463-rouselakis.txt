Practical Constructions and New Proof Methods for Large

Universe Attribute-Based Encryption

Yannis Rouselakis

The University of Texas at Austin

jrous@cs.utexas.edu

∗
Brent Waters

The University of Texas at Austin

bwaters@cs.utexas.edu

ABSTRACT
We propose two large universe Attribute-Based Encryption
constructions. In a large universe ABE system any string
can be used as an attribute and attributes need not be
enumerated at system setup. Our ﬁrst construction estab-
lishes a novel large universe Ciphertext-Policy ABE scheme
on prime order bilinear groups, while the second achieves
a signiﬁcant eﬃciency improvement over the large universe
Key-Policy ABE system of Lewko-Waters and Lewko. Both
schemes are selectively secure in the standard model under
two “q-type” assumptions similar to ones used in prior works.
Our work brings back “program and cancel” techniques to
this problem and aims in providing practical large universe
ABE implementations.

To showcase the eﬃciency improvements over prior con-
structions, we provide implementations and benchmarks of
our schemes in Charm; a programming environment for rapid
prototyping of cryptographic primitives. We compare them
to implementations of the only three published constructions
that oﬀer unbounded ABE in the standard model.

Categories and Subject Descriptors
E.3 [Data]: Data Encryption—Public key cryptosystems

General Terms
Security; Theory

∗Supported by NSF CNS-0915361 and CNS-0952692, CNS-

1228599 DARPA through the U.S. Oﬃce of Naval Research
under Contract N00014-11-1-0382, DARPA N11AP20006,
Google Faculty Research award, the Alfred P. Sloan Fel-
lowship, Microsoft Faculty Fellowship, and Packard Foun-
dation Fellowship. Any opinions, ﬁndings, and conclusions
or recommendations expressed in this material are those of
the author(s) and do not necessarily reﬂect the views of the
Department of Defense or the U.S. Government.

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’13, November 4–8, 2013, Berlin, Germany.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-2477-9/13/11 ...$15.00.
http://dx.doi.org/10.1145/2508859.2516672.

Keywords
attribute-based encryption; large universe; unbounded; q-
type assumptions; ciphertext-policy; key-policy; Charm

1.

INTRODUCTION

Traditionally, public key encryption schemes provided any
user with the ability to share data with another speciﬁc
user in a private manner. However, in many applications
we would like to have the additional capability to encrypt
data for a set of users according to a speciﬁc policy on their
credentials. For example, one might want to store data in a
public server such that only parties with credentials of spe-
ciﬁc forms are able to decrypt.
Instead of encrypting the
data once for each party it would be beneﬁcial to be able
to encrypt only once for all desired parties. This encryp-
tion notion, called Attribute-Based Encryption (ABE), was
introduced by Sahai and Waters [36]. In this setting, each
user possesses a set of attributes/credentials and a secret
key that corresponds to these credentials. The encrypting
party can deﬁne any Boolean formula on the possible at-
tributes and a user can decrypt if and only if his attribute
set satisﬁes the Boolean formula.

Several attribute-based constructions have been presented
since then (see related work below). A common classiﬁca-
tion property is whether a system is a “small universe” or
“large universe” constructions. In “small universe” construc-
tions the size of the attribute space is polynomially bounded
in the security parameter and the attributes were ﬁxed at
setup. Moreover, the size of the public parameters grew
linearly with the number of attributes. In “large universe”
constructions, on the other hand, the size of the attribute
universe can be exponentially large, which is a desirable fea-
ture.

Achieving the large universe property can be challenging.
Diﬀerent works either imposed restrictions on the expres-
siveness of the policies or were proved secure in the random
oracle model. For example, in [20] a bound n was ﬁxed at
setup on the number of attributes that could be used while
encrypting a message. For constructions that had no bounds
on the expressiveness of policies and constant sized public
parameters, the random oracle security model was used.

The above restrictions place undesirable burdens on the
deployment of ABE schemes. If the designer of the system
desires the beneﬁts of avoiding the random oracle heuristic,
he has to pick a speciﬁc bound for the expressiveness of the
system at the setup time; either the size of the attribute uni-
verse or the bound on the policies. If the bound is too small,
the system might exhaust its functionality and will have to

463be completely rebuilt. For example, consider the design of
a framework that allows Attribute-Based Encryption in a
huge multinational company and suppose that, as this com-
pany expands, a large number of new attributes have to be
added to the system. If this number exceeds the bound set
during the initial deployment of the system, then the com-
pany would have to re-deploy the (expanded) system and
possibly re-encrypt all its data spending a huge amount of
expenses. On the other hand, if the bound chosen is too big,
the increased size of the public parameters will impose an
unnecessary eﬃciency burden on all operations.

The ﬁrst large-universe constructions in the standard mo-
del were presented in the recent work of Lewko and Waters
[25]. They presented the ﬁrst large universe KP-ABE con-
struction, secure in the standard model. The system was
proved selectively secure under static assumptions. The au-
thors of [25] refer to their construction as an “unbounded”
scheme, in the sense that the public parameters do not im-
pose additional limitations on the functionality of the sys-
tems. Their scheme is indeed large universe, since the size of
the attribute universe is exponentially large in the security
parameter.

The authors utilized the dual system framework on com-
posite order groups to prove security. While this framework
is highly useful for the proofs, the actual constructions re-
quire use of bilinear groups of large composite order. As a
result, these schemes sustain a signiﬁcant eﬃciency overhead
in comparison to prime order ABE constructions. In a recent
result [22] building on [30, 32, 23, 17], one can actually “em-
ulate” the eﬀects of the composite order groups by creating
special subspaces of vectors, called dual vector spaces intro-
duced by Okamoto and Takashima, and construct a large
universe KP-ABE system on prime order groups. This im-
proves the eﬃciency of the original construction, but there
is still a signiﬁcant performance penalty due to the required
size of the vectors.

In a subsequent work by Okamoto and Takashima [33], an-
other unbounded KP-ABE scheme and the ﬁrst unbounded
CP-ABE scheme are presented. Both of them are the ﬁrst
fully secure unbounded ABE schemes in the standard model
and utilize the dual vector spaces framework. Their sys-
tems are unbounded, since the size of the public parame-
ters is constant and does not impose any limitations on the
size of the attribute universe. However, the traditional no-
tion of “large”-“small” universe is not applicable, since each
“attribute” can take one or more diﬀerent values from an
exponential-sized space, instead of “present”/“not present”.
The total number of these sub-universes should be polyno-
mial in the security parameter and the maximum number
of times each sub-universe can be used in a policy is a pa-
rameter ﬁxed at the setup of the system. As this bound is
increased, the overall eﬃciency of the system is impaired.
In our benchmarks, we implement the most eﬃcient “basic
version” of their constructions where this parameter is equal
to 1, i.e. each sub-universe can be present only once in each
policy.

Goals and Contributions We present new construc-
tions and proof techniques for Large Universe ABE in the
standard model. Departing from the above recent trends,
our constructions are proved selectively secure using what is
know as partitioning style techniques.

We believe that this is an interesting avenue to explore
for two reasons. First, by considering selective model of

security we are able to get more eﬃcient and more practical
constructions. While full security is the strongest notion
of security, we believe selective is still a meaningful notion
and can be a reasonable trade oﬀ for performance in some
circumstances. In addition, new partitioning proofs can give
diﬀerent and new insights into the security or the style of a
construction.

Second, Lewko and Waters [26] recently showed a surpris-
ing connection between Dual System Encryption and older
selective proofs. Prior fully secure ABE systems [23] re-
quired an additional (relative to selective schemes) limit t on
the number of times an attribute could be used in a formula.
The public parameters and ciphertext size for KP-ABE (key
size for CP-ABE) grew proportionally to the bound t. Lewko
and Waters showed that through a new “delayed parameter”
variant of Dual System Encryption this limit could be done
away with. An integral part of their proof was that it lever-
aged older “program and cancel” style techniques. Given
this recent work, a reasonable conclusion is that developing
selectively secure proofs might typically become a ﬁrst step
to developing full security. (We note that the large universe
construction of [25] was only proved selectively secure.)
We aim to get practical large-universe ABE schemes

by adapting and expanding the system from [25] into the
prime order setting. In proving security we go back to more
traditional “program and cancel” techniques instead of the
dual system framework. We present two practical large uni-
verse ABE constructions (one CP-ABE and one KP-ABE)
in prime order bilinear groups both selectively secure in the
standard model under two diﬀerent q-type assumptions. Our
three main objectives in this work were large universe con-
structions, eﬃciency, and security in the standard model.
Both schemes support a “large universe” attribute space and
their public parameters consist of a constant number of
group elements. No bounds or other restrictions are im-
posed on the monotonic Boolean formulas or the attribute
sets used by the algorithms of the schemes; thus eliminat-
ing the need for design decisions at setup. The eﬃciency
objective refrained us from using composite order groups or
dual pairing vector spaces, while to achieve security in the
standard model we relied on non static (q-type) assumptions
and selective notions. These assumptions are non static in
the sense that a polynomial number of terms is given to the
adversary and therefore they are intuitively stronger than
the static ones. However, the polynomial number of terms
gives the ability to the simulator of the proof to embed the
additional entropy in the constant number of public param-
eters. We showcase diﬀerent techniques for harnessing the
power of these assumptions to achieve our large universe
constructions. Finally, we demonstrate the eﬃciency of our
constructions by implementing our schemes. We compare
performance results to other ABE schemes in prime order
groups.

Our Techniques The techniques used to achieve our
goals and prove the security of our schemes fall in the cate-
gory of partitioning methodologies. In this setting the sim-
ulator of the reduction sets up the public parameters of the
systems in such a way that the set of the possible poli-
cies (for KP-ABE) or the powerset of the attribute universe
(for CP-ABE) is partitioned in two disjoint sets. One for
which he can create the secret keys and answer the attack-
ers’ queries, and one for which this is not possible, where the
challenge query should belong. Since we are dealing with se-

464lective security notions, the simulator knows in advance the
required challenge set and therefore the suitable partition.
However due to the fact that we are aiming for large uni-
verse ABE, which implies constant size public parameters,
the simulator has to embed a polynomial amount of “chal-
lenge information” in them. This is achieved by utilizing the
non static power of our assumptions. Namely, the assump-
tions’ “size” depends on the size of the declared challenge
query. The additional terms available to the simulator allow
him to create all the necessary terms for the reduction.

Both our schemes work in a “layered” fashion in order
to encrypt information securely and being able to decrypt.
In the KP-ABE construction, which is simpler and directly
inspired by the composite order construction of [25], two
“layers” are employed: the “secret sharing” layer and the “at-
tribute layer”. The ﬁrst layer is responsible for the sharing
of the master secret key during the key generation algorithm
and the storing of the blinding factor randomness during the
encryption algorithm. The “attribute layer” holds informa-
tion about the attributes used in both key generation and
encryption phases. A “binder term” is utilized to connect the
two layers in a secure way. In the CP-ABE construction the
situation is slightly more complicated due to the fact that
the policies are applied on the ciphertext side. As a result,
the “sharing” is applied to the blinding factor randomness
and not on the master secret key. Therefore, an additional
“binder term” in the public parameters is being used to al-
low correct decryption using the master secret key. As we
will see, the assumptions and the corresponding reductions
follow closely this “layer” intuition.

Finally, we mention that both constructions use the “in-
dividual randomness” technique from [25] in the “attribute
layer” to achieve the large universe functionality. The com-
ponent for each attribute is masked by a diﬀerent random-
ness and as a result no restrictions are imposed on the poli-
cies or the attributes, since each component is individually
randomized.

1.1 Related Work

Attribute-Based Encryption was introduced by Sahai and
Waters [36]. The reﬁnement of the two notions was given
in [20] and many CP-ABE and KP-ABE selectively secure
constructions followed [6, 15, 19, 34, 35, 43]. Most of them
work for monotonic access structures with the exception
of the schemes by Ostrovsky, Sahai, and Waters [34], who
showed how to realize negation by incorporating speciﬁc re-
vocation schemes into the GPSW construction. Fully se-
cure constructions in the standard model were ﬁrst provided
by Okamoto and Takashima [32] and Lewko, Okamoto, Sa-
hai, Takashima, and Waters [23]. The ﬁrst large universe
KP-ABE construction in the standard model was given in
[25] (composite order groups) and the ﬁrst fully secure un-
bounded constructions were given in [33]. Okamoto and
Takashima initiated the dual pairing vector space frame-
work in various works [30, 31, 32], which lead to the ﬁrst
large universe KP-ABE construction in prime order group
groups by Lewko [22]. Parameterized (non static) assump-
tions were introduced in [7] and used in several subsequent
works [18, 43]. The problem of an environment with mul-
tiple central authorities in ABE was considered in [13, 14,
24], while several authors have presented schemes that do
not address the problem of collusion resistance [40, 28, 11,
2, 3, 4].

We note that several techniques in ABE schemes have
roots in Identity-Based Encryption [37, 8, 16, 7, 42, 18, 9].
Finally, we mention here the related concept of Predicate
Encryption introduced by Katz, Sahai, and Waters [21] and
further reﬁned in [39, 38, 31, 23, 32, 10].
1.2 Organization

In Sec. 2 we introduce some notation, background in-
formation about access structures and linear secret-sharing
schemes, and the complexity assumption for our CP-ABE
scheme. Section 3 contains the algorithms and the selective
security deﬁnition for CP-ABE schemes. Our CP-ABE con-
struction and the security proof are in Sec. 4. Finally, im-
plementations and eﬃciency results are presented in Sec. 5.
The assumption for our KP-ABE construction is in App. A.
In App. B and App. C we present the KP-ABE algorithms
with the security deﬁnition, and our KP-ABE construction
with the security proof, respectively.

2. PRELIMINARIES
2.1 Notation

p

$← S as shorthand for s1

For n ∈ N, we deﬁne [n] def.= {1, 2, . . . , n}. Also, for
n1, n2, . . . , nk ∈ N:
[n1, n2, . . . , nk] def.= [n1] × [n2] × . . . ×
[nm]. When S is a set, we denote by s $← S the fact that
the variable s is picked uniformly at random from S. We
$←
write s1, s2, . . . , sn
$← S. By negl(n) we denote a negligible function
S, . . . , sn
in n and by PPT probabilistic polynomial-time.
The set of matrices of size m × n with elements in Zp is
denoted by Zm×n
. Special subsets are the set of row vectors
of length n: Z1×n
, and column vectors of length n: Zn×1
.
When (cid:126)v is a vector (of any type), we will denote by vi the
i-th element and by (cid:104)(cid:126)v, (cid:126)w(cid:105) the inner product of vectors (cid:126)v
and (cid:126)w.
2.2 Access Structures and

$← S, s2

p

p

Linear Secret-Sharing Schemes

In this section, we present the formal deﬁnitions of access
structures and linear secret-sharing schemes introduced in
[5], adapted to match our setting.
Deﬁnition 2.1 (Access Structures [5]). Let U be the at-
tribute universe. An access structure on U is a collection A
of non-empty sets of attributes, i.e. A ⊆ 2U \ { }. The sets
in A are called the authorized sets and the sets not in A are
called the unauthorized sets.
∀B, C ∈ A : if B ∈ A and B ⊆ C, then C ∈ A.

Additionally, an access structure is called monotone if

In our constructions, we only consider monotone access
structures, which means that as a user (CP-ABE setting)
acquires more attributes, he will not lose his possible decryp-
tion privileges. General access structures in large universe
ABE can be realized by splitting the attribute universe in
half and treating the attributes of one half as the negated
versions of the attributes in the other half [20]. We note that
if the access structure is encoded as a monotonic Boolean
formula over attributes1, there is a generic algorithm that

1A monotonic Boolean formula consists of only AND, OR,
and threshold gates, for example A1∧(A2∨A3). This means

465generates the corresponding access policy in polynomial time
[5, 24].

Deﬁnition 2.2 (Linear Secret-Sharing Schemes (LSSS) [5]).
Let p be a prime and U the attribute universe. A secret-
sharing scheme Π with domain of secrets Zp realizing access
structures on U is linear over Zp if

1. The shares of a secret s ∈ Zp for each attribute form

a vector over Zp.

p

2. For each access structure A on U, there exists a matrix
M ∈ Z(cid:96)×n
, called the share-generating matrix, and a
function ρ, that labels the rows of M with attributes
from U, i.e. ρ : [(cid:96)] → U, which satisfy the following:
During the generation of the shares, we consider the
column vector (cid:126)v = (s, r2, . . . , rn)(cid:62), where r2, . . ., rn
$← Zp. Then the vector of (cid:96) shares of the secret s
according to Π is equal to M(cid:126)v ∈ Z(cid:96)×1
. The share
(M(cid:126)v)j where j ∈ [(cid:96)] “belongs” to attribute ρ(j).
We will be referring to the pair (M, ρ) as the policy of
the access structure A.

p

In our setting,

secret s according to Π, it is true that: (cid:80)

According to [5], each secret-sharing scheme (not only the
linear ones) should satisfy the reconstruction requirement
(each authorized set can reconstruct the secret) and the se-
curity requirement (any unauthorized set cannot reveal any
partial information about the secret).
let S denote an authorized set for the
access structure A encoded by the policy (M, ρ). Then
let I be the set of rows whose labels are in S, i.e. I =
{i|i ∈ [(cid:96)] ∧ ρ(i) ∈ S}. The reconstruction requirement as-
serts that the vector (1, 0, . . . , 0) is in the span of rows of M
indexed by I. This means that there exist constants {ωi}i∈I
in Zp such that for any valid shares {λi = (M(cid:126)v)i}i∈I of a
i∈I ωiλi = s.
Additionally, it has been proved in [5] that the constants
{ωi}i∈I can be found in time polynomial in the size of the
share-generating matrix M .
On the other hand, for unauthorized sets S(cid:48) no such con-
stants {ωi} exist. Moreover,
in this case it is also true
that if I(cid:48) = {i|i ∈ [(cid:96)] ∧ ρ(i) ∈ S(cid:48)}, there exists a vector (cid:126)w ∈
Z1×n
, such that its ﬁrst component w1 is any non zero el-
ement in Zp and (cid:104) (cid:126)Mi, (cid:126)w(cid:105) = 0 for all i ∈ I(cid:48), where (cid:126)Mi =
(Mi,1, Mi,2, . . . , Mi,n); the i-th row of M .
2.3 Assumption 1

p

For our CP-ABE construction we will use a q-type as-
sumption on prime order bilinear groups, denoted by q-1,
which is similar to the Decisional Parallel Bilinear Diﬃe-
Hellman Exponent Assumption [43]. It is parameterized by
a security parameter λ ∈ N and an integer q, polynomial
in λ. We assume that there exists a group generator algo-
rithm G(1λ) → (p, G, GT , e) that outputs the description of
the (symmetric) bilinear group of order p = Θ(2λ). This as-
sumption can be proved secure in the generic group model,
but the proof is omitted due to space constraints. It is de-
ﬁned via the following game between a challenger and an
attacker:

Initially the challenger calls the group generation algo-
rithm with input the security parameter, picks a random

that as a key (in CP-ABE) or a ciphertext (in KP-ABE)
acquires more attributes it will not lose the decryption ca-
pabilities.

j

, gbj , gsbj , gaibj , gai/b2

group element g $← G, and q + 2 random exponents a, s, b1,
$← Zp. Then he sends to the attacker the group
b2, . . ., bq
description (p, G, GT , e) and all of the following terms:
g, gs
∀(i, j) ∈ [q, q]
gai
∀(i, j, j(cid:48)) ∈ [2q, q, q] with j (cid:54)= j(cid:48)
gaibj /b2
j(cid:48)
∀(i, j) ∈ [2q, q] with i (cid:54)= q + 1
gai/bj
∀(i, j, j(cid:48)) ∈ [q, q, q] with j (cid:54)= j(cid:48)
gsaibj /bj(cid:48) , gsaibj /b2
j(cid:48)
The challenger also ﬂips a random coin b $← {0, 1} and if
b = 0, it gives to the attacker the term e(g, g)saq+1
. Other-
wise it gives a random term R $← GT . Finally the attacker
outputs a guess b(cid:48) ∈ {0, 1}.
Deﬁnition 2.3. We say that the q-1 assumption holds if all
PPT attackers have at most a negligible advantage in λ in
the above security game, where the advantage is deﬁned as
Adv = Pr [b(cid:48) = b] − 1/2.

Remark: Notice the absence of the term gaq+1/bj in the
fourth line of the assumption. If this term were given to the
attacker, then he could break the assumption trivially by
pairing it with the corresponding gsbj term. On the other
hand, the term gaq+1bj /b2
j(cid:48) is given, and this poses no prob-
lems in the generic group model since j (cid:54)= j(cid:48) and by possible
pairing the adversary cannot get rid of the bj’s.
3. CIPHERTEXT - POLICY ATTRIBUTE -

BASED ENCRYPTION

3.1 Algorithms

A Ciphertext-Policy Attribute-Based Encryption scheme
• Setup(1λ) → (pp, msk):

consists of the following four PPT algorithms:
The Setup algorithm takes
the security parameter λ ∈ N encoded in unary and outputs
the public parameters pp and the master secret key msk.
We assume that the public parameters contain a description
of the attribute universe U. 2
• KeyGen(1λ, pp, msk,S) → sk: The key generation al-
gorithm takes as inputs the public parameters pp, the master
secret key msk and a set of attributes S ⊆ U. The secu-
rity parameter is included in the inputs to ensure that it is
polynomial time in λ. The algorithm generates a secret key
corresponding to S.
• Encrypt(1λ, pp, m, A) → ct: The encryption algorithm
takes as inputs the public parameters pp, a plaintext message
m, and an access structure A on U. It outputs the ciphertext
ct.
• Decrypt(1λ, pp, sk, ct) → m: The decryption algorithm
takes as inputs the public parameters pp, a secret key sk,
and a ciphertext ct. It outputs the plaintext m.

Correctness: We require that a CP-ABE scheme is
correct, i.e the decryption algorithm correctly decrypts a
ciphertext of an access structure A with a secret key on S,
when S is an authorized set of A. Formally:
2In previous CP-ABE constructions the attribute universe U
(or its size) was one of the arguments of the Setup algorithm.
In our constructions, the attribute universe depends only on
the size of the underlying group G, which depends on the
security parameter λ and the group generation algorithm.

466Deﬁnition 3.1. A CP-ABE scheme is correct when for all
messages m, and all attribute sets S and access structures A
with S ∈ A (i.e. for S authorized), any pair (pp, msk) out-
put from Setup(1λ), any secret key sk output from KeyGen
(1λ, pp, msk,S), and any ciphertext ct output by Encrypt
(1λ, pp, m, A), it is true that: Decrypt(1λ, pp, sk, ct) = m.
3.2 CP-ABE Selective Security

In this section we present the deﬁnition of selective se-
curity for CP-ABE schemes. This is described by a game
between a challenger and an attacker and is parameterized
by the security parameter λ ∈ N. The phases of the game
are the following:

• Initialization:

In this phase the attacker declares the
challenge access structure A∗, which he will try to attack,
and sends it to the challenger.
• Setup: Here the challenger calls the Setup(1λ) algo-
rithm and sends the public parameters pp to the attacker.
• Query Phase 1:
In this phase the attacker can
adaptively ask for secret keys for the sets of attributes S1, S2,
. . ., SQ1 . For each Si the challenger calls KeyGen(msk,Si) →
ski and sends ski to the attacker. The restriction that has
to be satisﬁed for each query is that none of the queried sets
satisﬁes the challenge access structure, i.e. ∀i ∈ [Q1] : Si /∈
A∗.

• Challenge:

The attacker declares two equal-length
plaintexts m0 and m1 and sends them to the challenger. He
ﬂips a random coin b ∈ {0, 1} and calls Encrypt(mb, A∗) →
ct. He sends ct to the attacker.
• Query Phase 2: This the same as query phase 1. The
attacker asks for the secret key for the sets SQ1+1, SQ1+2,
. . ., SQ, for which the same restriction holds: ∀i ∈ [Q] : Si /∈
A∗.
• Guess: The attacker outputs his guess b(cid:48) ∈ {0, 1} for

b.

Deﬁnition 3.2. A CP-ABE scheme is selectively secure if
all PPT attackers have at most a negligible advantage in λ in
the above security game, where the advantage of an attacker
is deﬁned as Adv = Pr [b(cid:48) = b] − 1/2.

4. OUR LARGE UNIVERSE CP-ABE

In this section we present our large universe CP-ABE con-
struction. The public parameters consist of the six group el-
ements (g, u, h, w, v, e(g, g)α), which intuitively are utilized
in two separate “layers” to achieve secure large universe
CP-ABE.
In the “attribute layer”, the u, h terms provide
a Boneh-Boyen-style [7] hash function (uAh), while in the
“secret sharing layer” the w term holds the secret random-
ness r during key generation and the shares of the secret
randomness s during encryption. The v term is used to
“bind” the two layers together. The g and e(g, g)α terms are
used to introduce the master secret key functionality and
allow correct decryption.
4.1 Construction

Our scheme consists of the following four algorithms:
• Setup(1λ) → (pp, msk): The setup algorithm calls the
group generator algorithm G(1λ) and gets the descriptions
of the groups and the bilinear mapping D = (p, G, GT , e),
where p is the prime order of the groups G and GT . The
attribute universe is U = Zp.

Then the algorithm picks the random terms g, u, h, w, v $←

G and α $← Zp. It outputs

pp = (D, g, u, h, w, v, e(g, g)α)

msk = (α)
• KeyGen(msk,S = {A1, A2, . . . , Ak} ⊆ Zp) → sk:

Ini-
tially, the key generation algorithm picks k+1 random expo-
$← Zp. Then it computes K0 = gαwr,
nents r, r1, r2, . . . , rk
K1 = gr, and for every τ ∈ [k]

Kτ,2 = grτ and Kτ,3 = (uAτ h)rτ v

−r

• Encrypt(m ∈ GT , (M, ρ)) → ct:

The secret key output is sk = (S, K0, K1,{Kτ,2, Kτ,3}τ∈[k]).
The encryption
algorithm takes the plaintext message m and the access
structure encoded in an LSSS policy, with M ∈ Z(cid:96)×n
and
ρ : [(cid:96)] → Zp. First, it picks (cid:126)y = (s, y2, . . . , yn)(cid:62) $← Zn×1
.
In the terminology of Sec. 2.2, s is the random secret to
be shared among the shares. The vector of the shares is
(cid:126)λ = (λ1, λ2, . . . , λ(cid:96))(cid:62) = M (cid:126)y.

It then picks (cid:96) random exponents t1, t2, . . . , t(cid:96)

$← Zp and
calculates C = m · e(g, g)αs, C0 = gs, and for every τ ∈ [(cid:96)]

p

p

Cτ,1 = wλτ vtτ , Cτ,2 = (uρ(τ )h)

−tτ and Cτ,3 = gtτ

The ciphertext output is

ct = ((M, ρ), C, C0,{Cτ,1, Cτ,2, Cτ,3}τ∈[(cid:96)])

• Decrypt (sk, ct) → m:

constants {ωi ∈ Zp}i∈I such that(cid:80)

Firstly, the decryption algo-
rithm calculates the set of rows in M that provide a share to
attributes in S, i.e. I = {i : ρ(i) ∈ S}. Then it computes the
i∈I ωi (cid:126)Mi = (1, 0, . . . , 0),
where (cid:126)Mi is the i-th row of the matrix M . These constants
exist if the set S is an authorized set of the policy (c.f. Sec.
2.2).

Then it calculates

(cid:81)

B =

e(C0, K0)

i∈I (e(Ci,1, K1)e(Ci,2, Kτ,2)e(Ci,3, Kτ,3))ωi

where τ is the index of the attribute ρ(i) in S (it depends
on i). The algorithm outputs m = C/B.

If the attribute set S of the secret key is

authorized, we have that(cid:80)

Correctness:

i∈I ωiλi = s. Therefore:

e(g, g)αse(g, w)rs

i∈I e(g, w)rωiλi e(g, v)rtiωi e(g, uρ(i)h)−rτ tiωi

·

(cid:81)
(cid:81)
e(g, w)r(cid:80)

B =

=

1

i∈I e(g, uρ(i)h)rτ tiωi e(g, v)−rtiωi

e(g, g)αse(g, w)rs
i∈I ωiλi

= e(g, g)αs

4.2 Proof of Selective Security

We will prove the following theorem regarding the selec-

tive security of our CP-ABE scheme:

Theorem 4.1. If the q-1 assumption holds then all PPT
adversaries with a challenge matrix of size (cid:96) × n, where
(cid:96), n ≤ q, have a negligible advantage in selectively breaking
our scheme.

467Proof. To prove the theorem we will assume that there exists
a PPT attacker A with a challenge matrix that satisﬁes the
restriction, which has a non negligible advantage AdvA in
selectively breaking our scheme. Using this attacker we will
build a PPT simulator B that attacks the q-1 assumption
with a non negligible advantage.
Initialization: B receives the given terms from the as-
sumption and a challenge policy (M∗, ρ∗) from A. We have
that M∗ is an (cid:96)×n matrix, where (cid:96), n ≤ q, and ρ∗ : [(cid:96)] → Zp.
Setup: The simulator B has to provide A the public pa-
rameters of the system. In order to do that it implicitly sets
the master secret key of the scheme to be α = aq+1 + ˜α,
where a, q are set in the assumption and ˜α $← Zp is a known
to B random exponent. Notice that this way α is correctly
distributed and a is information-theoretically hidden from
A. Then B picks the random exponents ˜v, ˜u, ˜h $← Zp and
using the assumption gives to A the following public param-
eters:

g = g

u = g ˜u ·(cid:81)
h = g˜h ·(cid:81)
v = g ˜v ·(cid:81)

w = ga

(j,k)∈[(cid:96),n]

(j,k)∈[(cid:96),n]

gak/b2

j

gak/b2

j

(cid:16)
(cid:16)
(cid:16)

j,k

(cid:17)M∗
(cid:17)−ρ∗(j)M∗
(cid:17)M∗

j,k

j,k

(j,k)∈[(cid:96),n]
e(g, g)α = e(ga, gaq

gak/bj
) · e(g, g) ˜α

The term w is properly distributed in A’s view because the
term e(g, g)α hides the exponent a information-theoretically.
The terms v, u, h are also properly distributed due to ˜v, ˜u, ˜h,
respectively. Notice that all terms can be calculated by the
simulator using suitable terms from the assumption and the
challenge policy given by A.

As one can see, the “attribute layer”, which consists of the
terms u, h, is made up of terms whose exponents have b2
i in
the denominator, the “binder term” v has bi, and the “secret
sharing layer” w has only one power of a. This scaling of the
powers of bi will allow our simulator to properly simulate all
terms.

for an attribute set S =(cid:8)A1, A2, . . . , A|S|(cid:9) received by A.

Query phases 1 and 2: Now the simulator has to pro-
duce secret keys for non authorized sets of attributes re-
quested by A. In both phases the treatment is the same.
We describe here the way B works in order to create a key
Since S is non authorized for (M∗, ρ∗), there exists a vec-
p such that w1 = −1 and
tor (cid:126)w = (w1, w2, . . . , wn)
i , (cid:126)w(cid:105) = 0 for all i ∈ I = {i|i ∈ [(cid:96)] ∧ ρ∗(i) ∈ S} (c.f. Sec.
(cid:104) (cid:126)M∗
2.2). The simulator calculates (cid:126)w using linear algebra. Then
it picks ˜r $← Zp and implicitly sets

(cid:62) ∈ Zn

r = ˜r + w1aq + w2aq−1 + . . . + wnaq+1−n = ˜r +

wiaq+1−i

(cid:88)

i∈[n]

This is properly distributed due to ˜r. Then using the

suitable terms from the assumption it calculates:

gwiaq+2−i

g ˜αga˜r (cid:89)
gaq+2−i(cid:17)wi
(cid:16)
(cid:16)
gaq+1−i(cid:17)wi

i∈[n]

K0 = gαwr = gaq+1

n(cid:89)
K1 = gr = g ˜r (cid:89)

= g ˜α (ga)˜r

i=2

i∈[n]

Additionally, for all τ ∈ [|S|] it has to compute the terms
Kτ,2 = grτ and Kτ,3 = (uAτ h)rτ v−r. The common part
v−r for these terms is the following:

−˜r

v

g

= v

j,k/bj

i∈[n]

(j,k)∈[(cid:96),n]

gakM∗

g ˜v (cid:89)
−(cid:80)
gaq+1−i(cid:17)−˜vwi · (cid:89)
(cid:16)
−˜r (cid:89)
gaq+1−i(cid:17)−˜vwi · (cid:89)
(cid:16)
−˜r (cid:89)
(cid:123)(cid:122)
(cid:124)
· (cid:89)
= Φ · (cid:89)

(i,j)∈[n,(cid:96)]

j,iaq+1/bj

−wiM∗

−(cid:104) (cid:126)w, (cid:126)M∗

(i,j,k)∈
[n,(cid:96),n]

j (cid:105)aq+1/bj = Φ · (cid:89)

[n,(cid:96),n],i(cid:54)=k

(i,j,k)∈

i∈[n]

= v

g

g

Φ

j∈[(cid:96)]

i∈[n] wiaq+1−i

−wiM∗

j,kaq+1+k−i/bj

(cid:18)

aq+1+k−i

bj

g

(cid:19)−wiM∗

j,k

(cid:125)

−(cid:104) (cid:126)w, (cid:126)M∗

j (cid:105)aq+1/bj

g

j∈[(cid:96)]

ρ∗(j) /∈S

The Φ part can be calculated by the simulator using the
assumption, while the second part has to be canceled by the
(uAτ h)rτ part. So for every attribute Aτ ∈ S the simulator
sets implicitly

rτ = ˜rτ + r · (cid:88)
= ˜rτ + ˜r · (cid:88)

i(cid:48)∈[(cid:96)]

ρ∗(i(cid:48)) /∈S

i(cid:48)∈[(cid:96)]

ρ∗(i(cid:48)) /∈S

bi(cid:48)

Aτ − ρ∗(i(cid:48))

bi(cid:48)

Aτ − ρ∗(i(cid:48))

+

(cid:88)

(i,i(cid:48))∈[n,(cid:96)]
ρ∗(i(cid:48)) /∈S

wibi(cid:48) aq+1−i
Aτ − ρ∗(i(cid:48))

where ˜rτ

$← Zp and therefore rτ is properly distributed.
The use of the bi’s in the numerators of the fractions is ex-
plained by the “layer” intuition presented before. Namely,
these bi will cancel with the b2
i denominators in the “at-
tribute layer” and provide a cancellation for the unknown
part of v−r.
Also, notice that rτ is well-deﬁned only for attributes
in the speciﬁc unauthorized set S or unrelated attributes
(outside the policy), since the sum is over the i(cid:48) such that
ρ∗(i(cid:48)) /∈ S. Therefore, for all Aτ ∈ S or Aτ /∈ ρ∗([(cid:96)]), the
denominators Aτ − ρ∗(i(cid:48)) are non zero. If the simulator tries
to include more attributes of the policy in the key (and pos-
sibly make a key for an authorized set), he would have to
divide by zero (see Figure 1). Namely, the set of secret keys
is partitioned in two sets: the unauthorized, which the simu-
lator can create using the above method, and the authorized,
which the simulator cannot create.

468ρ∗([(cid:96)])

Zp

S

Figure 1: The simulator can not create the compo-
nents for attributes in the gray area.

After some algebraic manipulations, the (uAτ h)rτ part of

j,kbi(cid:48) ak/(Aτ −ρ∗(i(cid:48)))b2

j

Cτ,2 =

g(Aτ −ρ∗(j))wiM∗

j,kbi(cid:48) aq+1+k−i/(Aτ −ρ∗(i(cid:48)))b2

j

g(Aτ −ρ∗(j))wiM∗

j,ibj aq+1+i−i/(Aτ −ρ∗(j))b2

j

Kτ,3 is computed as:
(uAτ h)˜rτ · (Kτ,2/g ˜rτ )˜uAτ +˜h
g ˜r(Aτ −ρ∗(j))M∗

·

ρ∗(i(cid:48)) /∈S

(i(cid:48),j,k)∈[(cid:96),(cid:96),n]

· (cid:89)
(cid:89)
= Ψ · (cid:89)
= Ψ · (cid:89)

ρ∗(i(cid:48)) /∈S

(i,i(cid:48),j,k)∈[n,(cid:96),(cid:96),n]

(i,j)∈[n,(cid:96)]
ρ∗(j) /∈S

j∈[(cid:96)]

ρ∗(j) /∈S

(cid:104) (cid:126)w, (cid:126)M∗

j (cid:105)aq+1/bj

g

where Ψ includes the remaining terms of the product. The
Ψ and Kτ,2 terms can be calculated using the suitable terms
of our assumption. The second part of (uAτ h)rτ cancels ex-
actly with the problematic part of v−r. Therefore the sim-
ulator can calculate Kτ,2 and Kτ,3 for all Aτ ∈ S and hand
over the secret key sk = (S, K0, K1,{Kτ,2, Kτ,3}τ∈[|S|]) to
the attacker A.

Challenge: The attacker will output a pair of messages
In this phase the simulator

(m0, m1) of the same length.
ﬂips a random coin b $← {0, 1} and constructs

C = mb · T · e(g, gs) ˜α

and

C0 = gs

where T is the challenge term and gs the corresponding

term of the assumption.

The simulator sets implicitly (cid:126)y = (s, sa + ˜y2, sa2 + ˜y3,
$← Zp. We see that
. . ., san−1 + ˜yn)(cid:62), where ˜y2, ˜y3, . . . , ˜yn
the secret s and the vector (cid:126)y are properly distributed, since
s was information theoretically hidden from A and the ˜yi’s
are picked uniformly at random. As a result, since (cid:126)λ = M∗(cid:126)y
we have that

λτ =

∗
τ,isai−1 +

M

∗
τ,i ˜yi =

M

∗
τ,isai−1 + ˜λτ

M

for each row τ ∈ [(cid:96)].

Notice that the terms ˜λτ = (cid:80)n

i=2

i=2 M∗

τ,i ˜yi are known to
the simulator. For each row the simulator B sets implicitly
tτ = −sbτ . This is properly distributed as well, because the

(cid:88)

i∈[n]

(cid:88)

i∈[n]

n(cid:88)

bi’s are information theoretically hidden from the attacker.
Using the above, B calculates:

−M∗

τ,kaksbτ /bτ

gM∗

˜λτ · (cid:89)
gsbτ(cid:17)−˜v · (cid:89)

−M∗

i∈[n]

g

j,kaksbτ /bj

gsbτ(cid:17)−˜v
τ,isai ·(cid:16)
τ,isai · (cid:89)

g

gM∗

i∈[n]

k∈[n]

j,kaksbτ /bj =

gsbτ(cid:17)−˜v · (cid:89)
(cid:16)
(cid:17)−tτ

j,k

(j,k)∈[(cid:96),n]

j(cid:54)=τ

gsakbτ /bj(cid:17)−M∗
(cid:16)
gsbτ(cid:17)−(˜uρ∗(τ )+˜h)
−sbτ
(cid:17)−(ρ∗(τ )−ρ∗(j))M∗

j,kak/b2
j

j,k

g(ρ∗(τ )−ρ∗(j))M∗

Cτ,1 = wλτ vtτ = w

g

j(cid:54)=τ

= w

= w

−M∗

(j,k)∈[(cid:96),n]

(j,k)∈[(cid:96),n]

· (cid:89)
˜λτ ·(cid:16)
· (cid:89)
˜λτ ·(cid:16)
(cid:16)
 (cid:89)
(cid:16)
gsbτ(cid:17)−(˜uρ∗(τ )+˜h)
(cid:16)
· (cid:89)
(cid:16)
gsbτ(cid:17)−1

uρ∗(τ )h

gsakbτ /b2

(j,k)∈[(cid:96),n]

(j,k)∈[(cid:96),n]

j(cid:54)=τ

=

=

·

j

Cτ,3 = gtτ =
Notice that by using tτ = −sbτ we “raised” the exponents
of the “binder” term v so that they cancel with the unknown
powers of wλτ . Therefore, the simulator hands over the
ciphertext ct = ((M∗, ρ∗), C, C0, {Cτ,1, Cτ,2, Cτ,3}τ∈[(cid:96)]) to
the attacker A.

. Otherwise, it outputs 1.

If T = e(g, g)saq+1

Guess: After the query phase 2, where the simulator
creates the secret keys as described above, the attacker out-
puts a guess b(cid:48) for the challenge bit.
If b(cid:48) = b the sim-
it claims that the challenge term is
ulator outputs 0, i.e.
T = e(g, g)saq+1
then A played the proper security
game, because C = mb · T · e(g, gs) ˜α = mb · e(g, g)αs. On the
other hand, if T is a random term of GT then all informa-
tion about the message mb is lost in the challenge ciphertext.
Therefore the advantage of A is exactly 0. As a result, if
A breaks the security game with a non negligible advan-
tage, B has a non negligible advantage in breaking the q-1
assumption.

5.

IMPLEMENTATION AND
EVALUATION

Implementation Details We implemented our schemes
in Charm [1]; a framework developed to facilitate the rapid
prototyping of cryptographic schemes and protocols. It is
based on the Python language which allows the program-
mer to write code similar to the theoretical implementa-
tions. However, the routines that implement the dominant
group operations use the PBC library [27] (written natively
in C) and the time overhead imposed by the use of Python is

469usually less than 1%. Charm also provides routines for ap-
plying and using LSSS schemes needed for Attribute-Based
systems.

All Charm routines use formally asymmetric groups (al-
though the underlining groups might be symmetric) and
therefore we translated our schemes to the asymmetric set-
ting. Namely, we have three groups G1, G2 and GT and
the pairing e is a function from G1 × G2 to GT . The as-
sumptions and the security proofs can be translated to the
asymmetric setting in a generic way. We notice here that we
tried to implement our algorithms so that more operations
are executed in the G1 group than in the G2 and that en-
cryption consists mainly of operations in G1, compared to
key generation. The reason is that the time taken to exe-
cute them in the G1 group is considerably smaller than G2
in speciﬁc asymmetric groups such as the “MNT224” elliptic
curve group. We tested the schemes on all ECC groups pro-
vided by Charm, i.e. three super-singular symmetric groups
and two MNT asymmetric groups [29].

For more information on Charm we refer the reader to [12,
1]. The source code of our implementations can be found
in [41]. All our benchmarks were executed on a dual core
Intel R(cid:13) Xeon R(cid:13) CPU W3503@2.40GHz with 2.0GB RAM
running Ubuntu R10.04 and Python3.2.3.

We implemented our two ABE schemes (of Sec. 4 and
App. C), the prime order KP-ABE construction from [22],
and the two basic3 constructions from [33]. Actually, in
[22] a large universe prime order HIBE is provided, but the
transformation to KP-ABE is straightforward by substitut-
ing in the key generation algorithm the additive shares of
the secrets with the LSSS shares and the identities with the
attributes ρ(τ ). This modiﬁed construction is the one we
used for comparison to our KP-ABE scheme.

Time Benchmarks

In Table 1 we present time bench-
marks in diﬀerent elliptic curve groups for some sample poli-
cies (≈ size 4 attributes).

Regarding the comparison between our schemes and prior
works, we notice the big gap between the timings of our
constructions and prior ones. This is due to the fact that
dual vector spaces of high dimension (≈ 10 - 14) are uti-
lized, which increase the number of group operations by big
factors. We remind the reader that the OT schemes are
fully secure, while our scchemes and the LW schemes are
selectively secure.

Regarding the practicality, in general, of both our schemes
we notice that the KeyGen, Encrypt, and Decrypt times of our
algorithms are relatively small. They are all under 100ms,
with the exception of the super singular 1024-bit curve.
Even for this curve the times for each algorithm are un-
der the 700 msec mark. Although one would expect that as
the policies and the attributes sets grow bigger these times
will increase, the additional overhead will grow only linearly.
Thus we believe that the two constructions constitute the
most practical implementations of large universe ABE, se-
cure in the standard model.

6. REFERENCES
[1] Joseph A. Akinyele, Matthew Green, and Avi Rubin.

Charm: A framework for rapidly prototyping

3Where each sub-universe can appear at most once in the
policy.

cryptosystems. Cryptology ePrint Archive, Report
2011/617, 2011. http://eprint.iacr.org/.

[2] Sattam S. Al-Riyami, John Malone-Lee, and Nigel P.

Smart. Escrow-free encryption supporting
cryptographic workﬂow. Int. J. Inf. Sec.,
5(4):217–229, 2006.

[3] Walid Bagga, Reﬁk Molva, and Stefano Crosta.

Policy-based encryption schemes from bilinear
pairings. In ASIACCS, page 368, 2006.

[4] Manuel Barbosa and Pooya Farshim. Secure

cryptographic workﬂow in the standard model. In
INDOCRYPT, pages 379–393, 2006.

[5] Amos Beimel. Secure Schemes for Secret Sharing and

Key Distribution. PhD thesis, Dept. of Computer
Science, Technion, 1996.

[6] John Bethencourt, Amit Sahai, and Brent Waters.

Ciphertext-policy attribute-based encryption. In IEEE
Symposium on Security and Privacy, pages 321–334,
2007.

[7] Dan Boneh and Xavier Boyen. Eﬃcient selective-id

secure identity-based encryption without random
oracles. In EUROCRYPT, pages 223–238, 2004.

[8] Dan Boneh and Matthew K. Franklin. Identity-based
encryption from the Weil pairing. In CRYPTO, pages
213–229, 2001.

[9] Dan Boneh, Craig Gentry, and Michael Hamburg.
Space-eﬃcient identity based encryption without
pairings. In FOCS, pages 647–657, 2007.

[10] Dan Boneh, Amit Sahai, and Brent Waters.

Functional encryption: Deﬁnitions and challenges. In
TCC, pages 253–273, 2011.

[11] Robert W. Bradshaw, Jason E. Holt, and Kent E.
Seamons. Concealing complex policies with hidden
credentials. In ACM Conference on Computer and
Communications Security, pages 146–157, 2004.

[12] Charm. http://www.charm-crypto.com.
[13] Melissa Chase. Multi-authority attribute based

encryption. In TCC, pages 515–534, 2007.

[14] Melissa Chase and Sherman S. M. Chow. Improving

privacy and security in multi-authority attribute-based
encryption. In ACM Conference on Computer and
Communications Security, pages 121–130, 2009.

[15] Ling Cheung and Calvin C. Newport. Provably secure

ciphertext policy ABE. In ACM Conference on
Computer and Communications Security, pages
456–465, 2007.

[16] Cliﬀord Cocks. An identity based encryption scheme

based on quadratic residues. In IMA Int. Conf., pages
360–363, 2001.

[17] David Mandell Freeman. Converting pairing-based

cryptosystems from composite-order groups to
prime-order groups. In EUROCRYPT, pages 44–61,
2010.

[18] Craig Gentry. Practical identity-based encryption
without random oracles. In EUROCRYPT, pages
445–464, 2006.

[19] Vipul Goyal, Abhishek Jain, Omkant Pandey, and

Amit Sahai. Bounded ciphertext policy attribute
based encryption. In ICALP (2), pages 579–591, 2008.
[20] Vipul Goyal, Omkant Pandey, Amit Sahai, and Brent

Waters. Attribute-based encryption for ﬁne-grained

470Curve

Type

“SS512”

“SS1024”

“MNT159”

“MNT201”

“MNT224”

KP-ABE

CP-ABE

KP-ABE

CP-ABE

KP-ABE

CP-ABE

KP-ABE

CP-ABE

KP-ABE

CP-ABE

Scheme
[App.C]
LW [22]
OT [33]
[Sec.4]
OT [33]
[App.C]
LW [22]
OT [33]
[Sec.4]
OT [33]
[App.C]
LW [22]
OT [33]
[Sec.4]
OT [33]
[App.C]
LW [22]
OT [33]
[Sec.4]
OT [33]
[App.C]
LW [22]
OT [33]
[Sec.4]
OT [33]

Setup
19.1
447.2
673.7
25.0
678.0
71.5
5553.3
7904.3
110.8
7898.9
21.1
692.2
930.7
23.5
929.9
28.4
929.8
1237.1
31.3
1235.1
34.2
1150.9
1514.9
37.9
1511.7

KeyGen
49.1
642.3
924.4
32.9
922.9
626.3
9283.8
13389.3
431.0
13393.2
48.1
1666.3
2435.1
43.8
2396.2
59.2
2301.1
3338.3
58.7
3328.7
73.4
2896.0
4156.3
73.2
4140.0

Encrypt
30.7
483.4
933.5
52.0
938.5
396.8
6978.3
13582.0
669.3
13598.7
44.3
168.9
320.6
53.5
326.7
60.2
237.8
453.3
71.9
463.3
74.2
302.1
572.4
88.2
584.5

Decrypt
14.7
44.7
65.6
16.6
66.0
325.3
1098.8
1735.7
374.4
1740.4
36.4
125.2
178.4
41.5
183.5
49.7
173.6
251.5
57.4
251.8
60.9
215.6
309.8
74.4
310.7

Table 1: Typical running times in milliseconds of each scheme. KeyGen and Encrypt are called with attribute sets
and policies of size 4, while Decrypt with common attribute sets of size 2. “MNT” are the Miyaji, Nakabayashi,
Takano curves (asymmetric pairing groups), while “SS” are super singular curves (symmetric pairing groups).
The number after the type of the curve denotes the size of the base ﬁeld in bits.

access control of encrypted data. In ACM Conference
on Computer and Communications Security, pages
89–98, 2006.

[28] Gerome Miklau and Dan Suciu. Controlling access to

published data using cryptography. In VLDB, pages
898–909, 2003.

[21] Jonathan Katz, Amit Sahai, and Brent Waters.

[29] Atsuko Miyaji, Masaki Nakabayashi, and Shunzo

Predicate encryption supporting disjunctions,
polynomial equations, and inner products. In
EUROCRYPT, pages 146–162, 2008.

[22] Allison B. Lewko. Tools for simulating features of
composite order bilinear groups in the prime order
setting. In EUROCRYPT, pages 318–335, 2012.

[23] Allison B. Lewko, Tatsuaki Okamoto, Amit Sahai,

Katsuyuki Takashima, and Brent Waters. Fully secure
functional encryption: Attribute-based encryption and
(hierarchical) inner product encryption. In
EUROCRYPT, pages 62–91, 2010.

[24] Allison B. Lewko and Brent Waters. Decentralizing
attribute-based encryption. In EUROCRYPT, pages
568–588, 2011.

[25] Allison B. Lewko and Brent Waters. Unbounded

HIBE and attribute-based encryption. In
EUROCRYPT, pages 547–567, 2011.

[26] Allison B. Lewko and Brent Waters. New proof

methods for attribute-based encryption: Achieving full
security through selective techniques. In CRYPTO,
pages 180–198, 2012.

[27] Ben Lynn. The Stanford pairing based crypto library.

http://crypto.stanford.edu/pbc.

Takano. Characterization of elliptic curve traces under
fr-reduction. In ICISC, pages 90–108, 2000.

[30] Tatsuaki Okamoto and Katsuyuki Takashima.

Homomorphic encryption and signatures from vector
decomposition. In Pairing, pages 57–74, 2008.
[31] Tatsuaki Okamoto and Katsuyuki Takashima.

Hierarchical predicate encryption for inner-products.
In ASIACRYPT, pages 214–231, 2009.

[32] Tatsuaki Okamoto and Katsuyuki Takashima. Fully

secure functional encryption with general relations
from the decisional linear assumption. In CRYPTO,
pages 191–208, 2010.

[33] Tatsuaki Okamoto and Katsuyuki Takashima. Fully
secure unbounded inner-product and attribute-based
encryption. In ASIACRYPT, pages 349–366, 2012.

[34] Rafail Ostrovsky, Amit Sahai, and Brent Waters.

Attribute-based encryption with non-monotonic access
structures. In ACM Conference on Computer and
Communications Security, pages 195–203, 2007.

[35] Matthew Pirretti, Patrick Traynor, Patrick McDaniel,
and Brent Waters. Secure attribute-based systems. In
ACM Conference on Computer and Communications
Security, pages 99–112, 2006.

471[36] Amit Sahai and Brent Waters. Fuzzy identity-based
encryption. In EUROCRYPT, pages 457–473, 2005.

[37] Adi Shamir. Identity-based cryptosystems and

signature schemes. In CRYPTO, pages 47–53, 1984.

[38] Emily Shen, Elaine Shi, and Brent Waters. Predicate

privacy in encryption systems. In TCC, pages
457–473, 2009.

[39] Elaine Shi and Brent Waters. Delegating capabilities
in predicate encryption systems. In ICALP (2), pages
560–578, 2008.

[40] Nigel P. Smart. Access control using pairing based

cryptography. In CT-RSA, pages 111–121, 2003.

[41] Source code of our constructions.

www.cs.utexas.edu/~jrous/.

[42] Brent Waters. Eﬃcient identity-based encryption
without random oracles. In EUROCRYPT, pages
114–127, 2005.

[43] Brent Waters. Ciphertext-policy attribute-based

encryption: An expressive, eﬃcient, and provably
secure realization. In Public Key Cryptography, pages
53–70, 2011.

APPENDIX
A. ASSUMPTION 2

For our KP-ABE construction we will use a q-type as-
sumption on prime order bilinear groups, denoted by q-2,
which is similar to the Decisional Bilinear Diﬃe-Hellman
Assumption augmented with q parameters bi. It is parame-
terized by a security parameter λ ∈ N and an integer q, poly-
nomial in λ. We assume that there exists a group generator
algorithm G(1λ) → (p, G, GT , e) that outputs the descrip-
tion of the (symmetric) bilinear group of order p = Θ(2λ).
This assumption can be proved secure in the generic group
model, but the proof is omitted due to space constraints. It
is deﬁned via the following game between a challenger and
an attacker:

Initially the challenger calls the group generation algo-
rithm with input the security parameter, picks a random
group element g $← G, and q + 3 random exponents x, y, z,
$← Zp. Then he sends to the attacker the group
b1, b2, . . ., bq
description (p, G, GT , e) and all of the following terms:

i

i , gy2/b2
j , gxyzbi/bj , g(xz)2bi/bj

g, gx, gy, gz, g(xz)2
gbi , gxzbi , gxz/bi , gx2zbi , gy/b2
gxzbi/bj , gybi/b2
The challenger also ﬂips a random coin b $← {0, 1} and if
b = 0 it gives to the attacker the term e(g, g)xyz. Other-
wise it gives a random term R $← GT . Finally the attacker
outputs a guess b(cid:48) ∈ {0, 1}.

∀i ∈ [q]
∀i, j ∈ [q], i (cid:54)= j

Deﬁnition A.1. We say that the q-2 assumption holds if
all PPT attackers have at most a negligible advantage in λ
in the above security game, where the advantage is deﬁned
as Adv = Pr [b(cid:48) = b] − 1/2.

B. KEY-POLICY ATTRIBUTE-BASED EN-

CRYPTION
B.1 Algorithms

A Key-Policy Attribute-Based Encryption scheme consists
• Setup(1λ) → (pp, msk):

of the following four PPT algorithms:
The Setup algorithm takes
the security parameter λ ∈ N encoded in unary and outputs
the public parameters pp and the master secret key msk.
We assume that the public parameters contain a description
of the attribute universe U.
• KeyGen(1λ, pp, msk, A) → sk: The key generation al-
gorithm takes as inputs the public parameters pp, the master
secret key msk and an access structure A on U. The algo-
rithm generates a secret key corresponding to A.
• Encrypt(1λ, pp, m,S) → ct: The encryption algorithm
takes as inputs the public parameters pp, a plaintext message
m, and a set of attributes S ⊆ U. It outputs the ciphertext
ct.
• Decrypt(1λ, pp, sk, ct) → m: The decryption algorithm
takes as inputs the public parameters pp, a secret key sk,
and a ciphertext ct. It outputs the plaintext m.

Correctness: We require that a KP-ABE scheme is
correct, i.e the decryption algorithm correctly decrypts a
ciphertext on S with a secret key of an access structure A
when S is an authorized set of A. Formally:
Deﬁnition B.1. A KP-ABE scheme is correct when for all
messages m, and all attribute sets S and access structures A
with S ∈ A (i.e. for S authorized), any pair (pp, msk) out-
put from Setup(1λ), any secret key sk output from KeyGen
(1λ, pp, msk, A), and any ciphertext ct output by Encrypt
(1λ, pp, m,S), it is true that: Decrypt(1λ, pp, sk, ct) = m.
B.2 KP-ABE Selective Security

• Initialization:

The selective security game for KP-ABE is described by
a game between a challenger and an attacker and is param-
eterized by the security parameter λ ∈ N. The phases of the
game are the following:
In this phase the attacker declares the
challenge attribute set S∗, which he will try to attack, and
sends it to the challenger.
• Setup: Here the challenger calls the Setup(1λ) algo-
rithm and sends the public parameters pp to the attacker.
• Query Phase 1:
In this phase the attacker can adap-
tively ask for secret keys for the access structures A1, A2, . . .,
AQ1 . For each Ai the challenger calls KeyGen(msk, Ai) →
ski and sends ski to the attacker. The restriction that has
to be satisﬁed for each query is that none of the queried
policies is satisﬁed by the challenge attribute set, i.e. ∀i ∈
[Q1] : S∗ /∈ Ai.

• Challenge:

The attacker declares two equal-length
plaintexts m0 and m1 and sends them to the challenger. He
ﬂips a random coin b ∈ {0, 1} and calls Encrypt(mb,S∗) →
ct. He sends ct to the attacker.

• Query Phase 2:

This the same as query phase 1.
The attacker asks for the secret key for the access structures
AQ1+1, AQ1+2, . . ., AQ, for which the same restriction holds:
∀i ∈ [Q] : S∗ /∈ Ai.
• Guess: The attacker outputs his guess b(cid:48) ∈ {0, 1} for

b.

472Deﬁnition B.2. A KP-ABE scheme is selectively secure if
all PPT attackers have at most a negligible advantage in λ in
the above security game, where the advantage of an attacker
is deﬁned as Adv = Pr [b(cid:48) = b] − 1/2.

C. OUR LARGE UNIVERSE KP-ABE

In this section we present our large universe KP-ABE
scheme. We mention here that it can be converted to an
HIBE scheme using non repeating identities, “AND” poli-
cies and delegation capabilities (c.f.
[25]). The intuition
behind the functionality of this construction is simpler than
the CP-ABE. In this setting the public parameters consist
of the ﬁve terms (g, u, h, w, e(g, g)α). There is one term less
due to the fact that now the master secret key α is the secret
to be shared during all the key generation calls. As a result
the “secret sharing layer” uses the g term only and the w
term is used to “bind” this layer to the u, h “attribute layer”.
C.1 Construction

Our scheme consists of the following four algorithms.
• Setup(1λ) → (pp, msk): The setup algorithm calls the
group generator algorithm G(1λ) and gets the descriptions
of the groups and the bilinear mapping D = (p, G, GT , e),
where p is the prime order of the groups G and GT . The
attribute universe is U = Zp.

Then the algorithm picks the random terms g, u, h, w $← G

and α $← Zp. It outputs

pp = (D, g, u, h, w, e(g, g)α)

msk = (α)

• KeyGen(msk, (M, ρ)) → sk:

Initially, the algorithm

picks (cid:126)y = (α, y2, . . . , yn)(cid:62) where y2, . . . , yn
In the
terminology of Sec. 2.2, the master secret key α is the secret
to be shared among the shares. The vector of the shares is

$← Zp.

(cid:126)λ = (λ1, λ2, . . . , λ(cid:96))

(cid:62)

= M (cid:126)y

$← Zp and

It then picks (cid:96) random exponents t1, t2, . . . , t(cid:96)

for every τ ∈ [(cid:96)] it computes

(cid:16)

(cid:17)−tτ

Kτ,1 =

uρ(τ )h

Kτ,2 = gtτ
Kτ,0 = gλτ wtτ
The secret key is sk = ((M, ρ),{Kτ,0, Kτ,1, Kτ,2}τ∈[(cid:96)]).
• Encrypt(m,S = {A1, A2, . . . , Ak} ⊆ Zp) → ct:

Ini-
tially, the algorithm picks k + 1 random exponents s, r1, r2,
$← Zp. It computes C = m · e(g, g)αs, C0 = gs, and
. . ., rk
for every τ ∈ [k] it computes

Cτ,1 = grτ

Cτ,2 = (uAτ h)rτ w

−s

The ciphertext is ct = (S, C, C0,{Cτ,1, Cτ,2}τ∈[k]).
• Decrypt (sk, ct) → m: The algorithm ﬁnds the set of
rows in M that provide a share to attributes in S, i.e. I =
{i : ρ(i) ∈ S}. Then it calculates constants {ωi ∈ Zp}i∈I
i∈I ωi (cid:126)Mi = (1, 0, . . . , 0), where Mi is the i-th
row of the matrix M . These constants exist if the set S is
an authorized set of the policy (c.f. Sec. 2.2).

such that (cid:80)
(cid:89)

B =

i∈I

Then it calculates

(e(C0, Ki,0)e(Cτ,1, Ki,1)e(Cτ,2, Ki,2))ωi

where τ is the index of the attribute ρ(i) in S (it depends
on i). The algorithm outputs m = C/B.

authorized, we have that(cid:80)

Correctness:

If the attribute set S of the ciphertext is

i∈I ωiλi = α. Therefore:

B =

e(g, g)sωiλi e(g, w)stiωi

−rτ tiωi e(g, uρ(i)h)rτ tiωi e(g, w)
i∈I ωiλi = e(g, g)αs

−stiωi

(cid:89)
· e(g, uρ(i)h)
= e(g, g)s(cid:80)

i∈I

C.2 Proof of Selective Security

We will prove the following theorem regarding the selec-

tive security of our KP-ABE scheme:

Theorem C.1. If the q-2 assumption holds, then all PPT
adversaries with a challenge attribute set of size k, where
k ≤ q, have a negligible advantage in selectively breaking
our scheme.

Proof. To prove the theorem we will assume that there exists
a PPT attacker A with a challenge attribute set that satisﬁes
the restriction, which has a non negligible advantage AdvA in
selectively breaking our scheme. Using this attacker we will
build a PPT simulator B that attacks the q-2 assumption
with a non negligible advantage.
Initialization: Initially, B receives the given terms from
the assumption and an attribute set S∗ = {A∗
2, . . .,
k} ⊆ U.
A∗
Setup: Now, the simulator B has to provide A the public
parameters of the system. In order to do that it implicitly
sets the master secret key of the scheme to be α = xy,
where x, y are set in the assumption. Notice that this way α
is properly distributed. Then B picks the random exponents
˜u, ˜h $← Zp and gives to A the following terms:

1, A∗

g = g

u = g ˜u ·(cid:81)
h = g˜h ·(cid:81)

i∈[k] gy/b2

i∈[k] gxz/bi ·(cid:81)

i

i∈[k]

(cid:16)

gy/b2

i

(cid:17)−A∗

i

w = gx
e(g, g)α = e(gx, gy)

Since x is information-theoretically hidden from A, because
it is multiplied by y in α, the term w is properly uniformly
random in G. The terms u, h are properly distributed due
to ˜u, ˜h respectively. Notice that all terms can be calculated
by the simulator using suitable terms from the assumption
and the challenge set S∗ given by A.

In the KP-ABE proof we see that the “binder term” of
the CP-ABE reduction has been contained in the “attribute
layer”; namely the gxz/bi of the h term. Since the master se-
cret key α is shared in all key generation queries in KP-ABE,
we don’t need any more the extra functionality provided by
the powers of a.
Query phases 1 and 2: The simulator has to produce
secret keys for policies requested by A, for which the set S∗
is not authorized. In both phases the treatment is the same.
We describe here the way B works in order to create a key
for a policy (M, ρ) with M ∈ Z(cid:96)×n
Since S∗ is non authorized for (M, ρ), there exists a vec-
(cid:62) ∈ Zn
tor (cid:126)w = (w1, w2, . . . , wn)
p such that w1 = 1 and
(cid:104) (cid:126)Mτ , (cid:126)w(cid:105) = 0 for all τ ∈ [(cid:96)] such that ρ(τ ) ∈ S∗ (c.f. Sec.
2.2). The simulator calculates (cid:126)w using linear algebra. The

and ρ : [(cid:96)] → Zp.

p

473vector (cid:126)y that will be shared is implicitly

(cid:126)y = xy (cid:126)w + (0, ˜y2, ˜y3, . . . , ˜yn)

(cid:62)

Kτ,2 = gtτ

= (gy)

(cid:16)

−(cid:104) (cid:126)Mτ , (cid:126)w(cid:105) · (cid:89)

i∈[k]

(cid:16)

gxzbi(cid:17)(cid:104) (cid:126)Mτ , (cid:126)w(cid:105)/(ρ(τ )−A∗

i ) · g

˜tτ

(cid:17)

.

Therefore B can reply to A’s query with the entire secret

key sk =

(M, ρ),{Kτ,0, Kτ,1, Kτ,2}τ∈[(cid:96)]

Challenge: The attacker will output a pair of messages
(m0, m1) of the same length.
In this phase the simulator
ﬂips a random coin b $← {0, 1} and sets implicitly s = z
from the q-2 assumption. Also, it sets rτ = bτ for every
level τ ∈ [k]. These parameters are properly distributed
since z, b1, . . . , bq are information-theoretically hidden from
the attacker’s view. Now the simulator can compute the
following terms using the assumption:

τ h)rτ · w

C = mb · T
Cτ,1 = grτ = gbτ
Cτ,2 = (uA∗
= gbτ (˜uA∗

τ +˜h) · (cid:89)
(cid:16)
gbτ(cid:17)˜uA∗
τ +˜h · (cid:89)

i∈[k]

=

C0 = gs = gz

−s

gxzbτ /bi (cid:89)
gxzbτ /bi (cid:89)

i∈[k]

(cid:16)

i∈[k]
i(cid:54)=τ

i∈[k]
i(cid:54)=τ

gybτ (A∗

k−A∗

i )/b2

i · g

−xz

(cid:17)A∗

τ −A∗

i

gybτ /b2

i

As one can see, the choice of rτ = bτ “raises” one of
the xz/bi components to xz and achieves the cancellation
with w−s. The simulator hands over the ciphertext ct =

(cid:16)S∗, C, C0,{Cτ,1, Cτ,2}τ∈[k]

to the attacker A.

(cid:17)

Guess: After the query phase 2, where the simulator
creates the secret keys as described above, the attacker out-
puts a guess b(cid:48) for the challenge bit.
If b(cid:48) = b the sim-
it claims that the challenge term is
ulator outputs 0, i.e.
T = e(g, g)xyz. Otherwise, it outputs 1.
If T = e(g, g)xyz then A played the proper security game,
because C = mb · T = mb · e(g, g)αs. On the other hand, if
T is a random term of GT then all information about the
message mb is lost in the challenge ciphertext. Therefore
the advantage of A is exactly 0. As a result, if A breaks the
security game with a non negligible advantage, B has a non
negligible advantage in breaking the q-2 assumption.

$← Zp. This vector is properly dis-
where ˜y2, ˜y3, . . . , ˜yn
tributed because its ﬁrst component is xy = α and the re-
maining components are uniformly random in Zp. Therefore
for each row τ ∈ [(cid:96)] the share is

λτ = (cid:104) (cid:126)Mτ , (cid:126)y(cid:105) = xy(cid:104) (cid:126)Mτ , (cid:126)w(cid:105) + (cid:104) (cid:126)Mτ , (0, ˜y2, ˜y3, . . . , ˜yn)

= xy(cid:104) (cid:126)Mτ , (cid:126)w(cid:105) + ˜λτ

(cid:62)(cid:105)

As we mentioned above for each row τ for which ρ(τ ) ∈ S∗
it is true that (cid:104) (cid:126)Mτ , (cid:126)w(cid:105) = 0. Therefore in this case λτ =
˜λτ = (cid:104) (cid:126)Mτ , (0, ˜y2, ˜y3, . . . , ˜yn)(cid:62)(cid:105); hence its value is known to
$← Zp and outputs the
the simulator. In that case it picks tτ
terms Kτ,0, Kτ,1, Kτ,2 as in the KeyGen algorithm.
On the other hand, for each row τ for which ρ(τ ) /∈ S∗ it

picks ˜tτ

$← Zp and sets implicitly

tτ = −y(cid:104) (cid:126)Mτ , (cid:126)w(cid:105) +

(cid:88)

i∈[k]

xzbi(cid:104) (cid:126)Mτ , (cid:126)w(cid:105)
ρ(τ ) − A∗

i

+ ˜tτ

Since ρ(τ ) /∈ S∗ the above fractions are deﬁned and tτ is
properly distributed due to ˜tτ . The intuition behind this
choice is that the y exponent “raises” the power of w to
the secret α = xy. However, this also results to xyz/bi
exponents from h. Thus, the cancellation is provided by the
xzbi exponents on the y/b2
i part. Now the simulator can
compute the following terms using the assumption:

−xy(cid:104) (cid:126)Mτ , (cid:126)w(cid:105)+(cid:80)
gx2zbi(cid:17)(cid:104) (cid:126)Mτ , (cid:126)w(cid:105)/(ρ(τ )−A∗

i∈[k]

i ) · w

˜tτ

x2 zbi(cid:104) (cid:126)Mτ , (cid:126)w(cid:105)

ρ(τ )−A∗

i

· w

˜tτ

= g

i∈[n]

(cid:16)

−tτ =

Kτ,1 = (uρ(τ )h)

Kτ,0 = gλτ wtτ
= gxy(cid:104) (cid:126)Mτ , (cid:126)w(cid:105)+˜λτ · g

˜λτ · (cid:89)
= gy(cid:104) (cid:126)Mτ , (cid:126)w(cid:105)(ρ(τ )˜u+˜h) (cid:89)
· (cid:89)
gxyz(cid:104) (cid:126)Mτ , (cid:126)w(cid:105)/bi (cid:89)
· (cid:89)
· (cid:89)

gy2(cid:104) (cid:126)Mτ , (cid:126)w(cid:105)(ρ(τ )−A∗

i∈[k]

i∈[k]

i∈[k]

g

(i,j)∈[k,k]

−xzbi(ρ(τ )˜u+˜h)(cid:104) (cid:126)Mτ , (cid:126)w(cid:105)/(ρ(τ )−A∗
i )

g

−(xz)2bj(cid:104) (cid:126)Mτ , (cid:126)w(cid:105)/bi(ρ(τ )−A∗
j )

g

(i,j)∈[k,k]
i )/b2

i · (uρ(τ )h)

−˜tτ

(cid:16)
gxzbi(cid:17)−(ρ(τ )˜u+˜h)(cid:104) (cid:126)Mτ , (cid:126)w(cid:105)/(ρ(τ )−A∗

i )

−xyz(cid:104) (cid:126)Mτ , (cid:126)w(cid:105)bj(ρ(τ )−A∗

i )/b2

i (ρ(τ )−A∗
j )

(cid:104) (cid:126)Mτ , (cid:126)w(cid:105)(ρ(τ )˜u+˜h) (cid:89)
(cid:16)
g(xz)2bj /bi(cid:17)−(cid:104) (cid:126)Mτ , (cid:126)w(cid:105)/(ρ(τ )−A∗
(cid:17)(cid:104) (cid:126)Mτ , (cid:126)w(cid:105)(ρ(τ )−A∗

i∈[k]

j )

i ) · (uρ(τ )h)

−˜tτ

(cid:17)−(cid:104) (cid:126)Mτ , (cid:126)w(cid:105)(ρ(τ )−A∗

i )/(ρ(τ )−A∗
j )

gxyzbj /b2

i

(i,j)∈[k,k]

= (gy)

· (cid:89)
(cid:16)
· (cid:89)
· (cid:89)

i∈[k]

(i,j)∈[k,k]

i(cid:54)=j

gy2/b2

i

(cid:16)

474