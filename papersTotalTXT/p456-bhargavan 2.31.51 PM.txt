On the Practical (In-)Security of 64-bit Block Ciphers

Collision Attacks on HTTP over TLS and OpenVPN

Karthikeyan Bhargavan

Inria, France

karthikeyan.bhargavan@inria.fr

Gaëtan Leurent

Inria, France

gaetan.leurent@inria.fr

ABSTRACT
While modern block ciphers, such as AES, have a block size of
at least 128 bits, there are many 64-bit block ciphers, such as
3DES and Blowﬁsh, that are still widely supported in Internet
security protocols such as TLS, SSH, and IPsec. When used
in CBC mode, these ciphers are known to be susceptible
to collision attacks when they are used to encrypt around
232 blocks of data (the so-called birthday bound). This
threat has traditionally been dismissed as impractical since it
requires some prior knowledge of the plaintext and even then,
it only leaks a few secret bits per gigabyte. Indeed, practical
collision attacks have never been demonstrated against any
mainstream security protocol, leading to the continued use
of 64-bit ciphers on the Internet.

In this work, we demonstrate two concrete attacks that
exploit collisions on short block ciphers. First, we present
an attack on the use of 3DES in HTTPS that can be used
to recover a secret session cookie. Second, we show how a
similar attack on Blowﬁsh can be used to recover HTTP
BasicAuth credentials sent over OpenVPN connections. In
our proof-of-concept demos, the attacker needs to capture
about 785GB of data, which takes between 19-38 hours in
our setting. This complexity is comparable to the recent RC4
attacks on TLS: the only fully implemented attack takes 75
hours. We evaluate the impact of our attacks by measuring
the use of 64-bit block ciphers in real-world protocols. We
discuss mitigations, such as disabling all 64-bit block ciphers,
and report on the response of various software vendors to
our responsible disclosure of these attacks.

1.

INTRODUCTION

Internet protocols such as TLS [13], SSH [34], and IPsec [18]
are agile, in the sense that they are designed to support a
wide variety of ciphersuites: combinations of key exchange
protocols, encryption schemes, authentication modes, etc.
Each protocol implementation may choose to support a dif-
ferent subset of ciphersuites, but two implementations can
still interoperate if they can negotiate a common cipher-

Publication rights licensed to ACM. ACM acknowledges that this contribution was
authored or co-authored by an employee, contractor or afﬁliate of a national govern-
ment. As such, the Government retains a nonexclusive, royalty-free right to publish or
reproduce this article, or to allow others to do so, for Government purposes only.
CCS ’16, October 24–28, 2016, Vienna, Austria.
c(cid:13) 2016 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ACM ISBN 978-1-4503-4139-4/16/10. . . $15.00
DOI: http://dx.doi.org/10.1145/2976749.2978423

Figure 1: The Beastly attacker model for HTTPS: A
network attacker injects JavaScript on some window
in the user’s browser, which then makes cross-origin
HTTPS requests to a target website. The browser at-
taches a secret cookie or HTTP BasicAuth password to
authenticate each request. The attacker observes the en-
crypted traﬃc stream and tries to recover the secret.

suite. When it works well, protocol agility can enable a
graceful transition from old cryptographic algorithms to new
ones. A server can, for example, oﬀer AES-GCM to modern
clients while still supporting legacy ciphers like 3DES for
older clients that have not yet been upgraded. However, a
negative consequence of agility is that old ciphers may never
be removed, resulting in implementations that support a few
strong modern ciphers, followed by a long tail of obsolete
ciphers that are still supported for backwards compatibility,
but are known to be cryptographically weak. For example,
the OpenSSL library supports ﬁve versions of TLS and hun-
dreds of ciphersuites, even though many of these ciphersuites
include weak algorithms like RC4 and MD5.

There are several reasons why practitioners do not consider
theoretical weaknesses in cryptographic to be suﬃcient for
their removal from mainstream protocols. First, even if
an obsolete primitive is supported, it will typically only be
negotiated if one of the parties does not support a modern
alternative, in which case, the obsolete cipher is still better
than nothing. Second, the attack may not be applicable to
the way the primitive is used in the protocol, or it may require
too much computation to be considered practical. Third, the
attack may require special knowledge about the structure or
the content of the plaintext stream which may be diﬃcult to
obtain in general. Consequently, protocol implementations
tend to support legacy ciphers until a concrete attack is
demonstrated in a common usage of the protocol.

456Attacks on Legacy Crypto. A series of recent attacks
on TLS have conclusively shown that this line of defense
for legacy ciphers is fatally ﬂawed. Leaving old protocol
versions and obsolete cryptographic algorithms enabled can
lead to devastating attacks, such as BEAST [15] (on CBC
encryption in TLS 1.0), CRIME [28] (on TLS compression),
Lucky13 [4] (on CBC padding in TLS 1.2), POODLE [11]
(on CBC padding in SSL 3.0), RC4 NOMORE [3, 19, 32] (on
keystream biases in RC4), FREAK [9] (on export-grade RSA
keys), Logjam [2] (on export-grade Diﬃe-Hellman groups),
SLOTH [10] (on MD5 signatures), and DROWN [5] (on
RSA-PKCS#1v1.5 encryption in SSL 2.0).

These attacks follow a common pattern. Each attack is
based on a classic cryptographic weakness that was known to
cryptographers for years or even decades in advance, but had
not been demonstrated in real-world TLS scenarios. So these
works showed that with modern network speeds and comput-
ing power, the computational eﬀort required to exploit the
theoretical weakness is feasible even for academic researchers.
Furthermore, many of these attacks (e.g. BEAST, CRIME,
RC4 NOMORE) can be made more eﬃcient by relying on a
new HTTPS attacker model introduced by BEAST. Figure 1
depicts this Beastly attacker model, where a network attacker
uses JavaScript to implement an adaptive chosen-plaintext
adversary who can mix in his plaintext with the user’s secret
values, and then use his network vantage point to actively or
passively attack the ciphertext.

The ﬁnal element of each attack is ﬁnding clients and
servers who are willing to negotiate the legacy cipher. Some of
the attacked algorithms (e.g. RC4) and protocol versions (e.g.
SSL 3.0) were highly popular before the attack and have since
been deprecated. Other weak algorithms (e.g. export ciphers)
and versions (e.g. SSL 2.0) had already been deprecated
years ago and were never expected to be negotiated between
modern clients and servers. Surprisingly however, in many
cases the attacker is able to force the negotiation of a weak
algorithm via a downgrade attack by exploiting protocol ﬂaws
(e.g. Logjam, SLOTH) or implementation bugs (e.g. FREAK,
DROWN). One lesson to take from these downgrade attacks
is that relying on the negotiation protocol to avoid legacy
ciphers is error-prone and dangerous. When a concrete attack
against a legacy cipher is discovered, the only safe mitigation
is to fully remove the weak cipher from all implementations.
These previous attacks evaluated a variety of obsolete
cryptographic constructions and provided enough evidence
of their dangers for them to be disabled in popular imple-
mentations. We believe that it is important for the research
community to be vigilant and to continue to investigate the
strength of the weakest ciphers still supported by mainstream
protocols. For example, the attacks on RC4 have resulted in
RC4 being removed as the default fallback cipher for TLS
implementations, and this role has now fallen to 3DES, which
is a 28 year old 64-bit block cipher with known weaknesses.
However, the practical security of 64-bit block ciphers as used
in TLS and other protocols has not been previously studied.
This work aims to address this gap and to provide concrete
attacks and ﬁrm guidance on the use of such ciphers.

Collision Attacks on 64-bit Block Ciphers. The secu-
rity of a block cipher is often reduced to the key size k: the
best attack should be the exhaustive search of the key, with
complexity 2k. However, the block size n is also an important
security parameter, deﬁning the amount of data that can
be encrypted under the same key. This is particularly im-

portant when using common modes of operation: we require
block ciphers to be secure with up to 2n queries, but most
modes of operation (e.g. CBC, CTR, GCM, OCB, etc.) are
unsafe with more than 2n/2 blocks of message (the so-called
birthday bound). In particular, when these many blocks
are encrypted under a key in CBC mode, the probability of
collisions between two ciphertext blocks becomes signiﬁcant,
and each ciphertext collision reveals the XOR of the two cor-
responding plaintext blocks from the stream. Consequently,
if the attacker can guess one of the plaintext blocks, he can
recover the plaintext in the other block. While this attack is
well-known to researchers [30, 25], it is often disregarded by
practitioners because it require known plaintext, and reveals
only a few bits of a large datastream.

With a modern block cipher with 128-bit blocks such
as AES, the birthday bound corresponds to 256 EB (268
bytes). While this is leaves a safe margin for common uses of
cryptography today, the resulting security is still lower than
could be expected of 128-bit security and might be an issue
in the future. As a point of comparison, Google is estimated
to store around 16 EB (264 bytes), and the global Internet
traﬃc is expected to reach 1 ZB (270 bytes) per year in 2016.
More strikingly, the birthday bound corresponds to only
32 GB for a block cipher with 64-bit blocks, and there are
many real-world protocol scenarios in which this amount of
data may be sent under a 64-bit cipher: e.g. 3G telephone
connections (UMTS), which are encrypted with KASUMI,
OpenVPN tunnels, which uses Blowﬁsh as the default cipher,
and Internet standards like TLS, SSH, and IPsec that use
3DES and Blowﬁsh as legacy ciphers for interoperability. In
all these scenarios, 32 GB of data can be transferred in less
than one hour with a fast connection.

More recently, 64-bit ciphers have become common in
the ﬁeld of lightweight cryptography for applications, such as
embedded systems and smart devices, where resources are too
constrained to use conventional block ciphers. For instance,
PRESENT [12] and HIGHT [20] have been standardized
by ISO recently (in ISO/IEC 29192 and ISO/IEC 18033-3,
respectively).

Our Results.
In this work, we study the concrete impact
of birthday attacks against 64-bit block-ciphers as used in
popular protocols. We present the ﬁrst concrete attacks based
on ciphertext collisions on mainstream Internet protocols.

We focus on two concrete use cases. First, we consider
the use of OpenVPN to secure HTTP connections between
a web browser and a website, where the website asks the
user for HTTP BasicAuth (user/password) authentication.
OpenVPN uses Blowﬁsh in CBC mode by default, and we
show how one can use the Beastly attacker scenario to gener-
ate a lot of traﬃc including the BasicAuth in every request,
until collisions collisions in the Blowﬁsh ciphertext reveal
the BasicAuth token (i.e. the password). We demonstrate
a proof-of-concept attack between a Firefox client and an
nginx server connected via OpenVPN. The attack requires
about 785GB, which takes 19 hours in our setting to recover
the 16-byte authorization token.

Second, we consider the use of TLS to secure HTTP con-
nections between a browser and an HTTPS website that
sets secure session cookies on the browser. We ﬁnd that
3DES is supported by nearly 90% of HTTPS servers and
by all mainstream TLS clients. In practice, however, 3DES
is less preferred than AES and negotiated by only 1-2% of

457HTTPS connections. For such connections, we demonstrate
an attack, again using the Beastly attacker setup, that can
recover the secret 16-byte session cookie sent by the browser
with every HTTPS request to the target server. We demon-
strate the attack between a Firefox browser and an IIS 6.0
server (Windows Server 2003 R2 SP2), both in their default
up-to-date conﬁguration. This attack also requires 785GB,
which takes 38 hours in our setting.

Our attacks demonstrate that collision-based attacks on
64-bit block ciphers are practically exploitable. We suggest
two mitigations for the attack. Considering the low negotia-
tion probability of 3DES in TLS, we recommend disabling
it in popular clients and servers. For protocols where 64-
bit ciphers cannot yet be deprecated, we recommend using
strict rekeying limits to mitigate the attack. In response to
our attacks, mainstream TLS libraries, web browsers, and
OpenVPN have begun implementing these mitigations.

Outline. Section 2 provides background on collision attacks
on block ciphers and estimates their success probability under
various conditions. Section 3 investigates the usage of 64-
bit ciphers in various Internet protocols, and speciﬁcally in
HTTPS. Section 4 shows how block cipher collisions in the
encrypted stream can be used to attack HTTP. Section 4.4
and 4.5 describe our proof-of-concept attacks on OpenVPN
and HTTPS, respectively. Section 5 discusses the impact of
our attacks and their mitigations.

2. COLLISION ATTACKS ON BLOCK CI-

PHERS

Block ciphers like AES and 3DES are widely used for
symmetric encryption in security protocols. Mathematically,
a block cipher with a κ-bit key and n-bit blocks deﬁnes of
family of permutations of n-bit strings, indexed by the key.
The main security notion is that a block cipher should behave
like a pseudo-random permutation (PRP) family: the block
cipher Ek with a random key k should be hard to distinguish
from a random permutation.

Block ciphers operate on blocks of ﬁxed size, n bits, usu-
ally with n = 64 (DES, 3DES, Blowﬁsh, IDEA, KASUMI,
PRESENT, ...) or n = 128 (AES, Camellia, Twoﬁsh, Ser-
pent, SEED, ...).
In order to deal with arbitrary-length
messages, they are used within a mode of operation. A mode
divides the message M into n-bit blocks mi, and process the
blocks one by one through the block cipher E with various
chaining rules, to produce ciphertext blocks ci and/or an
authentication tag τ . Several modes have been widely stud-
ied and standardized [16] for encryption (CBC, CFB, OFB,
CTR), authentication (CBC-MAC, PMAC) and authenticated
encryption (OCB, CCM, GCM).
2.1 Security at the Birthday Bound

While block ciphers are required to resist any attack with
up to 2n data and 2κ time, most modes of operation are only
proven secure up to 2n/2 blocks of plaintext, a limit that
is commonly called the birthday bound. Indeed, there are
attacks matching this limit. In CBC mode, the probability
of collisions between two n-bit ciphertext blocks becomes
signiﬁcant after 2n/2 blocks because of the birthday paradox.
Rogaway summarizes the situation as follows [30, page 36]:

In general, unless special eﬀorts are taken, almost
any mode of operation based on an n-bit block-

m(0)

0

m(0)

1

m(0)

2

m(0)

3

c(0)−1 = IV

Ek

Ek

Ek

Ek

c(0)
0

c(0)
1

c(0)
2

c(0)
3

Figure 2: CBC mode

cipher will admit attacks that employ σ = 2n/2
blocks. [...]

Do birthday-bound attacks on CBC, CFB, and
OFB actually matter? They are of relatively little
concern when the blockcipher has a blocksize of
n = 128 bits, but the attacks can be a serious
concern when employing a blockcipher of n = 64
bits, requiring relatively frequent rekeying to keep
σ (cid:28) 232.

More recently, McGrew investigated plaintext recovery
attacks on 64-bit ciphers in CBC, CFB, and CTR modes. He
studied the mount of information leakage by assuming that
the attacker can observe all the ciphertext in an encrypted
stream and he has some (incomplete) knowledge of the plain-
text [25]. This theoretical analysis resulted in new security
recommendations for IPsec [26], but they did not trigger
any signiﬁcant changes in mainstream deployments of 64-bit
ciphers in IPsec, TLS, or SSH. Arguably the main reason for
the limited impact of these attacks is that they were never
implemented against a popular protocol under real-world
conditions.

Following McGrew, we explain theoretical attacks against
the CBC and CTR modes (the two most widely used encryp-
tion modes) in more detail below. In the rest of the paper,
we will show that these attacks can be exploited to mount
concrete attacks on HTTP over TLS and OpenVPN.
2.2 Plaintext recovery attack against CBC

The CBC mode is one of the oldest encryption modes, and
still widely used. The message M is divided into blocks
mi, 0 ≤ i < (cid:96) (see Figure 2) and is encrypted as:

ci = Ek(mi ⊕ ci−1),

where c−1 is an initialization value usually denoted as IV.
For simplicity, here we assume that all message sizes are a
multiple of the block size.

When encrypting a sequence of messages M (j), each mes-
sage should be encrypted with a fresh random IV c(j)−1. It is
important that the IV can not be predicted by an adversary
who can encrypt chosen messages; otherwise, it can lead
to attacks, as ﬁrst observed by Rogaway in 1995 [29], and
subsequently exploited in the BEAST attack [15] in 2011 on
TLS versions prior to 1.1.

CBC has been proven secure up to 2n/2 blocks of mes-
sages [7, 27]. On the other hand there is a simple birthday
attack against CBC: after 2n/2 message blocks encrypted

458with the same key (in the same message or in diﬀerent mes-
i = c(j(cid:48))
sages), a collision between two ciphertext blocks c(j)
i(cid:48)
is expected. Since Ek is a permutation, a collision in the
output means that the inputs are the same (m(j)
i−1 =
m(j(cid:48))
i(cid:48) ⊕ c(j(cid:48))
i(cid:48)−1), which reveals the xor of two plaintext blocks:

i ⊕ c(j)

i ⊕ m(j(cid:48))
m(j)

i(cid:48) = c(j)

i−1 ⊕ c(j(cid:48))
i(cid:48)−1.

In general, with 2d blocks of data,
Success probability.
the probability that there is at least one collision is (using
D = 2d and N = 2n):

p = 1 − D−1(cid:89)
≥ 1 − D−1(cid:89)

i=0

N − i
N

−i/N

e

using 1 − x ≤ e

−x

i=0
−D(D−1)/2N

≥ 1 − e

In particular, with d > n/2, we have p ≥ 1 − e−1/2 ≈ 0.39.
With larger values of d, the probably grows very close to 1:

p ≥ 1 −

2N

D(D − 1) + 2N

using 1 − e

−x >

x

x + 1

≥ 1 − 2N
D2
p ≥ 1 − 2n−2d+1

since D2 < D(D − 1) + 2N

On the other hand, when d < n/2 we can use:

p ≥ D(D − 1)

4N

≈ 22d−n−2

using e

−x < 1 − x/2

Furthermore, with 2d blocks of data the expected number

of collisions is roughly 22d−n−1.
2.3 Distinguishing attack against CTR

The counter mode CTR is another popular mode of opera-
tion for encryption, ﬁrst proposed by Diﬃe and Hellman [14].
In particular, it provides the encryption part of authenti-
cated encryption modes CCM and GCM, and a variant of
counter mode is used in 3G telephony (f8). The counter
mode actually builds a stream cipher out of a block cipher:
a counter is encrypted to generate key-stream that is xored
with the message. More precisely, the message M is divided
into blocks mi, 0 ≤ i < (cid:96) which are encrypted as:

ci = Ek(IV + i) ⊕ mi,

where IV is the initial value of the counter (see Figure 3).

If the encryption function Ek is a pseudo-random function,
rather than a pseudo-random permutation, then CTR is secure
up to 2n blocks [6]. However, in the common case where Ek is
a permutation, CTR is proven secure only up to 2n/2 blocks,
and there is matching distinguishing attack with complexity
2n/2. If a message where all the plaintext blocks are equal
is encrypted, then all the ciphertext blocks will be pairwise
diﬀerent. Indeed, all the Ek(IV + i) are unique, because Ek
is a permutation. This enables the attacker to distinguish
the counter mode from an ideal encryption scheme, because
a collision between two ciphertext blocks becomes likely
(with probability about 0.39). More interestingly, if the
attacker has prior knowledge about the plaintext (such as a

IV + 0

IV + 1

IV + 2

IV + 3

Ek

Ek

Ek

Ek

p(0)
0

p(0)
1

p(0)
2

p(0)
3

c(0)
0

c(0)
1

c(0)
2

c(0)
3

Figure 3: CTR mode

dictionary), he can use the distinguishing attack to eliminate
impossible values to eventually guess the right plaintext [25].
It is interesting to compare the collision attacks against
CBC and CTR. Both attacks have the same complexity, and
show that the proofs are tight. However, the loss of security
is quite diﬀerent: an attacker can immediately recover some
bits of information from the attack against CBC, while the
attack against the counter mode requires a lot more work
to recover any plaintext. In the remainder of this paper,
we investigate on the practical impact of the CBC attack,
but similar techniques (with higher complexity and more
assumptions on the plaintext) may be used to attack CTR
and GCM mode encryption in protocols like TLS and SSH.
2.4 Rekeying before the Birthday Bound

The main countermeasure against birthday attacks is to
change the key frequently, before reaching the birthday bound
under any single key. For instance, if the key is changed after
2n/2−16 blocks, a birthday attack against a given only suc-
ceeds with probability 2−32, and an attacker has to collect 232
diﬀerent sessions to mount an attack with high probability.
If implemented properly, this is an eﬀective security mea-
sure to strengthen block ciphers with a small block-size. We
stress than the key must be changed well before 2n/2 blocks,
despite misleading recommendations in published standards.
For instance, ISO recommends [21]:

Generally, for a block cipher with block size of n
bits, the maximum amount of plaintext that can
be encrypted before rekeying must take place is
2(n/2) blocks, due to the birthday paradox. As
long as the implementation of a speciﬁc block
cipher do not exceed these limits, using the block
cipher will be safe.

This is incorrect, because collisions can be found with high
probability (close to 0.39) with only 2n/2 blocks. Indeed,
we will show that our concrete attacks also work against
connections that are rekeyed close to the birthday bound.
2.5 Towards a Practical Attack on CBC

The CBC attack reveals the xor of two plaintext block, and
in many contexts, this may not be suﬃcient for a practical
attack. However, an eﬀective attack can be mounted when
the following conditions are fulﬁlled: (1) some high-value
secret data is sent repeatedly; and (2) some fraction of the
plaintext is known.
In this case, there is a chance that
a collision leaks the xor between a valuable secret and a
known block; this would immediately reveal the secret. More
precisely, this attack is expected to succeed (i.e. to recover
one block of a high-value secret) with high probability as

459soon as 2s blocks of secret and 2t known blocks are encrypted,
with s + t ≥ n.

To mount the attack in practice, an adversary would collect
and store all the traﬃc, then sort the ciphertext blocks to ﬁnd
collisions. Assuming that the adversary knows the position
of the secret blocks and of the known blocks in the stream,
he can quickly see which collisions are useful, and recover
the secret values by xoring with the known plaintext.

Attack Complexity. Let us denote the known fraction
of the data as α and the secret and valuable fraction of the
traﬃc as β (with fraction 1 − α − β that is neither known
nor valuable to the attacker). In order to recover some secret
information, an attacker must collect roughly 1/2αβ collisions,
so that one collision is between a valuable secret block and
a known block. Following the analysis of Section 2.2, this

requires about(cid:112)1/αβ · 2n/2 blocks of data.

For instance, with n = 64, in an optimal case for the
adversary half of the traﬃc is known, and half of the traﬃc
is highly valuable (α = β = 1/2). In this case, a collision an

attack requires about:(cid:112)1/αβ · 2n/2 = 2 · 2n/2 = 233

blocks of data, which corresponds to just 64 GB. For a more
concrete scenario, let us assume that the messages are HTTP
queries of 512 bytes (64 blocs), with a secret 8-byte cookie
(1 block), and that the remaining of the message is known,
i.e. α = 63/64 ≈ 1, β = 1/64. The number of blocks needed
by an attacker is roughly:

(cid:112)1/αβ · 2n/2 ≈ 8 · 2n/2 = 235

which correspond to 256 GB.

Rekeying at the Birthday Bound. The attack can
also be carried out when rekeying is used, if the keys are
changed with low frequency. In particular, even if the keys
are changed before 2n/2 blocks are encrypted, there is still a
non-negligible probability that a collision occurs.
More precisely, let us assume that keys are rotated after
encrypting 2r blocks (r ≤ n/2). As explained in Section 2.2,
the probability to have a collision between 2r blocks is at
least 22r−n−2. Therefore, an attacker needs 1/2αβ · 2n+2−2r
sessions (i.e. 1/2αβ · 2n+2−r blocks) to collect an interesting
collision. In practice, the attacker would collect all the data
in a session, sort it to ﬁnd collisions, and can discard the
data before collecting data from the next session.

In an optimal setting for the attacker (α = β = 1/2),
if the keys are changed after 2n/2 blocks as recommended
by ISO [21] (r = n/2), the number of blocks needed by an
attacker is roughly:

1/2αβ · 2n+2−r = 2 · 2n/2+2 = 235

which correspond to 256 TB. In the HTTP example above,
the number of blocks needed is roughly:

1/2αβ · 2n+2−r ≈ 32 · 2n/2+2 = 239

which correspond to 4 TB. Therefore rekeying just before
2n/2 blocks only has a limited impact on collision attacks.

Optimal Rekeying Strategies. The optimal use of rekey-
ing has been studied by Abdalla and Bellare in [1], with the
goal of increasing the encryption threshold (the number of
blocks that can be encrypted before the advantage of an
adversary becomes signiﬁcant). Their result depend on the

key size κ and the block size n. When n = κ, the optimal
strategy is to rekey after 2n/3 blocks, leading to an encryp-
tion threshold of 22n/3 (rather than 2n/2 without rekeying).
Concrete ﬁgures for AES-based modes are also given in [24].
On the other hand, when κ ≥ 2n (as is the case for
3DES and Blowﬁsh-128), the optimal strategy is to rekey
for every block. Assuming a perfect rekeying function, this
leads to an encryption threshold of 2n (rather than 2n/2).
In actual protocols such as TLS or OpenVPN, rekeying
requires a new key exchange, which can be quite expensive.
Therefore, rekeying should probably be implemented with
a ﬁxed limit, in the order of a few megabytes. We can
compute the encryption threshold when rekeying every 2r
blocks as 2n−r (this ﬁgure correspond to the optimal case for
an adversary, with α = β = 1/2). For example, by rekeying
every megabyte, a client and server can exchange a petabyte
of data before collision attacks become signiﬁcant.

Exploiting Repeated Messages. We now assume that
a ﬁxed message of 2u blocks is sent repeatedly (this will be
the case for the concrete attacks we describe in Sections 4.4
and 4.5). The attacker’s goal is to recover the full message,
assuming that α · 2u blocks are known or predictable.
If there is a single unknown block, we can use the previous
analysis with α ≈ 1 and β = 2−u: an attacker need roughly
2(n+u)/2 blocks. Indeed, this should lead to roughly 2u−1
collisions, and there is a good chance that one of these
collision is between the secret block and a known block. For a
more accurate analysis, we can use the results of van Oorschot
and Wiener [31], which gives an expected complexity of
If there are a few unknown blocks (k = (1 − α) · 2u), the
number of encrypted blocks required to recover them can be

(cid:112)π/2 · 2(n+u−1)/2 blocks to ﬁnd 2u−1 collisions.

Hk ·(cid:112)π/2 · 2(n+u−1)/2,

approximated as:√
numbers 1 Hk =(cid:80)k

1/i.

i=1

because the number of collision required follows the harmonic

On the other hand, if α is small, the attacker can use
collisions to derive equations between the plaintext blocks,
even if both blocks are unknown. Each collision reveals the
xor between two plaintext blocks, which can seen as an edge in
a graph whose vertexes are the plaintext blocks. If we model
the graph as a random graph with 2u vertexes, we know that
with high probability, the graph will be fully connected when
there are more than Θ(u/2 · 2u) edges [17]. At this point, all
plaintext blocks can be recovered from a single known block.
Therefore, the expected attack complexity becomes:

u ·(cid:112)π/2 · 2(n+u−1)/2

√

Summary of Attack Scenario. With a ﬁxed message
of size 2u repeatedly encrypted, an attacker that knows a
fraction α of the message can recover the k missing blocks of
plaintext (k = (1 − α) · 2u) by observing about log(k) · 2u−1
collisions. This gives an attack with a data complexity of

O(cid:0)(cid:112)log(k) · 2(n+u−1)/2(cid:1)
O(cid:0) log(k) · 2u+n+2−r(cid:1).

encrypted blocks. With rekeying every 2r blocks (r < n/2),
the complexity becomes:

1Assuming that the time to recover each block follows a
geometric law

460Protocol Year

Block ciphers

Mandatory Rekey

TLS 1.0
TLS 1.1
TLS 1.2

1999
2006
2008

3DES, DES, IDEA

AES, 3DES, DES

AES, 3DES

SSH 1
SSH 2

IKEv1
IKEv2
IPsec

1995
3DES, DES, IDEA
2006 AES, 3DES, Blowﬁsh

1998 3DES, DES, Blowﬁsh
2010 AES, 3DES, Blowﬁsh
2014

AES, 3DES

3DES
3DES
AES

3DES
3DES

DES
3DES
AES

-
278
278

-

230,

-
-

1GB

Table 1: Block ciphers in popular versions of Inter-
net protocols; 64-bit ciphers are shown in red

In particular, we will apply this attack to break the security
of encrypted HTTP connections when an authentication
token is send with every request. We use the Beastly attacker
of Figure 1 to generate a large number of requests, where
the headers are mostly predictable or even controlled by the
attacker (α ≈ 1), who can then recover the authentication
token by observing collisions in the encrypted traﬃc.

3. 64-BIT BLOCK CIPHER USAGE ON THE

INTERNET

Many of the most inﬂuential Internet security protocols,
such as TLS, SSH, and IPsec were standardized at a time
when 64-bit block ciphers, such as 3DES and Blowﬁsh, were
still considered strong. Consequently, these ciphers are still
widely supported on the Internet. In this section, we investi-
gate the real-world usage of these ciphers in order to quantify
the feasibility and practical impact of our attacks.
3.1 Block Ciphers in Internet Standards

Table 1 summarizes the support for various block ciphers
in several versions of the TLS, SSH, and IPsec standards.
The table shows that protocols that were standardized be-
fore 2000 typically supported only 64-bit ciphers (primarily
3DES), although later protocol extensions enabled 128-bit
ciphers (primarily AES). Still, old versions of these protocols
remain quite popular on the web. Notably, each standard
speciﬁes a mandatory cipher that “MUST” be supported
for interoperability, and in most of these speciﬁcations, the
mandatory encryption algorithm is 3DES. This means that
all implementations of TLS, SSH, and IPsec must implement
3DES, and unless the user explicitly disables it, they will
oﬀer to negotiate 3DES with their peers.

For example, in TLS 1.0 and 1.1, 3DES is the mandatory
encryption algorithm, so all TLS libraries implement it and
a vast majority of web servers support it. Although TLS
1.2 changed the mandatory cipher to AES, it still explicitly
recommends 3DES as secure [13, Sec. 7.3]:

If you negotiate 3DES with a 1024-bit RSA key
exchange with a host whose certiﬁcate you have
veriﬁed, you can expect to be that secure.

In fact, it has even started being recommended as the new
backup cipher in place of RC4.2 TLS does not mandate
rekeying for short block ciphers, and so TLS libraries leave
the decision to rekey to their applications.

In SSH version 1, the strongest available ciphers are all 64-
bit block ciphers: 3DES, Blowﬁsh, and IDEA, and although
SSH 2 introduced AES-based ciphers, it still labeled 3DES
as the mandatory cipher. Consequently, popular implemen-
tations such as OpenSSH still use 3DES as the default cipher
for SSH-1 connections, and 3DES continues to be the most
widely supports cipher in SSH.3 SSH standards recommend
that implementations rekey after every 1GB of data, or after
every 2n/4 blocks [8], but many popular SSH clients do not
implement this feature.

The early IPSec speciﬁcations also widely used and recom-
mended 3DES. For example, RFC4835 recommended 3DES
as a mandatory (MUST) algorithm until 2007, although the
more recent RFC7321 has downgraded it to a “MAY”. Conse-
quently, most IPSec libraries continue to support 3DES, and
since IPSec deployments tend to be stable over a long period
of time within corporate networks, we anticipate that the
algorithm may continue to be supported on IPSec networks
for the foreseeable future.

In summary, short block ciphers and 3DES in particular
have widespread support in major secure transport protocols,
making them vulnerable to the attacks described in this
paper. However, to evaluate the real-world impact of this
vulnerability, the key question is whether these ciphers are
actually used in connections between popular clients and
servers. In the rest of this section, we attempt to quantify
this usage.
3.2 3DES and Blowﬁsh usage in VPNs

TLS, SSH, and IPSec are often used to implement tunnels
or virtual private networks (VPNs) across untrusted net-
work connections. We have already discussed the widespread
support for 64-bit block ciphers in these protocols, but es-
timating whether these ciphers are actually negotiated in
practice is hard, because unlike web servers, most VPN ser-
vices are not publicly accessible, and each VPN server may
use its own conﬁguration. However, we found a few VPN
solutions that use 64-bit ciphers by default.

IPsec. Most IPSec-based VPN clients support 3DES for
interoperability. Notably, some versions of Microsoft’s L2TP
VPN client use 3DES by default4; some versions of MAC
OS X negotiate 3DES with certain VPN servers5; and some
versions of CISCO IPsec VPN devices implement hardware
optimizations for 3DES and consequently prefer it over other
ciphers.6

OpenVPN. OpenVPN is a popular open-source VPN so-
lution originally written by James Yonan. The default en-
cryption for the transport protocol of OpenVPN is Blowﬁsh,
a 64-bit cipher, in CBC mode. OpenVPN supports two diﬀer-
ent ways of generating session keys to encrypt the messages.
In pre-shared-key mode, static keys are used for all the traf-

As a result, mainstream TLS libraries still treat 3DES to be
at the same security level as AES-128. For example, until
we disclosed the attacks in this paper, OpenSSL included
3DES ciphersuites in its HIGH-security list (it has now been
moved to MEDIUM). Moreover, while the use of RC4 in TLS
has been explicitly deprecated in RFC7465 in response to
recent attacks, 3DES continues to be trusted by TLS libraries.

2https://wiki.mozilla.org/Security/Server Side TLS
3https://blog.binaryedge.io/2015/11/10/ssh/
4https://support.microsoft.com/en-us/kb/325158
5http://www.jacco2.dds.nl/networking/openswan-
macosx.html
6http://www.cisco.com/c/en/us/td/docs/ios/12 2/12 2z/
12 2zj/feature/guide/gtaimvpn.html

461Firefox Version

AES

3DES support Andr5 FF44

IE11 Chr47

# Release date RC4

3DES CBC GCM

35
36
37
38
39
40
41
42
43
44
45

2015/01/13
2015/02/24
2015/03/31
2015/05/12
2015/07/02
2015/08/11
2015/09/22
2015/11/03
2015/12/15
2016/01/26
2016/03/08

20.4
0.20
0.13
0.09
0.08
0.08
0.08
0.08
0.05

–
–

0.15
1.81
1.81
1.82
1.81
1.68
1.44
1.26
1.19
1.17
1.13

27.5
45.5
41.7
36.0
31.6
29.7
27.9
27.9
28.6
28.3
28.1

51.9
52.5
56.4
62.1
66.5
68.6
70.6
70.7
70.2
70.5
70.8

Table 2: Cipher use for TLS connection from the
Firefox web browser (percentage). The ﬁgures come
from telemetry data available at https://telemetry.
mozilla.org/ (we use the SSL_SYMMETRIC_CIPHER_FULL
metric), and are gathered during the lifetime of a
particular version. RC4 is fallback-only since ver-
sion 36.

ﬁc. In particular, there is no limit to the lifetime of those
keys. In TLS mode, session keys are generated with a TLS
handshake, using certiﬁcates to authenticate the peers. The
session keys are updated periodically, with limits on the
number of packets, the number of bytes, or a session time.
The default conﬁguration rekeys the tunnel every hour. In
addition, the tunnel is rekeyed shortly before 232 packets in
TLS mode, because the packet counter is a 32-bit integer. In
pre-shared-key mode, the packet counter is a 64-bit integer.
3.3 3DES usage in HTTPS

3DES is the second most widely supported cipher (after
AES) in HTTPS servers, with about 87% of servers support-
ing it.7 Furthermore, all popular web browsers support 3DES.
The cipher that is actually negotiated for a TLS connection is
chosen by the server, based on its local preference order and
on the order in which the client advertises its ciphersuites.
Since most modern browsers and servers prefer AES over
3DES, we ﬁnd evidence that 1-2% of all TLS connections
likely use 3DES in CBC mode, as detailed below.

Browser Telemetry. Telemetry data from Mozilla Firefox
(given in Table 2) show that 3DES is used for more than 1%
of HTTPS connections from Firefox browsers. Interestingly,
the use of 3DES with Firefox has actually increased recently,
as a consequence of the removal of RC4 from the list of
supported ciphers in version 36 (following [3] and RFC 7465).
Indeed a number of servers are conﬁgured to use, in order of
preference, ﬁrst RC4, then 3DES, and now use 3DES with
Firefox.

Other browser vendors have privately reported the fol-
lowing telemetry data to us. Microsoft sees 1.2% 3DES
connections for Internet Explorer and Edge, but only 0.8%
system wide (the lower value can be explained by the fact
that some applications still support RC4). Google Chrome
sees 1.1% of connections using 3DES, but this number peaked
at 1.6% soon after RC4 was disabled.

7https://securitypitfalls.wordpress.com/2016/04/17/
february-2016-scan-results-incomplete/

Top 1k
Top 10k
Top 100k
Top 1m

93% 0.4% 1.6% 1.6% 1.6%
92% 1.0% 2.1% 2.1% 2.1%
89% 0.8% 1.9% 1.9% 1.9%
86% 0.6% 1.3% 1.3% 1.3%

3DES support for HTTPS servers in
Table 3:
Alexa’s top website list. We count servers that sup-
port 3DES, and servers that would select 3DES with
common browsers: Android 5.0 integrated browser,
Firefox 44, Internet Explorer 11, and Chrome 47.
Scans performed on February 16 – 18, 2016.

Scanning the Top 1M Websites. We performed a scan
of the top 1 million servers as listed by Alexa using the
cipherscan tool8. We found that 86% of the servers that
support TLS include 3DES as one of the supported ciphers.
Moreover, using the ciphersuites sent by a modern client
(Firefox 44, IE 11 or Chrome 47), we estimate that 1.2% will
actually use a 3DES based ciphersuite. We report detailed
ﬁgures in Table 3.

Windows XP Clients and Windows 2003 Servers.
The Windows XP and Windows Server 2003 operating sys-
tems do not support AES-based ciphersuites, although sup-
port for AES can be added with an optional hotﬁx. With the
default conﬁguration, they support only RC4, 3DES, DES,
and RC2-40. While these operating systems are not sup-
ported anymore by Microsoft, they still have users, and this
creates situations where the best available cipher is 3DES.

If a client uses Internet Explorer on Windows XP or Win-
dows Server 2003 to connect to a modern web server (with
no RC4 ciphersuites), the connection will use 3DES or fail.
Indeed, supporting Windows XP clients is the main stated
reason for servers to continue supporting RC4 and 3DES.

If a web server runs on IIS 6.0 (i.e. Windows XP or
Windows Server 2003), it will oﬀer only RC4 and 3DES
ciphersuites, unless support for AES ciphersuites has been
added.
If a modern web browser visits the website over
HTTPS, the connection will use 3DES. According to web
server surveys9, IIS 6.0 powers about 1.9% of SSL enabled
web servers, but it is likely used even more within corporate
networks, and these servers would not appear in public scans.

In order to mount
Long-lived HTTPS connections.
the attack in practice, we need to ﬁnd client and servers
that not only negotiate the use of 3DES, but also exchange a
large number of HTTP request in the same TLS connection
(without rekeying). This is possible using a persistent HTTP
connection, as deﬁned in HTTP/1.1 (Keep-Alive).

On the client side, all browsers that we tested (Firefox,
Chrome, Opera) will reuse a TLS connection as long as the
server keeps it open. On the server side, we found that
a number of HTTP servers will close the TLS connection
even when it is still active. In particular, Apache and Nginx
limit the number of requests sent in the same connection,
with a maximum of 100 in the default conﬁguration10. On

8https://github.com/jvehent/cipherscan
9http://www.securityspace.com/s survey/sdata/201604/
servers.html
10The setting is called MaxKeepAliveRequests for Apache,
and keepalive_requests for Nginx.

462Website

connection closed after
1 hour†

google.com
facebook.com no limit detected†
youtube.com no limit detected†
no limit detected†
yahoo.com
up to one day†
live.com
100 requests
baidu.com
100 requests
amazon.com
100 requests
wikipedia.org
2000 requests
qq.com
twitter.com
50 requests

Table 4: Maximum connection lifetime for Alexa’s
top 10 servers (detected experimentally). The “†”
symbol marks servers which accept at least one mil-
lion requests in a single TLS connection.

the other hand, IIS does not seem to have such a limit.
In practice, many high proﬁle servers accept a very large
number of requests in a single TLS connection. We made
some experiments using a simple Perl script to send simple
HTTP requests over a TLS connection, using pipelining to
maximize the throughput. As seen in Table 4, we found that
about half of the servers in Alexa’s top 10 support a large
number of requests without rekeying.

For a better estimate of the number of vulnerable servers,
we tested servers from Alexa’s top 10k that negotiate 3DES
with a modern client. We identiﬁed 11483 diﬀerent HTTPS
servers11, and found that 226 of them (1.9%) negotiate 3DES
with a modern client. Moreover, 72 of these (0.6% of the
total) also accept to keep a connection open for at least
800k requests. Consequently, the duration of the attack
is not unrealistic, at least from the viewpoint of browsers
and servers, and we estimate that at least 0.6% of HTTPS
connections are vulnerable to our attacks.

Downgrading to 3DES. From our measurements, only
1-2% of HTTPS connections use 3DES, and perhaps even
fewer of these connections are to servers that allow long-
lived TLS connections. However, ignoring the danger posed
by 3DES would be dangerous for several reasons. 3DES
is typically the second or third most preferred encryption
algorithms in HTTPS, so any change in the client or server
conﬁgurations, say in response to some future attack on AES,
would cause a large number of connections to fallback to
3DES. Furthermore, as recent downgrade attacks on TLS (e.g.
FREAK) have demonstrated, protocol and implementation
ﬂaws can sometimes cause a weaker cipher to be negotiated.
For example, if a downgrade attack from TLS 1.2 to SSL 3
becomes possible, then the strongest SSL 3 cipher that can
be negotiated may well be 3DES. As an example, we describe
a downgrade attack to 3DES that is currently possible on
TLS connections. Although it does not enable our full attack,
it nevertheless serves as a useful warning for practitioners.

Downgrading False Start. TLS False Start [23] is an
optimization to the TLS handshake that reduces its latency.
A client implementing False Start will start sending data
before receiving the Finished message from the server. This
allows an attacker to force the selection of a ciphersuite by

11We tested common sub-domains: www, m, secure, signin,
auth, account, login

tampering with the ServerHello message (he can replace AES
by 3DES, for example) and the client will start sending data
before verifying that the ciphersuite was really selected by
the authentic server. If the client is willing to send millions of
requests and gigabytes of data before ﬁnishing the handshake,
this could allow our attack even against a server that would
not select a 3DES ciphersuite. While 3DES ciphersuite
are not recommended for use with False Start in the RFC
draft [23], it turns out that they are white-listed for use with
False Start with Internet Explorer. We have informed the
Microsoft security team and they decided to remove 3DES
from this white-list.
4. ATTACKING AUTHENTICATED HTTP

OVER TLS AND OPENVPN

We now demonstrate concrete attacks against authenti-
cated HTTP sessions even when they are secured by TLS
or OpenVPN. First, we identify a few examples of secret
authentication credentials that are repeatedly sent by the
browser on every request. We then show how we can recover
these secrets using block cipher collisions.
4.1 HTTP bearer tokens

Cookie-based Sessions. Modern HTTPS websites use a
variety of methods to manage authenticated sessions with
their clients. The most popular mechanism is secure cookies
as speciﬁed in RFC6265. Once a user has logged in, the
server sets a cookie containing a secret value on the user’s
browser. The browser will then send the cookie on all subse-
quent requests to the website, implicitly authenticating the
user. For example, if domain.com sets a cookie C=XXXX, a
subsequent HTTPS request from the browser looks like:

GET /path/to/file HTTP/1.1
User-Agent: Mozilla/4.0 ...
Host: domain.com
Cookie: C=XXXXX
Accept-Language: en-us
Accept-Encoding: gzip, deflate
Connection: Keep-Alive

Cookies are sensitive, because an attacker who obtains a
session cookie can then log in as the user from a diﬀerent
browser. The cookie acts as a bearer token that carries the
user’s delegated credential. Except for its short-lived nature,
it has the same security requirements as a password. Indeed,
many websites, such as Facebook, use cookies with very long
expiry times, making cookie theft even more attractive.

A cookie for a website is normally included in all requests
to that website whether that request was initiated by the
user, or a script on the website, or even by a diﬀerent website.
Browsers sometimes impose stricter rules for this last category
of requests, called cross-origin or cross-domain requests. For
example, XmlHttpRequests sent from one domain to another
may not have cookies attached. However, cross-domain
requests for images or iframes will still send cookies.

HTTP BasicAuth. On corporate networks and even on
the web, many websites are protected using the HTTP Basic
Authentication mechanism speciﬁed in RFC7617. When the
server asks for Basic authentication, the browser prompts
the user to enter a username and password into a special
dialog and then sends this information (in plaintext) as an
HTTP header of the form:

463Authorization: Basic dGVzdDoxMjPCow=

Once a user has entered his login information once, the
browser will typically cache this information and use it on all
subsequent requests to the server. Notably, even if a diﬀerent
website creates a cross-domain request to the authenticated
server, the BasicAuth credentials will be automatically sent
by the browser.

BasicAuth credentials contain the user’s password and are
hence security-critical. One should only use this authenti-
cation mechanism over HTTPS but a number of corporate
websites use BasicAuth over HTTP, under the assumption
that their users can only access the website over a VPN or
some other secure connection.

OAuth and OpenID Connect Access Tokens. With
the growth in popularity of single sign-on protocols, many
websites now allow users to login with third-party creden-
tials, such as OAuth or OpenID Connect tokens, issued by
major websites like Google and Facebook. These tokens are
eﬀectively bearer tokens that must then be attached to all
authentication and authorization requests and are sent either
within the URI or in an Authorization header. While the
use of these tokens is speciﬁc to each website, an attacker
can usually repeatedly trigger the sending of these tokens
by re-initiating the login sequence. An attacker who steals
one of these tokens can then impersonate the user as well as
retrieve sensitive data about the user from the login provider.
4.2 The Beastly Attack Scenario

Our attack scenario, depicted in Figure 1, is similar to the
setup used in recent attacks on RC4 [3, 19, 32]. The attacker
wants to steal some bearer token that is being repeatedly
sent by a browser to a website secured with HTTPS, or an
HTTP website accessed through a VPN. We assume that the
attacker can control some JavaScript on a web page loaded
by the user’s browser, either by actively tampering with an
HTTP response on the wire, or by hosting a malicious website
that the user is fooled into visiting. We also assume that the
attacker can observe all the encrypted traﬃc between the
target browser and the secure website.

We further assume that the data is encrypted with a 64-bit
block cipher in CBC mode (either an HTTPS connection
where the client and server have negotiated 3DES, or an
HTTP connection though a VPN encrypted with Blowﬁsh
or 3DES). Suppose the victim is already logged in to a
website and has a session cookie. The attacker runs malicious
JavaScript code on the victim’s browser that repeatedly sends
HTTP queries to the target website server, each containing
the session cookie. If he sends close to 232 queries, a collision
is expected between a ciphertext block corresponding to the
cookie (ci), and a known block (cj), containing a known part
of the query. The collision attack against CBC reveals the
session cookie: pi = pj ⊕ ci−1 ⊕ cj−1.

Note that most of the traﬃc generated by the attacker
is known or predictable. The requested URL is chosen by
the attacker, and all the headers excepted the cookie are
predictable and can be observed in any plaintext HTTP
traﬃc. We will assume that the Cookie takes 16-bytes, i.e.
two blocks, and that the attacker has aligned the cookie
to a block boundary using other headers. As explained in
Section 2.2, if a query contains 2u known blocks, the number
of encrypted blocks required for the attack is about:

H2 ·(cid:112)π/2 · 2(n+u−1)/2.

√

In practice, an HTTP query is about 512 bytes (64 blocks),
which implies a total complexity of 235.1 blocks (229.1 queries),
and a total captured trace of size 280 GB.

However, the attack can be made faster by using larger
queries: this increases the total amount of data to capture,
but it reduces the total number of queries. Since the speed
of clients and servers is dependent on the number of queries,
a larger query size can result in a faster attack overall. In
our experiments, we got good results with 4 kB queries (512
In this setting, the attack requires 236.6 blocks
blocks).
(785 GB), but this corresponds to only 227.6 queries:
in-
√
creasing the requests size by a factor 8 (from 512 bytes to
√
8,
4 kB) increases the total data to capture by a factor
and reduces the number of queries needed by a factor
8.
In practice large queries can be produced by adding a long
query string to the URL.
4.3 Proof-of-concept Code

The attacker code consists of two parts: a JavaScript
program that sends a large number of HTTP requests, and
a network adversary who processes the resulting ciphertext
to recovers a 16-byte secret.

Man-in-the-browser code. We experimented with hid-
den <img> tags in a web-page with Javascript code to the
onload event to reload the images repeatedly, and web work-
ers issuing XmlHttpRequests. Cookies are automatically
inserted when loading images from a diﬀerent domain, and
are also included in cross-domain XmlHttpRequests if the
withCredentials property is set to true (this is only al-
lowed for synchronous request, and the request result can
not be read, but these restrictions don’t prevent our attack).
According to our experiments, request are generated faster
using XmlHttpRequest. In order to avoid caching, we request
a non-cacheable resource. Alternatively, we can include a
unique query string in each URL, but the responses are still
cached by the client and this can aﬀect the query rate. We
experimented with several browsers, and we obtained the
best results with Firefox Developer Edition 47.0a2 12.

Recovering collisions. We captured the encrypted pack-
ets with tcpdump and used a C++ program to extract the
ciphertext blocks (using libpcap). In both the HTTPS at-
tack and the OpenVPN attack, each HTTP query is sent in
a separate encrypted record, which contain the plaintext at
a ﬁxed position, as well as some extra information (packet
number, padding, MAC, ...). Therefore, it is easy to know
to which plaintext block corresponds each ciphertext block,
and to align the cookie to a block limit.

After capturing all the traﬃc, the C++ program sorts
the ciphertext blocks in order to locate collisions. Since the
amount of data is quite large (hundreds of gigabytes), we use
the external sort implementation of the stxxl library. With
a NAS storage, sorting the data took around four hours.
4.4 Attacking Basic Auth over OpenVPN

To demonstrate the attack against OpenVPN, we use a pre-
shared-key tunnel between two physical machines running
Linux, with Firefox Developer Edition 47.0a2 on one side,
and an nginx server on the other side. Access to the server
is protected by BasicAuth, and the user has entered his

12We have similar results with the stable version Firefox 48.0
which was released after we made our experiments.

464credentials. Using the default OpenVPN settings, the tunnel
is encrypted with Blowﬁsh in CBC mode.

We use the Javascript code described in the previous sec-
tion to send a large number of requests to the server though
the tunnel. We found that increasing the size of the request
to 4 kB does not signiﬁcantly reduce the query rate, but
reduces the number of queries required for the attack. In
our setting, the browser generates about 2900 requests per
second, using several web Worker running in parallel. We
expect the ﬁrst collision after roughly 232.3 blocks (40 GB),
i.e. one hour. In practice, we detected the ﬁrst collision
early, after only 30 minutes (231.3 blocks); as expected, the
predicted xor diﬀerence was correct. The full attack needs
about 236.6 blocks (785 GB) to recover a two-block secret
out of 4 kB messages; this should take about 19 hours in this
setting. In our demo, it took 18.6 hours and 705 GB, and
we successfully recovered the 16-byte authentication token.

In TLS mode, OpenVPN
OpenVPN in TLS mode.
rekeys the tunnel every hour with the default settings (as
apposed to the pre-shared-key mode used above that doesn’t
do any rekeying). With our experimental setting, this means
we can only capture about 223.3 requests encrypted with a
given key, i.e. 232.3 blocks. Therefore, we expect to detect a
collision with probability close13 to 1/2. In order to recover
a two-byte secret out of 4 kB messages, we need about 384
collisions as explained in Section 2.2. Therefore, this attack
will take roughly 768 hours, or 32 days.

This illustrate the point that keys should be changed well
before reaching 232 blocks:
if each session is broken after
232 blocks, there is still a collision with probability roughly
1−e−1/2 ≈ 0.4. This increases the time required by the attack
to 40 days, but it will still succeed with high probability.
4.5 Attacking Secure Cookies over HTTPS

The attack against HTTPS connection is very similar to
the attack against OpenVPN, as long as we have a client
and server that negotiate 3DES, and that keep a connection
open for a long time.

Vulnerable Websites. As detailed in Section 3.3, about
0.6% of the top Alexa 100K websites support 3DES and
allow long-lived HTTPS connections. This list contains many
high-proﬁle e-commerce and banking websites, including the
ones shown in Table 5. In addition, we found a number of
domains were the server serving domain.com will use 3DES,
but it just redirects the client to a better conﬁgured server
for www.domain.com. This could still open the way for our
attacks, if sessioncookies for www.domain.com are set at the
top-level domain and hence also sent to domain.tld. The
last three websites in Table 5 belong to this category.

Proof-of-Concept Attack Demo.
In our setup we use
Firefox Developer Edition 47.0a2 running on Linux and an IIS
6.0 server in a Windows Server 2003 R2 SP2 Virtual machine.
The default conﬁguration of IIS 6.0 with all recommended
updates oﬀers only RC4 and 3DES ciphers, and will use
3DES with Firefox and other recent browsers where RC4 is
disabled. Moreover, IIS 6.0 supports HTTP/1.1 and keeps
an active connection open for an arbitrary long time.

We use the Javascript code described in Section 4.3, but we
note that with several Workers running in parallel (or several
<img> tags), modern browsers open a few parallel connec-
13The probability can be computed as 1 − e−232.2232.2/264

.

Website

Category

E-commerce
https://signin.ebay.com
Finance
https://account.nasdaq.com
https://www.bancomercantil.com
Banking
https://www.unionbankonline.co.in Banking
Banking
https://ziraatbank.com.tr
https://www.state.nj.us
Government
Dating
https://secure.match.com

https://amadeus.net
https://walmart.com
https://citrix.com

Travel
Corporate
Corporate

Table 5: High-value websites that negotiate 3DES
with modern browsers, and accept at least 1 million
requests in the same TLS session

tions to the server (typically, 6) and split the requests over
these connections. For our attack, we need to maximize the
throughput over a single connection. This can be achieved
by disturbing some of the connections so that most of request
are send in a single. In our setup, we used iptables rules to
limit the rate of all connections except one. In a real attack,
this would be done by an active man-in-the-middle, but a
passive man-in-the-middle can also mount the attack – it
will just take more time to collect the data.

On Firefox Developer Edition 47.0a2, with a few dozen
Workers running in parallel, we can send up to 2000 requests
per second in a single TLS connection. To further reduce
the time needed for the attack, we inject a padding cookie
to expand the requests to 4 KB (512 blocks). In our setting
this reduces the rate to 1500 requests per second, but it still
leads to a faster attack. Again, we expect the ﬁrst collision
after roughly 232.3 blocks (40 GB), i.e. 223.3 queries. This
should take slightly less than two hours.

In our experiment, we were lucky to detect the ﬁrst collision
after only 25 minutes (220.1 requests), and we veriﬁed that
the collision revealed the xor of two plaintexts blocks. As
seen previously, the full attack should require 236.6 blocks
(785 GB) to recover a two-block cookie, which should take
38 hours in our setting. Experimentally, we recovered the
two-block cookie after only 30.5 hours and 610 GB.

Note that special care must be taken to recover the ﬁrst
block of a TLS fragment. When a collision involves the
ﬁrst ciphertext block (c(j)
), this gives an equation
involving the IV (c(j)
special treatment for TLS 1.0, because the IV of a given of a
given record is not explicitly included in the message: it is
the last ciphertext block of the previous record.

i−1 = c(j(cid:48))−1 ). In particular, this requires

i = c(j(cid:48))

0

Our attack above relied on knowing most of the plaintext,
but if we have enough data we can even recover most of the
plaintext using just a single known block. In our experiment,
after 65 hours (228.3 requests, 1.3TB) we can recover 492
blocks out of 510, assuming a single known plaintext block.

5.

IMPACT AND MITIGATION

We have demonstrated the ﬁrst concrete attacks on main-
stream Internet protocols that exploit block cipher collisions.
Our attacks can recover valuable secrets such as HTTP cook-
ies and passwords in under 40 hours. Our attacks impact a

465majority of OpenVPN connections and an estimated 0.6%
of HTTPS connections to popular websites. We expect that
our attacks also impact a number of SSH and IPsec connec-
tions, but we do not have concrete measurements for these
protocols. Like many recent attacks on TLS, such a BEAST
and RC4 NOMORE, the underlying principles behind our
attacks were well known to cryptographers. Our goal is to
raise awareness among practitioners about the vulnerabilities
of short block ciphers and on safe ways of using them.
5.1 Comparison with RC4 attacks

Our attack scenario is very similar to the setup of the
recent attacks on the use of RC4 in HTTPS. We use the
same man-in-the-browser setting to generate a large number
of HTTP requests, and the data complexity of our attacks is
comparable to these prior works:

• the ﬁrst attack by Al Fardan et al. [3] uses between
228 and 232 sessions, with rekeying for each session,
to recover the ﬁrst 220 bytes a the message (but the
cookie is not usually in these 220 bytes);

• the second attack by Al Fardan et al. [3] uses between
233 and 234 request, in the same TLS session or in
diﬀerent sessions, to recover a cookie;

• Garman et al. [19] improved the ﬁrst attack to require
only 226 sessions when targeting a BasicAuth password,
using a better guessing strategy;

• the latest attack by Vanhoef and Piessens [32] requires
230.2 requests, in the same TLS session or in diﬀerent
sessions, to recover a cookie.

In comparison, our attack requires only 229.1 short queries
of 512 bytes (280 GB in total), which can be reduced to
227.6 longer queries of 4 kB (785 GB in total). However,
these numbers are for the case when all the data is encrypted
within the same session. Even if the amount of data sent on
a single connection is limited, as long as the limit is close
enough to the birthday bound, we can still mount our attacks
across multiple parallel and sequential sessions, albeit with a
higher data and time complexity.
5.2 Mitigation

The obvious way to avoid these attacks is to stop using
legacy 64-bit block-ciphers. There is no good reason to conﬁg-
ure a VPN or an HTTPS server to prefer 3DES (or Blowﬁsh)
over AES. AES is more secure, is a FIPS standard, and will
almost certainly be faster: it is implemented in hardware
in most server and desktop CPUs, and can be implemented
eﬃciently in dedicated hardware when an extremely high
throughput is required.

On the other hand, there are speciﬁc uses of cryptography
were 128-bit block ciphers can not be used, because of legacy
reasons, or due to the relatively large hardware footprint of
128-bit ciphers (in this case, lightweight 64-bit block ciphers
such as PRESENT or HIGHT would typically be used). In
these scenarios, protocol designers should pay close attention
to the issue of birthday attacks. In particular, they should
verify that the amount of data encrypted with a ﬁxed key is
signiﬁcantly smaller than 232 blocks, or use modes that pro-
vide security beyond the birthday bound, such as CENC [22]
or PMAC plus [33].

Concretely, we recommend the following measures to pre-

vent our attack:

1. Web servers and VPNs should be conﬁgured to prefer
128-bit ciphers. According to our scans, about 1.1% of
the top 100k web server from Alexa, and 0.5% of the
top 1 million, support AES but prefer to use 3DES.

2. Web browsers should oﬀer 3DES as a fallback-only
cipher, to avoid using it with servers that support AES
but prefer 3DES.

3. TLS libraries and web browsers and servers should limit
the length of TLS sessions with a 64-bit cipher. This
could be done in TLS renegotiation, or in some cases
by closing the connection and starting a new one (i.e.
limiting HTTP/1.1 Keep-Alive, SPDY, and HTTP/2
with 3DES ciphersuites).

5.3 Responsible Disclosure

We have communicated our results and concerns to the
OpenVPN team, and to various website owners, browser
vendors, and TLS libraries. They all acknowledged the issue,
and are working on implementing countermeasures. The
TLS vulnerability received CVE number CVE-2016-2183.
OpenVPN will display a warning to users who choose to
use 64-bit ciphers and encourage them to transition to AES-
GCM (cipher negotiation is also being implemented in the
2.4 branch). It will also implement a default renegotiation
limit of 64MB when used in TLS mode.
OpenSSL has moved 3DES ciphersuites from the HIGH cat-
egory to MEDIUM in the 1.0.2 branch, and will disable it by
default in the upcoming 1.1.0 release.
Akamai will oﬀer an option for web server administrators
to drop 3DES from the oﬀered ciphers.
Apple has disabled 3DES on icloud.com and is recommend-
ing that all its customers disable 3DES on their websites.

Currently, most browsers see about 1% of their connections
using 3DES, and vendors consider this number too high
to simply disable 3DES on the client side, since too many
websites would be broken. So, they are instead considering
implementing data limits per connection to force rekeying,
or oﬀering 3DES ciphersuites only in a fallback negotiation
if no AES ciphersuite is acceptable to the server.
Mozilla is implementing data limits for all ciphersuites:
https://bugzilla.mozilla.org/show bug.cgi?id=1268745

.

Microsoft has removed 3DES from the False Start whitelist:
https://technet.microsoft.com/library/security/3155527.aspx
More details about implemented countermeasures will be

added to our webpage as they become available:

http://sweet32.info

6. REFERENCES
[1] M. Abdalla and M. Bellare. Increasing the lifetime of a
key: a comparative analysis of the security of re-keying
techniques. In T. Okamoto, editor, ASIACRYPT 2000,
volume 1976 of LNCS, pages 546–559. Springer,
Heidelberg, Dec. 2000.

[2] D. Adrian, K. Bhargavan, Z. Durumeric, P. Gaudry,

M. Green, J. A. Halderman, N. Heninger, D. Springall,
E. Thom´e, L. Valenta, B. VanderSloot, E. Wustrow,
S. Z. B´eguelin, and P. Zimmermann. Imperfect forward
secrecy: How Diﬃe-Hellman fails in practice. In I. Ray,
N. Li, and C. Kruegel:, editors, ACM CCS 15, pages
5–17. ACM Press, Oct. 2015.

466[3] N. J. AlFardan, D. J. Bernstein, K. G. Paterson,

[19] C. Garman, K. G. Paterson, and T. V. der Merwe.

B. Poettering, and J. C. N. Schuldt. On the Security of
RC4 in TLS. In S. T. King, editor, USENIX Security,
pages 305–320. USENIX Association, 2013.

[4] N. J. AlFardan and K. G. Paterson. Lucky thirteen:

Breaking the TLS and DTLS record protocols. In 2013
IEEE Symposium on Security and Privacy, pages
526–540. IEEE Computer Society Press, May 2013.

[5] N. Aviram, S. Schinzel, J. Somorovsky, N. Heninger,

M. Dankel, J. Steube, L. Valenta, D. Adrian, J. A.
Halderman, V. Dukhovni, E. Kasper, S. Cohney,
S. Engels, C. Paar, , and Y. Shavitt. DROWN:
Breaking TLS using SSLv2, 2016.
https://drownattack.com.

[6] M. Bellare, A. Desai, E. Jokipii, and P. Rogaway. A

concrete security treatment of symmetric encryption. In
38th FOCS, pages 394–403. IEEE Computer Society
Press, Oct. 1997.

[7] M. Bellare, J. Kilian, and P. Rogaway. The security of

cipher block chaining. In Y. Desmedt, editor,
CRYPTO’94, volume 839 of LNCS, pages 341–358.
Springer, Heidelberg, Aug. 1994.

[8] M. Bellare, T. Kohno, and C. Namprempre. The Secure
Shell (SSH) Transport Layer Encryption Modes. IETF
RFC 4344, 2006.

[9] B. Beurdouche, K. Bhargavan, A. Delignat-Lavaud,

C. Fournet, M. Kohlweiss, A. Pironti, P.-Y. Strub, and
J. K. Zinzindohoue. A messy state of the union:
Taming the composite state machines of TLS. In 2015
IEEE Symposium on Security and Privacy, pages
535–552. IEEE Computer Society Press, May 2015.
[10] K. Bhargavan and G. Leurent. Transcript Collision

Attacks: Breaking Authentication in TLS, IKE, and
SSH. In ISOC Network and Distributed System Security
Symposium (NDSS16), 2016.

[11] K. K. Bodo Moller, Thai Duong. This POODLE Bites:

Exploiting The SSL 3.0 Fallback, 2014.
https://www.openssl.org/˜bodo/ssl-poodle.pdf.

[12] A. Bogdanov, L. R. Knudsen, G. Leander, C. Paar,

A. Poschmann, M. J. B. Robshaw, Y. Seurin, and
C. Vikkelsoe. PRESENT: An ultra-lightweight block
cipher. In P. Paillier and I. Verbauwhede, editors,
CHES 2007, volume 4727 of LNCS, pages 450–466.
Springer, Heidelberg, Sept. 2007.

[13] T. Dierks and E. Rescorla. The Transport Layer

Security (TLS) Protocol Version 1.2. IETF RFC 5246,
2008.

[14] W. Diﬃe and M. E. Hellman. Privacy and

authentication: An introduction to cryptography.
Proceedings of the IEEE, 67(3):397–427, 1979.
[15] T. Duong and J. Rizzo. Here come the ⊕ ninjas.

Unpublished manuscript, 2011.

[16] M. Dworkin. Recommendation for Block Cipher Modes
of Operation. NIST Special Publication
800-38{A,B,C,D}, National Institute for Standards and
Technology, 2001 – 2011.

[17] P. Erdos and A. R´enyi. On the evolution of random
graphs. Bull. Inst. Internat. Statist, 38(4):343–347,
1961.

[18] S. Frankel and S. Krishnan. IP Security (IPsec) and
Internet Key Exchange (IKE) Document Roadmap.
IETF RFC 6071, 2011.

Attacks Only Get Better: Password Recovery Attacks
Against RC4 in TLS. In J. Jung and T. Holz, editors,
USENIX Security, pages 113–128. USENIX Association,
2015.

[20] D. Hong, J. Sung, S. Hong, J. Lim, S. Lee, B.-S. Koo,
C. Lee, D. Chang, J. Lee, K. Jeong, H. Kim, J. Kim,
and S. Chee. HIGHT: A new block cipher suitable for
low-resource device. In L. Goubin and M. Matsui,
editors, CHES 2006, volume 4249 of LNCS, pages
46–59. Springer, Heidelberg, Oct. 2006.

[21] On the Assessment of Cryptographic Techniques and

Key Lengths, 4th edition. ISO/IEC JTC 1/SC 27
Standing Document 12, May 2014. Available online:
http://www.din.de/blob/78392/
6f4bbd95d0cf11d1b32784948039600b/sc27-sd12-
data.pdf.

[22] T. Iwata. New blockcipher modes of operation with

beyond the birthday bound security. In M. J. B.
Robshaw, editor, FSE 2006, volume 4047 of LNCS,
pages 310–327. Springer, Heidelberg, Mar. 2006.

[23] A. Langley, N. Modadugu, and B. Moeller. Transport
Layer Security (TLS) False Start. Internet Draft, Nov.
2015.
https://tools.ietf.org/html/draft-ietf-tls-falsestart-01.

[24] A. Luykx and K. G. Paterson. Limits on authenticated

encryption use in TLS, march 2016.
http://www.isg.rhul.ac.uk/˜kp/TLS-AEbounds.pdf.
[25] D. McGrew. Impossible plaintext cryptanalysis and

probable-plaintext collision attacks of 64-bit block
cipher modes. In Fast Software Encryption Workshop
(FSE), 2013. https://eprint.iacr.org/2012/623.

[26] D. McGrew and P. Hoﬀman. Cryptographic Algorithm
Implementation Requirements and Usage Guidance for
Encapsulating Security Payload (ESP) and
Authentication Header (AH) . IETF RFC 7321, 2014.

[27] E. Petrank and C. Rackoﬀ. CBC MAC for real-time
data sources. Journal of Cryptology, 13(3):315–338,
2000.

[28] J. Rizzo and T. Duong. The crime attack. In EKOparty

Security Conference, volume 2012, 2012.

[29] P. Rogaway. Problems with Proposed IP Cryptography.

Unpublished draft, 1995.
http://web.cs.ucdavis.edu/˜rogaway/papers/draft-
rogaway-ipsec-comments-00.txt.

[30] P. Rogaway. Evaluation of Some Blockcipher Modes of

Operation. Technical report, CRYPREC, Feb 2011.

[31] P. C. van Oorschot and M. J. Wiener. Parallel collision

search with cryptanalytic applications. Journal of
Cryptology, 12(1):1–28, 1999.

[32] M. Vanhoef and F. Piessens. All Your Biases Belong to
Us: Breaking RC4 in WPA-TKIP and TLS. In J. Jung
and T. Holz, editors, USENIX Security, pages 97–112.
USENIX Association, 2015.

[33] K. Yasuda. A new variant of PMAC: Beyond the

birthday bound. In P. Rogaway, editor, CRYPTO 2011,
volume 6841 of LNCS, pages 596–609. Springer,
Heidelberg, Aug. 2011.

[34] T. Ylonen and C. Lonvick. The Secure Shell (SSH)

Transport Layer Protocol. IETF RFC 4253, 2006.

467