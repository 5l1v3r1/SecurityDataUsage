Deniable Key Exchanges for Secure Messaging

Cheriton School of Computer Science

Cheriton School of Computer Science

Ian Goldberg

University of Waterloo,
Waterloo, ON, Canada

iang@cs.uwaterloo.ca

Nik Unger

University of Waterloo,
Waterloo, ON, Canada

njunger@uwaterloo.ca

ABSTRACT
In the wake of recent revelations of mass government surveillance,
secure messaging protocols have come under renewed scrutiny. A
widespread weakness of existing solutions is the lack of strong
deniability properties that allow users to plausibly deny sending
messages or participating in conversations if the security of their
communications is later compromised. Deniable authenticated key
exchanges (DAKEs), the cryptographic protocols responsible for
providing deniability in secure messaging applications, cannot cur-
rently provide all desirable properties simultaneously.

We introduce two new DAKEs with provable security and denia-
bility properties in the Generalized Universal Composability frame-
work. Our primary contribution is the introduction of Spawn, the
ﬁrst non-interactive DAKE that offers forward secrecy and achieves
deniability against both ofﬂine and online judges; Spawn can be
used to improve the deniability properties of the popular TextSe-
cure secure messaging application. We also introduce an interactive
dual-receiver cryptosystem that can improve the performance of the
only existing interactive DAKE with competitive security proper-
ties. To encourage adoption, we implement and evaluate the per-
formance of our schemes while relying solely on standard-model
assumptions.

Categories and Subject Descriptors
K.4.1 [Computers and Society]: Public Policy Issues—Privacy;
C.2.0 [Computer-Communication Networks]: General—Secu-
rity and protection

Keywords
Deniability, authenticated key exchanges, secure messaging, uni-
versal composability, online repudiation

1.

INTRODUCTION

Our society today makes use of large-scale communications plat-
forms such as the Internet, mobile networks, and leased lines to re-
liably deliver our most critical discourse. However, recent revela-
tions of mass surveillance by intelligence services have highlighted
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS’15, October 12–16, 2015, Denver, Colorado, USA.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-3832-5/15/10 ...$15.00.
DOI: http://dx.doi.org/10.1145/2810103.2813616 .

the lack of security and privacy in our messaging tools and spurred
demand for better solutions [20]. A widespread weakness in cur-
rent secure messaging tools is the lack of strong deniability proper-
ties [28]. Deniable secure messaging schemes allow conversation
participants to later plausibly deny sending messages, or even par-
ticipating in a conversation, while still providing authentication to
the participants at the time of the conversation. This notion was
popularized in the secure messaging context with the release of
Off-the-Record Messaging (OTR) a decade ago [3]. Unfortunately,
the OTR protocol is not well suited to modern settings such as mo-
bile device communication due to its requirement for synchronous
connections. Protocol designers seeking to achieve OTR-like de-
niability properties in these environments have been forced to turn
to the cryptographic literature, and have found that existing primi-
tives are not well suited to the task. Different schemes deﬁne deni-
ability in slightly different ways, and no existing secure messaging
schemes can be said to be deniable under all deﬁnitions [28]. Some
practitioners have also prematurely dismissed deniability as an im-
practical property for modern secure messaging applications [15].
Most secure messaging solutions incorporate an authenticated
key exchange (AKE) protocol as part of their construction. The
goal of an AKE is to establish a fresh shared session key and to
authenticate the conversation participants to each other. If the ses-
sion key cannot be derived from a protocol transcript even when
any long-term secret keys are compromised in the future, then the
AKE is said to have forward secrecy. A deniable authenticated key
exchange (DAKE) is an AKE that additionally allows participants
to plausibly deny some aspect of their participation in the protocol.
to improve the practicality of
strong deniability for secure messaging over synchronous connec-
tions, and to introduce strong deniability to asynchronous messag-
ing applications such as text messaging. To achieve these goals,
we present two new DAKEs that allow deniable message trans-
mission and participation in conversations, even when malicious
insiders secretly communicate with judges during protocol execu-
tion. Among them, we introduce the ﬁrst non-interactive DAKE
achieving both message and participation deniability against these
powerful judges while also offering forward secrecy. This DAKE
is the ﬁrst of its kind that can be used in secure messaging ap-
plications such as TextSecure [19]. Our DAKEs permit sessions
between any parties to be simulated ofﬂine with nothing more than
the public keys of the alleged participants. We also present a tech-
nique that improves the performance of the only existing (3-ﬂow)
scheme achieving these levels of deniability. We provide open im-
plementations of our schemes to encourage adoption.

This work has two main goals:

The remainder of this paper is structured as follows: Section 2
discusses the meaning of deniability for secure messaging applica-
tions; Section 3 describes the cryptographic primitives that we em-

1211ploy; Section 4 describes an existing scheme with comparable deni-
ability properties, as well as our performance enhancements; Sec-
tion 5 presents our new DAKE based on ring signatures; Section 6
introduces our one-round DAKE and discusses non-interactive use;
Section 7 outlines our implementations, which are evaluated in Sec-
tion 8; and Section 9 provides our concluding thoughts.

2. DENIABILITY

When we discuss deniability, we must do so with respect to an
action and a type of judge. We say that an action is deniable with
respect to a given judge if the judge cannot be convinced that an
individual performed the action. To make such a statement, we
need to deﬁne the environment in which the judge resides, and the
type of evidence that is required to convince the judge that the ac-
tion was performed. If an action is deniable with respect to a judge,
we say that individuals can “plausibly deny” performing the action.
Note that this deniability does not constitute a proof that the parties
did not perform the action; plausible deniability simply denotes a
lack of convincing proof.

There are two primary aspects of conversations that can be called
deniable. We can say that messages transmitted during a conversa-
tion are deniable (message repudiation), but we can also say that
participation in the conversation itself is deniable (participation re-
pudiation). These properties are orthogonal; a protocol may offer
one or the other, both, or neither. For example, messages sent us-
ing the well-known OpenPGP protocol are signed with the sender’s
long-term key, but the signed message does not include the recipi-
ent’s identity. An OpenPGP-signed email can be used as proof that
the message was signed, and presumably authored, by the sender,
but not that the sender was in a conversation with the ostensible
recipient. Consequently, OpenPGP offers participation repudiation
but not message repudiation.
2.1 Judges

When deﬁning a judge, we must deﬁne the conditions under
which the judge will believe that a user performed a given action,
such as sending a message or participating in a conversation. Un-
fortunately, we must make some assumptions about the behavior
of judges if we wish to make meaningful statements about the de-
niability of secure messaging protocols. If we allow judges to use
arbitrary criteria to deliver judgments, then we can never conclude
that an action is deniable.
In the secure messaging literature, it
is common to consider only judges that are completely rational,
and decide on the plausibility of an event based solely on the ev-
idence presented to them. The only acceptable evidence for these
judges is a valid cryptographic proof, veriﬁable by the judge, show-
ing that the event must have occurred. In reality, of course, judges
are more lenient, and routinely accept plaintext transcripts as evi-
dence. The goal of deniable protocols is to not supply additional
evidence against a participant, in the form of a hard-to-deny cryp-
tographic proof. Concretely, a messaging protocol that digitally
signs every message with the sender’s long-term key would not
satisfy our notion of deniability, while an unencrypted and unau-
thenticated protocol would.

Our model of the judge should accurately reﬂect the quantity
and type of evidence required to accept a claim. For example, a
digital signature demonstrating that a message was sent either by
an accused party or by a speciﬁc third party under the condition that
this third party had access to unrealistically powerful computational
resources may not convincingly provide plausible deniability. If the
model of the judge is inaccurate, then we may inadvertently reject
deniable schemes or admit non-deniable schemes.

In this paper, we consider only protocols that offer strong deni-
ability. These protocols allow conversation transcripts to be forged
by any user with the ability to perform basic computations, while
still providing authentication to conversation participants. Conse-
quently, no unforgeable cryptographic proofs can be produced to
convince a judge that sessions of these protocols took place.

In addition to the requirements for evidence, we must also deﬁne
the judge’s relationship to the protocol participants and the judge’s
capabilities. Two primary types of judges have been discussed in
the secure messaging literature: ofﬂine judges, and online judges.
An ofﬂine judge examines the transcript of a protocol execution
that occurred in the past, and decides whether or not the event in
question occurred. A judge of this type is given a protocol tran-
script, showing all of the (usually encrypted) transmitted data, and
a chat transcript, showing the high-level chat messages that were
exchanged. The judge must then decide whether the protocol and
chat transcript constitute proof that the action in question occurred.
When proving the deniability of protocols, it is also normally as-
sumed that an ofﬂine judge is given access to the long-term secrets
of all parties named in the transcript. Our goal is to prevent judges
from distinguishing between real and fake transcripts.

An online judge interacts with a protocol participant, referred
to as the informant, while the secure messaging protocol is being
executed. The judge has a secure and private connection to the in-
formant, and may instruct the informant to perform actions in the
protocol. The goal of the judge is to evaluate whether the actions
of other participants in the protocol are actually occurring, or if
the informant is fabricating the conversation (i.e., they are a mis-
informant). The judge does not have any direct visibility into the
network, but it may instruct the informant to corrupt participants,
compromising their secret keys. The judge is notiﬁed when a par-
ticipant is corrupted.
2.2 Practicality of Deniability

The secure messaging community has previously debated wheth-
er or not deniability should be implemented in end-user tools [15].
There are two main arguments against designing deniable messag-
ing protocols: deniability properties are too expensive to imple-
ment, and these properties are not useful in practice. However, the
relevant deniability properties for secure messaging protocols can
now be implemented relatively inexpensively and without any us-
ability consequences [28].

While the secure messaging literature mostly focuses on judges
that understand cryptography and rely on cryptographic proofs to
make decisions, real-world judges often do not behave in this man-
ner, and routinely accept plaintext transcripts. We cannot design
protocols that provide more deniability than plaintext; however, we
can easily design protocols that provide less deniability—while a
real-world judge of this type may not accept arguments that a plain-
text transcript could theoretically be forged, they may be likely to
accept testimony from experts that a protocol containing a digital
signature could not be forged. For these reasons, we should strive
to design deniable protocols to avoid unintentionally incriminating
users.

3. CRYPTOGRAPHIC PRIMITIVES

We make use of several specialized cryptosystems when con-
structing our schemes. This section provides high-level deﬁnitions
of these underlying cryptosystems and outlines our notation.
We write r $←− S to denote that r is assigned an element from
set S selected uniformly at random. For all schemes, we implic-
itly assume that a security parameter λ is provided to control the
security level of the system. We abuse notation by assuming that

1212r $←− {0, 1}λ produces a random binary value with an appropriate
length for the task at hand, with a security level controlled by λ.
Several functions we deﬁne accept a parameter r that denotes the
randomness associated with operations; if omitted, r $←− {0, 1}λ is
used. We denote concatenation of values with the (cid:107) operator. We
implicitly assume that all concatenated values are of a ﬁxed width.
We denote a traditional digital signature scheme as three func-
tions: SigGen(r), a key generation function producing key pair
(pk, sk); Sig(pk, sk, m, r), a signing function producing a signa-
ture σ of message m; and Vrf(pk, σ, m), a veriﬁcation function.
Our only security requirements for digital signature schemes are
correctness, soundness, and consistency [5]. Similarly, we denote
a public-key cryptosystem as: PKGen(r), PKEnc(pk, m, r), and
PKDec(pk, sk, γ), where γ is the ciphertext. Our constructions
that make use of public-key cryptosystems require that they are
IND-CCA2 secure [22].

Dual-Receiver Encryption (DRE). It is sometimes desir-
able to encrypt a message such that it can only be read by either of
two named recipients, and that anyone can verify this fact. Dual-
receiver encryption (DRE) is a type of specialized cryptosystem
that enables publicly veriﬁable encryptions of messages for two re-
ceivers. A DRE scheme consists of three functions: DRGen(r),
a key generation function; DREnc(pk1, pk2, m, r), an encryption
function; and DRDec(pk1, pk2, ski, γ), a decryption function for
i ∈ {1, 2}. DREnc encrypts a message m under two public keys:
pk1 and pk2. To achieve correctness, DRE schemes must sat-
isfy DRDec(pk1, pk2, ski, DREnc(pk1, pk2, m, r)) = m for any
(pk1, sk1) and (pk2, sk2) produced by DRGen, i ∈ {1, 2}, and
any m and r. We require DRE schemes to exhibit symmetry, pub-
lic veriﬁability, completeness, soundness, and dual-receiver IND-
CCA1 security, as deﬁned by Chow et al. [9].

Non-Committing Encryption (NCE). A public-key cryp-
tosystem is called non-committing if, in addition to offering the
standard functions of a PKE scheme, it can also produce “rigged”
ciphertexts [6]. A non-committing cryptosystem consists of ﬁve
functions: NCGen, NCEnc, and NCDec, which behave identi-
cally to the corresponding functions of a PKE scheme; NCSim(r),
a rigged ciphertext generation function; and NCEqv(pk, γ, α, m),
an equivocation function. NCSim produces: pk, a public key; γ, a
ciphertext; and α, some auxiliary information. Public keys and ci-
phertexts produced by NCSim are identically distributed to public
keys and ciphertexts produced by NCGen and NCEnc, respectively.
If NCEqv is called with (pk, γ, α) produced by NCSim, it gener-
ates values sk, r∗, and rN CE such that NCGen(r∗) = (pk, sk)
and NCEnc(pk, m, rN CE) = γ.
In other words, it uses α to
generate a secret key sk corresponding to pk such that the pre-
viously generated γ decrypts to m using sk. All of this is accom-
plished while making key pair (pk, sk) appear as though it were
honestly generated using NCGen, and γ as though it was honestly
generated using NCEnc. There are several existing NCE construc-
tions [6,8,11,31], but they are all considerably more expensive than
the other primitives used in our protocols.

Ring Signatures. Ring signature schemes, originally proposed
by Rivest et al. [24], are a specialized type of digital signature
scheme. A ring signature is veriﬁably produced by a member of a
given set, but the exact identity of the signer cannot be determined.
A ring signature scheme consists of three functions: RSGen(r),
a key generation function; RSig(pk, sk, R, m, r), a signing func-
tion; and RVrf(R, σ, m), a veriﬁcation function. The ring R is a
set of n public keys {pk1, pk2, . . . , pkn} that could possibly have

produced the signature. It is required that n > 1, (pk, sk) was gen-
erated with RSGen, and pk ∈ R. r controls the randomization of
the output. We require the use of ring signature schemes exhibiting
correctness, anonymity against full key exposure, and unforgeabil-
ity with respect to insider corruption [2].

4. THE WALFISH PROTOCOL

In his thesis, Walﬁsh [29] introduced Φdre.1 Φdre is the only
previously deﬁned DAKE of which we are aware that provides de-
niability against both online and ofﬂine judges while simultane-
ously providing forward secrecy.

To prove the security of Φdre, Walﬁsh extended Canetti’s Uni-
versal Composability (UC) framework [4] to produce the General-
ized UC (GUC) framework [29]. Security proofs in the UC frame-
work demonstrate that real protocols operating in the presence of
an adversary A behave identically to idealized protocols, wherein
a trusted central server with secure connections to the protocol par-
ticipants executes an “ideal functionality” program, in the presence
of an adversary S; in other words, these settings are indistinguish-
able from the perspective of a “distinguishing environment” Z. A
common operation for ideal functionalities is to send a “delayed
message” to a party, where the adversary S is allowed to withhold
or delay the message arbitrarily (even if the message contents are
hidden from S). Unfortunately, the UC framework does not pro-
vide security guarantees when information is shared between pro-
tocol sessions (e.g., as in a PKI). GUC differs from UC in that it al-
lows multiple concurrent protocol sessions with shared information
that is accessible by both the adversary and Z. Additionally, Z is
permitted to execute arbitrary other protocols. Shared information
is represented by persistent machines running “shared functionali-
ties”. A GUC-based security model in which a shared functionality
G is accessible is called a G-hybrid model. Despite this additional
distinguishing power, GUC can still provide the usual UC security
guarantees. A simpliﬁed but equivalent framework, the External-
subroutine UC (EUC) framework, can be used to prove security in
the GUC framework more easily [29]. Throughout the remainder
of this work, we assume some familiarity with the UC framework.
4.1 Protocol Φdre

Φdre, depicted in Figure 1, is a two-round interactive DAKE.2
Each message sent between I and R (other than the introductory
message asserting identities) is encrypted using DRE under the
public keys of I and R. This guarantees that all three messages
can be read by both I and R, but nobody else (unless either I or
R has been corrupted). To provide authentication, the core of the
protocol involves each party echoing a nonce generated by their
partner, thereby proving that they can decrypt the communications.
Since only I and R can decrypt the DRE, and each party knows that
they did not produce the response to their nonce themselves, this
provides non-transferable authentication.
In addition, I includes
in its encrypted message an ephemeral public key pk for an NCE
scheme. R generates the shared secret for the session, and encrypts
it using pk as part of its last message to I.

It is trivial for anyone with access to the long-term public keys
to forge protocol transcripts between any two parties, even with-
out access to any long-term secret keys. An ofﬂine forger of this
type merely needs to simulate both participants; although it cannot
decrypt the DRE layer itself, it already knows the contents of all

1Φdre was later restated in a publication by Dodis et al. [12].
2In practice, the protocol can be collapsed into three ﬂows by hav-
ing the party denoted as R in Figure 1 send the session identiﬁer
and party names.

1213I

R

sid, “I”, “R”

DREnc(P KI , P KR, sid(cid:107)η1)

$←− {0, 1}λ
(pk, sk) ← NCGen()

η2

DREnc(P KI , P KR, sid(cid:107)η1(cid:107)η2(cid:107)pk))

DREnc(P KI , P KR, sid(cid:107)η2(cid:107)NCEnc(pk, k))

$←− {0, 1}λ

η1

k $←− {0, 1}λ

Figure 1: Φdre [29]. The shared secret is k.

messages. Deniability against online judges is provided because
each party can simulate the behavior of the other; the DRE allows
misinformants to read the contents of any messages that the judge
produces on their behalf. The use of NCE is only needed in the non-
erasure model (where we assume that memory cannot be erased)
with semi-adaptive corruptions (i.e., the adversary may not corrupt
participants while the protocol is executing); if erasures are allowed
or corruptions are only static, then a standard PKE scheme sufﬁces.
Walﬁsh used the GUC framework to prove that Φdre provides
its claimed security and deniability properties with semi-adaptive
corruptions in the ¯Gkrk-hybrid model [29]. ¯Gkrk (key registration
with knowledge) is a shared functionality that models a PKI. Any
party P can register for a key pair with ¯Gkrk. ¯Gkrk generates the
requested key pair directly, thereby modeling a PKI that requires
proof of knowledge of secret keys. A corrupted party can override
this by providing its own key pair for storage. P KP , the public key
for a party P , can be retrieved from ¯Gkrk by any machine. ¯GF
krk
also allows SKP , the secret key for party P , to be retrieved by an
honest machine executing F or by P if it has been corrupted.

The deniability of Φdre is necessarily imperfect: if an adversary
is willing to disrupt the protocol in such a way that it is guaranteed
to abort before completion, then incriminating information demon-
strating that I was attempting to communicate with R can be re-
leased. If Justin, an online judge, instructs Mallory, the adversary,
to modify the ﬁrst ﬂow from R to I to an encryption of nonce η(cid:48)
1
known only to Justin (and thereby inevitably cause R to abort), then
Mallory will need to provide I’s response to R. This requires Mal-
lory to actually interact with the real I (i.e., Mallory is a legitimate
informant), or to compromise SKI or SKR without the knowl-
edge of Justin (something disallowed by the GUC framework). If
Mallory attempts to simulate a response, then Justin can later in-
struct Mallory to corrupt a party to recover their secret key. Justin
can then use this secret key to decrypt the simulated response, and
determine that it did not include η(cid:48)
1. Walﬁsh accounts for this weak-
ness of Φdre in the security proof by deﬁning an incrimination pro-
cedure called IncProc. If the adversary causes the protocol to abort,
it gains access to IncProc, which releases incriminating information
that precisely models the real-world leakage.

4.2 Efﬁcient Standard-Model Instantiation

In order to implement Φdre, we must select a DRE scheme to
use. Unfortunately, nearly all existing DRE schemes require use of
the random oracle model. The DRE construction of Chow et al. [9]
is relatively efﬁcient and is secure in the standard model, but it is
still expensive compared to simple encryption schemes. Alongside
the original deﬁnition of Φdre, Walﬁsh describes a construction
of a generic DRE scheme [29]. This scheme involves encrypting
the plaintext twice using a PKE scheme with IND-CCA2 security,

and then providing two non-interactive zero-knowledge proofs of
knowledge (NIZKPK) demonstrating that the encrypted plaintexts
are equal. Unfortunately, NIZKPK schemes are either highly inefﬁ-
cient or require random oracles. In this section, we describe a new
DRE construction that improves the performance of Φdre while
still maintaining its security properties in the standard model.

We begin by making an important observation about Φdre: it is
an interactive protocol that takes place between two known parties.
While DRE in general is a non-interactive protocol, allowing the
DRE scheme to require interactivity does not negatively impact the
usability of the overall scheme. We are able to do this because
for each encryption of a message, the only party that will need to
decrypt the message is available for interactive communications.

Our basic approach to the construction is similar to Walﬁsh’s
general DRE scheme, but we use an interactive zero-knowledge
proof of knowledge (ZKPK) scheme instead. While we will only
describe one possible instantiation, any PKE scheme with IND-
CCA2 security can be combined with any interactive ZKPK of
plaintext equality. This DRE remains “publicly veriﬁable” in the
sense that the ZKPK veriﬁer can verify the correctness of the ci-
phertexts even if they do not know any secret keys; this is sufﬁ-
cient for use in Φdre. As a PKE scheme, we make use of the cryp-
tosystem published by Cramer and Shoup [10]. The Cramer-Shoup
scheme provides IND-CCA2 security in the standard model with
only the DDH assumption. To prove that the two ciphertexts con-
tain identical messages and are of a valid format, we use a Σ ZKPK
of the kind described by Schnorr [25]. The resulting scheme is
secure with only the DDH assumption for the underlying Cramer-
Shoup group, and consists of the following functions:
DRGen(r): key generation is the same as in the Cramer-Shoup
scheme [10]. The resulting public key for a user consists of a group
description (G, q, g1, g2) and values c = gx1
1 , and
h = gz
DREnc(pk1, pk2, m, r): m is encrypted twice using the Cramer-
Shoup scheme (once for each public key), and a ZKPK of plain-
text equality is produced. r is interpreted as r = k1(cid:107)k2 and is
used to randomize the encryptions of m. Given public key pki =
(Gi, qi, g1i, g2i, ci, di, hi), the ciphertexts consist of u1i = gki
1i ,
for i ∈ {1, 2} and
u2i = gki
αi = H(u1i(cid:107)u2i(cid:107)ei) using a collision-resistant hash function H.
The result also includes an interactive ZKPK that proceeds be-
tween the prover P (the party calling DREnc) and the veriﬁer V
(the party that will call DRDec) as follows:
1. P generates random values mi ∈ [0, qi) for i ∈ 1, 2. P then
i )mi, and T4 =

2 , d = gy1
1. The corresponding secret key is (x1, x2, y1, y2, z).

i m, and vi = cki

2i , T3i = (cidαi

2i , ei = hki

1 gx2

i dkiαi

i

computes T1i = gmi
m1
h
1
m2
2

1i , T2i = gmi
, and sends these values to V.

h

12142. V generates random value L and sends it to P.
3. P computes ni = mi − Lki (mod qi) for i ∈ {1, 2} and sends

these values to V.

4. V accepts the encryption as valid if the following equalities
?=

?= gni

1i, T2i

2i uL

2i, T3i

hold for i ∈ {1, 2}: T1i
?= h
(cidαi
h

i , and T4

i )ni vL

?= gni
1i uL
)L.
( e1
e2

n1
1
n2
2

1i uy2i

DRDec(pk1, pk2, ski, γ): γ is parsed to locate the encryption for
pki, and decryption proceeds as in the Cramer-Shoup scheme. Let
ski = (x1i, x2i, y1i, y2i, zi). At this point, the recipient of γ has
already veriﬁed that the ciphertexts are of the correct form and
that they contain encryptions of the same message as a result of
the interactive ZKPK. In addition, the recipient computes αi =
H(u1i(cid:107)u2i(cid:107)ei) and then veriﬁes that ux1i
2i )αi ?= vi.
1i ux2i
2i (uy1i
The message m is recovered using m = ei
.
zi
u
1i

The resulting protocol consists of 9 messages (plus an additional
message for the introductory identity assertions). This instantia-
tion of Φdre is very efﬁcient compared to implementations using
non-interactive DRE in the standard model, which typically require
hundreds of group elements to be transmitted [9]. While we do not
prove the security of this variant here, the original proof by Wal-
ﬁsh [29] can be extended without issue, as this interactive DRE
construction satisﬁes all of the required properties of the original
protocol deﬁnition. We caution that the interactive ZKPK sessions
must not be interleaved in order to preserve online repudiation (i.e.,
the veriﬁer must wait for all ZKPK message ﬂows to complete be-
fore decrypting the message). We also note that, if an implementer
is willing to accept the use of the random oracle model, then this
instantiation of DRE can be made non-interactive through the use
of the Fiat-Shamir heuristic [13].

5. AN EFFICIENT DAKE SCHEME FROM

RING SIGNATURES

While Φdre can be made efﬁcient through the use of interactive
DRE, the resulting protocol requires 9 ﬂows to complete the key
exchange.
In environments with high latency, such an approach
may be undesirable. Additionally, Φdre is a non-contributory key
exchange; the resulting shared secret is chosen entirely by a sin-
gle party (the responder R). Consequently, an adversary that has
corrupted R can cause the initiator I to use an adversarially cho-
sen key. Moreover, while Φdre allows parties to transmit identities
within the protocol, the ideal functionality used by Walﬁsh to prove
the scheme’s security represents a pre-speciﬁed peer key exchange
(i.e., both parties must know the identity of the other participant
before the protocol begins), which fails to capture this feature.

All of these limitations can be overcome by a family of key ex-
changes known as SIGMA (“SIGn-and-MAc”) protocols. First
proposed by Krawczyk [16], SIGMA protocols are contributory
(both parties ensure the randomness and freshness of the resulting
key), consist of only 3 message ﬂows, and permit post-speciﬁed
peers (i.e., the identity of the other party is an output of the pro-
tocol). Canetti and Krawczyk have previously shown that a ba-
sic SIGMA protocol is UC-secure in the FSIG-hybrid model with
adaptive corruptions [7]. Unfortunately, this proof shares the limi-
tations of all proofs in plain UC-based models, including a failure
to model public key directories that are available to the distinguish-
ing environment. Additionally, no SIGMA protocols can match the
strong deniability properties offered by Φdre.

In this section, we make use of ring signatures to construct a new
deniable key exchange protocol, inspired by SIGMA designs, that

Algorithm 1 Ideal functionality F IncProc

post-keia

on receipt of (initiate, sid, I, SKI ) from I:

if (I is “active”) return
Mark I as “active”
Send (initiate, sid, I) to S

on receipt of (establish, sid, R, SKR) from R:

if (I is not “active”) return
if ((R is “active”) || (R is “aborted”)) return
Mark R as “active”
Send (establish, sid, R) to S
k $←− {0, 1}λ

on receipt of (set-key, sid, T, P (cid:48), k(cid:48)) from S:
if (a set-key message was already sent to T ) return
if ((T /∈ {I, R}) || (T is not “active”)) return
Let P ∈ {I, R} such that P (cid:54)= T
if ((P (cid:48) (cid:54)= P ) && (P (cid:48) is uncorrupted)) return
if ((I is corrupt) || (R is corrupt)) {

Send (set-key, sid, P (cid:48), k(cid:48)) to T

} else {

Send (set-key, sid, P, k) to T

}
if (two set-key messages have been sent) Halt

on receipt of (abort, sid, I, R) from S:

if (I is “active”) Send delayed (abort, sid, I) to I
if (R is “active”) {

Mark R as “aborted”
Send delayed (abort, sid, R) to R

on receipt of (incriminate, sid, I, R) from S:

if (already received incriminate message) return
if ((R is “aborted” and honest) && (I is “active”)) {
Execute IncProc(sid, I, R, P KI , P KR, SKR, k)

}

}

offers provably strong security and deniability in the GUC frame-
work. The resulting protocol, RSDAKE, is not a true SIGMA pro-
tocol (since it does not need to use a MAC), but it addresses all of
the aforementioned problems with Φdre.
5.1 Functionality F IncProc

post-keia

keia

post-keia and the design decisions behind it.

Before deﬁning RSDAKE, we begin by formulating an ideal
functionality in the GUC framework that captures the desired prop-
erties. The new functionality, F IncProc
post-keia (post-speciﬁed peer key
exchange with incriminating abort), is given in Algorithm 1. The
name and operation of F IncProc
post-keia is partially based on the F IncProc
functionality deﬁned by Walﬁsh, which was used to prove the se-
curity of Φdre [29]. In the remainder of this section, we discuss the
behavior of F IncProc
To prove the security of SIGMA protocols using the UC frame-
work, Canetti and Krawczyk deﬁned Fpost-ke, an ideal functional-
ity that models a key exchange with post-speciﬁed peers [7]. Like
Fpost-ke, F IncProc
post-keia takes place between an unbounded number of
parties, but each session captures the interaction between only two
of these parties. The ﬁrst party to request a key exchange is sub-
sequently known as I, the initiator. The second party to request
a key exchange is subsequently known as R, the responder. After
both I and R are known, F IncProc
post-keia selects a random shared key
k for the session. The adversary is then given a chance to attempt
to set the output (the shared key and the identity of the other party)
of both I and R. If the adversary has corrupted either party, then

1215I

R

i $←− {0, 1}λ
(pkI , skI ) ← SigGen()
(rpkI , rskI ) ← RSGen()

Compute gir and erase i

“I” (cid:107) pkI (cid:107) gi (cid:107) rpkI (cid:107) Sig(pkI , skI , gi(cid:107)rpkI )

“R” (cid:107) pkR (cid:107) gr (cid:107) rpkR (cid:107) Sig(pkR, skR, gr(cid:107)rpkR)

(cid:107) RSig(P KR, SKR,{P KI , P KR, rpkI}, “0”(cid:107)“I”(cid:107)pkI(cid:107)pkR)

RSig(P KI , SKI ,{P KI , P KR, rpkR}, “1”(cid:107)“R”(cid:107)pkR(cid:107)pkI )

Figure 2: RSDAKE. The shared secret is gir.

r $←− {0, 1}λ
(pkR, skR) ← SigGen()
(rpkR, rskR) ← RSGen()
Compute gir and erase r

keia , F IncProc

it is given the ability to send an adversarially chosen secret k(cid:48) and
partner identity P to I and R.3 Otherwise, each party is given k
and the true identity of their conversation partner.
Unfortunately, Fpost-ke cannot be realized in the GUC frame-
work in the ¯Gkrk-hybrid model. Similarly to F IncProc
post-keia
must explicitly weaken the deniability of the protocol by allow-
ing for incriminating aborts. Concretely, we allow the adversary to
abort the protocol in order to cause R to output incriminating infor-
mation. The nature of this incriminating information is a parameter
to F IncProc
post-keia in the form of a procedure IncProc, allowing it to be
tailored to the real protocol under consideration. When the adver-
sary S asks F IncProc
post-keia to abort, an instance of IncProc is started.
S cannot cause an uncorrupted R to output a key after the protocol
has aborted, but it may still cause I to output a key by withholding
the abort message sent to I.
post-keia and
F IncProc
keia , it is the initiator I that releases
incriminating information when the protocol aborts.
In contrast,
if the RSDAKE exchange aborts, incriminating information will
be released by the responder R. Additionally, since incriminating
aborts in F IncProc
post-keia occur after R has generated k, IncProc must
also accept k as input.
5.2 RSDAKE

There are several subtle differences between the F IncProc

functionalities. In F IncProc

keia

Our new protocol, RSDAKE, is presented in Figure 2. Each pro-
tocol participant P has a long-term key pair (P KP , SKP ) for a
ring signature scheme, where P KP is publicly known. To begin
a session, the initiator I generates an ephemeral signing key pair
(pkI , skI ), an ephemeral Difﬁe-Hellman public key gi, and a ring
signature key pair (rpkI , rskI ). It sends its identity, its ephemeral
public keys, and a signature of gi(cid:107)rpkI using pkI to R. This signa-
ture binds the ephemeral keys for the different schemes to the same
“master” key pkI. This ﬁrst message is referred to as ψ1.

Responder R performs the same procedure and responds with
pkR, gr, and rpkR. It also performs a ring signature of the two
ephemeral master keys pkI and pkR as well as the identity of I.
The response message is referred to as ψ2. The ring used for this
signature is {P KI , P KR, rpkI}. This ring signature serves the
same purpose as the (traditional) signature and MAC in the ba-
sic SIGMA protocol. An honest I is convinced that R produced
3F IncProc
post-keia models a scenario in which the adversary S can com-
pletely control the value of the shared secret key after corrupting
only one party. In a contributory key exchange, S may not have
full control over this value, but it can still inﬂuence the result.

the signature because it knows that no other parties have access to
SKI or rskI. It also knows that this signature has not been reused
from another session (because it contains pkI and pkR), and that
R believes that it is communicating with the correct partner (be-
cause the signature contains the identity of I). However, this proof
is not transferable to any other party because the signature could
have also been forged by I using SKI.

In the third and ﬁnal step of the protocol, I responds with its own
ring signature of the master ephemeral keys and the identity of R,
computed over the ring {P KI , P KR, rpkR}. This ﬁnal message is
referred to as ψ3. R is convinced of I’s identity, but cannot transfer
this conviction, for the same reasons as before. The resulting shared
secret is gir, as in a standard Difﬁe-Hellman exchange.

Unlike SIGMA protocols, RSDAKE offers ofﬂine repudiation
equal to that of Φdre. Speciﬁcally, anyone can forge a key exchange
(and subsequent conversation) between any two parties I and R us-
ing nothing other than P KI and P KR. An ofﬂine forger is in the
unique position of generating ephemeral keys for both simulated
parties, and so it can compute both ring signatures using rskI and
rskR. Transcripts generated by such a forger are indistinguish-
able from real transcripts due to the security of the ring signature
scheme. If the ring signature scheme provides security under full-
key exposure, this indistinguishability holds even if the long-term
secret keys of both I and R are subsequently compromised.

Assuming the existence of a signature scheme and a ring sig-
nature scheme that is secure under full-key exposure, RSDAKE
GUC-realizes F IncProc
-hybrid model
with fully adaptive corruptions. For brevity, we omit proof of this
claim here; a formal proof can be found in the ﬁrst author’s Mas-
ter’s thesis [27, §3.7.3].

post-keia within the erasure ¯GRSDAKE

krk

6. A NON-INTERACTIVE DAKE

Both Φdre and RSDAKE have a usability limitation: they are
interactive protocols (i.e., they require both parties to be online).
In applications such as secure messaging, the key exchange must
be completed before messages can be transmitted.
In some do-
mains, such as instant messaging, consistent peer availability may
be a valid assumption. However, email and text messaging are two
extremely popular systems in which interactive key exchanges can-
not be used in general. These environments beneﬁt from the use of
non-interactive key exchanges; secure messages can be sent imme-
diately to any peer in the network, irrespective of their connectivity.
TextSecure [19] is a popular secure messaging application for
mobile phones that offers one of the most comprehensive sets of

1216Algorithm 2 Ideal functionality F IncProc

1psp-keia

on receipt of (establish, sid, I, R, SKR) from R:

on receipt of (solicit, sid, I, SKI ) from I:
if ((I is “active”) || (I is “aborted”)) return
Mark I as “active”; record (initiator, sid, I, SKI )
Send (solicit, sid, I) to S
if ((solicit not received) || (R is “active”)) return
Mark R as “active”; record (responder, sid, R, SKR)
Send (establish, sid, I, R) to S
k $←− {0, 1}λ
on receipt of (set-key, sid, P, k(cid:48)) from S:
if ((k is set) && (P = R || P is corrupt)) {
Send (set-key, sid, I, P, k(cid:48)) to R
if (I is “active”) {

if (R is corrupt) {

Send delayed (set-key, sid, I, P, k(cid:48)) to I

Send (set-key, sid, I, R, k) to R
if (I is “active”) {

Send delayed (set-key, sid, I, R, k) to I

} else {

}

}

}

}
Halt

}

}

on receipt of (abort, sid, I, R) from S:

if (I is “active”) {

Mark I as “aborted”
Send delayed (abort, sid, I, R) to I

on receipt of (incriminate, sid, R) from S:

if (already received incriminate message) return
if ((I is “aborted”) && (R is “active”) && (R is honest)) {

Execute IncProc(sid, I, R, P KI , P KR, SKR, k)

security features [28]. TextSecure currently uses the triple Difﬁe-
Hellman (3-DH) DAKE, but this protocol does not offer online re-
pudiation. In this section, we present a secure and deniable one-
round key exchange protocol that can be used in interactive or non-
interactive settings, with the ultimate goal of improving the denia-
bility of TextSecure.
6.1 Functionality F IncProc

1psp-keia

To prove that our key exchange is secure in the GUC framework,
we must deﬁne an ideal functionality that captures the behavior
of TextSecure. Unfortunately, neither F IncProc
post-keia fully
describe the desired properties.

keia nor F IncProc

In TextSecure, the initiator I begins by uploading “prekeys” to
a central server. A prekey is a set of ephemeral information that
can be used as the ﬁrst ﬂow of a one-round key exchange protocol.
Subsequently, the responder R requests the next available prekey
for I and uses it to complete the key exchange. In practice, the
ﬁrst message of the conversation is encrypted under this key and
attached to the same ﬂow. Even if I is ofﬂine when this message is
sent, and R then goes ofﬂine forever, I will still be able to decrypt
this message when it comes back online. It is important to note that
I does not know the identity of the party that will respond to the
prekeys it produces, but R knows the identity of the party to whom
it wishes to send a message. In this sense, the key exchange has a

Similarly to F IncProc

single post-speciﬁed peer. Concretely, the identity of R should be
part of the output for I, while the identity of I is an input for R.
Neither F IncProc

post-keia captures this notion.

keia nor F IncProc

post-keia, information generated by IncProc in-
criminates the responder R, and IncProc is called after the shared
secret k is generated. We deﬁne ideal functionality F IncProc
1psp-keia (sin-
gle post-speciﬁed peer key exchange with incriminating abort) to
capture the desired properties. F IncProc
1psp-keia takes place between two
or more parties. The functionality is given in Algorithm 2.

In the normal case, a party informs F IncProc

1psp-keia that it would like
to solicit a connection. Without loss of generality, we call this party
I. Only one party solicits a connection per session. Later, another
party asks the functionality to complete an exchange with I. With-
out loss of generality, we call this party R. F IncProc
1psp-keia generates
a shared secret k, and then waits for the adversary S to issue a
set-key request. If S has not corrupted R, then F IncProc
1psp-keia in-
stantly sends k to R and then sends k and the identity of R as a
delayed message to I.
S can choose to withhold the ﬁnal message sent to I, causing
R to complete and I to stall. If S corrupts R before the protocol
halts, then it can cause I to receive an adversarially chosen secret
k(cid:48) and the identity of any corrupted party P . Finally, S is also al-
lowed to abort the protocol after I has solicited a connection, and
it can choose whether or not I should be informed of this abort.
In any case, if the protocol is aborted, S can cause R to generate
incriminating information that proves R was attempting to commu-
nicate with I. S cannot cause I to output a key if the protocol was
aborted, but it can still cause R to output a key.

F IncProc
1psp-keia is parameterized with an incriminating abort proce-
dure IncProc that accepts the as parameters the session identiﬁer,
the identities of I and R, the long-term public keys of I and R, the
secret key of R, and the shared secret k.

In practice, at most one honest respondent replies to each ini-
tial message from I. If dishonest parties send multiple responses
to I, then I processes only the ﬁrst response received. F IncProc
1psp-keia
captures this situation by binding each instance of the functional-
ity (i.e., each protocol “session”) to a distinct solicit message
sent by I. Therefore, at most one party is labeled as “R” for each
session; subsequent establish messages to F IncProc
1psp-keia are ig-
nored. The GUC framework spawns a new instance of F IncProc
1psp-keia
for each session within the network, while still supporting shared
state between them through the use of shared functionalities.
6.2 Spawn∗

We now deﬁne a one-round DAKE, Spawn∗, that can be used
in interactive or non-interactive settings. Spawn∗ provides both of-
ﬂine and online message and participation repudiation (with limited
exceptions that we discuss later) while also providing forward se-
crecy for completed sessions.4 Figure 3 depicts the protocol, which
takes place between an initiator I and a responder R.

P , SK Sig

) ← DRGen() as well as (P K RS

Before any sessions begin, all parties register long-term public
keys with a PKI. Each party P generates a master signing keypair
P ) ← SigGen(), and two scheme-speciﬁc keypairs:
(P K Sig
P ) ←
(P K DRE
, SK DRE
RSGen(). P binds the keys together by computing a signature
P ← Sig(P K Sig
P ) and uploading
σP KI
P KP = (P K Sig
) to the PKI along with
proofs of knowledge of the corresponding secret keys. When re-
trieving P KP from the PKI, parties verify the trustworthiness of

P , P K DRE
P
, P K RS

P , P K DRE

P , SK Sig

(cid:107)P K RS

P , SK RS

P , σP KI

P

P

P

P

4 In a well-known result, Bellare et al. have previously shown that
no one-round protocol can achieve the strongest notion of forward
secrecy [1]. Here, we discuss “weak forward secrecy”.

1217(pk, sk) ← SigGen()
(npk, nsk) ← NCGen()
(rpk, rsk) ← RSGen()

I

R

“I” (cid:107) pk (cid:107) npk (cid:107) rpk (cid:107) Sig(pk, sk, npk(cid:107)rpk)

“R” (cid:107) NCEnc(npk, DREnc(P K DRE
(cid:107) RSig(P K RS

R ,{P K RS

R , SK RS

I
, P K RS

, P K DRE
R , rpk}, γ)

R

I

, “I”(cid:107)pk(cid:107)k))

k $←− {0, 1}λ

Figure 3: Spawn∗. The shared secret is k. γ denotes “R” concatenated with the output of NCEnc. Spawn replaces NCGen with
PKGen and NCEnc with PKEnc. In all other ways, Spawn is identical to Spawn∗.

using a scheme-speciﬁed key veriﬁcation mechanism. This

and P K RS

P by verifying σP KI

P

.

P K Sig
trust is extended to P K DRE

P

P

When starting a session, I uses a standard signature scheme to
generate an ephemeral key pair (pk, sk). This key pair is then used
to sign ephemeral public keys for other schemes: one pair for non-
committing encryption, and one pair for ring signatures. This sig-
nature binds both ephemeral keys to pk. In an interactive setting,
I immediately sends its identity, the ephemeral public keys, and
the signature binding them to pk to R as message ψ1. In a non-
interactive setting, I instead uploads this information to a central
server as a prekey. Later, when R wishes to send a message to I,
the central server relays a prekey to R. I expects only one response
for each prekey. Thus, the role of the central server is merely to pre-
vent prekey collisions; the server is not trusted—while it can attack
the availability of the protocol by going ofﬂine or by distributing
non-genuine or repeated prekeys, it is not entrusted with any infor-
mation that could be used to attack the security of the protocol.

Irrespective of the interactivity mode, R subsequently veriﬁes
the consistency of ψ1 and then uses the ephemeral keys to formu-
late a response ψ2 to I. At a high level, this response consists
of R’s identity, a wrapped session key k, and a signature to au-
thenticate the ciphertext. The session key is ﬁrst encrypted us-
ing dual-receiver encryption for the long-term public keys of I
and R. The resulting ciphertext is then encrypted once more us-
ing non-committing encryption for npk. Consequently, the session
}
key can only be decrypted by a party knowing {nsk, SK DRE
}. In the normal case (when both I and R are
or {nsk, SK DRE
honest), the only party satisfying these requirements is I. In inter-
active settings, a misinformant in the presence of an online judge
will be able to learn k—misinformants simulating I have access
to {nsk, SK DRE
}, and misinformants simulating R generate k
themselves—and thus they can fully simulate conversations.

, P K RS

R also encrypts pk and the identiﬁer for I alongside k. This
binds both the non-committing encryption and the dual-receiver en-
cryption to the current session, preventing replay attacks.
As part of the response ψ2, R also includes a ring signature of
the ciphertext. The ring, {P K RS
R , rpk}, includes the long-
term public keys of both I and R, as well as the ephemeral key rpk
associated with pk. In the case where both I and R are honest, R
creates the signature using its long-term secret SK RS
R . An honest I
is assured that only R could have produced the signature, because I
knows that it has not revealed SK RS
or rsk to any other party. The
inclusion of both long-term keys in the ring allows misinformants
to simulate signatures for online judges. The inclusion of rpk in
the ring allows an ofﬂine forger to create transcripts for exchanges
between arbitrary parties.

R

R

I

I

I

krk

Assuming the existence of a signature scheme, a ring signature
scheme that is secure under full-key exposure, a dual-receiver en-
cryption scheme, and a non-committing public-key cryptosystem,
1psp-keia within the non-erasure ¯GSpawn∗
Spawn∗ GUC-realizes F IncProc
-
hybrid model with fully adaptive corruptions. For brevity, we omit
proof of this claim here; the complete formal proof can be found in
the thesis [27, §3.8.4].
6.3 Implications of Incriminating Abort

Like Φdre and RSDAKE, Spawn∗ can leak incriminating infor-
mation if an adversary causes the protocol to abort in a speciﬁc
manner. When Spawn∗ is aborted, the adversary can receive a valid
R . There
ψ2 message created and signed using R’s secret key SK RS
is a critical difference between Spawn∗, Φdre, and RSDAKE in
this respect: when incriminating information is released, one of the
honest parties (R) does not abort. This leads to a potential attack.
If Mallory, an active network adversary, is attempting to con-
vince Justin that Bob is communicating with Alice using Spawn∗,
she can cause the protocol to abort. Justin begins by generating
1 using (npk(cid:48), nsk(cid:48)) ← NCGen() and sending ψ(cid:48)
ψ(cid:48)
1 to Mallory,
while ensuring that nsk(cid:48) is kept private. When Alice sends ψ1 to
Bob, Mallory intercepts this message and replaces it with ψ(cid:48)
1. Bob
responds with ψ2 containing an encryption γ of session key k and
B , rpk}. Mallory
a ring signature σ signed by ring {P K RS
relays ψ2 to Justin, but either causes Alice to stall by withholding
ψ2, or causes Alice to abort by delivering ψ2. Justin now instructs
Mallory to corrupt Bob. When Mallory corrupts Bob, she recovers
k(cid:48). Mallory sends k(cid:48) and SKB to Justin. Justin uses his knowledge
to decrypt γ, ensuring that k = k(cid:48). In this
of nsk and SK DRE
case, Justin will be convinced that Bob attempted to communicate
with Alice as long as he believes that Mallory did not corrupt Alice
or Bob until after ψ2 was sent. This attack does not apply in settings
where it is unreasonable for Justin to make this assumption.
6.4 Weakness of Online Repudiation

A , P K RS

B

When choosing to implement a cryptographic scheme, it is ex-
tremely important to consider the security assumptions of the cor-
responding security proof; when the assumptions do not hold, at-
tacks may be possible. The security of Spawn∗ relies on the ac-
curacy of the GUC model, which makes an assumption that is not
necessarily true in all real-world scenarios. If the distinguishing
environment Z has previously corrupted some party P and gained
access to SK RS
P , it may instruct the adversary to cause a corrupted
party R (cid:54)= P to identify itself as P in response to I. In our secu-
rity model, we assume that since P is corrupted, S can also access
in order to decrypt the response sent by R. When this
SK DRE
assumption fails in practice, it yields a potential attack in which

P

1218Z can distinguish between simulated and real protocol executions.
We will now consider how such an attack might proceed in practice.
Alice is a whistleblower that has previously provided secret in-
formation to Bob, a journalist, using Spawn∗ over the Internet.
Justin is an agent for a group that has some leverage over Bob.
Justin wishes to prevent further whistleblowing by demanding that
Bob asks Alice to send him some new information that will incrim-
inate her. Bob agrees, but refuses to reveal his long-term secret key
B to Justin since it would allow Justin to impersonate Bob in
SK RS
all conversations. However, Bob does not actually want to incrimi-
nate Alice; instead, he would like to secretly simulate Alice.

Bob computes a message ψ1, and reports to Justin that he has re-
ceived ψ1 from Alice. However, Justin has covertly stolen the long-
term secrets SKC from Alice’s friend Charlie in the past. Justin
constructs a response ψ2 containing session key k that purportedly
comes from Charlie, and signs the ring signature using SK RS
C . He
then instructs Bob to send ψ2 to Alice, along with a message, en-
crypted under k, asking Alice to meet Charlie for coffee (or some
other innocuous message). Justin expects Alice to respond to Char-
lie’s message using a protocol that requires her to know k. If Bob
has access to SKC, as is assumed by the GUC framework, then he
can forge the expected response from Alice by recovering k from
ψ2. However, if Bob does not know SKC, then he cannot simulate
a response; Justin has caught Bob attempting to deceive him.

This attack weakens online repudiation in a nuanced manner. If
Justin receives a response purportedly from Alice, then he knows
that either Bob was communicating with the real Alice, or Charlie’s
secret key was compromised by Bob (and not only by Justin). If
Justin does not receive a response, then he knows that either the
real Alice did not respond to the (forged) message from Charlie, or
Bob has attempted to deceive Justin by simulating Alice. Note that
this situation only occurs when Justin “probes” the honesty of Bob
by sending a message from Charlie; Justin does not accomplish his
primary objective of incriminating Alice. If Bob predicts that Justin
is going to attempt such a probe, he can establish a connection to
Alice and relay ψ2 honestly—but if Bob’s prediction is incorrect,
then he will unintentionally incriminate Alice. In practice, Justin
will always have some uncertainty about the veracity of Alice’s
responses to Bob.

6.5 Non-interactive Spawn∗

1,1 , ψAlice

The main advantage of Spawn∗ is that, unlike Φdre and RS-
DAKE, it can be used in a non-interactive setting. Non-interactive
Spawn∗ is implemented with the assistance of an untrusted central
server tasked with the distribution of prekeys. It is natural to con-
sider this version of the protocol in the context of mobile text mes-
saging. Initially, Alice uses her phone’s data connection to connect
to a central server operated by the developer of a secure commu-
nication app using Spawn∗. Alice generates a set of n messages,
{ψAlice
1,n }, where each message is a valid message
ψ1 for a Spawn∗ session. Alice uploads all n message to the cen-
tral server.5 Later, Bob uses his phone’s data connection to request
one of Alice’s messages from the server. The server sends an avail-
1,i , 1 ≤ i ≤ n, to Bob and removes it from its list.
able message ψAlice
Bob now uses ψAlice
to complete the
1,i
key exchange. He sends ψAlice
2,i along with his message, encrypted
with k, to Alice over his text messaging service. Upon receiving
the message, Alice locates the corresponding secret keys for the
message to recover k.

to compute a response ψAlice
2,i

1,2 , ..., ψAlice

5The server can deniably authenticate uploaded keys by receiving
keys within an interactive Spawn∗ or RSDAKE session.

Unfortunately, this non-interactive capability comes at a cost:
the deniability of the protocol is not as strong as the interactive
version. Intuitively, the issue is that ψ1 is no longer part of a sin-
gle protocol session; it has been moved into a cross-session global
infrastructure. This allows an online judge to request a genuine
prekey from the server, overriding any simulated prekey produced
by a misinformant. In practice, this means that Spawn∗ does not
provide online repudiation when R attempts to simulate I in the
non-interactive setting. However, I still maintains online repudi-
ation in this setting—I can reliably simulate a response from any
party, even in the presence of online judges—and all other security
properties of the protocol continue to hold. Thus, non-interactive
Spawn∗ still provides stronger deniability guarantees than triple
Difﬁe-Hellman (3-DH), the current (non-interactive) TextSecure
key exchange protocol.
6.6 Conjecture: TextSecure Iron Triangle

Given the incomplete online repudiation of Spawn∗ when it is
used non-interactively, an obvious question to ask is whether the
protocol can be modiﬁed to address these problems. We may also
wonder more generally about all key exchanges suitable for use in
the TextSecure setting. We deﬁne a TextSecure-like key exchange
as a one-round key exchange protocol in which the initiator I does
not initially know the identity of the responder R. Our results lead
us to an unfortunate suspicion about the nature of such protocols:
any TextSecure-like key exchange cannot simultaneously provide
non-interactivity, (weak) forward secrecy, and online repudiation
with respect to R simulating I.

Intuitively, this conﬂict arises from the set of secrets required to
recover the session key k from the protocol transcript. In general,
both I and R may have short-term secrets (skI and skR, respec-
tively) and long-term secrets (SKI and SKR, respectively). In a
non-interactive setting, R cannot simulate I’s generation of skI to
an online judge (for the reasons given in Section 6.5), and the on-
line judge can insist on generating skR itself. Consequently, the
only secret information known only by R in this case is SKR. If
R is able to recover k from the transcript, then this implies that the
protocol does not have forward secrecy (because only long-term
secrets are required to recover k).
If R is not able to recover k
from the transcript, then this implies that the protocol lacks online
repudiation (because R cannot simulate I’s subsequent use of k).
Additionally, there is no way to force the judge to reveal any secrets
to R since the judge can always insist on the use of a secure multi-
party computation protocol to generate any required response.
6.7 A Practical Relaxation: Spawn

The security properties of Spawn∗ hold in a very strong threat
model: the adversary can adaptively corrupt parties, and no infor-
mation can ever be erased. In practice, these assumptions may not
hold. If either assumption is removed, then the security model will
admit a modiﬁed version of Spawn∗ with substantially increased
performance. Spawn is a protocol that is equivalent to Spawn∗,
except that it replaces the use of non-committing encryption in ψ2
with a standard public-key cryptosystem. PKGen is used to gen-
erate an ephemeral key pair (epk, esk) rather than the (npk, nsk)
pair produced by NCGen in Spawn∗. The motivation for this mod-
iﬁcation is that non-committing encryption schemes are extremely
expensive compared to standard public-key cryptosystems (e.g., the
NCE scheme described by Walﬁsh [29] makes 2λn calls to the
PKEnc function of an underlying 1-bit PKE scheme to encrypt an
n-bit message with security parameter λ).

In practice, it is reasonable to accept this weaker threat model
in many common environments. Security and privacy tools such

1219as hard drive encryption utilities and secure messaging tools com-
monly assume that cryptographic keys can be limited to RAM stor-
age, and RAM can be securely erased while a machine is uncor-
rupted. It is also reasonable to assume that corruptions are not fully
adaptive. When Spawn is used interactively, I can easily erase esk
if a timely response is not received from R (e.g., if an adversary
prevents delivery of ψ2 in an attempt to cause I to retain esk for
later corruption). In the non-interactive setting, online repudiation
of Spawn∗ is already weakened (see Section 6.5); there are no prac-
tical situations in non-interactive Spawn∗ that actually require the
use of NCEqv for simulation. For this reason, the use of Spawn in-
stead of Spawn∗ causes no loss of deniability beyond that already
incurred due to use in a non-interactive environment.
6.8 Bootstrapping Axolotl

One of the most innovative features of TextSecure is its per-
message forward and backward secrecy [28]; if keys are compro-
mised during a conversation, messages sent before or after the com-
promise cannot be decrypted by the adversary. TextSecure achieves
these properties by using the 3-DH DAKE to initialize Axolotl, a
scheme that refreshes cryptographic keys over time [21]. While 3-
DH provides deniability against ofﬂine judges, it does not defend
against online judges. Spawn can improve the deniability proper-
ties of TextSecure by replacing the 3-DH key exchange.

When Axolotl begins, I and R perform a 3-DH key exchange to
obtain a shared secret k. A key derivation function is used to derive
a variety of keys from k that are used internally by Axolotl. Spawn
(or Spawn∗) can be used instead of 3-DH to share k, which can then
be passed through the key derivation function in the same manner.
One complication that arises comes from the fact that 3-DH is a
contributory DAKE, while Spawn is non-contributory. Axolotl nor-
mally encrypts the ﬁrst message in the conversation using, in part,
an ephemeral secret key generated by R, for which there is no ana-
log in Spawn. Luckily, this is easily solved by encrypting the ﬁrst
message using a key derived solely from k; the details of Axolotl
ensure that subsequent messages are encrypted using freshly gen-
erated ephemeral keys. The thesis describes the complete technical
details of incorporating Spawn into TextSecure [27, §3.8.10].

7.

IMPLEMENTATION

Currently, there exists a disconnect between secure messaging
system developers and the academic community; there is an abun-
dance of solutions described in the literature that are never imple-
mented [28]. It has become clear that describing a new system and
writing security proofs, while necessary, are insufﬁcient for making
cryptography usable; we need to do more if we want actual users to
beneﬁt from our schemes. One way to bridge this gap is to provide
open implementations of our designs to encourage use by devel-
opers of consumer security products. We developed open-source
implementations6 of the key exchanges presented in this work us-
ing the Go programming language [14].

Our primary development objective was to implement Φdre with
non-interactive DRE, Φdre with interactive DRE (hereafter referred
to as Φidre), RSDAKE, and Spawn. Since the specialized cryp-
tosystems used by these protocols lack widely available implemen-
tations, we also developed implementations of these underlying
schemes as part of our development effort. In summary, we pro-
duced the following libraries:
• Pairing-Based Cryptography Library [17] wrapper for Go;
6The resulting libraries can be found at https://crysp.
uwaterloo.ca/software/.

• Shacham-Waters [26] ring signatures;
• HORS [23] one-time signatures with HORS+ [30] improvement;
• Cramer-Shoup cryptosystem [10], both in ﬁnite ﬁelds of prime

order and elliptic curve groups;

• Chow-Franklin-Zhang [9] BDDH-based DRE;
• Interactive DRE (deﬁned in Section 4.2);
• Φdre [29] (the ﬁrst public implementation);
• RSDAKE (deﬁned in Section 5.2);
• Spawn (deﬁned in Section 6.7).
We used the Chow-Franklin-Zhang non-interactive DRE scheme
in Φdre and Spawn, the Shacham-Waters ring signature scheme
in RSDAKE and Spawn, the Cramer-Shoup cryptosystem in Φdre
and Spawn, and ECDSA [18] in RSDAKE and Spawn. All of the
implemented schemes are provably secure in the standard model
(i.e., they do not require random oracles). Our implementations
each come with predeﬁned parameters to approximate security lev-
els between 80 and 256 bits. Precise details about the operation
of our libraries, and the exact standard-model security assumptions
made by each, are available in the thesis [27, §4].

8. EVALUATION

To compare the performance of the key exchange implementa-
tions, we instantiated a simulation of an interactive session between
two parties over the Internet. This simulation modeled a duplex
connection with conﬁgurable transmission latency and bandwidth
restrictions. We evaluated the performance of four protocols: Φdre,
Φidre, RSDAKE, and Spawn. We tested each protocol in a variety
of simulated network conditions at 112-, 128-, and 192-bit approx-
imate security levels. We simulated message latencies at 0, 50,
100, 300, 1000, 2000, 5000, and 10000 milliseconds. We sim-
ulated communication channel bandwidth at 10 Gib/s, 100 Mib/s,
20 Mib/s, 5 Mib/s, 500 Kib/s, and 50 Kib/s. We performed each test
200 times on 3.6 GHz processor cores with access to RAM provid-
ing 15 GiB/s read and write speeds with 63 ns latency. All graphs
in this section make use of logarithmic vertical axes and error bars.
The error bars, which denote the standard error of the mean, are
typically too small to see.
8.1 Space Complexity

All four schemes transmit different amounts of data during the
protocol session. The amount of data transmitted depends only on
the choice of protocol and the security level; it does not depend
on the speed of the network connection. Figure 4 shows the total
amount of data transmitted by each protocol during a session; this
total represents the sum of the number of bytes written at the ap-
plication layer by each party. All schemes are relatively expensive
compared to a simple SIGMA protocol; all four schemes require
at least 4 KiB to complete a session with at least 112 bits of secu-
rity. However, both Φdre and Spawn require signiﬁcantly more data
transmission than Φidre or RSDAKE; additionally, Φdre transmits
approximately three times more data than Spawn. The reason for
this disparity is the use of the HORS+ one-time signature scheme
by the non-interactive DRE implementation. Since Φdre makes use
of three DRE encryptions and Spawn makes use of only one, Φdre
requires nearly three times more data than Spawn to complete the
exchange. The use of interactive DRE in Φidre dramatically re-
duces the data costs of the protocol; Φidre consistently uses the
least data of all four protocols.

While RSDAKE uses nearly as little data as Φidre for the 112-bit
security level, its costs increase much faster as the security level is

1220Φdre
Φidre
RSDAKE
Spawn

)

i

B
K

(

a
t
a
d

d
e
t
t
i

m

s
n
a
r
T

512

256

128

64

32

16

8

4

Φdre
Φidre
RSDAKE
Spawn

)
s

m

(

e
m
T

i

106

105

104

103

102

112

128

192

Security level (bits)

112

128

192

Security level (bits)

Figure 4: The amount of data transmitted increases signiﬁ-
cantly with higher security levels. Φdre and Spawn require sig-
niﬁcantly more transmissions than Φidre or RSDAKE.

Figure 6: Over a low-bandwidth and high-latency connection,
the network signiﬁcantly affects performance. RSDAKE and
Spawn perform the best at 112- and 128-bit security levels.

As shown in Figure 5, RSDAKE and Spawn are roughly an order
of magnitude more expensive than Φdre and Φidre. The ring signa-
ture scheme used by both RSDAKE and Spawn is to blame for this
disparity. As we mentioned in Section 8.1, the Shacham-Waters
scheme used in our implementation makes use of composite-order
bilinear groups. Operations in this group setting are much more
expensive than operations in the prime-order elliptic curve groups
used by Φdre and Φidre. RSDAKE suffers more from this expense
than Spawn because RSDAKE requires two ring signatures.

Φdre
Φidre
RSDAKE
Spawn

)
s

m

(

e
m
T

i

106

105

104

103

102

112

128

192

Security level (bits)

Figure 5: Over a high-bandwidth connection with no latency,
the cryptographic overhead of each protocol is clear. The use
of ring signatures negatively affects RSDAKE and Spawn.

increased. Since the Shacham-Waters ring signature scheme used
by RSDAKE requires composite-order bilinear groups, the relative
ease of the integer factorization problem requires that the size of
group elements increases with approximately the cube of the secu-
rity level. As a result, the two ring signatures exchanged within
RSDAKE rapidly grow in size with heightened security. Nonethe-
less, RSDAKE never approaches the transmission costs of Φdre or
Spawn, even at the 192-bit security level.

8.2 Time Complexity vs. Security Level

As the desired security level increases, all four schemes require
increasingly expensive cryptographic operations. To understand
the impact of security levels on the time complexity of the algo-
rithms, we focus on the simulation with minimal impact from net-
work conditions. Figure 5 shows the amount of time required to
complete a session of each protocol when the parties are connected
through a 10 Gib/s channel with no latency; the resulting delays are
directly indicative each scheme’s cryptographic overhead.

Both Φdre and Φidre are extremely computationally efﬁcient,
requiring less than one second to complete at the 112- and 128-
bit security levels. However, in this fast network environment, the
interactive DRE scheme used by Φidre scales better than the Chow-
Franklin-Zhang scheme used by Φdre. At the 128- and 192-bit
security levels, Φidre requires the least amount of time to complete.
This performance improvement can be attributed to the direct use of
elliptic curve groups by the Cramer-Shoup scheme in Φidre, rather
than the use of pairing-based cryptography in Φdre.

It is also useful to understand how the schemes react to poor
network conditions. Figure 6 shows the total time required to com-
plete a session of each protocol when the parties are communicat-
ing across a 50 Kib/s connection with 2 seconds of latency. This
simulation models an extremely poor network environment that is
effectively a worst-case scenario for the protocols; the primary use
of this model is to provide insight into how the protocols behave
under difﬁcult network conditions.

The poor performance of the network connection depicted in
Figure 6 dominates the cost of all four protocols. Despite requir-
ing nine message ﬂows to complete, Φidre performs comparatively
well in this high-latency environment. Φidre is the most scalable
protocol; since it only requires operations in small elliptic curve
groups, the cryptographic overhead is relatively constant. Φdre
performs the worst at all security levels since it makes use of the
Chow-Franklin-Zhang DRE scheme three times, which imposes
high bandwidth costs. Spawn generally performs well since it only
requires two message ﬂows to complete, but it is still slower than
RSDAKE at 128- and 192-bit security levels due to its use of the
Chow-Franklin-Zhang DRE scheme. RSDAKE is the most efﬁ-
cient protocol at the 112- and 128-bit security levels. At the 192-bit
security level, the performance of RSDAKE and Spawn is impacted
by the computational costs of the Shacham-Waters ring signature

1221scheme. Consequently, Φidre performs signiﬁcantly better than all
other protocols at the 192-bit security level.

In the thesis, we examine the scalability of the algorithms with
respect to network latency and bandwidth at various security lev-
els [27, §4.3]. As a two-ﬂow protocol, Spawn scales the best as
latency increases. Φidre scales the worst with increasing latency
since it requires nine ﬂows. The performance of Φdre and Spawn
begin to deteriorate rapidly as channel bandwidth decreases below
5 Mib/s, especially at higher security levels.

9. CONCLUSION

When choosing a protocol to use in a real-world application,
developers should consider their security and performance needs.
Φdre, RSDAKE, and Spawn have different security and usability
properties, and thus are best suited for different environments.

We have introduced Spawn, the ﬁrst protocol with strong de-
niability properties and forward secrecy that can be used in non-
interactive environments. Spawn also requires the fewest number
of ﬂows. Although non-interactive Spawn does not provide online
repudiation with respect to R simulating I (see Section 6.5), it still
provides improved deniability properties compared to 3-DH. When
a practitioner only needs to support interactive environments, more
choices are available: Spawn is useful in interactive environments
where the weaknesses described in Section 6.3 and Section 6.4 are
not a concern; Φdre and our newly deﬁned RSDAKE scheme can
both be used interactively and offer the same security properties,
but RSDAKE offers some additional features. Unlike Φdre, RS-
DAKE is a contributory key exchange proven secure in the post-
speciﬁed peer setting.

It is also important to understand how the schemes perform in
practice under various network conditions. Our evaluation pre-
sented in Section 8 is meant to serve as a guideline for real-world
performance expectations. When implemented using primitives se-
cure under only standard-model assumptions, Φidre and RSDAKE
are the best choices for bandwidth-constrained environments such
as mobile data connections. Φdre and Φidre are better suited for
use over large and fast connections. Only Spawn supports non-
interactive environments, irrespective of their network characteris-
tics. If a practitioner is willing to make use of schemes that depend
on random oracles for security, then the performance of all four
protocols can be greatly improved.

Deniability of secure messaging schemes remains a research area
with many unsolved problems. The most appropriate deﬁnition of
deniability to use when constructing protocols is not yet agreed
upon; speciﬁcally, very few publications consider online repudi-
ation during analysis of their designs. While we suspect that weak
forward secrecy and online repudiation are mutually exclusive in
the non-interactive setting, the conjecture in Section 6.6 remains
unproven. Finally, although we provide proof-of-concept imple-
mentations of our new DAKE protocols, adoption by end-user tools
may be encouraged by integrating these implementations with a
higher-level popular cryptographic library.

10. ACKNOWLEDGMENTS

The authors would like to thank the anonymous reviewers for
their insightful comments and feedback. We gratefully acknowl-
edge the support of NSERC and the Ontario Research Fund.

11. REFERENCES
[1] M. Bellare, D. Pointcheval, and P. Rogaway. Authenticated

Key Exchange Secure Against Dictionary Attacks. In

Advances in Cryptology–EUROCRYPT, pages 139–155.
Springer, 2000.

[2] A. Bender, J. Katz, and R. Morselli. Ring Signatures:

Stronger Deﬁnitions, and Constructions without Random
Oracles. In Theory of Cryptography, pages 60–79. Springer,
2006.

[3] N. Borisov, I. Goldberg, and E. Brewer. Off-the-Record

Communication, or, Why Not To Use PGP. In Workshop on
Privacy in the Electronic Society, pages 77–84. ACM, 2004.

[4] R. Canetti. Universally Composable Security: A New

Paradigm for Cryptographic Protocols. In Foundations of
Computer Science, pages 136–145. IEEE, 2001.

[5] R. Canetti. Universally Composable Signature, Certiﬁcation,

and Authentication. In Computer Security Foundations
Workshop, pages 219–233. IEEE, 2004.

[6] R. Canetti, U. Feige, O. Goldreich, and M. Naor. Adaptively

Secure Multi-party Computation. Technical report,
Massachusetts Institute of Technology, 1996.
http://theory.csail.mit.edu/ftp-data/
pub/people/oded/dynamic.ps.

[7] R. Canetti and H. Krawczyk. Security Analysis of IKE’s
Signature-Based Key-Exchange Protocol. In Advances in
Cryptology–CRYPTO 2002, pages 143–161. Springer, 2002.

[8] S. G. Choi, D. Dachman-Soled, T. Malkin, and H. Wee.

Improved Non-Committing Encryption with Applications to
Adaptively Secure Protocols. In Advances in
Cryptology–ASIACRYPT 2009, pages 287–302. Springer,
2009.

[9] S. S. Chow, M. Franklin, and H. Zhang. Practical

Dual-Receiver Encryption. In Topics in Cryptology–CT-RSA
2014, pages 85–105. Springer, 2014.

[10] R. Cramer and V. Shoup. A Practical Public Key

Cryptosystem Provably Secure against Adaptive Chosen
Ciphertext Attack. In Advances in Cryptology–CRYPTO’98,
pages 13–25. Springer, 1998.

[11] I. Damgård and J. B. Nielsen. Improved Non-Committing

Encryption Schemes Based on a General Complexity
Assumption. In Advances in Cryptology–CRYPTO 2000,
pages 432–450. Springer, 2000.

[12] Y. Dodis, J. Katz, A. Smith, and S. Walﬁsh. Composability

and On-Line Deniability of Authentication. In Theory of
Cryptography, pages 146–162. Springer, 2009.

[13] A. Fiat and A. Shamir. How To Prove Yourself: Practical

Solutions to Identiﬁcation and Signature Problems. In
Advances in Cryptology–CRYPTO’86, pages 186–194.
Springer, 1987.

[14] Go Project. The Go Programming Language.

https://golang.org/, 2009. Accessed 2015-04-13.

[15] M. Hearn. Value of deniability. Mailing list discussion,

https://moderncrypto.org/mail-archive/
messaging/2014/001173.html, 2014. Accessed
2015-04-02.

[16] H. Krawczyk. SIGMA: The ‘SIGn-and-MAc’ Approach to

Authenticated Difﬁe-Hellman and its Use in the IKE
protocols. In Advances in Cryptology–CRYPTO 2003, pages
400–425. Springer, 2003.

[17] B. Lynn. The Pairing-Based Cryptography Library.

https://crypto.stanford.edu/pbc/, 2006.
Accessed 2015-04-13.

[18] U. D. of Commerce / National Institute of Standards

& Technology. Digital Signature Standard (DSS), 2013.

1222[19] Open Whisper Systems. Open WhisperSystems.

https://www.whispersystems.org/, 2013.
Accessed 2014-11-02.

[20] Open Whisper Systems. Open Whisper Systems partners

with WhatsApp to provide end-to-end encryption. https:
//www.whispersystems.org/blog/whatsapp/,
2014. Accessed 2014-12-23.

[21] T. Perrin. Axolotl Ratchet.

https://github.com/trevp/axolotl/wiki,
2013. Accessed 2014-11-02.

[22] C. Rackoff and D. R. Simon. Non-Interactive

Zero-Knowledge Proof of Knowledge and Chosen
Ciphertext Attack. In Advances in Cryptology–CRYPTO’91,
pages 433–444. Springer, 1992.

[23] L. Reyzin and N. Reyzin. Better than BiBa: Short One-time
Signatures with Fast Signing and Verifying. In Information
Security and Privacy, pages 144–153. Springer, 2002.

[24] R. L. Rivest, A. Shamir, and Y. Tauman. How to Leak a

Secret. In Advances in Cryptology–ASIACRYPT 2001, pages
552–565. Springer, 2001.

[25] C.-P. Schnorr. Efﬁcient Signature Generation by Smart

Cards. Journal of Cryptology, 4(3):161–174, 1991.

[26] H. Shacham and B. Waters. Efﬁcient Ring Signatures

without Random Oracles. In Public Key Cryptography, pages
166–180. Springer, 2007.

[27] N. Unger. Deniable Key Exchanges for Secure Messaging.

Master’s thesis, University of Waterloo, 2015.
http://hdl.handle.net/10012/9406.

[28] N. Unger, S. Dechand, J. Bonneau, S. Fahl, H. Perl,

I. Goldberg, and M. Smith. SoK: Secure Messaging. In
Symposium on Security and Privacy. IEEE, 2015.
[29] S. Walﬁsh. Enhanced Security Models for Network
Protocols. PhD thesis, New York University, 2008.

[30] J. Zhang, J. Ma, and S. Moon. Universally composable

one-time signature and broadcast authentication. Science
China Information Sciences, 53(3):567–580, 2010.

[31] H. Zhu, T. Araragi, T. Nishide, and K. Sakurai. Universally

Composable Non-committing Encryptions in the Presence of
Adaptive Adversaries. In e-Business and
Telecommunications, pages 274–288. Springer, 2012.

1223