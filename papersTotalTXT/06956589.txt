2014 IEEE Symposium on Security and Privacy

Modeling and Discovering Vulnerabilities

with Code Property Graphs

Fabian Yamaguchi∗, Nico Golde†, Daniel Arp∗ and Konrad Rieck∗

∗University of G¨ottingen, Germany
†Qualcomm Research Germany

Abstract—The vast majority of security breaches encountered
today are a direct result of insecure code. Consequently, the
protection of computer systems critically depends on the rigorous
identiﬁcation of vulnerabilities in software, a tedious and error-
prone process requiring signiﬁcant expertise. Unfortunately, a
single ﬂaw sufﬁces to undermine the security of a system and
thus the sheer amount of code to audit plays into the attacker’s
cards. In this paper, we present a method to effectively mine
large amounts of source code for vulnerabilities. To this end,
we introduce a novel representation of source code called a
code property graph that merges concepts of classic program
analysis, namely abstract syntax trees, control ﬂow graphs and
program dependence graphs, into a joint data structure. This
comprehensive representation enables us to elegantly model tem-
plates for common vulnerabilities with graph traversals that, for
instance, can identify buffer overﬂows, integer overﬂows, format
string vulnerabilities, or memory disclosures. We implement our
approach using a popular graph database and demonstrate its
efﬁcacy by identifying 18 previously unknown vulnerabilities in
the source code of the Linux kernel.

Keywords—Vulnerabilities; Static Analysis; Graph Databases

I.

INTRODUCTION

The security of computer systems fundamentally depends
on the quality of its underlying software. Despite a long series
of research in academia and industry, security vulnerabilities
regularly manifest in program code, for example as failures
to account for buffer boundaries or as insufﬁcient validation
of input data. Consequently, vulnerabilities in software remain
one of the primary causes for security breaches today. For
example, in 2013 a single buffer overﬂow in a universal plug-
and-play library rendered over 23 million routers vulnerable
to attacks from the Internet [26]. Similarly,
thousands of
users currently fall victim to web-based malware that exploits
different ﬂaws in the Java runtime environment [29].

The discovery of software vulnerabilities is a classic yet
challenging problem of security. Due to the inability of a
program to identify non-trivial properties of another program,
the generic problem of ﬁnding software vulnerabilities is
undecidable [33]. As a consequence, current means for spotting
security ﬂaws are either limited to speciﬁc types of vulnera-
bilities or build on tedious and manual auditing. In particular,
securing large software projects, such as an operating system
kernel, resembles a daunting task, as a single ﬂaw may
undermine the security of the entire code base. Although some
classes of vulnerabilities reoccurring throughout the software
landscape exist for a long time, such as buffer overﬂows
and format string vulnerabilities, automatically detecting their

incarnations in speciﬁc software projects is often still not
possible without signiﬁcant expert knowledge [16].

As a result of this situation, security research has initially
focused on statically ﬁnding speciﬁc types of vulnerabilities,
such as ﬂaws induced by insecure library functions [6], buffer
overﬂows [45], integer overﬂows [40] or insufﬁcient validation
of input data [18]. Based on concepts from software testing,
a broader detection of vulnerabilities has then been achieved
using dynamic program analysis, ranging from simple fuzz
testing [e.g., 38, 42] to advanced taint tracking and symbolic
execution [e.g., 2, 35]. While these approaches can discover
different types of ﬂaws, they are hard to operate efﬁciently in
practice and often fail to provide appropriate results due to
either prohibitive runtime or the exponential growth of execu-
tion paths to consider [16, 21]. As a remedy, security research
has recently started to explore approaches that assist an analyst
during auditing instead of replacing her. The proposed methods
accelerate the auditing process by augmenting static program
analysis with expert knowledge and can thereby guide the
search for vulnerabilities [e.g., 39, 43, 44].

In this paper, we continue this direction of research and
present a novel approach for mining large amounts of source
code for vulnerabilities. Our approach combines classic con-
cepts of program analysis with recent developments in the ﬁeld
of graph mining. The key insight underlying our approach is
that many vulnerabilities can only be adequately discovered
by jointly taking into account the structure, control ﬂow and
dependencies of code. We address this requirement by intro-
ducing a novel representation of source code denoted as code
property graph. This graph combines properties of abstract
syntax trees, control ﬂow graphs and program dependence
graphs in a joint data structure. This comprehensive view on
code enables us to elegantly model templates for common
vulnerabilities using graph traversals. Similar to the query in a
database, a graph traversal passes over the code property graph
and inspects the code structure, the control ﬂow, and the data
dependencies associated with each node. This joint access to
different code properties enables crafting concise templates for
several types of ﬂaws and thereby helps to audit large amounts
of code for vulnerabilities.

We implement our approach using a popular graph database
and demonstrate its practical merits by designing graph traver-
sals for several well-known vulnerability types, such as buffer
overﬂows, integer overﬂows, format string vulnerabilities, or
memory disclosures. As a show case, we analyze the source
code of the Linux kernel—a large and well-audited code
base. We ﬁnd that almost all vulnerabilities reported for

© 2014, Fabian Yamaguchi. Under license to IEEE.
DOI 10.1109/SP.2014.44

590

the Linux kernel in 2012 can be described using traversals
in its code property graph. Despite considerable efforts by
the open-source community to improve the kernel’s security,
these traversals enable us to discover 18 previously unknown
vulnerabilities in the Linux kernel, thereby demonstrating the
capabilities of code property graphs in practice.

problem of vulnerability discovery:

In summary, we make the following contributions to the
• Code property graph. We introduce a novel representa-
tion of source code that combines properties of abstract
syntax trees, control ﬂow graphs and program depen-
dence graphs in a joint data structure.
• Traversals for vulnerability types. We show that common
types of vulnerabilities can be elegantly modeled as
traversals of the code property graph and give rise to
efﬁcient detection templates.
• Efﬁcient implementation. We demonstrate that by im-
porting the code property graph into a graph database,
traversals can be efﬁciently executed on large code
bases, such as the Linux kernel.

The remainder of this paper is structured as follows: We
provide background information on representations of code
in Section II and deﬁne the concepts of property graphs
and graph traversals in Section III. We introduce our novel
representation—code property graphs—in Section IV and
demonstrate how it can be used to characterize vulnerabilities
in Section V. We evaluate our approach in Section VI. Related
work and limitations are discussed in Section VII and VIII,
respectively. Section IX concludes the paper.

II. REPRESENTATIONS OF CODE

Various different representations of code have been devel-
oped in the ﬁelds of program analysis and compiler design to
reason about properties of programs. While these representa-
tions have been designed primarily to analyze and optimize
code, they are also suited to characterize it as explored in this
work. In particular, we focus on three classic representations,
namely abstract syntax trees, control ﬂow graphs and program
dependence graphs which form the basis for our approach to
vulnerability discovery. A detailed discussion of code repre-
sentations can be found in the book by Aho et al. [1].

void foo()
{

int x = source();
if (x < MAX)
{

int y = 2 * x;
sink(y);

}

}

1
2
3
4
5
6
7
8
9

Fig. 1: Exemplary code sample (see Figure 2).

A. Abstract Syntax Trees (AST)

Abstract syntax trees are usually among the ﬁrst interme-
diate representations produced by code parsers of compilers
and thus form the basis for the generation of many other code
representations. These trees faithfully encode how statements
and expressions are nested to produce programs. In contrast
to a parse tree, however, abstract syntax trees no longer
represent the concrete syntax chosen to express the program.
For example, in the language C, a comma-separated list of
declarations will usually produce the same abstract syntax tree
as two consecutive declarations.

Abstract syntax trees are ordered trees where inner nodes
represent operators (e.g., additions or assignments) and leaf
nodes correspond to operands (e.g., constants or identiﬁers).
As an example, consider Figure 2a showing an abstract syntax
tree for the code sample given in Figure 1. While abstract
syntax trees are well suited for simple code transformations
and have been employed to identify semantically similar
code [3, 43], they are not applicable for more evolved code
analysis, such as the detection of dead code or uninitialized
variables. The reason for this deﬁciency is that neither the
control ﬂow nor data dependencies are made explicit by this
representation of code.

B. Control Flow Graphs (CFG)

A control ﬂow graph explicitly describes the order in which
code statements are executed as well as conditions that need
to be met for a particular path of execution to be taken. To
this end, statements and predicates are represented by nodes,
which are connected by directed edges to indicate the transfer
of control. While these edges need not be ordered as in the
case of the abstract syntax trees, it is necessary to assign a
label of true, false or  to each edge. In particular, a statement
node has one outgoing edge labeled as , whereas a predicate
node has two outgoing edges corresponding to a true or
false evaluation of the predicate. Control ﬂow graphs can be
constructed from abstract syntax trees in a two step procedure:
ﬁrst, structured control statements (e.g., if, while, for) are taken
into account to build a preliminary control ﬂow graph. Second,
the preliminary control ﬂow graph is corrected by additionally
considering unstructured control statements such as goto, break
and continue. Figure 2b shows the CFG for the code sample
given in Figure 1.

Control ﬂow graphs have been used for a variety of applica-
tions in the security context, e.g., to detect variants of known
malicious applications [11] and to guide fuzz testing tools [37].
Moreover, they have become a standard code representation in
reverse engineering to aid in program understanding. However,
while control ﬂow graphs expose the control ﬂow of an
application, they fail to provide data ﬂow information. For
vulnerability analysis in particular, this means that control ﬂow
graphs cannot be easily used to identify statements, which
process data inﬂuenced by an attacker.

As a simple example illustrating the different representations
and running through this section, we consider the code sample
shown in Figure 1.

C. Program Dependence Graphs (PDG)

Program dependence graphs introduced by Ferrante et al.
[9] have been originally developed to perform program slic-

591

FUNC
FUNC

ENTRY
ENTRY

ε 

DECL
DECL

IF
IF

int x = source()
int x = source()

int x = source()
int x = source()

int
int

=
=

PRED
COND

STMT
STMT

x
x

CALL
CALL

<
<

DECL
DECL

CALL
CALL

ε 

if (x < MAX)
if (x < MAX)

true

int y = 2 * x

y = 2 * x

Dx

Dx

if (x < MAX)
if (x < MAX)

Ctrue

int y = 2 * x

y = 2 * x

source
source

x
x

MAX
MAX

int
int

=
=

sink
sink

ARG
ARG

ε 

false

Ctrue

Dy

y
y

*
*

y
y

2
2

x
x

sink(y)
sink(y)

ε 

EXIT
EXIT

sink(y)
sink(y)

(a) Abstract syntax tree (AST)

(b) Control ﬂow graph (CFG)

(c) Program dependence graph (PDG)

Fig. 2: Representations of code for the example in Figure 1. Control and data dependencies are indicated by C and D in the
program dependence graph.

ing [41], that is, to determine all statements and predicates
of a program that affect the value of a variable at a speciﬁed
statement. The program dependence graph explicitly represents
dependencies among statements and predicates. In particular,
the graph is constructed using two types of edges: data
dependency edges reﬂecting the inﬂuence of one variable on
another and control dependency edges corresponding to the
inﬂuence of predicates on the values of variables. The edges
of a program dependence graph can be calculated from a
control ﬂow graph by ﬁrst determining the set of variables
deﬁned and the set of variables used by each statement
and calculating reaching deﬁnitions for each statement and
predicate, a standard problem from compiler design [see 1].

As an example, Figure 2c shows the program dependence
graph for the code sample given in Figure 1. Note that control
dependency edges are not simply control ﬂow edges and, in
particular, that the order in which statements are executed can
no longer be determined from the graph, whereas dependencies
between statements and predicates are clearly visible.

III. PROPERTY GRAPHS AND TRAVERSALS

Each of the presented representations provides a unique view
on source code emphasizing different aspects of the underlying
program. To combine these views into a joint representation for
vulnerability discovery, we employ the concept of a property
graph [34], which is a basic representation of structured data in
many graph databases, as for example ArangoDB, Neo4J and
OrientDB. Formally, a property graph is deﬁned as follows.
Deﬁnition 1. A property graph G = (V, E, λ, μ) is a directed,
edge-labeled, attributed multigraph where V is a set of nodes,
E ⊆ (V × V ) is a set of directed edges, and λ : E → Σ is an
edge labeling function assigning a label from the alphabet Σ
to each edge. Properties can be assigned to edges and nodes
by the function μ : (V ∪ E) × K → S where K is a set of
property keys and S the set of property values.

Figure 3 shows a simple property graph with four nodes.
Note that property graphs are multigraphs and thus two nodes
may be connected by multiple edges, as for example the nodes
A and B in Figure 3. Moreover, in the example, a property
with key k ∈ K is assigned to each node, where only the nodes
A and B store property values from the set S = {x, w}.

k:x

A
A

a

BD

k:ε

a

b

a

k:ε

C
C

B
B

k:w

b

Fig. 3: Example of a property graph. Properties assigned to
nodes are indicated by dashed lines.

The main tool for mining information in property graphs
are so-called graph traversals, or short traversals, which can
be used to move along the edges of the graph depending on
the labels and properties. Formally, a traversal of the graph is
deﬁned as follows.
Deﬁnition 2. A traversal is a function T : P(V ) → P(V )
that maps a set of nodes to another set of nodes according to
a property graph G, where P is the power set of V .
This generic deﬁnition allows for chaining multiple traver-
sals together. For example, two graph traversals T0 and T1 can
be chained together to T0 ◦T1 using a function composition ◦.
Based on this chaining, we can deﬁne a number of elementary
traversals, which serve as a basis for the construction of all
other traversals discussed in this paper. We begin by deﬁning
a simple ﬁlter traversal

FILTERp(X) = {v ∈ X : p(v)}

that returns all nodes in the set X matching the Boolean
predicate p(v), for example, by checking for a certain property.

592

To move along the edges of a property graph, we deﬁne the

following forward traversals

(cid:4)

OUT(X) =

OUTl(X) =

OUT

k,s
l

(X) =

(cid:3)
(cid:3)
(cid:3)

(cid:2)
(cid:2)
v∈X
(cid:2)
v∈X
v∈X

,

u : (v, u) ∈ E
u : (v, u) ∈ E and λ((v, u)) = l
u : (v, u) ∈ E and λ((v, u)) = l

(cid:4)

,

(cid:4)

and μ((v, u), k) = s

k,s
l

which return nodes reachable from the set of nodes X. In
detail, the traversal OUT returns all nodes reachable from X,
OUTl returns all nodes reachable over edges with label l,
and OUT
all nodes reachable over edges with label l and
k,s
property k:s. Similarly, we deﬁne traversals IN, INl and IN
l
(cid:4)
for moving backward in the graph by
v : (v, u) ∈ E
v : (v, u) ∈ E and λ((v, u)) = l
v : (v, u) ∈ E and λ((v, u)) = l

INl(X) =

IN(X) =

(cid:3)
(cid:3)
(cid:3)

IN

k,s
l

(X) =

,

(cid:4)

,

(cid:2)
(cid:2)
u∈X
(cid:2)
u∈X
u∈X

(cid:4)

and μ((v, u), k) = s

.

Finally, we deﬁne two traversals OR and AND to aggregate

the output of other traversals as follows:

OR(T1, . . . ,TN )(X) = T1(X) ∪ . . . ∪ TN (X)
AND(T1, . . . ,TN )(X) = T1(X) ∩ . . . ∩ TN (X)

Despite the slightly technical deﬁnitions, several graph
databases provide efﬁcient implementations for these elemen-
tary traversals. In particular, the FILTER, OUT and IN traversals
are basic functions of the graph language Gremlin supported
by popular databases, such as Neo4J and InﬁniteGraph. We
discuss the details of implementing graph traversals along with
the evaluation of our approach in Section VI.

IV. CODE PROPERTY GRAPHS

Each of the representations presented in Section II captures
certain properties of the underlying software. However, a single
representation alone is insufﬁcient to characterize a vulnera-
bility type in the vast majority of cases. We thus combine the
three representation into a joint data structure using the concept
of property graphs introduced in Section III. In particular, we
ﬁrst model ASTs, CFGs and PDGs as property graphs and then
proceed to merge them to one graph offering all advantages
of the individual representations.

A. Transforming the Abstract Syntax Tree

The only representation offering a detailed decomposition of
source code into language constructs is the AST. Hence, we
start the construction of a joint representation by expressing an
AST as a property graph GA = (VA, EA, λA , μA), where the

593

nodes VA are given by the tree nodes and the edges EA are the
corresponding tree edges labeled as AST edges by the labeling
function λA. Additionally, we assign a property code to each
node using μA, such that the property value corresponds to the
operator or operand the node represents. Finally, we assign a
property order to each node to reﬂect the ordered structure
of the tree. As a result, the property keys of the graph are
KA = {code, order} while the set of property values SA is
given by all operators and operands and the natural numbers.

B. Transforming the Control Flow Graph

As the next step, we prepare the CFG for incorporation into
a joint representation. For this purpose, we express the CFG as
a property graph GC = (VC, EC, λC, · ), where the nodes VC
simply correspond to statements and predicates in the AST, that
is, all nodes VA with the property values STMT and PRED for
the key code. Furthermore, we deﬁne an edge labeling function
λC that assigns a label from the set ΣC = {true, false, } to
all edges in the property graph.

C. Transforming the Program Dependence Graph

The PDG represents data and control dependencies among
statements and predicates. The nodes of this graph are thus
the same as those of the CFG and only the edges of the two
graphs differ. Hence, the PDG can be represented as a property
graph GP = (VC, EP , λP , μp) simply by deﬁning a new set
of edges EP and a corresponding edge labeling function λP :
Ep → ΣP where ΣP = {C, D} corresponds to control and
data dependencies. Additionally, we assign a property symbol
to each data dependency to indicate the corresponding symbol
and a property condition to each control dependency to indicate
the state of the originating predicate as true or false.

D. Combining the Representations

As the last step, we combine the three property graphs into
a joint data structure denoted as code property graph. The key
insight necessary to construct this graph is that in each of the
three graphs, a node exists for each statement and predicate in
the source code. In fact, the AST is the only one of the three
representations, which introduces additional nodes. Statement
and predicate nodes thus naturally connect representations and
serve as transition points from one representation to another.
Deﬁnition 3. A code property graph is a property graph
G = (V, E, λ, μ) constructed from the AST, CFG and PDG of
source code with
• V = VA,
• E = EA ∪ EC ∪ EP ,
• λ = λA ∪ λC ∪ λP and
• μ = μA ∪ μE,

where we combine the labeling and property functions with a
slight abuse of notation.

An example of a code property graph is shown in Figure 4
for the code sample given in Figure 1. For simplicity, property
keys and values as well as labels on AST edges are not

Dx 

Ctrue 

false

ENTRY
ENTRY

ε 

DECL
DECL

ε 

Dx 

PRED
COND

true 

Ctrue 

DECL
DECL

ε 

Dy 

CALL
CALL

ε 

EXIT
EXIT

int
int

=
=

<
<

int
int

=
=

sink
sink

ARG
ARG

x
x

CALL
CALL

x
x

MAX
MAX

y
y

*
*

y
y

source
source

2
2

x
x

Fig. 4: Code property graph for the code sample given in Figure 1.

AST edge
CFG edge
PDG edge

shown. The nodes of the graph mainly match the AST in
Figure 2a (except for the irrelevant FUNC and IF node), while
the transformed CFG and PDG are indicated by colored edges.

V. TRAVERSALS FOR

WELL-KNOWN TYPES OF VULNERABILITIES

it

The code property graph allows many different kinds of
programming patterns to be expressed, however,
is not
immediately clear how it can be employed to discover vulner-
abilities. In this section, we show that code property graphs
can be effectively mined to identify many different types of
security ﬂaws and develop templates for the description of
vulnerabilities. We begin by exploring the limitations of purely
syntactic descriptions of code in Section V-B and proceed to
show that additional control ﬂow information only provides a
slight improvement (Section V-C). Finally, in Section V-D, data
ﬂow, control ﬂow and syntactical information are combined,
thus making a large variety of vulnerabilities accessible.

A. Motivational Example

We begin with a recent example of a buffer overﬂow found
in an SSH implementation by Esser [7] exposing many Apple
iOS applications to attack. Esser employed a regular expression
to spot the vulnerable code shown in Figure 5.

[...]
if (channelp) {
/* set signal name (without SIG prefix) */
uint32_t namelen =
_libssh2_ntohu32(data + 9 + sizeof("exit-signal"));
channelp->exit_signal =

LIBSSH2_ALLOC(session, namelen + 1);

[...]
memcpy(channelp->exit_signal,

data + 13 + sizeof("exit_signal"), namelen);

channelp->exit_signal[namelen] = ’\0’;
[...]

}
[...]

1
2
3
4
5
6
7
8
9
10
11
12
13
14

Fig. 5: Excerpt from the code of libssh2 showing a vulnera-
bility in the function libssh2 packet add

The vulnerable statement (marked in red) allocates memory
for the buffer exit signal using the function LIBSSH2 ALLOC

594

on line 6. The amount of memory to allocate is calculated
directly in the argument by adding 1 to the variable namelen.
Unfortunately, this variable is attacker-controlled and thus if
it is chosen to be the maximum size of a 32-bit unsigned
integer, the summation wraps and a value of 0 is passed to the
allocation function resulting in the allocation of only a few
padding bytes. When namelen bytes are then copied into the
undersized buffer on line 9, a buffer overﬂow occurs.

Esser was able to discover the vulnerable statement on line 6

using the following regular expression:

ALLOC[A-Z0-9_]*\s*\([ˆ,]*,[ˆ;]*[*+-][ˆ>][ˆ;]*\)\s*; .

Unfortunately,

the regular expression only describes the
summation inside the allocation call, one of a number of
necessary conditions for the vulnerability. Moreover, the de-
scription is inherently vague as regular expressions cannot
match the nested structure of code. However,
the biggest
drawback of the formulation is that the description fails to
model attacker control over the variable namelen. Furthermore,
the vulnerability would not exist if the variable had been
properly sanitized. Finally, the width of the variable is vital
for the vulnerability.

This simple example gives insight into the different prop-
erties of code that play a role in the characterization of
vulnerability patterns. In summary, the following aspects need
to be covered.

1)

Sensitive operations. Security sensitive operations such
as calls to protected functionality, copying into buffers
or the allocation of memory need to be describable.
As the example shows, nested code such as arithmetic
operations inside allocations are of great interest, and
thus full access to an AST is necessary.

2) Type usage. Many vulnerabilities are tightly bound
to data types used in a program. For example, the
vulnerability shown in Figure 5 would not exist
if
namelen was a 16 bit integer as opposed to a 32 bit
integer. This information is present in the AST.

3) Attacker control. Analysts must be able to express
which data sources are under attacker control. Referring
to the example, it is highly likely that variables returned
by libssh2 ntohu32 are attacker-controlled as the rou-
tine converts an integer from network to host byte order
and hence the integer is almost certainly received from

4)

a network. Data dependencies as expressed by the PDG
are needed in order to model this.
Sanitization. Finally, many vulnerabilities only occur
if a program lacks proper sanitization of attacker-
controlled data. If in the example, the variable namelen
had been checked to be in a safe range before allocation,
the vulnerability would not exist. Modeling statement
order as made explicit by the CFG is thus crucial.

We now analyze in detail how the different views provided
by the code property graph contribute to the construction of
successful graph traversals for vulnerability discovery.

B. Syntax-Only Vulnerability Descriptions
The code property graph exposes all

information origi-
nally contained in the abstract syntax tree. This information
is sufﬁcient to describe attacker-controlled sources, sensitive
operations and sanitizers, but fails to capture the interplay
between statements as illustrated in this section.

We begin by describing the vulnerable statement in Figure 5
by its syntactical structure. The key property of the vulnera-
bility is that a summation occurs directly in an argument to
an allocation function, a simple example already introducing
two challenges: ﬁrst, we need to determine whether a function
contains summations and calls; second, we need to capture the
nested structure of code.

The ﬁrst problem can be addressed by obtaining all nodes
of a function and subsequently ﬁltering them to determine
whether any of the nodes represent summations or calls.
Finding all nodes of an AST that match a criterion is a
reoccurring problem. We address it once and for all by deﬁning
a re-usable traversal TNODES that traverses from the root of
an AST to all nodes of the AST.1 This immediately allows
us to determine whether an AST contains summation or call
nodes simply by combining TNODES with FILTER to obtain

MATCHp(V ) = FILTERp ◦ TNODES(V )

which traverses to all nodes contained in ASTs rooted at all
v ∈ V and ﬁlters these nodes according to the predicate p.
Traversing to all calls to allocation functions in the code can
then simply be achieved by running a MATCH traversal where
V is the set of all function nodes and p(v) is true if v is a call
to an allocation function.

The second problem, i.e., identifying summations nested
inside arguments to calls now becomes easy to solve as well,
as MATCH traversals can simply be chained using function
composition, e.g., to identify summations inside i’th arguments
to a function f, we use the traversal

MATCHp ◦ ARGi

f

where ARGi
f is a MATCH traversal returning i-th arguments
of calls to functions named f and p(v) is true if μ(v, code) =
Summation and false otherwise.

MATCH traversals alone are not suited to characterize the
interplay between statements, however, they form the basis for
the precise description of sensitive operations, sanitizers and

•

•

•

attacker controlled sources in the vast majority of vulnerability
types. Moreover, there are a number of cases where charac-
terizing a single statement can already narrow the search for
vulnerabilities of a type as seen in the example of Figure 5. The
following are examples of vulnerability types where MATCH
traversals alone are equally successful.

Insecure arguments. Insecure arguments are a common
source for vulnerabilities. For example, format string
vulnerabilities [see 12, 31, 36] result when an attacker-
controlled format string is passed to functions such as
printf or sprintf and can be exploited for arbitrary code
execution on several platforms. A necessary condition
for format string vulnerabilities is that the format string
passed to a utility function such as printf, sprintf or
is not a constant string. This can be described
fprintf
using a MATCH traversal as follows:

MATCHp ◦ ARG

1
sprintf

where p is true if v does not represent a constant string,
i.e., if μ(v, code) (cid:8)= String. While this traversal does
not model attacker control, it is successful in practice
as there are few reasons to ever supply a non-constant
format string.
Integer overﬂows. Cases where arithmetic operations
are performed inside arguments to allocation functions
are prime candidates for integer overﬂows leading to
the corruption of memory as shown in the motivating
example depicted in Figure 5. These can be easily
expressed by traversals such as the following:

MATCHp ◦ ARG

1
malloc

where p(v) is true if v is an arithmetic operation, e.g.,
μ(v, code) = Multiplication.
Integer type issues. Several types of vulnerabilities are
a direct consequence of type conversions unforeseen
by developers. In particular, buffer overﬂows are often
caused by incorrectly calculated or veriﬁed buffer sizes
resulting from implicit integer casts. As an example, an
integer truncation occurs when integers on the right-
hand side of an assignment are wider than those on the
left hand side. Spotting these types of vulnerabilities is
a little more evolved than in the previous two cases as
the left and right subtrees of assignments need to be
compared in order to determine vulnerable cases. To this
T2T1. Starting from a set
end, we deﬁne the function PAIRS
of nodes, e.g., all assignment nodes, PAIRS performs two
independent traversals T1 and T2, for example, one that
traverses to the left subtree of the assignment and one
that traverses to the right, and combines the results of
the two traversals into pairs. These pairs can then be
ﬁltered according to a predicate p using the function
PAIRFILTERp deﬁned analogously to FILTER2. Integer
truncations can now easily be detected by combining the
two functions with MATCH, yielding the traversal

PAIRFILTERp1

◦ PAIRS

T2T1

◦ MATCHp2

1A formal deﬁnition is given in Appendix IX-A.

2Formal deﬁnitions of PAIR and PAIRFILTER are given in Appendix IX-C.

595

where p1 is true if the second node denotes a variable
with a type wider than that of the ﬁrst node, p2 is true if
the node is an assignment and ﬁnally, T1 and T2 traverse
to left and right subtrees of assignments respectively.

While most attempts to characterize vulnerabilities based on
MATCH traversals alone are bound to fail, as statements cannot
be put into relation, it is possible to combine several MATCH
traversals using AND and OR as introduced in Section III to
narrow in on potentially interesting code. For example, missing
permission checks [see 27, 44] can be characterized by the
security critical operation and attacker-controlled source which
must occur and a check which may not occur in order for the
code to be vulnerable. Unfortunately, this is also the best one
can do using abstract syntax trees and we provide the following
deﬁnition to capture this.
Deﬁnition 4. A syntax-only vulnerability description S is a
2-tuple (M0,M1) where M0 and M1 are sets of MATCH
traversals. An AST node matches a syntax-only description
if it matches all MATCH traversals in M0 and none of the
traversals in M1.

Syntax-only vulnerability descriptions are often effective in
practice, however, as it is not possible to express attacker
control nor the interaction of statements, they often produce a
high number of false positives. In the next section, we discuss
descriptions based on control ﬂow that tackle this problem
partially.

C. Control-Flow Vulnerability Descriptions

By using the control ﬂow edges of the code property graph,
a wider range of vulnerabilities becomes accessible as we can
model statement execution order. In particular, vulnerabilities
corresponding to paths in the control ﬂow graph, such as the
following, can be described well.
• Resource leaks. Many vulnerabilities exist where re-
sources are allocated which are not properly deallocated
on all error paths. In typical cases, this leads to a system
becoming unavailable, however, it can also be used to
trigger further vulnerabilities.
• Failure to release locks. While concurrency issues in
the general case are hard to detect, simple control ﬂow
analysis can be used to detect cases where a lock is not
released on an error path.
• Use-after-free vulnerabilities. Software defects where
code accesses an already released memory region are of-
ten exploitable for arbitrary code execution. While these
vulnerabilities often result from complicated interactions
of several seemingly unrelated functions, simple control
ﬂow analysis can sufﬁce to identify these vulnerabilities
within a function.

In all three cases, a vulnerability can be associated with a
speciﬁc path in the control ﬂow graph. For example, resource
leaks are tied to a path in the control ﬂow graph leading from a
statement attaining memory (e.g., a call to malloc) to the end of
the function without passing through a statement that releases
the resource (e.g., a call to free). However, the path is only
relevant if the allocation function returns a pointer to allocated

596

source

memory and thus we need to attach additional constraints to
paths in the control ﬂow graph. We capture these observations
in the following deﬁnition.
Deﬁnition 5. A control-ﬂow vulnerability description is
cnd, ti)}i=1...N ) where Ssrc
a 4-tuple (Ssrc,Send,Sdst,{(S i
is
statements, Send
syntax-only description for
a
for end-statements, Sdst
for destination statements and
cnd, ti)}i=1...N is a list of syntax-only descriptions for
{(S i
conditions and associated outcomes ti ∈ {true, false}. A
node v matches a control-ﬂow vulnerability description if the
following conditions hold:
• The AST rooted at v contains a subtree with the root
node vsrc that matches Ssrc.
• There exists a path in the control ﬂow graph from vsrc to
a node matching Send that does not lead through a node
matching Sdst.
• For all 1 ≤ i ≤ N, if a node matches the description
S i
cnd, all edges of the path originating from the node
must be labeled as ti.

Control-based vulnerabilities can be expressed using a
traversal which performs a depth-ﬁrst search to ﬁnd all paths
from a given set of source nodes to end-nodes which do not
lead through nodes matching the destination description and
adhere to the condition description and associated outcomes.
A formal deﬁnition of this traversal is omitted for brevity.

Unfortunately, control ﬂow and syntactical

information
alone are usually not sufﬁcient to specify vulnerability patterns
as one is particularly interested in tracking the ﬂow of attacker
controlled data as we discuss in the next section.

D. Taint-Style Vulnerability Descriptions

Finally, we combine syntax, control and data ﬂow infor-
mation to model vulnerabilities. Compared to syntax-only and
control-ﬂow vulnerability descriptions, we gain the additional
capability to model attacker control using data ﬂow edges.

As each statement node contains incoming data ﬂow edges
from all assignments and variable deﬁnitions reaching it, we
can easily traverse to all statements producing variables used
by a statement simply by following these edges. However, a
small difﬁculty arises as only statement nodes are connected by
data ﬂow edges and thus if, for example, we want to traverse
from an argument of a function call to its data producers,
we must ﬁrst traverse to the enclosing statement. Fortunately,
this can easily be achieved using the traversal STATEMENT
formally deﬁned in Appendix IX-B. The producers of variables
for a set of nodes can then be calculated using the traversal

(cid:2)
n∈N

PRODUCERSN =

INsymbol,n

D

◦ STATEMENT

where N is a set of identiﬁers of interest, allowing us to restrict
analysis to a subset of the variables used by a statement. For
convenience, we also deﬁne the traversal SOURCES to describe
all statements producing data for any of the variables used by
a statement.

SOURCES is a valuable traversal as it can be combined
with syntax-only descriptions for sensitive operations and data

sources to identify cases where attacker-controlled data is used
by a sensitive operation. For example, a common incarnation
of buffer overﬂows in the Linux kernel is that a user-provided
integer produced by the function get user is directly used
as a size-ﬁeld in a memcpy operation. We can formulate the
following traversal to identify such vulnerabilities:

MATCHp ◦ SOURCES ◦ ARG3

memcpy

where p is a predicate returning true if a node represents a call
to get user, i.e., we traverse to all calls to get user directly
producing third arguments of memcpy. In addition, the traversal
SOURCES can be chained an arbitrary number of times to
identify cases where arguments are only indirectly generated
by the attacker-controlled source.

A weakness of this formulation is that it does not account
for data sanitization and thus, even cases are returned where
data is checked to ensure that it is not harmful. A possibility
to account for sanitizers is to introduce additional syntax-only
descriptions, however, this does not take into account the order
of statements, making it impossible to detect whether a check
is placed correctly. We address this deﬁciency by using a
combination of control and data ﬂow information. In particular,
we are interested in creating a traversal providing the same
functionality as SOURCES, but additionally allowing a syntax-
only description for sanitizers to be supplied.

We deﬁne the traversal UNSANITIZED3 as a drop-in re-
placement for SOURCES which additionally allows symbol-
speciﬁc syntax-only sanitizer descriptions S s
val for symbols s
to be supplied to exclude all properly sanitized cases. The
traversal returns attacker-controlled sources only if they meet
the following two conditions.
• There exists a path from the source statement to the sink
statement in the control ﬂow graph such that no node on
the path matches any of the sanitizer descriptions.
• A variable deﬁned by the source and used by the sink
the

reaches the sink via the control ﬂow path,
i.e.,
variable is not redeﬁned by any node on the path.

Combining syntax-only descriptions and the UNSANITIZED
traversal, we deﬁne taint-style vulnerability description as
follows.
Deﬁnition 6. A taint-style vulnerability description is a 3-tuple
(Ssrc,Sdst,S s
san) given by a syntax-only description Ssrc for
attacker-controlled sources, for security sensitive sinks (Sdst)
and a set of syntax-only descriptions for sanitizers (S s
san). A
node v matches a taint-style description if the AST rooted at v
contains a subtree with the root node vsource that matches Ssrc
and another subtree rooted at vsink matching Sdst and
• there exists a path of data dependency edges from vsource
to vsink, i.e., a sequence of nodes (v0, . . . , vn) exists such
that v0 = vsource, vn = vsink, ei = (vi, vi+1) ∈ E and
λ(ei) = D for all i = 0, . . . , n − 1.
for each of these data dependency edges ei = (vi, vi+1),
there exists a path (v0, . . . , vm) in the control ﬂow graph
from vi to vi+1 such that for all k, 0 ≤ k ≤ m, vk

•

3A formal deﬁnition of UNSANITIZED is given in Appendix IX-E

does not deﬁne μ(ei, symbol) and vk does not match
the sanitizer description S μ((vi,vi+1),symbol)

.

san

integer type vulnerabilities,

Taint-style descriptions are well suited to deﬁne traversals
for vulnerabilities that can be described by a validated source-
sink system [see 18]. Examples for these types of vulnera-
bilities are injection vulnerabilities, buffer overﬂows, integer
overﬂows,
insecure arguments,
missing permission checks and even memory disclosure. The
following examples illustrate this.
• Buffer overﬂow vulnerabilities. As discussed to motivate
ﬂow-based descriptions, many buffer overﬂows are the
result of insufﬁcient validation of length ﬁelds passed
to copy operations. For example, in Linux kernel code,
many buffer overﬂows result from size ﬁelds read by
the function get user and passed as a third argument to
memcpy or copy from user without undergoing valida-
tion. This vulnerability pattern can be expressed by a
traversal such as:

ARG

1

get user ◦ UNSANITIZED{Ts} ◦ ARG

3
memcpy

This traversal selects all third arguments to memcpy
directly tainted by ﬁrst arguments to get user not being
validated by a node matching the traversal Ts, e.g.,
a match traversal matching relational expressions in-
volving the tracked variable s. Traversal of this type
can easily be extended to include arguments tainted
indirectly, by chaining UNSANITIZED traversals.
• Code injection vulnerabilities. Vulnerabilities such as
SQL and command injection can be described well using
taint-style descriptions. For example, a typical command
injection vulnerability allowing an attacker to execute
arbitrary shell commands could be described using a
traversal such as:

ARG

2

recv ◦ UNSANITIZED{Ts} ◦ ARG

1
system

where Ts is a traversal matching comparisons to semi-
colons and calls to well known validation functions. This
traversal returns all cases where a second argument to
recv reaches a ﬁrst argument to system without checking
whether it contains a semicolon.
• Missing permission checks. Both web application and
kernel code commonly need to check user permissions
before executing an operation and failure to do so allows
privileges to be escalated [see 27, 44]. Vulnerabilities of
this type can be expressed as follows:

MATCHp1 ◦ UNSANITIZED{MATCHp2} ◦ MATCHp3

where p1, p2 and p3 are predicates describing attacker-
controlled sources, checks to ensure the user has suf-
ﬁcient permissions and security sensitive operations,
respectively.

Taint-style descriptions allow us to describe attacker con-
trolled sources, security sensitive operations, sanitizers, type
information and even the interplay of statements in terms of
data and control ﬂow. This enables us to provide search queries
covering a wide range of vulnerabilities. In the next section,

597

we present an evaluation of our approach, showing that the
types of vulnerabilities covered are indeed relevant for today’s
security-critical code.

VI. EVALUATION

We proceed to evaluate the practical efﬁcacy of our approach
on the source code of the Linux kernel, a large code base
that is regularly audited for vulnerabilities by several software
vendors and the open-source community. Our evaluation is
carried out in two steps: ﬁrst, we conduct a coverage analysis
by reviewing the code of all vulnerabilities reported for the
Linux kernel in 2012 and determining which vulnerability
types can be modeled using graph traversals (Section VI-B).
Second, we study the ability of our approach to discover
vulnerabilities by constructing traversals for prevalent vulner-
abilities and applying them to the code property graph of the
Linux kernel (Section VI-C).

A. Implementation

For our evaluation we implement a static code analysis
system based on the idea of code property graphs4. Our system
employs a robust C/C++ parser to ﬁrst extract ASTs for each
function in a given code base. We then transform these ASTs
into CFGs and PDGs and merge all three representations to a
code property graph as outlined in Section IV. Additionally, we
introduce nodes for global variables and structure declarations
in the code. We ﬁnally link together the graphs of all functions
based on visible caller-callee relationships, thus representing
the entire code base as one large code property graph.

For the source code of the Linux kernel, we obtain a
graph with 52 million nodes and 87 million edges. Obviously,
mining information in such a large graph on commodity
hardware is far from being a trivial task. Fortunately, we can
make use of specialized graph databases that are capable of
providing efﬁcient access to very large property graphs (we
employ Neo4J Version 1.9.5). Moreover, these graph databases
allow us to beneﬁt from sophisticated caching algorithms that
accelerate traversals over the graph.

Using a prototype implementation,

importing the Linux
kernel version 3.10-rc1 with approximately 1.3 million lines
of code takes a total of 110 minutes on a laptop computer with
a 2.5 GHz Intel Core i5 CPU and 8 GB of main memory. The
resulting database requires 14 GB of disk space for nodes and
edges as well as another 14 GB for efﬁcient indexing.

For implementing graph traversals, we ﬁnd Gremlin to be a
well suited graph language, as it allows user-deﬁned traversals
to be chained and provided to the database, thus implementing
a mechanism similar to stored procedures in SQL databases.
This enables us to convert the different traversals presented in
Section V directly to Gremlin code. Furthermore, Gremlin is
one of the few languages interfacing with databases over the
compatibility layer Blueprints, thereby enabling us to run all
crafted traversals against other graph database implementations
without modiﬁcation.

4http://mlsec.org/joern/

598

Running the traversals for vulnerability discovery presented
in this paper takes under 40 seconds on a cold database, i.e.,
when database contents needs to be read from hard disk. Once
nodes and edges are cached in main memory, execution time
reduces to 30 seconds where the vast majority of time is spent
to determine viable control ﬂow paths in large functions using
the traversal UNSANITIZED.

B. Coverage Analysis

We begin our analysis by querying the central vulnerability
database maintained by the MITRE organization for all CVE
identiﬁers allocated to vulnerabilities in the Linux kernel in
2012. In total we retrieve 69 identiﬁers addressing 88 unique
vulnerabilities in the source code of the kernel. To categorize
these vulnerabilities into different types we manually inspect
the patches for each of the vulnerabilities and determine the
root-cause of the reported ﬂaw. With this information we are
able to assign the 88 vulnerabilities to 12 common types as
shown in Table I. More than half of the vulnerabilities (47
out of 88) are either memory disclosures, buffer overﬂows or
resource leaks—all of which can be expressed well using graph
traversals as discussed in Section V.

To assess the coverage of our approach, we analyze which
code representations are necessary to describe the 12 vulner-
ability types discovered in the Linux kernel. In particular, we
analyze the coverage of (a) an AST alone, (b) the combination
of an AST and PDG, (c) the combination of an AST and CFG,
and (d) the combination of an AST, PDG and CFG. The results
of this analysis are presented in Table II.

Vulnerability types

Code representations

AST

AST+PDG

AST+CFG

AST+CFG+PDG

Memory Disclosure
Buffer Overﬂow
Resource Leaks
Design Errors
Null Pointer Dereference
Missing Permission Checks
Race Conditions
Integer Overﬂows
Division by Zero
Use After Free
Integer Type Issues
Insecure Arguments

(cid:2)

((cid:2))

(cid:2)

(cid:2)

(cid:2)

(cid:2)

((cid:2))
(cid:2)

(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
(cid:2)
((cid:2))
(cid:2)
(cid:2)

TABLE II: Coverage of different code representation for
modeling vulnerability types.

Obviously, the AST alone provides only little information
for spotting security ﬂaws and thus only some forms of
insecure arguments, e.g. incorrect type casts, can be discovered
using this representation. By combining the information from
the AST and PDG, we obtain a better view of the code and can
describe different classes of buffer overﬂows, missing permis-
sion checks and divisions by zero. However, the combination
of an AST and PDG is of limited use in cases where the order
of statements matters, for example, when the location of a
security check needs to be determined. The combination of an
AST and CFG also misses some vulnerabilities, since most

Vulnerability types
Memory Disclosure
Buffer Overﬂows
Resource Leaks
Design Errors
Null Pointer Dereference
Missing Permission Checks
Race Conditions
Integer Overﬂows
Division by Zero
Use After Free
Integer Type Vulnerabilities
Insecure Arguments
Total vulnerabilities

Description
A structure is copied to user space and not all ﬁelds or padding bytes are properly initialized resulting in memory disclosure.
A length ﬁeld involved in a copy operation is not checked resulting in buffer overﬂows.
A function creates a resource, but it is not destroyed on all error paths.
Program design does not sufﬁciently implement security policies.
A pointer controlled by an attacker is dereferenced without checking whether it is null.
A security sensitive operation can be accessed without undergoing a prior permission check.
Concurrently running processes cause various types of vulnerabilities.
A length ﬁeld involved in a copy operation is checked, but the check is insufﬁcient as integer overﬂows are not accounted for.
An attacker-controlled value is a denominator in a division and it is allowed to be zero.
An allocated block of memory is used after being freed by the allocator.
A length ﬁeld involved in a copy operation is checked, but the check is insufﬁcient as the length ﬁeld is a signed integer.
Passing arguments to a function results in an implicit, insecure type cast.

#
21
16
10
10
8
6
6
3
3
3
1
1

88

TABLE I: Vulnerabilities discovered in the Linux kernel in 2012 sorted by vulnerability type.

vulnerability types require the ﬂow of attacker-controlled data
to be modeled. Still, resources leaks and some use-after-free
vulnerabilities can be identiﬁed from the ﬂow of statements
encoded in a CFG.

By combining all three representations in a code property
graph, we are ﬁnally able to model 10 of the 12 vulnerability
types, making use of information available from the AST, CFG
and PDG. The two remaining types, race conditions and design
errors, are hard to express using graph traversals, as the ﬁrst
depends on runtime properties and the second is difﬁcult to
model without details on the intended design of a program.
Moreover, there exist many contrived cases of use-after-free
vulnerabilities that are difﬁcult to describe without runtime
information. We provide a discussion of the limitations of our
approach in Section VII.

C. Discovery of Vulnerabilities

Graph traversals over code property graphs are well suited
to describe many vulnerability types, however, it remains to
be shown that they are effective in practice. To this end, we
practically evaluate our method by mining the code property
graph of the Linux kernel using traversals for different kinds
of vulnerabilities.

We begin by specifying traversals for the two most common
vulnerability types encountered in 2012, buffer overﬂows due
to missing bounds checks and memory disclosures caused
by incompletely initialized structures. We proceed to build
traversals for types of vulnerabilities not encountered in 2012,
namely memory mapping vulnerabilities and zero-byte alloca-
tions, both of which are types of vulnerabilities very speciﬁc
to the Linux kernel and thus hard to spot with conventional
tools. In summary, we used the following traversals in our
experiments.
• Buffer overﬂows. We construct a traversal for buffer
overﬂows resulting from missing checks on attacker
controlled length ﬁelds. This traversal is discussed in
detail in Section VI-D.
• Memory disclosures. The largest number of security
critical ﬂaws found in the Linux kernel in 2012 are
caused by improperly initialized structures copied to user
space. These ﬂaws can be used by attackers to leak
sensitive objects stored in kernel memory. To identify

these vulnerabilities, we construct a taint-style traversal
from local declarations of structures to operations copy-
ing to user space which do not pass through memset.
Moreover, we lookup the structure type and use a syntax-
only description to determine whether all ﬁelds of the
structure are assigned to.
• Memory mapping. The kernel must ensure that users
cannot map arbitrary physical memory addresses to user
space in order to prevent leaking of conﬁdential informa-
tion and arbitrary code execution. This is a vulnerability
type which is very speciﬁc to kernels. We formulate a
simple syntax-only vulnerability description to identify
these vulnerabilities, showing that our method can be
adapted well to program-speciﬁc bugs.
• Zero-byte allocations. Cases where an attacker can cause
an allocation function to receive a length ﬁeld of zero
bytes often lead to crashes in the Linux kernel as many
of its allocation functions return error-codes instead of
allocated memory. This is uncommon when compared
to other allocators and thus represents a rather program-
speciﬁc vulnerability. We cover these cases with a taint-
style traversal.

Overall, by running the four traversals, we identiﬁed 18
previously unknown vulnerabilities, all of which have been
addressed by kernel developers. It is particularly alarming to
see that 9 out of the total of 18 vulnerabilities are vulnerability
types prevalent in the last year. This shows that it can be suf-
ﬁcient for attackers to model existing vulnerability patterns to
effectively ﬁnd similar ﬂaws in the code base using traversals.
Table III summarizes our ﬁndings.

We now proceed to discuss a case study to illustrate the
vulnerability discovery process using graph traversals, showing
how a simple traversal allowed us to identify seven previously
unknown buffer overﬂow vulnerabilities while reviewing only
eleven functions.

D. Case Study: Buffer Overﬂow Identiﬁcation

In the following, we present a traversal to identify buffer
overﬂows caused by missing validation checks on length ﬁelds.
These types of vulnerabilities can be elegantly expressed using
taint-style descriptions and hence as traversals of the form T0◦
◦ T2. To this end, we merely need to deﬁne
UNSANITIZEDT s

1

599

Type

Location

Developer Feedback

Identiﬁer

Buffer Overﬂow
Buffer Overﬂow
Buffer Overﬂow
Buffer Overﬂow
Buffer Overﬂow
Buffer Overﬂow
Buffer Overﬂow
Memory Disclosure
Memory Disclosure
Memory Mapping
Memory Mapping
Memory Mapping
Memory Mapping
Memory Mapping
Zero-byte Allocation
Zero-byte Allocation
Zero-byte Allocation
Zero-byte Allocation

arch/um/kernel/exitcode.c
drivers/staging/ozwpan/ozcdev.c
drivers/s390/net/qeth_core_main.c
drivers/staging/wlags49_h2/wl_priv.c
drivers/scsi/megaraid/megaraid_mm.c
drivers/infiniband/hw/ipath/ipath_diag.c
drivers/infiniband/hw/qib/qib_diag.c
drivers/staging/bcm/Bcmchar.c
drivers/staging/sb105x/sb_pci_mp.c
drivers/video/au1200fb.c
drivers/video/au1100fb.c
drivers/uio/uio.c
drivers/staging/.../drv_interface.c
drivers/gpu/drm/i810/i810_dma.c
fs/xfs/xfs_ioctl.c
fs/xfs/xfs_ioctl32.c
drivers/net/wireless/libertas/debugfs.c
drivers/scsi/aacraid/commctrl.c

Fixed
Fixed
Fixed
Fixed
Fixed
Fixed
Fixed
Fixed
Fixed
Fixed
Fixed
Fixed
Fixed
Fix underway
Fixed
Fixed
Fixed
Fixed

CVE-2013-4512
CVE-2013-4513
CVE-2013-6381
CVE-2013-4514
-
-
-
CVE-2013-4515
CVE-2013-4516
CVE-2013-4511
CVE-2013-4511
CVE-2013-4511
-
-
CVE-2013-6382
CVE-2013-6382
CVE-2013-6378
CVE-2013-6380

TABLE III: Zero-day vulnerabilities discovered using our four graph traversals

suitable traversals T0 for attacker controlled sources, T s
1 for
sanitizers and ﬁnally, T2 for security sensitive sinks. We begin
with the sources controlled by an attacker, which are speciﬁc
to the application under examination. For the Linux kernel, the
following two prominent sources of potentially harmful input
are considered.

• User/kernel

0 = ARG

space interfaces. Data can be copied
from user to kernel space using a number of differ-
ent API functions. As an example, we consider the
copy from user function which taints its ﬁrst argument
with data controlled by an attacker. This can be captured
using the traversal T 0
• Parameters of system call handlers. Attackers have di-
rect control over the parameters of system call handlers
by invoking the corresponding system call. We consider
count-parameters of write system calls as an example
0 = FUNC( write) ◦ PARAMcnt
and use the traversal T 1
where PARAMp and FUNCf are non-empty for pa-
rameters named p and nodes in functions with names
containing the sub-string f respectively.

1
copy from user.

As data sinks, we consider the length ﬁelds (i.e.,

third
arguments) passed to copy from user and memcpy calls as we
are interested in identifying cases where an attacker controls
the amount of data copied into a buffer. In the system call
handler case, we further restrict the analysis by analyzing only
calls to copy from user to ensure that not only the length
ﬁeld but also the copied data is under the attacker’s control.
The sink traversals are thus given by T 0
3
memcpy and
T 1
2 = ARG
Finally, we reduce the number of false positives by assuming
that a length ﬁeld is properly sanitized if at least one of the
following conditions are met.
• Dynamic allocation of the destination buffer. The desti-
nation buffer is dynamically allocated using the length
ﬁeld to specify the size of the buffer and thus the buffer
is large enough to hold the data.
• Relational expressions. The length ﬁeld is used in a
relational expression inside a condition, e.g., x <

3
copy from user.

2 = ARG

buffer size, or in a call to the macro min. Note that
such checks may be incorrect and thus this rule is a
practical example of a trade-off between false-positives
and false-negatives.
0 ,V s

Hence, we deﬁne the sanitizer traversal T s
1 =
OR(V s
0 is a match traversal matching allocations
where the ﬁrst argument contains s and V s
1 is a match traversal
matching relative expressions and calls to min containing s.
The ﬁnal traversal is then given by

1 to be T s

1 ) where V s

(cid:5) T 0
0 ◦ UNSANITIZEDT s
T 1
0 ◦ UNSANITIZEDT s

1

1

OR

(cid:6)
◦ OR(T 0
◦ T 1

2

2 ,T 1
2 ),

Running this traversal on the entire Linux source code
returns the eleven functions shown in Table IV. Of those
eleven functions, seven are buffer overﬂow vulnerabilities.
As an example, Figure 6 shows the vulnerable function
qeth snmp command. On line 13, attacker controlled data is
used to initialize the local variable req len. This variable is
used without performing sanitization on line 28 as a length-
ﬁeld of a copy-operation. An attacker can thus overﬂow the
buffer snmp possibly allowing execution of arbitrary code.

Filename

arch/um/kernel/exitcode.c
security/smack/smackfs.c
drivers/staging/ozwpan/ozcdev.c
drivers/infiniband/hw/ipath/ipath_diag.c
drivers/infiniband/hw/qib/qib_diag.c
drivers/scsi/megaraid/megaraid_mm.c
drivers/scsi/megaraid.c
drivers/char/xilinx_.../xilinx_hwicap.c
drivers/s390/net/qeth_core_main.c
drivers/staging/wlags49_h2/wl_priv.c
arch/ia64/sn/kernel/sn2/sn_hwperf.c

Function

exitcode proc write
smk write rules list
oz cdev write
ipath diagpkt write
qib diagpkt write
mimd to kioc
megadev ioctl
hwicap write
qeth snmp command
wvlan uil put info
sn hwperf ioctl

TABLE IV: The 11 functions extracted from the Linux
kernel using the graph traversal discussed in this section.
Vulnerabilities are shaded.

600

int qeth_snmp_command(struct qeth_card *card,

char __user *udata)

{

}

struct qeth_cmd_buffer *iob;
struct qeth_ipa_cmd *cmd;
struct qeth_snmp_ureq *ureq;
int req_len;
struct qeth_arp_query_info qinfo = {0, };
int rc = 0;
// [...]
/* skip 4 bytes (data_len struct member)

to get req_len */

if (copy_from_user(&req_len, udata

+ sizeof(int),sizeof(int)))

return -EFAULT;

ureq = memdup_user(udata, req_len +

sizeof(struct qeth_snmp_ureq_hdr));

if (IS_ERR(ureq)) {

QETH_CARD_TEXT(card, 2, "snmpnome");
return PTR_ERR(ureq);

}
// [...]
iob = qeth_get_adapter_cmd(card,

IPA_SETADP_SET_SNMP_CONTROL,
QETH_SNMP_SETADP_CMDLENGTH + req_len);

// [...]
memcpy(&cmd->data.setadapterparms.data.snmp,

&ureq->cmd, req_len);

rc = qeth_send_ipa_snmp_cmd(card, iob,

QETH_SETADP_BASE_LEN + req_len,
qeth_snmp_command_cb, (void *)&qinfo);

// [...]
kfree(ureq);
kfree(qinfo.udata);
return rc;

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37

Fig. 6: Buffer overﬂow vulnerability in a Linux kernel driver
found using our approach.

VII. LIMITATIONS

there exist

The discovery of several unknown vulnerabilities in the
Linux kernel clearly demonstrates the capabilities of our
approach. Nonetheless,
limitations that need to
be considered: First, our approach is purely static and thus
cannot overcome the inherent limitations of static program
analysis. While we implement control and data ﬂow tracking,
we do not interpret code, for example, to ﬁnd equivalent but
differently formulated expressions as would be possible using
symbolic execution. As a result, vulnerabilities induced by
runtime behavior, such as race conditions, cannot be modeled
using code property graphs.

Second, due to the fact that the problem of vulnerability
discovery is undecidable in the general case [33], our approach
can only spot potentially vulnerable code. In contrast
to
approaches that target a speciﬁc types of vulnerabilities, we
focus on a generic way of mining for vulnerabilities that may
not guarantee the presence of a security ﬂaw, but can identify
potentially vulnerabilities in very large software projects.

Third, our current implementation does not address inter-
procedural analysis. While we link functions according to call
relations in the graph database, formulating effective inter-
procedural traversals poses additional challenges. This is not an
inherent limitation of our approach, as inter-procedural variants
of control ﬂow graphs and program dependence graphs exist

601

in the form of inter-procedural control ﬂow graphs and system
dependence graphs [see 17]. In the future, we aim to extend
our work for inter-procedural analysis.

VIII. RELATED WORK

Scanning source code for patterns of vulnerabilities has
a long history and a number of vulnerability scanners used
in practice, such as Microsoft PREfast [23], PScan [5] or
RATS [4], have adopted this idea to ﬁnd several well-known
vulnerabilities. While these tools are valuable, in particular
during the development process, they usually fail to identify
complex and subtle vulnerabilities in code. Moreover, it is
not possible to adapt these tools to account for the speciﬁcs
of a code base. As a remedy, several researchers have since
considered to incorporate expert knowledge into methods of
static analysis. For example, Evans and Larochelle [8] describe
Splint, which allows analysts to provide annotations to ﬁnd in-
carnations of buffer overﬂows and format string vulnerabilities
in different applications. Moreover, Vanegue and Lahiri [39]
propose an extended static checker named HAVOC-Lite to
identify vulnerabilities in Microsoft COM components. Our
approach is related, yet makes a wider range of vulnerabilities
accessible at the expense of a less precise analysis.

A different branch of security research has studied query
languages for spotting vulnerabilities [e.g., 22, 25] and other
ﬂaws [e.g., 14, 15, 30] in source code. For example, Livshits
and Lam [24] construct static checkers from high-level pro-
gram descriptions formulated in the query language PQL. They
subsequently employ static taint analysis to uncover cross-
site-scripting and SQL injection vulnerabilities in Java code.
Similarly, Shankar et al. [36] make use of static taint analysis
to identify format string vulnerabilities in C programs. These
approaches are highly effective at identifying speciﬁc types
of vulnerabilities, however, they have not been shown to be
applicable to a wider range of vulnerability types, such as
memory disclosures and resource leaks. Furthermore, static
taint-analysis is inherently limited by its passive view on data
ﬂow, for example, expressions cannot be evaluated.

Dynamic approaches to program analysis such as fuzz
testing [10, 13, 42] and dynamic taint tracking [e.g., 28, 40]
have been proposed to address the deﬁciencies of static pro-
gram analysis. Unfortunately, only vulnerabilities triggered at
runtime can be found in this way and thus security ﬂaws in
unusual control paths are often not discovered. As a remedy,
several researchers have proposed to combine fuzz testing
with symbolic execution to actively guide the analysis into
exploring unusual paths. These approaches, however, are costly
and often hard to operate in practice as they suffer from the
exponential number of program paths to consider.

Finally, not directly related to vulnerability discovery, Reps
[32] pioneered the idea of performing program analysis by
solving graph reachability problems, showing that many data-
ﬂow problems as well as program slicing can be solved
by traversing graphs. Moreover, creating new representations
speciﬁcally to aid in bug ﬁnding and program understanding
has been considered by Kinloch and Munro [19]. They
present the Combined C Graph (CCG), which, in essence, is

a system-wide program dependence graph. Similarly, Krinke
and Snelting [20] present a ﬁne grained system dependence
graph that also combines syntactical as well as control and
data ﬂow information to allow precise program slices to be
calculated via constraint solving. Yet, they do not explore the
idea of describing bug or vulnerability patterns using graph
traversals as explored in this work.

IX. CONCLUSION

Providing analysts with practical means for discovery of
vulnerabilities in software is of utmost importance to secure
computer systems. In this paper, we have presented an ap-
proach for mining large amounts of code for vulnerabilities.
This approach builds on a novel representation of source code,
a code property graph,
that enables modeling patterns for
common vulnerabilities in terms of graph traversals. Using this
representation we have presented small and concise traversals
for many well-known types of vulnerabilities, including buffer
overﬂows, format string vulnerabilities and memory address
leaks. Moreover, we have audited a large code base—the
Linux kernel—with a code property graph and identiﬁed a
total of 18 previously unknown vulnerabilities in the source
code conﬁrmed and ﬁxed by the vendor.

Code property graphs and graph traversals are suitable to
ﬁnd common types of vulnerabilities but more importantly,
they can be tailored well to identify vulnerabilities speciﬁc
to a code base. By reﬁning traversals, the analyst has full
control over false-positive and false-negative rates, allowing
vague traversals to be formulated during the discovery phase
of an analysis and very precise traversals to capture instances
of well-understood types of vulnerabilities.

ACKNOWLEDGMENTS

The authors acknowledge funding from BMBF under the
project PROSEC (FKZ 01BY1145) and from DFG under the
project DEVIL (RI 2469/1-1).

REFERENCES

[1] A. Aho, R. Sethi, and J. Ullman. Compilers Principles,

Techniques, and Tools. Addison-Wesley, 1985.

[2] T. Avgerinos, S. K. Cha, B. L. T. Hao, and D. Brumley.
AEG: Automatic Exploit Generation. In Proc. of Network
and Distributed System Security Symposium (NDSS),
2011.

[3] I. D. Baxter, A. Yahin, L. Moura, M. S. Anna, and L. Bier.
Clone detection using abstract syntax trees.
In Proc.
of International Conference on Software Maintenance
(ICSM), 1998.

[4] B. Chess and M. Gerschefske.

Rough auditing
tool
Google Code, http://code.google.
com/p/rough-auditing-tool-for-security/, visited Novem-
ber, 2013.

for security.

[5] A. DeKok. Pscan: A limited problem scanner for c source
ﬁles. http://deployingradius.com/pscan/, visited February,
2013.

[6] S. Eidemiller and E. Dalci. Cwe-676: Use of potentially

dangerous function. MITRE Corporation., 2012.

602

[7] S. Esser. Mountain Lion/iOS vulnerabilities garage sale.

Presentation at SyScan Conference, 2013.

[8] D. Evans and D. Larochelle.

Improving security using
extensible lightweight static analysis. IEEE Software, 19
(1):42–51, 2002.

[9] J. Ferrante, K. J. Ottenstein, and J. D. Warren. The pro-
gram dependence graph and its use in optimization. ACM
Transactions on Programming Languages and Systems,
9:319–349, 1987.

[10] V. Ganesh, T. Leek, and M. Rinard. Taint-based directed
whitebox fuzzing. In Proc. of the International Confer-
ence on Software Engineering, 2009.

[11] H. Gascon, F. Yamaguchi, D. Arp, and K. Rieck. Struc-
tural detection of android malware using embedded call
graphs.
In Proc. of ACM CCS Workshop on Artiﬁcial
Intelligence and Security (AISEC), Nov. 2013.

[12] gera and riq. Advances in format string exploitation.

Phrack Magazine, 0x3b(0x07), 2002.

[13] P. Godefroid, M. Y. Levin, and D. Molnar.

SAGE:
whitebox fuzzing for security testing. Communications
of the ACM, 55(3):40–44, 2012.

[14] S. F. Goldsmith, R. O’Callahan, and A. Aiken. Relational
queries over program traces. In Proc. of ACM SIGPLAN
International Conference on Object-Oriented Program-
ming, Systems, Languages and Applications (OOPSLA),
2005.

[15] S. Hallem, B. Chelf, Y. Xie, and D. Engler. A system
and language for building system-speciﬁc, static analyses.
In Proc. of ACM SIGPLAN International Conference
on Programming Languages Design and Implementation
(PLDI), 2002.

[16] S. Heelan. Vulnerability detection systems: Think cyborg,
not robot. IEEE Security & Privacy, 9(3):74–77, 2011.
[17] S. Horwitz, T. Reps, and D. Binkley. Interprocedural slic-
ing using dependence graphs. In Proc. of ACM SIGPLAN
International Conference on Programming Languages
Design and Implementation (PLDI), pages 35–46, 1988.
[18] N. Jovanovic, C. Kruegel, and E. Kirda. Pixy: A static
analysis tool for detecting web application vulnerabilities.
In Proc. of IEEE Symposium on Security and Privacy,
pages 6–263, 2006.

[19] D. A. Kinloch and M. Munro. Understanding C programs
using the combined C graph representation.
In Proc.
of International Conference on Software Maintenance
(ICSM), 1994.

[20] J. Krinke and G. Snelting. Validation of measurement
software as an application of slicing and constraint solv-
ing. Information and Software Technology, 40(11):661–
675, 1998.

[21] J. A. Kupsch and B. P. Miller. Manual vs. automated
vulnerability assessment: A case study.
In Proc. of
Workshop on Managing Insider Security Threats (MIST),
pages 83–97, 2009.

[22] M. S. Lam, J. Whaley, V. B. Livshits, M. C. Martin,
D. Avots, M. Carbin, and C. Unkel. Context-sensitive
program analysis as database queries. In Proc. of Sym-
posium on principles of database systems, 2005.

[23] J. R. Larus, T. Ball, M. Das, R. DeLine, M. F¨ahndrich,

J. Pincus, S. K. Rajamani, and R. Venkatapathy. Righting
software. IEEE Software, 21(3):92–100, 2004.

[24] V. B. Livshits and M. S. Lam. Finding security vulnera-
bilities in java applications with static analysis. In Proc.
of USENIX Security Symposium, 2005.

[25] M. Martin, B. Livshits, and M. S. Lam. Finding ap-
plication errors and security ﬂaws using pql: Program
query language. In Proc. of ACM SIGPLAN International
Conference on Object-Oriented Programming, Systems,
Languages and Applications (OOPSLA), 2005.

[26] H. Moore. Security ﬂaws in universal plug and play:

Unplug. don’t play. Technical report, Rapid 7, 2013.

[27] D. Muthukumaran, T. Jaeger, and V. Ganapathy. Lever-
aging choice to automate authorization hook placement.
In Proc. of ACM conference on Computer and Commu-
nications Security, 2012.

[28] J. Newsome and D. Song. Dynamic taint analysis for
automatic detection, analysis, and signature generation of
exploits on commodity software. In Proc. of Network and
Distributed System Security Symposium (NDSS), 2005.

[29] J. W. Oh. Recent Java exploitation trends and malware.

Presentation at Black Hat Las Vegas, 2012.

[30] S. Paul and A. Prakash. A framework for source code
IEEE Transactions on

search using program patterns.
Software Engineering, 1994.

[31] C. Planet. A eulogy for format strings. Phrack Magazine,

0x43(0x09), 2010.

[32] T. Reps. Program analysis via graph reachability. Infor-

mation and Software Technology, 1998.

[33] H. G. Rice. Classes of recursively enumerable sets and
their decision problems. Transactions of the American
Mathematical Society, 74:358–366, 1953.

[34] M. A. Rodriguez and P. Neubauer. The graph traversal
pattern. Graph Data Management: Techniques and Ap-
plications, 2011.

[35] E. Schwartz, T. Avgerinos, and D. Brumley. All you ever
wanted to know about dynamic taint analysis and forward
symbolic execution (but might have been afraid to ask).
In Proc. of IEEE Symposium on Security and Privacy,
pages 317–331, 2010.

[36] U. Shankar, K. Talwar, J. S. Foster, and D. Wagner. De-
tecting format string vulnerabilities with type qualiﬁers.
In Proc. of USENIX Security Symposium, pages 201–218,
2001.

[37] S. Sparks, S. Embleton, R. Cunningham, and C. C. Zou.
Automated vulnerability analysis: Leveraging control
ﬂow for evolutionary input crafting. In Proc. of Annual
Computer Security Applications Conference (ACSAC),
pages 477–486. IEEE Computer Society, 2007.

[38] M. Sutton, A. Greene, and P. Amini. Fuzzing: Brute
Force Vulnerability Discovery. Addison-Wesley Long-
man, 2007.

[39] J. Vanegue, L. Bloomberg, and S. K. Lahiri. Towards
practical reactive security audit using extended static
checkers. In Proc. of IEEE Symposium on Security and
Privacy, 2013.

[40] T. Wang, T. Wei, Z. Lin, and W. Zou. IntScope: Auto-
matically detecting integer overﬂow vulnerability in x86

binary using symbolic execution. In Proc. of Network and
Distributed System Security Symposium (NDSS), 2009.

[41] M. Weiser. Program slicing.

In Proc. of International

Conference on Software Engineering, 1981.

[42] M. Woo, S. K. Cha, S. Gottlieb, and D. Brumley.
In Proc. of
Scheduling blackbox mutational fuzzing.
ACM Conference on Computer and Communications
Security (CCS), 2013.

[43] F. Yamaguchi, M. Lottmann, and K. Rieck. Generalized
vulnerability extrapolation using abstract syntax trees. In
Proc. of Annual Computer Security Applications Confer-
ence (ACSAC), pages 359–368, Dec. 2012.

[44] F. Yamaguchi, C. Wressnegger, H. Gascon, and K. Rieck.
Chucky: Exposing missing checks in source code for
vulnerability discovery. In Proc. of ACM Conference on
Computer and Communications Security (CCS), 2013.

[45] M. Zitser, R. Lippmann, and T. Leek. Testing static anal-
ysis tools using exploitable buffer overﬂows from open
source code.
In Proc. of ACM SIGSOFT International
Symposium on Foundations of Software Engineering SIG-
SOFT FSE, pages 97–106, 2004.

A. The Traversal TNODES

APPENDIX

The traversal TNODES is used to identify all child nodes
of the ASTs rooted at any of the nodes in the set X. This
⎞
⎞
traversal can be formally deﬁned as
⎠
⎠ .

⎛
⎝ (cid:2)

TNODES({vc})

⎛
⎝v ∪

TNODES(X) =

(cid:2)
v∈X

vc∈OUTA({v})

The recursive deﬁnition is based entirely on the elementary
traversal OUTl applied on AST edges (labeled as A) and
simply states that the nodes contained in a tree are given by
the node itself and the nodes contained in its subtrees.

B. The Traversals STATEMENT and FUNCTION

Statement nodes are the central connecting points between
the three views on the code offered by the code property
graph. In consequence, it is often necessary to traverse from
an arbitrary non-statement node to the statement that encloses
it. To this end, we introduce the traversal STATEMENT, as used
in Section V-D, to determine statement nodes for all nodes in
a set X:

(cid:2)
v∈X

s({v})

STATEMENT(X) =
(cid:11)

where

s(X) =

X1,

s(INA(X)),

if μ( X1, code) = Stmt
otherwise

and X1 denotes the only member of the set X. This traversal
follows incoming AST edges until a node of type Stmt is
reached. A similar deﬁnition can be given for a traversal
FUNCTION to reach the function enclosing the statement, sim-
ply by traversing to parent nodes until an enclosing function
node is found.

603

C. PAIRS and PAIRFILTER

E. The Traversal UNSANITIZED

Finally, we give a formal deﬁnition of

the traversal
UNSANITIZEDM, the core ingredient for taint-style vulnera-
bility descriptions. This traversal follows outgoing control ﬂow
edges in a depth-ﬁrst manner and terminates at a node if it is a
destination node or any of the following three conditions hold:
(1) the node matches any of the sanitizer descriptions from M
or (2) the node assigns to the tracked symbol, thus overwriting
it or (3) the node has been visited twice already.
To capture these termination criteria, we deﬁne the predicate
psM(v,V) to be true if for any 0 ≤ i ≤ |M|−1, Mi({v}) (cid:8)= ∅,
i.e., v matches Mi or FILTER(μ(v,code)=s)◦DEFINES({v}) (cid:8)= ∅,
i.e., v assigns to symbol s. Moreover, we maintain a multi-set
V to keep track of the number of times a node has been visited,
and thus psM(v,V) is also true if V(v) = 2.
We proceed to deﬁne the function u(v, d)sM to denote all
paths in the control ﬂow graph from the source node v to the
destination node d which do not undergo validation by M and
do not re-deﬁne the symbol s as

g(v, d,V, p)sM =

where g is deﬁned recursively as
{p : v}
∅

if v = d
if v (cid:8)= d ∧ p (cid:8)= []
∧ psM(v)
h(v, d,V, p)sM otherwise

u(v, d)sM = g(v, d,∅, [])sM
⎧⎪⎨
⎪⎩
and h(v, d,V, p)sM =
In this deﬁnition, OUTC(v) denotes the nodes connected to
v via outgoing control ﬂow edges, V is a multi set used to
record the number of times a node has been visited and p
is the path traversed so far. The function u simply initializes
the latter two variables to be an empty set and an empty list
respectively and references the recursive deﬁnition g which
implements the depth-ﬁrst traversal. Finally, we can deﬁne the
function UPATH which calculates u over all symbols used by
a statement as

g(vc, d,V (cid:12) v, p : v)sM.

vc∈OUTC({v})

(cid:16)

(cid:2)

(cid:2)

UPATHM(d) =

u(src, d)sM

s∈USES({d})

where S(s, d) = PRODUCERS{s}({d}), and ﬁnally
UNSANITIZEDM(X) = FIRST ◦

src∈S(s,d)
(cid:2)

UPATHM(d)

d∈STATEMENT(X)

which calculates UPATH for all elements of the set X and
extracts the start node of each path using the traversal FIRST.
In practice, it is often sufﬁcient to determine only if an
unsanitized path exists at all so our implementation terminates
calculation of UPATH when one of the paths has been found.
Moreover, UNSANITIZED can be further optimized by allowing
a vague source description to be passed to S, thus reducing the
number of source/sink-pairs considered by u. Finally, a trade-
off between precision and required computation time can be
made by performing depth ﬁrst search only up to a maximum
path length.

Comparing two subtrees of an AST is a reoccurring problem
when formulating traversals for vulnerabilities. To this end, we
T2T1 for two traversals T1 and T2 as
(cid:2)
deﬁne the function PAIRS
v∈X

{(T1({v}),T2({v})}

(X) =

PAIRS

T2T1

as well as the corresponding function
PAIRFILTERp(X) = {(v1, v2) : (v1, v2) ∈ X and p(v1, v2)}
to obtain all pairs (v1, v2) of abstract syntax trees where the
criterion p(v1, v2) is true.

D. Traversals for Type Information

The code property graph as described in Section IV already
allows the types of variables to be determined from the abstract
syntax tree using a traversal such as the following

TYPEs = TYPENODE ◦ FILTERps

◦ TNODES

where ps(v) is true if v is an identiﬁer or parameter declaration
for the symbol s and TYPENODE traverses to the type node of
an identiﬁer or parameter declaration. However, in practice, we
augment an additional graph structure onto the code property
graph to provide quick access to the deﬁnition of variables
and the symbols used by a statement. As constructing the
program dependence graph from the control ﬂow graph already
requires the symbols used and deﬁned by all statements to
be calculated, we make this information explicit in a function
symbol graph.

A function symbol graph GS = (VS, ES, λS, μS) is a
property graph where VS contains an attributed node for each
symbol used by the function. The function μS adds a property
named code to each of the nodes holding its corresponding
symbol. The sets of property keys and values are subsets of
the respective sets of the AST. Moreover, the edge set ES
contains an edge from each statement to each symbol used or
deﬁned by the statement, labeled by the edge labeling function
λS : ES → ΣS as D and U respectively.
traversals we have found to be useful in our work.

The function symbol graph allows us to deﬁne the following
• DEFINES. The DEFINES traversal

DEFINES(V ) = OUTD(V )

transforms a node to the nodes of all symbols it deﬁnes.
• USES. This traversal transforms nodes to all symbols

used

USES(V ) = OUTU (V )

• TYPEs. The traversal TYPEs can be used to determine
the type of a local symbol s starting from an AST node:

TYPEs = TYPENODE ◦ FILTERps ◦ IND ◦ USES

where ps(v) is true if v is an identiﬁer or parameter
declaration node of symbol s and false otherwise.

Equipped with these traversals, it becomes easier to express

the UNSANITIZED traversal presented in the next section.

604

