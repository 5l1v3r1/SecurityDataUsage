Outsourced Symmetric Private Information Retrieval

Stanislaw Jarecki
U. California Irvine
stasio@ics.uci.edu

Charanjit Jutla
IBM Research

csjutla@us.ibm.com

Hugo Krawczyk

IBM Research

hugo@ee.technion.ac.il

Marcel Rosu
U. California Irvine

marcelrosu@gmail.com

ABSTRACT
In the setting of searchable symmetric encryption (SSE), a
data owner D outsources a database (or document/ﬁle col-
lection) to a remote server E in encrypted form such that
D can later search the collection at E while hiding informa-
tion about the database and queries from E . Leakage to E
is to be conﬁned to well-deﬁned forms of data-access and
query patterns while preventing disclosure of explicit data
and query plaintext values. Recently, Cash et al. presented
a protocol, OXT, which can run arbitrary boolean queries
in the SSE setting and which is remarkably eﬃcient even for
very large databases.

In this paper we investigate a richer setting in which the
data owner D outsources its data to a server E but D is
now interested to allow clients (third parties) to search the
database such that clients learn the information D autho-
rizes them to learn but nothing else while E still does not
learn about the data or queried values as in the basic SSE
setting. Furthermore, motivated by a wide range of appli-
cations, we extend this model and requirements to a setting
where, similarly to private information retrieval, the client’s
queried values need to be hidden also from the data owner
D even though the latter still needs to authorize the query.
Finally, we consider the scenario in which authorization can
be enforced by the data owner D without D learning the
policy, a setting that arises in court-issued search warrants.
We extend the OXT protocol of Cash et al. to support
arbitrary boolean queries in all of the above models while
withstanding adversarial non-colluding servers (D and E )
and arbitrarily malicious clients, and while preserving the
remarkable performance of the protocol.

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for prof t or commercial advantage and that copies bear this notice and the full cita-
tion on the f rst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior specif c permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’13, November 4–8, 2013, Berlin, Germany.
Copyright 2013 ACM 978-1-4503-2477-9/13/11 ...$15.00.
http://dx.doi.org/10.1145/2508859.2516730.

Michael Steiner

IBM Research

msteiner@us.ibm.com

1.

INTRODUCTION

Consider a database DB composed of collection of docu-
ments or records and an application that needs to search DB
based on the keywords contained in these records. For exam-
ple, DB can be a medical relational database with records
indexed by a set of attributes (e.g., name, zipcode, medi-
cal condition, etc.), an email repository indexed by English
words and/or envelope information (date, sender, receivers,
etc.), a collection of webpages indexed by text and metadata,
etc. A search query consists of a boolean expression on key-
words that returns all documents whose associated keywords
satisfy that expression. In this paper we are concerned with
applications where the database is outsourced to an exter-
nal server E and search is performed at E privately. That is,
E stores an encrypted version of the original database DB
(plus some metadata) and answers encrypted queries from
clients such that the client obtains the documents matching
his query without E learning plaintext information about
the data and queries.

The most basic setting of private data outsourcing as de-
scribed above is where the owner of the data itself, D, is the
party performing the search at E . In this setting, D initially
processes DB into an encrypted database EDB and sends it
to E . D only keeps a set of cryptographic keys that allows
her to later run encrypted searches on E and decrypt the
matching documents returned by E . This setting is known as
searchable symmetric encryption (SSE) and has been stud-
ied extensively [29, 15, 16, 10, 13, 11, 24]. While most of the
research has focused on single-keyword searches (i.e., return
all documents containing a given keyword), recently Cash
et al. [9] provided the ﬁrst SSE solution, the OXT protocol,
that can support in a practical and private way arbitrary
boolean queries on sets of keywords and in very large DBs.
The leakage to E , which is formally speciﬁed and proven in
[9], is in the form of data-access and query patterns, never
as direct exposure of plaintext data or searched values.

In this work we are concerned with richer outsourcing sce-
narios where multiple third parties (clients) access the data
at E but only through queries authorized by the data owner
D. For example, consider a hospital outsourcing an (en-
crypted) database to an external service E such that clients
(doctors, administrators,
can
search the database but only via queries authorized accord-
ing to the hospital’s policy and without these clients learn-
ing information on non-matching documents. As before, E
should learn as little as possible about data and queries.

insurance companies, etc.)

In this multi-client scenario (to which we refer as MC-
SSE), D provides search tokens to clients based on their

875queries and according to a given authorization policy. Se-
curity considers multiple clients acting maliciously and pos-
sibly colluding with each other (trying to gain information
beyond what they are authorized for) and a semi-trusted
server E which acts as “honest-but-curious” but does not
collude with clients. Extending SSE solutions to the multi-
client scenario is straightforward when (a) search tokens are
fully determined by the query and (b) the SSE protocol does
not return false positives (returning false positives, i.e. doc-
uments that do not match a query, is allowed in SSE since
the recipient in that case is the owner of the data but not
in the multi-client setting where clients are not allowed to
learn data they were not authorized for). In such cases, D
would receive the client’s query, generate the corresponding
SSE search tokens as if D herself was searching the database,
and provide the tokens to the client together with a signa-
ture that E can check before processing the search. However,
for enabling general boolean queries, the SSE OXT protocol
of [9] requires a number of tokens that is not known a-priori
(it depends on the searched data, not only on the query) and
therefore the above immediate adaptation does not work.

Our ﬁrst contribution is in extending the OXT protocol
from [9] to the MC-SSE setting while preserving its full
boolean-query capabilities and performance. In this exten-
sion, D provides the client C with a set of query-speciﬁc trap-
doors which the client can then transform into search tokens
as required by OXT. The set of trapdoors given to C is fully
determined by the query and independent of the searched
data. An additional subtle technical challenge posed by
OXT is how to allow E to verify that the search tokens pre-
sented by C are authorized by D. The simple solution is for
D to sign the trapdoors, however in OXT these trapdoors
need to be hidden from E (otherwise E can learn information
about unauthorized searches) so a simple signature on them
cannot be veriﬁed by E . Our solution uses a homomorphic
signature by D on the trapdoors that C can then transform
homomorphically into signatures on the search tokens. We
show that forging the tokens or their signatures is infeasible
even by fully malicious clients.

The resulting MC-OXT protocol preserves the full func-

tional properties of OXT, namely support for arbitrary boolean
queries, the same level of privacy (i.e., same leakage pro-
ﬁle) with respect to E , and the same remarkable perfor-
mance. Privacy with respect to clients is near-optimal (see
Section 3.1 for why such leakage may be inevitable) with
leakage conﬁned only to information on the number of doc-
uments matching one of the query terms (typically, the least-
frequent term).

Next, we extend the MC-OXT protocol to an even more
challenging setting we call Outsourced Symmetric Private
Information Retrieval (OSPIR), where on top of the MC-
SSE requirements, one asks that client queries be hidden
from D - similarly to the Private Information Retrieval (PIR)
primitive. This requirement arises in important outsourc-
ing scenarios. In the medical database example mentioned
above, the hospital authorizes doctors or other parties to
search the medical database according to certain policy;
however, in some cases the actual query values are to be
kept secret from the hospital itself (due to privacy, liability
and regulatory requirements). Only the minimal informa-
tion for determining the compliance of a query to the policy
should be disclosed to the hospital. For example, the policy
may indicate that only conjunctions with a minimal number

of terms are allowed or that the query needs to include at
least three of a set of attributes, etc. In such a case, there is
no need for the hospital to learn the particular values being
searched (such as a speciﬁc last name or medical condition).
In other cases, as in outsourced patent or ﬁnancial informa-
tion search, the provider D may want to enforce that a client
C pays for the type of query it is interested in but C wants
to keep his query hidden from both D and E . Applications
to intelligence scenarios are discussed in [18] (see also [32]).
Thus, we relax the query privacy requirement with respect
to D to allow for minimal information needed for D to deter-
mine policy compliance. Speciﬁcally, we consider the case
where keywords are formed by pairs of attribute-values. For
example, in a relational database, attributes are deﬁned by
the database columns (e.g., SSN, name, citizenship, etc.),
while in an email repository attributes can refer to envelope
information such as sender and receivers or to the message
body (in which case the values are, say, English words). In
this case, a policy deﬁnes the class of boolean expressions
allowed for a given client and the attributes that may be
used as inputs into these expressions.
In order to enforce
the policy, D learns the boolean expression and attributes
but nothing about the searched values. For policies deﬁned
via classes of attributes (e.g. allowing any attribute from
the set of attributes {name, city, zipcode}) leakage to D can
be further reduced by revealing the class and not the speciﬁc
attributes in the query.

Our most advanced result is extending the OXT proto-
col to the above OSPIR setting. The resultant protocol,
OSPIR-OXT, adds some crucial new ingredients to OXT:
It uses oblivious PRFs (OPRF) for hiding the query val-
ues from D, uses attribute-speciﬁc keys for enforcing policy
compliance, and uses homomorphic signatures (or the more
general abstraction of shared OPRFs) for query veriﬁcation
by E . A further extension of the protocol accommodates an
external policy manager, e.g., a judge in a warrant-based
search, who checks policy compliance and allows server D
to enforce the policy without learning the attributes being
searched.

Performance-wise our extensions to OXT preserve the pro-
tocol’s performance in both pre-processing (creating EDB)
and search phases. OSPIR-OXT adds to the computational
cost by adding a few exponentiations but these are gener-
ally inexpensive relative to the I/O cost (especially thanks
to common-base exponentiation optimizations). The pro-
tocols we provide for MC-SSE and OSPIR models support
encrypted search over database containing tens of billions
record-keyword pairs, for example a full snapshot of English
Wikipedia or a 10-TByte, 100M-record US-census database
(see Sections 4.3 and 4.4).

We achieve provable security against adaptive adversar-
ial honest-but-curious server E , against arbitrarily malicious
(but non-colluding1 with E ) server D, and against arbitrar-
ily malicious clients. Our security models extend the SSE
model [13, 11, 9] to the more complex settings of MC-SSE
and OSPIR. In all cases security is deﬁned in the real-vs-
ideal model and is parametrized by a speciﬁed leakage func-
tion L(DB, q). A protocol is said to be secure with leakage
proﬁle L(DB, q) against adversary A if the actions of A on
adversarially-chosen input DB and queries set q can be sim-
ulated with access to the leakage information L(DB, q) only

1See Section 5.1.

876(and not to DB or q). This allows modeling and bounding
partial leakage allowed by SSE protocols. It means that even
an adversary that has full information about a database, or
even chooses it, does not learn anything from the protocol
execution other than what can be derived solely from the
deﬁned leakage proﬁle.

Related work: Searchable symmetric encryption (SSE)
has been extensively studied [29, 15, 16, 10, 13, 11, 24] (see
[13, 11] for more on related work). Most SSE research fo-
cused on single-keyword search, and after several solutions
with complexity linear in the database size, Curtmola et
al. [13] present the ﬁrst solution for single-keyword search
whose complexity is linear in the number of matching doc-
uments. They also improve on previous security models, in
particular by providing an adaptive security deﬁnition and
a solution in this model.

Extending single-keyword SSE to search by conjunctions
of keywords was considered in [16, 7, 2], but all these schemes
had O(|DB|) search complexity. The ﬁrst SSE which can
handle very large DBs and supports conjunctive queries is
the OXT protocol discussed above, given by Cash et al. [9].
The MC-SSE and OSPIR schemes we present are based on
this protocol and they preserve its performance and privacy
characteristics.

Extension of the two-party client-server model of SSE to
the multi-client setting was considered by Curtmola et al,
[13], but their model disallowed per-query interaction be-
tween the data owner and the client,
leading to a rela-
tively ineﬃcient implementation based on broadcast encryp-
tion. Multi-client SSE setting which allows such interac-
tion was considered by Chase and Kamara [11] as SSE with
“controlled disclosure”, and by Kamara and Lauter [23], as
“virtual private storage”, but both considered only single-
keyword queries and did not support query privacy from the
data owner. De Cristofaro et al. [12] extended multi-client
SSE to the OSPIR setting, which supports query privacy,
but only for the case of single-keyword queries.
In recent
independent work, Pappas et al. [27] provide support for
boolean queries in a setting similar to our OSPIR setting
(but with honest-but-curious clients).

SSE schemes which support eﬃcient updates of the en-
crypted database appeared in [30, 24] for single-keyword
SSE. The OXT SSE scheme of [9] which supports arbitrary
boolean queries, has been extended to the dynamic case in
[8], and the same techniques apply to the MC-SSE and OS-
PIR schemes presented in this paper.

Recently Islam et al. [19] showed that frequency analy-
sis revealed by access control patterns in SSE schemes can
be used to predict single-keyword queries. Such attacks, al-
though harder to stage, are possible for conjunctive queries
as well, but the general masking and padding countermea-
sures suggested in [19] are applicable to the MC-OXT and
OSPIR-OXT protocols.

In other directions, SSE was extended to the public key
setting, allowing any party to encrypt into the database, ﬁrst
for single-keyword search [5, 31, 1, 3, 6, 28], and later for
conjunctive queries as well [6], but all these PKSE schemes
have O(|DB|) search complexity. Universally composable
SSE was introduced by [25], also with O(|DB|) search com-
plexity.

Multi-client SSE and OSPIR models are related to the
work on multi-client ORAM, e.g. see the recent work of
Huang and Goldberg [17], which aims for stronger privacy

protection of client’s queries from server E , but multi-client
ORAM supports DB lookups by (single) indexes instead of
(boolean formulas on) keywords, and they can currently sup-
port much smaller DB sizes.

Paper organization. We ﬁrst present our protocols for
the case of conjunctive queries:
in Section 2 we recall the
basic OXT protocol [9], suitably reformulated for our gen-
eralizations, in Section 3 we address the multi-client SSE
model, and in Section 4 we handle the OSPIR model.
In
Section 4.2 we explain how to extend support for general
boolean queries. Our security models and claims are pre-
sented concisely in Section 5 — a complete treatment is
deferred to the full version [20]. While the main implemen-
tation details and performance analysis is deferred to a com-
panion paper [8], we provide some information on computa-
tional cost and performance measurements from our imple-
mentation in Section 4.3 and 4.4, respectively.

2. SSE AND THE OXT PROTOCOL

We ﬁrst recall the SSE OXT protocol from [9] that forms
the basis for our solution to searchable encryption in the
more advanced MC and OSPIR models.

SSE protocols and formal setting [9]. Let λ be a se-
curity parameter. A database DB = (indi, Wi)d
i=1 is a list
of identiﬁer and keyword-set pairs, where indi ∈ {0, 1}λ is a
document identiﬁer and Wi ⊆ {0, 1}∗ is a list of keywords
in that document. We set W to Sd
i=1 Wi. A query ψ( ¯w) is
speciﬁed by a tuple of keywords ¯w ∈ W∗ and a boolean for-
mula ψ on ¯w. We write DB(ψ( ¯w)) for the set of identiﬁers
of documents that “satisfy” ψ( ¯w). Formally, this means that
indi ∈ DB(ψ( ¯w)) iﬀ the formula ψ( ¯w) evaluates to true when
we replace each keyword wj with true or false depending on if
wj ∈ Wi or not (in particular DB(w) = {indi s.t. w ∈ Wi}).
Below we let d denote the number of records in DB, m = |W|,
and N = Pw∈W |DB(w)|.

A searchable symmetric encryption (SSE) scheme Π con-
sists of an algorithm EDBSetup and a protocol Search ﬁtting
the following syntax. EDBSetup takes as input a database
DB and a list of document decryption keys RDK, and outputs
a secret key K along with an encrypted database EDB. The
search protocol proceeds between a client C and server E ,
where C takes as input the secret key K and a query ψ( ¯w)
and E takes as input EDB. At the end of the protocol C
outputs a set of (ind, rdk) pairs while E has no output. We
say that an SSE scheme is correct if for all DB, RDK and all
queries ψ( ¯w), for (K, EDB) ← EDBSetup(DB, RDK), after
running Search with client input (K, φ( ¯w)) and server in-
put EDB, the client outputs DB(φ( ¯w)) and RDK[DB(φ( ¯w))]
where RDK[S] denotes {RDK[ind] | ind ∈ S}. Correctness
can be statistical (allowing a negligible probability of er-
ror) or computational (ensured only against computation-
ally bounded attackers - see [9]).

Note (conjunctive vs. Boolean queries). Throughout the
paper we present our protocols for the case of conjunctive
queries where a query consists of n keywords ¯w = (w1, . . . , wn)
and it returns all documents containing all these keywords.
The adaptation to the case of boolean queries is described
in Section 4.2.

Note (the array RDK). Our SSE syntax, and the OXT de-
scription in Figure 1, includes as input to EDBSetup an array
RDK that contains, for each document in DB, a key rdk used

877to encrypt that document. When a client retrieves the in-
dex ind of a document matching its query, it also retrieves
the record-decrypting key rdk needed to decrypt that record.
This mechanism is not strictly needed in the SSE setting
(where rdk could be derived from ind using a PRF with a
secret key known to C) and it is not part of the original OXT
in [9], but it is needed in the more advanced models consid-
ered later. This extension does not change the functionality
and security properties of OXT as analyzed in [9]).

Note (retrieval of matching encrypted records). Our formal-
ism deﬁnes the output of the SSE protocol as the set of ind
identiﬁers pointing to the encrypted records matching the
query, together with the associated record decryption key.
For the sake of generality, we do not model the processing
and retrieval of encrypted records. This allows us to decou-
ple the storage and processing of document payloads (which
can be done in a variety of ways, with varying types of leak-
age) from the storage and processing of the metadata, which
is the focus of our protocols.

SSE Security. The SSE setting considers security w.r.t.
an adversarial server E , hence security is parametrized via
a leakage function capturing information learned by E from
the interaction with C. See Section 5.
2.1 The OXT Protocol

The OXT protocol [9] is presented in Figure 1; see [9] for
full design rationale and analysis. Here we provide a high
level description as needed for the extensions to this protocol
we introduce in the following sections.

The basis of OXT is the following simple search algorithm
over unencrypted databases. The algorithm uses two types
of data structures. First, for every keyword w there is an
inverted index (a list) Iw pointing to the indices ind of all
documents that contain w. Then, for every document ind
there is a list Lind of all keywords contained in document
ind. To search for a conjunction ¯w = (w1, . . . , wn), the
client chooses the estimated least frequent keyword 2 in ¯w,
say w1, and checks for each ind ∈ Iw1 whether wi ∈ Lind,
i = 2, . . . , n. If this holds for all 2 ≤ i ≤ n then ind is added
to the result set. As a performance optimization, instead
of maintaining a list Lind for each ind, one can ﬁx a hash
function f and keep a data structure representing the set
X = {f (w, ind) : w ∈ W, ind ∈ DB(w)}. Thus, the check
w ∈ Lind can be replaced with the check f (w, ind) ∈ X. Pro-
tocol OXT adapts this algorithm to the encrypted setting as
follows (we start with the description of a simpliﬁed version,
corresponding to protocol BXT in [9], and then move to the
more speciﬁc details of OXT).

For each keyword w ∈ W an inverted index (corresponding
to Iw above), referred to as TSet(w), is built pointing to all
the ind values of documents in DB(w). Each TSet(w) is iden-
tiﬁed by a string called stag(w) and ind values in TSet(w)
are encrypted under a secret key Ke. Both stag(w) and
Ke are computed as a PRF applied to w with secret keys
known to C only. In addition, a data structure called XSet is
built as an “encrypted equivalent” of the above set X as fol-
lows. First, for each w ∈ W, a value xtrap(w) = F (KX , w)
is computed where KX is a secret PRF key then for each
ind ∈ DB(w) a value xtag = f (xtrap(w), ind) is added to
XSet where f is an unpredictable function of its inputs (e.g.,

2

The estimated least frequent keyword is called the conjunction’s s-

term; the other terms in a conjunction are called x-terms.

f can be a PRF used with xtrap(w) as the key and ind as
input). The output EDB from the EDBSetup phase includes
TSet = {TSet(w)}w∈W and the set XSet. In the Search pro-
tocol for a conjunction (w1, . . . , wn), the client C chooses
the conjunction’s s-term (i.e., the estimated least frequent
keyword in the conjunction, which we assume to be w1),
computes stag(w1) and Ke using C’s secret keys and com-
putes xtrapi = F (KX , wi) for each i = 2, . . . , n.
It then
sends (Ke, stag, xtrap2, . . . , xtrapn) to the server E . E uses
stag to retrieve TSet(w1), uses Ke to decrypt the ind val-
ues in TSet(w1), and sends back to C those ind for which
f (xtrapi, ind) ∈ XSet for all i = 2, . . . , n.

The OXT protocol from Figure 1 follows the above logic
but instantiates it in a way that minimizes leakage to E .
Rather than assuming a speciﬁc implementation of TSet,
[9] abstracts this data structure through an API that we
adopt here. Speciﬁcally, the abstract TSetSetup operation
receives a collection T of lists t(w) for each w ∈ W and
builds the TSet data structure out of these lists; it returns
TSet and a key KT . Then, TSetRetrieve(TSet, stag(w)) in-
stantiates the retrieval of a TSet(w) via its handle stag(w)
which is computed by a function TSetGetTag(KT , w) (typ-
ically a PRF). The elements in the t(w) lists are called tu-
ples and their contents are deﬁned by the OXT protocol.
A TSet implementation provides two crucial security prop-
erties [9]: privacy in that the TSet datastructure does not
reveal anything about the tuple lits in T except their sum-
mary length Pw |T[w]|; and correctness in that (except for
negligible probability) TSetRetrieve(TSet, stag) returns T[w]
for stag = TSetGetTag(KT , w), and it returns an empty set
for all other stag values.

Next, we note that using the protocol described above
leads to signiﬁcant leakage in that the xtrap value allows E to
check whether xtag = f (xtrap, ind) ∈ XSet for each value ind
ever seen by E , revealing correlation statistics between each
s-term and each x-term ever queried by C. This motivates
the main mechanism in OXT, i.e. the instantiation of the
function f via a two-party computation in which E inputs an
encrypted value ind, C inputs xtrap and the ind-decryption
key, and E gets the value of xtag = f (xtrap, ind) without
learning either the xtrap or ind values themselves. For this
OXT uses a blinded DH computation over a group G (with
generator g of prime order p). However, to avoid the need
for interaction between E and C in the Search phase, the
blinding factors are pre-computed and stored as part of the
tuples in the TSet lists. Speciﬁcally, indexes ind are replaced
in the computation of f with dedicated per-record values
xind ∈ Z ∗
p (computed as Fp(KI , ind) where Fp is a PRF
p ), xtrap(w)’s are implemented as gFp(KX ,w)
with range Z ∗
(KI and KX are secret keys kept by C), and xtag is re-deﬁned
as (xtrap(w))xind. The blinding factor in the underlying two-
party computation is pre-computed during EDBSetup and
stored in the TSet. Namely, each tuple corresponding to a
keyword w and document index ind contains a blinded value
yc = xind · z−1
for xind = Fp(FI , ind) where zc is an element
in Z ∗
p derived (via a PRF) from w and a tuple counter c
(this counter, incremented for each tuple in the tuple list
associated with w, ensures independence of each blinding
value zc).

c

During search, the server E needs to compute the xtag val-
ues gFp(KX ,wi)·xind for each xind in TSet(w1) and then test
these for membership in XSet. To enable this the client
sends, for the c-th tuple in t, an n-long array xtoken[c] de-

878EDBSetup(DB, RDK)

Key Generation. D picks key KS for PRF Fτ and keys KT , KX , KI for PRF Fp. Fτ and Fp are PRF’s which output strings
in respectively {0, 1}τ and Z ∗

p , and τ is a security parameter.

• Initialize XSet to an empty set, and initialize T to an empty array indexed by keywords from W.

• For each w ∈ W, build the tuple list t and insert elements into set XSet as follows:

– Initialize t to be an empty list.

– Set strap ← Fτ (KS , w) and (Kz , Ke) ← (Fτ (strap, 1), Fτ (strap, 2)).
– Initialize c ← 0; then for all ind in DB(w) in random order:

∗ Set rdk ← RDK(ind), e ← Enc(Ke, (ind|rdk)), xind ← Fp(KI , ind).
∗ Set c ← c + 1, zc ← Fp(Kz , c), y ← xind · z−1
∗ Set xtag ← gFp(KX ,w)·xind and add xtag to XSet.

. Append (e, y) to t.

c

– T[w] ← t.

• Create (TSet, KT ) ← TSetSetup(T), and output key K = (KS , KX , KT , KI ) and EDB = (TSet, XSet).

Search protocol
Client C on input K deﬁned as above and a conjunctive query ¯w = (w1, . . . , wn):

• Sets stag ← TSetGetTag(KT , w1); strap ← Fτ (KS , w1), (Kz , Ke) ← (Fτ (strap, 1), Fτ (strap, 2)).
• Sends to the server E the message (stag, xtoken[1], xtoken[2], . . .) where xtoken[·] are deﬁned as:

– For c = 1, 2, . . ., until E sends stop:

∗ Set zc ← Fp(Kz , c) and set xtoken[c, i] ← gFp(KX ,wi)·zc for i = 2, . . . , n.
∗ Set xtoken[c] ← (xtoken[c, 2], . . . , xtoken[c, n]).

Server E on input EDB = (TSet, XSet) responds as follows:

• Retrieve t ← TSetRetrieve(TSet, stag) from TSet.

• For c = 1, . . . , |t| do:

– Retrieve (e, y) from the c-th tuple in t
– If ∀i = 2, . . . , n : xtoken[c, i]y ∈ XSet then send e to client C.

• When last tuple in t is reached, sends stop to C and halt.

For each received e client C computes (ind|rdk) ← Dec(Ke, e) and outputs (ind, rdk).

Figure 1: OXT: Oblivious Cross-Tags SSE Scheme

c = gFp(KX ,wi)·xind, meaning that the server

ﬁned by xtoken[c, i] := gFp(KX ,wi)·zc , i = 1, . . . , n, where
zc is the precomputed blinding derived by C from w (via
a PRF) and the tuple counter c. E then performs the T-
set search to get the results for w1, and for each c it ﬁl-
ters the c-th result by testing if xtoken[c, i]yc ∈ XSet for all
i = 2, . . . , n. This protocol is correct because xtoken[c, i]yc =
gFp(KX ,wi)·zc ·xind·z−1
correctly recomputes the pseudorandom values in the XSet.
Putting these ideas together results in the OXT protocol of
Figure 1. Note that C sends the xtoken arrays (each holding
several values of the form gFp(KX ,wi)·zc ) until instructed to
stop by E . There is no other communication from server to
client (alternatively, server can send the number of elements
in TSet(w) to the client who will respond with such number
of xtoken arrays).
Note. The OXT protocol in Figure 1 derives keys Ke, Kz
slightly diﬀerently than in the OXT description of [9]. The
modiﬁed key derivation is closer to what we need for MC-OXT
and OSPIR-OXT protocols presented in the following sec-
tions, without aﬀecting the functionality or security of OXT.

3. MULTI-CLIENT SSE

We present an extension of the OXT protocol for the multi-
client SSE (MC-SSE) setting described in the introduction
and in more detail below. The extension preserves the func-
tionality of OXT, supporting any boolean query, and superb
performance, while securely serving multiple clients, all of
which can behave maliciously.

Multi-Client SSE Setting. In MC-SSE there is the owner
D of the plaintext database DB, an external server E that
holds the encrypted database EDB, and clients that receive
tokens from D in order to perform search queries at E . In
other words, D is outsourcing her search service to a third
party but requires clients to ﬁrst obtain search tokens from
her. Her goal is to ensure service to clients via E while leak-
ing as little as possible information to E about the plaintext
data and queries, and preventing clients from running any
other DB queries than those for which D issued them a to-
ken. This is a natural outsourcing setting of increasing value
in cloud-based platforms, and it was described by Chase and
Kamara [11] as an SSE with controlled disclosure.

Formally, the MC-SSE setting changes the syntax of an
SSE scheme by including an additional algorithm GenToken

879which on input the secret key K, generated by the data
owner D in the EDBSetup procedure, and a boolean query
ψ( ¯w), submitted by client C, generates a search-enabling
value token. Then, procedure Search is executed by server E
on input EDB, but instead of the client C running on input
K and query ψ( ¯w) (as in SSE), C runs on input consist-
ing only of the search token token. Correctness is deﬁned
similarly to the SSE case, namely, assuring (except for neg-
ligible error probability) that C’s output sets DB(ψ( ¯w)) and
RDK[DB(ψ( ¯w))]. Security is treated in Section 5.
3.1 The MC-OXT Protocol

We describe the changes to OXT from Figure 1 needed to
support boolean queries in the MC-SSE setting. As before,
the protocol is described for conjunctions with the adapta-
tion to boolean queries described in Section 4.2.

EDBSetup(DB, RDK). This pre-processing phase is identical
to the one in OXT except for the addition of a key KM
shared between D and E . The output from this phase is K =
(KS, KX , KT , KM ) kept by D and EDB = (KM , TSet, XSet)
stored at E .

GenToken(K, ¯w). This is the new MC-speciﬁc phase in which
D, using key K, authorizes C for a conjunction ¯w = w1, . . . , wn
and provides C with the necessary tokens to enable the search
at E . We assume w1 to be the s-term (and chosen by D who
has knowledge of term frequencies). Speciﬁcally, D performs
the following operations. She sets stag ← TSetGetTag(KT , w1)
and strap ← Fτ (KS, w1), same as C does in OXT. Then,
for i = 2, ..., n, she picks ρi ← Z ∗
p and sets bxtrapi ←
gFp(KX ,wi)·ρi . Finally, she sets
env ← AuthEnc(KM , (stag, ρ2, ..., ρn)) and outputs token =
(env, strap, bxtrap2, . . . , bxtrapn) (which C uses in the search
phase).

To see how this enables search as in OXT, ﬁrst note that
with xtrapi = gFp(KX ,wi), i = 2, . . . , n, the client can pro-
duce the values gFp(KX ,wi)·zc needed in the Search phase of
OXT. Hence, D could just provide the xtrapi values to C.
However, D needs to be able to sign (or MAC) these values
so that E can check that C is authorized to this query and,
e.g., did not truncate a conjunction or mix parts from dif-
ferent queries. Signing the plain xtrap values does not work
since these values must not be seen by E (it would allow E
to learn information from unauthorized searches). The so-
lution is to provide C with a homomorphic signature that C
can convert into individual signatures for all tokens sent to E .
This is accomplished as follows: D picks one-time blinding
factors ρ2, . . . , ρn and provides C with blinded (or MAC’ed)
xtrap values bxtrapi = xtrapρi
for j = 2, . . . , n, while pro-
viding the blinding factors (ρ2, . . . , ρn) to E in an encrypted
and authenticated envelope env. To produce gFp(KX ,wi)·zc
during Search, C will compute bxtrapzc
i and E will raise this
value to 1/ρi. Security relies on the fact that if C provides E
with values other than those given by D, then when raised
to 1/ρi by E (where ρi is random and unknown to C) the re-
sulting values will not correspond to elements of XSet except
with negligible probability.

i

Search Protocol. The Search protocol reﬂects the above changes:
On token = (env, strap, bxtrap2, ..., bxtrapn), C computes (Kz, Ke)
from strap as in OXT. Then, it sends to E the value env as
well as the sequence bxtoken[1], bxtoken[2], . . . which contains
the same values as xtoken[1], xtoken[2], . . . in OXT up to the
blinding exponents ρi. Speciﬁcally, the values bxtoken[c, i],

for i = 2, . . . , n, are computed by C as (bxtrapi)zc. On
the receiving side, E veriﬁes the authenticity of env and de-
crypts it to ﬁnd stag, which it uses to retrieve TSet(w1), and
ρ2, . . . , ρn. The only change from OXT is that the operation
xtoken[c, i]y is replaced with bxtoken[c, i]y/ρi .
Note (masking the size of TSet(w1)). MC-OXT leaks to
C the size of TSet(w1) = DB(w1) given by the number of
bxtoken vectors requested by E . Note that the exact size of
this set can easily be masked by E requesting more bxtoken
values from C than needed. We observe that some form of
leakage on the frequency of the least frequent term in the
conjunction appears to be inherent even for plaintext search
algorithms. Indeed, it is likely (though there seem to be no
proven lower bounds) that running time will be noticeably
diﬀerent for conjunctions with all terms being infrequent
from the case that all terms are very frequent, except if
short searches are artiﬁcially padded to full database size
(or if conjunctions are pre-computed). Two considerations
in masking the size of TSet(w1) are that (i) the masked
size should be chosen as a step function of |TSet(w1)| (and
not, say, a ﬁxed linear function); (ii) During search, E should
return to C all results matching a query only after E received
all the bxtoken vectors from C; indeed, sending the results
as soon as they are found to match the query would leak
information on |TSet(w)| to C (since no ind’s will be returned
after C sends |TSet(w)| tokens). In the full version [20] we
show a strategy applied by D during EDBSetup to allow E
to send results as soon as they are found while avoiding the
above leakage.

4. OUTSOURCED SYMMETRIC PIR

The OSPIR (for Outsourced Symmetric PIR) setting aug-
ments the MC-SSE setting with an additional requirement:
The database owner D should learn as little as possible about
queries performed by clients while still being able to verify
the compliance of these queries to her policy. Here we extend
MC-OXT to this setting by augmenting the token generation
component GenToken to support “blinding” by the client of
query requests sent to D, and adding a mechanism for D
to enforce policy-compliance of the query when only hav-
ing access to their blinded versions. OSPIR-OXT supports
attribute-based policies where D learns information about
query attributes but nothing about values (e.g., D may learn
that a query includes a last-name, a zipcode and two words
from a text ﬁeld but nothing about the actual queried key-
words). The security model adds D as a new adversarial
entity trying to learn C’s hidden query values. Refer to the
introduction for more discussion about the OSPIR setting
and attribute-based policies.
OSPIR SSE Syntax. An OSPIR-SSE scheme replaces
the GenToken procedure which in MC-SSE is executed by
the data owner D on the cleartext client’s query ¯w, with a
two-party protocol between C and D that allows C to com-
pute a search-enabling token without D learning ¯w. In addi-
tion, D should be able to enforce an attribute-based query-
authorization policy on these queries. For this, we assume
that keyword set W is partitioned into m attributes, and
let I(w) denote the attribute of keyword w.3 An attribute-
based policy is represented by a set of attribute-sequences

3

We assume that the string representing w has its attribute encoded
into it, i.e. w = (i, val) for i = I(w), so that Ryan as a ﬁrst name is
distinguished from Ryan as a last name.

880P s.t. a conjunctive query ¯w = (w1, ..., wn) is allowed by
policy P if and only if the sequence of attributes av( ¯w) =
(I(w1), ..., I(wn)) corresponding to this query is an element
in set P. Using this notation, the goal of the GenToken pro-
tocol is to let C compute token corresponding to its query
¯w only if av( ¯w) ∈ P. Reﬂecting these goals, an OSPIR-SSE
scheme is a tuple Σ = (EDBSetup, GenToken, Search) where
EDBSetup is an algorithm run by D on inputs (DB, RDK)
with outputs (EDB, K), GenToken is a protocol run by C on
input ¯w and by D on input (P, K), with C outputting token
or ⊥ and D outputting av, and Search is a protocol run by
C on input token and by E on input EDB, with C outputting
a set of ind’s matching his query and the corresponding set
of rdk’s.
4.1 The OSPIR-OXT Protocol

The OSPIR-OXT protocol addresses the above OSPIR set-
ting by enhancing MC-OXT with query-hiding techniques
that allow D to authorize queries without learning the queried
values. Most changes with respect to MC-OXT are in the
GenToken protocol. EDBSetup remains mostly unchanged
except for the implementation of the PRFs, and Search is
essentially unmodiﬁed.

We introduce the two main tools used in the design of
GenToken. First, instead of the use of regular PRFs for stag
and xtag computations in OXT and MC-OXT, the OSPIR-
OXT protocol uses an an “oblivious PRF” (OPRF) compu-
tation between C and D. A PRF F (K, w) is called oblivious
[26] if there is a two-party protocol in which C inputs w,
D inputs K, C learns the value of F (K, w) and D learns
nothing. A simple example is the Hashed DH OPRF which
we use in our implementation of the OSPIR-OXT protocol,
deﬁned as F (K, x) = H(x)K where H is a hash function
onto G \ {1} where G is a group of prime order p, and K
is chosen at random in Z ∗
p . In this case, the OPRF proto-
col consists of C sending a = H(x)r for random r in Z ∗
p ,
D sending back b = aK and C computing H(x)K as b1/r.
The second tool used in GenToken is needed to enforce an
attribute-based policy and guarantee that only queries on au-
thorized attributes can generate valid tokens for search at
E . To enforce such policies we have D use a diﬀerent key for
each possible attribute; for example, when a stag (or xtag)
is requested for attribute ‘zipcode’ the key that D inputs
into the OPRF computation is diﬀerent than the key used
for attribute ‘name’ or attribute ‘text’. The point is that
if C claims to be querying zipcode but actually enters the
keyword “Michael” into the OPRF computation, the output
for C will be the tag F (Kzip, “Michael”), where Kzip is a
zipcode-speciﬁc key, which will match no tag stored at E .

To obtain OSPIR-OXT we combine the above two tools
with an authorization mechanism similar to the one used in
MC-OXT via a homomorphic signature (using the ρi expo-
nents) for binding together the n tokens corresponding to
an n-term conjunctive query in a way that E can verify. We
describe the changes to MC-OXT (deﬁned via Figure 1 and
the modiﬁcations in Section 3) required by OSPIR-OXT. We
ﬁrst replace the PRF Fp used in computing xtrap and xtag
values with a PRF FG which maps w directly onto the group
G generated by g, i.e. we set xtrap as FG(KX , w) instead of
gFp(KX ,w), hence xtag = (xtrap)xind will now be computed as
FG(KX , w)xind instead of gFp(KX ,w)·xind. We similarly replace
the PRF Fτ used in computing the strap value with the PRF
FG, i.e. we set strap as FG(KS, w) instead of Fτ (KS, w).

(Since we use strap as a key to Fτ in deriving (Kz, Ke), we
assume that a PRF Fτ key can be extracted from a random
group element.)

G s.t. F m

We also make a speciﬁc assumption on the implemen-
tation of the function TSetGetTag used to derive stag(w)
value, i.e., the handle pointing to the set TSet(w) which
is computed as TSetGetTag(KT , w). First, we assume that
TSetGetTag is implemented using PRF FG. Second, to en-
able enforcement of attribute-based policies we assume that
the key KT in TSetGetTag is formed by an array of FG
keys KT = (KT [1], ..., KT [m]), where KT [i] is the key to be
used only for keywords with attribute I(w) = i. For nota-
tional convenience we deﬁne a PRF F m
G (KT , w) =
FG(KT [I(w)], w), and we set stag(w) = TSetGetTag(KT , w)
to F m
G (KT , w). Since we explicitly handle the keys used in
the TSetGetTag implementation we also need to modify the
TSet API: We will initialize TSet as TSet ← TSetSetup0(T),
where T indexes the tuple lists t(w) not by the keywords w
but by the corresponding stag(w) values. (This API change
does not aﬀect existing TSet implementations [9] because
they internally use stag(w) = TSetGetTag(KT , w) to store
the t(w) list.) The PRF we use in the computation of
xtag’s will be similarly attribute-partitioned. Namely, KX
is also an array of m independent FG keys KX = (KX [1],
. . . , KX [m]), the xtrap value for keyword w is deﬁned as
F m
G (KX , w), and the xtag corresponding to keyword w and
index xind is set to (F m

G (KX , w))xind.

In OSPIR-OXT, there are two two-party protocols involved
in the computation of FG. In the ﬁrst case, the protocol im-
plements an OPRF computation in which C enters an input
w, D enters a key KS, and the output is FG(KS, w) for C and
⊥ for D. In the second case, F m
G is computed via a protocol,
that we call a shared OPRF (S-OPRF), in which C inputs w
and i = I(w), and D enters a key K and additional input
ρ ∈ Z ∗
p ; the output learned by D is i, and the output learned
G (K, x))ρ = (FG(K[i], x))ρ. Note that the pair of
by C is (F m
outputs ((F m
G (K, x))ρ, ρ) can be seen as a secret sharing of
F m
G (K, x), hence the name shared-OPRF. OSPIR-OXT uses
the OPRF protocol to let C learn the strap value correspond-
ing to the w1 s-term, i.e. strap = FG(KS, w1), without D
learning w1. The S-OPRF protocol is used to let C com-
G (KT , w1)]ρ1 and the blinded
pute a blinded stag bstag = [F m
xtraps bxtrapi = [F m
G (KI , wi)]ρi , for i = 2, ..., n. The func-
tionality of the blinding ρi is the same as in the case of
MC-OXT, namely, as a form of homomorphic signature bind-
ing and authorizing stag and xtrap’s that E can verify. As
in MC-OXT, E will receive the corresponding (de)blinding
factors ρ1, . . . , ρn in the authenticated envelope env.

To simplify the description of OSPIR-OXT, we assume
that both OPRF and S-OPRF protocols take a single round
of interaction between C and D, as is indeed the case for
several eﬃcient OPRF’s of interest [14, 21], including the
Hashed Diﬃe-Hellman OPRF [22] used in our implementa-
tion below. We denote C’s initial computation in the OPRF
protocol as (a, r) ← OPRF.C1(x) (a is the value sent to D
and r is randomness used by C), D’s response computation
as b ← OPRF.D(K, a), and C’s local computation of the ﬁnal
output as OPRF.C2(b, r). We use the corresponding notation
in the case of S-OPRF, except that S-OPRF.D takes as an
input a triple (K, i, a) where i is an attribute and outputs a
pair (b, ρ). See below for a simple implementation of these
procedures for the case of the Hashed Diﬃe-Hellman OPRF.

881GenToken protocol

• Client C, on input ¯w = (w1, ..., wn) where w1 is chosen as s-term:

– Compute (as, rs) ← OPRF.C1(w1), and (ai, ri) ← S-OPRF.C1(wi) for each i = 1, ..., n.
– Send (as, a1, ..., an) and av = (I(w1), ..., I(wn)) to D.

• Data owner D, on input policy P and master key K = (KS , KX , KT , KI , KP , KM ):

– Abort if av is not in policy set P. Otherwise set av as D’s local output.

– Compute bs ← OPRF.D(KS , as).
– Compute (b1, ρ1) ← S-OPRF.D(KT , I1, a1), and (bi, ρi) ← S-OPRF.D(KX , Ii, ai) for i = 2, .., n.
– Set env ← AuthEnc(KM , (ρ1, ρ2, ..., ρn)) and send (env, bs, b1, ..., bn) to C.

• C outputs token = (env, strap, bstag, bxtrap2, ..., bxtrapn) where strap ← OPRF.C2(bs, rs),

bstag ← S-OPRF.C2(b1, r1), and bxtrapi ← S-OPRF.C2(bi, ri) for i = 2, ..., n.

Figure 2: Token Generation in OSPIR-OXT

OSPIR-OXT Speciﬁcation. With the above ingredients
and notation we specify OSPIR-OXT on the basis of MC-OXT
via the following changes.
Keys. Select key KS for FG; KT and KX for F m
Fp; and KM for the authenticated encryption scheme.

G ; KI for

EDBSetup. Follow the EDBSetup procedure of MC-OXT ex-
cept for computing strap ← FG(KS, w) and
xtag ← (F m
procedure as TSetGetTag(KT , w) = F m
that we compute stag(w) ← F m
G (KT , w); index t(w) in T
by stag(w) instead of by w itself; and generate TSet using
the modiﬁed API procedure TSetSetup0(T).

G (KX , w))xind, and for implementing the TSetGetTag
G (KT , w), which means

GenToken protocol. This is the main change with respect
to OSPIR-OXT; it follows the above mechanisms and is pre-
sented in Figure 2.

Search protocol. Same as MC-OXT except that stag is not
included under env but rather it is provided to E by C as
bstag from which E computes stag ← (bstag)1/ρ1 .

Instantiation via Hashed Diﬃe-Hellman OPRF. Our
implementation and analysis of OSPIR-OXT assumes the use
of Hashed DH OPRF mentioned above, namely, FG(K, x) =
(H(x))K. The instantiations of OPRF and S-OPRF protocols
in this case are as follows. OPRF.C1(x) and S-OPRF.C1(x)
p , set a ← (H(x))r, and output
both pick random r in Z ∗
(a, r). Procedure OPRF.D(K, a), where K ∈ Z ∗
p is a key for
PRF FG, outputs b ← aK. Procedure S-OPRF.D(K, i, a),
p )m
where i ∈ {1, ..., m} and K = (K[1], . . . , K[m]) ∈ (Z ∗
is a key for PRF F m
p , computes
b ← aK[i]·ρ, and outputs (b, ρ). Procedures OPRF.C1(b, r)
and S-OPRF.C1(b, r) both output b1/r. Note that if parties
follow the protocol, C’s ﬁnal output is equal to (H(x))K =
FG(K, x) in the OPRF protocol, while in the S-OPRF proto-
G (K, x))ρ
col it is equal to (H(x))K[i]·ρ, which is equal to (F m
if i = I(x). These OPRF and S-OPRF protocols emulate
their corresponding ideal functionalities in ROM under so-
called One-More Gap Diﬃe-Hellman assumption [22], see
Section 5.

G , picks random ρ in Z ∗

Figure 3 shows the OSPIR-OXT scheme instantiated with
the above Hashed DH OPRF. It helps to visualize the entire
protocol and it reﬂects our actual implementation. In Fig-
ure 3 we denote keys KT and KX of PRF F m
G by vectors of

exponents in Z ∗
p , respectively (k1, . . . , km) and (e1, . . . , em),
where m is the number of attributes. Also, because of the
speciﬁc OPRF instantiation we equate as to a1 in C’s mes-
sage of the GenToken protocol, instead of computing these
two blinded versions of keyword w1 separately, as in Fig-
ure 2.

4.2 Supporting Boolean Queries

For simplicity we presented our protocols for the case
of conjunctions. The protocols can be readily adapted to
search boolean queries in “searchable normal form (SNF)”,
i.e., of the form “w1 ∧φ(w2, . . . , wm)” (intended to return any
document that matches keyword w1 and in addition satis-
ﬁes the formula φ on the remaining keywords). In this case,
OXT and its derivatives change only in the way E determines
which tuples match a query (i.e., which values e it sends
back to C). Speciﬁcally, in OXT the c-th tuple matches if
and only if xtoken[c, i]y/ρi ∈ XSet for all 2 ≤ i ≤ n. Instead,
for boolean queries as above, E will have a set of boolean
variables v2, . . . , vn and will set vi to the truth value of the
predicate xtoken[c, i]y/ρi ∈ XSet. A tuple is matching if and
only if the result of evaluating φ on these values returns
true. The complexity of boolean search is same as for con-
junctions, i.e., proportional to |DB(w1)|, and leakage to E
is the same as for a conjunctive query on the same set of
keywords except that E also learns the expression φ being
evaluated. See [9] for details and support of other forms of
boolean queries.

In the OSPIR-SSE setting, supporting boolean queries re-
quires policies that are deﬁned in terms of such queries.
Speciﬁcally, a policy will determine a set of allowed pairs
(ψ, I) where ψ is a symbolic boolean expression and I a
sequence of attributes, one per each variable in ψ. Thus,
leakage to D will include I (as in the case of conjunctions)
plus the symbolic expression being evaluated.

4.3 Computational Cost

Here we provide an operations count for OSPIR-OXT when
instantiated with the DH-based OPRF noting its (mild)
overhead over the original OXT protocol from [9]. The com-
putational cost of OSPIR-OXT is easy to quantify by inspect-
ing Figure 3 in Page .

882The cost of pre-processing (EDBSetup) is dominated by
operations related to the group G, mainly exponentiations:
For every w ∈ W:

1. One hashing operation, H(w), of keyword w into an

element of the group G.

2. Two exponentiations: strap(w) = (H(w))KS and stag(w) =

(H(w))ki.

3. For every ind in DB(w): One exponentiation H(w)ei ·xind

for computing an XSet element.

The ﬁrst two items are speciﬁc to OSPIR-OXT while the
third is from the original OXT protocol, except that here
the base for exponentiation is changed from the generator g
in OXT to the value H(w). Hence the overhead introduced
by OSPIR-OXT is given by the ﬁrst two items and the vari-
able base. Importantly, the overhead for the ﬁrst two items
is only linear in |W|, typically much smaller than the num-
ber of exponentiations in OXT (item 3), namely one per pair
(w, ind) for ind ∈ DB(w). As for the latter exponentiations,
while the bases are variable, each H(w) is typically used
with a very large number of exponentiations (as the number
of documents containing w) hence allowing for signiﬁcant
same-base optimizations. The hashing of w into the group
G (item 1) is modeled as a random oracle, hence it rules
out algebraic implementations such as gh(w). For the ellip-
tic curves groups we use, H is realized by sampling a ﬁeld
element e and a bit b from a PRNG seeded with w until (e, b)
is the compressed representation of a valid group element.
Depending on the particular nature of a curve, the generic
square root algorithms required in solving the Weierstrass
equation, though, can be extremely ineﬃcient: Our origi-
nal implementation for the chosen NIST 224p curve using
OpenSSL’s standard algorithms was more than an order of
magnitude slower than a normal exponentiation and consid-
erably more when common-base optimization is used. By
implementing our own algorithm inspired by [4] and opti-
mizing it for this particular ﬁeld, we could reduce the cost
down to the order of an exponentiation. Once all these op-
timizations are in place, the performance of OSPIR-OXT is
remarkable as shown in Section 4.4 and, in much more de-
tails, in a companion paper [8].

The dominating cost of GenToken is just 2n + 1 exponen-

tiations for the client and n + 1 for D.

Finally, the cost of query processing between C and E

(Search) on a n-term SNF expression is as follows:

1. C computes n − 1 exponentiations for each tuple in

TSet(w1)

2. E performs up to n−1 exponentiations for each element

in TSet(w1).

Note that C can apply same-base optimization to the expo-
nentiations since each term in the SNF expression has its
own ﬁxed base. On the other hand, E cannot use same-base
optimizations. However, note that as soon as one of the val-
ues xtoken[c, i]y/ρi for a conjunction is found not to be in
XSet, the other terms for this conjunction do not have to
be evaluated (hence avoiding the need for these exponen-
tiations). Similarly, for general Boolean expressions, early
termination can be exploited to reduce costly computation.
This highlights an important optimization for query process-
ing (especially for queries with large TSet(w1) sets): Besides

choosing the s-term as a term with high-entropy to keep
TSet(w1) small, also choose the evaluation order of x-terms
of an SNF expression such that it maximizes the proba-
bility of early termination and, hence, reduces the number
of (expected) exponentiations executed by E , e.g., for con-
junctions order the x-terms in descending order of entropy
(equivalently, ascending order of frequency).
Note (frequency ordering). In the OSPIR setting the client
may not know the frequency of terms in the database and
D will not know the query values to choose such terms opti-
mally. Thus, the exact mechanism for determining the above
ordering will depend on the speciﬁc setting. In our imple-
mentation we decide on ordering based on typical entropy of
attributes; e.g., assuming last names have more entropy than
names, and names more entropy than addresses, etc. (note
that an attribute-based ordering is more privacy-preserving
for the client than a value-based one).
4.4 Implementation and performance

The practicality of the proposed schemes was validated by
experiments on DBs which included e.g. English-language
Wikipedia (13,284,801 records / 2,732,311,945 indexed tu-
ples), and a synthetic US census database (100 million records
/ 22,525,274,592 index tuples, resulting in EDB with 1.7 TB
TSet and 0.4 TB XSet). To illustrate search eﬃciency, in
the census DB case we executed complex queries like

SELECT id WHERE fname=’CHARLIE’ AND
sex=’Female’ AND NOT (state=’NY’ OR
state=’MA’ OR state=’PA’ OR state=’NJ)

in about 4 seconds on an IBM Blade dual Intel 4-core Xeon
processor and storage provided by a (low-end) 6.2TB RAID-
5 storage system. Preprocessing of such large DBs (TSet
and XSet creation) has been feasible by, among other things,
optimization of common-base exponentiations, achieving ag-
gregated (parallel) rate of about 500,000 exp.’s/sec. for the
NIST 224p elliptic curve.

See [8] for details on implementation and performance as
well as for the extension of OXT and OSPIR-OXT to support
dynamic databases (where documents can be added, deleted
and modiﬁed).

5. SECURITY

We analyze security of the OSPIR-SSE scheme. We focus
on the OSPIR case as it is the more comprehensive setting
and it contains MC-SSE as a special case. The SSE-OXT
protocol is analyzed in the SSE setting in [9].
5.1 Security and Correctness Def nitions

SSE security deﬁnitions where the only adversarial entity
is server E are provided in prior work. Here we follow the def-
initions from [9] - which in turn follow [11, 13] - and extend
them to the MC setting by considering multiple malicious
clients and to the OSPIR setting by adding also the data
owner D as an adversarial entity. All security deﬁnitions
follow the ideal/real model framework of secure computa-
tion and are parametrized by a leakage function L bounding
the information leaked to an adversarial party in addition to
the intended output for that party. Speciﬁcally, we ask that
whatever an adversary can do by running the real protocol
on data and queries chosen by the adversary, a simulator
can do solely on the basis of the leakage function.

883Correctness. We say that an OSPIR-SSE scheme Σ =
(EDBSetup, GenToken, Search) is computationally correct if
for every eﬃcient algorithm A, there is a negligible proba-
bility that the following experiment outputs 0. On inputs
(DB, RDK) and ¯w(1), . . . , ¯w(m) provided by A, execute (K,
EDB) ← EDBSetup(DB, RDK); and for i = 1, 2, . . ., execute
protocol GenToken on C’s input ¯w(i) and D’s inputs (P, K),
denote C’s output as token(i), execute protocol Search be-
tween C on input token(i) and E on input EDB and denote
C’s outputs as a pair (indSet(i), rdkSet(i)). Output 1 if for
each i we have that indSet(i) = DB( ¯w(i)) and rdkSet(i) =
RDK[DB( ¯w(i))]. Otherwise output 0.

Security against adversarial server E . Security against
adversarial (honest-but-curious) E has been the focus of prior
SSE work. Adapting the deﬁnition of L-semantic security
against adaptive attacks (by the server E ) from [9] to our
setting is straightforward and is omitted here.

Security against adversarial clients. The deﬁnition cap-
tures the information leaked to a malicious client in addi-
tion to the intended output DB( ¯w) and the corresponding
record-decrypting keys RDK[DB( ¯w)]. The deﬁnition com-
pares the real execution to an emulation of an interaction
with algorithm I-SSEL, which models an ideal functional-
ity of the OSPIR-SSE scheme instantiated with the leakage
function L. The interactive algorithm I-SSEL, running on
local input (DB, RDK, P), answers queries ¯w ∈ W∗ by check-
ing if av( ¯w) ∈ P.
If the check veriﬁes, then it replies to
this ¯w with a triple (DB( ¯w), RDK[DB( ¯w)], L(DB, ¯w)), and if
av( ¯w) 6∈ P then it sends back a rejection symbol ⊥.

Definition 1. Let Π = (EDBSetup, GenToken, Search) be
an OSPIR-SSE scheme. Given algorithms L, A, and S =
(S0, S1, S2) we deﬁne experiments (algorithms) RealΠ
A(λ)
and IdealΠ

A,S(λ) as follows:

RealΠ
A(λ): A(1λ) chooses (DB, RDK, P), and the experiment
runs (K, EDB) ← EDBSetup(DB, RDK). Adversary A can
then adaptively invoke instances of the protocol GenToken
and Search, interacting with party D running on input K and
P in the ﬁrst case and with party E running on input EDB
in the second case. Note that A can behave arbitrarily in all
these protocol instances. Let q be the number of GenToken
instances and let avi be D’s local output in the i-th instance.
If at any point A halts and outputs a bit b, the game outputs
(b, av1, . . . , avq).
A,S(λ): A(1λ) chooses (DB, RDK, P) as above, while
IdealΠ
the experiment initializes S = (S0, S1, S2) by running st ←
S0(1λ). Subsequently, each time A invokes an instance of
protocol GenToken, it interacts with the experiment running
S1(st, P), whereas if A invokes an instance of protocol Search,
it interacts with the experiment running S2(st). Both S1 and
S2 algorithms are allowed to update the global simulator’s
state st while interacting with A. Both can issue queries ¯w
to I-SSEL(DB, RDK, P). Let q be the number of these queries
and let avi = I( ¯wi), where ¯wi is the i-th query. As above,
if at any point A halts and output a bit b, the game outputs
(b, av1, . . . , avq).

We call Π L-semantically-secure against malicious clients
if for any eﬃcient algorithm A there is an eﬃcient algorithm
S s.t. the statistical diﬀerence between tuples (b, av1, . . . , avq)
output by experiments RealΠ
A,S is a negligible
function of the security parameter λ.

A and IdealΠ

Security against adversarial data owner. Security against
a data-owner D models privacy of the client’s queries ¯w
against malicious D, given an adaptive choice of the client’s
queries. Similarly to the case of security against either the
client C or the EDB-storing server E , this security deﬁnition
also allows for leakage of some information L( ¯w) regarding
the query ¯w to D.

A(λ) and IdealΠ

Definition 2. Let Π = (EDBSetup, GenToken, Search) be
an OSPIR-SSE scheme. Given algorithms L, A, and S we
deﬁne experiments (algorithms) RealΠ
A,S(λ)
as follows:
A(λ): Adversary A(1λ) can adaptively invoke any num-
RealΠ
ber of GenToken instances by specifying a query ¯w and inter-
acting with party C running the GenToken protocol on input
¯w. At any point A can halt and output a bit, which the game
uses as its own output.
IdealΠ
A,S(λ): Adversary A(1λ) can adaptively invoke any
number of GenToken instances as above, but for any query
¯w which A speciﬁes, it interacts with S running on input
L( ¯w). As above if A halts and output a bit, the game uses
this bit as its own output.

We call Π L-semantically-secure against malicious data
owner if for any eﬃcient alg. A there is an eﬃcient alg. S
s.t. Pr[RealΠ

A(λ)=1] − Pr[IdealΠ

A,S(λ)=1] ≤ neg(λ).

Note (non-collusion between D and E ). We stress that even
though the data owner D can be arbitrarily malicious, we as-
sume that D and E do not collude. Indeed, client’s security
in the OSPIR-OXT scheme we propose is not maintained
against such collusion. Moreover, providing query-privacy
from D under collusion with E would have the (impracti-
cal) cost of a single-server symmetric PIR protocol. The
hospital example mentioned in the introduction, is a case
where such non-collusion requirement makes sense. Indeed,
it is the hospital interest not to learn the queries: It helps
avoiding liability and complying with regulations as well as
withstanding potential insider attacks. Similarly, for a ser-
vice providing private access to a database (e.g. to a patent
repository) preserving client privacy is part of its very busi-
ness model. See also [18].
5.2 Security of OSPIR-OXT
Correctness of OSPIR-OXT. We ﬁrst argue that proto-
col OSPIR-OXT is correct.

Theorem 3. The OSPIR-SSE scheme OSPIR-OXT in-
stantiated with the Hashed Diﬃe-Hellman OPRF is compu-
tationally correct assuming that the DDH assumption holds,
that the T-set implementation is computationally correct,
that Fp is a secure PRF, and assuming the Random Ora-
cle Model for hash function H.

Since T-set implementation is computationally correct,
any correctness errors can only come from collisions in PRF
functions, including function FKX ,KI eﬀectively used in com-
puting xtag values, deﬁned as FKX ,KI (w, ind) =
G (KX , w))Fp(KI ,ind). But assuming the PRF property of
(F m
Fp, and the PRF property of F m
G , which holds under DDH in
ROM, function FKX ,KI is a PRF too, and so collision prob-
ability is negligible, resulting in negligible error probability
over the execution of the OSPIR-OXT correctness experi-
ment.

884Security of OSPIR-OXT. Using the security notions ex-
plained above we describe the security properties of the
OSPIR-SSE scheme OSPIR-OXT instantiated with the Hashed
Diﬃe-Hellman OPRF, as shown in Figure 3. We ﬁrst state
the OM-GDH security assumption required for the security
of the OPRF and S-OPRF sub-protocols of this OSPIR-OXT
instantiation.
One-More Gap Diﬃe-Hellman (OM-GDH). Let G =
Gλ be a prime order cyclic group of order p = p(λ) generated
by g. We say that the One-More Gap Diﬃe-Hellman (OM-
GDH) assumption holds in G if Advddh
G,A(λ) is negligible for
all eﬃcient adversaries A, where Advddh
G,A(λ) is deﬁned as the
probability that A wins the following game: (1) The game
chooses random t in Z ∗
p and two random elements h1, h2 in
G; (2) A, on input h1, h2, speciﬁes a single query a to the
Diﬃe-Hellman oracle, which on input a returns b ← at; (3)
A can make any number of queries to a Decisional Diﬃe-
Hellman oracle DDHt(·, ·), which on input (h, v) returns 1 if
v = ht and 0 otherwise; (4) Finally A outputs two values
v1, v2, and we say that A wins the game if v1 = (h1)t and
v2 = (h2)t.
Security against adversarial server E . The OSPIR-
SSE scheme OSPIR-OXT is Loxt-semantically-secure against
adaptive server E under the same assumptions and for the
same leakage function Loxt as the underlying SSE scheme
OXT of [9]. This is because the speciﬁc PRF’s used by
OSPIR-OXT in EDB construction are instantiations of gen-
eral PRF’s considered in OXT, and because E ’s view of the
Search protocol in the OSPIR-OXT scheme can be generated
from E ’s view of Search in the OXT scheme. Speciﬁcally, each
ρi in env is random in Z ∗
p , and bstag and each bxtoken[c, i]
value in Figure 3 can be computed by exponentiating values
stag and xtoken[c, i] in Figure 1 to, respectively, ρ1 and ρi.
Security against adversarial client C. Let Mask(|DB(w1)|)
denote an upper bound on |DB(w1)| used by E to mask the
size of TSet(w1) when responding to C’s queries as described
at the end of Section 3.

Theorem 4. Let L be a deﬁned as L(DB, ¯w) = Mask

(|DB(w1)|) for ¯w = (w1, ..., wn). OSPIR-SSE scheme OSPIR-OXT
instantiated with the Hashed Diﬃe-Hellman OPRF is L-
semantically-secure against malicious clients assuming that
the One-More Gap Diﬃe-Hellman assumption holds in G,
that Fp is a secure PRF, that the T-set implementation
is (computationally) correct, that (AuthEnc, AuthDec) is an
IND-CPA and Strongly-UF-CMA authenticated encryption
scheme, and assuming the Random Oracle Model for hash
function H.

Proof. See full version [20].

Security against adversarial data owner D.
OSPIR-SSE scheme a malicious D learns nothing about clients’
query ¯w = (w1, . . . , wn) except for the vector of attributes
av( ¯w) = (I(w1), . . . , I(wn)).

In our

Theorem 5. Let L be a leakage function deﬁned as L( ¯w) =

av( ¯w). OSPIR-SSE scheme OSPIR-OXT instantiated with
the Hashed Diﬃe-Hellman OPRF is L-semantically-secure
against malicious data owner.

Proof. See full version [20].

and the values as, a1, ..., an. In the Hashed DH OPRF in-
stantiation of this scheme in Figure 3, these values are formed
as aj ← H(wj)rj for random rj ’s in Z ∗
p (additionally, as is
set to a1). Since G is of prime order, every element in G\{1}
is a generator, and thus each aj is uniform in G. Thus D’s
view of the GenToken protocol can be trivially simulated
from L( ¯w) = av( ¯w).
5.3 Extensions: Reducing Leakage to D

In the full version [20] we show how to adapt OSPIR-OXT
to a setting where a third party, called a policy manager, au-
thorizes queries while D can enforce them without learning
the policy, the boolean expression or the queried attributes;
only the number of such attributes is learned by D. This set-
ting is precisely what is needed to implement searches autho-
rized by a warrant while keeping the searched information
hidden from all parties except the authorized searcher.

In addition, OSPIR-OXT can be extended (even without
introducing a policy manager) so that the leakage about
queried attributes to D is further limited to the minimum
needed to make policy decisions (e.g., D may not need to
know the exact attributes in a query but only the attribute
classes they belong to).

Acknowledgment
Supported by the Intelligence Advanced Research Projects
Activity (IARPA) via Department of Interior National Busi-
ness Center (DoI / NBC) contract number D11PC20201.
The U.S. Government is authorized to reproduce and dis-
tribute reprints for Governmental purposes notwithstanding
any copyright annotation thereon. Disclaimer: The views
and conclusions contained herein are those of the authors
and should not be interpreted as necessarily representing the
oﬃcial policies or endorsements, either expressed or implied,
of IARPA, DoI/NBC, or the U.S. Government.

6. REFERENCES
[1] M. Abdalla, M. Bellare, D. Catalano, E. Kiltz,
T. Kohno, T. Lange, J. Malone-Lee, G. Neven,
P. Paillier, and H. Shi. Searchable encryption
revisited: Consistency properties, relation to
anonymous IBE, and extensions. In V. Shoup, editor,
CRYPTO 2005, volume 3621 of LNCS, pages 205–222.
Springer, Aug. 2005.

[2] L. Ballard, S. Kamara, and F. Monrose. Achieving

eﬃcient conjunctive keyword searches over encrypted
data. In S. Qing, W. Mao, J. L´opez, and G. Wang,
editors, ICICS 05, volume 3783 of LNCS, pages
414–426. Springer, Dec. 2005.

[3] M. Bellare, A. Boldyreva, and A. O’Neill.

Deterministic and eﬃciently searchable encryption. In
A. Menezes, editor, CRYPTO 2007, volume 4622 of
LNCS, pages 535–552. Springer, Aug. 2007.

[4] D. J. Bernstein. Faster square roots in annoying ﬁnite

ﬁelds. http://cr.yp.to/papers/sqroot.pdf, 2001.

[5] D. Boneh, G. Di Crescenzo, R. Ostrovsky, and

G. Persiano. Public key encryption with keyword
search. In C. Cachin and J. Camenisch, editors,
EUROCRYPT 2004, volume 3027 of LNCS, pages
506–522. Springer, May 2004.

Note that the D’s view of the GenToken protocol in the
OSPIR-OXT scheme consists of the attribute vector av( ¯w)

[6] D. Boneh and B. Waters. Conjunctive, subset, and
range queries on encrypted data. In S. P. Vadhan,

885editor, TCC 2007, volume 4392 of LNCS, pages
535–554. Springer, Feb. 2007.

[7] J. W. Byun, D. H. Lee, and J. Lim. Eﬃcient

conjunctive keyword search on encrypted data storage
system. In EuroPKI, pages 184–196, 2006.

[8] D. Cash, J. Jaeger, S. Jarecki, C. Jutla, H. Krawczyk,

M.-C. Ro¸su, and M. Steiner. Dynamic Searchable
Encryption in Very Large Databases: Data Structures
and Implementation. Manuscript, 2013.

[9] D. Cash, S. Jarecki, C. Jutla, H. Krawczyk, M. Rosu,
and M. Steiner. Highly-scalable searchable symmetric
encryption with support for boolean queries.
Crypto’2013. Cryptology ePrint Archive, Report
2013/169, Mar. 2013.
http://eprint.iacr.org/2013/169.

[10] Y.-C. Chang and M. Mitzenmacher. Privacy

preserving keyword searches on remote encrypted
data. In J. Ioannidis, A. Keromytis, and M. Yung,
editors, ACNS 05, volume 3531 of LNCS, pages
442–455. Springer, June 2005.

[20] S. Jarecki, C. Jutla, H. Krawczyk, M. C. Rosu, and

M. Steiner. Outsourced symmetric private information
retrieval. http://eprint.iacr.org/2013/.

[21] S. Jarecki and X. Liu. Eﬃcient oblivious

pseudorandom function with applications to adaptive
OT and secure computation of set intersection. In
O. Reingold, editor, TCC 2009, volume 5444 of LNCS,
pages 577–594. Springer, Mar. 2009.

[22] S. Jarecki and X. Liu. Fast secure computation of set

intersection. In SCN 10, LNCS, pages 418–435.
Springer, 2010.

[23] S. Kamara and K. Lauter. Cryptographic cloud

storage. In Financial Cryptography Workshops, pages
136–149, 2010.

[24] S. Kamara, C. Papamanthou, and T. Roeder.

Dynamic searchable symmetric encryption. In Proc. of
CCS’2012, 2012.

[25] K. Kurosawa and Y. Ohtaki. UC-secure searchable
symmetric encryption. In Financial Cryptography,
page 285, 2012.

[11] M. Chase and S. Kamara. Structured encryption and

[26] M. Naor and O. Reingold. Number-theoretic

constructions of eﬃcient pseudo-random functions. In
38th FOCS, pages 458–467. IEEE Computer Society
Press, Oct. 1997.

[27] V. Pappas, B. Vo, F. Krell, S. G. Choi, V. Kolesnikov,

A. Keromytis, and T. Malkin. Blind Seer: A Scalable
Private DBMS. Manuscript, 2013.

[28] E. Shi, J. Bethencourt, H. T.-H. Chan, D. X. Song,
and A. Perrig. Multi-dimensional range query over
encrypted data. In 2007 IEEE Symposium on Security
and Privacy, pages 350–364. IEEE Computer Society
Press, May 2007.

[29] D. X. Song, D. Wagner, and A. Perrig. Practical

techniques for searches on encrypted data. In 2000
IEEE Symposium on Security and Privacy, pages
44–55. IEEE Computer Society Press, May 2000.

[30] P. van Liesdonk, S. Sedhi, J. Doumen, P. H. Hartel,
and W. Jonker. Computationally eﬃcient searchable
symmetric encryption. In Proc. Workshop on Secure
Data Management (SDM), pages 87–100, 2010.
[31] B. R. Waters, D. Balfanz, G. Durfee, and D. K.

Smetters. Building an encrypted and searchable audit
log. In NDSS 2004. The Internet Society, Feb. 2004.

[32] WSJ. U.S. Terrorism Agency to Tap a Vast Database

of Citizens. Wall Street Journal 12/13/12.
http://alturl.com/ot72x.

controlled disclosure. In ASIACRYPT 2010, LNCS,
pages 577–594. Springer, Dec. 2010.

[12] E. D. Cristofaro, Y. Lu, and G. Tsudik. Eﬃcient

techniques for privacy-preserving sharing of sensitive
information. In J. M. McCune, B. Balacheﬀ, A. Perrig,
A.-R. Sadeghi, A. Sasse, and Y. Beres, editors,
TRUST, volume 6740 of Lecture Notes in Computer
Science, pages 239–253. Springer, 2011.

[13] R. Curtmola, J. A. Garay, S. Kamara, and

R. Ostrovsky. Searchable symmetric encryption:
improved deﬁnitions and eﬃcient constructions. In
A. Juels, R. N. Wright, and S. Vimercati, editors,
ACM CCS 06, pages 79–88. ACM Press, Oct. / Nov.
2006.

[14] M. J. Freedman, Y. Ishai, B. Pinkas, and O. Reingold.

Keyword search and oblivious pseudorandom
functions. In J. Kilian, editor, TCC 2005, volume 3378
of LNCS, pages 303–324. Springer, Feb. 2005.

[15] E.-J. Goh. Secure indexes. Cryptology ePrint Archive,

Report 2003/216, 2003. http://eprint.iacr.org/.

[16] P. Golle, J. Staddon, and B. R. Waters. Secure

conjunctive keyword search over encrypted data. In
M. Jakobsson, M. Yung, and J. Zhou, editors, ACNS
04, volume 3089 of LNCS, pages 31–45. Springer, June
2004.

[17] Y. Huang and I. Goldberg. Outsourced private

information retrieval with pricing and access control.
Technical Report 2013-11, Centre for Applied
Cryptographic Research (CACR), University of
Waterloo, Feb. 2013.

[18] IARPA. Security and Privacy Assurance Research

(SPAR) Program - BAA, 2011.
http://www.iarpa.gov/solicitations_spar.html/.

[19] M. Islam, M. Kuzu, and M. Kantarcioglu. Access

pattern disclosure on searchable encryption:
Ramiﬁcation, attack and mitigation. In Proceedings of
the Symposium on Network and Distributed Systems
Security (NDSS 2012), San Diego, CA, Feb. 2012.
Internet Society.

886Group operations. G is a cyclic group of prime order p generated by an element g. H is a hash function with range in G \ {1}.

EDBSetup(DB, RDK)

Key Generation. D picks key KS and two vectors of elements KT = (k1, . . . , km) and KX = (e1, . . . , em) at random in Z ∗
p
(m = number of attributes); key KI for PRF Fp; and key KM for a symmetric authenticated encryption AuthEnc. Fp and Fτ are
PRF’s which outputs strings in respectively Z ∗

p and {0, 1}τ , and τ is a security parameter.

• Initialize XSet to an empty set, and initialize T to an empty array indexed by group elements in G.

• For each w = (i, val) ∈ W, build the tuple list t and add elements to set XSet as follows:

– Initialize t to an empty list.
– Set strap ← (H(w))KS ,
G (KT , w) ],
– Initialize c ← 0; then for all ind in DB(w) in random order:

stag ← (H(w))ki [ = F m

(Kz , Ke) ← (Fτ (strap, 1), Fτ (strap, 2)).

∗ Set rdk ← RDK(ind), e ← Enc(Ke, (ind|rdk)), xind ← Fp(KI , ind).
∗ Set c ← c + 1, zc ← Fp(Kz , c), y ← xind · z−1
∗ Set xtag ← H(w)ei ·xind [ = (F m

. Append (e, y) to t.
G (KX , w))xind ] and add xtag to XSet.

c

– T[stag] ← t.

• Create TSet ← TSetSetup0(T), and output key K = (KS , KX , KT , KI , KM ) and EDB = (TSet, XSet, KM ).

GenToken protocol
Client C on input a conjunctive query ¯w = (w1, ..., wn), where w1 is chosen as s-term, proceeds as follows:

• Pick r1, ..., rn

$

← Z ∗

p and set aj ← (H(wj ))rj for j = 1, . . . , n.

• Send to D the blinded queries a1, . . . , an and the attribute sequence av = (I(w1), . . . , I(wn)).

Data owner D on input policy P and key K proceeds as follows:

• Abort if av 6∈ P . Otherwise set av as a local output. Pick ρ1, . . . , ρn
• Set strap0 ← (a1)s, bstag0 ← (a1)ki1

·ρ1 [ = (a1)KT [i1]·ρ1 ], and bxtrap0

$

← Z ∗
p .

j ← (aj )

eij

·ρj [ = (aj )KX [ij ]·ρj ] for j = 2, . . . , n.

• Reply to C with (strap0, bstag0, bxtrap0

2, . . . , bxtrap0

n) and env = AuthEncKM (ρ1, . . . , ρn).

C sets:

• strap ← (strap0)r−1

1 ; bstag ← (bstag0)r−1

1 ; bxtrapj ← (bxtrap0

(∀j=2,...,n);

j)r−1

j

• token ← (env, strap, bstag, bxtrap2, . . . , bxtrapn).

Search protocol

Client C on input token proceeds as follows:

• Set (Kz , Ke) ← F (τ (strap, 1), F (strap, 2)), and send to E the message (env, bstag, bxtoken[1], bxtoken[2], . . .) deﬁned as follows:

– For c = 1, 2, . . ., until E sends stop:

∗ Set zc ← Fp(Kz , c) and set bxtoken[c, i] ← (bxtrapi)zc for i = 2, . . . , n.
∗ Set bxtoken[c] ← (bxtoken[c, 2], . . . , bxtoken[c, n]).

Server E on input EDB = (TSet, XSet, KM ) responds as follows:

• Upon receiving env, bstag from C, decrypt/verify env; if veriﬁcation fails return “no results” and stop.

• Set stag ← (bstag)1/ρ1 and retrieve t ← TSetRetrieve(TSet, stag) from TSet.

• For c = 1, . . . , |t| do:

– Receive bxtoken[c] from C and retrieve value (e, y) from the c-th tuple in t.
– Check if bxtoken[c, i]y/ρi ∈ XSet for all i = 2, . . . , n. If so, send e to C (else nothing is returned for this tuple).
– When last tuple in t is reached, send stop to C and halt.

For each received e client C computes (ind|rdk) ← Dec(Ke, e) and outputs (ind, rdk).

Figure 3: OSPIR-OXT Instantiated for Conjuntions with the Hashed Diffie-Hellman OPRF

887