Succinct Non-Interactive Zero Knowledge  

for a von Neumann Architecture

Eli Ben-Sasson, Technion—Israel Institute of Technology; Alessandro Chiesa,  

Massachusetts Institute of Technology; Eran Tromer, Tel Aviv University;  

Madars Virza, Massachusetts Institute of Technology

https://www.usenix.org/conference/usenixsecurity14/technical-sessions/presentation/ben-sasson

This paper is included in the Proceedings of the 23rd USENIX Security Symposium.August 20–22, 2014 • San Diego, CAISBN 978-1-931971-15-7Open access to the Proceedings of  the 23rd USENIX Security Symposium is sponsored by USENIXSuccinct Non-Interactive Zero Knowledge for a von Neumann Architecture

Eli Ben-Sasson

Alessandro Chiesa

Technion

MIT

Eran Tromer
Tel Aviv University

Madars Virza

MIT

Abstract

Cryptography offers a powerful tool to address these se-
curity concerns: zero-knowledge proofs [43]. The server,
acting as the prover, attempts to convince the client, act-
ing as the veriﬁer, that the following NP statement is true:
“there exists w such that z = F(x,w)”. Indeed:
• The soundness property of the proof system guarantees
that, if the NP statement is false, the prover cannot
convince the veriﬁer (with high probability). Thus,
soundness addresses the client’s integrity concern.

• The zero-knowledge property of the proof system guar-
antees that, if the NP statement is true, the prover can
convince the veriﬁer without leaking any information
about w (beyond was is leaked by the output z). Thus,
zero knowledge addresses the server’s conﬁdentiality.
Moreover, the client sometimes not only seeks soundness
but also proof of knowledge [43, 11], which guarantees
that, whenever he is convinced, not only can he deduce
that a witness w exists, but also that the server knows one
such witness. This stronger property is often necessary to
security if F encodes cryptographic computations, and is
satisﬁed by most zero-knowledge proof systems.

Efﬁciency. Besides the aforementioned security desider-
ata, many settings also call for efﬁciency desiderata. The
client may be either unable or unwilling to engage in
lengthy interactions with the server, or to perform large
computations beyond the “bare minimum” of sending the
input x and receiving the output z. For instance, the client
may be a computationally-weak device with intermittent
connectivity (e.g., a smartphone).

Thus, it is desirable for the proof to be non-interactive
[25, 55, 23]: the server just send the claimed output ˜z,
along with a non-interactive proof string π that attests
that ˜z is the correct output. Moreover, it is also desirable
for the proof to be succinct: π has size Oλ (1) and can be
veriﬁed in time Oλ (|F| +|x| +|z|), where Oλ (·) is some
polynomial in a security parameter λ ; in other words, π is
very short and easy to verify (i.e., veriﬁcation time does
not depend on |w|, nor F’s running time).

We build a system that provides succinct non-interactive
zero-knowledge proofs (zk-SNARKs) for program execu-
tions on a von Neumann RISC architecture. The system
has two components: a cryptographic proof system for
verifying satisﬁability of arithmetic circuits, and a circuit
generator to translate program executions to such circuits.
Our design of both components improves in functionality
and efﬁciency over prior work, as follows.

Our circuit generator is the ﬁrst to be universal:

it
does not need to know the program, but only a bound
on its running time. Moreover, the size of the output
circuit depends additively (rather than multiplicatively)
on program size, allowing veriﬁcation of larger programs.
The cryptographic proof system improves proving and
veriﬁcation times, by leveraging new algorithms and a
pairing library tailored to the protocol.

Introduction

We evaluated our system for programs with up to
10,000 instructions, running for up to 32,000 machine
steps, each of which can arbitrarily access random-access
memory; and also demonstrated it executing programs
that use just-in-time compilation. Our proofs are 230
bytes long at 80 bits of security, or 288 bytes long at
128 bits of security. Typical veriﬁcation time is 5 ms,
regardless of the original program’s running time.
1
1.1 Goal
Consider the setting where a client owns a public input x,
a server owns a private input w, and the client wishes to
learn z := F(x,w) for a program F known to both parties.
For instance, x may be a query, w a conﬁdential database,
and F the program that executes the query on the database.
Security. The client is concerned about integrity of
computation: how can he ascertain that the server reports
the correct output z? In contrast, the server is concerned
about conﬁdentiality of his own input: how can he prevent
the client from learning information about w?

USENIX Association  

23rd USENIX Security Symposium  781

zk-SNARKs. A proof system achieving the above se-
curity and efﬁciency desiderata is called a (publicly-
veriﬁable) zero-knowledge Succinct Non-interactive AR-
gument of Knowledge (zk-SNARK). zk-SNARK con-
structions can be applied to a wide range of security appli-
cations, provided these constructions deliver good enough
efﬁciency, and support rich enough functionality (i.e., the
class of programs F that is supported).

Remark 1.1. In the zero-knowledge setting above, the
client does not have the server’s input, and so cannot
conduct the computation on his own. Hence, it is not
meaningful to compare “efﬁciency of outsourced compu-
tation at the server” and “efﬁciency of native execution at
the client”, because the latter was never an option. Non-
interactive zero-knowledge proofs (and zk-SNARKs) are
useful regardless of cross-over points.

Our goal in this paper is to construct

a zk-SNARK implementation supporting executions on a

universal von Neumann RISC machine.

1.2 Prior work
zk-SNARKs. Many works have obtained zk-SNARK
constructions [45, 51, 38, 22, 56, 16, 52, 27]. Three of
these [56, 16, 27] provide implementations, and thus we
brieﬂy recall them. Parno et al. [56] present two main
contributions.
• A zk-SNARK, with essentially-optimal asymptotics,
for arithmetic circuit satisﬁability, based on quadratic
arithmetic programs (QAPs) [38]. They accompany
their construction with an implementation.

• A compiler that maps C programs with ﬁxed memory
accesses and bounded control ﬂow (e.g., array accesses
and loop iteration bounds are compile-time constants)
into corresponding arithmetic circuits.

Ben-Sasson et al. [16] present three main contributions.
• Also a QAP-based zk-SNARK with essentially-
optimal asymptotics for arithmetic circuit satisﬁability,
and a corresponding implementation. Their construc-
tion follows the linear-interactive proofs of [22].

• A simple RISC architecture, TinyRAM, along with a
circuit generator for generating arithmetic circuits that
verify correct execution of TinyRAM programs.

sponding TinyRAM program.

• A compiler that, given a C program, produces a corre-
Finally, Braun et al. [27] re-implemented the protocol
of [56] and combined it with a circuit generator that in-
corporates memory-checking techniques [24] to support
random-access memory [14].
Outsourcing computation to powerful servers. Nu-
merous works [63, 65, 66, 64, 32, 68, 71, 67, 27] seek to
veriﬁably outsource computation to untrusted powerful

servers, e.g., in order to make use of cheaper cycles or
storage. (See Appendix A for a summary.) We stress that
veriﬁable outsourcing of computations is not our goal.
Rather, as mentioned, we study functionality and efﬁ-
ciency aspects of non-interactive zero-knowledge proofs,
which are useful even when applied to relatively-small
computations, and even with high overheads.

Compared to most protocols to outsource computations,
known zk-SNARKs use “heavyweight” techniques, such
as probabilistically-checkable proofs [6] and expensive
pairing-based cryptography. The optimal choice of pro-
tocol, and whether it actually pays off compared to local
native execution, are complex, computation-dependent
questions [71], and we leave to future work the ques-
tion of whether zk-SNARKs are useful for the goal of
outsourcing computations.

1.3 Limitations of prior work
Recent work has made tremendous progress in taking
zk-SNARKs from asymptotic theory into concrete im-
plementations. Yet, known implementations suffer from
several limitations.
Per-program key generation. As in any non-interactive
zero-knowledge proof, a zk-SNARK requires a one-time
trusted setup of public parameters: a key generator sam-
ples a proving key (used to generate proofs) and a ver-
iﬁcation key (used to check proofs). However, current
zk-SNARK implementations [56, 16] require the setup
phase to depend on the program F, which is hard-coded
in the keys. Key generation is costly (quasilinear in F’s
runtime) and is thus difﬁcult to amortize if conducted
anew for each program. More importantly, per-program
key generation requires, for each new choice of program,
a trusted party’s help.
Limited support for high-level languages. Known cir-
cuit generators have limited functionality or efﬁciency:
(i) [56]’s circuit generator only supports programs with-
out data dependencies, since memory accesses and loop
iteration bounds cannot depend on a program’s input;
(ii) [27]’s circuit generator allows data-dependent memory
accesses, but each such access requires expensive hashing
to verify Merkle-tree authentication paths; (iii) [16]’s cir-
cuit generator supports arbitrary programs but its circuit
size scales inefﬁciently with program size (namely, it has
size Ω((cid:31)T ) for (cid:31)-instruction T -step TinyRAM programs).
Moreover, while there are techniques that mitigate some
of the above limitations [72], these only apply in special
cases, and not do address general data dependencies, a
common occurrence in many programs.
Generic
aforementioned
zk-SNARKs use several sub-algorithms, and in particular
elliptic curves and pairings. Protocol-speciﬁc optimiza-
tions are a key ingredient in fast implementations of

sub-algorithms.

The

782  23rd USENIX Security Symposium 

USENIX Association

2

pairing-based protocols [59], yet prior implementations
only utilize off-the-shelf cryptographic libraries, and miss
key optimization opportunities.

1.4 Results
We present two main contributions: a new circuit genera-
tor and a new zk-SNARK for circuits. These can be used
independently, or combined to obtain an overall system.

1.4.1 A new circuit generator
We design and build a new circuit generator that incorpo-
rates the following two main improvements.
(1) Our circuit generator is universal: when given input
bounds (cid:31),n,T , it produces a circuit that can verify the
execution of any program with ≤ (cid:31) instructions, on any
input of size ≤ n, for ≤ T steps. Instead, all prior circuit
generators [66, 64, 56, 16, 27] hardcoded the program
in the circuit. Combined with a zk-SNARK for circuits
(or any NP proof system for circuits), we achieve a no-
table conceptual advance: once-and-for-all key genera-
tion that allows verifying all programs up to a given size.
This removes major issues in all prior systems: expen-
sive per-program key generation, and the thorny issue of
conducting it anew in a trusted way for every program.

Our circuit generator supports a universal machine
that, like modern computers, follows the von Neumann
paradigm (program and data lie in the same read/write
address space). Concretely, it supports a von Neumann
RISC architecture called vnTinyRAM, a modiﬁcation of
TinyRAM [17]. Thus, we also support programs leverag-
ing techniques such as just-in-time compilation or self-
modifying code [36, 58].

To compile C programs to the vnTinyRAM machine
language, we ported the GCC compiler to this architecture,
building on the work of [16].

See Figure 1 for a functionality comparison with prior

circuit generators (for details, see [27, §2]).
Supported functionality
side-effect free comp.
data-dep. mem. accesses
data-dep. contr. ﬂow
self-modifying code
universality

[66, 64, 56]

[16]
(cid:31)
(cid:31)
(cid:31)
×
×

(cid:31)
×
×
×
×

[27]
(cid:31)
(cid:31)
×
×
×

this work

(cid:31)
(cid:31)
(cid:31)
(cid:31)
(cid:31)

Figure 1: Functionality comparison among circuit generators.

(2) Our circuit generator efﬁciently handles larger arbi-
trary programs: the size of the generated circuit C(cid:31),n,T

pendence on program size is additive, instead of multi-
plicative as in [16], where the generated (non-universal)

is O(cid:31)((cid:31) + n + T ) · log((cid:31) + n + T )(cid:30) gates. Thus, the de-
circuit has size Θ(cid:31)(n +T )· (log(n +T ) + (cid:31))(cid:30). As Figure 2

shows, our efﬁciency improvement compared to [16] is

not merely asymptotic but yields sizable concrete sav-
ings: as program size (cid:31) increases, our amortized per-cycle
gate count is essentially unchanged, while that of [16]
grows without bound, becoming orders of magnitudes
more expensive.

|C(cid:31),n,T|/T

improvement

n = 102
T = 220
(cid:31) = 103
(cid:31) = 104
(cid:31) = 105
(cid:31) = 106

[16]
1,872
10,872
100,872
1,000,872

1.4×
7.9×
72.1×
590.8×
Figure 2: Per-cycle gate count improvements over [16].

this work
1,368
1,371
1,400
1,694

An efﬁciency comparison with other non-universal cir-
cuit generators [66, 64, 56, 27] is not well-deﬁned. First,
they support more restricted classes of programs, so a pro-
grammer must “write around” the limited functionality.
Second, their efﬁciency is not easily speciﬁed, since the
output circuit is ad hoc for the given program, and the only
way to know its size is to actually run the circuit generator.
We expect, and ﬁnd, that such circuit generators perform
better than ours for programs that are already “close to a
circuit”, and worse for programs rich in data-dependent
memory accesses and control ﬂow.

1.4.2 A new zk-SNARK for circuits
Our third contribution is a high-performance implementa-
tion of a zk-SNARK for arithmetic circuits.
(3) We improve upon and implement the protocol of Parno
et al. [56]. Unlike previous zk-SNARK implementations
[56, 16, 27], we do not use off-the-shelf cryptographic
libraries. Rather, we create a tailored implementation
of the requisite components: the underlying ﬁnite-ﬁeld
arithmetic, elliptic-curve group arithmetic, pairing-based
checks, and so on.

To facilitate comparison with prior work, we instanti-
ate our techniques for two speciﬁc algebraic setups: we
provide an instantiation based on Edwards curves [33] at
80 bits of security (as in [16]), and an instantiation based
on Barreto–Naehrig curves [9] at 128 bits of security (as
in [56, 27]).

On our reference platform (a typical desktop), proof
veriﬁcation is fast: at 80-bit security, for an n-byte input
to the circuit, veriﬁcation takes 4.7 + 0.0004· n millisec-
onds, regardless of circuit size; at 128-bit security, it takes
4.8 + 0.0005· n. The constant term dominates for small
inputs, and corresponds to the veriﬁer’s pairing-based
checks; in both cases, it is less than half the time for sep-
arately evaluating the 12 requisite pairings of the checks.
We achieve this saving by merging parts of the pairings’
computation in a protocol-dependent way — another rea-
son for a custom implementation of the underlying math.

USENIX Association  

23rd USENIX Security Symposium  783

3

Key generation and proof generation entail a per-gate
cost. For example, for a circuit with 16 million gates: at
80 bits of security, key generation takes 81 µs per gate
and proving takes 109 µs per gate; at 128 bits of security,
these per-gate costs mildly increase to 100 µs and 144 µs.
As in previous zk-SNARK implementations, proofs
have constant size (independent of the circuit or input
size); for us, they are 230 bytes at 80 bits of security, and
288 bytes at 128 bits of security.

Compared to previous implementations of zk-SNARKs
for circuits [56, 16, 27], our implementation improves
both proving and veriﬁcation times, e.g., see Figure 3.

80 bits of security

128 bits of security

Key gen.
Prover
Veriﬁer
Proof

[16]
306s
351s
66.1ms
322B

this
97s
115s
4.9ms
230B

impr.
3.2×
3.1×
13.5×
1.4×

[56]
123s
784s
9.2ms
288B

this
117s
147s
5.1ms
288B

impr.
1.1×
5.3×
1.8×
(same)

Figure 3: Comparison with prior zk-SNARKs for a 1-million-gate arith-
metic circuit and a 1000-bit input, running on our benchmarking ma-
chine, using software provided by the respective authors. Since [27] is
a re-implementation of [56], we only include the latter’s performance.
(N = 5 and std < 2%)

1.4.3 Two components: independent or combined
Our new circuit generator and our new zk-SNARK for
circuits can be used independently. For instance, the
circuit generator can (up to interface matching) replace
the circuit generators in [66, 64, 56, 16, 27], thus granting
these systems universality. Similarly, our zk-SNARK
for circuits can replace the underlying zk-SNARKs in
[56, 16, 27], or be used directly in applications where a
suitable circuit is already speciﬁed.

Combining these two components, we obtain a full
system: a zk-SNARK for proving/verifying correctness of
vnTinyRAM computations; see Figure 4 and Figure 5 for
diagrams of this system. We evaluated this overall sys-
tem for programs with up to 10,000 instructions, running
for up to 32,000 steps. Veriﬁcation time is, again, only
few milliseconds, independent of the running time of the
vnTinyRAM program, even when program size and input
size are kilobytes. Proofs, as mentioned, have a small
constant size. Key generation and proof generation entail
a per-cycle cost, with a dependence on program size that
“tapers off” as computation length increases. For instance,
at 128-bit security and vnTinyRAM with a word size of
32 bits, key generation takes 210ms per cycle and proving
takes 100ms per cycle, for 8K-instruction programs.
JIT case study: efﬁcient memcpy. Besides evaluat-
ing individual components, we give an example demon-
strating the rich functionality supported by the integrated
system. We wrote a vnTinyRAM implementation of
memcpy that leverages just-in-time compilation (in par-

OFFLINE PHASE (ONCE) 

Key Generator 

circuit 

generator 

universal 
circuit 

zk-SNARK 

key generator 

program size bound 
input size bound 
time bound 

proving key 

verification key 

Figure 4: Ofﬂine phase (once). The key generator outputs a proving
key and veriﬁcation key, for proving and verifying correctness of any
program execution meeting the given bounds.

Prover 

ONLINE PHASE (ANY NUMBER OF TIMES) 
Verifier 

auxiliary 
input 

(nondeterminism) 

witness 
map 

circuit 

assignment 

zk-SNARK 
prover 

proof 

zk-SNARK 
verifier 

accept/ 
reject 

program  input 

proving key 

verif. key 

program  input 

Figure 5: Online phase (any number of times). The prover sends a
short and easy-to-verify proof to a veriﬁer. This can be repeated any
number of times, each time for a different program and input.

ticular, dynamic loop unrolling) to require fewer cycles.
(See Section B.)
2 Preliminaries
F[z] denotes the ring of univariate polynomials over F,
and by F≤d[z] the subring of polynomials of degree ≤ d.
Concatenation of vectors/scalars is denoted by ◦.
2.1 Arithmetic circuits
Given a ﬁnite ﬁeld F, an F-arithmetic circuit takes inputs
that are elements in F, and its gates output elements in F.
The circuits we consider only have bilinear gates.1
Deﬁnition 2.1. Let n,h,l respectively denote the input,
witness, and output size. The circuit satisfaction prob-
lem of a circuit C : Fn × Fh → Fl with bilinear gates is
deﬁned by the relation RC = {((cid:28)x,(cid:28)a) ∈ Fn×Fh : C((cid:28)x,(cid:28)a) =
0l} and language LC = {(cid:28)x ∈ Fn : ∃(cid:28)a ∈ Fh, C((cid:28)x,(cid:28)a) = 0l}.
All the arithmetic circuits we consider are over prime
ﬁelds Fp. In this case, when passing boolean strings as
inputs to arithmetic circuits, we pack the string’s bits into
as few ﬁeld elements as possible: given s ∈ {0,1}m, we
use [[s]]m
, where |m|p :=
(cid:22)m/(cid:21)log p(cid:20)(cid:19), such that the binary representation of xi ∈
Fp is the i-th block of (cid:22)log p(cid:19) bits in s (padded with 0’s if
needed). We extend the notation [[s]]m
p to binary strings s ∈
p := [[s0m−n]]m
{0,1}n with n < m bits via padding: [[s]]m
p .
2.2 Quadratic arithmetic programs
Our zk-SNARK leverages quadratic arithmetic programs
(QAPs), introduced by Gennaro et al. [38].
Deﬁnition 2.2. A quadratic arithmetic program of size
m and degree d over F is a tuple ((cid:28)A,(cid:28)B, (cid:28)C,Z), where
(cid:28)A,(cid:28)B, (cid:28)C are three vectors, each of m + 1 polynomials in
F≤d−1[z], and Z ∈ F[z] has degree exactly d.
1A gate with inputs x1, . . . ,x m ∈ F is bilinear if the output is
(cid:17)(cid:28)a, (1,x1, . . . ,x m)(cid:16)·(cid:17)(cid:28)b, (1,x1, . . . ,x m)(cid:16) for some (cid:28)a,(cid:28)b ∈ Fm+1. In particu-
lar, these include addition, multiplication, and constant gates.

p to denote the vector (cid:28)x ∈ F|m|p

p

784  23rd USENIX Security Symposium 

USENIX Association

4

Like a circuit, a QAP induces a satisfaction problem:

Deﬁnition 2.3. The satisfaction problem of a size-m
QAP ((cid:31)A,(cid:31)B, (cid:31)C,Z) is the relation R((cid:31)A,(cid:31)B,(cid:31)C,Z) of pairs ((cid:31)x,(cid:31)s)
such that (i) (cid:31)x ∈ Fn, (cid:31)s ∈ Fm, and n ≤ m; (ii) xi = si for
i ∈ [n] (i.e., (cid:31)s extends (cid:31)x); and (iii) the polynomial Z(z)
divides the following one:

(A0(z) + ∑m

i=1 siAi(z))· (B0(z) + ∑m

i=1 siBi(z))

− (C0(z) + ∑m

i=1 siCi(z)) .

We denote by L((cid:31)A,(cid:31)B,(cid:31)C,Z) the language of R((cid:31)A,(cid:31)B,(cid:31)C,Z).
Gennaro et al. [38] showed that circuit satisﬁability can
be efﬁciently reduced to QAP satisﬁability (which can
then be proved and veriﬁed using zk-SNARKs):

Lemma 2.4. There exist two polynomial-time algorithms
QAPinst, QAPwit that work as follows. For any circuit
C : Fn×Fh → Fl with a wires and b gates, ((cid:31)A,(cid:31)B, (cid:31)C,Z) :=
QAPinst(C) is a QAP of size m and degree d over F that
satisﬁes the following three properties.
• EFFICIENCY. It holds that m = a and d = b + l + 1.
• COMPLETENESS. For any ((cid:31)x,(cid:31)a) ∈ RC, it holds that
• PROOF OF KNOWLEDGE. For any ((cid:31)x,(cid:31)s) ∈ R((cid:31)A,(cid:31)B,(cid:31)C,Z),
• NON-DEGENERACY. The polynomials A0, . . . ,A n are

((cid:31)x,(cid:31)s) ∈ R((cid:31)A,(cid:31)B,(cid:31)C,Z), where (cid:31)s := QAPwit(C,(cid:31)x,(cid:31)a).
it holds that ((cid:31)x,(cid:31)a) ∈ RC, where (cid:31)a is a preﬁx of (cid:31)s.
nonzero and distinct.

2.3 Pairings
Let G1 and G2 be two cyclic groups of order r. We
denote elements of G1,G2 via calligraphic letters such
as P, Q. We write G1 and G2 in additive notation.
Let P1 be a generator of G1, i.e., G1 = {αP1}α∈Fr
(α is also viewed as an integer, hence αP1 is well-
deﬁned); let P2 be a generator for G2. A pairing is
an efﬁcient map e: G1 × G2 → GT , where GT is also a
cyclic group of order r (which we write in multiplicative
notation), satisfying the following properties: (i) bilin-
earity: for every nonzero elements α,β ∈ Fr, it holds
that e(αP1,β P2) =e(P 1, P2)αβ ; (ii) non-degeneracy:
e(P1, P2) is not the identity in GT .

zk-SNARKs for arithmetic circuits

2.4
A (preprocessing) zk-SNARK for F-arithmetic circuit
satisﬁability (see, e.g., [22]) is a triple of polynomial-
time algorithms (G,P,V ), called key generator, prover,
and veriﬁer. The key generator G, given a security pa-
rameter λ and an F-arithmetic circuit C : Fn × Fh → Fl,
samples a proving key pk and a veriﬁcation key vk; these
are the proof system’s public parameters, which need
to be generated only once per circuit. After that, any-
one can use pk to generate non-interactive proofs for the

language LC, and anyone can use the vk to check these
proofs. Namely, given pk and any ((cid:31)x,(cid:31)a) ∈ RC, the hon-
est prover P(pk,(cid:31)x,(cid:31)a) produces a proof π attesting that
(cid:31)x ∈ LC; the veriﬁer V (vk,(cid:31)x,π) checks that π is a valid
proof for(cid:31)x ∈ LC. A proof π is both a proof of knowledge,
and a (statistical) zero-knowledge proof. The succinctness
property requires that π has length Oλ (1) and V runs in
time Oλ (|(cid:31)x|), where Oλ hides a (ﬁxed) polynomial in λ .
Constructions. Several zk-SNARK constructions are
known [45, 51, 38, 22, 56, 16, 52]. The most efﬁcient ones
are based on quadratic span programs (QSPs) [38, 52] or
quadratic arithmetic programs (QAPs) [38, 22, 56, 16].
We focused on QAP-based constructions, because QAPs
allow for tighter reductions from arithmetic circuits (see
Lemma 2.4). Concretely, we build on the QAP-based
zk-SNARK protocol of Parno et al. [56] (see Section 4).

Remark 2.5 (full succinctness). The key generator G
takes C as input, and so its complexity is linear in |C|.
One could require G to not take C as input, and have
its output keys work for all (polynomial-size) circuits
C; then, G’s running time would be independent of C.
A zk-SNARK satisfying this stronger property is fully
succinct. Theoretical constructions of such zk-SNARKs
are known, based on various cryptographic assumptions
[54, 69, 21]. Despite achieving essentially-optimal asymp-
totics [6, 18, 15, 14, 21] no implementations of them have
been reported to date.

2.5 A von Neumann RISC architecture
Ben-Sasson et al. [16] introduced TinyRAM, a Harvard
RISC architecture with word-addressable memory. We
modify TinyRAM to obtain vnTinyRAM, which differs
from it in two main ways. First, vnTinyRAM follows the
von Neumann paradigm, whereby program and data are
stored in the same read-write address space; programs
may use runtime code generation. Second, vnTinyRAM
has byte-addressable memory, along with instructions to
load/store bytes or words.2

Besides the above main differences, vnTinyRAM is
very similar to TinyRAM. Namely, it is parametrized by
the word size, denoted W , and the number of registers,
denoted K. The CPU state of the machine consists of
(i) a W -bit program counter; (ii) K general-purpose W -bit
registers; (iii) a 1-bit condition ﬂag. The full state of the
machine also includes memory, which is a linear array
of 2W bytes, and two tapes, each with a string of W -bit
words, and read-only in one direction. One tape is for a
primary input
(treated as nondeterministic, untrusted advice).

and the other for an auxiliary input

2Byte-addressing is common in programs performing array or string
operations (and is a deeply-ingrained assumption in the GCC and LLVM
compilers), while word-addressing in programs performing arithmetic.

USENIX Association  

23rd USENIX Security Symposium  785

5

In memory, an instruction is represented as a double
word (one word for an immediate, and another for opcode,
etc.). Thus, a program is a list of address/double-word
pairs specifying the initial contents of memory; all other
memory locations assume the initial value of 0.

We deﬁne the language of accepting computations:

Deﬁnition 2.6. Fix bounds (cid:31),n,T . The language L(cid:31),n,T
consists of pairs ( , ) such that: (i)
is a program
with ≤ (cid:31) instructions, (ii)
is a primary input with ≤ n
words, (iii) there exists an auxiliary input
)
accepts in ≤ T steps. We denote by R(cid:31),n,T the relation
corresponding to L(cid:31),n,T .

s.t.

( ,

3 Our circuit generator
A circuit generator translates the correctness of suitably-
bounded program executions into circuit satisﬁability:
given input bounds (cid:31),n,T , it produces a circuit that can
verify the execution of any program with ≤ (cid:31) instructions,
on any input of size ≤ n, for ≤ T steps. More precisely,
using the notations [[s]]p (for packing the binary string
s into ﬁeld elements) and |s|p (for computing the num-
ber of ﬁeld elements required to pack s) introduced in
Section 2.1, we deﬁne a (universal) circuit generator for
vnTinyRAM as follows.

Deﬁnition 3.1. A (universal) circuit generator of efﬁ-
ciency f (·) over a prime ﬁeld Fp is a polynomial-time
algorithm circ, together with an efﬁcient witness map
wit, working as follows. For any program size bound
(cid:31), time bound T , and primary-input size bound n, C :=
circ((cid:31),n,T ) is an Fp-arithmetic circuit C : Fm
p → Fl
p,
for m := |(cid:31)2W|p +|nW|p and some h,l, where W is the
word size (cf. Section 2.5).
• EFFICIENCY. The circuit C has f ((cid:31),n,T ) gates.
• COMPLETENESS. Given any program , primary in-
such that(cid:31)( , ), (cid:30) ∈ R(cid:31),n,T , it
put
◦ [[ ]]nW
holds that ((cid:29)x,(cid:29)a) ∈ RC, where (cid:29)x := [[
p and
(cid:29)a := wit((cid:31),n,T,
• PROOF OF KNOWLEDGE. There is a polynomial-time
algorithm such that, given any ((cid:29)x,(cid:29)a) ∈ RC, outputs a
witness

, and witness

p ×Fh

]](cid:31)2W
p

for ( , ) ∈ L(cid:31),n,T .

,

,

).

The circuit C output by circ is universal because it does
not depend on the program or primary input
, but only
on their respective size bounds (cid:31) and n (as well as the
time bound T ). When combined with any proof system
for circuit satisﬁability (e.g., our zk-SNARK), this fact
enables the generation of the proof systems’ parameters
to be universal as well. Namely, it is possible to generate
keys for all bound choices (e.g., in powers of 2) up to some
constant, once and for all; afterwards, one can pick the
keys corresponding to bounds ﬁtting a given computation.
This avoids expensive per-program key generation and,

more importantly, the need for a trusted party to conduct
key generation anew for every program.

We construct a universal circuit generator with the fol-

lowing efﬁciency:

Theorem 3.2. There is a circuit generator of efﬁciency

f ((cid:31),n,T ) =O(cid:31)((cid:31) + n + T ) · log((cid:31) + n + T )(cid:30) over any

prime ﬁeld Fp of size p > 22W , where W is the word
size (cf. Section 2.5).

(In our case, the condition p > 22W is always fulﬁlled.)

3.1 Past techniques
Most of the difﬁculties that arise when designing a circuit
generator have to do with data dependencies. A circuit’s
topology does not depend on its inputs but, in contrast,
program ﬂow and memory accesses depend on the choice
of program and the program’s inputs. Thus, a circuit
tasked with verifying program executions must be “ready”
to support a multitude of program ﬂows and memory
accesses, despite the fact that its topology has already
been ﬁxed. Various techniques have been applied to the
design of circuit generators.
Program analysis.
and its inputs ( ,

In the extreme, if both the program
) are known in advance, designing
a circuit generator is simple: construct a circuit that eval-
uates
) by preparing the circuit’s topology to
match the pre-determined program ﬂow and memory ac-
cesses. But now suppose that only
is known in advance,
but not its inputs ( ,
piece by piece (e.g., separately examine the various loops,
branches, and so on), one could try to design a circuit C
that can handle different choices of inputs. Most prior
circuit generators [66, 64, 56, 27] take this approach.

). In this case, by analyzing

on ( ,

However, this approach suffers from several limitations.
First, the class of supported programs
is not rich, be-
cause support for data dependencies is limited. E.g., [56]
requires array accesses and loop iteration bounds to be
compile-time constants; also, while [27] supports data-
dependent memory accesses, most program ﬂow is also
restricted to be known (or bounded) at compile-time; mit-
igations are possible, but only in special cases [72]. Sec-
ond, and more importantly, this approach does not seem to
allow for designing universal circuit generators, because
the program is not known in advance and thus there is
no program to analyze.
Multiplex every access.
Computers are universal
random-access machines (RAMs), so one approach of
designing a universal circuit is to mimic a computer’s
execution, building a layered circuit as follows. The i-th
layer contains the entire state of the machine (CPU state
and random-access memory) at time step i, and layer i +1
is computed from it by evaluating the transition function

786  23rd USENIX Security Symposium 

USENIX Association

6

of the machine, handling any accesses to memory via mul-
tiplexing. While this approach supports arbitrary program
ﬂow, memory accesses are inefﬁciently supported; indeed,
if memory has S addresses, the resulting circuit is huge:
it has size Ω(T S).
Nondeterministic routing. Ben-Sasson et al. [14] sug-
gested using nondeterministic routing on a Beneˇs network
to support memory accesses efﬁciently; Our circuit gen-
erator builds on the techniques of [14, 16], so we brieﬂy
review the main idea behind nondeterministic routing.

Following [14], Ben-Sasson et al. [16] introduced a
simple computer architecture, called TinyRAM, and con-
structed a routing-based circuit generator for TinyRAM.
They deﬁne the following notions. A CPU state, denoted
S, is the CPU’s contents (e.g., program counter, regis-
ters, ﬂags) at a given time step. An execution trace for
a program , time bound T , and primary input
is a
sequence tr = (S1, . . . ,S T ) of CPU states. An execution
such that
trace tr is valid if there is an auxiliary input
the execution trace induced by
)
is tr.

running on inputs ( ,

We seek an arithmetic circuit C for verifying that tr is
valid. We break this down by splitting validity into three
sub-properties: (i) validity of instruction fetch (for each
time step, the correct instruction is fetched); (ii) validity
of instruction execution (for each time step, the fetched
instruction is correctly executed); and (iii) validity of
memory accesses (each load from an address retrieves the
value of the last store to that address).

The ﬁrst two properties are veriﬁed as follows. Con-
struct a circuit C so that, for any two CPU states S and S(cid:31),
C (S,S(cid:31),g) is satisﬁed for some “guess” g if and only if S(cid:31)
can be reached from S (by fetching from the instruction
indicated by the program counter in S and then executing
it), for some state of memory. Then, properties (i) and
(ii) hold if C (Si,Si+1,·) is satisﬁable for i = 1, . . . ,T − 1.
Thus, C contains T − 1 copies of C , each wired to a pair
of adjacent states in tr.
The third property is veriﬁed via nondeterministic rout-
ing. Assume that C also gets as input MemSort(tr), which
equals to the sorting of tr by accessed memory addresses
(breaking ties via timestamps), and write a circuit Cmem so
that validity of memory accesses holds if Cmem is satisﬁed
by each pair of adjacent states in MemSort(tr). (Roughly,
Cmem checks consistency of “load-after-load”, “load-after-
store”, and so on.) However, C merely gets some auxiliary
input tr∗, which purports to be MemSort(tr). So C works
as follows: (a) C has T − 1 copies of Cmem, each wired to
a pair of adjacent states in tr∗; (b) C separately veriﬁes
that tr∗ = MemSort(tr) by routing on a O(T logT )-node
Beneˇs network. The switches of the routing network are
set according to non-deterministic guesses (i.e., additional
values in the auxiliary input), and the routing network
merely veriﬁes that the switch settings induce a permu-

tation; this allows for a very tight reduction. (Known
constructions that compute the correct permutation hide
large constants in big-oh notation [1].)
Past inefﬁciencies. After ﬁlling in additional details,
the construction of [16] reviewed above gives a circuit

of size Θ(cid:31)(n + T ) · (log(n + T ) + (cid:29))(cid:30) = Ω((cid:29) · T ). The
Ω((cid:29)· T ) arises from the fact that all of the (cid:29) instructions
are hardcoded into each of the T − 1 copies of C .
in
Thus, besides being non-universal, the circuit scales inef-
ﬁciently as (cid:29) grows (e.g., for (cid:29) = 104, C ’s size is already
dominated by ’s size).

3.2 Our construction
In comparison to [16], our circuit generator is universal
and, moreover, its size only grows with (cid:29) + T (additive
dependence on program size) instead of with (cid:29)· T (mul-
tiplicative dependence). As our evaluation demonstrates
(see Section 5.1), the size improvement actually translates
into signiﬁcant savings in practice.

Instead of hardcoding the program into each copy
of the circuit C , we follow the von Neumann paradigm,
where the program lies in the same read/write memory
space as data. We ensure that
is loaded into the initial
state of memory, using a dedicated circuit; we then verify
instruction fetch via the same routing network that is used
for checking data loads/stores. While the idea is intuitive,
realizing it involves numerous technical difﬁculties, some
of which are described below.
Routing instructions and data. We extend an execution
trace to not only include CPU states but also instructions:
tr = (S1,I1, . . . ,S T ,IT ) where Si is the i-th CPU state, and
Ii is the i-th executed instruction. We seek an arithmetic
circuit C that checks tr, in this “extended” format, for the
same three properties as above: (i) validity of instruction
fetch; (ii) validity of instruction execution; (iii) validity of
memory accesses.

As in [16], checking that tr satisﬁes property (ii)
is quite straightforward. Construct a circuit Cexe so
that, given two CPU states S,S(cid:31) and an instruction I,
Cexe(S,S(cid:31),I,g) is satisﬁed, for some guess g, if and only
if S(cid:31) can be reached from S, by executing I, for some state
of memory. Then, C contains T − 1 copies of Cexe, each
wired to adjacent CPU states and an instruction, i.e., the
i-th copy is Cexe(Si,Si+1,Ii,gi).

Unlike [16], though, we verify properties (i) and (iii)
jointly, via the same routing network. The auxiliary input
now contains tr∗ = (A1, . . . ,A 2T ), purportedly equal to the
memory-sorted list of both instructions fetches and CPU
states. (Since the program lies in the same read-write
memory as data, an instruction fetch from is merely
a special type of memory load.) Thus, to check that tr
satisﬁes properties (i) and (iii), we design C to (a) verify
that tr∗ = MemSort(tr) via nondeterministic routing, and

USENIX Association  

23rd USENIX Security Symposium  787

7

(b) verify validity of all (i.e., instruction and data) memory
accesses, via a new circuit C(cid:31)mem applied to each pair of
adjacent items Ai,Ai+1 in tr∗. Thus, in this approach,
is never replicated T times; rather, the fetching of its
instructions is veriﬁed together with all other memory
accesses, one instruction fetch at a time.
Multiple memory-access types. Each copy of C(cid:31)mem
inspects a pair of items in tr∗ and (assuming tr∗ =
MemSort(tr)) must ensure consistency of “load-after-
load”, “load-after-store”, and so on. However, unlike
in [16], the byte-addressable memory of vnTinyRAM
is accessed in different-sized blocks:
instruction-size
blocks for instruction fetch; word-size blocks when
loading/storing words; and byte-size blocks when load-
ing/storing bytes. The consistency checks in C(cid:31)mem must
handle “aliasing”, i.e., accesses to the same point in mem-
ory via different addresses and block sizes.

We tackle this difﬁculty as follows. Double-word
blocks are the largest blocks in which memory is ac-
cessed (as instructions are encoded as double words; cf.
Section 2.5). We thus let each item in tr∗ always specify
a double-word, even if the item’s memory access was
with respect to a smaller-sized block (e.g., word or byte).
With this modiﬁcation, we can let C(cid:31)mem perform consis-
tency checks “at the double-word level”, and handling
word/byte accesses by mapping them to double-word ac-
cesses with suitable shifting and masking.
Booting the machine. We have so far assumed that
the program , given as input to C, already appears in
memory. However, the circuit C sketched so far only
veriﬁes the validity of tr with respect to a machine whose
memory is initialized to some state, corresponding to the
execution of some program. But C must verify correct
, and so it must also verify
execution of, speciﬁcally,
. Since C does
that memory is initialized to contain
not explicitly maintain memory (not even the initial one)
and only implicitly reasons about memory via the routing
network, it is not clear how C can perform this check.

We tackle this difﬁculty as follows. We further modify
the the execution trace tr, by extending it with an initial
boot section, preceding the beginning of the computation,
during which the input program is stored into mem-
ory, one instruction i at a time. This extends the length
of both tr and tr∗ from 2T to (cid:30) + 2T , for (cid:30)-instruction
programs, and introduces a new type of item, “boot in-
put store”, in tr∗. Similarly, the routing network is now
responsible for routing (cid:30) + 2T , rather than 2T , packets.
Further optimizations. The above construction sketch
(depicted in Figure 6) is only intuitive, and does not dis-
cuss other optimizations that ultimately yield the perfor-
mance that we report in Section 5.1.

For example, while [16] rely on Beneˇs networks, we
rely on arbitrary-size Waksman networks [10], which

𝐏𝐏1 𝐏𝐏𝟐𝟐 𝐏𝐏ℓ𝓁𝓁 ⋮ 
𝑆𝑆1 
𝐼𝐼1 
𝑆𝑆2 
𝐼𝐼2 
𝑆𝑆3 
⋮ 
𝐼𝐼𝑇 
𝑆𝑆𝑇 

routing 
network 

boot 

𝐶𝐶exe 
𝐶𝐶exe 
⋮ 
𝐶𝐶exe 

𝐶𝐶mem 
𝐶𝐶mem 
𝐶𝐶mem 
𝐶𝐶mem 
𝐶𝐶mem 
𝐶𝐶mem 
⋮ 𝐶𝐶mem 
⋮ 
𝐶𝐶mem 
𝐶𝐶mem 

𝐴𝐴1 
𝐴𝐴2 
𝐴𝐴3 
𝐴𝐴4 
𝐴𝐴5 
𝐴𝐴6 
𝐴𝐴7 
𝐴𝐴8 
⋮ 
𝐴𝐴2T+ℓ𝓁𝓁−1 
𝐴𝐴2T+ℓ𝓁𝓁 

only require N(logN − 0.91) switches to route N packets,
instead of 2(cid:28)logN(cid:27)((cid:28)logN(cid:27)− 0.5). Besides being closer
to the information-theoretic lower bound of N(logN −
1.443), such networks eliminate costly rounding effects
in [16], where the size of the network is doubled if N is
just above a power of 2.
Compiling to vnTinyRAM. To enable veriﬁcation of
higher-level programs, written in C, we ported the GCC
compiler to the vnTinyRAM architecture, by modifying
the Harvard-architecture, word-addressible TinyRAM C
compiler of [16]. Given a C program, written in the
same subset of C as in [16], the compiler produces the
initial memory map representing a program . This also
served to validate the vnTinyRAM architectural choices
(e.g., the move to byte-addressing signiﬁcantly, and added
instructions, improved efﬁciency for many programs).

Figure 6: Outline of our universal circuit construction with the extended
trace tr on the left and (allegedly) its memory sort tr∗ on the right.

4 Our zk-SNARK for circuits

We discuss our second main contribution:
a high-
performance implementation of a zk-SNARK for arith-
metic circuit satisﬁability. Our approach is to tailor
the requisite mathematical algorithms to the speciﬁc
zk-SNARK protocol at hand. While our techniques can be
instantiated in many algebraic setups and security levels,
we demonstrate them in two speciﬁc settings, to facilitate
comparison with prior work.

See Section 2.4 for an informal deﬁnition of a
zk-SNARK for arithmetic circuit satisﬁability. We im-
prove upon and implement the zk-SNARK of Parno et
al. [56]. For completeness the “PGHR protocol” is sum-
marized in the full version of this paper, which provides
pseudocode for its key generator G, prover P, and veriﬁer
V . The construction is based on QAPs, introduced in
Section 2.2.

Like most other zk-SNARKs, the PGHR protocol relies
on a pairing, which is speciﬁed by a prime r ∈ N, three

788  23rd USENIX Security Symposium 

USENIX Association

8

cyclic groups G1,G2,GT of order r, and a bilinear map
e: G1 × G2 → GT . (See Section 2.3.)
A pairing is typically instantiated via a pairing-friendly
elliptic curve. Concretely, suppose that one uses a curve
E deﬁned over Fq, with embedding degree k with re-
spect to r, to instantiate the pairing. Then GT is set to
µr, the subgroup of r-th roots of unity in F∗qk. The in-
stantiation of G1 and G2 depends on the choice of e;
typically, G1 is instantiated as an order-r subgroup of
E(Fq), while, for efﬁciency reasons [7, 8], G2 as an order-
r subgroup of E(cid:28)(Fk/d) where E(cid:28) is a d-th twist of E.
Finally, the pairing e is typically a two-stage function
e(P, Q) := FE(ML(P, Q)), where ML: G1×G2 → Fk
q
is known as Miller loop, and FE: Fk
q is known as
ﬁnal exponentiation and maps α to FE(α) := α (qk−1)/r.
As mentioned, we instantiate our techniques based on
two different curves: an Edwards curve for the 80-bit
security level (as in [16]) and a Barreto–Naehrig curve for
the 128-bits security level (as in [56, 27]). We selected
both the Edwards curve and Barreto–Naehrig curve so
that r− 1 has high 2-adic order (i.e., r− 1 is divisible by
a large power of 2), because this was shown to improve
the efﬁciency of the key generator and the prover [16].

q → Fk

4.1 An optimized veriﬁer
The veriﬁer V takes as input a veriﬁcation key vk, input
(cid:29)x ∈ Fn
r , and proof π, and checks if π is a valid proof for
the statement “(cid:29)x ∈ LC”. The computation of V consists
of two parts. First, use vkIC,0, . . . ,vk IC,n ∈ G1 (part of
vk) and input (cid:29)x to compute vk(cid:29)x := vkIC,0 + ∑n
i=1 xivkIC,i.
Second, use vk, vk(cid:29)x, and π, to compute 12 pairings and
perform the required checks. In other words, V performs
O(n) scalar multiplications in G1, followed by O(1) pair-
ing evaluations.

With regard to V ’s ﬁrst part, variable-base multi-scalar
multiplication techniques can be used to reduce the num-
ber of G1 operations needed to compute vk(cid:29)x [16, 56].
With regard to V ’s second part, even if the pairing evalu-
ations take constant time (independent of the input size
n), these evaluations are very expensive and dominate for
small n. Our focus here is to minimize the cost of these
pairing evaluations.

When only making “black-box” use of a pairing, the
veriﬁer must evaluate 12 pairings, amounting to 12 Miller
loops plus 12 ﬁnal exponentiations. The straightfor-
ward approach is to compute these using a generic high-
performance pairing library. We proceed differently:
we obtain high-performance implementations of sub-
components of a pairing, and then tailor their use speciﬁ-
cally to V ’s protocol.

Namely, ﬁrst, we obtain state-of-the-art implementa-
tions of a Miller loop and ﬁnal exponentiation. We utilize
optimal pairings [70] to minimize the number of loop

iterations in each Miller loop, and, to efﬁciently eval-
uate each Miller loop, rely on the formulas of [3] (for
Edwards curves) and [20] (for BN curves). As for ﬁnal
exponentiation, we use multiple techniques to speed it
up: [62, 44, 35, 50].

Next, building on the above foundation, we incorporate

in V the following optimizations.
(1) Sharing Miller loops and ﬁnal exponentiations.
The veriﬁer V computes two products of two pairings.
We leverage the fact that a product of pairings can be
evaluated faster than evaluating each pairing separately
and then multiplying the results [60]. Concretely, in a
product of m pairings, the Miller loop iterations for evalu-
ating each factor can be carried out in “lock-step” so to
share a single Miller accumulator variable, using one Fqk
squaring per loop instead of m.

In a similar vein, one can perform a single ﬁnal expo-
nentiation on the product of the outputs of the m Miller
loops, instead of m ﬁnal exponentiations and then multi-
plying the results. In fact, since the output of the pairing
can be inverted for free (as the element is unitary so that
inverting equals conjugating [61]), the idea of “sharing”
ﬁnal exponentiations extends to a ratio of pairing products.
Thus, in the veriﬁer we only need to perform 5, instead of
12, ﬁnal exponentiations.

Our implementation incorporates both of the above
techniques. For example, at the 80-bit security level,
separately computing 12 optimal pairings costs 13.6ms,
but the above techniques reduce the time to only 8.1ms.
We decrease this further as discussed next.
(2) Precomputation by processing the veriﬁcation key.
Of the 12 pairings the veriﬁer needs to evaluate, only one
is such that both of its inputs come from the proof π. The
other 11 pairings have one ﬁxed input, either a generator
of G1 or G2, or coming from the veriﬁcation key vk.

When one input to a pairing is ﬁxed, precomputation
techniques apply [60], especially in the case when the
ﬁxed input is the base point in Miller’s algorithm. In V ,
this holds for 9 out of the 11 pairing evaluations. We
thus split the veriﬁer’s computation into an ofﬂine phase,
which consists of a one-time precomputation that only
depends on vk, and a many-time online phase, which
depends on the precomputed values, input (cid:29)x, and proof π.
The result of the ofﬂine phase is a processed veriﬁcation
key vk∗. While vk∗ is longer than vk, it allows the online
phase to be faster.

E.g., at the 80-bit security level, vk∗ decreases the total

cost of pairing checks from 8.1ms to 4.7ms.

4.2 An optimized prover
The prover P takes as input a proving key pk (which in-
cludes the circuit C : Fn
r , and
witness (cid:29)a ∈ Fr. The prover P is tasked to produce a proof

r), input (cid:29)x ∈ Fn

r → Fl

r × Fh

USENIX Association  

23rd USENIX Security Symposium  789

9

π, attesting that (cid:31)x ∈ LC. The computation of P con-
sists of two main parts. First, compute the coefﬁcients(cid:31)h
of the polynomial H(z) := A(z)B(z)−C(z)
, where A,B,C ∈
Fr[z] are derived from the QAP instance ((cid:31)A,(cid:31)B, (cid:31)C,Z) :=
QAPinst(C) and QAP witness(cid:31)s := QAPwit(C,(cid:31)x,(cid:31)a). Sec-
ond, use the coefﬁcients(cid:31)h, QAP witness (cid:31)s, and public key
pk to compute π.

Z(z)

With regard to the ﬁrst part of P, the coefﬁcients (cid:31)h
can be efﬁciently computed via FFT techniques [16, 56];
our implementation follows [16], and leverages the high
2-adic order of r − 1 for both of the elliptic curves we
use. With regard to P’s second part, computing π requires
solving large instances of the following problem: given
elements Q1, . . . ,Q n all in G1 (or all in G2) and scalars
α1, . . . ,α n ∈ Fr, compute (cid:29)(cid:31)α, (cid:31)Q(cid:28) := α1Q1 +··· + αnQn.
Previous work [56, 16] has leveraged generic multi-scalar
multiplication to compute π. We observe that these algo-
rithms can be tailored to the speciﬁc scalar distributions
In P, the vector (cid:31)α is one of two types:
arising in P.
(i) (cid:31)α ∈ Fd+1
and represents the coefﬁcients of the degree-
d polynomial H; or (ii) (cid:31)α = (1◦(cid:31)s◦ δ1 ◦ δ2 ◦ δ3) ∈ F4+m
,
for random δ1,δ2,δ3 ∈ Fr.
In case i, the entries in of (cid:31)α are random-looking. We
use the Bos–Coster algorithm [26] due to its lesser mem-
ory requirements (as compared to, e.g., [57]). We follow
[19]’s suggestions and achieve an assembly-optimized
heap to implement the Bos–Coster algorithm.

r

r

In case ii, the entries in (cid:31)s depend on the input (C,(cid:31)x,(cid:31)a)
to QAPwit; in turn, (C,(cid:31)x,(cid:31)a) depends on our circuit gen-
erator (Section 3). Using the above algorithm “as is” is
inefﬁcient: the algorithm works well when all the scalars
have roughly the same bit complexity, but the entries in
(cid:31)c have very different bit complexity. Indeed, (cid:31)α equals to
(cid:31)s augmented with a few entries; and (cid:31)s, the QAP witness,
can be thought of as the list of wire values in C when
computing on ((cid:31)x,(cid:31)a); the bit complexity of a wire value
depends on whether it is storing a boolean value, a word
value, and so on. We observe that there are only a few
“types” of values, so that the entries of (cid:31)α can be clustered
into few groups of scalars with approximately the same
bit complexity; we then apply the algorithm of [26] to
each such group.

4.3 An optimized key generator
The key generator G takes as input a circuit C : Fn
r →
Fl
r, and is tasked to compute a proving key pk and a
veriﬁcation key vk. The computation of G consists of
two main parts. First, evaluate each Ai,Bi,Ci at a random
element τ, where ((cid:31)A,(cid:31)B, (cid:31)C,Z) := QAPinst(C) is the QAP
instance. Second, use these evaluations to compute pk
and vk.

r ×Fh

With regard to G’s ﬁrst part, we follow [16] and again
leverage the fact that Fr has a primitive root of unity of

large order. With regard to G’s second part, it is dominated
by the cost of computing pk, which requires solving large
instances of the following problem: given an element
P in G1 or G2 and scalars α1, . . . ,α n ∈ Fr, compute
α1P, . . . ,α nP. Previous work [56, 16], used ﬁxed-base
windowing [28] to efﬁciently compute such ﬁxed-base
multi-scalar multiplications.

In our implementation, we achieve additional efﬁciency,
in space rather than in time. Speciﬁcally, we leverage
a structural property of QAPs derived from arithmetic
circuits, in order to reduce the size of the proving key
pk, as we now explain. Lemma 2.4 states that an F-
arithmetic circuit C : Fn × Fh → Fl, with α wires and
β gates, can be converted into a corresponding QAP of
size m = α and degree d ≈ β over F. Roughly, this is
achieved in two steps. First, construct three matrices
A,B,C ∈ F(m+1)×d that encode C’s topology: for each
j ∈ [d], the j-th column of A,B respectively encodes the
“left” and “right” coefﬁcients of the j-th bilinear gate in
C, while the j-th column of C encodes the coefﬁcients of
the gate’s output. Second, letting S ⊂ F be a set of size
d, deﬁne Z(z) := ∏ω∈S(z − ω) and, for i ∈ {0, . . . ,m},
let Ai be the low-degree extension of the i-th row of A;
similarly deﬁne each Bi and Ci. All prior QAP-based
zk-SNARK implementations exploit the fact that columns
in the matrices A,B,C are very sparse.

In contrast, we also leverage a different kind of spar-
sity: we observe that it is common for entire rows of
A,B,C to be all zeroes, causing the corresponding low-
degree extensions to be zero polynomials.3 For instance,
our circuit generator typically outputs a circuit for which
the percentage of non-zero polynomials in (cid:31)A,(cid:31)B, (cid:31)C is only
about 52%,15%,71% respectively. The fact that many
polynomials in (cid:31)A,(cid:31)B, (cid:31)C evaluate to zero can be used to-
wards reducing the size of pk, by switching from a dense
representation to a sparse one.

In fact, we have engineered our circuit generator to re-
duce the number of non-zero polynomials in (cid:31)B as much as
possible, because computations associated to evaluations
of (cid:31)B are conducted with respect to more expensive G2
arithmetic, which we want to avoid as much as possible.

5 Evaluation
We evaluated our system on a desktop computer with
a 3.40 GHz Intel Core i7-4770 CPU (with Turbo Boost
disabled) and 32 GB of RAM. All experiments, except the
largest in Figure 8 and 9, used a small fraction of the RAM.
For the two largest experiments in Figure 9 we added a
Crucial M4 solid state disk for swap space. (While our
code supports multi-threading, our experiments are in
single-thread mode, for comparison with prior work.)

3E.g., if the i-th wire never appears with a non-zero coefﬁcient as

the “left” input of a bilinear gate, then the i-th row of A is zero.

790  23rd USENIX Security Symposium 

USENIX Association

10

5.1 Performance of our circuit generator
In Section 3 we described our universal circuit generator;
we now benchmark its performance.
Parameters. The circuit supports vnTinyRAM, which
is parametrized by two quantities: the word size W and
the number of registers K (see Section 2.5). We report
performance for a machine with K = 16 registers, and
two choices of word size: W = 16 and W = 32.
Methodology. Theorem 3.2 provides an asymptotic ef-
ﬁciency guarantee: it states that our circuit generator has

efﬁciency f ((cid:31),n,T ) = O(cid:31)((cid:31) +n +T )·log((cid:31) +n +T )(cid:30). To

understand concrete efﬁciency, we “uncover” the con-
stants hidden in the big-oh notation. By studying the num-
ber of gates in various subcircuits of the generated circuit
C := circ((cid:31),n,T ), we computed the following (quite tight)
upper bound on C’s size:

4logH − 1.82)· H

(12 + 2W )· (cid:31) + (12 +W )· n +|Cexe|·T + (|Cmem| +
where H := ((cid:31) + n + 2T ) is the “height” of the routing
network, and
• for (W,K) = (16,16): |Cexe| = 777 and |Cmem| = 211;
• for (W,K) = (32,16): |Cexe| = 1114 and |Cmem| = 355.
In Figure 7, we give per-cycle gate counts (i.e., |C|/|T|)
for various choices of ((cid:31),n,T ); we also give sub-counts
divided among program/input boot, CPU execution, mem-
ory checking, and routing. (See the full version of this
paper for an extended table with additional data.)
Discussion. We ﬁrst go through the size expression, to
understand it: The ﬁrst two terms, (12 + 2W )· (cid:31) + (12 +
W )·n, correspond to the pre-execution boot phase, during
which an (cid:31)-instruction program and an n-word primary
input are loaded into the machine. The term |Cexe| · T
corresponds to the T copies of Cexe used to verify each
CPU transition, given the fetched instruction and two CPU
states. The term |Cmem|· H corresponds to the H copies
of Cmem used to verify consistency on the memory-sorted
trace. Finally, the term (4logH −1.82)·H corresponds to
the routing network for routing H packets (two gates for
each of (2logH − 0.91)· H binary switches). Note that
H = ((cid:31) +n +2T ) because boot needs (cid:31) +n memory stores
(one for each program instruction and primary input word)
and execution needs 2T memory accesses (1 instruction
fetch and 1 data store/load per execution cycle).

The gate counts in Figure 7 demonstrate the additive
(instead of multiplicative) dependence on program size of
our universal circuit pays off. For example, for (W,K) =
(32,16), a 100-fold increase in program size, from (cid:31) =
103 to (cid:31) = 105, barely impacts the per-cycle gate count:
for T = 220, it increases from 1,992.5 to only 2,041.5.
Indeed, the cost of program size is incurred, once and
for all, during the machine boot; Figure 7 shows that the
per-cycle cost of machine boot diminishes as T grows.

Second, less than half of C’s gates are dedicated to
verifying accesses to random-access memory, while the
majority of gates are dedicated to verifying execution
of the CPU; indeed, almost always, |Cexe|T > 1
2|C|. Put
otherwise, C, which veriﬁes an automaton with random-
access memory (vnTinyRAM), has size that is less than
twice that for verifying an automaton with the same CPU
but no random-access memory at all. Moreover, note that
the size of Cexe appears quite tight: for example, with
(W,K) = (32,16), it has size 1114, not much larger than
the size of the CPU state (545 bits).
5.2 Performance of our zk-SNARK for cir-

cuit satisﬁability

r × Fh

r → Fl

r , and witness (cid:26)a ∈ Fh

In Section 4 we described our zk-SNARK implementa-
tion; we now benchmark its performance.
Methodology. We provide performance characteristics
for each of the zk-SNARK algorithms, G, P and V , at the
80-bit and 128-bit security levels.
(1) The key generator G takes as input an arithmetic cir-
cuit C : Fn
r. Its efﬁciency mostly depends on
the number of gates and wires in C, because these af-
fect the size and degree of the corresponding QAP (see
Lemma 2.4). Thus, we evaluate G on a circuit with
2i gates and 2i wires for i ∈ {10,12, . . . ,24} (and ﬁxed
n = h = l = 100). In Figure 8 we report the resulting
running times and key sizes, as per-gate costs.
(2) The prover P takes as input a proving key pk, input
(cid:26)x ∈ Fn
r . Its efﬁciency mostly depends
on the number of gates and wires in C (the circuit used
to generate pk); we thus evaluate P on the proving keys
output by G, for the same circuits as above. In Figure 8
we report the times, as per-gate costs, and proof sizes.
(3) The veriﬁer V takes as input a veriﬁcation key vk,
input (cid:26)x ∈ Fn
r , and proof π. Its efﬁciency depends only on
(cid:26)x (since the size of (cid:26)x determines that of vk). Thus, we
evaluate V on a random input (cid:26)x ∈ Fn
r of 2i bytes for i ∈
{2,4, . . . ,20}. In Figure 8 we report the resulting running
times, along with corresponding key sizes.
Discussion. The data demonstrates that our zk-SNARK
implementation works and scales as expected, as long as
sufﬁcient memory is available (e.g., on a desktop com-
puter with 32GB of DRAM: up to 16 million gates). Key
generation takes about 10ms per gate of C; the size of a
proving key is about 300B per gate, and the size of a ver-
iﬁcation key is about 1B per byte of input to C. Running
the prover takes 11ms to 14ms per gate. For an n-byte
input, proof veriﬁcation time is c1n + c0, where c0 is a
few milliseconds and c1 is a few tenths of microseconds.
5.3 Performance of the combined system
As discussed, our circuit generator (Section 3) and
zk-SNARK for circuits (Section 4) can be used in-

USENIX Association  

23rd USENIX Security Symposium  791

11

Per-cycle gate count of C := circ((cid:31),n,T ) with vnTinyRAM parameters (W,K)

n = 102, K = 16

|C|/T
1,367.4
1,399.0
1,431.0
1,370.3
1,399.2
1,431.0
1,399.7
1,401.1
1,431.1

boot
0.04
0.00
0.00
0.41
0.03
0.00
4.12
0.26
0.02

W = 16
|C|/T divided among
exec.
777.0
777.0
777.0
777.0
777.0
777.0
777.0
777.0
777.0

mem.
422.2
422.0
422.0
424.0
422.1
422.0
442.1
423.3
422.1

routing
168.1
200.0
232.0
168.8
200.1
232.0
176.4
200.6
232.0

Per
cycle
1,992.5
2,024.0
2,056.0
1,997.0
2,024.3
2,056.0
2,041.5
2,027.2
2,056.2

W = 32
|C|/T divided among
exec.
1,114.0
1,114.0
1,114.0
1,114.0
1,114.0
1,114.0
1,114.0
1,114.0
1,114.0

mem.
710.4
710.0
710.0
713.4
710.2
710.0
743.9
712.1
710.1

routing
168.1
200.0
232.0
168.8
200.1
232.0
176.4
200.6
232.0

boot
0.08
0.00
0.00
0.72
0.05
0.00
7.19
0.45
0.03

0
1
=
(cid:31)

3 T = 220
T = 224
T = 228
4 T = 220
T = 224
T = 228
5 T = 220
T = 224
T = 228

0
1
=
(cid:31)

0
1
=
(cid:31)

Figure 7: Per-cycle gate counts in C := circ((cid:31),n,T ) for different choices of ((cid:31),n,T ) and vnTinyRAM parameters (W,K).

80 bits of security

128 bits of security

time/|C|
0.21ms
0.16ms
0.14ms
0.12ms
0.11ms
0.10ms
0.09ms
0.08ms

|pk|/|C|
248.8B
252.5B
253.4B
253.7B
253.7B
253.7B
253.7B
253.7B

time/|C|
0.21ms
0.17ms
0.16ms
0.14ms
0.12ms
0.12ms
0.11ms
0.10ms

|pk|/|C|
304.1B
309.1B
310.3B
310.6B
310.7B
310.7B
310.7B
310.7B

2.8KB

3.6KB

time/|C|
0.18ms
0.16ms
0.14ms
0.13ms
0.12ms
0.12ms
0.11ms
0.11ms

|vk|/|(cid:27)x|
118.7B
29.7B
8.1B
2.8B
1.5B
1.1B
1.1B
1.0B
1.0B
1.0B

|π|
230B
230B
230B
230B
230B
230B
230B
230B

time/|(cid:27)x|
1.2ms
0.3ms
76.7 µs
19.5 µs
5.4 µs
1.8 µs
0.8 µs
0.5 µs
0.4 µs
0.4 µs

time/|C|
0.21ms
0.18ms
0.16ms
0.15ms
0.15ms
0.15ms
0.14ms
0.14ms

|vk|/|(cid:27)x|
123.4B
30.8B
8.7B
2.9B
1.5B
1.1B
1.0B
1.0B
1.0B
1.0B

|π|
288B
288B
288B
288B
288B
288B
288B
288B

time/|(cid:27)x|
1.2ms
0.3ms
81.2 µs
20.3 µs
5.9 µs
2.1 µs
1.0 µs
0.7 µs
0.6 µs
0.5 µs

0
0
1
=
n

0
0
1
=
n

key gen. G
|C| = 210
|C| = 212
|C| = 214
|C| = 216
|C| = 218
|C| = 220
|C| = 222
|C| = 224
|vk|
prover P
|C| = 210
|C| = 212
|C| = 214
|C| = 216
|C| = 218
|C| = 220
|C| = 222
|C| = 224

veriﬁer V

|(cid:27)x| = 4B
|(cid:27)x| = 16B
|(cid:27)x| = 64B
|(cid:27)x| = 256B
|(cid:27)x| = 1.0KB
|(cid:27)x| = 4.1KB
|(cid:27)x| = 16.4KB
|(cid:27)x| = 65.5KB
|(cid:27)x| = 262.1KB
|(cid:27)x| = 1.0MB

Figure 8: Per-gate costs of the key generator and prover; and per-byte
costs of the veriﬁer. (N = 10 and std < 1%)

dependently, or combined to obtain a zk-SNARK for
vnTinyRAM. For completeness, the paper’s full version
we spell out how these two components can be combined.
Here we report measured performance of this combined
system, at the 128-bit security level, and for a word size
W = 32 and number of registers K = 16.
Methodology. A zk-SNARK for vnTinyRAM is a triple
of algorithms (KeyGen, Prove, Verify). Given bounds
(cid:31),n,T (for program size, input size, and time), the ef-
ﬁciency of KeyGen and Prove depends on (cid:31),n,T , while

that of Verify essentially depends only on (cid:31),n. Thus, we
benchmark the system as follows. We evaluate KeyGen
and Prove for various choices of (cid:31) and T , while keeping
n = 100. Instead, since the efﬁciency of Verify does not
depend on T , we evaluate Verify, for various choices of (cid:31)
and n, on random (cid:31)-instruction programs and n-word in-
puts. In Figure 9, we report the following measurements:
KeyGen’s running time, the sizes of the keys pk and vk,
Prove’s runtime, the (constant) proof size, and Verify’s
running time. For quantities growing with T , we divide
by T and report the per-cycle cost.
Discussion. The measurements demonstrate that, on
a desktop computer, our zk-SNARK for vnTinyRAM
scales up to computations of 32,000 machine cycles, for
programs with up to 10,000 instructions. Key generation
takes about 200ms per cycle; the size of a proving key is
500KB to 650KB per cycle, and the size of a veriﬁcation
key is a few kilobytes. Running the prover takes 100ms
to 200ms per cycle. Veriﬁcation times remain a few ms ,
even for inputs and programs of several kilobytes.
Program-speciﬁc vk. The time complexity of Verify is
O((cid:31) + n), so veriﬁcation time grows with program size.
This is inevitable, because Verify must read a program
(of at most (cid:31) instructions) and input
(of at most n words)
in order to check, via the given proof π, if ( , ) ∈ L(cid:31),n,T
(cf. Deﬁnition 2.6). However, this is inconvenient, e.g.,
when one has to verify many proofs relative to different
inputs to the same program . In our zk-SNARK it is
possible to amortize this cost as follows. Given vk and ,
one can derive, in time O((cid:31)), aprogram-speciﬁc veriﬁca-
tion key vk , which can be used to verify proofs relative
to any input to . Subsequently, the time complexity of
Verify for any input
5.4 Comparison with prior work
5.4.1 Comparison with prior circuit generators
Universality is the main innovative feature of our circuit
generator. No previous circuit generator achieves univer-

(to ) is O(n), independent of (cid:31).

792  23rd USENIX Security Symposium 

USENIX Association

12

T
/
e
m
i
n t
e
G
y
e
K

T
/
|
k
p
|

|
k
v
|

T
/
e
m

i
t

e
m

i
t

e
v
o
r
P

y
f
i
r
e
V

0
0
1
=
n

T = 4K
T = 8K
T = 16K
T = 32K
T = 4K
T = 8K
T = 16K
T = 32K
T = ∗
0 T = 4K
T = 8K
T = 16K
T = 32K

0
1
=
n

T
f
o

) n = 0
n = 10
n = 102
n = 103
n = 104

.
p
e
d
n
i
(

128 bits of security
W = 32, K = 16

(cid:31) = 2K
209.8ms
190.9ms
195.4ms
206.0ms
584.2KB
552.4KB
539.4KB
533.8KB
17.0KB
75.7ms
69.2ms
89.0ms
98.9ms
19.0ms
19.1ms
19.6ms
23.0ms
48.9ms

(cid:31) = 4K
232.1ms
205.9ms
198.1ms
208.4ms
653.6KB
585.2KB
553.9KB
541.1KB
33.1KB
86.7ms
79.7ms
89.1ms
98.6ms
30.0ms
30.2ms
30.7ms
34.1ms
60.0ms

(cid:31) = 6K
257.5ms
216.1ms
204.2ms
211.2ms
727.1KB
618.1KB
570.4KB
548.3KB
49.2KB
103.4ms
97.0ms
98.4ms
102.3ms
40.6ms
40.7ms
41.3ms
44.7ms
70.6ms

(cid:31) = 8K
275.9ms
228.9ms
213.6ms
213.5ms
784.0KB
655.1KB
586.9KB
555.6KB
65.3KB
104.8ms
110.4ms
99.6ms
102.1ms
51.2ms
51.2ms
51.8ms
55.2ms
81.1ms

(cid:31) = 10K
306.4ms
238.8ms
218.3ms
223.7ms
876.8KB
683.7KB
605.5KB
563.4KB
81.5KB
133.7ms
113.0ms
103.3ms
114.2ms
61.3ms
61.4ms
61.9ms
65.4ms
91.3ms

Figure 9: Per-cycle costs of KeyGen and Prove for various program sizes (cid:31), and total running time of Verify for various (cid:31) and n.

sality. (See Figure 1 and Section 3.)

Putting universality aside and focusing on efﬁciency
instead, a comparison with previous circuit generators is a
multi-faceted problem. On one hand, due to a shared core
of techniques, a comparison with [16]’s circuit generator
is straightforward, and shows signiﬁcant improvements
in circuit size, especially as program size grows. See
Section 1.4.1 and Figure 2 (the ﬁgure is for W,K = 16).
Instead, a comparison with other circuit generators
[66, 64, 56, 27] is complex. First, they support a smaller
class of programs (see Figure 1), so a programmer must
“write around” the limited functionality, somehow. And
second, their efﬁciency is not easily speciﬁed: due to the
program-analysis techniques (see Section 3.1) the output
circuit is ad hoc for the given program, and the only way
to know its size is to actually run the circuit generator.

Compared to [66, 64, 56, 27], our circuit generator
performs better for programs that are rich in memory
accesses and control ﬂow, and worse for programs that
are more “circuit like”.
Comparison with [66, 64, 56]. The circuit generators
in [66, 64, 56] restrict loop iteration bounds and memory
accesses to be known at compile time; if a program does
not respect these restrictions, it must be ﬁrst somehow
mapped to another one that does. For simplicity, we take
[56]’s circuit generator (the latest one) as representative
and, to illustrate the differences between [56]’s and our
circuit generator, we consider two “extremes”.

On one extreme, we wrote a simple C program multi-
plying two 10×10 matrices of 16-bit integers. The circuit
generator in [56] produces a circuit with 1100 gates; in-
stead, our circuit generator (when given the corresponding
vnTinyRAM assembly) produces a much larger circuit:
one with ≈ 107 gates.
On the other extreme, we consider a program mak-
ing many random accesses to memory: pointer-chasing.

Given a permutation π of [N], start position i ∈ [N], and
an integer k, the program outputs πk(i), the element ob-
tained by starting from i and following “pointers” for k
times. Since no information about π is known at com-
pile time, the only way of obtaining π( j), the pointer to
follow, in [56] is via a linear scan. On a simple C pro-
gram that does one linear scan of π to obtain each new
pointer, [56]’s generator outputs a circuit with 2Nk + 1
gates (each of the k array accesses costs 2N gates).

20N

and

In vnTinyRAM, the corresponding program consists
to it is N + 3 words.
of 9 instructions, and the input
Booting vnTinyRAM with
requires 9 + N + 3
“boot stores” (see Section 3.2), and takes 5 + 4k cycles
to execute (independent of N). Say that we ﬁx k = 10;
then, in our circuit generator (with W = 32 and K = 16),
each cycle costs about 2000 gates, and can perform a
random access to memory. Thus, pointer chasing in our
case is cheaper than in [56] already for N > 5000, and the
2000·(5+40) = N
multiplicative saving, which is about
4500,
grows unbounded as N increases.
Comparison with [27]. The circuit generator of [27] is
also based on program analysis, but provides an additional
feature that allows data-dependent memory accesses: a
program may access memory by guessing the value and
verifying its validity via a subcircuit that checks Merkle-
tree authentication paths. In [27], memory consists of
230 cells, and each access costs many gates: 140K for a
load, and 280K for a store. In comparison, in our circuit
generator for vnTinyRAM (with word size W = 32 so
that memory has 232 cells), each memory store/load costs
less than 1000 gates out of about 2000 per cycle (see
Section 5.1). Besides the aforementioned feature, [27]
rely on program analysis, and (as in [66, 64, 56]) only
support bounded control ﬂow. Thus, [27] performs better
than our circuit generator for programs with bounded
control ﬂow and few data-dependent accesses to memory.

USENIX Association  

23rd USENIX Security Symposium  793

13

5.4.2 Comparison with prior zk-SNARKs
Addressing the other component of our system, the
zk-SNARK for circuits: Figure 3 compares our imple-
mentation with prior ones, on a 1-million-gate circuit
with a 1000-byte input. As shown, we mildly improve the
key generation time and, more importantly, signiﬁcantly
improve the “online” costs of proving and veriﬁcation.

6 Conclusion
We have presented two main contributions: (i) a circuit
generator for a von Neumann RISC architecture that is
universal and scales additively with program size; and
(ii) a high-performance zk-SNARK for arithmetic circuit
satisﬁability. These two components can be used inde-
pendently to the beneﬁt of other systems, or combined
into a zk-SNARK that can prove/verify correctness of
computations on this architecture.
The beneﬁts of universality. Universality attains the
conceptual advance of once-and-for-all key generation,
allowing verifying all programs up to a given size. This
removes major issues in prior systems: expensive per-
program key generation and the thorny issue of conduct-
ing it anew in a trusted way for every program.
The price of universality. The price of universality is
still very high. Going forward, and aiming for widespread
use in security applications, more work is required to
slash costs of key generation and proving so to scale up to
larger computations: e.g., billion-gate circuits, or millions
of vnTinyRAM cycles, and beyond. An interesting open
problem is whether the “program analysis” techniques
underlying most prior circuit generators [66, 64, 56, 27],
typically more efﬁcient for restricted classes of programs,
can be used to construct universal circuits.
Beyond vnTinyRAM. Finally, going beyond the foun-
dation of a von Neumann RISC architecture, more work
lies ahead towards a richer architecture (e.g., efﬁcient
support for ﬂoating-point arithmetic and cryptographic
acceleration), code libraries, and tighter compilers.

A Other prior work
Prior work most relevant to us is about zk-SNARKs, and
is discussed in Section 1.2. There are also numerous
works studying variations or relaxations of the goal we
consider; here, we summarize some of them.
Interactive proofs for low-depth circuits. Goldwasser
et al. [42] obtained an interactive proof for outsourc-
ing computations of low-depth circuits. A set of works
[32, 68, 67] has optimized and implemented the proto-
col of [42]. The protocol of [42] can also be reduced
to a two-message argument system [48, 47]. Canetti et
al. [30] showed how to extend the techniques in [42] to
also handle non-uniform circuits.

Batching arguments.
Ishai et al. [46] constructed a
batching argument for NP, where, to simultaneously ver-
ify that N circuits of size S are satisﬁable, the veriﬁer runs
in time max{S2,N}.
A set of works [63, 65, 66, 64] has improved, optimized,
and implemented the batching argument of Ishai et al. [46]
for the purpose of outsourcing computation. In particular,
by relying on quadratic arithmetic programs of [38], Setty
et al. [64] have improved the running time of the veri-
ﬁer and prover to max{S,N}·poly(λ ) and ˜O(S)· poly(λ )
respectively. Vu et al. [71] provide a system that incorpo-
rates both the batching arguments of [63, 65, 66, 64] as
well as the interactive proofs of [32, 68, 67]. The system
decides which of the two approaches is more efﬁcient to
use for outsourcing a given computation.

Braun et al. [27] apply batching techniques (as well
as zk-SNARKs) to verify MapReduce computations, by
relying on various veriﬁable data structures.
Arguments with competing provers. Canetti et al. [29]
use collision-resistant hashes to get a protocol for out-
sourcing deterministic computations in a model where
a veriﬁer interacts with two computationally-bounded
provers at least one of which is honest [34]. The proto-
col in [29] works directly for random-access machines,
and therefore does not require reducing random-access
machines to any “lower-level” representation (such as
circuits). Canetti et al. implement their protocol for deter-
ministic x86 programs.
Previous circuit generators.
Some prior work ad-
dresses the problem of translating high-level languages
into low-level languages such as circuits. Most prior work
only supports restricted classes of programs: [66, 64]
present a circuit generator based on Fairplay [53, 12],
whose SFDL language does not support important primi-
tives and has inefﬁcient support for others; [56] present a
circuit generator for programs without data dependencies
(pointers and array indices must be known at compile
time, and so do loop iteration bounds).

Other works support more general functionality: [16]
rely on nondeterministic routing to support random-
access machine computations [14]; [27] rely on online
memory checking [24, 14] to support accessing untrusted
storage from a circuit. See [27, Section 2] for a more
detailed overview of some of the above techniques.
Other cryptographic tools. Fully-homomorphic en-
cryption (FHE) [39] and probabilistically-checkable
proofs [5, 4] are powerful tools that are often used in pro-
tocols for outsourcing computations (with integrity or con-
ﬁdentiality guarantees, or both) [49, 54, 2, 37, 31, 47, 41].
However, such constructions have so far not been explored
in practice. Another powerful tool is secure multi-party
computation [40, 13], but most work in this area does not
consider the goal of succinctness.

794  23rd USENIX Security Symposium 

USENIX Association

14

B Case study: memcpy
The function memcpy is a standard C function that works
as follows: given as input two array pointers and a length,
memcpy copies the contents of one array to the other.
Of course, with no data dependencies, copying data in a
circuit is trivial: you just connect the appropriate wires.
However, when the array addresses and their lengths are
unknown, and memcpy is invoked as a subroutine in a
larger program, the trivial solution does not work, and an
efﬁcient implementation is needed.

A naive implementation of memcpy iterates, via a loop,
over each array position i and copies the i-th value from
one array to the other. In vnTinyRAM each such loop
iteration costs 6 instructions; 2 of these are to increase the
iteration counter and jump back to the start of the loop.
Thus, for m-long arrays, copying takes 6m instructions
(discounting loop initialization). But, in vnTinyRAM,
one can do better: loop unrolling can be used to avoid
paying for the 2 “control” instructions. Asymptotically,
the optimal number of unrollings depends on the array
length: it is Θ(√m). Thus, optimal unrolling requires
dynamic code generation on a von Neumann architec-
ture. We wrote a 54-instruction vnTinyRAM program
for memcpy that uses dynamic loop unrolling to achieve
an efﬁciency of ≈ 4m + 11.5√m cycles for m-long ar-
rays. For m ≥ 600, we get 1.25× speed-up over the naive
implementation, and 1.4× speed-up for m ≥ 3000.
Acknowledgments
We thank Daniel Genkin, Raluca Ada Popa, Ron Rivest,
and Nickolai Zeldovich for helpful comments and discus-
sions, and Lior Greenblatt, Shaul Kﬁr, Michael Riabzev,
and Gil Timnat for programming assistance.

This work was supported by: the Center for Science
of Information (CSoI), an NSF Science and Technology
Center, under grant agreement CCF-0939370; the Check
Point Institute for Information Security; the European
Community’s Seventh Framework Programme (FP7/2007-
2013) under grant agreement number 240258; the Israeli
Centers of Research Excellence I-CORE program (center
4/11); the Israeli Ministry of Science, Technology and
Space; the Simons Foundation, with a Simons Award for
Graduate Students in Theoretical Computer Science; and
the Skolkovo Foundation.
References
[1] AJTAI, M., KOML ´OS, J., AND SZEMER ´EDI, E. An o(nlogn)

sorting network. In STOC ’83 (1983).

[2] APPLEBAUM, B., ISHAI, Y., AND KUSHILEVITZ, E. From
secrecy to soundness: Efﬁcient veriﬁcation via secure computation.
In ICALP ’10 (2010).

[3] AR `ENE, C., LANGE, T., NAEHRIG, M., AND RITZENTHALER,
C. Faster computation of the Tate pairing. Journal of Number
Theory (2011).

15

[4] ARORA, S., LUND, C., MOTWANI, R., SUDAN, M., AND
SZEGEDY, M. Proof veriﬁcation and the hardness of approxi-
mation problems. JACM (1998).

[5] ARORA, S., AND SAFRA, S. Probabilistic checking of proofs: a

new characterization of NP. JACM (1998).

[6] BABAI, L., FORTNOW, L., LEVIN, L. A., AND SZEGEDY, M.
Checking computations in polylogarithmic time. In STOC ’91
(1991).

[7] BARRETO, P. S. L. M., KIM, H. Y., LYNN, B., AND SCOTT, M.
Efﬁcient algorithms for pairing-based cryptosystems. In CRYPTO
’02 (2002).

[8] BARRETO, P. S. L. M., LYNN, B., AND SCOTT, M. Efﬁcient
implementation of pairing-based cryptosystems. Journal of Cryp-
tology (2004).

[9] BARRETO, P. S. L. M., AND NAEHRIG, M. Pairing-friendly

elliptic curves of prime order. In SAC’05 (2006).

[10] BEAUQUIER, B., AND ´ERIC, D. On arbitrary size Waksman net-
works and their vulnerability. Parallel Processing Letters (2002).
[11] BELLARE, M., AND GOLDREICH, O. On deﬁning proofs of

knowledge. In CRYPTO ’92 (1993).

[12] BEN-DAVID, A., NISAN, N., AND PINKAS, B. FairplayMP: a

system for secure multi-party computation. In CCS ’08 (2008).

[13] BEN-OR, M., GOLDWASSER, S., AND WIGDERSON, A. Com-
pleteness theorems for non-cryptographic fault-tolerant distributed
computation (extended abstract). In STOC ’88 (1988).

[14] BEN-SASSON, E., CHIESA, A., GENKIN, D., AND TROMER,
E. Fast reductions from RAMs to delegatable succinct constraint
satisfaction problems. In ITCS ’13 (2013).

[15] BEN-SASSON, E., CHIESA, A., GENKIN, D., AND TROMER, E.
On the concrete efﬁciency of probabilistically-checkable proofs.
In STOC ’13 (2013).

[16] BEN-SASSON, E., CHIESA, A., GENKIN, D., TROMER, E.,
AND VIRZA, M. SNARKs for C: Verifying program executions
succinctly and in zero knowledge. In CRYPTO ’13 (2013).

[17] BEN-SASSON, E., CHIESA, A., GENKIN, D., TROMER, E., AND

VIRZA, M. TinyRAM architecture speciﬁcation v2.00, 2013.

[18] BEN-SASSON, E., GOLDREICH, O., HARSHA, P., SUDAN, M.,
AND VADHAN, S. Short PCPs veriﬁable in polylogarithmic time.
In CCC ’05 (2005).

[19] BERNSTEIN, D. J., DUIF, N., LANGE, T., SCHWABE, P., AND
YANG, B.-Y. High-speed high-security signatures. In CHES ’11
(2011).

[20] BEUCHAT, J.-L., GONZ ´ALEZ-D´IAZ, J. E., MITSUNARI, S.,
OKAMOTO, E., RODR´IGUEZ-HENR´IQUEZ, F., AND TERUYA, T.
High-speed software implementation of the optimal ate pairing
over Barreto-Naehrig curves. In Pairing ’10 (2010).

[21] BITANSKY, N., CANETTI, R., CHIESA, A., AND TROMER, E.
Recursive composition and bootstrapping for SNARKs and proof-
carrying data. In STOC ’13 (2013).

[22] BITANSKY, N., CHIESA, A., ISHAI, Y., OSTROVSKY, R., AND
PANETH, O. Succinct non-interactive arguments via linear inter-
active proofs. In TCC ’13 (2013).

[23] BLUM, M., DE SANTIS, A., MICALI, S., AND PERSIANO, G.

Non-interactive zero-knowledge. SIAM J. Comp. (1991).

[24] BLUM, M., EVANS, W., GEMMELL, P., KANNAN, S., AND
NAOR, M. Checking the correctness of memories. In FOCS ’91
(1991).

[25] BLUM, M., FELDMAN, P., AND MICALI, S. Non-interactive

zero-knowledge and its applications. In STOC ’88 (1988).

USENIX Association  

23rd USENIX Security Symposium  795

[26] BOS, J., AND COSTER, M. Addition chain heuristics. In CRYPTO

’89 (1989).

[27] BRAUN, B., FELDMAN, A. J., REN, Z., SETTY, S., BLUMBERG,
A. J., AND WALFISH, M. Verifying computations with state. In
SOSP ’13 (2013).

[28] BRICKELL, E. F., GORDON, D. M., MCCURLEY, K. S., AND
WILSON, D. B. Fast exponentiation with precomputation. In
EUROCRYPT ’92 (1993).

[29] CANETTI, R., RIVA, B., AND ROTHBLUM, G. N. Practical
delegation of computation using multiple servers. In CCS ’11
(2011).

[30] CANETTI, R., RIVA, B., AND ROTHBLUM, G. N. Two protocols

for delegation of computation. In ICITS 12 (2012).

[31] CHUNG, K.-M., KALAI, Y., AND VADHAN, S. Improved dele-
gation of computation using fully homomorphic encryption. In
CRYPTO ’10 (2010).

[32] CORMODE, G., MITZENMACHER, M., AND THALER, J. Prac-
tical veriﬁed computation with streaming interactive proofs. In
ITCS ’12 (2012).

[33] EDWARDS, H. M. A normal form for elliptic curves. Bulletin of

the American Mathematical Society (2007).

[34] FEIGE, U., AND KILIAN, J. Making games short. In STOC ’97

(1997).

[35] FUENTES-CASTA ˜NEDA, L., KNAPP, E., AND RODR´IGUEZ-

HENR´IQUEZ, F. Faster hashing to G2. In SAC ’11 (2012).

[36] GAL, A., EICH, B., SHAVER, M., ANDERSON, D., MANDELIN,
D., HAGHIGHAT, M. R., KAPLAN, B., HOARE, G., ZBARSKY,
B., ORENDORFF, J., RUDERMAN, J., SMITH, E. W., REIT-
MAIER, R., BEBENITA, M., CHANG, M., AND FRANZ, M. Trace-
based just-in-time type specialization for dynamic languages. In
PLDI ’09 (2009).

[37] GENNARO, R., GENTRY, C., AND PARNO, B. Non-interactive
veriﬁable computing: outsourcing computation to untrusted work-
ers. In CRYPTO ’10 (2010).

[38] GENNARO, R., GENTRY, C., PARNO, B., AND RAYKOVA, M.
Quadratic span programs and succinct NIZKs without PCPs. In
EUROCRYPT ’13 (2013).

[39] GENTRY, C. Fully homomorphic encryption using ideal lattices.

In STOC ’09 (2009).

[40] GOLDREICH, O., MICALI, S., AND WIGDERSON, A. How to
play any mental game or a completeness theorem for protocols
with honest majority. In STOC ’87 (1987).

[41] GOLDWASSER, S., KALAI, Y., POPA, R. A., VAIKUN-
TANATHAN, V., AND ZELDOVICH, N. Reusable garbled circuits
and succinct functional encryption. In STOC ’13 (2013).

[42] GOLDWASSER, S., KALAI, Y. T., AND ROTHBLUM, G. N. Dele-
gating computation: Interactive proofs for Muggles. In STOC ’08
(2008).

[43] GOLDWASSER, S., MICALI, S., AND RACKOFF, C. The knowl-
edge complexity of interactive proof systems. SIAM J. Comp.
(1989).

[44] GRANGER, R., AND SCOTT, M. Faster squaring in the cyclotomic

subgroup of sixth degree extensions. In PKC’10 (2010).

[45] GROTH, J. Short non-interactive zero-knowledge proofs.

ASIACRYPT ’10 (2010).

In

[46] ISHAI, Y., KUSHILEVITZ, E., AND OSTROVSKY, R. Efﬁcient

arguments without short PCPs. In CCC ’07 (2007).

[47] KALAI, Y., RAZ, R., AND ROTHBLUM, R. Delegation for

bounded space. In STOC ’13 (2013).

[48] KALAI, Y. T., AND RAZ, R. Probabilistically checkable argu-

ments. In CRYPTO ’09 (2009).

[49] KILIAN, J. A note on efﬁcient zero-knowledge proofs and argu-

ments. In STOC ’92 (1992).

[50] KIM, T., KIM, S., AND CHEON, J. H. On the ﬁnal exponentiation
in Tate pairing computations. IEEE Trans. on Inf. Theory (2013).
[51] LIPMAA, H. Progression-free sets and sublinear pairing-based
non-interactive zero-knowledge arguments. In TCC ’12 (2012).
[52] LIPMAA, H. Succinct non-interactive zero knowledge arguments
from span programs and linear error-correcting codes. In ASI-
ACRYPT ’13 (2013).

[53] MALKHI, D., NISAN, N., PINKAS, B., AND SELLA, Y. Fairplay
— a secure two-party computation system. In SSYM ’04 (2004).
[54] MICALI, S. Computationally sound proofs. SIAM J. Comp.

(2000).

[55] NAOR, M., AND YUNG, M. Public-key cryptosystems provably

secure against chosen ciphertext attacks. In STOC ’90 (1990).

[56] PARNO, B., GENTRY, C., HOWELL, J., AND RAYKOVA, M.
In Oak-

Pinocchio: Nearly practical veriﬁable computation.
land ’13 (2013).

[57] PIPPENGER, N. On the evaluation of powers and monomials.

SIAM J. Comp. (1980).

[58] RIGO, A., AND PEDRONI, S. PyPy’s approach to virtual machine

construction. In OOPSLA ’06 (2006).

[59] SCOTT, M. Computing the Tate pairing. In CT-RSA ’05 (2005).
[60] SCOTT, M. Implementing cryptographic pairings. In Pairing ’07

(2007).

[61] SCOTT, M., AND BARRETO, P. S. L. M. Compressed pairings.

In CRYPTO ’04 (2004).

[62] SCOTT, M.,

N.,

BENGER,

CHARLEMAGNE, M.,
DOMINGUEZ PEREZ, L. J., AND KACHISA, E. J.
On
the ﬁnal exponentiation for calculating pairings on ordinary
elliptic curves. In Pairing ’09 (2009).

[63] SETTY, S., BLUMBERG, A. J., AND WALFISH, M. Toward
practical and unconditional veriﬁcation of remote computations.
In HotOS ’11 (2011).

[64] SETTY, S., BRAUN, B., VU, V., BLUMBERG, A. J., PARNO, B.,
AND WALFISH, M. Resolving the conﬂict between generality and
plausibility in veriﬁed computation. In EuroSys ’13 (2013).

[65] SETTY, S., MCPHERSON, M., BLUMBERG, A. J., AND WAL-
FISH, M. Making argument systems for outsourced computation
practical (sometimes). In NDSS ’12 (2012).

[66] SETTY, S., VU, V., PANPALIA, N., BRAUN, B., BLUMBERG,
A. J., AND WALFISH, M. Taking proof-based veriﬁed computa-
tion a few steps closer to practicality. In Security ’12 (2012).

[67] THALER, J. Time-optimal interactive proofs for circuit evaluation.

In CRYPTO ’13 (2013).

[68] THALER, J., ROBERTS, M., MITZENMACHER, M., AND PFIS-
TER, H. Veriﬁable computation with massively parallel interactive
proofs. CoRR (2012).

[69] VALIANT, P. Incrementally veriﬁable computation or proofs of

knowledge imply time/space efﬁciency. In TCC ’08 (2008).

[70] VERCAUTEREN, F. Optimal pairings. IEEE Trans. on Inf. Theory

(2010).

[71] VU, V., SETTY, S., BLUMBERG, A. J., AND WALFISH, M.
A hybrid architecture for interactive veriﬁable computation. In
Oakland ’13 (2013).

[72] ZAHUR, S., AND EVANS, D. Circuit structures for improving

efﬁciency of security and privacy tools. In SP ’13 (2013).

796  23rd USENIX Security Symposium 

USENIX Association

16

