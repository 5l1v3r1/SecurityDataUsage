Demystifying Incentives in the Consensus Computer

Loi Luu

School of Computing

National University of Singapore
loiluu@comp.nus.edu.sg

Jason Teutsch

School of Computing

National University of Singapore
teutsch@comp.nus.edu.sg

Raghav Kulkarni

Centre for Quantum Technologies
National University of Singapore

kulraghav@gmail.com

Prateek Saxena
School of Computing

National University of Singapore
prateeks@comp.nus.edu.sg

ABSTRACT
Cryptocurrencies like Bitcoin and the more recent Ethereum
system allow users to specify scripts in transactions and con-
tracts to support applications beyond simple cash transac-
tions. In this work, we analyze the extent to which these
systems can enforce the correct semantics of scripts. We
show that when a script execution requires nontrivial com-
putation eﬀort, practical attacks exist which either waste
miners’ computational resources or lead miners to accept
incorrect script results. These attacks drive miners to an ill-
fated choice, which we call the veriﬁer’s dilemma, whereby
rational miners are well-incentivized to accept unvalidated
blockchains. We call the framework of computation through
a scriptable cryptocurrency a consensus computer and de-
velop a model that captures incentives for verifying com-
putation in it. We propose a resolution to the veriﬁer’s
dilemma which incentivizes correct execution of certain ap-
plications, including outsourced computation, where scripts
require minimal time to verify. Finally we discuss two dis-
tinct, practical implementations of our consensus computer
in real cryptocurrency networks like Ethereum.

Categories and Subject Descriptors
C.2.0 [Computer-Communication Networks]: General—
Security and protection; K.4.4 [Computers And Society]:
Electronic Commerce—Cybercash, digital cash

Keywords
Bitcoin; Ethereum; cryptocurrency; incentive compatibility;
veriﬁable computation; consensus computer

1.

INTRODUCTION

Cryptocurrencies such as Bitcoin [1] are attracting mas-
sive investments in computing power, and the power con-
sumed has been growing exponentially in recent years [2].

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS’15, October 12–16, 2015, Denver, Colorado, USA.
c(cid:13) 2015 ACM. ISBN 978-1-4503-3832-5/15/10 ...$15.00.
DOI: http://dx.doi.org/10.1145/2810103.2813659.

Bitcoin can be viewed as a large network of miners compet-
ing in a lottery that awards newly minted currency, called
Bitcoins,
in exchange for contributing computational
resources to solutions of cryptographic puzzles, or blocks.
Bitcoin miners collectively agree upon who receives the
minted Bitcoins and which transactions to accept. This pro-
cess of consensus, or agreement by majority, permanently
records decisions in a public ledger called the blockchain.
More than 50 cryptocurrencies use similar blockchain proto-
cols. While the core blockchain mechanism has been used for
establishing a public ledger of who-pays-whom transactions,
it has features that go beyond this function. Speciﬁcally, the
blockchain supports a light-weight scripting language, de-
signed primarily to allow conditional transactions which can
be repurposed for other applications. Emerging cryptocur-
rencies can now enable computation for applications such as
ﬁnancial back-oﬃces, prediction markets, distributed com-
putation (e.g.,, Gridcoin for BOINC [3]), and perhaps even
a decentralized Linux OS [4].

In Bitcoin, a transaction deﬁnes a particular activity in
the network, e.g., sending Bitcoin between users. Trans-
actions may include a script that speciﬁes a validity con-
dition. Figure 1 illustrates a basic transaction having a
script check whether the payee in the transaction has the
private key corresponding to the recipient’s Bitcoin wallet
address. More interestingly, next-generation cryptocurren-
cies such as Ethereum [5] introduce a Turing-complete script
language which allows users to encode arbitrary computa-
tion as scripts and support a variety decentralized applica-
tions. The large number of miners on the cryptocurrency
network, who both execute and verify computational tasks,
reach agreement through an established consensus protocol.
We therefore refer collectively to these miners as verifers,
and the computation framework of scriptable cryptocurren-
cies as a consensus computer. We wish to characterize the
classes of computation that users can trust a cryptocurrency
network to execute and verify correctly.

Miners have two separate functions in the consensus com-
puter: checking that blocks are correctly constructed, or
proof-of-work, and checking the validity of transactions in
each block. While verifying correct block construction re-
quires a relatively small amount of work (two SHA256 calcu-
lations), checking the validity of transactions contained in a
block can take much more time for two reasons. First, the
number of transactions per block may be large (≈ 800 in
Bitcoin at the time of writing, and its capacity may soon

706be extended to support high transaction rates [6, 7]). Sec-
ond, expressive transaction scripts in emerging cryptocur-
rencies such as Ethereum can require signiﬁcant compu-
tational work to verify. These expressions create a new
dilemma for miners — whether the miners should verify
the validity of scripted transactions or accept them without
veriﬁcation. Miners are incentivized to verify all scripted
transactions for the “common good” of the cryptocurrency
so to speak. However, verifying scripts consumes compu-
tation resources and therefore delays honest miners in the
race to mine the next block. We argue that this dilemma
leaves open the possibility of attacks which result in unver-
iﬁed transactions on the blockchain. This means that some
computation tasks outsourced to cryptocurrency-based con-
sensus computers may not execute correctly.

Our work makes three new contributions. First, we de-
scribe the veriﬁer’s dilemma in emerging cryptocurrencies
which shows that honest miners have an ill-fated choice:
whether to validate a block’s transactions or not. In either
case, they are susceptible to a set of attacks from dishon-
est miners. We show that malicious miners can attack their
peers with zero ﬁnancial risk via the scriptability feature of
cryptocurrencies. Furthermore, our veriﬁer’s dilemma im-
plies that rational miners have incentive to skip the veriﬁ-
cation of expensive transactions to gain a competitive ad-
vantage in the race for the next block. However, this results
in an unvalidated blockchain containing unveriﬁed compu-
tation results.

Second, we propose a security model to formalize the con-
sensus computer. Our model allows us to study the incentive
structure and attacks that aﬀect the correctness of com-
putations performed on a consensus computer. Veriﬁable
computation methods on consensus computers diﬀer from
techniques that have been used on classical computers [8, 9,
10, 11, 12, 13, 14]. A consensus computer allows complete
decentralization of veriﬁcation — the puzzle giver need not
trust any individual veriﬁers on the network or the prover
who provides the solution. In our model, the network is as-
sumed to implicitly agree on correct transactions if and only
if the incentives donot advantage dishonest miners. Ver-
iﬁable computation techniques for classical setting have a
diﬀerent goal: that of producing an explicit cryptographic
proof of the correctness of the computation. Often, such
techniques require an involved key setup phase, and have
impractical computational overheads for the prover.

Previous works implicitly assume that the Bitcoin con-
sensus computer will always generate correct solutions, i.e.,
miners will verify and agree on correct transactions [15, 16,
17, 18, 19, 20, 21]. Our present model provides a formal
explanation as to why this assumption holds and suggests
potential constraints of consensus computation in cryptocur-
rencies with more expressive scripting languages. Speciﬁ-
cally, when the computational advantage of skipping veriﬁ-
cation is low, say ε, rational miners gain little by cheating
thus behaving honestly to give correct solutions. We call
a system restricted to such primitives an ε-consensus com-
puter and expect it to compute correctly.

We propose two mechanisms to realize an ε-consensus
computer on Ethereum. Our ﬁrst approach allows us to
achieve correctness by splitting the computation into sev-
eral smaller steps such that the consensus correctly veriﬁes
each step. This approach achieves exact correctness in re-
sults but with higher computational burden to the network.

P r e v i o u s T X : ID of p r e v i o u s t r a n s a c t i o n
Index : 0
s c r i p t S i g : Sign ( PubKey ) , PubKey

1 Input :
2
3
4
5
6 Output :
7
8
9
10

Value : 5 0 0 0 0 0 0 0 0 0
s c r i p t P u b K e y : % take S i g n a t u r e and PubKey as params

checkif Hash ( PubKey ) = Payee ’ s ID ,
checkif Sign ( PubKey ) is valid

Figure 1: Illustration of a simple transaction in Bitcoin. User’s
address is computed by hashing their public key. scriptPubKey is
the script that deﬁnes how the payee claims the recieved Bitcoin.

Our second mechanism allows for approximate correctness.
Speciﬁcally, we allow the approximation gap between sub-
mitted and correct results to be tunable to a negligible quan-
tity, at much lower computational cost. Whether one can
design a distributed, cryptocurrency system which permits
secure execution of a larger class of computations remains
an interesting open problem, as is the problem of determin-
ing the class of puzzles whose solutions admit light-weight
veriﬁcation.

Contributions. In summary, our work makes the follow-

ing contributions:

• Veriﬁer’s dilemma and attacks. We introduce a dilemma
in which miners are vulnerable to attacks regardless of
whether they verify a transaction or not. We further
show that miners are incentivized to skip the veriﬁca-
tion and perform an attack to get more advantage in
mining the next blocks.

• Security model for a Consensus computer. We for-
malize the computation and veriﬁcation by a consen-
sus computer. We investigate the incentive structure,
threat model and conditions under which a consensus
computer can realize correct outsourced computation.
• Techniques to realize an ε-consensus computer. We
propose techniques to realize our ε-consensus computer
in real cryptocurrency networks like Ethereum. We
illustrate the practical utility of our techniques with
examples from outsourced computation.

2. BACKGROUND: CRYPTOCURRENCIES
2.1 The consensus protocol

Most cryptocurrencies use a public peer-to-peer consen-
sus protocol known as Nakamoto consensus, named after
and introduced by the founder of Bitcoin [1], which does
not require a central authority. At the heart of this protocol
is a blockchain which acts as a public ledger and stores the
complete transaction history of the network. The security
of the blockchain is maintained by a cryptographic chain
of puzzles (or blocks). Miners validate and approve transac-
tions while generating, or mining, new blocks. Mining a new
block rewards newly minted coins to one of the miners that
demonstrates by consensus that it successfully solved a des-
ignated cryptographic puzzle. Figure 2 concisely illustrates
the structure of the blockchain data structure.

The protocol uses consensus in two places to make the
cryptocurrency robust. First, the network must agree on
the rules to verify valid blocks and transactions. Second,

707Block

Block

PrevBlk

BlkHeader Nonce

PrevBlk

BlkHeader Nonce

Tx1

Tx2

...

Tx1

Tx2

...

Figure 2: The Blockchain in popular cryptocurrencies like Bitcoin
and Ethereum. Each block consists of several transactions (Txs).

the data in the blockchain must be consistent across miners,
so that everyone knows who owns what. Thus the blockchain
acts as a base to verify which transactions are valid.
2.2 Transactions & scriptability

A transaction in a cryptocurrency deﬁnes a particular ac-
tivity in the network of that currency. For example, Fig-
ure 1 is a basic transaction in Bitcoin which transfers Bit-
coins from sender to receiver. The scriptPubKey component
(Line 8) allows the sender to deﬁne the receiver’s address and
on which condition he can spend the Bitcoins. The sender
can dynamically program the scriptPubkey to support var-
ious use cases.
Transaction veriﬁcation. In order to verify a transaction,
one has to check whether the input provided in scriptSig
satisﬁes the logic encoded in the scritptPubkey of the Priv-
iousTX. For example, in Figure 1, miners will check if the
receiver is the intended payee (on Line 9) and he indeed
owns the payee’s address (on Line 10). The Bitcoin pro-
tocol states that the veriﬁcation of a transaction TX should
happen in two places, when:

• A new transaction is broadcast (step 1). When a user
broadcasts TX to a miner, the miner veriﬁes if the trans-
action is correct according to the latest blockchain
state. If so, he includes it in his block header to mine a
new block and propagates the transaction to his neigh-
bors.

• A new block is broadcast (step 2). When TX is included
in a newly found block, before accepting the block ev-
eryone will check the correctness of all transactions
contained in the block.

2.3 Incentivizing correctness

While it is clear that Nakamoto consensus incentivizes a
miner to mine new blocks with a reward of newly minted
coins, the incentive for others to correctly verify the trans-
actions is not generally understood. The folklore reasons
for why miners verify transactions in the Bitcoin blockchain
are:

• Verifying a transaction at both steps requires negligible
additional work compared to mining a new block. For
example, the Bitcoin transaction in Figure 1 has only
4 opcodes. Miners can do this extra check without
expending any signiﬁcant computational work. The
cost of validation outweighs the miner’s risk of having
their earned Bitcoins in new blocks be discarded, if the
invalidity is detected in the future.

• When receiving a new block, miners can accept it with
or without verifying the included transactions. How-

1 code :
2
3

if msg . d a t a s i z e ==2:

return msg . data [0] + msg . data [1]

Figure 3: An Ethereum contract that returns sum of two numbers.

ever, most miners want to maintain a cheap and cor-
rect system (the “common good”), so that the Bitcoin
blockchain remains healthy and Bitcoins act as a store-
of-value. Thus miners check the validity of a block’s
included transactions for free 1.

In this work, we study the ﬁnancial incentives of users
more carefully to understand when these folklore assump-
tions may fail and what happens when they do.
2.4 Ethereum—Turing-complete scripting

Ethereum is a next generation cryptocurrency which en-

ables more applications beyond those supported by Bitcoin [5].
It provides a Turing-complete programming language in its
design which equips users with a mechanism to express con-
crete conditional semantics for transactions. Ethereum and
Bitcoin share nearly identical incentive structures. The only
conceptual diﬀerence is that Ethereum includes a small re-
ward for late, valid “uncle block” [5]. However, as in Bit-
coin, Ethereum miners maximize their rewards by racing to
extend the longest valid block. Ethereum also introduces
smart contracts which permit many potential applications
to run on top of the blockchain.

Smart contract. A smart contract is an entity on the
Ethereum blockchain which can embed many contractual
clauses and make it expensive for anyone to disoblige or
deviate from the contract after agreement [22]. Each smart
contract has its own address, balance, and storage space
which is used to run a speciﬁed script. While Bitcoin only
allows users to encode a stateless program, smart contracts
support stateful programs. Users can trigger a contract by
sending a transaction to its address. Once a smart contract
transaction gets included in the blockchain, everyone in the
network is expected to execute the contract script to verify
its validity. Figure 3 is a simple contract which returns the
sum of two numbers.

Gas system.

It may be obvious to some readers that
having Turing-complete language in Ethereum script is a
problem. More speciﬁcally, users can write a transaction or
contract script with long veriﬁcation time to perform Denial-
of-Service (DoS) attack on the network. For example, one
can write a simple transaction to make the network enter
an inﬁnite loop while verifying the transaction. To prevent
such attacks, Ethereum introduces the concept of gas [23].
The script is compiled into Ethereum opcodes while stored
in the blockchain, and each opcode costs some predeﬁned
amount of gas (a form of transaction fee) charged to trans-
action sender. When a sender sends a transaction to activate
a contract, he has to specify the available gasLimit that he
supports for the execution. The gas is paid to a miner who
veriﬁes and includes the transactions in his block.
Intu-
itively, the gas system seems to make it expensive for the
attacker to perform DoS attack to the system. However, as

1Note that only the one who ﬁnds the block receives a trans-
action fee, not those who verify.

708# Record the initiator , reward and data
c o n t r a c t . storage [0]= msg . sender
c o n t r a c t . storage [1]=0
c o n t r a c t . storage [2]= msg . value
# record the size n of the m a t r i c e s
c o n t r a c t . storage [3]= msg . data [0]
# record the m a t r i c e s A and B
c o n t r a c t . storage [4] = msg . data [1]
c o n t r a c t . storage [5] = msg . data [2]
c o n t r a c t . storage [6] = 1 # status

if c o n t r a c t . storage [6] == 0:

return (1)

1 init :
2
3
4
5
6
7
8
9
10
11
12 code :
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32

# data [ C ]: C is the result matrix
if msg . d a t a s i z e == 1:

C = msg . data [0]
n = c o n t r a c t . storage [3]
A = c o n t r a c t . storage [4]
B = c o n t r a c t . storage [5]
# c h e c k i n g the result
for i in range ( n ):

for j in range ( n ):

cell = sum ([ A [ i ][ k ] * B [ k ][ j ]

for k in range ( n )])

if cell != C [ i ][ j ]:

return (0)

# if e v e r y t h i n g is fine , send the reward
send (1000 , msg . sender , c o n t r a c t . storage [2])
c o n t r a c t . storage [6]=0 # update status
c o n t r a c t . storage [7]= C # store result
return (2)

Figure 4: Code snippet of a contract which allows an user can
outsource a matrix multiplication problem. The contract will
verify the correctness of the result before sending out the reward.

we later show, this mechanism does not actually solve the
DoS attack problem.

3. THE VERIFIER’S DILEMMA

In Section 2.3, we discussed incentives for Bitcoin min-
ers to verify transactions in a block. We show that these
motivations fail when block veriﬁcation requires signiﬁcant
computation eﬀort. Various mechanisms can lead to longer
veriﬁcation times. Ethereum users can create transaction
and contract scripts which place arbitrary computational
demands on miners, and similarly Bitcoin miners face high
computational demands when the number of transactions in
a single block is large.

In this section we present a veriﬁer’s dilemma in which
the honest miners in the network decide whether to skip
the veriﬁcation of expensive transactions or to maintain the
common good. To describe the veriﬁer’s dilemma, we ﬁrst
introduce a motivating smart contract in Ethereum which
we will use throughout the paper.

3.1 Example of outsourced computation

Figure 4 shows a code snippet of a contract in Ethereum
which allows a problem giver (G) to ask anyone to compute
A× B where A, B are two matrices of size n× n. In the init
phase, G ﬁrst sends an transaction which speciﬁes n, A, B,
and deposits the reward amount to the contract’s wallet ad-
dress. All information is public including the reward amount
since everything is stored on the blockchain. If a prover (P),
i.e., a user is interested in solving the problem, wants to
claim the solution to get the reward, he sends a transaction
with the result matrix C to the veriﬁer.

When other miners receive the transaction from the prover,
they will verify if C = A × B by running the code phase in
the contract script. G expects that the Nakamoto consensus
protocol used in Ethereum will ensure that the result is cor-
rect due to the check on Lines 22–27, and only one prover
will get paid due to the update of the contract’s status on
Line 30. Note that for the purpose of demonstration, we use
an example in which verifying C requires to run the actual
computation again. In practice, there are several problems
that verifying whether a solution is correct is much easier
than ﬁnding one, e.g., solving a SAT instance, ﬁnding a
hash inversion, breaking cryptography key and so on. Thus,
G can create a contract to allow anyone to submit their so-
lution and rely on the network to verify the correctness as
in Figure 4.
3.2 Attacks
When a transaction that asks miners to verify whether
C = A × B appears in the network, miners have an option
to either verify or not to verify. We show that the miners
are susceptible to a resource exhaustion attack or a incorrect
transaction attack depending on their choice.

Attack 1 (Resource exhaustion attack by problem
givers). If miners honestly follow the protocol, they volun-
tarily verify all transactions in a new block which is broad-
cast to them (step 2 in Section 2.2). Thus, if an attacker
broadcasts his expensive transactions to the network, other
miners will have to spend a lot of power and time to verify
all the transactions. To prevent such situations, Ethereum
introduced a gas system to charge the transaction initiator
(sender) some amount of money for each operation he wants
veriﬁed.

However, the gas system does not prevent the attacker
from creating and including resource-intensive transactions
in his newly minted block. This is because transaction fee
(i.e., gas) is collected by the block founder only (in step 1,
Section 2.2). Thus, the attacker does not lose anything by
adding his transactions to his own block. The other min-
ers, on the other hand, have to spend a signiﬁcant amount
of time verifying those transactions (in step 2, Section 2.2)
and get nothing in return. As a consequence, the attack not
only exhausts other miners’ resource, but also gives the at-
tacker some time ahead of other miners in the race for the
next block. Note that the attacker has complete freedom
to prepare the transactions, so the diﬃculty of verifying the
transaction script is in his control. Since gas charged in each
transaction is credited to his account in step 1, his attack
works at a zero fee (no loss).

As a concrete attack on the running example, the attacker
ﬁrst introduces the contract in Figure 4 with big matrices
size, say n = 1000, and a small reward so that no one will
attempt to solve it. In the second step, he includes a trans-
action with an arbitrary matrix C that he knows whether
C = A × B before hand in all the blocks that he is mining.
He also prepares enough gas to execute the contract script
so that the transaction looks valid and normal. Other hon-
est miners on receiving the block from the attacker spend
time verifying the block and all the included transactions
to see if the block is valid and move on to the next one in
the chain. Since n is quite large, verifying a single transac-
tion from the attacker will take signiﬁcantly more time than
normal transaction. The mining process of other miner will

709be delayed, while the attacker enjoys considerable advantage
and has higher chance in ﬁnding the next valid blocks in the
blockchain.

Remark 1. In Ethereum, the number of operations one in-
cludes in a new block is bounded by oplimit, which can
be varied by a certain rate after every block by miners [5].
However, we argue that oplimit does not completely pre-
vent the above attack since attackers can increase oplimit
to a large enough value after some blocks to include his
resource-intensive transactions. We explain this in the Ap-
pendix A. Further, some may argue that attacker’s blocks
are likely to become stale, i.e., other blocks get broadcast to
the network faster, due to the long veriﬁcation time. How-
ever, in [24], Miller et al. ﬁnd that there are (approx. 100)
inﬂuential nodes in the Bitcoin network which are more eﬃ-
cient in broadcasting blocks. An attacker can broadcast his
block to those inﬂuential nodes to reduce the chance that
his blocks getting staled signiﬁcantly.

Attack 2 (Incorrect transaction attack by provers).
Due to Attack 1, rational miners have strong incentive to
skip expensive transactions to compete for the race of the
next block. The mechanism that drives the Bitcoin net-
work (Section 2.3) to achieve a consensus does not hold in
Ethereum. This is because verifying a transaction now may
take much more time and aﬀect the miners’ mining speed.
As a result, when the puzzle giver G asks for the product
A × B, the malicious prover P can include a transaction
which has a wrong solution C. Since verifying C = A × B
requires long time, rational miners are well-incentivized to
accept it as correct without running the veriﬁcation check.
Thus, the result of a contract/transaction, although is de-
rived from the consensus of the network, is incorrect and
unreliable. The problem giver G wastes his money for an
incorrect answer. Unlike in Attack 1, G is a honest miner in
this case. However his computational power is not enough
to match the rational miners who are incentivized to skip
the check.

It is clear that skipping veriﬁcation is problematic. First,
P can include anything as the result of the contract execu-
tion, e.g., sending others’ money deposited in the contract’s
wallet to his wallet. Second, the health of the currency is
aﬀected since it is impossible to correctly verify who-owns-
what. However, if the miners na¨ıvely verify all the transac-
tions, they are vulnerable to Attack 1.
3.2.1 Findings
Attack 1 and Attack 2 are not only speciﬁc to the running
example, but are common challenges to any application that
relies on a consensus protocol. From the veriﬁer’s dilemma,
we establish the following ﬁndings and implications.

Claim 1 (Resource exhaustion attack). In cryptocurren-
cies that allow miners to create expensive blocks, the honest
miners are vulnerable to ampliﬁed resource exhaustion at-
tacks. Malicious miners can perform the attack without fee
and gain signiﬁcant advantage in ﬁnding the next blocks.

The attack is applicable to most cryptocurrency once they
become widely adopted, regardless of the applications run-
ning on top of the cryptocurrency. One can imagine the
same problem will ocur in Bitcoin if block sizes were to in-
crease dramatically, say to 1 GB per block. An attacker
has incentive to create such a huge block to waste other

miners’ resources so as to gain advantage in the race for
the next block. Such attacks have been reported in Bitcoin
recently [25, 26]. It is shown in [26] that one can create a
block-size transaction which requires miners to hash 19.1 GB
of data and takes an average of CPU 3 minutes to verify. Bit-
coin patched this vulnerability by allowing only pre-deﬁned
standard transactions, and thus limiting the potential ap-
plications of Bitcoin. Ethereum, on the other hand, has
no such restrictions and permits users to deﬁne arbitrarily
contracts.

Claim 2 (Nakamoto consensus permits unveriﬁed blocks).
Assuming all miners are rational, Nakamoto consensus may
elect blockchains with unveriﬁed transactions.

Rationale. Miners in Nakamoto consensus-based cryptocur-
renices are vulnerable to a resource exhaustion attack (At-
tack 1). The time and computational resource required to
verify all transactions in a block expands signiﬁcantly with
number of transactions. By skiping veriﬁcations, a miner
starts the race to ﬁnd the next block earlier than honest min-
ers. As a result, rational miners yield a longer blockchain
by not verifying transactions in all blocks that they receive.
By Nakamoto consensus, the longer chain will be considered
the main chain 2 and contain unveriﬁed transactions.

Incentive incompatibility in existing cryptocurren-
cies. Since users can place arbitrary computation in a script,
miners in Ethereum have high incentive to skip verifying a
block. For example in Figure 4, one can set n arbitrar-
ily large to create a contract that requires, say, 30% of the
computational power used in mining a block to verify its
execution. That demand slows down the mining process of
miners and incentivizes rational miners to skip veriﬁcation
in order to maintain their search speed in ﬁnding new blocks.
Even though the remaining honest miners still account for
the majority of the computational power in the network,
their eﬀective power is reduced by 30%. Thus, with high
probability the rational miners will ﬁnd more blocks and
get a longer blockchain by skipping the veriﬁcation of these
transactions.

As we mentioned earlier, Ethereum introduced constraints
on the rate of gasLimit variation. Unfortunately, however,
we discuss in Appendix A why the gasLimit constraints are
not a fool-proof mitigation against our attacks.

In Bitcoin, although the amount of work required to verify
all the transactions is smaller, miners have non-zero incen-
tive to skip veriﬁcation as well. Indeed, on July 4 2015, a se-
rious incident on the Bitcoin network was reported, wherein
large pools extended blocks containing invalid transactions
[27]. These pools mined on blocks without ﬁrst verifying
the block’s transactions and caused a fork in the blockchain.
As the veriﬁer’s dilemma describes, rational miners lack im-
mediate economic incentives to verify transactions in newly
mined blocks. The computational eﬀort exhausted in verify-
ing transactions detracts from the race to mine subsequent
blocks, and it is possible that these pools skipped veriﬁca-
tion in order to gain computational advantage in the mining
race.

2In Bitcoin, the protocol picks the blockchain which has
more amount of work (the sum of the diﬃculties in blocks).
However, it will be almost the same as comparing the lengths
of both the blockchains.

7104.

INCENTIVIZING CORRECTNESS

In this section, we study and address the design drawbacks
of the consensus protocol to prevent the aforementioned At-
tack 1 and Attack 2. Our goal is to incentivize miners to
verify all transactions in each new block broadcast to them.
Miners who deviate from the protocol should gain negligi-
ble advantage, and honest miners who verify all transactions
should suﬀer negligible disadvantage from dishonest or ma-
licious miners. Our consensus-based computation protocol
below is not tied to any particular cryptocurrency, however
we show how one might realize it in Ethereum in a way so
as to achieve correct computations.
4.1 Consensus-based computation model

We deﬁne the consensus computation model, which for-
malizes the veriﬁcation process of transactions/contracts in
any consensus protocol, as follows.

Deﬁnition 1. A consensus-based computation protocol em-
ployed by a consensus computer involves three parties.

• Problem giver (G): who needs a solution for his partic-
ular problem and provides a function f which veriﬁes
the correctness of a solution.

• Prover (P): who submits a solution s to claim the re-

ward from G.

• Veriﬁers (V): miners in the network execute f (s) to
decide whether s is a correct solution. In addition V
always try to mine a new block, which requires Wblk
work on average, in order to gain a reward.

In Bitcoin, the veriﬁcation function f is rather simple. For
the transaction in Figure 1, the problem that a sender (G)
asks is to determine whether a receiver is the intended payee.
The solution s that the receiver (P) needs to provide is his
public key signed by his private key. The miners (V) will
execute a function f deﬁned in scriptPubKey to determine
if s is correct and P can spend the received amount in that
transaction. Miners all try to ﬁnd new blocks to get reward
as newly minted coins.

Let us denote by Wf the amount of work required to ex-
ecute a veriﬁcation function f . We deﬁne the advantage of
rational miner as follows.

Deﬁnition 2. The advantage for a rational miner by skip-
ping the veriﬁcation of a transaction with veriﬁcation func-
tion f is:

Adv(f ) = Wf − Wdf

where Wdf is the work required by deviating from the honest
protocol.

Generally Wdf = O(1), which is the cost of picking a ran-
dom result in {0, 1} or even Wdf = 0 if the miners just an-
swer a constant value. Based on Deﬁnition 2, the advantage
that a dishonest miner can get by skipping the veriﬁcation
process in one block is:

N(cid:88)

N(cid:88)

Wfi − O(1)

Adv(Blk) =

Adv(fi) =

i+1

i=1

where N is the total number of transactions in a block Blk,
and fi is the veriﬁcation function for the i-th transaction
in Blk. Our threat model assumes an ε-rational miner as
deﬁned in Deﬁnition 3.

Deﬁnition 3. An ε-rational miner is one who honestly ver-
iﬁes the transactions in a block iﬀ

Adv(Blk) ≤ εWblk,

and deviates from it otherwise.

A ε-rational miner is incentivized to deviate from the hon-
est protocol if the the work required to verify all transactions
in a block is higher than a threshold εWblk. Being dishonest
helps him have a higher chance of ﬁnding the next blocks
since others have to do a signiﬁcant amount of work verify-
ing transactions. On the other hand, if the work required
is less, skipping the veriﬁcation does not gain him much ad-
vantage (e.g., lesser than other practical factors like network
latency) to make his blockchain the longest one. Doing that
may even risk his new block value if other miners detect that
the previous block includes invalid transactions.

Incentivizing correct consensus computation. We
incentivize miners to correctly execute f by limiting the
amount of work required to verify all transactions in a block.
Our goal is to provide an upper bound in the advantage
that miners get by deviating from the honest protocol. This
means honest miners are also guaranteed not to run long
and expensive scripts while verifying the transactions. More
speciﬁcally, we propose a new model deﬁned as follows.

Deﬁnition 4. An ε-consensus-based computation protocol
is a protocol in which the total amount of work that all
veriﬁcation functions require miners to do is at most εWblk
per block.

A ε-consensus computer is a consensus computer that fol-
lows an ε-consensus-based computation. From Deﬁnition 3,
our ε-consensus computer is incentive-compatible w.r.t. ε-
rational. More speciﬁcally, it incentivizes miners to behave
correctly, i.e., honestly verify all transactions in a block.
4.2 Building an ε-consensus computer in

Ethereum

One can estimate the value of ε to be the largest amount
of “common good” work that the majority of miners ﬁnd
acceptable. This value, however, depends on several fac-
tors including the real net-worth of applications on the cur-
rency, the network properties, the incentive mechanism in
the cryptocurrency, and individual miner’s beliefs about the
currency’s value. Estimating ε is a separate and interesting
research problem. Our next goal is to design a cryptocur-
rency network which supports ε-consensus computing for a
speciﬁc pre-chosen value ε.

We next describe how to support ε-consensus computer
based on Ethereum without requiring any major changes in
its design. We further discuss which classes of computa-
tions can be run correctly on the existing cryptocurrency.
While in general it is non-trivial to estimate the compu-
tation required by programs written in a Turing-complete
language [28], the gas charged for a transaction is a reliable
indicator of the amount of work required in that transac-
tion script. To make our approach clearer, we deﬁne a gas
function G(x) as in Deﬁnition 5.

Deﬁnition 5. The gas function G(x) determines the maxi-
mum gas amount that a program can require to do x amount
of work.

Since Ethereum already speciﬁes the gas value for each
opcode in their design [23], computing G(x) is relatively

711easy. Moreover, G(x) can be computed once and used for
all transactions. It only requires to update G(x) again if the
gas value is changed, or more opcodes are enabled.

We need only introduce a critical constraint on the trans-
action to make Ethereum an ε-consensus computer. That is,
miners should only accept to verify the transaction that has
gasLimit bounded by G(εWblk/N0), where N0 is the max-
imum number of transactions can be included in a block.
Generally N0 is ﬁxed and represents the upper bound on
the computational capacity of the network in one block time.
We formally state our solution in Lemma 1.

Lemma 1 (Achieving ε-consensus computer in Ethereum).
Given a speciﬁc ε value, one can construct an ε-consensus
computer from Ethereum by limiting the gasLimit in every
transaction by

(cid:18) εWblk

(cid:19)

G

.

N0

1 init :
2
3
4 code :
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24

...
c o n t r a c t . storage [7] == 0 # no . of rounds

...
if msg . d a t a s i z e ==1:

c o n t r a c t . storage [8]= msg . data [0] # store C
c o n t r a c t . storage [9]= msg . sender # store prover
return ( " S u b m i t t e d C " )

# verify the result
elif msg . d a t a s i z e == 0:

C = c o n t r a c t . storage [8]
i = c o n t r a c t . storage [7]/ n
j = c o n t r a c t . storage [7]% n
c o n t r a c t . storage [7] += 1
cell = sum ([ A [ i ][ k ] * B [ k ][ j ]

for k in range ( n )])

if cell != C [ i ][ j ]:

return ( " Invalid result " )

# after n ^2 checks have passed
# send the reward to the prover
if c o n t r a c t . storage [7] == n * n :

s e n d _ r e w a r d ()
....

Proof. Let us denote Wtx as:

Wtx =

εWblk

N0

.

Since the gasLimit is at most G(Wtx), Wtx is the upper
bound on the amount of work required to verify a transac-
tion. Thus, the work required in verifying all transactions
in a block is no greater than εWblk. By Deﬁnition 3, this an
incentive-compatible strategy for ε-rational miners.

There are certainly classes of computations that require
more than Wtx and even εWblk work to execute. While one
can code such scripts in Ethereum, these puzzles fall outside
the class of computations that our ε-consensus computer
model can guarantee to execute and verify correctly.
4.3 Supporting more applications on an

ε-consensus computer

We discuss two techniques for supporting puzzles which
require greater than Wtx veriﬁcation in Ethereum. One
technique achieves correctness but sacriﬁces performance la-
tency since it distributes the computation across multiple
transactions and blocks that ﬁt in the ε-consensus com-
puter model. This technique eﬀectively amortizes the veri-
ﬁcation cost across multiple transactions and blocks in the
blockchain. The second technique, on the other hand, sac-
riﬁces only exactness and achieves probabilistic correctness.
4.3.1 Exact consensus computation
We introduce our ﬁrst technique in the context of exact
solutions. Here we simply split the execution of the script
into smaller steps such that verifying each step requires at
most Wtx work. Once all the steps have been run and veriﬁed
as separate scripts, the outcome is the same as the result one
would obtain from correctly executing the original script.
Although the total veriﬁcation work that the ε-consensus
computer has to do is the same regardless of whether we use
a single or multiple scripts, splitting the task guarantees a
correct outcome because the ε-consensus computer correctly
veriﬁes smaller. We illustrate an alternative implementation
for outsourcing matrix multiplication in n2 steps where Wtx
is O(n) in Figure 5 (instead of 1 transaction where Wtx is
O(n3) as in Figure 4).
The execution of the contract in Figure 5 works as follows.
P ﬁrst submits C to the contract as the solution for A × B.

Figure 5: Matrix multiplication with O(n) work per transaction
on a consensus computer.

The veriﬁcation happens across the next n2 steps when P
sends n2 transactions to the contract. Each transaction ver-
iﬁes a particular and diﬀerent element Ci,j of the submitted
result. A counter stores the number of passed checks (Lines
13–15).

Advantage across multiple transactions. A careful
reader may be concerned that a rational miners might recog-
nize the global connection between the n2 transactions and
skip verifying all of them to gain an advantage. However,
the advantage from skipping the veriﬁcation of transactions
in the i-th block only helps the miners ﬁnd the (i + 1)-th
block faster. In other words, one cannot “save” the “unspent”
advantage in skipping the veriﬁcation in one block and use
that in the future since the competition for ﬁnding a new
block “restarts” after every block. Essentially, we amortize
the advantage of the computation across multiple transac-
tions and blocks such that at any given block, the advantage
of rational miners is bounded by εWblk. Thus our approach
does not break the incentive compatibility of the ε-consensus
computer model.

Depending on the nature of the application, multiple steps
can either happen in parallel or must be executed sequen-
tially. For example in matrix multiplication, P can send
simultaneously n2 transactions. The reason is verifying Ci,j
does not rely on the correctness of Ci,j−1, and the order of
verifying the two elements does not matter. On the other
hand, if, say, Ci,j = 2· Ci,j−1, the prover would have to wait
until Ci,j−1 gets veriﬁed before sending the next transac-
tion which veriﬁes Ci,j. In section 6, we illustrate these two
scenarios with case studies.

4.3.2 Approximate consensus computation
Our second approach avoids the latency of sequential com-
putation processes by employing probabilistic, light-weight
veriﬁcation. This approach will guarantee the correctness
of the solution to a certain (adjustable) extent while only
having to check a small portion of the solution.
Deﬁnition 6. Let us denote a problem Z : {0, 1}n →
{0, 1}m, an input x ∈ {0, 1}n and a claimed solution y(cid:48) ∈

712{0, 1}m of Z(x). We say Z is (δ, λ)-approximate veriﬁable if
there exists a veriﬁcation function f such that f accepts y(cid:48)
only if y(cid:48) diﬀers from Z(x) in at most δ bits with probability
greater than λ.

Our task is to encode f to ensure that if a solution y(cid:48) is
deemed correct only when y(cid:48) does not diﬀer much from the
correct solution, i.e., diﬀerent in at most δ bits. Further-
more, in order to run f in a ε-consensus computer model, f
should not require more than Wtx work to ﬁnish. The high
level insight to encode such a f is that by randomly sampling
and checking an entry of the output, there is some proba-
bility that we can detect if the output is incorrect at that
sample. If we ﬁnd an incorrect sample, we can conclude that
the submitted solution is wrong and reject the solution. The
more samples we take, the better the probability of catching
an error. Otherwise, the solution is close to a correct one
with an overwhelming probability greater than λ.

In Deﬁnition 6, we avoid deﬁning too precisely the notion
of “bits” and distance between two solutions since they vary
slightly on speciﬁc encoding of the veriﬁcation function f .
One can translate “bits” as the positions in an array, or the
pairs of elements, where the solution diﬀers. In either case,
the fraction of errors δ would change accordingly to the deﬁ-
nition of “bit.” For example, in the case of sorting, each “bit”
would correspond to a pair (i, j) where i < j and a bit in a
solution y(cid:48) diﬀers from that in Z(x) if y(cid:48)[i] > y(cid:48)[j].

We borrow the above sampling idea from the property
testing literature which shows that in many practical in-
stances one can determine whether a large object has a de-
sired property by inspecting a small number of samples [29,
30]. For instance, property testing is a technique which al-
lows a veriﬁer to sample the output to decide whether an
array is sorted. Property testing diﬀers from veriﬁable com-
putation, however, in that veriﬁable computation deals with
general computations whereas property testing can only con-
sider decision problems. Decision problems are not inter-
esting for consensus veriﬁability because without doing any
work a prover P can simultaneously post two solutions, “0”
and “1,” and one of these is guaranteed to be correct. Such
an answer shifts the entire burden of computation onto the
veriﬁer unless the prover also provides some certiﬁcate which
helps the veriﬁer to check his answer more quickly. To use
property testing in veriﬁable computation, we need to check
the two following properties:

• Property 1. The provided solution diﬀers in at most
δ-bits from a solution that satisﬁes the property of the
computation with high probability.

• Property 2. The provided solution is computed from

the given input x with high probability.

Note that given a particular number of samples, the correct-
nesses that we can guarantee for Property 1 and Property 2
are diﬀerent. For example, in the case of sorting a n-element
array, n random samples may be suﬃcient to check whether
the provided solution has the same elements as the given
array with a 1 − λ = 99% guarantee (Property 2). However,
it may take more than n samples to fully check if the pro-
vided solution is sorted (Property 1). Thus, to achieve the
overall 99% guarantee of correctness for both Property 1 and
Property 2, the number of samples one must take is the max-
imum of the numbers of samples to attain 99% guarantee of
correctness for either of the checks.

5.

IMPLEMENTATION

In this section we discuss the challenges while encoding a
veriﬁcation function f in our ε-consensus computer model.
We further discuss techniques to address those challenges.
5.1 Challenges in implementation

The presence of contract and Turing-complete language
in Ethereum enables a veriﬁable computing environment in
which users can ask anyone to solve their problem and get
the results veriﬁed by the network. We have established how
to encode those veriﬁcation computations f in Section 4.2 to
work with our ε-consensus computer model. In fact, P can
do the computation to arrive at the solution on his physical
computer. G encodes the veriﬁcation function f such that
it takes P’s solution and auxiliary data for the veriﬁcation
process. For example, if G asks P to sort an array, G can
encode f to ask P to provide the sorted array (result) with
the map between the result and the input. Our previous
contract in Figure 5 is a concrete example where the matrix
multiplication is outsourced to the network. We summarize
the properties such a contract in our ε-consensus computer
model can achieve.

1. Correctness. G receives correct results.
2. No prior trust. No pre-established trust between P

and G is required.

3. No interaction. No interaction between P and G is

required in order to verify the result.

4. Eﬃciency. G and P have to do only a modest amount

of work.

5. Fairness. P is rewarded for a valid solution.

Properties 1–4 are immediate when we encode the veriﬁca-
tion function f in our ε-consensus computer model. Speciﬁ-
cally, correctness is guaranteed since miners are incentivized
to verify all computation. P and G do not need to trust or
know each other, yet G cannot deviate after knowing the
result. However, there are several challenges while imple-
menting those veriﬁcation function using smart contracts.
In fact, simple smart contracts like the one in Figure 5 can-
not guarantee fairness property due to one of the challenges
that we describe below.

• Insecure relay attack. Once P ﬁnds a solution C,
he broadcasts a transaction having C to his neighbors
and to the whole network. However, since the solution
is in the plaintext, a rational neighbor node may copy
C, delay or even discard the prover’s transaction and
forge a new transaction to claim the reward.

• How to randomly sample in Ethereum? In order
to verify computations via sampling, we need a mech-
anism for generating random numbers. We want to
make sure that the random generator is unbiased in
seed selection, and that the seed is unpredictable. If it
is biased or predictable, the correctness property may
be violated since P can submit a solution which is cor-
rect only in the “bits” that will be sampled. Ethereum
does not natively support a random generator opera-
tor. We discuss our solution in Section 5.2.

Another desirable property of a random generator is
that it should be consistent across the network, i.e., it
should return the same sample set to everyone. Oth-
erwise an honest miner M could verify that a solution

713Commitment: TX b
from: Prover

to: contract CT
data: TX a’s ID

commit

Contract: CT
1. Accept commitment

2. Accept solution C

Solution: TX a

from: Prover

to: contract CT

data: matrix C

release

3. Verify C

4. Send reward

Figure 6: The commitment scheme used in our outsourced com-
putation case studies. CT accepts the commitment in transaction
TX b before recieving solution in TX a. That means P should see
TX b in the blockchain before he broadcasts TX a to CT .

is correct with his samples but the other miners see
it incorrect since they have a diﬀerent sets of sam-
ples. Although M is honest, the other miners reject
his block because with their sample sets M ’s transac-
tion including his solution is invalid. It is unfair for
M and problematic for the network as a whole since
network consensus then becomes probabilistic.

One na¨ıve approach to defeat the insecure relay attack
above is for the prover P to encrypt and sign his solution
since a key management system already exists in Ethereum.
Unfortunately this does not work since every miner needs
to access P’s solution in order to verify the corresponding
puzzle. In the next section, we devise a commitment scheme
which helps us obtain fairness and discuss how to implement
all the necessary components in our ε-consensus computer
protocol.
5.2 Construction

We now resolve the bullet points raised above in Sec-

tion 5.1.

Achieving fairness via a commitment scheme. A
commitment scheme provides two important features. First,
it ensures that other users cannot see, thus steal P’s solution
and claim the reward. Second, P once commits a solution
cannot later alter it. This is to prevent some prover from
submitting a fake answer to win the race with others (since
only one prover is paid for correct solution), then spending
more time computing the correct solution.

Our commitment scheme leverages the one-way hash func-
tion SHA2, which is already used in current cryptocurrencies
to compute proof-of-work and transaction ID’s. Speciﬁcally,
we ask P to prepare a transaction TX a that he includes
his solution, and a transaction TX b to commit TX a to the
contract. P ﬁrst sends TX b, which includes TX a’s ID, to
the contract to say that he has the solution and will send
that in the next transaction TX a—commit phase. Once the
contract accepts P’s commitment, he sends TX a and pro-
ceeds further as in without having the commitment—release
phase. Our commitment scheme is shown in Figure 6.

Since an ID is computed by crytographically hashing the
transaction data, other miners by observing TX a’s ID in
TX b are not able to construct TX a to get C. Moreover, P
cannot alter TX a by a diﬀerent solution since doing that will
raise a conﬂict between the committed ID and the new one.
In addition, once TX b gets accepted and P broadcasts TX a,

the neighbors cannot claim the rewards with the solution
observed in TX a. This is because the contract is waiting for
transaction TX a which has been committed before.

Random sampling in Ethereum. Recall that for prob-
abilistic veriﬁcation, we need a psuedo random generator to
randomly sample elements in a solution. Our key idea is
to leverage some data in future blocks that miners do not
know and cannot predict at the time of creating the trans-
action/contract. For instance, the randomness source can
be the hash of the next block. Given a pseudo-random vari-
able R as the next block hash, one can generate n other
pseudo-random numbers simply by taking a hash as:

SHA256(R || i)

in which 1 ≤ i ≤ n, and || is a concatenation operator.

Since the information of a block is public and consistent in
the network, all miners when run the above pseudo-random
generator will get the same set of samples, thus achieving
consistency. Further, the information of block is unknown
before it is mined by miners, coupling with the random-
ness of SHA256 function makes our pseudo-random generator
fair.

6. CASE STUDIES

In this section, we exhibit several problems that can be
solved by using our ε-consensus computer model. We are
interested in the problems that require high computational
resource to verify if are encoded na¨ıvely without using our
techniques discussed in Section 4.2. The purpose of those
examples is to illustrate the practicality of our techniques,
and also describe how to encode f for various δ-approximate
verifable problems. Our examples consists of several prob-
lems in diverse domains such as Graph Theory, Linear Al-
gebra, Number Theory and simple operations like matrix
multiplication and sorting. In several of these cases we are
able to easily verify whether a solution is correct. However,
for several interesting problems verifying the correctness of a
solution appears to be elusive. We try to circumvent this dif-
ﬁculty by taking a recourse in an approximate veriﬁability.
We illustrate how one can encode the veriﬁcation function
f to employ the light-weight veriﬁcation and approximately
verify the correctness of several problems. For the conve-
nience of readers, we list our case studies in Table 1.
In
this section, we consider the basic operations as basic arith-
metic operations, e.g., addition, multiplication and compar-
ison over 32-bit integers, unless otherwise stated.
6.1 Exact computations

We show several applications that we can encode f to
guarantee the correctness of a solution in an ε-consensus
computer model. We also discuss the potential high latency
due to the need of distributing the computation to multiple
transactions.
6.1.1 GCD of Large Numbers
This example computes the exact GCD of two large num-
bers, each of size n bits. The usual way to solve to the great-
est common divisor problem on a classical computer goes via
the Euclidean algorithm which takes work proportional to
O[log3(n)]. We show that by encoding the veriﬁcation func-
tion diﬀerently, one can verify the result in quadratic time
O[log2(n)]. More interestingly, this example requires only a
single solution transaction — that is, guarantees exactness

714Problems

GCD

Dot Product

Matrix Multiplication (Fig. 4)
Matrix Multiplication (Fig. 5)

Matrix Multiplication (Section 6.1)

Matrix Multiplication

Sorting

k-coloring







Exact Approx # TXs Wtx
O(1)
O(1)
O(n3)
O(n)
O(1)
O(1)
O(1)
O(1)

O(1)
O(n)
O(1)
O(n2)
O(n3)
O(n)
O(1)
O(1)





#. Rounds

1

O(log n)

N/A
N/A
N/A

O(log n)

N/A
N/A

Table 1: Case studies for outsourced computation in our ε-consensus computer model. Wtx represents the amount of work required in
each transaction. #. Rounds is the number of rounds required to have a solution veriﬁed if the transactions have to send in order (N/A
means there is no such order).

with no additional latency. Speciﬁcally, the algorithm is as
below.

3. For each i, V accepts P’s solution iﬀ s1,i = a2ib2i +

a2i+1b2i+1.

1. G posts two integers m and n.

2. P posts ﬁve integers a, b, x, y, and z.

3. V checks that:

(a) ax = m, bx = n,
(b) |y| < b, |z| < a, and
(c) ay + bz = 1,

(d) If all of these checks succeed, then V accepts P’s

solution. Otherwise V rejects P’s solution.

We claim that if both checks above succeed, then gcd(m, n)
= x. If (a) is satisﬁed, then clearly x divides m and y di-
vides n. To see that x is the smallest such number, we
appeal to B´ezout’s Identity which tells us that a and b are
relatively prime iﬀ there exist y and z satisfying (b) and (c).
If some integer greater than x divided both m and n, then
by uniqueness of factorization, x would also divide that in-
teger, forcing a and b to have a nontrivial common factor.
Our veriﬁcation uses 10 arithmetic operations over inputs of
size log(n).
6.1.2 Dot product
We compute the exact dot product of two vectors
(a1, . . . , an) · (b1, . . . , bn) = a1b1 + ··· + anbn

by way of a sequence of transactions on the consensus com-
puter. The puzzle giver G need not perform a single basic
operation, while the miners perform no more than 3 basic
operations per transaction. Each transaction will permit us
to reduce the number of additions in the running sum by
one. The puzzle giver G will post (cid:100)n/2(cid:101) transactions to the
ﬁrst block, (cid:100)n/4(cid:101) transactions to the second block, (cid:100)n/8(cid:101) to
the third, and so on for a total of at most n transactions. For
simplicity of presentation, we will assume that G knows the
quantity n, however this assumption is not necessary. One
could modify the protocol below so that we iterate over all
indices i for which ai and bi are both deﬁned (with possibly
one extra pair an+1 = bn+1 = 0 added in case n is odd), and
similarly for the partial sums in the subsequent stages.

1. For each i ≤ (cid:100)n/2(cid:101), G creates a puzzle transaction T1,i

requesting the sum a2ib2i + a2i+1b2i+1.

2. For each i, P posts a number s1,i equal to the requested

sum, in some permanent, public place.

Subsequent stages k, for k = 1 up to the least k such that
2k ≥ n proceed similarly in a recursive way:

1. For each i ≤ (cid:100)(cid:100)(cid:100)n/2(cid:101)/2(cid:101) . . . /2(cid:101) (k 2’s in this expres-
sion), G creates a puzzle transaction Tk,i requesting
the sum sk−1,2i + sk−1,2i+1.

2. For each i, P posts a number sk,i equal to the requested
3. V accepts P’s solution iﬀ ∀i sk,i = sk−1,2i + sk−1,2i+1.

sum, in some permanent, public place.

(cid:80)

By induction on k, if for each i P’s solution is correct, then
i sk,i is equal to the desired dot product. In the ﬁnal stage,
we obtain a single value which equals the dot product, and
so our multi-stage protocol succeeds. It is easy to verify that
the work required in each transaction is O(1) 3.
6.2 Veriﬁcation with random sampling

As discussed earlier, some applications have solutions
which are not easy or cheap to be veriﬁed. We show how to
encode the veriﬁcation function f for such applications to
achieve probabilistic correctness with much smaller latency.

6.2.1 Approximate Sorting
We apply the direct sampling method so that with high
probability the consensus will accept a correct solution but
reject a solution with many errors. Let A denote the in-
put array of |A| = n elements. Let B denote the claimed
output array of n elements and f denote a permutation on
{1, . . . , n}, representing the claimed sorting order.
Deﬁnition 7 (δ-approximate sorting). For δ ≥ 0, we say
that an array B (together with a permutation f ) is a δ-
approximate solution to sorting array A if:

• at most δ fraction of elements of B are incorrectly
• at most δn2 pairs of B are out of order.

mapped by f , i.e., A[i] (cid:54)= B[f (i)], and

We ﬁx a δ > 0 and let k denote the number of sample
used by our protocol. The work required in the protocol

3 In Figure 5, we showed how to compute the exact product
of two matrices using n2 transactions, each requiring O(n)
veriﬁcation work. By applying the above mutli-transaction
dot product contract n2 times, one could also compute a
matrix product via transactions each requiring only O(1)
work.

715below will be directly proportional to k. The protocol be-
low guarantees that if the output is correctly sorted then it
is accepted with high probability and if the output is not
δ-approximately sorted then it is rejected with high proba-
bility. Thus we get the guarantee that if an output is ac-
cepted then it must be δ-approximately sorted with high
conﬁdence. The conﬁdence can be made arbitrarily close to
1 at the cost of increasing the sample size.

on {1, . . . , n}.

1. G posts an array A of n elements.
2. P posts an array B of n elements and f , a permutation
3. V chooses k random indices p1, . . . , pk ≤ |A| and k ran-
dom pairs of indices (q1, r1), . . . , (qk, rk) and checks:
(a) if: for all i ≤ k, A[pi] = B[f (pi)], and
(b) if: for all i ≤ k, if qi ≤ ri then B[qi] ≤ B[ri].
(c) If both the checks (a) and (b) succeed then V

accepts P’s solution. Otherwise V rejects.

The veriﬁcation requires k equality checks and k sorting
comparisons.

Soundness of the protocol: Let us ﬁrst assume that P’s solu-
tion (B, f ) is a correct solution to sorting A, i.e., B has no
errors in the bijection f and no pairs are out of order. In this
case, check (a) and (b) will not fail as there are no errors.
Thus the protocol will accept every correct solution.

Proof of approximate correctness: On the other hand if the
array B diﬀers from A in more than δ|A| places, then with
probability at least δ, V will detect this error in (a). Simi-
larly, if at least δ|A|2 pairs of elements in B are out of order,
then with probability at least δ, the veriﬁer V will detect
this error in (b). The probability that (a) is satisﬁed for
all i is less than (1 − δ)k, and similarly the probability that
(b) is satisﬁed for all i is less than (1− δ)k. Thus the proba-
bility that both of the checks succeed is at most the product
(1 − δ)2k. The veriﬁer V fails to detect an error only when
both checks (a) and (b) succeed. If we choose k large enough
such that (1 − δ)2k < λ then we the protocol will reject any
solution that is not δ-approximately sorted with probability
greater than 1 − λ.
6.2.2 Approximate Matrix Multiplication
We want to guarantee that if our veriﬁcation function f
accepts C then at least 1 − δ fraction of the entries of C
match with A × B with high probability. The idea is to
randomly pick a small number of entries of C and verify that
they are computed correctly. For this check one may use the
protocol for the Dot Product described in Section 6.1.2. By
a calculation similar to the one for Approximate Sorting
in Section 6.2.1, log λ/log(1 − δ) samples suﬃce to ensure
(δ, λ)-approximate veriﬁability.
6.2.3 Approximate 2-Coloring
A 2-coloring of a graph is an assignment of one of two
speciﬁed colors to each of its nodes. An edge is colored prop-
erly if the two endpoints of the edge are assigned diﬀerent
colors. Recall that a graph is 2-colorable, or bipartite if there
a 2-coloring of its nodes such that every edge is properly col-
ored. A 2-coloring is δ-approximate if at most δ fraction of
the edges are not colored properly.

Using the sampling method, we design a protocol for the
following decision problem: does a given graph A have a

δ-approximate 2-coloring? Our protocol is inspired by the
property testing algorithm for 2-coloring and its correctness
relies on Szemeredi’s Regularity Lemma [31, 32].

1. G posts a graph A.
2. P posts either posts:

(a) “yes” and a 2-coloring of A, or
(b) “no” and an array of

k(δ) =

34 ln4(1/δ) ln ln(1/δ)

δ

nodes from A.

3. V checks:

(a) If P answered “yes,” then V chooses k(δ)-random

nodes v1, . . . , vk(δ) from A.

i. V accepts P’s solution if the subgraph induced

on v1, . . . , vk(δ) is 2-colorable, and

ii. V rejects otherwise.
(b) If P answered “no,” then

i. V accepts P’s solution if

A. P’s solution is an odd cycle, and
B. all the edges of the odd cycle are present

in A.

ii. V rejects if either of the above conditions fails.

Soundness of the protocol: With probability greater than 1/2,
a graph is not δ-approximate 2-colorable if and only if a ran-
dom subset of k(δ) nodes contains an odd cycle [33]. Thus
if the graph is not δ-approximate 2-colorable then we will
detect this with probability at least 1 − λ by repeating the
above protocol (cid:100)log2(1/λ)(cid:101) times. On the other hand, if the
graph is 2-colorable then no subset of k(δ) nodes will contain
an odd cycle. Hence our protocol will correctly accept the
solution. Thus our protocol computes correctly with high
probability both when the answer is “yes” or “no.”

Complexity of veriﬁcation: Note that if the graph is not δ-
approximate 2-colorable then indeed we have a constant size
witness for this. Hence the “no” answer from the prover has
a light-weight veriﬁcation. It remains to show that the “yes”
answer from the prover also has an easy veriﬁcation. This
can be achieved by a sampling method similar to the one
used for sorting. If more than δ fraction of the edges are not
properly colored by P’s 2-coloring, then we will catch a vio-
lated edge with high probability using s = k(δ)·(cid:100)log2(1/λ)(cid:101)
samples.

In the “yes” instance, V does s basic operations to choose
the random nodes and s2 comparisons to check that the
subgraph inherits a 2-coloring. In the “no” instance, s basic
operations are used to check whether P gave an odd cycle,
and s basic operations to check it’s presence in A for a total
of 2s basic operations.

Finally, we remark without proof that our protocol can in
fact be modiﬁed to verify approximate c-coloring as well for
any constant c using [33]; see also [32].

7. RELATED WORK
Consensus protocol. Since the Nakamoto consensus pro-
tocol ﬁrst appeared [1], numerous works have investigated
alternative consensus algorithms [34, 35, 36, 37]. The prob-
lem we look at in this work is independent of the underlying

716consensus algorithm used in the network as the veriﬁer’s
dilemma arises in any cryptocurrency that has high block’s
veriﬁcation cost.
Incentive compatibility in cryptocurrency. Apart from
verifying blocks and transactions, mining new blocks is one
major activity in cryptocurrencies. Block mining requires a
huge computational resource, thus miners often join hands
to mine together in a pool. Several previous works also study
the incentive compatibility of Bitcoin mining [38, 39, 40, 41].
For example, in [38, 40], the authors prove that pooled min-
ing protocol is not incentive compatible by showing that
miners and pools are susceptible to a block withholding at-
tack. Our work also studies the incentive compatibility in
cryptocurrency, but via the lens of the veriﬁcation activity.
We show that in a network which allows Turing complete
scripts, miners are vulnerable to a new class of attacks.
Security analysis of Bitcoin protocol. A recent paper
by Gary et al. models and analyses security of the Bitcoin
protocol [42]. Gary et al. prove that Bitcoin can achieve all
ideal properties, e.g., common preﬁx, chain quality, only if
f is negligible, where f is the number of proof-of-work so-
lutions that miners can generate while a block is broadcast.
We ﬁnd that our ﬁnding follows closely to their result. In
fact, the parameter f in [42] typically depends on the pa-
rameter ε in our paper. The present work showed that when
ε is suﬃciently large, the veriﬁer’s dilemma exists. Our so-
lution is to keep ε small, which is equivalent to keeping f
close to 0.
Veriﬁable computation. Our proposed outsourced com-
putation scheme on an ε-consensus computer is the ﬁrst sys-
tem to achieve all the ideal properties mentioned in Sec-
tion 5. A popular line of work uses classical computers for
veriﬁcation that involves prior trust establishment to guar-
antee that G does not deviate after knowing the solution [8,
9, 10, 11, 12, 13, 14]. A key diﬀerence is in the assumptions
and goals. Our goal is not to produce explicit proofs of cor-
rectness, rather to enable an incentive structure where cheat-
ing provides no intrinsic advantage over following the proto-
col honest. Secondly, our techniques are speciﬁc to certain
algorithms, whereas veriﬁable computation enables proving
correctness of arbitrary circuits. Moreover, veriﬁable com-
putation can be and have been applied in our setting, since
recent schemes have constant veriﬁcation eﬀort [43]. How-
ever, such schemes impose impractically high overheads on
provers and require expensive inial key setup between all
miners in the protocol.

Since the rise of Bitcoin, a new line of work on repurposing
the blockchain for other applications has been initiated [19,
21, 16, 20]. For example, in [19, 21], Kumaresan et al. stud-
ied how to run several applications, including veriﬁable com-
putation, on Bitcoin. Their technique is fairly complicated
and relies on the assumption that all the computations done
by consensus protocol will be correct. As we have shown,
with expressive scripting languages (c.f. Ethereum), one can
achieve what these previous works have done in Bitcoin with
a single concise smart contract. However, as we pointed
out in this paper, miners have incentive to deviate from the
honest protocol in a new Turing-complete cryptocurrency.
Thus, techniques used in [20, 21] may not guarantee the
correctness of the computation on some ε-consensus com-
puter having small ε. Furthermore, our technique diﬀers
from theirs by leveraging a new cryptocurrency design and

adapting property testing techniques within the veriﬁable
computation domain.

8. CONCLUSION

In this paper, we introduce a veriﬁer’s dilemma demon-
strating that honest miners are vulnerable to attacks in cryp-
tocurrencies where verifying transactions per block requires
signiﬁcant computational resources. We formalize the se-
curity security model to study the incentive structure and
attacks which aﬀect the correctness of computations per-
formed on a consensus computer. Finally, we discuss how
to implement our ε-consensus computer in Ethereum with
various trade-oﬀs in latency and accuracy. We consider it
an interesting open problem to determine whether one can
incentivize robust computations to execute correctly on a
consensus computer by modifying its underlying consensus
mechanism.

9. ACKNOWLEDGMENT

We thank Frank Stephan, Shruti Tople, Pratik Soni, Ratul
Saha, Virgil Griﬃth and Vitalik Buterin for useful discus-
sions and feedback on the early version of the paper. This
work is supported by the Ministry of Education, Singapore
under under Grant No. R-252-000-560-112. All opinions ex-
pressed in this work are solely those of the authors.

10. REFERENCES
[1] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic

cash system. bitcoin.org, 2009.

[2] Karl J. O’Dwyer and David Malone. Bitcoin mining

and its energy footprint. In Irish Signals Systems
Conference 2014 and 2014 China-Ireland International
Conference on Information and Communications
Technologies (ISSC 2014/CIICT 2014). 25th IET,
pages 280–285, June 2014.

[3] Rob Halford. Gridcoin: Crypto-currency using

berkeley open infrastructure network computing grid
as a proof of work. http://www.gridcoin.us/images/
gridcoin-white-paper.pdf, May 2014.

[4] Use case for factom: The world’s ﬁrst blockchain

operating system (bos). http://kencode.de/
projects/ePlug/Factom-Linux-Whitepaper.pdf, Feb
2015.

[5] Ethereum Foundation. Ethereum’s white paper.

https:
//github.com/ethereum/wiki/wiki/White-Paper,
2014.

[6] blockchain.info. Bitcoin average number of

transactions per block. https://blockchain.info/
charts/n-transactions-per-block.

[7] Gavin Andresen. Why increasing the max block size is

urgent. http://gavinandresen.ninja/
why-increasing-the-max-block-size-is-urgent,
May 2015.

[8] Justin Thaler. Time-optimal interactive proofs for

circuit evaluation. In Advances in Cryptology -
CRYPTO 2013 - 33rd Annual Cryptology Conference,
Santa Barbara, CA, USA, August 18-22, 2013.
Proceedings, Part II, pages 71–89, 2013.

[9] Graham Cormode, Michael Mitzenmacher, and Justin
Thaler. Practical veriﬁed computation with streaming

717interactive proofs. In Proceedings of the 3rd
Innovations in Theoretical Computer Science
Conference, ITCS ’12, pages 90–112, 2012.

[10] Srinath T. V. Setty, Richard McPherson, Andrew J.

Blumberg, and Michael Walﬁsh. Making argument
systems for outsourced computation practical
(sometimes). In 19th Annual Network and Distributed
System Security Symposium, NDSS, pages 253–268,
2012.

[11] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin,

Eran Tromer, and Madars Virza. Snarks for c:
Verifying program executions succinctly and in zero
knowledge. Cryptology ePrint Archive, Report
2013/507, 2013. http://eprint.iacr.org/.

[12] Benjamin Braun, Ariel J. Feldman, Zuocheng Ren,

Srinath Setty, Andrew J. Blumberg, and Michael
Walﬁsh. Verifying computations with state. In
Proceedings of the Twenty-Fourth ACM Symposium on
Operating Systems Principles, SOSP ’13, pages
341–357, 2013.

[13] Srinath Setty, Victor Vu, Nikhil Panpalia, Benjamin

Braun, Andrew J. Blumberg, and Michael Walﬁsh.
Taking proof-based veriﬁed computation a few steps
closer to practicality. In Proceedings of the 21st
USENIX Conference on Security Symposium,
Security’12, 2012.

[14] Bryan Parno, Jon Howell, Craig Gentry, and Mariana

Raykova. Pinocchio: Nearly practical veriﬁable
computation. In Proceedings of the 2013 IEEE
Symposium on Security and Privacy, SP ’13, pages
238–252, 2013.

[15] Joseph Bonneau, Andrew Miller, Jeremy Clark,

Arvind Naryanan, Joshua A. Kroll, and Edward W.
Felten. SoK: Research Perspectives and Challenges for
Bitcoin and Cryptocurrencies. In IEEE Security and
Privacy 2015, May 2015.

[16] A Miller, A Juels, E Shi, B Parno, and J Katz.

Permacoin: Repurposing bitcoin work for long-term
data preservation. IEEE Security and Privacy, 2014.

[17] Ian Miers, Christina Garman, Matthew Green, and

Aviel D Rubin. Zerocoin: Anonymous Distributed
E-Cash from Bitcoin. IEEE Symposium on Security
and Privacy, 2013.

[18] Eli Ben Sasson, Alessandro Chiesa, Christina Garman,
Matthew Green, Ian Miers, Eran Tromer, and Madars
Virza. Zerocash: Decentralized anonymous payments
from bitcoin. In Proceedings of the 2014 IEEE
Symposium on Security and Privacy, SP ’14, 2014.

[19] Ranjit Kumaresan and Iddo Bentov. How to use

bitcoin to incentivize correct computations. In
Proceedings of the 2014 ACM SIGSAC Conference on
Computer and Communications Security, 2014, pages
30–41, 2014.

[20] Marcin Andrychowicz, Stefan Dziembowski, Daniel

Malinowski, and Lukasz Mazurek. Secure multiparty
computations on bitcoin. In Proceedings of the 2014
IEEE Symposium on Security and Privacy, SP ’14,
pages 443–458. IEEE Computer Society, 2014.

[21] Iddo Bentov and Ranjit Kumaresan. How to use

bitcoin to design fair protocols. In Advances in
Cryptology - CRYPTO 2014 - 34th Annual Cryptology

Conference, Santa Barbara, CA, USA, August 17-21,
2014, Proceedings, Part II, pages 421–439, 2014.
[22] Nick Szabo. The idea of smart contracts. http:

//szabo.best.vwh.net/smart_contracts_idea.html,
1997.

[23] Gavin Wood. Ethereum: A secure decentralised

generalised transaction ledger.
http://gavwood.com/paper.pdf, 2014.

[24] Andrew Miller, James Litton, Andrew Pachulski,
Neil Spring Neal Gupta, Dave Levin, and Bobby
Bhattacharjee. Discovering Bitcoin’s public topology
and inﬂuential nodes. http:
//cs.umd.edu/projects/coinscope/coinscope.pdf,
May 2015.

[25] US-CERT/NIST. Resource exhaustion attack in
bitcoin. https://web.nvd.nist.gov/view/vuln/
detail?vulnId=CVE-2013-2292, 2013.

[26] Sergio Demian Lerner. New bitcoin vulnerability: A

transaction that takes at least 3 minutes to be veriﬁed
by a peer. https://bitcointalk.org/?topic=140078,
2013.

[27] Some miners generating invalid blocks. https:

//bitcoin.org/en/alert/2015-07-04-spv-mining,
July 2015.

[28] Byron Cook, Andreas Podelski, and Andrey

Rybalchenko. Proving program termination. Commun.
ACM, 54(5):88–98, May 2011.

[29] Dana Ron. Property testing (a tutorial). http:

//www.eng.tau.ac.il/~danar/Public-pdf/tut.pdf,
2000.

[30] Oded Goldreich. Combinatorial property testing (a

survey). Electronic Colloquium on Computational
Complexity (ECCC), 4(56), 1997.

[31] Endre Szemer´edi. Regular partitions of graphs. In

Probl`emes combinatoires et th´eorie des graphes
(Colloq. Internat. CNRS, Univ. Orsay, Orsay, 1976),
volume 260 of Colloq. Internat. CNRS, pages 399–401.
1978.

[32] Noga Alon and Asaf Shapira. Every monotone graph

property is testable. SIAM Journal on Computing,
38(2):505–522, 2008.

[33] Noga Alon and Michael Krivelevich. Testing

k-colorability. SIAM Journal on Discrete
Mathematics, 15(2):211–227, 2002.

[34] Miguel Castro and Barbara Liskov. Practical

byzantine fault tolerance. In Proceedings of the Third
Symposium on Operating Systems Design and
Implementation, OSDI ’99, pages 173–186, 1999.

[35] David Mazieres. The stellar consensus protocol: A

federated model for internet-level consensus.
https://www.stellar.org/papers/
stellar-consensus-protocol.pdf, April 2015.

[36] Kwon Jae. Tendermint: Consensus without mining.

http://jaekwon.com/2014/05/11/tendermint/, May
2014.

[37] King Sunny and Nadal Scott. Ppcoin: Peer-to-peer

crypto-currency with proof-of-stake. http:
//peercoin.net/assets/paper/peercoin-paper.pdf,
August 2012.

[38] Loi Luu, Ratul Saha, Inian Parameshwaran, Prateek

Saxena, and Aquinas Hobor. On power splitting
games in distributed computation: The case of bitcoin

718pooled mining. The 28th IEEE Computer Security
Foundations Symposium, July 2015.

[39] Ittay Eyal and Emin G¨un Sirer. Majority is not

enough: Bitcoin mining is vulnerable. arXiv preprint
arXiv:1311.0243, 2013.

[40] Ittay Eyal. The miner’s dilemma. In The 36th IEEE

Symposium on Security and Privacy, SP ’15, May
2015.

[41] Joshua A. Kroll, Ian C. Davey, and Edward W. Felten.

The economics of Bitcoin mining, or Bitcoin in the
presence of adversaries. In Workshop on the
Economics of Information Security, June 2013.

[42] Juan A. Garay, Aggelos Kiayias, and Nikos Leonardos.

The bitcoin backbone protocol: Analysis and
applications. In Advances in Cryptology -
EUROCRYPT 2015, pages 281–310, 2015.

[43] Ahmed Kosba, Andrew Miller, Elaine Shi, Zikai Wen,

and Charalampos Papamanthou. Hawk: The
blockchain model of cryptography and
privacy-preserving smart contracts. Cryptology ePrint
Archive, Report 2015/675, 2015.
http://eprint.iacr.org/.

[44] Response from founder of ethereum about our paper.

https://www.reddit.com/r/ethereum/comments/
3fcw0i/verifiers_dilemma_renders_ethereum_
nonincentive/, July 2015.

APPENDIX
A. DISCUSSION ON GASLIMIT IN ETHEREUM
We explain why gasLimit does not help Ethereum prevent
our DoS attack completely. The current design allows the
miners to set the gasLimit for the next block once they ﬁnd
a block. However, the gasLimit of the next block cannot
vary more than a fraction (2−10) of the current gasLimit.
We learned this from our private communication with the
founder of Ethereum. The constraint seems to mitigate our
attack, however, we explain why the gasLimit can reach
to a high value that makes the resource exhaustion attack
feasible.

In practice, miners have diﬀerent views of what gasLimit
value is acceptable because of various reasons. For instance,
one may be willing to always verify a new block regardless
of its gasLimit value because they have more resources or
they simply value the advantages of having a high gasLimit
value than the disadvantages. Thus, each miner will decide
to only reduce block’s gasLimit at a diﬀerent threshold Gi.
Suppose that our DoS attack requires gasLimit to be at
least G0 to be practical. In a scenario where more than 50%
of computational power consider G0 is still within their Gi,
all miners are under our denial-of-service attack. On the
other hand, if the majority of miners have their Gi less than
G0, gasLimit can successfully block our attack.

For the completeness of our argument, rational users in
the network have the following incentives to extend gasLimit
value.

• Higher gasLimit value means higher transaction fee

that miners can collect from a block.

• A block with a higher gasLimit can support more ap-
plications, speciﬁcally the application that requires more
gas to run. Thus, the value of the network and its un-
derlying currency is more valuable, which beneﬁts di-
rectly the miners.

• As more and more applications are built on top of
Ethereum, the gasLimit has to be increased correspond-
ingly in order to improve the throughput of the network
to support those applications. It is not practical to wait
for, say, ten blocks to see a transaction gets included in
the blockchain due to the small throughput.

There are also reasons that miners decide to reduce gasLimit.

The Ethereum founder mentions about those reasons in a
public post which discusses our work [44].

• Miners realize that high gasLimit value may cause DoS

attack as we described.

• Transaction fee is increased because low gasLimit means
only a limited number of transactions can be included
in a block.

In conclusion, gasLimit does not completely block our
DoS attack, i.e., resource exhaustion attack, in Ethereum.

719