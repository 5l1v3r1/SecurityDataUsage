On the Security of TLS Renegotiation

Florian Giesen
Horst Görtz Institut

Germany

Florian Kohlar
Horst Görtz Institut

Germany

Ruhr-Universität Bochum,

Ruhr-Universität Bochum,

ﬂorian.giesen@rub.de

ﬂorian.kohlar@rub.de

Douglas Stebila

Queensland University of

Technology

Brisbane, Australia

stebila@qut.edu.au

ABSTRACT
The Transport Layer Security (TLS) protocol is the most
widely used security protocol on the Internet. It supports
negotiation of a wide variety of cryptographic primitives
through diﬀerent cipher suites, various modes of client au-
thentication, and additional features such as renegotiation.
Despite its widespread use, only recently has the full TLS
protocol been proven secure, and only the core cryptographic
protocol with no additional features. These additional fea-
tures have been the cause of several practical attacks on TLS.
In 2009, Ray and Dispensa demonstrated how TLS renego-
tiation allows an attacker to splice together its own session
with that of a victim, resulting in a man-in-the-middle attack
on TLS-reliant applications such as HTTP. TLS was subse-
quently patched with two defence mechanisms for protection
against this attack.

We present the ﬁrst formal treatment of renegotiation in
secure channel establishment protocols. We add optional
renegotiation to the authenticated and conﬁdential channel
establishment model of Jager et al., an adaptation of the
Bellare–Rogaway authenticated key exchange model. We
describe the attack of Ray and Dispensa on TLS within our
model. We show generically that the proposed ﬁxes for TLS
oﬀer good protection against renegotiation attacks, and give
a simple new countermeasure that provides renegotiation
security for TLS even in the face of stronger adversaries.

Categories and Subject Descriptors
C.2.0 [Computer–Communication Networks]: General
—security and protection

Keywords
Transport Layer Security (TLS); renegotiation; security
models; key exchange

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’13, November 4–8, 2013, Berlin, Germany.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-2477-9/13/11 ... $15.00.
http://dx.doi.org/10.1145/2508859.2516694.

1.

INTRODUCTION

The Transport Layer Security (TLS) protocol, the suc-
cessor of the Secure Sockets Layer (SSL) protocol, provides
secure channel establishment on the Internet. It is commonly
used to protect information sent via the Hypertext Transfer
Protocol (HTTP) on the web, and many other application
layer protocols such as email and ﬁle transfer. TLS consists
of a handshake protocol, used to agree on security parame-
ters, establish a secret key, and authenticate the parties; and
a record layer protocol, used to send encrypted data.

Despite the importance of TLS, progress on formally mod-
elling the security of TLS has been slow. A technicality of
TLS prevents it from being proven secure in standard authen-
ticated key exchange (AKE) models: in AKE, the session key
must be indistinguishable from a random key of the same
length. However, the ﬁnal handshake message of the TLS
protocol is encrypted under the session key, so an adversary
can distinguish the session key from a random key by trying
to verify the ﬁnal handshake message. Some analyses [17,
22] have shown that a truncated form of the TLS handshake
is AKE-secure. Others [12] deal with a substantially weaker
security requirement, namely unauthenticated key agreement.
Krawczyk [19] analyzed a variant of the TLS record layer.

Only very recently have analyses of unmodiﬁed TLS func-
tionality appeared. Paterson et al. [23] showed that TLS’s
MAC-then-encode-then-encrypt record layer when used with
CBC encryption (with certain length restrictions) satisﬁes
length-hiding authenticated encryption (LHAE). Jager et al.
[16] gave the ﬁrst full proof of the security of (one ciphersuite
of) unmodiﬁed TLS in a strong security model. Jager et al.
introduced a variant of the Bellare–Rogaway authenticated
key exchange model, called authenticated and conﬁdential
channel establishment (ACCE). They proved that the TLS
1.2 protocol using the TLS_DHE_DSS_WITH_3DES_EDE_CBC_
SHA ciphersuite (which we shorten to TLS_DHE_DSS_) is a
secure ACCE protocol, under standard assumptions on the
cryptographic components. Ciphersuites based on RSA key
transport and static Diﬃe–Hellman have since been shown
ACCE-secure by both Kohlar et al. [18] and Krawczyk et al.
[20]. (An alternative modular approach to proving the full
security of TLS was given by Brzuska et al. [5].)
But TLS is not just a basic secure channel:

it consists
of hundreds of variants with many optional complex func-
tionalities. Alert messages report various error conditions.
Previous sessions can be resumed with a shortened handshake.
As of August 2013, over 300 ciphersuites—combinations of
cryptographic primitives—have been standardized. Client
authentication is optional, and can be certiﬁcate-based or

387password-based. Various additional options can be speciﬁed
via extensions and optional ﬁelds. Record layer communica-
tion can be compressed. And most importantly for this paper,
after a TLS handshake has been completed and transmission
on the record layer has started, parties can renegotiate the
handshake. There have been many attacks on TLS over the
years, such Bleichenbacher’s attack [4] and others involving
padding, and Ray and Dispensa’s renegotiation attack [24],
all of which exploit ﬂaws outside the core cryptographic
primitives of TLS.

In this paper, we focus on renegotiation, which allows two
parties to either (a) obtain a fresh session key, (b) change
cryptographic parameters, or (c) change authentication cre-
dentials. For example, if a client needs to authenticate using
a client certiﬁcate but wishes to not reveal her identity over a
public channel, she could ﬁrst authenticate anonymously (or
with pseudonymous credentials), then renegotiate using her
real certiﬁcate; since the renegotiation messages are trans-
mitted within the existing record layer, the transmission of
her certiﬁcate is encrypted, and thus she obtains privacy for
her identity. We will examine TLS renegotiation in detail,
especially in light of previously identiﬁed practical attacks
related to TLS renegotiation.

Despite the utility of renegotiation in real-world protocols—
beyond TLS, renegotiation, rekeying, or reauthentication
is also used in the Secure Shell (SSH) protocol, Internet
Key Exchange version 2, the Tor anonymity protocol, and
others—there has been almost no research in the literature
on the security of protocols involving renegotiation, with the
exception of a brief note on the TLS renegotiation attack
by Farrell [10] and the recent thesis of Gelashvili [13], which
uses the Scyther tool to automatically identify the TLS
renegotiation attack. Bhargavan et al. [2] implement TLS
supporting a variety of ciphersuites and deﬁne an application
programming interface for TLS which diﬀerentiates between
renegotiated phases; using typechecking, the implementation
is shown secure according to a formal speciﬁcation, albeit
with a restricted adversary who cannot corrupt session keys.

1.1 The TLS Renegotiation Issue

All versions of TLS [7, 8, 9], and SSL v3 [11] before it,
support optional renegotiation. After the initial handshake
is completed and secure communication begins in the record
layer, either party can request renegotiation. The client can
request renegotiation by sending a new ClientHello message
in the current record layer (i.e., encrypted under the current
session key); the server can request renegotiation by sending
a HelloRequest message in the record layer, which triggers
the client to send a new ClientHello message.

In November 2009, Ray and Dispensa [24] described a man-
in-the-middle attack that exploits how certain TLS-reliant
applications—such as HTTP over TLS [25]—process data
across renegotiations. The attack is shown in Figure 1. The
attacker Eve observes Alice attempting to establish a TLS
session with Bob. Eve delays Alice’s initial ClientHello
and instead establishes her own TLS session with Bob and
transmits a message m0 over that record layer. Then Eve
passes Alice’s initial ClientHello to Bob over the Eve–Bob
record layer. Bob views this as a valid renegotiation and
responds accordingly; Eve relays the handshake messages
between Alice and Bob, who eventually establish a new record
layer to which Eve has no access. Alice then transmits a
message m1 over the Alice–Bob record layer.

Alice

Eve

handshakeAB

Bob

Bob

(TLS server)

(application)

d
e
l
a
y
e
d

b
y

E
v
e

handshakeEB

record layerEB

m0

m0

record layerAB

m1

m1

m0(cid:107)m1

Figure 1: Ray and Dispensa’s man-in-the-middle
renegotiation attack on TLS-reliant applications

This is not strictly speaking an attack on TLS but on
how some applications process TLS-protected data. It re-
sults from some applications, including HTTPS [24] and
SMTPS [28], concatenating m0 and m1 and treating them
as coming from the same party in the same context. For
example, if Eve sends the HTTP request m0 and Alice sends
the HTTP request m1, where

m0 = “GET /orderPizza?deliverTo=123-Fake-St ←(cid:45)

X-Ignore-This: ”

m1 = “GET /orderPizza?deliverTo=456-Real-St ←(cid:45)

Cookie: Account=111A2B”

(where ←(cid:45) denotes new-line character), then the concatenated
request (across multiple lines for readability) is
m0(cid:107)m1 = “GET /orderPizza?deliverTo=123-Fake-St ←(cid:45)

X-Ignore-This: GET /orderPizza

?deliverTo=456-Real-St ←(cid:45)

Cookie: Account=111A2B”

The “X-Ignore-This:” preﬁx is an invalid HTTP header,
and since this header, without a new line character, is con-
catenated with the ﬁrst line of Alice’s request, so this line is
ignored. However, the following line, Alice’s account cookie,
is still processed. Eve is able to have the pizza delivered to
herself but paid for by Alice.

It should be noted that Ray and Dispensa’s attack works for
both server-only authentication and mutual authentication
modes of TLS: the use of client certiﬁcates in general does
not prevent the attack [24, 28].
1.2 Countermeasures Added to TLS

The immediate recommendation due to this attack was to
disable renegotiation except in cases where it was essential.
Subsequently, the Internet Engineering Task Force (IETF)
TLS working group developed RFC 5746 [26] to provide
countermeasures to this attack, with the goal of applicability
to SSLv3.0 and TLS versions 1.0–1.2. Two countermeasures
were standardized: the Signalling Ciphersuite Value (SCSV)
and the Renegotiation Information Extension (RIE). In RIE,
the parties include the key conﬁrmation value from the previ-
ous handshake in a ClientHello/ServerHello extension [3],
demonstrating they have the same view of the previous
handshake, or a distinguished null value if not renegotiation.
SCSV is a slight modiﬁcation that is more compatible with
buggy implementations. A diagram showing the message
ﬂow for a generic TLS ciphersuite with SCSV/RIE counter-
measures appears in Figure 2 in Appendix B. According to

388one survey [27], as of July 2013, 82% of TLS-enabled web-
sites support SCSV/RIE, with 9% still supporting insecure
renegotiation and 9% not supporting renegotiation.
1.3 Contributions

Security model for renegotiable channel establishment pro-
tocols. In Section 2, we present a new security model for
renegotiable protocols. Since our goal is to analyze the se-
curity of TLS, we start from the ACCE model, rather than
AKE security models. The primary diﬀerence in our model
for renegotiable protocols is that each party’s oracle (session)
can have multiple phases; each new phase corresponds to
a renegotiation in that session, and can involve the same
or diﬀerent long-term keys.1 This is qualitatively diﬀerent
than simply having multiple sessions, since short-term values
from one phase of a session may be used in the renegotia-
tion for the next phase, whereas multiple sessions only share
long-term values. Each oracle maintains state and encryp-
tion/MAC keys for each phase. Like in TLS, our formalism
allows control messages to be sent on the encrypted channel.
Our extension to the ACCE model also models server-only
authentication in addition to mutual authentication.

The basic goals of a secure renegotiable ACCE protocol are
that (a) the adversary should not be able to read or inject
messages on the encrypted channel, and (b) whenever parties
successfully renegotiate, they should have exactly the same
view of all previous negotiations and all encrypted messages
sent in all previous phases of that session, even when values
from previous phases have been compromised.

Analysis of TLS without and with SCSV/RIE countermea-
sures. Based on the TLS renegotiation attack of Ray and
Dispensa, we see in Section 3 that TLS without counter-
measures is not secure in our model for renegotiation. We
subsequently show in Section 4 that, generically, TLS with
the SCSV/RIE countermeasures of RFC 5746 [26] is a weakly
secure renegotiable ACCE protocol. In this slightly weaker—
but still quite reasonable—model, the adversary is slightly
restricted in the previous secrets she is allowed to reveal.

Our approach for proving the renegotiable security of TLS
with SCSV/RIE countermeasures is modular. We cannot
generically prove that an ACCE-secure TLS ciphersuite is,
with SCSV/RIE, a weakly secure renegotiable ACCE, be-
cause the protocol itself is modiﬁed by including SCSV/RIE
and hence a black-box approach does not work. Instead, we
consider tagged TLS where an arbitrary tag can be provided
as an extension. Via a chain of results and models, we show
that if a tagged TLS ciphersuite is secure in an ACCE variant
where Finished messages are revealed, then that TLS cipher-
suite with SCSV/RIE is a weakly secure renegotiable ACCE
protocol. This provides a generic justiﬁcation for the security
of SCSV/RIE. Proving that TLS ciphersuite secure in this
tagged variant model seems to be almost no harder than a
proof that it is ACCE-secure; we only needed to change a few
lines from the ACCE security proof of TLS_DHE_DSS_ [16].

New countermeasure for TLS. TLS with SCSV/RIE can-
not meet our strongest notion of renegotiable security, only
the weaker notion described above. In the strong deﬁnition,
even if the adversary learns the session key of one phase,
parties who later renegotiate still should detect any earlier

1Note that TLS standards use diﬀerent words. We say a
single session can have multiple phases; the TLS standards
refer to a single connection having multiple sessions.

Secure

Weakly secure

Secure

multi-phase

renegotiable

renegotiable

ACCE
(Defn. 3)

×

—

—

ACCE
(Defn. 5)

(cid:88)

× (§3)

(cid:88) (Thm. 1)

ACCE
(Defn. 4)

(cid:88)1
× (§3)
× (§4.1)

(cid:88) (Thm. 4)

(cid:88) (Thm. 4)

(cid:88) (Thm. 4)

Secure against Ray–
Dispensa-type attacks

TLS w/o countermeasures

with SCSV/RIE
(if tagged-ACCE-ﬁn-secure)

with new countermeasure
(if tagged-ACCE-ﬁn-secure)

1 For secure renegotiable ACCE, security holds even if session
keys from one phase are revealed while that phase is active.

Table 1: Summary of security notions and results on
TLS

message injections by the adversary. Though the ability to
learn session keys of phases while the protocol is still running
makes the adversary quite powerful, this may be realistic
in scenarios with long-lived session keys, for example with
session resumption. We present in Section 5 a simple adjust-
ment to the renegotiation information extension—adding a
ﬁngerprint of the transcript of the previous phase’s record
layer—so TLS can achieve this stronger security notion. This
countermeasure can be seen as providing record layer recog-
nition, conﬁrming that both parties have the same view
of all communicated messages, rather than just handshake
recognition as in the SCSV/RIE countermeasure.

Table 1 summarizes our results on TLS and renegotiation
countermeasures. While our theorems are speciﬁc to TLS,
our deﬁnitional framework is suitable for any channel estab-
lishment protocol that involves renegotiation, and could for
example be used to check if renegotiation in the Secure Shell
(SSH) protocol really is secure [21].

On composability and the choice of ACCE. It would be
desirable to prove the security of the TLS renegotiation coun-
termeasures via some kind of composability framework, such
as universal composability or the game-based composability
framework of Brzuska et al. [5]. Unfortunately, this is not
possible with existing security deﬁnitions for TLS. The TLS
renegotiation countermeasures are not achieved by composing
in a black-box manner one protocol or primitive with another.
Instead, the SCSV/RIE countermeasure looks inside the pro-
tocol and changes it in a white-box way:
it modiﬁes the
messages sent by the protocol, and re-uses an internal value.
Thus we cannot make use of existing security results in a
black-box compositional way. Our approach is the “next best
thing”: we modify an existing security deﬁnition (ACCE) in
what seems to be a minimal way, adding just enough “hooks”
to get at the internal values needed to modify and re-use
the required values for the SCSV/RIE countermeasure. We
are then able to prove in a fully generic way that any TLS
protocol that satisﬁes this slightly modiﬁed ACCE notion
with hooks is, when using the SCSV/RIE countermeasure,
secure against renegotiation attacks. Since the hooks added
are quite small, it is not much work to change a proof that a
TLS ciphersuite is ACCE secure to show that it satisﬁes this
slightly modiﬁed ACCE notion as well.

Of the two existing deﬁnitional approaches for proving
the full security of the TLS protocol [16, 5], we chose the
ACCE approach over the game-based composability approach

389because renegotiation in TLS makes extensive use of the
interplay between the handshake and record layer.

Moreover, the modiﬁcations we make to the execution
environment to enable analysis of renegotiable ACCE proto-
cols can be adapted to capture renegotiation and rekeying in
other types of protocols such as authenticated key exchange.

2. SECURITY DEFINITIONS FOR MULTI-

PHASE AND RENEGOTIABLE ACCE

In this section we describe what a multi-phase authenti-
cated and conﬁdential channel establishment (ACCE) proto-
col is and our various renegotiation security notions. Essen-
tially, a multi-phase protocol can have many key exchanges—
each called a phase—linked to a single session. Our deﬁnition
builds on the ACCE deﬁnition of Jager et al. [16], which
combined the Bellare–Rogaway model for authenticated key
exchange [1] with a Jager et al.’s stateful variant of Pater-
son et al.’s length-hiding authenticated encryption [23].

Notation. If S is a set, x $← S denotes sampling a value x
uniformly at random from S. x $← A(y) denotes the output
x of the probabilistic algorithm A when run on input y and
randomly chosen coins. AO(·) means A is run with access to
oracle O(·). The notation [1, n] denotes the set {1, 2, . . . , n};
phases[(cid:96)] denotes the (cid:96)th entry in the 1-indexed array phases
and |phases| denotes the number of entries in the array. πs
A.x
denotes variable x stored in oracle instance πs
A.

2.1 Overview

The ﬁrst security notion, a secure multi-phase ACCE pro-
tocol, is a straightforward extension of the ACCE model to
allow multiple, independent phases per session; notably, we
require essentially no link between phases:
• An adversary breaks (multi-phase) authentication if a
party accepts in a phase with uncorrupted long-term
keys, but no matching phase exists at the peer.
• An adversary breaks conﬁdentiality/integrity if it can
guess the bit b involved in a conﬁdentiality/integrity ex-
periment similar to stateful length-hiding authenticated
encryption.

Our main security deﬁnition is a secure renegotiable ACCE
protocol, which strengthens the authentication notion: parties
should successfully renegotiate only when they have exact
same view of everything that happened before.
• An adversary breaks renegotiation authentication if a
party accepts in a phase where long-term keys have not
been corrupted, but either no matching phase exists at
the peer or some previous handshake or record layer
transcript does not match.

However, it is not possible to prove that TLS with the
SCSV/RIE countermeasures is a secure renegotiable ACCE
protocol: as we will see in Section 3, the strong deﬁnition
requires that the views of parties match when successfully
renegotiating, even when previous sessions’ long-term secret
keys or session keys were revealed. TLS’s SCSV/RIE coun-
termeasures do not fully protect against the case when these
secret values are revealed.

As a result, we introduce the weaker, though still quite rea-
sonable, notion of a weakly secure renegotiable ACCE protocol,
and prove in Section 3 that the SCSV/RIE countermeasure
for TLS generically provides it:

• An adversary breaks weak renegotiation authentication
if a party accepts in a phase with uncorrupted long-
term keys and session keys for each earlier phase were
not revealed while that phase was active, but either no
matching phase exists at the peer or some previous
handshake or record layer transcript does not match.
We proceed by describing the execution environment for
adversaries interacting with multi-phase ACCE protocols,
then deﬁne the various security notions described above.

2.2 Execution Environment

Parties. The environment consists of npa parties, {P1, . . . ,
Pnpa}. Each party PA is a potential protocol participant,
and has a list of nke long-term key pairs (pkA,1, skA,1), . . . ,
(pkA,nke , skA,nke ). We assume that each party PA is uniquely
identiﬁed by any one of its public keys pkA,∗. In practice,
there may be other identities that are bound to these public
keys, e.g. by using certiﬁcates, but this is out of scope of this
paper. It is common in AKE security models to assume ideal
distribution of long-term public keys for simplicity [1, 6, 16].

Sessions. Each party PA can participate in up to nse
sessions, which are independent executions of the protocol
and can be concurrent or subsequent; all of a party’s sessions
have access to the same list of its long-term key pairs, as well
as a trusted list of all parties’ public keys. Each session s ∈
[1, nse] is presented to the environment as an oracle πs
A. Each
oracle πs
A.d the oracle corresponding
to the intended communication partner, e.g.πs
B. As
well, the variable ρ ∈ {Client, Server} records the role of the
oracle. Parties can play the role of the client in some sessions
and of the server in other sessions, but their role is ﬁxed
across all phases within a session.

A records in a variable πs

A.d = πt

Phases. Each session can consist of up to nph phases. Each
phase consists of two stages: a pre-accept, or “handshake”,
stage, which is eﬀectively an AKE protocol that establishes
a session key and performs mutual or server-only authen-
tication; and a post-accept, or “record layer”, stage, which
provides a stateful communication channel with conﬁden-
tiality and integrity. A list πs
A.phases of diﬀerent phase
states is maintained; we sometimes use the notation πs,(cid:96)
A
for πs
A.phases[(cid:96)]. There can be at most nph phases per or-
acle. The last entry of πs
A.phases contains the state of the
current phase, which may still be in progress. Each entry
πs

A.phases[(cid:96)] in the log contains:
• pk, the public key used by πs
• pk(cid:48), the public key that πs
A observed as being used for
• ω ∈ {0, 1}, denoting the authentication mode used,
where 0 indicates that server-only authentication is used
in that phase and 1 indicates mutual authentication,
• ∆, a counter used to keep track of the current status
• α, either accept, reject, or ∅ (for in-progress),
• k, the encryption and/or MAC key(s) established by
• T , the transcript of all (plaintext) messages sent and
A during the pre-accept stage of that

its peer in that phase2,

of the protocol execution,

A in that phase,

πs

A in that phase,

received by πs
phase,

2One of the public keys may remain empty, if no client
authentication is requested.

390• RTs and RTr, the transcripts of all ciphertexts sent
and received (respectively) in the post-accept phase by
πs
A encrypted under the key established in that phase,
• b, a random bit sampled by the oracle at the beginning
• st, some additional temporary state (which may, for
instance, be used to store ephemeral Diﬃe–Hellman
exponents for the handshake, or state for the sLHAE
scheme for the record layer).

of the phase, and

Once a phase of a protocol accepts (that is, an encryption
key has been negotiated and authentication is believed to
hold), then α is set to accept. If the protocol rejects and the
oracle wishes to discontinue operation, the counter ∆ can be
set to the special symbol reject. Whenever a new handshake
initialization message is received, the oracle adds a new entry
to its phases list. The variable ω is set at some point during
(or before) the protocol execution, depending on the protocol
speciﬁcation (e.g.in case of TLS, the server can send the
message CertificateRequest to request client, i.e. mutual,
authentication, otherwise server-only authentication is used).
Application data messages sent and received encrypted under
a newly established encryption key (e.g. messages sent in
the TLS record layer) will be appended to variables RTs and
RTr in the latest entry of the log. If handshake messages
for the renegotiation of a new phase are encrypted under
the previous phase’s session key (as they are in TLS), the
plaintext messages are appended to variable T in the new
entry of the phase log, and ciphertexts are appended to RT
in the previous phase.

Remark 1. The introduction of multiple phases is the
main diﬀerence compared to previous AKE and ACCE mod-
els. We need to allow multiple authentications and key ex-
changes within one oracle to capture the functionality of
renegotiation. When limited to a single phase and when each
party has only one long-term key pair, our execution environ-
ment/security experiment is equivalent to the original ACCE
model of Jager et al. [16].

Adversarial interaction. The adversary interacts with or-
acles by issuing the following queries, which allow her to
control (forward/alter/create/drop) all communication on
the public channel (Send), learn parties’ long-term secret
keys (Corrupt), learn session keys (Reveal), and control send-
ing and receiving of arbitrary messages on the encrypted
record layer (Encrypt/Decrypt) using a stateful symmetric
encryption scheme StE [23].

• Send(πs

A, m): The adversary can use this query to send
any (plaintext) message m of its choosing to (the cur-
rent phase of) oracle πs
A. The oracle will respond
according to the protocol speciﬁcation, depending on
its internal state. Some distinguished control messages
have special behaviour:

– m = (newphase, pk, ω) triggers an oracle to initi-
ate renegotiation of a new phase (or new session
if ﬁrst phase). Note that the action here may vary
based on the role of the party: for example, when
renegotiating in TLS, a client would prepare a new
ClientHello message, encrypt it by calling the
Encrypt oracle below, and then return the cipher-
text to the adversary for delivery; a server would
correspondingly prepare an encrypted ServerHel-
loRequest message.

– m = (ready, pk, ω) activates a (server) oracle to

use the public key pk in its next phase.

For the above control messages, pk indicates the long-
term public key pk the oracle should use in the phase
and ω indicates the authentication mode to use; the
oracle returns ⊥ if it does not hold the secret key for pk.
Since the control messages do not specify the identity
of the peer, this is instead learned during the run of the
protocol: we are using a post-speciﬁed peer model [6].
Delivery of encrypted messages in the post-accept stage
are handled by the Decrypt query below. For protocols
such as TLS that perform renegotiation within the
encrypted channel, the oracle may reply with an error
symbol ⊥ if it has at least one entry in phases and
m (cid:54)= (newphase,·) or (ready,·).

A responds with the long-
term secret key skA,i corresponding to public key pk =
pkA,i of party PA, or ⊥ if there is no i such that
pk = pkA,i. This is the weak corruption model, meaning
we do not allow the adversary to obtain the party’s
internal state nor register rogue keys.
A responds with the key(s) πs
A.
phases[(cid:96)].k used in phase (cid:96), or ∅ if no such value exists.
Since the TLS record layer is unidirectional, there are
both encryption and decryption keys, and for most ci-
phersuites also MAC keys, so all 4 keys (K C→S
, K S→C
,
K C→S
, K S→C
) would be revealed, though one could
reﬁne if desired.

A, (cid:96)): Oracle πs

mac

mac

enc

enc

• Corrupt(PA, pk): Oracle π1

• Reveal(πs

• Encrypt(πs

A, ctype, m0, m1, len, hd): This query takes
as input a content type ctype, messages m0 and m1, a
length len, and header data hd. Content type control
is used for handshake messages. The adversary cannot
query this oracle with ctype = control. Through an
abuse of notation, we allow the party itself to call this
oracle with control to encrypt protocol messages that
must be sent encrypted; this abuse of notation allows
the party to construct encrypted protocol messages
while all aspects of the security experiment remain
synchronized. Content type data is used for record
layer messages; in this case, one of the two messages
(chosen based on bit b) is encrypted for the adversary
to distinguish. Encrypt depends on the random bit b
sampled by πs
A at the beginning of the current phase. It
maintains a counter u initialized to 0 and an encryption
state ste, and proceeds as follows:

A + 1

1. us
2. If (ctype = control) and caller is not πs

A, then
e ) $← StE.Enc(k, len, hd, ctype(cid:107)m0, ste)
e ) $← StE.Enc(k, len, hd, ctype(cid:107)m1, ste)

A ← us
return ⊥
3. (C (0), st(0)
4. (C (1), st(1)
5. If (C (0) = ⊥) or (C (1) = ⊥), then return ⊥
6. (C s
7. Return C s

A], ste) ← (C (bA

s ), st(bs
A)

)

e

A[us
A]

A, C, hd): This query takes as input a cipher-
text C and header data hd. If πs
A has not accepted in
the current phase, then it returns ⊥. Decrypt maintains
a counter v and a switch diverge, both initialized to 0,
and a decryption state std, and proceeds as described
below. If the decryption of C contains a control mes-
sage, then the oracle processes the message according
to the protocol speciﬁcation, which may include up-
dating the state of the oracle and/or creating a new

A[us
• Decrypt(πs

391phase, and returns any protocol response message to
the adversary, which may or may not be encrypted by
calling Encrypt according to the protocol speciﬁcation.
Technically it proceeds as follows:

A ← vs
A.d, vs
B) or (C (cid:54)= C t

A > ut
A = 1) and (diverge = 1), then m(cid:48) ← m

1. (B, t) ← πs
A + 1, m(cid:48) ← ∅
2. (ctype(cid:107)m, std) = StE.Dec(k, hd, C, std)
A]), then diverge ← 1
3. If (vs
4. If (bs
5. If ctype = control, then r(cid:48) ← protocol response
6. Else r(cid:48) ← ⊥
7. Return (m(cid:48), r(cid:48))

for m

B[vs

Remark 2. Note that k may be a ‘multi-part’ key with
diﬀerent parts for encryption, decryption, and MAC; we
assume StE.Enc and StE.Dec know which parts to use. Also
note that the ‘protocol response for m(cid:48) may be encrypted by
the party internally making an Encrypt call.

The behaviour of the Decrypt oracle in this combined def-
inition for conﬁdentiality and integrity can be somewhat
diﬃcult to understand. It extends that of stateful length-
hiding authenticated encryption as originally deﬁned by Pa-
terson et al. [23].
2.3 Security Deﬁnitions

In the original security deﬁnition for ACCE protocols,
security is deﬁned by requiring that (i) the protocol is a
secure authentication protocol, thus any party πs
A reaches
the post-accept state only if there exists another party πt
B
such that πs
A has a matching conversation (in the sense of
[16]) to πt
B, and (ii) data transmitted in the post-accept stage
over a secure channel is secure (in a sense similar to sLHAE).
We extend this notion to include security when a session
has multiple phases that can be renegotiated. We will give
several security deﬁnitions with diﬀerent levels of security
against renegotiation attacks, as described in the introduction
to Section 2.
Each security notion is formally deﬁned as a game played
between an adversary A and a challenger C, with the same
overall setup but diﬀerent winning conditions. In each game,
A : A ∈
the challenger implements the collection of oracles {πs
[1, npa], s ∈ [1, nse]}. At the beginning of the game, the chal-
lenger generates nke long-term key pairs (pkA,1, skA,1), . . . ,
(pkA,nke , skA,nke ) for each party PA; we assume that, within
a party, all public key pairs are distinct.
(That distinct
parties have distinct key pairs comes as a consequence of
the protocol being secure.) The adversary receives all par-
ties’ public keys as input. The adversary may issue Send,
Corrupt, Reveal, Encrypt, and Decrypt queries to the oracles
and eventually terminates.

Definition 1

(Correct multi-phase ACCE).

A with destination address πs

A.d = πt
A.phases[(cid:96)].T and πt

We say Π is a correct multi-phase ACCE protocol if, for all
oracles πs
B, and for all
(cid:96), (cid:96)(cid:48) ∈ [1, nph] for which πs
B.phases[(cid:96)(cid:48)].T
are matching conversations, it holds that πs
A.phases[(cid:96)].α =
B.phases[(cid:96)(cid:48)].α = accept, πs
πt
B.phases[(cid:96)].ω
and πs
A.phases[(cid:96)].k = πt
2.3.1 Conﬁdentiality.
All of our notions for secure ACCE protocols will require
conﬁdentiality/integrity of the post-accept stage record layer
in each uncorrupted phase. Intuitively, an adversary should

B.phases[(cid:96)(cid:48)].k.

A.phases[(cid:96)].ω = πt

not be able to guess the bit b used in the Encrypt/Decrypt
oracles in a phase where she has not impersonated the parties
(i.e., corrupted the long-term secret keys before the phase
accepted) or revealed the session key of the party or its
peer. As with the ACCE notion of Jager et al. [16], this
notion ensures forward security: corrupting long-term se-
cret keys after completion of a session should not impact
conﬁdentiality/integrity of messages.

Definition 2

(Confidentiality/integrity).

B; and

B = πs

A.d is πs

accepted in phase (cid:96); and

Suppose an algorithm A with running time τ interacts with
a multi-phase ACCE protocol Π in the above execution envi-
ronment and returns a tuple (A, s, (cid:96), b(cid:48)). If
C1. πs
A.phases[(cid:96)].α = accept; and
C2. A did not query Corrupt(PA, πs
C3. A did not query Corrupt(PB, πs
πs
A accepted in phase (cid:96), where πs
C4. A did not query Reveal(πs
A, (cid:96)); and
C5. A did not query Reveal(πt
B, (cid:96)(cid:48)), where πt

A.phases[(cid:96)].pk) before πs
A
A.phases[(cid:96)].pk(cid:48)) before
A.d = πt

A.phases[(cid:96)].T ; and
A.phases[(cid:96)].b = b(cid:48)] − 1/2| ≥ ,

A’s
intended communication partner, and (cid:96)(cid:48) is any phase
B.phases[(cid:96)(cid:48)].T is a matching conversation
for which πt
to πs
C6. |Pr [πs
then we say A (τ, )-breaks conﬁdentiality/integrity of Π.
2.3.2
First we state a straightforward extension of the ACCE
model to protocols with multiple phases, but with essentially
no security condition relating one phase to another. This
deﬁnition captures the properties of TLS without any renego-
tiation countermeasures, and will be used as a stepping stone
in our generic result in Section 4. For this simplest notion of
authentication, an adversary should not be able to cause a
phase to accept unless there exists a phase at the peer with
a matching pre-accept handshake transcript, provided she
has not impersonated the parties (i.e., corrupted long-term
secret keys before the phase accepted).

Secure multi-phase ACCE.

Definition 3

(Secure multi-phase ACCE).

Suppose an algorithm A with running time τ interacts with
a multi-phase ACCE protocol Π in the above execution envi-
ronment and terminates. If, with probability at least , there
exists an oracle πs
A.d = πt
B and a phase (cid:96) such that
A1. πs
A.phases[(cid:96)].α = accept; and
A2. A did not query Corrupt(PA, πs
A3. A did not query Corrupt(PB, πs

A.phases[(cid:96)].pk) before πs
A
A.phases[(cid:96)].pk(cid:48)) before

accepted in phase (cid:96); and

A with πs

πs

A accepted in phase (cid:96); and
A.phases[(cid:96)].ω = 0 then πs
A4. if πs
A5. A did not query Reveal(πt
phase (cid:96) for any (cid:96)(cid:48) such that πt
ing conversation to πs

B, (cid:96)(cid:48)) before πs

A.ρ = Client; and
A accepted in
B.phases[(cid:96)(cid:48)].T is a match-
B.phases[(cid:96)(cid:48)].T is a matching

A.phases[(cid:96)].T ; and

conversation to πs

M. there is no (cid:96)(cid:48) such that πt
then we say that A (τ, )-breaks authentication of Π.
A protocol Π is a (τ, )-secure multi-phase ACCE protocol
if there exists no algorithm A that (τ, )-breaks conﬁdential-
ity/integrity (Def. 2) or authentication (as above) of Π.

A.phases[(cid:96)].T

In A1 and M we redeﬁne the NoMatch-condition from
[1]. In A2 we exclude leaking of the secret long-term keys
of the accepting party (necessary for example to counter

392key compromise impersonation attacks). In A3 we exclude
corruptions of the peer. In A4 (only for server-only authen-
tication), we ensure that the adversary only wins by making
a client-oracle maliciously accept. In A5 we exclude trivial
attacks that exist for protocols with explicit key conﬁrmation
and probabilistic computations under the negotiated key.

The secure multi-phase ACCE deﬁnition when limited to a
phase per session and a single key pair per party (nph = nke =
1) collapses to an extension of the original ACCE deﬁnition,
the extension being support for server-only authentication.
2.3.3 Secure renegotiable ACCE.
We next strengthen the authentication notion to include
renegotiation. Intuitively, an adversary should not be able
to cause a phase to accept unless there exists a phase at the
peer with a matching pre-accept handshake transcript and
all previous phases’ handshake and record layer transcripts
match, provided she has not impersonated the parties in the
current phase. We will show in Section 5 that TLS with our
proposed countermeasure satisﬁes this deﬁnition.

Definition 4

(Secure renegotiable ACCE).

A.d = πt

A with πs

Suppose an algorithm A with running time τ interacts with
a multi-phase ACCE protocol Π in the above execution envi-
ronment and terminates. If, with probability at least , there
B and a phase (cid:96)∗ such that
exists an oracle πs
A1–A5 as in Deﬁnition 3 with (cid:96)∗, and either
B.phases[(cid:96)∗].T is not a matching conversation to
M(cid:48)(a) πt
A.phases[(cid:96)∗].T or
πs
A.phases[(cid:96)].T(cid:107)RTs(cid:107)RTr (cid:54)= πt
M(cid:48)(b) for some (cid:96) < (cid:96)∗, πs
B.
phases[(cid:96)].T(cid:107)RTr(cid:107)RTs;
we say A (τ, )-breaks renegotiation authentication of Π.
A protocol Π is a (τ, )-secure renegotiable ACCE protocol
if there exists no algorithm A that (τ, )-breaks conﬁden-
tiality/integrity (Def. 2) or renegotiation authentication (as
deﬁned above) of Π.
2.3.4 Weakly secure renegotiable ACCE.
Unfortunately, TLS with SCSV/RIE does not meet Def. 4
because, as we will see in Section 4.1, revealing session keys
in earlier phases allows the adversary to change the messages
on the record layer in earlier phases, but SCSV/RIE will not
detect this.

Of course, revealing earlier phases’ session keys while that
phase is active and still expecting detection when renego-
tiating later is a strong security property, and the lack of
this property does not imply an attack in most scenarios.
Our desire to characterize the renegotiable security of the
SCSV/RIE countermeasure motivates a slightly weaker rene-
gotiation notion: when previous phases’ session keys are not
revealed while that phase is active and the current phase’s
long-term secret keys are not corrupted, no adversary should
be able to cause a phase to accept unless there exists a
phase at the peer with a matching pre-accept handshake
transcript and all previous phases’ handshake and record
layer transcripts match.

Definition 5

(Weakly secure renegotiable ACCE).

Suppose an algorithm A with running time τ interacts with
a multi-phase ACCE protocol Π in the above execution envi-
ronment and terminates. If, with probability at least , there
B and a phase (cid:96)∗ such that
exists an oracle πs
all conditions from Def. 4, as well as the following additional
conditions are satisﬁed:

A with πs

A.d = πt

A accepted

A, (cid:96)) query before πs

B, (cid:96)) query before πs

in phase (cid:96) + 1, for every (cid:96) < (cid:96)∗, and
in phase (cid:96) + 1, for every (cid:96) < (cid:96)∗;

A6. A did not issue a Reveal(πs
A7. A did not issue a Reveal(πt
A accepted
then we say that A (τ, )-breaks weak renegotiation authenti-
cation of Π.
A protocol Π is a (τ, )-weakly secure renegotiable ACCE
protocol if there exists no algorithm A that (τ, ) breaks
conﬁdentiality/integrity (Def. 2) or weak renegotiation au-
thentication (as deﬁned above) of Π.

Remark 3. While conditions A6 and A7 prohibit the
adversary from revealing encryption keys of previous phases
while active for the purposes of breaking authentication, the
conﬁdentiality/integrity aspect of Def. 5 still places no such
restriction on previous encryption keys being revealed.

Remark 4. The chain of implications between Defns. 3–5
is as follows: secure renegotiable ACCE protocol (Defn. 4)
=⇒ weakly secure renegotiable ACCE (Defn. 5) =⇒ secure
multi-phase ACCE (Defn. 3) =⇒ ACCE protocol [16]. The
separations are strict, as seen in Table 1.
3. TLS RENEGOTIATION (IN)SECURITY
We now discuss how the original TLS protocol, without
SCSV/RIE countermeasures, ﬁts into our model, and show
how the attack of Ray and Dispensa is captured in the model.
Jager et al. [16] in their full version described how to map
TLS into the ACCE model. We highlight a few components
of that mapping, and the alterations needed for renegotiation.
Oracles generally respond to Send, Encrypt, and Decrypt
queries as speciﬁed by the TLS handshake and record layer
protocols. The Send control message m = (newphase, pk)
when sent to a client causes the client to send a new Client-
Hello message, and when sent to a server causes the server
to send a new HelloRequest message. For the Encrypt and
Decrypt queries, we use a content type ﬁeld ctype that corre-
sponds to the ContentType ﬁeld of the TLSPlaintext data
type in the TLS record layer speciﬁcation [9, §6.2.1]:

Packets with ContentType=change_cipher_spec (20) or
handshake (22) are considered in our model to have ctype =
control and packets with ContentType=application_data
(23) are considered in our model to have ctype = data. We
do not explicitly handle ContentType=alert (21) messages.
The Reveal query reveals the encryption and MAC keys
derived from the master secret key, not the master secret
key itself.
3.1 TLS without countermeasures is not a

(weakly) secure renegotiable ACCE

Recall the TLS renegotiation attack by Ray and Dispensa
[24], as described previously in Figure 1 on page . The
attacker Eve observes Alice attempting to establish a TLS
session with Bob. Eve delays Alice’s initial ClientHello and
instead establishes her own TLS session with Bob and trans-
mits a message m0 over that record layer. Then Eve passes
Alice’s initial ClientHello to Bob over the Eve–Bob record
layer. Bob views this as a valid renegotiation and responds
accordingly; Eve relays the handshake messages between
Alice and Bob, who will eventually establish a new record
layer to which Eve has no access. Alice then transmits a
message m1 over the Alice–Bob record layer. Intuitively, this
is a valid attack: Alice believes this is the initial handshake,
but Bob believes this is a renegotiated handshake.

393Formally, this attack is captured in our weakly secure
renegotiable ACCE model of Deﬁnition 5 as follows. Assume
Alice and Bob each have a single oracle instance, and Eve
has carried out the above attack. Then for Bob’s oracle π1
Bob,
the value of (cid:96)∗ is 2: the last entry in phases where Bob has a
matching handshake transcript to some handshake transcript
in Alice’s oracle π1
Alice is the second (and last) phases entry.
The attacker has broken renegotiation authentication at both
Alice and Bob’s instances. At Alice by satisfying condition
M(cid:48)(a) (Alice’s ﬁrst handshake transcript does not match
Bob’s ﬁrst handshake transcript), and at Bob by satisfying
both M(cid:48)(a) (Bob’s second handshake transcript does not
match Alice’s second handshake transcript) and M(cid:48)(b) (for
every (cid:96) < 2, Bob’s (cid:96)th handshakes/record layer transcripts
do not match Alice’s). Thus TLS without countermeasures
is not a weakly secure or secure renegotiable ACCE.

4. RENEGOTIATION SECURITY OF TLS
WITH SCSV/RIE COUNTERMEASURE
In this section we analyze the security of TLS with the
SCSV/RIE countermeasures proposed in RFC 5746 [26]. We
ﬁrst see, in Section 4.1, that the SCSV/RIE countermeasures
are not enough to prove that TLS satisﬁes our strongest
notion, a secure renegotiable ACCE (Defn. 4).

Our goal will be to show that TLS with the SCSV/RIE
countermeasures is a weakly secure renegotiable ACCE. Ide-
ally, we would do so generically, with a result saying some-
thing like “If a TLS ciphersuite is a secure ACCE, then
that TLS ciphersuite with SCSV/RIE is a weakly secure
renegotiable ACCE.” As noted in the introduction, we do
so generically since the protocol is modiﬁed to include the
countermeasure values in the ClientHello and ServerHello
messages, and thus we cannot make use of the ACCE secu-
rity of the particular TLS ciphersuite in a black-box way.
Moreover, we must ensure that revealing the Finished values
from the previous handshake does not impact its security.
Although these barriers prevent a generic black-box result, a
white-box examination of the proof details of TLS_DHE_DSS_
[16] ﬁnds that only small changes are needed in the proof.

We will provide a sequence of deﬁnitions and results that

justiﬁes the security of the SCSV/RIE countermeasure.

1. Deﬁne a modiﬁed ACCE security model, called tagged-
ACCE-ﬁn, speciﬁc to TLS, in which the adversary can
reveal Finished messages after the handshake com-
pletes and supply tags to be used in extensions.

2. Deﬁne tagged TLS as a modiﬁcation of a standard ci-
phersuite in which arbitrary opaque data can be placed
in an extension ﬁeld in the ClientHello and Server-
Hello messages.

3. Explain how the existing proof of that TLS_DHE_DSS_
is ACCE secure can be modiﬁed in a very minor way
to show that tagged TLS_DHE_DSS_ is tagged-ACCE-
ﬁn-secure.

4. Show that, if a TLS ciphersuite is tagged-ACCE-ﬁn
secure, then that TLS ciphersuite with SCSV/RIE is a
secure multi-phase ACCE.

5. Show that, if a TLS ciphersuite with SCSV/RIE is
a secure multi-phase ACCE, then it is also a weakly
secure renegotiable ACCE.

Combined, these results yield (a) a general result justifying
the security of the SCSV/RIE countermeasure, and (b) that

TLS_DHE_DSS_ with SCSV/RIE countermeasures is a weakly
secure renegotiable ACCE.
4.1 TLS with SCSV/RIE is not a secure rene-

gotiable ACCE

Deﬁnition 4 requires that, even when the adversary can
reveal previous phases’ session keys, the parties will not
successfully renegotiate if the attacker has manipulated the
record layer. The SCSV/RIE countermeasures do not protect
against this type of adversary. They only provide assurance
that handshake transcripts from previous phases match ex-
actly. TLS itself of course provides integrity protection for
record layer transcripts via the message authentication codes,
but Deﬁnition 4 allows the adversary to reveal the encryption
and MAC keys of previous phases. Thus, an adversary who
reveals the current encryption and MAC keys can modify
record layer messages but Alice and Bob will still successfully
renegotiate a new phase (although the adversary must not
alter the number of messages sent, as the number of record
layer messages sent in the previous phase happens to be
protected by SCSV and RIE countermeasures).

We emphasize that while this demonstrates a theoretical
weakness in TLS renegotiation countermeasures compared
to our very strong security model, it does not translate into
an attack on TLS renegotiation countermeasures when inter-
mediate phases’ encryption and MAC keys are not revealed.
SCSV/RIE meets its original goal of authenticating the pre-
vious handshake.
4.2 Tagged-ACCE model and tagged TLS

In this section we introduce a variant of the ACCE model
from which we can prove a generic result on the renegotiable
security of TLS with countermeasures. In our models, the
tag can be an arbitrary string. For our purpose of analyzing
TLS with SCSV/RIE countermeasures, the tag will be the
previous phase’s Finished messages.
4.2.1 Tagged-ACCE security model
The tagged-ACCE security model is an extension of the
ACCE security model to allow arbitrary tags as follows. Since
the original ACCE deﬁnition of Jager et al. [16] does not sup-
port server-only authentication, while our deﬁnition allows
both authentication modes, we extend the ACCE deﬁnition
implied by limiting multi-phase ACCE (Deﬁnition 3) to a
single phase (nph = 1) and at most one public key per party
(nke = 1).

per-phase variable tag.

The phases log phases is extended with an additional
• Send(πs

A, m). The adversary can specify an arbitrary

tag during session initialization.

– If m = (newphase, ω, tag), the party sets its inter-
nal variable ρ ← Client, sets authentication mode
ω, stores tag, and responds with the ﬁrst protocol
message.
– If m = (ready, ω, tag), the party sets ρ ← Server,
authentication mode ω, stores tag, and responds
with the next protocol message, if any.

The freshness and winning conditions of tagged-ACCE are
unchanged from ACCE.
4.2.2 Tagged-ACCE-ﬁn security model
We will work with a further variant, tagged-ACCE-ﬁn,
which is not a fully general security model but instead is

394tied speciﬁcally to generic TLS protocols of the form given
in Figure 2. It adds the following query:

• RevealFin(πs

A): If α = accept, then return the f inC
and f inS values sent/received by the queried oracle.
Return ∅ otherwise.

The following queries are modiﬁed:

• Encrypt(πs
• Decrypt(πs

A, ctype, m0, m1, len, hd): The adversary is

not prevented from querying with ctype = control.

A, C, hd): No semantic meaning is associated
with ctype = control messages. In other words, line 5
of Decrypt is removed.

We extend the Encrypt- and Decrypt-queries to allow the
adversary to send and receive messages on the encrypted
channel with content type control. The freshness and win-
ning conditions of tagged-ACCE-ﬁn are as in ACCE.

Remark 5. Revealing the Finished messages is very spe-
ciﬁc to the TLS protocol family and is not necessarily relevant
for other protocols. Imagine, for example, a variant of the
SCSV/RIE countermeasure where a separate hash of the com-
plete transcript as it was sent over the channel is used as
an authenticator. Since this value can be computed by any
passive adversary, leaking this value could not aﬀect security.

4.2.3 Tagged TLS
Figure 2 shows a generic TLS ciphersuite, along with
the SCSV/RIE extensions denoted in green with a dagger.
By tagged TLS, we mean the generic TLS ciphersuite from
Figure 2, without any of the SCSV/RIE extensions shown
in green, but where an arbitrary string can be placed in the
extC and extS ﬁelds. In other words, it is a normal TLS
ciphersuite, but with an arbitrary extension ﬁeld that just
carries strings that are not being interpreted as having any
particular meaning.

As noted in the beginning of this section, we cannot gener-
ically prove that, if a TLS ciphersuite is ACCE-secure, then
the tagged version of that ciphersuite is tagged-ACCE- or
tagged-ACCE-ﬁn-secure, as we have made white-box modiﬁ-
cations to the TLS protocol in introducing the SCSV/RIE
countermeasure. Thus we cannot use its security results in
a black-box manner. However, in most cases, a white-box
approach, where the actual security proof is modiﬁed or ex-
tended, should be possible, and even very easy. This was
indeed the case when we examined tagged TLS_DHE_DSS_.

Theorem 1

(Informal). Under the same assumptions
on the cryptographic building blocks as in Jager et al. [16],
TLS_DHE_DSS_ is a secure tagged-ACCE-ﬁn protocol.

The formal theorem statement and proof are omitted due to
the space limitation and appear in the full version [14]. The
proof follows almost exactly the proof by Jager et al. [16]
that TLS_DHE_DSS_ is a secure ACCE protocol. Leaking the
Finished messages does not aﬀect security due to a game
hop where, due pseudorandomness of the PRF, the Finished
messages are replaced with uniformly random values inde-
pendent of any information exchanged during the handshake.
Including arbitrary extra data in the handshake messages
does not impact security.
4.3 TLS with SCSV/RIE is multi-phase-secure
We begin by showing that including the SCSV/RIE coun-
termeasure does not weaken security: putting the Finished

messages in the ClientHello and ServerHello does not in-
troduce any vulnerabilities. Having done so, in the next
subsection we will show how including the SCSV/RIE coun-
termeasure yields a weakly secure renegotiable ACCE.

Theorem 2. Let Π be a generic tagged TLS ciphersuite
as described in Section 4.2. Assume that Π is (τ, tagged)-
tagged-ACCE-ﬁn-secure. Let Π(cid:48) denote Π with SCSV/RIE
countermeasures as described in Figure 2. For any adversary
that (τ(cid:48), mp)-breaks the multi-phase ACCE security of Π(cid:48)
with τ ≈ τ(cid:48), it holds that mp ≤ 2(cid:48), where (cid:48) is obtained from
 by replacing all instances of npa in  with npa · nke and
replacing all instances of nse in  with nse · nph. (Recall that
npa, nse, nph, and nke are the maximum number of parties,
sessions per party, phases per session, and keypairs per party,
respectively.)

Due to the page limitation we only give the proof strategy
here and refer to the anonymous full version [14] for the
details.

Proof idea: We will construct a multi-phase ACCE simula-
tor S for Π(cid:48) that makes use of a tagged-ACCE-ﬁn challenger
C for Π. S will simulate every (party, public-key) pair and
every (session, phase) pair with distinct parties and sessions
in C. For the most part, S will relay queries down to C and
return the result. However, for queries that relate to renego-
tiation (Send, Decrypt), S carefully manages the handshake
messages to transition one session in C to another.

Remark 6. A simulation similar to the one in the proof
allows us to prove that TLS with SCSV/RIE countermeasures
is a multi-phase ACCE protocol, even when diﬀerent cipher-
suites are used in diﬀerent phases. The simulator interacts
with a diﬀerent tagged-ACCE-ﬁn challenger for each cipher-
suite; when a renegotiation inside one ciphersuite will result
in a new ciphersuite, the simulator uses the Encrypt/Decrypt
queries in the old ciphersuite to encrypt the Send messages
from the handshake of the new ciphersuite. Unfortunately,
for this multi-ciphersuite simulation to work, it is essen-
tial that public keys not be shared across ciphersuites: this
technique could show that switching between an RSA-based ci-
phersuite and an ECDSA-based ciphersuite is safe. However,
to analyze using the same RSA public key in two diﬀerent
ciphersuites, one would have to take an alternative approach,
as it may not be possible to generically prove that re-using
the same public key in two ACCE protocols is safe.
4.4 TLS with SCSV/RIE is a weakly secure

renegotiable ACCE

We are now in a position to show that the use of the
SCSV/RIE countermeasure in TLS results in a weakly secure
renegotiable ACCE. We will do so generically, starting from
the consequence of the previous theorem: that TLS with
SCSV/RIE is a secure multi-phase ACCE.

Theorem 3. Let Π be a TLS ciphersuite with SCSV/RIE
countermeasures, as described in Figure 2. If Π is a (τ, mp)-
secure multi-phase ACCE protocol, and PRF is a (τ, prf )-
secure pseudorandom function, then Π is a (τ, )-weakly se-
cure renegotiable ACCE, with  = mp + prf .

The full proof of the theorem appears in Appendix A.
Intuitively, the use of the RIE countermeasure guarantees
that each party who renegotiates has the same view of (a)

395whether they are renegotiating, and (b) which handshake is
the “previous” handshake. We can chain these together to
obtain the property of a secure renegotiable ACCE: parties
who renegotiate have the same view of all previous hand-
shakes. If this is violated, either the non-renegotiable aspects
of TLS have been broken, or a collision has been found in
the computation of the renegotiation indication extension.
We can combine Theorems 2 and 3 to obtain the central
results of the paper, justifying the security of the SCSV/RIE
countermeasure:

Corollary 1. If a tagged TLS ciphersuite Π as described
in Section 4.2 is a secure tagged-ACCE-ﬁn protocol and PRF
is a secure pseudorandom function, then that TLS ciphersuite
Π with SCSV/RIE countermeasures as described in Figure 2
is a weakly secure renegotiable ACCE.

Corollary 2. Under the same assumptions as in Theo-
rem 1, TLS_DHE_DSS_ with SCSV/RIE countermeasures is a
weakly secure renegotiable ACCE protocol.

5. RENEGOTIATION SECURITY OF TLS

WITH A NEW COUNTERMEASURE

We now present a new TLS renegotiation countermeasure
that provides integrity protection for the record layer tran-
script upon renegotiation (even when previous phases’ session
keys are leaked while the phase is still active), thereby achiev-
ing the full security of Deﬁnition 4. This countermeasure is
quite straightforward: by including a hash of all record layer
messages in the renegotiation information extension, parties
can conﬁrm that they share the same view of their previous
record layers.

S

C

The renegotiation information extension already contains
a ﬁngerprint of the previous phrase’s handshake transcript
via the client_verify_data (f in(−1)
C ) and server_verify_
data (f in(−1)
) values. We modify the renegotiation informa-
tion extension to include an additional value, the ﬁngerprint
of the encrypted messages sent over the previous phase’s
record layer. In particular, if negotiating:
extC ← f in(−1)
))
(1)
where ms(−1) is the previous phase’s master secret, H is
a collision-resistant hash function, and RT (−1)
is
the client’s view of the previous phase’s record layer tran-
script; the server uses RT (−1)
instead. Appropriate
checks are performed by the server. With this additional
information, the two parties will now not complete renego-
tiation unless they have matching views of the record layer
transcripts from the previous phase.

(cid:107) PRF(ms(−1), label5(cid:107)H(RT (−1)

(cid:107)RT (−1)

(cid:107)RT (−1)

s

(cid:107)RT (−1)

r

s

s

r

r

In practice, it is not diﬃcult to, on an incremental basis,
compute hashes of the ciphertexts sent and received over
the record layer in that phase. In particular, it is not neces-
sary to store all record layer messages to input to the hash
function all at once, as common programming APIs for hash
functions allow the hash value to be provided incrementally.
However, the cost of the MAC computation can dominate
the cryptographic cost of record layer computations [15]. The
new countermeasure is only suitable for TLS communications
over a reliable channel and could not be used with DTLS
communications over an unreliable channel.

Alternatively, if the sLHAE scheme for the record layer is
implemented as encrypt-then-MAC or MAC-then-encrypt,

it should be possible to use MAC contained in the last en-
crypted message of the sLHAE scheme instead of the hash
value computed above; this would result in no additional
performance impact and would be easier to implement.

Theorem 4. Let Π be a TLS ciphersuite with the original
RIE countermeasures as in Figure 2 but using extC as in
equation (1). If Π is a (τ, mp)-secure multi-phase ACCE
protocol, H is a (τ, h)-collision-resistant hash function, and
PRF is a (τ, prf )-secure pseudorandom function, then Π is a
(τ, )-secure renegotiable ACCE, where  = mp + h + prf .

The proof proceeds similarly to that of Theorem 3. The
main diﬀerence is that, in one case, the removal of restrictions
A6 and A7 means we can no longer reduce down to a viola-
tion of conﬁdentiality/integrity in the multi-phase security
of Π, and instead have to rely on the new countermeasure to
detect non-matching record layer transcripts and reduce to
the security of the PRF and hash function.

We refer to the full version [14] for the full proof.

6. CONCLUSION

Although two-party protocols for establishing secure com-
munication have been extensively studied in the literature
and are widely used in practice, this is the ﬁrst work to
consider the important practical issue of renegotiation, in
which parties update one or more aspects of their connection
— authentication credentials, cryptographic parameters, or
simply refresh their session key. The importance of correctly
implementing renegotiation was highlighted by the 2009 at-
tack of Ray and Dispensa on how certain applications process
data from renegotiable TLS connections.

We have developed a formal model for describing the secu-
rity of renegotiable cryptographic protocols, focussing on au-
thenticated and conﬁdential channel establishment (ACCE)
protocols. We have speciﬁcally analyzed renegotiation in
the TLS protocol, identifying the original attack of Ray and
Dispensa in our model. We have provide a generic proof
that the SCSV/RIE countermeasure oﬀers good protection
against renegotiation attacks, and give a new countermea-
sure that provides renegotiation security even in the face
of slightly stronger adversaries. In practice, the SCSV/RIE
countermeasure may be good enough.

Renegotiation, reauthentication, and rekeying are impor-
tant features of many other applied cryptographic protocols.
Future applied work includes examining the security of rekey-
ing in protocols such as SSH or IKEv2 in our model. Open
theoretical questions include how to adapt our approach for
deﬁning secure renegotiation to other primitives, in particular
authenticated key exchange protocols. The overall security of
TLS still has many important open questions, including the
security of other TLS ciphersuites and the formal analysis of
other complex functionality such as alerts and error messages.
TLS session resumption [9, §F.1.4] is another important func-
tionality of TLS, and it appears that our multi-phase ACCE
model may be the right model in which to analyze its security,
another interesting open problem. Given that attacks con-
tinue to be found outside the core key agreement component
of TLS, further research into modelling the security of TLS
in increasingly realistic scenarios is well-motivated.
Acknowledgements
The authors gratefully acknowledge discussions with Colin
Boyd, Cas Cremers, Kenny Paterson, J¨org Schwenk, and

396the authors of the SCSV/RIE countermeasure [26], and the
advice of anonymous reviewers. The research was supported
by an Australian Technology Network–German Academic
Exchange Service (ATN-DAAD) joint research cooperation
scheme grant. D.S. was supported by an Australian Research
Council (ARC) Discovery Project.

7. REFERENCES

[1] M. Bellare and P. Rogaway. Entity authentication and

key distribution. In Proc. CRYPTO’93, vol. 773 of
LNCS, pp. 232–249.

[2] K. Bhargavan, C. Fournet, M. Kohlweiss, A. Pironti,

and P.-Y. Strub. Implementing tls with veriﬁed
cryptographic security. In IEEE Symposium on Security
& Privacy, 2013. http://mitls.rocq.inria.fr/.

[3] S. Blake-Wilson, M. Nystroem, D. Hopwood,

J. Mikkelsen, and T. Wright. Transport Layer Security
(TLS) extensions, June 2003. RFC 3546.

[4] D. Bleichenbacher. Chosen ciphertext attacks against

protocols based on the RSA encryption standard PKCS
#1. In Proc. CRYPTO’98, vol. 1462 of LNCS, pp. 1–12.

[5] C. Brzuska, M. Fischlin, N. P. Smart, B. Warinschi,

and S. C. Williams. Less is more: Relaxed yet
composable security notions for key exchange. Int. J.
Information Security, 12(4):267–297.

[6] R. Canetti and H. Krawczyk. Security analysis of IKE’s

signature-based key-exchange protocol. In Proc.
CRYPTO 2002, vol. 2442 of LNCS, pp. 143–161.

[7] T. Dierks and C. Allen. The TLS protocol version 1.0,

January 1999. RFC 2246.

[8] T. Dierks and E. Rescorla. The Transport Layer

Security (TLS) protocol version 1.1, April 2006. RFC
4346.

[9] T. Dierks and E. Rescorla. The Transport Layer

Security (TLS) protocol version 1.2, August 2008. RFC
5246.

[10] S. Farrell. Why didn’t we spot that? IEEE Internet

Computing, 14(1):84–87, Jan.–Feb. 2010.

[11] A. O. Freier, P. Karlton, and P. C. Kocher. The Secure
Sockets Layer (SSL) protocol version 3.0, August 2011.
RFC 6101; republication of original SSL 3.0
speciﬁcation by Netscape of November 18, 1996.

[12] S. Gajek, M. Manulis, O. Pereira, A.-R. Sadeghi, and

J. Schwenk. Universally composable security analysis of
TLS. In Proc. ProvSec 2008, vol. 5324 of LNCS, pp.
313–327.

[13] R. Gelashvili. Attacks on re-keying and renegotiation in

key exchange protocols, April 2012. Bachelor’s thesis,
ETH Zurich.

[14] F. Giesen, F. Kohlar, and D. Stebila. On the security of

TLS renegotiation (full version), 2013.
http://eprint.iacr.org/2012/630.

[15] V. Gupta, D. Stebila, S. Fung, S. C. Shantz, N. Gura,

and H. Eberle. Speeding up secure web transactions
using elliptic curve cryptography. In Proc. NDSS 2004.
The Internet Society, Feb. 2004.

[16] T. Jager, F. Kohlar, S. Sch¨age, and J. Schwenk. On the
security of TLS-DHE in the standard model. In Proc.
CRYPTO 2012, vol. 7417 of LNCS, pp. 273–293. Full
version: http://eprint.iacr.org/2011/219.

[17] J. Jonsson and B. S. Kaliski Jr. On the security of RSA
encryption in TLS. In Proc. CRYPTO 2002, vol. 2442
of LNCS, pp. 127–142.

[18] F. Kohlar, S. Sch¨age, and J. Schwenk. On the security
of TLS-DH and TLS-RSA in the standard model, 2013.
http://eprint.iacr.org/2013/367.

[19] H. Krawczyk. The order of encryption and

authentication for protecting communications (or: How
secure is SSL?). In Proc. CRYPTO 2001, vol. 2139 of
LNCS, pp. 310–331.

[20] H. Krawczyk, K. G. Paterson, and H. Wee. On the

security of the TLS protocol: A systematic analysis. In
Proc. CRYPTO 2013, vol. 8042 of LNCS, pp. 429–448.
[21] D. Miller. SSL vulnerability and SSH, November 2009.

http://lists.mindrot.org/pipermail/
openssh-unix-dev/2009-November/028003.html.

[22] P. Morrissey, N. P. Smart, and B. Warinschi. A
modular security analysis of the TLS handshake
protocol. In Proc. ASIACRYPT 2008, vol. 5350 of
LNCS, pp. 55–73.

[23] K. G. Paterson, T. Ristenpart, and T. Shrimpton. Tag

size does matter: Attacks and proofs for the TLS
record protocol. In Proc. ASIACRYPT 2011, vol. 7073
of LNCS, pp. 372–389.

[24] M. Ray and S. Dispensa. Renegotiating TLS,

November 2009.

[25] E. Rescorla. HTTP over TLS, May 2000. RFC 2818.
[26] E. Rescorla, M. Ray, S. Dispensa, and N. Oskov.

Transport Layer Security (TLS) renegotiation
indication extension, February 2010. RFC 5746.

[27] Trustworthy Internet Movement. SSL Pulse, July 2013.
https://www.trustworthyinternet.org/ssl-pulse/.

[28] T. Zoller. TLS & SSLv3 renegotiation vulnerability.

Technical report, G-SEC, 2009.
http://www.g-sec.lu/practicaltls.pdf.

APPENDIX
A. PROOF OF THEOREM 3

Proof. Suppose A breaks the weak renegotiable ACCE
security of the protocol Π. We will show that either A breaks
the multi-phase ACCE security of Π or A can be used to
construct another algorithm that breaks either the security
of the PRF or the multi-phase ACCE security of Π.
We approach the proof in three cases: either A has broken
the conﬁdentiality/integrity of the weakly secure renegotiable
ACCE, or A has broken the weak renegotiation authentica-
tion of the weakly secure renegotiable ACCE, the latter by
meeting either condition M(cid:48)(a) or M(cid:48)(b).

Conﬁdentiality/integrity. Since the winning conditions for
the conﬁdentiality/integrity part of the security game are
the same for both deﬁnitions, every adversary who breaks
conﬁdentiality/integrity in the weakly secure renegotiable
ACCE security game for Π breaks conﬁdentiality/integrity
in the multi-phase ACCE security game for Π.

Authentication — M(cid:48)(a). Suppose A wins the weak rene-
gotiable ACCE security experiment for Π using condition
M(cid:48)(a). Either there is no (cid:96) at all such that πt
B.phases[(cid:96)].T
A.phases[(cid:96)∗].T , or there is such an (cid:96) but (cid:96) (cid:54)= (cid:96)∗.
matches πs

397First consider the case where there is no (cid:96) at all such
A.phases[(cid:96)∗].T . That meets

B.phases[(cid:96)].T matches πs

that πt
condition M of Deﬁnition 3 for Π.

C

B.phases[(cid:96) − j].T .

Now consider the case where there is an (cid:96) such that πt
B.
A.phases[(cid:96)∗].T but (cid:96) (cid:54)= (cid:96)∗. Assume
phases[(cid:96)].T matches πs
without loss of generality (cid:96) < (cid:96)∗ (otherwise we could swap
the oracles).
There must exist some value j ∈ [1, (cid:96) − 1] such that
A.phases[(cid:96)∗ − j].T (cid:54)= πt
πs
In particular,
j ≤ (cid:96) − 1, since in πt
B’s ﬁrst phase its outgoing message m1
contains extC = empty but πs
A received a message m1 with
extc (cid:54)= empty. Let j be minimal. Then πt
B.phases[(cid:96)−j +1].T
A.phases[(cid:96)∗ − j + 1].T . In particular, messages
matches πs
m1 of those two transcripts are equal, and so are messages
m2 of those two transcripts. Since RIE is being used, m1
, and since πs,(cid:96)∗−j+1
and m2 contain f in(−1)
accepted, both πs,(cid:96)∗−j+1
used the same f in(−1)
and f in(−1)
and f in(−1)
are the hash (using a PRF) of the handshake transcripts from
phases πs,(cid:96)∗−j
, and we know that these handshake
transcripts are not equal. This means a collision has occurred
in PRF, which happens with negligible probability.
ACCE, no A can achieve conditions M(cid:48)(a) and A1–A7.

values. But at each party, f in(−1)

Assuming PRF is secure and Π is a secure multi-phase

and f in(−1)
and πt,(cid:96)−j+1

and πt,(cid:96)−j

Authentication — M(cid:48)(b). Now suppose A wins the weak
renegotiable ACCE security experiment for Π using condition
M(cid:48)(b) but not M(cid:48)(a).
In particular, for every (cid:96)(cid:48) < (cid:96)∗,
B.phases[(cid:96)(cid:48)].T but there is some (cid:96) < (cid:96)∗
A.phases[(cid:96)(cid:48)].T = πt
πs
B.phases[(cid:96)].RTr(cid:107)RTs.
such that πs
Choose (cid:96) minimal. Let v be the smallest index such that the
A.phases[(cid:96)].RTs(cid:107)RTr is not equal to
vth ciphertext Cv of πs
B.phases[(cid:96)].RTr(cid:107)RTs.
the vth ciphertext of πt

A.phases[(cid:96)].RTs(cid:107)RTr (cid:54)= πt

B

B

A

A

A

C

C

S

S

S

Assume without loss of generality that Cv was received by
πs
A as the vth ciphertext but was not sent by πt
B as the vth
ciphertext. (The alternative is that Cv was sent by πs
A as
the vth ciphertext but was not received by πt
B as the vth
ciphertext. However, we could then focus on everything from
πt
B’s perspective and apply the same argument.)
This means that when A called Decrypt(πs
A, Cv, hd), if
b = 0 then Decrypt returned (⊥,·), whereas if b = 1 then
Decrypt returned (m(cid:48),·) where m(cid:48) (cid:54)=⊥. Our simulator can
thus output (A, s, (cid:96), b(cid:48)) for its guess of b(cid:48) as above, and this
will equal b with probability at least , making condition
C6 hold in Deﬁnition 3. We need to show that conditions
C1–C5 also hold for (A, s, (cid:96)).
Since A wins the weak renegotiable ACCE experiment
using condition M(cid:48)(b), we have that A1–A7 all hold. We
want to show that, at the time that πs
A accepted in phase
(cid:96) + 1, conditions C1–C5 also hold for (A, s, (cid:96)).
• C1: A1 implies C1, since if πs
A has rejected in any
phase prior to (cid:96)∗ then it would not have a phase (cid:96)∗.
• C2 and C3: Conditions A2 and A3 of Deﬁnition 5
do not imply that A did not ask Corrupt queries pro-
hibited by C2 and C3. However, we do have that
B.phases[(cid:96)].T ; in other words, A
πs
A.phases[(cid:96)].T = πt
was not active in the handshake for phase (cid:96). Thus, A is
equivalent to an adversary who did not ask any Corrupt
queries for public keys used in phase (cid:96) until after πs
A
accepts in phase (cid:96).

• C4: A6 implies C4, at the time that πs
• C5: Since πs

A chooses nonce rC (if a client) or rS
(if a server) randomly, except with negligible proba-

A accepted.

bility there is no (cid:96)(cid:48) < (cid:96) such that πs
A.phases[(cid:96)].T . By A7, A did not issue Reveal(πt
πs
before πs
that πs
phase with πt
ing condition C5.

A.phases[(cid:96)(cid:48)].T =
B, (cid:96))
A accepted in phase (cid:96) + 1. Thus at the time
B, (cid:96)(cid:48)) to any
A.phases[(cid:96)].T , satisfy-
Thus, assuming Π is a secure multi-phase ACCE no A can

A accepted, A did not issue Reveal(πt

B.phases[(cid:96)(cid:48)].T = πs

achieve conditions M(cid:48)(b) and A1–A7.
B. GENERIC TLS PROTOCOL WITH

SCSV/RIE COUNTERMEASURE

C

(IC = pkC , skC )
r←− {0, 1}λ1

(cid:40)
empty,
f in(−1)
C ,

rC
†extC ←

pre-accept stage

S

(IS = pkS , skS )

if initial,
if reneg

m1 : rC , cs-list, †extC

r←− {0, 1}λ1
rS
(cid:40)
†If extC (cid:54)= f in(−1)
: α ← reject
if initial,
if reneg
keyexS ← . . .

C (cid:107)f in(−1)

empty,
f in(−1)

C

S

,

†extS ←

m2 : rS , sid, cs-choice, †extS

m3 : certS

m4 : keyexS

m5 : get-cert

m6 : done
: α ← reject

S

C (cid:107)f in(−1)

†If extS (cid:54)= f in(−1)
If ¬verify(keyexS ) : α ← reject
keyexC ← . . .
σC ← SIG.Sign(skC , m1(cid:107) . . . (cid:107)m8)
pms ← . . .
ms ← PRF(pms, label1(cid:107)rC(cid:107)rS )
mac (cid:107)KS→C
KC→S
f inC ← PRF(ms, label3(cid:107)H(m1(cid:107) . . . (cid:107)m10))
†store f in(−1)

(cid:107)KC→S

(cid:107)KS→C

C ← f inC

enc

enc

m7 : certC

mac ← PRF(ms, label2(cid:107)rC(cid:107)rS )

m8 : keyexC

m9 : σC

m10 : f lagenc

m11 : (C11, ste) = StE.Enc(KC→S

enc

(cid:107)KC→S

mac

, (cid:96), hd, f inC , ste)

enc

enc

(cid:107)KS→C

(cid:107)KC→S

mac (cid:107)KS→C

If SIG.Vfy(pkC , σC , m1(cid:107) . . . (cid:107)m8) = 0 : α ← reject
pms ← . . .
ms ← PRF(pms, label1(cid:107)rC(cid:107)rS )
mac ← PRF(ms, label2(cid:107)rC(cid:107)rS )
KC→S
If f inC (cid:54)= PRF(ms, label3(cid:107)H(m1(cid:107) . . . (cid:107)m10)) : α ← reject
f inS ← PRF(ms, label3(cid:107)H(m1(cid:107) . . . (cid:107)m12))
S ← f inS
C ← f inC
α ← accept

†store f in(−1)
†store f in(−1)

m12 : f lagenc

m13 : (C13, ste) = StE.Enc(KS→C

enc

(cid:107)KS→C

mac

, (cid:96), hd, f inS , ste)

If f inS (cid:54)= PRF(ms, label3(cid:107)H(m1(cid:107) . . . (cid:107)m12)) : α ← reject
†store f in(−1)
α ← accept

S ← f inS

post-accept stage

StE.Enc(KC→S
StE.Enc(KS→C

enc

enc

mac

(cid:107)KC→S
(cid:107)KS→C

mac

, (cid:96), hd, data, ste)

, (cid:96), hd, data, ste)

Figure 2: Generic TLS handshake protocol with
†SCSV/RIE renegotiation countermeasures

398