LOOP: Logic-Oriented Opaque Predicate Detection in

Obfuscated Binary Code

Jiang Ming, Dongpeng Xu, Li Wang, and Dinghao Wu

College of Information Sciences and Technology

The Pennsylvania State University

{jum310,dux103,lzw158,dwu}@ist.psu.edu

ABSTRACT
Opaque predicates have been widely used to insert super-
ﬂuous branches for control ﬂow obfuscation. Opaque predi-
cates can be seamlessly applied together with other obfusca-
tion methods such as junk code to turn reverse engineering
attempts into arduous work. Previous eﬀorts in detecting
opaque predicates are far from mature. They are either ad
hoc, designed for a speciﬁc problem, or have a considerably
high error rate. This paper introduces LOOP, a Logic Ori-
ented Opaque Predicate detection tool for obfuscated binary
code. Being diﬀerent from previous work, we do not rely on
any heuristics; instead we construct general logical formu-
las, which represent the intrinsic characteristics of opaque
predicates, by symbolic execution along a trace. We then
solve these formulas with a constraint solver. The result ac-
curately answers whether the predicate under examination
is opaque or not. In addition, LOOP is obfuscation resilient
and able to detect previously unknown opaque predicates.
We have developed a prototype of LOOP and evaluated it
with a range of common utilities and obfuscated malicious
programs. Our experimental results demonstrate the eﬃ-
cacy and generality of LOOP. By integrating LOOP with
code normalization for matching metamorphic malware vari-
ants, we show that LOOP is an appealing complement to
existing malware defenses.

1.

INTRODUCTION

In general, a predicate is a conditional expression that
evaluates to true or false. A predicate is opaque when its
result is known to the obfuscator a priori, but at runtime
it still needs to be evaluated and is diﬃcult to deduce by
an adversary afterwards. Opaque predicates have been ap-
plied extensively in various areas of software security, such as
software protection [14, 15], software watermarking [3, 39],
software diversiﬁcation [19, 29], securing mobile agents [35],
metamorphism malware [9, 10], and obfuscation of Android
applications [28].

Real-world obfuscation tools have already supported em-
bedding opaque predicates into program at link time or bi-

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS’15, October 12–16, 2015, Denver, Colorado, USA.
c(cid:13) 2015 ACM. ISBN 978-1-4503-3832-5/15/10 ...$15.00.
DOI: http://dx.doi.org/10.1145/2810103.2813617.

nary level [16, 26, 34]. As a result, control ﬂow graph is
heavily cluttered with infeasible paths and software com-
plexity increases as well [2]. Unlike other control ﬂow graph
obfuscation schemes such as call stack tampering or con-
trol ﬂow ﬂattening [46], opaque predicates are more covert
as it is hard to distinguish opaque predicates from normal
conditions. Furthermore, opaque predicates can be seam-
lessly woven together with other obfuscation methods, such
as opaque constants [37] and metamorphic mutations [44]
to further subvert reverse engineering eﬀorts. Such an ex-
ample can be found in a recent notorious “0 day” exploit
(CVE-2012-4681), in which opaque predicates are used to-
gether with encrypted code [21]. Therefore, it has become
more diﬃcult to locate the exploit code of interest due to
the use of opaque predicates.

Depending on the construction cost and resilience to de-
obfuscation, we classify previous work on opaque predicates
into three categories. The ﬁrst category is invariant opaque
predicates. Such predicates always evaluate to the same
value for all possible inputs. Invariant predicates are mainly
constructed from well-known algebraic theorems [3, 39]. For
example, predicate (x3 − x ≡ 0 (mod 3)) is opaquely true
for all integers x. Since it is easy to construct invariant
opaque predicates they are commonly used. The second
category, contextual opaque predicates, is built on some pro-
gram invariant under a speciﬁc context. That means only
the obfuscator knows such a predicate is true (false) at a
particular point, but could be false (true) if the context is
not satisﬁed. The third category, dynamic opaque predi-
cates, is the most complicated one. In this category, a set
of correlated and adjacent predicates evaluate to the same
value in any given run, but the value might be diﬀerent in
another run. In any case, the program produces the same
output. To make matters worse, dynamic opaque predicates
can be carefully crafted by utilizing the static intractability
property of pointer aliasing [17].

A number of methods have been proposed to identify
opaque predicates [17, 33, 42, 43, 45]. Unfortunately, none
of them is suﬃcient to meet our requirements: generality,
accuracy, and obfuscation-resilience. They are either heuris-
tics based [17], limited to a speciﬁc type of already known
opaque predicates [42], unable to work on highly obfuscated
binary [45] (e.g, binary packing and virtualization obfusca-
tion), or have a rather high error rate [33]. On the ad-
versary’s side, to defeat the pattern matching of commonly
used opaque predicates, Arboit [3] introduces a construction
method based on quadratic residues, which can be extended
to a larger set of new opaque predicates. Furthermore, all ex-
isting detection approaches only focus on invariant opaque

757predicates. There has been little work on systematically
modeling and solving contextual or dynamic opaque predi-
cates.

To bridge the gap stated above, we introduce a novel logic-
based, general approach to detecting opaque predicates pro-
gressively in obfuscated binary code. We ﬁrst perform sym-
bolic execution on an execution trace to build path condi-
tion formulas, on which we detect invariant opaque predi-
cates (the ﬁrst category) by verifying tautologies with a con-
straint solver. In the next step, we identify an implication
relationship to detect possible contextual opaque predicates
(the second category). Finally, with input generation and
semantics-based binary diﬃng techniques, we further iden-
tify correlated predicates to detect dynamic opaque predi-
cates. Our method is based on formal logic that captures
the intrinsic semantics of opaque predicates. Hence, LOOP
can detect previously unknown opaque predicates. A bene-
ﬁt of LOOP’s trace oriented detection is that it is resilient
to most of the known attacks that impede static analysis,
ranging from indirect jump, pointer alias analysis [8], opaque
constants [37], to function obfuscation [36]. Our results can
be fed back to security analysts to further de-obfuscate the
cluttered control ﬂow graph incurred by opaque predicates.
We have implemented LOOP to automate opaque pred-
icates detection on top of the BAP platform [7] and con-
ducted the evaluation with a set of common utilities and ob-
fuscated malicious programs. The experimental results show
that LOOP is eﬀective and general in detecting opaque pred-
icates with zero false negatives. Several optimizations such
as taint propagation and “short cut” strategy oﬀer enhanced
performance gains. To conﬁrm the merit of our approach, we
also test LOOP in the task of code normalization for meta-
morphic malware [9, 10]. This kind of malware often uses
opaque predicates to mutate the code during propagations
to evade signature-based malware detection. The result in-
dicates that LOOP can greatly speed up control ﬂow graph
matching by a factor of up to 2.0.

In summary, we make the following contributions.
• We study the common limitations of existing work in
detecting opaque predicates and propose LOOP, an
eﬀective and general approach that identiﬁes opaque
predicates in the obfuscated binary code. Our ap-
proach captures the intrinsic semantics of opaque pred-
icates with formal logic, so that LOOP can detect pre-
viously unknown opaque predicates.

• Our method is based on strong principles of program
semantics and logic, and can detect known and un-
known, simple invariant, intermediate contextual, and
advanced dynamic opaque predicates.

• LOOP is developed based on symbolic execution and
theorem proving techniques. Our evaluation shows
that our approach automatically diagnoses opaque pred-
icates in an execution trace with zero false negatives.
• To the best of our knowledge, our approach is the ﬁrst
solution towards solving both contextual and dynamic
opaque predicates.

The rest of the paper is organized as follows. Section 2
presents the background information about three categories
of opaque predicates. Section 3 illustrates our core method
with a motivating example. Section 4 describes each step of

Figure 1: Examples of two invariant opaque predi-
cates for all integers x.

Figure 2: Example of a contextual opaque predicate
for all integers satisfying x > 3.

our approach in detail. Section 5 introduces our implemen-
tation. We evaluate our approach in Section 6. Discussions
and future work are presented in Section 7. Related work is
discussed in Section 8. We conclude the paper in Section 9.

2. BACKGROUND

In this section, we introduce the three types of opaque

predicates we try to solve:

Invariant Opaque Predicates.

An opaque predicate is invariant when its value always
evaluates to true or false for all possible inputs, but only
obfuscator knows the value in advance. Figure 1 shows two
cases of invariant opaque predicates: always true and always
false. The dashed line indicates that the path will never be
executed. Due to the simplicity, this kind of opaque predi-
cates have a large set of candidates. Most of them are de-
rived from well-known algebraic theorems [39] or quadratic
residues [3]. However, the invariant property also becomes
the drawback of this category. For example, we can iden-
tify possible invariant opaque predicates by observing the
branches that never change at run time with fuzzing test-
ing [33].

Contextual Opaque Predicates.

To avoid an opaque predicate always produces the same
value for all inputs, Drape [22] proposes a more covert opaque
predicate that is always true (false) under a speciﬁc pre-
condition, but could be false (true) when precondition does
not hold. We call this kind as contextual opaque predicates,
which can be carefully constructed based on program invari-
ants under a particular context. Figure 2 shows an example
of contextual opaque predicate, in which x2 − 4x + 3 > 0

x3 - x = 0 (mod 3)truefalsetruex2 < 0falsetrue(a) always true(b) always falseI1;I2;x > 3truefalse   x2 - 4x + 3 > 0x > 3truefalsetruefalseI1;I2;758Figure 3: Example of a dynamic opaque predicate.

is always true if the precondition x > 3 holds. Note that
the constant value in the precondition can be further obfus-
cated [37] to hide the context relationship.

Dynamic Opaque Predicates.

Palsberg et al. [41] introduce the idea of dynamic opaque
predicates, which are a family of correlated and adjacent
predicates that all present the same value in any given run,
but the value may vary in another run. That means the
values of such opaque predicates switch dynamically. Com-
bined with code clone, dynamic opaque predicates can al-
ways produce the same output. The term “correlated” is
used to describe that dynamic opaque predicates contain
a set of mutually related predicates, and “adjacent” means
these opaque predicates execute one after another strictly.
Figure 3 illustrates an example of dynamic opaque predi-
cates. Two correlated predicates, p and q, meet the require-
ment of evaluating to true (false) in any given run. The
original three instructions {I1; I2; I3;} execute one after an-
other. After transformation, each run either follows the path
p ∧ q (blue path) or ¬p ∧ ¬q (red path). In any case, the
same instructions will be executed. Look carefully at Fig-
ure 3, we can ﬁnd another common feature. Since predi-
cate q divides both blue path and red path into diﬀerent
segments (i.e., {I1;} vs. {I1; I2;} and {I2; I3;} vs. {I3}), p
and q must be strictly adjacent; or else the transformation
is not semantics-persevering. The correlated predicates can
be crafted by utilizing pointer aliasing, which is well known
for its static intractability property [17].

Existing eﬀorts in identifying opaque predicates mainly
focus on invariant opaque predicates and they are unable
to detect more covert opaque predicates such as contextual
and dynamic opaque predicates. A general and accurate
approach to opaque predicate detection is still missing. Our
research aims to ﬁll in this gap.

3. OVERVIEW

3.1 Method

The core of our approach is an opaque predicate detector,
whose overall detection ﬂow is shown in Figure 4. There are
three rounds in our system to detect three kinds of opaque
predicates progressively. Here we present an overview of our
core method.

Figure 5: A motivating example.

Since embedding opaque predicates into a program is a
semantics-preserving transformation, deterministic programs
before and after opaque predicate obfuscation should pro-
duce the same output. Let us assume the program P is
obfuscated by opaque predicates and the resulting program
is denoted as Po. The logic of an execution of Po is expressed
as a formula Ψ, which is the conjunction of all branch con-
ditions executed, including the following opaque predicates.

Ψ = ψ1 ∧ ... ∧ ψi−1 ∧ ψi ∧ ... ∧ ψn

Formula Ψ represents the conditions that an input must sat-
isfy to execute the same path. Supposing constraint ψi is de-
rived from an opaque predicate, we call ψi a culprit branch.
The key to our approach is to locate all culprit branches in
Ψ. Similar to dynamic symbolic execution [25] on binary
code, we ﬁrst characterize the logic of an execution in terms
of symbolic path conditions, by performing a symbolic exe-
cution on the concrete execution trace.

Then our approach carries out three rounds of scanning.
In the ﬁrst round, we diagnose whether ψi is derived from an
invariant opaque predicate by proving whether ψi is always
true; that is, it is a tautology. Note that the false branch
conditions have already been negated in the recorded trace.
After that, we remove identiﬁed culprit branches from Ψ
and continue to detect possible contextual opaque predicates
in the second round. Our key insight is that a contextual
opaque predicate does not enforce any further constraint on
its prior path condition. Based on this observation, diagnos-
ing whether a path constraint ψi (1 ≤ i ≤ n) is a contextual
opaque predicate boils down to answering an implication
query, namely

ψ1 ∧ ... ∧ ψi−1 ⇒ ψi

I1;ptrueI1;I2;falseI2;I3;qtrueI3;falseI1;I2;I3;  1 int opaque(int x)  2 {  3     int *p = &x;  4     int *q = &x;  5     int y = 0;  6     if (x*x < 0)         // invariant opaque predicate  7         x = x+1;  8     if (x > 3)  9     {                      // contextual opaque predicate10         if (x*x-4x+3 > 0)11         x = x<<1;12      }13     if ((*p)%2 == 0) // dynamic opaque predicate14         y = x+1;15     else16     {17         y = x+1;18         y = y+2;19     }   20     if ((*q)%2 == 0)21     {22         y = y+2;23         x = y+3;24     }25    else26        x = y+3;27    return x;28 }759Figure 4: Opaque predicate detector.

to calculate path condition formula Ψ. In our example, the
predicates are represented as follows.

ψ1 : x ∗ x >= 0
ψ2 : x > 3
ψ3 : x ∗ x − 4x + 3 > 0
ψ4 : (∗p)%2 == 0
ψ5 : (∗q)%2 == 0
Ψ : ψ1 ∧ ψ2 ∧ ψ3 ∧ ψ4 ∧ ψ5
We present the three rounds step by step.

1. At the ﬁrst round, we verify whether a predicate sat-
isﬁes invariant property; i.e., it is a tautology. In our
example, we prove that ψ1 (x ∗ x >= 0) is always true
and therefore conclude that ψ1 is an invariant opaque
predicate. After that, we remove ψ1 from path con-
dition Ψ to reduce the formula size and pass the new
path condition to the next round.

2. We start the second round to detect possible contex-
tual opaque predicates by performing implication check
cumulatively from the ﬁrst predicate. We identify two
cases that satisfy the implication check in our exam-
ple: ψ2 ⇒ ψ3 (ψ1 has been removed), i.e., (x > 3) ⇒
(x ∗ x − 4x + 3 > 0) and ψ2 ∧ ψ3 ∧ ψ4 ⇒ ψ5, i.e.,
(x > 3) ∧ (x ∗ x − 4x + 3 > 0) ∧ ((∗p)%2 == 0) ⇒
((∗q)%2 == 0). Note that ψ5 in the second case is
corresponding to the second culprit branch of the dy-
namic opaque predicates.

3. In the third round, we trace back from the culprit
branches identiﬁed in the second step and further ver-
ify whether their prior predicates are correlated or not.
Recall that another property of dynamic opaque predi-
cates is being adjacent. In our example, we ﬁrst negate
each prior predicate as ¬ψ2 and ψ2 ∧ ψ3 ∧¬ψ4 and au-
tomatically generate inputs to satisfy such new path
conditions. Here we generate two new inputs respec-
tively, namely, x = 0 and x = 5. With the new traces,
we perform implication check for ¬ψ2 ⇒ ¬ψ3 and
ψ2 ∧ ψ3 ∧ ¬ψ4 ⇒ ¬ψ5. It is evident that ¬ψ2 ⇒ ¬ψ3
fails under the counterexample of x = 0. At last,
we compare trace segments controlled by ψ4 ∧ ψ5 and
¬ψ4 ∧ ¬ψ5 to make sure they are semantically equiva-
lent. As a result, we conclude that ψ3 is a contextual
opaque predicate and ψ4 and ψ5 consist of dynamic
opaque predicates.

For the presentation purpose, all the examples in this sec-
tion are shown as C code and the predicates are presented as

Figure 6: An execution trace given x=4.

Note that dynamic opaque predicates satisfy such implica-
tion check as well. For example, the combination of path
condition for Figure 3 is either p∧q or ¬p∧¬q. It is straight-
forward to infer the following implication relationship.

(p ⇒ q) ∧ (¬p ⇒ ¬q)

Assume we have detected p ⇒ q in the second round of
scanning. To further clarify p and q are correlated dynamic
opaque predicates, we go one step further in the third round
to verify whether ¬p ⇒ ¬q holds as well. To this end, we
automatically generate a new input that follows the path of
¬p ∧ ¬q. If ¬p ⇒ ¬q is also true, we continue to compare
trace segments guided by both p ∧ q and ¬p ∧ ¬q to make
sure two paths are semantically equivalent. Further details
about the detection process are discussed in Section 4.
3.2 Example

We create a motivating example (shown in Figure 5) to
illustrate our core method. Figure 5 contains three diﬀer-
ent kinds of opaque predicates. Note that the two dynamic
opaque predicates are constructed using pointer deference
(line 13 ∼ line 27). The predicates in line 13 and line
20 are correlated, since they evaluate to the same value at
any given run. In any case, the same instruction sequence
{y = x + 1; y = y + 2; x = y + 3;} will be executed.
Consider an execution of the code snippet given x = 4 as
input. Figure 6 shows a source-level view of such execution
trace. We perform backward slicing and symbolic execution

New traceSymbolic formulas Tautology check Invariant opaque predicatesImplication check  Input generationOriginal traceThe first roundThe second roundContextual opaque predicatesDynamic opaque predicatesThe third roundSemantics-based binary diffingReduced path conditionCulprit branches  3  int *p = &x;  4  int *q = &x;  5  int y = 0;  6  if (x*x < 0)         // invariant opaque predicate  8  if (x > 3)  9  {                       // contextual opaque predicate10      if (x*x-4x+3 > 0)11          x = x<<1;12   }13  if ((*p)%2 == 0) // dynamic opaque predicate14      y = x+1;   20  if ((*q)%2 == 0)21  {22      y = y+2;23      x = y+3;24   }27  return x;28 }760the “if” conditional statements. LOOP works at the binary
level, in which the conditional statements such as “if” and
“switch” are compiled as conditional jump instructions like
je/jne/jg. LOOP identiﬁes the conditional jump instruc-
tions that are opaquely true or false.

4. APPROACH

In this section, we present each step of our approach in
detail. Figure 7 illustrates the architecture of LOOP, which
includes two main parts: online trace logging and oﬄine
analysis. The online part, as shown in the left side of Fig-
ure 7, is built on top of a dynamic binary instrumentation
(DBI) platform, enabling LOOP to work with unmodiﬁed
binary code. To analyze packed malware, our online part
includes two tools: generic unpacking and trace logging.

The logged trace is passed to the second part of LOOP for
oﬄine analysis (the right component of Figure 7). We ﬁrst
lift x86 instructions to BAP IL [7], a RISC-like intermediate
language. Then starting from each predicate (branch), we
perform backward slicing to determine the instructions that
contribute to the value of the predicate. Then we perform
symbolic execution along the slice to calculate a symbolic
expression for each predicate. Based on that, our opaque
predicate detector will construct formulas to represent the
semantics of opaque predicates. We then solve them with
a constraint solver. As discussed in Section 3, the detector
conducts three rounds of scanning. The net result is a set
of culprit branches corresponding to the opaque predicates.
4.1 Online Logging

As shown in Figure 7, LOOP’s online part is built on a
dynamic binary instrumentation framework. To undermine
anti-malware detection, most malware developers apply dif-
ferent packers to compress or encrypt malware binaries. As
a result, when a packed sample starts running, unpacking
routines will ﬁrst restore the original payload (e.g., decom-
press or decrypt) and then jump to the original entry point
(OEP) to continue the execution. One of our implemen-
tation choices is we only detect opaque predicates within
malware real payload. To this end, when a malware sam-
ple starts running, we ﬁrst invoke our generic unpacking
tool to monitor memory write operations. If a memory re-
gion pointed by the eip register is “written and then ex-
ecute” [31], it indicates that we have identiﬁed the newly
generated code. Then we activate our trace logging tool to
start trace recording.

In general, analyzing all the instructions could be a te-
dious job. To keep the logged trace compact, LOOP sup-
ports on-demand logging to optionally record instructions
of interest.
In addition, our logging tool can perform dy-
namic taint tracking so that only the tainted instructions
are collected.
4.2 Slicing and Symbolic Execution

Taking the logged trace as input, LOOP’s oﬄine analysis
ﬁrst lifts x86 instructions to BAP IL, which is a RISC-like
intermediate language without side eﬀect. In addition, the
property of static single assignment (SSA) format facilitates
tracing the use-def chain when we perform slicing. The sym-
bolic execution is carried out on BAP IL as well.

Given a predicate (or branch), LOOP ﬁrst identiﬁes all
the instructions that contribute to the calculation of this
predicate. Note that x86 control transfer instructions typi-
cally depend on certain bits of the eflags register (e.g., jz

and jnz). Therefore, the slicing criteria look like (cid:104)eip, zf(cid:105),
where eip is the instruction pointer and zf is the abbrevia-
tion of the zero ﬂag bit. Starting from the slicing criteria, we
perform dynamic slicing [1] to backtrack a chain of instruc-
tions with data and control dependencies. We terminate our
backward slicing when the source of the slice criteria sat-
isfy one of the following conditions: constant values, static
strings, user deﬁned value (e.g., function return value) or
input. Besides, we also observe a case that the conditional
logic is implemented without eflags register: jecxz jumps
if register ecx is zero. LOOP handles this exception as well.
By labeling inputs or user deﬁned values as symbols, we
conduct symbolic execution along the slice to compute a
symbolic expression for each predicate. The result will be
passed to the opaque predicate detector, the core of LOOP’s
oﬄine analysis. Figure 4 shows the components of our opaque
predicate detector, which consists of three rounds of scan-
ning to detect invariant, contextual and dynamic opaque
predicates progressively. We will present each round of de-
tection in the following subsections.

4.3 Invariant Opaque Predicates

Invariant opaque predicates refer to those predicates that
are always true or false for all possible inputs. This kind
of opaque predicates mainly relies on well-known algebraic
theorems [3, 39]. Since they are easy to construct, invariant
opaque predicates are the most frequently used ones. The
detection method is straightforward by exploiting the invari-
ant property. Tautology check in Figure 4 is used to prove
whether the symbolic expression for each predicate in the
trace always evaluates to true. For instance, one symbolic
expression may be expressed as ∀x ∈ Z. (x3− x)%3 = 0. We
feed this formula to a constraint solver to prove its validity.
Another characteristic of this category of predicates is that
they are independent from each other, and therefore it is
natural to parallelize the detection. We remove the identi-
ﬁed invariant opaque predicates from the path condition to
reduce its size. After that, the reduced path condition is
sent to the second round of scanning.

4.4 Contextual Opaque Predicates

Diﬀerent from the invariant property of the ﬁrst category
of predicates, a contextual opaque predicate relies on some
program invariants so that it always produces the same value
when certain precondition holds. At other places, such a
predicate may evaluate to a diﬀerent value. The precon-
dition can be further obfuscated to camouﬂage the context
information. Our detection method is based on the observa-
tion that a contextual opaque predicate (ψi) does not impose
additional constraint on its prior path condition. Therefore,
ψi should be logically implied by its prior path condition:
ψ1∧ψ2...∧ψi−1; that is, ψ1∧ψ2...∧ψi−1 ⇒ ψi. The process of
testing whether a predicate ψi and its preceding predicates
satisfy the relation ψ1 ∧ ψ2... ∧ ψi−1 ⇒ ψi is called implica-
tion check. Without knowing which predicate is a potential
contextual opaque predicate, we have to perform the impli-
cation check cumulatively starting from the ﬁrst predicate
to the last one. One challenge here is, subject to computing
resources (e.g., memory and CPU), a complicated formula
may be hard or infeasible to solve. To address this issue,
we adopt a “short cut” strategy. When the generated for-
mula becomes too complicated, we divide it into each single
predicate and detect whether ψj ⇒ ψi, j < i. If this check

761Figure 7: The architecture of LOOP.

Algorithm 1 Testing dynamic opaque predicates

P : a set of predicates which pass the implication check
T : the execution trace from which P is derived

for each ψi in P do

T (cid:48) ← GenTrace(¬ψi−1)
i ← Next(T (cid:48), ¬ψi−1)
ψ(cid:48)
if ψ(cid:48)

1: function TestDOP(T , P )
2:
3:
4:
5:
6:
7:
8:
9:

end if
if ¬ψi−1 ⇒ ¬ψi then

i (cid:54)= ¬ψi then
return False

if Ti−1..i ≈ T (cid:48)

i−1..i then

// semantically equivalent
return True

else

10:
11:
12:
13:
14:
15:
16:
17:
18: end function

end for

end if

else

return False

end if

return False

passes, we do not need to prove ψ1 ∧ ψ2... ∧ ψi−1 ⇒ ψi any
more, as the standard implication check will pass certainly.
The results of the second round of scanning are culprit
branches that pass the implication check. Note that at this
point, we cannot conclude whether these culprit branches
are corresponding to real contextual opaque predicates. Re-
call the correlation property of dynamic opaque predicates
discussed in Section 2, most dynamic opaque predicates (from
the second to the last one in a family of related dynamic
opaque predicates) satisfy the implication check as well. In
the third round of detection, LOOP will distinguish these
two categories and identify all correlated dynamic opaque
predicates.
4.5 Dynamic Opaque Predicates

Dynamic opaque predicates consist of a family of cor-
related and adjacent predicates which produce the same
boolean value in any given run. However, the value may
switch to a diﬀerent result in another run. Locating cor-
related predicates is the key to dynamic opaque predicate
detection. A set of predicates are correlated means they
are implied by each other, or in other words, they are logi-
cally equivalent. Therefore, predicates ψ1, ψ2, ..., ψn are cor-
related iﬀ

ψ1 ⇔ ψ2 ⇔ ... ⇔ ψn.

Assume we have two correlated predicates ψi−1 and ψi. Re-
call that in the detection of contextual opaque predicates,
we have proved that ψi−1 ⇒ ψi. Now we have to go one

Figure 8: Trace segment comparison (A and B rep-
resent diﬀerent inputs).

step further to verify whether ψi ⇒ ψi−1. In logic, we have
the following equation.

ψi ⇒ ψi−1 ≡ ¬ψi−1 ⇒ ¬ψi

Therefore, we alternatively verify whether ¬ψi−1 implies
¬ψi by generating a new input. Another property of dy-
namic opaque predicates is that they utilize code clone to
make sure the same instructions are executed in any case. As
a result, we have to compare the two traces to ensure they
are semantically equivalent. Similar to the trace-oriented
binary diﬃng tool [36], our comparison approach relies on
symbolic execution and theorem proving techniques so that
we can ﬁnd that two code pairs with ostensibly diﬀerent
syntax are semantically equivalent.

i. Then we verify ψ(cid:48)

Suppose ψi−1 and ψi are dynamic opaque predicates and
ψi has been identiﬁed as a culprit branch satisfying implica-
tion check. The procedure of our third round of detection is
shown in Algorithm 1. First, we negate the predicate ψi−1
and use constraint solver to generate a new input to follow
the path ψ1 ∧ ψ2... ∧ ¬ψi−1. Given the new trace, the pred-
icate following ¬ψi−1 is ψ(cid:48)
i is equivalent
to ¬ψi. Next, we test whether ¬ψi−1 ⇒ ¬ψi. If it succeeds,
we will compare the trace segments controlled by ψi−1 ∧ ψi
and ¬ψi−1 ∧ ¬ψi. Diﬀerent from previous semantics-based
binary diﬃng tools [36], whose comparison unit is a single
basic block, LOOP merges all the basic blocks which have
control ﬂow dependence with ψi−1 ∧ ψi or ¬ψi−1 ∧ ¬ψi as
a trace segment (as shown in Figure 8). LOOP carries out
symbolic execution for the trace segment and represents its
input-output relation with a set of formulas. At last, LOOP
uses a constraint solver to compare the output formula pairs
and then ﬁnds a bijective equivalent mapping among them.

OnlineOfflineProgram DBIBAP IL converterInputOpaque predicatesSlicing and symbolic execution Generic unpackingTrace logging Opaque predicate detectorConstraint solverExecution traceCompareMerge basic blockI1;ptrueI4;I5;falseI2;I3;qtrueI6;falseABI1;I2;I3;I4;I5;I6;762Table 1: Common mathematical formulas and their
STP solving time.
Formulas
∀x ∈ Z. x2 ≥ 0
∀x ∈ Z. 2 | x(x + 1)
∀x ∈ Z. 3 | x(x + 1)(x + 2)
∀x, y ∈ Z. 7y2 − 1 (cid:54)= x2
∀x ∈ Z. (x2 + 1)%7 (cid:54)= 0
∀x ∈ Z. (x2 + x + 7)%81 (cid:54)= 0
∀x ∈ Z. (4x2 + 4)%19 (cid:54)= 0
∀x ∈ Z. 4 | x2(x + 1)(x + 1)
∀x ∈ Z. 2 | x ∨ 8 | (x2 − 1)
∀x ∈ Z. 2 | (cid:98) x2
2 (cid:99)

Solving time (s)
0.003
0.008
0.702
0.008
17.762
22.657
15.392
0.012
0.022
0.015

If so, we conclude that these two trace segments are seman-
tically equivalent and therefore ψi−1 and ψi are dynamic
opaque predicates. If ¬ψi−1 ⇒ ¬ψi fails or new trace seg-
ment is diﬀerent to the original one, we conclude ψi is a
contextual opaque predicate.

Following the similar idea, we can identify the correlated
predicates containing more than two predicates and then
check the equivalence of the trace segments which have con-
trol dependence on these predicates.
4.6 Solving Opaque Predicate Formulas

It is evident that the eﬃcacy of LOOP depends on the
capability of constraint solvers in proving the validity of a
formula. State-of-the-art constraint solvers (e.g., STP [23],
Z3 [38]) have supported all arithmetic operators found in the
C programming language (e.g., bitwise operations, multipli-
cation, division, and modular arithmetics). Table 1 shows
ten mathematical formulas that are commonly used as in-
variant opaque predicates, including integer division, mod-
ulo and remainder operations. We solve these formulas with
STP in our testbed and present the solving time in the sec-
ond column. Most formulas only need less than 0.1 seconds,
which are almost negligible. However, we notice that formu-
las involving modular arithmetic increase the solving time
considerably. For example, the solving time for three com-
plicated modular arithmetic formulas in Table 1 varies from
15 to 23 seconds. Even so, compared with other methods
which need to run a large set of test inputs (e.g., statistical
analysis [17] and fuzz testing [33]), our approach achieves
better performance and accuracy.
4.7 Whole Program Deobfuscation

After three rounds of detection, LOOP returns all possible
opaque predicates in an execution trace. Our result can be
fed back to security analysts to further deobfuscate the clut-
tered control ﬂow graph of a whole program. For example,
the unreachable paths introduced by invariant opaque pred-
icates are discarded; the redundant contextual opaque pred-
icates are cut oﬀ as well. To reverse the eﬀect of dynamic
opaque predicates, we remove the set of correlated dynamic
opaque predicates and replace the corresponding multiple
paths with a single straight-line path. Since our approach
is trace-oriented, we deobfuscate a part of the control ﬂow
graph each time. To increase path coverage, we can leverage
automatic input generation techniques [13, 25].

5.

IMPLEMENTATION

LOOP’s online logging part consists of two tools, generic
unpacking and trace logging, which are implemented based

Table 2: Contextual opaque predicates used in com-
mon utilities evaluation.

∀x ∈ Z. x > 5 ⇒ x > 0
∀x ∈ Z. x > 3 ⇒ x2 − 4x + 3 > 0
∀x ∈ Z. x%4 = 0 ⇒ x%2 = 0
∀x ∈ Z. x%9 = 0 ⇒ x%3 = 0
∀x ∈ Z. x%10 = 0 ⇒ x%5 = 0
∀x ∈ Z. 3|(7x − 5) ⇒ 9|(28x2 − 13x − 5)
∀x ∈ Z. 5|(2x − 1) ⇒ 25|(14x2 − 19x − 19)
∀x, y, z ∈ Z. (2 (cid:45) x ∧ 2 (cid:45) y) ⇒ x2 + y2 (cid:54)= z2

1
2
3
4
5
6
7
8

on the Pin DBI framework [32] (version 2.12) with 1,752
lines of code in C/C++. To make the logged trace com-
pact, we start trace logging when unpacking routine ﬁnishes
and support on-demand logging for instructions of inter-
est. LOOP’s oﬄine analysis part is implemented on top of
BAP [7] (version 0.8) with 2, 588 lines of OCaml code. We
rely on BAP to lift up x86 instructions to the BAP IL and
convert BAP IL to CVC formulas. LOOP’s backward slic-
ing is performed on BAP IL; the opaque predicate detector
and trace segment comparison tool are built on BAP’s sym-
bolic execution engine. We use STP [23] as our constraint
solver. Besides, we write 644 lines of Perl scripts to glue all
components together to automate the detection. To facili-
tate future research, we have made LOOP code available at
https://github.com/s3team/loop.

6. EVALUATION

We evaluate LOOP’s eﬀectiveness to automatically de-
tect various opaque predicates. We test LOOP with a set
of Linux common utilities and highly obfuscated malicious
programs. We make sure we have the ground truth so that
we can accurately assess false positives and false negatives.
Also, since LOOP is strongly motivated by its application,
we evaluate the impact of LOOP in the task of code nor-
malization for metamorphic malware. The experiments are
performed on a machine with a Intel Core i7-3770 proces-
sor (Quad Core, 3.40GHz) and 8GB memory, running both
Ubuntu 12.04 and Windows XP SP3.
6.1 Evaluation with Common Utilities

This experiment is designed to evaluate the eﬀectiveness
and eﬃciency of our method. First, we select ten widely
used utility programs in Linux as our test cases. To en-
sure the samples’ variety, those candidates are picked from
diﬀerent areas, including data compression, core utilities,
regular expression search, hash computing, web ﬁle trans-
fer, and HTTP server. Since all of those programs are open
source, we can easily verify our detection results. We im-
plement automatic opaque predicate insertion as an LLVM
pass, based on Obfuscator-LLVM [26]. For each program,
we insert seven opaque predicates, including three invari-
ant, three contextual and one dynamic opaque predicates.
The three invariant opaque predicates are randomly selected
from Table 1; the three contextual opaque predicates are
chosen from Table 2. We use the example of dynamic opaque
predicates shown in Figure 5. At the same time, we make
sure that all the opaque predicates can be reached by the
test inputs.

We ﬁrst label the inputs of test cases as tainted and record
tainted instructions. Then we run LOOP’s oﬄine analysis
to detect the opaque predicates. Table 3 shows the exper-
imental results. The second column shows the number of

763Program

bzip
grep

ls

head

md5sum
thttpd

boa
wget
scp

libpng

#Predicates

Invariant

Table 3: Evaluation results on linux common utilities.

Contextual

Dynamic

(no-taint, taint) #OP SE (s)
0.9
0.9
3.3
0.7
2.8
8.7
6.8
3.0
3.4
51.4

(6,313, 13)
(4,969, 16)
(5,867, 21)
(1,496, 11)
(3,450, 14)
(6,605, 124)
(4,718, 131)
(3,230, 36)
(2,402, 30)
(25,377, 446)

4
5
13
6
3
3
3
5
5
7

STP (s) #OP SE (s)
1.2
1.8
22.4
1.1
1.5
3.6
2.5
2.0
2.8
14.6

1.4
1.5
3.9
2.5
4.5
16.8
18.7
7.6
5.8
351.6

6
6
3
7
3
3
3
3
4
4

STP (s) #OP SE (s)
1.8
2.3/1.9
2.4
1.6/1.3
12.5
3.5/2.8
1.9
1.3/1.3
25.0/20.3
1.0
1.4
5.4/2.2
1.7
6.2/1.8
1.5
2.2/1.2
1.5
4.1/2.4
33.2/11.6
10.4

2
3
1
1
1
1
1
1
1
2

STP (s)
2.4
0.3
2.1
1.0
2.2
0.7
0.8
0.7
0.7
5.2

(#FP, #FN)

(5, 0)
(6, 0)
(10, 0)
(1, 0)
(0, 0)
(0, 0)
(0, 0)
(2, 0)
(3, 0)
(6, 0)

predicates before and after taint. It is evident that forward
taint propagation reduces the number of predicates signif-
icantly. For each category of opaque predicate, we report
the number of opaque predicate detected (#OP), the time
of symbolic execution (SE) and the time of running STP
solver (STP). Note that in the column of STP time for con-
textual opaque predicates, we list the diﬀerent time before
and after “short cut” optimization (see Section 4.4).

For the majority of our test cases, the symbolic execution
and STP solver only take several seconds. Because libpng’s
trace size is large and its invariant opaque predicates in-
serted involve modulus arithmetic, the corresponding STP
solving time is the longest. The data presented in the eighth
column indicate that the eﬀect of “short cut” optimization
is encouraging, especially for the cases with large path for-
mulas (e.g., libpng). Furthermore, we manually verify each
logged traces and ﬁnd that our approach successfully diag-
noses all the opaque predicates if there is any; that is, we
have zero false negatives (#FN in the last column).

To test false positives of our approach, namely whether
LOOP mistakes a normal condition as an opaque predicate,
we conduct a similar evaluation on our test cases’ clean ver-
sion (no opaque predicate insertion). Contrary to our expec-
tation, we notice that seven out of ten cases detect opaque
predicates but all of them are false positives (#FP in the last
column). We look into the factors leading to the false posi-
tives and ﬁnd that one major reason is “under tainting” [27],
which is a common problem in taint analysis. Generally, un-
der tainting means instructions that should be tainted are
not recorded. As a result, under tainting will mistakenly
replace some symbols with concrete values. For instance,
supposing y with a concrete value of 2 is not labeled as a
symbol in the predicate y > 1, the predicate in the trace
would be 2 > 1, which is a tautology, and LOOP will issue
a false alarm.

6.2 Evaluation with Obfuscated Malware

Opaque predicates are also widely used by malware devel-
opers. Moreover, opaque predicates are typically integrated
with other obfuscation methods to impede reverse engineer-
ing attempts. To evaluate the resilience of LOOP against
various obfuscation methods, we collect 15 malware bina-
ries from VX Heavens.1 These malware samples are chosen
for two reasons: 1) they are representative in obfuscation
techniques; 2) we have either source code (e.g., QQThief
and KeyLogger) or detailed reverse engineering reports (e.g.,

Figure 9: Example of an opaque predicate in mal-
ware.

Bagle and Mydoom). Hence, we can accurately evaluate our
detection results.
Table 4 shows a variety of obfuscation techniques with
diﬀerent purposes. Column 4 ∼ 9 represent the methods to
obfuscate code and data, such as binary compression and
encryption packers, junk code, code reorder, and opaque
constant. Column 10 ∼ 12 denote the control ﬂow obfus-
cation methods in addition to opaque predicates, includ-
ing call-stack tampering, CFG ﬂatten, and obfuscated con-
trol transfer target. The methods in column 13 and 14 are
used to detect the debugging and virtual machine (VM) en-
vironment. The “# OP” column presents the number of
opaque predicates detected by LOOP. The triple such as
(5,3,1) represents the number of invariant, contextual, and
dynamic opaque predicates, respectively. We ﬁnd that most
malware samples (12 out of 15) are embedded with opaque
predicates and invariant opaque predicates are the most fre-
quently used. The high number (90) of invariant opaque
predicates detected in Hunatcha is caused by loop unrolling.
With the help of source code and reverse engineering re-
ports, we count false positives and false negatives (shown in
column 16). Similar with common utilities’ results, LOOP
achieves zero false negatives. That is, LOOP does not miss
any opaque predicates. The last column lists the total oﬄine
analysis time. Note that our generic unpacking cannot han-
dle virtualization obfuscators [18] such as VMProtect2 and
Themida3. In our test cases, we ﬁnd two malware samples
(BullMoose and Branko) are obfuscated with virtualization
obfuscation. As a result, the logged trace mixes the code of
virtualization interpreter with the code of malicious payload.
LOOP nevertheless detects opaque predicates successfully.
Figure 9 shows an opaque predicate we detected in Key-
Logger Trojan. This opaque predicate utilizes the fact of
stack memory alignment, and therefore both ebp and esp
are even numbers. After several arithmetic operations, the

1http://vxheaven.org/src.php

2http://vmpsoft.com/
3http://www.oreans.com/themida.php

call near ptr GetFontData                                                                   and eax, ebp                                                                                          inc eax                                         and eax, 01h                        cmp eax, 0                             jne   new_target                    ;  eax = 0xFFFFFFFF;  ebp, esp are even numbers;  eax = eax & ebp;  eax is an even number;  eax += 1, eax is an odd number;  eax = 01h;  always true764Table 4: Various obfuscation methods applied by malicious program.

)
b
k
(

Sample
Bube
Tefuss
Champ

BullMoose
QQThief
KeyLogger
Autocrat
Codbot
Loony
Branko

Hunatcha

Bagle
Sasser

Mydoom
Zeynep

Type
Virus
Virus
Virus
Trojan
Trojan
Trojan

Backdoor
Backdoor
Backdoor

Worm
Worm
Worm
Worm
Worm
Worm

.
f
s
n
a
r
t

.
t
a
c
s
u
f
b
O

g
n
i
g
g
u
b
e
d
-
i
t
n
A

n
e
t
t
a
ﬂ
G
F
C

M
V

-
i
t
n
A

(cid:88) (cid:88)
(cid:88) (cid:88)
(cid:88)
(cid:88) (cid:88)
(cid:88)

P
O
#
(0,0,0)
(2,0,0)
(0,0,0)
(5,3,1)
(3,0,0)
(8,1,1)
(cid:88) (cid:88) (12,0,0)
(2,0,0)
(0,0,0)
(cid:88) (cid:88) (cid:88) (cid:88) (10,0,0)
(cid:88) (cid:88)
(90,3,1)
(6,0,0)
(4,0,0)
(6,0,0)
(8,1,0)

(cid:88)
(cid:88) (cid:88)

(cid:88)
(cid:88)

(cid:88)

)
N
F
#

,

P
F
#

(

(0, 0)
(0, 0)
(0, 0)
(2, 0)
(1, 0)
(0, 0)
(4, 0)
(0, 0)
(1, 0)
(0, 0)
(0, 0)
(2, 0)
(0, 0)
(1, 0)
(3, 0)

)
s
(

i

e
m
T
3.4
4.2
3.0
7.8
15.4
22.3
244.5
8.2
5.3
8.5
36.2
24.6
18.2
132.3
192.3

(cid:88) (cid:88)
(cid:88)
(cid:88) (cid:88)
(cid:88)
(cid:88)

(cid:88)

(cid:88) (cid:88)

r
e
k
c
a
p

r
e
k
c
a
p

.
t
p
y
r
c
n
E

.
s
e
r
p
m
o
C
(cid:88)
(cid:88)
(cid:88)

.
e
p
m
a
t

t
n
a
t
s
n
o
c

r
e
d
r
o
e
r

e
d
o
c

k
n
u
J

e
d
o
C

e
u
q
a
p
O

k
c
a
t
s
-
l
l
a
C
(cid:88) (cid:88) (cid:88) (cid:88)
(cid:88) (cid:88)
(cid:88)
(cid:88) (cid:88)

(cid:88) (cid:88) (cid:88)

ASPack

Packer
FSG
UPX

PECompact
VMProtect

e
z
i
S
12
29
13
30
32 Yoda’s Protector (cid:88) (cid:88)
(cid:88) (cid:88)
33
(cid:88)
276
(cid:88) (cid:88)
30
(cid:88) (cid:88)
20
(cid:88)
17
(cid:88) (cid:88)
61
47
60
41
85 Yoda’s Protector (cid:88) (cid:88)

ASPack
ASPack
Themida
PolyEnE

UPack
UPack

PECompact

ASProtect

(cid:88) (cid:88) (cid:88) (cid:88)
(cid:88) (cid:88) (cid:88) (cid:88)
(cid:88) (cid:88) (cid:88) (cid:88) (cid:88)

Table 5: Speed up metamorphic malware variants
matching

Family

Metaphor
Lexotan32
Win32.Evol

Basic blocks
reduction (%)

Isomorphism
speedup (X)

26
20
16

2.0
1.6
1.2

last branch is always true.
In summary, our experiments
show that LOOP is eﬀective in detecting opaque predicates
in obfuscated binary code with a zero false negative rate.
Considering that LOOP aims to provide a general and au-
tomatic de-obfuscation solution, which usually involves te-
dious manual work, the false positive rate is tolerable.

6.3 Metamorphic Malware Matching

To conﬁrm the value of our approach in malware defenses,
we also test LOOP in the task of code normalization for
metamorphic malware [9, 10]. Metamorphic malware mu-
tates its code during infection so that each variant bears
little resemblance to another one in syntax. It is well known
that metamorphism can undermine the signature-based anti-
malware solutions [44]. Bruschi et al. [9, 10] propose code
normalization to reverse the mutation process. To test whether
an instance of metamorphic malware is present inside an in-
fected host program, they compare malicious code and nor-
malized program by inter-procedural control ﬂow subgraph
isomorphism. The drawback is that they do not handle
opaque predicates, although opaque predicates are one of
the commonly used mutation methods. Opaque predicates
can seriously thwart normalized control ﬂow graph compari-
son [9]. We re-implement their code normalization based on
BAP and test the speedup of normalized control ﬂow graph
isomorphism under the preprocess of LOOP on three famous
metamorphic malware families.

Since the three metamorphic malware samples are all ﬁle-
infecting, we ﬁrst force each malware to infect 20 Cygwin

utilities.4 For each family, we follow similar steps as in Br-
uschi et al.
to normalize infected programs and compare
their control ﬂow graphs (CFG) with malicious code’s CFG,
leveraging VFLIB library [20]. In addition, we apply LOOP
to preprocess infected programs to remove the corresponding
superﬂuous branches and infeasible paths. Table 5 shows the
improvements introduced by our approach on average. Com-
pared with the results without applying LOOP, we remove
redundant basic blocks as much as 26% and speed up sub-
graph isomorphism by a factor of up to 2.0 (e.g., Metaphor).

7. DISCUSSIONS AND FUTURE WORK

We further discuss about our design choices, limitations

and future work in this section.

Dynamic Approach.

Our approach bears the similar limitations as dynamic
analysis in general. For example, LOOP can only detect
opaque predicates executed at run time. Static analysis
might explore all the possible paths in the program. How-
ever, even static disassembly of stripped binaries is still a
challenge [30, 47]. Moreover, the various obfuscation tech-
niques listed in Table 4 will undoubtedly deter extracting
accurate control ﬂow graph from binary code. We believe
our approach, based on the test cases that execute opaque
predicates, is practical in analyzing a malicious program. A
possible way to increase path coverage is to leverage test-
generation techniques [13, 25] to automatically explore new
paths. Another concern we want to discuss is scalability is-
sue. The size of a slice may become signiﬁcant for a program
with high workload, and our detection approach is linearly
dependent on the size of a slice. In that case, LOOP has
to analyze a large number of predicates, resulting in a sub-
stantial performance slowdown. One way to alleviate the
high overhead is to detect opaque predicates in parallel. We
plan to explore this direction in our future work. Detect-

4www.cygwin.com

765Figure 10: Example of two-way opaque predicates.

Figure 11: Example of 3x+1 conjecture.

ing repetitive opaque predicates due to loop unrolling leads
to performance penalty. We will extend our tool with loop
identiﬁcation in the next version.

Floating Point.

The eﬀect of LOOP is restricted by the capability of the
constraint solver and symbolic execution tools. One example
is ﬂoating point. Since precisely deﬁning the rounding se-
mantics of ﬂoating point is challenging, current binary sym-
bolic execution does not support ﬂoating point instructions
(e.g., fdiv and fmul) [7]. As a result, currently LOOP is
unable to detect opaque predicates involving ﬂoating point
operations. One might argue that attackers can easily get
around LOOP by using ﬂoating point equations. However,
using ﬂoating point equations in malware increases the pos-
sibility of detection as well, because both ﬂoating point in-
structions and related numerics library API calls (e.g., log,
exp and sqrt) are rarely seen in malicious code.

Two-way Opaque Predicates.

Figure 10 shows a subtle case of opaque predicate,

in
which two possible directions will sometimes be taken and
I1; I2 are executed in any case. P does not belong to the cat-
egories we summarized in Section 2 and therefore we cannot
ensure P is an opaque predicate in a single trace. One way
to detect such case is to check semantic equivalence of P ’s
two jump targets [49].

Unsolved Conjectures.

Recently Wang et al. [48] proposed a more stealthy obfus-
cation scheme by incorporating linear unsolved conjectures,
which appear to be correct but without proof. Figure 11
presents an example of embedding the well-known 3x+1 con-
jecture into a program. This conjecture asserts that given
any positive integer y, the loop will always terminate.
In
principle, we could treat the conjunction of branch condi-
tions derived from the unroll loop as a single opaque predi-
cate, which always evaluates to be true for any positive inte-
ger. However, diﬀerent from dynamic opaque predicates, the
number of conditions is various under diﬀerent inputs and

conditions themselves are not correlated as well. To detect
such unsolved conjectures, we observe that all the exam-
ples [48] will eventually converge to a ﬁxed value regardless
of the initial value. We could automatically generate test
cases to explore diﬀerent paths and observe whether the
multiple inputs cover the same value when the conjecture
loop ends. We leave it as our future work.

8. RELATED WORK

In this section, we ﬁrst present previous work on opaque
predicates detection, which is close in spirit to our work.
Then, we introduce related work on concolic testing, a hy-
brid approach to perform symbolic execution. In principle,
our trace-oriented detection is also a hybrid approach that
applies symbolic execution in de-obfuscation. At last we
introduce previous work on infeasible paths identiﬁcation,
which is related to our work in that LOOP can be applied
to detect infeasible paths in binary.

Opaque Predicate Detection.

The concept of opaque predicates is ﬁrst proposed by Coll-
berg et al. [17] to prevent malicious reverse engineering at-
tempts. Collberg et al. [17] also provide some ad-hoc detec-
tion methods. One of them is called “statistical analysis”;
that is, a predicate that always produces the same result
over a larger number of test cases has a great chance to
be an opaque predicate. Due to the limited set of inputs,
statistical analysis could lead to high false positive rates.
Preda et al. [42] propose to detect opaque predicates by
abstract interpretation. However, their approach only de-
tects a speciﬁc type of known invariant opaque predicates
such as ∀x ∈ Z.n|f (x). Madou [33] ﬁrst identiﬁes can-
didate branches that never change at run time, and then
veriﬁes such predicates by fuzz testing with a considerably
high error rate. Udupa et al. [45] utilize static path fea-
sibility analysis to determine whether an execution path is
feasible. However, their approach cannot work on a highly
obfuscated binary with, for example, complicated opaque
predicates based on pointer aliasing, which is known to be
statically intractable. OptiCode [43] has a similar idea in
using theorem prover to decide if a desired branch is always
true or false, but it can only deal with invariant opaque
predicates. Our work is diﬀerent from the previous work in
that LOOP is both general and accurate. We are able to
detect previously unknown opaque predicates in obfuscated
binary, including more sophisticated ones such as contextual
and dynamic opaque predicates.

Concolic Testing.

Our logic-based approach is inspired by the active research
in concolic testing [13, 12, 24, 25], a hybrid software veriﬁ-
cation method combining concrete execution with symbolic
execution. Similar to SAGE [25], LOOP ﬁrst maps symbols
to inputs and then collects constraints of these symbolic in-
puts along a recorded execution trace. The diﬀerence is
our primary purpose is not for path exploration; instead we
construct formulas representing the characteristics of opaque
predicates and solve these formulas with a constraint solver.
In addition to automatic input generation, we have seen
applications of concolic testing in discovery of deviations
in binary [6], software debugging with golden implementa-
tion [4], and alleviating under-tainting problem [27]. Our

I1;I2;        PfalseI1;I1;trueI2;x = input ( );I1;I2;x = input ( );I1;y = x;while (y > 1){    if (y%2 != 0)          y = 3*y+1;    else y = y/2;}I2;766approach adopts part of the concolic testing idea in software
de-obfuscation and malware analysis.

Infeasible Path Identiﬁcation.

The eﬀect of opaque predicates is to obfuscate control ﬂow
graph with infeasible paths. In software testing, eliminat-
ing infeasible paths saves eﬀorts to generate redundant test
cases. Previous work identiﬁes infeasible paths in source
code, either by branch correlation analysis [5], pattern match-
ing [40], or monitoring the search for test data [11]. However,
these work cannot be directly used to detect opaque pred-
icates in an adversary environment, in which the program
source code under examination is typically absent. There-
fore, we believe LOOP has compelling application in identi-
fying infeasible paths in binary.

9. CONCLUSION

Opaque predicates have been widely used in software pro-
tection and malicious program to obfuscation program con-
trol ﬂow. Existing eﬀorts to detect opaque predicates are ei-
ther heuristics-based or work only on speciﬁc categories. In
this paper, we have presented LOOP, a program logic-based
and obfuscation resilient approach to the opaque predicate
detection in binary code. Our approach represents the char-
acteristics of various opaque predicates with logical formu-
las and veriﬁes them with a constraint solver. LOOP de-
tects not only simple invariant opaque predicates, but also
advanced contextual and dynamic opaque predicates. Our
experimental results show that LOOP is eﬀective in detect-
ing opaque predicates in a range of benign and obfuscated
binary programs. By diagnosing culprit branches derived
from opaque predicates in an execution trace, LOOP can
help analysts for further de-obfuscation. The experiment of
speeding up code normalization for matching metamorphic
malware variants conﬁrms the value of LOOP in malware
defenses.

10. ACKNOWLEDGMENTS

We thank the ACM CCS 2015 anonymous reviewers and
Bill Harris for their valuable feedback. This research was
supported in part by the National Science Foundation (NSF)
grants CNS-1223710 and CCF-1320605, and the Oﬃce of
Naval Research (ONR) grant N00014-13-1-0175.

11. REFERENCES
[1] H. Agrawal and J. R. Horgan. Dynamic program

slicing. ACM SIGPLAN Notices, 25(6):246–256, 1990.

[2] B. Anckaert, M. Madou, B. D. Sutter, B. D. Bus,

K. D. Bosschere, and B. Preneel. Program
obfuscation: a quantitative approach. In Proceedings
of the 2007 ACM workshop on Quality of Protection
(QoP’07), 2007.

[3] G. Arboit. A method for watermarking Java programs

via opaque predicates. In Proceedings of 5th
International Conference on Electronic Commerce
Research (ICECR-5), 2002.

[4] A. Banerjee, A. Roychoudhury, J. A. Harlie, and
Z. Liang. Golden implementation driven software
debugging. In Proceedings of the 18th ACM SIGSOFT
International Symposium on Foundations of Software
Engineering (FSE’10), 2010.

[5] R. Bod´ık, R. Gupta, and M. L. Soﬀa. Reﬁning data

ﬂow information using infeasible paths. In Proceedings

of the 5th ACM SIGSOFT International Symposium
on Foundations of Software Engineering (FSE’97),
1997.

[6] D. Brumley, J. Caballero, Z. Liang, J. Newsome, and

D. Song. Towards automatic discovery of deviations in
binary implementations with applications to error
detection and ﬁngerprint generation. In Proceedings of
16th USENIX Security Symposium, 2007.

[7] D. Brumley, I. Jager, T. Avgerinos, and E. J.

Schwartz. BAP: A binary analysis platform. In
Proceedings of the 23rd international conference on
computer aided veriﬁcation (CAV’11), 2011.

[8] D. Brumley and J. Newsome. Alias analysis for

assembly. Technical Report CMU-CS-06-180R, School
of Computer Science, Carnegie Mellon University,
2006.

[9] D. Bruschi, L. Martignoni, and M. Monga. Detecting

self-mutating malware using control-ﬂow graph
matching. In Proceedings of Detection of Intrusions
and Malware & Vulnerability Assessment
(DIMVA’06), 2006.

[10] D. Bruschi, L. Martignoni, and M. Monga. Code

normalization for self-mutating malware. IEEE
Security and Privacy, 5(2), 2007.

[11] P. M. S. Bueno and M. Jino. Identiﬁcation of

potentially infeasible program paths by monitoring the
search for test data. In Proceedings of the 15th IEEE
International Conference on Automated Software
Engineering (ASE’00), 2000.

[12] C. Cadar, D. Dunbar, and D. Engler. KLEE:

Unassisted and automatic generation of high-coverage
tests for complex systems programs. In Proceedings of
the 2008 USENIX Symposium on Operating Systems
Design and Implementation (OSDI’08), 2008.

[13] C. Cadar, V. Ganesh, P. Pawlowski, D. Dill, and

D. Engler. EXE: Automatically generating inputs of
death. In Proceedings of the 2006 ACM Conference on
Computer and Communications Security (CCS’06),
2006.

[14] J. Cappaert and B. Preneel. A general model for

hiding control ﬂow. In Proceedings of the 10th Annual
ACM Workshop on Digital Rights Management
(DRM’10), 2010.

[15] H. Chen, L. Yuan, X. Wu, B. Zang, B. Huang, and

P.-c. Yew. Control ﬂow obfuscation with information
ﬂow tracking. In Proceedings of the 42nd Annual
IEEE/ACM International Symposium on
Microarchitecture (MICRO 42), 2009.

[16] C. Collberg, G. Myles, and A. Huntwork. Sandmark–a

tool for software protection research. IEEE Security
and Privacy, 1(4):40–49, July 2003.

[17] C. Collberg, C. Thomborson, and D. Low. A

taxonomy of obfuscating transformations. Technical
report, The University of Auckland, 1997.

[18] K. Coogan, G. Lu, and S. Debray. Deobfuscation of
virtualization-obfuscated software. In Proceedings of
the 18th ACM Conference on Computer and
Communications Security (CCS’11), 2011.
[19] B. Coppens, B. De Sutter, and J. Maebe.

Feedback-driven binary code diversiﬁcation. ACM
Transactions on Architecture and Code Optimization
(TACO), 9(4), Jan. 2013.

767[20] L. Cordella, P. Foggia, C. Sansone, and M. Vento. A

[35] A. Majumdar and C. Thomborson. Securing mobile

(sub)graph isomorphism algorithm for matching large
graphs. IEEE Transactions on Pattern Analysis and
Machine Intelligence, 26(10):1367–1372, 2004.

[21] DefenseCode. Diving into recent 0day Javascript

obfuscations. http://blog.defensecode.com/2012/
10/diving-into-recent-0day-javascript.html, last
reviewed, 04/27/2015.

[22] S. Drape. Intellectual property protection using
obfuscation. Technical Report RR-10-02, Oxford
University Computing Laboratory, 2010.

[23] V. Ganesh and D. L. Dill. A decision procedure for

bit-vectors and arrays. In Proceedings of the 2007
International Conference in Computer Aided
Veriﬁcation (CAV’07), 2007.

[24] P. Godefroid, N. Klarlund, and K. Sen. DART:

Directed automated random testing. In Proceedings of
the 2005 ACM SIGPLAN Conference on Programming
Language Design and Implementation (PLDI’05),
2005.

[25] P. Godefroid, M. Y. Levin, and D. Molnar. Automated

whitebox fuzz testing. In Proceedings of the 15th
Annual Network and Distributed System Security
Symposium (NDSS’08), 2008.

[26] P. Junod, J. Rinaldini, J. Wehrli, and J. Michielin.

Obfuscator-LLVM - software protection for the
masses. In Proceedings of the 1st International
Workshop on Software PROtection (SPRO’15), 2015.

[27] M. G. Kang, S. McCamant, P. Poosankam, and
D. Song. DTA++: Dynamic taint analysis with
targeted control-ﬂow propagation. In Proceedings of
the 18th Annual Network and Distributed System
Security Symposium (NDSS’11), 2011.

[28] A. Kovacheva. Eﬃcient code obfuscation for Android.

Master’s thesis, University of Luxembourg, 2013.

[29] P. Larsen, A. Homescu, S. Brunthaler, and M. Franz.
SoK: Automated software diversity. In Proceedings of
the 2014 IEEE Symposium on Security and Privacy
(SP’14), 2014.

[30] C. Linn and S. Debray. Obfuscation of executable

code to improve resistance to static disassembly. In
Proceedings of the 10th ACM Conference on Computer
and Communications Security (CCS’03), 2003.
[31] L. Liu, J. Ming, Z. Wang, D. Gao, and C. Jia.
Denial-of-service attacks on host-based generic
unpackers. In Proceedings of the 11th International
Conference on Information and Communications
Security (ICICS’09), 2009.

[32] C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser,

G. Lowney, S. Wallace, V. J. Reddi, and
K. Hazelwood. Pin: building customized program
analysis tools with dynamic instrumentation. In
Proceedings of the 2005 ACM SIGPLAN conference
on Programming language design and implementation
(PLDI’05), 2005.

[33] M. Madou. Application Security through Program
Obfuscation. PhD thesis, Ghent University, 2007.

[34] M. Madou, L. Van Put, and K. De Bosschere. LOCO:

An interactive code (de)obfuscation tool. In
Proceedings of the 2006 ACM SIGPLAN Symposium
on Partial Evaluation and Semantics-based Program
Manipulation (PEPM’06), 2006.

agents control ﬂow using opaque predicates. In
Proceedings of the 9th International Conference on
Knowledge-Based Intelligent Information and
Engineering Systems (KES’05), 2005.

[36] J. Ming, M. Pan, and D. Gao. iBinHunt: Binary

hunting with inter-procedural control ﬂow. In
Proceedings of the 15th Annual International
Conference on Information Security and Cryptology
(ICISC’12), 2012.

[37] A. Moser, C. Kruegel, and E. Kirda. Limits of static
analysis for malware detection. In Proceedings of the
23th Annual Computer Security Applications
Conference (ACSAC’07), December 2007.

[38] L. D. Moura and N. Bjørner. Z3: an eﬃcient SMT

solver. In Proceedings of the 14th International
Conference on Tools and Algorithms for the
Construction and Analysis of Systems, 2008.

[39] G. Myles and C. Collberg. Software watermarking via

opaque predicates: Implementation, analysis, and
attacks. Electronic Commerce Research, 6(2):155 –
171, April 2006.

[40] M. N. Ngo and H. B. K. Tan. Detecting large number
of infeasible paths through recognizing their patterns.
In Proceedings of the the 6th Joint Meeting of the
European Software Engineering Conference and the
ACM SIGSOFT Symposium on the Foundations of
Software Engineering (ESEC-FSE’07), 2007.

[41] J. Palsberg, S. Krishnaswamy, M. Kwon, D. Ma,
Q. Shao, and Y. Zhang. Experience with software
watermarking. In Proceedings of the 16th Annual
Computer Security Applications Conference
(ACSAC’00), 2000.

[42] M. D. Preda, M. Madou, K. D. Bosschere, and

R. Giacobazzi. Opaque predicate detection by abstract
interpretation. In Proceedings of 11th International
Conference on Algebriac Methodology and Software
Technology (AMAST’06), 2006.

[43] N. A. Quyn. OptiCode: Machine code deobfuscation

for malware analysis. In Proceedings of the 2013
SyScan, 2013.

[44] P. Szor. The Art of Computer Virus Research and

Defense. Addison-Wesley Professional, February 2005.

[45] S. K. Udupa, S. K. Debray, and M. Madou.

Deobfuscation: Reverse engineering obfuscated code.
In Proceedings of the 12th Working Conference on
Reverse Engineering (WCRE’05), 2005.

[46] C. Wang, J. Hill, J. C. Knight, and J. W. Davidson.

Protection of software-based survivability mechanisms.
In Proceedings of the 2001 International Conference
on Dependable Systems and Networks (DSN’01), 2001.

[47] S. Wang, P. Wang, and D. Wu. Reassembleable

disassembling. In Proceedings of the 24th USENIX
Security Symposium (USENIX Security’15), 2015.

[48] Z. Wang, J. Ming, C. Jia, and D. Gao. Linear
obfuscation to combat symbolic execution. In
Proceedings of the 2011 European Symposium on
Research in Computer Security (ESORICS’11), 2011.
[49] F. Zhang, D. Wu, P. Liu, and S. Zhu. Program logic

based software plagiarism detection. In Proceedings of
the 25th IEEE International Symposium on Software
Reliability Engineering (ISSRE’14), 2014.

768