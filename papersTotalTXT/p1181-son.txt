Diglossia: Detecting Code Injection Attacks

with Precision and Efﬁciency

Sooel Son

The University of Texas at
samuel@cs.utexas.edu

Austin

Kathryn S. McKinley

Microsoft Research

The University of Texas at

Austin

mckinley@cs.utexas.edu

Vitaly Shmatikov

The University of Texas at
shmat@cs.utexas.edu

Austin

ABSTRACT
Code injection attacks continue to plague applications that incor-
porate user input into executable programs. For example, SQL in-
jection vulnerabilities rank fourth among all bugs reported in CVE,
yet all previously proposed methods for detecting SQL injection
attacks suffer from false positives and false negatives.

This paper describes the design and implementation of DIGLOS-
SIA, a new tool that precisely and efﬁciently detects code injec-
tion attacks on server-side Web applications generating SQL and
NoSQL queries. The main problems in detecting injected code
are (1) recognizing code in the generated query, and (2) determin-
ing which parts of the query are tainted by user input. To recog-
nize code, DIGLOSSIA relies on the precise deﬁnition due to Ray
and Ligatti. To identify tainted characters, DIGLOSSIA dynami-
cally maps all application-generated characters to shadow charac-
ters that do not occur in user input and computes shadow values for
all input-dependent strings. Any original characters in a shadow
value are thus exactly the taint from user input.

Our key technical innovation is dual parsing. To detect injected
code in a generated query, DIGLOSSIA parses the query in tandem
with its shadow and checks that (1) the two parse trees are syntacti-
cally isomorphic, and (2) all code in the shadow query is in shadow
characters and, therefore, originated from the application itself, as
opposed to user input.

We demonstrate that DIGLOSSIA accurately detects both SQL
and NoSQL code injection attacks while avoiding the false posi-
tives and false negatives of prior methods. By recasting the prob-
lem of detecting injected code as a string propagation and parsing
problem, we gain substantial improvements in efﬁciency and pre-
cision over prior work. Our approach does not require any changes
to the databases, Web servers, or Web browsers, adds virtually un-
noticeable performance overhead, and is deployable today.
Categories and Subject Descriptors Security and
privacy — Intrusion/anomaly detection and malware mitigation —
Intrusion detection systems
Keywords Web application security; Dynamic analysis; Code
injection; SQL injection; NoSQL injection; Taint tracking

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’13, November 4–8, 2013, Berlin, Germany.
Copyright 2013 ACM 978-1-4503-2477-9/13/11 ...$15.00.
http://dx.doi.org/10.1145/2508859.2516696.

1.

INTRODUCTION

Diglossia /d¯I" glˆos¯e@/ noun
A situation in which two languages (or two varieties of the same
language) are used under different conditions within a community,
often by the same speakers.

Oxford Dictionaries

Modern Web applications accept input from users and incorporate
it into dynamically generated code. For example, a Web application
may invite the user to ﬁll a form, post a comment, or submit a user-
name and password for authentication. The application then takes
this user-provided input and inserts it into a dynamically gener-
ated program in another language—for example, a new client-side
script, or an SQL or JavaScript query to a back-end database.

A code injection attack occurs when a malicious user manages
to inject his own code into the program generated by the applica-
tion. Injected code may steal data, compromise database integrity,
and/or bypass authentication and access control, violating system
correctness, security, and privacy properties.

Database queries generated by server-side Web applications are
a classic target of code injection. For example, SQL injection at-
tacks on retail stores owned by TJX Companies compromised more
than 45 million credit and debit numbers in 2005-2007 [23]. SQL
injection vulnerabilities still rank fourth among all reported CVE
bugs [4], and, according to the 2012 WhiteHat security report, SQL
injection attacks are the eighth most prevalent attack type [25].

The recent trend towards NoSQL databases [14] is not improv-
ing the situation. Many NoSQL databases, including MongoDB,
CouchDB, and DynamoDB, use JSON and/or JavaScript as query
languages, but this does not help protect NoSQL-based applica-
tions from code injection attacks. In 2010, Diaspora reported a se-
rious NoSQL injection vulnerability in its social community frame-
work [15]. Code injection attacks on JavaScript queries for Mon-
goDB were demonstrated at Black Hat 2011 [21].

By deﬁnition, a code injection attack on a Web application in-
volves tainted code: the application generates a string that is inter-
preted as an executable program (e.g., an SQL or NoSQL query),
and the string contains user input that is interpreted as code when
the program executes. Preventing code injection attacks therefore
requires precisely determining (1) which parts of the generated
string are code, and (2) which parts of the generated string are
tainted by user input.

All prior approaches to runtime detection of code injection at-
tacks suffer from two types of problems. They either fail to pre-
cisely deﬁne what constitutes code, or their taint analysis algo-
rithm does not identify exactly which characters in the application-
generated string originate from user input and which originate from

1181the application itself. Errors of both types lead to false positives
(benign queries rejected) and false negatives (code injection attacks
accepted as valid queries).
Our contributions. We design, implement, and evaluate DIGLOS-
SIA, a new runtime tool that precisely and efﬁciently detects code
injection attacks. The key idea behind our approach is to transform
the problem of detecting injected code into a string propagation and
parsing problem.

In tandem with the application computing its output string,
DIGLOSSIA computes a shadow of this string. The purpose of
the shadow is to identify user input in the application-generated
string. In the shadow string, all characters introduced by the ap-
plication itself are remapped to a shadow character set, which is
disjoint from all characters in user input; the shadow value thus pre-
cisely encodes which characters came from user input and which
came from the application. To precisely identify code, DIGLOSSIA
relies on the deﬁnitions by Ray and Ligatti [17]. DIGLOSSIA uses
a novel dual parsing technique to compare the shadow string with
the actual string generated by the application and ensure that the
actual string does not contain any code tainted by user input.

Our basic approach is language-agnostic and does not depend
on the details of the language used to implement the application,
nor the target language of the generated string. For concreteness,
our DIGLOSSIA prototype works with server-side PHP applications
generating database queries in SQL, JSON, or JavaScript. Conse-
quently, we use the term query for the generated string.
Deﬁning code injection attacks.
Ray and Ligatti show that
deﬁning code simply as pre-speciﬁed keywords and operators does
not provide a clear distinction between code and non-code.
In-
stead, precisely identifying code and non-code requires parsing the
query [17].

Following Ray and Ligatti, only values (numeric and string liter-
als) and reserved values (NULL, TRUE, etc.) are non-code. Code
comprises all reserved keywords, operators, and method calls, as
well as all uses of bound identiﬁers (variables, types, and method
names). Note that this deﬁnition forbids the dangerous program-
ming practice where certain user inputs are intended by a developer
to be interpreted as code in the query. In the absence of strict access
control on database operations, this practice may lead to arbitrary
code execution and should be deprecated.

With their deﬁnition of code and non-code in hand, Ray and Lig-
atti show that all prior approaches for detecting code injection suf-
fer from false negatives and false positives. They illustrate these
inaccuracies with 11 SQL injection attacks and non-attacks, which
are explained in detail in Section 3.1 and summarized in Table 1.
For example, the attack in Case 5 injects a call to a bound method.
All prior approaches miss this attack, but DIGLOSSIA detects it.
On the other hand, Case 7 shows how a use of a reserved literal
(TRUE) causes at least one prior tool to report a false positive
whereas DIGLOSSIA correctly classiﬁes this case.
Value shadowing. To identify taints efﬁciently, DIGLOSSIA dy-
namically creates a shadow string for each query issued by the ap-
plication P . In the shadow query, all application-generated parts
use shadow characters, while all tainted parts—i.e., substrings orig-
inating from user input—use original characters.

When P is invoked, DIGLOSSIA dynamically generates a set of
shadow characters that occur in neither user input, nor the query
language. DIGLOSSIA then creates a one-to-one map from each
character used by the query language to a unique shadow character.
As P executes, DIGLOSSIA computes shadow values for all
strings computed by P that depend on user input. DIGLOSSIA
follows the control ﬂow of P ’s execution and performs shadow

operations only on input-dependent string and character array op-
erations. In a shadow string, all characters c originating from P
are remapped to shadow characters sc where sc = map(c), while
all characters originating from user input remain intact. Value
shadowing is a precise, lightweight way to propagate character-
level taint information. We implement this functionality as a PHP
interpreter extension that dynamically remaps characters and com-
putes shadow values in tandem with the string and character array
operations performed by P .
Dual parsing. To guarantee that the query issued by the applica-
tion P does not contain injected code, it is sufﬁcient to ensure the
following two properties. First, the shadow query must not contain
injected code (technically, the code in the shadow query must not
be tainted by user input). Second, the actual query must be syntac-
tically isomorphic to the shadow query.

When P issues a query, DIGLOSSIA examines this query and its
shadow using a dual parser. Dual parsing is the key technical inno-
vation in DIGLOSSIA. For any string accepted by the original query
language, the dual parser accepts the same string, as well as strings
in which the original characters are replaced with their correspond-
ing shadow characters. DIGLOSSIA examines the parse trees of
the actual query and its shadow and establishes the following two
conditions:

1. There is a one-to-one mapping between the parse tree of the ac-
tual query and the parse tree of the shadow query. In particular,
all code in the actual query maps exactly to equivalent code in
the shadow query.

2. The shadow query does not contain any code in the original

language L.

If either condition does not hold, DIGLOSSIA reports a code injec-
tion attack. Intuitively, the presence of any original-language code
in the shadow query and/or any syntactic difference between the
actual query and its shadow indicate a code injection attack.
Evaluation and deployability. We demonstrate the precision
and efﬁciency of DIGLOSSIA on 10 open-source PHP Web ap-
plications that issue queries to relational MySQL and MongoDB
NoSQL back-end databases. DIGLOSSIA detects all 25 code in-
jection attacks we attempted against these applications with no
perceptible performance overhead.

Unlike prior tools, DIGLOSSIA correctly classiﬁes 10 out of 11
challenging cases described by Ray and Ligatti [17]—see Table 1.
The sole exception is the case where user input is a number speci-
fying how many objects of a certain type to allocate. Even though
Ray and Ligatti classify this case as code injection, this is a matter
of opinion. We instead classify all integer literals in SQL type def-
initions as values—for example, 64 in CHAR(64) [22]. Therefore,
DIGLOSSIA does not report Case 10 in Table 1 as a code injection.
By recasting the problem of detecting code injection attacks as
a string propagation and parsing problem, we gain substantial im-
provements in efﬁciency and precision over prior work. DIGLOS-
SIA uses shadow values only to detect injected code and does not
actually submit shadow queries to the database. Therefore, in con-
trast to SQL keyword randomization [2] and complementary en-
coding [11], DIGLOSSIA does not require any changes to Web ap-
plications, databases, query parsers, Web servers, or Web browsers.
Unlike these tools, DIGLOSSIA can be deployed today.

2. RELATED WORK
This section compares our approach with prior techniques for stat-
ically detecting SQL injection vulnerabilities in Web applications

11823
Ray and Ligatti’s deﬁnition of code injection [17] Yes Yes Yes
Halfond et al. [5], Nguyen-Tuong et al. [13] Yes Yes Yes
Xu et al. [26] Yes Yes Yes

1

2

Tools

9

8

7

5

4

10
6
No Yes Yes Yes
No Yes Yes
No
No
No
No
No
No
No
No Yes
No
No
No Yes
No Yes Yes

No
No
No
No
No Yes Yes

11
No
No Yes
No Yes
No
No
No Yes
No
No

No
No
No
No

No
No
No
No

SQLCHECK [20] Yes

No

CANDID [1] Yes Yes Yes
DIGLOSSIA Yes Yes Yes

1
2
3
4
5
6

SELECT bal FROM acct WHERE pwd=‘’ OR 1=1 - -’
SELECT balance FROM acct WHERE pin= exit()
...WHERE ﬂag=1000 > GLOBAL
SELECT * FROM properties WHERE ﬁlename=‘f.e’
...pin=exit()
...pin=aaaa()

7
8
9
10
11

SELECT * FROM t WHERE ﬂag=TRUE
SELECT * FROM t WHERE ﬂag=aaaa
SELECT * FROM t WHERE ﬂag=password
CREATE TABLE t (name CHAR(40))
SELECT * FROM t WHERE name=‘x’

Table 1: Canonical code injection attacks and non-attacks misclassiﬁed by prior methods. Underlined terms are user input.

and dynamically detecting attacks exploiting these vulnerabilities.
In Section 3, we explain Ray and Ligatti’s examples shown in Ta-
ble 1 and why prior methods misclassify between 5 and 8 of these
11 examples.
Static methods. Static methods use pointer and taint analysis to
ﬁnd unsanitized data ﬂows from user input to database queries [6,9,
19]. These methods can verify that a sanitization routine is always
called on tainted inputs, but not whether sanitization is performed
correctly. Since incorrectly sanitized input may cause an injection
attack, it is essential to precisely model the semantics of string op-
erations performing sanitization. Wassermann and Su model string
operations as transducers and check whether non-terminals in the
query are tainted by user input [24]. Static dataﬂow analysis must
be conservative, thus static methods inevitably suffer from false
positives.
Dynamic methods. Most dynamic methods aim to precisely track
the source of every byte and thus determine which parts of the
query come from tainted user input and which come from the ap-
plication itself [3, 5, 13, 16, 26]. All of these tools use a simple,
imprecise deﬁnition of “code” and consequently suffer from false
positives and false negatives (see Table 1).

To avoid the expense of byte-level taint tracking, several dy-
namic methods modify and examine inputs and generated queries.
For example, Su and Wassermann wrap user input with meta-
characters, propagate meta-characters through string operations in
the program, parse the resulting query, and verify that if a meta-
character appears in the parse tree, then it is in a terminal node and
has a parent non-terminal such that the meta-characters wrap the
descendant terminal nodes in their entirety [20]. This approach suf-
fers from false positives and false negatives because how to wrap
input (e.g., the entire input string, each word, and/or each numeric
value) depends on the application generating the query.

To infer the tainted parts of the query, Sekar proposes to mea-
sure similarity between the query and user input [18], while Liu et
al. compare the query to previous queries generated from benign
inputs [8]. In addition to being unsound, these heuristics do not use
a precise deﬁnition of code and non-code and thus suffer from false
positives and false negatives.

CANDID performs a shadow execution of the program on a be-
nign input “aaa. . . a”, compares the resulting query with the actual
query, and reports a code injection attack if the queries differ syn-
tactically [1]. As Ray and Ligatti point out, this analysis is insufﬁ-
cient to differentiate code from non-code [17]. Furthermore, CAN-

DID cannot tell which parts of the query came from user input and
which came from the application itself, and thus cannot detect in-
jected identiﬁers (where user input injects a bound variable name
that occurs elsewhere in the query), injected method invocations,
and incorrect types of literals—see examples in Section 3.3.
Randomization and complementary encoding. To prevent injec-
tion of SQL commands, SQLrand remaps SQL keywords to secret,
hard-to-guess values [2]. Applications must be modiﬁed to use the
remapped keywords in the generated queries, and database middle-
ware must be modiﬁed to decrypt them back to original keywords.
The mapping must remain secret from all users. This approach
requires pervasive changes to applications and database implemen-
tations and is thus difﬁcult to deploy.

Mui et al. suggest using complementary encoding for user in-
put [11]. The goal is to strictly separate the character set appearing
in user input from the character set used by the system internally.
This approach cannot be deployed without changing databases,
Web browsers, and all other systems dealing with user input.

In contrast, DIGLOSSIA is a simple PHP extension that does not

require any modiﬁcations to applications or databases.

3. EXAMPLES OF CODE INJECTION
This section gives examples of SQL, NoSQL, and syntax mimicry
code injection attacks.
3.1 SQL injection attacks
We illustrate SQL injection attacks using 11 canonical examples
described by Ray and Ligatti [17]. Table 1 shows how ﬁve prior
tools and DIGLOSSIA classify these cases. Underlined terms are
user input. Below, we review each attack and non-attack on this list
and explain how DIGLOSSIA improves over prior work.

1. SELECT bal FROM acct WHERE pwd=‘’ OR 1=1 - -’

This case is the classic SQL injection attack with a backquote
that ends a string and injects user input as code into the query.
All tools detect this code injection. DIGLOSSIA detects it be-
cause the injected code “OR”, “=”, and “-” appears in original
characters in the shadow query.

2. SELECT balance FROM acct WHERE pin= exit()

User input injects exit(), which is a built-in function call.
SQLCHECK misclassiﬁes this case because the function call
is an ancestor of complete leaf nodes (injected) in the query’s
parse tree. DIGLOSSIA detects this injection because exit is a

1183bound variable (and, therefore, code), yet appears in original
characters in the shadow query.

3. ...WHERE ﬂag=1000>GLOBAL

The injected “>” is code that SQLCHECK misses because,
again,
this input is correctly positioned in the parse tree.
DIGLOSSIA detects it because > is code, yet appears in original
characters in the shadow query.

4. SELECT * FROM properties WHERE ﬁlename=‘f.e’

Even if f.e is an object reference, the quotes enforce its interpre-
tation as a string. SQLCHECK strips off quotes and misclas-
siﬁes f.e as a reference, generating a false positive. All other
tools, including DIGLOSSIA, correctly classify this input as a
string literal and not an injection.

5. ...pin=exit()

All tools except DIGLOSSIA miss the injection of the exit
identiﬁer because they do not reason about bound names at
all. DIGLOSSIA detects code injection because exit is bound
(and, therefore, code), yet appears in original characters in the
shadow query.

6. ...pin=aaaa()

When the identiﬁer is undeﬁned, only DIGLOSSIA correctly de-
tects code injection.

7. SELECT * FROM t WHERE ﬂag=TRUE

Since the injected TRUE is a literal value, this case is not an
attack. CANDID incorrectly classiﬁes this input as code injec-
tion because the TRUE literal is parsed to a different terminal
than the benign input “aaaa”, which is parsed to an identiﬁer.
DIGLOSSIA correctly parses this input as a literal in both the
actual query and its shadow, and does not report an attack.

8. SELECT * FROM t WHERE ﬂag=aaaa

This attack injects a bound identiﬁer (equal to the benign input
used by CANDID) into the query.
It is missed by all prior
methods. DIGLOSSIA detects code injection because aaaa is
bound (and, therefore, code), yet appears in original characters
in the shadow query.

9. SELECT * FROM t WHERE ﬂag=password

This attack injects a bound identiﬁer into the query and is
missed by all prior methods. DIGLOSSIA detects code injec-
tion because password is bound (and, therefore, code), yet
appears in original characters in the shadow query.

10. CREATE TABLE t (name CHAR(40))

DIGLOSSIA does not detect this case as code injection. Unlike
Ray and Ligatti, we consider integer literals, even in SQL type
deﬁnitions, to be values, thus this case is not an injection attack
from our viewpoint.

11. SELECT * FROM t WHERE name=‘x’

Since the injected ‘x’ is a string literal, this case is not an attack.
CANDID uses ‘aaa’ instead of ‘x’ in the shadow execution;
they are different terminals and CANDID incorrectly reports
a code injection attack. Xu et al. classify this case as an attack
because tainted meta-characters (quotes) appear in the query.
Halfond et al. also classify this case as an attack because quotes
do not come from a trusted source. DIGLOSSIA, on the other
hand, parses ‘x’ into a literal in both the actual query and its
shadow, and correctly does not report an attack.

3.2 NoSQL injection attacks
Modern Web applications are increasingly using NoSQL back-
end data stores instead of relational SQL databases. NoSQL is a
new class of distributed, scalable databases [14] that store data in

mongodbadmin.php

( ! $document ) {

$document = findMongoDbDocument ( $_REQUEST [ ' s e a r c h ' ] ,
true ) ;

$_REQUEST [ ' db ' ] , $_REQUEST [ ' c o l l e c t i o n ' ] ,

$customId = true ;

. . .
f u n c t i o n findMongoDbDocument ( $id , $db , $ c o l l e c t i o n ,

$ f o r c e C u s t o m I d = f a l s e )

1 <?
. . .
2
i f
3
4

5
6 }
7
8

9 {
10
11

12
13
14
15 }
. . .
16
17 ?>

g l o b a l $mongo ;
$ c o l l e c t i o n = $mongo−>s e l e c t D B ( $db )−> s e l e c t C o l l e c t i o n

( $ c o l l e c t i o n ) ;

. . .
$document = $ c o l l e c t i o n −>findOne ( array ( ' _ i d ' => $ i d ) ) ;
. . .

Attack URL

http://victimHost/mongodbadmin.php?search[$ne]=1&db=test&collection=test

Figure 1: JSON injection vulnerability.

key-value pairs. NoSQL databases include Amazon’s DynamoDB,
MongoDB, CouchDB, and several others. For example, MongoDB
is an open-source, document-oriented NoSQL database that sup-
ports JSON and JavaScript as query languages. It has been adopted
by Craigslist, Foursquare, and other popular Web services [10].

NoSQL databases are as vulnerable to code injection attacks as
SQL databases. For example, we found four PHP MongoDB-based
applications in GitHub with injection vulnerabilities.

Figure 1 shows a PHP application with a JSON injection vul-
nerability. Line 13 of mongodbadmin.php in Figure 1 builds
an array consisting of a single key-value pair, where the key
is “_id” and the value is equal to the user input obtained from
$_REQU EST [‘search’]. The Mongo API transforms this array
into a JSON query and sends it to MongoDB. The intention is to re-
turn all database items whose _id ﬁeld is equal to the user-supplied
value.

A malicious user, however, can set the search variable to be an
array value, array($ne => 1). In the resulting JSON query, line
13 of Figure 1 no longer compares _id for equality with $id, but
instead interprets the ﬁrst element of $id as a function, $ne, the
second element, 1, as the argument to this function, and returns all
database items whose _id is not equal to 1. In this case, user input
is supposed to be a string constant, but instead symbols $ne are
interpreted as code in the query.

Figure 2 shows another vulnerable PHP application. Lines 3 to
18 build a query string from user input, Line 21 sends the resulting
JavaScript program to MongoDB. MongoDB evaluates this pro-
gram on every key-value pair in the database and returns the pairs
on which the program evaluates to “true”.

The query is supposed to retrieve data whose privilege keys are
the same as userType. The malicious URL, however, tricks the
application into generating a tautology query, which always returns
“true”. Note that user-injected symbols ;, return, }, and // are
parsed into code in the JavaScript query:

f unction q(){ var def ault_user = ‘normal(cid:48);
var admin_passwd = ‘guessme(cid:48);
var userT ype = 1; return true;}//....

1184vulfquery.php

f u n c t i o n q u e r y from u s e r

i n p u t

/ / B u i l d a J a v a S c r i p t

f u n c t i o n q ( ) {

1 <?
2
3 $query_body = "
4
5
6
7
8
9

v a r d e f a u l t _ u s e r = ‘ normal ’ ;
v a r admin_passwd = ‘ guessme ’ ;
v a r userType = "
v a r userPwd = "
i f ( userType == ‘ _admin_ ’ && userPwd == admin_passwd

. $_GET [ ‘ u s e r ’ ]
. $_GET [ ‘ passwd ’ ]

" ;
" ;

.

.

login.php in minibill

1 <?
2 $Q = "SELECT * FROM u s e r s
3
4
5
6 $ r e s = mysql_query ( $Q ) ;
7 ?>

WHERE e m a i l = ‘{$_REQUEST [ ‘ e m a i l ’ ] } ’
AND password = ‘{$_REQUEST [ ‘ password ’ ] } ’
LIMIT 1 " ;

http://victimHost/login.php?email=no\&password=AND others=‘any

Attack URL

)

e l s e

userType = ‘ admin ’ ;

userType = ‘ normal ’ ;

i f (

t h i s . s h o w p r i v i l e g e == userType )

r e t u r n t r u e ;

e l s e

r e t u r n f a l s e ;

10
11
12
13
14
15
16
17
18
19
20

} " ;

. . . .
/ /

22
23 ?>

Actual query
SELECT
users
password=’ AND others=‘any’ LIMIT 1

FROM

*

WHERE

email=‘no\’

AND

Query on a benign input

SELECT * FROM users WHERE email=‘aaa’ AND password=‘aaaaaaaaaaaaaaaa’
LIMIT 1

) ;

Figure 4: SQL syntax mimicry attack on minibill.

reset_password_save.php in phpAddressBook 8.2.5

I n i t i a t e a f u n c t i o n q u e r y

21 $ r e s u l t = $ c o l l e c t i o n −>f i n d ( array (

‘ $where ’ => $query_body )

Attack URL

http://victimHost/vulfquery.php?user=1;return true;}//

Figure 2: JavaScript injection vulnerability.

3.3 Syntax mimicry attacks
The query containing injected code need not be syntactically dif-
ferent from a benign query (we call such injections syntax mimicry
attacks). Consequently, detection tools such as CANDID that look
for syntactic discrepancies between the actual query and the query
on a benign input will miss some attacks.

vulnerable.php

1 <?
2

/ / B u i l d a J a v a S c r i p t q u e r y

t h a t

c h e c k s w h e t h e r pwd

f i e l d i s

t h e same as u s e r

i n p u t $_GET [ ’ i d ’]

s e c r e t _ n u m b e r = t h i s . pwd ; " ;
. $_GET [ ‘ i d ’ ]

3
4 $query = " f u n c t i o n q ( ) { " ;
5 $query . = " v a r
6 $query . = " v a r u s e r _ t r y = ’
7 $query . = " i f
8 $query . = " r e t u r n t r u e ; " ;
9 $query . = " } " ;
10
11 $ c o l l e c t i o n −>f i n d ( array ( ‘ $where ’ => $query ) ) ;
12 ?>

( s e c r e t _ n u m b e r != u s e r _ t r y )

.

‘ ; " ;

r e t u r n f a l s e ; " ;

Attack URL

http://victimHost/vulnerable.php?id=secret_number

Figure 3: JavaScript syntax mimicry attack.

Figure 3 shows sample PHP code that builds a JavaScript query
for a MongoDB. User input in $_GET [‘id’] is supposed to be a
numeric literal. If the attacker inputs secret_number instead of
a number, the query will return “true”, sabotaging the intended se-
mantics. CANDID will use “aaaaaaaaaaaa” as the benign input for
secret_number in its shadow execution and miss the attack, but
DIGLOSSIA will detect it.

Figure 4 shows login.php in minibill, an actual PHP program
vulnerable to syntax mimicry attacks. The attack URL makes the
syntactic structures of the actual and shadow queries equivalent.

1 <?
2 $ p a s s w o r d _ h i n t = $_REQUEST [ ‘ p a s s w o r d _ h i n t ’ ] ;
3 $ e m a i l =$_REQUEST [ ‘ e m a i l ’ ] ;
4
5
6 $query = "UPDATE u s e r s SET password = ‘ $cleanpw ’ ,

. . .
/ / Assume t h a t $cleanpw i s

" a r b i t r a r y "

p a s s w o r d _ h i n t = ‘ $ p a s s w o r d _ h i n t ’ WHERE e m a i l = ‘ $ e m a i l
’ " ;

7
8 $ r e s = mysql_query ( $query ) ;
9 ?>

Attack URL exploiting CVE-2013-0135

http://victimHost/login.php?password_hint=no\&email=WHERE zip=‘77051

UPDATE users SET password=‘arbitrary’,
email=’ WHERE zip=‘77051’

password_hint=‘no\’ WHERE

Actual query

Query on a benign input

UPDATE users SET password=’arbitrary’,
email=’aaaaaaaaaaaaaaaaa’

password_hint=’aaa’ WHERE

Figure 5: SQL syntax mimicry attack on phpAddressBook.

Observe, however, that the attack query refers to the others ﬁeld
instead of the intended password ﬁeld. This particular attack may
not seem damaging, but if the actual query had used OR instead of
AND, the attack would have been much more serious.

Figure 5 shows another PHP program with an injection vulnera-
bility (CVE-2013-0135). The attack URL results in this query re-
setting the passwords of users whose ZIP code is 77051. DIGLOS-
SIA can detect syntax mimicry attacks such as this one because,
unlike CANDID, it creates shadow queries from the same input
as the actual execution. The syntactic structures of the actual and
shadow queries are equivalent, but the shadow contains the code
“WHERE” in original characters (since it originated from user in-
put). Therefore, DIGLOSSIA reports an attack.

4. DESIGN AND IMPLEMENTATION
DIGLOSSIA is as an extension to the PHP interpreter. It is imple-
mented in C using PECL (PHP Extension Community Library).
The Web server invokes the interpreter automatically when the
URL hosting a PHP application is accessed.

DIGLOSSIA has has three phases, as depicted in Figure 6 and

described below.

1185Figure 6: Overview of DIGLOSSIA.

Phase I creates a shadow character map and the dual parser.
Phase II computes a shadow value for each string that depends on

user input.

Phase III detects injected code by examining and comparing the

actual query string and its shadow.

Phase I creates a map from all characters c in the query language
L to a disjoint set of shadow characters SC = {map(c)}. Phase I
also creates the dual parser for the shadow language SL, which is
a superset of L and described in more detail in Section 4.3.

In tandem with the execution of the application, Phase II creates
and computes shadow values for all strings and array operations
that depend on user input. When the Web server invokes a PHP
application, DIGLOSSIA creates a shadow string value for each in-
put string, exactly equal to that string. Therefore, at the beginning
of the execution, all shadow values consist only of original char-
acters. For every subsequent string or character array computation
where one or both operands already have shadow values, DIGLOS-
SIA computes the shadow value for the result of the operation. If

an operand does not have a shadow value, DIGLOSSIA creates a
shadow value for it by remapping each character to the correspond-
ing shadow character. This remapping guarantees that all charac-
ters introduced by the application itself are in the shadow character
set, regardless of whether they appear in the application as explicit
constants, come from a library, or are generated dynamically.

When the PHP application issues a query q, Phase III intervenes
and checks whether the query includes injected code. To this end,
DIGLOSSIA parses q and its shadow q(cid:48) with the dual parser and
checks the following two conditions.
First, there must exist a one-to-one mapping between the nodes
in the respective parse trees of q and q(cid:48). Furthermore, each parse
tree node in q(cid:48) must be a shadow of the corresponding node in q, as
deﬁned in Section 4.3. For instance, a string literal node in q must
map to a string literal node in q(cid:48), except that the string in q only uses
characters in C, whereas the string in q(cid:48) may use characters in C ∪
SC. This isomorphism condition ensures that shadow characters
in the shadow query correspond exactly to the untainted characters
in the actual query.

Malicious Inputid = “12; return true;//”DiglossiaPHP script...$q = “var id = “ . $_GET[‘id’] . “;”;$q .= “if(this.id == id) return true”;$q .= “else return false”;…$collection->find( array(“$where” => $q ) );Mapping Table (CT)  A => 가  I => 나  F => 다  …Original Parser (P)   IF   ELSE   DO  … Dual Parser (PCT)   IF, 나다    ELSE, 마바사마      DO, 아자    … Original values  $q =“var id =”. “12;return true;// ” . “;”;  $q .= “if(this.id == id ) return true;”  $q .= “else return false;”Shadow values $q_s=“이가영 타아 는”. “12;return true;// ” . “끝”; $q_s=“나다 괄티카타사점나아 는는 나아괼           영마티유영엔 티영유마끝”; $q_s=“마바사마 영마티유영엔 다가바사마끝”;  rootstmt 1varid=12returntrue;;stmt 2comment 1;if(this.id …//rootstmt 1이가영타아는12returntrue;;stmt 2comment 1끝 나다 …  //code injection!Phase II. Value shadowingPhase I. Prepare a character mapping table and a dual parserPhase III. Validate queriesActual query parse treeShadow query parse treePHP interpreter1186Second, all code in the shadow query q(cid:48) must use only the char-

acters in SC, because all characters in C come from user input.

If both conditions are satisﬁed, DIGLOSSIA passes the original
query q to the back-end database. Otherwise, DIGLOSSIA stops the
application and reports a code injection attack.
4.1 Character remapping
We implemented character remapping and dual parsing for SQL,
JSON, and JavaScript query languages. These languages use
ASCII characters, found on standard English keyboards, for all
keywords, numerals, identiﬁers (variables, types, method names,
etc.) and special values (NULL, TRUE, etc.). Although the lan-
guages are different and DIGLOSSIA has a separate parser for each,
we use the term “query language L” generically to simplify the
exposition.

Let C be the subset of ASCII characters consisting of the lower-
and upper-case English alphabet and special characters (DIGLOS-
SIA does not remap digits). Formally, C includes characters whose
decimal ASCII codes are from 33 to 47 and from 58 to 126.
DIGLOSSIA dynamically creates a one-to-one mapping from each
character in C to a shadow UTF-8 character that occurs in neither
C, nor user input. Observe that since L uses only characters from
C, no shadow characters appear in code written in L.

UTF-8 is a variable-byte representation that uses one to four 8-bit
bytes to encode characters. The total number of UTF-8 characters
is 1,112,064 and it is easy to ﬁnd 84 characters among them that do
not occur in user input. In our current implementation, every web-
page request (i.e., every invocation of a PHP application) results in
a different random map. To create this map, DIGLOSSIA (1) ran-
domly selects two-byte shadow characters from among 1,112,064
possible UTF-8 characters, and (2) examines all variables holding
user input (e.g., P OST , GET , and COOKIE) to ensure that
shadow characters do not occur in them.

It is also possible to pre-compute a set of random mappings of-

ﬂine to reduce runtime overhead.
4.2 Value shadowing
As the application executes, DIGLOSSIA computes shadow values
for the results of all string and character array operations that de-
pend on user input. Because DIGLOSSIA is implemented using
PECL, it can directly manage memory and monitor program state-
ments during the application’s execution.

DIGLOSSIA allocates shadow values on the heap and stores their
addresses in the shadow value table indexed by the address of the
memory location for the original value. For operations that do
not involve user input, including all non-string, non-array opera-
tions, conditionals, branches, arithmetic operations, etc., DIGLOS-
SIA performs no computations or allocations. Therefore, the con-
trol ﬂow of value shadowing follows the control ﬂow of the appli-
cation.

When a Web server invokes the PHP application, it passes in
user inputs as strings. DIGLOSSIA allocates a shadow value for
each input string, equal to the string itself, and adds this value to
the shadow value table. If the application reads in additional user
input, DIGLOSSIA repeats this process. These initial shadow values
contain only characters from the original character set C.

Whenever the application performs a string or character array
operation lhs = operation(op1, op2) where one or both operands
(op1 and op2) already have shadow values—and, therefore, the op-
eration is data-dependent on user input—DIGLOSSIA computes the
shadow value shadowlhs for the result as follows.

If one operand op does not already have a shadow value, DIGLOS-
SIA allocates a new shadow value and remaps each character in

op to the corresponding shadow character, creating shadowop.
Given individual characters ci ∈ op, shadowop = map(c0) || . . .||
map(cn−1) where n is the length of op. This remapping guaran-
tees that all characters introduced by the application itself are in
the shadow character set, regardless of whether they appear in the
application as explicit string literal constants, come from libraries,
or are generated dynamically. DIGLOSSIA then computes

shadowlhs = operation(shadowop1,shadowop2).

If lhs does not have an entry in the shadow value table, DIGLOS-
SIA allocates a shadow value and enters it in the table. DIGLOSSIA
shadows built-in PHP string and array operations. Built-in PHP
string operations include string trim, string assignment, substring,
concatenation, and replacement. Built-in PHP array operations in-
clude array merge, push, pop, and assignment.

Memory for shadow values is proportional to memory tainted by
user input, and shadow computations are proportional to the num-
ber of program statements that depend on user input. The num-
ber of lookups for taint information is signiﬁcantly smaller than in
byte-level taint tracking methods. In value shadowing, the number
of lookups is the same as the number of involved values; in contrast,
the number of lookups in precise byte- and character-level taint
tracking methods is proportional to the byte or character length
of every value. Furthermore, ﬁne-grained taint tracking methods
require heavy augmentation of built-in operations on strings and
bytes to precisely propagate taint information. In contrast, value
shadowing performs only the same string and array operations on
shadow values as the application performs on the actual values.

Figure 6 shows an overview of our approach,

in which we
remap ASCII characters into Korean characters and use the lat-
ter to compute shadow values. In Figure 6, the assignment $q =
“var id = ”.“12; return true; //”.“; ”; concatenates string
constants with user input. We compute the shadow value as
$qs = map(“var id = ”).“12; return true; //”.map(“; ”);.
Observe that computing the shadow value involves the same con-
catenation operation on the shadow values as done in the original
application. All strings originating from user input remain the
same, but string constants introduced by the application have been
remapped to (in this case) Korean UTF-8 characters. DIGLOS-
SIA stores the resulting $qs as the shadow of q and uses it for
subsequent shadow operations.

Figure 7 illustrates how DIGLOSSIA computes shadow val-
ues. Given that $input is 150, this PHP application computes
the $SQL string to be used as the query. $SQLs is the shadow
value of $SQL. Let SOi be the shadow operation correspond-
ing to the ith line of the application (it is shown in the gray box
underneath the corresponding line). The full execution sequence
comprises lines 1, SO1, 2, SO2, 3, SO3, 4, 6, 9, SO9, 11, SO11,
12, and 13 in order. Observe that non-string, non-character-array
operations are not shadowed.

Line 13 makes the database call with the query stored in string
$SQL. In this case, $SQL has a shadow value $SQLs because
the query depends on user input.
4.3 Detecting injected code
When the application issues a query q using calls such as mysql_qu-
ery, MongoCollection::ﬁnd, or MongoCollection::remove, DIGLOS-
SIA intervenes and compares q with its shadow q(cid:48). DIGLOSSIA
checks that (1) q and q(cid:48) are syntactically isomorphic, and (2) the
code in the shadow query q(cid:48) is not tainted. If either condition fails,
it reports an attack. DIGLOSSIA performs both checks at the same
time, using a dual parser.

1187show t h e shadow o p e r a t i o n s

/ / b o x e s
1 $ i n p u t = $_GET [ ' i n p u t ' ] ;
$input_s = $_GET[‘input’];

2 $amount = $_GET [ ' amount ' ] ;
$amount_s = $_GET[‘amount’];

3 $SQL = ' CCS13SELECT * FROM ' ;
$SQL_s = map(‘CCS13SELECT * FROM ’);

( $ i n p u t < 100) {

4 i f
5

$SQL

$amount

;

= $SQL .

' s ma l l_ nu m be r s WHERE c o u n t < '

.

$SQL_s = $SQL_s . map(‘small_numbers WHERE count < ’) . $amount_s;

i f

( $ i n p u t > 200) {

6 } e l s e
7

$SQL = $SQL .
$amount

;

' l a r g e _ n u m b e r s WHERE c o u n t > '

.

$SQL_s = $SQL_s . map(‘large_numbers WHERE count > ’) . $amount_s;

8 } e l s e {
9

$SQL = $SQL .
$amount

;

' middle_numbers WHERE c o u n t < '

.

$SQL_s = $SQL_s . map(‘middle_numbers WHERE count < ’) . $amount_s;

10 }
11 $SQL = s u b s t r ( $SQL , 6 ) ;

t h e

s t a r t

/ /

t r i m f i v e

c h a r a c t e r s

from

$SQL_s = substr( $SQL_s, 6 );

12 I n t e r p o s e and
13 mysql_query ( $SQL ) ;
?>

v a l i d a t e ( $SQL , $SQL_s

) ;

Figure 7: An example of value shadowing.

Intuitively,

the purpose of the dual parser is to analyze the
shadow query using the grammar of the query language L, but
taking into account the fact that the shadow query contains a mix
of original and shadow characters. Value shadowing guarantees
that all characters in q(cid:48) that were introduced by the application are
in the shadow character set, and all characters in q(cid:48) that originate
from user input are in the original character set.

We ﬁrst formally deﬁne a new shadow language SL that is a
superset of the original query language L. We then describe how
we optimize our implementation by re-using the parser for L to
parse the shadow language SL.
Query language and grammar.
Let G = (N, Σ, R, S) be the
context-free grammar of the query language L. N is the set of
non-terminal states, representing different operations, conditionals,
expressions, etc. Σ is the set of terminal states, disjoint from N.
We will use the symbol  to refer to individual terminal states in Σ.
R is the set of production rules that express the ﬁnite relation from
N to (N ∪ Σ)∗. S ∈ N is the unique start symbol.

When the parser uses this grammar G to accept a program P , it
produces a parse tree that maps every character in P to a terminal.
Each terminal is either code or non-code. Code terminals include
operations (e.g., “+” and “-”), keywords, bound identiﬁers, and
method calls. Non-code terminals include constant literals, string
literals, and reserved symbols (NULL, TRUE, etc.).
Shadow language and grammar. Given a query language L and
its grammar G, DIGLOSSIA deﬁnes a corresponding shadow lan-
guage SL and shadow grammar SG. As described in Section 4.1,
every character c used in L has a corresponding shadow character
sc. Characters in SL are drawn from C ∪ SC, where C is the
original character set and SC is the shadow character set.

We deﬁne SG = (N, Σs, Rs, S) to be the grammar of the
shadow language SL. N and S are the same as in G. For every
terminal  ∈ Σ, there exists exactly one corresponding shadow
terminal s ∈ Σs, deﬁned as follows.

Let σ be any string accepted by . If  is an identiﬁer or string
literal, then, for each legal character c occurring in σ, the shadow
terminal s accepts c or map(c). In other words, any identiﬁer or
string literal from the original language L can be expressed in an
arbitrary mixture of original and shadow characters in the shadow
language SL. For these terminals, s accepts a superset of .

For any other terminal  in G, the corresponding shadow terminal
s accepts only σ or map(σ). In other words, any non-identiﬁer,
non-string-literal terminal in the shadow language must be ex-
pressed entirely in original characters, or else entirely in shadow
characters. For instance, if the query language L contains a “SE-
LECT” terminal, the shadow grammar will accept “map(SELECT)
* FROM table”, but not “SELEmap(CT) * FROM table”. This re-
striction immediately rules out some injection attacks even before
the security checks described below. For example, keywords that
contain both original and shadow characters will not even parse.
For each production rule ∈ R, SG has a corresponding
rules ∈ Rs. Formally, rule has the form:

rule : n → v1v2...vl where n ∈ N, v ∈ N ∪ Σ

In rules, all non-terminals are the same as in rule, while the ter-
minals s are deﬁned as above. Consider the following example,
where rules are the rules from the original grammar, and ruless
are the corresponding rules from the shadow grammar.
rules :

→SELECT _term list_exp table_exp
select_stmt
SELECT _term→SELECT
→{a|b| . . .}
identiﬁer
. . .
→SELECT _term list_exp table_exp
SELECT _term→SELECT | map(SELECT )
→{a|b| . . .|map(a)|map(b)| . . .}
identiﬁer
. . .

ruless : select_stmt

The example shows one non-terminal rule and two terminal rules.
Since select_stmt ∈ G is a non-terminal rule, it is exactly the
same in both grammars. The terminal rule for SELECT _term ∈
SG accepts both SELECT and map(SELECT ), a superset of
the original language, since SELECT is a keyword. The termi-
nal rule for identiﬁer ∈ SG accepts strings with an arbitrary mix
of original characters c and the corresponding shadow characters
map(c).

Applying these simple transformations to the original language
and parser, we create a shadow language and parser. Shadow pro-
duction rules deﬁned in this fashion do not add conﬂicts, thus the
parser for SG produces a deterministic parse tree.

Each character map requires its own shadow grammar. Since a
fresh map is dynamically generated for each page request (i.e., each
invocation of a PHP application), automatically building a new
parser for each execution would be expensive. Instead, DIGLOS-
SIA takes advantage of the fact that the non-terminals are the same
in G and SG, and there is a one-to-one correspondence between
the terminals. This enables DIGLOSSIA to re-use the parser for G
when parsing SG.

A parser is a function that chooses the next parsing state based on
the current state and the input token. If a particular token t triggers
a production rule in G (e.g., SELECT _term ∈ G in the example
above), then the remapped token ts triggers the corresponding rule
in SG (e.g., SELECT _term ∈ SG in the example above). This
feature enables DIGLOSSIA to use the same internal handle for both
t and ts, while extending the set of accepted characters. With this

1188optimization, DIGLOSSIA can use the same parsing tables for all
dynamically generated shadows of a given query language.
Using the dual parser to detect injected code. Let DP be the dual
parser that can parse query strings according to either the original
grammar G, or the shadow grammar SG deﬁned above.

Otherwise, DP compares the terminal nodes in the two parse

Given the actual query q issued by the application, DP parses
it using G and generates a parse tree T . DP then parses the cor-
responding shadow query q(cid:48) and generates a parse tree T (cid:48). If DP
cannot produce a parse tree for either q or q(cid:48), it rejects the query
and reports a code injection attack.
trees, T and T (cid:48), and checks the following two conditions:
1. For each node ti ∈ T , there exists a one-to-one mapping to t(cid:48)

i ∈
i is the shadow of ti. For example, if ti
i is the same code operator.
2. If ti parses to a code terminal, then for every character tij ∈
C, there exists a one-to-one mapping from tij to the correct
shadow character t(cid:48)
ij = map(tij), where
map is the shadow character map.

T (cid:48) and, furthermore, t(cid:48)
is a particular code operator, then t(cid:48)

ij ∈ SC such that t(cid:48)

If either condition is violated, DIGLOSSIA reports a code injection
attack.
The actual query q may only use the original characters c ∈ C
for code, whereas its shadow q(cid:48) may only use the shadow charac-
ters sc ∈ SC for code. For example, if an identiﬁer terminal  ∈ q
is generated by merging a string constant with user input, the iden-
tiﬁer terminal s ∈ q(cid:48) will contain original characters. This case is
an instance of code injection because the code of the query depends
on user input. DIGLOSSIA makes sure that all code terminals in q
come entirely from the application itself and not a single character
comes from user input.
On the other hand, the non-code in q(cid:48) may use any combination
of original and shadow characters, reﬂecting the fact that non-code
may be derived from strings originating from user input or the ap-
plication itself. For example, if the query q contains a string literal
“ab”, then “map(a)map(b)”, “amap(b)” or ‘map(a)b” can all occur
in the shadow query q(cid:48).
In summary, given the parse tree for the actual query q and the
parse tree for the shadow query q(cid:48), DIGLOSSIA checks whether
the two queries agree on code and non-code. Since all code in q(cid:48)
that comes from the application itself is in shadow characters and
all code in q(cid:48) that comes from user input is in original characters,
DIGLOSSIA checks whether q(cid:48) contains any code in original char-
acters and, if so, reports a code injection attack.
5. LIMITATIONS
DIGLOSSIA follows Ray and Ligatti’s strict deﬁnition of code and
non-code [17] which does not permit any user input to be used as
part of code in the query. If the application developer intention-
ally incorporates user input into the query code (a dangerous and
ill-advised programming practice), DIGLOSSIA will report a code
injection attack when the application is executed.

The ability to recognize and separate code and non-code in the
query string generated by the application critically depends on us-
ing the correct grammar for the query language. If the language
accepted by the database’s query parser differs from the language
accepted by DIGLOSSIA’s parser during its analysis, DIGLOSSIA
may generate both false positives (mistakenly parse a tainted part
of the query as code, even though it will not be parsed as code by
the database) and false negatives (mistakenly parse a tainted part of
the query as non-code, even though it will be parsed as code by the
database).

Applications
MongoPress
mongodb-admin
mongodb_php_basic
rockmongo
MongoTinyURL
simple-user-auth
faqforge
schoolmate
webchess
MyBB with
MyYoutube(1.0)

Database

MongoDB

MySQL

LoC Attacks Detected
0
2
1
0
1
1
1
6
12
1

35,231
555
209
11,218
60
236
1,520
7,024
5,780
108,267

0
2
1
0
1
1
1
6
12
1

Table 2: Benchmark PHP applications.

If the application passes an input-tainted string to a third-party
PECL extension or some other built-in function that is not im-
plemented in PHP, value shadowing can be incomplete because
DIGLOSSIA cannot observe the string operations inside these func-
tions.
Incomplete value shadowing may lead to false negatives
(missed attacks). Fortunately, unlike Java and C applications, PHP
applications do not use third-party libraries heavily. For example,
we did not observe any calls to third-party libraries that perform
string or array operations on user inputs in our benchmarks.

6. EVALUATION
To evaluate DIGLOSSIA, we created a test suite of ten Web ap-
plications implemented in PHP (see Table 2). Four of our bench-
mark applications use MongoDB and contain NoSQL injection vul-
nerabilities, which we found by manual inspection of the appli-
cations’ source code: mongodb_php_basic, mongodb-admin,
M ongoT inyU RL, and simple-user-auth. Two, M ongoP ress
and rockmongo, were chosen to demonstrate the performance of
DIGLOSSIA on relatively large applications. The remaining four
applications were chosen because they contain known SQL injec-
tion vulnerabilities [7, 12].

We implemented concrete attacks exploiting the known vulnera-
bilities in the benchmark applications. We also implemented con-
crete instances for all of Ray and Ligatti’s canonical cases listed in
Table 1. All experiments were performed on an Intel(R) dual core
3.30 GHz machine with 8G of RAM.

Table 2 summarizes the results of our evaluation on the ten
benchmark Web applications. The ﬁrst column lists the applica-
tions, the second column shows the back-end database each ap-
plication uses, the third column shows the size of the application.
The fourth column shows the number of different code injection
attacks we attempted against the application, while the last column
demonstrates that DIGLOSSIA successfully detected all attacks.

Figure 8 shows the time it took to build the front page of each
application, measured as the average of 50 runs with the database
cache disabled. Range bars represent 95% conﬁdence intervals.
Most interval ranges overlap, thus the performance overhead of
DIGLOSSIA is unnoticeable to the users of the application. The
numbers at the top of each bar represent overhead percentages,
computed by taking the time it took to build the page with DIGLOS-
SIA deployed and dividing it by the original page-building time.
The maximum overhead is 13%, but the actual time difference is
less than 2 ms, within the variance of the original page-building
time.

Figure 9 shows the performance overhead of DIGLOSSIA with
the database cache enabled. The overall response times are lower,
thus the overhead percentages are bigger than those in Figure 8.
However, most overhead is not statistically signiﬁcant compared to
the variation in the page-loading time.

1189servers, or Web browsers. It can be easily added to the PHP envi-
ronment and is ready to deploy today.
Acknowledgments. We are very grateful to Venkat Venkatakrish-
nan for his insightful critique of an early version of this research,
and to Jay Ligatti for his comments on a draft of this paper. This
work was partially supported by the NSF grants CNS-0746888,
CNS-0905602, SHF-0910818, CCF-1018271, and CNS-1223396.

8. REFERENCES
[1] S. Bandhakavi, P. Bisht, P. Madhusudan, and V. N.

Venkatakrishnan. CANDID: Preventing SQL injection
attacks using dynamic candidate evaluations. In CCS, 2007.

[2] S. Boyd and A. Keromytis. SQLrand: Preventing SQL

injection attacks. In ACNS, 2004.

[3] E. Chin and D. Wagner. Efﬁcient character-level taint

tracking for Java. In SWS, 2009.

[4] CVE Details.

http://www.cvedetails.com/vulnerabilities-by-types.php.

[5] W. Halfond, A. Orso, and P. Manolios. Using positive
tainting and syntax-aware evaluation to counter SQL
injection attacks. In FSE, 2006.

[6] N. Jovanovic, C. Kruegel, and E. Kirda. Pixy: A static

analysis tool for detecting Web application vulnerabilities. In
S&P, 2006.

[7] A. Kie˙zun, P. Guo, K. Jayaraman, and M. Ernst. Automatic
creation of SQL injection and cross-site scripting attacks. In
ICSE, 2009.

[8] A. Liu, Y. Yuan, D. Wijesekera, and A. Stavrou. SQLProb: A

proxy-based architecture towards preventing SQL injection
attacks. In SAC, 2009.

[9] V. Livshits and M. Lam. Finding security vulnerabilities in
Java applications with static analysis. In USENIX Security,
2005.

[10] mongoDB production deployments.

http://www.mongodb.org/about/production-deployments/.

[11] R. Mui and P. Frankl. Preventing web application injections
with complementary character coding. In ESORICS, 2011.

[12] MyYoutube MyBB Plugin 1.0 SQL Injection.

http://www.exploit-db.com/exploits/23353.

[13] A. Nguyen-Tuong, S. Guarnieri, D. Greene, and D. Evans.

Automatically hardening Web applications using precise
tainting. In SEC, 2005.

[14] NoSQL. http://nosql-database.org/.
[15] NoSQL injection attack on Diaspora.

http://www.kalzumeus.com/2010/09/22/security-lessons-
learned-from-the-diaspora-launch/.

[16] T. Pietraszek and C. Berghe. Defending against injection

attacks through context-sensitive string evaluation. In RAID,
2006.

[17] D. Ray and J. Ligatti. Deﬁning code-injection attacks. In

POPL, 2012.

[18] R. Sekar. An efﬁcient black-box technique for defeating Web

application attacks. In NDSS, 2009.

[19] S. Son and V. Shmatikov. SAFERPHP: Finding semantic

vulnerabilities in PHP applications. In PLAS, 2011.
[20] Z. Su and G. Wassermann. The essence of command
injection attacks in Web applications. In POPL, 2006.

[21] B. Sullivan. Server-side JavaScript injection.

http://media.blackhat.com/bh-us-
11/Sullivan/BH_US_11_Sullivan_Server_Side_WP.pdf,
2011.

Figure 8: Performance overhead of DIGLOSSIA with the database
cache disabled.

Figure 9: Performance overhead of DIGLOSSIA with the database
cache enabled.

These experimental results show that DIGLOSSIA accurately de-
tects SQL and NoSQL code injection attacks with virtually unno-
ticeable performance overhead.

7. CONCLUSION
To the best of our knowledge, DIGLOSSIA is the ﬁrst tool capable
of accurately detecting both SQL and NoSQL injection attacks on
server-side PHP applications at runtime, without any modiﬁcations
to applications or back-end databases.

DIGLOSSIA follows Ray and Ligatti’s deﬁnition of code and
non-code, combined with very precise character-level taint track-
ing, and thus avoids the false positives and false negatives of prior
tools for detecting code injection attacks. In tandem with the exe-
cution of the application, DIGLOSSIA remaps all characters intro-
duced into the query by the application itself into a shadow charac-
ter set, while leaving the characters that originate from user input
intact. The resulting query and its shadow are then analyzed using
a dual parser that can parse both the original and shadow query
languages. Dual parsing is the main technical innovation of this
work. Any discrepancy between the parse trees of the query and its
shadow, or the presence of any original characters in the code of the
shadow query indicate that the code of the actual query is tainted
by user input and thus a code injection attack has occurred.

DIGLOSSIA imposes negligible performance overhead and does
not require any changes to the existing applications, databases, Web

1.93.32.85.70.10.46.20.43.1256.86.17.34.18.713.512.58.52.80 ms10 ms20 ms30 ms40 ms50 ms60 ms70 msmongodb-adminmongo_php_basicMongoPressrockMongoMongoTinyURLsimple-user-authfaqforgeschoolmatewebchessMyBBFull ( parsing + value shadowing)Value shadowing without parsingOriginalPage buildingtime (ms)11.94.31.11.39.512.5913.211.80.312.622.535.512.623.322.118.819.21.40 ms10 ms20 ms30 ms40 ms50 ms60 msmongodb-adminmongo_php_basicMongoPressrockMongoMongoTinyURLsimple-user-authfaqforgeschoolmatewebchessMyBBFull ( parsing + value shadowing)Value shadowing without parsingOriginalPage buildingtime (ms)1190[22] The BNF grammar for SQL-99. http://savage.net.au/SQL/.
[23] J. Vijayan. TJX data breach: At 45.6M card numbers, it’s the

biggest ever. http://www.computerworld.com/s/article/
9014782/TJX_data_breach_At_45.
6M_card_numbers_it_s_the_biggest_ever, 2007.

[24] G. Wassermann and Z. Su. Sound and precise analysis of

Web applications for injection vulnerabilities. In PLDI, 2007.

[25] WhiteHat website security statistics report.

https://www.whitehatsec.com/resource/stats.html, 2012.
[26] W. Xu, S. Bhatkar, and R. Sekar. Taint-enhanced policy

enforcement: A practical approach to defeat a wide range of
attacks. In USENIX Security, 2006.

1191