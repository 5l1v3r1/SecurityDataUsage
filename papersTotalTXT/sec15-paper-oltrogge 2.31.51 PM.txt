To Pin or Not to Pin—Helping App Developers 

Bullet Proof Their TLS Connections

Marten Oltrogge and Yasemin Acar, Leibniz Universität Hannover; Sergej Dechand and 

Matthew Smith, Universität Bonn; Sascha Fahl, Fraunhofer FKIE

https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/oltrogge

This paper is included in the Proceedings of the 24th USENIX Security SymposiumAugust 12–14, 2015 • Washington, D.C.ISBN 978-1-931971-232Open access to the Proceedings of  the 24th USENIX Security Symposium is sponsored by USENIXHelping App Developers Bullet Proof Their TLS Connections

To Pin or Not to Pin

Marten Oltrogge, Yasemin Acar

DCSEC, Leibniz University Hannover
oltrogge,acar@dcsec.uni-hannover.de

Sergej Dechand, Matthew Smith

USECAP, University Bonn

dechand, smith@cs.uni-bonn.de

Sascha Fahl

FKIE, Fraunhofer

fahl@fkie.fraunhofer.de

Abstract
For increased security during TLS certiﬁcate valida-
tion, a common recommendation is to use a vari-
ation of pinning. Especially non-browser software
developers are encouraged to limit the number of
trusted certiﬁcates to a minimum, since the default
CA-based approach is known to be vulnerable to se-
rious security threats.
The decision for or against pinning is always a trade-
oﬀ between increasing security and keeping mainte-
nance eﬀorts at an acceptable level. In this paper,
we present an extensive study on the applicability
of pinning for non-browser software by analyzing
639,283 Android apps. Conservatively, we propose
pinning as an appropriate strategy for 11,547 (1.8%)
apps or for 45,247 TLS connections (4.25%) in our
sample set. With a more optimistic classiﬁcation of
borderline cases, we propose pinning for considera-
tion for 58,817 (9.1%) apps or for 140,020 (3.8%1)
TLS connections. This weakens the assumption that
pinning is a widely usable strategy for TLS security
in non-browser software. However, in a nominal-
actual comparison, we ﬁnd that only 45 apps ac-
tually implement pinning. We collected developer
feedback from 45 respondents and learned that only
a quarter of them grasp the concept of pinning, but
still ﬁnd pinning too complex to use. Based on their
feedback, we built an easy-to-use web-application
that supports developers in the decision process and
guides them through the correct deployment of a
pinning-protected TLS implementation.

1 Introduction
Android is the major platform for mobile users and
mobile app developers. Many apps handle sensitive
1This smaller percentage in the optimistic case is caused

by a diﬀerent prevalence of third party library use.

information and deploy the transport layer security
protocol (TLS) to protect data in transit. Previous
research uncovered security issues with TLS in mo-
bile apps [7, 8, 9, 2, 22] that highlight that developers
have problems with implementing correct certiﬁcate
validation while users are challenged by TLS intersti-
tials. Furthermore, the default TLS implementation
on Android receives criticism [24, 18]: Adopted from
web-browsers, default TLS certiﬁcate validation re-
lies on a huge number of root CAs pre-installed on
all Android devices [24]. Hence, all Android apps
suﬀer from the same issues as web-browsers: A single
malicious CA is able to conduct Man-In-The-Middle
attacks (MITMAs) against all apps trusting the re-
spective certiﬁcate. To make things even worse, Fahl
et al. [8] uncovered that in 97% of all cases where
developers implemented their own certiﬁcate valida-
tion strategy, they turned oﬀ validation entirely and
left their apps vulnerable to MITMAs with arbitrary
certiﬁcates, i.e. every active network attacker was
able to attack successfully.

Pinning is often recommended as a general coun-
termeasure to tackle the weakest link in the CA-
based infrastructure [1, 14, 17, 8]. We use the term
pinning in this paper to include both pinning the
complete X.509 certiﬁcate or only the certiﬁcate’s
public key.
Instead of trusting a large set of root
CAs that come pre-installed with the operating sys-
tem, software limits the set of certiﬁcates it trusts
to pins, which can be single leaf certiﬁcates, single
root CA certiﬁcates or a set of certiﬁcates. Pin-
ning is a straightforward mechanism and its de-
ployment does not require changes to the current
CA infrastructure. However, pinning has not found
widespread adoption yet. While limiting the number
of trusted certiﬁcates drastically increases security,
pinning doesn’t come for free: Embedding trusted
certiﬁcates into an app requires app updates when-
ever the pins change. Hence, the decision whether

USENIX Association  

24th USENIX Security Symposium  239

pinning is applicable for a TLS connection is always
a trade-oﬀ between increased security and mainte-
nance eﬀort that is not entirely under the control
of an app developer: Whenever users do not update
their app although the pins have changed, the app
stops working and users might uninstall the broken
app. Therefore, to pin or not to pin is a critical deci-
sion for app developers, which requires in-depth un-
derstanding of the mechanisms behind pinning and
its implications on their apps. This is where our
work comes in: To the best of our knowledge, we
are the ﬁrst to explore the applicability of pinning
as an appropriate alternative certiﬁcate validation
strategy for non-browser software. In this paper, we
make the following contributions:
Status Quo We evaluate the status quo and ana-
lyze 639,283 Android apps to ﬁnd that only 45 apps
implement pinning.
Formalization Instead of intuitively recommend-
ing pinning, we formalize criteria that must be con-
sidered when the decision is made whether to pin or
not to pin.
Implementation We apply static code analysis
and program slicing to automatically assess those
criteria and obtain an overview of the situation for
single apps.
Evaluation We evaluate our criteria against a set
of 639,283 Android apps for an overview of the ap-
plicability of pinning in the Android universe. We
ﬁnd that 223,655 apps establish TLS-secured con-
nections to remote origins; 11,481 (5.13%) of these
223,655 apps are eligible candidates to implement
pinning for one or more of their TLS connections.
App Updates Since new certiﬁcate pins need to
be updated on the users’ devices, the update speed
is crucial. Therefore, we instrument telemetry data
from a popular anti-virus software provider. We
evaluate the update behaviour of 871,911 unique
users from January 2014 to December 2014 and ﬁnd
that only 50% of the users update to a new app
version within the ﬁrst week after release.
Developer View Although pinning is only ap-
plicable in relatively few cases, the nominal-actual
comparison leaves room for improvement. We there-
fore collected feedback from 45 developers of apps
for which we would recommend pinning. We iden-
tiﬁed the developers’ major issues with pinning and
used their feedback as the foundation to build an
easy-to-use web application that assists developers
with securing their apps’ TLS connections. We oﬀer
help on the decision whether to pin or not to pin and
support the implementation of pinning with concrete
suggestions and code examples.

Take-aways We formulate lessons learned during
our evaluation to share them with the research com-
munity.

2 Background and Motivation

To establish secure TLS connections, certiﬁcate val-
idation is important in order for communication
partners to authenticate remote endpoints. There-
fore, Android and most other non-browser software
adopted the in-browser certiﬁcate validation strat-
egy, i.e. applications trust a predeﬁned set of root
certiﬁcate authorities (root CAs). When attempting
to establish a secure connection, the server provides
the client with a certiﬁcate chain.

2.1 Default Certiﬁcate Validation
Certiﬁcate chain validation works as follows:
Chain of Trust Based on the certiﬁcate chain
sent by the server, the client tries to build the chain
of trust beginning at the server’s leaf certiﬁcate up
to one of the root CA certiﬁcates. Every certiﬁcate
in the chain is checked for validity – i.e.
it is not
expired and it is signed by its immediate successor
in the chain. The second last certiﬁcate in the chain
must be signed by one of the root CAs installed on
the user’s device [3]; the last certiﬁcate in the chain
belongs to the signing root CA.
Hostname Veriﬁcation A certiﬁcate is bound to
a certain identity – in this case a particular hostname
or a set of hostnames. During hostname veriﬁcation,
a client veriﬁes this identity by checking whether
the hostname can be matched to one of the identi-
ties (i.e. CommonName, SubjectAltName [20]) for
which the certiﬁcate was issued.
Further checks Complete certiﬁcate validation
may include further checks, e. g. certiﬁcates have
to be checked for revocation which is done via a cer-
tiﬁcate revocation list (CRL)[3] or Online Certiﬁcate
Status Protocol (OCSP)[21].

2.2 MITM Attack
In a Man-In-The-Middle attack (MITMA), the at-
tacker is in a position to intercept network communi-
cation. A passive MITMA can only eavesdrop on the
communication, while an active MITMA can also
tamper with the communication. Correctly conﬁg-
ured TLS together with proper certiﬁcate validation
is fundamentally capable of preventing both passive
and active attackers from executing their attacks.

240  24th USENIX Security Symposium 

USENIX Association

2

2.3 Alternative Validation Strategies
Over the years, alternative certiﬁcate validation
strategies have come up [12, 26, 16, 15, 10, 17].
While they all provide approaches to check a cer-
tiﬁcate chain’s validity, our paper focuses on pin-
ning [17] as one of the most recommended alterna-
tive strategies for non-browser software.

2.3.1 Pinning
Pinning is a notion of certiﬁcate validation that uses
existing knowledge about the network origin or the
certiﬁcation data presented to protect the TLS con-
nection [17]. Required parameters to be pinned need
to be available in an application before the TLS
handshake happens. Pinning can be achieved based
on diﬀerent parameters (e.g. public key, whole cer-
tiﬁcate).
Pinning can also be applied to diﬀerent subjects:
Leaf Pinning Leaf pinning includes pinning a sin-
gle leaf certiﬁcate or its public key or a set of leaf
certiﬁcates or their public keys and is the most rig-
orous way of pinning.
CA Pinning Certiﬁcate authority pinning eﬀec-
tively limits the number of trusted certiﬁcate au-
thorities and allows for more ﬂexible reconﬁguration
of deployed TLS certiﬁcates. This includes both in-
termediate and root CAs.

2.3.2 Trust on First Use (TOFU)
Another notion of pinning is trust on ﬁrst use
(TOFU). Instead of knowing the information to be
pinned in advance, the ﬁrst certiﬁcate (leaf or CA)
seen for a TLS connection is stored locally on the
client side and used to validate certiﬁcates for fur-
ther connections. Hence, TOFU can be seen as a mix
of conventional pinning (cf. Section 2.3.1) and the
default validation strategy. TOFU is used to secure
SSH connections and is an opt-in feature for HTTPS
webservers for which it is called HTTP Public Key
Pinning (HPKP [5]). As of today, HPKP has not
found widespread adoption on the web [11].

2.4 Flaws in client implementations
The Android platform provides built-in function-
alities for handling TLS and certiﬁcate validation
based on the PKI without further conﬁguration. It
comes pre-loaded with an extensive truststore fea-
turing 140+ root CAs [18]. Additionally, the An-
droid framework enables developers to provide cus-
tom implementations for handling certiﬁcate valida-
tion. There are several reasons for developers to use
custom implementations:

• Application developers might want to use a self-
signed certiﬁcate either for testing, eﬀort- or
economical reasons;

• When a root CA is not in the system-wide list
of trusted root CAs, a company might have an
internal CA that issues certiﬁcates for use in
intranet applications;

• Security can be enhanced by restricting reliance
on the PKI to mitigate the exposure to weak-
nesses in the PKI

• and custom implementations are required to im-

plement leaf or CA pinning.

[7] and Georgiev et al.

2.5 Related Work
Recently, TLS has been subject to urgent ﬂaws.
Studies by Fahl et al.
[9]
uncovered a disastrous state of TLS-Code. Georgiev
et al. [9] show numerous ﬂaws in non-browser TLS-
Code. Fahl et al. [7] identify numerous applications
featuring erroneous custom TLS-code that poten-
tially renders applications vulnerable to MITMAs.
This is caused by incorrect implementations of cus-
tom certiﬁcate handling. Investigations on the rea-
sons illustrate that especially developers without a
security focus are unaware of the correct use of
the APIs that Android provides: They carelessly
incorporate code snippets from platforms such as
stackoverflow.com [8].
In particular, self-signed
certiﬁcates used during development lead to erro-
neous code that makes applications vulnerable by
deactivating certiﬁcate validation completely.

Both of the above investigations [7, 9] focused
on the diﬃculties experienced by developers with
the implementation of correct certiﬁcate valida-
tion. However, they discuss possible countermea-
sures rather sketchily and do not evaluate the appli-
cability of pinning for non-browser software.

To improve the state of erroneous certiﬁcate han-
dling and to mitigate the threats, Fahl et al. [8] sug-
gest to completely disallow custom code.
Instead,
they propose a framework that allows to realize com-
mon use-cases (e.g. self-signed certiﬁcates for test-
ing, pinning, default warning messages, etc.) by con-
ﬁguration without the developer writing any TLS-
related code. Tendulkar and Enck [23] suggest a sim-
ilar approach. However, although both approaches
try to improve the usability of certiﬁcate handling
for software developers, they do not support devel-
opers in the decision process of whether pinning is a
recommendable certiﬁcate validation strategy.

USENIX Association  

24th USENIX Security Symposium  241

3

3 An Exit Strategy
Previous work shows that TLS is complex and error-
prone. Studies imply that the implementation of
client code for correct certiﬁcate validation is hard
for software developers. The general trust model
received a lot of criticism over the last years and al-
ternative solutions have not found widespread adop-
tion.

As a general solution for both problems, pinning
is often advocated as a secure and reliable alter-
native to the default trust model for non-browser
software [17, 14, 1, 8]. Pinning can serve two pur-
poses. First, it can mitigate the risk of MITMAs
as it strengthens the validation process. Secondly,
pinning allows to overcome limitations of the cur-
rent CA infrastructure, e.g. by allowing self-signed
certiﬁcates.

We challenge the recommendation to use pinning
for non-browser software and conduct a deep anal-
ysis on the root causes that hinder its widespread
adoption in non-browser software.

3.1 Pinning in Android Apps
Before evaluating the status quo, we give a brief
overview of how TLS pinning can be implemented
in Android apps. In general, Android apps can es-
tablish low-level TLS connections via an SSLSocket
or an HTTPSUrlConnection object. Using pinning
in these cases requires the developer to implement a
custom version of Android’s TrustManager interface
with an appropriate checkServerTrusted method.
This method has to check whether the certiﬁcate
sent by the remote server matches one of the given
pins. Another option is to use a custom KeyStore
in which developers can store their own certiﬁcates.
Many Android applications do not make use of
such lower level APIs but use a WebView to display
HTML directly. Sadly Android does not provide
an API to implement pinning for WebViews2. As a
workaround, developers can download all HTML/-
JavaScript via the low-level HTTPSUrlConnection,
store it locally and only use the WebView for ren-
dering. However, this is a clear shortcoming of An-
droid’s API and makes the implementation of pin-
ning unnecessarily hard.

3.2 Status Quo
For a better understanding of the current adoption
of TLS pinning in Android apps, we evaluated cus-

2https://code.google.com/p/android/issues/detail?

id=76501

tom certiﬁcate veriﬁcation strategies for 639,283 An-
droid apps. Therefore we used MalloDroid [7] and
extended the classiﬁcation feature of custom veriﬁ-
cation implementations. We focused on both cus-
tomized implementations of the TrustManager in-
terface and the usage of a custom KeyStore for TLS
certiﬁcates.

Whenever we found that a KeyStore object was
created, we conducted a reachability analysis [13] for
this object. For objects that were reachable from an
app’s entry point, we assume that this app uses pin-
ning. Next, we extracted the keystore ﬁle that was
loaded to check whether leaf or CA certiﬁcates were
pinned. We found 21 apps that implement pinning
using the keystore method. 13 of these apps pin a
leaf certiﬁcate, while 8 of them pin a custom root
CA certiﬁcate.

Whenever we found a TrustManager implementa-
tion, we checked whether the chain parameter of the
checkServerTrusted method was accessed by the
implementation.
Implementations that do not use
this parameter do not verify the remote origin’s cer-
tiﬁcate chain and hence were removed from further
analyses.
In a second step we conducted a reach-
ability analysis for implemented TrustManager ob-
jects and removed all implementations that were not
reachable from an app’s entry point. We found cus-
tom TrustManager implementations in 42,902 apps
and could remove 42,042 apps from the list since
they either implemented bypassing TrustManagers
or were not reachable. The remaining 858 apps im-
plemented 189 diﬀerent TrustManagers. We com-
pared these implementations with the list provided
by Fahl et al. [8] and could ﬁlter out 124 implemen-
tations that basically add logging for certiﬁcate vali-
dation. We manually reviewed the remaining 65 im-
plementations and found that 13 implemented pin-
ning. Overall, these implementations were used by
24 apps.

Altogether, of the 639,283 apps in our data-set, 45
implement pinning. These numbers conﬁrm ﬁndings
already reported by Fahl et al. [8].

4 Classiﬁcation Strategy

The decision whether or not a TLS connection
should be secured by pinning depends on multiple
factors and is not trivial in many cases.

Furthermore, whenever we cannot reliably identify
the origin string for a TLS connection endpoint, we
cannot assess whether pinning would be a reasonable
validation strategy. Therefore, we report our results
for two diﬀerent scenarios:

4

242  24th USENIX Security Symposium 

USENIX Association

Conservative We report numbers for a conserva-
tive scenario. Whenever we cannot identify the ori-
gin string for a TLS connection endpoint, we assume
that pinning is unfeasible. This covers most of our
results.

Optimistic For some of the cases where we could
not successfully identify origin strings, pinning could
be applied under certain circumstances. These cases
are treated diﬀerently for the optimistic scenario as
detailed in Section 6.

For our classiﬁcation, we consider the following

properties as high level indicators:

Prior Knowledge of the Target Origin Prior
knowledge about the target origin is vital: Pinning
is only feasible if the developer of an app is able
to hard-code target origins into their app. This
includes adding target origins at compile time as
well as via conﬁguration ﬁles before or at run-time.
Whenever target origins depend on user- or external
app input – e.g. via an Intent – at run-time, we
consider pinning as not feasible, since web-browsers
do not automatically pin certiﬁcates for websites for
the same reasons.3. Automatically pinning previ-
ously unknown origins would increase the danger of
failed TLS handshakes due to substituted certiﬁcates
and would decrease acceptance of pinning for both
developers and app users.

In the conservative scenario, we recommend the
default validation strategy for all connections where
the origin depends on external input. However, some
of these connections can be pinned in the optimistic
scenario (cf. Section 6).

Ownership of Relevant API Calls App de-
velopment consists of writing one’s own code and
embedding external libraries. All source code that
was written by the developer or the developer’s com-
pany is considered owned by the developer. API
calls required for certiﬁcate validation during the
establishment of TLS-secured network connections
are relevant for this. Relevant API calls might be
a HTTPSUrlConnection or an SSLSocket. When-
ever ownership of relevant API calls is given, pin-
ning might be feasible. Library developers do not
own their code when it is included in other apps.
Therefore, we do not recommend pinning for library
code. Library developers cannot control when app
3Administrators can conﬁgure HTTP Public Key Pinning
(HPKP) to pin TLS certiﬁcates in modern web-browsers.
However, this involves heavy manual conﬁguration work on
the server side and does not happen automatically (cf. Sec-
tion 2).

developers update their libraries, while app develop-
ers can hardly inﬂuence whether library developers
keep their certiﬁcate pins up to date.

For both the conservative and the optimistic sce-
nario pinning is not recommended in case API own-
ership is not given.

TLS Certiﬁcate Conﬁguration Responsibility
Being responsible for the TLS certiﬁcate conﬁgura-
tion as well as being the owner of relevant API calls
eases the coordinated deployment of pinning in apps.
In case developers or their companies have control
over the TLS certiﬁcate conﬁguration of origins used
in apps, both the certiﬁcate pins in apps and the
corresponding server conﬁgurations can be coordi-
nated.
In these cases, pinning is feasible. When-
ever apps communicate with public origins, such as
public API interfaces or websites, pinning cannot be
recommended. Certiﬁcate conﬁgurations can change
frequently and the responsible administrators only
rarely announce them in advance. Unplanned cer-
tiﬁcate changes can lead to failing TLS handshakes
and are therefore unacceptable.

For both the conservative and the optimistic sce-
nario pinning is not recommended in case the devel-
oper is not responsible for TLS certiﬁcate conﬁgura-
tion.

4.1 Possible Recommendations
The above criteria build the foundation for the de-
cision whether pinning is applicable for a TLS con-
nection in a given app. The classiﬁcation algorithm
recommends one of the following strategies:

Leaf Pinning Leaf pinning limits the number
of trusted certiﬁcates to the server’s leaf certiﬁ-
cate/public key (cf. Section 2.3.1).
CA Pinning CA pinning eﬀectively limits the
number of trusted CAs (cf. Section 2.3.1). We treat

conventional pinning (cf. Section 2.3.1) and TOFU
(cf. Section 2.3.2) equally, since both provide a sim-
ilar level of security (cf. Section 2.3.1) and require
the same maintenance overhead from an app devel-
oper’s point of view.
Default Whenever none of the above criteria ap-
plies, pinning is not a recommended strategy and
should not be implemented. This also accounts for
cases where external input – e.g. user input in an
address bar or Intent input – inﬂuences a TLS con-
nection.

USENIX Association  

24th USENIX Security Symposium  243

5

4.2 Classiﬁcation Details
Algorithm 1 illustrates the classiﬁcation process we
apply to decide whether pinning is an advisable ver-
iﬁcation strategy.
In the initial state, the default
strategy is assumed to be the right choice for a
TLS connection, since we do not know yet if pin-
ning is recommendable. First, we check whether the
TLS connection is established within a third party
library. In this case classiﬁcation ends with the rec-
ommendation to use the default strategy, since own-
ership of the relevant API is not guaranteed.

Second, we check whether the remote origin de-
pends on user input, other external sources such as
Intents, or may be conﬁgured via a conﬁguration
ﬁle. In these cases we recommend the default strat-
egy, since control over the remote origin is not guar-
anteed.

Third, we check whether the TLS connection’s re-
mote endpoint is a popular origin; in this case, clas-
siﬁcation ends with recommending the default strat-
egy, since the TLS conﬁguration of the remote ori-
gin is probably not under the developer’s control. If
we assume that a remote origin is probably under
control of the developer, as no other app accesses
it, the classiﬁcation continues: We check whether
the origin’s certiﬁcate was issued by a valid CA or
is self-signed. For self-signed certiﬁcates and certiﬁ-
cates that were issued by a valid CA, we recommend
leaf certiﬁcate pinning. For certiﬁcates issued by an
untrusted CA, we recommend CA pinning, since the
custom CA is probably under control of the devel-
oper.

4.3 Challenges
For our strategy classiﬁcation, we apply static code
analysis on a large set of Android apps. To work
as eﬃciently as possible, we identiﬁed multiple chal-
lenges:

4.3.1 Relevant API Calls

First, we identify relevant API calls, which means
taking remote origins as parameters and establish-
ing a TLS-secured connection between the app and
the origin. The oﬃcial Android API documenta-
tion identiﬁes relevant API calls in the packages pre-
sented in Table 1.

These API calls are the most low-level calls in the
API and they implicitly include higher level APIs
such as the HTTPSUrlConnection.

Package name
org.apache.http.client.methods.*
org.apache.http.HttpHost
android.webkit.WebView.loadUrl
android.webkit.WebView.loadDataWithBaseURL
android.webkit.WebView.loadData
android.webkit.WebView.postUrl
android.net.http.AndroidHttpClient
java.net.Url

Table 1: Relevant API Calls.

4.3.2 Embedded Static TLS Origins
As described above, knowing remote origins in ad-
vance is crucial for pinning. At this point, we focus
on extracting whether a remote origin is embedded
in an app or depends on user input or is injected
via an external interface such as an Intent. This
information is supplied via parameters to relevant
API calls. Although these mainly refer to String
values, the object-oriented and Java-based nature of
the Android platform introduces complexity:

• Strings may not be constant values but can be
composed of numerous substrings. We identify
concatenation of Strings, formatting of Strings
and platform-speciﬁc APIs for building URIs
as relevant. Therefore, we statically backtrack
these and reproduce String values.

• Values can stem from variables or may be return
values of method calls. Therefore, we account
for intra-application method calls as well.

• Values that stem from Resources, Properties
or Preferences hint at conﬁguration parame-
ters.

• Origins can be input parameters for applica-
tion entrypoints. Entrypoints are parts of an
application that allow either other app compo-
nents, external apps or users to interact with
an app. Android application entrypoints are
Activities, Services, Receivers, Intents
and Bundles. UI-Components in Activities
hint at user input.

4.3.3 API Call Ownership
API call ownership is a requirement for pinning. To
identify whether an app developer holds ownership
of relevant API calls, we must distinguish relevant
API calls that are accessed by third party libraries
and relevant API calls accessed by code that was

244  24th USENIX Security Symposium 

USENIX Association

6

Algorithm 1: The Classiﬁcation Process.
for r ∈ results do

dependencies ← dependencies(r);
set strategy as default;
if dependencies (cid:29)= /0 then

continue;

if ∃d ∈ dependencies|d ∈ {exposed intent,UI −Component} then
else if ∃d ∈ dependencies|d ∈ {unexposed intent,variable,con f iguration} then

continue;

if not callInLibrary(r) and not isPublicHost(r) then

host ← host(r);
schema ← schema(r);
cert ← cert(r);
dependencies ← dependencies(r);
if isUnderControl(host) then

if signedByUntrustedCA(cert) then

mark for CA pinning;

else if validCertChain(cert) or isSel f Signed(cert) then

mark for leaf pinning;

written by the app developer (we call this custom
code). Whenever we ﬁnd relevant API calls in code
that is shared between multiple apps by diﬀerent au-
thors, we assume a library that is not under control
of an app’s developer.

4.3.4 Origin Exclusivity
Whenever the TLS conﬁguration of a remote origin
is not in the range of inﬂuence of the developer, pin-
ning is not advisable. We classify origins that are
shared between multiple apps’ authors and connec-
tions that access public origins as not under control
of the developer.

5 Implementation Details

To decide whether pinning for a TLS connection is
advisable and to address the above challenges (cf.
Section 4.3), we implement our classiﬁcation strat-
egy in a multi-step process. We extend4 the Mallo-
Droid tool [7] and execute the following steps:

1. Disassemble a given Android application to gain
access to the application’s code and call graph
(cf. Section 5.1).

4Our MalloDroid extension is available at https://

github.com/sfahl/mallodroid.

2. Identify relevant API calls – i.e. API calls that
implement TLS connections in apps (cf. Sec-
tions 5.2 and 4.3.1).

3. Extract information for remote origins applying

program slicing (cf. Sections 5.3 and 5.3.1).

4. Determine whether API and/or origin owner-
ship for relevant API calls is given and decide
which certiﬁcate validation strategy suits best
(cf. Sections 4.2 and 5.4).

5.1 Disassembly
In Step 1, we use androguard [4] to disassemble apps
and construct call graphs for further processing.

5.2 Relevant API Calls
In Step 2, the call graphs were used to identify apps
that make use of API calls in which origin infor-
mation for establishing TLS-enabled connections is
speciﬁed (cf. Section 4.3).

We consider API calls as relevant if they are used
during the process of TLS connection establishment
(cf. Table 1).

5.3 Program Slicing
In Step 3, we apply backwards program slicing [25]
to collect method parameters which we subsequently
call slicing criteria. We focus on slicing criteria that

USENIX Association  

24th USENIX Security Symposium  245

7

represent remote origins which are used as input for
relevant API calls, i. e. we are backtracking param-
eters that are URLs or hostnames for TLS connec-
tions.

Our approach is similar to the one applied by Poe-
plau et al. [19], who apply a backward slicing algo-
rithm to identify security issues with dynamic code
loading in Android apps.

In contrast to backwards slicing single and ﬁxed
method parameters, our targets are network origins.
A network origin String can be a composition of
multiple substrings. We take this fact into account
by applying backwards slicing for multiple param-
eters. After backtracking, we join these (multiple)
substrings to one origin string whenever possible. To
break cycles, we stop the slicer after 80 iterations,
which guarantees that the algorithm terminates and
also makes sure we do not lose data.

5.3.1 Extracting Origin Strings
Origin strings can be compositions of multiple sub-
strings (e.g. https:// and www.example.com and
:443). Thus, reconstructing an origin string might
require combining multiple sliced substrings. There-
fore, after program slicing, we apply a combination
of backward and forward analysis. Backwards anal-
ysis is used for backtracking constant register values
while forward analysis determines calls of a String
instance. Both, back- and forward analyses are ap-
plied multiple times successively as long as we ﬁnd
new substrings that are part of a ﬁnal origin string.
Algorithm 2 outlines pseudocode for handling
StringBuilder objects. The algorithm makes use
of the following functions:
methodsOnInstance returns a list of all method
calls to
for

invocations on an instance (e.g.
toString, append or
StringBuilder objects).

the constructor

backtrack applies the actual backtracking tech-
niques to gather all substrings for the origin
string composition.

add adds one originSubstring to the array of
originSubstrings that make the origin string
we are looking for.

join merges all originSubstrings to get the ﬁnal
origin string that is represented by the given
StringBuilder object.

1. Identify instructions indicating the instanti-
a

ation of a StringBuilder object (i.e.

Algorithm 2: StringBuilder Analysis
Data: stringBuilderObjects sbos
Result: new originSubstring O
begin

for sb ∈ sbos do

methodInvocations ←
methodsOnInstance(sb);
originSubstrings ← /0;
origin ← null;
for mi in methodInvocations do

if isAppend(mi) then
originSubstring ←
backtrack(mi.regs[1]);
if originSubstring (cid:29)= null then

add(originSubstrings,
originSubstring);

else if isToString(mi) then

break;

join(O, originSubstrings);

new-instance instruction referring to the
StringBuilder constructor) and store them in
sbos.

2. Find

StringBuilder object sb;

all method

invocations

for

each

3. For calls of the constructor or the append()
method, backtrack the register value for the
String parameter originSubstring and add
it to all originSubstrings.

4. Stop on calls of the toString method and
join all collected originSubstrings to a new
originSubstring.

Similarly, we support String concatenation, for-
matting Strings, UriBuilder instances, Android
UI-Components, Intents, Bundles, Properties,
Preferences and Resources. For Intents and
Bundles we identify the source in order to deter-
mine whether the corresponding component is ex-
posed externally, e.g. via a Service.

5.4 Decide on Validation Strategy
In the ﬁnal Step 4, we assess whether API and/or
origin ownership is given (cf. Section 4). For pinning
candidates, X.509 certiﬁcate information is collected
and a decision for or against pinning is made (cf.
Section 4.2).

246  24th USENIX Security Symposium 

USENIX Association

8

5.5 Limitations
The described approach is limited in multiple ways.
We decided to reverse engineer a large sample of free
Android apps and analyze the resulting code. This
limits the analysis compared to the analysis of orig-
inal source code, e.g. we lose variable names and
cannot preclude obfuscation. This is however the
state of the art for large scale app analyses, since
reaching out to developers and asking for source code
does not scale well. We apply static code analysis
and program slicing to determine the best certiﬁcate
validation strategy to secure a TLS connection. Our
approach does not consider native code in Android
apps. We cannot track potential TLS connections in
code that was dynamically loaded or when obfusca-
tion was applied.

Since we apply static code analysis techniques, we
might report some false positives: Some of the TLS
connections we found and identiﬁed as being reach-
able code might not be used during real applica-
tion usage. However, this is not a speciﬁc limitation
of our work, but a general limitation of static code
analysis.
We might also report some false negatives: Due to
the strategy to classify origins to which apps devel-
oped by diﬀerent developers connect as “not under
control of the developer”, we might miss the sce-
nario that one company has several distinct devel-
opers write apps for them that all access the same
domain. However, there exist no criteria to distin-
guish these cases from the common scenario that
multiple apps by diﬀerent developers accessing the
same domain means that the domain is not under
control of the developers. Therefore, these cases are
included in the group of public origins for which we
do not recommend pinning.

6 Evaluation
We applied the classiﬁcation algorithm (cf. Section
4) to a set of 639,283 Android applications we down-
loaded from Google Play in October 2014. Our data
extraction showed that of these apps, 573,258 imple-
mented network connections.

In the following, we report details of our auto-
mated large-scale analysis. We report our results on
a per-connection base (see Figure 2) as well as on a
per-app base (see Figure 1), where an app is counted
as eligible for pinning if at least one of its connections
can be pinned. We distinguish between a conserva-
tive and an optimistic strategy rating (cf. Section
4). Altogether we found 20,020,535 calls to network
related API calls (cf. Table 1). For these calls we
tried to identify the origin strings. We could iden-

Overall
Hard-coded HTTPS Origin
Hard-coded HTTP Origin
Non-hard-coded Origin

Third Party Libraries
Hard-coded HTTPS Origin
Hard-coded HTTP Origin
Non-hard-coded Origin

Custom Code
Hard-coded HTTPS Origin
Hard-coded HTTP Origin
Non-hard-coded Origin

Con.
1,062,810
2,420,104
16,537,621
20,020,535

Con.
917,567
1,659,933
14,564,581
17,142,081

Apps
229,317
414,194
553,399
573,258

Apps
203,159
310,331
512,055
517,790

Con.
145,243
760,171
1,973,040
2,878,454

Apps
48,755
184,184
246,636
299,863

Table 2: Distribution of Network API Calls.

tify 1,062,810 calls as TLS connections due to the
fact that the corresponding origin string’s scheme
was HTTPS. 2,420,104 connections were identiﬁed
as plain HTTP, while 16,537,621 connections did not
have a hard-coded origin string in the app’s code.
Hence, for 81% of all connections, it was not di-
rectly possible to determine whether TLS was used.
However, a deeper analysis based on our classiﬁca-
tion criteria (cf. Section 4.2) gives detailed insights
into the applicability of pinning. Table 2 gives an
overview of the results.

6.1 Library Code
The majority of network connections we identiﬁed
were made in third party library code, i. e. users
include third party libraries to make use of exter-
nal functionality. Such connections can include both
plain and TLS-protected connections. As described
in Section 4.2, we recommend not to use pinning
for those TLS connections, as API ownership is not
given. Of the 20,021,137 TLS connections we could
identify, we found that 17,142,081 (85.6%) connec-
tions are embedded in third party libraries.

Table 3 gives an overview of the top 10 third party

libraries we found in our data-set.

Most of

ad networks
reporting
org.apache.cordova.*)

tools

or

the
(e.g.

identiﬁed libraries belong to
crash
(e.g.
that establish network

com.google.ads.*),
app
kits

building

USENIX Association  

24th USENIX Security Symposium  247

9

Library
com.google.ads.*
org.apache.cordova.*
com.qbiki.*
com.millennialmedia.*
com.facebook.*
com.Tobit.*
com.inmobi.*
com.ﬂurry.*
com.startapp.*
com.adsdk.*

Connections
2,535,020
1,145,108
977,298
730,408
551,373
488,143
352,855
340,929
276,988
234,130

Table 3: Top 10 Third Party Libraries.

connections without any interaction with an app’s
custom code.

We found the AndroidPinning library5 to be the
only library that supports pinning as a security fea-
ture out of the box. However, in our data-set we
found only 14 apps that made use of this library (cf.
Section 3.2).

6.2 Custom Code
Next, we identiﬁed network connections that were
established in code that was actually written by
apps’ developers, i.e. network-related API objects
were not instantiated within third party libraries.

We found 2,878,454 connections in custom code
of which we identiﬁed 145,243 as TLS connections.
48,755 apps implemented hard-coded TLS origins as
parts of their custom code. Based on the type of the
deployed certiﬁcate and depending on whether the
origin is shared, we evaluated which of these TLS
connections are candidates for pinning.

For 1,973,040 of the connections that were imple-
mented as part of apps’ custom code, we could not
identify hard-coded origins in apps. Those connec-
tions could be either HTTP or HTTPS and depend
on further input available only at run-time, e.g. user
input or Intents. For these connections, we con-
sider a conservative as well as an optimistic scenario.
Based on diﬀerent assumptions, these scenarios al-
low us to estimate the applicability of pinning in
Android apps.

6.2.1 Hard-coded Origins
Overall, we found 145,243 hard-coded HTTPS con-
nections and 760,171 hard-coded HTTP connections
in our data-set. For the HTTPS connections, we
collected further information such as the number of

5https://github.com/moxie0/AndroidPinning

10

e
v
i
t
a
v
r
e
s
n
o

c
i
t
s
i

m

i
t
p
O
-


Shared Origin
Unique Origin(d.a.b.c)

Con. Apps C
40,691
99,996
-
11,547 
45,247
145,243
45,549
(a) HTTPS Origins in Custom Code.

Internal Intent
Public Intent
Parcel
UI Component
Resource
(Shared) Preference
Variable
JSON

Apps C O
81,040

-
8,268
-
2,883
-
18,766
32,113

31,975

119,406

32,200

326,651
(b) Dynamic Origins in Custom Code.

Con.
294,846
14,599
5,729
31,266
124,356
87,051
432,985
96,438
1,973,040

-
-
-
-
-
-
-
-

Table 4: Origins in Custom Code – Connections
marked with  can be pinned.

connections that connect to the same origin and the
origin’s X.509 certiﬁcate whenever possible.

The 145,243 TLS connections we found included
connections to 11,203 diﬀerent TLS-enabled remote
origins.

To investigate whether pinning is the recommend-
able validation strategy, it is important to know if
an origin is shared between multiple apps authored
by multiple developers or used by apps of a single
developer only (cf. Section 4).

Shared Origins
1,301 of the extracted 11,203
hosts were present in multiple apps that were au-
thored by multiple developers. We assume these
hosts not to be under the control of an app’s de-
veloper and hence recommend the default certiﬁcate
validation strategy, since host-ownership is not given
(cf. Section 4). This aﬀects 99,996 of the TLS con-
nections we identiﬁed in our data-set (cf. Table 4a).
Table 5 lists the top 10 shared origins in custom

code we found in our data-set.

Unique Origins
6,012 origins were unique to one
single app while 3,890 origins were included in no
more than ﬁve apps owned by a single developer.
Hence, we assume 9,902 origins to be under the con-

248  24th USENIX Security Symposium 

USENIX Association

Hostname
graph.facebook.com
m.facebook.com
www.googleapis.com
bugsense.appspot.com
www.starbucks.com
www.facebook.com
docs.google.com
mobileclient.paypal.com
api.twitter.com
svcs.paypal.com

.

n
o
C
220,697
110,903
30,101
18,402
32,063
39,969
29,240
39,214
34,641
38,175

s
p
p
A
111,559
104,745
20,120
18,285
16,029
13,923
11,872
10,963
10,551
9,999

Table 5: Top 10 Remote Origins.

trol of a single developer each. We recommend pin-
ning for these apps and their connections, since both
host- and code-ownership are given (cf. Section 4).
This aﬀects 45,247 TLS connections in our data-set
(cf. Table 4a).

To determine whether leaf pinning or CA pinning
is the right choice, we analyzed the deployed certiﬁ-
cates for the respective origins. Overall, we gathered
7,941 unique certiﬁcate chains. We used Androids
pre-installed root CA certiﬁcates and Androids cer-
tiﬁcate validation strategy to verify the validity of
the origins’ certiﬁcates and found that 7,177 of all
chains could be veriﬁed successfully, while veriﬁca-
tion failed for 764 chains. Of these non-validating
certiﬁcate chains, 182 certiﬁcates were self-signed;
170 certiﬁcates were issued by an unknown CA; 335
certiﬁcates were already expired and for 160 certiﬁ-
cates hostname veriﬁcation failed. Table 6 gives an
overview of the chains and the aﬀected connections
and apps in our data-set.

.

n
o

Veriﬁcation Result C
40,433
Chain Ok
Self-Signed
1,966
269
Custom CA
1,709
Expired
870
Hostname Mismatch
45,247

s
p
p
A
10,176
486
81
546
258
11,547

Table 6: X.509 Certiﬁcates Statistics.

We recommend pinning for all of these connections
(cf. Section 4). We recommend leaf pinning for the
connections that use a self-signed certiﬁcate and CA
pinning for all other connections (cf. Table 7).

11

Type
Leaf Pinning
CA Pinning

Connections Apps
11,247
81

44,978
269

Table 7: Pinning Statistics (Conservative).

6.2.2 Dynamic Origins
While the unique origins in custom code are good
candidates for pinning, the majority of origins for
connections in custom code were not hard-coded into
the apps at compile time (cf. Table 4). These con-
nections’ origins can depend on diﬀerent external
factors such as Intents, UI components etc.

For these connections, we distinguish two scenar-

ios:

Conservative In the conservative scenario, we as-
sume that connections that use dynamic origins can-
not be pinned. This assumption prevents us from
over-reporting the applicability of pinning, but prob-
ably underestimates its applicability as well. As-
suming this scenario, 45,247 of the 1,062,810 TLS
connections we found in our data-set would be good
pinning candidates, which makes up 4.25%.

Optimistic In this scenario, we assume some of
the 1,973,040 dynamic origins connections eligible
for pinning. We still assume that connections that
get their input from Public Intents, Parcels and UI
Components are no good pinning candidates, since
the app developer probably does not have control
over the actual origin strings values. That leaves
some of the remaining 1,921,446 connections that
depend on dynamic origin strings eligible for pin-
ning. We assume that – as for the custom code
with hard-coded origins – 16% of all connections are
HTTPS connections (cf. Table 4), which leaves us
with 307,431 HTTPS connections. If we again as-
sume that, like for the hard-coded custom code ori-
gins, 31.1% of the HTTPS connections can be pinned
(cf. Table 4), we can recommend 95,611 connections
for pinning. In combination with the 45,247 connec-
tions from the conservative scenario, we recommend
to pin 140,858 connections in the optimistic scenario.
However, while only 86.33% of all known HTTPS
connections are implemented in third party library
code, but 88.07% of our assumed HTTPS connec-
tions happen via third library code, the connections
we optimistically recommend for pinning make up
only 3.8% of all (assumed and deﬁnite) HTTPS con-
nections (as opposed to 4.25% for deﬁnite HTTPS
connections). We can optimistically pin 140,858 con-

USENIX Association  

24th USENIX Security Symposium  249

6.3 Update Frequencies
In addition to the strategy classiﬁcation, a crucial
requirement for pinning to work properly is the pos-
sibility to deploy quick updates for apps to distribute
new pins. The applicability of pinning for Android
apps in general depends on how quickly developers
can push new certiﬁcate pins to their users’ devices.
Hence, we were interested in assessing the frequency
for app updates.

Although newer Android versions have an auto
update feature for apps, this feature is opt-in. Fur-
thermore, the default is that app updates are only
downloaded in case a device is connected to a WiFi.
Hence, even auto-updates are not guaranteed to hap-
pen instantly.

Information about update frequencies is not eas-
ily accessible via Google Play. To gain insights into
users’ update behaviour, we cooperated with a pop-
ular anti-virus software vendor for Android with an
install base of 5 million devices. Our cooperation
partner runs a telemetry program and gathers user
data for all users that participate in that program.
From January 2014 to December 2014, we collected
data for 784,721 unique apps and 871,911 unique
users. The 871,911 users that participated in the
telemetry program and gave their consent to anony-
mously analyze the data for our research yield the
following meta information:
Pseudonym We

random
pseudonym to each device to protect the users’
privacy. The pseudonym did not reveal any
private information.

assigned a

256-bit

DeviceInfo We collected manufacturer- and device
model information as well as the installed An-
droid version.

DeviceFlags We gathered three diﬀerent ﬂags for
(1) Whether developer options
every device:
were enabled, (2) whether app installs from un-
trusted sources were allowed and (3) whether
USB debugging was enabled.

PackageInfo For every (pre-)installed app we
gathered the package name and version code.
PackageHashes For every (pre-)installed app we
gathered SHA256 checksums of the packages
and their corresponding signing keys.

Timestamps We gathered timestamps for when we

nections as opposed to only 45,247 connections in the
conservative case. Naturally, we are unable to spec-
ify which pinning strategy we would suggest, but
extrapolating from the conservative scenario i.e. ap-
plying the percentages of which pinning strategy is
applicable in the small conservative data-set to the
larger data-set, 140,020 cases would be eligible for
leaf pinning, while we would recommend CA pin-
ning for 838 connections.

Figure 1: Statistics and Classiﬁcation Results for
Apps; Network Access includes apps with custom-
coded,
library- and dynamic HTTPS and HTTP
connections.

saw an app version installed on a device.

Figure 2: Statistics and Classiﬁcation Results for
Connections.

Our interest focused on third party apps such
as facebook or games, as these apps get updates
pushed via Android’s default update mechanism.
We excluded Google apps and device vendor speciﬁc
apps from our analysis, since these can be updated

12

250  24th USENIX Security Symposium 

USENIX Association

through special update channels provided by Google
or the device vendor. We identiﬁed Google apps and
device vendor apps based on the keys they have been
signed with [6].

For third party apps, we found that on average
40% of all users update to a new version on the re-
lease day. Around half of all app users update within
the ﬁrst week after release and 70% update within 30
days after release. However, to update all devices,
on average 200 days elapse. Figure 3 illustrates the
average apps update periods.

via conﬁguration ﬁles that can easily be updated via
a secure remote connection. Such an update mecha-
nism could be enforced immediately and developers
would not depend on the (lazy) update behaviour
of their users. An alternative pinning deployment
strategy would be to use multiple origins for a TLS
connection, e. g. having pin1.example.com for one
pin version and pin2.example.com for a second ver-
sion. Both mechanisms allow for out-of-band pin
updates but come with some extra eﬀort on the de-
velopers’ side.

7 Developer Support
After conducting a large scale analysis for real world
Android apps and the applicability of pinning, we
were also interested in the developers’ point of view
as the actors who actually implement pinning. First,
we collected informative feedback from developers
to learn more about their view on pinning. Second,
based on their valuable and constructive feedback,
we built a tool that supports developers in the pro-
cess of deciding whether to implement pinning and
eases the implementation.

7.1 Feedback
We analyzed all apps in our sample set and ex-
tracted possible candidates for pinning 7. For those,
we extracted the email addresses of the developers
from Google Play, taking care not to create multi-
ple emails for the same recipient, which left us with
roughly 3,200 addresses. We emailed a random sam-
ple of 500 developers with an introductory email and
the plea to provide us feedback on their experience
with pinning, or, if they were not the developer, to
please forward the email to their app’s developer.
Our outreach to developers was intended for a qual-
itative analysis of their feedback and comments to
be used as the foundation to build our tool. A quan-
titative analysis was not our primary focus. We were
able to gather 498 responses, of which we manually
removed 4 who had answered in a nonsensical way
or who clearly did not understand English. After
we analyzed the 45 responses, we had gained insight
into the major problem areas, a saturation of new in-
put was reached and more responses would probably
not have provided more valuable insights.

7Here we made conservative choices to prevent unnecessar-

ily bothering developers.

8Given the lack of a platform comparable to Amazon Me-
chanical Turk for software developer studies, which also means
that they donate their time to our research for free, a response
rate of 10% seems quite reasonable.

Figure 3: Average days between the release of a new
app version and its installation.

These numbers illustrate that app updates are
unsuitable for security-critical app components. In
case of pinning, half of all users of an app would be
unable to use the app during the ﬁrst week after the
update is released, since the pinning-secured TLS
handshakes would fail 6.

6.4 Discussion
Our results have multiple major implications: The
majority of TLS connections happen in third party
libraries (86.33%) and another 68.85% of connec-
tions are established with shared hosts. However, al-
though only 4.25% of all TLS connections seem to be
good candidates for pinning, the current situation of
only 45 apps that actually implement pinning leaves
much room for improvement. An additional hurdle
for deploying pinning are the lazy update frequen-
cies of many users; losing half of the users for a total
of one week after a certiﬁcate (pin) update is unac-
ceptable for both app developers and their users. To
facilitate the use of pinning for eligible developers,
we cannot recommend to hard-code certiﬁcate pins
into app binaries. Instead, pins should be included
6We assume that apps use TLS-secured connections for
critical components and do not work properly without Inter-
net access.

USENIX Association  

24th USENIX Security Symposium  251

13

To build our tool with the best possible feature
set and usability in mind, we were mainly interested
in the following aspects:

Knowledge About Pinning 15 (a third) of our
participants stated they knew what pinning was.
We asked them to explain this knowledge, and their
replies varied from correct mentions of “custom, self-
signed certiﬁcates”, “reduction of the reliance on in-
termediate/root certiﬁcates, if a intermediate/root
gets compromised you don’t.” and “mobile apps that
talk to the same well known server all the time”
over “securing the communication between the app
and the server without needing to pay to issuers out
there” to “i don’t know” and confused and/or wrong
answers like “when you change the servers and/or
certiﬁcates more often”. We rated 80% of the an-
swers as sensible.
Key Result: Only a quarter of the developers who
gave us feedback have a basic understanding of
pinning.

Desired Change: More detailed and critical ex-
planation of what pinning is and how it works
as part of the oﬃcial Android documentation.

Obstacles Six participants had considered imple-
menting pinning and decided against it. The reasons
ranged from “laziness” over confusion to complaints
about the complexity and the lack of an “out-of-
the-box solution”. To the two thirds of our par-
ticipants who didn’t know what pinning was, we
showed a short explanatory text 9 and asked them to
rate what they imagined could hypothetically keep
them from using pinning or convince them to stay
with the standard solution. We showed the same
set of possible reasons to the developers who were
informed about pinning and asked how much these
reasons contributed to their not implementing pin-
ning. They ranked “fear of losing users with old
app versions / due to hard TLS fails” the high-
est, followed by ”updates required when a certiﬁ-
cate changes” and “complexity of the implementa-
tion”. They said the standard solution was prefer-
able, because “it is easier”, they “trust in the existing
CA-ecosystem” and “already own CA-signed certiﬁ-
cates”, but rather not because of “employing several
diﬀerent certiﬁcates”.
Key Result: Of those who had heard of pinning,
40% had considered implementing it, but dis-
counted it for being unusable or hard to imple-
ment.

9taken and adapted from www.owasp.org

Desired Change: Provide concrete sample code

for the speciﬁc use case or app.

Wishlist We received wishes for “good tutorials
and programming examples”, “example code”, “li-
braries across platforms”, a “native Android API”,
a “test period and simple implementations” and the
possibility to “do the same for the web front-end”.
Key Result: Developers want better tool support

and support in the decision process.

Desired Change: Easy-to-use tool support.

7.2 Tool Support
The developer feedback conﬁrmed that more tool
support is required and requested. When oﬀering
security solutions, we have to keep in mind that de-
velopers usually do not have a strong security fo-
cus and are not TLS experts, therefore, choosing
and implementing secure solutions must be made as
easy as possible. To this end, we built a tool that
supports developers with implementing secure cer-
tiﬁcate validation in general; it additionally helps
to decide whether pinning is the appropriate strat-
egy. We made a web application publicly accessible
at https://pinning.android-ssl.org/, which we
base on our classiﬁcation framework, the evaluation
results and the developer study’s results. We chose
to implement our tool as a web application, since
it is easily accessible and allows to keep the data
backend up-to-date.

Developers and app users can upload APK ﬁles
and have results presented to them in a clear web
interface. First of all, the developers need to up-
load their app’s APK ﬁle, whereupon the web ap-
plication conducts all required information extrac-
tion steps (cf. Section 4) and presents the developer
with an overview of relevant API calls and the cor-
responding remote origins that could be extracted.
To increase accuracy, in the next step the developers
are asked (1) whether they hold ownership for the
relevant API calls and (2) whether they control the
TLS conﬁguration for the extracted remote origins
(to keep the workﬂow as simple as possible and not
overcharge the developer with unnecessary informa-
tion, we ﬁlter out well known libraries and popular
origins). Involving developers into the decision pro-
cess is especially important in cases where automatic
classiﬁcation might not reveal accurate results, such
as for conﬁgured origins (cf. Section 4).

Finally, the strategy classiﬁcation is conducted
and we present the developer with our recommenda-
tion for making their connections as secure as pos-

252  24th USENIX Security Symposium 

USENIX Association

14

sible. In case the default strategy was selected, we
do not recommend the developer to take further ac-
tion. In case leaf or CA pinning is recommended, the
developers are encouraged to increase their app’s se-
curity by implementing pinning. However, we also
inform the developers about the downsides of pin-
ning in terms of updatability of certiﬁcate pins (cf.
Section 6.3). In a last step, the developer is oﬀered
support for implementing pinning.

For any given relevant API call and the corre-
sponding remote origin, concrete example code for
pinning is generated over the following steps:

1. The remote origin’s certiﬁcate is fetched and the

corresponding pin is computed.

2. A PinningTrustManager that uses the pin for

certiﬁcate validation is generated.

3. Surrounding

that

code

includes

the
rele-
PinningTrustManager
for an
vant API calls is generated, e.g.
HTTPSUrlConnection,
is
generated that is initialized with the given
PinningTrustManager.

SSLContext

into

the

an

The developer can then simply include this scaﬀold
into the app and proﬁt from a higher level of security.
We asked the interested developers who left their
contact information in our developer study to test
our web application; 7 participated and gave positive
feedback on its usability.

8 Limitations
In addition to the limitations described in Section
5.5, our work has three more limiations.

First, the update behaviour analysis we conducted
for the users that participated in the AV’s telemetry
program might not necessarily represent the global
update behaviour. However, we think that security
aﬃne users who install anti-virus software on their
devices have a tendency to update their software
more quickly than average users. Therefore, update
frequencies for the global Android user population
might be even worse.

Second, the feedback we got from app developers
was based on self-reporting and might be inﬂuenced
by a self-selection bias. Since we emailed developers
who our classiﬁcation framework had identiﬁed as
good candidates for pinning, but oﬀered them no
incentive for taking part in our survey, we could only
work with the developers who responded, leaving us
with an opt-in bias. However, this is best practice
for getting feedback from developers.

Third, our tool is currently implemented as a web
service and a standalone command line tool. In the

future, it would be reasonable to include the classi-
ﬁcation and recommendation process into the pub-
lication process in Google Play: An uploaded APK
ﬁle could be run through the tool and unpinned but
pinnable connections could be pointed out to the
respective developer or pinned automatically via a
library.

9 Conclusions

We conducted an extensive analysis on the applica-
bility of pinning as an alternative and more secure
certiﬁcate validation mechanism for non-browser
software. Therefore, we analyzed 639,283 Android
apps of which 229,317 (35.9%) use TLS to secure
network connections and conservatively recommend
pinning for 11,547 (1.8%) of all apps, or 5.0% of the
apps that use TLS. This corresponds to 20,020,535
connections, of which 1,062,810 (5.3%) use TLS,
of which 45,247 (4.25%) are conservatively recom-
mendable for pinning. Optimistically, including es-
timates for unclassiﬁed connections as well as con-
nections depending on dynamic code loading, we are
able to suggest 140,858 connections or 58,817 (9.1%)
apps to take pinning into consideration.

This contradicts the common assumption that
pinning is a widely applicable solution for making
TLS certiﬁcate validation in non-browser software
more secure. Of the 229,317 apps we analyzed that
make use of TLS to secure (some of) their network
connections, 203,159 (88.6%) establish TLS connec-
tions via third-party libraries.

While we ﬁnd that pinning is applicable only for
relatively few apps and their TLS connections, a
nominal-actual comparison illustrates that there is
room for improving the current situation, as only
45 of the 11,481 apps that could beneﬁt from pin-
ning actually implement it. To help us understand
aﬀected developers and design a solution, we con-
ducted a qualitative study with 45 developers, where
we learned that pinning is relatively unknown and
often neglected due to usability problems. These
results incentivized us to build an easy-to-use web-
application to support developers in the decision
making process and guide them through the imple-
mentation of pinning for appropriate connections.

Our work concludes with the following take-aways:

Poor Support for Pinning The Android API
lacks suﬃcient support for pinning: For low-level
APIs, developers have to implement their own cer-
tiﬁcate validation and need detailed knowledge re-
garding pinning. For higher level APIs, support for
pinning is missing entirely.

15

USENIX Association  

24th USENIX Security Symposium  253

Education Developer

Limited Applicability The application of pin-
ning in non-browser software such as apps is very
limited: We recommend pinning for only 5.0% of the
229,317 TLS-enabled Android apps we analyzed.
Developer
feedback
showed that only a third of the developers who
could have implemented pinning had heard of it
before. Pinning seems to be confusing and devel-
opers misinformed. In the future, better developer
education is required as well as better developer
support.
Security Updates Our analysis of update peri-
ods for Android apps suggests that Android requires
mechanisms to quickly deploy security updates in
the future (cf. Section 6.3).
Pinning Implementation The current Android
documentation recommends to include pinning in-
formation at compile time, i. e.
the recommenda-
tion is to add pins to the source code of an app.
However, our analysis of the update behaviour of
Android users suggests that developers should not
implement certiﬁcate pins into an app’s binary. In-
stead, we recommend to set pins via conﬁguration
ﬁles that are only accessible by the respective app.

References
[1] API, A. Android TLS API.

https://developer.
android.com/training/articles/security-ssl.html.
[2] Bates, A., Pletcher, J., Nichols, T., Hollembaek,
B., Tian, D., Butler, K. R., and Alkhelaifi, A. Se-
curing ssl certiﬁcate veriﬁcation through dynamic link-
ing. CCS ’14, ACM, pp. 394–405.

[3] Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
Housley, R., and Polk, W. RFC 5280 Internet X.509
Public Key Infrastructure Certiﬁcate and Certiﬁcate Re-
vocation List (CRL) Proﬁle.
https://datatracker.
ietf.org/doc/rfc5280/?include_text=1, May 2008.

[4] Desnos, A. Androguard. http://code.google.com/p/

androguard/.

[5] Evans, C., Palmer, C., and Sleevi, R. Public Key
Pinning Extension for HTTP. http://tools.ietf.org/
html/draft-ietf-websec-key-pinning-21, Oct 2014.
Internet-Draft.

[6] Fahl, S., Dechand, S., Perl, H., Fischer, F., Smrcek,
J., and Smith, M. Hey, nsa: Stay away from my market!
future prooﬁng app markets against powerful attackers.
CCS ’14, ACM, pp. 1143–1155.

[7] Fahl, S., Harbach, M., Muders, T., Baumgärtner,
L., Freisleben, B., and Smith, M. Why Eve and Mal-
lory Love Android: An Analysis of Android SSL (in)Se-
curity. CCS ’12, ACM, pp. 50–61.

[8] Fahl, S., Harbach, M., Perl, H., Koetter, M., and
Smith, M. Rethinking SSL Development in an Appiﬁed
World. CCS ’13, ACM, pp. 49–60.

[9] Georgiev, M., Iyengar, S., Jana, S., Anubhai, R.,
Boneh, D., and Shmatikov, V. The Most Dangerous
Code in the World: Validating SSL Certiﬁcates in Non-
browser Software. CCS ’12, ACM, pp. 38–49.

[10] Hoffman, P., and Schlyter, J. The DNS-Based Au-
thentication of Named Entities (DANE) Transport Layer
Security (TLS) Protocol: TLSA. RFC 6698 (proposed
standard), IETF, 2012. http://tools.ietf.org/html/
rfc6698.

[11] Kranch, M., and Bonneau, J. Upgrading HTTPS in
Mid-Air: An Empirical Study of Strict Transport Secu-
rity and Key Pinning.

[12] Laurie, B., Langley, A., and Kasper, E. RFC
6962 Certiﬁcate Transparency. http://tools.ietf.org/
html/rfc6962, June 2013.

[13] Lu, L., Li, Z., Wu, Z., Lee, W., and Jiang, G. Chex:
Statically vetting android apps for component hijacking
vulnerabilities. CCS ’12, ACM, pp. 229–240.

[14] Marlinspike, M. Android Pinning. https://github.

com/moxie0/AndroidPinning.

[15] Marlinspike, M. TACK: Trust Assertions for Certiﬁ-

cate Keys. http://tack.io/draft.html.

[16] Marlinspike, M. SSL And The Future Of Authenticity.

In BlackHat USA, 2011.

[17] OWASP.

OWASP Certiﬁcate Pinning Guide.

https://www.owasp.org/index.php/Certificate_
and_Public_Key_Pinning.

[18] Perl, H., Fahl, S., and Smith, M. You Won’t Be Need-
ing These Any More: On Removing Unused Certiﬁcates
From Trust Stores. In Financial Cryptography and Data
Security 2014 (2014).

[19] Poeplau, S., Fratantonio, Y., Bianchi, A., Kruegel,
C., and Vigna, G. Execute This! Analyzing Unsafe and
Malicious Dynamic Code.

[20] Rescorla, E. RFC 2818 HTTP Over TLS. http://

tools.ietf.org/html/rfc2818, May 2000.

[21] Santesson, S., Myers, M., Ankney, R., Malpani, A.,
Galperin, S., and Adams, C. RFC 6960 X.509 Internet
Public Key Infrastructure Online Certiﬁcate Status Pro-
tocol - OCSP. https://tools.ietf.org/html/rfc6960,
June 2013.

[22] Sounthiraraj, D., Sahs, J., Greenwood, G., Lin, Z.,
and Khan, L. SMV-Hunter: Large Scale, Automated
Detection of SSL/TLS Man-in-the-Middle Vulnerabili-
ties in Android Apps.

[23] Tendulkar, V., and Enck, W. An Application Pack-
age Conﬁguration Approach to Mitigating Android SSL
Vulnerabilities.

[24] Vallina-Rodriguez, N., Amann, J., Kreibich, C.,
Weaver, N., and Paxson, V. A tangled mass: The
android root certiﬁcate stores. CoNEXT ’14, ACM,
pp. 141–148.

[25] Weiser, M. Program Slicing. IEEE TRANSACTIONS
ON SOFTWARE ENGINEERING VOL. SE-10, NO. 4
(1984), 352–357.

[26] Wendlandt, D., Andersen, D. G., and Perrig, A.
Perspectives:
Improving ssh-style host authentication
with multi-path probing. ATC’08, USENIX Association,
pp. 321–334.

254  24th USENIX Security Symposium 

USENIX Association

16

