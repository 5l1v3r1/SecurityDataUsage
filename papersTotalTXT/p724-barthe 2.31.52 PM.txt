Veriﬁed Security of Redundancy-Free Encryption

from Rabin and RSA

Gilles Barthe

IMDEA Software Institute
Campus de Montegancedo

28660 Madrid, Spain

gilles.barthe@imdea.org

David Pointcheval

École Normale Supérieure

45 Rue d’Ulm

75230 Paris Cedex 05, France
david.pointcheval@ens.fr

Santiago Zanella Béguelin

Microsoft Research

7 JJ Thomson Avenue

CB3 0FB Cambridge, UK

santiago@microsoft.com

ABSTRACT
Veriﬁed security provides a ﬁrm foundation for crypto-
graphic proofs by means of rigorous programming language
techniques and veriﬁcation methods. EasyCrypt is a frame-
work that realizes the veriﬁed security paradigm and sup-
ports the machine-checked construction and veriﬁcation of
cryptographic proofs using state-of-the-art SMT solvers, au-
tomated theorem provers and interactive proof assistants.
Previous experiments have shown that EasyCrypt is eﬀective
for a posteriori validation of cryptographic systems. In this
paper, we report on the ﬁrst application of veriﬁed security
to a novel cryptographic construction, with strong security
properties and interesting practical features. Speciﬁcally,
we use EasyCrypt to prove in the Random Oracle Model
the IND-CCA security of a redundancy-free public-key en-
cryption scheme based on trapdoor one-way permutations.
Somewhat surprisingly, we show that even with a zero-length
redundancy, Boneh’s SAEP scheme (an OAEP-like construc-
tion with a single-round Feistel network rather than two)
converts a trapdoor one-way permutation into an IND-CCA-
secure scheme, provided the permutation satisﬁes two addi-
tional properties. We then prove that the Rabin function
and RSA with short exponent enjoy these properties, and
thus can be used to instantiate the construction we propose
to obtain eﬃcient encryption schemes. The reduction that
justiﬁes the security of our construction is tight enough to
achieve practical security with reasonable key sizes.

Categories and Subject Descriptors
E.3 [Data encryption]: Public key cryptosystems; F.3.1
[Logics and Meanings of Programs]: Specifying and
Verifying and Reasoning about Programs

General Terms
Security, Veriﬁcation, Languages

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’12, October 16–18, 2012, Raleigh, North Carolina, USA.
Copyright 2012 ACM 978-1-4503-1651-4/12/10 ...$15.00.

Keywords
Provable security, machine-checked proofs, public-key en-
cryption

1.

INTRODUCTION

More than three decades after its inception by Rivest,
Shamir and Adleman, the RSA algorithm [40] has become
a recommendation of several
international standards for
public-key cryptography and is widely used in practical cryp-
tosystems.
In order to achieve the level of security man-
dated by modern cryptography, RSA is used for instantiat-
ing cryptographic systems based on trapdoor one-way func-
tions, rather than as a standalone primitive. The prevailing
deﬁnition of security for public-key encryption schemes is
the notion of ciphertext indistinguishability against chosen-
ciphertext attacks (IND-CCA) [39], which requires that no ef-
ﬁcient adversary with access to a decryption oracle be able
to distinguish between the ciphertexts resulting from en-
crypting two messages of its choice. Since IND-CCA security
cannot be achieved by deterministic encryption algorithms
like RSA, encryption systems adopt the encode-then-encrypt
paradigm, in which a message is pre-processed and random-
ized before encryption. For instance, the PKCS standard
recommends that the RSA algorithm be used together with
the Optimal Asymmetric Encryption Padding [11] scheme
(OAEP), a two-round Feistel construction due to Bellare and
Rogaway. In OAEP, redundancy is added during the encod-
ing phase with the goal of achieving plaintext-awareness,
that is, of making infeasible for an adversary to obtain a
valid ciphertext other than by encrypting a known plain-
text. Although the formalization of plaintext-awareness has
unveiled subtleties (see Section 6 for a brief discussion), it
is an appealing notion satisﬁed by many prominent encryp-
tion schemes. Furthermore, plaintext-awareness is achieved
by cryptographic transformations [26, 27, 36] that convert
encryption schemes that are just semantically secure under
chosen-plaintext attacks [29] into IND-CCA-secure schemes.
As a consequence, it was a widespread belief that plaintext-
awareness was necessary to achieve IND-CCA security.
In
2003, Phan and Pointcheval [37] proved this intuition wrong,
by proposing the ﬁrst IND-CCA-secure encryption schemes
without redundancy, both in the ideal-cipher model and the
random oracle model. They showed that a trapdoor one-way
permutation combined with a full-domain random permuta-
tion, in a similar way to the FDH signature scheme [12],
suﬃce to build a redundancy-free IND-CCA-secure scheme.
In addition, Phan and Pointcheval showed that a 3-round
version of OAEP together with a partial-domain one-way

724permutation would not require redundancy, as in the clas-
sical OAEP construction [11, 28]. This result was later im-
proved when it was shown that (full-domain) one-wayness
on its own is actually enough to eliminate redundancy in
a 3-round version of OAEP [38]. Abe et al. [2] construct a
redundancy-free scheme based on a 4-round Feistel network
that achieves optimal ciphertext overhead (but that imposes
a minimal message size). This line of work was further devel-
oped in a series of papers, including [20, 33], in the context
of identity-based encryption and DL-based cryptosystems.
In this paper, we revisit the problem of designing
redundancy-free IND-CCA-secure schemes based on trap-
door one-way functions. Our starting point is the SAEP
and SAEP+ padding schemes, put forward by Boneh [19]
in 2001. SAEP and SAEP+ are basically one-round OAEP-
like paddings, that when combined with the Rabin func-
tion or RSA with exponent 3, yield encryption schemes with
eﬃcient security reductions. We generalize Boneh’s con-
struction to an arbitrary trapdoor one-way function and we
show that SAEP padding without redundancy, which we call
ZAEP (Zero-Redundancy Asymmetric Encryption Padding),
achieves IND-CCA security in the Random Oracle Model for
a class of trapdoor one-way functions that satisfy two novel
properties: Common Input Extractability (CIE), and Sec-
ond Input Extractability (SIE). Informally, CIE allows us
to eﬃciently extract the plaintexts and randomness from
two diﬀerent ciphertexts that share the same randomness,
whereas SIE allows us to eﬃciently extract the plaintext
from a ciphertext and its randomness—in both cases, with-
out knowing the trapdoor to the underlying one-way func-
tion. Using Coppersmith algorithm [21], we then show that
the original Rabin function and RSA with short exponent
satisfy these two properties. We thus obtain two eﬃcient
encryption algorithms, that are well-suited to encapsulate
AES keys at a very low cost, with classical RSA moduli,
either under the integer factoring assumption or the RSA
assumption with exponent 3.

Our result is remarkable in two respects. First, ZAEP
is
surprisingly simple in comparison to the previous
redundancy-free 3-round variant of OAEP that was shown
to achieve IND-CCA security. Second, it constitutes the ﬁrst
application of veriﬁed security to a novel cryptographic con-
struction. Speciﬁcally, we formally verify the security re-
duction (and the exact probability bound) of ZAEP using
the EasyCrypt framework [4], which aims to make machine-
checkable security proofs accessible to the working cryp-
tographer by leveraging state-of-the-art methods and tools
for program veriﬁcation. Quite pleasingly, the functional-
ities and expressive power of EasyCrypt proved adequate
for converting an incomplete and intuitive argument into
a machine-checked proof. In less than a week, we were able
to ﬂesh out the details of the proof, including the new se-
curity assumptions, concrete security bound, and sequence
of games, and to build a machine-checked proof. As further
developed in Section 7, our work contributes to evidencing
that, as anticipated by Halevi [30], computer-aided security
proofs may become commonplace in the near future.

Organization of the paper. Section 2 describes the ZAEP
redundancy-free encryption scheme; Section 3 presents some
background on veriﬁed security and the EasyCrypt frame-
work; Section 4 overviews the machine-checked reduction of
the security of ZAEP to the one-wayness of the underlying

trapdoor permutation, while Section 5 discusses possible in-
stantiations. We conclude with a discussion on related work
in Section 6, and an analysis of the signiﬁcance of our re-
sults in Section 7. The EasyCrypt input ﬁle corresponding
to the proof presented in Section 4 appears in an extended
version [7]; all the infrastructure needed to machine-check
this proof is available on request.

2. REDUNDANCY-FREE ENCRYPTION

In 1994, Bellare and Rogaway [11] proposed the padding
scheme OAEP (see Fig. 1(a)), that in combination with a
trapdoor permutation (e.g. RSA) yields an eﬃcient encryp-
tion scheme. When encrypting using OAEP, a random value
r is ﬁrst expanded by a hash function G and then xor-ed
with the redundancy-padded input message. The resulting
value s is then hashed under an independent function H and
the result xor-ed with r to obtain t. The ciphertext is com-
puted by applying the permutation to the concatenation of
s and t. OAEP was proved IND-CCA-secure by Fujisaki et
al. [28] under the assumption that the underlying trapdoor
permutation is partial-domain one-way. This is in general a
stronger assumption than just one-wayness, but fortunately
both assumptions are equivalent in particular for RSA. The
reduction from the security of OAEP to the RSA problem
is not tight for two reasons: (1) the generic reduction from
OAEP security to the partial-domain one-wayness of the un-
derlying permutation is itself not tight, and (2) the reduction
from RSA partial-domain one-wayness to the RSA problem
introduces an extra security gap. In order to obtain a direct
reduction to the RSA problem (or the one-wayness of the
underlying permutation), one needs to add a third round
to the Feistel network used in OAEP [38]. Although this
latter reduction is still not tight, the redundancy resulting
from padding the input message can be removed without
breaking the proof.

Boneh [19] showed that by exploiting Coppersmith algo-
rithm [21], it is possible to shave oﬀ one round of OAEP
without compromising security. Encryption in the resulting
scheme, SAEP (see Fig. 1(c)), works by choosing a random
value r, hashing it under a function G and xor-ing it with the
message padded with a zero-bitstring of length k0. The re-
sulting value s is then concatenated with the random value
r and fed to the RSA function. However, an eﬃcient re-
duction is possible only if a small RSA public exponent is
used, or if the Rabin function is used instead. The security
reduction of SAEP is quite tight, but the redundancy intro-
duced when padding the input message is essential and can-
not be removed—as a by-product, SAEP achieves plaintext-
awareness. We revisit SAEP with zero-length redundancy
(i.e., letting k0 = 0) and show that a reduction to the one-
wayness of the underlying trapdoor permutation is still pos-
sible under additional (but achievable) assumptions.

2.1 A Novel Redundancy-Free Scheme

We recall the SAEP construction [19] with zero-length re-
dundancy (see Fig. 1(d)). We use k to denote the length
of the random value used during encryption and ℓ to de-
note the length of input messages. Let (KGf , f, f −1) be a
family of trapdoor one-way permutations on {0, 1}n, where
n = k + ℓ. For any pair of keys (pk, sk) output by the key
generation algorithm KGf , fpk(·) and f −1
sk (·) are permuta-
tions on {0, 1}n and inverses of each other. We model fpk
and f −1
sk as two-input functions from {0, 1}k × {0, 1}ℓ onto

725m k 0k0

⊕

s

G

H

r

⊕

t

m

⊕

s

⊕

u

F

G

H

r

⊕

t

r

r

m k 0k0

G

⊕

s

r

r

G

m

⊕

s

(a) OAEP

(b) 3-round OAEP

(c) SAEP

(d) ZAEP

Figure 1: Asymmetric Encryption Paddings

{0, 1}n. Let in addition G : {0, 1}k → {0, 1}ℓ be a hash
function, which we model as a random oracle in the reduc-
tion [10]. The ZAEP encryption scheme is composed of the
triple of algorithms (KG, E , D) deﬁned as follows:

Key Generation KG is the same as the key generation al-
gorithm KGf of the underlying trapdoor permutation;

Encryption Given a public key pk and an input message
m ∈ {0, 1}ℓ, the encryption algorithm Epk(m) chooses
uniformly at random a value r ∈ {0, 1}k and outputs
the ciphertext c = fpk(r, G(r) ⊕ m);

Decryption Given a secret key sk and a ciphertext c, the
decryption algorithm Dsk(c) computes (r, s) = f −1
sk (c)
and outputs m = s ⊕ G(r). No additional check is
required because all ciphertexts are valid.

2.2 Adaptive Security of ZAEP

We recall the usual deﬁnitions of trapdoor one-way
function and IND-CCA security for public-key encryption
schemes.

Deﬁnition 1 (Trapdoor one-way function) Consider
trapdoor functions (KG, f, f −1) on {0, 1}n.
a family of
The success probability SuccOW
(I) of an algorithm I in
inverting fpk on a freshly generated public-key pk and a
uniformly chosen input is deﬁned as follows:

f

Pr(cid:20) (pk, sk) ← KG(1η);

x $← {0, 1}n; x′ ← A(fpk(x))

: fpk(x) = fpk(x′)(cid:21)

In an asymptotic setting, a family of trapdoor functions is
one-way if this probability is negligible on the security pa-
rameter η for any eﬃcient (probabilistic polynomial-time)
algorithm I.

Deﬁnition 2 (IND-CCA security) The advantage of an
adversary A = (A1, A2) against the IND-CCA security
of an asymmetric encryption scheme Π = (KG, E , D),
AdvCCA

Π (A), is deﬁned as follows:

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)

Pr




(pk, sk) ← KG(1η);
(m0, m1, σ) ← ADsk(·)
(pk);
b $← {0, 1}; c∗ ← Epk(mb);
b′ ← ADsk(·6=c∗)

(c∗, σ)

1

2

: b = b′


−

1
2

In both stages of the experiment the adversary has access
to a decryption oracle, but in the second stage A2 cannot
query for the decryption of the challenge ciphertext c∗. In

an asymptotic setting, Π is IND-CCA-secure if all eﬃcient
adversaries have a negligible advantage.

In order to prove the IND-CCA security of ZAEP, we re-
quire that the underlying trapdoor function satisfy the two
properties deﬁned below.

Deﬁnition 3 (Second-Input Extractability) A family
of trapdoor functions (KG, f, f −1) satisﬁes SIE if there ex-
ists an eﬃcient algorithm sie that given a public key pk,
c ∈ {0, 1}n and r ∈ {0, 1}k, outputs s if c = fpk(r, s) or ⊥
otherwise.

Observe that Second-Input Extractability collapses the
distinction between one-wayness and partial one-wayness.
If a family of one-way functions satisﬁes Second-Input Ex-
tractability, then it is also partial-domain one-way over its
ﬁrst input.

Deﬁnition 4 (Common-Input Extractability) A fam-
ily of trapdoor functions (KG, f, f −1) satisﬁes CIE if there
exists an eﬃcient algorithm cie that given a public key pk
and c1, c2 ∈ {0, 1}n, outputs (r, s1, s2) if c1 = fpk(r, s1),
c2 = fpk(r, s2) and s1 6= s2, or ⊥ otherwise.

Since we conduct our proof in a concrete security setting
rather than in an asymptotic setting, and we prove exact
probability and time bounds, we ﬁx the security parame-
ter and omit it in the remainder. We prove the following
security result for ZAEP.

Theorem 1 Let (KG, f, f −1) be a family of trapdoor per-
mutations satisfying both SIE and CIE properties. Let A be
an adversary against the IND-CCA security of ZAEP instan-
tiated with (KG, f, f −1) that runs within time tA and makes
at most qG queries to the random oracle G and at most qD
queries to the decryption oracle. Then, there exists an algo-
rithm I running within time tI such that

Succ

OW
f

tI ≤ tA + 2qGqD tsie + q2
qD
2n

CCA
ZAEP(A) −

(I) ≥ Adv

D tcie

where tcie (resp. tsie) is an upper bound on the execution time
of the algorithm cie (resp. sie) for (KG, f, f −1).

In Section 4 we give an overview of a machine-checked
reductionist proof of the above theorem in EasyCrypt. We
observe that while ZAEP can be cast as an instance of SAEP
by setting the length of the padding k0 = 0, our reduction

726is diﬀerent from Boneh’s reduction for SAEP [19]; in fact,
Boneh’s exact security bounds are meaningless as soon as
k0 is of the order of log(qD).

3. A PRIMER ON VERIFIED SECURITY

Veriﬁed security [4, 6] is an emerging approach to cryp-
tographic proofs. While adhering to the principles and the
methods of provable security, veriﬁed security takes the view
that cryptographic proofs should be treated in a manner
similar to high-integrity software, so that conﬁdence in the
design of a cryptographic system is no lower than conﬁdence
in the software systems that use it. Thus, veriﬁed security
mandates that security proofs are built and validated using
state-of-the-art technology in programming languages and
veriﬁcation.

EasyCrypt [4] is a recent realization of the veriﬁed secu-
rity paradigm. As its predecessor CertiCrypt [6], it adopts
a code-centric view of cryptography. Under this view, secu-
rity assumptions and goals are formalized using probabilistic
programs, also called games. Each game is a probabilistic
imperative program composed of a main command and a
collection of concrete procedures and adversaries. More-
over, the statements of the language include deterministic
and probabilistic assignments, conditional statements and
loops, as given by the following grammar:

C ::= skip

|
|
|
|
|
|

V ← E
V $← DE
if E then C else C
while E do C
V ← P(E , . . . , E )
C; C

nop
deterministic assignment
probabilistic assignment
conditional
while loop
procedure call
sequence

where V is a set of variable identiﬁers, P a set of procedure
names with a distinguished class of abstract procedures used
to model adversaries, E is a set of expressions, and DE is
a set of distribution expressions. The latter are expressions
that evaluate to distributions from where values can be sam-
pled; for the purpose of this paper, we only need to consider
uniform distributions over bitstrings.

Programs in EasyCrypt are given a denotational seman-
tics, that maps initial memories to sub-distributions over
ﬁnal memories, where a memory is a (well-typed) mapping
from variables to values. We let Pr [c, m : A] denote the
probability of an event A in the sub-distribution induced by
executing the program c with initial memory m, which we
omit when it is not relevant. For additional details on the
semantics, we refer the reader to [6].

As envisioned by Halevi

[30] and Bellare and Rog-
away [13], this code-centric view of cryptographic proofs
leads to statements that are amenable to veriﬁcation using
programming language techniques. EasyCrypt captures com-
mon reasoning patterns in cryptographic proofs by means of
a probabilistic relational Hoare Logic (pRHL). Judgments
in pRHL are of the form

|= c1 ∼ c2 : Ψ ⇒ Φ

where c1 and c2 are probabilistic programs, and Ψ and Φ,
respectively called the pre-condition and the post-condition,
are relations over program states. We represent these rela-
tions as ﬁrst-order formulae deﬁned by the grammar:

Ψ, Φ ::= e | ¬Φ | Ψ ∧ Φ | Ψ ∨ Φ | Ψ → Φ | ∀x. Φ | ∃x. Φ

where e stands for a Boolean expression over logical vari-
ables and program variables tagged with either h1i or h2i
to denote their interpretation in the left or right-hand side
program, respectively. We write ehii for the expression e in
which all program variables are tagged with hii. A relational
formula is interpreted as a relation on program memories.
For example, the formula xh1i + 1 ≤ yh2i is interpreted as
the relation

R = {(m1, m2) | m1(x) + 1 ≤ m2(y)}

There are two complementary means to establish the va-
lidity of a pRHL judgment. Firstly, the user can apply in-
teractively atomic rules and semantics-preserving program
transformations. Secondly, the user can invoke an auto-
mated procedure that given a logical judgment involving
loop-free closed programs, computes a set of suﬃcient condi-
tions for its validity, known as veriﬁcation conditions. In the
presence of loops or adversarial code, EasyCrypt requires the
user to provide the necessary annotations. The outstanding
feature of this procedure, and the key to its eﬀectiveness, is
that veriﬁcation conditions are expressed as ﬁrst-order for-
mulae, without any mention of probability, and thus can
be discharged automatically using oﬀ-the-shelf SMT solvers
and theorem provers.

As security properties are typically expressed in terms of
probability of events, and not as pRHL judgments, Easy-
Crypt provides mechanisms to derive from a valid judgment

|= c1 ∼ c2 : Ψ ⇒ Φ

inequalities of the form

Pr [c1, m1 : A] ≤ Pr [c2, m2 : B] (+Pr [c2, m2 : F ])

for events A, B and F that are suitably related to the post-
condition Φ. The mechanisms are described more precisely
by the next two lemmas.

Lemma 2 (Probability Lemma) Let c1 and c2 be two
games, and A and B be events such that

|= c1 ∼ c2 : Ψ ⇒ Ah1i → Bh2i

For every pair of memories m1, m2 such that m1 Ψ m2, we
have

Pr [c1, m1 : A] ≤ Pr [c2, m2 : B]

Lemma 3 (Shoup’s Fundamental Lemma) Let c1 and
c2 be two games and A, B, and F be events such that

|= c1 ∼ c2 : Ψ ⇒ (F h1i ↔ F h2i) ∧ (¬F h1i → Ah1i → Bh2i)

Then,
m1 Ψ m2, we have

for every pair of memories m1, m2

such that

Pr [c1, m1 : A] ≤ Pr [c2, m2 : B] + Pr [c2, m2 : F ]

Moreover, EasyCrypt includes support for applying proba-
bility laws (e.g. the union bound) and computing the proba-
bility of simple events. The proof of ZAEP relies on two main
rules. The ﬁrst one states that an adversary has probability
1
2 of guessing a bit b independent from its view; indepen-
dence is captured by proving that sampling the bit b after
the adversary returns its guess does not change the seman-
tics of the game. The second rule allows to upper bound the
probability that a uniformly sampled value belongs to a list

727of bounded length. For instance, if L is a list of values in A
of length at most q and x is a value sampled independently
and uniformly over A, the probability that x belongs to L is
upper bounded by q/|A|.

3.1 User Perspective

Building a cryptographic proof in EasyCrypt is a process

that involves the following tasks:

• Deﬁning a logical context, including declarations of
types, constants and operators, axioms and derived
lemmas. Declarations allow users to extend the core
language, while axioms allow to give the extension
a meaning. Derived lemmas are intermediary results
proved from axioms, and are used to drive SMT solvers
and automated provers.

• Deﬁning games, including the initial experiment en-
coding the security property to be proved, intermedi-
ate games, and a number of ﬁnal games, which either
correspond to a security assumption or allow to di-
rectly compute a bound on the probability of some
event.

• Proving logical judgments that establish equivalences
between games. This may be done fully automatically,
with the help of hints from the user in the form of re-
lational invariants, or interactively using basic tactics
and automated strategies. In order to beneﬁt from ex-
isting technology and target multiple veriﬁcation tools,
veriﬁcation conditions are generated in the intermedi-
ate language of the Why3 Software Veriﬁcation Plat-
form [18] and then translated to individual provers to
check their validity.

• Deriving inequalities between probabilities of events in
games, either by using previously proven logical judg-
ments or by direct computation.

Although the above tasks can be carried out strictly in the
order described, one can conveniently interleave them as in
informal game-based proofs. To ease this process, Easy-
Crypt provides an interactive user-interface as an instance
of ProofGeneral, a generic Emacs-based frontend for proof-
assistants. Figure 2 gives an overview of the workﬂow in the
framework.

4. SECURITY PROOF

We overview the proof of Theorem 1 in EasyCrypt. The
proof is organized as a sequence of games starting from
game CCA, that encodes an adaptive chosen-ciphertext at-
tack against ZAEP for an arbitrary adversary A, and ending
in game OW, that encodes the reduction to the one-wayness
of the underlying trapdoor permutation. These two games
are shown in Figure 3; the rest of the games are shown in Fig-
ure 4. Games are shown alongside the oracles made available
to adversary A and global variables are typeset in boldface.
Formalizing the security proof of ZAEP in EasyCrypt re-
quired providing an appropriate axiomatization of the un-
derlying trapdoor permutation and the SIE and CIE prop-
erties. We extended the expression language with the fol-
lowing operators corresponding to the permutation f , its

ProofGeneral Frontend

Emacs Shell

EasyCrypt Toplevel

Why3 API

Why3 Software Veriﬁcation Platform

SMT Solvers

Automated Provers

Interactive Provers

Alt-Ergo

CVC3
Z3
Yices

Vampire

E-Prover

SPASS

Coq

Figure 2: Overview of workﬂow in EasyCrypt

inverse, and algorithms sie and cie:

: (pkey, {0, 1}k × {0, 1}l) → {0, 1}k × {0, 1}l
op f
op finv : (pkey, {0, 1}k × {0, 1}l) → {0, 1}k × {0, 1}l
op sie : (pkey, {0, 1}k × {0, 1}l, {0, 1}k) → {0, 1}ℓ option
op cie : (pkey, {0, 1}k × {0, 1}l, {0, 1}k × {0, 1}l) →

({0, 1}k × {0, 1}ℓ × {0, 1}ℓ) option

We gave these operators a meaning by introducing their
speciﬁcations as axioms; for instance, the operator sie is
speciﬁed as follows:

axiom sie_spec :

forall (pk : pkey, sk : skey), key_pair(pk, sk) =⇒
forall (c : {0, 1}k × {0, 1}ℓ, r : {0, 1}k, s : {0, 1}ℓ),

sie(pk, c, r) = Some(s) ⇐⇒ c = f(pk, (r, s))

Veriﬁcation conditions generated during the proof are ﬁrst-
order formulae over a mixture of theories: e.g. ﬁnite maps,
integer arithmetic, exclusive-or, an the above axiomatiza-
tion of the SIE and CIE solvers. All veriﬁcation conditions
are discharged automatically using the CVC3 and Alt-Ergo
SMT solvers.

The proof itself begins by transforming the initial CCA
game into game G1, where we inline the encryption of the
challenge ciphertext and eagerly sample the random value
r∗ used. We also introduce a Boolean ﬂag bad that is set
to true whenever r∗ would be appear as a query to G in the
CCA experiment. All these changes are semantics-preserving
w.r.t. to the event b = b′ and thus we have

Pr(cid:2)CCA : b = b′(cid:3) = Pr(cid:2)G1 : b = b′(cid:3)

Game G2 behaves identically to game G1 except that the
value of G(r∗) used to mask the plaintext of the challenge
ciphertext is always chosen at random, regardless of whether
it has been queried by the adversary during the ﬁrst stage
of the experiment. Subsequent queries to G(r∗) are also
answered with a fresh random value. This only makes a
diﬀerence if the ﬂag bad is set, and applying Lemma 3, we
obtain:

|Pr(cid:2)G1 : b = b′(cid:3) − Pr(cid:2)G2 : b = b′(cid:3) | ≤ Pr [G2 : bad]

728def ← false; q ← 0;

Game CCA :
LG ← nil; c∗
(pk, sk) ← KG();
(m0, m1, σ) ← A1(pk);
b $← {0, 1};
c∗ ← Epk(mb);
def ← true;
c∗
b′ ← A2(c∗, σ);
return (b = b′)

Game OW :
(pk, sk) ← KG();
z $← {0, 1}k+ℓ;
(x, y) ← I(pk, fpk(z));
return (fpk(x, y) = fpk(z))
Adversary I(pk, z) :
LG, LD ← nil; c∗
c∗ ← z; pk ← pk;
(m0, m1, σ) ← A1(pk);
def ← true;
c∗
b′ ← A2(c∗, σ);
r ← ﬁnd r ∈ dom(LG). siepk(c∗, r) 6= ⊥;
if r 6= ⊥ then return (r, siepk(c∗, r));
else

def ← false; q ← 0;

c ← ﬁnd c ∈ dom(LD). ciepk(c∗, c) 6= ⊥;
if c 6= ⊥ then

(r, s, t) ← ciepk(c∗, c); return (r, s)

else return ⊥

Oracle G(x) :
if x /∈ dom(LG) then

LG[x] $← {0, 1}ℓ;

return LG[x]

Oracle D(c) :
if q < qD ∧ ¬(c∗

def ∧ c = c∗) then

q ← q + 1;
(r, s) ← f −1
g ← G(r);
return g ⊕ s

sk (c);

else return ⊥

Oracle G(x) :
if x /∈ dom(LG) then

c ← ﬁnd c ∈ dom(LD). siepk(c, x) 6= ⊥;
if c 6= ⊥ then

LG[x] ← LD[c] ⊕ siepk(c, x);

else

LG[x] $← {0, 1}ℓ;

return LG[x]

Oracle D(c) :
if q < qD ∧ ¬(c∗

def ∧ c = c∗) then

q ← q + 1;
r ← ﬁnd r ∈ dom(LG). siepk(c, r) 6= ⊥;
if r 6= ⊥ then return LG[r] ⊕ siepk(c, r)
else

if c ∈ dom(LD) then return LD[c]
else

c′ ← ﬁnd c′ ∈ dom(LD). ciepk(c, c′) 6= ⊥;
if c′ 6= ⊥ then

(r, s, t) ← ciepk(c, c′);
return LD[c′] ⊕ s ⊕ t;

else

if c∗

def ∧ ciepk(c, c∗) 6= ⊥ then
(r, s, t) ← ciepk(c, c∗);
LG[r] $← {0, 1}ℓ; return LG[r]⊕s;

else

LD[c] $← {0, 1}ℓ; return LD[c]

else return ⊥

Figure 3: Initial IND-CCA game and reduction to the problem of inverting the underlying permutation

In game G3 we remove the dependency of the adver-
sary’s output on the hidden bit b by applying a semantics-
preserving transformation known as optimistic sampling. In-
stead of of sampling g∗ at random and computing the chal-
lenge ciphertext c∗ as fpk(r∗, g∗ ⊕ mb), we sample directly a
value s∗ at random and compute c∗ as fpk(r∗, s∗), deﬁning
g∗ as s∗ ⊕ mb. Once this is done, and since g∗ is no longer
used elsewhere in the game, we can drop its deﬁnition as
dead-code and postpone sampling b to the end of the game,
making it trivially independent of b′. We have

Pr(cid:2)G2 : b = b′(cid:3) = Pr(cid:2)G3 : b = b′(cid:3) =

Pr [G2 : bad] = Pr [G3 : bad]

1
2

In game G4, instead of always using f −1 to compute the pre-
image (r, s) of an input c in the decryption oracle, we use
the sie and cie algorithms to compute it when possible from
previous queries made by the adversary. We can do this in
two cases:

1. when r appeared before in a query to oracle G, using

algorithm sie to obtain the second input s;

2. when r = r∗, using algorithm cie to compute s from

c∗.

When neither of these two cases occur, we use f −1 and the
secret key to invert c and obtain (r, s). Rather than sam-
pling a fresh value for G(r), we apply once more the opti-
mistic sampling transformation to sample a response m at
random and deﬁne G(r) as m ⊕ s. We store values of G(r)
computed in this fashion in a diﬀerent map L′
G. We prove
the following relational invariant between G3 and G4, which
allows to characterize the event bad of G3 in terms of the

variables of G4:

badh1i ⇐⇒ (r∗ ∈ dom(LG) ∨ r∗ ∈ dom(L′

G))h2i

To prove this, we have to ﬁrst show that the simulation of
the decryption oracle using algorithms cie and sie in G4 is
consistent with the view of the adversary in G3. We do this
by establishing that the following is a relational invariant
between the implementations of D in games G3 and G4:

def , q)h1i = (r∗, s∗, c∗

(r∗, s∗, c∗
(c∗ = fpk(r∗, s∗))h2i ∧
badh1i ⇐⇒ (r∗ ∈ dom(LG) ∨ r∗ ∈ dom(L′
(∀x ∈ dom(LGh2i).

def , q)h2i ∧

G))h2i ∧

x ∈ dom(LGh1i) ∧ LGh1i[x] = LGh2i[x]) ∧

(∀x ∈ dom(LGh1i).

x /∈ dom(LGh2i) → LGh1i[x] = L′

Gh2i[x]) ∧

(∀x. x ∈ dom(LGh1i) ↔ (x ∈ dom(LG) ∨ x ∈ dom(L′

G))h2i

We have hence that

Pr [G3 : bad] = Pr(cid:2)G4 : r∗ ∈ dom(LG) ∨ r∗ ∈ dom(L′

G)(cid:3)

In game G5 we ﬁnally eliminate every reference to f −1 from
the decryption oracle. We do this by replacing the map L′
G
with a map LD in where we store ciphertexts that implicitly
deﬁne values of G(r). We reformulate the simulation of the
decryption oracle using this map instead of L′
G, by proving
the following invariant between the implementations of D in

729Oracle G(x) :
if x = r∗ then bad ← true;
if x /∈ dom(LG) then

LG[x] $← {0, 1}ℓ;

return LG[x]

Oracle D(c) :
if q < qD ∧ ¬(c∗

def ∧ c = c∗) then

q ← q + 1;
(r, s) ← f −1
g ← G(r);
return g ⊕ s

sk (c);

else return ⊥

def ← false; q ← 0;

Game G1 G2 :
LG ← nil; c∗
bad ← false; r∗ $← {0, 1}k;
(pk, sk) ← KG();
(m0, m1, σ) ← A1(pk); b $← {0, 1};
if r∗ /∈ dom(LG) then

g∗ $← {0, 1}ℓ; LG[r∗] ← g∗;

else

bad ← true;
g∗ ← LG[r∗]; g∗ $← {0, 1}ℓ;

c∗ ← fpk(r∗, g∗ ⊕ mb); c∗
b′ ← A2(c∗, σ);
return (b = b′)

def ← true;

def ← false; q ← 0;

Game G3 :
LG ← nil; c∗
bad ← false; r∗ $← {0, 1}k;
(pk, sk) ← KG();
(m0, m1, σ) ← A1(pk);
if r∗ ∈ dom(LG) then bad ← true;
s∗ $← {0, 1}ℓ;
c∗ ← fpk(r∗, s∗); c∗
b′ ← A2(c∗, σ);
b $← {0, 1};
return (b = b′)

def ← true;

Oracle G(x) :
if x = r∗ then bad ← true;
if x /∈ dom(LG) then

LG[x] $← {0, 1}ℓ;

return LG[x]

Oracle D(c) :
if q < qD ∧ ¬(c∗

def ∧ c = c∗) then

q ← q + 1;
(r, s) ← f −1
g ← G(r);
return g ⊕ s

sk (c);

else return ⊥

def ← false; q ← 0;

G ← nil; c∗

Game G4 :
LG, L′
r∗ $← {0, 1}k;
s∗ $← {0, 1}ℓ;
c∗ ← fpk(r∗, s∗);
(pk, sk) ← KG();
(m0, m1, σ) ← A1(pk);
def ← true;
c∗
b′ ← A2(c∗, σ);
return true

Oracle G(x) :
if x /∈ dom(LG) then

if x /∈ dom(L′

G) then

LG[x] $← {0, 1}ℓ;

else

LG[x] ← L′

G[x];

return LG[x]

def ← false; q ← 0;

Game G5 :
LG, LD ← nil; c∗
r∗ $← {0, 1}k;
s∗ $← {0, 1}ℓ;
c∗ ← fpk(r∗, s∗);
(pk, sk) ← KG();
(m0, m1, σ) ← A1(pk);
def ← true;
c∗
b′ ← A2(c∗, σ);
return true

Oracle G(x) :
if x /∈ dom(LG) then

c ← ﬁnd c ∈ dom(LD). siepk(c, x) 6= ⊥;
if c 6= ⊥ then

LG[x] ← LD[c] ⊕ siepk(c, x);

else

LG[x] $← {0, 1}ℓ;

return LG[x]

Oracle D(c) :
if q < qD ∧ ¬(c∗

def ∧ c = c∗) then

q ← q + 1;
r ← ﬁnd r ∈ dom(LG). siepk(c, r) 6= ⊥;
if r 6= ⊥ then return LG[r] ⊕ siepk(c, r)
else

r ← ﬁnd r ∈ dom(L′
if r 6= ⊥ then return L′
else

G). siepk(c, r) 6= ⊥;
G[r] ⊕ siepk(c, r)

if c∗

def ∧ ciepk(c, c∗) 6= ⊥ then
(r, s, t) ← ciepk(c, c∗);
LG[r] $← {0, 1}ℓ; return LG[r] ⊕ s

else

(r, s) ← f −1
sk (c);
m $← {0, 1}ℓ; L′
return m;

G[r] ← m ⊕ s;

else return ⊥

Oracle D(c) :
if q < qD ∧ ¬(c∗

def ∧ c = c∗) then

q ← q + 1;
r ← ﬁnd r ∈ dom(LG). siepk(c, r) 6= ⊥;
if r 6= ⊥ then return LG[r] ⊕ siepk(c, r)
else

if c ∈ dom(LD) then return LD[c]
else

c′ ← ﬁnd c′ ∈ dom(LD). ciepk(c, c′) 6= ⊥;
if c′ 6= ⊥ then

(r, s, t) ← ciepk(c, c′);
return LD[c′] ⊕ s ⊕ t;

else

if c∗

def ∧ ciepk(c, c∗) 6= ⊥ then
(r, s, t) ← ciepk(c, c∗);
LG[r] $← {0, 1}ℓ; return LG[r]⊕s;

else

LD[c] $← {0, 1}ℓ; return LD[c]

else return ⊥

Figure 4: Sequence of games in the proof of ZAEP. Fragments of code displayed inside a box appear only in
the game whose name is surrounded by the matching box.

730games G4 and G5:

(LG, c∗, c∗
(∀c. (∀r ∈ dom(L′

def , q)h1i = (LG, c∗, c∗

def , q)h2i ∧
G). siepk(c, r) = ⊥)h1i ↔

(∀c′ ∈ dom(LD). ciepk(c, c′) = ⊥ ∧ c /∈ dom(LD))h2i ∧
Gh1i) ↔ (∀c ∈ dom(LD). siepk(c, r) = ⊥)h2i∧

(∀r. r /∈ dom(L′
(∀c. let (r, s) = f −1

sk (c) in

c ∈ dom(LD))h2i →
Gh1i) ∧ L′
r ∈ dom(L′

Gh1i[r] = s ⊕ LDh2i[c])

Theorem 4 (Coppersmith method) Let
be a
monic integer polynomial of degree d and N a positive inte-
ger of unknown factorization. In time polynomial in log(N )
and d, using Coppersmith algorithm one can ﬁnd all integer
solutions x0 to p(x0) = 0 mod N with |x0| < N 1/d.

p(X)

We denote by tC(N,d) an upper bound on the running time
of the above method for ﬁnding all roots modulo N of a
polynomial of degree d.

We then prove the following relational invariant between
games G4 and G5:

5.1 Short Exponent RSA

For an n-bit RSA modulus N = pq, the function

(r∗ ∈ dom(LG) ∨ r∗ ∈ dom(L′
(r∗ ∈ dom(LG) ∨ ∃c ∈ dom(LD). ciepk(c, c∗) 6= ⊥)h2i

G))h1i →

From which we obtain

Pr [G4 : r∗ ∈ dom(LG) ∨ r∗ ∈ dom(L′
Pr [G5 : r∗ ∈ dom(LG) ∨ ∃c ∈ dom(LD). ciepk(c, c∗) 6= ⊥]

G)] ≤

We can ﬁnally write an inverter I against the one-wayness
of the underlying trapdoor permutation that uses the map
LD in the previous game to perfectly simulate the decryption
oracle for the IND-CCA adversary A. However, the inverter
I only succeeds if r∗ ∈ dom(LG):

Pr [G5 : r∗ ∈ dom(LG) ∨ ∃c ∈ dom(LD). ciepk(c, c∗) 6= ⊥] ≤
Pr [OW : fpk(x, y) = fpk(z)] + Pr [OW : c∗ ∈ dom(LD)]

We bound the second term on the right-hand side of the
above inequality by qD/2n using a short sequence of games
that we omit. Putting all the above results together, we
conclude:

Pr(cid:2)CCA : b = b′(cid:3) −

(cid:12)(cid:12)(cid:12)(cid:12)

1

2(cid:12)(cid:12)(cid:12)(cid:12)

≤ Pr [OW : fpk(x, y) = fpk(z)] +

qD
2n

The execution time of tI can be bound by inspecting the

formulation of the inverter I in game OW:

• Each simulated query to G requires at most qD evalu-

ations of algorithm sie;

• Each simulated query to D requires at most qG evalu-
ations of algorithm sie and at most qD evaluations of
algorithm cie;

• When the simulation ﬁnishes, the inverter I requires
at most qG evaluations of algorithm sie and at most
qD + 1 evaluations of algorithm cie to ﬁnd the inverse
of its challenge.

Thus

tI ≤ tA + 2qGqD tsie + q2

D tcie + qG tsie + (qD + 1) tcie

The last two terms are negligible w.r.t. the rest and can be
safely ignored.

5.

INSTANTIATIONS

In this section, we show that both the Rabin function
and RSA with small exponent satisfy the properties required
for the security reduction of ZAEP. Moreover, we provide a
practical evaluation of both instantiations of ZAEP and a
comparison to 3-round OAEP. Our proofs are inspired by [19]
and rely on Coppersmith algorithm to ﬁnd small integer
roots of polynomials [21]:

RSA[N, e] : x 7→ xe mod N

is a well-known trapdoor one-way permutation on Z∗
N for
any exponent e coprime to ϕ(N ). For any non-negative
ℓ ≤ n, an element x ∈ Z∗
N can be uniquely represented as
r × 2ℓ + s, where s ∈ {0, 1}ℓ and r ∈ {0, 1}n−ℓ. We can thus
express the RSA function as a function of two arguments:

RSA[N, e] : (r, s) 7→ (r × 2ℓ + s)e mod N

We denote by RSA-ZAEP the encryption scheme resulting
from instantiating ZAEP with this function.

Second-Input Extractability. Given an output
c of
RSA[N, e] and a tentative value r, the Second-Input Extrac-
tion problem boils down to solving p(X) = 0 mod N for
p(X) = c − (r × 2ℓ + X)e mod N with the additional con-
straint |X| < 2ℓ. The Coppersmith method ﬁnds the root
s (the second input to the function when r is the correct
ﬁrst input) when 2ℓ < N 1/e, or equivalently, when ℓ < n/e.
We thus have an eﬃcient sie algorithm that executes within
time tsie ≤ tC(N,e).

Common-Input Extractability. Given two diﬀerent out-
puts c1 and c2 of RSA[N, e], the Common-Input Extraction
problem for RSA[N, e] consists in ﬁnding r, s1 and s2 such
that c1 = (r×2ℓ+s1)e mod N and c2 = (r×2ℓ+s2)e mod N ,
if they exist. Let us consider the two polynomials

p1(X, ∆) = c1 − X e mod N
p2(X, ∆) = c2 − (X + ∆)e mod N

These polynomials should be equal to zero for the correct
values x = r × 2ℓ + s1 mod N for X and δ = s2 − s1 mod N
for ∆. Therefore, the resultant polynomial R(∆) of p1 and
p2 in X, which is the determinant of the 2e × 2e Sylvester
Matrix associated to the polynomials p1 and p2 in the vari-
able X, and thus with coeﬃcients that are polynomials in
∆ (of degree 0 for the coeﬃcients of p1, but of degree up to
e for the coeﬃcients of p2), is a polynomial with δ = s2 − s1
as a root. Due to the speciﬁc form of the matrix, R(∆)
is of degree at most e2 modulo N , and the Coppersmith
method ﬁnds the root δ provided 2ℓ < N 1/e2
or equiva-
lently, when ℓ < n/e2. Once this root is known, we can
focus on the monic polynomials p1(X) = c1 − X e mod N
and p2(X) = c2 − (X + δ)e mod N , for which x is a common
(and unique) root. These two polynomials are distinct, but
are both divisible by X − x, which can be found by com-
puting their GCD. We thus have an eﬃcient cie algorithm
that executes within time tcie bounded by the running time
of Coppersmith method for ﬁnding δ, tC(N,e2), plus the time
needed to compute the GCD of two polynomials of degree
e, which we denote tGCD(e).

7315.2 Rabin Function

The Rabin function is unfortunately not a permutation.
However, for particular moduli we can limit its domain and
co-domain to convert it into a bijection. More precisely, if
p and q are Blum integers, then −1 a non-quadratic residue
modulo p and q, and hence is a false square modulo N =
pq. Put otherwise, JN (−1) = +1 where JN (·) denotes the
Jacobi symbol modulo N . In addition, any square x in Z∗
N
admits four square roots in Z∗
N , derived from the two pairs of
square roots of x in Z∗
p and Z∗
q using the Chinese Remainder
Theorem. As a consequence, one and only one is also a
quadratic residue modulo N , which we denote α. Then, α
and −α are the two square roots of x with Jacobi symbol
+1. We will ignore the other two square roots of x that
have Jacobi symbol −1. Let JN denote the subgroup of the
multiplicative subgroup of ZN whose elements have Jacobi
symbol +1 (membership can be eﬃciently decided). We
additionally restrict JN to the elements smaller than N/2,
and we denote this subset J <
N . We now consider the function

SQ[N ] : J <
SQ[N ] : (x, b) 7→ (−1)bx2 mod N

N × {0, 1} → JN

The inverse function takes an element y ∈ JN , which may
be a true quadratic residue or a false one. In the former case,
one extracts the unique square root α that is also a quadratic
residue and sets x to be the smallest value in {α, N − α}
that is less than N/2; the inverse of y is (x, 0). In the latter
case, one does as before to compute x, but from −y, which
is a true quadratic residue; the inverse of y is (x, 1). The
function SQ[N ] thus deﬁned is a bijection from J <
N × {0, 1}
onto JN .

N \JN (instead of J <

One-wayness. Let us assume that an algorithm A can in-
vert SQ[N ] with non-negligible probability. Then one can
ﬁrst choose a random z ∈ Z∗
N ) and a
random bit b, and submit y = (−1)b × z2 mod N to A. This
element y is uniformly distributed in JN , and thus with non-
negligible probability A outputs (x, b′) ∈ J <
N × {0, 1} such
that y = (−1)b′
×x2 = (−1)b ×z2 mod N . Since −1 is a false
quadratic residue, necessarily b′ = b and x2 = z2 mod N ,
with x ∈ JN and z 6∈ JN . The GCD of x − z and N is
either p or q, from which N can be factored. This function
is thus one-way under the integer factoring problem.

As above, in order to be used with ZAEP, we have to
consider the function SQ[N ] as a function of two bitstrings.
Given an input (x, b) ∈ J <
N ×{0, 1}, for any 0 ≤ ℓ ≤ n−1 we
N as x = r × 2ℓ + s, with s ∈ {0, 1}ℓ
can uniquely write x ∈ Z∗
and r ∈ {0, 1}n−1−ℓ. We consider thus the function:

SQ[N ] : {0, 1}n−ℓ × {0, 1}ℓ → {0, 1}n
SQ[N ] : (bkr, s) 7→ (−1)b × (r × 2ℓ + s)2 mod N

Second-Input Extractability. Given an output c of SQ[N ]
and a pair of values b, r, the Second-Input Extraction prob-
lem consists in solving the equation p(X) = 0 mod N for
p(X) = c − (−1)b × (r × 2ℓ + X)2 mod N with the additional
constraint |X| < 2ℓ. The above Coppersmith method ﬁnds
the root s (the second input to SQ[N ] used to compute c if
bkr is the correct ﬁrst input) provided 2ℓ < N 1/2, or equiva-
lently when ℓ < n/2. We thus have an eﬃcient sie algorithm
that runs within time tsie ≤ tC(N,2).

Common-Input Extractability. The Common-Input Ex-
traction problem can be solved as in the case of RSA, pro-
vided ℓ < n/4. We thus have an eﬃcient cie algorithm whose
running time tcie is bounded by tC(N,4) + tGCD(2).

We denote by Rabin-ZAEP the encryption scheme result-
ing from instantiating ZAEP with the function SQ[N ]. Since
this function operates only on elements in J <
N , the encryp-
tion algorithm may have to iterate:

Key Generation The algorithm KG generates two Blum
integers p and q of length n/2, and outputs (pk, sk),
where pk = N = pq and sk = (p, q);

Encryption Given a public key N and a message m ∈
{0, 1}ℓ, the encryption algorithm iteratively samples
a random value r ∈ {0, 1}k−1 and a bit b and sets
s = m ⊕ G(bkr), stopping when x = r × 2ℓ + s ∈ J <
N .
This requires on average one iteration only. The ci-
phertext c is computed as

SQ[N ](bkr, s) = (−1)b × (r × 2ℓ + s)2 mod N ;

Decryption Given a secret key (p, q) and a ciphertext c, D
ﬁrst inverts SQ[N ] using the prime factors (p, q) of N
and gets (x, b). It then parses x as r × 2ℓ + s mod N
and outputs m = s ⊕ G(bkr).

5.3 Practical Considerations

For RSA-ZAEP, all the required properties to achieve IND-

CCA-security hold as long as e < pn/ℓ. For a practical

message size ℓ, e has to be small (e.g. e = 3). But for a
small exponent e, both sie and cie algorithms are eﬃcient
operations on small polynomials, and thus the reduction is
eﬃcient: from an adversary that achieves an IND-CCA ad-
vantage ε within time t, one can invert RSA with small expo-
nent with success probability essentially ε, within time close
to t. As a consequence, one can use classical RSA moduli:
for e = 3, a 1024-bit modulus allows to encrypt 112-bit mes-
sages, whereas a 1536-bit modulus allows to securely encrypt
messages of up to 170-bits.

For Rabin-ZAEP, encryption is reasonably eﬃcient (an
evaluation of J (·) on average plus one modular square). The
IND-CCA-security of the scheme can be reduced to the inte-
ger factoring problem in the random oracle model, with an
eﬃcient reduction (even better than for RSA exponent 3).
As a consequence, for n = 1024, one can securely encrypt
messages of up to 256-bits. This suﬃces, for instance, to
encrypt AES keys of all standard sizes.

5.4 Other Redundancy-Free Schemes

We compare our security result of Theorem 1 to the secu-
rity results for 3-round OAEP (see Fig. 1(b)) and the 4-round
scheme of Abe et al. [2], the only other two redundancy-free
schemes based on the integer factoring assumption.

The original result about the IND-CCA security of 3-round
RSA-OAEP [37] relies on an intermediate reduction to the
partial-domain one-wayness of RSA. Phan and Pointcheval
[38] improved on this result by showing a direct reduction
to the (full-domain) one-wayness of RSA, which avoids the
additional cost of reducing partial-domain one-wayness to
one-wayness. They show that given an adversary A against
the IND-CCA-security of 3-round OAEP that executes within
time tA and makes at most qG queries to its 3 hash oracles
and qD queries to its decryption oracle, it is possible to con-
struct an inverter I for RSA that executes within time tI,

732such that

tI ≤ tA + tRSA × ((qD + 1)q2

OW
Succ
f

(I) ≥ Adv

CCA
OAEP3R(A) −

G + q2
D)
5qDqG + q2
D + qD + qG
2k

The probability loss in the above reduction can be made
negligibly small with an appropriate choice of k, the length
of the random value used during encryption. However, even
while tRSA is small, the qDq2
G factor in the time bound makes
the reduction for 3-round OAEP ineﬃcient, because qG ≫ qD
can be large. This quadratic contribution in the number of
hash queries also appears in the OAEP security bound and
is the major reason for requiring larger moduli.

The 4-round scheme of Abe et al. [2] improves on the ef-
ﬁciency of 3-round OAEP at the cost of one extra Feistel
round. Given an adversary A against the IND-CCA-security
of the scheme that executes within time tA and makes at
most qG hash oracle queries and qD decryption queries, it is
possible to construct an inverter I for the underlying per-
mutation, say RSA, that executes within time tI , such that

tI ≤ tA + tRSA × q2

G

Succ

OW
f

(I) ≥ Adv

CCA
OAEP4R(A) −

4qG
2k −

2q2
D
22k −

2qG(qD + 1)

23k

In contrast to 3-round OAEP, the leading term in the proba-
bility loss is O((qG+qD)/2k) because qG, qD must be bounded
by 2k to achieve semantic security. This allows to use smaller
moduli and to get an optimal ciphertext overhead for suﬃ-
ciently large messages.

In comparison to the above schemes, we show the following

bounds for ZAEP in Theorem 1:

SuccOW

f

tI ≤ tA + 2qGqD tsie + q2
qD
(I) ≥ AdvCCA
2n

ZAEP(A) −

D tcie

The probability loss in our reduction is negligible and the
leading term in the time bound is linear in qG, allowing the
use of standard RSA moduli.

6. RELATED WORK

Plaintext-awareness and Non-Redundancy. Plaintext
awareness is an intuitive concept, that has proved diﬃ-
cult to formalize. The concept was introduced by Bellare
and Rogaway for proving security of OAEP [11]. How-
ever, their work only dealt with a weak notion of plaintext-
awareness that provides a weaker, non-adaptive, notion of
chosen-ciphertext security [34] rather than the adaptive no-
tion of IND-CCA security considered in this paper. Subse-
quently, Bellare et al. [8] enhanced the plaintext-awareness
notion to guarantee IND-CCA security. In an eﬀort to ac-
commodate it to the standard model, the deﬁnition was
further reﬁned by Herzog, Liskov and Micali [31], Bellare
and Palacio [9], Dent [24], and Birket and Dent [14]. As
noted in the introduction, plaintext-awareness is an appeal-
ing concept:
it is satisﬁed by most IND-CCA encryption
schemes, and the common way to transform an IND-CPA
scheme into an IND-CCA scheme is to introduce redundancy
that ensures plaintext-awareness.
In fact, it has been ob-
served that existing schemes, such as OAEP, cease to guaran-
tee IND-CCA security—but still retain IND-CPA security—
whenever the redundancy is omitted. Nevertheless, sev-

eral works have shown that redundancy and plaintext-
awareness are not required to achieve chosen-ciphertext se-
curity. The initial results in this direction are due to Phan
and Pointcheval [37, 38]; earlier work by Desai [25] achieves
a similar goal, but in the setting of symmetric encryption.
Libert and Quisquater [33] build a redundancy-free identity-
based encryption scheme that achieves adaptive IND-CCA
security. More recently, Boyen [20] proposes a compact
redundancy-free encryption scheme based on the Gap-Diﬃe-
Hellman problem [35]. Whereas Boyen’s scheme is deﬁnitely
optimal from the point of view of bandwidth, with a 160-bit
overhead only, it is not really eﬃcient because many costly
full exponentiations must be computed for encryption and
decryption.

Formal proofs of cryptographic schemes. The applica-
tion of formal methods to cryptography has a long and rich
history. However, much of the the work in this area has
focused on the formal veriﬁcation of cryptographic proto-
cols in the symbolic model, which assumes that the under-
lying primitives are perfectly secure. A seminal article by
Abadi and Rogaway [1] shows, for the case of encryption,
that symbolic methods are indeed sound for the computa-
tional model, and can thus be used to achieve cryptographi-
cally meaningful guarantees. The computational soundness
result of Abadi and Rogaway has been extended in many
directions; we refer the reader to [22] for a survey on com-
putational soundness.

In contrast, the application of formal proofs to crypto-
graphic schemes is more recent, and less developed. To our
best knowledge, Impagliazzo and Kapron [32] were the ﬁrst
to propose a formal logic to reason about indistinguishabil-
ity. Using this logic, they prove that next-bit unpredictabil-
ity implies pseudo-randomness. However, the logic cannot
handle adaptive adversaries with oracle access. Computa-
tional Indistinguishability Logic [3] is a more recent logic
that overcomes these limitations. Both of these works pro-
vide logical foundations for reasoning about cryptographic
systems, but lack tool support.

In an inspiring article, Halevi [30] advocates that cryp-
tographic proofs should be computer-assisted, and outlines
the design of an automated tool to support cryptographic
proofs that follow the code-based game-playing approach.
CryptoVerif [15] is among the ﬁrst tools to have provided
support for computer-aided cryptographic proofs. It allows
users to conduct, automatically or interactively, game-based
concrete security proofs of primitives or protocols. Games
in CryptoVerif are modeled as processes in the applied π-
calculus, and transitions are proved using a variety of meth-
ods, including process-algebraic (for instance bisimulations)
or purpose-built (for instance failure events) tools. To date,
CryptoVerif has been applied to prove the security of the
Full-Domain Hash signature scheme [17] and several pro-
tocols; we refer to [16] for a more detailed account of the
examples proved with CryptoVerif. The work we report in
this paper uses EasyCrypt [4], a more recent tool that takes
a programming language approach to cryptographic proofs.
EasyCrypt and its predecessor CertiCrypt have been used to
verify a number of emblematic cryptographic schemes, in-
cluding OAEP [5]. As CryptoVerif, EasyCrypt and CertiCrypt
aim to provide general frameworks that capture common
reasoning patterns in cryptography. An alternative is to de-
velop specialized logics, that are able to prove a particular

733property for a given class of schemes. A relevant exam-
ple is the Hoare logic of Courant et al. [23], which allows
to prove automatically that an encryption scheme based on
trapdoor one-way functions, random oracles, concatenation
and exclusive-or is IND-CPA or IND-CCA secure. Their logic
(or a suitable extension) uses a syntactic form of plaintext-
awareness to conclude that an encryption scheme is IND-
CCA secure; hence it cannot be applied to conclude IND-CCA
security of ZAEP.

7. CONCLUSION

ZAEP is a surprisingly simple and eﬃcient padding scheme
that achieves adaptive chosen-ciphertext security without
introducing any redundancy. Using the EasyCrypt tool, we
have built a machine-checked proof that ZAEP yields IND-
CCA security with a rather eﬃcient reduction, whenever it is
instantiated with trapdoor permutations satisfying two in-
tuitive algebraic properties that hold for the Rabin function
and small exponent RSA. The proof is signiﬁcant beyond
its intrinsic interest, as the ﬁrst application of veriﬁed se-
curity to a novel construction. Pleasingly, starting from a
high-level intuition, we were able to build with reasonable
eﬀort in less than a week and directly in EasyCrypt, the se-
quence of games for proving IND-CCA security. The time
needed to complete the proof stands in sharp contrast with
the six man-monthes that were reported needed to repro-
duce the proof of OAEP in CertiCrypt [5]. Thus, our work
provides further evidence that, as stated in [4], “EasyCrypt
makes a signiﬁcant step towards the adoption of computer-
aided proofs by working cryptographers”.

The ZAEP proof opens exciting perspectives for future
work. On the one hand, it suggests that automation can
be signiﬁcantly improved through user-deﬁned and built-in
strategies that automatically generate a sequence of games.
More speculatively, we are currently investigating whether
strategies could provide an eﬀective means to automate IND-
CPA and IND-CCA proofs for encryption schemes obtained
with methods of program synthesis. In a parallel thread of
work, we have implemented a synthesis tool that generates
encryption schemes based on trapdoor one-way permuta-
tions, random oracles, concatenation and exclusive-or.
In
order to limit the set of candidate schemes to examine, we
have constrained the generation mechanism by Dolev-Yao
ﬁlters that eliminate obviously insecure schemes. Thus, the
synthesis algorithm generates a list of candidates that is ex-
haustive up to a given number of operations. Noticeably,
there are only two candidates with a minimal number (four)
of operations:
the (redundant-free and IND-CPA) Bellare
and Rogaway encryption scheme [10], which is known since
1993, and ZAEP, which has not been studied before. The
case of ZAEP makes us hopeful that automated synthesis of
cryptographic schemes may lead to surprising discoveries.

Acknowledgments
This work was partially funded by European Projects FP7-
256980 NESSoS and FP7-229599 AMAROUT, Spanish Na-
tional project TIN2009-14599 DESAFIOS 10, and Madrid
Regional project S2009TIC-1465 PROMETIDOS.

8. REFERENCES
[1] M. Abadi and P. Rogaway. Reconciling two views of

cryptography (The computational soundness of formal
encryption). J. Cryptology, 15(2):103–127, 2002.

[2] M. Abe, E. Kiltz, and T. Okamoto. Chosen ciphertext

security with optimal ciphertext overhead. In
Advances in Cryptology – ASIACRYPT 2008, volume
5350 of Lecture Notes in Computer Science, pages
355–371. Springer, 2008.

[3] G. Barthe, M. Daubignard, B. Kapron, and

Y. Lakhnech. Computational indistinguishability logic.
In 17th ACM Conference on Computer and
Communications Security, CCS 2010, pages 375–386.
ACM, 2010.

[4] G. Barthe, B. Gr´egoire, S. Heraud, and

S. Zanella B´eguelin. Computer-aided security proofs
for the working cryptographer. In Advances in
Cryptology – CRYPTO 2011, volume 6841 of Lecture
Notes in Computer Science, pages 71–90. Springer,
2011.

[5] G. Barthe, B. Gr´egoire, Y. Lakhnech, and

S. Zanella B´eguelin. Beyond provable security.
Veriﬁable IND-CCA security of OAEP. In Topics in
Cryptology – CT-RSA 2011, volume 6558 of Lecture
Notes in Computer Science, pages 180–196. Springer,
2011.

[6] G. Barthe, B. Gr´egoire, and S. Zanella B´eguelin.
Formal certiﬁcation of code-based cryptographic
proofs. In 36th ACM SIGPLAN-SIGACT Symposium
on Principles of Programming Languages, POPL
2009, pages 90–101. ACM, 2009.

[7] G. Barthe, D. Pointcheval, and S. Zanella-B´eguelin.
Veriﬁed security of redundancy-free encryption from
Rabin and RSA. Cryptology ePrint Archive, Report
2012/308, 2012.

[8] M. Bellare, A. Desai, D. Pointcheval, and P. Rogaway.

Relations among notions of security for public-key
encryption schemes. In Advances in Cryptology –
CRYPTO 1998, volume 1462 of Lecture Notes in
Computer Science, pages 26–45. Springer, 1998.

[9] M. Bellare and A. Palacio. Towards plaintext-aware

public-key encryption without random oracles. In
Advances in Cryptology – ASIACRYPT 2004, volume
3329 of Lecture Notes in Computer Science, pages
48–62. Springer, 2004.

[10] M. Bellare and P. Rogaway. Random oracles are

practical: A paradigm for designing eﬃcient protocols.
In 1st ACM Conference on Computer and
Communications Security, CCS 1993, pages 62–73.
ACM, 1993.

[11] M. Bellare and P. Rogaway. Optimal asymmetric

encryption. In Advances in Cryptology –
EUROCRYPT 1994, volume 950 of Lecture Notes in
Computer Science, pages 92–111. Springer, 1994.
[12] M. Bellare and P. Rogaway. The exact security of

digital signatures: How to sign with RSA and Rabin.
In Advances in Cryptology – EUROCRYPT 1996,
volume 1070 of Lecture Notes in Computer Science,
pages 399–416. Springer, 1996.

[13] M. Bellare and P. Rogaway. The security of triple

encryption and a framework for code-based
game-playing proofs. In Advances in Cryptology –
EUROCRYPT 2006, volume 4004 of Lecture Notes in
Computer Science, pages 409–426. Springer, 2006.

[14] J. Birkett and A. W. Dent. Relations among notions of
plaintext awareness. In 11th International Conference

734on Theory and Practice of Public Key Cryptography,
PKC 2008, volume 4939 of Lecture Notes in Computer
Science, pages 47–64. Springer, 2008.

[15] B. Blanchet. A computationally sound mechanized

prover for security protocols. In 27th IEEE
Symposium on Security and Privacy, S&P 2006, pages
140–154. IEEE Computer Society, 2006.

1666 of Lecture Notes in Computer Science, pages
537–554. Springer, 1999.

[28] E. Fujisaki, T. Okamoto, D. Pointcheval, and J. Stern.

RSA-OAEP is secure under the RSA assumption. In
Advances in Cryptology – CRYPTO 2001, volume
2139 of Lecture Notes in Computer Science, pages
260–274. Springer, 2001.

[16] B. Blanchet. Security protocol veriﬁcation: Symbolic

[29] S. Goldwasser and S. Micali. Probabilistic encryption.

and computational models. In 1st Conference on
Principles of Security and Trust, volume 7215 of
Lecture Notes in Computer Science, pages 3–29.
Springer, 2012.

[17] B. Blanchet and D. Pointcheval. Automated security

proofs with sequences of games. In Advances in
Cryptology – CRYPTO 2006, volume 4117 of Lecture
Notes in Computer Science, pages 537–554. Springer,
2006.

[18] F. Bobot, J.-C. Filliˆatre, C. March´e, and

A. Paskevich. The Why3 platform. Version 0.71.
Online – http://why3.lri.fr, 2010.

[19] D. Boneh. Simpliﬁed OAEP for the RSA and Rabin

functions. In Advances in Cryptology – CRYPTO
2001, volume 2139 of Lecture Notes in Computer
Science, pages 275–291. Springer, 2001.

[20] X. Boyen. Miniature CCA2 PK encryption: Tight

security without redundancy. In Advances in
Cryptology – ASIACRYPT 2007, volume 4833 of
Lecture Notes in Computer Science, pages 485–501.
Springer, 2007.

[21] D. Coppersmith. Finding a small root of a univariate

modular equation. In Advances in Cryptology –
EUROCRYPT 1996, volume 1070 of Lecture Notes in
Computer Science, pages 155–165. Springer, 1996.

[22] V. Cortier, S. Kremer, and B. Warinschi. A survey of

symbolic methods in computational analysis of
cryptographic systems. J. Autom. Reasoning,
46(3-4):225–259, 2011.

[23] J. Courant, M. Daubignard, C. Ene, P. Lafourcade,

and Y. Lakhnech. Towards automated proofs for
asymmetric encryption schemes in the random oracle
model. In 15th ACM conference on Computer and
Communications Security, CCS 2008, pages 371–380.
ACM, 2008.

[24] A. W. Dent. The Cramer-Shoup encryption scheme is
plaintext aware in the standard model. In Advances in
Cryptology – EUROCRYPT 2006, volume 4004 of
Lecture Notes in Computer Science, pages 289–307.
Springer, 2006.

[25] A. Desai. New paradigms for constructing symmetric
encryption schemes secure against chosen-ciphertext
attack. In Advances in Cryptology – CRYPTO 2000,
volume 1880 of Lecture Notes in Computer Science,
pages 394–412. Springer, 2000.

Journal of Computer and System Sciences,
28(2):270–299, 1984.

[30] S. Halevi. A plausible approach to computer-aided

cryptographic proofs. Cryptology ePrint Archive,
Report 2005/181, 2005.

[31] J. Herzog, M. Liskov, and S. Micali. Plaintext
awareness via key registration. In Advances in
Cryptology – CRYPTO 2003, volume 2729 of Lecture
Notes in Computer Science, pages 548–564. Springer,
2003.

[32] R. Impagliazzo and B. M. Kapron. Logics for

reasoning about cryptographic constructions. In 44th
Annual IEEE symposium on Foundations of Computer
Science, FOCS 2003, pages 372–383. IEEE Computer
Society, 2003.

[33] B. Libert and J.-J. Quisquater. Identity based

encryption without redundancy. In 3rd International
Conference on Applied Cryptography and Network
Security, ACNS 2005, volume 3531 of Lecture Notes in
Computer Science, pages 285–300. Springer, 2005.
[34] M. Naor and M. Yung. Public-key cryptosystems

provably secure against chosen ciphertext attacks. In
22nd Annual ACM Symposium on Theory of
Computing, STOC 1990. ACM, 1990.

[35] T. Okamoto and D. Pointcheval. The gap-problems: A
new class of problems for the security of cryptographic
schemes. In 4th International Workshop on Theory
and Practice in Public Key Cryptography, PKC 2001,
volume 1992 of Lecture Notes in Computer Science,
pages 104–118. Springer, 2001.

[36] T. Okamoto and D. Pointcheval. REACT: Rapid

Enhanced-security Asymmetric Cryptosystem
Transform. In Topics in Cryptology – CT-RSA 2001,
volume 2020 of Lecture Notes in Computer Science,
pages 159–175. Springer, 2001.

[37] D. H. Phan and D. Pointcheval. Chosen-ciphertext

security without redundancy. In Advances in
Cryptology – ASIACRYPT 2003, volume 2894 of
Lecture Notes in Computer Science, pages 1–18.
Springer, 2003.

[38] D. H. Phan and D. Pointcheval. OAEP 3-round: A

generic and secure asymmetric encryption padding. In
Advances in Cryptology – ASIACRYPT 2004, volume
3329 of Lecture Notes in Computer Science, pages
63–77. Springer, 2004.

[26] E. Fujisaki and T. Okamoto. How to enhance the

[39] C. Rackoﬀ and D. R. Simon. Non-interactive

security of public-key encryption at minimum cost. In
2nd International Workshop on Theory and Practice
in Public Key Cryptography, PKC 1999, volume 1560
of Lecture Notes in Computer Science, pages 53–68.
Springer, 1999.

[27] E. Fujisaki and T. Okamoto. Secure integration of
asymmetric and symmetric encryption schemes. In
Advances in Cryptology – CRYPTO 1999, volume

zero-knowledge proof of knowledge and chosen
ciphertext attack. In Advances in Cryptology –
CRYPTO 1991, volume 576 of Lecture Notes in
Computer Science, pages 433–444. Springer, 1992.

[40] R. L. Rivest, A. Shamir, and L. M. Adleman. A

method for obtaining digital signature and public-key
cryptosystems. Communications of the Association for
Computing Machinery, 21(2):120–126, 1978.

735