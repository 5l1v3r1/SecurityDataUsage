Automated Proofs of Pairing-Based Cryptography

Gilles Barthe

IMDEA Software Institute

Madrid, Spain

gilles.barthe@imdea.org

Benjamin Grégoire

INRIA

Benedikt Schmidt

IMDEA Software Institute

Madrid, Spain

Sophia-Antipolis, France

benjamin.gregoire@sophia.inria.fr

benedikt.schmidt@imdea.org

ABSTRACT
Analyzing cryptographic constructions in the computational
model, or simply verifying the correctness of security proofs,
are complex and error-prone tasks. Although computer tools
have signiﬁcant potential to increase conﬁdence in security
proofs and to reduce the time for building these proofs, ex-
isting tools are either limited in scope, or can only be used
by formal methods experts, and have a signiﬁcant overhead.
In eﬀect, it has remained a challenge to design usable and in-
tuitive tools for building and verifying cryptographic proofs,
especially for more advanced ﬁelds such as pairing-based or
lattice-based cryptography.

This paper introduces a formal logic which captures some
key reasoning principles in provable security, and more im-
portantly, operates at a level of abstraction that closely
matches cryptographic practice. Automatization of the logic
is supported by an eﬀective proof search procedure, which
in turn embeds (extended and customized) techniques from
automated reasoning, symbolic cryptography and program
veriﬁcation. Although the logic is general, some of the tech-
niques for automating proofs are speciﬁc to ﬁxed algebraic
settings. Therefore, in order to illustrate the strengths of our
logic, we implement a new tool, called AutoG&P, which sup-
ports extremely compact, and often fully automated, proofs
of cryptographic constructions based on (bilinear or multi-
linear) Diﬃe-Hellman assumptions. For instance, we pro-
vide a 100-line proof of Waters’ Dual System Encryption
(CRYPTO’09), and fully automatic proofs of Boneh-Boyen
Identity-Based Encryption (CRYPTO’04). Finally, we pro-
vide an automated tool that generates independently veriﬁ-
able EasyCrypt proofs from AutoG&P proofs.

Categories and Subject Descriptors
F.3 [Reasoning about Programs]: Logics of programs

Keywords
automated proofs; provable security; public-key encryption

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS’15, October 12–16, 2015, Denver, Colorado, USA.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-3832-5/15/10 ...$15.00.
DOI: http://dx.doi.org/10.1145/2810103.2813697.

1.

INTRODUCTION

Formal veriﬁcation tools have the ability to deliver high-
integrity artefacts; they can also increase productivity of
artefact designers, provided they can achieve reasonable trade-
oﬀs between beneﬁts and costs of formal veriﬁcation. Al-
though there is a lack of data and metrics to measure gains
in productivity, general-purpose software is one area where
appropriate trade-oﬀs have been identiﬁed and where formal
veriﬁcation has achieved signiﬁcant beneﬁts. In contrast, it
has proved more challenging to leverage the potential bene-
ﬁts of formal veriﬁcation in security-related areas, partly be-
cause formalizing properties of interest and adequate mod-
els to reason about them is hard. One notable exception
where formal veriﬁcation has been used very successfully is
the security of cryptographic protocols in the Dolev-Yao or
symbolic model, for which numerous automated tools have
been developed [12, 21, 35]. However, proofs in the symbolic
model are restricted to cryptographic protocols (rather than
primitives) and deliver weaker guarantees than proofs in the
computational model. The question then arises whether one
can design veriﬁcation tools for analyzing the security of
cryptographic protocols and primitives in the computational
model. Signiﬁcant progress has been made over the last ten
years, and tools like CertiCrypt [9], CryptoVerif [13], Easy-
Crypt [8], and more recently FCF [34], have been used to
verify emblematic case studies. However, automated proofs
of cryptographic primitives remain out of scope, and it is
also a challenge to support proofs which follow the same
structure and level of abstraction as pen-and-paper proofs
from the literature. As a consequence, the scopus of for-
mally veriﬁed proofs (almost) completely elides some of the
most important developments in the ﬁeld, such as pairing-
based or lattice-based cryptography (the only exception is a
formal proof of chosen-plaintext security of Boneh-Franklin
Identity Based Encryption in the random oracle model [10])
and adoption of formal proofs by the cryptographic commu-
nity has been limited.

Contributions. The main contribution of this paper is a
formal logic to reason about the concrete security of crypto-
graphic constructions directly in the computational model.
The distinguishing characteristics of our logic is its ability
to adhere to a level of abstraction that is close to the one
used in pen-and-paper proofs from the cryptography liter-
ature and to deliver compact and intuitive formal proofs,
using a core set of rules for bridging steps, failure events, re-
ductions, or hybrid arguments. The logic is similar in spirit
to CIL [6], but is instantiated to a functional programming

1156Type types of expressions

t

::= B
|
BSl
| Gi
|
Fq
|
t × . . . × t

boolean value
bitstring of length l ∈ Len
cyclic group with i ∈ GName
prime ﬁeld of order q
tuple

Figure 1: Grammar for types.

language. Moreover, the logic is supported by an eﬀective
proof search procedure which applies high-level rules built
on top of the core rules and exploits (often extended and
customized) techniques from automated reasoning (e.g. al-
gorithms for equational reasoning), symbolic cryptography
(e.g. algorithms for deducibility), and program veriﬁcation
(e.g.
strongest post-condition calculus) for automatically
discharging proof obligations. The proof search procedure
is proof-producing, in the sense that the proofs it constructs
are elaborated into elementary proofs in which all inferences
are performed using the core rules of the logic. Such ele-
mentary proofs are then translated into EasyCrypt, to obtain
foundational proofs in which all inference steps are explained
in terms of relational program logics.

Although the logic is general, some of the techniques used
for automating proofs, in particular those related to equa-
tional reasoning, are speciﬁc to an algebraic setting. Be-
cause of its importance in modern cryptography, we focus
on pairing-based cryptography, and implement a new tool,
called AutoG&P, able to analyze the security of pairing-
based constructions. Using AutoG&P, we provide the ﬁrst
formal proofs of pairing-based constructions in the standard
model, including a fully automated proof of Boneh-Boyen
Identity Based Encryption [14] and a short (<100 lines)
proof of Waters’ Dual System Encryption [36]. Our proofs
show the feasibility of formal proofs for pairing-based cryp-
tography. Moreover, and quite interestingly, our proofs also
suggest that AutoG&P provides an adequate level of abstrac-
tion for transforming automatically proofs of security from
Type I to Type III settings, as investigated in [4, 3], as the
same high-level proof can be used to prove the security of
the Boneh-Boyen IBE scheme in the two settings.

2. NOTATION

In this paper, we consider expressions, programs, and se-
curity experiments as terms and make use of the following
operations on terms. We use t|p to refer to the subterm
of the term t at position p and t{t(cid:48)}p to refer to the result
of replacing the term at position p with t(cid:48).
If p is a po-
sition in a sequence, we abuse notation and write t{}p to
remove the element in the sequence at position p. We write
t{x1 (cid:55)→ t1, . . . , xk (cid:55)→ tk} to denote the result of substituting
xi by ti in t. A context C is a term with a distinguished
variable 2 which denotes a hole that can be ﬁlled in by an
arbitrary term. We use C{t} to denote the term obtained
by plugging t into C(cid:48)s hole.

3. LANGUAGE

In this section, we deﬁne the syntax and semantics of ex-

pressions, games, security experiments, and judgments.

3.1 Types and expressions

The set Type of types is deﬁned by the grammar given
in Figure 1 where Len denotes a ﬁnite set of length vari-
ables and GName denotes a ﬁnite set of group names. We
assume given disjoint inﬁnite sets Vart of typed variables
and deﬁne Var as the union of these sets. We also assume
given sets Fsym of function symbols and Emap ⊆ GName ×
GName × GName and Isom ⊆ GName × GName deﬁning the
types of modeled bilinear maps and isomorphisms between
the groups. Given these sets, we deﬁne the corresponding
signature Sig in Figure 2. The set Expr of expressions con-
sists of all terms built over Sig. We say an expression is
eﬃcient if it does not contain log.
A group setting G = (q,{Gi}i∈GName,{ˆej}j∈Emap,{φj}j∈Isom)
consists of a prime q, an indexed set of cyclic groups Gi of or-
der q, an indexed set of bilinear maps ˆer,s,t : Gr × Gs → Gt,
and an indexed set of isomorphisms φr,s : Gr → Gs. We as-
sume that the structure deﬁned by Emap and Isom does not
contain cycles that would allow for an unbounded number
of multiplications in the exponent. Our formalism can be
used to model bilinear groups of Type I, Type II, Type III,
and (leveled) k-linear groups [15, 17, 28]. An interpreta-
tion I consists of a group setting G, a mapping from length
variables to natural numbers, and a mapping from function
symbols to functions. We write I(l) to denote the length
assigned to l and I(h) to denote the function assigned to h.
3.2 Equivalence of expressions

We deﬁne an equivalence relation on expressions based on
satisfaction in ﬁrst-order logic. The expressions e and e(cid:48)
are equivalent modulo E, written e =E e(cid:48), if E |= e = e(cid:48).
Here, E denotes the axioms for our signature consisting of
the ﬁeld axioms for Fq, the (bilinear) group axioms for Gi,
and the usual axioms for congruence, the logical operators
and the bitstring operators. We consider inversion in Fq as
underspeciﬁed, i.e., 0−1 is some arbitrary ﬁxed value in Fq
and we can only simplify x∗ x−1 to 1 if x (cid:54)= 0 holds. We use
Γ |= e =E e(cid:48) to denote (Γ,E) |= e = e(cid:48), i.e., E is extended
with additional axioms Γ. We assume the set of axioms Γ
consists of (in)equalities on expressions.

We use contexts to express algorithms that can be deﬁned
using the signature Sig. We say a context C is ground if C
does not contain any variables except 2. We write e (cid:96)CE e(cid:48)
if C{e} =E e(cid:48) for a ground context C. We write e (cid:96)E e(cid:48) if
there exists a context C such that e (cid:96)CE e(cid:48). Similarly, we
write Γ |= e (cid:96)CE e(cid:48) if Γ |= C{e} =E e(cid:48) and Γ |= e (cid:96)E e(cid:48) if
there exists such a context C. For example, it does not hold
that a ∗ b (cid:96)E b, but a (cid:54)= 0 |= a ∗ b (cid:96)E b holds as witnessed by
the context C = 2/a.
3.3 Games

A game is a sequence of game commands. A game com-
mand is a let binding, a random sampling, an assertion, or
an adversary call. For each adversary call, the provided ora-
cles are deﬁned inline. An oracle deﬁnition consists of the or-
acle symbol, the parameters, a sequence of oracle commands,
and the return value. An oracle command is a let binding, a
random sampling, or a guard that ensures that ⊥ is returned
unless the given test succeeds. The grammars O for oracle
deﬁnitions and gc for game commands are given in Figure 3.
In the grammars, we use typed oracle symbols o ∈ Osym
and typed adversary symbols A ∈ Asym. The scope of vari-
ables bound in the body of games extends to succeeding or-

1157Sig Signature for expressions

x : t
h( ) : t1 → t2
( , . . . , ) : t1 × . . . × tk → (t1 × . . . × tk), πi : t1 × . . . × tk → ti
gi : Gi
/ : Gi × Gi → Gi
∗
: Gi × Gi → Gi,
( )( ) : Gi × Fq → Gi,
log : Gi → Fq
ˆei : Gi1 × Gi2 → Gi3 , φj : Gj1 → Gj2
0 : Fq,
1 : Fq,
0l : BSl,
= : t × t → B,
¬ : B → B,

+ : Fq × Fq → Fq, −( ) : Fq → Fq
( )−1 : Fq → Fq
∗

: Fq × Fq → Fq,
⊕ : BSl × BSl → BSl

) : B × t × t → t

( ?

:

∧ : B × B → B

variables for x ∈ Vart
function symbols h ∈ Fsym
tuple construction and projection
generator of Gi
multiplication and division in Gi
exponentiation and discrete log in Gi
bilinear map (i ∈ Emap), isomorphism (j ∈ Isom)
additive group operations for Fq
multiplicative group operations for Fq
operations on bitstrings BSl
equality and if-then-else

negation and conjunction

Figure 2: Signature for expressions.

acle deﬁnitions. In assertions, we support event expressions
ev ∈ Exprev, which are also deﬁned in Figure 3. The quantiﬁ-
cations range over the parameters used in adversary queries.
For example, the assertion assert(∀c ∈ QDec1 . c (cid:54)= c∗) ex-
presses that c∗ is a ciphertext that has not been queried to
the decryption oracle Dec1. We use osym(G) to denote all
oracle symbols occuring in a game G and asym(G) to de-
note all adversary symbols occuring in a game G. We say a
game G is well-formed if it is well-typed, does not contain
free variable occurences, all oracle and adversary symbols
are distinct, and all binders bind distinct variables. To sim-
plify the presentation, we allow for at most one exceptional
value in random samplings. This restriction can be lifted,
but care must be taken to ensure that the types are large
enough such that the support of the resulting distribution is
not empty.
We say a tuple S = (I,{δo}o∈osym(G),{AA}A∈asym(G)) is
a G-setting if I is an interpretation, δ is an indexed set of
query bounds for oracle symbols occuring in G, and A is an
indexed set of adversaries for adversary symbols occuring
in G. Given such a setting, we can execute G as follows:

1. Compute generators of the groups Gi by random sam-
pling or by applying the bilinear maps and isomor-
phisms to generators that have already been computed.

2. For each oracle o occuring in G, we initialize a counter
variable co with zero and a query set variable Qo with
the empty set.

3. For a let binding let x = e, we evaluate the expression e
using the operations deﬁned by I and store the result
in the variable x.

4. For a random sampling x ←$ t\ a, we evaluate a denot-
ing the result with b, uniformly sample from the set
I(t) \ {b} (where I(t) is set of values of type t), and
store the result in the variable x.

5. For an assertion assert(ev), we evaluate ev and abort

if the result is false.

asym(G) =

if G = G[no := f ]
asym(G, A) \ {A} if G = G[A := A]

6. For an adversary call y ← A(e) with (cid:126)O, we evaluate e
and call the adversary AA with the result as input.
The adversary is provided with access to the imple-
mentations of the oracles (cid:126)O. We allow the adversary
procedures AA to share state.

The oracles are implemented as follows:

1. If co ≥ δo, then ⊥ is returned. Otherwise, the counter
co is increased, the query parameters are stored in Qo,
and the oracle body is executed.

2. Guards are treated similar to assertions, but instead
of aborting, the value ⊥ is returned to the adversary
and execution continues normally.

To perform reductions, we want to be able to state that a
game G(B) is equivalent to a game G(cid:48)(A), capturing a cryp-
tographic assumption, when the adversary A is instantiated
in a certain way. Usually, A is instantiated with a simula-
tor that simulates G to the original adversary B and uses
B’s output to break the assumption. Additionally, we might
want to express the oracle bounds for A in G(cid:48) in terms of
oracle bounds for B in G.

To achieve this, we extend our syntax and semantics to
support the instantiation of adversaries and oracle bounds.
We extend the syntax of games as follows. A game G is
either an uninstantiated game G as deﬁned before, a game
G[no := f ] where the bound for calls to o is instantiated
by the polynomial f over oracle bounds, a game G[A := A]
where the adversary symbol A is instantiated with the adver-
sary deﬁnition A. Here, A is deﬁned in some language that
extends our language of games, e.g., the probabilistic pro-
gramming language PWhile [8] used in EasyCrypt. We allow
such adversary deﬁnitions A to include calls to unspeciﬁed
adversary procedures identiﬁed by adversary symbols B. To
prevent cyclic deﬁnitions, we assume that o /∈ osym(f ) and
A /∈ asym(A). We extend asym to return only uninstanti-
ated adversary symbols:

(cid:26) asym(G)

1158O ::= o(x) = { (cid:126)oc; return e} oracle deﬁnition

oc

gc

::= c
|

guard(b)

ordinary command
guard for b ∈ ExprB

::= c
|
|

assert(ev)
y ← A(x) with (cid:126)O

ordinary command
assertion for ev ∈ Exprev
adversary call with oracles

GBB =

2 ∗ P3)e);

i∗ ← A1();

1 : c, d, h ←$ Fq; let P =(gc, gd, gh);
2 :
3 : b ←$ B; e ←$ Fq; let C =(ge, (P i∗
let K0 = ˆe(P1, P2)e; K1 ←$ Gt;
4 :
5 : b(cid:48) ← A2(P, C, (b?K0 : K1)) with

PrivKey(i) = {
guard(i (cid:54)= i∗);
r ←$ Fq;
return (g(c∗d+r∗(d∗i+h)), gr)

5.1 :
5.2 :
5.3 :

};

c

::= let x = e
|
x ←$ t \ a

let binding
sample unif. from t \ {a}

ev

b

∃ b1, . . . , bk. e
∀ b1, . . . , bk. e

::= e
|
|
::= x ∈ Qo

expression
there exist queries
for all queries

x ranges over queries

Figure 3: Grammars for oracle deﬁnitions and
games.

Similarly, we extend osym to return only uninstantiated or-
acle symbols:

(cid:26) osym(G, f ) \ {o} if G = G[no := f ]

osym(G)

if G = G[A := A]

osym(G) =

The deﬁnition of G-setting remains unchanged, but uses the
extended versions of asym and osym. The instantiated or-
acle bounds and the instantiated adversaries are then com-
puted from the bound polynomials and adversary deﬁnitions
by using δ and A for the occuring oracle and adversary sym-
bols.

3.4 Security experiments and judgments

A security experiment SE is a pair [ G : ev ] of a game
G and an event expression ev. We say a security experi-
ment is well-formed if G; assert(ev) is well-formed. We use
PrS[ G : ev ] to denote the probability that the execution
of G in the setting S terminates without aborting and ev
evaluates to true in the ﬁnal memory.

We use the following grammar to deﬁne the set PExpr of

probability expressions:

P, P (cid:48)

::= 0
|
|
|
|
|
|

P + P (cid:48)
no × P
1/|t|
[ G : ev ]succ
[ G : ev ]adv
[ G : ev ][ G(cid:48) : ev(cid:48) ] distinguishing prob.

zero
addition
security loss
collision bound
success prob.
advantage prob.

We call the subscripts succ, adv, and [ G(cid:48) : c(cid:48) ] probabil-
ity tags. We say S = (I, δ,A) is a P -setting if dom(δ) =
osym(P ) and dom(A) = asym(P ). Given such a P -setting S,
we deﬁne the probability function probS(P ) that assigns

GDBDH

β

=

a, b, c ←$ Fq; t ←$ Fq
b ← B(ga, gb, gc, ˆe(g, g)a b c

[β=1]

[β=0]

ˆe(g, g)t

[β=1]

)

Figure 4: Game for IND-sID-CPA security of the
Boneh-Boyen-IBKEM and game for DBDH assump-
tion. The overlined expressions only occur for β = 0
(resp. β = 1).

probabilities to probability expressions as follows:

probS(P ) =

0
probS(P1) + probS(P2)
δo probS(P1)
1/|I(t)|
PrS[ SE ]
PrS[ SE ] − 1
| PrS[ SE ] − PrS[ SE(cid:48) ]|

2

if P = 0
if P = P1 + P2
if P = no × P1
if P = 1/|t|
if P = [ SE ]succ
if P = [ SE ]adv
if P = [ SE ]SE(cid:48)

A probability judgment J is a pair P (cid:22) P (cid:48) of probability

expressions. A judgment P (cid:22) P (cid:48) is valid if

1. asym(P (cid:48)) ⊆ asym(P ),
2. osym(P (cid:48)) ⊆ osym(P ), and
3. for all P -settings S, it holds that probS(P ) ≤ probS(P (cid:48)).
Conditions (1) and (2) ensure that all adversary and oracle
symbols that occur only in P (cid:48) must be instantiated.

Example 1. For the games given in Figure 4, we can ex-
press the probability associated to the IND-sID-CPA secu-
rity of the Boneh-Boyen-IBKEM as [ GBB : b = b(cid:48) ]adv and we
can express the DBDH assumption as

[ GDBDH

0

: b ][ GDBDH

1

: b ] .

We consider the key encapsulation mechanism (KEM) vari-
ant of the Boneh-Boyen identity-based encryption scheme [14]
to simplify the presentation of our example. The game GBB
proceeds as follows.
In line 1, the master secret key and
the public parameters are computed. In line 2, the adver-
sary must choose the challenge identity.
In lines 3 and 4
the challenge encapsulation C, the corresponding session
key K0, and a random session key K1 are computed.
In
line 5 the adversary is called and must guess if he received
the real or a random session key. He is provided with access
to the PrivKey-oracle that returns the private key for the

1159given identity, which is computed in lines 5.2 and 5.3. The
guard in line 5.1 denies queries for the challenge identity.

We would like to prove the probability judgment

[ GBB : b = b

(cid:48)

]adv (cid:22) [ GDBDH

0

[B := B] : b ][ GDBDH

1

[B:=B] : b ]

for some adversary deﬁnition B that can use A1 and A2.
The judgment formalizes that the IND-sID-CPA advantage
for all adversaries A1 and A2 instantiating A1 and A2 can
be upper-bounded by the DBDH distinguishing probability
for B (using A1 and A2).

In the next section, we will present a logic that allows us
to prove the validity of such judgments P (cid:22) P (cid:48). The logic
takes a probability expression P and during proof construc-
tion, the bound P (cid:48) and the oracle polynomials and adversary
deﬁnitions for reductions are synthesized. Our logic captures
concrete security [11] since we explicitly relate adversaries
and bounds in P and P (cid:48).

4. CORE LOGIC

In this section, we present our core logic. We focus on
a subset of rules that is suﬃcient for proofs that do not
require advanced techniques such as hybrid arguments or
equivalence up to failure. We ﬁrst present these core rules.
Then, we formalize and prove soundness of the logic. Finally,
we present algorithms for checking contextual equivalence of
expressions. We will present high-level rules derived from
the core rules in Section 5 and the remaining core rules in
Section 6.
4.1 Core rules

Our logic relates probability judgments and consist of

rules of the form

P1 (cid:22) 1

. . . Pk (cid:22) k
P (cid:22) 

where the Pi and P are probability expressions, the i are
metavariables, and  is a probability expression built over
the i. The logic can be used to prove the validity of judg-
ments of the form [ G : ev ]t (cid:22)  for a ﬁxed  or to synthe-
size  while performing the proof. Our logic deﬁnes a small
set of core rules which we then use to construct high-level
rules that can be elaborated into core logic derivations.

For rules that perform contextual reasoning, we make use
of the function spp([ G : ev ]) that computes the strongest
postcondition at position p by collecting all (in)equalities in
lets, random samplings, asserts, and guards on the path to p.
The formal deﬁnition of sp can be found in Section 4.3. We
now discuss the core rules given in Figure 5. The ﬁgure con-
tains rules for dealing with probability judgments, bridging
rules formalizing program transformations and equivalence
of distributions, and rules for case distinctions and reduc-
tions.
Probability judgment rules
The Sym rule swaps the two security experiments in a dis-
tinguishing probability. This rule is required since all other
rules only act on the ﬁrst security experiment. The Deq
rule formalizes that two identical games cannot be distin-
guished. The FalseEv rule formalizes that the probability
of the event false is 0 in all games G. The Refl rule formal-
izes reﬂexivity. It is usually used if the premise is a hardness

assumption that appears on the right-hand-side of the prob-
ability judgment to be proved. The Trans(SE(cid:48)) rule for-
malizes transitivity and is usually used in combination with
other rules to derive new rules. For example, it is possible
to derive inverses for all program transformation rules using
Trans. The side condition enforces that no uninstantiated
oracle or adversary symbols are introduced.

Program transformation rules
The Swap(p) rule swaps the command at positions p with
the following command. Note that we require premise and
conclusion to be well-formed, e.g., all variable occurences
must be bound and bound variables must be distinct. This
prevents Swap applications that lead to undeﬁned variable
occurences or change the semantics. The Add(p, c) rule
inserts the command c at position p. As for Swap, the
well-formenedness requirement is important since it prevents
overshadowing of existing deﬁnitions. Add can be used to-
gether with Trans and Sym to remove commands. The
Subst(p, e) rule performs contextual rewriting and replaces
e(cid:48) at position p by e if spp(SE) |= e =E e(cid:48) holds. The Subst
rule is used for many diﬀerent purposes in proofs. For exam-
ple, it is often required to rewrite expressions before applying
a cryptographic assumption, e.g., rewrite ga∗b∗x to (ga∗b)x.

Random sampling and branching rules
The Rnd(p, t(cid:48), C, C(cid:48)) rule formalizes optimistic sampling and
replaces a uniform sampling from t by a uniform sampling
from the distribution deﬁned by s ←$ t(cid:48); return C{s}. To
ensure that these distributions are equal, the rule checks
that C is bijective in the given context using the provided
inverse C(cid:48). The Except(p, b) rule adds the new excepted
value b to the random sampling at position p. The bound is
scaled by no if p is inside an oracle o. The CaseEv(c) rule
performs a case distinction on the condition c in the event
to bound both cases separately.

Reduction rules
The Abstract(G(cid:48), B, B) rule moves some parts of the orig-
In the arguments, G(cid:48) is a
inal game into a simulator B.
game, B is an adversary symbol occuring exactly once in G(cid:48),
and the simulator B = (Bcs, Bret) is a tuple of a sequence
of commands and a return-expression. The simulator B can
contain a hole to represent an input and oracle calls y ← o(e)
to oracles provided to B in G(cid:48). To apply the rule, the result
of instantiating B with B in G(cid:48) must be equal to G.

More formally, we deﬁne the (partial) function for adver-
sary instantiation as follows. If B is not eﬃcient or if any of
the following steps fail, then inst(G(cid:48), B, B) = ⊥. Otherwise,
let y, e,(cid:126)o, (cid:126)x, (cid:126)c, (cid:126)r such that

y ← B(e) with {oi(xi) = {ci; return ri}}k

i=1.

is the only call to B in G(cid:48). We denote the position of this
call with p. Then inst(G(cid:48), B, B) = G(cid:48){B(cid:48); let y = Bret{e}}p
where B(cid:48) is obtained from Bcs by plugging e into the hole
and inlining all oracle calls.

Since rules should only introduce instantiated oracle and
adversary symbols, the Abstract rule instantiates B with
B and the new oracle symbols in G(cid:48) with the polynomial
bounds fi. The bounds fi are computed by inspecting B,
e.g., if o1 is called twice in the main body and once in an
unbounded oracle o(cid:48), then f1 = 2 + no(cid:48) .

1160Probability judgment:
(cid:48)

Sym

][SE] (cid:22) 
[ SE
[ SE ][SE(cid:48)] (cid:22) 

Deq

Refl

[ SE ]t (cid:22) [ SE ]t

Program transformation:

[ SE ][SE] (cid:22) 0
(cid:48)

[ SE

Trans(SE(cid:48))

FalseEv

[ G : false ]t (cid:22) 0

t ∈ {succ, adv}

[ SE ][SE(cid:48)] (cid:22) 2

]t (cid:22) 1
[ SE ]t (cid:22) 1 + 2

asym(SE) = asym(SE(cid:48)) and
osym(SE) = osym(SE(cid:48))

(cid:48)

Swap(p)

[ SE{c
[ SE{c; c
Random sampling:

; c}p ]t (cid:22) 
(cid:48)}p ]t (cid:22) 

Add(p, c)

[ SE{c; c
[ SE{c

(cid:48)}p ]t (cid:22) 
(cid:48)}p ]t (cid:22) 

c sampling, let,
or guard(true)

Subst(p, e)

[ SE{e}p ]t (cid:22) 
[ SE{e
(cid:48)}p ]t (cid:22) 

spp(SE) |= e =E e(cid:48)

Rnd(p, t(cid:48), C, C(cid:48))

Except(p, b)

(cid:48)

; let r = C{s}}p ]t (cid:22) 

[ SE{s ←$ t
[ SE{r ←$ t}p ]t (cid:22) 
[ SE{r ←$ t \ b}p ]t (cid:22) 
[ SE{r ←$ t}p ]t (cid:22)  + s × 1/|t|

spp(SE) |= C(cid:48){C} =E 2

(cid:26) no if p in o

s =

1 otherwise

t ∈ {succ, adv}

Branching:

Reduction:

CaseEv(c)

[ G : ev ∧ c ]t (cid:22) 1

[ G : ev ∧ ¬c ]t (cid:22) 2

[ G : ev ]t (cid:22) 1 + 2

Abstract(G(cid:48), B, B)

(cid:48)

[ G

[B := B, no1 := f1, . . . , nok := fk] : ev ]t (cid:22) 

[ G : ev ]t (cid:22) 

G = inst(G(cid:48), B, B), asym(G(cid:48)) ⊆ asym(G) (cid:93) {B},
o1, . . . , ok oracles provided to B,
{o1, . . . , ok} ∩ osym(G) = ∅, and
fi bounds for oracle queries to oi in B

Figure 5: Core Rules. We require all security experiments in premises and conclusions to be well-formed.

4.2 Soundness of the core logic

In this section, we state and prove a soundness theorem
for the core logic. For the proof, remember that our side-
condition on rules ensures that all security experiments oc-
curing in a derivation are well-formed.

Theorem 1. Let ∆ denote a derivation of

P (cid:22) P

(cid:48)

in the core logic, then P (cid:22) P (cid:48) is valid.

i

Proof Sketch. We perform a proof by induction over
derivations. Let S denote an arbitrary P -setting. Let ∆i
denote derivations of Pi (cid:22) P (cid:48)
for i ∈ {1, . . . , k} and as-
sume ∆ is the result of applying one of the core rules to the
premises ∆i. We then know that the premises Pi (cid:22) P (cid:48)
i are
valid. For all rules except Trans and Abstract this im-
plies that conditions (1) and (2) also hold for P (cid:22) P (cid:48). We
proceed by performing a case distinction on the applied core
rule:
Sym, Deq, FalseEv, Refl: Immediately follows from the
Trans(SE(cid:48)): Conditions (1) and (2) for [SE]t (cid:22) 1 +2 are
implied by the side-condition of the rule. To see that
condition (3) holds, observe that the second premise
yields | PrS[ SE ] − PrS[ SE(cid:48) ]| ≤ 2.

deﬁnition of validity and probS.

Swap, Add: Well-formedness of the premise implies that
the distribution of the ﬁnal memory (except for unused
variables) coincides in both security experiments.
Subst: In the given context, evaluating e and e(cid:48) yields the

same result.

Rnd: The distribution of the ﬁnal memory is the same.
Note that the variable s must be fresh since the premise
is well-formed.

Except(p, b): The games diﬀer only if the value b is sam-
pled. The probability of sampling b is reﬂected in the
term 1/|t| × s.
CaseEv: Follows from the fact that PrS[ G : ev ] =
PrS[ G : ev ∧ c ] + PrS[ G : ev ∧ ¬c ].
Abstract(G(cid:48), B, B): The game G where B is inlined and
the game G(cid:48) where B is an instantiation argument are
equivalent.

4.3 Checking contextual equivalence

For most of the rules presented so far, it is obvious how to
implement proof checking if all rule arguments are explicitly
given. The only exceptions are the rules Subst and Rnd
that both require a precise deﬁnition of spp(SE) and algo-
rithms for checking the conditional equivalence Γ |= e =E e(cid:48).
To deﬁne sp, we use the function conseq that takes a com-
mand c and returns a formula that characterizes its eﬀect

1161on the state:

conseq(c) =



x (cid:54)= a
x = e
b
nquant(ev)

if c = x ←$ t \ a
if c = let x = e
if c = guard(b)
if c = assert(ev)

Here, nquant(ev) denotes the (in)equalities in ev that are not
below a quantiﬁer. To compute spp(G), we start with true
and for each command c on the path to p, we add the con-
junct conseq(c) to the current post-condition. We ignore all
oracle bodies unless p points into an oracle. If p points into
an oracle, the commands in the oracle body preceding p are
taken into account and all other oracle bodies are ignored.
Since we can always rewrite the strongest post-condition into
disjunctive normal form and check Γ |= e =E e(cid:48) for each dis-
junct separately, we assume w.l.o.g. that Γ is a conjunction
of equalities and inequalities.
We use the following algorithm to rewrite e and e(cid:48) into
a normal-form and then check for syntactic equality. The
algorithm combines separate algorithms for bitstrings, ﬁeld
expressions, and booleans that are applied bottom-up to val-
ues of the given types. In a ﬁrst step, we simplify and orient
the equalities in Γ and apply the resulting replacements to
e and e(cid:48). Afterwards, values of type Gi are rewritten as gf
i
by using the log function and translating multiplication, di-
vision, and pairing to the corresponding operations on the
exponents. Then we perform normalization bottom-up us-
ing the following approach:
• For bitstrings, we deal with ⊕ and 0 using the standard
approach of ﬂattening, sorting, ﬁltering out 0, and counting
occurences of expressions modulo 2.
• For values of type Fq, our algorithm computes a normal-
form of rational functions as used in computer algebra sys-
tems [29]. The algorithm represents ring expressions as poly-
nomials over expressions e with non-ﬁeld root symbols. It
represents ﬁeld expressions using a numerator polynomial f
and a denominator polynomial h such that gcd(f, h) = 1.
Since the algorithm is only valid for well-deﬁned expressions,
i=1 fi (cid:54)= 0 =⇒ h (cid:54)= 0 for all di-
visions by expressions h in e and e(cid:48). The subroutine uses gcd
j hj for some
c ∈ Q. Since we know hj (cid:54)= 0, this implies h (cid:54)= 0. Concretely,
the subroutine searches for i such that hj = gcd(h, fi) non-
trivial. If no such i exists, it fails. Otherwise it continues
with h := h/hj until eventually, h ∈ Q.
• For boolean values, we simplify equations by splitting
equalities on product types, applying log to transform equal-
ities on Gi into equalities on Fq, and exploit the group struc-
ture for both bitstrings and ﬁeld elements to obtain equa-
tions of the form e = 0. For ﬁeld elements, e must be equal
to f ∗ h−1 for normal-form ring expressions f and h. If e is
well-deﬁned, we further simplify f ∗ h−1 = 0 to f = 0 and
obtain a disjunction of inequalities fi = 0 after factoring
i fi. For the logical operators, we apply the usual
simpliﬁcation rules such as e ∧ e = e and e ∨ true = true.
• For if-then-else, we detect common contexts C in both
branches and simplify b?C{e} : C{e(cid:48)} to C{b?e : e(cid:48)}.

we use a subroutine to prove(cid:86)n
to ﬁnd divisors hj of the fi such that h = c∗(cid:81)

f into (cid:81)

Our implementation uses the Factory library packaged
with the computer algebra system Singular [22] to perform
the required computations on multivariate polynomials such
as gcd or factoring. In the future, we might investigate the
use of Groebner bases to check the satisﬁability of sets of

(in)equalities. But so far, we did not have problems with
completeness using our approach.

5. HIGH LEVEL LOGIC

In theory, the core rules presented so far are suﬃcient
to perform proofs that do not require hybrid arguments or
equivalence up to failure. In practice, the level of abstraction
is too low to perform non-trivial proofs.

In this section, we therefore derive high-level rules that
capture standard arguments in cryptographic proofs. The
high-level rules critically rely on algorithms that automati-
cally infer arguments required for the elaboration into core
rules. To perform fully automated proofs and to automati-
cally discharge individual proof obligations, we then present
a proof search procedure that ﬁnds derivations using our
high-level rules.
5.1 Derived rules

The Simp rule unfolds all let-bindings and rewrites all ex-
pressions to their normal form. Simp is elaborated to appli-
cations of Subst that replace expressions by their normal
form and applications of Trans and Add to remove (un-
used) let-bindings. The rule exploits that the normal form
replaces all occurences of let-deﬁned variables with their def-
initions. Optionally, the Simp rule can also use Swap to
reorder commands in a unique, dependency-preserving way,
remove exceptional values from samplings, and replace sam-
plings of group elements by samplings of exponents.
The high-level Rnd(cid:63) rule accepts a placeholder for one of
C or C(cid:48). For example, given C and in a context where Γ
holds, Rnd(cid:63) uses a specialized algorithm for deducibility to
ﬁnd C(cid:48) such that Γ |= C, (cid:126)x (cid:96)C(cid:48)
E 2 where (cid:126)x denotes all vari-
ables in G that are deﬁned before the considered random
sampling. Rnd(cid:63) then uses the Simp rule to unfold the in-
troduced let-binding. We will describe the algorithm for
conditional deducibility in Section 5.3.
The Indep rule can be used to bound the probability of
an event ev in G with 1/|t| if the event implies that G
“guesses” the value of an unused randomly sampled vari-
able. For all random variables r that are not used in the
game, Indep tries to ﬁnd an expression e not containing r
such that r = e is implied by ev. After adding such an
equality to the event, Except can be used to sample r
from t \ e. The event can then be simpliﬁed to false and
we can conclude by applying FalseEv. To ﬁnd such an e,
Indep ﬁrst combines all equalities in the event to obtain
an equality of the form (e1, . . . , ek) = (0, . . . , 0). Then,
it uses a specialized algorithm for deducibility to ﬁnd a
C such that Γ |= (e1, . . . , ek), (cid:126)x (cid:96)CE r where (cid:126)x contains
all variables that are deﬁned before r is sampled. Since
C{(e1, . . . , ek)} = C{(0, . . . , 0)} is implied by the event and
C{(0, . . . , 0)} does not contain r, it now suﬃces to exploit
Γ |= C{(e1, . . . , ek)} =E r to get the desired equality of the
form r = e.

The high-level rule IfEq replaces all occurences of b?r1 : r2
in a security experiment SE by r1 if r1 and r2 are randomly
sampled variables of type Fq that only occur in this context.
The IfEq rule ﬁrst applies Rnd(cid:63) to replace r2 by r1 + r2.
This yields r1 + (b?0 : r2) after simpliﬁcation. Then, Rnd(cid:63)
is applied to the sampling of r1 and replaces r1 + (b?0 : r2)
with r1. This often makes the adversary’s view independent
of b and enables applications of Indep.

11625.2 Automated application of assumptions

To apply a computational assumption such as [ G(cid:48) : ev(cid:48) ]succ
to a judgment [ G : ev ]succ, the Abstract rule must be used
followed by the Refl rule. To apply Abstract, the simu-
lator argument B has to be given explicitly and the instan-
tiation of B in G(cid:48) : ev(cid:48) with B has to be syntactically equal
to G : ev. To apply an assumption, it is therefore necessary
to perform the following steps:
1. Rewrite G and G(cid:48) into a normal form, e.g., instead of

sampling X ∈ Gi, sample x ∈ Fq and compute gx
i .
2. Swap and rename random samplings in G to match up
with G(cid:48). The remainder of G will correspond to the
simulator B.

3. Rewrite the part of G corresponding to B such that it
does not use log or the random variables sampled by
the challenger. To achieve this, the argument a used in
the call B(a) in G(cid:48) can be used instead. It might also
be required to replace samplings of group elements in
B by samplings of exponents.

We use the correct variant of Simp to perform the ﬁrst
step unfolding all let-bindings in both games.
If required
to match up the samplings in both games, we also remove
exceptions from samplings. Then, for all injections ρ from
samplings in G(cid:48) to samplings in G, we try the following.
We match up the samplings according to ρ and match up
adversary calls in G(cid:48) with commands in G. To ﬁnd the cor-
rect return value for the adversary call, we match up the
two events ev and ev(cid:48). We now know the commands B(cid:48)
and the return expression B(cid:48)
ret that make G(cid:48) equivalent to
G. We still must rewrite these to (Bcs, Bret) to satisfy the
restrictions described in the third step. To achieve this, we
use conditional deducibility and for each expression e in B(cid:48)
we try to ﬁnd a C such that Γ |= C{a, (cid:126)x} =E e where a
is the adversay input and (cid:126)x are the variables deﬁned in B(cid:48)
before e is used.

cs

The approach for applying a decisional assumption of the
form [ G0 : ev0 ][ G1 : ev1 ] is similar. Instead of discharging
a judgment [ SE ]t, it yields a new judgment [ SE(cid:48) ]t where
the diﬀerence between SE and SE(cid:48) reﬂects the diﬀerence
between [ G0 : ev0 ] and [ G1 : ev1 ]. The high-level rule for
decisional assumptions ﬁrst rewrites SE such that it can be
expressed as inst(G0, B, B) for some B. Then it computes
SE(cid:48) = inst(G1, B, B) and applies Trans(SE(cid:48)). The ﬁrst
premise of Trans is [ SE(cid:48) ]t. The second premise is dis-
charged by applying Abstract (with the same B and B)
to both [SE] and [SE(cid:48)] in the distinguishing probability fol-
lowed by Refl.

5.3 Algorithms for conditional deducibility

So far, we have encountered three diﬀerent high-level rules
that require an algorithm to solve conditional deducibility
problems. The Rnd(cid:63) rule must ﬁnd the inverse C(cid:48) of a given
context C. The Indep rule must ﬁnd a context C to extract
a random variable from an expression. The rules for the
automated application of assumptions must ﬁnd (log-free)
contexts C to deduce expressions e from known variables (cid:126)x
and the adversary input a.

We have developed an algorithm following the approach
described in [18] to deal with the combination of theories
and to deal with Xor as a monoidal theory by solving equa-
tions over the associated semiring. For deducibility in groups
and Fq, we extended their approach to deal with the condi-

tional axioms required to model inversion as a partial func-
tion. Our extension consists of two separate algorithms.

The ﬁrst algorithm is used for Rnd(cid:63) and Indep and uses
log to reduce deducibility in Gi to deducibility in Fq.
In
both use-cases, the subroutine used for deducibility in Fq
must solve problems of the form Γ |= e, (cid:126)x (cid:96)E y where (cid:126)x is a
vector of variables of type Fq, y is a variable of type Fq, and e
is a well-deﬁned ﬁeld-expression over the variables (cid:126)x and y.
We can therefore normalize e and obtain two polynomials f
and h such that e is equal to f∗h−1. If y occurs in both f and
h, we give up. Otherwise, let {f, h} = { ˆw, w} such that w
contains y and ˆw does not. We can then deduce ˆw and it
suﬃces to focus on deducing y from w. To achieve this, we
try to ﬁnd w1, w2 such that w is equal to w1 ∗ y + w2 and wi
does not contain y and is hence deducible. If the degree of y
in w is diﬀerent from 1, this will not be possible and we give
up. Otherwise, we can solve for y and since ˆw, w1, and w2
are deducible, we can deduce y from f ∗ h−1 which is either
equal to ˆw ∗ (w1 ∗ y + w2)−1 or to (w1 ∗ y + w2) ∗ ˆw−1.

The second algorithm is more complicated since the con-
text C cannot use log and we must distinguish between ex-
pressions in Fq that are known and expression that are only
known “in the exponent”. In the second case, we can only
perform a limited number of multiplications using pairings
and compute linear combinations using group multiplica-
tions. Our algorithm is tailored to problems of the form
Γ |= (cid:126)x, gf1
j where (cid:126)x is a vector of variables
of type Fq and the fi and h are polynomials. To solve such
problems, we perform the following two steps keeping track
of the context associated to each step.

, . . . , gfk
ik

(cid:96)E gh

i1

1. Compute all group elements in Gj that can be obtained
by applying pairings and isomorphisms to the given
group elements gfu
. This results in the new problem
iu
Γ |= (cid:126)x, gw1
, . . . , gwl

j

2. Search for polynomials ui over (cid:126)x such that

j (cid:96)E gh
j .
l(cid:88)

ui ∗ wi = h.

i=1

To ﬁnd such polynomials, we roughly proceed as fol-
lows. Perform a division with remainder of h by wi to
obtain ui and b such that h = ui ∗ wi + b. Check that
ui is a polynomial over (cid:126)x and continue with h := b.
Since the division step might succeed with some wj,
but we might get stuck later on since there is no so-
lution that uses wj, we perform backtracking on the
choice of divisors wj.

5.4 Proof search

i

Between each step, our proof search procedure applies the
simpliﬁcation rule Simp. This is critical since most steps are
information-theoretical and exploit that group elements are
always of the form gf /h
for polynomials f and h. Next, we
try to apply FalseEv, Indep, or a computational assump-
tion that we want to use in the proof. Then, we try to make
the view of an adversary Ai independent of random vari-
ables by applying Rnd(cid:63) to replace contexts C{r} occuring
in the game by r. If this succeeds, then the other random
variables occuring in C are not used in the given positions
anymore. This might enable new applications of Indep, e.g.,
if a variable r(cid:48) that previously occcured in C{r} in an adver-
sary argument only occurs in the event afterwards. Another
useful side-eﬀect is that Rnd might remove products of vari-

1163GBB,1 =

GBB,4 =

i∗ ← A1();

1 :
2 : c, d, h, e ←$ Fq; let P =(gc, gd, gh);
3 : b ←$ B; let C =(ge, g(d∗i∗+h)∗e );
let K0 = ˆe(g, g)c∗d∗e ; K1 ←$ Gt;
4 :
5 : b(cid:48) ← A2(P, C, (b?K0 : K1)) with

PrivKey(i) = {
guard(i (cid:54)= i∗);
r ←$ Fq;
return (g(c∗d+r∗(d∗i+h)), gr)

5.1 :
5.2 :
5.3 :

};

i∗ ← A1();

1 :
2 : c, d, h, e, t ←$ Fq; let P =(gc, gd, gh−d∗i∗
3 : b ←$ B; let C =(ge, gh∗e);
4 :
5 : b(cid:48) ← A2(P, C, (b?K0 : K1)) with

let K0 = ˆe(g, g)t ; K1 ←$ Gt;

PrivKey(i) = {
guard(i (cid:54)= i∗);
r ←$ Fq;
return (g(c∗d+r∗(d∗(i−i∗)+h)), gr)

5.1 :
5.2 :

5.3 :

};

GBB,2 =

);

GBB,5 =

i∗ ← A1();

1 :
2 : c, d, h, e ←$ Fq; let P =(gc, gd, gh−d∗i∗
3 : b ←$ B; let C =(ge, gh∗e );
let K0 = ˆe(g, g)c∗d∗e; K1 ←$ Gt;
4 :
5 : b(cid:48) ← A2(P, C, (b?K0 : K1)) with

);

PrivKey(i) = {
guard(i (cid:54)= i∗);
r ←$ Fq;
return ( g(c∗d+r∗(d∗(i−i∗)+h)) , gr)

5.1 :
5.2 :

5.3 :

};

i∗ ← A1();

1 :
2 : c, d, h, e, t ←$ Fq; let P =(gc, gd, gh−d∗i∗
3 : b ←$ B; let C =(ge, gh∗e);
5 : b(cid:48) ← A2(P, C, ˆe(g, g)t )) with

);

PrivKey(i) = {
guard(i (cid:54)= i∗);
r ←$ Fq;
return (g(c∗d+r∗(d∗(i−i∗)+h)), gr)

5.1 :
5.2 :

5.3 :

};

Figure 6: Proof of the Boneh-Boyen IBKEM using our high-level rules.

ables that are not deducible from the values provided by the
challenger for an assumption. Finally, we try to to apply one
of the decisional assumptions speciﬁed in the given context.
To exclude useless applications of decisional assumptions,
we check that the adversary arguments that diﬀer in G0 and
G1 are used. To prevent cycles, we also disallow applications
of assumptions that undo previous applications by applying
the assumption in the opposite direction. In general, non-
termination might still be possible and we therefore bound
the size of the explored proof trees.

Example 2. We now prove the judgment from Example 1
using the high-level rules. Our implementation of the proof
search automatically ﬁnds the following proof.

The proof search ﬁrst applies Simp which yields the game
GBB,1 given in Figure 6. We keep the let-deﬁnitions in our
presentation to increase readability.

In the next step, the proof search applies the Rnd(cid:63) rule
to the sampling of h. The proof search discovers that h is
used in the context h + d∗ i∗ in the exponent of C2 and that
replacing h+d∗i∗ by h removes all occurences of the product
d ∗ e from the game. The elaborated core rule application is

Rnd(ph, 2 − d ∗ i

∗

, 2 + d ∗ i
∗

)

where ph is the position of the sampling of h. The rule
replaces h ←$ Fq by h(cid:48) ←$ Fq; let h = h(cid:48) − d ∗ i∗ and after
unfolding, the new exponent of C2 is (d∗i∗ +(h(cid:48)−d∗i∗))∗e =
h(cid:48) ∗ e. After renaming h(cid:48) to h, we get game GBB,2 given in
Figure 6.
Next, the proof search focuses on the product c ∗ d in the
exponent of the ﬁrst group element returned by PrivKey and
applies Rnd(cid:63) to replace the expression r ∗ (i − i∗) + c by r

The actual core rule application is

Rnd(pr, (2 − c)/(i − i
∗

), 2 ∗ (i − i
∗

) + c)

where pr is the position of the sampling of r in the oracle.
Here, sppr (GBB,2) includes the axiom i (cid:54)= i∗ which is re-

quired to prove that the second context is the inverse of the
ﬁrst. After simpliﬁcation, line 5.3 changes to

5.3 :

return (gd∗r+h∗(r−c)/(i−i∗), g(r−d)/(i−i∗)).

In the next step, the proof search automatically applies
the DBDH assumption. The rule matches up the samplings
of c, d, e in the game with the samplings of a, b, c in the
DBDH assumption. The rule synthesizes the simulator given
in Figure 7 using (ξ1, ξ2, ξ3, ξ4) = (gc, gd, ge, ˆe(g, g)c∗d∗e) to
denote B’s input. Applying the rule results in the game
GBB,4 given in Figure 6. The game GBB,4 diﬀers from GBB,3
in the sampling of t and the value assigned to K0.

To ﬁnish the proof, the proof search ﬁrst applies IfEq to
obtain game GBB,5 given in Figure 6. Afterwards b does not
occur anywhere except in the event b = b(cid:48) and the proof
is concluded by applying the Indep rule to the randomly
sampled boolean b. The application of Indep yields the
desired probability bound 1
2 .

6. ADVANCED CORES RULES

The set of basic core rules are complemented by a set of
advanced core rules which are required for more advanced
examples. The set of advanced core rules is given in Fig-
ure 8. The set contains rules new rules for program trans-
formations, equivalence up to failure, and hybrid arguments.

1164Program transformation:

Equivalence up to failure:

Assert(c)

[ G; assert(c) : ev ∧ c ]t (cid:22) 

[ G : ev ∧ c ]t (cid:22) 

Upto(p, c)

[ G{guard(c)}p : ev ]t (cid:22) 1

[ G{guard(c)}p : ∃ x ∈ Qo. c(x) (cid:54)= c

[ G{guard(c

(cid:48)

)}p : ev ]t (cid:22) 1 + 2

(cid:48)

(x) ]succ (cid:22) 2

p ﬁrst position in o

Guess

[ G; x ← A() : ev ]t (cid:22)  × no

[ G : ∃ x ∈ Qo. ev ]t (cid:22) 

Find(C, e)

[ G; x ← A(e) : ev1 ∧ ev2 ]t (cid:22) 
[ G : (∃ x ∈ Qo. ev1) ∧ ev2 ]t (cid:22) 

C eﬃcient and
sp|G|(G) |= C{(e, x)} =E ev1

Hybrid Arguments:

Hybrid(p, ob)

[ G{ob}p : ev ]t (cid:22) 1

[ SE1 ][SE2] (cid:22) 2

[ G{ob

(cid:48)}p : ev ]t (cid:22) 1 + no × 2

p points to body of o, ev(cid:48) = splitQuants(o, ev),
SE1 = [ G{bif< : ob | bif= : ob(cid:48) | bif> : ob(cid:48)}p : ev(cid:48) ], and
SE2 = [ G{bif< : ob | bif= : ob | bif> : ob(cid:48)}p : ev(cid:48) ]

OSwap(p)

[ SE{}p{x ←$ D}p(cid:48) ]t (cid:22) 
[ SE{x ←$ D}p ]t (cid:22) 

p ﬁrst position in bif= of hybrid oracle
p(cid:48) position before adversary call containing p

Figure 8: Advanced Core Rules.

i∗ ← A1();

1 :
2 : h ←$ Fq; let P =(ξ1, ξ2, ξi∗
3 : b ←$ B; let C =(ξ3, ξh
3 ;
let K0 = ξ4; K1 ←$ Gt;
4 :
5 : b(cid:48) ← A2(P, C, (b?K0 : K1)) with

2 ∗ gh);

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)

B =

5.1 :
5.2 :

5.3 :

6 :

PrivKey(i) = {
guard(i (cid:54)= i∗);
r ←$ Fq;
return (ξr

};

return b = b(cid:48)

2 ∗ gh∗r/(i−i∗) ∗ ξ
, gr/(i−i∗) ∗ ξ

−1/(i−i∗)
2

)

−h/(i−i∗)
1

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)

Figure 7: Synthesized simulator for DBDH.

6.1 Program transformation

The Assert(c) rule appends the command assert(c) to
the body of the game and requires that the event already
contains the conjunct c. The assert(c) can then be moved
further up using Swap if c is well-deﬁned at the given posi-
tion. Then the condition c can be exploited to simplify later
commands.
6.2 Equivalence up to failure

The Upto(p, c) rule replaces guard(c(cid:48)) at position p in an
oracle with guard(c) and yields two proof obligations: In the
resulting game, bound the probability of the original event
and the probability that the adversary performs a query
where the results of c and c(cid:48) diﬀer. To deal with the exis-
tential quantiﬁers introduced by Upto, the following rules
are used. The Guess and Find(C, e) rules get rid of an exis-
tential quantiﬁcation ∃x ∈ Qo. ev in the event by introducing

an adversary that guesses or ﬁnds an e ∈ Qo for which ev
is true. The arguments e and C of the Find rule deﬁne the
argument given to A and (eﬃcient) test executed by A to
determine if a given x ∈ Qo satisﬁes ev.
6.3 Hybrid arguments

To formalize hybrid arguments, we ﬁrst extend the syntax
and semantics of games with hybrid oracles. A hybrid oracle
has a body of the following form:

[bif< : ob1 | bif= : ob2 | bif> : ob3]

Here, ob1, ob2, and ob3 are ordinary oracle bodies consisting
of a sequence of oracle commands and a return expression.
To execute a game containing hybrid oracles, a value io in
{0, . . . , δo − 1} is sampled initially for each hybrid oracle o.
The oracle body for a hybrid oracle o is deﬁned as

(co < io) then bif<
if
elif (co = io) then bif=
elif (co > io) then bif>.

For Hybrid oracles, the query loq Qo contains only argu-
ments for queries with co (cid:54)= io and the argument of the
io-query is stored in a global variable.

Hybrid oracles are required to express the proof obliga-
tions of the Hybrid rule. The Hybrid(p, ob) rule replaces
the oracle body ob(cid:48) with ob at position p and yields two
proof obligations: Bound the original event ev in the result-
ing game and bound the distinguishing probability for the
two hybrid games. In both hybrid games, ob is used if co < io
and ob(cid:48) is used if co > io. If co = io, the ﬁrst hybrid game
uses ob(cid:48) and the second hybrid game uses ob. The modiﬁed
event ev(cid:48) accounts for the fact that the query log does not
contain the argument for the io-th query anymore. It uses
the function splitQuants to replace quantiﬁcations such as
∀x ∈ Qo. c (cid:54)= c∗ with (∀x ∈ Qo. c (cid:54)= c∗) ∧ c (cid:54)= c∗ where c
refers to the argument of the io-th query.

1165A related rule is the OSwap(p) rule that requires the po-
sition p to point into a hybrid oracle deﬁnition. More pre-
cisely, p must point to the ﬁrst command of the body for
io = co, and this must be a sampling. OSwap exploits that
the body for io = co is executed at most once and moves this
sampling to the main body of the game immediately before
the adversary call containing the oracle deﬁnition.

7. TOOL AND CASE STUDIES

We have implemented the logic and the described algo-
rithms in the AutoG&P tool and veriﬁed its eﬀectiveness on
the case studies presented in Table 1.1 The source code of
AutoG&P comprises about 13K lines of OCaml with about
3KLoC each for proof search and extraction to EasyCrypt.
The tool performs proof search with a bound on the size of
the proof tree to ensure termination.
7.1 Case studies

The ﬁrst four entries of the table are smaller examples
that can be proven automatically except for the ﬁrst one.
The ﬁrst example proves the implication between two as-
sumptions and requires a creative step that the proof search
(expectedly) does not discover.

The Cramer-Shoup encryption scheme and the Kurosawa-
Desmedt encryption scheme use cyclic groups and are IND-
CCA secure. Our proofs of the two schemes closely follow
the published proofs and yield similar bounds. For Cramer-
Shoup, we provide two proofs. The ﬁrst proof is manual
(25 lines) and checked in one second. The second proof is
discovered fully automatically by the proof search algorithm.
The proof is essentially identical to our manual proof and
is found in around 12 seconds. The structure-preserving
encryption scheme by Camenisch et al. uses bilinear groups
of Type I. Again, the structure of our proofs closely follows
the pen-and-paper proof. All three proofs rely on the Upto
rule for reasoning up to failure.

The proof of selective security for the Boneh-Boyen IBE
scheme is discovered automatically both for the Type I and
Type III versions of the scheme. Somewhat surprisingly, the
sequence of high-level rule applications is identical for both
settings which is promising for certiﬁed automated trans-
lation between settings. The proof of full security for the
Water dual-system IBE follows the dual-system methodol-
ogy, i.e., ﬁrst the challenge cipher-text is encrypted using
the so-called semi-functional encryption algorithm, then a
hybrid argument is used to replace the key generation algo-
rithm by a semi-functional version, and ﬁnally, it is shown
that the view of the adversary is independent of the bit b.
7.2 EasyCrypt proof generation

We have implemented a proof generation mechanism that
transforms a valid derivation in our logic into a ﬁle that
can be veriﬁed independently using EasyCrypt. Generation
is done in four steps:

1. build a context that declares all size variables, opera-
tors, constants and global variables required in the diﬀerent
games of the proof. This step translates the signature and
the setting into EasyCrypt;

2. build the sequence of games, including the code of the

simulators in reduction steps;

1 The AutoG&P tool and the case studies are available at
https://github.com/ZooCrypt/AutoGnP.

3. output judgments in the relational and ambient logics
of EasyCrypt to justify all steps in the derivation tree. This
step critically uses high-level proof principles formalized and
proved in EasyCrypt libraries;

4. prove the concluding claim by combining all previous

derived inequalities.

The generation algorithm involves some non-trivial “plumb-
ing” between the two systems. In the long term, we plan to
enhance automation in EasyCrypt by providing a tighter in-
tegration of AutoG&P and EasyCrypt.

8. RELATED WORK

There is an increasing number of tools for proving the se-
curity of cryptographic constructions in the computational
model. The oldest tool is CryptoVerif [13], which has been
used for protocols and a few primitives. To our best knowl-
edge, CryptoVerif achieves best automation for protocols and
has never been used to verify pairing-based constructions.
More recent tools, such as CertiCrypt [9], EasyCrypt [8], and
FCF [34] can be used to reason about protocols and primi-
tives. Indeed, CertiCrypt has been used to verify the chosen
plaintext security of Boneh and Franklin Identity Based En-
cryption in the random oracle model [10]. However, these
tools are mostly interactive and proofs are very long and
can only be built by experts. On the other hand, there ex-
ist specialized tools, such as [19], [27], [26], [33], [31] and [7],
which achieve complete automation for specialized classes of
constructions (padding-based encryption, message authen-
tication codes, modes of operation, authenticated encryp-
tion, bounded security of structure-preserving signatures in
the generic group model). Our work is closely related to
ZooCrypt [5], which relies on a powerful domain-speciﬁc logic
to reason about chosen-plaintext and chosen-ciphertext se-
curity of padding-based encryption schemes; in particular,
our work generalizes the idea of algebraic reduction from
ZooCrypt. However, our logic is applicable to a broad range
of constructions—although AutoG&P is focused on group-
based and pairing-based cryptography. Moreover, our core
logic has strong connections with Computational Indistin-
guishability Logic, or CIL [6], a general-purpose logic to
reason about security of cryptographic constructions. How-
ever, CIL does not provide a syntax for describing games
and does not oﬀer support for automation.

9. CONCLUSION

We have introduced a formal logic that supports concise
and intuitive proofs of cryptographic constructions, and pre-
sented the AutoG&P tool, which implements the logic for the
specialized case of pairing-based cryptography. Our exper-
iments show that formal proofs of complex pairing-based
constructions are now within reach. Future work includes
extending the scope of AutoG&P to accommodate i. q-type
and interactive assumptions; ii. random oracles; iii. key ex-
change protocols; iv. other types of constructions, including
(structure preserving) signatures; v. other areas, including
lattice-based cryptography. In addition, we plan to explore
the possibility to build on top of AutoG&P automated proof
transformations from Type I to Type III settings [4, 3], or
composite-order via prime-order groups [25, 32, 30].

1166Reference

Abe et al. ’10 [1]
ElGamal ’84 [23]
Escala et al. ’13 [24]
Escala et al. ’13 [24]

Case study

Scheme
DDH ⇒ DP assumption
ElGamal encryption
Matrix D-Lin Encryption
Matrix S-Casc Encryption

Property

reduction
IND-CPA
IND-CPA
IND-CPA

LoC

4
auto
auto
auto

Proof

Time (s)

1
1
1
1

1/12
2
12

2
3

Cramer and Shoup ’98 [20] Cramer-Shoup encryption
Abe et al. ’05 [2]
Camenisch et al. ’11 [16]

IND-CCA
Kurosawa-Desmedt encryption
IND-CCA
Structure-preserving encryption IND-CCA

25/auto
70
22

Boneh and Boyen ’04 [14]
Waters ’09 [36]

Boneh-Boyen IBE
Waters dual-system IBE

sID-IND-CPA auto
ID-IND-CPA 98

Table 1: Case studies

Acknowledgement
This work is supported in part by ONR grant N00014-12-1-
0914, Madrid regional project S2009TIC-1465 PROMETI-
DOS, and Spanish national projects TIN2009-14599 DE-
SAFIOS 10, and TIN2012-39391-C04-01 Strongsoft. The
research of Schmidt has received funds from the European
Commission’s Seventh Framework Programme Marie Curie
Cofund Action AMAROUT II (grant no. 291803).
10. REFERENCES
[1] M. Abe, G. Fuchsbauer, J. Groth, K. Haralambiev,

and M. Ohkubo. Structure-preserving signatures and
commitments to group elements. In T. Rabin, editor,
Advances in Cryptology – CRYPTO 2010, volume
6223 of Lecture Notes in Computer Science, pages
209–236. Springer, Aug. 2010.

[2] M. Abe, R. Gennaro, K. Kurosawa, and V. Shoup.

Tag-KEM/DEM: A new framework for hybrid
encryption and a new analysis of Kurosawa-Desmedt
KEM. In R. Cramer, editor, Advances in Cryptology –
EUROCRYPT 2005, volume 3494 of Lecture Notes in
Computer Science, pages 128–146. Springer, May 2005.

[3] M. Abe, J. Groth, M. Ohkubo, and T. Tango.

Converting cryptographic schemes from symmetric to
asymmetric bilinear groups. In Advances in Cryptology
– CRYPTO 2014, Part I, Lecture Notes in Computer
Science, pages 241–260. Springer, Aug. 2014.

[4] J. A. Akinyele, M. Green, and S. Hohenberger. Using
SMT solvers to automate design tasks for encryption
and signature schemes. In A.-R. Sadeghi, V. D. Gligor,
and M. Yung, editors, ACM CCS 13: 20th Conference
on Computer and Communications Security, pages
399–410. ACM Press, Nov. 2013.

[5] G. Barthe, J. M. Crespo, B. Gr´egoire, C. Kunz,

Y. Lakhnech, B. Schmidt, and S. Z. B´eguelin. Fully
automated analysis of padding-based encryption in the
computational model. In A.-R. Sadeghi, V. D. Gligor,
and M. Yung, editors, ACM CCS 13: 20th Conference
on Computer and Communications Security, pages
1247–1260. ACM Press, Nov. 2013.

[6] G. Barthe, M. Daubignard, B. M. Kapron, and

Y. Lakhnech. Computational indistinguishability logic.
In E. Al-Shaer, A. D. Keromytis, and V. Shmatikov,
editors, ACM CCS 10: 17th Conference on Computer
and Communications Security, pages 375–386. ACM
Press, Oct. 2010.

[7] G. Barthe, E. Fagerholm, D. Fiore, A. Scedrov,
B. Schmidt, and M. Tibouchi. Strongly-optimal
structure preserving signatures from type II pairings:
Synthesis and lower bounds. In J. Katz, editor,
Public-Key Cryptography - PKC 2015, volume 9020 of
Lecture Notes in Computer Science, pages 355–376.
Springer, 2015.

[8] G. Barthe, B. Gr´egoire, S. Heraud, and S. Z. B´eguelin.

Computer-aided security proofs for the working
cryptographer. In P. Rogaway, editor, Advances in
Cryptology – CRYPTO 2011, volume 6841 of Lecture
Notes in Computer Science, pages 71–90. Springer,
Aug. 2011.

[9] G. Barthe, B. Gr´egoire, and S. Zanella-B´eguelin.
Formal certiﬁcation of code-based cryptographic
proofs. In 36th ACM SIGPLAN-SIGACT Symposium
on Principles of Programming Languages, POPL
2009, pages 90–101, New York, 2009. ACM.

[10] G. Barthe, F. Olmedo, and S. Z. B´eguelin. Veriﬁable
security of boneh-franklin identity-based encryption.
In Proceedings of the 5th International Conference on
Provable Security, ProvSec’11, pages 68–83, Berlin,
Heidelberg, 2011. Springer-Verlag.

[11] M. Bellare, A. Desai, E. Jokipii, and P. Rogaway. A

concrete security treatment of symmetric encryption.
In Foundations of Computer Science, 1997.
Proceedings., 38th Annual Symposium on, pages
394–403. IEEE, 1997.

[12] B. Blanchet. An eﬃcient cryptographic protocol

veriﬁer based on prolog rules. In Proceedings of the
14th IEEE workshop on Computer Security
Foundations, page 82. IEEE Computer Society, 2001.

[13] B. Blanchet. A computationally sound mechanized

prover for security protocols. In 2006 IEEE
Symposium on Security and Privacy, pages 140–154.
IEEE Computer Society Press, May 2006.

[14] D. Boneh and X. Boyen. Eﬃcient selective-ID secure
identity based encryption without random oracles. In
C. Cachin and J. Camenisch, editors, Advances in
Cryptology – EUROCRYPT 2004, volume 3027 of
Lecture Notes in Computer Science, pages 223–238.
Springer, May 2004.

[15] D. Boneh and A. Silverberg. Applications of

multilinear forms to cryptography. Contemporary
Mathematics, 324(1):71–90, 2003.

1167[16] J. Camenisch, K. Haralambiev, M. Kohlweiss,

J. Lapon, and V. Naessens. Structure preserving CCA
secure encryption and applications. In D. H. Lee and
X. Wang, editors, Advances in Cryptology –
ASIACRYPT 2011, volume 7073 of Lecture Notes in
Computer Science, pages 89–106. Springer, Dec. 2011.

[17] J.-S. Coron, T. Lepoint, and M. Tibouchi. Practical

multilinear maps over the integers. In R. Canetti and
J. A. Garay, editors, Advances in Cryptology –
CRYPTO 2013, Part I, volume 8042 of Lecture Notes
in Computer Science, pages 476–493. Springer, Aug.
2013.

[18] V. Cortier and S. Delaune. Decidability and

combination results for two notions of knowledge in
security protocols. Journal of Automated Reasoning,
48(4):441–487, 2012.

[19] J. Courant, M. Daubignard, C. Ene, P. Lafourcade,

and Y. Lakhnech. Towards automated proofs for
asymmetric encryption schemes in the random oracle
model. In P. Ning, P. F. Syverson, and S. Jha, editors,
ACM CCS 08: 15th Conference on Computer and
Communications Security, pages 371–380. ACM Press,
Oct. 2008.

[20] R. Cramer and V. Shoup. A practical public key

cryptosystem provably secure against adaptive chosen
ciphertext attack. In H. Krawczyk, editor, Advances in
Cryptology – CRYPTO’98, volume 1462 of Lecture
Notes in Computer Science, pages 13–25. Springer,
Aug. 1998.

[21] C. J. Cremers. The scyther tool: Veriﬁcation,

falsiﬁcation, and analysis of security protocols. In
Computer Aided Veriﬁcation, pages 414–418. Springer,
2008.

[22] W. Decker, G.-M. Greuel, G. Pﬁster, and

H. Sch¨onemann. Singular 4-0-2 — A computer
algebra system for polynomial computations.
http://www.singular.uni-kl.de, 2015.

[23] T. ElGamal. A public key cryptosystem and a

signature scheme based on discrete logarithms. In
G. R. Blakley and D. Chaum, editors, Advances in
Cryptology – CRYPTO’84, volume 196 of Lecture
Notes in Computer Science, pages 10–18. Springer,
Aug. 1984.

[24] A. Escala, G. Herold, E. Kiltz, C. R`afols, and

J. Villar. An algebraic framework for Diﬃe-Hellman
assumptions. In R. Canetti and J. A. Garay, editors,
Advances in Cryptology – CRYPTO 2013, Part II,
volume 8043 of Lecture Notes in Computer Science,
pages 129–147. Springer, Aug. 2013.

[25] D. M. Freeman. Converting pairing-based

cryptosystems from composite-order groups to
prime-order groups. In H. Gilbert, editor, Advances in
Cryptology – EUROCRYPT 2010, volume 6110 of
Lecture Notes in Computer Science, pages 44–61.
Springer, May 2010.

[26] M. Gagn´e, P. Lafourcade, and Y. Lakhnech.

Automated security proofs for almost-universal hash

for MAC veriﬁcation. In J. Crampton, S. Jajodia, and
K. Mayes, editors, ESORICS 2013: 18th European
Symposium on Research in Computer Security, volume
8134 of Lecture Notes in Computer Science, pages
291–308. Springer, Sept. 2003.

[27] M. Gagn´e, P. Lafourcade, Y. Lakhnech, and

R. Safavi-Naini. Automated security proof for
symmetric encryption modes. In A. Datta, editor,
Advances in Computer Science - ASIAN 2009, volume
5913 of Lecture Notes in Computer Science, pages
39–53. Springer, 2009.

[28] S. Garg, C. Gentry, and S. Halevi. Candidate

multilinear maps from ideal lattices. In T. Johansson
and P. Q. Nguyen, editors, Advances in Cryptology –
EUROCRYPT 2013, volume 7881 of Lecture Notes in
Computer Science, pages 1–17. Springer, May 2013.

[29] K. O. Geddes and G. Labahn. Algorithms for computer

algebra. Springer Science & Business Media, 1992.

[30] G. Herold, J. Hesse, D. Hofheinz, C. R`afols, and

A. Rupp. Polynomial spaces: A new framework for
composite-to-prime-order transformations. In
Advances in Cryptology – CRYPTO 2014, Part I,
Lecture Notes in Computer Science, pages 261–279.
Springer, Aug. 2014.

[31] V. T. Hoang, J. Katz, and A. J. Malozemoﬀ.

Automated analysis and synthesis of authenticated
encryption schemes. In ACM Conference on Computer
and Communications Security, 2015.

[32] A. B. Lewko. Tools for simulating features of

composite order bilinear groups in the prime order
setting. In D. Pointcheval and T. Johansson, editors,
Advances in Cryptology – EUROCRYPT 2012, volume
7237 of Lecture Notes in Computer Science, pages
318–335. Springer, Apr. 2012.

[33] A. J. Malozemoﬀ, J. Katz, and M. D. Green.

Automated analysis and synthesis of block-cipher
modes of operation. In Computer Security
Foundations Symposium (CSF), 2014 IEEE 27th,
pages 140–152. IEEE, 2014.

[34] A. Petcher and G. Morrisett. The foundational

cryptography framework. In R. Focardi and A. C.
Myers, editors, Principles of Security and Trust - 4th
International Conference, POST, volume 9036 of
Lecture Notes in Computer Science, pages 53–72.
Springer, 2015.

[35] B. Schmidt, S. Meier, C. Cremers, and D. Basin.

Automated analysis of Diﬃe-Hellman protocols and
advanced security properties. In Computer Security
Foundations Symposium (CSF), pages 78–94. IEEE,
2012.

[36] B. Waters. Dual system encryption: Realizing fully
secure IBE and HIBE under simple assumptions. In
S. Halevi, editor, Advances in Cryptology –
CRYPTO 2009, volume 5677 of Lecture Notes in
Computer Science, pages 619–636. Springer, Aug.
2009.

1168