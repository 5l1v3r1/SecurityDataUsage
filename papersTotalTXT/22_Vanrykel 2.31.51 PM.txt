Leaky Birds: Exploiting Mobile Application

Traﬃc for Surveillance

Eline Vanrykel1, Gunes Acar2, Michael Herrmann2, and Claudia Diaz2

1 KU Leuven, Leuven, Belgium

eline.vanrykel@gmail.com

2 KU Leuven ESAT/COSIC, iMinds, Leuven, Belgium

{name.surname}@esat.kuleuven.be

Abstract. Over the last decade, mobile devices and mobile applica-
tions have become pervasive in their usage. Although many privacy risks
associated with mobile applications have been investigated, prior work
mainly focuses on the collection of user information by application de-
velopers and advertisers. Inspired by the Snowden revelations, we study
the ways mobile applications enable mass surveillance by sending unique
identiﬁers over unencrypted connections. Applying passive network ﬁn-
gerprinting, we show how a passive network adversary can improve his
ability to target mobile users’ traﬃc.
Our results are based on a large-scale automated study of mobile applica-
tion network traﬃc. The framework we developed for this study down-
loads and runs mobile applications, captures their network traﬃc and
automatically detects identiﬁers that are sent in the clear. Our ﬁndings
show that a global adversary can link 57% of a user’s unencrypted mobile
traﬃc. Evaluating two countermeasures available to privacy aware mo-
bile users, we ﬁnd their eﬀectiveness to be very limited against identiﬁer
leakage.

1

Introduction

Documents that have been revealed by the former NSA contractor Edward
Snowden shed light on the massive surveillance capabilities of the USA and UK
intelligence agencies. One particular document released by the German newspa-
per Der Spiegel describes the ways in which traﬃc of mobile applications (apps)
is exploited for surveillance [16]. The document, which reads “Exploring and
Exploiting Leaky Mobile Apps With BADASS,” provides a unique opportunity
to understand the capabilities of powerful network adversaries. Furthermore, the
document reveals that identiﬁers sent over unencrypted channels are being used
to distinguish the traﬃc of individual mobile users with the help of so-called se-
lectors. Similar revelations about the use of Google cookies to target individuals
imply that BADASS is not an isolated incident [12, 34].

While it is known that a substantial amount of mobile app traﬃc is unen-
crypted and contains sensitive information such as users’ location or real identi-
ties [24,35,43], the opportunities that mobile traﬃc oﬀers to surveillance agencies

II

may still be greatly underestimated. Identiﬁers that are being sent in the clear,
may allow the adversary to link app sessions of users and thus to learn more
information about the surveilled users than he could without. The purpose of
this study is to evaluate this risk and to quantify the extent to that it is possible
to track mobile app users based on unencrypted app traﬃc.

To this end we present a novel framework to quantify the threat that a
surveillance adversary poses to smartphone users. The framework automates the
collection and analysis of mobile app traﬃc: it downloads and installs Android
apps, runs them using Android’s The Monkey [18] tool, captures the network
traﬃc on cloud-based VPN servers, and ﬁnally analyzes the traﬃc to detect
unique and persistent identiﬁers. Our framework allows large-scale evaluation of
mobile apps in an automated fashion, which is demonstrated by the evaluation
of 1260 apps. We choose the apps among all possible categories of the Google
Play store and of diﬀerent popularity levels.

Our study is inspired by a recent work by Englehardt et al. [26]. They studied
the surveillance implications of cookie-based tracking by combining web and
network measurements. The evaluation method they use boils down to measuring
the success of the adversary by the ratio of user traﬃc he can cluster together.
We take a similar approach for automated identiﬁer detection but we extend
their work to capture non-cookie-based tracking methods that are suitable for
user tracking. Moreover, we show how TCP timestamp-based passive network
ﬁngerprinting can be used to improve the clustering of the traﬃc and may allow
to detect the boot time of Android devices.

1.1 Contributions

Large-scale, automated study on surveillance implications of mobile
apps. We present an automated analysis of 1260 Android apps from 42 app
categories and show how mobile apps enable third party surveillance by sending
unique identiﬁers over unencrypted connections.

Applying passive network ﬁngerprinting for mobile app traﬃc ex-
ploitation. We show how a passive network adversary can use TCP timestamps
to signiﬁcantly improve the amount of traﬃc he can cluster. This allows us to
present a more realistic assessment of the threat imposed by a passive adversary.
Further, we show how an adversary can guess the boot time of an Android device
and link users’ traﬃc even if they switch from WiFi to 3G or vice versa.

Evaluation of the available defenses for privacy aware users. We an-
alyze the eﬃcacy of two mobile ad-blocking tools: Adblock Plus for Android [13]
and Disconnect Malvertising [14]. Our analysis shows that these tools have a
limited eﬀect preventing mobile apps from leaking identiﬁers.

2 Background and Related Work

III

Table 1: Unique smartphone identiﬁers present on Android, an overview.

Name

Persistence

Permission

Android ID
MAC Address
IMEI
IMSI
Serial number
SIM serial number
Phone number
Google Advertising ID until reset by the user

until a factory reset
lifetime of the device
lifetime of the device
lifetime of the SIM card
lifetime of the device
lifetime of the SIM card
lifetime of the SIM card

None

ACCESS WIFI STATE

READ PHONE STATE

READ PHONE STATE
None [41]

READ PHONE STATE

READ PHONE STATE
ACCESS NETWORK STATE, INTERNET

Android apps and identiﬁers. Android apps and third-parties can access
common identiﬁers present on the smartphone, such as MAC address, Google
Advertising ID or IMEI number. We call these identiﬁers smartphone IDs. An
overview of the Android smartphone IDs can be found in Table 1. Developers
may also choose to assign IDs to users (instead of using smartphone IDs), for
identifying individual app installations or simply to avoid asking for additional
permissions [11]. We refer to such identiﬁers as app assigned IDs.

Privacy implications of mobile apps. Although privacy implications of
Android apps have been extensively studied in the literature [25, 28, 29], prior
work has mainly focused on the sensitive information that is collected and trans-
mitted to remote servers. Xia et al. showed that up to 50% of the traﬃc can be
attributed to the real names of users [43]. Enck et al. developed TaintDroid [25],
a system-wide taint analysis system that allows runtime analysis and tracking
of sensitive information ﬂows. While it would be possible to use TaintDroid in
our study, we opted to keep the phone modiﬁcations minimal and collect data
at external VPN servers. This allows us to have a more realistic assessment of
application behavior and adversary capabilities.

Our work diﬀers from these studies, by quantifying the threat posed by a pas-
sive network adversary who exploits mobile app traﬃc for surveillance purposes.
We also show how the adversary can automatically discover user identiﬁers and
use passive network ﬁngerprinting techniques to improve his attack.

Passive network monitoring and surveillance. Englehardt et al. [26]
show how third-party cookies sent over unencrypted connections can be used to
cluster the traﬃc of individual users for surveillance. They found that recon-
structing 62-73% of the user browsing history is possible by passively observing
network traﬃc.

In addition to using identiﬁers to track smartphones, an eavesdropping ad-
versary can use passive network ﬁngerprinting techniques to distinguish traﬃc
from diﬀerent physical devices. Prior work showed that clock skew [31, 33, 44],
TCP timestamps [23, 42] and IP ID ﬁelds [21] can be used to remotely identify
hosts or count hosts behind a NAT. In this study, we use TCP timestamps to

IV

improve the linking of users’ mobile traﬃc in short time intervals. We assume
the adversary to exploit TCP timestamps to distinguish traﬃc of users who are
behind a NAT. Moreover, we demonstrate how an adversary can discover the
boot time of an Android device by exploiting TCP timestamps.

3 Threat Model

In this paper we consider passive network adversaries whose goal is to link
app traﬃc of smartphone users. The adversaries observe unique identiﬁers that
are being transmitted from mobile apps in the clear and apply network ﬁnger-
printing techniques. We consider that the adversaries cannot break cryptography
or launch MITM attacks such as SSLstrip [32].

We distinguish between two types of passive adversaries: A global passive
adversary, who can intercept all Internet traﬃc at all time; and a restricted
passive adversary who can only observe a limited part of the network traﬃc.
Both adversaries have the capability to collect bulk data. This may be achieved
in various ways, such as tapping into undersea ﬁber-optic cables; hacking routers
or switches; intercepting traﬃc at major Internet Service Providers (ISP) or
Internet Exchange Points (IXP) 3.

There can be several models in which an adversary may have limited access to
the user’s traﬃc. In this study we evaluate adversaries whose limitation is either
host-based or packet-based. The host-based adversary is only able to see traﬃc
bound to certain hosts; for example, because the adversary is only able to obtain
warrants for intercepting traﬃc within its own jurisdiction. The packet-based
adversary may only have access to a certain point in the Internet backbone and
thus miss traﬃc that is being sent along other routes. For both adversaries, we
evaluate the success based on diﬀerent levels of network coverage (Section 7.2).
We simulate partial network coverage by randomly selecting hosts or packets to
be analyzed depending on the model. For instance, for the host-based model with
0.25 network coverage, we randomly pick one-fourth of the hosts and exclude the
traﬃc bound to remaining hosts from the analysis.

4 Data Collection Methodology

4.1 Experimental Setup

We present the experimental setup4 that is used for this paper in Fig. 1. It in-
cludes a controller PC, two smartphones and two VPN servers for traﬃc capture.
The main building blocks of our framework are as follows:

3 All these methods are feasible, as illustrated by the Snowden revelations [6, 8].
4 The source code of the framework, as well as the collected data will be made available

to researchers upon request.

V

Fig. 1: Our setup in this study consists of a Controller PC that manages the
experiments, two Android phones that run apps, and two VPN servers that
capture the network traﬃc.

Controller PC. The Controller PC runs the software that orchestrates the
experiments and the analysis. It has three main tasks: 1) installing apps on the
smartphones and ensuring that the experiment runs smoothly, e.g. checking the
phone’s WiFi and VPN connections, 2) sending SSH commands to the remote
VPN servers to start, stop and download the traﬃc capture, 3) analyzing the
collected data.

Smartphones. We conducted our experiments with two Samsung Galaxy
SIII Mini smartphones running Android version 4.1.2. We rooted the phones to
address issues such as storage and uninstallation problems. Although we consid-
ered using the Android emulator as in other works [24, 36, 38], our preliminary
tests [39] showed that the number of transmitted identiﬁers is signiﬁcantly less
in the emulator compared to the same setting with a real smartphone and the
emulator lacks certain identiﬁers, such as the WiFi MAC address. We also chose
not to intercept system API calls or instrument the operating system, such as
in [25, 27], since we preferred a simpler and more portable solution.

The Monkey. We use The Monkey [18] tool to automate the experiments
and simulate the user interaction at large scale. The Monkey generates a pseudo-
random event stream that includes touch, motion and keyboard events.

Traﬃc Capture. The network traﬃc is captured by two remote VPN
servers, using the dumpcap [5] command line tool. Using VPN servers, we could
capture all the network traﬃc and not only HTTP traﬃc, which would be the
case with an HTTP proxy. Also, since we record the traﬃc on remote machines,
we ensure that there is no packet drop due to lack of buﬀer space on resource
constrained devices [15]. However, we captured traﬃc locally on the phone dur-
ing the evaluation of ad-blockers for Android. These tools use a proxy or VPN

INTERNETAds &AnalyticsApp BackendadbVPNController PCVPN ServersVI

themselves to block ads. Since Android does not allow simultaneous VPN con-
nections, we captured the traﬃc locally by running tcpdump on the smartphones.
To ensure comparability, we exclude all the captures where we observed packet
drops from the analysis (20% of the cases, 171 apps in two experiments).

Traﬃc parser. For parsing the captured network traﬃc, we developed a
Python script based on the dpkt [3] packet parsing library. The script allows
us to decode IPv4 and IPv6 datagrams, reassemble TCP streams, decompress
compressed HTTP bodies and to parse GRE and PPTP encapsulation used by
the VPN. We extract HTTP headers and bodies, packet timestamps, IP ad-
dresses and port numbers from the packets for later use. Since it is outside of
the scope of this study, we did not decrypt SSL/TLS records. However, for the
TCP timestamp analysis described in Section 6 it is beneﬁcial, yet not neces-
sary, to extract TCP timestamps from all TCP packets, including the ones from
encrypted HTTPS traﬃc. Note that this is within our adversary model, because
TCP headers are sent in the clear and thus available to a passive adversary.

Having described the main building blocks of the experimental setup, now

we outline the diﬀerent modes and steps of the experiments:

Experiment modes. We run experiments in two diﬀerent modes to evaluate
the diﬀerence in identiﬁer transmission; i) if the app is simply opened and ii) if
the user actually interacts with the app. We refer to the former as startscreen
experiment and to the latter as interactive experiment. The Monkey is used to
simulate user interaction in the interactive experiments.

Evaluation of ad-blocker apps. We evaluate the eﬀect of apps that block
ads and trackers. While those apps are not speciﬁcally designed to prevent iden-
tiﬁer leakage, they may still reduce the number of identiﬁers being sent in the
clear. Speciﬁcally, we repeated the experiment of the top-popularity apps after
we installed and activated the ad-blocker apps Adblock Plus for Android [13]
and Disconnect Malvertising [14].

Steps of the experiment. Our framework executes the steps of the experi-
ments in an entirely automated fashion. The Controller PC connects the smart-
phone to the VPN server by running a Python based AndroidViewClient [4]
script that emulates the touch events necessary to start the VPN connection
on the smartphone. Since installing all the apps at once is not possible due to
storage constraints, our framework conducts the experiment in cycles. In each
cycle we install 20 apps and then run them sequentially5. The apps for each
cycle are randomly chosen from the entire set of apps, with the condition that
each app is only picked once. Before running an app, the Controller PC kills the
process of the previous app. This way we are able to prevent the traﬃc of the
previously tested app mistakenly being recorded for the subsequent app. After
ﬁnished running the 20 apps, the Controller PC runs all 20 apps a second time
in the same order. Running each app twice enables the automated detection
of identiﬁers outlined in Section 5.1. Finally, the Controller PC completes the
current cycle by uninstalling all 20 apps.

5 We chose 20 since this was the maximum number of apps that can be installed on
an Android emulator at once, which we used in the preliminary stages of the study.

VII

4.2 Obtaining Android Applications

To obtain the Android apps, we developed scripts for crawling the Google
Play store and, subsequently, to download APK ﬁles. Our scripts are based on
the Python Selenium [17] library, the APK downloader browser extension and
webpages [1]. Using this software, we crawled the entire Play Store and obtained
information on 1, 003, 701 diﬀerent Android apps. For every app we collected
information such as number of downloads, rating scores and app category. This
allows us to rank the apps of every category according to their popularity.

For every app category we choose 10 apps from three diﬀerent popularity
levels: top-popularity, mid-popularity and low-popularity. While we use the most
popular apps for the top-popularity category, we sample the mid-popularity and
low-popularity apps from the 25th and 50th percentiles from each category. At
the time we conducted the crawl, there were 42 diﬀerent app categories and
we therefore obtained a total of 1260 (42 × 10 × 3) apps. The average time for
evaluating one app is 64 seconds.

5 Analysis Methodology

In the following we show how an adversary is able to extract identiﬁers from
network traﬃc and then use these identiﬁers to cluster data streams, i.e. linking
data streams as belonging to the same user. This is the same that an adversary
with the goal of surveilling Internet traﬃc would do, i.e. extracting and applying
a set of selectors that match unique and persistent mobile app identiﬁers.

5.1 Identiﬁer Detection

Suitable identiﬁers for tracking need to be persistent and unique, i.e. the
same ID cannot appear on diﬀerent phones and IDs need to be observable over
multiple sessions. Our framework automatically detects such unique identiﬁers
in unencrypted mobile app traﬃc. While the overall approach is similar to the
one in [19, 26] we extend the cookie-based identiﬁer detection technique to cover
mobile app traﬃc. We assume that the smartphone IDs (such as Android ID
or MAC address) are not known a priori to the adversary. The adversary has
to extract IDs based on the traﬃc traces only. Yet, we use smartphone IDs as
the ground truth to improve our automated ID detection method by tuning its
parameters.

For ﬁnding identiﬁers, we process HTTP request headers, bodies and URL
parameters. Speciﬁcally, the steps of the unique identiﬁer detection are as follows:

– Split URLs, headers, cookie contents and message bodies using common
delimiters, such as “=”, “&”, “:”, to extract key-value pairs. Decode JSON
encoded strings in HTTP message bodies.

VIII

– Filter out cookies with expiry times shorter than three months. A tracking

cookie is expected to have a longer expiry period [26].

– Compare values of the same key between runs of two smartphones.

– For each key-value pair, we construct an identifying rule set and add it to
the potential identiﬁer list. This is the tuple (host, position, key), where host
is extracted from the HTTP message and position indicates whether the key
was extracted from a cookie, header or URL.
• Eliminate values if they are not the same length.
• Eliminate values that are not observed in two runs of the same app on
• Eliminate values that are shorter than 10 or longer than 100 characters.
• Eliminate values that are more than 70% similar according to the Ratcliﬀ-

the same smartphone.

Obershelp similarity measure [22].

– Add (host, position, key) to the rule set.

We tuned similarity (70%) and length limits (10, 100) according to two crite-
ria: minimizing false positives and detecting all the smartphone identiﬁers (Ta-
ble 1) with the extracted rule set. We experimented with diﬀerent limit values
and picked the values that gave us the best results based on these criteria. A
more thorough evaluation of these limits is omitted due to space constraints, but
interested readers can refer to [19,26] for the main principles of the methodology.

5.2 Clustering of App Traﬃc

While the ultimate goal of the adversary is to link diﬀerent app sessions of
the same user by exploiting unique identiﬁers transmitted in app traﬃc, the
ﬁrst challenge of the adversary is to identify the traﬃc of one app. An app may
open multiple TCP connections to diﬀerent servers and linking these connections
can be challenging. The user’s public IP address is not a good identiﬁer: several
users may share the same public IP via a NAT. Moreover, IP addresses of mobile
phones are known to change frequently [20].

In this work we consider two diﬀerent clustering strategies. In the TCP stream
based linking, the attacker can only link IP packets based on their TCP stream.
The adversary can simply monitor creation and tear down of TCP streams and
ensure that the packets being sent within one stream are originating from the
same phone. The second, more sophisticated strategy employs passive network
ﬁngerprinting techniques to link IP packets of the same app session. We will
refer this technique as app session based linking and outline it in Section 6.

Following Englehardt et al. [26] we present linking of the user traﬃc as a
graph building process. We use the term node to refer to a list of packets that
the adversary is certain that they belong to the same user. As explained above,
this is either a TCP stream or an app session. For every node the adversary
extracts the identifying rule set (host, position, key) as described in Section 5.1.
Starting from these nodes, the adversary inspects the content of the traﬃc and
then tries to link nodes together to so-called components.

IX

Therefore, the attacker will try to match a node’s identiﬁers to the identiﬁers
of the existing components. We account for the fact that some developers do not
use the smartphone ID right away as identiﬁer, but derive an identiﬁer from it
by hashing or encoding. Thus the clustering algorithm will also try to match the
SHA-1, SHA-256, MD5 and murmur3 hashes and base64 encoded form of the
identiﬁers. For every node, there exist three possibilities when comparing the
node’s identiﬁers to a existing component’s identiﬁers:

1. The node’s value (or its derivative) matches the identiﬁers of an
existing component: The node will be added to the component and the
respective identiﬁers are being merged, i.e. the newly added node may include
identiﬁers not yet included in the component.

2. None of the node’s identiﬁers or their derivatives can be matched
to an existing component: The node creates its own component which is
disconnected from all other components.

3. The node shares identiﬁers with multiple components: These com-

ponents are merged together and the node is added to this component.

For the remainder of this paper, we refer to the component that contains the
highest number of nodes as the Giant Connected Component (GCC). Further-
more, we deﬁne the ratio of number of nodes in GCC to the number of nodes
in the whole graph as the GCC ratio. The GCC ratio serves as a metric for
measuring the adversary’s success for linking users’ traﬃc based on the amount
of traﬃc he observes.

5.3 Background Traﬃc Detection

The Android operating system itself also generates network traﬃc, for exam-
ple to check updates or sync user accounts. Although we ﬁnd in our experiments
that the Android OS does not send any identiﬁers in the clear, we still take
measures to avoid that this traﬃc pollutes our experiment data. Particularly,
we captured the network traﬃc of two smartphones for several hours multiple
times without running any app. A complete overview of all HTTP queries made
during such captures can be found in [40]. We excluded all the HTTP requests
to these domains during the analysis stage. Although we excluded background
traﬃc from our analysis, the adversary may try to exploit the background traﬃc
in a real-world attack.

6 Linking Mobile App Traﬃc with TCP Timestamps

In this section we elaborate on the adversary’s ability to employ passive
ﬁngerprinting techniques to link diﬀerent IP packets originating from the same
smartphone. As mentioned in Section 5.2, this gives a signiﬁcant advantage to
the adversary when clustering the user traﬃc. In particular, the adversary is

X

able to analyze TCP timestamps for this task as they are commonly allowed by
the ﬁrewalls [33].

TCP timestamps are an optional ﬁeld in TCP packets that include a 32-
bit monotonically increasing counter. They are used to improve the protocol
performance and protect against old segments that may corrupt TCP connec-
tions [30]. While the exact usage of TCP timestamps is platform dependent, our
inspection of the Android source code and capture ﬁles from our experiments
revealed that Android initializes the TCP timestamp to a ﬁxed value after boot
and uses 100Hz as the timestamp increment frequency [2]. Thus, at any time
t, TCP timestamp of a previously observed device can be estimated as follows:
T St = T Sprev +100×(t−tprev), where T Sprev is the timestamp observed at tprev
and (t−tprev) is the elapsed time. The adversary can therefore link diﬀerent visits
from the same device by comparing the observed TCP timestamps to his esti-
mate. Prior studies have shown that distinguishing devices behind a NAT using
TCP timestamps can be done in an eﬃcient and scalable manner [23, 37, 42].

Fig. 2: TCP timestamp vs. capture time plot of Angry Birds Space app follows
a line with a slope of 100, which is the timestamp resolution used by Android.
Diﬀerent TCP sessions, indicated by diﬀerent colors, can be linked together by
exploiting the linearity of the TCP timestamp values.

Fig. 2 demonstrates the linear increase of the TCP timestamps of a phone
running the “Angry Bird Space” app. To demonstrate the linkability of TCP
streams, every point in Fig. 2 is colored based on its TCP source and destination
port. The straight line shows that the adversary can easily link diﬀerent TCP
streams of the same device by exploiting the linearity of the timestamps. The

XI

adversary is also able to consider TCP timestamps of encrypted communications,
because TCP timestamps are sent unencrypted in the packet headers. This allows
adversaries within our threat model to further increase the success of the linking.
Furthermore, TCP timestamps can be used to link traﬃc even if the user switches
from WiFi to mobile data connection or vice versa [40]. Finally, the linking is still
feasible even if the adversary misses some packets, for instance, due to partial
coverage of the network.

Limitations. During the background traﬃc detection experiments, we ob-
served cases in which TCP timestamps are not incremented linearly. Consulting
the Android System Clock Documentation, we determined that the CPU and
certain system timers stop when the device enters the deep sleep state [10]. This
power saving mechanism is triggered only when the screen is oﬀ and the device
is not connected to the power outlet or USB port. Therefore, the phone will
never go into deep sleep when a user is interacting with an app and the TCP
timestamps will be incremented in a predictable way, allowing the linking of the
traﬃc by app sessions.

Implications for traﬃc linking. We will assume the adversary can use
TCP timestamps to cluster packets generated during the use of an app (app
session), as the phone never enters deep sleep mode when it is in active use. As
mentioned in Section 5.2, we will refer to this as app session based linking.

Android boot time detection. In addition to linking packets from diﬀer-
ent TCP streams, TCP timestamps can also be used to guess the boot time of
remote devices [7]. Among other things, boot time can be used to determine if
the device is patched with critical updates that require a reboot. Since it is not
directly related to traﬃc linking attack considered in the study, we explain the
boot time detection methodology in the unabridged version of this paper [40].

7 Results

7.1 Identiﬁer Detection Rules

We present in Table 2 an overview of the identifying rule set that we detected
by the methodology explained in Section 5.1. Recall that identifying rules cor-
respond to “selectors” in the surveillance jargon, which allow an adversary to
target a user’s network traﬃc. In total we found 1597 rules with our method, of
which 1127 (71%) correspond to a smartphone ID or its derivative. Our results
show that the Android ID and Google Advertising ID are the most frequently
transmitted smartphone IDs, accounting for 72% (812/1127) of the total. We
group the least commonly transmitted smartphone IDs under the Other Smart-
phone IDs column, which include the following: device serial number, IMSI, SIM
serial number and registered Google account email. Furthermore, we found 29%
of the extracted rules to be app-assigned IDs.

XII

Table 2: The extracted ID detection rules and corresponding smartphone IDs.
SID: Smartphone ID, AAID: App Assigned ID.

IMEI MAC Other

AAIDs Total

Exp.
Mode

App
popu-
larity

Android
ID

Google
Ad ID

Interactive top
Startscreen top
Interactive mid
Startscreen mid
Interactive low
Startscreen low

Total

165
115
56
48
73
47

504

111
56
28
28
61
24

308

63
45
20
16
22
16

182

29
19
6
5
15
7

81

SIDs

16
11
5
4
8
8

52

193
91
60
40
53
33

470

ID
Rules

577
337
175
141
232
135

1597

Analyzing the extracted rules for the top-popularity, interactive experiments,
we found that 50% of the identiﬁers are sent in the URI of the HTTP requests
(291 rules). In 39% (225) of the rules, the IDs are sent in the HTTP request
body, using the POST method. Only 3% (18) of the cases, the identiﬁer was
sent in a cookie. The average identiﬁer length in our rule set is 26.4 characters.
A sample of identifying rules is given in Table 3.

Table 3: Examples rules found in the constructed identifying rule set. The values
are modiﬁed to prevent the disclosure of real identiﬁers of the phones used in
the study.

Host

Position Key

ID

Value

data.flurry.com Body
apps.ad-x.co.uk URI
apps.ad-x.co.uk URI
alog.umeng.com Body
d.applovin.com Body

oﬀset60
custom data / meta udid Unknown
macAddress
header / device id
device info / idfa

Android ID AND9f20d23388...
19E5B4CEE6F5...
WiFi MAC D0:C4:F7:58:6C:12
IMEI
Google Ad ID 0e5f5a7d-a3e4-..

354917158514924

After extracting identiﬁer detection rules, we apply them to the traﬃc cap-
tured during the experiments. Due to space constraints we present the detailed
results on the transmitted IDs in the unabridged version of this paper [40].

Moreover, analyzing the traﬃc captures of the top-popularity apps, we found
that certain apps send precise location information (29 apps), email address (7
apps) and phone number (2 apps) in the clear. Together with the linking attack
presented in this paper, this allows an adversary to link signiﬁcantly more traﬃc
to real-life identities.

XIII

Table 4: The most common third-party hosts found to collect at least an identiﬁer
over unencrypted connections. The listed hosts are contacted by the highest
number of apps (based on 420 top-popularity apps, interactive experiment).

Host

# Apps Collected IDs

data.flurry.com

ads.mopub.com

apps.ad-x.co.uk

alog.umeng.com

a.applovin.com

43
32
22
16
16

Android ID
Google advertising ID
Google advertising ID, IMEI, Serial number, Android ID
IMEI
Google advertising ID

We found that 1076 diﬀerent hosts were contacted over unencrypted connec-
tions during the experiments for the top-popularity apps in the interactive mode.
The data.ﬂurry.com domain is the most popular third-party domain collecting
Android ID from 43 diﬀerent apps (Table 4). Note that data.ﬂurry.com received
a notable mention in the slides of the BADASS program [16] for its identiﬁer
leakage.

7.2 Traﬃc Clustering

Here we evaluate the adversary’s success in terms of unencrypted app traﬃc
ratio (GCC ratio) that he can link together in diﬀerent settings. We follow the
analysis methodology explained in Section 5.2 and present clustering results for
100 randomly selected combinations of 27 apps. We pick 27 apps since it is the
average number of apps used per month according to a recent survey [9]. Running
100 iterations with a diﬀerent combination of (27) apps allowed us to reduce the
variance between diﬀerent runs and account for all the studied apps. We only
consider apps that send at least one HTTP request and calculate the GCC ratio
based on the unencrypted traﬃc. For the top-popular apps in interactive mode,
these account for 69% of the apps. For simplicity, we will present the clustering
results for only one phone and a single run of each app. The results from two
phones did not have any signiﬁcant diﬀerence.

Eﬀect of using TCP timestamps for traﬃc linking. The left boxplot
in Fig. 3(a), shows that when the adversary does not take TCP timestamps into
account (TCP stream based linking), he can cluster 25% of users’ unencrypted
traﬃc. However, by exploiting TCP timestamps he can increase the GCC ratio
to 57%.

Eﬀect of app popularity Fig. 3(b) shows that popularity has a signiﬁcant
impact on the linking success of the adversary. The most popular apps allow
the adversary to cluster 57% of the unencrypted traﬃc, while the apps from
the mid-popular and low-popular level result in a GCC ratio of 32% and 28%,
respectively.

Due to space constraints, we will only present results for the apps from the

top-popularity level in the rest of this section.

XIV

(a) GCC ratio for the top-popularity
apps, shown for TCP stream and app ses-
sion based linking.

(b) GCC ratio for apps of diﬀerent popu-
larity levels for interaction mode.

(c) GCC ratio for top-popularity apps,
shown for interaction and startscreen
mode.

(d) GCC ratio for the top-popularity
apps, shown while using diﬀerent privacy
enhancing tools.

(e) GCC ratio for the top-popularity
apps, shown for diﬀerent network cover-
age levels of a host based restricted ad-
versary.

(f) GCC ratio for the top-popularity apps,
shown for diﬀerent network coverage lev-
els of a packet based restricted adversary.

Fig. 3: The success of the adversary under diﬀerent experimental settings and
adversary models. The GCC ratio is the proportion of the unencrypted app traﬃc
that the adversary can link together. The results are shown for 100 diﬀerent
randomly selected combinations of 27 apps.

XV

Eﬀect of user interaction. Fig. 3(c) shows the GCC ratio for two diﬀerent
experiment modes, interaction and startscreen. Although, the number of identi-
ﬁers sent in two modes are signiﬁcantly diﬀerent (577 vs. 337), the graph shows
a similar GCC ratio around 53% for two modes. A possible explanation is that
the identiﬁers that enable linking are already sent as soon as the app is started.
Eﬀect of countermeasures. Fig. 3(d) shows that both ad-blocking apps
provide a limited protection against linking of the app traﬃc. Using Adblock Plus
leads to an average linking of 50%. Disconnect Malvertising performs better, with
a GCC rate of 38%, reduced from 57%.

Restricted adversary. Fig. 3(e) shows that an adversary that can only
intercept traﬃc to 50% of the hosts can link up to 38% of the unencrypted mobile
app sessions. For the packet based restricted adversary model, we observe that
an adversary with a limited coverage of 25% of the user’s packets can still link
37% of all app sessions together (Fig. 3(f)). In both models restricted adversary’s
success grows almost linear with his network coverage. Note that packet based
restricted adversary can link signiﬁcantly more traﬃc than the host-based model
for the same network coverage ratio. This may be due to being able to observe
packets from more hosts which will allow to link apps across sessions.

8 Limitations

Some apps may not be fully discovered by The Monkey, leading to an incom-
plete view of the network traﬃc. Also, apps that require user logins may not
be suﬃciently analyzed by our automated methodology. For those reasons, our
results should be taken as lower bounds.

While we assume that the smartphones can be distinguished by their TCP
timestamps, some middleboxes may interfere with user traﬃc. Firewalls, proxies
or cache servers may terminate outgoing HTTP or TCP connections and open a
new connection to the outside servers. Furthermore, end-user NAT devices may
have various conﬁgurations and hence behave diﬀerently compared to enterprise
NATs. In such cases, the adversary’s ability to link traﬃc by TCP timestamps
may be reduced.

We used rooted Android phones in our experiments. Although rooting the
phones may introduce changes in the observed traﬃc, we assumed the changes
to be minimal.

9 Conclusion

The revealed slides of the BADASS program have shown that unencrypted
mobile app traﬃc is exploited for mass surveillance. Identiﬁers sent in the clear
by the mobile applications allow targeting mobile users, linking of their traﬃc
and building a database of their online activities.

XVI

In this study, we evaluated the surveillance threat posed by a passive network
adversary who exploits mobile app traﬃc for surveillance purposes. We presented
a novel framework that automates the analysis of mobile app network traﬃc. Our
framework and methodology is designed to be ﬂexible and can be used in other
mobile privacy studies with slight modiﬁcations.

Our results show that using TCP timestamps and unique identiﬁers sent
in the unencrypted HTTP traﬃc, a global adversary can cluster 57% of users’
unencrypted mobile app sessions. We demonstrated that a passive adversary can
automatically build a rule set that extracts unique identiﬁers in the observed
traﬃc, which serves as a “selector” list for targeting users.

Our results suggest that popular apps leak signiﬁcantly more identiﬁers than
the less popular apps. Furthermore, while interacting with the app increases the
number of leaked identiﬁers, solely starting an app amounts to the same attack
eﬀectiveness.

We evaluated two countermeasures designed to block mobile ads and found
that they provide a limited protection against linking of the user traﬃc. Encrypt-
ing mobile app traﬃc can eﬀectively protect against passive network adversaries.
Moreover, a countermeasure similar to HTTPS Everywhere browser extension
can be developed to replace insecure HTTP connections of mobile apps with
secure HTTPS connections on the ﬂy.

Acknowledgment

Thanks to Yves Tavernier for sharing his valuable insights about middleboxes,
and anonymous reviewers for their helpful and constructive feedback. This work
was supported by the Flemish Government FWO G.0360.11N Location Privacy,
FWO G.068611N Data mining and by the European Commission through H2020-
DS-2014-653497 PANORAMIX and H2020-ICT-2014-644371 WITDOM.

References

1. APK Downloader [Latest] Download Directly — Chrome Extension v3 (Evozi Of-

ﬁcial). http://apps.evozi.com/apk-downloader/

2. Cross

Reference:

/external/kernel-headers/original/asm-arm/param.h.

http://androidxref.com/4.1.2/xref/external/kernel-headers/original/
asm-arm/param.h#18

3. dpkt 1.8.6.2 : Python Package Index. https://pypi.python.org/pypi/dpkt
4. dtmilano/AndroidViewClient.

https://github.com/dtmilano/

AndroidViewClient/

5. dumpcap - The Wireshark Network Analyzer 1.12.2. https://www.wireshark.

org/docs/man-pages/dumpcap.html

6. GCHQ taps ﬁbre-optic cables for secret access to world’s communications
7. Nmap Network Scanning - Remote OS Detection - Usage and Examples. http:

//nmap.org/book/osdetect-usage.html

8. NSA Prism program taps in to user data of Apple, Google and others. http:

//www.theguardian.com/world/2013/jun/06/us-tech-giants-nsa-data

9. Smartphones: So many apps, so much time. http://www.nielsen.com/us/en/

insights/news/2014/smartphones-so-many-apps--so-much-time.html

10. SystemClock — Android Developers.

http://developer.android.com/

reference/android/os/SystemClock.html

XVII

11. Identifying App

http://
android-developers.blogspot.be/2011/03/identifying-app-installations.
html (2011)

Installations — Android Developers Blog.

12. ‘Tor Stinks’ presentation. http://www.theguardian.com/world/interactive/

2013/oct/04/tor-stinks-nsa-presentation-document (2013)

13. About Adblock Plus for Android. https://adblockplus.org/android-about

(2015)

14. Disconnect Malvertising

for Android.
disconnect-malvertising/sideload (2015)

https://disconnect.me/mobile/

15. Manpage of TCPDUMP. http://www.tcpdump.org/tcpdump_man.html (2015)
16. Mobile apps doubleheader: BADASS Angry Birds. http://www.spiegel.de/

media/media-35670.pdf (2015)

17. Selenium - Web Browser Automation. http://docs.seleniumhq.org/ (2015)
18. UI/Application Exerciser Monkey — Android Developers. http://developer.

android.com/tools/help/monkey.html (2015)

19. Acar, G., Eubank, C., Englehardt, S.: The Web Never Forgets: Persistent Tracking
Mechanisms in the Wild. Proceedings of the 2014 ACM SIGSAC Conference on
Computer and Communications Security (2014)

20. Balakrishnan, M.: Where’s That Phone?: Geolocating IP Addresses on 3G Net-
works. Proceedings of the 9th ACM SIGCOMM Conference on Internet Measure-
ment Conference pp. 294–300 (2009)

21. Bellovin, S.M.: A Technique for Counting NATted Hosts. Proceedings of the second

ACM SIGCOMM Workshop on Internet measurment - IMW ’02 p. 267 (2002)

22. Black, P.E.: Ratcliﬀ/Obershelp pattern recognition. http://xlinux.nist.gov/

dads/HTML/ratcliffObershelp.html (December 2004)

23. Bursztein, E.: Time has something to tell us about network address translation.

In: Proc. of NordSec (2007)

24. Dai, S., Tongaonkar, A., Wang, X., Nucci, A., Song, D.: NetworkProﬁler: Towards
automatic ﬁngerprinting of Android apps. 2013 Proceedings IEEE INFOCOM pp.
809–817 (Apr 2013)

25. Enck, W., Cox, L.P., Gilbert, P., Mcdaniel, P.: TaintDroid: An Information-Flow
Tracking System for Realtime Privacy Monitoring on Smartphones. OSDI’10 Pro-
ceedings of the 9th USENIX conference on Operating systems design and imple-
mentation (2010)

26. Englehardt, S., Reisman, D., Eubank, C., Zimmerman, P., Mayer, J., Narayanan,
A., Felten, E.W.: Cookies That Give You Away: The Surveillance Implications
of Web Tracking. In: Proceedings of the 24th International Conference on World
Wide Web. pp. 289–299 (2015)

27. Felt, A.P., Chin, E., Hanna, S., Song, D., Wagner, D.: Android Permissions Demys-
tiﬁed. Proceedings of the 18th ACM Conference on Computer and Communications
Security p. 627 (2011)

28. Grace, M., Zhou, W., Jiang, X., Sadeghi, A.: Unsafe Exposure Analysis of Mobile
In-App Advertisements. Proceedings of the ﬁfth ACM conference on Security and
Privacy in Wireless and Mobile Networks 067(Section 2) (2012)

29. Hornyack, P., Han, S., Jung, J., Schechter, S., Wetherall, D.: These aren’t the
droids you’re looking for: Retroﬁtting Android to protect data from imperious

XVIII

applications. In: Proceedings of the 18th ACM conference on Computer and com-
munications security. pp. 639–652. ACM (2011)

30. Jacobson, V., Braden, R., Borman, D., Satyanarayanan, M., Kistler, J., Mummert,

L., Ebling, M.: RFC 1323: TCP extensions for high performance (1992)

31. Kohno, T., Broido, A., Claﬀy, K.C.: Remote physical device ﬁngerprinting. De-

pendable and Secure Computing, IEEE Transactions on 2(2), 93–108 (2005)

32. Marlinspike, M.: New tricks for defeating SSL in practice. BlackHat DC, February

(2009)

33. Murdoch, S.J.: Hot or not: Revealing hidden services by their clock skew. In: Pro-
ceedings of the 13th ACM conference on Computer and Communications Security.
pp. 27–36. ACM (2006)

34. Soltani, A., Peterson, A., Gellman, B.: NSA uses Google cookies to pinpoint tar-
gets for hacking. https://www.washingtonpost.com/news/the-switch/wp/2013/
12/10/nsa-uses-google-cookies-to-pinpoint-targets-for-hacking/ (2013)
35. Stevens, R., Gibler, C., Crussell, J.: Investigating User Privacy in Android Ad

Libraries. IEEE Mobile Security Technologies (MoST) (2012)

36. Suarez-Tangil, G., Conti, M., Tapiador, J.E., Peris-Lopez, P.: Detecting targeted
smartphone malware with behavior-triggering stochastic models. In: Computer
Security-ESORICS 2014, pp. 183–201. Springer (2014)

37. Tekeoglu, A., Altiparmak, N., Tosun, A.S¸.: Approximating the number of active
nodes behind a NAT device. In: Computer Communications and Networks (IC-
CCN), 2011 Proceedings of 20th International Conference on. pp. 1–7. IEEE (2011)
38. Tongaonkar, A., Dai, S., Nucci, A., Song, D.: Understanding mobile app usage
patterns using in-app advertisements. In: Passive and Active Measurement. pp.
63–72. Springer (2013)

39. Vanrykel, E.: Passive Network Attacks on Mobile Applications. Master’s thesis,

Katholieke Universiteit Leuven (2015)

40. Vanrykel, E., Acar, G., Herrmann, M., Diaz, C.: Exploiting Unencrypted Mobile
Application Traﬃc for Surveillance (Technical Report). https://securewww.esat.
kuleuven.be/cosic/publications/article-2602.pdf (2016)

41. Weinstein,

D.:

Leaking

Android

unprivileged
leaking-android-hardware-serial-number.html (2013)

apps.

hardware

to
http://insitusec.blogspot.be/2013/01/

number

serial

42. Wicherski, G., Weingarten, F., Meyer, U.: IP agnostic real-time traﬃc ﬁltering and
host identiﬁcation using TCP timestamps. In: Local Computer Networks (LCN),
2013 IEEE 38th Conference on. pp. 647–654. IEEE (2013)

43. Xia, N., Song, H.H., Liao, Y., Iliofotou, M.: Mosaic: Quantifying Privacy Leakage
in Mobile Networks. SIGCOMM ’13 Proceedings of the ACM SIGCOMM 2013
conference on SIGCOMM (ii), 279–290 (2013)

44. Zander, S., Murdoch, S.J.: An Improved Clock-skew Measurement Technique for
Revealing Hidden Services. In: USENIX Security Symposium. pp. 211–226 (2008)

