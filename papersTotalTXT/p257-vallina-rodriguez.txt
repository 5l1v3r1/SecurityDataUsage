RILAnalyzer: a Comprehensive 3G Monitor On Your Phone

Narseo

∗
Vallina-Rodriguez

ICSI

narseo@icsi.berkeley.edu

Andrius Aucinas
Computer Laboratory
University of Cambridge

Mario Almeida
Telefonica Research

4knahs@gmail.com

andrius.aucinas@cl.cam.ac.uk

Yan Grunenberger
Telefonica Research

yan@tid.es

Konstantina
Papagiannaki
dina@tid.es

Telefonica Research

Jon Crowcroft

Computer Laboratory
University of Cambridge

jon.crowcroft@cl.cam.ac.uk

ABSTRACT
The popularity of smartphones, cloud computing, and the
app store model have led to cellular networks being used
in a completely diﬀerent way than what they were designed
for. As a consequence, mobile applications impose new chal-
lenges in the design and eﬃcient conﬁguration of constrained
networks to maximize application’s performance. Such dif-
ﬁculties are largely caused by the lack of cross-layer under-
standing of interactions between diﬀerent entities - applica-
tions, devices, the network and its management plane. In
this paper, we describe RILAnalyzer, an open-source tool
that provides mechanisms to perform network analysis from
within a mobile device. RILAnalyzer is capable of record-
ing low-level radio information and accurate cellular net-
work control-plane data, as well as user-plane data. We
demonstrate how such data can be used to identify previ-
ously overlooked issues. Through a small user study across
four cellular network providers in two European countries
we infer how diﬀerent network conﬁgurations are in reality
and explore how such conﬁgurations interact with applica-
tion logic, causing network and energy overheads.

Categories and Subject Descriptors
C.2.3 [Computer-communication networks]: Network
OperationsNetwork Monitoring

General Terms
Design, Measurement, Performance

Keywords
Energy, Mobile, Radio, Cellular, Networks, RNC
∗
at the University of Cambridge.

This work was done while the author was a PhD student

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
IMC’13, October 23–25, 2013, Barcelona, Spain.
Copyright 2013 ACM 978-1-4503-1953-9/13/10 ...$15.00.
http://dx.doi.org/10.1145/2504730.2504764.

1.

INTRODUCTION

The success of mobile apps has exposed new issues for
end-users (battery life, erratic connectivity), and network
providers (coverage and dynamic load management) that
were not initially expected on its design. As opposed to
wired and WiFi networks, cellular networks have clearly sep-
arated control-plane for signaling traﬃc and user-plane for
user traﬃc respectively. Unfortunately, as previous research
has revealed [1,2], the control plane directly impacts on user
plane performance and vice-versa.

The way applications use the network aﬀect its control-
plane by increasing signaling traﬃc. The eﬀects also depend
on the network conﬁguration. On one hand, the goal is to
minimize the network load and improve spectrum eﬃciency.
On the other hand, inappropriate network conﬁgurations
can decrease the battery life of the handset and increase
its communication latency. The two factors are not orthog-
onal and it is necessary to take into account both the way
applications use the network (i.e. user plane) as well as the
way network conﬁguration aﬀects applications (i.e. control
plane) to alleviate network and energy ineﬃciencies.

In order to understand application-network dynamics and
their inter-dependencies, it is important to follow a cross-
layer approach that spans from applications and user events,
to the behavior of the control-plane. A major challenge
for such analysis is accessing the diﬀerent layers: neither
control-plane information is generally exposed by the radio
driver to the mobile OS (only from within the operator),
nor user and application events other than network packets
are sent to the mobile operator. As a consequence, most
of the previous research has been performed either thanks
to privileged access to internal and proprietary data from
mobile carriers [3–5], expensive test-beds [2] and diagnostic
tools [6], or by emulating low-level control-plane events on
the terminal [7]. In this paper, we present RILAnalyzer, a
software and handset-oriented approach that enables gather-
ing of accurate control-plane and user-plane data, including
any layer on the protocol stack, “in the wild” with real users
traﬃc load, and network conﬁgurations.

Firstly, we review the classical vantage points in cellu-
lar network research, including low-level diagnostic tools.
We discuss their capability and openness in capturing the
ground truth in terms of control plane events, user plane,
as well as their scope in terms of scale and layers. Previous
research is classiﬁed based on the type of data and vantage
point they use in their analysis. Secondly, we present an

257258Vantage point
1. Cellular network components
2. GGSN and IP Core
3. Mobile OS
4. Engineering tools

Control plane User plane

Ground truth

Inferred
Inferred

Ground truth

(cid:2)
(cid:2)

Scale
Large
Large

Medium

Small

Process ID OS/User events

Access

Reverse DNS

(cid:2)

(cid:2)

Operator/Vendor
Operator/Vendor

Open

Licensed/Open

Table 1: Comparison of the diﬀerent vantage points used for characterizing cellular networks and mobile application perfor-
mance along six diﬀerent axis.

(cid:19)(cid:48)(cid:41)(cid:42)(cid:27)(cid:35)(cid:19)(cid:27)(cid:40)(cid:46)(cid:27)(cid:40)(cid:1)

(cid:19)(cid:25)(cid:40)(cid:27)(cid:27)(cid:36)(cid:1)(cid:41)(cid:42)(cid:23)(cid:42)(cid:27)(cid:1)

(cid:18)(cid:10)(cid:13)(cid:2)(cid:36)(cid:23)(cid:34)(cid:48)(cid:49)(cid:27)(cid:40)(cid:2)(cid:25)(cid:43)(cid:46)(cid:32)(cid:42)(cid:48)(cid:1)

(cid:20)(cid:6)(cid:13)(cid:6)(cid:17)(cid:9)(cid:16)(cid:15)(cid:22)(cid:1)(cid:7)(cid:18)(cid:2)(cid:14)(cid:6)(cid:21)(cid:16)(cid:18)(cid:12)(cid:1)

(cid:23) (cid:43) (cid:37) (cid:36) (cid:1)

(cid:13) (cid:37) (cid:25)

(cid:8) (cid:41) (cid:35) (cid:4) (cid:27) (cid:34)(cid:34)

(cid:16)(cid:27)(cid:35)(cid:4)(cid:37)(cid:35)(cid:35)(cid:23)(cid:36)(cid:26)(cid:1)(cid:54)(cid:18)(cid:27)(cid:39)(cid:45)(cid:27)(cid:41)(cid:42)(cid:55)(cid:1)

(cid:20)(cid:27)(cid:34)(cid:27)(cid:38)(cid:31)(cid:37)(cid:36)(cid:48)(cid:1)
(cid:14)(cid:23)(cid:36)(cid:23)(cid:30)(cid:27)(cid:40)(cid:1)

(cid:18)(cid:10)(cid:13)(cid:1)

(cid:54)(cid:18)(cid:10)(cid:13)(cid:11)(cid:51)(cid:18)(cid:10)(cid:13)(cid:5)(cid:55)(cid:1)

(cid:4)(cid:37)(cid:36)(cid:42)(cid:40)(cid:37)(cid:34)(cid:53)(cid:17)(cid:34)(cid:23)(cid:36)(cid:27)(cid:1)(cid:26)(cid:23)(cid:42)(cid:23)(cid:1)(cid:1)

(cid:54)(cid:10)(cid:17)(cid:4)(cid:1)(cid:3)(cid:32)(cid:36)(cid:26)(cid:27)(cid:40)(cid:55)(cid:1)

(cid:3)(cid:9)(cid:8)(cid:13)(cid:11)(cid:9)(cid:7)(cid:15)(cid:10)(cid:7)(cid:2)(cid:8)(cid:4)(cid:1)(cid:7)(cid:9)(cid:5)(cid:5)(cid:6)(cid:8)(cid:5)(cid:1)
(cid:14)(cid:12)(cid:4)(cid:11)(cid:15)(cid:10)(cid:7)(cid:2)(cid:8)(cid:4)(cid:1)(cid:7)(cid:9)(cid:5)(cid:5)(cid:6)(cid:8)(cid:5)(cid:1)

(cid:3)(cid:16)(cid:16)(cid:20)(cid:1)

(cid:15)(cid:27)(cid:42)(cid:47)(cid:37)(cid:40)(cid:33)(cid:13)(cid:37)(cid:30)(cid:19)(cid:27)(cid:40)(cid:46)(cid:32)(cid:25)(cid:27)(cid:1)

(cid:17)(cid:23)(cid:25)(cid:33)(cid:27)(cid:42)(cid:52)(cid:17)(cid:10)(cid:5)(cid:1)

(cid:36)(cid:29)(cid:37)(cid:30)(cid:1)
(cid:54)(cid:17)(cid:23)(cid:40)(cid:41)(cid:27)(cid:40)(cid:55)(cid:1) (cid:17)(cid:23)(cid:25)(cid:33)(cid:27)(cid:42)(cid:1)

(cid:32)(cid:38)(cid:42)(cid:23)(cid:24)(cid:34)(cid:27)(cid:41)(cid:1)

(cid:17)(cid:23)(cid:25)(cid:33)(cid:23)(cid:30)(cid:27)(cid:1)(cid:36)(cid:23)(cid:35)(cid:27)(cid:1)(cid:28)(cid:37)(cid:40)(cid:1)(cid:17)(cid:10)(cid:5)(cid:1)

(cid:17)(cid:23)(cid:25)(cid:33)(cid:23)(cid:30)(cid:27)(cid:14)(cid:23)(cid:36)(cid:23)(cid:30)(cid:27)(cid:40)(cid:1)

Figure 2: Data ﬂow between the diﬀerent components

Plane
Control

Data

Data
Cellular technology (GPRS/UMTS/HSPA), RNC
state, number of HSPA channels, SNR indicators
(e.g. RSCP and EC/IO), Cell ID
Screen state, transport/network layer header, IP
header, process ID owning socket

Table 2: Data collected by RILAnalyzer.

data on an external terminal for processing. This makes it
diﬃcult to correlate between control-plane information and
on-device logs, as well as perform “in situ” experiments.

Overall, some vantage points can oﬀer privileged access
to the network’s ground truth at the expense of gathering
limited data across the layers or geographical areas, diﬀer-
ent operators, number of events captured etc. By leverag-
ing terminal capabilities, one could achieve open and decent
accuracy across multiple levels (UI events, application, OS
events), but even in that case, OS and network design, and
current monitoring tools make performing experiments out
of the research lab unrealistic. This leaves out an interesting
possibility: how can nearly complete, integrated ground truth
knowledge be obtained at the terminal level in the wild?

4.

INTRODUCING RILANALYZER

To overcome the limitations described above, we imple-
mented RilAnalyzer for rooted Android devices with In-
tel/Inﬁneon XGold chipsets. The tool is publicly available
at [18]. Some of the most popular Android devices (e.g.
Samsung Galaxy SII/SIII) use this chipset. Figure 2 and
Table 2 describe its software architecture and the informa-
tion it collects. As opposed to other analysis based on data
collected from the OS [15, 19], our implementation allows
for gathering and correlation of user, application, and OS
events with control and user-plane data in a single memory
space from within the mobile handset.
Control-plane logging: Most mobile platforms are shipped
with a dedicated modem chip which runs a real-time ﬁrmware
in isolation. The main OS of the phone (e.g. Android)

communicates with the baseband using the Radio Interface
Layer (RIL). A typical Android’s RIL spans across three dif-
ferent software sub-components: high-level RILJ (Java mod-
ule that exposes RIL interface at the Android framework
level), the low-level vendor RIL library (that implements
vendor-speciﬁc messages communication with the modem
serial interface), and a RIL Daemon (that runs in memory
and translates packets and commands between RILJ and
vendor RIL). Although developers can access events such
as ongoing calls and the type of cellular network with the
public APIs exposed by RILJ, the OS is not capable of ac-
cessing directly any control-plane information such as RNC
states [1]. This information by default stays in the ﬁrmware.
The communication between RILJ and vendor RIL hap-
pens through special commands (similar to AT commands
for PSTN modems) handled by the RILD. Some modems,
including those in highly popular Android devices (e.g. Sam-
sung Galaxy SII/SIII) also facilitate a way of sending spe-
cial, and chipset-dependent commands to the vendor RIL
for ﬁeld-test and debugging measurements reserved to radio
engineers. In the case of Samsung’s XGold-based handsets,
this information is displayed on a foreground application
that is launched by entering *#*#197328640#*#* on the di-
aler. Among many other low-level information, it provides
access to RF status (e.g. RNC state, HSPA channels), signal-
ing traﬃc, and control-plane information such as the band
of radio access technology (RAT) by converting GUI events
into special commands used to poll the radio modem for
speciﬁc control-plane data.

Although multiple control-plane events can be obtained
with such codes, they are not publicly documented. As a re-
sult, we had to identify the necessary requests triggering the
information we were interested on by adding hooks on RILJ.
In particular, we are interested in logging RNC states, which
are obtained through the code *#*#0011#*#*. Furthermore,
any application that interacts with RIL has to use speciﬁc
radio system permissions, and use non-public RILJ’s meth-
ods to send OemCommands to RIL Daemon on a request/reply
basis. To overcome these limitations, we implemented a sys-
tem tool that runs in the background and polls the modem
at the maximum frequency the device responds at, approx-
imately every second (1291 ± 119 ms).
User-plane logging: To log user-plane information we
chose to extend and improve NetworkLog [20], an open source
tool that uses iptables with Nflog target to log packets in
user space. A daemon called Nflog reads and parses netlink
sockets to extract full network and transport layer headers
(Figure 2). Once parsed, the information is sent to Net-
workLogService (Java background service) to identify the
process name for a given PID using the PackageManager
public API. This solution provides a more accurate traﬃc
to app mapping than other approaches that are based on
information available on the /proc ﬁlesystem [7], especially
for short-lived TCP connections and UDP traﬃc.

2594.1 Validation

To verify accuracy of the tool we cross-checked the packets
reported by RILAnalyzer against the ones captured by tcp-
dump. We ran 10 series of 100 ICMP packets, at 1 second and
10 ms intervals, DNS lookups to google.com, and HTTP
requests (BBC’s front-page), as well as a full over-night exe-
cution with real user-traﬃc. Exactly the same packets were
logged by both RILAnalyzer and tcpdump.

Accurate packet timing is a hard problem to solve at
the user space: Nflog only reports timestamps for outgo-
ing packets as recorded by the Linux kernel. Consequently,
they need to be added at the time of processing packets
in user-space, which may be signiﬁcantly later than the ac-
tual packet arrival time. This granularity is suﬃcient for
analysing app traﬃc and control-plane interactions as base-
band polling interval is currently limited to 1 second. To
record more accurate timing information both modem ﬁrmware
and Linux kernel require improvements.

Because of the diﬃculty of obtaining control plane infor-
mation, we had to verify that RILAnalyzer correctly logs
such events in two steps. First, we veriﬁed that the vendor-
speciﬁc tool xgoldmon [17] logs control-plane information
correctly by comparing its traces against control-plane traces
obtained from a cellular network testbed. Given xgoldmon’s
verbosity when compared against RILAnalyzer (e.g. it logs
RRC messages which indicate RNC state changes while RIL-
Analyzer logs only RNC states), we only had to verify that
the polling frequency is compatible with the frequency of
occurrence of state changes for basic network operations in
several locations under controlled conditions, and that the
state reported by the tool is correct.

We used the following technique as both tools cannot run
simultaneously on the same handset (due to exclusive use of
the same modem interface). We observed that despite the
diﬀerent types of loads (ICMP pings and TCP packets of dif-
ferent size) and diﬀerent events (3G activation/deactivation)
the resulting RNC state events extracted from xgoldmon
traces were all separated at least by 3-4 seconds, hence the
polling frequency of 1 second is not a limiting factor.
4.2 Performance and limitations

Current RILAnalyzer version is limited to Intel Inﬁneon
XGold chipsets. Some of the most popular Android de-
vices use the chipsets: Samsung Galaxy SII, SIII, Note 2
and Nexus. We tested our system with the SII and SIII
versions. Although the same commands work for LTE net-
works, we could not test them given limited deployment in
Europe. Focusing on single chipsets may induce particular
behavior and interaction problems on its own due to Ven-
dor RIL implementation diﬀerences, however we perform our
case-study (Section 5) on devices shipped with the same ra-
dio baseband, hence we still discover network and applica-
tion diﬀerences accurately. As licensed monitoring tools for
Qualcomm chipsets are available, we expect ﬁnding similar
features in other product vendors. Providing support for
other chipsets is limited by the eﬀort it takes to reverse-
engineer the hidden commands. A more eﬃcient solution
would be for vendors to expose the information to the OS.
We observed CPU and memory consumption of RILAn-
alyzer both idle and under stress conditions on a Samsung
Galaxy S2 (Dual-core 1.2 GHz Cortex-A9). The idle ex-
periment was conducted over three hours with Google Ser-
vices, Skype and Facebook apps active in the background

but without any user interaction. Stress conditions were
simulated using Speedtest application [21]. During the idle
experiment, RILAnalyzer consumed an average of 0.16% of
CPU and 22 MB of physical memory. In this period, appli-
cations generated periodic traﬃc that produced variations
on the CPU consumption that remained below 10%. In the
stress test, at the maximum observed download throughput
(+5 Mbps) the maximum observed CPU consumption was
47% using close to 42 MB of physical memory. The high
memory load is due to the number of diﬀerent components
logging all aspects of the running systems as well as polling
the radio periodically for its state.

The increase is due to the way network packets are logged
by our iptables-based approach: each packet is duplicated
and forwarded to Nflog, annotated with the additional in-
formation as described above and recorded. Because of plat-
form limitations, the current version of the tool is forced to
rely on polling mechanisms to achieve association between
applications, network traﬃc, and cellular state. This adds
computational and energy overheads on embedded systems
like Android, which have aggressive sleeping policies [22].
Although such overheads are not desirable, they would only
be decreased if vendors open their APIs to eﬃciently gather
control plane data within the system.

The current version relies on suﬃcient internal storage to
log data for mid-term studies. The volume of logs generated
is 62±2 bytes per RNC promotion, and 130±10 bytes per
logged packet (including process name). In its current iter-
ation, RILAnalyzer is meant to be used for limited duration
studies as a measurement tool in a real environment, rather
than a data collection app adopted by a large userbase. Nev-
ertheless, we plan to extend the control-plane traces using
other hidden codes, and build an online facility for collect-
ing and processing anonymized data for users, researchers
and developers interested in identifying network and apps
ineﬃciencies.
5. CASE STUDIES

In order to demonstrate RILAnalyzer’s capabilities, we
instrumented eight Samsung Galaxy SII handsets owned by
experienced Android users subscribed to diﬀerent mobile op-
erators. They were asked to run the tool for one complete
week, with their normal set of apps. The logged data ac-
counts for more than 1200 hours of mobile activity. During
this period of time, 70 applications sent or received more
than 2.6M packets, causing +138K RNC transitions (29K
promotions to connected states such as FACH (shared) - and
DCH (dedicated)). Using the data collected with RILAna-
lyzer, we characterize the diversity of RNC state machines
across the diﬀerent networks and their eﬀects on resource
consumption (Section 5.1). Finally, we evaluate the network
costs associated to TCP operations to reach the back-end in-
frastructure in four popular applications (Section 5.2).
5.1 RNC state machine dynamics

In the past, RNC state machine has been modeled using
probes and external power meters [1,9]. Although this iden-
tiﬁed one of the main energy sinks of mobile systems, they
are static and inaccurate as they are obtained “in situ”. In
contrast, we have usedRILAnalyzer to record actual device
RNC states and demonstrate that RNC state machines are
much more diverse, necessitating more complex solutions
for improving device performance and energy consumption.

260261AccuWeather

1 90.9 10.3 12 0.5

0.2

Twitter

Skype

1.5

0.1

Whatsapp

69.2

30 16.4 3.5
3.5

82.5 18.9

n
o
i
t
a
c

i
l

p
p
A

92.7

20.4

0.7

65.6

0.6

0.4

App
Facebook
Google GCM
Skype
WhatsApp
All apps

Hearbeats & FIN (%)

Server-side (%)

3.2
6.1
15.9
47.1
41.0

12.6
69.6
40.2
3.0
58.9

Table 3: Per-App promotions triggered by TCP operations
and initiated by a server

ing RILAnalyzer that TCP heartbeats and FINs (messages
that are driven by these restrictions) alone account for a
signiﬁcant proportion of RNC promotions (Table 3). In the
case of WhatsApp, a large fraction of RNC promotions as-
sociated with these operations are due to TCP hearbeats
maintaining connections, while the others often also include
application-level information.

For network-intensive applications such as Skype and push
notiﬁcation mechanisms, a large portion of total promotions
are triggered by packets sent from the server-side, indicating
where connection maintenance logic is located. On the other
hand, applications such as Facebook rely on Google’s push
notiﬁcations, thus reducing the need to maintain their own
TCP connections. These observations suggest that to reduce
the energy and network overheads of mobile traﬃc, it is
essential to control downlink traﬃc (e.g. using middleboxes
or enhancement proxies) in addition to the classic approach
of controlling uplink on the mobile handset [1, 3, 4, 9, 28].
6. CONCLUSION

In this work we presented a tool which facilitates researchers

to analyze cellular network issues in a new light without re-
quiring access to the internal components of the cellular net-
work. We prototyped the tool, RILAnalyzer, on the Android
platform for popular smartphone devices. RILAnalyzer is
meant to be used outside of laboratory environment and
therefore allows open accurate mobile device measurement
studies across many users, applications, networks and geo-
graphical regions. We evaluated performance of the tool and
discussed its limitations - some of them inherent to running
within a mobile device and not relying on external resources.
We have demonstrated the ability of RILAnalyzer to accu-
rately perform cross-layer analysis on mobile systems. First,
we demonstrated important RNC state machines diﬀerences
across 4 mobile operators in two European countries. Sec-
ond, to demonstrate the strengths of RILAnalyzer, we ex-
posed ineﬃcient connection maintenance logic for a few pop-
ular applications, caused by the large number of backend
systems they rely on and sub-optimal use of TCP. We are
releasing the tool publicly [18] for the mobile research com-
munity to use, extend and improve.
Acknowledgments
This material is based upon work supported by the EPRSC
INTERNET Project, the Department Homeland Security
under Contract N66001-12-C-0128, by the NSF under grant
1213157, and by the European Commission under grant
agreement FP7-318627 (mPlane). The authors would also
like to thank the volunteers, the anonymous reviewers and
our shepherd Aditya Akella (University of Wisconsin-Madison)
for constructive feedback on preparation of the ﬁnal version
of this paper.

Facebook

9.7

0.5

99.4

Google GCM

Gmail

100

100

l

e
g
o
o
G

k
o
o
b
e
c
a
F

t
f

o
s
o
r
c
M

i

i

a
m
a
k
A

t

e
u
t
s
A

e
v
o
c
t
h
g
i
r

B

t

s
k
r
o
w
e
N
D
C

C
D

I
 
t
f

o
s
o
r
c
M

i

l
i

t

a
m
o
H
S
M

 

e
p
y
k
S

r
e
y
a

l
t
f

o
S

t

l

e
n
a
P
e
h
T

r
e

t
t
i

w
T

t
s
a
C
e
g
d
E

r
e
h
O

t

Hosting/Cloud/CDN service

Figure 6: Percentage of observed RNC promotions per ap-
plication to diﬀerent backends

teraction patterns, but taking into account RNC behavior
of each device as recorded by RILAnalyzer. We count pro-
motions to both FACH and DCH states. As we can see,
applications have diﬀerent frequencies in terms of RNC pro-
motion frequency and the steps on the lines (especially clear
in the cases of WhatsApp and Facebook) represent periodic
messages, such as TCP or HTTP/1.1 keepalives.

Apps have to rely heavily on backend infrastructure, such
as CDNs, advertising networks [3], push mechanisms [24],
and authentication APIs (e.g. OAuth), often managed by
diﬀerent organizations. An often overlooked fact is that a lot
of overheads are exactly due to distributed backends’ lack of
coordination even in a single app, as indicated by Figure 6.
Every long lived TCP connection is kept alive individually.
Using reverse DNS to map network traﬃc to applications
would incorrectly attribute it to the apps developed by the
same company that owns the backend infrastructure.

Something that is only accurately feasible from within a
device (e.g. using RILAnalyzer) is demonstrated in Figure 6:
the proportion of RNC promotions in which there is traﬃc
to a particular backend (a few more apps are included for
comparison). Each network packet is assigned promotion ID
during which it is transmitted and the percentage is obtained
by combining organization name obtained from reverse DNS
with the promotion ID. Naturally, there are promotions dur-
ing which traﬃc goes to multiple backends. This happens
when the sum of percentages for an app is more than 100%.
Skype here demonstrates a pathological case due to its
P2P nature: RNC promotions are triggered every 30 sec-
onds on average to maintain connections with other con-
nected users.
In addition, it relies on distributed services
to monitor QoS, billing, and to guarantee reachability and
resilience (managed by Microsoft or Skype). As much as
74% of connections are directly to other peers although sur-
prisingly they only account for 57% of packets. Google’s
GCM, on the other hand, aggregates notiﬁcations for mul-
tiple applications (Google’s own and ones that use it for
push notiﬁcations) reducing the amortized cost for each ap-
plication - only one open TCP connection is needed to a
single entity serving multiple applications. We can not iso-
late per-application information from Google GCM protocol
and have to analyze the entity as a whole.

Another problem with distributed backends is due to the
fact that cellular networks are controlled by middleboxes for
security and performance [25]. Such middleboxes impose re-
strictions on the way applications maintain their connections
at the transport [26] and application layer [27]. We found us-

2627. REFERENCES
[1] F. Qian, Z. Wang, A. Gerber, Z. M. Mao, S. Sen, and

O. Spatscheck. Characterizing radio resource
allocation for 3G networks. In Proceedings of ACM
IMC, 2010.

[2] Nokia Siemens Networks Smart Labs. Understanding

smartphone behavior in the network.
http://www.nokiasiemensnetworks.com/sites/
default/files/document/Smart_Lab_WhitePaper_
27012011_low-res.pdf, 2011.

[3] N. Vallina-Rodriguez, J. Shah, A. Finamore,

Y. Grunenberger, K. Papagiannaki, H. Haddadi, and
J. Crowcroft. Breaking for commercials: characterizing
mobile advertising. In Proceedings of ACM IMC, 2012.

[4] J. Huang, F. Qian, Z. M. Mao, S. Sen, and

O. Spatscheck. Screen-oﬀ traﬃc characterization and
optimization in 3G/4G networks. In Proceedings of
ACM IMC, 2012.

[13] M. Z. Shaﬁq, L. Ji, A. X. Liu, J. Pang, and J. Wang.

A ﬁrst look at cellular machine-to-machine traﬃc:
large scale measurement and characterization. In
Proceedings of ACM SIGMETRICS, 2012.

[14] H. Falaki, R. Mahajan, S. Kandula,

D. Lymberopoulos, R. Govindan, and D. Estrin.
Diversity in smartphone usage. In Proceedings of ACM
MobiSys, 2010.

[15] L. Zhang, B. Tiwana, Z. Qian, Z. Wang, R. P. Dick,

Z. M. Mao, and L. Yang. Accurate online power
estimation and automatic battery behavior based
power model generation for smartphones. In
Proceedings of IEEE/ACM CODESS, 2010.

[16] P. Abhinav, Y. C. Hu, and M. Zhang. Where is the

energy spent inside my app?: ﬁne grained energy
accounting on smartphones with Eprof. In Proceedings
of ACM EuroSys, 2012.

[17] Github. XGoldMon project.

[5] F. Qian, Z. Wang, Y. Gao, J. Huang, A. Gerber, Z. M.

https://github.com/2b-as/xgoldmon.

Mao, S. Sen, and O. Spatscheck. Periodic transfers in
mobile applications: network-wide origin, impact, and
optimization. In Proceedings of WWW Conference,
2012.

[6] Qualcomm Extensible Diagnostic Monitor.

http://www.qualcomm.com/media/documents/qxdm-
professional-qualcomm-extensible-diagnostic-
monitor.

[7] F. Qian, Z. Wang, A. Gerber, Z. M. Mao, S. Sen, and

O. Spatscheck. Proﬁling resource usage for mobile
applications: a cross-layer approach. In Proceedings of
ACM MobiSys, 2011.

[8] J. Huang, F. Qian, A. Gerber, Z. M. Mao, S. Sen, and

O. Spatscheck. A close examination of performance
and power characteristics of 4G LTE networks. In
Proceedings of ACM MobiSys, 2012.

[9] N. Balasubramanian, A. Balasubramanian, and

A. Venkataramani. Energy consumption in mobile
phones: a measurement study and implications for
network applications. In Proceedings of ACM IMC,
2009.

[10] N. Vallina-Rodriguez and J. Crowcroft. Energy

management techniques in modern mobile handsets.
Communications Surveys Tutorials, IEEE, 2013.

[11] Z. Shaﬁq, L. Ji, A. Liu, J. Pang, S. Venkataraman,

and J. Wang. A ﬁrst look at cellular network
performance during crowded events. In Proceedings of
ACM SIGMETRICS, 2013.

[12] J. Erman, A. Gerber, K. K. Ramadrishnan, S. Sen,

and O. Spatscheck. Over the top video: the gorilla in
cellular networks. In Proceedings of ACM IMC, 2011.

[18] RILAnalyzer. http://rilanalyzer.smart-e.org/.
[19] X. Wei, L. Gomez, I. Neamtiu, and M. Faloutsos.

ProﬁleDroid: multi-layer proﬁling of android
applications. In Proceedings of ACM Mobicom, 2012.

[20] Github. Network Log.

https://github.com/pragma-/networklog.

[21] Speedtest android application.

https://play.google.com/store/apps/details?id=
org.zwanoo.android.speedtest&hl=en.

[22] A. Jindal, A. Pathak, Y. C. Hu, and S. Midkiﬀ.

Hypnos: understanding and treating sleep conﬂicts in
smartphones. In Proceedings of ACM EuroSys, 2013.

[23] Nokia. 3G radio optimisation parameter testing guide.
http://www.scribd.com/doc/103289214/Parameter-
Testing-Reference-Quide.

[24] Google Cloud Messaging. http:

//developer.android.com/google/gcm/index.html.

[25] Z. Wang, Z. Qian, Q. Xu, Z. M. Mao, and Ming

Zhang. An untold story of middleboxes in cellular
networks. In Proceedings of the ACM SIGCOMM
Conference, 2011.

[26] F. Busatto. TCP Keepalive HOWTO.

http://tldp.org/HOWTO/TCP-Keepalive-HOWTO.

[27] R. Fielding, J. Gettys, J. Mogul, H. Frystyk,

L. Masinter, P. Leach, and T. Berners-Lee. Hypertext
Transfer Protocol – HTTP/1.1, 1999.

[28] F. Qian, Z. Wang, A. Gerber, Z. M. Mao, S. Sen, and
O. Spatscheck. TOP: Tail Optimization Protocol For
Cellular Radio Resource Allocation. In Proceedings of
IEEE ICNP, 2010.

263