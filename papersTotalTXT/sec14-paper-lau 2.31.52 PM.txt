Mimesis Aegis: A Mimicry Privacy Shield– 

A System’s Approach to Data Privacy  

on Public Cloud

Billy Lau, Simon Chung, Chengyu Song, Yeongjin Jang, Wenke Lee,  

and Alexandra Boldyreva, Georgia  Institute of Technology

https://www.usenix.org/conference/usenixsecurity14/technical-sessions/presentation/lau

This paper is included in the Proceedings of the 23rd USENIX Security Symposium.August 20–22, 2014 • San Diego, CAISBN 978-1-931971-15-7Open access to the Proceedings of  the 23rd USENIX Security Symposium is sponsored by USENIXMimesis Aegis: A Mimicry Privacy Shield

A System’s Approach to Data Privacy on Public Cloud

Billy Lau, Simon Chung, Chengyu Song, Yeongjin Jang, Wenke Lee, and Alexandra Boldyreva

College of Computing, Georgia Institute of Technology, Atlanta, GA 30332

{billy, pchung, csong84, yeongjin.jang, wenke, sasha.boldyreva}@cc.gatech.edu

Abstract

Users are increasingly storing, accessing, and ex-
changing data through public cloud services such as
those provided by Google, Facebook, Apple, and Mi-
crosoft. Although users may want to have faith in cloud
providers to provide good security protection, the conﬁ-
dentiality of any data in public clouds can be violated,
and consequently, while providers may not be “doing
evil,” we can not and should not trust them with data con-
ﬁdentiality.

To better protect the privacy of user data stored in the
cloud, in this paper we propose a privacy-preserving sys-
tem called Mimesis Aegis (M-Aegis) that is suitable for
mobile platforms. M-Aegis is a new approach to user
data privacy that not only provides isolation but also pre-
serves the user experience through the creation of a con-
ceptual layer called Layer 7.5 (L-7.5), which is inter-
posed between the application (OSI Layer 7) and the user
(Layer 8). This approach allows M-Aegis to implement
true end-to-end encryption of user data with three goals
in mind: 1) complete data and logic isolation from un-
trusted entities; 2) the preservation of original user ex-
perience with target apps; and 3) applicable to a large
number of apps and resilient to app updates.

In order to preserve the exact application workﬂow
and look-and-feel, M-Aegis uses L-7.5 to put a transpar-
ent window on top of existing application GUIs to both
intercept plaintext user input before transforming the in-
put and feeding it to the underlying app, and to reverse-
transform the output data from the app before displaying
the plaintext data to the user. This technique allows M-
Aegis to transparently integrate with most cloud services
without hindering usability and without the need for re-
verse engineering. We implemented a prototype of M-
Aegis on Android and show that it can support a number
of popular cloud services, e.g. Gmail, Facebook Messen-
ger, WhatsApp, etc.

Our performance evaluation and user study show that
users incur minimal overhead when adopting M-Aegis

on Android:
imperceptible encryption/decryption la-
tency and a low and adjustable false positive rate when
searching over encrypted data.

1

Introduction

A continuously increasing number of users now utilize
mobile devices [2] to interact with public cloud services
(PCS) (e.g. Gmail, Outlook, and WhatsApp) as an es-
sential part of their daily lives. While the user’s con-
nectivity to the Internet is improved with mobile plat-
forms, the problem of preserving data privacy while in-
teracting with PCS remains unsolved. In fact, news about
the US government’s alleged surveillance programs re-
minds everybody about a very unsatisfactory status quo:
while PCS are essentially part of everyday life, the de-
fault method of utilizing them exposes users to privacy
breaches, because it implicitly requires the users to trust
the PCS providers with the conﬁdentiality of their data;
but such trust is unjustiﬁed, if not misplaced. Incidents
that demonstrate breach of this trust are easy to come by:
1) PCS providers are bound by law to share their users’
data with surveillance agencies [14], 2) it is the business
model of the PCS providers to mine their users’ data and
share it with third parties [11, 22, 24, 40], 3) operator er-
rors [34] can result in unintended data access, and 4) data
servers can be compromised by attackers [47].

To alter this undesirable status quo, solutions should
be built based on an updated trust model of every-
day communication that better reﬂects the reality of the
threats mentioned above.
In particular, new solutions
must ﬁrst assume PCS providers to be untrusted. This
implies that all other entities that are controlled by the
PCS providers, including the apps that users installed to
engage with the PCS, must also be assumed untrusted.

Although there are a plethora of apps available today
that come in various combinations of look and feel and
features, we observed that many of these apps provide
text communication services (e.g. email or private/group

USENIX Association  

23rd USENIX Security Symposium  33

1

messaging categories). Users can still enjoy the same
quality of service1 without needing to reveal their plain-
text data to PCS providers. PCS providers are essen-
tially message routers that can function normally with-
out needing to know the content of the messages being
delivered, analogous to postmen delivering letters with-
out needing to learn the actual content of the letters.

Therefore, applying end-to-end encryption (E2EE)
without assuming trust in the PCS providers seems to
solve the problem. However, in practice, the direct ap-
plication of E2EE solutions onto the mobile device envi-
ronment is more challenging than originally thought [65,
59]. A good solution must present clear advantages to the
entire mobile security ecosystem. In particular it must
account for these factors: 1) the users’ ease-of-use, hence
acceptability and adoptability; 2) the developers’ efforts
to maintain support; and 3) the feasibility and deploya-
bility of solution on a mobile system. From this analysis,
we formulate three design goals that must be addressed
coherently:

1. For a solution to be secure, it must be properly
isolated from untrusted entities. It is obvious that
E2EE cannot protect data conﬁdentiality if plain-
text data or an encryption key can be compromised
by architectures that risk exposing these values.
Traditional solutions like PGP [15] and newer so-
lutions like Gibberbot [5], TextSecure [12], and
SafeSlinger [41] provide good isolation, but force
users to use custom apps, which can cause usabil-
ity problems (refer to (2)). Solutions that repack-
age/rewrite existing apps to introduce additional se-
curity checks [68, 26] do not have this property
(further discussed in Sect. 2.3). Solutions in the
form of browser plugins/extensions also do not have
this property (further discussed in Sect. 2.2), and
they generally do not ﬁt into the mobile security
landscape because many mobile browsers do not
support extensions [7], and mobile device users
do not favor using mobile browsers [27] to access
PCS. Therefore, we rule out conventional browser-
plugin/extension-based solutions.

2. For a solution to be adoptable, it must preserve the
user experience. We argue that users will not accept
solutions that require them to switch between dif-
ferent apps to perform their daily tasks. Therefore,
simply porting solutions like PGP to a mobile plat-
form would not work, because it forces users to use
a separate and custom app, and it is impossible to
recreate the richness and unique user experience of
all existing text routing apps offered by various PCS
providers today. In the context of mobile devices,
PCS are competing for market share not only by of-

1the apps’ functionalities and user experience are preserved

fering more reliable infrastructure to facilitate user
communication, but also by offering a better user
experience [16, 58]. Ultimately, users will choose
apps that feel the most comfortable. To reduce in-
terference with a user’s interaction with the app of
their choice, security solutions must be retroﬁttable
to existing apps. Solutions that repackage/rewrite
existing apps have this criterion.

3. For a solution to be sustainable, it must be easy to
maintain and scalable: the solution must be sufﬁ-
ciently general-purpose, require minimal effort to
support new apps, and withstand app updates. In the
past, email was one of the very few means of com-
munication. Protecting it is relatively straightfor-
ward because email protocols (e.g. POP and IMAP)
are well deﬁned. Custom privacy-preserving apps
can therefore be built to serve this need. How-
ever, with the introduction of PCS that are becom-
ing indispensable in a user’s everyday life, a good
solution should also be able to integrate security
features into apps without requiring reverse engi-
neering of the apps’ logic and/or network protocols,
which are largely undocumented and possibly pro-
prietary (e.g. Skype, WhatsApp, etc.).

In this paper, we introduce Mimesis Aegis (M-Aegis),
a privacy-preserving system that mimics the look and
feel of existing apps to preserve their user experience
and workﬂow on mobile devices, without changing the
underlying OS or modifying/repackaging existing apps.
M-Aegis achieves the three design goals by operating at
a conceptual layer we call Layer 7.5 (L-7.5) that is po-
sitioned above the existing application layer (OSI Layer
7 [8]), and interacts directly with the user (popularly la-
beled as Layer 8 [19, 4]).

From a system’s perspective, L-7.5 is a transparent
window in an isolated process that interposes itself be-
tween Layer 7 and 8. The interconnectivity between
these layers is achieved using the accessibility frame-
work, which is available as an essential feature on mod-
ern operating systems. Note that utilizing accessibility
features for unorthodox purposes have been proposed by
prior work [56, 48] that achieves different goals. L-7.5
extracts the GUI information of an app below it through
the OS’s user interface automation/accessibility (UIA) li-
brary. Using this information, M-Aegis is then able to
proxy user input by rendering its own GUI (with a differ-
ent color as visual cue) and subsequently handle those in-
put (e.g. to process plaintext data or intercept user button
click). Using the same UIA library, L-7.5 can also pro-
grammatically interact with various UI components of
the app below on behalf of the user (refer to Sect. 3.3.2
for more details). Since major software vendors today
have pledged their commitment towards continuous sup-

34  23rd USENIX Security Symposium 

USENIX Association

2

USENIX Association  

23rd USENIX Security Symposium  35

portandenhancementofaccessibilityinterfacefordevel-opers[9,20,6,1],ourUIA-basedtechniqueisapplicableandsustainableonallmajorplatforms.Fromasecuritydesignperspective,M-Aegisprovidestwoprivacyguaranteesduringauser’sinteractionwithatargetapp:1)allinputfromtheuserﬁrstgoestoL-7.5(andisoptionallyprocessed)beforebeingpassedtoanapp.Thismeansthatconﬁdentialdataanduserintentcanbefullycaptured;and2)alloutputfromtheappmustgothroughL-7.5(andisoptionallyprocessed)beforebeingdisplayedtotheuser.Fromadeveloper’sperspective,accessingandinter-actingwithatargetapp’sUIcomponentsatL-7.5issimilartothatofmanipulatingtheDOMtreeofawebappusingJavaScript.WhileDOMtreemanipulationonlyworksforbrowsers,UIAworksforallappsonaplatform.TotracktheGUIofanapp,M-Aegisre-liesonresourceidnamesavailablethroughtheUIAli-brary.Therefore,M-Aegisisresilienttoupdatesthatchangethelookandfeeloftheapp(e.g.GUIpositionorcolor).Itonlyrequiresresourceidnamestoremainthesame,which,throughempiricalevidence,oftenholdstrue.Evenifaresourceidchanges,minimaleffortisre-quiredtorediscoverresourceidnamesandremapthemtothelogicinM-Aegis.Fromourexperience,M-Aegisdoesnotrequiredeveloperattentionacrossminorappup-dates.Fromauser’sperspective,M-Aegisisvisibleasanalways-on-topbutton.Whenitisturnedon,userswillperceivethattheyareinteractingwiththeoriginalappinplaintextmode.TheonlydifferenceistheGUIoftheoriginalappwillappearinadifferentcolortoindicatethatprotectionisactivated.Thismeansthatsubtlefea-turesthatcontributetowardstheentireuserexperiencesuchasspellcheckingandin-appnavigationarealsopreserved.However,despiteuserperception,theorigi-nalappneverreceivesplaintextdata.Figure1givesahighlevelideaofhowM-AegiscreatesanL-7.5topro-tectuser’sdataprivacywheninteractingwithGmail.Foruserswhowouldliketoprotecttheiremailcom-munications,theywillalsobeconcernedifencryptionwillaffecttheirabilitytosearch,asitisanimportantaspectofuserproductivity[64].Forthispurpose,wedesignedandincorporatedanewsearchableencryptionschemenamedeasily-deployableefﬁciently-searchablesymmetricencryptionscheme(EDESE)intoM-Aegisthatallowssearchoverencryptedcontentwithoutanyserver-sidemodiﬁcation.Webrieﬂydiscussthedesignconsiderationsandsecurityconcernsinvolvedinsup-portingthisfunctionalityinSect3.3.4.Asaproofofconcept,weimplementedaprototypeM-AegisonAndroidthatprotectsuserdatawheninterfac-ingwithtext-basedPCS.M-AegissupportsemailappslikeGmailandmessengerappslikeGoogleHangout,Figure1:ThisdiagramshowshowM-AegisusesL-7.5totransparentlyreverse-transformthemessage“dead-beef”into“Hithere”,andalsoallowsausertoentertheirplaintextmessage“Helloworld”intoM-Aegis’stextbox.Totheuser,theGUIlooksexactlythesameastheoriginalapp.Whentheuserdecidestosendames-sage,the“Helloworld”messagewillbetransformedandrelayedtotheunderlyingapp.WhatsApp,andFacebookChat.ItprotectsdataprivacybyimplementingE2EEthatpassesnoplaintexttoanappwhilealsopreservingtheuserexperienceandworkﬂow.WealsoimplementedaversionofM-Aegisonthedesk-toptodemonstratethegeneralityofourapproach.OurinitialperformanceevaluationanduserstudyshowsthatusersincurminimaloverheadinadoptingM-AegisonAndroid.Thereisimperceptibleencryption/decryptionlatencyandalowandadjustablefalsepositiveratewhensearchingoverencrypteddata.Insummary,thesearethemajorcontributionsofourwork:•WeintroducedLayer7.5(L-7.5),aconceptuallayerthatdirectlyinteractswithusersontopofexistingapps.Thisisanovelsystemapproachthatprovidesseeminglycontrastingfeatures:transparentinterac-tionwithatargetappandstrongisolationfromthetargetapp.•WedesignedandbuiltMimesisAegisbasedontheconceptofL-7.5,asystemthatpreservesuserpri-vacywheninteractingwithPCSbyensuringdataconﬁdentiality.Essentialfunctionalitiesofexistingapps,especiallysearch(evenoverencrypteddata),arealsosupportedwithoutanyserver-sidemodiﬁ-cation.•WeimplementedtwoprototypesofMimesisAegis,oneonAndroidandtheotheronWindows,with3support for various popular public cloud services,
including Gmail, Facebook Messenger, Google
Hangout, WhatsApp, and Viber.

• We designed and conducted a user study that

demonstrated the acceptability of our solution.

The rest of the paper is structured as follows. Section 2
compares our work to related work. Section 3 discusses
the threat model and the design of M-Aegis. Section 4
presents the implementation of M-Aegis and the chal-
lenges we solved during the process. Section 5 presents
performance evaluations and user study of the accept-
ability of M-Aegis on Android. Section 6 discusses limi-
tations of our work and answers some common questions
that readers may have about our system. Section 7 dis-
cusses future work and concludes our work.

2 Related Work

Since M-Aegis is designed to achieve the three design
goals described in Sect. 1 while seamlessly integrating
end-to-end encryption into user’s communication, we
discuss how well existing works achieve some of these
goals and how they differ from our work. As far as we
know, there is no existing work that achieves all the three
design goals.

2.1 Standalone Solutions
There are many standalone solutions that aim to protect
user data conﬁdentiality. Solutions like PGP [15] (in-
cluding S/MIME [37]), Gibberbot [5], TextSecure [12],
SafeSlinger [41], and FlyByNight [55] provides secure
messaging and/or ﬁle transfer through encryption of user
data. These solutions provide good isolation from un-
trusted entities. However, since they are designed as
standalone custom apps, they do not preserve the user
experience, requiring users to adopt a new workﬂow on
a custom app. More importantly, these solutions are not
retroﬁttable to existing apps on the mobile platform.

Like M-Aegis, Cryptons [36] introduced a similarly
strong notion of isolation through its custom abstrac-
tions. However, Cryptons assumes a completely differ-
ent threat model that trusts PCS, and requires both server
and client (app) modiﬁcations. Thus, Cryptons could not
protect a user’s communication using existing messag-
ing apps while assuming the provider to be untrusted.
We also argue that it is non-trivial to modify Cryptons to
achieve the three design goals we mentioned in Sect. 1.

2.2 Browser Plugin/Extension Solutions
Other solutions that focus on protecting user privacy
include Cryptocat [3], Scramble! [24], TrustSplit [40],

NOYB (None of Your Business) [46], and SafeBut-
ton [53]. Some of these assume different threat mod-
els, and achieve different goals. For example, NOYB
protects a user’s Facebook proﬁle data while SafeBut-
ton tries to keep a user’s browsing history private. Most
of these solutions try to be transparently integrated into
user workﬂow. However, since these solutions are mostly
based on browser plugins/extensions, they are not appli-
cable to the mobile platform.

Additionally, Cryptocat and TrustSplit require new
and/or independent service providers to support their
functionalities. However, M-Aegis works with the exist-
ing service providers without assuming trust or requiring
modiﬁcation to server-side communication.

2.3 Repackaging/Rewriting Solutions
There is a category of work that repackages/rewrites an
app’s binary to introduce security features, such as Aura-
sium [68], Dr. Android [49], and others [26]. Our solu-
tion is similar to these approaches in that we can retroﬁt
our solutions to existing apps and still preserve user ex-
perience, but is different in that M-Aegis’ coverage is
not limited to apps that do not contain native code. Also,
repackaging-based approaches suffer from the problem
that they will break app updates. In some cases, the se-
curity of such solutions can be circumvented because the
isolation model is unclear, i.e. the untrusted code resides
in the same address space as the reference monitor (e.g.
Aurasium).

2.4 Orthogonal Work
Although our work focuses on user interaction on mobile
platforms with cloud providers, we assume a very differ-
ent threat model than those that focus on more robust
permission model infrastructures and those that focus
on controlling/tracking information ﬂow, such as Taint-
Droid [38] and Airbag [67]. These solutions require
changes to the underlying app, framework, or the OS,
but M-Aegis does not.

Access Control Gadgets (ACG) [57] uses user input as
permission granting intent to allow apps to access user
owned resources. Although we made the same assump-
tions as ACG to capture authentic user input, ACG is de-
signed for a different threat model and security goal than
ours. Furthermore, ACG requires a modiﬁed kernel but
M-Aegis does not.

Persona [23] presents a completely isolated and new
online social network that provides certain privacy and
security guarantees to the users. While related, it differs
from the goal of M-Aegis.

Frientegrity [43] and Gyrus [48] focus on different as-

pects of integrity protection of a user’s data.

36  23rd USENIX Security Symposium 

USENIX Association

4

Tor [35] is well known for its capability to hide a user’s
IP address while browsing the Internet. However, it fo-
cuses on anonymity guarantees while M-Aegis focuses
on data conﬁdentiality guarantees.

Off-the-record messaging (OTR) [30] is a secure com-
munication protocol that provides perfect forward se-
crecy and malleable encryption. While OTR can be im-
plemented on M-Aegis using the same design architec-
ture to provide these extra properties, it is currently not
the focus of our work.

3 System Design

3.1 Design Goals
In this section, we formally reiterate our design goals.
We posit that a good solution must:

1. Offer good security by applying strong isolation

from untrusted entities (deﬁned in Sect. 3.2).

2. Preserve the user experience by providing users

transparent interaction with existing apps.

3. Be easy to maintain and scale by devising a sufﬁ-

ciently general-purpose approach.

Above all, these goals must be satisﬁed within the
unique set of constraints found in the mobile platform,
including user experience, transparency, deployability,
and adoptability factors.

3.2 Threat Model
3.2.1 In-Scope Threats

We begin with the scope of threats that M-Aegis is de-
signed to protect against. In general, there are three par-
ties that pose threats to the conﬁdentiality of users’ data
exposed to public cloud through mobile devices. There-
fore, we assume these parties to be untrusted in our threat
model:

• Public cloud service (PCS) providers. Sensitive
data stored in the public cloud can be compromised
in several ways: 1) PCS providers can be compelled
by law [21] to provide access to a user’s sensitive
data to law enforcement agencies [14]; 2) the busi-
ness model of PCS providers creates strong incen-
tive for them to share/sell user data with third par-
ties [11, 22, 24, 40]; 3) PCS administrators who
have access to the sensitive data may also compro-
mise the data, either intentionally [14] or not [34];
and 4) vulnerabilities of the PCS can be exploited
by attackers to exﬁltrate sensitive data [47].

• Client-side apps. Since client-side apps are devel-
oped by PCS providers to allow a user to access
their services, it follows that these apps are consid-
ered untrusted too.

• Middle boxes between a PCS and a client-side app.
Sensitive data can also be compromised when it is
transferred between a PCS and a client-side app. In-
correct protocol design/implementation may allow
attackers to eavesdrop on plaintext data or perform
Man-in-the-Middle attacks [39, 18, 13].

M-Aegis addresses the above threats by creating L-
7.5, which it uses to provide end-to-end encryption
(E2EE) for user private data. We consider the following
components as our trusted computing base (TCB): the
hardware, the operating system (OS), and the framework
that controls and mediates access to hardware.
In the
absence of physical input devices (e.g. mouse and key-
board) on mobile devices, we additionally trust the soft
keyboard to not leak the keystrokes of a user. We rely
on the TCB to correctly handle I/O for M-Aegis, and to
provide proper isolation between M-Aegis and untrusted
components.

Additionally, we also assume that all the components
of M-Aegis, including L-7.5 that it creates, are trusted.
The user is also considered trustworthy under our threat
model in his intent. This means that he is trusted to turn
on M-Aegis when he wants to protect the privacy of his
data during his interaction with the PCS.

3.2.2 Out of Scope Threats
Our threat model does not consider the following types of
attacks. First, M-Aegis only guarantees the conﬁdential-
ity of a user’s data, but not its availability. Therefore, at-
tacks that deny access to data (denial-of-service) either at
the server or the client are beyond the scope of this work.
Second, any attacks against our TCB are orthogonal to
this work. Such attacks include malicious hardware [52],
attacks against the hardware [66], the OS [50], the plat-
form [63] and privilege escalation attacks (e.g. unautho-
rized rooting of device). However, note that M-Aegis
can be implemented on a design that anchors its trust
on trusted hardware and hypervisor (e.g. Gyrus [48],
Storage Capsules [29]) to minimize the attack surface
against the TCB. Third, M-Aegis is designed to prevent
any direct ﬂow of information from an authorized user
to untrusted entities. Hence, leakages through all side-
channels [62] are beyond the scope of this work.

Since the user is assumed to be trustworthy under our
threat model to use M-Aegis correctly, M-Aegis does
not protect the user against social-engineering-based at-
tacks. For example, phishing attacks to trick users into
either turning off M-Aegis and/or entering sensitive in-
formation into unprotected UI components are beyond

USENIX Association  

23rd USENIX Security Symposium  37

5

the scope of our paper. Instead, M-Aegis deploys best-
effort protection by coloring the UI components in L-7.5
differently from that of the default app UI.

The other limitations of M-Aegis, which are not secu-

rity threats, are discussed in Sect. 6.2.

3.3 M-Aegis Architecture
M-Aegis is architected to fulﬁll all of the three design
goals mentioned in Sect. 3.1. Providing strong isolation
guarantees is ﬁrst. To achieve this, M-Aegis is designed
to execute in a separate process, though it resides in the
same OS as the target client app (TCA). Besides memory
isolation, the ﬁlesystem of M-Aegis is also shielded from
other apps by OS app sandbox protection.

Should a greater degree of isolation be desirable, an
underlying virtual-machine-based system can be adopted
to provide even stronger security guarantees. However,
we do not consider such design at this time as it is cur-
rently unsuitable for mobile platforms, and the adoption
of such technology is beyond the scope of our paper. The
main components that make up M-Aegis are as follows.

3.3.1 Layer 7.5 (L-7.5)

M-Aegis creates a novel and conceptual layer called
Layer 7.5 (L-7.5) to interpose itself between the user and
the TCA. This allows M-Aegis to implement true end-to-
end encryption (E2EE) without exposing plaintext data
to the TCA while maintaining the TCA’s original func-
tionalities and user experience, fulﬁlling the second de-
sign goal. L-7.5 is built by creating a transparent window
that is always-on-top. This technique is advantageous
in that it provides a natural way to handle user interac-
tion, thus preserving user experience without the need to
reverse engineer the logic of TCAs or the network pro-
tocols used by the TCAs to communicate with their re-
spective cloud service backends, fulﬁlling the third de-
sign goal.

There are three cases of user interactions to han-
dle. The ﬁrst case considers interactions that do not
involve data conﬁdentiality (e.g. deleting or relabel-
ing email). Such input do not require extra process-
ing/transformation and can be directly delivered to the
underlying TCA. Such click-through behavior is a natu-
ral property of transparent windows, and helps M-Aegis
maintain the look and feel of the TCA.

The second case considers interactions that involve
data conﬁdentiality (e.g. entering messages or search-
ing encrypted email). Such input requires extra process-
ing (e.g. encryption and encoding operations). For such
cases, M-Aegis places opaque GUIs that “mimic” the
GUIs over the TCA, which are purposely painted in dif-
ferent colors for two reasons: 1) as a placeholder for user

input so that it does not leak to the TCA, and 2) for user
visual feedback. Mimic GUIs for the subject and content
as seen in Fig. 3 are examples of this case. Since L-7.5 is
always on top, this provides the guarantee that user input
always goes to a mimic GUI instead of the TCA.

The third case considers interactions with control
GUIs (e.g. send buttons). Such input requires user action
to be “buffered” while the input from the second case is
being processed before being relayed to the actual con-
trol GUI of the TCA. For such cases, M-Aegis creates
semi-transparent mimic GUIs that register themselves to
absorb/handle user clicks/taps. Again, these mimic GUIs
are painted with a different color to provide a visual cue
to a user. Examples of these include the purple search
button in the left ﬁgure in Fig. 2 and the purple send but-
ton in Fig. 3. Note that our concept of intercepting user
input is similar to that of ACG’s [57] in capturing user
intent, but our application of user intent differs.

3.3.2 UIA Manager (UIAM)

To be fully functional, there are certain capabilities that
M-Aegis requires but are not available to normal apps.
First, although M-Aegis is conﬁned within the OS’ app
sandbox, it must be able to determine with which TCA
the user is currently interacting. This allows M-Aegis
to invoke speciﬁc logic to handle the TCA, and helps
M-Aegis clean up the screen when the TCA is termi-
nated. Second, M-Aegis requires information about the
GUI layout for the TCA it is currently handling. This
allows M-Aegis to properly render mimic GUIs on L-
7.5 to intercept user I/O. Third, although isolated from
the TCA, M-Aegis must be able to communicate with
the TCA to maintain functionality and ensure user expe-
rience is not disrupted. For example, M-Aegis must be
able to relay user clicks to the TCA, eventually send en-
crypted data to the TCA, and click on TCA’s button on
behalf of the user. For output on screen, it must be able to
capture ciphertext so that it can decrypt it and then render
it on L-7.5.

M-Aegis extracts certain features from the underly-
ing OS’s accessibility framework, which are exposed
to developers in the form of User Interface Accessibil-
ity/Automation (UIA) library. Using UIA, M-Aegis is
not only able to know which TCA is currently execut-
ing, but it can also query the GUI tree of the TCA to get
detailed information about how the page is laid out (e.g.
location, size, type, and resource-id of the GUI compo-
nents). More importantly, it is able to obtain information
about the content of these GUI items.

Exploiting UIA is advantageous to our design as com-
pared to other methods of information capture from the
GUI, e.g. OCR. Besides having perfect content accuracy,
our technique is not limited by screen size. For example,

38  23rd USENIX Security Symposium 

USENIX Association

6

Figure 2: The ﬁgure on the left illustrates how a user perceives the Gmail preview page when M-Aegis is turned on.
The ﬁgure on the right illustrates the same scenario but with M-Aegis turned off. Note that the search button is painted
with a different color when M-Aegis is turned on.

even though the screen size may prevent full text to be
displayed, M-Aegis is still able to capture text in its en-
tirety through the UIA libraries, allowing us to comfort-
ably apply decryption to ciphertext.

We thus utilize all these capabilities and advantages
to build a crucial component of M-Aegis called the UIA
manager (UIAM).

3.3.3 Per-TCA Logic

M-Aegis can be extended to support many TCAs. For
each TCA of interest, we build per-TCA logic as an ex-
tension module. The per-TCA logic is responsible for
rendering the speciﬁc mimic GUIs according to informa-
tion it queries from the UIAM. Therefore, per-TCA logic
is responsible for handling direct user input. Speciﬁcally,
it decides whether the user input will be directly passed
to the TCA or be encrypted and encoded before doing
so. This ensures that the TCA never obtains plaintext
data while user interaction is in plaintext mode. Per-TCA
logic also intercepts button clicks so that it can then in-
struct UIAM to emulate the user’s action on the button in
the underlying TCA. Per-TCA logic also decides which
encryption and encoding scheme to use according to the
type of TCA it is handling. For example, encryption and
encoding schemes for handling email apps would differ
from that of messenger apps.

3.3.4 Cryptographic Module

M-Aegis’ cryptographic module is responsible for pro-
viding encryption/decryption and cryptographic hash ca-
pabilities to support our searchable encryption scheme

(described in detail later) to the per-TCA logic the so
that M-Aegis can transform/obfuscate messages through
E2EE operations. Besides standard cryptographic prim-
itives, this module also includes a searchable encryp-
tion scheme to support search over encrypted email that
works without server modiﬁcation. Since the discussion
of any encryption scheme is not complete without en-
cryption keys, key manager is also a part of this module.
Key Manager. M-Aegis has a key manager per TCA
that manages key policies that can be speciﬁc to each
TCA according to user preference. The key manager
supports a range of schemes, including simple password-
based key derivation functions (of which we assume the
password to be shared out of band) to derive symmetric
keys, which we currently implement as default, to more
sophisticated PKI-based scheme for users who prefer
stronger security guarantees and do not mind the addi-
tional key set-up and exchange overheads. However, the
discussion about the best key management/distribution
policy is beyond the scope of this paper.

Searchable Encryption Scheme (EDESE). There
are numerous encryption schemes that support keyword
search [45, 61, 44, 31, 33, 28, 51]. These schemes ex-
hibit different tradeoffs between security, functionality
and efﬁciency, but all of them require modiﬁcations on
the server side. Schemes that make use of inverted in-
dex [33] are not suitable, as updates to inverted index
cannot be practically deployed in our scenario.

Since we cannot assume server cooperation (con-
sistent with our threat model
in Sect. 3.2), we de-
signed a new searchable encryption scheme called easily-
deployable efﬁciently-searchable symmetric encryption
scheme (EDESE). EDESE is an adaptation of a scheme

USENIX Association  

23rd USENIX Security Symposium  39

7

40  23rd USENIX Security Symposium 

USENIX Association

proposedbyBellareetal.[25],withmodiﬁcationssimi-lartothatofGoh’sscheme[44]thatisretroﬁttabletoanon-modifyingserverscenario.WeincorporatedEDESEforemailapplicationswiththefollowingconstruct.Theideafortheconstructionissimple:weencryptthedocumentwithastandardencryp-tionschemeandappendHMACsofuniquekeywordsinthedocument.WediscussthespeciﬁcinstantiationsofencryptionandHMACschemesthatweuseinSect.4.1.Topreventleakingthenumberofuniquekeywordsweaddasmany“dummy”keywordsasneeded.Wepresentthisconstructionindetailinthefullversionofourpa-per[54].Inordertoachievehigherstorageandsearchefﬁ-ciency,weutilizedaBloomﬁlter(BF)torepresenttheEDESE-index.Basically,aBFisadatastructurethatallowsforefﬁcientset-inclusiontests.However,suchset-inclusiontestsbasedonBFsarecurrentlynotsup-portedbyexistingemailproviders,whichonlysupportstring-basedsearches.Therefore,wedevisedasolutionthatencodesthepositionsofon-bitsinaBFasUnicodestrings(refertoSect.4.4fordetails).Sincetheunderlyingdatastructurethatisusedtosup-portEDESEisaBF,searchoperationsaresusceptibletofalsepositivesmatches.However,thisdoesnotposearealproblemtousers,becausethefalsepositiverateisextremelylowandiscompletelyadjustable.Ourcurrentimplementationfollowstheseparameters:thelengthofkeyword(inbits)isestimatedtobek=128,thesizeoftheBFarrayisB=224,themaximumnumberofuniquekeywordsusedinanyemailthreadisestimatedtobed=106,thenumberofbitssetto1foronekeywordisr=10.Plugginginthesevaluesintotheformulaforfalsepositivecalculation[44],i.e.(1−e−rd/B)r,wecaptheprobabilityofafalsepositiveδto0.0003.Weformallyassessthesecurityguaranteesthatourconstructionprovides.Inthefullversionofourpa-per[54],weproposeasecuritydeﬁnitionforEDESEschemesanddiscusswhytheexistingnotionsarenotsuitable.Ourdeﬁnitionconsidersanattackerwhocanobtainexamplesofencrypteddocumentsofitschoiceandtheresultsofqueriesofkeywordsofitschoice.Givensuchanadversary,anEDESEschemesecureun-derourdeﬁnitionshouldhideallpartialinformationaboutthemessagesexceptforthemessagelengthandthenumberofcommonkeywordsbetweenanysetofmes-sages.Leakingthelatterisunavoidablegiventhatforthesearchfunctiontobetransparenttoencryption,theoutputofaqueryhastobeapartaciphertext.Butev-erythingelse,e.g.,thenumberofuniquekeywordsinamessage,positionsofthekeywords,ishidden.Giventhesecuritydeﬁnitioninourfullpaper[54],weprovethatourconstructionsatisﬁesitunderthestandardnotionsofsecurityforencryptionandHMACs.Figure3:UserstillinteractswithGmailapptocomposeemail,withM-Aegis’mimicGUIspaintedwithdifferentcolorsonL-7.5.3.4UserWorkﬂowTobetterillustratehowthedifferentcomponentsinM-Aegisﬁttogether,wedescribeanexampleworkﬂowofausercomposingandsendinganemailusingthestockGmailapponAndroidusingM-Aegis:1)WhentheuserlaunchestheGmailapp,theUIAMnotiﬁesthecorrectper-TCAlogicoftheevent.Theper-TCAlogicwilltheninitializeitselftohandletheGmailworkﬂow.2)AssoonasGmailislaunched,theper-TCAlogicwilltrytodetectthestateofGmailapp(e.g.preview,reading,orcomposingemail).ThisallowsM-AegistoproperlycreatemimicGUIsonL-7.5tohandleuserin-teraction.Forexample,whenauserisonthecomposepage,theper-TCAlogicwillmimictheGUIsofthesubjectandcontentﬁelds(asseeninFig.3).TheusertheninteractsdirectlywiththesemimicGUIsinplain-textmodewithoutextraeffort.Thus,theworkﬂowisnotaffected.Notethatessentialbutsubtlefeatureslikespellcheckandautocorrectarestillpreserved,astheyareinnatefeaturesofthemobiledevice’ssoftkeyboard.Ad-ditionally,the“send”buttonisalsomimickedtocaptureuserintent.3)Astheuserﬁnishescomposinghisemail,heclicksonthemimicked“send”buttononL-7.5.SinceL-7.5re-ceivestheuserinputandnottheunderlyingGmailapp,theper-TCAlogicisabletocapturethiseventandpro-ceedtoprocessthesubjectandthecontent.4)Theper-TCAlogicselectstheappropriateencryp-tionkeytobeusedbasedontherecipientlistandthepredeterminedkeypolicyforGmail.Ifakeycannotbefoundforthisconversation,M-Aegispromptstheuser(seeFig.4)forapasswordtoderiveanewkey.Afterob-8USENIX Association  

23rd USENIX Security Symposium  41

Figure4:Passwordpromptwhenusersendsencryptedmailforanewconversation.tainingtheassociatedkeyforthisconversation,M-AegiswillthenencrypttheseinputsandencodeitbacktotextsuchthatGmailcanconsumeit.5)Theper-TCAlogicthenrequeststheUIAMtoﬁllinthecorrespondingGUIsonGmailwiththetransformedtext.Aftertheyareﬁlled,theUIAMisinstructedtoclicktheactual“send”buttononbehalfoftheuser.Thispro-videsatransparentexperiencetotheuser.Fromthisworkﬂow,itshouldthereforebeevidentthatfromtheuser’sperspective,theworkﬂowofusingGmailremainsthesame,becauseofthemimickingpropertiesofM-Aegis.4ImplementationandDeploymentInthissection,wediscussimportantdetailsofourpro-totypeimplementations.WeimplementedaprototypeofM-AegisusingJavaonAndroid,asanaccessibilityservice.ThisisdonebycreatingaclassthatextendstheAccessibilityServiceclassandrequestingtheBINDACCESSIBILITYSERVICEpermissionintheman-ifest.ThisallowsustointerfacewiththeUIAlibrary,buildingourUIAM.WediscussthisinfurtherdetailinSect.4.2.WethendeployedourprototypeontwoAndroidphonesfromseparatemanufacturers,i.e.SamsungGalaxyNexus,andLGNexus4,targetingseveralver-sionsofAndroid,fromAndroid4.2.2(APIlevel17)toAndroid4.4.2(APIlevel19).ThedeploymentwasdoneonstockdevicesandOS,i.e.withoutmodifyingtheOS,Androidframework,orrooting.Onlysimpleappinstal-lationwasperformed.Thisdemonstratestheeaseofde-ploymentanddistributionofoursolution.WehavealsoimplementedanM-AegisprototypeonWindows7todemonstrateinteroperabilityandgeneralityofapproach,butwedonotdiscussthedetailshere,asitisnotthefocusofthispaper.Asaninterfacetotheuser,wecreateabuttonthatisalwaysontopevenifotherappsarelaunched.Thisal-lowsustocreateanon-bypassabledirectchannelofcom-municationwiththeuserbesidesprovidingvisualcueofwhetherM-Aegisisturnedonoroff.Forappsupport,weuseGmailasanexampleofanemailappandWhatsAppasanexampleofamessengerapp.Wearguethatitiseasytoextendthesupporttootherappswithintheseclasses.Weﬁrstdescribethecryptographicschemesthatwedeployedinourprototype,thenweexplainhowwebuildourUIAMandcreateL-7.5onAndroid,andﬁnallydis-cusstheper-TCAlogicrequiredtosupportbothclassesofapps.4.1CryptographicSchemesForalltheencryption/decryptionoperations,weuseAES-GCM-256.Forapassword-basedkeygenerationalgorithm,weutilizedPBKDF2withSHA-1asthekeyed-hashmessageauthenticationcode(HMAC).WealsoutilizedHMAC-SHA-256asourHMACtogener-atetagsforemailmessages(Sect.4.4.1).Thesefunc-tionalitiesareavailableinJava’sjavax.cryptoandjava.securitypackages.Forthesakeofusability,weimplementedapassword-basedschemeasthedefault,andweassumeonepass-wordforeachgroupofmessagerecipients.Werelyontheuserstocommunicatethepasswordtothereceivingpartiesusingoutofbandchannel(e.g.inpersonorphonecalls).Formessagingapps,weimplementedanauthenti-catedDifﬁe-HellmankeyexchangeprotocoltonegotiatesessionkeysforWhatsAppconversations.APGPkeyisautomaticallygeneratedforauserduringinstallationbasedonthehashedphonenumber,andisdepositedtopubliclyaccessiblerepositoriesontheuser’sbehalf(e.g.MITPGPKeyServer[10]).Furtherdiscussionaboutverifyingtheauthenticityofpublickeysretrievedfromsuchserversisomittedfromthispaper.Sinceallsessionandprivatekeysarestoredlocallyforuserconvenience,wemakesurethattheyareneversavedtodiskinplain-text.Theyareadditionallyencryptedwithakeyderivedfromamasterpasswordthatisprovidedbytheuserdur-inginstallation.4.2UIAMAsmentionedearlier,UIAMisimplementedus-ingUIAlibraries.OnAndroid,eventsthatsig-nifysomethingnewbeingdisplayedonthescreencanbedetectedbymonitoringfollowingtheevents:WINDOWCONTENTCHANGED,WINDOWSTATECHANGED,9and VIEW SCROLLED. Upon receiving these events, per-
TCA logic is informed. The UIA library presents a data
structure in the form of a tree with nodes representing UI
components with the root being the top window. This
allows the UIAM to locate all UI components on the
screen.

Additionally, Android’s UIA framework also pro-
vides the ability to query for UI nodes by provid-
ing a resource ID. For instance, the node that repre-
sents Gmail’s search button can be found by query-
ing for com.google.android.gm:id/search. More
importantly,
there is no need to guess the names of
these resource IDs. Rather, a tool called UI Automator
Viewer [17] (see Sect. 4.4), which comes with the default
Android SDK. Once the node of interest is found, all the
other information about the GUI represented by the node
can be found. This includes the exact location and size
of text boxes and buttons on the screen.

is

able

M-Aegis

to programmatically interact
with various GUIs of a TCA using the function
performAction(). This allows it t to click on a TCA’s
button on the user’s behalf after it has processed the user
input.

4.3 Layer 7.5
We implemented Layer 7.5 on Android as speciﬁc types
of system windows, which are always-on-top of all
other running apps. Android allows the creation of
various types of system windows. We focus on two,
TYPE SYSTEM OVERLAY and TYPE SYSTEM ERROR; the
ﬁrst is for display only and allows all tap/keyboard events
to go to underlying apps. In contrast, the second type al-
lows for user interaction. Android allows the use of any
View objects for either type of window, and we use this
to create our mimic GUIs, and set their size and loca-
tion. We deliberately create our mimic GUIs in different
colors as a subtle visual cue to the users that they are
interacting with M-Aegis, without distracting them from
their original workﬂow.

4.4 Per-TCA Logic
From our experience developing per-TCA logic, the gen-
eral procedure for development is as follows:

1) Understand what the app does. This allows us to
identify which GUIs need to be mimicked for intercept-
ing user I/O. For text-based TCAs, this is a trivial step
because the core functionalities that M-Aegis needs to
handle are limited and thus easy to identify, e.g. buffer-
ing user’s typed texts and sending them to the intended
recipient.

2) Using UI Automator Viewer [17], examine the UIA
tree for the relevant GUIs of a TCA and identify sig-

Figure 5: The UI Automator Viewer presents an easy
to use interface to examine the UIA tree and determine
the resource ID (blue ellipse) associated with a GUI of
interest (red rectangle).

natures (GUI resource IDs) for each TCA state. UI
Automator Viewer allows inspection of the UIA tree
through a graphical interface (as seen in Fig. 5), which
reduces development time. We rely on UI components
that are unique to certain states (e.g. the “send” button
signiﬁes that we are in the compose state).

3) For each relevant GUI, we need to devise algo-
rithms to extract either the location and content of cipher-
text (for decryption and display), or the type, size, and
location of GUIs we need to mimic (e.g. the subject and
content boxes in the Gmail compose UI). Again, this is
done through UI Automator Viewer. For example, for the
Gmail preview state, we query the UIA for nodes with ID
com.google.android.gm:/id/conversation list
to identify all
the UIA nodes corresponding to the
preview item of each individual email, and from those
we can extract all ciphertext on the preview window
through the UIA).

4) Create event handlers for controls we mimic on L-
7.5. For the Gmail compose state, we need to listen for
click/touch events for the L-7.5 “send” button and carry
out the process described in Sect. 3.3.3 to encrypt the
email and send the ciphertext to the underlying TCA.

5) Identify ways that each relevant state can be up-
dated. Updates can be handled via the following method:
clear L-7.5, extract all necessary information from the
new state, and render again. This is equivalent to redraw-
ing all GUIs on L-7.5 based on the detected state.

There are two details worth considering when devel-
oping per-TCA logic. First, careful consideration must
be given about the type of input data fed to TCAs. Since
most TCAs only accept input data in speciﬁc formats,
e.g. text, they do not support the input of random byte
sequences as valid data. Therefore, encrypted data must

42  23rd USENIX Security Symposium 

USENIX Association

10

be encoded into text format before feeding it as input
to a TCA. Conventionally, base64 encoding is used for
this purpose. However, base64 encoding consumes too
much on-screen real estate. To overcome this, we en-
coded the binary encrypted data into Chinese Japanese
Korean (CJK) Unicode characters, which have efﬁcient
on-screen real estate consumption. To map the binary
data into the CJK plane, we process the encrypted data
at the byte granularity (28). For each byte, its value is
added to the base of the CJK Unicode representation, i.e.
0x4E00. For example, byte 0x00 will be encoded as ‘一’,
and byte 0x01 will be represented as ‘丁’.

Second, M-Aegis can only function correctly if it can
differentiate between ordinary messages and encrypted
messages. We introduce markers into the encrypted data
after encoding; in particular, we wrap the subject and
content of a message using a pair of curly braces (i.e.
{, }).
Next, we describe implementation details that are spe-
ciﬁc to these classes of apps. We begin by introducing
the format of message we created for each class. Then
we discuss other caveats (if any) that are involved in the
implementation.

4.4.1 Email Apps

We implemented support for Gmail on our prototype as
a representative app of this category. We create two cus-
tom formats to communicate the necessary metadata to
support M-Aegis’ functionalities.
Subject: {Encode(IDKey||IV||Encrypt(Sub ject))}
Content: {Encode(Encrypt(Content)||Tags)}
A particular challenge we faced in supporting decryp-
tion during the Gmail preview state is that only the begin-
ning parts of both the title and the subject of each mes-
sage are available to us. Also, the exact email addresses
of the sender and recipients are not always available, as
some are displayed as aliases, and some are hidden due
to lack of space. The lack of such information makes it
impossible to automatically decrypt the message even if
the corresponding encryption key actually exists on the
system.

To solve these problems, when we encrypt a message,
we include a key-ID (IDKey) to the subject ﬁeld (as seen
in the format description above). Note that since the key-
ID is not a secret, it need not be encrypted. This way, we
will have all the information we need to correctly decrypt
the subtext displayed on the Gmail preview.

The Tags ﬁeld is a collection of HMAC digests that
are computed using the conversation key and keywords
that exist in a particular email. It is then encoded and
appended as part of the content that Gmail receives to fa-
cilitate encrypted search without requiring modiﬁcation
to Gmail’s servers.

4.4.2 Messenger Apps
We implemented support for WhatsApp on our prototype
as a representative app of this category. The format we
created for this class of apps is simple, as seen below:
Message: {Encode(IV||Encrypt(Message))}
supporting WhatsApp.

We did not experience additional challenges when

5 Evaluations

In this section, we report the results of experiments to de-
termine the correctness of our prototype implementation,
measure the overheads of M-Aegis, and user acceptabil-
ity of our approach.

5.1 Correctness of Implementation
We manually veriﬁed M-Aegis’s correctness by navi-
gating through different states of the app and checking
if M-Aegis creates L-7.5 correctly. We manually veri-
ﬁed that the encryption and decryption operations of M-
Aegis work correctly. We ensured that plaintext is prop-
erly received at the recipient’s end when the correct pass-
word is supplied. We manually veriﬁed the correctness
of our searchable encryption scheme by introducing spe-
ciﬁc search keywords. We performed search using M-
Aegis and found no false negatives in the search result.

5.2 Performance on Android
The overhead that M-Aegis introduced to a user’s work-
ﬂow can be broken down into two factors: the additional
computational costs incurred during encryption and de-
cryption of data, and the additional I/O operations when
redrawing L-7.5. We measure overhead by measuring the
overall latency presented to the user in various use cases.
We found that M-Aegis imposes negligible latency to the
user.

All test cases were performed on a stock Android
phone (LG Nexus 4), with the following speciﬁcations:
Quad-core 1.5 GHz Snapdragon S4 Pro CPU, equipped
with 2.0 GB RAM, running Android Kit Kat (4.4.2, API
level 19). Unless otherwise stated, each experiment is
repeated 10 times and the averaged result is reported.

For our evaluation, we only performed experiments for
the setup of the Gmail app because Gmail is represen-
tative of a more sophisticated TCA, and thus indicates
worst-case performance for M-Aegis. Messenger apps
incur fewer overheads given their simpler TCA logic.

5.2.1 Previewing Encrypted Email
There are additional costs involved in previewing en-
crypted emails on the main page of Gmail. The costs are

USENIX Association  

23rd USENIX Security Symposium  43

11

broken down into times taken to 1) traverse the UIA tree
to identify preview nodes, 2) capture ciphertext from the
UIA node, 3) obtain the associated encryption key from
the key manager, 4) decrypting ciphertext, and 5) render-
ing plaintext on L-7.5. We measure these operations as a
single entity by running a macro benchmark.

For our experiment, we ensured that the preview page
consists of encrypted emails (a total of 6 can ﬁt on-
screen) to demonstrate worst-case performance. We
measured the time taken to perform all operations. We
found, on average, it takes an additional 76 ms to render
plaintext on L-7.5. Note that this latency is well within
expected response time (50 - 150 ms), beyond which a
user would notice the slowdown effect [60].

5.2.2 Composing and Sending Encrypted Email

We measured the extra time taken for a typical email to
be encrypted and for our searchable encryption index to
be built. We used the Enron Email Dataset [32] as a
representation of typical emails. We randomly picked
10 emails. The average number of words in an email
is 331, of which 153 are unique. The shortest sampled
email contained 36 words, of which 35 are unique. The
longest sampled email contains 953 words, of which 362
are unique.

With the longest sampled email, M-Aegis took 205
ms in total to both encrypt and build the search index.
Note that this includes the network latency a user will
perceive while sending an email, regardless of their use
of M-Aegis.

5.2.3 Searching on Encrypted Emails

A user usually inputs one to three keywords per search
operation. The latency experienced when performing
search is negligible. This is because the transformation
of the actual keyword into indexes requires only the for-
ward computation of one HMAC, which is nearly instan-
taneous.

5.3 User Acceptability Study
This section describes the user study we performed to
validate our hypothesis of user acceptability of M-Aegis.
Users were sampled from a population of college stu-
dents. They must be able to proﬁciently operate smart
phones and have had previous experience using the
Gmail app. Each experiment was conducted with two
identical smart phones, i.e. Nexus 4, both running An-
droid 4.3, installed with the stock Gmail app (v. 4.6).
One of the devices had M-Aegis installed.

The set up of the experiment is as follows. We asked
the user to perform a list of tasks: previewing, reading,

composing, sending, and searching through email on a
device that is not equipped with M-Aegis. Participants
were asked to pay attention to the overall experience of
performing such tasks using the Gmail app. This served
as the control experiment.

Participants were then told to repeat the same set of
tasks on another device that was equipped with M-Aegis.
This was done with the intention that they were able to
mentally compare the difference in user experience when
interacting with the two devices.

We queried the participants if they found any differ-
ence in the preview page, reading, sending, and search-
ing email, and if they felt that their overall experience
using the Gmail app on the second device was signiﬁ-
cantly different.

We debriefed the participants about the experiment
process and explained the goal of M-Aegis. We asked
them whether they would use M-Aegis to protect the pri-
vacy of their data. The results we collected and report
here are from 15 participants.

We found that no participants noticed major differ-
ences between the two experiences using the Gmail app.
One participant noticed a minor difference in the email
preview interface, i.e. L-7.5 did not catch up smoothly
when scrolled. A different participant noticed a minor
difference in the process of reading email, i.e. L-7.5 lag
before covering ciphertext with mimic GUIs. There were
only two participants that found the process of sending
email differed from the original. When asked for details,
they indicated that the cursor when composing email was
not working properly. After further investigation, we de-
termined this was a bug in Android’s GUI framework
rather than a fundamental ﬂaw in M-Aegis’s design.

Despite the perceived minor differences when per-
forming particular tasks, all participants indicated that
they would use M-Aegis to protect the privacy of their
data after understanding what M-Aegis is. This implies
that they believe that the overall disturbance to the user
experience is not large enough to impede adoption.

Since we recruited 15 users for this study, the accu-
racy/quality of our conclusion from this study lies be-
tween 80% and 95% (between 10 and 20 users) accord-
ing to ﬁndings in [42]. We intend to continue our user
study to further validate our acceptability hypothesis and
to continuously improve our prototype based on received
feedback.

6 Discussions

6.1 Generality and Scalability
We believe that our M-Aegis architecture presents a gen-
eral solution that protects user data conﬁdentiality, which
is scalable in the following aspects:

44  23rd USENIX Security Symposium 

USENIX Association

12

Across Multiple Cloud Services. There are two main
classes of apps that provide communication services,
email and messenger apps. By providing functionality
for apps in these two categories, we argue that M-Aegis
can satisfy a large portion of user mobile security needs.
The different components of M-Aegis incur a one-time
development cost. We argue that it is easy to scale
across multiple cloud services, because per-TCA logic
that needs to be written is minimal per new TCA. This
should be evident through the ﬁve general steps high-
lighted in Sect. 4.4. In addition, the logic we developed
for the ﬁrst TCA (Gmail) serves as a template/example
to implement support for other apps.

Across App Updates. Since the robustness of the
UIAM construct (Sect. 4.2) gives M-Aegis the ability to
track all TCA GUIs regardless of TCA state, M-Aegis is
able to easily survive app updates. Our Gmail app sup-
port has survived two updates without requiring major
efforts to adapt.

Resource ID names can change across updates. For
example, when upgrading to Gmail app version 4.7.2,
the resource ID name that identiﬁes a sender’s account
name changed. Using UI Automator Viewer, we quickly
discovered and modiﬁed the mapping in our TCA logic.
Note that only the mapping was changed; the logic for
the TCA does not need to be modiﬁed. This is be-
cause the core functionality of the updated GUI did not
change (i.e., the GUI associated with a sender’s account
remained a text input box).

6.2 Limitations
As mentioned earlier, M-Aegis is not designed to protect
users against social-engineering-based attacks. Adver-
saries can trick users into entering sensitive information
to the TCA while M-Aegis is turned off. Our solution is
best effort by providing distinguishing visual cues to the
user when M-Aegis is turned on and its L-7.5 is active.
For example the mimic GUIs that M-Aegis creates a dif-
ferent color. Users can toggle M-Aegis’ button on or off
to see the difference (see Fig. 2). Note that M-Aegis’s
main button is always on top and cannot be drawn over
by other apps. However, we do not claim that this fully
mitigates the problem.

One of the constraints we faced while retroﬁtting a se-
curity solution to existing TCAs (not limited to mobile
environments) is that data must usually be of the right
format (e.g. strictly text, image, audio, or video). For
example, Gmail accepts only text (Unicode-compatible)
for an email subject, but Dropbox accepts any type of
ﬁles, including random blobs of bytes. Currently, other
than text format, we do not yet support other types of user
data (e.g. image, audio and video). However, this is not
a fundamental design limitation of our system. Rather,

it is because of the unavailability of transformation func-
tions (encryption and encoding schemes) that works for
the these media types.

Unlike text, the transformation/obfuscation functions
in M-Aegis for other type of data may also need to sur-
vive other process steps, such as compression. It is nor-
mal for TCAs to perform compression on multimedia to
conserve bandwidth and/or storage. For example, Face-
book is known to compress/downsample the image up-
loads.

The conﬁdentiality guarantee that we provide excludes
risks at the end points themselves. For example, a
poor random number generator can potentially weaken
the cryptographic schemes M-Aegis applies.
It is cur-
rently unclear how our text transformations will affect a
server’s effectiveness in performing spam ﬁltering.

Our system currently does not tolerate typographical
error during search. However, we would like to point out
that this is an unlikely scenario, given that soft keyboards
on mobile devices utilize spell check and autocorrect fea-
tures. Again, this is not a ﬂaw with our architecture;
rather, it is because of the unavailability of encryption
schemes that tolerate typographical error search without
requiring server modiﬁcation.

7 Conclusions

In this paper we presented Mimesis Aegis (M-Aegis), a
new approach to protect private user data in public cloud
services. M-Aegis provides strong isolation and pre-
serves user experience through the creation of a novel
conceptual layer called Layer 7.5 (L-7.5), which acts as
a proxy between an app (Layer 7) and a user (Layer 8).
This approach allows M-Aegis to implement true end-to-
end encryption of user data while achieving three goals:
1) plaintext data is never visible to a client app, any in-
termediary entities, or the cloud provider; 2) the origi-
nal user experience with the client app is preserved com-
pletely, from workﬂow to GUI look-and-feel; and 3) the
architecture and technique are general to a large number
of apps and resilient to app updates. We implemented
a prototype of M-Aegis on Android that can support a
number of popular cloud services (e.g. Gmail, Google
Hangout, Facebook, WhatsApp, and Viber). Our user
study shows that our system preserves both the workﬂow
and the GUI look-and-feel of the protected applications,
and our performance evaluations show that users expe-
rienced minimal overhead in utilizing M-Aegis on An-
droid.

Acknowledgement
The authors would like to thank the anonymous review-
ers for their valuable comments. We also thank the vari-

USENIX Association  

23rd USENIX Security Symposium  45

13

ous members of our operations staff who provided proof-
reading of this paper. This material is based upon work
supported in part by the National Science Foundation
under Grants No. CNS-1017265, CNS-0831300, CNS-
1149051, and CNS-1318511, by the Ofﬁce of Naval Re-
search under Grant No. N000140911042, by the Depart-
ment of Homeland Security under contract No. N66001-
12-C-0133, and by the United States Air Force under
Contract No. FA8650-10-C-7025. Any opinions, ﬁnd-
ings, and conclusions or recommendations expressed in
this material are those of the authors and do not necessar-
ily reﬂect the views of the National Science Foundation,
the Ofﬁce of Naval Research, the Department of Home-
land Security, or the United States Air Force.

References
[1] Accessibility.

http://developer.android.com/guide/topics/ui/
accessibility/index.html.
Networking

Visual

Index:

[2] Cisco

Data

Trafﬁc

bile
http://www.cisco.com/c/en/us/solutions/collateral/service-
provider/visual-networking-index-vni/white paper c11-
520862.html.

Forecast

Update,

Global Mo-
2013–2018.

[3] Cryptocat. https://crypto.cat.
[4] Engineering Security Solutions at Layer 8 and Above.

https://blogs.rsa.com/engineering-security-solutions-at-layer-8-
and-above/, December.

[5] Gibberbot

Android
https://securityinabox.org/en/Gibberbot main.

for

devices.

[6] Google Accessibility.

https://www.google.com/accessibility/policy/.

[7] Google

Chrome

Mobile

https://developers.google.com/chrome/mobile/docs/faq.

FAQ.

[8] International

technology - Open Systems Interconnection -
Basic Reference Model: The Basic Model. http://www.ecma-
international.org/activities/Communications/TG11/s020269e.pdf.

[9] Microsoft Accessibility.

http://www.microsoft.com/enable/microsoft/
section508.aspx.

[10] MIT PGP Public Key Server. http://pgp.mit.edu/.
begins
[11] New privacy
access
boost

facebook
to

companies

sonal
ailing
http://www.dailymail.co.uk/news/article-2212178/New-
privacy-row-Facebook-begins-selling-access-users-boost-
ailing-proﬁts.html.

fears
to

selling

as

per-
proﬁts.

[12] Secure texts for Android. https://whispersystems.org.
[13] Sniffer

tool displays other people’s WhatsApp messages.

http://www.h-online.com/security/news/item/Sniffer-tool-
displays-other-people-s-WhatsApp-messages-1574382.html.

[14] Snowden: Leak of NSA spy programs ”marks my end”.

http://www.cbsnews.com/8301-201 162-57588462/snowden-
leak-of-nsa-spy-programs-marks-my-end/.

[15] Symantec

desktop

email

encryption

email
and
http://www.symantec.com/desktop-email-encryption.

software

for

encryption
laptops

end-to-end
desktops.

14

[16] Ten

Mistakes

Cus-
tomers’
Experience.
http://www.itbusinessedge.com/slideshows/show.aspx?c=96038.

Can
App

Mobile

Ruin

That

[17] UI Testing — Android Developers.

http://developer.android.com/tools/testing/
testing_ui.html.
is

broken,

really

http://ﬁleperms.org/whatsapp-is-broken-really-broken/.

[18] Whatsapp

broken.

[19] Layer

8 Linux Security:
mon Users, Developers
http://www.linuxgazette.net/164/kachold.html, July 2009.

OPSEC for Linux Com-
Systems Administrators.

and

[20] Accessibility.

https://www.apple.com/accessibility/resources/,
February 2014.

[21] 107TH CONGRESS. Uniting and strengthening america by pro-
viding appropriate tools required to intercept and obstruct terror-
ism (usa patriot act) act of 2001. Public Law 107-56 (2001).

[22] ACQUISTI, A., AND GROSS, R. Imagined communities: Aware-
ness, information sharing, and privacy on the facebook. In Pri-
vacy enhancing technologies (2006), Springer, pp. 36–58.

[23] BADEN, R., BENDER, A., SPRING, N., BHATTACHARJEE, B.,
AND STARIN, D. Persona: an online social network with user-
deﬁned privacy. In ACM SIGCOMM Computer Communication
Review (2009), vol. 39, ACM, pp. 135–146.

[24] BEATO, F., KOHLWEISS, M., AND WOUTERS, K. Scramble!
In Privacy Enhancing Technologies

your social network data.
(2011), Springer, pp. 211–225.

[25] BELLARE, M., BOLDYREVA, A., AND O’NEILL, A. Determin-
istic and efﬁciently searchable encryption. In CRYPTO (2007),
A. Menezes, Ed., vol. 4622 of Lecture Notes in Computer Sci-
ence, Springer, pp. 535–552.

[26] BERTHOME, P., FECHEROLLE, T., GUILLOTEAU, N., AND LA-
LANDE, J.-F. Repackaging android applications for auditing
access to private data.
In Availability, Reliability and Security
(ARES), 2012 Seventh International Conference on (2012), IEEE,
pp. 388–396.

[27] B ¨OHMER, M., HECHT, B., SCH ¨ONING, J., KR ¨UGER, A., AND
BAUER, G. Falling asleep with angry birds, facebook and kindle:
a large scale study on mobile application usage. In Proceedings
of the 13th international conference on Human computer interac-
tion with mobile devices and services (2011), ACM, pp. 47–56.

[28] BONEH, D., CRESCENZO, G. D., OSTROVSKY, R., AND PER-
SIANO, G. Public key encryption with keyword search. In EU-
ROCRYPT (2004), C. Cachin and J. Camenisch, Eds., vol. 3027
of Lecture Notes in Computer Science, Springer, pp. 506–522.

[29] BORDERS, K., VANDER WEELE, E., LAU, B., AND PRAKASH,
A. Protecting conﬁdential data on personal computers with stor-
age capsules. Ann Arbor 1001 (2009), 48109.

[30] BORISOV, N., GOLDBERG, I., AND BREWER, E. Off-the-record
communication, or, why not to use pgp. In Proceedings of the
2004 ACM workshop on Privacy in the electronic society (2004),
ACM, pp. 77–84.

[31] CHANG, Y.-C., AND MITZENMACHER, M. Privacy preserving
keyword searches on remote encrypted data.
In Applied Cryp-
tography and Network Security, J. Ioannidis, A. Keromytis, and
M. Yung, Eds., vol. 3531 of Lecture Notes in Computer Science.
Springer, 2005, pp. 442–455.

[32] COHEN, W. W. Enron email dataset. http://www.cs.cmu.edu/ en-

ron, August 2009.

[33] CURTMOLA, R., GARAY, J. A., KAMARA, S., AND OSTRO-
VSKY, R. Searchable symmetric encryption: Improved deﬁni-
tions and efﬁcient constructions. In ACM Conference on Com-
puter and Communications Security (2006), A. Juels, R. N.
Wright, and S. D. C. di Vimercati, Eds., ACM, pp. 79–88.

46  23rd USENIX Security Symposium 

USENIX Association

[34] DELTCHEVA,

Apple,

AT&T

R.
issues

protection
http://www.messagingarchitects.com/resources/security-
compliance-news/email-security/apple-att-data-leak-protection-
issues-latest-in-cloud-failures19836720.html, June 2010.

cloud

latest

in

data

leak
failures.

[35] DINGLEDINE, R., MATHEWSON, N., AND SYVERSON, P. Tor:
The second-generation onion router. Tech. rep., DTIC Document,
2004.

[36] DONG, X., CHEN, Z., SIADATI, H., TOPLE, S., SAXENA, P.,
AND LIANG, Z. Protecting sensitive web content from client-
side vulnerabilities with cryptons.
In Proceedings of the 2013
ACM SIGSAC conference on Computer & communications secu-
rity (2013), ACM, pp. 1311–1324.

[37] ELKINS, M. Mime security with pretty good privacy (pgp).

[38] ENCK, W., GILBERT, P., CHUN, B.-G., COX, L. P., JUNG, J.,
MCDANIEL, P., AND SHETH, A. Taintdroid: An information-
ﬂow tracking system for realtime privacy monitoring on smart-
phones. In OSDI (2010), vol. 10, pp. 1–6.

[39] FAHL, S., HARBACH, M., MUDERS, T., BAUMG ¨ARTNER, L.,
FREISLEBEN, B., AND SMITH, M. Why eve and mallory love
android: An analysis of android ssl (in)security. In Proceedings
of the 2012 ACM Conference on Computer and Communications
Security (New York, NY, USA, 2012), CCS ’12, ACM, pp. 50–
61.

[40] FAHL, S., HARBACH, M., MUDERS, T., AND SMITH, M. Trust-
split: usable conﬁdentiality for social network messaging. In Pro-
ceedings of the 23rd ACM conference on Hypertext and social
media (2012), ACM, pp. 145–154.

[41] FARB, M., LIN, Y.-H., KIM, T. H.-J., MCCUNE, J., AND
PERRIG, A. Safeslinger: easy-to-use and secure public-key ex-
change. In Proceedings of the 19th annual international confer-
ence on Mobile computing & networking (2013), ACM, pp. 417–
428.

[42] FAULKNER, L. Beyond the ﬁve-user assumption: Beneﬁts of
increased sample sizes in usability testing. Behavior Research
Methods, Instruments, & Computers 35, 3 (2003), 379–383.

[43] FELDMAN, A. J., BLANKSTEIN, A., FREEDMAN, M. J., AND
FELTEN, E. W. Social networking with frientegrity: privacy and
integrity with an untrusted provider. In Proceedings of the 21st
USENIX conference on Security symposium, Security (2012),
vol. 12.

[44] GOH, E.-J. Secure indexes.

(2003).

IACR Cryptology ePrint Archive

[45] GOLDREICH, O., AND OSTROVSKY, R. Software protection and

simulation on oblivious rams. J. ACM 43, 3 (1996), 431–473.

[46] GUHA, S., TANG, K., AND FRANCIS, P. Noyb: Privacy in on-
In Proceedings of the ﬁrst workshop on

line social networks.
Online social networks (2008), ACM, pp. 49–54.

[47] HENRY,

S.

Largest
history

hacking,
data
launches with

breach
ﬁve

prose-
arrests.

in U.S.

cution
http://www.mercurynews.com/business/ci23730361/largest-
hacking-data-breach-prosecution-u-s-history, July 2013.

[48] JANG, Y., CHUNG, S. P., PAYNE, B. D., AND LEE, W. Gyrus:
A framework for user-intent monitoring of text-based networked
applications. In NDSS (2014).

[49] JEON, J., MICINSKI, K. K., VAUGHAN, J. A., FOGEL, A.,
REDDY, N., FOSTER, J. S., AND MILLSTEIN, T. Dr. android
and mr. hide: ﬁne-grained permissions in android applications.
In Proceedings of the second ACM workshop on Security and pri-
vacy in smartphones and mobile devices (2012), ACM, pp. 3–14.

15

[50] JIANG, X. Gingermaster: First android malware utilizing a root

exploit on android 2.3 (gingerbread).
http://www.csc.ncsu.edu/faculty/jiang/
GingerMaster/.

[51] KAMARA, S., PAPAMANTHOU, C., AND ROEDER, T. Dy-
In Proceedings of the
namic searchable symmetric encryption.
2012 ACM conference on Computer and communications secu-
rity (2012), ACM, pp. 965–976.

[52] KING, S. T., TUCEK, J., COZZIE, A., GRIER, C., JIANG, W.,
AND ZHOU, Y. Designing and implementing malicious hard-
ware.
In Proceedings of the 1st Usenix Workshop on Large-
Scale Exploits and Emergent Threats (Berkeley, CA, USA, 2008),
LEET’08, USENIX Association, pp. 5:1–5:8.

[53] KONTAXIS, G., POLYCHRONAKIS, M., KEROMYTIS, A. D.,
AND MARKATOS, E. P. Privacy-preserving social plugins.
In
Proceedings of the 21st USENIX conference on Security sympo-
sium (2012), USENIX Association, pp. 30–30.

[54] LAU, B., CHUNG, S., SONG, C., JANG, Y., LEE, W., AND
BOLDYREVA, A. Mimesis Aegis: A Mimicry Privacy Shield.
http://hdl.handle.net/1853/52026.

[55] LUCAS, M. M., AND BORISOV, N. Flybynight: mitigating the
privacy risks of social networking.
In Proceedings of the 7th
ACM workshop on Privacy in the electronic society (2008), ACM,
pp. 1–8.

[56] PEEK, D., AND FLINN, J. Trapperkeeper: the case for using vir-
tualization to add type awareness to ﬁle systems. In Proceedings
of the 2nd USENIX conference on Hot topics in storage and ﬁle
systems (2010), USENIX Association, pp. 8–8.

[57] ROESNER, F., KOHNO, T., MOSHCHUK, A., PARNO, B.,
WANG, H. J., AND COWAN, C. User-driven access control: Re-
thinking permission granting in modern operating systems. In Se-
curity and Privacy (SP), 2012 IEEE Symposium on (2012), IEEE,
pp. 224–238.

[58] SHAH, K. Common Mobile App Design Mistakes to Take Care.

http://www.enterprisecioforum.com/en/blogs/kaushalshah/common-
mobile-app-design-mistakes-take-c.

[59] SHENG, S., BRODERICK, L., HYLAND, J., AND KORANDA,
C. Why johnny still can’t encrypt: evaluating the usability of
email encryption software.
In Symposium On Usable Privacy
and Security (2006).

[60] SHNEIDERMAN, B. Designing the User Interface: Strategies
for Effective Human-Computer Interaction, fourth ed. Addison-
Wesley, 2005.

[61] SONG, D. X., WAGNER, D., AND PERRIG, A. Practical tech-
niques for searches on encrypted data. In IEEE Symposium on
Security and Privacy (2000), pp. 44–55.

[62] TSUNOO, Y., SAITO, T., SUZAKI, T., SHIGERI, M., AND
MIYAUCHI, H. Cryptanalysis of des implemented on computers
with cache. In Cryptographic Hardware and Embedded Systems-
CHES 2003. Springer, 2003, pp. 62–76.

[63] US-CERT/NIST. Cve-2013-4787.

http://web.nvd.nist.gov/view/vuln/detail?vulnId=
CVE-2013-4787.

[64] WHITTAKER, S., MATTHEWS, T., CERRUTI, J., BADENES, H.,
AND TANG, J. Am i wasting my time organizing email?: a study
of email reﬁnding. In PART 5——–Proceedings of the 2011 an-
nual conference on Human factors in computing systems (2011),
ACM, pp. 3449–3458.

[65] WHITTEN, A., AND TYGAR, J. D. Why johnny can’t encrypt: A
usability evaluation of pgp 5.0. In Proceedings of the 8th USENIX
Security Symposium (1999), vol. 99, McGraw-Hill.

USENIX Association  

23rd USENIX Security Symposium  47

[66] WOJTCZUK, R., AND TERESHKIN, A. Attacking intel R(cid:31) bios.

Invisible Things Lab (2010).

[67] WU, C., ZHOU, Y., PATEL, K., LIANG, Z., AND JIANG, X.
Airbag: Boosting smartphone resistance to malware infection. In
NDSS (2014).

[68] XU, R., SA¨IDI, H., AND ANDERSON, R. Aurasium: Practi-
cal policy enforcement for android applications. In Proceedings
of the 21st USENIX conference on Security symposium (2012),
USENIX Association, pp. 27–27.

48  23rd USENIX Security Symposium 

USENIX Association

16

