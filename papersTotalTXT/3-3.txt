A Scalable Scheme for Privacy-Preserving

Aggregation of Time-Series Data

Marc Joye and Benoˆıt Libert

Technicolor

975 avenue des Champs Blancs, 35576 Cesson-S´evign´e Cedex, France

{marc.joye,benoit.libert}@technicolor.com

Abstract. Suppose that a set of multiple users uploads in every time
period encrypted values of some data. The considered problem is how an
untrusted data aggregator can compute the sum of all users’ values but
nothing more. A solution was recently given by Shi et al. (NDSS 2011).
However, as advocated by the authors, the proposed encryption scheme
suﬀers from some limitations. In particular, its usage is restricted to small
plaintext spaces. This paper presents a practical scheme which, advanta-
geously, can accommodate large plaintext spaces. Somewhat surprisingly,
it comes with an eﬃcient security reduction, regardless of the number of
users. Furthermore, the proposed scheme requires a minimal number of
interactions, is eﬃcient for both encryption and decryption/aggregation
and can operate in an oﬀ-line/on-line mode.

Keywords: Private aggregation, smart metering, homomorphic encryp-
tion, large data sets.

1

Introduction

A fundamental problem is that of private data analysis where a third party has to
compute some aggregate statistics over some sensitive data held by individuals.
This problem ﬁnds concrete applications in a number of situations. When the
third party, called hereafter aggregator, is trusted an easy solution would be
to ask the users to encrypt their data using the aggregator’s public key. Upon
receiving the ciphertexts the aggregator applies its private key to recover the
data in clear and then compute statistics. The problem becomes much more
challenging in the case of an untrusted aggregator. This is the setting we are
dealing with in this paper.

As an illustrative example, consider the case of smart energy metering (e.g.,
gas, electricity or water). Frequent aggregates of consumption over a popula-
tion of users is very useful to ﬁnely tune the service by adapting the load or
forecasting the supply, which results in better prices. It also reveals useful to
rapidly detect anomalies on the grid in the case of accidental leakage. While
the computation of aggregate statistics is beneﬁcial to the consumers, it may
legitimately raise privacy concerns. Electricity smart meters typically report the
electricity usage every 15 minutes. Such data can be used to infer information

about users’ behaviors (e.g., when they are at home and what they do). Other
examples include collecting medical data for disease monitoring or developing
new drugs, collecting users’ preferences for recommendation systems, etc.

The previous examples clearly highlight the need of allowing users to privately
share their data while at the same time allowing a [non-necessarily trusted]
aggregator to carry out aggregate statistics. Diﬀerent types of statistics can be
computed over private data. Sums and averages are widespread examples.

Privacy-preserving protocols. Several approaches can be found in the literature
(see [19] for a comprehensive survey of these) to address the problem of comput-
ing the sum of time-series data, in a privacy-preserving fashion.1

Borrowing the taxonomy of [19], general privacy-preserving protocols can be

characterized from the following dimensions:

– Aggregate function: This is the function evaluated by the aggregator. In our

case, the function is the sum of the users’ private inputs.

– User synchronization: A protocol is said asynchronous if the users can re-
port their data independently of each other to the aggregator and at any
time. Following the terminology of [19], our protocol is synchronous as we
consider time-series data aggregation and so users should report their data
at approximatively the same time (i.e., the time when aggregation is com-
puted). However, it does not require interaction among users. In that sense,
the protocol we propose in this paper is synchronous yet non-interactive.

– Fault tolerance: This notion captures the capability of coping with failures.
Our basic protocol assumes that there are no failures: all users report their
data. This basic protocol can nevertheless be adapted to support failures;
see [8, 18].

– Communication model: The communication between the users and the ag-
gregator can be unidirectional or bidirectional. The bidirectional setting re-
quires a return channel from the aggregator to the users or among users.
Our protocol merely requires an unidirectional communication link to the
aggregator.

– Privacy notions: There are diﬀerent ﬂavors of privacy. Our protocol provably
achieves the strongest notion of aggregator-obliviousness: The aggregator
learns nothing beyond the output of the aggregate function. See Section 3.
– Aggregate error: The output of the aggregate function can be exact or noisy.
Our basic protocol returns the exact sum of all users’ data. It can however
be modiﬁed to return a noisy sum through diﬀerential-privacy techniques,
similarly to [26].

– Group management: This last notion indicates if the protocol is static or
dynamic. Dynamic protocols allow users to join or leave the group without
requiring a new set-up phase. As described, our protocol is static. Techniques
for dealing with dynamic settings can be found in [8, 18].

1 We note that very eﬃcient solutions are known, based on symmetric-key cryptogra-

phy, in the case of a trusted aggregator. See e.g. [7].

Related work. In [25], Rastogi and Nath suggested that each user encrypts her
private data using an additively homomorphic encryption scheme. The aggre-
gator collects all the ciphertexts, aggregates them to get the encryption of the
aggregate sum and sends this value back to the users. All the users, who possess
each a share of the decryption key, contribute to the decryption of the aggregate
sum by sending their decryption share to the aggregator. The aggregator then
combines all decryption shares received from the users to get in clear the sum
of the users’ private data.

Like other proposals [1, 21, 22], the approach of [25] requires a bidirectional
communication link between the users and the aggregator. Unfortunately a re-
turn channel is not always available. To alleviate this issue, Garcia and Ja-
cobs [16] came up with an aggregation protocol based on homomorphic encryp-
tion and additive secret sharing. Their proposal eliminates the need for a bidi-
rectional channel. On the downside, the communication complexity is quadratic
in the number of users and each user has to compute a linear number of homo-
morphic encryptions.

Independently, Kursawe et al. [20] described four protocols allowing the ag-
gregation of users’ data and comparisons among data aggregates without using
bidirectional channels. Nevertheless, the ﬁrst three protocols incur interaction,
Diﬃe-Hellman key agreements or bilinear map evaluations. They thus require ei-
ther user-to-user communication or somewhat costly arithmetic operations. The
fourth protocol of [20] has low overhead but, like the previous ones, it requires
each user to store the ﬁxed public key of all other users.

Recently, Erkin and Tsudik [14] suggested a diﬀerent technique based on
homomorphic encryption. Their protocols do not use a designated aggregator as
all participants can act as aggregators. As a consequence, the techniques of [14]
require a substantial amount of interaction among users.

say s0 =(cid:80)
ing only on t and on (cid:80)

Back in 2011, Shi, Chan, Rieﬀel, Chow and Song [26] described a completely
non-interactive solution. They astutely suggested to split the aggregator capabil-
ity, viewed as an un-blinding key s0, into additive shares among the set of users,
i si. Each user makes use of her secret share si and blinds her private
data xi,t at time period t with a one-time mask derived from si and t to obtain
a masked value ci,t. At each time period, the aggregator collects all the ci,t’s.
The diﬃculty resides in ﬁnding a scheme such that the aggregation results in
the private data adding together and the masks summing up to a value depend-
i si = s0. Using the un-blinding key s0, the aggregator
can so recover in clear the sum of the users’ private data. Shi et al. [26] gave
a solution that generically works in any prime order group where the Decision
Diﬃe-Hellman (DDH) assumption holds. They also provided a security proof in
a formally deﬁned privacy model. See § 3.2 for a detailed description of their
scheme. The authors however left open a couple of research challenges (cf. [26,
Section 8]). One of them is that of user failure (fault tolerance) and eﬃcient
support of dynamic joins and leaves. Solutions to this problem have been found
in [1, 8, 18].

Among the fault-tolerant systems [1, 8, 18], the construction of ´Acs and Castel-
lucia [1] requires shared keys among all pairs of users, which incurs a linear
storage in the size of the network at each user. Moreover, users should also be
able to receive messages from the aggregator. In a recent work, Jawurek and
Kerschbaum [18] managed to avoid these overheads in a protocol that further
computes weighted sums. On one hand, their protocol allows for an arbitrary
number of missing inputs from users. It also eliminates the need for synchro-
nization among these. On the other hand, it involves distributed key managing
authorities whose task is to jointly decrypt Paillier encryptions during the pro-
tocol. As a result, these key managing authorities have to be involved — and
interact with the user performing the calculation — in each aggregation opera-
tion.

Our contribution. In this paper, we reconsider the fully non-interactive construc-
tion of Shi et al. [26] and show how to get rid of one of its limitations. An im-
portant challenge left open in [26] (and also discussed in [8]) is that of eﬃciently
computing sums over large plaintext spaces. This paper proposes a scheme that
supports large plaintext spaces and number of users. At the same time, the de-
cryption algorithm operates in constant time, regardless of the number of users.
As a bonus, the scheme also provides a great on-line/oﬀ-line eﬃciency: namely,
using pre-computations, the encryptor is left with a mere modular multiplica-
tion in the on-line phase (i.e., when the data to be encrypted is known), which
is highly desirable when computations take place on resource-limited devices.

To achieve this, we follow the research direction suggested in [26], namely
investigating other algebraic settings. The natural candidate is the Paillier cryp-
tosystem [24]. However, the proof given in [26] does not seem to readily extend
to this setting due to technical diﬃculties arising when we want to rely on the
DDH assumption. The main hurdle appears to ﬁnd a way to eﬃciently hash to
a cyclic subgroup of hidden order while remaining able — in order to properly
simulate the adversary’s view in the security proof — to explain hash values as
being obtained by exponentiating the output of a random oracle whose range
has no speciﬁc algebraic structure. While several techniques are known (e.g.,
[5, 17]) to eﬃciently hash onto cyclic groups of public order, this turns out to
be more complicated in DDH-hard groups of hidden order like the subgroup of
squares modulo N or N 2, for some moduli N = pq of unknown factorization.
By trading the DDH assumption for the Decision Composite Residuosity (DCR)
assumption [24], we eliminate the need to hash onto a group of hidden order.
Somewhat surprisingly, we are moreover able to derive a security proof with a
much tighter (i.e., independent of the number of users) reduction in the random
oracle model [2]. This in turn results in better parameters when the scheme is
concretely instantiated.

While practical, our scheme inherits the limitations of [26] in that it does not
allow partial aggregations in the presence of missing contributions. Unlike [21,
22, 18], it does not extend to compute weighted sums and, unlike [22, 18], it
requires synchronization among participants. On the other hand, our system
inherits the main advantage of [26]: the data aggregator can process users’ data

by itself without having to interact with a distributed key-managing authority
at each aggregation. Here, the trusted party that generates the Paillier public
key is never involved in any aggregation and can remain oﬀ-line after the setup
phase. As for its advantages over [1], our construction only requires users to store
O(1) values and does not require a bidirectional channel.

Like [25, 26], the proposed scheme can serve as a building block for the fault-
tolerant solution of [8] while enjoying the beneﬁts of our construction. In fact,
all the extensions of [26] are also possible with our system. In particular, al-
though the focus of this paper is put on the encryption, the proposed scheme
is compatible with the diﬀerential-privacy framework [13, 12]. In this case, the
users simply need to add some appropriately-generated noise to their data prior
to encryption.

Outline of the paper. The rest of this paper is organized as follows. The next sec-
tion introduces some mathematical background and related cryptographic prob-
lems. Section 3 explains what is meant by aggregator obliviousness. Section 4 is
the core of the paper. It presents a new aggregator-oblivious encryption scheme,
a security proof of which is provided in Section 5. Finally, Section 6 discusses
the performance of the proposed scheme and some implementation issues.

2 Preliminaries

In this section we review the necessary background and introduce some notation
used throughout the paper.

2.1 N -th residues and discrete logarithms in (Z/N 2Z)∗
Let p be a prime. Consider the ring Z/p2Z = {0, 1, . . . , p2− 1}. Its multiplicative
group is given by (Z/p2Z)∗ = {x ∈ Z/p2Z | gcd(x, p) = 1}. This group has
p(p−1) elements. Letting ord(x) denote the order of x as an element of (Z/p2Z)∗
(i.e., the smallest nonnegative integer α such that xα ≡ 1 (mod p2)), Lagrange’s
theorem tells that ord(x) divides p(p − 1). In particular, (Z/p2Z)∗ has a p-order
subgroup Γp given by

Γp = {x ∈ (Z/p2Z)∗ | xp ≡ 1

(mod p2)} .

Suppose now that x = 1 + βp with β ∈ {0, . . . , p − 1} — observe that such an x
is in (Z/p2Z)∗ since gcd(1 + βp, p) = 1. Further, the binomial identity yields

1n−k(βt)k ≡

+

βp ≡ 1 + tβp (mod p2) .

(1 + βp)t ≡ t(cid:88)

k=0

(cid:18)t

(cid:19)

k

(cid:18)t

(cid:19)

0

(cid:18)t

(cid:19)

1

Hence, we have (1 + βp)p ≡ 1 (mod p2) and consequently 1 + βp ∈ Γp. From
∼= (Z/pZ)+ (a cyclic group), we also deduce that any element x (cid:54)= 1 ∈ Γp
Γp
generates it. In particular, 1 + p is a generator of Γp. As a result, we get
Γp = {(1 + p)β

(mod p2) | β ∈ {0, . . . , p− 1}} = {1 + βp | β ∈ {0, . . . , p− 1}} .

Let now N = pq where p and q are (distinct) primes. By Chinese remainder-
ing, we can construct the multiplicative group (Z/N 2Z)∗ ∼= (Z/p2Z)∗×(Z/q2Z)∗.
This group has order #(Z/N 2Z)∗ = #(Z/p2Z)∗×#(Z/q2Z)∗ = p(p−1)q(q−1) =
N φ(N ) where φ(N ) = (p − 1)(q − 1) is Euler’s totient function. Similarly, we
can deﬁne ΓN

∼= Γp × Γq with #ΓN = #Γp × #Γq = pq = N as
(mod N 2) | β ∈ {0, . . . , N − 1}}
ΓN = {(1 + N )β

= {1 + βN | β ∈ {0, . . . , N − 1}} .

Again, it is worth noticing that (1 + N )β mod N 2 = 1 + βN ; note also that β
is deﬁned modulo N . This shows that computing discrete logarithms in ΓN is
easy. Namely, given two random elements u, v ∈ ΓN , it is easy to ﬁnd α such
that v = uα (mod N 2):

α =

L(v)
L(u)

mod N where L(x) =

x − 1
N

.

Proof. Since u ∈ ΓN , we have u ≡ 1 (mod N ) and so we can write u = 1 + βN
where β = (u − 1)/N = L(u). Likewise, we can write v = 1 + L(v)N . Since we
have that uα = v, it follows that (1 + L(u)N )α ≡ 1 + L(v)N (mod N 2) ⇐⇒
1+αL(u)N ≡ 1+L(v)N (mod N 2) ⇐⇒ N (αL(u)−L(v)) ≡ 0 (mod N 2). Since
N (αL(u) − L(v)) mod N 2 = N [(αL(u) − L(v)) mod N ], we get αL(u) ≡ L(v)
(cid:117)(cid:116)
(mod N ) and consequently α = L(v)/L(u) mod N .

Another subgroup of (Z/N 2Z)∗ is the group of N -th residues given by

SN = {xN (mod N 2) | x ∈ (Z/N 2Z)∗} .

This subgroup has order φ(N ) and computing discrete logarithms in SN is
as hard as computing discrete logarithms in (Z/NZ)∗ (see [23, 27]). Given two
elements u, v ∈ SN with v = uα (mod N 2) for some α ∈ {0, . . . , φ(N )}, it
turns out that v ≡ uα (mod N ). It is also worth observing that each N -th
residue possesses exactly N roots of order N , of which only one is smaller than
N . Indeed, if y ≡ xN (mod N ) then so is y ≡ (x0 + βN )N (mod N 2) with
x0 := x mod N and β ∈ {0, . . . , N − 1}.

2.2 DCR complexity assumption

We need the following hardness assumption, introduced in [24], which is implied
by the commonly assumed intractability of factoring.

Deﬁnition 1. Let N = pq be a product of two large primes. The Decision Com-
posite Residuosity (DCR) assumption in (Z/N 2Z)∗ is to distinguish among the
following two distributions given only N = pq:

D0 = {xN (mod N 2) | x ∈R (Z/N 2Z)∗}

and D1 = {x ∈R (Z/N 2Z)∗} .

The DCR assumption states that the advantage of any distinguisher D, deﬁned
as the distance

AdvDCR(D) =(cid:12)(cid:12)Pr[D(y, N ) = 1 | y = xN mod N 2, x ∈R (Z/NZ)∗]

− Pr[D(y, N ) = 1 | y ∈R (Z/N 2Z)∗](cid:12)(cid:12)

where probabilities are taken over all coin tosses, is a negligible function.

3 Aggregator-Oblivious Encryption

We start with the deﬁnition and then proceed with the corresponding security
notion. We refer the reader to [26] for further introductory background.

Deﬁnition 2. An aggregator-oblivious encryption scheme is a tuple of algo-
rithms, (Setup, Enc, AggrDec), deﬁned as:

Setup(1κ) On input a security parameter κ, a trusted dealer generates the system
parameters param, the aggregator’s private key sk0, and the private key ski
for each user i (1 ≤ i ≤ n);

Enc(param, ski, xi,t) At time period t, user i encrypts a value xi,t using her pri-

vate encryption key ski to get ci,t = Enc(param, ski, xi,t).

AggrDec(param, sk0, c1,t, . . . , cn,t) At time period t, the aggregator using sk0 ob-

tains Xt =(cid:80)n

i=1 xi,t as Xt = AggrDec(param, sk0, c1,t, . . . , cn,t).

3.1 Aggregator obliviousness

Basically, the security notion of aggregator obliviousness (AO) requires that the
aggregator cannot learn, for each time period, anything more than the aggregate
value Xt from the encrypted values of n (honest) users. If there are corrupted
users (i.e., users sharing their private information with the aggregator), the
notion only requires that the aggregator gets no extra information about the
values of the honest users beyond that their aggregate value. Furthermore, it is
assumed that each user encrypts only one value per time period.

More formally, AO is deﬁned by the following game between a challenger and

an attacker.

Setup The challenger runs the Setup algorithm and gives param to the attacker.
Queries In a ﬁrst phase, the attacker can submit queries that are answered by

the challenger. The attacker can make two types of queries:
1. Encryption queries: The attacker submits (i, t, xi,t) for a fresh 2 pair (i, t)

and gets back the encryption of xi,t under key ski for time period t;

2. Compromise queries: The attacker submits i and receives the private
key ski of user i; if i = 0, the attacker receives the private key of the
aggregator.

2 More precisely, queries like (i, t, xi,t) and (i, t, x(cid:48)
xi,t.

i,t) are not permitted, unless x(cid:48)

i,t =

Challenge In a second phase, the attacker chooses a time period t(cid:63). Let U (cid:63) ⊆
{1, . . . , n} be the whole set of users for which, at the end of the game, no
encryption queries have been made on time period t(cid:63) and no compromise
queries have been made. The attacker chooses of a subset S (cid:63) ⊆ U (cid:63) and two
diﬀerent series of triples

(cid:104)(i, t(cid:63), x(0)

and (cid:104)(i, t(cid:63), x(1)

i,t(cid:63) )(cid:105)i∈S (cid:63) ,

i,t(cid:63) )(cid:105)i∈S (cid:63)
(cid:88)

i∈S (cid:63)

(cid:88)

i∈S (cid:63)

that are given to the challenger. Further, if the aggregator capability sk0 is
compromised at the end of the game and S (cid:63) = U (cid:63), it is required that

x(0)
i,t(cid:63) =

x(1)
i,t(cid:63) .

(1)

Guess The challenger chooses at random a bit b ∈ {0, 1} and returns the en-

cryption of (cid:104)x(b)

i,t(cid:63)(cid:105)i∈S (cid:63) to the attacker.

More queries The attacker can make more encryption and compromise queries.
Outcome At the end of the game, the attacker outputs a bit b(cid:48) and wins the

game if and only if b(cid:48) = b. As usual, A’s advantage is deﬁned to be

AdvAO(A) := | Pr[b(cid:48) = b] − 1/2|.

Remark 1. Note in the “More queries” stage that since S (cid:63) ⊆ U (cid:63), the attacker
cannot submit an encryption query (i, t(cid:63),·) with i ∈ S (cid:63) or a compromise query i
with i ∈ S (cid:63).

Deﬁnition 3. An encryption scheme is said to meet the AO security notion if
no probabilistic polynomial-time attacker can guess correctly in the above game
the bit b with a probability non-negligibly better (in the security parameter) than
1/2. The probability is taken over the random coins of the game according to the
distribution induced by Setup and over the random coins of the attacker.

3.2 Shi et al.’s scheme

In [26], Shi, Chan, Rieﬀel, Chow and Song consider the following encryption
scheme. They show that the scheme meets the AO security notion under the
DDH assumption [4], in the random oracle model.
Setup(1κ) Let a group G of prime order q for which the DDH assumption holds,
and let a random generator g ∈ G. Let also a hash function H : Z →
G viewed as a random oracle. Finally, let n random elements in Z/qZ,

s1, . . . , sn, and deﬁne s0 = −(cid:80)n

i=1 si mod q.
param = {G, g, H}; ski = si (for 0 ≤ i ≤ n).

Enc(param, ski, xi,t) At time period t, for a private input xi,t ∈ Z/qZ, user i

produces

ci,t = gxi,tH(t)si

.

period t by ﬁrst computing Vt := H(t)s0(cid:81)n

AggrDec(param, sk0, c1,t, . . . , cn,t) The aggregator obtains the sum Xt for time
i=1 ci,t = gXt and next the dis-

crete logarithm of Vt w.r.t. basis g.

Remark 2. Since g has order q, note that the so-obtained value for Xt is deﬁned
modulo q.

We see that in the AggrDec algorithm the aggregator has to compute the
value of Xt from Vt = gXt in G. For known groups satisfying Shi et al.’s setting
(i.e., prime-order DDH groups), the most appropriate method is Pollard’s λ
algorithm (or variants thereof) and requires that the range of Xt is small. In the
next section, we present a scheme where the computation of discrete logarithms
can be done eﬃciently without such a restriction on the range, while at the same
time, meeting the AO security notion.

4 New Scheme

Shi et al.’s scheme involves the computation of a discrete logarithm in a prime-
order group for which the DDH assumption holds. We rather consider groups G
of composite order for which there is a subgroup G1 [of unknown order] wherein
some intractability assumption holds and another subgroup G2 wherein discrete
logarithms are easily computable. It is crucial that the order of G1, #G1, is only
known to a trusted dealer. For anyone else (including the aggregator), #G1 must
remain unknown. Merely an upper bound on #G1 can be derived. We present
below a scheme fulﬁlling these requirements.

Setup(1κ) On some input security parameter κ, the trusted dealer randomly
generates a modulus N = pq, which is the product of two equal-size primes
p, q. Note that size condition on p and q implies that gcd(φ(N ), N ) = 1.
It also deﬁnes a hash function H : Z → (Z/N 2Z)∗ that will be viewed
as a random oracle in the security analysis. Letting (cid:96) the bit-length of N ,
from n randomly chosen elements in ±{0, 1}2(cid:96), s1, . . . , sn, it ﬁnally sets s0 =
i=1 si and deﬁnes param = {N, H} as well as ski = si (for 0 ≤ i ≤ n).
Enc(param, ski, xi,t) At time period t, for a private input xi,t ∈ Z/NZ, user i

−(cid:80)n

produces

ci,t = (1 + xi,tN ) · H(t)si mod N 2 .

period t by ﬁrst computing Vt := H(t)s0(cid:81)n

AggrDec(param, sk0, c1,t, . . . , cn,t) The aggregator obtains the sum Xt for time

i=1 ci,t mod N 2 and next Xt as

Xt =

Vt − 1
N

.

The correctness follows by observing that

n(cid:89)

ci,t ≡ n(cid:89)

(1 + xi,tN ) ≡ 1 +(cid:0) n(cid:88)

H(t)s0

xi,t mod N(cid:1)N (mod N 2) .

i=1

i=1

i=1

N =(cid:80)n

Again, observe that the value of Xt is deﬁned modulo N . Hence, if(cid:80)n

i=1 xi,t < N ,
we have Xt = Vt−1
i=1 xi,t over the integers. The main diﬀerence with the
scheme of Shi et al. resides in that there is no discrete logarithm to compute in
a group in which the DDH assumption holds. On the contrary, the recovery of
Xt from the accumulated product, Vt, is now easy. As a result, there is no longer
the restriction on the size of xi,t or on the total number n of users, as long as
i=1 xi,t < N . Typically, N is a 2048-bit value. In practice, there is therefore

(cid:80)n

no restriction.

Another interesting advantage of the scheme over [26] is that it allows ef-
ﬁciently encrypting “on-the-ﬂy” [15]. Namely, exponentiations H(t)si mod N 2
can be pre-computed in such a way that, when the plaintext xi,t is known, the
sender only has to compute a modular multiplication to get ci,t. In applica-
tions to smart metering systems, this advantage may be crucial as computations
usually take place in constrained devices.

One surprising thing about the scheme is its extreme simplicity. Indeed, some-
what unexpectedly, we do not even need to restrict the range of the random
oracle H to, for example, the subgroup of quadratic residues in (Z/N 2Z)∗ or the
subgroup of elements with positive Jacobi symbol modulo N . If H(t) mod N has
Jacobi symbol −1 modulo N , the parity of si is leaked by ci,t. However, as will
be established in Section 5, this does not jeopardize the security of the scheme
as long as the values si mod N remain computationally hidden.

5 Security Proof

Although the scheme is very similar to the construction of Shi et al., its security
analysis is completely diﬀerent (and actually simpler). Albeit taking place in the
random oracle model [2], it bears similarities with the techniques of Cramer and
Shoup [10] (see also [6]) in that it appeals to an information theoretic argument
exploiting some entropy hidden in the private key.

As a result, we obtain a much tighter security reduction than in [26]. Here,
the gap between the DCR distinguisher and the adversary’s advantage is only
proportional to the number of encryption queries. In contrast, the construction
in [26] suﬀers from an additional degradation factor of O(n3), where n is the
number of users in the system, in terms of concrete security. In contrast, our
security bound is completely independent of the number of users.

Theorem 1. The scheme provides AO security under the DCR assumption in
the random oracle model. Namely, for any probabilistic polynomial-time adver-
sary A, there exists a DCR distinguisher B with comparable running time and
such that

AdvAO(A) ≤ e · (qenc + 1) · AdvDCR(B) ,

where qenc is the number of encryption queries and e is the base for the natural
logarithm.

Proof. The proof proceeds with a sequence of three games. The latter begins
with Game 0, which is the real game, and ends with Game 2, where even a

computationally unbounded adversary has no advantage. For each j ∈ {0, 1, 2},
we denote by Sj the event that the challenger B outputs 1 in Game j. We also
deﬁne Adv j = | Pr[Sj] − 1/2|.
In the sequel, we assume w.l.o.g. that the adversary A has always already
queried the random oracle H on the input t before any encryption query for
the time period t. Indeed, the challenger can always enforce this by making
H-queries for itself. For simplicity, we also assume that the adversary does not
query the random oracle more than once for a given t.

R← ±{0, 1}2(cid:96) and deﬁning s0 = −(cid:80)n

Game 0: This is the real game. Namely, the challenger performs the setup of
the system by choosing s1, . . . , sn
i=1 si.
Queries to the random oracle H are answered by returning uniformly ran-
dom elements in (Z/N 2Z)∗. Encryption queries (i, t, xi,t) are answered by
returning the ciphertext ci,t = (1 + xi,tN ) · H(t)si mod N 2. Whenever the
adversary decides to corrupt some player i ∈ {0, . . . , n}, the challenger re-
veals si. In the challenge phase, the adversary chooses a target time period t(cid:63),
an uncorrupted subset S (cid:63) ⊆ U (cid:63) and two distinct series (cid:104)(i, t(cid:63), x(0)
i,t(cid:63) )(cid:105)i∈S (cid:63) ,
i,t(cid:63) )(cid:105)i∈S (cid:63) which must satisfy Equation (1) if S (cid:63) = U (cid:63) and the aggre-
(cid:104)(i, t(cid:63), x(1)
gator’s private key s0 is exposed at some point of the game (cf. § 3.1). At this
stage, the challenger ﬂips a fair binary coin b R← {0, 1} and the adversary A
receives

(cid:8)ci,t(cid:63) = (1 + x(b)

i,t(cid:63) N ) · H(t(cid:63))si mod N 2(cid:9)

i∈S (cid:63) .

We assume that the adversary queries H(t(cid:63)) before the challenge phase.
Otherwise, B can simply make the query for itself. In the second phase, after
a second series of queries, A outputs a bit b(cid:48) ∈ {0, 1}. We let the challenger
B output 1 if b(cid:48) = b and 0 otherwise. The adversary’s advantage in Game 0
is thus Adv0 = | Pr[S0] − 1/2| = AdvAO(A).

Game 1: This game is identical to Game 0 with the following diﬀerence. For
each random oracle query t, the challenger B ﬂips a biased coin δt ∈ {0, 1}
that takes the value 1 with probability 1/(qenc + 1) and the value 0 with
probability qenc/(qenc + 1). At the end of the game, B considers the event E
that either of the following conditions holds:

– For the target time period t(cid:63), the coin δt(cid:63) ﬂipped for the hash query
– There exists a time period t (cid:54)= t(cid:63) such that an encryption query (i, t, .)

H(t(cid:63)) was δt(cid:63) = 0.
was made for some user in i ∈ U (cid:63) but for which δt = 1.

If event E occurs (which B can detect at the end of the game), B halts and
outputs a random bit. Otherwise, it outputs 1 if and only if b(cid:48) = b. The same
analysis as that of Coron [9] shows that Pr[¬E] = 1/e(qenc + 1), where e is
the base for the natural logarithm. The transition from Game 0 to Game 1
is thus a transition based on a failure event of large probability [11] and we
thus have Adv1 = Adv0 · Pr[¬E] = Adv0/e(qenc + 1).

Game 2: In this game, we modify the distribution of random oracle outputs.
Speciﬁcally, the treatment of each hash query t depends on the random coin
δt ∈ {0, 1}.
– If δt = 0, the challenger B chooses a random N -th residue zt = rt

N mod
R← (Z/NZ)∗, and deﬁnes H(t) = zt. Note that the resulting
– If δt = 1, B chooses a uniformly random rt ∈ (Z/N 2Z)∗ and programs

N 2, with rt
hash value H(t) is now a N -th residue in (Z/N 2Z)∗.

H so as to have H(t) = rt.

Lemma 1 below shows that Game 2 and Game 1 are computationally indis-
tinguishable if the DCR assumption holds. It follows that

| Pr[S2] − Pr[S1]| ≤ AdvDCR(B) .

In Game 2, we claim that Pr[S2] = 1/2 so that A has no advantage. Indeed, with
probability 1/e(qenc +1), we have H(t(cid:63)) ∈R (Z/N 2Z)∗ for the target time period
t(cid:63) (for which the challenge ciphertexts {ci,t(cid:63) = (1+N )xi,t(cid:63) ·H(t(cid:63))si mod N 2}i∈S (cid:63)
are generated) whereas, for each t (cid:54)= t(cid:63), the hash value H(t) is uniform in the sub-
group of N -th residues. For each t (cid:54)= t(cid:63), H(t) thus lives in a subgroup whose order
is co-prime with N since gcd(N, φ(N )) = 1. By the Chinese Remainder Theo-
rem, for each i ∈ S (cid:63), the value H(t)si is completely independent of si mod N
when t (cid:54)= t(cid:63). In other words, encryption queries for periods t (cid:54)= t(cid:63) leak no infor-
mation about {si mod N}i∈S (cid:63) . At the same time, for period t(cid:63), {H(t(cid:63))si}i∈S (cid:63)
contain random components of order N which only appear in the challenge ci-
phertexts {ci,t(cid:63) = (1 + N )x(b)
i,t(cid:63) · H(t(cid:63))si mod N 2}i∈S (cid:63) , where they completely
blind {x(b)
A can see. We have the following two mutually exclusive situations.
– If S (cid:63) (cid:40) U (cid:63) or A did not compromise the aggregator, then A has no infor-
i∈S (cid:63) si mod N
remains hidden because there exists θ ∈ (U (cid:63)\{S (cid:63)})∪{0} such that sθ mod N
is completely independent of A’s view. If we consider individual ciphertexts
{ci,t(cid:63)}i∈S (cid:63) and their partial aggregation

mation about {si mod N}i∈S (cid:63) whatsoever. Even the sum (cid:80)

More precisely, let us consider what a computationally unbounded adversary

i,t(cid:63)}i∈S (cid:63) .

(cid:89)

i∈S (cid:63)

cS (cid:63),t(cid:63) =

ci,t(cid:63) mod N 2 ,

(2)

i,t(cid:63) =(cid:80)

have(cid:80)
A obtains about {si mod N}i∈S (cid:63) is the sum(cid:80)

for each value of b ∈ {0, 1}, there exist {si mod N}i∈S (cid:63) that explain the
adversary’s view.
– If S (cid:63) = U (cid:63) and A has obtained s0 by corrupting the aggregator, we must
i=0 si = 0, the only information that
i∈S (cid:63) si mod N , which an all-
powerful adversary can infer via corruption queries or encryption queries
during period t(cid:63). However, if consider the partially aggregated ciphertext
(Eq. (2)), then cφ(N )

S (cid:63),t(cid:63) mod N 2 does not depend on the bit b ∈ {0, 1}.

i,t(cid:63) . Since(cid:80)n

i∈S (cid:63) x(0)

i∈S (cid:63) x(1)

In Game 2, we can only have b(cid:48) = b with probability 1/2. Putting all together,
we therefore ﬁnd

AdvAO(A) ≤ e · (qenc + 1) · AdvDCR(B) ,

which concludes the proof.

(cid:117)(cid:116)

R← ±{0, 1}2(cid:96) and sets s0 = −(cid:80)n

Lemma 1. Under the DCR assumption, Game 2 is computationally indistin-
guishable from Game 1.
Proof. The proof is by contradiction and builds a DCR distinguisher B from an
adversary A that has noticeably diﬀerent behaviors in Game 1 and Game 2.
The reduction B receives as input a pair (N, z) and has to decide whether z =
rN mod N 2, for some r ∈ (Z/NZ)∗, or z ∈R (Z/N 2Z)∗. To this end, B begins by
picking s1, . . . , sn
i=1 si, exactly as the challenger
of Game 1 does. Throughout the game, B always answers encryption queries and
corruption queries faithfully. However, the treatment of random oracle queries
H(t) depends on the value of the biased coin δt ∈ {0, 1}. Namely, when δt = 0,
B uses the random self-reducibility of DCR and builds many instances {zt}t for
the same N out of z.
– If δt = 0, B chooses αt

R← Z/NZ, βt

R← (Z/NZ)∗ and computes zt = zαt ·
N mod N 2. Observe that, if z is a N -th residue (resp. a random element
βt
of (Z/N 2Z)∗), zt is uniformly distributed in the subgroup of N -th residues
modulo N 2 (resp. uniformly distributed in (Z/N 2Z)∗). Then, B programs
the random oracle H to have H(t) = zt.
R← (Z/N 2Z)∗ instead of choosing it among N -th

– If δt = 1, B draws zt

residues. It deﬁnes H(t) = zt.

When A terminates, B outputs a random bit if event E has come about during
the game. Otherwise, B outputs 1 if b(cid:48) = b and 0 otherwise.
Clearly, if z ∈R (Z/N 2Z)∗, A’s view is exactly the same as in Game 1. In
contrast, if z is a N -th residue, B is rather playing Game 2 with the adversary.(cid:117)(cid:116)

6 Concluding Remarks

This paper presented a new scheme allowing an untrusted aggregator to eval-
uate the sum of user’s private inputs. In contrast to prior solutions, there is
no restriction on the message space or on the number of users. This results in
always fast decryption and aggregation, even over large plaintext spaces and/or
population of users.

Our scheme provides many other advantages over prior solutions. One of these
is a much better concrete security in the random oracle model as our bound is
completely independent of the number n of users. In comparison, the security
proof in [26] entails a multiplicative gap proportional to n3 in the reduction

from the DDH assumption. Considering that large values of n such as n ≈ 220
are expectable in practical applications, it seems advisable to increase the key
size accordingly. In our setting, our reduction decreases the security loss to only
30 bits if we allow for qenc = 230, as recommended in the literature [3] (note
that, in this setting, this value should be seen as a rather theoretical bound
since, using a counter, one can always bound qenc to arbitrarily small values
like, e.g., qenc ≤ 3).3

Finally, our scheme makes it possible to encrypt data in oﬀ-line/on-line mode
through the use of coupons: once the message is known, the user only has to
evaluate a single modular multiplication. It is therefore well-suited to low-power
devices that are typically used in applications like smart metering or sensor
networks.

References

1. Gergely ´Acs and Claude Castelluccia. I have a dream! (diﬀerentially private smart
metering). In T. Filler et al., editors, Information Hiding (IH 2011), volume 6958
of Lecture Notes in Computer Science, pages 118–132. Springer, 2011.

2. Mihir Bellare and Phillip Rogaway. Random oracles are practical: A paradigm for
designing eﬃcient protocols. In D. E. Denning et al., editors, 1st ACM Conference
on Computer and Communications Security, pages 399–416. ACM Press, 1993.

3. Mihir Bellare and Phillip Rogaway. The exact security of digital signatures - how
to sign with RSA and Rabin. In U. M. Maurer, editor, Advances in Cryptology
− EUROCRYPT ’96, volume 1070 of Lecture Notes in Computer Science, pages
399–416. Springer, 1996.

4. Dan Boneh. The decision Diﬃe-Hellman problem. In J. Buhler, editor, Algorithmic
Number Theory (ANTS-III), volume 1423 of Lecture Notes in Computer Science,
pages 48–63. Springer, 1998.
5. Dan Boneh, Ben Lynn, and Hovav Shacham. Short signatures from the Weil
pairing. In Advances in Cryptology − ASIACRYPT 2001, volume 2248 of Lecture
Notes in Computer Science, pages 514–532. Springer, 2001.
6. Jan Camenisch and Victor Shoup. Practical veriﬁable encryption and decryption of
discrete logarithms. In D. Boneh, editor, Advances in Cryptology − CRYPTO 2003,
volume 2729 of Lecture Notes in Computer Science, pages 126–144. Springer, 2003.
7. Claude Castelluccia, Aldar C.-F. Chan, Einar Mykletun, and Gene Tsudik. Eﬃ-
cient and provably secure aggregation of encrypted data in wireless sensor networks.
ACM Transactions on Sensor Networks, 5(3), 2009. Article 20.

8. T.-H. Hubert Chan, Elaine Shi, and Dawn Song. Privacy-preserving stream aggre-
gation with fault tolerance. In A. D. Keromytis, editor, Financial Cryptography
and Data Security (FC 2012), volume 7397 of Lecture Notes in Computer Science,
pages 200–214. Springer, 2012.
9. Jean-S´ebastien Coron. On the exact security of full domain hash. In M. Bellare,
editor, Advances in Cryptology − CRYPTO 2000, volume 1880 of Lecture Notes
in Computer Science, pages 229–235. Springer, 2000.

3 The proof in [26] additionally features a degradation factor of qH , where qH is the
number of random oracle queries. We suspect that it can be reduced to qenc using
Coron’s technique [9]. The main limiting factor in [26] is thus the cubic dependence
on n.

10. Ronald Cramer and Victor Shoup. Universal hash proofs and a paradigm for
adaptive chosen ciphertext secure public-key encryption. In L. R. Knudsen, editor,
Advances in Cryptology − EUROCRYPT 2002, volume 2332 of Lecture Notes in
Computer Science, pages 45–64. Springer, 2002.

11. Alexander W. Dent. A note on game-hopping proofs. Cryptology ePrint Archive:

Report 2006/260, 2006.

12. Cynthia Dwork. Diﬀerential privacy: A survey of results. In M. Agrawal et al.,
editors, Theory and Applications of Models of Computation (TAMC 2008), volume
4978 of Lecture Notes in Computer Science, pages 1–19. Springer, 2008.

13. Cynthia Dwork, Krishnaram Kenthapadi, Frank McSherry, Ilya Mironov, and Moni
Naor. Our data, ourselves: Privacy via distributed noise generation. In Advances
in Cryptology − EUROCRYPT 2006, volume 4004 of Lecture Notes in Computer
Science, pages 486–503. Springer, 2006.

14. Zekeriya Erkin and Gene Tsudik. Private computation of spatial and temporal
power consumption with smart meters. In F. Bao, editor, Applied Cryptography
and Network Security (ACNS 2012), volume 7341 of Lecture Notes in Computer
Science, pages 561–577. Springer, 2012.
15. Shimon Even, Oded Goldreich, and Silvio Micali. On-line/oﬀ-line digital schemes.
In G. Brassard, editor, Advances in Cryptology − CRYPTO ’89, volume 435 of
Lecture Notes in Computer Science, pages 263–275. Springer, 1990.

16. Flavio D. Garcia and Bart Jacobs. Privacy-friendly energy-metering via homo-
morphic encryption. In J. Cu´ellar et al., editors, Security and Trust Management
(STM 2010), volume 6710 of Lecture Notes in Computer Science, pages 226–238.
Springer, 2010.
17. Thomas Icart. How to hash into elliptic curves. In S. Halevi, editor, Advances in
Cryptology − CRYPTO 2009, volume 5677 of Lecture Notes in Computer Science,
pages 303–316. Springer, 2009.

18. Marek Jawurek and Florian Kerschbaum. Fault-tolerant privacy-preserving statis-
tics. In S. Fischer-H¨ubner and M. Wright, editors, Privacy Enhancing Technologies
(PETS 2012), volume 7384 of Lecture Notes in Computer Science, pages 221–238.
Springer, 2012.

19. Marek Jawurek, Florian Kerschbaum, and George Danezis. Privacy technologies for
smart grids – A survey of options. Technical Report MSR-TR-2012-119, Microsoft
Research, November 2012.

20. Klaus Kursawe, George Danezis, and Markulf Kohlweiss. Privacy-friendly aggre-
gation for the smart-grid. In S. Fischer-H¨ubner and N. Hopper, editors, Privacy
Enhancing Technologies (PETS 2011), volume 6794 of Lecture Notes in Computer
Science, pages 221–238. Springer, 2011.

21. Fengjun Li, Bo Luo, and Peng Liu. Secure information aggregation for smart grids
using homomorphic encryption. In 2010 First IEEE International Conference on
Smart Grid Communications (SmartGridComm), 2010.

22. Hsiao-Ying Lin, Wen-Guey Tzeng, Shiuan-Tzuo Shen, and Bao-Shuh Paul Lin.
A practical smart metering system supporting privacy preserving billing and load
monitoring. In F. Bao, editor, Applied Cryptography and Network Security (ACNS
2012), volume 7341 of Lecture Notes in Computer Science, pages 544–560. Springer,
2012.

23. Kevin S. McCurley. A key distribution system equivalent to factoring. Journal of

Cryptology, 1(2):95–105, 1988.
24. Pascal Paillier. Public-key cryptosystems based on composite degree residuosity
classes. In J. Stern, editor, Advances in Cryptology − EUROCRYPT ’99, volume
1592 of Lecture Notes in Computer Science, pages 223–238. Springer, 1999.

25. Vibhor Rastogi and Suman Nath. Diﬀerentially private aggregation of dis-
tributed time-series with transformation and encryption.
In A. K. Elmagarmid
and D. Agrawal, editors, 2010 ACM SIGMOD International Conference on Man-
agement of Data (SIGMOD 2010), pages 735–746. ACM Press, 2010.

26. Elaine Shi, T.-H. Hubert Chan, Eleanor G. Rieﬀel, Richard Chow, and Dawn Song.
In Network and Distributed

Privacy-preserving aggregation of time-series data.
System Security Symposium (NDSS 2011). The Internet Society, 2011.

27. Zahava Shmuely. Composite Diﬃe-Hellman public key generating systems hard
to break. Technical Report 356, Israel Institute of Technology, Computer Science
Department, Technion, February 1985.

