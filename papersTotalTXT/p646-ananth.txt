Optimizing Obfuscation:

Avoiding Barrington’s Theorem

†
Prabhanjan Ananth

Department of Computer Science and
Center for Encrypted Functionalities,

UCLA, USA

prabhanjan.va@gmail.com

∗

Yuval Ishai

Department of Computer Science,

Technion, Israel

yuvali@cs.technion.ac.il

Divya Gupta

†

Department of Computer Science and
Center for Encrypted Functionalities,

UCLA, USA

divyag@cs.ucla.edu

†

Amit Sahai

Department of Computer Science and
Center for Encrypted Functionalities,

UCLA, USA

sahai@cs.ucla.edu

ABSTRACT
In this work, we seek to optimize the eﬃciency of secure
general-purpose obfuscation schemes. We focus on the prob-
lem of optimizing the obfuscation of Boolean formulas and
branching programs – this corresponds to optimizing the
“core obfuscator” from the work of Garg, Gentry, Halevi,
Raykova, Sahai, and Waters (FOCS 2013), and all subse-
quent works constructing general-purpose obfuscators. This
core obfuscator builds upon approximate multilinear maps,
where eﬃciency in proposed instantiations is closely tied to
the maximum number of “levels” of multilinearity required.
The most eﬃcient previous construction of a core obfus-
cator, due to Barak, Garg, Kalai, Paneth, and Sahai (Euro-
crypt 2014), required the maximum number of levels of mul-
tilinearity to be O((cid:96)s3.64), where s is the size of the Boolean
formula to be obfuscated, and (cid:96) is the number of input bits to

∗Research supported by the European Union’s Tenth Frame-

work Programme (FP10/2010-2016) under grant agreement
no. 259426 ERC-CaC, ISF grant 1361/10, and BSF grant
2012378. Research done in part while visiting UCLA and
the Center for Encrypted Functionalities.

†Research supported in part from a DARPA/ONR PRO-

CEED award, NSF grants 1228984, 1136174, 1118096, and
1065276, a Xerox Faculty Research Award, a Google Fac-
ulty Research Award, an equipment grant from Intel, and an
Okawa Foundation Research Grant. This material is based
upon work supported by the Defense Advanced Research
Projects Agency through the U.S. Oﬃce of Naval Research
under Contract N00014-11- 1-0389. The views expressed are
those of the author and do not reﬂect the oﬃcial policy or
position of the Department of Defense, the National Science
Foundation, or the U.S. Government.

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’14, November 3–7, 2014, Scottsdale, Arizona, USA.
Copyright 2014 ACM 978-1-4503-2957-6/14/11 ...$15.00.
http://dx.doi.org/10.1145/2660267.2660342 .

the formula. In contrast, our construction only requires the
maximum number of levels of multilinearity to be roughly
(cid:96)s, or only s when considering a keyed family of formulas,
namely a class of functions of the form fz(x) = φ(z, x) where
φ is a formula of size s. This results in signiﬁcant improve-
ments in both the total size of the obfuscation and the run-
ning time of evaluating an obfuscated formula.

Our eﬃciency improvement is obtained by generalizing the
class of branching programs that can be directly obfuscated.
This generalization allows us to achieve a simple simulation
of formulas by branching programs while avoiding the use
of Barrington’s theorem, on which all previous constructions
relied. Furthermore, the ability to directly obfuscate general
branching programs (without bootstrapping) allows us to
eﬃciently apply our construction to natural function classes
that are not known to have polynomial-size formulas.

1.

INTRODUCTION

The goal of general-purpose program obfuscation is to
make an arbitrary computer program “unintelligible” while
preserving its functionality. Obfuscation allows us to achieve
a powerful capability: software that can keep a secret. That
is, software that makes use of secrets to perform its compu-
tations, but with the additional property that these secrets
remain secure even if the code of the software is captured in
its entirety by an adversary. At least as far back as the work
of Diﬃe and Hellman in 1976 [15]1, researchers have contem-
plated applications of general-purpose obfuscation. Indeed,
if secure general-purpose obfuscation could be cryptograph-
ically achieved eﬃciently, the implications to computer se-
curity would be profound [4].

To understand why obfuscation can be so useful, it is in-
structive to contemplate what kinds of secrets we might want
to hide within our software code. An important instance of
such secrets is hiding the existence and nature of rare in-
put/output behavior that our software may exhibit. This
leads to several interesting motivating scenarios:

1Diﬃe and Hellman suggested the use of general-purpose
obfuscation to convert private-key cryptosystems to public-
key cryptosystems.

646• Our software may be a control algorithm that is pro-
grammed to enter a failsafe mode on certain rare and
hard-to-predict inputs. We would not want an adver-
sary that gains access to the code of the control soft-
ware to be able to learn these rare inputs. By securely
obfuscating the control software, the existence of the
failsafe mode itself would be hidden from the adver-
sary.

• We may modify software to introduce such rare in-
put/output behavior to suit our goals. Consider the
problem of software watermarking, where we want to
add an undetectable imprint to our software that we
can later identify. We may do so by modifying the
behavior of our software, so that on several rare and
hard-to-predict inputs, it outputs a watermark code in-
stead of performing its usual computation. An obfus-
cated version of this modiﬁed software would hide the
existence of these imprints, and thereby also prevent
an adversary from removing them unless the adversary
rewrites from scratch almost all of the software.

• So far our examples have dealt with hiding known rare
input/output behavior. But obfuscation could also be
used to hide the existence of unknown and uninten-
tional rare input/output behavior: Consider software
bugs that are particularly resistant to good-faith soft-
ware testing, because the input/output behavior that
is aﬀected by these bugs only arises from inputs that
are rare and hard to predict given only the function-
ality of the software. Then, obfuscation can be used
to hide the existence of such software bugs (and the
vulnerabilities they introduce), even from an attacker
that has the code of the software.

• Finally, turning the previous example around, obfus-
cation can also be used to hide which of these software
bugs are being ﬁxed by a software patch, thereby pre-
venting adversaries from learning vulnerabilities from
software patches and using this knowledge to attack
unpatched software.

As these motivating scenarios illustrate, secure obfusca-
tion would greatly expand the scope of security problems
addressable through cryptographic means. However, eﬃ-
cient and secure obfuscation would also have powerful ap-
plications to data security, speciﬁcally to protecting against
data breaches by low-level insiders. Low-level insiders can
cause data breaches if they go rogue, or if their computing
systems are compromised through theft or malware attack.
As a result, a critical problem arises when such insiders hold
decryption keys – indeed even low-level insiders may need
such keys to perform basic functions. For example, an em-
ployee tasked with generating summaries of ﬁnancial statis-
tics may need decryption keys in order to decrypt sensitive
ﬁnancial spreadsheets. If this decryption key is captured by
an adversary, however, it can be used to steal vast quan-
tities of sensitive information, even though the decryption
key was only meant to allow the insider to generate low-
value statistical summaries. Obfuscation, however, provides
a powerful solution to this problem: The decryption keys
can be safely hidden within the statistical summary genera-
tion software that is entrusted to the low-level insider. Then,
even if the insider turns rogue, the only power he can derive

from his software is the ability to generate statistics2; he
cannot abuse his position to directly decrypt the underlying
ﬁnancial ﬁles.

The above examples provide only a fractional view of the
applicability that eﬃcient secure obfuscation would have to
computer security. However, until 2013, even heuristic con-
structions for secure general-purpose obfuscation were not
known.

This changed with the work of Garg, Gentry, Halevi, Ray-
kova, Sahai, and Waters [18], which gave the ﬁrst candidate
cryptographic construction for a general-purpose obfuscator.
Formal exploration of the applications of general-purpose
obfuscation began shortly thereafter [18, 30]. Since then,
the ﬂoodgates have opened, and many new applications of
general-purpose obfuscation have been explored (see [1] for
a detailed list of recent works).

Eﬃciency of General-Purpose Obfuscation. This great
interest in the utility of obfuscation leads to a natural and
pressing goal: to improve the eﬃciency of general-purpose
obfuscation. Up to this point, the simplest and most eﬃ-
cient proposed general-purpose obfuscator was given by [3],
building upon [18, 8]. However, the general-purpose obfus-
cator presented in [3] (see below for more details) remains
extremely ineﬃcient.

Our work aims to initiate a systematic research program
into improving the eﬃciency of general-purpose obfuscation.
Tackling this important problem will no doubt be the sub-
ject of many research papers to come. We begin by recall-
ing the two-stage approach to general-purpose obfuscation
outlined in [18] and present in all subsequent work on con-
structing general-purpose obfuscators:

1. At the heart of their construction is the “core obfus-
cator” for Boolean formulas (equivalently, NC1 cir-
cuits), building upon a simpliﬁed subset of the Ap-
proximate Multilinear Maps framework of Garg, Gen-
try, and Halevi [17] that they call Multilinear Jigsaw
Puzzles. (We will defer discussion of security to later.)

2. Next, a way to bootstrap from the core obfuscator for
Boolean formulas to general circuits is used. The works
of [18, 8, 3] all adopt a method for bootstrapping us-
ing Fully Homomorphic Encryption. This bootstrap-
ping method works provably with the security deﬁni-
tion of indistinguishability obfuscation, and can rely
on well-studied cryptographic assumptions such as the
LWE assumption. Alternatively, the earlier work of
Goyal et al. [20] constructed a universal stateless hard-
ware token for obfuscation that can be implemented by
polynomial-size boolean formulas using a pseudoran-
dom function in NC1. Applebaum [2] gives a simpler
alternative construction that has the disadvantage of
requiring the size of the Boolean formulas to be poly-
nomial in the input size and the security parameter
(rather than only in the security parameter in [20]).
Using either of these alternative approaches [20, 2],
however, requires an ad-hoc (but arguably plausible)
assumption to bootstrap from obfuscation for Boolean
formulas to obfuscation for general circuits.

2Of course, the statistical software itself must be carefully
written to avoid vulnerabilities that allow a user to extract
speciﬁc sensitive information by making unexpected statis-
tical queries.

647Our work focuses on improving the eﬃciency of the ﬁrst of
these steps: namely, the core obfuscator for Boolean formu-
las. We give one set of results for the setting of boolean
formulas over the {and, not, or}-basis, and another set of
results for general basis.

Previous constructions of a core obfuscator [18, 8, 3] ﬁrst
apply Barrington’s theorem [5] to convert the Boolean for-
mula into an equivalent “matrix branching program,” which
is then obfuscated. Roughly speaking, a matrix branching
program computes an iterated product of n full-rank matri-
ces, where each matrix in the product is determined by one
of the input bits, and the result of the product should be
either the identity matrix (corresponding to an output of 1)
or some other ﬁxed full-rank matrix (corresponding to an
output of 0). The length of the program is n and its width
is the matrix dimension.

For any circuit or formula of depth d, Barrington’s the-
orem gives a constant-width matrix branching program of
length 4d. Since the length is exponential in the formula
depth, it is crucial to balance the depth of the formula in
order to avoid the exponential blowup. Hence, the ﬁrst step
would be to balance the formula to get a depth which is loga-
rithmic in the size and then apply Barrington’s theorem. For
general formulas of size s, the best known depth obtained
by balancing them is 1.73 log s + d0 by Khrapchenko [22,
21] where d0 is a constant. However, the constant d0 is
quite large, which can have an adverse eﬀect on concrete
eﬃciency.3
Instead, one can balance the formula using a
method by Preparata and Muller [29]. The depth of the bal-
anced formula obtained by this method is 1.82 log s. There
have been other works which try to optimize the size of bal-
anced formulas [7], but the depth of the formula obtained
by these works is worse.

The matrix branching program obtained by applying Bar-
rington’s theorem to a formula of depth 1.82 log s has length
s3.64. This is a major source of ineﬃciency. In particular,
the bound of s3.64 on the length of the branching program
not only aﬀects the number of elements given out as the ﬁnal
obfuscation, but also the number of levels of multilinearity
required by the scheme. Since the size of each multilinear
encoding grows with the number of levels of multilinearity
required in known realizations of approximate multilinear
maps [17, 13], this greatly aﬀects the size of the ﬁnal ob-
fuscated program and also the evaluation time. Hence, in
order to optimize the size of obfuscation it is critical to ﬁnd
an alternative approach.

Our Contributions. In our work, we posit an alternative
strategy for obfuscation that avoids Barrington’s theorem,
as well as the need to balance Boolean formulas at all. In
fact, this strategy can be eﬃciently applied to general (de-
terministic or even non-deterministic) branching programs,
which are not known to be simulated by polynomial-size
formulas. Our strategy employs variants of randomization
techniques that were used in the context of secure multi-
party computation [16, 14], adapting them to the setting of
obfuscation.

A crucial ﬁrst step is to formulate a notion of a “relaxed
matrix branching program” (RMBP) which relaxes some
of the requirements of matrix branching programs needed

3Note that once we apply Barrington’s theorem, d0 goes into
the exponent and hence the size of the resulting obfuscation
scheme will incur a factor of 4d0 .

in [18, 8, 3]. The relaxation replaces permutation matrices
by general full-rank matrices over a ﬁnite ﬁeld and, more
importantly, determines the output by testing whether some
ﬁxed entry in the matrix product is nonzero. (See Section 2.3
for a formal deﬁnition.) We show how to adapt the construc-
tion and security proofs of [3] to work with RMBPs. The
eﬃciency of this obfuscation will be discussed in more de-
tail below. Roughly speaking, given the eﬃciency of current
candidate multilinear encodings, the complexity of obfuscat-
ing RMBPs grows quadratically with the width and cubicly
with the length. For now, we will measure eﬃciency in terms
of the length and width of the RMBP.

Armed with the ability to obfuscate RMBPs, we look for
simple and eﬃcient ways to convert Boolean formulas and
traditional types of branching programs into RMBPs with-
out invoking Barrington’s theorem. For this, we can use a
previous transformation implicit in [16] towards converting
any ordinary graph-based non-deterministic branching pro-
gram4 of size s into an RMBP of length s and width 2(s+1).
We also provide more eﬃcient variants of this transforma-
tion that apply to classes of layered branching programs that
satisfy certain technical conditions and arise in natural ap-
plications.

The above is already enough for eﬃciently obfuscating
functions that are represented by small branching programs.
However, in many cases functions are more naturally repre-
sented by Boolean formulas. In order to eﬃciently obfuscate
formulas, we turn to the (abundant) literature on simulating
formulas by branching programs.
In the case of formulas
consisting of only and, or, and not gates, we can use a
simple transformation of any such formula of size s into a
branching program of the same size (cf. Theorem 6 in [26]
and Appendix B).

The above simple transformation is limited in that it does
not directly apply to formulas with xor gates, and even
without such gates its eﬃciency leaves much to be desired.
Concretely, a formula of size s is transformed into an RMBP
whose length and width are roughly s and 2s, respectively,
leading to a total of O(s3) matrix elements. To get around
both limitations we rely on the work of Giel [19], which
builds on previous results of [7, 12] to eﬃciently transform a
formula over the full basis to a layered branching program of
constant width. The layered branching program described
in [19] satisﬁes our conditions and can be used to obfus-
cate formulas over the full set of binary gates. Concretely,
a formula of size s can be transformed into an RMBP of
length O(s1+), for an arbitrarily small constant  > 0, and
constant width (depending only on ).

As in previous obfuscation techniques [18, 8, 3], a di-
rect application of the above methods reveals the order in
which input variables are read. Thus, to obfuscate a class of
branching programs or formulas which may read the inputs
in a varying order, we (as well as previous works) need to
apply an additional step to make the RMBP family input-
oblivious. This incurs an additional multiplicative overhead
of (cid:96) to the length. However, this step and the resulting
overhead can be avoided when the RMBP family is already

4A non-deterministic branching program is a standard com-
putational model that corresponds to non-deterministic log-
arithmic space. Such branching programs are believed to
be strictly stronger than deterministic branching programs
and formulas (see below) and strictly weaker than general
circuits. See Section 2.2 for a formal deﬁnition.

648input-oblivious. This is guaranteed in the useful case of ob-
fuscating a class of keyed functions, namely a class of func-
tions of the form fz(x) = φ(z, x) where φ is a publicly known
branching program or formula of size s.
In other words,
the goal is to obfuscate the class φ(z,·) to hide the key z.
In this case, an RMBP for φ can be easily turned into an
input-oblivious family of RMBPs for the class fz with no
additional overhead.

Eﬃciency comparison. We now quantify the eﬃciency
improvements we obtain over previous work; we will do so
both asymptotically and with explicit numbers through ex-
amples. The eﬃciency of our obfuscation scheme can be
compared to previous ones by considering (1) the level κ of
the multilinear encoding being employed, and (2) the num-
ber S of encoded ﬁeld elements. The parameter κ is of spe-
cial importance, as the bit-length of each encoded element
in current multilinear encoding candidates [17, 13] grows
quadratically with κ. Thus, a good estimate for the total
size (in bits) of an obfuscated program is ˜O(κ2 · S), where
˜O hides a multiplicative factor which depends polynomially
on the security parameter. Moreover, our constructions (as
well as previous ones) can be implemented so that the run-
ning time required for evaluating the obfuscated program is
quasi-linear in the obfuscation size. Thus, from here on we
will not explicitly refer to the asymptotic running time.

The concrete cost of implementing optimized multilin-
ear encoding candidates is a subject of much ongoing re-
search [13, 24, 25], and as of the time of this writing, explicit
running time and size estimates for multilinear candidates
optimized for obfuscation5 are not available for the κ values
that we need. However, as research in this direction is still
in its infancy, it is reasonable to expect major improvements
in the near future. For this reason, we do not attempt to
provide real-life running time estimates, but rather compare
our constructions with previous ones by considering the pa-
rameters κ and S described above.

The obfuscation methods from [18, 8, 3], when applied to
a (strict) matrix branching program of length n and width
w (one whose evaluation involves the product of n matri-
ces of size w × w) requires κ = n levels of multilinearity
and S = w2n encoded elements. The same holds for our
method when applied to an RMBP of length n and width
w. Our simple and direct transformation for a (keyed) for-
mula of size s over the standard basis yields an RMBP of
length n ≈ s and width w ≈ 2s. This should be com-
pared with the previous Barrington-based solution combined
with the best known formula balancing results, leading to a
matrix branching program with parameters n = O(s3.64)
and w = O(1). Thus, under the quadratic cost assump-
tion mentioned above, the obfuscation size is improved from
˜O(κ2 · S) = ˜O(s10.92) to ˜O(s5).
(For the case of a com-
pletely balanced formula, the obfuscation size of the previ-
ous method is reduced to ˜O(s6).) By further applying the
result from [19], we can obfuscate formulas over a full basis
while reducing the total size to ˜O(s3(1+)). See Table 1 for
a detailed summary of old and new results for obfuscating
formulas.
5We note that obfuscation only requires Multilinear Jigsaw
Puzzles [18], a strict subset of the full multilinear map func-
tionality, which allows for substantial eﬃciency improve-
ments in implementations. However, as of this writing, no
experimental study of Multilinear Jigsaw Puzzle implemen-
tations has been completed.

We note that even if future implementations of multilin-
ear maps achieve an encoding size that only grows linearly
with κ, our results would still yield signiﬁcant improvements.
(An encoding size that grows sublinearly with κ seems out
of reach with current lattice-based methods, due to error
growth.)

Finally, to the best of our knowledge, it is not known
how to simulate general branching programs (even deter-
ministic ones) by strict (i.e., non-relaxed) matrix branching
programs with a polynomial overhead. Thus, for the pur-
pose of obfuscating branching programs without the use of
bootstrapping, our method provides a super-polynomial ef-
ﬁciency improvement over previous core obfuscators. See
Table 2 for a detailed summary of old and new results for
obfuscating branching programs.

Examples. We illustrate our concrete eﬃciency gains by
two examples. The ﬁrst example is motivated by the goal of
obfuscating a psudorandom function (PRF) and deals with
a conjectural PRF. As discussed above, PRFs can be used to
bootstrap general obfuscation [20, 2]. While practical PRF
candidates such as AES are not known to have small formu-
las or branching programs, it seems plausible that there are
good PRF candidates with relatively small formulas or lay-
ered non-deterministic branching programs. Suppose that a
PRF family fz : {0, 1}100 → {0, 1} can be implemented by
a layered, invertible non-deterministic branching program
of length 300 and width 30 (see Section 2.2 for deﬁnition).
Obfuscating such a PRF family using our methods would
require roughly 270,000 encoded ﬁeld elements, with multi-
linearity κ ≈ 300. In contrast, obfuscating such a PRF with
previous approaches would require one to decide reachabil-
ity in a layered graph of length 300 and width 30. The latter
can be done using at least (cid:100)log2 300(cid:101) = 9 levels of recursion,
each implemented by a circuit of depth 6, leading to a circuit
of at least depth 54. Thus, a direct use of the Barrington-
based approach would require using κ > 2100 levels, which
is infeasible. We pose the design and analysis of such an
“obfuscation-friendly” PRF as a major open question that is
motivated by our work.

As another example, consider the task of obfuscating a
“fuzzy match” functionality, deﬁned by a Hamming ball of
radius r around a secret point z ∈ {0, 1}n. That is, the
obfuscated function fz(x) evaluates to 1 if the Hamming
distance between x and z is at most r, and evaluates to 0
otherwise. Functions from this class can be implemented
by (input-oblivious, special) layered branching programs of
width r + 1 and length n, leading to an obfuscation that
contains roughly 4r2n encoded elements with multilinearity
κ ≈ n. For the case n = 100 and r = 20, we get an obfus-
cation that consists of roughly 160,000 encoded elements,
with multilinearity κ ≈ 100. In contrast, representing such
functions by formulas or low-depth circuits, which is essen-
tially equivalent to computing the (n, r)-threshold function,
leads to a best known formula size s > n4.4 and circuit
depth d > 4.9 log2 n [28, 32], which in turn require κ > 1019
levels of multilinearity using previous obfuscation methods.
Thus in this concrete example, our improvement just to the
level of multilinearity κ is over 1017; the improvement in the
overall running time and size would be even greater.

Security. While improving security of obfuscation is not
the focus of this work, our work on improving eﬃciency of
obfuscation would be meaningless if it sacriﬁced security.

649Table 1: Comparing the eﬃciency of obfuscation schemes for
keyed formulas over diﬀerent bases. We use ˜O to suppress
the multiplicative polynomial dependence on the security
parameter and other poly-logarithmic terms and O to sup-
press multiplicative constants which depend on . Here s is
the formula size,  > 0 is an arbitrarily small constant, and
φ is a constant such that for κ-level multilinear encodings,
the size of each encoding is ˜O(κφ). The current best known
constructions have φ = 2. Evaluation time is given in the
form a · b, where a denotes the number of multilinear oper-
ations (up to lower order additive terms) and b denotes the
time for carrying out one multilinear operation.

Work

[3] + [29]

(previous work)

{and, or, not}-basis
This work (direct)
{and, or, not}-basis

This work + [19]
any complete basis

Levels of

Size of Obfuscation/

Multilinearity

Evaluation Time

O(s3.64)

O(s3.64) · ˜O((s3.64)φ)

s

4s3 · ˜O(sφ)

O(s1+)

O(s(1+)) · ˜O((s(1+))φ)

Table 2: Comparing the eﬃciency of obfuscation schemes
for keyed non-deterministic branching programs and special
layered branching programs, as deﬁned in Section 2.2. For a
general branching program, s denotes the size of the branch-
ing program. For a layered branching program, n is the
length and w is the width. Other notation is as in Table 1.

Work

Levels of

Multilinearity

Previous work (general)

sO(log s)

This work (general)

s

Previous work (layered)

nO(log w)

This work (layered)

n

Size of Obfuscation/

Evaluation Time
sO(log s) · ˜O(sO(log s))

4s3 · ˜O(sφ)

nO(log w) · ˜O(nO(log w))

4nw2 · ˜O(nφ)

We give evidence for the security of our constructions in
the same way that the work of [3] does: by showing that
our constructions unconditionally achieve a strong virtual
black-box notion of security [4], against adversaries that
are limited to algebraic attacks allowed in a generic mul-
tilinear model.
In fact, our obfuscators are information-
theoretically secure against query-bounded adversaries in
this generic model. We note that our work actually pro-
vides a new feasibility result in the generic multilinear model,
namely an information-theoretic (and unconditional) obfus-
cation for non-deterministic branching programs which cap-
ture the complexity class NL. This should be compared to
previous results in the same model, which only eﬃciently
apply to formulas (or the complexity class NC1).

As in the case of [3], our security proof in the generic
model can be interpreted in two natural ways: (1) Our proof
can be viewed as evidence of virtual black-box security for
practical applications, in a similar spirit to proofs of secu-
rity in the random oracle model [6]. It is important to note
that analogous to known attacks on contrived schemes in
the random oracle model (e.g. [11]), there are known attacks
to virtual black-box security for obfuscating quite contrived
functionalities [4]. However, no attacks are known for virtual

black-box obfuscation for obfuscating practical functionali-
ties. (2) Our proof can also be viewed as evidence that our
obfuscator achieves the notion of indistinguishability obfus-
cation [4], which is a deﬁnition of security of obfuscation
that does not suﬀer from any known attacks even for con-
trived functionalities, but which nevertheless has proven to
be quite useful.

Organization.
In Section 2 we deﬁne virtual black box
obfuscation and various notions of branching programs rele-
vant to our construction. Then in Section 3 we give a general
transformation from a branching program to a relaxed ma-
trix branching program (RMBP). For completion, we show
the transformation from formulae to branching programs
in Appendix B. The next step is randomization of these
RMBPs which is described in Section 4. Finally, we con-
struct an obfuscation scheme by showing how to encode the
elements in the randomized RMBP using ideal multilinear
encodings (deﬁned in Section 5) and the concept of strad-
dling sets (deﬁned in Section 6). The construction of the
obfuscation scheme is described in Section 7.
2. PRELIMINARIES
We denote the security parameter by λ. We use [n] to denote
the set {1, . . . , n}.
2.1 “Virtual Black-Box" Obfuscation in an Ide-
Let M be some oracle. Below we deﬁne “Virtual Black-
Box” obfuscation in the M-idealized model taken verbatim
from [3]. In this model, both the obfuscator and the eval-
uator have access to the oracle M. However, the function
family that is being obfuscated does not have access to M.
Definition 1. For a (possibly randomized) oracle M, and
(cid:96)∈N, we say that a uniform PPT oracle
(cid:96)∈N
in the M-idealized model, if the following conditions are sat-
isﬁed:

a circuit class (cid:8)C(cid:96)
machine O is a “Virtual Black-Box” Obfuscator for(cid:8)C(cid:96)

alized Model

(cid:9)

(cid:9)

• Functionality: For every (cid:96) ∈ N, every C ∈ C(cid:96), every

input x to C, and for every possible coins for M:

Pr[(OM

(C))(x) (cid:54)= C(x)] ≤ negl(|C|) ,

where the probability is over the coins of C.

• Polynomial Slowdown: There exist a polynomial p such
that for every (cid:96) ∈ N and every C ∈ C(cid:96), we have that
|OM(C)| ≤ p(|C|).

• Virtual Black-Box: For every PPT adversary A there
exist a PPT simulator Sim, and a negligible function µ
such that for all PPT distinguishers D, for every (cid:96) ∈ N
and every C ∈ C(cid:96):

(cid:12)(cid:12) Pr[D(AM

(OM

(C))) = 1]−

)) = 1](cid:12)(cid:12) ≤ µ(|C|) ,

Pr[D(SimC (1

|C|

where the probabilities are over the coins of D,A,Sim,O
and M.

Note that in this model, both the obfuscator and the eval-
uator have access to the oracle M but the function family
that is being obfuscated does not have access to M.

For deﬁnition of Boolean formulas see Appendix A. Next,

we describe branching programs.

6502.2 Branching Programs

In this section we deﬁne a non-deterministic branching
program, and several types of layered branching programs
that are useful for our purpose.

A non-deterministic branching program (BP) is a ﬁnite
directed acyclic graph with two special nodes, a source node
and a sink node, also referred to as an “accept” node. Each
non-sink node is labeled with a variable xi and can have ar-
bitrary out-degree. 6 Each of the out-edges is either labeled
with xi = 0 or xi = 1. The sink node has out-degree 0. In
the following, we denote a branching program by BP and
denote the restriction of the branching program consistent
with input x by BP|x. An input x ∈ {0, 1}(cid:96) is accepted if
and only if there is a path from the source node to the ac-
cept node in BP|x. Note that an input can have multiple
computation paths in BP|x. The length of the BP is the
maximum length of any such path in the graph. The size
s of the branching program is the total number of non-sink
nodes in the graph, i.e., total number of nodes minus 1.

A layered branching program is a branching program such
that nodes can be partitioned into a sequence of layers where
all the nodes in one layer are labeled with the same variable
and edges go only from nodes of one layer to the next. We
can assume without loss of generality that the ﬁrst layer
contains the source node and the last layer contains the sink
node. The length n of a layered branching program is the
number of layers minus 1 and its width w is the maximum
number of nodes in any layer. It will be convenient to assume
that a layered BP has exactly w nodes in each layer. We
denote the kth node in layer i by vi,k for 0 ≤ i ≤ n and
k ∈ [w].

The following nonstandard types of branching programs
will be useful for our purposes. A special layered branching
program is a layered branching program with the following
additional property. For each layer i, 0 ≤ i < n, and each
k ∈ [w], there is an edge from vi,k to vi+1,k labeled by both
0 and 1 (namely, this edge is consistent with all inputs).
Finally, we deﬁne an invertible layered branching program
as follows. Corresponding to each i ∈ [n], we deﬁne two
w × w matrices Bi,0 and Bi,1 as follows: Bi,b[x, y] = 1 if
and only if there is an edge from node vi−1,x to node vi,y
labeled with b. Otherwise, Bi,b[x, y] = 0. We say that the
layered branching program is invertible if Bi,b is full rank
for all i ∈ [n] and b ∈ {0, 1}.
2.3 Relaxed Matrix Branching Programs

In this section we deﬁne the original notion of matrix
branching programs used in [18] followed by our notion of
relaxed matrix branching programs.

Definition 2

(Matrix Branching Program (MBP)).

[3] A matrix branching program of width w and length n for
(cid:96)-bit inputs is given by a w × w permutation matrix Preject
such that Preject (cid:54)= Iw×w and by a sequence:
BP = (inp, Bi,0, Bi,1)i∈[n],

where Bi,b, for i ∈ [n], b ∈ {0, 1}, are w × w permutation
matrices and inp : [n] → [(cid:96)] is the evaluation function of BP.
The output of BP on input x ∈ {0, 1}(cid:96), denoted by BP(x), is
6We assume for simplicity that the out-degree is bound by
some ﬁxed constant (say 4), so that the total number of
paths is bounded by 2O(s) as opposed to ss.

determined as follows:



1 if

0 if
⊥

n(cid:81)
n(cid:81)

i=1

Bi,xinp(i) = Iw×w

Bi,xinp(i) = Preject

i=1
otherwise

BP(x) =

We say that a family of MBPs are input-oblivious if all
programs in the family share the same parameters w, n, (cid:96) and
the evaluation function inp.

Barrington [5] showed that every circuit with depth d and
fan-in 2 can be represented by a MBP of length at most
4d and width 5. Previous works [18, 8, 3] used MBPs ob-
tained by applying Barrington’s theorem to obfuscate cir-
cuits. Since the MBP obtained has length exponential in
the depth of the circuit, this turns out to be a bottleneck for
eﬃciency. In this work, we will use relaxed MBPs towards
obfuscation.

In MBP after evaluation we either get Iw×w or Preject which
decides the output. We relax this requirement as follows.
We only require that a single designated entry in the ﬁnal
product is either 0 or non-zero depending on the output and
place no restriction on other entries. Note that this is a
further relaxation of the notion considered in [27]. More
formally, we deﬁne the notion of relaxed matrix branching
programs as follows.

Definition 3

(Relaxed MBP (RMBP)). Let R be any

ﬁnite ring. A relaxed matrix branching program (over R) of
size w and length n for (cid:96)-bit inputs is given by a sequence:

BP = (inp, Bi,0, Bi,1)i∈[n],

where each Bi,b is a w × w full-rank, i.e. invertible, matrix
and inp : [n] → [(cid:96)] is the evaluation function of BP. The
output of BP on input x ∈ {0, 1}(cid:96), denoted by BP(x), is
determined as follows:

(cid:16) n(cid:89)

(cid:17)

Bi,xinp(i)

[1, w] (cid:54)= 0

BP(x) = 1 if and only if

i=1

Dual-input Relaxed Matrix Branching Programs. Sim-
ilar to [3], for the proof of obfuscation we would need to
consider dual input matrix branching programs. We deﬁne
dual input RMBP as follows.

Definition 4

(Dual Input RMBP). Let R be a ﬁnite
ring. A dual-input relaxed matrix branching program (over
R) of size w and length n for (cid:96)-bit inputs is given by a se-
quence:

BP = (inp1, inp2, Bi,b1,b2 )i∈[n],b1,b2∈{0,1},

where each Bi,b1,b2 is a w×w full-rank matrix and inp1, inp2 :
[n] → [(cid:96)] are the evaluation functions of BP. The output of
BP on input x ∈ {0, 1}(cid:96), denoted by BP(x), is determined
as follows:

(cid:16) n(cid:89)

(cid:17)

[1, w] (cid:54)= 0

BP(x) = 1 if and only if

Bi,xinp1(i),xinp2(i)

i=1

We say that a family of matrix branching programs is
input-oblivious if all programs in the family share the same
parameters w, n, (cid:96) and the evaluation functions inp1, inp2.

For the purpose of obfuscation we would consider dual

input oblivious relaxed matrix branching programs.

6513. FROM BP TO RELAXED MATRIX BP

In this section we describe a sequence of transformations
which allow us to transform a non-deterministic branching
program of size s to a relaxed matrix branching program
of width 2(s + 1) and length s. These transformations are
close variants of similar transformations from [16]. The main
steps are to convert a non-deterministic branching program
to a special layered branching program, then to an invertible
layered branching program, and ﬁnally to an RMBP. These
intermediate steps can be independently useful, as they al-
low for more eﬃcient transformations of special or invertible
layered branching programs into RMBPs.

Branching program to special layered branching pro-
gram.

Lemma 1. Any non-deterministic branching program BP
of size s can be eﬃciently converted to an equivalent special
layered branching program SLBP of length s and width s + 1.

Proof Sketch. Recall that since we do not include the sink
node in the size of a BP, a BP of size s has s + 1 nodes.
Given a branching program with s + 1 nodes, ﬁrst do a
topological sort of the nodes, say {v1, . . . , vs+1}. Without
loss of generality, assume that v1 is the source node and vs+1
is the sink node. We construct a special layered branching
program with s+1 layers where each layer has s+1 nodes as
follows. Let the nodes in layer i be {vi,1, . . . , vi,s+1}. That
is, we denote kth node in layer i by vi,k. For each 0 ≤ i < s
we do the following: Let node vi+1 be labeled with xj in
original BP. Then, we label layer i with xj. We draw the
outgoing edges from node vi,i+1 to node vi+1,k if there was
an edge from vi+1 to vk in the original BP. Labels on the
edges are retained. Now, we also add edges between vi,k to
vi+1,k for all k ∈ [s + 1] for both xj = 0 and xj = 1.

It is easy to see that there is a path between source, i.e.,
v1 to the accept node, i.e., vs in the original branching pro-
gram if and only if there is a path from v0,1 to vs,s+1.

Special layered branching program to an invertible
layered branching program.

Lemma 2. Any special layered branching program SLBP
of length n and width w can be eﬃciently converted to an
equivalent invertible layered branching program ILBP of length
n and width 2w.
Proof Sketch. Let edges in layer i be {v1, . . . , vw}. For each
layer i, where 0 ≤ i < n, we add w dummy nodes, say
{vi,w+1, . . . , vi,2w} and add the following edges. For each
layer i and j ∈ [w] add edges from vi,j to vi+1,w+j and from
vi,w+j to vi+1,j.

It is easy to see that the new layered branching program
is invertible. More precisely, the columns can be re-arranged
so that the matrices obtained are upper-triangular with all
the main diagonal entries set to 1. It also easy to observe
that if SLBP(x) = 1 then ILBP(x) = 1. For the other direc-
tion, note that adding these extra nodes and edges does not
create a path between any two original nodes if there was
no path before.

Invertible layered branching program to relaxed ma-
trix branching program.

Lemma 3. Any invertible layered branching program ILBP
of length n and width w can be eﬃciently converted to an

equivalent relaxed matrix branching program RMBP of length
n and width w.

Proof. Consider a large enough 7 prime p. Correspond-
ing to each layer in the layered branching program, we will
have two (w × w) matrices Bi,0 and Bi,1 over Zp. Let the
label of this layer be xj for some j ∈ [(cid:96)]. For i ∈ [n] and
b ∈ {0, 1}, deﬁne Bi,b as follows:
For any x, y ∈ [w], set Bi,b[x, y] = 1 if there is an edge
between vi−1,x to vi,y labeled xj = b. Set the rest of the
entries in Bi,b to be 0. We deﬁne inp to be a function from
[n] to (cid:96), where (cid:96) is the input length of ILBP. We set inp(i) = j
if all the nodes in the ith layer depend on the jth input bit.
Since we are given an invertible layered branching pro-
gram, it is easy to see that all the matrices are full-rank.
Without loss of generality, let the source node be the node
v0,1 and accept node be the node vn,w of the invertible lay-
ered branching program. Then,

product (cid:81)n

Claim 1. Consider an input x ∈ {0, 1}(cid:96). Denote the
i=1 Bi,xinp(i) by P . Then, P [1, w] ≥ 1 if and only

if ILBP(x) = 1.

Pj =(cid:81)j

Proof Sketch: We prove this via induction on the num-
ber of layers in the branching program.
Intuitively, we
will prove that the following invariant is maintained. Let
i=1 Bi,xinp(i) . Then, Pj[x, y] will denote the number
of paths from v0,x to vj,y.
In particular, P [1, w] captures
the number of paths from the source node to the sink node.
And hence, P [1, w] is non-zero iﬀ ILBP(x) = 1. For more
details, refer to the full version [1].

Theorem 1. Any non-deterministic branching program
BP of size s can be eﬃciently converted to an equivalent re-
laxed matrix branching program RMBP of length s and width
2(s + 1).

Proof. It follows directly from Lemmas 1, 2 and 3.

Converting relaxed matrix branching program to
dual input oblivious relaxed matrix branching pro-
gram. First note that if the family of invertible layered
matrix branching programs is input oblivious, then the re-
laxed matrix branching program obtained from the above
transformation would also be input oblivious. If that is not
the case, we can convert it to a dual-input relaxed matrix
branching program by incurring a multiplicative cost of (cid:96) in
the length of the branching program. More formally,

Lemma 4. Any relaxed matrix branching program RMBP =

(inp, Bi,0, Bi,1)i∈[n] of length n and width w can be eﬃciently
converted to a dual-input oblivious relaxed matrix branching
program of length at most n(cid:96) and width w.

Proof Sketch: We ﬁrst make our program input oblivious
as follows: In jth block of (cid:96) matrices, all the matrices are
identity matrices apart from the matrices at index inp(j).
At this index, we place the two non-trivial matrices Bj,0
and Bj,1 which help in actual computation. Now we make
the above relaxed matrix branching program dual-input, by
pairing the input position used at each index with a dummy

7In the following construction, we use the fact that the prime
p is large enough so that there are no wrap-arounds while
multiplying the matrices.
In particular, assume that p =
2Ω(n).

652input position in an oblivious manner. 8 For complete de-
scription of this transformation, refer to the full version [1].
3.1 From Formula to RMBP
Direct construction. Transforming formulas to branch-
ing programs is a well studied problem [26, 5, 12, 31]. In
particular, it is well known [26] that formula of size s over
and, or, and not gates can be converted to a branching
program of essentially the same size; for self containment,
we describe such a transformation in Appendix B which sat-
isﬁes the following lemma.

Lemma 5. Any formula of size s can be converted to a

branching program of size s.

Using the transformations described in the previous section,
we obtain the following.

Theorem 2. Any formula of size s can be eﬃciently con-
verted to an equivalent relaxed matrix branching program of
width 2(s + 1) and length s. Moreover, it can be converted
to a dual input oblivious matrix branching program of width
2(s + 1) and length s(cid:96).

Keyed formulas. Consider the class of keyed formulas,
namely a class of formulas of the form fz(x) = φ(z, x) such
that φ is a formula of size s. While obfuscating this class of
formulas, we only need to hide the key z since φ is public.
Since we do not require the matrix branching program to
be input oblivious, we do not incur the additional factor of
(cid:96) in the length of the matrix branching program. So the
length of the branching program for this class of functions
is at most s.
Alternate approach. We note that there is an asymptot-
ically more eﬃcient transformation to obtain relaxed ma-
trix branching program using the work of Giel [19]. The
transformation consists of the following steps – ﬁrst the for-
mula is balanced and then the resulting balanced formula is
converted to a linear bijection straightline-program (LBSP)
which is then converted to an RMBP. More formally, we
have the following result due to Giel [19].

Theorem 3

([19]). Given a boolean formula of size s
over any complete basis, there exists a relaxed matrix branch-
ing program of size O(s1+) with the width of each matrix is
a constant depending only on ,where  > 0 is any constant.

4. RANDOMIZATION OF RMBP

In this section, we describe how to randomize the matrices
in the (dual-input and oblivious) relaxed matrix branching
program obtained from the construction in Section 3. The
result of the randomization process is another relaxed matrix
branching program such that the restriction of the relaxed
matrix branching program9 on input x can be simulated
by just knowing the output of the branching program on
input x. Looking ahead, this property will come in handy
when proving the security of the obfuscation scheme in the

8We assume here that n is a multiple of (cid:96). In general even if
this is not the case we can suitably pad RMBP with identity
matrices incurring an additive cost of (cid:96) in the length of the
RMBP.
9Recall that the restriction of a relaxed matrix branching
program BP = (inp1, inp2,{Bi,b1,b2}i∈[n],b1,b2∈{0,1}) is de-
ﬁned to be {Bi,xinp1 (i),xinp2(i)}.

ideal graded encoding model. The randomization technique
we employ closely follows a similar randomization technique
that was used in [14] in the context of secure multiparty
computation.

The non-triviality of the randomization process here com-
pared to [3] is the following: in [3] the product matrix cor-
responding to an input x depends only on the output of the
function on input x. More speciﬁcally it is either an iden-
tity matrix or a ﬁxed matrix Preject (Deﬁnition 2). Thus, the
product matrix does not reveal any information about the
branching program. However, in our case the entries in the
product matrix might contain useful information about the
branching program – speciﬁcally the product matrix in our
RMBP captures the number of paths between every pair of
vertices. Hence, we have to randomize the matrices in such
a way that the product of the matrices only reveals infor-
mation about the output of the function. We do this in
two steps. In the ﬁrst step we design a randomization pro-
cedure, denoted by randBP, which reveals just the (1, w)th
entry of the product matrix. Note that this itself will not
be enough for us because the (1, w)th entry essentially con-
tains the number of paths between the source and the accept
vertex and hence has more information than just the out-
put of the function. And so in the second step, we describe
how to randomize the RMBP using the procedure randBP(cid:48),
such that the resulting (equivalent) RMBP when restricted
to any particular input x can be simulated by just knowing
the output of the RMBP on x.

We ﬁrst describe the randBP procedure. Though the pro-
cedure randBP to randomize our matrices is similar in spirit
to Kilian’s randomization (also used in [18, 3]), the way we
will simulate these matrices will deviate from that of Kilian.
Notation. We will denote the relaxed matrix branching
program as BP = (inp1, inp2,{Bi,b1,b2}i∈[n],b1,b2∈{0,1}) with
length n, width w and input of (cid:96) bits. For any x ∈ {0, 1}(cid:96),
deﬁne Px :=

Bi,xinp1(i),xinp2(i) and,

n(cid:81)

i=1

Let e1, ew ∈ {0, 1}w, be such that e1 = (1, 0, 0, . . . , 0) and
ew = (0, 0, . . . , 0, 1). For notational convenience, let e1 be a
row vector and ew we a column vector.
Procedure randBP. The input to the randomization pro-
cedure is an oblivious dual-input RMBP BP = (inp1, inp2,
{Bi,b1,b2}i∈[n],b1,b2∈{0,1}) of length n, width w and input of
(cid:96) bits.
Procedure randBP(BP):

p

.

- Pick n + 1 random full-rank matrices R0, . . . , Rn ∈
Zw×w
- Compute the matrices ˜Bi,b1,b2 = Ri−1 · Bi,b1,b2 · R
for all i ∈ [n] and b1, b2 ∈ {0, 1}.
- Finally, compute ˜s = e1 · R
- Output (cid:102)BP =

(cid:16)
inp1, inp2, ˜s,(cid:8) ˜Bi,b1,b2

and ˜t = Rn · ew.

i∈[n],b1,b2∈{0,1}, ˜t

(cid:9)

−1
i

−1
0

(cid:17)

.

It follows that the branching program output by the above
procedure on input BP is functionally equivalent to BP.

We can construct a simulator SimBP such that the follow-
ing theorem holds. At a high level, the theorem states that

the matrices in (cid:102)BP (which is the output of randBP on BP)

(cid:12)(cid:12)(cid:12)x

BP

:= (Bi,xinp1(i),xinp2(i) )i∈[n]

653when restricted to a particular input x can be simulated
by just knowing the (1, w)th entry in the product matrix
obtained by evaluating BP on input x. The proof of the
theorem is in Appendix C.

Theorem 4. Consider an oblivious dual-input RMBP BP =

(inp1, inp2, {Bi,b1,b2}i∈[n],b1,b2∈{0,1}) of length n, of width w
(cid:111)
(cid:110)
and input of (cid:96) bits. Then for every x ∈ {0, 1}(cid:96),

(cid:111) ≡ (cid:110)

SimBP(1n, 1w, 1(cid:96), Px[1, w])

.

randBP(BP)

(cid:12)(cid:12)(cid:12)x

We now move to the second step where we show how to ran-
domize the branching program using the procedure randBP(cid:48)
in such a way that the product of the matrices (which will
be a 1×1 matrix) corresponding to an input only reveals the
output of the function and nothing else. To achieve this, we
need to ensure that the product of the matrices correspond-
ing to one input is not correlated to the product of matrices
corresponding to a diﬀerent input, where both the inputs are
such that they evaluate to 1. We solve this by multiplying
the matrix Bi,b1,b2 by αi,b1,b2 (which is picked at random).
This ensures that multiplying the matrices corresponding to
two diﬀerent inputs result in two diﬀerent products of α’s
which are mutually independent which in turn makes it fea-
sible to achieve simulation of these matrices by just knowing
the value of the function. We now describe the procedure

randBP(cid:48). Note that randBP(cid:48) takes as input (cid:102)BP which is the
Procedure randBP(cid:48)((cid:102)BP):

output of randBP on the relaxed matrix branching program
BP.

- It picks random and independent non-zero scalars
αi,b1,b2 ∈ Zp for i ∈ [n], b1, b2 ∈ {0, 1} and computes
Ci,b1,b2 = αi,b1,b2 · ˜Bi,b1,b2 . It outputs
(˜s,{Ci,b1,b2}i∈[n],b1,b2∈{0,1}, ˜t).
We can construct a simulator Sim(cid:48)
BP (which internally exe-
cutes SimBP) such that the following theorem holds. A for-
mal proof of the theorem can be found in the full version [1].

Theorem 5. Consider an oblivious dual-input RMBP BP =

(inp1, inp2,{Bi,b1,b2}i∈[n],b1,b2∈{0,1}) of length n, width w and
input of (cid:96) bits. Then there exists a PPT simulator Sim(cid:48)
(cid:111)
(cid:110)
such that for every x ∈ {0, 1}(cid:96),

BP

(cid:48)
BP(1n, 1w, 1(cid:96), BP(x))

Sim

.

(cid:111) ≡ (cid:110)

(cid:12)(cid:12)(cid:12)x

(randBP(BP))

(cid:48)
randBP

If (cid:0)(cid:81)

Deﬁne c = ((cid:81)

Proof Sketch. The proof of above theorem relies on the fol-
lowing crucial observation. Let M1, M2, . . . , Mn be a given
set of matrices. Let (N1, . . . , Nn) be the output of
randBP(cid:48)(M1, M2, . . . , Mn). That is, N1 = α1M1, . . . , Nn =
αnMn, where α1, α2, . . . , αn are uniform non-zero scalars.
i Ni)[1, w].
distributed uniformly in Z∗
p and it is 0, otherwise. Now, we
can simulate these matrices in such a way that the product
of the matrices is either distributed uniformly at random in
Z∗
p or it is 0, depending on the value of the function.
5.

(cid:1) [1, w] (cid:54)= 0, then c is

IDEAL GRADED ENCODING MODEL

i Mi

In this section, we describe the ideal graded encoding
model. This section has been taken almost verbatim from
[3]. All parties have access to an oracle M, implementing an
ideal graded encoding. The oracle M implements an ideal-
ized and simpliﬁed version of the graded encoding schemes

from [17]. The parties are provided with encodings of vari-
ous elements at diﬀerent levels. They are allowed to perform
arithmetic operations of addition/multiplication and testing
equality to zero as long as they respect the constraints of the
multilinear setting. We start by deﬁning an algebra over the
elements.

Definition 5. Given a ring R and a universe set U, an
element is a pair (α, S) where α ∈ R is the value of the
element and S ⊆ U is the index of the element. Given an
element e we denote by α(e) the value of the element, and
we denote by S(e) the index of the element. We also deﬁne
the following binary operations over elements:

• For two elements e1, e2 such that S(e1) = S(e2), we
deﬁne e1 + e2 to be the element (α(e1) + α(e2), S(e1)),
and e1 − e2 to be the element (α(e1) − α(e2), S(e1)).
• For two elements e1, e2 such that S(e1) ∩ S(e2) = ∅,
we deﬁne e1·e2 to be the element (α(e1)·α(e2), S(e1)∪
S(e2)).

Next, we describe the oracle M. M is a stateful oracle
mapping elements to “generic” representations called han-
dles. Given handles to elements, M allows the user to per-
form operations on the elements. M will implement the
following interfaces:
Initialization. M will be initialized with a ring R, a uni-
verse set U, and a list L of initial elements. For every element
e ∈ L, M generates a handle. We do not specify how the
handles are generated, but only require that the value of the
handles are independent of the elements being encoded, and
that the handles are distinct (even if L contains the same
element twice). M maintains a handle table where it saves
the mapping from elements to handles. M outputs the han-
dles generated for all the elements in L. After M has been
initialized, all subsequent calls to the initialization interface
fail.
Algebraic operations. Given two input handles h1, h2
and an operation ◦ ∈ {+,−,·}, M ﬁrst locates the relevant
elements e1, e2 in the handle table. If any of the input han-
dles do not appear in the handle table (that is, if the handle
was not previously generated by M) the call to M fails. If
the expression e1 ◦ e2 is undeﬁned (i.e., S(e1) (cid:54)= S(e2) for
◦ ∈ {+,−}, or S(e1) ∩ S(e2) (cid:54)= ∅ for ◦ ∈ {·}) the call fails.
Otherwise, M generates a new handle for e1 ◦ e2, saves this
element and the new handle in the handle table, and returns
the new handle.
Zero testing. Given an input handle h, M ﬁrst locates
relevant element e in the handle table. If h does not appear
in the handle table (that is, if h was not previously generated
by M) the call to M fails.
If S(e) (cid:54)= U, the call fails.
Otherwise, M returns 1 if α(e) = 0, and returns 0 if α(e) (cid:54)=
0.

6. STRADDLING SET SYSTEM

In this section, we describe a straddling set system which
is same as the one considered in [3]. This is the set system
under which the elements in the RMBP are encoded. Then
we will state two combinatorial properties of this set system,
which will be very useful in proving the VBB security of our
scheme.

Definition 6. A straddling set system Sn = {Si,b : i ∈
[n], b ∈ {0, 1}} with n entries over the universe U = {1, 2,

654. . . , 2n − 1} is as follows:

S1,0 = {1}, S2,0 = {2, 3}, . . . , Si,0 = {2i − 2, 2i − 1},

. . . , Sn−1,0 = {2n−4, 2n−3}, Sn,0 = {2n−2, 2n−1}

S1,1 = {1, 2}, S2,1 = {3, 4}, . . . , Si,1 = {2i − 1, 2i},

. . . , Sn−1,1 = {2n−3, 2n−2}, Sn,1 = {2n−1}

U are {Si,0}i∈[n] and {Si,1}i∈[n]. That is, U =(cid:83)
(cid:83)
and (cid:83)

The two properties satisﬁed by the above system are:
1. Unique covers of universe: The only exact covers of
i∈[n] Si,0 =
i∈[n] Si,1.
2. Collision at universe: Let C and D be non-empty col-
lections of sets such that C ⊆ {Si,0}i∈[n], D ⊆ {Si,1}i∈[n],
S∈D S, then following must hold: C =
{Si,0}i∈[n] , D = {Si,1}i∈[n].

S∈C S = (cid:83)

7. OBFUSCATION IN THE IDEAL GRADED

ENCODING MODEL

In this section, we describe our VBB obfuscator O for
polynomial sized formulae in the ideal graded encoding model.
Input. The input to our obfuscator O is a dual-input oblivi-
ous relaxed matrix branching program BP of length n, width
w, input length (cid:96):

BP = (inp1, inp2,{Bi,b1,b2}i∈[n],b1,b2∈{0,1})

such that inp1 and inp2 are evaluation functions mapping
[n] → [(cid:96)], and each Bi,b1,b2 ∈ {0, 1}w×w is a full rank matrix.
We make a simplifying assumption that every input bit is
inspected by BP exactly (cid:96)(cid:48) number of times. We denote the
set of indices that inspect the input bit j by ind(j).
ind(j) = {i ∈ [n] : inp1(i) = j} ∪ {i ∈ [n] : inp2(i) = j} .
Step 1: Randomizing the relaxed matrix branching
program BP. The obfuscator O randomizes the branching
program in two steps using procedures randBP and randBP(cid:48)
described in Section 4. It begins by sampling a large enough
prime p of Ω(n) bits.

(cid:9)

(cid:17)

˜s, ˜t ∈ Zw
{0, 1}.

i∈[n],b1,b2∈{0,1}, ˜t

p and ˜Bi,b1,b2 ∈ Zw×w

1. It invokes the procedure randBP on the relaxed matrix

branching program BP obtained above to get (cid:102)BP =
(cid:16)
inp1, inp2, ˜s,(cid:8) ˜Bi,b1,b2
2. It then executes the procedure randBP(cid:48) on input (cid:102)BP
to obtain (˜s, {Ci,b1,b2}i∈[n],b1,b2∈{0,1}, ˜t). The matrices
Ci,b1,b2 are such that Ci,b1,b2 = αi,b1,b2 · ˜Bi,b1,b2 , where
αi,b1,b2 ∈ Zp with i ∈ [n], b1, b2 ∈ {0, 1} are picked
uniformly at random.

. Recall that
for all i ∈ [n], b1, b2 ∈

p

The output of this phase is (inp1, inp2, ˜s, {Ci,b1,b2}

˜t).

i∈[n],

b1,b2∈{0,1}

,

Looking ahead, the ﬁnal obfuscation of BP will consist of
ideal encodings of these elements with respect to a carefully
chosen set system. Next, we describe how these sets are
chosen.
Step 2: Initialization of the set systems. Consider a
universe set U. Let Us, Ut, U1, U2, . . . , U(cid:96) be partitions of

U1, U2, . . . , U(cid:96) are disjoint sets and U = Us ∪ Ut ∪ (cid:96)(cid:83)

U such that for all j ∈ [(cid:96)], |Uj| = (2(cid:96)(cid:48) − 1). That is, Us, Ut,
Uj.
Now let Sj be the straddling set system (deﬁned in Sec-
tion 6) over the elements in Uj. Note that Sj will have
|ind(j)| = (cid:96)(cid:48) sets in the system for each j ∈ [(cid:96)]. We now as-
sociate the entries in the straddling set system Sj with the
indices of BP which depend on xj, i.e. the set ind(j). More
precisely, let

j=1

Sj = {Sj

k,b : k ∈ ind(j), b ∈ {0, 1}}.

Step 3: Associating elements of randomized RMBP
with sets. Next, we associate a set to each element output
by the randomization step. Recall that in a dual-input re-
laxed matrix branching program, each step depends on two
ﬁxed bits in the input deﬁned by the evaluation functions
inp1 and inp2. For each step i ∈ [n], b1, b2 ∈ {0, 1}, we de-
ﬁne the set S(i, b1, b2) using the straddling sets for input bits
inp1(i) and inp2(i) as follows:

S(i, b1, b2) := Sinp1(i)

i,b1

∪ Sinp2(i)

i,b2

.

Step 4: Encoding of elements in randomized RMBP.
We use the set S(i, b1, b2) to encode the elements of Ci,b1,b2 .
We will use the sets Us and Ut to encode the elements in ˜s
and ˜t respectively. More formally, O does the following:
O initializes the oracle M with the ring Zp and universe
set U. Then it asks for the encodings of the following ele-
ments:

(cid:8)(˜s[k], Us), (˜t[k], Ut)(cid:9)

k∈[w]

{(Ci,b1,b2 [j, k], S(i, b1, b2)}i∈[n],b1,b2∈{0,1},j,k∈[w]

O receives a list of handles for these elements from M.
Let [β]S denote the handle to (β, S). For a matrix M , let
[M ]S denote a matrix of handles such that [M ]S[j, k] is a
handle for (M [j, k], S). Thus, O receives the following han-
dles, which is then output by O.

[˜t]Ut , (cid:8)[Ci,b1,b2 ]S(i,b1,b2)

(cid:9)

[˜s]Us ,

i∈[n],b1,b2∈{0,1}

Evaluation of O(BP) on input x. Recall that two handles
corresponding to the same set S can be added. If [β]S and
[γ]S are two handles, we denote the handle for (β + γ, S)
obtained from M on addition query by [β]S +[γ]S. Similarly,
two handles corresponding to S1 and S2 can be multiplied
if S1 ∩ S2 = ∅. We denote the handle for (β · γ, S1 ∪ S2)
obtained from M on valid multiplication query on [β]S1 and
[γ]S2 by [β]S1 · [γ]S2 . Similarly, we denote the handle for
(M1 · M2, S1 ∪ S2) by [M1]S1 · [M2]S2 .
Given x ∈ {0, 1}(cid:96), to compute BP(x), O(BP) computes
(cid:105)

the handle for the following expression:

h = [˜s]Us · n(cid:89)

· [˜t]Ut

Ci,xinp1(i),xinp2(i)

(cid:104)

S(i,xinp1(i),xinp2(i))

i=1

Next, O(BP) uses the oracle M to do a zero-test on h. If the
zero-test returns a 1, then O(BP) outputs 0 else it outputs
1.
Correctness of Evaluation. We ﬁrst assume that none of
the calls to M fail and show that O(BP) on x outputs 1 iﬀ
BP(x) = 1. We denote bi
2 = xinp2(i) in the
following equation. From the description of the evaluation

1 = xinp1(i) and bi

655above, O(BP) outputs 0 on x if and only if

0 = ˜s · n(cid:89)
(cid:32)
(cid:32)

i=1

=

=

−1

Ci,bi

1,bi
2

(e1R

0 ) · n(cid:89)
e1 · n(cid:89)

Bi,bi

i=1

i=1

· ˜t = ˜s · n(cid:89)
(cid:33)

i=1

R(i−1) · Bi,bi

· n(cid:89)

i=1

· ew

1,bi
2

αi,bi

1,bi
2

· ˜Bi,bi

· ˜t

1,bi
2

(cid:33) n(cid:89)
= Px[1, w] · n(cid:89)

· (Rnew)

i=1

· R

−1
i

1,bi
2

αi,bi

1,bi
2

αi,bi

1,bi
2

αi,bi

1,bi
2

i=1

We conclude with the following theorem and corollary

which summarize our results.

Theorem 6. There is a virtual black box obfuscator O in
the idealized model for all poly-sized RMBPs. For a fam-
ily of input-oblivious RMBPs of length n and width w, the
obfuscation requires n levels of multilinearity over a ﬁeld of
size p = 2Ω(n), the obfuscated program consists of nw2 en-
codings of ﬁeld elements, and its evaluation involves O(nw2)
multilinear operations.

The proof of the above theorem follows along the lines of
Barak et al. [3]. For a formal proof refer to the full ver-
sion [1].

The following corollary follows from Theorem 1, Theo-

rem 2 and the above theorem.

Corollary 1. There is a virtual black box obfuscator O
in the idealized model for non-deterministic branching pro-
grams. For a family of keyed branching programs (or for-
mulas) of size s, the obfuscation requires s levels of multilin-
earity over a ﬁeld of size p = 2Ω(s), the obfuscated program
consists of O(s3) encodings of ﬁeld elements, and its evalu-
ation involves O(s3) multilinear operations. For a family of
input-oblivious, special layered branching programs of length
n and width w, the obfuscation requires n levels of multilin-
earity over a ﬁeld of size p = 2Ω(n), the obfuscated program
consists of O(nw2) encodings of ﬁeld elements, and its eval-
uation involves O(nw2) multilinear operations.

In the above theorem and its corollary, the obliviousness
requirement can be relaxed by incurring an additional mul-
tiplicative overhead of (cid:96) to the levels of multilinearity and
the number of multilinear operations, where (cid:96) is the number
of input variables.

Acknowledgements
We thank Paul Beame and Milos Ercegovac for discussions
about formula size versus depth tradeoﬀs for interesting func-
tions. We thank Jean-Sebastien Coron and Shai Halevi for
helpful discussions regarding secure parameter sizes for mul-
tilinear map instantiations. We thank Ilan Komargodski
and Alexander Sherstov for bringing to our attention the
best results on optimizing depth of formulas. We also thank
Omkant Pandey, Manoj Prabhakaran, and Mark Zhandry
for several helpful comments. We are especially grateful to
Ilan Komargodski for bringing the work of [19] to our at-
tention as well as for several other helpful suggestions and
comments. Finally, we thank the CCS Program Committee,
and especially Mariana Raykova, for very useful feedback
and suggestions.

8. REFERENCES

[1] P. Ananth, D. Gupta, Y. Ishai, and A. Sahai.

Optimizing obfuscation: Avoiding barrington’s
theorem. Cryptology ePrint Archive, Report
2014/222, 2014. http://eprint.iacr.org/.

[2] B. Applebaum. Bootstrapping obfuscators via fast

pseudorandom functions. Cryptology ePrint Archive,
Report 2013/699, 2013.

[3] B. Barak, S. Garg, Y. T. Kalai, O. Paneth, and

A. Sahai. Protecting obfuscation against algebraic
attacks. In EUROCRYPT, 2014.

[4] B. Barak, O. Goldreich, R. Impagliazzo, S. Rudich,

A. Sahai, S. P. Vadhan, and K. Yang. On the
(im)possibility of obfuscating programs. In CRYPTO,
pages 1–18, 2001.

[5] D. A. M. Barrington. Bounded-width polynomial-size
branching programs recognize exactly those languages
in NC1. In STOC, 1986.

[6] M. Bellare and P. Rogaway. Random oracles are

practical: A paradigm for designing eﬃcient protocols.
In ACM Conference on Computer and
Communications Security, pages 62–73, 1993.

[7] M. L. Bonet and S. R. Buss. Size-depth tradeoﬀs for

boolean formulae. Information Processing Letters,
49(3):151–155, 1994.

[8] Z. Brakerski and G. N. Rothblum. Virtual black-box

obfuscation for all circuits via generic graded
encoding. In TCC, pages 1–25, 2014.

[9] R. P. Brent. The parallel evaluation of general

arithmetic expressions. Journal of the ACM (JACM),
pages 201–206, 1974.

[10] N. H. Bshouty, R. Cleve, and W. Eberly. Size-depth

tradeoﬀs for algebraic formulae. In FOCS, pages
334–341, 1991.

[11] R. Canetti, O. Goldreich, and S. Halevi. The random
oracle methodology, revisited. J. ACM, 51(4):557–594,
2004.

[12] R. Cleve. Towards optimal simulations of formulas by

bounded-width programs. In STOC, pages 271–277,
1990.

[13] J.-S. Coron, T. Lepoint, and M. Tibouchi. Practical

multilinear maps over the integers. In CRYPTO,
pages 476–493, 2013.

[14] R. Cramer, S. Fehr, Y. Ishai, and E. Kushilevitz.

Eﬃcient multi-party computation over rings. In
EUROCRYPT, pages 596–613, 2003.

[15] W. Diﬃe and M. E. Hellman. Multiuser cryptographic
techniques. In AFIPS National Computer Conference,
pages 109–112, 1976.

[16] U. Feige, J. Kilian, and M. Naor. A minimal model for

secure computation. In STOC, pages 554–563, 1994.

[17] S. Garg, C. Gentry, and S. Halevi. Candidate

multilinear maps from ideal lattices. In
EUROCRYPT, pages 1–17, 2013.

[18] S. Garg, C. Gentry, S. Halevi, M. Raykova, A. Sahai,

and B. Waters. Candidate indistinguishability
obfuscation and functional encryption for all circuits.
In FOCS, pages 40–49, 2013.

[19] O. Giel. Branching program size is almost linear in

formula size. J. Computer and System Sciences, pages
222–235, 2001.

656[20] V. Goyal, Y. Ishai, A. Sahai, R. Venkatesan, and

A. Wadia. Founding cryptography on tamper-proof
hardware tokens. In TCC, pages 308–326, 2010.

[21] S. Jukna. Boolean Function Complexity - Advances

and Frontiers, volume 27 of Algorithms and
combinatorics. Springer, 2012.

[22] V. Khrapchenko. On a relation between the

complexity and the depth. Metody Diskretnogo
Analiza Synthesis of Control Systems, 32:76–94, 1978.

[23] J. Kilian. Founding cryptography on oblivious

transfer. In STOC, pages 20–31, 1988.

[24] A. Langlois, D. Stehl´e, and R. Steinfeld. Gghlite:

More eﬃcient multilinear maps from ideal lattices. In
EUROCRYPT, pages 239–256, 2014.

[25] H. T. Lee and J. H. Seo. Security analysis of

multilinear maps over the integers. In CRYPTO (1),
pages 224–240, 2014.

[26] W. J. Masek. A fast algorithm for the string editing

problem and decision graph complexity, 1976.

[27] R. Pass, K. Seth, and S. Telang. Indistinguishability

obfuscation from semantically-secure multilinear
encodings. In CRYPTO, pages 500–517, 2014.

[28] M. Paterson and U. Zwick. Shallow circuits and

concise formulae for multiple addition and
multiplication. Computational Complexity, 3:262–291,
1993.

[29] F. P. Preparata and D. E. Muller. Eﬃcient parallel

evaluation of boolean expression. IEEE Trans.
Computers, 25(5):548–549, 1976.

[30] A. Sahai and B. Waters. How to use

indistinguishability obfuscation: deniable encryption,
and more. In STOC, pages 475–484, 2014.

[31] M. Sauerhoﬀ, I. Wegener, and R. Werchner. Relating
branching program size and formula size over the full
binary basis. In STACS, pages 57–67, 1999.

[32] I. S. Sergeev. Upper bounds for the formula size of

symmetric boolean functions. Russian Mathematics,
58 (5):30–42, 2014.

[33] P. M. Spira. On time-hardware complexity tradeoﬀs

for boolean functions. In Proceedings of the 4th Hawaii
Symposium on System Sciences, pages 525–527, 1971.

APPENDIX
A. BOOLEAN FORMULAE

A boolean circuit for a function f : {0, 1}(cid:96) → {0, 1} is
a directed acyclic graph (DAG). The vertices in this graph
are either input variables or gates. We assume that all the
gates in the circuit have fan-in at most 2. The outdegree of
an output gate is 0 and it is at least 1 for all other vertices.
The fan-out of a gate is the out-degree of that gate. In this
work, we consider a special type of circuits called formulae.
A boolean formula is a boolean circuit where the fan-out of
each gate is 1. A formula can be viewed as binary tree where
the root is the output gate. We deﬁne the size of a formula
to be the number of leaves in this binary tree.

B. FROM FORMULA TO BP

In this section, we give a transformation of boolean formu-
las over and and not gates to a branching program. Note
that any formula over and, or and not gates can be con-

source

BPF1

BPF

acc

rej

source

BPF2

acc

rej

Figure 1: This denotes the branching program for an and
gate.

verted to a formula over and and not gates of the same
size.
Consider a formula, denoted by F. We inductively trans-
form F to a branching program BP. Our construction will
maintain a stronger induction hypothesis. There will be two
sink nodes, “accept” and “reject.” Also, there will be a path
from the source to the accept iﬀ the output is 1 and there
will be a path from the source to the reject iﬀ the output is
0.

The base case corresponds to an input wire w. Let input
variable be xi. We construct a branching program for w,
denoted by BPw consists of three nodes denoted by source,
acc and rej. We add an edge labeled 0 from source to rej and
an edge labeled 1 from source to acc. We label the source
with xi.
We proceed to the induction hypothesis. Consider a gate G.
Case (1) and gate:- Let F1 and F2 be two sub-formulae
such that their output wires are fed to F. Let BPF1 and
BPF2 be the branching programs for F1 and F2, respectively.
We construct a branching program for F as follows (see Fig-
ure 1). We merge the accept node of BPF1 with the source
node of BPF2 . Similarly, merge the reject node of BPF1 with
the reject node of BPF2 .
Case (2) not gate:- Let F(cid:48) be the sub-formula such that
the output wire of F(cid:48) is fed into the gate G. Let BPF(cid:48) be
a branching program for F(cid:48). To construct the branching
program for F we simply rename accept node of BPF(cid:48) as
reject node for BPF. We also rename reject node of BPF(cid:48) as
accept node for BPF.

BPF

source

BPF(cid:48)

acc

rej

Figure 2: This denotes the branching program for a not
gate. The accept and the reject nodes are interchanged.

Note that once the transformation is complete for the for-
mula, the ﬁnal reject node can be deleted. So our ﬁnal con-
struction will only have one sink node, the “accept” node.

It is easy to see that the above described layered branching
program correctly evaluates the formula F. More formally,
Lemma 6. For every input x ∈ {0, 1}l, we have F(x) = 1
if and only if BPF(x) = 1. Moreover, for a formula of size
s, the size of the branching program BPF is at most s.

657Proof Sketch.
It follows by an induction on the structure
of the formula by noting that the number of leaves in a
formula is the sum of the leaves of the left sub-tree and the
right sub-tree.

C. PROOF OF THEOREM 4

(cid:12)(cid:12)(cid:12)x

We ﬁrst describe the simulator SimBP which simulates
the output of randBP for any input x. More formally, let
be deﬁned as (˜s, { ˜Bi,xinp1 (i),xinp2(i)}i∈[n], ˜t).
randBP(BP)
We describe a simulator SimBP which takes as input
(1n, 1w, 1(cid:96), Px[1, w]) and outputs a tuple which is identically
distributed to randBP(BP)
. Recall that s is the size of the

(cid:12)(cid:12)(cid:12)x

formula.

Before we describe SimBP we will ﬁrst recall the following

theorem.

gram BP = (cid:8)inp1, inp2, {Bi,b1,b2}i∈[n],b1,b2∈{0,1}(cid:9). There

Theorem 7. ([23]) Consider a dual-input branching pro-
exists a PPT simulator SimK such that for every x ∈ {0, 1}l,

{R0,{Ri−1Bi,xinp1 (i),xinp2(i) R

i }i∈[n], Rn}
−1

≡ SimK(1n, 1w, 1(cid:96), BP(x))

We are now ready to describe SimBP.
SimBP(1n, 1w, 1(cid:96), Px[1, w]):

- If Px[1, w] (cid:54)= 0, deﬁne the matrix A as A := Px[1, w] ·
Iw×w. Else, A := “mirror-image” of Iw×w.

p

- Run SimK(1n, A) to obtain full-rank matrices
R0, R1, . . . , Rn+1 ∈ Zw×w
i≥0 Ri = A.
Note that SimK is the simulator as deﬁned in Theo-
rem 7.
- Let ˆR0 = e1 · R
- Output ( ˆR0, R1, . . . , Rn, ˆRn+1).

and ˆRn+1 = Rn+1 · ew.

−1
0

such that (cid:81)

We now show that:

(cid:110)

(cid:111) ≡ (cid:110)

(cid:12)(cid:12)(cid:12)x

randBP(BP)

SimBP(1s, Px[1, w])

.

(cid:111)

As a ﬁrst step, we state the following lemma from Cramer
et al. [14] that will be useful to prove the theorem.

p

Lemma 7. For any x, y ∈ Zw

p \{0} and a full rank matrix
there exist full rank matrices X, Y ∈ (Zp)n×n
M ∈ Zw×w
such that the ﬁrst row of X is xT , the ﬁrst column of Y is
y, and XM Y depends only on xT M y. In particular, there
is a procedure Extend, running in time polynomial in n and
w, that takes as input (xT M y, x, y, M ), where x, y and M
are as deﬁned in the above lemma and outputs X and Y
such that XM Y is (xT M y) · Iw×w if xT M y (cid:54)= 0 else it is
“mirror-image” of I. 10

We now proceed to proving that the output distributions
of randBP and SimBP are identical. We ﬁrst deﬁne a sequence
of hybrids such that the ﬁrst hybrid is the real experiment
(which is randBP) while the last hybrid is the simulated ex-
periment (which is SimBP). Then, we show that the output
10The “mirror-image” of a w × w identity matrix is also a
w × w matrix such that the (i, w − i + 1)th entry in the
matrix is 1 and the rest of the entries in the matrix are 0.

distribution of each hybrid is identical to the output distri-
bution of the previous hybrid which will prove the theorem.

Hybrid0: This is the same as the real experiment. That is,
on input BP and x it ﬁrst executes randBP(BP) to obtain

(cid:12)(cid:12)(cid:12)x
(cid:102)BP. It then outputs (cid:102)BP
is (cid:99)BP = BP(cid:12)(cid:12)x
(cid:16)(cid:99)BP = (M1, . . . , Mn)

Hybrid1

Hybrid1: We describe Hybrid1 as follows. The input to Hybrid1

= (Bi,xinp1(i),xinp2 (i) )i∈[n]. Let Mi = Bi,xinp1(i),xinp2(i) .

= (˜s,{ ˜Bi,xinp1(i),xinp2(i)}i∈[n], ˜t)
(cid:17)

:

.

p

- Pick n + 1 random full-rank matrices R0, . . . , Rn ∈
Zw×w
- Compute the matrices ˜Mi = Ri−1 · Mi · R
- Finally, compute ˜s = e1 · R
- Output

and ˜t = Rn · ew.

˜s,{ ˜Mi}i∈[n], ˜t

for i ∈ [n].

(cid:16)

(cid:17)

−1
i

−1
0

.

It can be seen that the output distribution of this hybrid is
identical to the output distribution of the previous hybrid
Hybrid0.

Hybrid2: Hybrid2 is same as Hybrid1 except the way we com-
pute ˜s and ˜t. The input to Hybrid2, like the previous hybrid,

is (cid:99)BP = BP(cid:12)(cid:12)x

Hybrid2

.

(cid:16)(cid:99)BP = (M1, . . . , Mn)

(cid:17)

:

.

p

−1
i

n(cid:81)

- Pick n + 1 random full-rank matrices R0, . . . , Rn ∈
Zw×w
- Compute the matrices ˜Mi = Ri−1 · Mi · R
Mi and c := e1 · P · ew.

- Deﬁne P :=
- Execute Extend on input (c, e1, ew, P ) to obtain w × w
matrices S and T as described in Lemma 7. Compute
ˆS = SR
and ˆT = RnT . Finally, compute ˜s = e1 ˆS
and ˜t = ˆT ew.
- Output (˜s,{ ˜Mi}i∈[n], ˜t).

for i ∈ [n].

−1
0

i=1

Hybrid1 and Hybrid2 diﬀer only in the way ˜s and ˜t are com-
puted. In Hybrid2, ˜s = e1 ˆS = e1 · (SR
−1
0 =
xT · R
−1
0 , where x is the ﬁrst row of S. But the ﬁrst row of
S is e1 and hence, ˜s = e1 · R
−1
0 , which is same as the value
in Hybrid1. Similarly, we can show this for ˜t.

0 ) = (e1 · S) · R
−1

Hybrid3: This is same as the simulated experiment. That
is, it takes as input (1n, 1w, 1(cid:96)) and Px[1, w] and then ex-
ecutes SimBP(1n, 1w, 1(cid:96), Px[1, w]). The output of Hybrid3 is
the output of SimBP.

We now argue that Hybrid2 and Hybrid3 are identically dis-
tributed. First note that in Hybrid2, c = P [1, w]. Then it
follows from Lemma 7 that if c (cid:54)= 0, S · P · T = c · I, else
S · P · T = J, where J is the “mirror-image” of I. Theorem 7
can be used to show that hybrids Hybrid2 and Hybrid3 are
identically distributed. This shows that the output distri-
bution of Hybrid0 is identically distributed to Hybrid3. This
completes the proof of Theorem 4.

658