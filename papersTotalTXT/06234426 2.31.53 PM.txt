2012 IEEE Symposium on Security and Privacy

Clash Attacks on the Veriﬁability of

E-Voting Systems

Ralf K¨usters, Tomasz Truderung and Andreas Vogt
{kuesters,truderung,vogt}@uni-trier.de

University of Trier, Germany

Abstract—Veriﬁability is a central property of modern e-voting
systems. Intuitively, veriﬁability means that voters can check that
their votes were actually counted and that the published result
of the election is correct, even if the voting machines/authorities
are (partially) untrusted.

In this paper, we raise awareness of a simple attack, which we
call a clash attack, on the veriﬁability of e-voting systems. The
main idea behind this attack is that voting machines manage to
provide different voters with the same receipt. As a result, the
voting authorities can safely replace ballots by new ballots, and
by this, manipulate the election without being detected.

This attack does not seem to have attracted much attention in
the literature. Even though the attack is quite simple, we show
that, under reasonable trust assumptions, it applies to several e-
voting systems that have been designed to provide veriﬁability. In
particular, we show that it applies to the prominent ThreeBallot
and VAV voting systems as well as to two e-voting systems that
have been deployed in real elections: the Wombat Voting system
and a variant of the Helios voting system.

We discuss countermeasures for each of these systems and for
(various variants of) Helios provide a formal analysis based on
a rigorous deﬁnition of veriﬁability. More precisely, our analysis
of Helios is with respect to the more general and in the area of
e-voting often overlooked notion of accountability.

Keywords-accountability; veriﬁability; protocol analysis; voting

I. INTRODUCTION

Veriﬁability is a fundamental property of modern e-voting
systems. Intuitively, a veriﬁable e-voting system allows voters
to make sure that
their votes were actually counted and
that the published result of the election is correct, even if
voting machines/authorities are (partially) untrusted. In order
to achieve veriﬁability, voters are typically provided with some
kind of receipt which they can use—together with additional
data published on a bulletin board, such as encrypted ballots
and zero-knowledge proofs—to check that their votes were
counted and that voting machines/authorities followed the
prescribed procedure.

The main goal of this paper is to raise awareness of a simple
attack on veriﬁability, which does not seem to have attracted
much attention in the literature, and to discuss and (formally)
analyze countermeasures. The simple idea behind the attack,
which we call a clash attack, is as follows: Voting machines
try to provide different voters with the same receipt—hence,
the name of the attack. As a result, authorities can safely
replace ballots by new ballots on the bulletin board, and thus,
manipulate the election without being detected. We show that,

© 2012, Ralf Küsters. Under license to IEEE.
DOI 10.1109/SP.2012.32

395

surprisingly, several e-voting systems that have been designed
to provide veriﬁability, among them systems that have been
used in real elections, are vulnerable to this attack, under
realistic trust assumptions on voting machines and authorities.
Our ﬁndings illustrate that this attack is a potentially dangerous
attack for a large class of e-voting systems. We note that the
clash attack can work even if voters and election observers
know exactly how many and which voters voted. So clash
attacks are different from and more subtle than the well-known
ballot stufﬁng attacks (see, e.g., [4] for ballot stufﬁng attacks).
More precisely, the contribution of this paper is as follows.

Contribution of this Paper. We show that the clash attack
applies to the prominent voting systems ThreeBallot and VAV
[12], the Wombat voting system [16], which was used in an
election at an Israeli college, and variants of the Helios voting
system [1]. In the variant of Helios where each ballot (basically
an encrypted vote) is published on the bulletin board next to
the name of the voter who cast the ballot, the clash attack
does not work (see below); we refer to this variant as the
original variant of Helios. However, this variant is not an
option for many elections. One reason is that the mere fact of
voting is often required to be conﬁdential by law, see e.g., [2].
Moreover, it might be possible to break the encryption of votes
in the future, which would then reveal how speciﬁc voters
voted. Therefore, another variant of Helios was proposed [2]
where voters are provided with aliases (the variant of Helios
with aliases). In this variant, ballots are published on the
bulletin board along with the aliases, instead of the names of
voters. This variant of Helios has been used for a presidential
election at a Belgian university [2] and also for the IACR
renewal of the board of directors election [5]. We show that
for this variant of Helios the clash attack works, under the
realistic assumption that the assignment of aliases to voters
is not trusted. Another natural variant of Helios is to merely
publish the ballots without voter names/aliases or to publish
the ballots detached from the voter names/aliases (the variant
of Helios with detached names). We show that for this variant
of Helios too the clash attack can be carried out successfully.
We discuss several countermeasures for the discovered clash
attacks. Since Helios is probably the most prominent and
practical e-voting system among the ones we have studied,
we also carry out formal analysis for the different variants
of Helios (with our countermeasures applied, if necessary):
the original variant, the variant with aliases, and the variant

with detached names. More speciﬁcally, we do not only study
the veriﬁability property for Helios but also the accountability
property. This analysis is of independent interest since so
far veriﬁability has only very rarely been formally analyzed
for concrete e-voting systems [8], [14], [6], [15], [10] and
accountability has almost never been studied (formally or
informally) for concrete e-voting systems, with the formal
analysis of the Bingo voting system carried in [10] being an
exception.

Rigorous cryptographic deﬁnitions of accountability and
veriﬁability were introduced by K¨usters et al. in [10]. Our
analysis uses these deﬁnitions. Intuitively, in the context of
voting, accountability means that if the published outcome of
the election is not correct, i.e., does not correspond to how
the voters actually voted, and hence, some party must have
misbehaved (intentionally or unintentionally), then someone—
ideally (a group of) voting authorities—can be held account-
able for the misbehavior. It was shown in [10] that veriﬁability
can be seen as a special case of accountability. A very
useful feature of the deﬁnitions by K¨usters et al.
is that
they permit to precisely measure the level of accountability
(veriﬁability) an e-voting system provides: it can be precisely
captured under which conditions which (group of) parties can
be held accountable and how likely it is that misbehavior
goes unnoticed. Our formal analysis of Helios shows that we
obtain different levels of accountability for the three variants
of Helios—the original variant, the variant with aliases, and
the variant with detached names.

Orthogonally to the clash attack, our formal analysis also
reveals some quite obvious, but serious problem with the
accountability of the Helios system: If a voter claims that
her ballot is not published or not correctly displayed on the
bulletin board, then it is unclear whether the voter misbehaved,
e.g., simply lied, or the authority/bulletin board tried to cheat.
Fixing this problem would probably require a major redesign
of the system.
Related Work. As mentioned, our formal analysis of Helios
uses the deﬁnitions of accountability and veriﬁability proposed
by K¨usters et al. [10]. Their deﬁnition of veriﬁability takes a
global view on veriﬁability, unlike the traditional notions of
individual and universal veriﬁability. It was recently demon-
strated in [9] by attacks on the veriﬁability of ThreeBallot and
VAV [12] that individual and universal veriﬁability in general
do not imply (global) veriﬁability. We note that the attacks
found in [9] use speciﬁc details of ThreeBallot and VAV and
are very different from the clash attack considered here, which
applies to a much broader class of e-voting systems (see also
Section IV-C).

The clash attack should not be confused with the so-called
trash attack [3]. The idea of the trash attack is that if voters
throw away their (paper) receipt, then authorities who ﬁnd
these receipts could conclude that these voters will not check
their receipts on the bulletin board, and hence, ballots of such
voters can safely be modiﬁed. In contrast, the clash attack also
works if all voters check their receipts.

Helios was analyzed by Kremer et al. [8] with respect to

veriﬁability in a symbolic Dolev-Yao style model, rather than a
cryptographic model; accountability has not been studied for
Helios so far. The deﬁnition of veriﬁability and the model
of Helios Kremer et al. use is quite coarse. For example,
their deﬁnition of veriﬁability assumes that all voters are
honest. (The attack in [9] demonstrates that the existence of
dishonest voters may introduce new attacks.). Also, unlike
the deﬁnition in [10], their deﬁnition does not allow them
to measure the level of veriﬁability,
to calculate the
probability that manipulations go undetected, and to precisely
determine under what circumstances it is guaranteed that the
election can be carried out without complaints. While their
deﬁnition of veriﬁability in principle captures clash attacks,
Helios is modeled by Kremer et al. in such a way that clash
attacks are excluded and these attacks are not discussed in
their paper. We also note that Kremer et al. do not model
the auditing of ballots by voters. In their model, ballots are
simply guaranteed to contain the vote intended by the voter; in
fact, since Kremer et al. have a possibilistic model, faithfully
modeling the audit process would be rather tricky.

i.e.,

A logic-based formulation of accountability was presented
in [7], which, however, does not seem to have been applied to
a concrete protocol.
Structure of the Paper.
In the following three sections,
the clash attacks on the Wombat voting system, the variants
of Helios as well as ThreeBallot and VAV are discussed
informally. For the formal treatment of Helios, in Section V
we ﬁrst recall the deﬁnitions of accountability and veriﬁability
proposed by K¨usters et al. in [10]. We then formally analyze
accountability and veriﬁability of the different variants of
Helios in the subsequent sections. We conclude in Section IX.
Some more details are provided in the appendix; see our
technical report [11] for full details.

II. WOMBAT VOTING

In this section, we brieﬂy recall the Wombat voting system,
the clash attack on this system, and sketch some

present
countermeasures.

A. The System

The Wombat voting system was recently developed under
the lead of Alon Rosen, Amnon Ta-shma, Ben Riva, and
Jonathan Ben-Nun and was used in an election at the Inter-
disciplinay Center (IDC) in Herzliya, Israel [16], in which
the students union chairman and vice-chairman as well as the
director of a school within IDC were elected. It is a voting
booth scheme which consists of the following steps:
1. A voter presents her id-card at the polling station, where
a number of clerks check that the voter is eligible and has
not voted so far.

2. The voter enters the voting booth and indicates her choice
by pressing the name of her candidate on the touchscreen of
the voting machine. The voting machine then prints a ballot
consisting of the chosen candidate’s name (in plaintext) and
the encryption of this name (with some threshold public key
scheme), together with a (random-looking) serial number.

396

3. The voter can now either opt for casting this ballot or for
auditing it. If she chooses to audit, the machine supplies
the random coins used in the encryption, which allows the
voter (or anyone else)1 to check that the previously printed
encryption is indeed an encryption of the chosen candidate.
This audited ballot is not valid anymore and the voter can
vote again.

4. If eventually the voter decides to cast a ballot, she de-
taches the candidate’s name (in plaintext) from the part
containing the encryption and the serial number. The latter
part is scanned by the clerks and published on a bulletin
board. The part of the ballot with the candidate’s name
in clear is put into a separate box. This paper trail can,
if inconsistencies occur, be used for manual recounting.
However, as we will see later, our attack will not cause
any observable inconsistencies; therefore, there will be no
reason for a manual recount.

5. The part with the encrypted ballot and the random-looking
serial number serves as a receipt for the voter. Having this
data, the voter can check that her ballot indeed appears on
the bulletin board.

6. When the voting phase is ﬁnished, the data on the bulletin
board is ﬁrst sent through a mixnet and then decrypted (in
a threshold manner) by a group of trustees.

B. The Clash Attack on Wombat Voting

The authors of this system say that, under the (reasonable)
assumption that one trusts the clerks to only let eligible voters
vote once, the integrity of the system is always preserved
even in the case “where a hacker gets full control of both
the software and all the secret keys of the system [...] Thus,
if the elections pass audit and are successfully veriﬁed by
voters, then voters can be assured that the election results are
correct.”.2 This, however, is not true! The Wombat scheme is
vulnerable to the clash attack if the voting machine and the
bulletin board collaborate (which deﬁnitely is a scenario in the
scope of “a hacker gets full control of the system”), even if
all voters check their receipts and all published data, such as
zero-knowledge proofs, are successfully veriﬁed.

The clash attack on the Wombat system works as follows:
In the extreme case, the voting machine uses, for every ballot,
the same random coin r for encrypting a vote and, for every
candidate c, the same serial number sc in all the ballots that
contain a vote for c. As a result, voters who voted for the
same candidate c will get the same receipt, namely a receipt
containing the ciphertext Encpk(c,r) and the serial number
sc. Now the bulletin board, for every candidate c, can leave
only one original ballot, and safely replace all the remaining
ones by ballots of its choice. Note that every voter will ﬁnd
“her” ballot on the bulletin board, as one copy of every
ballot produced in the voting phase is kept. So, the bulletin
board (although manipulated) appears to be consistent and the
remaining phase—the tallying of the ballots as they appear on

1The authors of the Wombat system implemented an Android app for that

purpose, available at https://market.android.com/details?id=com.veriballot.

2http://www.wombat-voting.com/faq

the bulletin board—can follow the prescribed procedure. Note
that the attack works even if everybody knows exactly how
many and which voters voted.

The general observation is that for every duplicated receipt,
produced by the voting machine, the bulletin board can safely
manipulate one vote. So the attack is successful even if the
voting machine is more subtle than described above and uses
many more random coins and serial numbers.

We emphasize that

in the current procedure clerks and
voters are not obligated to detect duplicated receipts. Also,
for humans, noticing duplicates is not easy anyway in the
Wombat system since an encrypted vote is presented as a QR
code (a two dimensional bar code) and the serial numbers
are, as mentioned, random-looking. Hence, without writing
down serial numbers, it is quite hard for voters and clerks to
notice duplicates. In particular, clerks will not get suspicious
if the voting machine produces duplicated receipts only from
time to time. Moreover, the voting machine can easily prevent
that a single voter sees duplicated receipts by using new
serial numbers and new randomness for the cast ballot and
the one audited by the voter. (Note that the clash attack will
nevertheless be very effective.)

We also note that for the clash attack to work, it is not
necessary that the voting machine is completely corrupted. It
is sufﬁcient if the part of the machine that is responsible for
the random number generation is ﬂawed (and produces some
number of clashes).

As mentioned before, the Wombat voting system keeps a
paper trail. So if the paper ballots were recounted, the clash
attack would be detected. However, the point of a veriﬁable
voting system is to make the recounting superﬂuous in cases
were there have been no complaints. The clash attack for the
Wombat system shows that it is possible to manipulate the
outcome of the election without risking any complaints.

C. Countermeasures

The above scheme can be ﬁxed in several ways in order to
prevent our attack. One possible ﬁx is to print serial numbers
on receipts in advance, instead of letting the voting machine
print these numbers, and in case one does not trust the process
of printing the serial numbers, check that no number is printed
twice. Another ﬁx is to let the clerks collect all serial numbers
of ballots that were cast and check whether duplicates occur.
Assuming that the clerks are trusted (or there is a least one
honest clerk among the group of clerks), this again prevents
the clash attack, or more precisely, the clash attack would be
detected by the clerks.

Similarly, voters might compare their receipts and, by this,
prevent the clash attack; how this is done exactly, should
however be made explicit in the voting procedure. We note that
publishing/comparing receipts naively may have negative con-
sequences regarding privacy, analogously to a setting where
receipts are published along with the names of voters (see
Section I).

A formal analysis of the Wombat voting system with these
ﬁxes applied would be very similar to the formal analysis we

397

carry out for the variants of Helios in this paper. Since the
Helios voting scheme is more inﬂuential, we only focus on
the formal analysis of Helios in this paper.

III. HELIOS

We now recall several variants of the Helios voting sys-
tem, present the clash attacks on these systems, as far as
applicable, and discuss countermeasures. A formal analysis
of Helios (with the countermeasures applied) is carried out in
the subsequent sections.

A. The System

There are different variants of Helios and still new versions
of Helios are proposed. However, all these variants have the
following structure:
1. Voters can use their browsers to create and submit ballots.
More precisely, the browser (or, more precisely, the voter’s
client program run in the browser) encrypts the choice of
a voter, resulting in a ballot; if a variant of Helios with
homomorphic encryption is used, the ballot also contains
a zero-knowledge proof testifying the well-formedness of
the ballot. A voter can then opt for casting that ballot or
for auditing it. If the voter chooses to audit the ballot,
the browser provides the voter with the used randomness.
The voter is then supposed to check, with the help of a
trusted tool, that the browser in fact encrypted the voter’s
choice, i.e., whether the voter’s choice encrypted using
the randomness provided by the browser indeed yields the
audited ballot. Audited ballots cannot be cast. Voters are
therefore asked to vote again.

2. Once a voter has decided to cast the ballot, she is asked
to authenticate herself using some credential. The authen-
tication can be done directly on the voting server or on an
intermediate authentication server, which, after a successful
authentication, passes the ballot to the voting server.

3. The ballots are published on a bulletin board after the
voting phase is ﬁnished. (Below we also comment on
the case were ballots are visible on the bulletin board
immediately.)

4. The ballots are now ﬁrst sent through a veriﬁable mixnet
and then decrypted by a set of trustees, or, if an homo-
morphic encryption scheme is used, the ballots are ﬁrst
multiplied and then the resulting ciphertext is decrypted.

We mention that in Helios, typically the voters may revote,
that is, after having submitted a ballot, at any point before the
voting phase is ﬁnished, a voter may submit a new ballot which
replaces the old one. However, for the ease of presentation,
we assume that voters do not revote. We emphasize that
our results—both positive and negative ones—still hold true
without this simpliﬁcation.

The variants of Helios differ, besides other things that are
not relevant for the clash attack, in the kind of information
posted on the bulletin board:
The original variant:

In the original variant [1], the name of
a voter is published next to the voter’s ballot. This variant
is immune to our attack (see Section VI for a formal

Helios with aliases:

analysis). However, as already mentioned in the introduc-
tion, this variant of Helios has several disadvantages: (a)
everybody learns who abstained from voting, information
that in some cases must not be revealed by law, see, e.g.,
[2], and (b) it is possible that in the future, the encryption
scheme used to encrypt votes can be broken, and hence,
votes of individual voters would be revealed.

In a variant of Helios proposed in [2]
and used in two real elections [5], [2], voters obtain
aliases from the election authority in a registration phase.
In this variant ballots of voters are published on the
bulletin board next to these aliases, instead of the actual
names of the voters. Besides being additional work, the
issuing of aliases is security relevant, as will become clear
in Section III-B.

Helios with detached names: Other natural variants of He-
lios without the disadvantages mentioned above are that
the names of voters are not published at all on the bulletin
board or that the names are published in lexicographic or-
der, detached from the ballots. The former variant has the
advantage that nobody learns who abstained from voting,
whereas in the latter variant ballot stufﬁng (i.e., adding a
ballot for every voter that did not vote) is somewhat more
difﬁcult for voting authorities. However, both variants are
vulnerable to the clash attack, as discussed next.

B. Clash Attacks on the Variants of Helios with Aliases and
Detached Names

We now show how the clash attack can be mounted on the
variant of Helios with aliases and the variant with detached
names as described in Section III-A; as mentioned, the original
variant of Helios is immune to the clash attack. Note that
Helios shares a lot of ideas with the Wombat voting system
as far as the clash attack is concerned. The main difference
is that in Helios, instead of a voting machine, voters use their
browsers to cast ballots.
Helios with Detached Names. For the clash attack to work
for this variant of Helios, we assume that the browser (i.e.
the client program run in the browser) and the bulletin board
are dishonest; the tallying will be done correctly. Now, the
browser works as follows for every voter. It always uses the
same sequence r1,r2, . . . of random coins: r1 is used to produce
the ﬁrst ballot (i.e. the ﬁrst ballot contains an encrypted vote
of the form Encpk(c,r1), where c is the candidate chosen by
the voter), r2 is used to produce the second ballot, and so on.3
As a result, many identical ballots reach the bulletin board.
More precisely, all the voters who vote for the same candidate
and have audited their ballots the same number of times cast
identical ballots and obtain identical receipts. The bulletin
board can then safely replace all but one of each of the
duplicates by arbitrary ballots (i.e., encryptions of candidates
of its choice), and hence, safely manipulate the result of the
election. In fact, nobody will detect any manipulation: every

3If homomorphic encryption is used, the random coins ri are also used to

procedure the mentioned zero-knowledge proofs.

398

voter who cast her ballot can check that her name, in the case
where names are published (detached from ballots), as well as
her ballot appears on the bulletin board. Note that the attack
works even if voters know exactly how many and which voters
voted.
Helios with Aliases. Here we assume that the browser (i.e.,
the client program run in the browser), the bulletin board,
and the authority in charge of issuing aliases to voters are
dishonest; the tallying will again be done correctly.

It is realistic to assume that an adversary knows for sure
for some voters that they will vote and how they will vote,
provided that the voters do not have too many choices. For
example, very active members of a political party will not
abstain from voting and vote for the same political party,
namely their party. Now, the idea behind the clash attack for
Helios with aliases is that the authority in charge of issuing
aliases to voters could issue the same alias to two or more
voters for which the authority knows that they will make
the same choice, i.e., vote for the same candidate/party. All
browsers, or at least those for voters with the same aliases,
always use the same randomness for preparing the ballots. By
this, a voter who obtained the same alias as another voter
will obtain the same receipt, and again, the bulletin board can
replace all but one of those duplicates by arbitrary ballots.
Provided that those voters who were issued the same alias in
fact vote for the same candidate/party (the adversary would
not risk to issue the same alias if he could not be sure of
that), no manipulation will be detected: every voter who cast
a ballot can check that the ballot next to “her” alias coincides
with “her” receipt. Again, we note that the attack works even
if voters know exactly how many and which voters voted.

An important difference to the clash attack for Helios with
detached names is that now the browser always uses the same
random coins (at least for those voters who obtained the same
alias). If the browser used a sequence r1,r2, . . . of random
coins to encrypt consecutive choices of voters, as in the case
of Helios with detached names, the attack would very likely
be detected: If two voters with the same alias, say a, choose
to audit their ballots a different number of times, then two
different ballots, say b1 and b2, are produced for them. Now,
the bulletin board can only publish one of these ballots on the
bulletin board along with the alias a. (There should be at most
one entry on the bulletin board for every alias.) But then, one
of the voters with alias a could detect a mismatch.

This is why in the clash attack on Helios with aliases,
the same random coins r are used to encrypt all the votes
for voters who share the same alias. Consequently, all the
ballots produced for such a voter are the same. Note that
the audit procedure, as proposed in [2], only mandates to
check whether the audited ballot is indeed an encryption of
the chosen candidate. It does not required to check whether
the ballots produced in the consecutive steps are different
(use different random coins). Therefore, as long as this audit
procedure is carried out, no manipulation is detected. Also note
that voters are not asked to remember the ballots produced in

different steps and that these ballots (or their ﬁngerprint) are
quite hard to remember since their representations are rather
long strings. Voters will therefore typically not remember these
strings but simply copy and paste them for the purpose of
auditing and otherwise forget about them.

We ﬁnally note that the clash attack is more risky to carry
out, if ballots (along with the aliases) are published on the
bulletin board not after the voting phase is ﬁnished but right
away—which also means that the election turnout is published
before the end of the election phase. For example, this is done
in the IACR election [5]: A voter with alias a might check
the bulletin board before she votes by herself and then might
detect that the bulletin board already contains an entry for a,
namely one generated by another voter with the same alias.
C. Countermeasures
Helios with Detached Names. To prevent the clash attack
on Helios with detached names, we let the voter contribute
to the randomness that is used for encryption. One way of
implementing this is to ask the voter to type in a “random”
string before the ballot is produced by the browser. The voter-
provided randomness is then combined with the random coins
generated by the browser using a collision resistant hash
function h.4 More speciﬁcally, the voting procedure consists
of the following steps:
1. The voter indicates her choice c and provides a random
string rv (similarly to a one-time password). For simplicity
of the argument, we assume such random strings to all have
the same length (e.g., eight characters).
2. The browser chooses a random coin rb, then computes r =
h(rb||rv), and uses r to encrypt the voter’s choice, where
rb||rv denotes the concatenation of rb and rv.

3. Now, if the voter chooses to audit the ballot, the browser
is supposed to provide its random coin rb. This allows
the voter (by using some independent program) to check
whether the ballot has been produced correctly: the voter
recalculates the encryption of her choice using rb and the
random string rv provided by herself.

Intuitively, the above procedure prevents the clash attack (or
at least makes it very risky for the adversary) because it is
quite unlikely that two voters who choose the same candidate
also choose the same voter-provided random string for the
ballot cast. Note that due to the collision resistance of h it is
computationally infeasible for the browser, given two different
voter-provided random strings rv and r(cid:2)
v of the same length to
||r(cid:2)
produce random coins rb and r(cid:2)
v).
In Section VII we formally show that this variant of Helios
provides a reasonable level of accountability and veriﬁability.
(We also formally show that this variant of Helios without the
ﬁx does not provide a sufﬁcient level of accountability and
veriﬁability.) Clearly, the level of security achieved depends
on the entropy of the voter-provided randomness.

b such that h(rb||rv) = h(r(cid:2)

b

4To prove vote privacy of this variant of Helios, a stronger assumption
on h is necessary. Basically, h has to produce random strings when given
random strings as input, which is, for instance, the case when h is modeled
as a random oracle.

399

(a) A: o
B: x

A: o
B: x

A: x
B: o

(b) A: x
B: x

A: o
B: o

A: o
B: x

Fig. 1. Two ways of voting for the second candidate (candidate B) in the
ThreeBallot protocol, where x represents a marked position and o represents
an unmarked position. All the other possibilities of voting for B can be
obtained as permutations of these two.

Helios with Aliases. One way of preventing the clash attack is
to apply the same countermeasure as the one described above
for Helios with detached names. Another countermeasure,
which would not work for Helios with detached names, is
the following:

As discussed, for the clash attack on Helios with aliases to
be effective, a browser has to always use the same randomness
(for each ballot of a given voter), which then leads to identical
ballots. A natural countermeasure is therefore to modify the
audit procedure voters carry out as follows: In addition to
checking whether the audited ballot in fact is computed with
the voter’s choice and the random coins provided by the
browser for that ballot, a voter also makes sure that all ballots
(including the submitted ballot) constructed by the browser are
different. For this purpose, a voter would typically record the
ballots in some way, e.g., by having them emailed to her, and
then compare these ballots.

The intuition behind this countermeasure is that the browser
now has to use fresh ballots in every round. Now, if two voters
are assigned the same alias, they may choose to audit their
ballots a different number of times and, by the above, submit
different ballots with the same alias. Hence, the clash attack
would be detected with non-negligible probability.

We prove in Section VIII that this variant of Helios in fact
has a relatively good level of accountability and veriﬁability.
Conversely, we also formally show that this variant of Helios
without the ﬁx does not provide a sufﬁcient level of account-
ability and veriﬁability.

IV. THREEBALLOT AND VAV

We now brieﬂy recall

the ThreeBallot and VAV voting
systems [13], [12], following the representation in [9]. Then
we discuss how the clash attack applies to these systems.

A. The ThreeBallot System

In ThreeBallot [12], a voter is given a multi-ballot consisting
of three simple ballots, also called a three-ballot. On every
simple ballot the candidates are printed in the same ﬁxed order.
In the secrecy of a voting booth, the voter is supposed to ﬁll
out all three simple ballots in the following way: She marks
the candidate of her choice on exactly two simple ballots and
every other candidate on exactly one simple ballot; Figure 1
shows two ways of voting for candidate B in an election with
two candidates, candidate A and candidate B. After this, she
feeds all three simple ballots to a voting machine (some kind
of scanner) and indicates the simple ballot she wants to get
as a receipt. The machine checks the well-formedness of the
three-ballot, prints secretly random numbers on each simple
ballot, where numbers on different simple ballots are chosen

400

independently, and gives the voter a copy of the chosen simple
ballot, with the random number printed on it. Note that the
voter does not get to see the random numbers of the remaining
two simple ballots. As usual for ThreeBallot, we assume that
the machine is constructed in such a way that it does not
get to know which simple ballot has been taken as a receipt.
The scanner keeps all three simple ballots (now separated)
in a ballot box. We assume that clerks guarantee that only
registered voters can vote and that every voter votes at most
once.

In the tallying phase, the voting machine posts all (electronic
copies of) the cast simple ballots in a random order on the
bulletin board. From the ballots shown on the bulletin board
the result can easily be computed: the number of votes for the
i-th candidate is the number of simple ballots with the i-th
position marked minus the total number of votes, which is the
total number of simple ballots on the bulletin board divided
by three.

ThreeBallot was meant to provide (some level of) veriﬁabil-
ity. A crucial assumption for this, already made in the original
paper [12], is that neither the scanner, the voting authority, nor
the bulletin board know which simple ballots have been taken
as receipts by honest voters before all ballots are published on
the bulletin board. Now the intuition behind why ThreeBallot
provides (some level of) veriﬁability is that it should be risky
for any party to remove or alter simple ballots in order to
manipulate the result since the probability that the modiﬁcation
of k simple ballots goes undetected is merely ( 2
3

Unfortunately, as we will see in Section IV-C, this argument,

)k.

found in the literature, is ﬂawed.

B. The VAV System

In VAV [12], a voter is given a three-ballot consisting of
three simple ballots. On every simple ballot the candidates
are printed in the same ﬁxed order. On the top of one of
those simple ballots the letter A is printed; on the top of the
remaining two simple ballots the letter V is printed. In the
secrecy of a voting booth, the voter is supposed to ﬁll out her
three-ballot in the following way: (S1) She marks the position
next to the candidate of her choice on one of the V-ballots
and then (S2) she marks the position next to some randomly
chosen candidate on the two remaining simple ballots, one
V- and one A-ballot. Figure 2 shows all three ways of ﬁlling
out the three-ballot for candidate 1 in an election with three
candidates. After this, she feeds all three simple ballots to
a voting machine (some kind of scanner) and indicates the
simple ballot she wants to get as a receipt. The machine checks
the well-formedness of the three-ballot, prints secretly random
numbers on each simple ballot, where numbers on different
simple ballots are chosen independently, and gives the voter
a copy of the chosen simple ballot, with the random number
printed on it. Note that the voter does not get to see the random
numbers of the remaining two simple ballots. The scanner
keeps all simple ballots (now separated) in a ballot box.
the voting machine posts all

the
(electronic copies of) cast simple ballots in a random order

In the tallying phase,

(a)

(b)

(c)

V
1 : x
2 : o
3 : o

V
1 : x
2 : o
3 : o

V
1 : x
2 : o
3 : o

A

1 : x
2 : o
3 : o

A

1 : o
2 : x
3 : o

A

1 : o
2 : o
3 : x

V
1 : x
2 : o
3 : o

V
1 : o
2 : x
3 : o

V
1 : o
2 : o
3 : x

Fig. 2. Three ways of voting for the candidate 1 in the VAV protocol, where
x represents a marked position and o represents an unmarked position.

on the bulletin board. From the ballots shown on the bulletin
board the result can easily be computed: All A-ballots and
the corresponding V-ballots (i.e. V-ballots marked at the same
position) are removed. From the remaining V-ballots the
number of votes for each candidate can directly be read off.
Similarly to ThreeBallot, VAV is supposed to provide (some
level of) veriﬁability because it should be risky for any party
to remove or alter simple ballots in order to manipulate the
result, again under the assumption that neither the scanner, the
voting authority, nor the bulletin board know which simple
ballots have been taken as receipts by honest voters before all
ballots are published on the bulletin board.

C. The Clash Attack on ThreeBallot and VAV

We ﬁrst present the clash attack on ThreeBallot. We assume
that the voting machine (i.e., the scanner) and the bulletin
board are dishonest.

the same number. (Roughly speaking,

The idea of the attack is as follows: The voting machine
simply prints the same serial number on those simple ballots
which have the same pattern, i.e., where the same candidates
are marked. We note that it is not necessary that all such
simple ballots get the same serial number. It sufﬁces if some
get
the number of
clashes corresponds to the number of votes that can safely be
manipulated.) The bulletin board can now safely replace all
but one simple ballot with the same serial number by simple
ballots of its choice (with new serial numbers). The bulletin
board only needs to make sure that altogether the published
set of simple ballots remains consistent, i.e., the set of simple
ballots can be grouped into a set of well-formed three-ballots,
and hence, votes. This can in fact easily be done as follows:
First, it is not hard to see that a given consistent set of simple
ballots can efﬁciently be grouped into a set of consistent three-
ballots. Now, for example, if we have two three-ballots of the
form

and

A: x
B: o

A: o
B: x

A: x
B: o

A: x
B: x

A: o
B: x

A: o
B: o

in that set and the simple ballots in the middle of these two
three-ballots have the same serial number, then the bulletin
board can replace the simple ballot of the ﬁrst three-ballot,

401

say, by A: x
B into a vote for A; similarly for other cases.

B: o , which turns the ﬁrst three-ballot from a vote for

Since the bulletin board stays consistent and all voters ﬁnd
“their” receipt on the bulletin board, the clash attack goes
unnoticed. We emphasize that this attack works even if the
scanner and the bulletin board do not know which simple
ballots voters chose as receipts. Also note that clerks in polling
stations do not necessarily get to see simple ballots with the
serial numbers printed on them and voters typically only get
to see their receipts; occasionally maybe a few more receipts
of other voters. So it is rather unlikely that duplicates will be
noticed, and moreover, voters and clerks are not required to
check for duplicates.

Similarly to the Wombat voting system, ThreeBallot keeps a
paper trail and recounting of ballots would uncover the clash
attack. But again, the point of a veriﬁable voting system is
to make the recounting superﬂuous in cases where there have
been no complaints.

Given the clash attack on ThreeBallot presented above, it is
easy to see how the clash attack on VAV works. The main idea
is the same: The scanner prints the same serial number on (at
least some) simple ballots with the same pattern. The bulletin
board can then safely modify duplicated simple ballots and by
this manipulate the result of the election.

As already mentioned in the introduction, in [9] another
attack on the veriﬁability of ThreeBallot and VAV was pre-
sented. This attack assumes a dishonest bulletin board and
a dishonest voter (or alternatively a dishonest scanner). The
main idea here is that the dishonest voter tells the bulletin
board the serial number of its receipt. The bulletin board can
then change this voters receipt on the bulletin board, which
altogether corresponds to a voter casting an invalid three-
ballot, say one where on all three simple ballots candidate
B is marked. Now, the trick is that this invalid three-ballot
together with a three-ballot which represents a vote for A form
two votes for B. So, the attack presented in [9] and the one
presented here are quite different: the trust assumptions are
different and the basic ideas are different, in particular, clashes
do not play a role in [9].

One countermeasure for the clash attack, which is similar
to one of the proposals for the Wombat system, would be
to print serial numbers on ballots in advance and possibly
conceal
let a
different machine, which does not learn the patterns, print
the serial numbers. However, since ThreeBallot and VAV have
other quite serious problems with veriﬁability [9], we do not
elaborate further on countermeasures for these systems.

them (with a scratch strip) or, alternatively,

V. ACCOUNTABILITY AND VERIFIABILITY

In this section, we brieﬂy recall the deﬁnition of (com-
putational) accountability and veriﬁability of [10]. We start
with the notion of a protocol. For the purpose of this paper, a
protocol describes a voting system, including the honest and
possible dishonest behavior of parties.

A. Protocols

A protocol P speciﬁes the set of agents and channels these
agents can communicate over. Moreover, P speciﬁes, for every
agent a, a set Πa of all programs a can run and a set ˆΠa ⊆ Πa
of honest programs of a, i.e., the set of programs that a runs if
a is honest. (Formally, a program is modeled as a probabilistic
polynomial-time interactive Turing machine.)
(cid:4) . . . (cid:4) πan

Let P be a protocol with agents a1, . . . ,a n. Aninstance of
∈ Πai,
P is a process of the form π = (πa1
where (cid:4) denotes process composition. An agent ai is honest
∈ ˆΠai. Arun of P is a run of some
in such an instance, if πai
instance of P. An agent ai is honest in a run r, if r is a run of
an instance of P with honest ai. A property γ of P is a subset
of the set of all runs of P. By¬γ we denote the complement
of γ.

) with πai

B. Accountability

The deﬁnition of accountability is w.r.t. an agent J of the
protocol who is supposed to blame protocol participants in
case of misbehavior. The agent J, sometimes referred to as a
judge, can be a “regular” protocol participant or an (external)
judge, who is typically provided with additional information
by other, possibly untrusted protocol participants.

Informally speaking, accountability requires two conditions

to be satisﬁed:

(i) (fairness) J (almost) never blames protocol participants

who are honest, i.e., run their honest program.

(ii) (completeness) If, in a run, some desired goal of the pro-
tocol is not met—due to the misbehavior of one or more
protocol participants—then J blames those participants
who misbehaved, or at least some of them (see below).
For example, for voting protocols a desired goal could be that
the published result of the election corresponds to the actual
votes cast by the voters. The completeness condition then
guarantees that if in a run of the protocol the published result
of the election does not correspond to the actual votes cast by
the voters (a fact that must be due to the misbehavior of one
or more protocol participants), then one or more participants
are held accountable by J; by the fairness condition they are
rightly held accountable.

A verdict

the form dis(a),

To specify the completeness condition in a ﬁne-grained way,
the notions of verdict and an accountability property are used.
is a positive boolean formula ψ built from
propositions of
for an agent a, where
dis(a) is intended to express that a misbehaved (behaved
dishonestly), i.e., did not follow the prescribed protocol. For
example,
in a voting protocol with a voting machine M
and auditors A1, . . . ,A r, a verdict (of a judge) of the form
dis(M)∨ (dis(A1)∧ . . .∧ dis(Ar)) expresses the judge’s belief
that either the voting machine misbehaved or all the auditors
misbehaved. We will denote by Fdis the set of all verdicts.

The agent J, i.e., the judge, can state a verdict ψ by sending
ψ on its dedicated output channel decisionJ. For a protocol P
and an instance π of P, a verdict ψ is true in π, written π |= ψ,

402

is

a

tuple

constraint

iff the formula ψ evaluates to true with the proposition dis(a)
set to false, if a is honest in π, and set to true otherwise.
(α,ψ1, . . . ,
An accountability
ψk), written (α ⇒ ψ1 | ··· |ψ k), where α is a property of
P and ψ1, . . . ,ψ k ∈ Fdis. Such a constraint covers a run r, if
r ∈ α.
Intuitively, in a constraint C = (α ⇒ ψ1 | ··· | ψk) the set α
contains runs in which some desired goal of the protocol is not
met (due to the misbehavior of some protocol participant). The
formulas ψ1, . . . ,ψ k are the possible (minimal) verdicts that are
supposed to be stated by J in such a case; J is free to state
stronger verdicts (by the fairness condition these verdicts will
be true). Formally, for a run r, J ensures C in r, if either r /∈ α
or J states in r a verdict ψ that implies one of ψ1, . . . ,ψ k (in
the sense of propositional logic).

f ((cid:2)) ≤ 1

(cid:2)c , for all (cid:2) > (cid:2)0. The function f

In practice, so-called individual accountability is highly
desirable in order to deter parties from misbehaving. Formally,
(α ⇒ ψ1 | ··· | ψk) provides individual accountability, if for
every i ∈ {1, . . . ,k}, there exists a party a such that ψi implies
dis(a). In other words, each ψ1, . . . ,ψ k determines at least one
misbehaving party.
A set Φ of constraints for protocol P is called an account-
ability property of P. Typically, an accountability property Φ
covers all relevant cases in which desired goals for P are not
met, i.e., whenever some desired goal of P is not satisﬁed
in a given run r due to some misbehavior of some protocol
participant, then there exists a constraint in Φ which covers r.
As usual, a function f from the natural numbers to the
interval [0,1] is negligible if, for every c > 0, there exists
(cid:2)0 such that
is
overwhelming if the function 1− f is negligible. A function
is δ -bounded if, for every c > 0 there exists (cid:2)0 such that
f
f ((cid:2)) ≤ δ + 1
Let P be a protocol with the set Σ of agents and Φ be
an accountability property of P. Let π be an instance of P,
and J ∈ Σ be an agent of P. We write Pr[π(1(cid:2)) (cid:10)→ ¬(J : Φ)]
to denote the probability that π, with security parameter 1(cid:2),
produces a run such that J does not ensure C in this run, for
some C ∈ Φ.
An agent J is computationally fair in P, if, for all instances
π of P, J states false verdicts only with negligible probability,
where a verdict ψ is false in a run r of π if π (cid:12)|= ψ.
Deﬁnition 1 (Computational accountability [10]). Let P be
a protocol with the set of agents Σ, J ∈ Σ, an accountability
property Φ of P, and δ ∈ [0,1]. We say that J ensures (Φ,δ )-
accountability for protocol P (or P is (Φ,δ )-accountable
w.r.t. J) if

(cid:2)c , for all (cid:2) > (cid:2)0.

(cid:3)

(cid:2)

Pr

π(1(cid:2)) (cid:10)→ ¬(J : Φ)

(i) (fairness) J is computationally fair in P and
(ii) (completeness) for every instance π of P, the probability
is δ -bounded as a function of (cid:2).
In the completeness condition, it is of course desirable that
δ = 0, i.e., the probability that J fails to ensure a constraint
is negligible. However, this is typically too demanding, as
illustrated in [10] and by our formal analysis of Helios
presented in the subsequent sections.

C. Veriﬁability

Let P be a protocol and γ be a property of P, called the
goal of P. An agent J accepts a run r, if in this run J sends
the message accept on channel decisionJ. Intuitively, J accepts
a run if she believes that the goal has been achieved in this
run. The agent J may be a regular protocol participant, e.g., a
voter, or an external judge, who is provided with information
by (possibly untrusted) protocol participants.

if a is honest

The deﬁnition of veriﬁability, besides the goal, has an addi-
tional parameter: a positive boolean formula over propositions
of the form hon(a), for an agent a. Such a formula describes
a group or groups of participants that can guarantee, when
running their honest programs, that the goal of the protocol is
achieved. We will denote the set of such formulas by Fhon.
For example, for a voting protocol with a voting machine M
and auditors A1, . . . ,A r, one might expect that to achieve the
goal of the protocol it is sufﬁcient that M is honest and at least
one of the auditors A1, . . . ,A r is honest. This can be expressed
by the formula ϕex = hon(M)∧ (hon(A1)∨···∨hon(A r)).
For an instance π of P and ψ ∈ Fhon, we write π |= ψ
if ψ evaluates to true with the proposition hon(a) set to
true,
to false otherwise. By
Pr[π(1(cid:2)) (cid:10)→ (J : accept)] we denote the probability that π, with
security parameter 1(cid:2), produces a run which is accepted by J.
Analogously, by Pr[π(1(cid:2)) (cid:10)→ ¬γ, (J : accept)] we denote the
probability that π, with security parameter 1(cid:2), produces a run
which is not in γ, i.e., the goal γ is not achieved in that run,
but the run is nevertheless accepted by J.
Deﬁnition 2 (Computational veriﬁability [10]). Let P be a
protocol with the set of agents Σ. Let δ ∈ [0,1], J ∈ Σ, ψ ∈
Fhon, and γ be a property of P. Then, we say that the goal
γ is guaranteed in P by ψ and δ -veriﬁable by J if for every
instance π of P the following conditions are satisﬁed:
(i) If π |= ψ, then Pr[π(1(cid:2)) (cid:10)→ (J : accept)] is overwhelming
(ii) Pr[π(1(cid:2)) (cid:10)→ ¬γ, (J : accept)] is δ -bounded as a function

as a function of (cid:2).

in π, and set

of (cid:2).

Just as in the case of accountability, requiring the probability
in (ii) to be negligible, i.e., δ = 0, is too strong for many
reasonable protocols. It is shown in [10] that veriﬁability is a
special case of accountability (see also our analysis of Helios
below).

VI. ANALYSIS OF THE ORIGINAL VARIANT OF HELIOS
In this section, we formally analyze accountability and
veriﬁability of the original version of the Helios voting system
with homomorphic aggregation of ballots, as described in
Section III; the variant with mixnets can be analyzed similarly
and such an analysis should yield similar results.

A. The Protocol Model

Following Section III-A, the system can be described in a
straightforward way as a protocol in the sense of Section V-A.
However, we ﬁx some more details.

The participants in this system are the following:

403

– The election administrator A, who is assumed to be honest,
i.e., in the terminology of Section V-A, ΠA is required to
contain only the honest program of A.

– The election server S with a bulletin board BB, which can
be honest or dishonest, i.e., ΠS contains, besides the honest
programs of S and BB, all probabilistic polynomial-time
programs (with the appropriate interface to the rest of the
system); we assume, however, that once the content of the
bulletin board is published, the bulletin board presents the
same content to every party and, moreover, every party is
able to obtain this content. In what follows, we do not
distinguish the election server S and the bulletin board BB
and use these terms interchangeably.

– The (human) voters v1, . . . ,v n, which, similarly to S, can be

– Browsers (client programs) of voters b1, . . . ,b n, which can

honest or dishonest.

be honest or dishonest.

– External verifying programs of voters vp1, . . . ,vp n, which
are assumed to be honest (this is a reasonable assumption,
as they may be provided by independent parties).

– The authentication authority AA, which can be honest or

dishonest.

– Decryption trustees D1, . . . ,D m, which can be honest or

dishonest.
The election administrator ﬁrst creates an election by post-
ing certain parameters, such as a list of candidates (choices or
questions) and the list of eligible voters. Then, the decryption
trustees create in a distributed manner a public/private key
pair for a homomorphic encryption scheme, such that every
decryption trustee holds a share of the private key. The public
key is sent to the administrator, who publishes a signed ﬁn-
gerprint of the election, i.e., a signed hash over all parameters,
including the public key.

The authentication authority is supposed to send to every
voter a credential (password), which she needs to submit when
casting a ballot.

In the voting phase, a voter can abstain from voting or
decide to vote (for some candidate). We model this choice
by a probability distribution p = p0, . . . , pl, where l
is the
number of candidates, such that a voter abstains from voting
with probability p0 and votes for candidate i, for i ∈ {1, . . . ,l},
with probability pi.

A voter who has decided to vote, prepares her ballots using
her browser. A ballot consists of the encrypted choice of
the voter and a zero-knowledge proof that the ballot is well-
formed.

As already described in Section III-A, voters can choose to
either cast a ballot or audit it. We parameterize the system
by a sequence of probabilities (cid:3)q = q1,q2, . . ., where qi
is
the probability that an honest voter, when she gets to decide
whether to audit her i-th ballot or not, chooses audit. The level
of accountability/veriﬁability Helios provides will depend in
such a sequence.

If a voter eventually decides to cast a ballot, this ballot is
submitted to the authentication authority who authenticates the
voter (requiring the password) and then is supposed to forward

this ballot to the election server. A voter who wants to vote
but did not get a credential from the authentication authority
would complain.

We note that the voter behavior we model here is slightly
simpliﬁed to a real voter. For instance, a voter who decides not
to vote (this decision is taken with probability p0) also does
not prepare or audit any ballots. However, a real voter could
prepare and audit some ballots, but then decide not to actually
cast a ballot. Also, as already mentioned, we do not allow
voters to revote. We emphasize that while these simpliﬁcations
ease the presentation of the model and the analysis, they do
not change our negative or positive results.

After the voting phase is ﬁnished, the content of the bulletin
board (containing voter name/ballot pairs) is published and
signed by the election server. Voters can now check this
content. We model this step by parameterizing the system with
a probability qcheck that an honest voter checks the bulletin
board: A voter who has voted checks that her ballot appears
on the bulletin. A voter who has not voted makes sure that no
ballot with her name appears on the bulletin board, but that
she obtained a credential from the authentication authority that
would have enabled her to vote (and complains otherwise).
Note that due to that procedure, ballot stufﬁng is not possible
(more precisely, highly risky): As the list of eligible voters
is correctly published, the adversary cannot add a vote for a
non-eligible voter. Further, if the adversary votes using a name
of an abstaining voter, this is detected with probability qcheck.
Finally, the published ballots are then multiplied and the

resulting ciphertext is decrypted by the decryption trustees.

We denote the protocol modeled as described above by
PHelios(n,(cid:3)q,qcheck, p) where n is the number of voters, (cid:3)q, qcheck
and p are as described above. So far we have not speciﬁed a
veriﬁcation or judging procedure, i.e. the steps that a protocol
participant or an observer can take to determine whether a run
should be accepted or rather some verdict should be stated.
Such a procedure will be speciﬁed below.

We take the standard cryptographic assumptions for the
used cryptographic primitives, in particular, digital signatures,
zero-knowledge proofs, and homomorphic encryption. How-
ever, our proofs for accountability/veriﬁability do not require
encryption to ensure conﬁdentiality of the plaintext. (Clearly,
this would be needed for vote privacy.)

B. Properties of the Protocol
Goal.
Ideally, one might expect the system to provide in-
dividual accountability (see Section V-B) whenever the goal
γopt is violated, where γopt contains all runs in which the result
returned in the tallying phase exactly corresponds to the input
of all the voters. However, as already noted in [10], this goal
is too strong for almost all real voting systems, and it is in fact
too strong for Helios, as it is impossible to give any guarantees
concerning dishonest voters: a dishonest voter might indicate
to the (dishonest) bulletin board that she is not going to check
her receipt and that the bulletin board is free to change her
ballot.

404

Therefore, the best goal γ we can hope for is that the result
is correct up to the votes of dishonest voters. More formally,
γ is satisﬁed in a run if the published result exactly reﬂects
the actual votes of the honest voters in this run and votes of
dishonest voters are distributed in some way on the candidates,
possibly in a different way than how the dishonest voters
actually voted. We analyze Helios with respect to this goal. If
this goal is achieved, one can be sure that all votes of honest
voters are counted correctly and that votes of dishonest voters
are counted at most once.

For the analysis of voting systems it is instructive to also
consider a family of goals γk, where γk coincides with γ except
that up to k of the votes of honest voters (rather than only
dishonest voters) may be altered as well; obviously γ = γ0.
Note that since honest voters check their receipts only with
a certain probability, undetected altering of votes by voting
authorities/machines may occur. (We will exactly measure the
probability for such things to happen in our analysis.)
Problems.
In some situations, it is impossible to determine
who misbehaved. This problem will be reﬂected in the rela-
tively weak accountability property we can state for Helios,
which is far from corresponding to individual accountability.
This also inﬂuences the level of veriﬁability one can state for
Helios. Intuitively, the main problems are as follows:

Problem 1. If a voter vi complains that the bulletin board
does not show her ballot (correctly) or that a ballot is shown
even though the voter did not vote, it is unclear who cheated: it
may be the voter (who possibly has falsely claimed that some-
thing went wrong), the browser of the voter (which possibly
has not submitted any ballot or has submitted a wrong ballot),
the bulletin board (which has possibly changed/discarded the
ballot), or the authentication authority (which might have used
the voters password to vote). Hence, a judge can in this
case only state dis(vi) ∨ dis(bi) ∨ dis(BB) ∨ dis(AA). Such a
(necessarily) coarse verdict has serious negative consequences:
It
the
involved parties are not deterred from misbehaving. Moreover,
it is not clear what to do after such a verdict is stated. If we
abort the election process in such a case, then any dishonest
voter can easily obstruct the whole election. If we ignore
voters’ complaints and just continue the process, then we lose
veriﬁability.

is impossible to punish a particular party. Hence,

Problem 2. If a voter complains that the auditing of a ballot
failed, it is not clear whether the browser actually manipulated
the ballot or whether the voter complained for no reason.
Therefore, the judge can only state dis(vi)∨ dis(bi). However,
this problem is less severe than the previous one, since a voter
could switch to another browser (client program) and/or to
another machine and try again.

Problem 3. If a voter complains that she did not get a
credential from the authentication authority, it is not clear
whether the authority in fact did not send a credential or
whether the voter complained for no reason. Therefore, the
judge can only state dis(vi)∨ dis(AA). However, this problem
is, again, less severe than the ﬁrst one, since a voter could try
to somehow obtain a credential before the voting phase ends.

Judging Procedure. In order to be able to formally state and
prove the level of accountability Helios provides, we need to
deﬁne a judging procedure which decides whether to accept a
run or whether to blame (groups of) parties. Such a procedure
should, in fact, be part of the protocol speciﬁcation.

The judging procedure is based solely on publicly available
information, and hence, can be carried out both by an exter-
nal judge and a regular protocol participant. The procedure
consists of the following steps, where we assume that the
procedure is run honestly by some party a.
J1. If a participant b deviates from the protocol in an obvious
way, e.g., a decryption trustee refuses to contribute to the
decryption or a zero-knowledge proof is not correct, then
a states dis(b).

J2. If a voter vi complains that her ballot does not appear
(correctly) on the bulletin board or a ballot appears even
though vi did not vote, a states the verdict dis(vi) ∨
dis(bi)∨ dis(BB)∨ dis(AA), as explained above. We denote
the set of runs in which some voter complains in that way
by αcompl.
J3. If a voter vi complains that the auditing of a ballot failed,
a states dis(vi)∨ dis(bi), as explained above. We denote
this event by αv−compl.
J4. If a voter vi complains that she did not get a creden-
tial from the authentication authority, a states dis(vi) ∨
dis(AA), as explained above. We denote this event by αcred.

J5. If none of the above happens, a accepts the run.

Let a be a regular protocol participant or an observer. By
Pa
Helios(n,(cid:3)q,qrec, p) we denote the protocol PHelios(n,(cid:3)q,qrec, p),
where the agent a carries out the judging procedure described
above, possibly in addition to the program a runs anyway.
We assume a to be honest, in particular, to run the judging
procedure as described.
Accountability. Due to the problems described above, with
the ﬁrst problem being the most severe one, we can only
prove accountability of the considered variant of Helios for
a relatively weak accountability property Φk (that reﬂects
these problems). More precisely, Φk consists of the following
accountability constraints:

αcompl ⇒ dis(v1)∨dis(b1)∨dis(BB)∨dis(AA) | . . .
··· | dis(vn)∨dis(bn)∨dis(BB)∨dis(AA)
αv−compl ⇒ dis(v1)∨ dis(b1) | . . .
··· | dis(vn)∨ dis(bn)
αcred ⇒ dis(v1)∨ dis(AA) | . . .
··· | dis(vn)∨ dis(AA)
⇒ dis(BB) | dis(AA)

| dis(D1) | ··· | dis(Dm).

¬γk ∩¬αcompl∩

¬αv-compl ∩¬αcred

the parameter δ k

We now deﬁne
system
Helios(n,(cid:3)q,qrec,(cid:3)p) and the goal γk, which captures the prob-
Pa
ability that something went wrong (γk was not achieved), but
nobody was blamed. (Recall that k is the tolerated number
of incorrectly counted votes of honest voters.) We will later

the

for

(cid:4)(cid:4)

(cid:5)

n∏

∗
ji

(cid:5)k+1

consider a special case of the formula for δ k, which is easier
let us note already that δ k decreases
to grasp. However,
exponentially in k.

i

i

i

n∑

n∏

∗
ji

˜q

∗
jm

q

+ (1− qcheck)

˜q

i=1

m=1

i=m+1

j1,..., jn∈N

= ∑ j<i q∗
= 1.

δ k = sup
= q1···qi−1· (1−qi) is the probability that an honest
where q∗
voter casts her i-th ballot, and hence, audits the previous i− 1
ballots, and ˜q∗
j is the probability that an honest voter
casts the j-th ballot, for some j < i. For the case i = 0, we set
= 0 and ˜q∗
q∗
i
Now we are ready to formally state the level of accountabil-
ity for the considered variant of Helios, where a proof sketch
of the theorem is given in the appendix.
Theorem 1. Let a be an external
judge or a voter, and
let k ≤ n. The agent a ensures (Φk,δ k)-accountability for
Pa
Helios(n,(cid:3)q,qrec,(cid:3)p).
This theorem implies that, in Pa

Helios, the probability that
the goal γk is not achieved but a nevertheless does not blame
anybody is at most δ k, up to some negligible value. Moreover,
if the goal is not achieved (¬γk), then a single agent can be
held accountable (and because of fairness rightly so) if no
voter complained that her ballot does not appear on the bulletin
board (¬αcompl), no voter complained that auditing of a ballot
failed (αv-compl), and no voter complained that she did not get
a credential (¬αcred); as explained, in the other cases, blaming
individual parties is not possible.

As mentioned, since the expression δk, as deﬁned above,
may be difﬁcult to grasp, we consider a special case for which
this expression becomes easy to understand. In this special
case, we assume that a voter, in each round, audits a ballot
with the same probability q ∈ [0,1], i.e., we assume that qi = q
for all i. With this, we can show:
Corollary 1. Let q ∈ [0,1] and let (cid:3)q = q1,q2, . . . with qi =
judge or a voter, and
q for all
let k ≤ n. The agent a ensures (Φk,δ k
q )-accountability for
Pa
Helios(n,(cid:3)q,qcheck,(cid:3)p), where

i. Let a be an external

q = max(1− qcheck,1− q)k+1.
δ k

Note that this formula, which decreases exponentially in
k, reﬂects the following intuition: If, in each round, the voter
audits her ballot with the same probability, and if the adversary
tries to change a vote, he either changes/adds a ballot on the
bulletin board (which goes undetected with probability 1 −
qcheck) or he lets the browser encrypt a different vote. In the
latter case, as the probability for getting detected is the same
in each round, the adversary can simply change the ﬁrst ballot
(which goes undetected with probability 1 − q); waiting for
other later ballots does not increase the adversaries chances of
not being caught.
Veriﬁability.
(cid:6)
Let us ﬁrst observe that since a ensures
(Φk,δ k)-accountability, a also ensures ({¬γk ⇒ ψ},δ k)-
b∈Σ dis(b) and Σ is the set of all
accountability, where ψ =

405

participants in Pa
Helios(n,(cid:3)q,qrec,(cid:3)p), because whenever a states
some verdict ψ(cid:2), then ψ(cid:2) implies ψ. Let us also observe that
the judging procedure (that a runs) is constructed in such a way
that a accepts a run if and only if a does not blame anybody.
Altogether, this means that if the goal γk is not achieved, a will
blame someone (i.e., not accept the run), except with proba-
bility at most δ k (plus some negligible function). Conversely,
if all parties are honest, a will accept the run (because of the
fairness condition). But this means, we obtain the following
level of veriﬁability of Pa
Corollary 2. Let a be an external
Helios(n,(cid:3)q,qcheck,(cid:3)p), the goal γk is guaranteed by
Pa
and δ k-veriﬁable by a.

(cid:7)
judge or a voter. In
a∈Σ hon(a)

Helios(n,(cid:3)q,qrec,(cid:3)p).5

the weakness of

This corollary reﬂects
the system
Pa
Helios(n,(cid:3)q,qrec,(cid:3)p) already discussed for accountability: by
wrongly complaining, every single dishonest voter can spoil
the election process, i.e., a cannot accept the run. Conversely,
only if all parties are honest, including all voters, it is guar-
anteed that a can accept the run. So, the level of veriﬁability
provided by the original variant of Helios is very good in
terms of the probability that cheating is detected, but quite
weak in terms of the guarantees that an election observer, a,
will accept a run. (Ideally, in a voting system, it should sufﬁce
if only the voting authorities are honest, in order to ensure that
the election is successful, i.e., is accepted by observers.).

VII. ACCOUNTABILITY AND VERIFIABILITY OF HELIOS

WITH DETACHED NAMES

In this section, we analyze accountability of the variant of
Helios with detached names, with and without the countermea-
sure described in Section III. However, we consider only the
variant where the names of the voters who voted are published
on the bulletin board (although detached from the ballots). In
the variant where these names are not published at all, ballot
stufﬁng cannot be prevented, and hence, this version would
not provide a reasonable label accountability and veriﬁability.
We start with a description of the protocol model.

A. The Protocol Model

The protocol model is very similar to the original variant,
as described in Section VI-A, except for the following differ-
ences:
(a) The names of voters are not published on the bulletin
board linked to their ballots, they are rather published
independently.

(b) In the version with the additional voter-provided random-
ness, the voters provide their randomness in the voting
phase, as described in Section III-C.

We denote the variant of the protocol without voter provided
randomness by Pa
Helios−DN(n,(cid:3)q,qcheck, p) and the one with
voter provided randomness by Pa
Helios−DNVR(n,(cid:3)q,qcheck, p,r),
where (cid:3)q, qcheck, and (cid:3)p are deﬁned as in Section VI and r is a

5A general theorem showing that accountability implies veriﬁability was

proved in [10], Proposition 1.

probability distribution on the set of valid inputs (e.g. alpha-
numeric strings), determining the way honest voters choose
their random input.

B. Negative Result

While it was already argued in Section III-B that the variant
without voter-provided randomness does not ensure a sufﬁcient
level of veriﬁability, we now make this statement precise.
We show that even the very weak accountability property Φ∗
k
consisting of the constraint
¬γk ⇒

dis(b),

(cid:8)
b∈Σ

where Σ contains every participant of the protocol
is not
ensured. This accountability constraint only requires that
somebody is blamed if γk is not fulﬁlled, and thus, it exactly
corresponds to what veriﬁability requires (as discussed at the
end of Section VI-B). More precisely, we show that
this
constraint can be violated with probability close to 1.

Recall

the clash attack for the variant of Helios with
detached names from Section III-B. The result of this attack
was that all the voters who vote for the same candidate and
have audited their ballots the same number of times cast
identical ballots and obtain identical receipts. If c0 denotes a
ﬁxed candidate, the bulletin board can therefore safely replace,
for each group of duplicates for candidates different than c0,
all members of this group, except for one member, and turn
these members into ballots for c0. We letsafe(k ) denote the
event that when the adversary follows this strategy he manages
to change at least k votes of honest voters.

Let P[safe(k)] denote the probability that safe(k) holds true.

Now we immediately obtain:
Theorem 2. Let a be an external
The agent a does not ensure (Φ∗
k
Helios−DN(n,(cid:3)q,qcheck,(cid:3)p) for any δ < P[safe(k + 1)].
Pa

judge or a voter.
,δ )-accountability for

For typical cases,
if only k is not

the probability P[safe(k)]
is close to
1,
too close to the number of honest
voters. Hence, the variant of Helios with detached names
(and without the countermeasure applied) provides virtually
no accountability/veriﬁability. For instance,
in an election
with three candidates, 100 voters, with a uniform distribution
on the candidates (including the choice of abstaining from
voting), and the probability 1
2 that a voter audits a ballot
= q1 = q2 = ···), the probability P[safe(20)] that the
(i.e., 1
2
adversary can change as much as 20 votes without a blaming
anybody is about 0.96.

C. Positive Result

We now show that Pa

Helios−DNVR(n,(cid:3)q,qcheck, p,r) provides a
similar level of accountability as the original variant of Helios
(see Section VI). More precisely, the accountability property is
exactly the same, namely Φk, and, for realistic distributions r
of voter-provided input, the δ -value is only slightly worse than

406

DNUR, let

To deﬁne δ k

δ k; but clearly δ now heavily depends on r. We denote the δ -
value for Helios with detached names and the countermeasure
applied by δ k

DNUR (see below for the deﬁnition).

j denote some ﬁxed candidate (in-
tuitively, the favorite candidate of the adversary). We now
consider the following scenario. We assume that all n voters,
the authentication authority, and the trustees are honest, and
that all browsers and the bulletin board are dishonest. The
browsers, controlled by the adversary, always use the same
randomness for computing all ballots. The intuition is that
by this the adversary produces the maximum number of
duplicate ballots. (However, he always takes the voter-provided
randomness into account as prescribed.) Now, the bulletin
board, which is also controlled by the adversary, replaces,
for each group of duplicates for candidates different than j,
all members of this group, except for one member, and turns
these members into ballots for j. In other words, we consider
a scenario where the adversary tries to generate as many
duplicates as possible and turns as many of these duplicates
as possible into ballots for j without being detected.

Now, by R j

l we denote the probability that in the above
scenario, the adversary can turn exactly l ballots for candidates
different from j into ballots for j. It is easy to see that R j
l only
depends on the probability distributions r and p.
Now, we deﬁne (see below for an explanation):

δ k
DNV R = max

j

· δ k−l,

R j
l

n∑

l=0

where j ranges over all candidates, δ i for i ≥ 0 is deﬁned as
in Section VI, and δ i = 1 for i < 0.
With Φk being the accountability property deﬁned in Sec-

judge or a voter.
for

)-accountability

tion VI, we can show:
Theorem 3. Let a be an external
The
DNV R
Pa
Helios−DNVR(n,(cid:3)q,qcheck,(cid:3)p,r).
The intuition behind the deﬁnition of δ k

(Φk,δ k

ensures

agent

a

DNV R is as follows:
The best strategy of an adversary to change k + 1 votes into
votes for j is to ﬁrst change as many votes as possible in a safe
way by turning duplicates into votes for j, as described above.
If he can change l votes in this way, then still k + 1− l more
votes have to be changed in order to altogether change at least
k +1 votes, and hence, violate the goal γk. For these remaining
k +1−l votes the chances of being able to change these votes
without being detected is δ k−l as in the original variant of
Helios. For the ﬁrst l votes the probability is R j
l . Note that
since the list of voters that actually voted is published, ballot
stufﬁng is prevented for similar reasons as in the case of the
original variant of Helios.

DNV R highly depends on the entropy of the ran-
domness provided by the voters: if they always choose the
same “random” value, Pa
Helios−DNVR(n,(cid:3)q,qcheck,(cid:3)p,r) is essen-
tially the same as Pa
Helios−DN(n,(cid:3)q,qcheck,(cid:3)p) (and hence does not
provide any reasonable level of accountability/veriﬁability).

However, for a realistic entropy of the voters input, the level
of accountability provided by the considered system, as given

Clearly, δ k

by Theorem 3, is quite close to the level of accountability
provided by the original variant of Helios. For instance, let
us consider an election with two candidates, 500 voters, a
uniform distribution on the candidates (including abstention
of voting), and qcheck = q1 = q2 = ··· = 1
2. Then, if the voters
uniformly draw their random input from a dictionary of size
100000 (or using some other distribution providing with the
same entropy, which seems to be a realistic setting), then
δ k
DNV R is 0.565, 0.286, 0.036, and 0.0011 for k equal to 1, 2,
5, and 10, respectively. The level of accountability provided
by the original variant, as given by Corollary 1, is, for the
same parameters, 0.5, 0.25, 0.03125, and 0.00097; hence, quite
similar. In both cases, the probability that more than 10 votes
can be changed is very close to zero.
Veriﬁability. Analogously to Section VI-B, we obtain the
following corollary for the veriﬁability of the system.
Corollary 3. Let a be an external
(cid:7)
judge or a voter. In
Helios−DNVR(n,(cid:3)q,qcheck, p,r), the goal γk is guaranteed by
Pa
a∈Σ hon(a) and δ k
VIII. ACCOUNTABILITY AND VERIFIABILITY OF HELIOS

DNV R-veriﬁable by a.

WITH ALIASES

In this section, we analyze the variant of Helios with aliases,
as described in Section III, with respect to accountability and
veriﬁability. We show that the clash attack is indeed reﬂected
in a very low level of accountability/veriﬁability formally
expressed by a very high δ , which is almost 1. We also show
that the ﬁx proposed in Section III provides a very effective
countermeasure. We start with a description of the protocol
model.

A. The Protocol Model

The protocol model is very similar to the original variant,
as described in Section VI-A, with the following differences:
– After the list of eligible voters is published, but before the
registration phase begins, AA publishes the list of aliases
(the number of aliases should be the same as the number
of eligible voters).

– In the registration phase,

the voters do not only get a
password, but also an alias from the authentication authority,
which needs to be provided along with the password for
authentication when a ballot is cast.

– If a voter who wants to vote has not received any alias,
she complains. Similarly, a voter who decides not to vote,
checks, with probability qcheck, whether she has obtained her
alias and whether this alias appears on the bulletin board.
Note that this procedure prevents ballot stufﬁng: The list
of aliases the adversary publishes cannot be longer than
the list of eligible voters. Also, the adversary cannot add
votes for aliases he did not publish before, and it would
be risky to vote for aliases that abstained from voting, as
these abstaining voters also check the bulletin board (with
probability qcheck).

Besides the problems concerning accountability already men-
tioned in Section VI-B, an additional problem occurs in the

407

alias variant: if the same alias appears twice on the bulletin
board, then it is not clear whether the bulletin board misbe-
haved or whether the authentication authority has assigned this
alias to two different voters. However, this problem is not very
severe, since both parties are part of the election authority.

We take care of this problem by the following changes in

the judging procedure:
J5. If the same alias appears twice on the bulletin board, then
a states dis(BB)∨ dis(AA). We denote the event that the
same alias appears twice on the bulletin board by αtwice.

J6. If none of the above happens, a accepts the run.
We denote this variant of Helios by Pa
Helios−AL(n,(cid:3)q,qcheck, p)
and Pa
respectively, depending on
whether the unﬁxed or ﬁxed version is considered, where in
the ﬁxed version, as described in Section III-C, voters check
the freshness of ballots.

Helios−ALF(n,(cid:3)q,qcheck, p),

As discussed in Section III-B, we assume that the adversary
knows, for some honest voters, how those voters are going to
vote. We will represent this knowledge as sets G1, . . . ,G l of
voters, where l is the number of candidates and Gi contains
those voters that are going to vote for candidate i.

B. Negative Result

We now show that for any δ < 1 the version of Helios
with aliases does not ensure even the very weak accountability
constraint Φ∗
k introduced in Section VII-B, which only requires
that somebody is blamed if the goal is violated.

In our clash attack on Helios with aliases (Section III-B)
the adversary issues the same alias to all the members of
the same group Gi (as deﬁned above). Let K denotes the
maximal number of votes that can be safely changed using the
knowledge represented by the sets G1, . . . ,G l. For instance, if
G1 = {}, G2 = {a,b,c} and G3 = {d,e}, then K = 3, since,
e.g., the adversary could change the votes of b, c, and e.
Now, the following theorem is easy to see. It also immediately
carries over to the veriﬁability of the system.
Theorem 4. Let a be an external judge or a voter. Let k +
1 ≤ K. The agent a does not ensure (Φ∗
,δ )-accountability for
k
Helios−AL(n,(cid:3)q,qcheck, p) for any δ < 1.
Pa
C. Positive Result

the

level of

We now show that
accountability of
Pa
Helios−ALF(n,(cid:3)q,qcheck, p) is comparable to the one for the
other two (ﬁxed) variants of Helios: the accountability property
is almost the same and the δ -value is also very good, although
the concrete values differ.

As the general formula for δ for the considered variant of
Helios is even more complex than the formula for δ k for the
original variant, for brevity of presentation, in this section,
we focus only on the special case where qi = q for all i, i.e.,
honest voters always audit ballots with probability q; see our
technical report [11] for the general case. Let G1, . . . ,G l and
K be deﬁned as above. Further, let the accountability property
Φ(cid:2)
k consist of the constraints for αcompl, αv−compl, and αcred as
deﬁned in Section VI-B and in addition the constraints:

¬γk ∩¬αcompl ∩¬αtwice∩
∩¬αv-compl ∩¬αcred

αtwice ⇒ dis(BB)∨ dis(AA)
⇒ dis(BB) | dis(AA) |

dis(D1) | ··· | dis(Dm).

Theorem 5. Let a be an external
(Φ(cid:2)
The
ALF
k
Pa
Helios−ALF(n,(cid:3)q,qcheck, p), where

ensures

agent

,δ k

a

judge or a voter.
for

)-accountability

ALF = (1− q· qcheck)k+1 .
δ k

Note that δ k
theorem can be found in our technical report [11].

ALF decreases exponentially in k. The proof of this

Similarly to the previous sections, we obtain, as a corollary,
ALF-veriﬁable

that in Pa
and guaranteed by the set of all protocol participants.

Helios−ALF(n,(cid:3)q,qcheck, p), the goal γk is δ k

IX. CONCLUSION

In this paper, we showed that a simple attack, which we call
a clash attack, can successfully be mounted on four different
e-voting systems (and variants thereof), some of which have
been deployed in real elections. This illustrates that the clash
attack is a potentially dangerous attack for a large class of
e-voting systems which try to provide veriﬁability by letting
voters check receipts on a bulletin board. It is interesting future
work to see to which other systems the clash attack could be
applied. We hope that our ﬁndings raise the awareness of this
attack and that future e-voting systems provide mechanisms
to prevent this attack, or if trust assumptions are made which
prevent the attack (e.g., aliases are distributed honestly), that
the scope of these assumptions is made clear.

For the four systems we studied, we proposed countermea-
sures for the clash attack, where some of these countermea-
sures only require changing the audit procedure clerks and/or
voters have to carry out, others change the voting procedure
itself.

For the different variants of Helios (with the countermea-
sures applied, if necessary)—the original variant, the variant
with aliases, and the variant with detached names—we pro-
vided ﬁne-grained analysis results, which highlighted some
further problems with the accountability of Helios orthogonal
to the clash attack and which precisely captured the different
levels of accountability and veriﬁability the different variants
of Helios and the proposed countermeasures provide.

This formal analysis is of independent interest since such
an analysis has rarely been carried out for concrete e-voting
systems, even more so in a cryptographic model which allows
precise measurement of the level of accountability/veriﬁability
a system provides. Also, while veriﬁability is a very prominent
property of e-voting systems, accountability has obtained
much less attention, both in informal and formal treatments.

408

Clearly, by the deﬁnition of the judging procedure, a always
ensures the ﬁrst,
the second and the third accountability
constraint. Therefore, we focus on the probability that the
fourth constraint is not ensured, which is the case if (i) the goal
γ0 is violated, i.e. the adversary changed at least one (honest)
vote, (ii) no voter complains that her ballot does not appear on
the bulletin board (¬αcompl), that the auditing of a ballot failed
(αv-compl), or that she did not get a credential (¬αcred), and (iii)
no individual party is blamed. We show that this happens only
with probability at most δ 0 (plus some negligible value).

First, let us notice that, if the adversary wants to change a
vote, then every time an honest voter, say the i-th voter, ini-
tiates her voting procedure, the adversary faces the following
choice: He can either (A) carry on the correct voting procedure
without changing the voters choice or he can (B) decide to try
to change the ji-th ballot of the voter. Therefore, without loss
of generality, we can represent a strategy of the adversary as a
sequence of integers (cid:3)j = j1, j2, . . . representing the choice of
the adversary: ji = 0 meaning that the adversary carries out the
correct voting procedure for the i-th voter and ji > 0 meaning
that the adversary will try to change her ji-th ballot.

Now, if the adversary runs (B) for the i-th voter, then one

of the following may happen:
(a) The voter submits her j-th ballot, by which the adversary
changes the vote and achieves his goal (he does not need
to change further votes); this happens with probability q∗
j.
ji − 1 ballots and the
adversary does not get the chance to change the j-th ballot.
This case happens with probability ˜q∗
j.

(b) The voter submits one of the ﬁrst

(c) The voter audits her j-th ballot and the attack is detected

(the goal is not achieved).

∗
ji

∗
q
jm

If, after all the voters have voted, the goal is still not achieved,
the adversary has to replace a ballot on the bulletin board
(otherwise he could be used to forge zero-knowledge proofs),
which is detected with probability 1− qrec.
We obtain the following probability that
succeeds using strategy (cid:3)j:
· m−1∏

the adversary

(cid:4)

(cid:5)

n∑

.

˜q

˜q

i=1

m=1

i=1
For a given m, the subformula q∗
ji expresses the
jm
probability that
this strategy succeeded, because case (a)
happened for the m-th voter, and case (b) happened for all pre-
vious voters. The subformula (1− qcheck)· ∏n
ji expresses
the probability that the strategy succeeded because (b) has
happened for all voters and then the adversary successfully
replaced one ballot on the bulletin board.

From the above formula, we obtain δ 0 by taking the
supremum over all possible strategies (cid:3)j, as described above.

i=1 ˜q∗

+ (1− qcheck)· n∏
· ∏m−1
i=1 ˜q∗

∗
ji

REFERENCES

[1] Ben Adida. Helios: Web-based Open-Audit Voting.

In Paul C. van
Oorschot, editor, Proceedings of the 17th USENIX Security Symposium,
pages 335–348. USENIX Association, 2008.

[2] Ben Adida, Olivier de Marneffe, Olivier Pereira, and Jean-Jaques
Quisquater. Electing a University President Using Open-Audit Voting:
Analysis of Real-World Use of Helios. In USENIX/ACCURATE Elec-
tronic Voting Technology (EVT 2009), 2009.

[3] Josh Benaloh and Eric Lazarus. The Trash Attack: An Attack on
Veriﬁable Voting Systems and a Simple Mitigation. Technical Report
MSR-TR-2011-115, Microsoft, 2011.

[4] J.H. Fund. Stealing elections: how voter fraud threatens our democracy.

[5] IACR 2011 Election, 2011.

http://www.iacr.org/elections/2011/

Encounter Books, 2004.

candidates.html.

[6] A. Juels, D. Catalano, and M. Jakobsson. Coercion-resistant Electronic
In Proceedings of Workshop on Privacy in the Eletronic

Elections.
Society (WPES 2005), pages 61–70. ACM Press, 2005.

[7] Simon Kramer and Peter Y. A. Ryan. A modular multi-modal speciﬁca-
tion of real-timed, end-to-end voter-veriﬁable voting systems. In 2011
International Workshop on Requirements Engineering for Electronic
Voting Systems (REVOTE 2011), pages 9–21. IEEE Computer Society,
2011.

[8] Steve Kremer, Mark Ryan, and Ben Smyth. Election Veriﬁability in
Electronic Voting Protocols.
In Dimitris Gritzalis, Bart Preneel, and
Marianthi Theoharidou, editors, 15th European Symposium on Research
in Computer Security (ESORICS2010), volume 6345 of Lecture Notes
in Computer Science, pages 389–404. Springer, 2010.

[9] R. K¨usters, T. Truderung, and A. Vogt. Veriﬁability, Privacy, and
Coercion-Resistance: New Insights from a Case Study. In IEEE Sym-
posium on Security and Privacy (S&P 2011). IEEE Computer Society,
2011.

[10] Ralf K¨usters, Tomasz Truderung, and Andreas Vogt. Accountability:
Deﬁnition and Relationship to Veriﬁability. In Proceedings of the 17th
ACM Conference on Computer and Communications Security (CCS
2010), pages 526–535. ACM, 2010.

[11] Ralf K¨usters, Tomasz Truderung, and Andreas Vogt. Clash Attacks
on the Veriﬁability of E-Voting Systems. Technical Report 2012/116,
Cryptology ePrint Archive, 2012. http://eprint.iacr.org/2012/116/.

[12] R. L. Rivest and W. D. Smith. Three Voting Protocols: ThreeBallot,
VAV and Twin. In USENIX/ACCURATE Electronic Voting Technology
(EVT 2007), 2007.

[13] Ron Rivest. The ThreeBallot Voting System. http://people.csail.mit.edu/

rivest/Rivest-TheThreeBallotVotingSystem.pdf, October 1, 2006.

[14] Ben Smyth, Mark D. Ryan, Steve Kremer, and Mounira Kourjieh.
Towards Automatic Analysis of Election Veriﬁability Properties.
In
Alessandro Armando and Gavin Lowe, editors, Proceedings of the Joint
Workshop on Automated Reasoning for Security Protocol Analysis and
Issues in the Theory of Security (ARSPA-WITS’10), Lecture Notes in
Computer Science. Springer, 2010.

[15] Mehdi Talbi, Benjamin Morin, Val´erie Viet Triem Tong, Adel Bouhoula,
and Mohamed Mejri. Speciﬁcation of electronic voting protocol prop-
erties using adm logic: Foo case study. In Liqun Chen, Mark Dermot
Ryan, and Guilin Wang, editors, Proceedings of the 10th International
Conference Information and Communications Security (ICICS 2008),
volume 5308 of Lecture Notes in Computer Science, pages 403–418.
Springer, 2008.

[16] Wombat Voting system, 2011. http://www.wombat-voting.com/.

APPENDIX A

PROOF SKETCH OF THEOREM 1

Due to the space limitations, we will only provide a sketch
of the proof for k = 0 to give some intuition about how δ k is
obtained.

Let S = Pa

Helios(n,(cid:3)q,qrec,(cid:3)p). Since it is quite easy to show
that a is computationally fair in S, we only focus on the
completeness condition of Deﬁnition 1, which requires that
for all of the accountability constraints in Φ0 the probability
that a does not ensure this constraint is at most δ 0 plus some
negligible function.

409

