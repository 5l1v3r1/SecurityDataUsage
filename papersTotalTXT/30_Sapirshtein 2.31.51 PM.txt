Optimal Selﬁsh Mining Strategies in Bitcoin

Ayelet Sapirshtein1, Yonatan Sompolinsky1, and Aviv Zohar1,2

1 School of Engineering and Computer Science,

The Hebrew University of Jerusalem, Israel

2 Microsoft Research, Herzliya, Israel

{ayeletsa,yoni sompo,avivz}@cs.huji.ac.il

Abstract. The Bitcoin protocol requires nodes to quickly distribute
newly created blocks. Strong nodes can, however, gain higher payoﬀs
by withholding blocks they create and selectively postponing their pub-
lication. The existence of such selﬁsh mining attacks was ﬁrst reported
by Eyal and Sirer, who have demonstrated a speciﬁc deviation from the
standard protocol (a strategy that we name SM1).
In this paper we investigate the proﬁt threshold – the minimal fraction of
resources required for a proﬁtable attack. Our analysis provides a bound
under which the system can be considered secure against such attacks.
Our techniques can be adapted to protocol modiﬁcations to assess their
susceptibility to selﬁsh mining, by computing the optimal attack under
diﬀerent variants. We ﬁnd that the proﬁt threshold is strictly lower than
the one induced by the SM1 scheme. The policies given by our algorithm
dominate SM1 by better regulating attack-withdrawals. We further eval-
uate the impact of some previously suggested countermeasures, and show
that they are less eﬀective than previously conjectured.
We then gain insight into selﬁsh mining in the presence of communication
delays, and show that, under a model that accounts for delays, the proﬁt
threshold vanishes, and even small attackers have incentive to occasion-
ally deviate from the protocol. We conclude with observations regarding
the combined power of selﬁsh mining and double spending attacks.

1

Introduction

In a seminal paper, Eyal and Sirer [9] have highlighted a ﬂaw in the incentive
scheme in Bitcoin. Given that most of the network follows the “standard” Bit-
coin protocol, a single node (or a pool) which possesses enough computational
resources or is extremely well connected to the rest of the network can increase
its expected rewards by deviating from the protocol. While the standard Bitcoin
protocol requires nodes to immediately publish any block that they ﬁnd to the
rest of the network, Eyal and Sirer have shown that participants can selﬁshly
increase their revenue by selectively withholding blocks. Their strategy, which
we denote SM1, thus shows that Bitcoin as currently formulated is not incentive
compatible. On the positive side, SM1 (under the model of Eyal and Sirer) be-
comes proﬁtable only when employed by nodes that possess a large enough share
of the computational resources, and are suﬃciently well connected to the rest of

the network. It is important to note, however, that SM1 is not the optimal best-
response to honest behaviour, and situations in which SM1 is not proﬁtable may
yet have other strategies that are better than strict adherence to the protocol.
Our goal in this paper is to better understand the conditions under which
Bitcoin is resilient to selﬁsh mining attacks. We begin with performing this anal-
ysis with respect to the standard Bitcoin protocol. Additionally, several protocol
modiﬁcations have been put forth, some with the explicit goal of alleviating self-
ish mining, and we suggest our techniques as a tool to provably analyze their
resilience to such attacks. To this end, we consider other possible deviations from
the classic Bitcoin protocol, and establish bounds on their proﬁtability. We later
demonstrate how to apply the same techniques to some of its variants.

The role of incentives in Bitcoin should not be underestimated: Bitcoin trans-
actions are conﬁrmed in batches, called blocks whose creation requires generating
the solution to computationally expensive proof-of-work “puzzles”. The security
of Bitcoin against the reversal of payments (so-called double spending attacks)
relies on having more computational power held by honest nodes than by mis-
behaving nodes. Block creation (which is also known as mining), is rewarded in
bitcoins that are given to the block’s creator. These rewards incentivize more
honest participants to invest additional computational resources in mining, and
thus support the security of Bitcoin.

When all miners follow the Bitcoin protocol, a single miner’s share of the
payoﬀs is equal to the fraction of computational power that it controls (out
of the computational resources of the entire network). However, Selﬁsh mining
schemes allow a strong attacker to increase its revenue at the expense of other
nodes. This is done by exploiting the conﬂict-resolution rule of the protocol,
according to which only one chain of blocks can be considered valid, and only
blocks on the valid chain receive rewards; the attacker creates a deliberate fork,
and (sometimes) manages to force the honest network to abandon and discard
some of its blocks.

The consequences of selﬁsh mining attacks are potentially destructive to the
Bitcoin system. A successful attacker becomes more proﬁtable than honest nodes,
and is able to grow steadily.3 It may thus eventually drive other nodes out of the
system. Proﬁts from selﬁsh mining increase as more computational power is held
by the attacker, making its attack increasingly more eﬀective. Eventually, the
attacker is able to collect all block rewards, to mount successful double spending
attacks at will, and to prevent any transaction from being processed (this is
known as the 50% attack, which requires 50% of the computational resources).

We summarize the contributions of this paper as follows:

1. We provide an eﬃcient algorithm that computes an optimal selﬁsh mining
policy, for any parametrization of the model in [9] (i.e., one that maximizes
the revenue of the attacker, given that all other nodes are following the
standard Bitcoin protocol). We prove the correctness of our algorithm, and
verify our results using simulations.

3 Growth is achieved either by buying more hardware, in the case of a single attacker,

or by attracting more miners, in the case of a pool.

2. Using our algorithm we show that, indeed, there are selﬁsh mining strategies
that earn more money and are proﬁtable for smaller miners compared to
SM1. The gains are relatively small (see Fig. 1 below). This can be seen
as a positive result, lower bounding the amount of resources needed for a
proﬁtable attacker.

3. We evaluate diﬀerent protocol modiﬁcations that were suggested as coun-
termeasures for selﬁsh mining. For the solution suggested by Eyal and Sirer
(in which miners randomly break ties between equal chains), we show that
attackers with strictly less than 25% of the computational resources can still
gain from selﬁsh mining, unlike previously conjectured.

4. We show that in a model that accounts for the delay of block propagation

in the network, attackers of any size can proﬁt from selﬁsh mining.

5. We discuss the interaction between selﬁsh mining attacks and double spend-
ing attacks. We demonstrate how any attacker for which selﬁsh mining is
proﬁtable can execute double spending attacks bearing no costs. This sheds
light on the security analysis of Satoshi Nakamoto [15], and speciﬁcally, on
the reason that it cannot be used to show high attack costs, and must instead
only bound the probability of a successful attack.

Below we provide a preview of some of our ﬁnal results, namely, the revenue
achieved by optimal policies compared to that of SM1 as well as the proﬁt
threshold of the protocol. In the following, α stands for the attacker’s relative
hashrate, and γ is a parameter representing the communication capabilities of
the attacker—the fraction of nodes to which it manages to send blocks ﬁrst
in case of a block race (see Section 2 for more details). Figure 1 depicts the
revenue of an attacker under three strategies: Honest mining, which adheres to
the Bitcoin protocol, SM1, and the optimal policies obtained by our algorithm.
The three graphs correspond to γ = 0, 0.5, 1. We additionally illustrate the curve
of α/(1 − α), which is an upper bound on the attacker’s revenue, achievable only
when γ = 1 (see Section 3). Figure 2 depicts the proﬁt threshold for each γ: If
the attacker’s hashrate α is below the threshold then honest mining is the most
proﬁtable strategy. For comparison, we depict the thresholds induced by SM1 as
well.

2 Model

We follow and extend the model of [9], to explicitly consider all actions available
to the attacker at any given point in time. We assume that the attacker controls
a fraction α of the computational power in the network, and that the honest
network thus has a (1 − α) fraction. Communication of newly created blocks is
modeled to be much faster than block creation, so no blocks are generated while
others are being transmitted.4

4 This is justiﬁed by Bitcoin’s 10 minute block creation interval which is far greater
than the propagation time of blocks in the network. This assumption is later removed
when we consider networks with delay.

 
 
 
 
 
ρ

)
e
u
n
e
v
e
r
(

1

0.9

0.8

0.7

0.6

0.5

0.4

0.3

0.2

0.1

0

0

SM1
Honest mining
α / (1-α)
eps-OPT policy
Upper-bound

0.05

0.1

0.15

0.2

0.25

0.3

0.35

0.4

0.45

0.5

α                

(fraction of hashrate)
(a) γ = 0

 
 
 
 
 
ρ

)
e
u
n
e
v
e
r
(

1

0.9

0.8

0.7

0.6

0.5

0.4

0.3

0.2

0.1

0

0

SM1
Honest mining
α / (1-α)
eps-OPT policy
Upper-bound

0.05

0.1

0.15

0.2

0.25

0.3

0.35

0.4

0.45

0.5

α                

(fraction of hashrate)
(b) γ = 0.5

 
 
 
 
 
ρ

)
e
u
n
e
v
e
r
(

1

0.9

0.8

0.7

0.6

0.5

0.4

0.3

0.2

0.1

0

0

SM1
Honest mining
α / (1-α)
eps-OPT policy
Upper-bound

0.05

0.1

0.15

0.2

0.25

0.3

0.35

0.4

0.45

0.5

α                

(fraction of hashrate)

(c) γ = 1

Fig. 1: The ǫ-optimal revenue and the computed upper bound, as a function of the
attacker’s hashrate α, compared to SM1, honest mining, and to the hypothetical
bound provided in Section 3. The graphs diﬀer in the attacker’s communication
capability, γ, valued 0, 0.5, and 1. The gains of the ǫ-optimal policies are very
close to the computed upper bound, except when α is close to 0.5, in case which
the truncation-imposed loss is apparent. See also Table 2.

Blocks are created in the network according to a Poisson process with rate
λ. A new block belongs to the attacker w.p. α or to the honest network w.p.
(1 − α). The honest network follows the Bitcoin protocol, and always builds its
newest block on top of the longest known chain. Once an honest node adopts a
block, it will discard it only if a strictly longer competing chain exists. Ties are
thus handled by each node according to the order of arrival of blocks. Honest
nodes immediately broadcast blocks that they create.

Blocks generally form a tree structure, as each block references a single pre-
decessor (save the genesis block). Since honest nodes adopt the longest chain,
blocks generate rewards for their creator only if they are eventually part of the
longest chain in the block tree (all blocks can be considered revealed eventually).
Following the communication model of Eyal and Sirer, we assume that when-
ever the attacker learns that a block has been released by the network it is able

l

d
o
h
s
e
r
h
t
 
t
i
f
o
r
p

0.335

0.330

0.325

0.320

0.315

0.310

0.305

0.300
0

optimal policies
SM1

0.05

0.1

0.15

0.2

0.25

γ

Fig. 2: The proﬁt thresholds induced by optimal policies, and by SM1, as a func-
tion of γ. Thresholds at higher γ values match those of SM1 (but still, optimal
strategies for these values earn more than SM1, once above the threshold).

to transmit an alternative block (which it created beforehand) that will arrive
ﬁrst at nodes that possess a fraction γ of the computational power of the honest
network. Thus, if the network is currently propagating a block of height h, and
the attacker has a competing block of the same height, it is able to get γ · (1 − α)
of the computational power (owned by honest nodes) to adopt this block.

The attacker does not necessarily follow the Bitcoin protocol. Rather, at any
given time t, it may choose to invest computational power in creating blocks that
extend any existing block in history, and may withhold blocks it has created
for any amount of time. A general selﬁsh mining strategy dictates, therefore,
two key behaviours: which block the attacker attempts to extend at any time
t, and which blocks are released at any given time. However, given that all
block creation events are driven by memoryless processes and that broadcast
is modeled as instantaneous, any rational decision made by the attacker may
only change upon the creation of a new block. The mere passage of time without
block creation does not otherwise alter the expected gains from future outcomes.5
Accordingly, we model the entire decision problem faced by an attacker using a
discrete-time process in which each time step corresponds to the creation of a
block. The attacker is thus asked to decide on a course of action right after the
creation of each block, and this action is pursued until the next event occurs.

Instead of directly modeling the primitive actions of block extension and pub-
lication on general block trees, we can limit our focus to “reasonable” strategies
where the attacker maintains a single secret branch of blocks that diverged from

5 See Section 6 for the implication of delayed broadcasting.

the network’s chain at some point. (We show that this limitation is warranted
and that this limited strategy space still generates optimal attacks in the full ver-
sion). Blocks before that point are agreed upon by all participants. Accordingly,
we must only keep track of blocks involved in the fork, and of the accumulated
reward up to the fork. We denote by la and lh the number of blocks built after
the latest fork, by the attacker and by honest nodes, respectively.

Formally, if all other participants are following the standard protocol, the
attacker faces a single-player decision problem of the form M := hS, A, P, Ri,
where S is the state space, A the action space, P the stochastic transition matrix,
and R the reward matrix. Though similar in structure, we do not regard M as an
MDP, since the objective function is nonlinear: The player aims to maximize its
share of the accepted blocks, rather than the absolute number of its own accepted
ones; its goal is to have a greater return-on-investment than its counterparts.6
Actions. We begin with the description of the action space A, which will moti-
vate the nontrivial construction of the state space.

• Adopt. This action represents the attacker’s acceptance of the honest net-
work’s chain. This action is always feasible, and following it the la blocks in
the attacker’s current chain are discarded.

• Override. This action represents the publication of lh + 1 of the attacker’s

blocks. It is feasible whenever la > lh.

• Match. Here the attacker responds to a freshly mined block of the honest
network with the publication of its block of the same height. The attacker
must have a block prepared in advance to execute such a race. The state-
space explicitly encodes the feasibility status of this action (see below).

• Wait. This is the null action, under which the attacker does not publish new

blocks, but keeps working on its branch until a new block is built.

State Space. The state space, denoted S, is deﬁned by 3-tuples of the form
(la, lh, f ork). The ﬁrst two entries represent the lengths of the attacker’s chain
and the honest network’s chain, built after the latest fork (that is, above the
most recent block accepted by all). The ﬁeld f ork obtains three possible val-
ues, dubbed irrelevant, relevant and active. State of the form (la, lh, relevant)
means that the previous state was of the form (la, lh − 1, ·); this implies that
if la ≥ lh, the match action is feasible. Conversely, (la, lh, irrelevant) denotes
the case where the previous state was (la − 1, lh, ·), and the attacker has built
the most recent block; in this situation, the attacker is unable to match the hth
block of the honest network, which already propagated through the network.
The third label, active, represents the case where the honest network is already
split, due to a previous match action; this information aﬀects the transition to
the next state, as described below. We will refer to states as (la, lh) or (la, lh, ·),
in contexts where the f ork label plays no eﬀective role.

6 Another possible motivation for this is the re-targeting mechanism in Bitcoin. When
the block creation rate in the network is constant, the adaptive re-targeting implies
that the attacker will also increase its absolute payoﬀ, in the long run.

Transition and Reward Matrices. In order to keep the time averaging of
rewards in scale, every state transition corresponds to the creation of a new
block. The initial state X0 is (1, 0, irrelevant) w.p. α or (0, 1, irrelevant) w.p.
(1 − α). Rewards are given as elements in N2, where the ﬁrst entry represents
blocks of the attacker that have been accepted by all parties, and the second
one, similarly, for those of the honest network.

The transition matrix P and reward matrix R are succinctly described in
Table 1. Largely, an adopt action “resets” the game, hence the state following
it has the same distribution as X0; its immediate reward is lh in the coordinate
corresponding to the honest network. An override reduces the attacker’s secret
chain by lh + 1 blocks, which it publishes, and which the honest network accepts.
This bestows a reward of lh + 1 blocks to the attacker. The state following a
match action depends on whether the next block is created by the attacker (α),
by honest nodes working on their branch of the chain ((1 − γ) · (1 − α)), or
by an honest node which accepted the sub-chain that the attacker published
(γ · (1 − α)). In the latter case, the attacker has eﬀectively overridden the honest
network’s previous chain, and is awarded lh accordingly.

Table 1: A description of the transition and reward matrices P and R in the
decision problem M . The third column contains the probability of transiting from
the state speciﬁed in the left-most column, under the action speciﬁed therein, to
the state on the second one. The corresponding two-dimensional reward (that of
the attacker and that of the honest nodes) is speciﬁed on the right-most column.

State × Action

(la, lh, ·), adopt

(la, lh, ·), override†

(la, lh, irrelevant), wait
(la, lh, relevant), wait

(la, lh, active), wait

(la, lh, relevant), match‡

†feasible only when la > lh
‡feasible only when la ≥ lh

State

Probability Reward

(1, 0, irrelevant)
(0, 1, irrelevant)

(la − lh, 0, irrelevant)
(la − lh − 1, 1, relevant)
(la + 1, lh, irrelevant)
(la, lh + 1, relevant)

(la + 1, lh, active)

(la − lh, 1, relevant)
(la, lh + 1, relevant)

α

1 − α

α

1 − α

α

1 − α

α

γ · (1 − α)

(1 − γ) · (1 − α)

(0, lh)

(lh + 1, 0)

(0,0)
(0,0)
(0,0)
(lh, 0)
(0,0)

Objective Function. As explained in the introduction, the attacker aims to
maximize its relative revenue, rather than its absolute one as usual in MDPs.
Let π be a policy of the player; we will write π(la, lh, f ork) for the action that π
dictates be taken at state (la, lh, f ork). The immediate reward from transiting
from state x to state y, under the action dictated by π, is denoted r(x, y, π) =
(r1(x, y, π(x)), r2(x, y, π(x))). X π
t will denote the t’th state that was visited. We
will abbreviate rt(X π
t+1, π) and write simply rt(π) or even rt, when context

t , X π

is clear. The objective function of the player is its relative payoﬀ, deﬁned by

REV := E"lim inf

T →∞

t=1 r1
t (π)
t (π) + r2

t (π))# .

(1)

PT

t=1 (r1

PT

We will specify the parameters of REV depending on the context (e.g.,
REV (π, α, γ), REV (π), REV (α)), and will occasionally denote the value of
REV by ρ. In addition, for full deﬁniteness of REV , we rule out pathological
behaviours in which the attacker waits forever—formally, the expected time for
the next non-null action of the attacker must be ﬁnite.
Honest Mining and SM1. We now deﬁne two policies of prime interest that
will serve as a baseline for future comparisons. Honest mining is the unique
policy which adheres to the protocol at every state. It is deﬁned by

honest mining (la, lh, ·) =(cid:26) adopt

override

lh > la

la > lh(cid:27) ,

(2)

and wait otherwise. Notice that under our model, REV (honest mining, α, γ) = α
for all γ.7 Eyal and Sirer’s selﬁsh mining strategy, SM1, can be deﬁned as

SM 1 (la, lh, ·) :=


adopt
match
override

wait

lh > la

lh = la = 1

lh = la − 1 ≥ 1

otherwise




.

(3)

Proﬁt threshold. Keeping the attacker’s connectivity capabilities (γ) ﬁxed, we
are interested in the minimal α for which employing dishonest mining strategies
becomes proﬁtable. We deﬁne the proﬁt threshold by:

ˆα(γ) := inf
α

{∃π ∈ A : REV (π, α, γ) > REV (honest mining, α, γ)} .

(4)

3 A Simple Upper Bound

The mechanism implied by the longest-chain rule leads to an immediate bound
on the attacker’s relative revenue. Intuitively, we observe that the attacker cannot
do better than utilizing every block it creates to override one block of the honest
network. The implied bound is provided here merely for general insight—it is
usually far from the actual maximal revenue.

Proposition 1. For any π, REV (π, α, γ) ≤ α
and achieved when γ = 1.

1−α . Moreover, this bound is tight,

7 Indeed,

in networks without delays, honest mining is equivalent to the policy
(cid:8) adopt if (la, lh) = (0, 1) ; override if (la, lh) = (1, 0) (cid:9), as these are the only reach-
able states.

Proof. We can map every block of the honest network which was overridden, to
a block of the attacker; this is because override requires the attacker to publish
a chain longer than that of the honest network’s.

Let kT be the number of blocks that the attacker has built up to time T .
The honest network thus built lT := T − kT by this time. The argument above
t ≤ kT . Also, Pr(lT > kT ) → 1, when T → ∞. Therefore,

t=1 r2

shows that lT −PT

the relative revenue satisﬁes:

REV (π) = lim
T →∞

t

t=1 r1

t=1 r1

PT
t +PT
t(cid:17)
1 + (lT − kT ) /(cid:16)PT

PT

t=1 r1

1

lim
T →∞

≤ lim
T →∞

t=1 r2

t

t

PT

t=1 r1
t + lT − kT

=

t=1 r1
1

PT

≤ lim
T →∞

1 + (lT − kT ) /kT

= lim
T →∞

kT
lT

.

(5)

(6)

The SLLN applies naturally to kT and lT , implying that the above equals
(1−α)·T = α

1−α (a.s.).

α·T

We claim that when γ = 1 the bound is achieved by the following policy:

π (la, lh, ·) :=


adopt
match
wait

lh = 1, la = 0

lh = la

otherwise




.

(7)

Indeed, under π the attacker only publishes its current number of blocks la when
the honest network has the same amount, hence every block of the attacker
overrides one block of the honest network. In addition, none of the attacker’s
blocks are overridden, since the policy never reaches a state where it needs to
adopt except when la = 0. This turns both inequalities in (5)-(6) into equalities.
⊓⊔

4 Computing the Optimal Policy

Finding an optimal policy is not a trivial task, as the objective function (1)
is nonlinear, and depends on the entire history of the game. To overcome this
we introduce the following method. Suppose we are given some value ρ as a
candidate for the optimal value of the objective function. We show that one can
construct a related MDP, Mρ, which has one important characteristic: If the
average reward of its optimal policy is negative, then ρ is above the optimal
value, and if it is positive, then ρ is below it. When the optimal average reward
is exactly 0, ρ is optimal in the original problem, and the policy that obtains
this value in Mρ, obtains a value of ρ in the original problem.

Formally, for any ρ ∈ [0, 1], deﬁne the transformation wρ : N2 → Z by
wρ(x, y) := (1 − ρ) · x − ρ · y. Deﬁne the MDP Mρ := hS, A, P, wρ(R)i; it shares
the same state space, actions, and transition matrix as M , while M ’s imme-
diate rewards matrix is transformed according to wρ. The value of a policy

π is deﬁned by vπ

v∗

ρ = maxπ∈A(cid:8)vπ

Proposition 2. If for some ρ ∈ [0, 1], v∗
value (thus maximizing vπ
ally, v∗

ρ is monotonically decreasing in ρ.

1

T →∞

t=1 wρ(rt(π))i, and the optimal value by
ρ = Ehlim inf
ρ(cid:9).8 Our solution method is based on the following proposition:

T PT

ρ ) also maximizes REV , and ρ = REV (π∗

ρ = 0, then any policy π∗ obtaining this
ρ). Addition-

Following these observations we can utilize the family Mρ to obtain an opti-
mal policy: We simply perform a search for ρ ∈ [0, 1] such that the optimal
solution of Mρ has a value v∗
ρ is monotonically decreasing, this
can be done eﬃciently, using binary search.

ρ = 0. Since v∗

In practice, this method needs some reﬁnement before it is applied, due to
several limitations: First, the search domain [0, 1] is continuous, and we must
account for some precision error. Second, standard MDP solvers can only deal
with ﬁnite-state spaces, and even then, only to a limited degree of accuracy. The
need to deal with ﬁnite state-spaces forces us to work with truncated versions
of Mρ whose optimal values serve as lower bounds to the real optimal one. To
circumvent this we have constructed another family of (ﬁnite) MDPs which serve
as upper bounds. Both bounds are tight, that is, they converge to the optimal
value as the truncation increases. A full description of this construction, an
algorithm to obtain these tight bounds, and a proof of the algorithm’s correctness
appear in the full version available online. Proposition 2 follows from the analysis
therein.

5 Results

5.1 Optimal Values

We ran our algorithm for γ in {0, 0.5, 1}, with various values of α, using an MDP
solver for MATLAB (an implementation of the relative value iteration algorithm
developed by Chad´es et al. [5]).9 The values of ρ returned by the algorithm are
depicted in Figure 1 above; additionally, the values for γ = 0 appear in Table 2.
The graphs demonstrate a rather mild gap between the attacker’s optimal rev-
enue and the revenue of SM1. In addition, the graphs depict the upper bound
on the revenue provided in Section 3; as we stated there, the bound is obtained
when γ = 1, which is observed clearly in the corresponding graph.

5.2 Optimal Policies

We now present the ǫ-optimal policies returned by our algorithm, in two particu-
lar setups. Table 3 above describes the policy for an attacker with α = 1/3, γ = 0

8 The equivalence of this formalization of the value function and alternatives in which

the order of expectation and limit is reversed is discussed in [3].

9 The error parameter ǫ was set to be 10−5 and the truncation was set to T = 75. See

full version.

Table 2: The revenue of the attacker
under SM1 and under ǫ-OPT poli-
cies, compared to the computed up-
per bound, for various α and γ = 0.

Table 3: Optimal actions for an attacker
with α = 0.35, γ = 0, in states (la, lh)
with la, lh ≤ 7. See legend in the text
(Subsection 5.2).

α

SM 1

1/3

ǫ-OPT

Upper-
Bound
1/3
0.33705 0.33707
0.35 0.36650 0.37077 0.37080
0.375 0.42118 0.42600 0.42614
0.4 0.48372 0.48863 0.48976
0.425 0.55801 0.56788 0.57672
0.45 0.65177 0.66809 0.72203
0.475 0.78254 0.7987 0.90476

lh 0 1 2 3 4 5 6 7

❅
❅❅la

0
∗ a ∗ ∗ ∗ ∗ ∗ ∗
1 w w w a ∗ ∗ ∗ ∗
2 w o w w a ∗ ∗ ∗
3 w w o w w a ∗ ∗
4 w w w o w w w a
5 w w w w o w w w
6 w w w w w o w w
7 w w w w w w o w

(here match is of no consequence, and no forks form). The row indices corre-
spond to la and the columns to lh. Table 4 corresponds to α = 0.45, γ = 0.5.
Each entry in it contains a string of three characters, corresponding to the possi-
ble status of f ork: irrelevant, relevant, active. Actions are abbreviated to their
initials: adopt, override, m atch, w ait, while ‘∗’ represents an unreachable state.

Table 4: Optimal actions (abbreviated to their initials) for an attacker with α =
0.45, γ = 0.5, for states (la, lh, ·) with la, lh ≤ 7. See legend in Subsection 5.2.10

❅
lh
❅❅la

0

1

2

3

4

5

6

7

0
∗∗∗ ∗a∗ ∗∗∗ ∗∗∗ ∗∗∗ ∗∗∗ ∗∗∗ ∗∗∗
1 w∗∗ ∗m∗ a∗∗ ∗∗∗ ∗∗∗ ∗∗∗ ∗∗∗ ∗∗∗
2 w∗∗ ∗mw ∗m∗ w∗∗ a∗∗ ∗∗∗ ∗∗∗ ∗∗∗
3 w∗∗ ∗mw ∗mw wm∗ w∗∗ a∗∗ ∗∗∗ ∗∗∗
4 w∗∗ ∗mw ∗mw omw wm∗ w∗∗ w∗∗ a∗∗
5 w∗∗ ∗mw ∗mw ∗mw omw wm∗ w∗∗ w∗∗
6 w∗∗ ∗mw ∗mw ∗mw ∗mw omw wm∗ w∗∗
7 w∗∗ ∗mw ∗mw ∗mw ∗mw ∗mw ooo w∗∗

Looking into these optimal policies we see they diﬀer from SM1 in two ways:
First, they defer using adopt in the upper triangle of the table, if the gap be-
tween lh and la is not too large, allowing the attacker to “catch up from behind”.
Thus, apart from block withholding, an optimal attack may also contain another

feature: attempting to catch up with the longer public chain from a disadvan-
tage. This implies that the attacker violates the longest-chain rule, a result which
counters the claim that the longest-chain rule forms a Nash equilibrium (see [12],
and discussion in Section 8). Secondly, they utilize match more extensively, ef-
fectively overriding the honest network’s chain (w.p. γ) using one block less.

5.3 Thresholds

Using the bounds provided by our algorithm, we are able to introduce lower
bounds on the proﬁt thresholds, i.e., on the minimal fraction of computational
resources needed for a proﬁtable attack. The exact methodology is described
in the full version. Figure 2 depicts the thresholds induced by optimal policies,
compared to that induced by SM1. The results demonstrate some cutback of the
thresholds when considering policies other than SM1.

5.4 Evaluation of Protocol Modiﬁcations

Several modiﬁcations to the Bitcoin protocol have been suggested. It is important
to provably verify the resilience of such protocols to selﬁsh mining, especially if
their explicit goal is to counter this attack. This can be done by adapting our
algorithm to the MDPs induced by these modiﬁcations. We demonstrate this
below for three protocols.
GHOST. First, we make a short note regarding the GHOST protocol, an al-
ternative to the longest-chain rule [18]. We point out that our entire analysis in
this paper applies to the GHOST protocol as well, since GHOST coincides with
the longest-chain rule when the network suﬀers no delays.
Freshness Preferred. The tie breaking rule in Bitcoin instructs a node to adopt
the chain whose tip was received by it ﬁrst, in case of ties. Freshness Preferred
is an alternative suggested in [11]. It uses unforgeable timestamps, and dictates
that if less than w seconds passed between the receiving of the two tips, the
node adopts the chain which contains the most recent time-stamp. Freshness
Preferred disincetivizes block withholding, and in particular counters the SM1
scheme. Unfortunately, when also considering deviations from the longest-chain
rule, it can be seen that an attacker of any size can beneﬁt from this protocol by
waiting in state (la, lh) = (0, 1), rather than adopting, for a certain period. Such
a consideration is also the basis for our following analysis of Eyal and Sirer’s
suggested tie breaking rule.
Uniform Tie Breaking. In case of ties, Eyal and Sirer suggest to instruct
nodes to choose between the chains uniformly at random. The immediate eﬀect
of this modiﬁcation is that it restricts the eﬃciency of the match action to 1/2,
even when the attacker’s communication capabilities correspond to γ > 1/2.
Admittedly, this limits the power of strongly communicating attackers, and thus

10 For instance, the string “wm∗” in entry (la, lh) = (3, 3) reads: “in case a fork is
irrelevant (i.e., the previous state was (2, 3)), wait; in case it is relevant (the previ-
ous state was (3, 2)), match; the case where a fork is already active is not reachable”.

guarantees a positive lower bound on the threshold for proﬁtability of SM1.
On the other hand, it has the apparent downside of enhancing the power of
poorly communicating attackers—it allows an attacker to match with a success-
probability 1/2 even if its “real” γ is smaller than 1/2.

Unfortunately, there is an additional drawback. An attacker is able to match
even if it did not have a block prepared in advance, thereby granting it addi-
tional chances to catch up from behind. Deviation from the longest-chain rule
thus becomes even more tempting. Indeed, by applying our algorithm to the
setup induced by uniform tie breaking, we found that the proﬁt threshold ˆα(0.5)
deteriorates from 0.25 to 0.2321.

Figure 3 demonstrates this by comparing the attacker’s optimal revenue un-
der the uniform tie breaking protocol with the optimal revenue under the original
protocol. The optimal policy is described in the online full version of this paper.

 
 
 
 
 
ρ

)
e
u
n
e
v
e
r
(

1

0.9

0.8

0.7

0.6

0.5

0.4

0.3

0.2

0.2

Honest mining
eps-OPT policy γ=0.5
eps-OPT policy Uniform tie-breaking

0.25

0.3

0.35

0.4

0.45

0.5

α                

(fraction of hashrate)

Fig. 3: The attacker’s optimal revenue under uniform tie breaking, compared to
that under the original protocol (with γ = 1/2) and to honest mining.

5.5 Simulations

In order to verify the results above we built a selﬁsh mining simulator which we
implemented in Java. We ran the simulator for various values of α and γ (as
in the ﬁgures above), with the attacker following the policies generated by the
algorithm. Each run was performed for 107 rounds (block creation events). The
relative revenue of the attacker matched the revenues returned by the algorithm,
up to an error of at most ±10−6.

6 A Model that Considers Delays

So far our model assumed that no new block is created during the propagation
of blocks released earlier. In reality, there are communication delays between
nodes in the network, including between the attacker and others. Thus, instead
of modeling the attacker’s communication capabilities via the parameter γ, it
is better to consider the eﬀect of network latency directly. Delays are especially
noticeable when the system’s throughput is increased by allowing larger blocks
to form or by increasing block creation rates.

We now adjust our model to incorporate communication delays. For simplic-
ity, and to demonstrate how the proﬁt threshold breaks down even when a delay
on a single link is introduced, we assume that only messages from the attacker
to the honest network suﬀer delays. We denote this delay by da,h. Messages be-
tween honest nodes and from them to the attacker are assumed to be delivered
instantaneously, as in the original model. Apart from la and lh, the process now
encodes also information about the timings of recent messages that are currently
propagating on the link from the attacker’s node to the honest network’s node.
Our following result states that under delays the proﬁt threshold is 0. A node of
any size can beneﬁt from occasional deviation from the longest-chain rule:

Proposition 3. Under communication delays (as modeled above), the attacker
has a strict better-response strategy to honest mining, for any α > 0.

Proof. Part I: Fix k ∈ N and let T > k + 1. Below we describe a policy which
instructs the attacker whether to adopt the honest network’s chain (adopt) or
not (wait). Our policy involves no block withholding at all; it thus deviates from
the longest-chain rule, but adheres to immediate-publication. Consequently, the
honest network adopts the attacker’s chain if and only if the latter is longer by
the time it arrived at the honest node. Our policy uses only (la, lh) to decide
between wait and adopt (although the state embeds additional information, e.g.,
timing of recent messages). When state (la, lh) = (k − 1, k) is reached, our policy
deviates from the honest protocol: In (k − 1, k) it waits, instead of adopting,
until the (k + 1) block of the attacker or of the honest network is created; it then
terminates the attack, and continues mining on the honest network’s updated
chain. Upon termination, the honest network’s chain contains the (k + 1) blocks
of the attacker only if they have propagated to the honest node in time. This
possibility will be incorporated into the immediate reward function below.

Policies as the one described are technically not considered stationary, and
a common circumvent is applied in such cases. We add a third bit to our rep-
resentation of states, which denotes whether (k − 1, k) has been reached during
this epoch. Thus, for any state with (la, lh) we write (la, lh, 0), corresponding to
the original states. Then, we add four new states that are only reachable from
(k−1, k, 0) under the wait action: (k, k, 1), (k+1, k, 1), (k, k+1, 1), (k−1, k+1, 1).
The original copies of these four states, with the third bit set to 0, are still
reachable via (k, k − 1, 0). The states with the bit set to 1 are unreachable un-
der honest mining, hence honest mining can still be seen as living inside this
modiﬁed state-space.

When the process arrives at either of the states (·, k + 1, 1) or (k + 1, k, 1)
it renews (i.e., it transits to (1, 0, 0) or (0, 1, 0)). Importantly, the immediate
reward in M T
ρ gained by arriving at (·, k + 1, 1) is (−ρ · (k + 1)), and by arriving
at (k + 1, k, 1) is q · (1 − ρ) · (k + 1) − (1 − q) · ρ · (k + 1), where q = e−(1−α)·2·da,h·λ.
This will be justiﬁed shortly. Our policy acts as follows:

πk(la, lh, m) :=


wait
adopt

honest mining(la, lh)

k − 1 ≤ la ≤ k, lh = k, m = 1

lh = k + 1, m = 1

m = 0

.




Since (·, k + 1, 1) and (k + 1, k, 1) are terminating states, there are two possi-
bilities: (a) The attacker managed to create the next two blocks in the network
(corresponding to (k + 1, k, 1)) and to propagate them in time to the honest net-
work. Thence the honest network adopts the attacker’s longer chain, and it gains
an immediate reward of (1 − ρ) · (k + 1). In reality this happens w.p. ≥ q, since
q is the probability that the honest network created no conﬂicting blocks during
2 · da,h seconds.11 (b) State (·, k + 1, 1) was reached, or (k + 1, k, 1) was reached
but the attacker’s blocks didn’t make it in time to the honest node before the
latter created its next one. The immediate reward described above assumes the
worst case for the attacker, i.e., that it suﬀers a loss of (−ρ · (k + 1)) (in (b)).

Part II: Let ρ = ρh := REV (honest mining) represent the revenue of the
attacker under honest mining. In the full version it is shown that it is suﬃcient
to prove that the expected sum of all immediate rewards accumulated in M T
ρh, in
a single epoch, is greater with πk than with honest mining. Now, the two policies
diﬀer only after reaching state (k − 1, k, 0), and this state is reached under both
policies with positive probability (as will be shown later). It thus suﬃces to
prove this assertion w.r.t the rewards that result from reaching this state. The
attacker’s expected immediate reward, under πk, upon reaching (k − 1, k, 0), is
α2 · q · (1 − ρh) · (k + 1) − (1 − α2 · q) · ρh · (k + 1); this stems from combining
the rewards in scenarios (a) and (b). In contrast, under honest mining it gains
(−ρh · k), since it adopts immediately. In conclusion, it suﬃces to show that
q · α2 (1 − ρh) · (k + 1) − (1 − q · α2) · ρh · (k + 1) − (−ρh · k) > 0. It is easy
to see that this is satisﬁed by any k > ρh
q·α2 − 1. In particular, there exists a
policy under which the expected immediate rewards of an attacker exceed those
it would have gained mining honestly. As this holds for any α > 0, we conclude
that an attacker of any size can beneﬁt from deviating from honest mining.

Part III: To complete the proof we show that after each renewal of the pro-
cess, state (k − 1, k, 0) is reached with positive probability, under both policies.
Indeed, there is a probability of αk−1 to arrive at (k − 1, 0, 0), with the at-
tacker creating the ﬁrst (k − 1) blocks. There is then a probability of (1 − α)k ·
to transit to (k − 1, k, 0), with the honest network creat-
⊓⊔

ing the next k blocks before learning of any of the attacker’s blocks.

(cid:0)1 − e−(1−α)·λ·da,h(cid:1)k−1

To gain further understanding of selﬁsh mining under delays it would be im-
portant to quantify the optimal gains from such deviations. We leave this as

11 After 2·da,h we are guaranteed that the link from the attacker to the honest network

is empty.

an open question for future research. Still, it is clear that Bitcoin will be more
vulnerable to selﬁsh mining if delays become more prominent, e.g., in the case of
larger blocks (block-size increases are currently being debated within the Bitcoin
developers community).

7 Eﬀect on Double Spending Attacks

In this section we discuss the qualitative eﬀect selﬁsh mining has on the secu-
rity of payments. The regular operation of bitcoin transactions is as follows: A
payment maker signs a transaction and pushes it to the Bitcoin network, then
nodes add it to the blocks they are attempting to create. Once a node succeeds
it publishes the block with its content. Although the payee can now see this
update to the public chain of blocks, it still waits for it to be further extended
before releasing the good or service paid for. This deferment of acceptance guar-
antees that a conﬂicting secret chain of blocks (if one exists) will not be able to
bypass and override the public one observed by the payee, thereby discard the
transaction. Building a secret chain in an attempt to reverse payments is called
a double spending attack.
Success-probability. Satoshi Nakamoto, in his original white paper, provides
an analysis regarding double spending in probabilistic terms: Given that the
block containing the transaction is followed by n subsequent blocks, what is the
probability that an attacker with computational power α will be able to override
this chain, now or in the future? Nakamoto showed that the success-probability
of double spending attacks decays exponentially with n. Alternative and perhaps
more accurate analyses, e.g., [17, 18], reach similar conclusions.
Cost. While a single double spending attack succeeds with negligible probability
(as long as the payee waits long enough), regrettably, an attacker which contin-
uously executes double spending attempts will eventually succeed (a.s.). We
should therefore be more interested in the cost of an attack than in its success-
probability. Indeed, every failed double spending attack costs the attacker the
potential award it could have gotten had it avoided the fork and published its
blocks right away.

Observe, however, that a smart strategy for an attacker would be to con-
tinuously employ selﬁsh mining attacks, and upon success combine them with
a double spending attack. Technically, this can be done by regularly engaging
in public transactions, while always hiding a conﬂicting one in the attacker’s
secret blocks.12 There is always some probability that by the time a successful
selﬁsh mining attack has ended, the payment receiver has already accepted the
payment, which additionally results in a successful double spending.

To summarize, the existence of a miner for which selﬁsh mining is at least as
proﬁtable as honest mining fundamentally undermines the security of payments,
as this attacker bears no cost for continuously attempting to double spend, and

12 In the worst case, the attacker is frequently engaged in “real” transactions anyways,

hence suﬀers no loss from them being occasionally conﬁrmed, when attacks fail.

it eventually must succeed. Similarly, an attacker that cannot proﬁt from selﬁsh
mining alone, might be proﬁtable in the long run if it combines it with double
spending, which potentially has grave implications on the proﬁt threshold.

8 Related Work

The Bitcoin protocol was introduced in a white paper published in 2008 by
Satoshi Nakamoto [15]. In the paper, Nakamoto shows that the blockchain is
secure as long as a majority of the nodes in the Bitcoin network follow the
protocol. Kroll et al. [12] show that, indeed, always extending the latest block
in the blockchain forms a (weak, non-unique) Nash equilibrium, albeit under a
simpler model that does not account for block withholding.

On the other hand, it has been suggested by various people in the Bitcoin fo-
rum that strong nodes might be incentivized to violate the protocol by withhold-
ing their blocks [1]. Eyal and Sirer proved this by formalizing a block withholding
strategy SM1 and analyzing its performance [9]. Their strategy thus violates the
protocol’s instruction to immediately publish one’s blocks, but still sticks to the
longest-chain rule (save a selective tie breaking). SM1 still abandons its chain
if the honest nodes create a longer chain. One result of our paper is that even
adhering to the longest-chain rule is not a best response. We also prove what
the optimal policies are, and compute the threshold under which honest mining
is a (strict, unique) Nash equilibrium.

A recent paper by G¨obel et al. has evaluated SM1 in the presence of de-
lays [10]. They show that SM1 is not proﬁtable under a model of delays that
greatly diﬀers from our own (in particular, they assume that block transmission
occurs as a memoryless process). While SM1 may indeed be unproﬁtable when
delay is modeled, we show that other proﬁtable selﬁsh mining attacks exist. Ad-
ditional analysis of block creation in the presence of delays and its eﬀects on
throughput and double spending appears in [7, 14, 18].

A recent work by Nayak et al. [16], which was independently conducted in
parallel to our own, discusses speciﬁc selﬁsh mining strategies which outperform
SM1 (that are not necessarily optimal), and analyzes the combination of selﬁsh
mining and a network-level attack. Our own work provides provably optimal
strategies, which allows us to compute the proﬁt thresholds, and to evaluate the
worst attack given various protocol modiﬁcations (which can only be done with
optimal strategies).

Additional work on selﬁsh mining via block withholding appears in [6]. An-
other approach to mitigate selﬁsh mining appears in [11]. Transaction propaga-
tion in Bitcoin has also been analyzed from the perspective of incentives. Results
in [2] show that nodes have an incentive not to propagate transactions, and sug-
gests a mechanism to correct this. Additional analysis from a game theoretic
perspective has also been conducted with regards to interactions pools, either
from a cooperative game theory perspective [13], or when considering attacks
between pools [8]. Further discussion on Bitcoin’s stability can be found in a
recent survey by Bonneau et al. [4].

References

1. https://bitcointalk.org/index.php?topic=2227 , 2008.

[Online; accessed 07-July-

2015].

2. Moshe Babaioﬀ, Shahar Dobzinski, Sigal Oren, and Aviv Zohar. On bitcoin and
red balloons. In Proceedings of the 13th ACM conference on electronic commerce,
pages 56–73. ACM, 2012.

3. K-J Bierth. An expected average reward criterion. Stochastic processes and their

applications, 26:123–140, 1987.

4. Joseph Bonneau, Andrew Miller, Jeremy Clark, Arvind Narayanan, Joshua A Kroll,
and Edward W Felten. Sok: Research perspectives and challenges for bitcoin and
cryptocurrencies. 2015.

5. Iadine Chad`es, Guillaume Chapron, Marie-Jos´ee Cros, Fr´ed´erick Garcia, and R´egis
Sabbadin. Mdptoolbox: a multi-platform toolbox to solve stochastic dynamic pro-
gramming problems. Ecography, 37(9):916–920, 2014.

6. Nicolas T Courtois and Lear Bahack. On subversive miner strategies and block
withholding attack in bitcoin digital currency. arXiv preprint arXiv:1402.1718,
2014.

7. Christian Decker and Roger Wattenhofer. Information propagation in the bitcoin
network. In Peer-to-Peer Computing (P2P), 2013 IEEE Thirteenth International
Conference on, pages 1–10. IEEE, 2013.

8. Ittay Eyal. The miner’s dilemma. arXiv preprint arXiv:1411.7099, 2014.
9. Ittay Eyal and Emin G¨un Sirer. Majority is not enough: Bitcoin mining is vul-
nerable. In Financial Cryptography and Data Security, pages 436–454. Springer,
2014.

10. Johannes G¨obel, Paul Keeler, Anthony E Krzesinski, and Peter G Taylor. Bitcoin
blockchain dynamics: the selﬁsh-mine strategy in the presence of propagation delay.
arXiv preprint arXiv:1505.05343, 2015.

11. Ethan Heilman. One weird trick to stop selﬁsh miners: Fresh bitcoins, a solution

for the honest miner. IACR Cryptology ePrint Archive, 2014:7, 2014.

12. Joshua A Kroll, Ian C Davey, and Edward W Felten. The economics of bitcoin
mining, or bitcoin in the presence of adversaries. In Proceedings of WEIS, volume
2013, 2013.

13. Yoad Lewenberg, Yoram Bachrach, Yonatan Sompolinsky, Aviv Zohar, and Jef-
frey S Rosenschein. Bitcoin mining pools: A cooperative game theoretic analy-
sis. In Proceedings of the 2015 International Conference on Autonomous Agents
and Multiagent Systems, pages 919–927. International Foundation for Autonomous
Agents and Multiagent Systems, 2015.

14. Yoad Lewenberg, Yonatan Sompolinsky, and Aviv Zohar.
protocols. Financial Cryptography and Data Security, 2015.

Inclusive block chain

15. Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system. Consulted,

1(2012):28, 2008.

16. Kartik Nayak, Srijan Kumar, Andrew Miller, and Elaine Shi. Stubborn mining:

Generalizing selﬁsh mining and combining with an eclipse attack.

17. Meni Rosenfeld. Analysis of hashrate-based double spending. arXiv preprint

arXiv:1402.2009, 2014.

18. Yonatan Sompolinsky and Aviv Zohar. Secure high-rate transaction processing in

bitcoin. Financial Cryptography and Data Security, 2015.

