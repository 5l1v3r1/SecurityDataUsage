PeerPress: Utilizing Enemies’ P2P Strength against Them

Zhaoyan Xu
SUCCESS Lab

Lingfeng Chen
SUCCESS Lab

Texas A&M University

Texas A&M University

z0x0427@cse.tamu.edu

lingfeng@cse.tamu.edu

Guofei Gu

SUCCESS Lab

Texas A&M University

guofei@cse.tamu.edu

Christopher Kruegel

Dept. of Computer Science

UC Santa Barbara

chris@cs.ucsb.edu

ABSTRACT
We propose a new, active scheme for fast and reliable de-
tection of P2P malware by exploiting the enemies’ strength
against them. Our new scheme works in two phases: host-
level dynamic binary analysis to automatically extract built-
in remotely-accessible/controllable mechanisms (referred to
as Malware Control Birthmarks or MCB) in P2P malware,
followed by network-level informed probing for detection.
Our new design demonstrates a novel combination of the
strengths from host-based and network-based approaches.
Compared with existing detection solutions, it is fast, reli-
able, and scalable in its detection scope. Furthermore, it can
be applicable to more than just P2P malware, more broadly
any malware that opens a service port for network com-
munications (e.g., many Trojans/backdoors). We develop a
prototype system, PeerPress, and evaluate it on many rep-
resentative real-world P2P malware (including Storm, Con-
ﬁcker, and more recent Sality). The results show that it
can eﬀectively detect the existence of malware when MCBs
are extracted, and the detection occurs in an early stage
during which other tools (e.g., BotHunter) typically do not
have suﬃcient information to detect. We further discuss its
limitations and implications, and we believe it is a great
complement to existing passive detection solutions.

Categories and Subject Descriptors
D.4.6 [Operating Systems]: Security and Protection

General Terms
Security

Keywords
P2P, Malware analysis, Malware detection

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’12, October 16–18, 2012, Raleigh, North Carolina, USA.
Copyright 2012 ACM 978-1-4503-1651-4/12/10 ...$15.00.

1.

INTRODUCTION

Malicious software (malware) is a serious threat to Inter-
net security. While many early botnets use centralized C&C
architecture, botmasters have realized its limitations and be-
gun to use more advanced and robust peer-to-peer (P2P)
architectures for C&C [27]. For example, several contempo-
rary successful botnets such as Storm/Peacomm and Con-
ﬁcker have infected millions of computers and adopted P2P
techniques in their C&C coordination [2, 48]. As stated in a
recent report [26], the Kaspersky Security Network detected
more than 2.5 million P2P malware incidents per month in
March 2010, a high water mark reached for the ﬁrst time
in its monitoring history. A recent P2P botnet, Sality, is
still alive as of the writing of this paper and becoming more
complex [12]. In short, P2P malware is widely believed to
be a promising direction for future malware [27, 43, 50].

Unfortunately, to date, there is relatively little research
available on detecting this important threat. Network-level
detection techniques have been proposed to perform clus-
tering/correlation analysis to identify suspicious botnet in-
fection/behavior patterns [29, 31, 32, 41] or to analyze the
network traﬃc graph/structure to detect possible P2P bot-
nets [33, 34, 43]. However, suspicious pattern identiﬁcation
may fail in front of traﬃc encryption, traﬃc randomiza-
tion and timing pattern manipulation [49]. Structure/graph
analysis can only detect P2P structure regardless whether
the traﬃc is actually malicious or not, and it typically re-
quires tremendous resources (e.g., global ISP-level view) for
acceptable results (a conclusion also mentioned in [34]), mak-
ing it a less attractive solution to Enterprise networks. In an-
other direction, host-based detection techniques such as tra-
ditional signature-based approaches (e.g., anti-virus tools)
and more recent behavior-based approaches (e.g., [35, 36])
have also been proposed. However, due to the widely used
advanced obfuscation/polymorphism [46] and the require-
ment of client-side installation, the solutions are not attrac-
tive for large scale P2P malware detection. Finally, it is
worth noting that both host-based techniques and the above-
mentioned network-based approaches have one common lim-
itation because of their passive monitoring mechanism: they
tend to be slow in terms of detection, e.g., they need to wait
until some (or many) actual (suspicious/malicious) activi-
ties/communications occur to be able to detect the malware
existence.

In this paper, we focus on answering the following ques-
is it possible to combine both the robustness of host-

tion:

581based approaches and the eﬃciency of network-based ap-
proaches to provide fast, reliable, and scalable detection of
P2P malware? We believe that while P2P provides more
ﬂexible and robust coordination for the enemy, we can utilize
the enemy’s strength against him. A key insight is that P2P
malware has to have built-in remotely-accessible/controllable
mechanisms. That is, P2P malware has to open some port(s)
for peer-to-peer communication, which is required for pro-
viding binary downloading services to new infected machines
(i.e., egg downloading [31]), or for easier later access/control
by remote attackers. If we can determine the port number(s)
in use and further know the access/control conversation logic
through that port (we refer to this information as Malware
Control Birthmarks, or MCBs, as deﬁned in detail later), we
could uniquely identify that P2P malware.

Our key insight motivates us to design a novel two-phase
detection framework: (i) ﬁrst, we automatically extract MCB
through host-level dynamic malware analysis; (ii) then, with
the MCB information, we perform network-level, active, in-
formed probing to identify infected machines. Thus, a P2P
malware sample will expose itself if it opens speciﬁc port(s)
or/and it responds in a predicted way to a speciﬁc probing
packet. It is worth noting that our new detection scheme ap-
plies in general to any malware that has MCBs, not just to
P2P malware. For example, Trojan/backdoors also belong
to the detection scope of this scheme and they are among
the current most popular malware in the wild as shown in a
recent Symantec Internet security threat report [8].

Our new design naturally bridges host-based dynamic bi-
nary analysis and network-based informed probing. Com-
pared with existing solutions, it has several unique advan-
tages. First, it is fast and active compared to existing passive
detection mechanisms. Instead of waiting for actual attack-
s/control to happen, we can proactively detect the existence
of malware. Second, it is very reliable in detecting the mal-
ware. While attackers can generate very diﬀerent binaries
for samples in a malware family, the underlying MCBs are
still the same and they are typically unique for diﬀerent
malware families. This is because the attackers still want
to control all the malware (in the same family) in the same
way to make them easily manageable. The accuracy and ro-
bustness of using MCB in detection are comparable to tra-
ditional host-based approaches (they both use ﬁne-grained
binary analysis techniques), and it avoids a lot of network
evasions. Finally, our approach is scalable to large network
deployments. Since we only need one scanner for the whole
network instead of installing detectors on every machine,
the deployment, management, and MCB updating are rela-
tively easy. It even provides the possibility of Internet-scale
scanning/detection when necessary.

Speciﬁcally, our paper makes the following contributions:

• We propose a new detection strategy combining host-
level dynamic malware binary analysis and network-
level informed probing techniques. To the best of our
knowledge, it is the ﬁrst work to discuss (P2P) mal-
ware detection based on automated MCB (Malware
Control Birthmark) extraction and informed network
probing.
It shows a novel combination of strengths
(fast, reliable and scalable) from host- and network-
based detection approaches.

niques to determine if given malware opens a speciﬁc
port and automatically extract the port generation al-
gorithm/logic. Furthermore, we design new techniques
to craft a speciﬁc/special MCB probing packet that
can let MCB-enabled malware expose itself (from net-
work observation perspective), much more eﬃcient and
eﬀective than existing network software fuzzing tech-
niques [7].
In particular, we develop ICE (Informed
forCed Executing), a new technique to quickly identify
possible MCB execution paths that can be used later
in stitched dynamic symbolic execution to derive sat-
isﬁable packet contents to trigger MCB logic. In eval-
uation, ICE can save up to 80% overhead compared to
traditional multi-path exploration schemes.

• We evaluate PeerPress with multiple representative
and complex real-world malware families (including
Storm/Peacomm, Conﬁcker and more recently Sality).
PeerPress successfully extracts their MCBs and demon-
strates that using MCB-informed active probing, we
can detect those malware infected machines with 100%
accuracy and 0 false positive (in three /24 networks).
It is able to detect these malware in an early stage
when other tools (e.g., BotHunter) can not.

• We extensively discuss the limitations and implica-
tions of our approach (Section 7). While not perfect,
PeerPress works great when MCBs are successfully ex-
tracted. Furthermore, even in the worst case (not able
to penetrate into some malware binary), PeerPress can
still use several special types of MCBs (e.g., “no re-
sponse”) to help recognize suspicious malware infec-
tions. We consider PeerPress as an important further
step toward proactive malware detection and a great
complement to existing passive detection techniques.

2. APPROACH OVERVIEW

2.1 Problem Deﬁnition
Assumption. We assume that a captured malware binary
P is available, and we analyze it in our host-based analysis
phase without source code access. With the wide deploy-
ment of honeypots to collect malware samples, this is a very
basic assumption for most malware analysis and defense re-
search [16, 36, 37, 42, 54]. Furthermore, since most malware
binaries are now protected against static analysis (e.g., us-
ing obfuscation/polymorphic techniques), we mainly employ
dynamic analysis techniques in this work.1

Since we target P2P malware, without loss of generality,
we assume the malware sample P contains two independent
program logics:

• P1, which opens a network service port ψ.

• P2, which parses certain network request(s) ρ and gen-

erates response(s) η through the network port ψ.

We assume all binary samples within the same malware
family/version share the same and unique P1 and P2. These
two program logics provide a remotely accessible/control-
lable mechanism that we capture as the birthmark of the

• We develop PeerPress, a prototype system that imple-
ments the proposed framework. We design new tech-

1Note that combining static analysis will deﬁnitely improve
our approach.

582malware family, which we call Malware Control Birthmark
(MCB) in this paper.

More formally, a MCB can be deﬁned as a pair:

<Portprint{P1, ψ}, MCB probing ρ and response η >

Here Portprint denotes the service port(s) ψ used by the
malware and the corresponding algorithm/logic P1 to gen-
erate such port number(s). MCB probing denotes some well-
constructed probing packet(s) ρ that trigger(s) the execution
of malware control logic P2 to reply with some (network ob-
servable) unique response(s) η.

2.2 Approach Overview

We illustrate the overview of PeerPress in Figure 1.

Dynamic(cid:13)
Malware(cid:13)
Analysis(cid:13)

Informed(cid:13)
Malware(cid:13)

Probe(cid:13)

Malware(cid:13)
Control(cid:13)
Birthmarks(cid:13)

Automated MCB Extraction(cid:13)

Active MCB 

Probing/Detection(cid:13)

Figure 1: Our Two-phase Approach: PeerPress

The ﬁrst phase is automated MCB extraction through dy-
namic malware analysis. In this phase, we analyze the mal-
ware sample and extract its MCBs (including both Portprint
{P1, ψ} and MCB Probing ρ, η) if possible.

• Portprint extraction. To identify a portprint, we ﬁrst
run the malware P in a test environment and collect
the trace from the malware starting up to opening a
socket and binding this socket to a port. We capture
the network service port ψ and further reason about
the generation of such port. If the port number is envi-
ronment dependent and/or algorithmically generated,
we need to further extract its generation logic P1.

• MCB probing extraction. Using the same analysis
environment, we begin with sending random fuzzing
packets to trigger the execution of logic P2. Lever-
aging the basic execution trace, we perform directed,
informed multi-path exploration to identify interest-
ing MCB execution paths. We further employ concrete
and symbolic execution techniques to derive MCB prob-
ing packets (input) ρ and the corresponding response
η. To verify the uniqueness of MCBs, we examine ρ
and η to ensure it is not the similar benign traﬃc tar-
geting port ψ.

The second phase is MCB-assisted network probing. We
will use our extracted MCBs to guide probing of networked
computers to quickly and reliably identify malware infected
victims. More speciﬁcally, targeting the P1-generated port
ψ, we employ a network scanner S to probe each host. If we
observe the desired ρ and η pair from probing, we report the
machine as compromised (by the speciﬁc P2P malware).

As we can see, the MCB-assisted network probing is rela-
tively straightforward once MCBs are generated. In the rest
of the paper, we will focus on the automated extraction of
MCBs.

2.3 Key Challenges and Basic Ideas
Challenge 1: Extracting and reasoning about the
dynamic portprint {P1, ψ}. It is worth noting that the
port number ψ that we might observe in the analysis envi-
ronment may not represent the actual port number that will
be opened on compromised machines. This is because the
malware instance P interacts with diﬀerent environments on
diﬀerent machines, which could inﬂuence the generation of
ψ. One real-world example is the Conﬁcker worm [45], which
binds to diﬀerent ports based on diﬀerent IP addresses. Al-
though we know that P generates ψ in the analysis environ-
ment Et, we still need to derive the corresponding port ψi
in the probing environment Ei when infected by the same
malware. The dynamic attribution of the listening port on
targeted machines represents a challenge.

We ﬁnd that malware generates its listening port in three

ways:

• Static. In this case, the malware always opens a ﬁxed
port number, which might be deﬁned in a conﬁgura-
tion ﬁle or is embedded in the binary. For example,
Nugache [50] always listens on TCP port 8.

• Algorithmically deterministic.

In this case, the mal-
ware uses some algorithm to generate a host-speciﬁc
port number. This algorithm can take various param-
eters, e.g., IP address and time. Conﬁcker.C belongs to
this type [2]. We envision that more future malware
might use this advanced feature because it removes
the need of some central servers or super peers to col-
lect port information and then coordinate/distribute
among other nodes for bootstraping peer discovery in
traditional P2P malware.

• Random. The malware listens on some randomly gen-
erated port. In this case, our probing scanner will have
to utilize existing network traﬃc monitoring or port
scanners to identify the opened ports on end hosts.
With the widely deployed network monitoring and scan-
ning tools already available to network administrators,
this should not be a signiﬁcant issue.

Thus, an eﬀective solution should tell us the portprint
type of a given malware program (static, random, or algo-
rithmically deterministic). Furthermore, it should provide
the port generation logic/algorithm P1 (particularly when
it is algorithmically deterministic) and the knowledge of the
environment it depends on (e.g., IP/Mac address, machine
name, or system time).
In this case, given a new target
machine i to scan, we can run the same portprint logic P1,
simulating environment ei on machine i as the input param-
eters to generate the target port.

The problem of determining the type of portprints and
the sources of portprints can be solved by using well-known
taint analysis techniques [13,51,56]. However, diﬀerent from
most traditional forward taint analysis work [13,56] to solve
known-sources-to-unknown-sinks problems, our problem is
essentially many-unknown-sources-to-one-known-sink. Thus,
we start from the port number and perform oﬄine backward
taint analysis to obtain the complete data dependence ﬂow
for the port generation. Based on the semantic meaning of
the sources, we can determine the portprint type, and the
necessary environment parameters that will contribute to
the port generation. Furthermore, to extract the portprint

583generation logic P1 as an independent program, we apply
classic backward program slicing techniques [40] in a similar
way to related work [16, 36, 37].
In short, since our tech-
niques on extracting portprint are mostly on top of existing
work [13, 16, 36, 37, 51, 56], we put some detailed description
in our extended technical report [55] and the rest of the
paper will mainly focus on the second challenge.

Challenge 2: Eﬃciently Exploring and Extracting
MCB Paths Inside P2. Regarding the packet parsing
logic P2 inside P , we aim to ﬁnd all possible execution paths
that start from packet receiving routines (e.g., recv()) to
packet transmitting routines (e.g, send()). This is a basic
requirement for candidate MCB paths, because as we men-
tioned before, we assume a well-constructed MCB probing
packet ρ can trigger a speciﬁc response η along a MCB path.
Thus, the problem becomes how to eﬃciently ﬁnd all pos-
sible MCB paths in P ? It seems that existing multipath ex-
ploration approaches [15,42] could be applied directly. How-
ever, these approaches typically follow a depth-ﬁrst search
scheme and randomly choose a path when reaching any
branch point. As a result, if they are used in our applica-
tion, they will blindly explore all possible (although mostly
unnecessary) paths to ﬁnd desired MCB paths. Compared
with these traditional trigger-to-unknown-behaviour explo-
ration model, our problem is better deﬁned as trigger-to-
one-response model. Essentially, the goal of traditional mul-
tipath exploration approaches is mainly to excavate dormant
behaviour, which is quite diﬀerent from our goal.

Our proposed solution, Informed enforCed Execution(ICE),

combines both forced execution [54] and concrete/symbolic
execution [15, 42, 51] techniques to improve the eﬀectiveness
and eﬃciency in ﬁnding MCB paths. During execution,
ICE ﬁrst takes a breadth-ﬁrst search approach to quickly
obtain an overview on the packet processing procedure be-
fore going into any depth (sub-functions). Furthermore, ICE
employs directed search when exploring paths at branch
points with the intuition that some paths containing cer-
tain functions/calls are more likely MCB paths. Examples
of these functions include those that directly call send(),
or indirectly call functions that wrap send() (several lay-
ers of wrapping is possible here). We speciﬁcally deﬁne
function containers (F C) to refer to such functions that
when called they will reach our desired network routines
such as send(). Code blocks leading to those F Cs that end
with valid network transmission such as send() are preferred
when exploring paths. Moreover, a special type of F Cs will
denote functions that lead to network/process termination
such as closesocket() and exitprocess() without send-
ing out network information. Code blocks leading to these
F Cs should be given lower priorities. Basically, ICE auto-
matically creates and maintains the list of diﬀerent F Cs and
uses them to make the best possible decision at any branch
point. When exploring new paths at a branch point, ICE
has a Foreseeing step to analyze the next k code blocks to
decide the priority of branches to take. Generally speaking,
ICE will prefer the branch containing high priority F Cs and
then force the execution towards that path. We discuss the
detailed exploration algorithm in Section 3.

3. MCB PROBING EXTRACTION

3.1 ICE: Efﬁcient Path Exploration

As stated earlier, the problem of ﬁnding candidate MCB
paths is diﬀerent from the problem of traditional multipath
exploration.
In particular, as discussed in previous work
[21], path exploration without any high-level semantic guid-
ance is ineﬃcient. In our context, we introduce three novel
exploration guidelines to eﬃciently identify MCB paths: (1)
Enlarge the sinkhole hit range using Function Containers;
(2) Make wise decision on branch points by Foreseeing; (3)
Complete the MCB path through Stitched Dynamic Sym-
bolic Execution.

Collecting Function Containers Inside Malware.
Blindly (randomly) exploring paths inside malware is not
eﬃcient in our context. Thus, we employ directed path ex-
ploration techniques for ﬁnding candidate MCB paths. Since
a MCB path has some desired patterns, e.g., typically con-
taining a sinkhole point of network transmission routines
such as a send library call, it makes sense to choose paths
that likely reach these sinkholing routines. In particular, to
expand such limited small number of sinkholing routines to
a larger hit surface, we introduce the concept of Function
Containers to assist directed exploration.

Deﬁnition A function container is a function satisfying
any of the following conditions:
(I) Any desired sinkholing system/library calls are automat-
ically function containers, i.e., SysCalldesired ∈ F C;
(II) The function directly or indirectly contains/wraps an ex-
isting function container. Furthermore, the call of this FC
will lead to the call of SysCalldesired.

In this deﬁnition, SysCalldesired refers to interesting, crit-
ical system/library calls that will be typical sinkhole points,
e.g., send() and closesocket(). Condition II implies that
one FC can be wrapped by another FC, i.e., FCs can have
multiple levels. One example of Conﬁcker’s send-out rou-
tine is shown in Figure 2(a), which illustrates four separate
FCs (at diﬀerent levels). Condition II also implies that the
call of a FC will invoke the desired system call. Although
this is very hard to verify without source code or full static
analysis, in this paper, we approximate this condition if it
holds in all our recorded dynamic traces.

Function containers can be analyzed with current static
analysis techniques but are harder to completely construct
based on dynamic analysis only. To initialize our FC ta-
ble, we take advantage of the malware execution traces that
our malware analysis environment generates. Often, we ﬁnd
that malware sends out packets to contact peers and initial-
ize its membership in the P2P network. This initial activ-
ity is valuable, because the networking code used for these
packets is typically the same that is used by the P2P service
logic. Thus, these initial traces typically allow us to deter-
mine which functions are used for network traﬃc. Conﬁcker
is one typical example. For each trace, we collect both con-
trol and data ﬂow information to conduct the automatic
oﬄine analysis. If we ﬁnd our desired system/library calls,
we trace back the call frames and extract a set of n level
containers and record them into our initial FC hashtable.

During the online path exploration, we follow a breadth-
ﬁrst principle and enforce the execution towards code blocks
containing high priority FCs (e.g., those will lead to network

584(a) Diﬀerent Levels of Functional Containers

(b) Path Foreseeing

Figure 2: ICE Illustration

transmission routines). At the same time, we also update
our FC hashtable if our initial FCs collection is not correct
or not complete. We use two policies to update the FC
hashtable: (1) If one trace shows that after entering a certain
FC the trace does not lead to the desired system/library call,
we delete it and its upper level FCs from the FC list (since
it violates condition II);2 (2) If we ﬁnd one critical system
call executed but not yet deﬁned in the FC hashtable, we
create a new set of level-n containers for this system call.

Foreseeing. As shown in Figure 2(b), our dynamic analy-
sis needs to make decisions at each branch point to determine
which path to take/prefer. We leverage Foreseeing for this
purpose.

In detail, we foresee (statically look forward) k code blocks
to search for the calls to any recorded function container.
As seen in Figure 2(b), if a high priority FC is contained
in a code block, ICE assigns a priority score of +1 for the
block. Similarly, it assigns −1 in the case of encountering a
low priority FC. Then, ICE simply sums up the total prior-
ity scores Λ among all code blocks in the Lef t and Right
branches and gives preference to the branch with the overall
higher priority score. We enforce the branch decision [54] at
such branches and repeat the foreseeing till we hit a target
FC. To prevent exploring the same path again, we set the
code block that we have explored as low priority. For the
case that priority score Λr = Λl, the exploration follows the
natural execution choice. However, ICE will remember the
decision point and go back to explore the other branch later.
When trying to ﬁnd a new MCB path (a path from a re-
ceive to a send function), ICE starts from the snapshot at
the recv() call and obtains the unexplored path information
from a decision queue, which saves all the explored and un-
explored branch information.
ICE continues until (1) the
queue is empty, (2) or a user-deﬁned threshold θ of maxi-
mum MCB candidate paths is reached.

Loops and Indirect Jumps. One challenging issue of
ICE is to handle control ﬂow constructs such as loops and
indirect jumps. For indirect jumps, our foreseeing operation
may fail to predict the possible target. For loops, the pri-
ority score may be inappropriately set, which might lead to
incorrect MCB paths. Thus, we need to detect such con-

2Note that the program execution after entering the FC is
nature (i.e., not enforced) because we need to update the FC
tables based on whether the natural execution of FC directs
to the target system call or not.

trol ﬂow logic and take special handling. Whenever our
online execution module detects that one possible branch
goes back to recorded addresses (loop) or jumps to certain
variable addresses, e.g., jmp eax, we stop foreseeing and let
the program execute naturally.

However, the basic execution may not work properly at
all if the target address of an indirect jump or the number
of loop iterations is incorrect (inconsistent) due to the pre-
vious forced execution. Thus, we have to perform special
handling for loops and indirect jumps in ICE. For indirect
jumps, we need to determine whether the probing packets
contribute to the generation of the jump target. To do that,
we perform concrete and symbolic execution. More speciﬁ-
cally, we treat each byte of the probing packets as a symbol
and track its propagation.
If these bytes are used in in-
direct jumps, e.g., propagating to eip, we deduce symbolic
equations at the point of indirect jumps. We will try to solve
the symbolic equation and enumerate the possible target ad-
dresses. Then, we switch back to our online execution mode,
analyze these possible target addresses, ﬁlter out impossible
branches (if disassembled instructions at these addresses are
invalid), and continue the execution to explore further paths.
Similarly, for loops, we try to ﬁgure out whether symbolic
input bytes are propagated to the loop counter. If so, we
adopt a similar idea introduced in [47] to perform symbolic
execution.

Stitched Dynamic Symbolic Execution. Because of
our breadth-ﬁrst exploration scheme, some MCB paths re-
turned by ICE are probably not complete, with some func-
tions not fully explored (in depth). Our next step is to com-
plete the full MCB path by adding (or stitching) back these
unexplored sub-paths. It turns out to be not a straightfor-
ward issue. This is because when entering these sub-paths,
there might be again multiple diﬀerent paths to explore (as
illustrated in Fig. 3), and it is likely that only one (or some)
execution path(s) can correctly (consistently) stitch back to
the main upper layer MCB path (others will lead to other
paths that deviate from the MCB one).

Another issue we need to handle is to ﬁlter invalid MCB
paths returned in the previous step. These paths will never
be actually executed by receiving probing packets but they
are generated as artifacts due to the enforced execution.
Thus, we need to ﬁlter them.

Both issues mentioned above are related to identifying cor-
rect MCB (sub-)paths and discarding irrelevant ones. We
solve both issues using a combination of concrete and sym-

585Safe MCB Probing. Among all MCB probing packets,
there is one type we refer to as Safe MCB Probing. Simple
examples of this kind of packets include error messages that
are mainly triggered when there are wrong commands/oper-
ations. A safe probing packet implies that the malware does
not execute any problematic (dangerous) operation along
this path but already exposes itself in a unique way. In our
implementation, we simply identify the length of the cor-
responding trace and system calls recorded in the trace. If
these traces contain no dangerous system calls and the trace
length is shorter than others, we consider this corresponding
packet as potential safe MCB probing.

Limitations.
ICE suﬀers from some of the problems in
existing multipath explorations approaches [15,42,44] due to
the dynamic analysis nature. For example, one issue lead-
ing to some undiscovered control ﬂow is shown in Fig. 4. If
malware has diﬀerent functions (A and B) to parse packets,
based on diﬀerent system conﬁgurations, e.g., configure_A
and configure_B, ICE may only generate one possible MCB
path that is observed during the execution and thus fail to
probe machines with the other conﬁguration. This prob-
lem could be solved by taking into account environment-
sensitive/implicit control ﬂows, which we leave for future
work.

1
2
3
4

I f

c o n f i g u r e A==TRUE:

p r o c e s s A ( r e c e i v e d p a c k e t b u f f e r )

I f

c o n f i g u r e B==TRUE:

p r o c e s s B ( r e c e i v e d p a c k e t b u f f e r )

Figure 4: Example of Undiscovered Control Flow

3.2 Veriﬁer: Filtering False Positive Cases

After the dynamic analysis of the malware sample, we
need to verify whether our generated MCB can actually be
used for probing. That is, we have to ensure that the probing
packet can actually trigger the malware to reply uniquely.
We run the malware sample again in another clean envi-
ronment without any instrumentation and check whether it
responds to the probing packet with the expected reply or
not. If so, we go to the second round veriﬁcation.

Second round veriﬁcation is to verify whether the reply
is unique or not. We need to ensure that the response is
not the same as a response from some normal well-known
(P2P) software. For that purpose, we need to manually
build a whitelist database of multiple, well-known benign
services/applications/protocols, including most well-known
P2P software, for their normal request-response patterns.
Such patterns include identifying the protocol speciﬁcation
and marking all the ﬁxed/variable ﬁelds inside the response.
In this way, we can search the whitelist and ﬁnd whether
our extracted MCB is a unique evidence or not.

Limitations. In reality, it is very challenging and almost
impossible to construct a complete and precise database as
whitelist.
In our preliminary implementation, we simply
collect around 50 benign P2P/FTP/HTTP software includ-
ing Apache, FileZilla, eDonkey, eMule, Morpheus, Limewire,
Kazaa, which we intend to expand over time. We test each
MCB probing on these benign software and make sure they
will not generate the same response as the malware does.
For each benign software, we carefully read the related pro-
tocol documents (e.g., eDonkey P2P, FTP) and extract the

Figure 3: Stitch sub-paths along MCBs

bolic execution. One important assumption is that we con-
sider the probing packet ρ as the only causal factor to drive
P2 to generate the response packet η along MCB paths.
Thus, we consider a (sub-)path of MCB as valid when the
relevant branches have control ﬂow dependences on symbol
variables in ρ. Speciﬁcally, for each MCB main path, we
mark the size and each byte of the received buﬀer as symbol
values. Then, we monitor the propagation of these symbols
along the path. If we encounter an enforced path with no
control dependence on the symbol variables, we discard this
MCB candidate because its execution may not be dependent
on probing packets.

When we encounter any function call in unexplored sub-
paths, we provide the call with the current symbol context
and create a snapshot at the entrance point. Thus, after
we enter the function, we repeat the procedure mentioned
before to keep track of the control ﬂow with symbolic vari-
ables. When we encounter a branch possibly aﬀected by
some symbol variable, we record this address into a queue.
It tells us that this branch has two possible choices and we
need go back to the snapshot and explore another branch
later. This step recursively occurs (in some cases, we need
to go even deeper into sub-functions) until we ﬁnd out all
possible sub-paths along the main MCB path.

Handling Encoding Function. One special case needs
to be further mentioned:
the encoding function such as
encryption, hash and checksum. Thanks to previous re-
search [18,51,53], we can prevent inﬁnite symbolic execution
for such functions that possibly exist along the MCB path.
We build an automatic tool to identify and bypass encoding
functions using similar heuristics mentioned in [18,28,39,56].
To actually reverse such functions, we leverage partially au-
tomatic techniques similar to previous work [18]. We skip
details here as they are not our major contributions, and we
will discuss some limitations of current design in Section 7.

Solving the MCB path. When we obtain a complete
MCB path (including sub-paths), the ﬁnal step is to solve
the constraints along this entire MCB path. The complete
MCB path includes the information about symbol propaga-
tion. We construct the symbolic equations and input the
resulting equation into a solver. If the equations are solv-
able, we can construct a MCB probing packet ρ that follows
the MCB from the receive function to the send function and
generates a response η.

586patterns mentioned before. Clearly, this manual work is te-
dious and may not work for benign software using unknown
or undocumented protocol. In this case, existing automatic
protocol reverse engineering techniques [17, 20, 23, 24] could
help us to build models for legitimate protocols, and we can
then use these models to improve our whitelist. This is es-
pecially important to ﬁnd minor diﬀerences between MCBs
and benign protocols. We also note that false positive cases
are possible due to the incompleteness of the whitelist. How-
ever, the incompleteness will mainly cause possible false pos-
sibles but not false negatives. Nevertheless, we did not see
false positives in our experiments. We discuss more impli-
cations in Section 7 and leave it as future work to construct
a better whitelist database.

4.

IMPLEMENTATION

Our PeerPress implementation combines both (online) dy-
namic analysis and oﬄine processing. For online analysis
and recording, we implement two versions based on toolset
DynamoRIO [3] (which is lightweight but may fail on some
malware) and TEMU [9] (which is more robust to run mal-
ware but is also more heavyweight). Online modules take
charge of generating instruction traces and performing in-
formed, forced execution. As an illustration, for our TEMU-
based implementation, we have developed three new inde-
pendent plug-ins. The ﬁrst is to record ﬁne-grained (for
port generation logic and probing packet parsing analysis)
and coarse-grained (for FC extraction/update) traces. The
second is to enforce certain branch decisions based on the
input of the oﬄine analysis components.
It executes the
foreseeing operations by disassembling code blocks follow-
ing undecided branches and searching for the calls of FCs.
The last plug-in is for general execution control. It helps us
to start execution at speciﬁc addresses, dump/modify mem-
ory/registry values, create execution snapshots and perform
system/library hooking. Furthermore, we enhance TEMU’s
taint analysis to support tainting the input/output of spe-
ciﬁc calls.

Our main implementation eﬀort concentrates on oﬄine
modules. Our oﬄine modules are mainly built using Python,
and they include program dataﬂow analysis, program slice
generation, and ICE input generation. For example, in port-
print extraction, we perform backward taint analysis and
program slicing on ﬁne-grained traces. At the same time,
our oﬄine module collects semantic information to derive
the portprint type and to extract the program slice for on-
line replaying. In ICE, to support multi-round exploration,
our oﬄine module ﬁrst fully analyzes the trace we generated
in the previous round. Then, it provides our online module
with a concrete speciﬁcation of the path exploration.
It
includes where to start execution, whether to create snap-
shot or not, what branch decision chain for our online en-
forced execution to follow ﬁrst, and how to modify the mem-
ory/register value. Furthermore, for symbolic execution, we
developed a module to translate the instruction traces into
the VEX intermediate language using libVex [4]. We devel-
oped our own symbolic execution engine and an interface to
Z3 [11] constraint solver.

5. EVALUATION

In this section, we evaluate PeerPress on several real-
world malware families, which are listed in Table 1. This

includes representative and complex modern P2P bots such
as the infamous Nugache malware [50], Phatbot, Storm/Pea-
comm [48], Conﬁcker C [2], and more recent Sality [12](still
active in the wild as the writing of this paper). We also in-
clude several Trojan horse/backoor malware, because they
also contain MCBs (many of them could also be considered
as bots). This is to further demonstrate that PeerPress can
detect more than just P2P malware, as long as PeerPress
can extract MCBs from the malware. These malware sam-
ples were collected from multiple online malware repositories
such as [1, 5] and diverse security researchers. We veriﬁed
the ground truth labels of these malware with multiple on-
line malware analysis services such as [1, 10] and manual
examination on binaries and network traﬃc.

5.1 Effectiveness of Portprint Extraction

We extracted portprints for each malware family and we
summarize them in Table 2. To verify their correctness, we
run these malware multiple times in a clean environment and
each time compare our extracted portprint with the actual
port the malware bound to. The detailed result is shown in
Table 2.

Among all the malware we have examined, Conﬁcker C
has a complex and unique port generation logic, which was
previously manually analyzed in [45]. Now with PeerPress,
we can automatically extract this logic within a few minutes.
Furthermore, PeerPress provides a clear function interface
with parameters and their semantic meanings because it cap-
tures system calls such as getpeername that parse the buﬀer
related to the slice arguments. It is worth noting that algo-
rithmically deterministic portprints are a strong evidence of
the malware existence. That is, with only portprints (even
without further MCB probing packets/response), we can al-
ready detect this kind of malware with very high conﬁdence.
We ﬁnd that many portprints are static in our tested
malware. Most of such malware embeds the port number
in the binary, such as NuclearRAT and NuCrypt, or reads
from some conﬁguration ﬁle, such as the case of Peacom-
m/Storm. Only a few malware samples (Phabot and Nu-
gache) listen on totally random ports.
In our tests, the
ports were used for FTP services in both cases (to pro-
vide egg downloading service for newly infected malware).
This inspired us to probe suspicious random ports just us-
ing an FTP packet and monitor their reply. In Section 5.3,
we further demonstrate even though the malware may use
the standard FTP protocol, the slight implementation dif-
ferences may still expose themselves. One very interesting
case is the algorithmically deterministic portprint of Sal-
ity (UDP port), because previous reports have claimed that
the port is selected pseudo-randomly [12]. We carefully ex-
amine our generated portprint and ﬁnd that there are two
source bytes that are the result of system call GetComput-
erName(). These two bytes are multiplied, and the result
is added to a constant number 0x438. Meanwhile, through
tracking the control dependences, PeerPress also successfully
extracts another path which forces the malware to bind to
a static port, 9674. We deduce that the reason why secu-
rity reports such as [25] claim the port is psedo-randomly
generated may be because: (1) The computer name can be
considered as a random value.
(2) It is possible for mal-
ware authors to reconﬁgure the constant number 0x438 to
other constant value. PeerPress declares that the portprint
of Sality is algorithmically deterministic, and it extracts the

587Name

Type

Name

Type

Conﬁcker C [2]

Phabot [6]

Storm/Peacomm [48]

NuclearRAT

Penumbra
NuCrypt

P2P Bot
P2P Bot
P2P bot
Trojan horse/Spyware
Backdoor
Trojan horse/worm

Nugache [50]

Sality [12]
BackOrﬁce

P2P bot & Trojan Horse
P2P Bot
Trojan horse/backdoor

WinEggDrop Keylogger/Spyware

WinCrash

Wopla

Backdoor
Trojan horse

Table 1: 12 malware families in our evaluation

Malware

Type detmined by MProbe

Observed Port Number

Description

Correctness

Conﬁcker C

Nugache

Sality
Phabot

Peacomm
BackOrﬁce
NuclearRAT
WinEggDrop

Penumbra
NuCrypt

Wopla

WinCrash

algorithmically determined
static/randomly generated
algorithmically determined

randomly generated

static
static
static
static
static
static
static
static

46523/TCP and 18849/UDP

Program Slice with IP and time

8/TCP, 3722/TCP

6162/UDP
1999/TCP

Open Multiple (ﬁxed/random) Ports
Generated based on Computer Name

7871,11217/UDP

Read from spooldr.ini

31337/TCP

190/TCP

12345/TCP
2046/TCP
3133/TCP

8080/TCP, 25099/TCP

1596/TCP

In binary
In binary
In binary
In binary
In binary

In binary/ﬁle

In binary

X

X

X

X

X

X

X

X

X

X

X

X

Table 2: Portprint details of diﬀerent malware families

program slice with the target computer name as the param-
eter. Once provided with computer names (which should be
available to most network administrators), PeerPress can
probe target machines to detect Sality infected victims.

5.2 Effectiveness of ICE

In this section, we evaluate the eﬀectiveness of ICE. First,
we conduct an experiment to verify that there are multiple
function containers in each malware binary, which supports
our assumption that function-level abstraction is feasible in
dynamic analysis. Second, we verify that it can signiﬁcantly
reduce the overhead of path exploration compared to exist-
ing exploration scheme.

Function Containers in Malware Binary. In our evalu-
ation, we set the maximum call depth level as 4, and locate
on average 28 function containers per malware sample us-
ing this level.
In our tests, all containers eventually lead
to desired system calls. More interestingly, throughout all
our test cases, malware calls these containers if they want
to execute speciﬁc tasks.

Overhead Comparison. To evaluate whether our informed
execution can eﬃciently locate desired MCB logic, we com-
pare the performance of ICE with the traditional approach
that randomly chooses a path to explore next [54]. Here, the
performance is measured using the number of rounds to ﬁnd
all MCB paths (that the system succeeds in ﬁnding using
a brute-force approach), and each round is deﬁned as one
path exploration attempt from the sink (receiving the prob-
ing packet) to the end of the execution run for this path.
Note that we do not claim to be able to explore all execu-
tion paths in the program. Instead, our baseline of all MCB
paths is determined by brute-force exploration of all possible
paths that can be directed/triggered by one single probing
packet (i.e., we may miss MCB paths that can only be trig-
gered by multiple probing packets). All these paths start
from packet receiving till (i) the malware sends out some
response, or (ii) the communication/process terminates. In

this test, it is not very important whether we obtain accu-
rately all MCB paths or not. Instead, more importantly we
want to see which technique is quicker to locate these MCB
paths given as the baseline. The result is shown in Figure
5. We can clearly see that our ICE signiﬁcantly outperforms
the traditional forced executions [54]. Our method requires
much fewer exploration rounds to ﬁnd MCB paths. In many
cases, our system reduces the overhead up to 80%.

5.3 Overall MCB Extraction

PeerPress successfully extracts on average about 6 MCB
probing/response pairs per sample from all the tested mal-
ware, as shown in Table 4.
In terms of running time, we
select three most complex, representative malware samples
and report the performance for diﬀerent components of our
system in Table 3 (performance of other samples are sim-
ilar or better, omitted here due to space limitation). We
acknowledge that some steps, such as semantic derivation
and symbolic execution are relatively slow, which is not
surprising considering that we are analyzing very complex
real-world P2P malware in a ﬁne-grained way with some
known-expensive operations. Compared with existing state-
of-the-art work (e.g., [17, 18]) that also uses expensive dy-
namic analysis and symbolic execution techniques, our per-
formance is on par with those studies, and we believe it is
reasonable and tolerable for oﬄine analysis of malware fam-
ilies (recall that the analysis does not need to be repeated
for each individual sample).
It can certainly be improved
by optimizing our code, parallelizing some operations, and
using more powerful hardware.

Among all MCBs that PeerPress extracted, the simple
case is represented by certain Trojan horses/backdoors that
provide some unique“Welcome” information in their response.
It is actually a very eﬀective and safe MCB without much
eﬀort to generate. We can initiate connections to the sus-
pected host and verify whether it welcomes us in the speciﬁc
way or not. This welcome message is most common in old
fashion Trojan horses, because an adversary may use any re-

588Figure 5: Performance comparison of ICE and Random Exploration

Recording

Fine-grained
(min)
Backward Taint (sec)
Program Slicing (sec)
Semantic Derivation (sec)
ICE engine (sec/trace)
Symbolic execution (sec/-
trace)

Conﬁcker
C
38

243
180
2813
54.4
6863

Nugache Peacomm

21

549
363
489
38.9
1602

37

780
173
541
40.3
2711

Table 3: Running time of MCB extraction

Malware

# MCB Malware

# MCB

Conﬁcker C
Sality
Phabot
WinEggDrop
Nugache
NuCrypt

3/3
1/1
13/9
11/8
21/7
2/2

Peacom
BackOriﬁce
NuclearRAT
Penumbra
WinCrash
Wopla

6/3
16/14
17/12
16/13
1/1
2/2

Table 4: Statistics on extracted malware MCBs.
(Here X/Y in Column # MCB means there are X
candidate MCBs and Y ﬁnal MCBs after veriﬁca-
tion.)

mote client to control the bots. We ﬁnd this in Nugache FTP
logic and some other malware, e.g., WinCrash and Wopla.
For example, Nugache uses the following welcome message:
220-220-Welcome 220.

We ﬁnd that many MCB probing packets are easy to
craft because there are no (or not many) encoding routines.
More precisely, we found cleartext FTP logic inside Nu-
gache, Wopla and Phatbot, peer synchronization logic inside
Peacomm, and command and control logic inside traditional
Trojan horses. Even though there are only a limited num-
ber of samples, our system is robust and fast to obtain MCB
probing in a fully automatic way. In detail, we ﬁnd one sim-
ple FTP service logic hosted by Nugache on a high-order
port. After traversing the MCB paths, we extract 21 com-
mand and response pairs. After further veriﬁcation, 14 are
ﬁltered (e.g., command ls and pwd) because they are not
be considered as unique evidence. As an interesting MCB
example among the rest, we ﬁnd that the Nugache FTP
service needs users to provide Username and Port for vali-
dation, which are quite diﬀerent from normal FTP services
we see.

For Peacomm/Storm case, PeerPress extracted six MCB
probing candidates. We test these MCBs on the benign
eDonkey clients and ﬁlter out three. One ﬁltered example
is a 509-byte probing packets (with the ﬁrst two bytes as
0xe3 0x13) that will receive a 18-byte response packet be-
ginning with 0xe3 0x14. This is actually used for regular

peer recognition in the eDonkey protocol. The remaining
three are interesting MCBs, include a probing packet begin-
ning with the ﬁrst two bytes 0xe3 0x0d and the correspond-
ing response packet beginning with 0xe3 0x0a.

For the most sophisticated cases, we have to bypass the en-
coding function before the symbolic execution. As described
before, we apply a semi-automatic approach to extract the
encoding function inside of the traces. We automatically
locate the RC4 encryption and checksum routine inside Con-
ﬁcker and Sality, using several heuristics including highly-
mixed receiving buﬀer [18]. We also successfully identify
two double-word decryption keys inside the Conﬁcker and
Sality packet (with payload oﬀset 2 and 0). Thus, we can
recover the encrypted probing packet after the symbolic ex-
ecution. Examining the cleartext payload, we ﬁnd one key
data ﬁeld containing the payload version inside both Con-
ﬁcker and Sality. Both malware programs generate replies
if the received payload version is lower or equal to its own
binary version. It seems that the P2P logic implements a
self-updating procedure, and the only way to trigger its re-
ply is to provide a payload with a suitable version number.
Another interesting ﬁnding about the Sality botnet is the
double replies. When we feed our probing packet, Sality se-
quentially replies with two packets. One packet attempts to
start a new UDP session while the other one is a reply to
our MCB probing.

Although PeerPress extracted MCBs from all tested mal-
ware, we note that it does not mean PeerPress can extract all
MCBs inside malware. We actually encounter some issues
due to some complex control logic inside some malware pro-
grams. For example, PeerPress failed to extract MCBs from
Nugache’s port 8. We ﬁnd multiple W aitF orSingleObject
calls in the traces, waiting for some (asynchronous) event
from other threads/process. ICE failed to correctly explore
the paths in that situation. In the case of Conﬁcker, Peer-
Press is not able to automatically crack the multi-round ad-
vanced encoding routines, thus failed to extract MCBs on
some ports. The fact that PeerPress failed in several cases
is not surprising, as we are dealing with real-world complex
malware. However, our results are still encouraging because
PeerPress could extract at least one meaningful MCB for all
families that we examined.

5.4 Detection Results through Active Probing
In this section, we conduct the experiments to verify that
our MCB-informed active probing can detect our targeted
malware in a reliable, robust, fast and scalable way.

Test in Virtual Networks. We built one virtual envi-
ronment with six virtual machines. All virtual machines
installed Windows XP SP1 without new patches. We ran-

589domly selected two diﬀerent malware samples (from Table
1) to install on each machine (and eventually cover all twelve
malware families in six VMs). Meanwhile, we installed some
well-known benign services, such as Apache web server, P2P
clients (e.g., edonkey), and FTP servers (e.g., Filezilla). Our
probing engine uses extracted MCBs to actively probe the
entire virtual network. PeerPress correctly detected all the
existing malware in the virtual network without false posi-
tives. In terms of detection speed, it only took on average
1.103 seconds to detect each malware. This demonstrates
that the informed active probing is an eﬀective approach to
detect malware in the network.

To further verify the robustness of PeerPress to detect dif-
ferent variants in the same malware family, we further col-
lected three additional (but diﬀerent) binaries of the same
malware for Conﬁcker, Storm/Peacomm, and NuclearRAT,
and Nugache, respectively3. Our test environment is the
same as mentioned before. PeerPress can not only detect all
the variants but also correctly classiﬁed all variants into its
original families. This again veriﬁes that MCBs are unique
for the same malware family and PeerPress is robust in de-
tecting diﬀerent malware variants in the same family.

False Positive Test in Real Networks. Next, we scanned
our campus network (we randomly choose three /24 net-
works with no ﬁrewall to ﬁlter our scans) to test the real-
world performance of PeerPress using the above extracted
MCBs. We did not ﬁnd any false positive during the scan,
because most hosts do not have the corresponding (malware
portprint speciﬁc) ports open. This is not surprising because
our campus networks/computers are well managed/secured.
We then intentionally scanned other open ports on these
machines in order to further test the false positive of using
MCB probing/response. We chose to scan port 80 (web)
and all ports above 1025 in these three networks in hope to
ﬁnd some P2P applications. We found 58 hosts opened port
80 and 110 hosts opened higher ports, varying from sev-
eral well-known P2P ports such as 6881 (BitTorrent) and
49153-49156 (uTorrent/Azureus) to some unknown ports.
Our MCB-informed probing again did not yield any false
positive. The probing speed for each host is about 1.128
seconds on average per MCB (including the ﬁrst TCP port
scanning interaction and the following MCB probing pack-
et/response). Considering that it is easy to perform paral-
lel scanning using multiple threads, PeerPress demonstrates
good detection speed/scalability.

Comparisons with State-of-the-Art Detection Sys-
tems. In terms of an eﬃciency comparison with some state-
of-the-art malware detection systems, we can mainly do a
paper-and-pencil case study here because we could not ob-
tain most of these tools. AccessMiner [38] is one relevant
host-based detection system.
It has a high accuracy and
covers a lot of malware families. However, it may not be
good enough at the stage where a P2P bot is waiting to
receive commands from the botmaster, because it has not
triggered its malicious logic yet. Meanwhile, it may also
consume considerable resources on each end-host, so it is
less scalable for deployment on large networks.

We further deploy another state-of-the-art network-based
detection system, BotHunter [31], in our test (virtual) net-

3For these four malware we could ﬁnd diﬀerent binaries/-
variants.

work and no malware (on six machines) is detected. This is
reasonable because BotHunter needs to accumulate actual
evidence related to multiple phases in the malware infection
life cycle. In our cases, most of malware does not exhibit ma-
licious network activity because the samples did not receive
any commands. This also exposes one common limitation of
many existing detection systems: they are passive and could
be slow in terms of detection speed. On the contrary, Peer-
Press can actively detect those malware, even before those
infected machine are accessed/controlled by remote peer-
s/botmasters.

Note that compared with existing systems, PeerPress does
have a limitation regarding to its detection scope. As clearly
mentioned, PeerPress only targets malware that has MCBs,
instead of all malware. However, we still consider it a valu-
able addition to our arsenal, because P2P malware and Tro-
jan/backdoors are serious and emerging threats that we need
to address. PeerPress greatly complements existing passive
malware detection approaches.

6. RELATED WORK
We now review additional related work previously not men-
tioned.

Multiple-path Exploration. One related research is the
exploration of dormant functionalities [15, 42, 44, 54] in mal-
ware binary.
In [42], the authors take snapshots at each
branch point and reset when an additional branch needs
to be explored. Wilhelm et al. [54] present a forced sam-
pled execution approach to explore multiple rootkit execu-
tion paths. However, both exploration schemes still depend
on random choice because they cannot correctly deﬁne what
is the target function they want to explore. Our goal is to
explore the MCB paths, so the exploration can be eﬀectively
accelerated and the overhead is signiﬁcantly reduced. Mean-
while, ICE solves the problem of exploring the sub-paths
along one explored MCB main path, which is diﬀerent from
the problem solved by previous work.

Protocol Reverse Engineering. Automatic protocol re-
verse engineering (PRE) research [17,20,23,24] discovers the
semantic meanings of network protocols. However, these
studies were mostly focused on analyzing legitimate net-
work protocols. In such cases, it is easy to elicit a response
from the application, simply by using a legitimate client that
sends a valid request. We do not know how a valid request
looks like; in fact, one key aspect of our work is to eﬃciently
locate MCB execution paths, which determine the format of
probe packets that can be used to obtain responses. More-
over, PRE systems are broader in the sense that they at-
tempt to reverse engineer entire packet formats and state
machines. This is ﬁne for legitimate applications, but might
be too brittle when applied to malicious binary code. Our
technique, on the other hand, focuses on a speciﬁc problem
(the extraction of inputs that trigger responses), and hence,
can be more robust. In addition, we introduce the idea of
dynamic portprints, a concept that is not considered by PRE
systems. Finally, we note that better protocol knowledge is
certainly helpful in both crafting better MCB packets and
verifying/ﬁltering false positive cases, as mentioned before.
Thus, we consider these PRE techniques to be complemen-
tary to our work.

Network-based (P2P) malware detection. Network-

590based detection approaches [22, 29, 31, 33, 34, 41, 43] attempt
to inspect network traﬃc to detect some anomalous activi-
ties, patterns, or structures. Their weaknesses were already
discussed earlier. In [30], Gu et al. present BotProbe that
actively sends probing packs through IRC channels to sepa-
rate botnet C&C dialogs from human-human conversations
to detect IRC bots. PeerPress diﬀers in that we accurately
extract MCBs from malware binaries to probe them.

Code Reuse. Previous work [16, 36, 37] applies forward
taint analysis and backward program slicing to extract in-
teresting, relevant instructions as a stand-alone program.
Our portprint extraction uses similar techniques to solve a
speciﬁc problem. Diﬀerent from [16], PeerPress extracts a
virtual function from the whole program level instead of
single function level, and the way of reusing/replaying of
the code is diﬀerent. Diﬀerent from [36, 37], PeerPress uses
backward taint analysis instead of forward analysis because
in our context, we have a clear sinkholing point (the port
binding event) but many unknown source points.

ment to existing passive detection techniques even though
it is not perfect (just as any intrusion/malware detection
technique).

8. CONCLUSION

P2P malware is an important direction for future malware.
Current P2P malware detection remains insuﬃcient. In this
paper, we propose a novel, two-phase detection framework
that seamlessly bridges host-level dynamic binary analysis
and network-level informed active probing techniques. It can
detect P2P malware and beyond, as long as the malware
has MCBs. We developed new techniques such as ICE to
tackle our research challenges, and we implemented a proto-
type system, PeerPress, to demonstrate the real-world util-
ity. Our initial results are very encouraging. Although not
perfect, PeerPress demonstrates an important step toward
proactive malware detection and defense (instead of passive
monitoring), a direction worth more attention from the se-
curity research community.

7. LIMITATIONS AND DISCUSSION

9. ACKNOWLEDGMENTS

In this section, we discuss the limitations and implications

of our solution.

A notable limitation of PeerPress is that it cannot craft
correct MCB probing packets in the case of advanced en-
cryption or certiﬁcate-based authentication, even though it
could identify/bypass these routines. However, this is a com-
mon problem for all malware analysis tools that aim to pro-
vide meaningful (network) input to malware samples [18].
Malware could use this to verify/authenticate our incorrect
probing packets and refuse providing any future response.
However, even in this worst case, we argue that this kind
of “no response” is indeed a special, suspicious, recognizable
response that could be used in MCB probing. Furthermore,
we note that our technique can still successfully extract port-
prints, and in many cases, the portprint itself is enough to
detect/conﬁrm the malware (without actually sending MCB
probing content).

To evade portprint extraction, malware authors may in-
tentionally delay the port binding until some conditions are
satisﬁed, e.g., the time reaches some speciﬁc date. Indeed,
it prevents PeerPress from discovering the port binding at
ﬁrst sight with the cost of decreasing the utility (in terms of
accessibility) of the malware. This issue could be solved if
we skip all the sleep() related functions in the monitoring
and analysis.

To slow down the analysis of ICE, malware authors may
intentionally include many (bogus) branches directly after
the packet receiving. Even in such case, ICE is still faster
than random path explorations.

Another possible evasion is to faithfully mimic a benign
normal protocol behavior. First, this will increase the work-
load of malware authors. Second, if not implemented faith-
fully, the malware still could be ﬁngerprinted due to the
subtle diﬀerences from normal protocols, as studies in this
domain have shown [14, 19]. If the malware authors choose
to copy code from existing open source software in order to
avoid diﬀerences in implementation, the code replication/-
copy [52] could become another possible point of detection.
Finally, we note that within its detection scope (when
MCBs can be successfully extracted), PeerPress is fast, re-
liable, robust, and scalable. We believe it is a great comple-

This material is based upon work supported in part by
the National Science Foundation under Grant CNS-0954096
and the Texas Higher Education Coordinating Board under
NHARP Grant no. 01909. Any opinions, ﬁndings, and con-
clusions or recommendations expressed in this material are
those of the author(s) and do not necessarily reﬂect the views
of the National Science Foundation and the Texas Higher
Education Coordinating Board.

10. REFERENCES
[1] Anubis: Analyzing Unknown Binaries.

https://anubis.iseclab.org.
[2] Conﬁcker C Analysis Report .

http://mtc.sri.com/Conficker/.

[3] DynamoRIO . http://dynamorio.org/.
[4] LibVex . http://http://valgrind.org/.
[5] OﬀensiveComputing.

http://www.offensivecomputing.net/.

[6] Phabot. http://www.secureworks.com/research/threats/

phatbot/?threat=phatbot.

[7] Sulley. http://code.google.com/p/sulley/.
[8] Symantec Internet Security Threat Report.

http://www.symantec.com/business/theme.jsp?themeid=
threatreport.

[9] Temu . http://bitblaze.cs.berkeley.edu/temu.html.

[10] Virustotal. https://www.virustotal.com/.
[11] Z3 EMT Solver . http://research.microsoft.com/en-us/

um/redmond/projects/z3/.

[12] Cybercriminals Making Sality Virus More Complex.

http://www.spamfighter.com/Cybercriminals-Making\
\-Sality-Virus-More-Complex-16068-News.htm, 2011.

[13] Thanassis Avgerinos, Edward Schwartz, and David

Brumley. All you ever wanted to know about dynamic taint
analysis and forward symbolic execution (but might have
been afraid to ask). In Proc. of IEEE S&P’10, 2010.

[14] David Brumley, Juan Caballero, Zhenkai Liang, James

Newsome, and Dawn Song. Towards automatic discovery of
deviations in binary implementations with applications to
error detection and ﬁngerprint generation. In Proc. of
USENIX Security’07, 2007.

[15] David Brumley, Cody Hartwig, Zhenkai Liang, James

Newsome, Pongsin Poosankam, Dawn Song, and Heng Yin.
Automatically identifying trigger-based behavior in
malware. In Wenke Lee, Cliﬀ Wang, and David Dagon,

591editors, Botnet Analysis and Defense, volume 36, pages
65–88. Springer, 2008.

R. Kemmerer. Behavior-based spyware detection. In Proc.
of USENIX Security’06, 2006.

[16] Juan Caballero, Noah M. Johnson, Stephen McCamant,

[36] Clemens Kolbitsch, Paolo Milani Comparetti, Christopher

and Dawn Song. Binary code extraction and interface
identiﬁcation for security applications. In Proc. of
NDSS’10, 2010.

Kruegel, Engin Kirda, Xiaoyong Zhou, and Xiaofeng Wang.
Eﬀective and eﬃcient malware detection at the end host. In
Proc. of USENIX Security’09, 2009.

[17] Juan Caballero, Pongsin Poosankam, Christian Kreibich,

[37] Clemens Kolbitsch, Thorsten Holz, Christopher Kruegel,

and Dawn Song. Dispatcher: Enabling active botnet
inﬁltration using automatic protocol reverse-engineering. In
Proc. of ACM CCS’09, 2009.

[18] Juan Caballero, Pongsin Poosankam, Stephen McCamant,

Domagoj Babi´c, and Dawn Song. Input generation via
decomposition and re-stitching: Finding bugs in malware.
In Proc. of ACM CCS’10, September 2010.

[19] Juan Caballero, Shobha Venkataraman, Pongsin

Poosankam, Min Gyung Kang, Dawn Song, and Avrim
Blum. FiG: Automatic ﬁngerprint generation. In Proc. of
NDSS’07, 2007.

[20] Juan Caballero, Heng Yin, Zhenkai Liang, and Dawn Song.
Polyglot: Automatic extraction of protocol message format
using dynamic binary analysis. In Proc. of ACM CCS’07,
2007.

[21] Chia Yuan Cho, Domagoj Babic, Pongsin Poosankam,

Kevin Zhijie Chen, Edward XueJun Wu, and Dawn Song.
Mace: Model-inference-assisted concolic exploration for
protocol and vulnerability discovery. In Proc. of USENIX
Security’11, 2011.

[22] Baris Coskun, Sven Dietrich, and Nasir Memon. Friends of

an enemy: Identifying local members of peer-to-peer
botnets using mutual contacts. In Proc. of ACSAC’10,
2010.

[23] W. Cui, J. Kannan, and H. J. Wang. Discoverer:

Automatic protocol description generation from network
traces. In Proceedings of USENIX Security Symposium,
Boston, MA, August 2007.

[24] W. Cui, M. Peinado, K. Chen, H. J. Wang, and

L. Irun-Briz. Tupni: Automatic reverse engineering of input
formats. In Proc. of ACM CCS’08, 2008.

[25] Nicolas Falliere. Sality: Story of a peer-to-peer viral

network. Technical report, 2011.

[26] Alexander Gostev. 2010: The year of the vulnerability .

http://www.net-security.org/article.php?id=1543,
2010.

[27] Julian B. Grizzard, Vikram Sharma, Chris Nunnery, Brent

Kang, and David Dagon. Peer-to-peer botnets: Overview
and case study. In Proc. of USENIX HotBots’07, 2007.
[28] Flix Grobert. Automatic identiﬁcation of cryptographic
primitives in software. Master’s thesis, Ruhr-University
Bochum,Germany, 2010.

[29] Guofei Gu, Roberto Perdisci, Junjie Zhang, and Wenke

Lee. BotMiner: Clustering Analysis of Network Traﬃc for
Protocol- and Structure-Independent Botnet Detection. In
Proc. of USENIX Security’08, 2008.

[30] Guofei Gu, Vinod Yegneswaran, Phillip Porras, Jennifer
Stoll, and Wenke Lee. Active botnet probing to identify
obscure command and control channels. In Proc. of
ACSAC’09, 2009.

[31] Guofei Gu, Junjie Zhang, and Wenke Lee. BotHunter:

Detecting Malware Infection Through IDS-Driven Dialog
Correlation. In Proceedings of USENIX Security’07, 2007.

[32] Guofei Gu, Junjie Zhang, and Wenke Lee. BotSniﬀer:
Detecting Botnet Command and Control Channels in
Network Traﬃc. In Proc. of NDSS’08, 2008.

[33] Duc T. Ha, Guanhua Yan, Stephan Eidenbenz, and

Hung Q. Ngo. On the eﬀectiveness of structural detection
and defense against p2p-based botnets. In Proc. of DSN’09,
2009.

[34] M´ark Jelasity and Vilmos Bilicki. Towards automated

detection of peer-to-peer botnets: on the limits of local
approaches. In Proc. of LEET’09, 2009.

[35] E. Kirda, C. Kruegel, G. Banks, G. Vigna, and

and Engin Kirda. Inspector gadget: Automated extraction
of proprietary gadgets from malware binaries. In 31st IEEE
Symposium on Security and Privacy, May 2010.

[38] Andrea Lanzi, Davide Balzarotti, Christopher Kruegel,
Mihai Christodorescu, and Engin Kirda. AccessMiner:
using system-centric models for malware protection. In
Proc. of ACM CCS’10, 2010.

[39] Felix Leder and Peter Martini. Ngbpa: Next generation
botnet protocol analysis. In SEC, pages 307–317, 2009.

[40] Andrea De Lucia. Program slicing: Methods and

applications. In 1st IEEE International Workshop on
Source Code Analysis and Manipulation, 2001.

[41] Reiter M. and Yen T. Traﬃc aggregation for malware

detection. In Proc. of DIMVA’08, 2008.

[42] Andreas Moser, Christopher Kruegel, and Engin Kirda.

Exploring Multiple Execution Paths for Malware Analysis.
In IEEE Symposium on Security and Privacy, 2007.

[43] Shishir Nagaraja, Prateek Mittal, Chi-Yao Hong, Matthew
Caesar, and Nikita Borisov. Botgrep: ﬁnding p2p bots with
structured graph analysis. In Proc. of USENIX Security’10,
2010.

[44] P.M.Comparetti, G.Salvaneschi, E.Kirda, C. Kolbitsch,

C.Krugel, and S.Zanero. Identifying dormant functionality
in malware programs. In 31st IEEE Symposium on
Security and Privacy, May 2010.

[45] Phillip Porras, Hassen Saidi, and Vinod Yegneswaran. An

Analysis of Conﬁcker’s Logic and Rendezvous Points.
http://mtc.sri.com/Conficker/, 2009.

[46] Paul Royal, Mitch Halpin, David Dagon, Robert Edmonds,
and Wenke Lee. Polyunpack: Automating the hidden-code
extraction of unpack-executing malware. In Proc. of
ACSAC’06, 2006.

[47] Prateek Saxena, Pongsin Poosankam, Stephen McCamant,

and Dawn Song. Loop-extended symbolic execution on
binary programs. In Proc. of ISSTA’08, 2008.

[48] Joe Stewart. Inside the Storm.

http://www.blackhat.com/presentations/bh-usa-08/
Stewart/BH_US_08_Stewart_Protocols_of_the_Storm.pdf.

[49] Elizabeth Stinson and John C. Mitchell. Towards

systematic evaluation of the evadability of bot/botnet
detection methods. In WOOT’08, 2008.

[50] S. Stover, D. Dittrich, J. Hernandez, and S. Dietrich.

Analysis of the storm and nugache trojans: P2P is here. In
;login, 2007.

[51] Tielei Wang, Tao Wei, Guofei Gu, and Wei Zou.

Taintscope: A checksum-aware directed fuzzing tool for
automatic software vulnerability detection. In Proc. of
IEEE S&P’10, 2010.

[52] Xinran Wang, Yoon-Chan Jhi, Sencun Zhu, and Peng Liu.

Behavior based software theft detection. In Proc. ACM
CCS’09, 2009.

[53] Zhi Wang, Xuxian Jiang, Weidong Cui, Xinyuan Wang,

and Mike Grace. Reformat: Automatic reverse engineering
of encrypted messages. In Proc. of ESORICS’09, 2009.

[54] J. Wilhelm and Tcker Chiueh. A forced sampled execution

approach to kernel rootkit identiﬁcation. In Proc. of
RAID’07, 2007.

[55] Zhaoyan Xu, Lingfeng Chen, and Guofei Gu. PeerPress:

Fast and reliable detection of p2p malware (and beyond).
Technical report, Texas A&M University, 2012.

[56] H. Yin, D. Song, M. Egele, C. Kruegel, and E. Kirda.

Panorama: Capturing system-wide information ﬂow
formalware detection and analysis. In In ACM Conference
on Computer and Communication Security (CCS), 2007.

592