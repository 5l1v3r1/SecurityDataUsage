2012 IEEE Symposium on Security and Privacy

Smashing the Gadgets: Hindering Return-Oriented
Programming Using In-Place Code Randomization

Vasilis Pappas, Michalis Polychronakis, and Angelos D. Keromytis

Columbia University

{vpappas,mikepo,angelos}@cs.columbia.edu

Abstract—The wide adoption of non-executable page protec-
tions in recent versions of popular operating systems has given
rise to attacks that employ return-oriented programming (ROP)
to achieve arbitrary code execution without the injection of
any code. Existing defenses against ROP exploits either require
source code or symbolic debugging information, or impose a
signiﬁcant runtime overhead, which limits their applicability for
the protection of third-party applications.

In this paper we present

in-place code randomization, a
practical mitigation technique against ROP attacks that can
be applied directly on third-party software. Our method uses
various narrow-scope code transformations that can be applied
statically, without changing the location of basic blocks, allowing
the safe randomization of stripped binaries even with partial
disassembly coverage. These transformations effectively eliminate
about 10%, and probabilistically break about 80% of the useful
instruction sequences found in a large set of PE ﬁles. Since no
additional code is inserted, in-place code randomization does
not incur any measurable runtime overhead, enabling it to be
easily used in tandem with existing exploit mitigations such
as address space layout randomization. Our evaluation using
publicly available ROP exploits and two ROP code generation
toolkits demonstrates that our technique prevents the exploitation
of the tested vulnerable Windows 7 applications, including Adobe
Reader, as well as the automated construction of alternative ROP
payloads that aim to circumvent in-place code randomization
using solely any remaining unaffected instruction sequences.

I. INTRODUCTION

Attack prevention technologies based on the No eXecute
(NX) memory page protection bit, which prevent the execution
of malicious code that has been injected into a process, are now
supported by most recent CPUs and operating systems [1].
The wide adoption of these protection mechanisms has given
rise to a new exploitation technique, widely known as return-
oriented programming (ROP) [2], which allows an attacker to
circumvent non-executable page protections without injecting
any code. Using return-oriented programming, the attacker
can link together small fragments of code, known as gadgets,
that already exist
in the process image of the vulnerable
application. Each gadget ends with an indirect control transfer
instruction, which transfers control to the next gadget ac-
cording to a sequence of gadget addresses injected on the
stack or some other memory area. In essence,
instead of
injecting binary code, the attacker injects just data, which
include the addresses of the gadgets to be executed, along
with any required data arguments.

Several research works have demonstrated the great poten-
tial of this technique for bypassing defenses such as read-

© 2012, Vasilis Pappas. Under license to IEEE.
DOI 10.1109/SP.2012.41

601

only memory [3], kernel code integrity protections [4], and
non-executable memory implementations in mobile devices [5]
and operating systems [6]–[9]. Consequently, it was only a
matter of time for ROP to be employed in real-world attacks.
Recent exploits against popular applications use ROP code
to bypass exploit mitigations even in the latest OS versions,
including Windows 7 SP1. ROP exploits are included in the
most common exploit packs [10], [11], and are actively used
in the wild for mounting drive-by download attacks.

Attackers are able to a priori pick the right code pieces
because parts of the code image of the vulnerable application
remain static across different
installations. Address space
layout randomization (ASLR) [1] is meant to prevent this kind
of code reuse by randomizing the locations of the executable
segments of a running process. However, in both Linux and
Windows, parts of the address space do not change due to
executables with ﬁxed load addresses [12], or shared libraries
incompatible with ASLR [6]. Furthermore, in some exploits,
the base address of a DLL can be either calculated dynamically
through a leaked pointer [9], [13], or brute-forced [14].

Other defenses against code-reuse attacks complementary to
ASLR include compiler extensions [15], [16], code randomiza-
tion [17]–[19], control-ﬂow integrity [20], and runtime solu-
tions [21]–[23]. In practice, though, most of these approaches
are almost never applied for the protection of the COTS
software currently targeted by ROP attacks, either due to the
lack of source code or debugging information, or due to their
increased overhead. In particular, from the above techniques,
those that operate directly on compiled binaries, e.g., by
permuting the order of functions [18], [19] or through binary
instrumentation [20], require precise and complete extraction
of all code and data in the executable sections of the binary.
This is possible only if the corresponding symbolic debugging
information is available, which however is typically stripped
from production binaries. On the other hand, techniques that
do work on stripped binary executables using dynamic binary
instrumentation [21]–[23], incur a signiﬁcant runtime overhead
that limits their adoption. At the same time, instruction set
randomization (ISR) [24], [25] cannot prevent code-reuse
attacks, and current implementations also rely on heavyweight
runtime instrumentation or code emulation frameworks.

Starting with the goal of a practical mitigation against
the recent spate of ROP attacks, in this paper we present
a novel code randomization method that can harden third-
party applications against return-oriented programming. Our

approach is based on narrow-scope modiﬁcations in the code
segments of executables using an array of code transformation
techniques, to which we collectively refer as in-place code
randomization. These transformations are applied statically, in
a conservative manner, and modify only the code that can be
safely extracted from compiled binaries, without relying on
symbolic debugging information. By preserving the length of
instructions and basic blocks, these modiﬁcations do not break
the semantics of the code, and enable the randomization of
stripped binaries even without complete disassembly coverage.
The goal of this randomization process is to eliminate or
probabilistically modify as many of the gadgets that are
available in the address space of a vulnerable process as
possible. Since ROP code relies on the correct execution of all
chained gadgets, altering the outcome of even a few of them
will likely render the ROP code ineffective.

Our evaluation using real-world ROP exploits against
widely used applications, such as Adobe Reader, shows the
effectiveness and practicality of our approach, as in all cases
the randomized versions of the applications rendered the ex-
ploits non-functional. When aiming to circumvent the applied
code randomization, Q [26] and Mona [27], two automated
ROP payload construction tools, were unable to generate
functional exploit code by relying solely on any remaining
non-randomized gadgets.

Although quite effective as a standalone mitigation, in-place
code randomization is not meant to be a complete prevention
solution, as it offers probabilistic protection and thus cannot
deliver any protection guarantees. However, it can be applied
in tandem with existing randomization techniques to increase
process diversiﬁcation. This is facilitated by the practically
zero overhead of the applied transformations, and the ease with
which they can be applied on existing third-party executables.

Our work makes the following main contributions:
• We present in-place code randomization, a novel and
practical approach for hardening third-party software
against ROP attacks. We describe in detail various
narrow-scope code transformations that do not change
the semantics of existing code, and which can be safely
applied on compiled binaries without symbolic debugging
information.

• We have implemented in-place code randomization for
x86 PE executables, and have experimentally veriﬁed the
safety of the applied code transformations with extensive
runtime code coverage tests using third-party executables.
• We provide a detailed analysis of how in-place code
randomization affects available gadgets using a large set
of 5,235 PE ﬁles. On average, the applied transformations
effectively eliminate about 10%, and probabilistically
break about 80% of the gadgets in the tested ﬁles.

• We evaluate our approach using publicly available ROP
exploits and generic ROP payloads, as well as two ROP
payload construction toolkits. In all cases, the randomized
versions of the executables break the malicious ROP
code, and prevent the automated construction of alter-
native payloads using the remaining unaffected gadgets.

II. BACKGROUND

The introduction of non-executable memory page protec-
tions led to the development of the return-to-libc exploitation
technique [28]. Using this method, a memory corruption
vulnerability can be exploited by transferring control to code
that already exists in the address space of the vulnerable
process. By jumping to the beginning of a library function
such as system(), the attacker can for example spawn a
shell without the need to inject any code. Frequently though,
especially for remote exploitation, calling a single function is
not enough. In these cases, multiple return-to-libc calls can
be “chained” together by ﬁrst returning to a short instruction
sequence such as pop reg; pop reg; ret; [29], [30].
When arguments need to be passed through registers, a few
short instruction sequences ending with a ret instruction can
be chained directly to set the proper registers with the desired
arguments, before calling the library function [31].

In the above code-reuse techniques,

the executed code
consists of one or a few short instruction sequences followed
by a large block of code belonging to a library function. Hovav
Shacham demonstrated that using only a carefully selected set
of short instruction sequences ending with a ret instruction,
known as gadgets, it is possible to achieve arbitrary computa-
tion, obviating the need for calling library functions [2]. This
powerful technique, dubbed return-oriented programming, in
essence gives the attacker the same level of ﬂexibility offered
by arbitrary code injection without injecting any code at all—
the injected payload comprises just a sequence of gadget
addresses intermixed with any necessary data arguments.

In a typical ROP exploit, the attacker needs to control
both the program counter and the stack pointer: the former
for executing the ﬁrst gadget, and the latter for allowing
its ret instruction to transfer control to subsequent gadgets.
Depending on the vulnerability, if the ROP payload is injected
in a memory area other than the stack, then the stack pointer
must ﬁrst be adjusted to the beginning of the payload through
a stack pivot [6], [32]. In a follow up work [33], Checkoway et
al. demonstrated that the gadgets used in a ROP exploit need
not necessarily end with a ret instruction, but with any other
indirect control transfer instruction.

The ROP code used in recent exploits against Windows
applications is mostly based on gadgets ending with ret
instructions, which conveniently manipulate both the program
counter and the stack pointer, although a couple of gadgets
ending with call or jmp are also used for calling library
functions. In all publicly available Windows exploits so far,
attackers do not have to rely on a fully ROP-based implemen-
tation for the whole malicious code that needs to be executed.
Instead, ROP code is used only as a ﬁrst stage for bypassing
DEP [1]. Typically, once control ﬂow has been hijacked, the
ROP code allocates a memory area with write and execute
permissions by calling a library function like VirtualAlloc,
copies into it some plain shellcode included in the attack
vector, and ﬁnally jumps to the copied shellcode which now
has execute permission [32].

602

III. APPROACH

Our approach is based on the randomization of the code
sections of binary executable ﬁles that are part of third-party
applications, using an array of binary code transformation
techniques. The objective of this randomization process is to
break the code semantics of the gadgets that are present in the
executable memory segments of a running process, without
affecting the semantics of the actual program code.

The execution of a gadget has a certain set of consequences
to the CPU and memory state of the exploited process. The at-
tacker chooses how to link the different gadgets together based
on which registers, ﬂags, or memory locations each gadget
modiﬁes, and in what way. Consequently, the execution of a
subsequent gadget depends on the outcome of all previously
executed gadgets. Even if the execution of a single gadget has
a different outcome than the one anticipated by the attacker,
then this will affect the execution of all subsequent gadgets,
and it is likely that the logic of the malicious return-oriented
code will be severely impacted.

A. Why In-Place?

The concept of software diversiﬁcation [34] is the basis
for a wide range of protections against the exploitation of
memory corruption vulnerabilities. Besides address space lay-
out randomization [1], many techniques focus on the internal
randomization of the code segments of executable, and can
be combined with ASLR to increase process diversity [17].
Metamorphic transformations [35] can shift gadgets from their
original offsets and alter many of their instructions, rendering
them unusable. Another simpler and probably more effective
approach is to rearrange existing blocks of code either at the
function level [18], [19], [36], [37], or with ﬁner granularity,
at the basic block level [38], [39]. If all blocks of code are
reordered so that no one resides at its original location, then
all the offsets of the gadgets that the attacker would assume
to be present in the code sections of the process will now
correspond to completely different code.

These transformations require a precise view of all the code
and data objects contained in the executable sections of a PE
ﬁle, including their cross-references, as existing code needs to
be shifted or moved. Due to computed jumps and intermixed
data [40], complete disassembly coverage is possible only
if the binary contains relocation and symbolic debugging
information (e.g., PDB ﬁles) [19], [41], [42]. Unfortunately,
debugging information is typically stripped from release builds
for compactness and intellectual property protection.

For Windows software, in particular, PE ﬁles (both DLL
and EXE) usually do retain relocation information even if
no debugging information has been retained [43]. The loader
needs this information in case a DLL must be loaded at an
address other than its preferred base address, e.g., because
another library has already been mapped to that location.
or for ASLR. In contrast to Linux shared libraries and PIC
executables, which contain position-independent code, Win-
dows binaries contain absolute addresses, e.g., as immediate
instruction operands or initialized data pointers, that are valid

only if the executable has been loaded at its preferred base
address. The .reloc section of PE ﬁles contains a list of
offsets relatively to each PE section that correspond to all
absolute addresses at which a delta value needs to be added
in case the actual load address is different [44].

Relocation information alone, however, does not sufﬁce for
extracting a complete view of the code within the executable
sections of a PE ﬁle [38], [41]. Without the symbolic debug-
ging information contained in PDB ﬁles, although the location
of objects that are reached only via indirect jumps can be
extracted from relocation information, their actual type—code
or data—still remains unknown. In some cases, the actual
type of these objects could be inferred using heuristics based
on constant propagation, but such methods are usually prone
to misidentiﬁcations of data as code and vice versa. Even a
slight shift or size increase of a single object within a PE
section will incur cascading shifts to its following objects.
Typically, an unidentiﬁed object that actually contains code
will include PC-relative branches to other code objects. In the
absence of the debugging information contained in PDB ﬁles,
moving such an unidentiﬁed code block (or any of its relatively
referenced objects) without ﬁxing the displacements of all its
relative branch instructions that reference other objects, will
result to incorrect code.

Given the above constraints, we choose to use only binary
code transformations that do not alter the size and location
of code and data objects within the executable, allowing
the randomization of third-party PE ﬁles without symbolic
debugging information. Although this restriction does not
allow us to apply extensive code transformations like basic
block reordering or metamorphism, we can still achieve partial
code randomization using narrow-scope modiﬁcations that
can be safely applied even without complete disassembly
coverage. This can be achieved through slight, in-place code
modiﬁcations to the correctly identiﬁed parts of the code, that
do not change the overall structure of basic blocks or functions,
but which are enough to alter the outcome of short instruction
sequences that can be used as gadgets.

B. Code Extraction and Modiﬁcation

Although completely accurate disassembly of stripped x86
binaries is not possible, state-of-the-art disassemblers achieve
decent coverage for code generated by the most commonly
used compilers, using a combination of different disassem-
bly algorithms [40], the identiﬁcation of speciﬁc code con-
structs [45], and simple data ﬂow analysis [46]. For our
prototype implementation, we use IDA Pro [47] to extract the
code and identify the functions of PE executables. IDA Pro is
effective in the identiﬁcation of function boundaries, even for
functions with non-contiguous code and extensive use of basic
block sharing [48], and also takes advantage of the relocation
information present in Windows DLLs.

Typically, however, without the symbolic information of
PDB ﬁles, a fraction of the functions in a PE executable
are not identiﬁed, and parts of code remain undiscovered.
Our code transformations are applied conservatively, only

603

on parts of the code for which we can be conﬁdent that
have been accurately disassembled. For instance, IDA Pro
speculatively disassembles code blocks that are reached only
through computed jumps, taking advantage of the relocation
information contained in PE ﬁles. However, we do not enable
such heuristic code extraction methods in order to avoid
any disastrous modiﬁcations due to potentially misidentiﬁed
code. In practice, for the code generated by most compilers,
relocation information also ensures that the correctly identiﬁed
basic blocks have no entry point other than their ﬁrst instruc-
tion. Similarly, some transformations that rely on the proper
identiﬁcation of functions are applied only on the code of
correctly recognized functions. Our implementation is separate
from the actual code extraction framework used, which means
that IDA Pro can be replaced or assisted by alternative
code extraction approaches [41], [49], [50], providing better
disassembly coverage.

After code extraction, disassembled instructions are ﬁrst
converted to our own internal representation, which holds ad-
ditional information such as any implicitly used registers, and
the registers and ﬂags read or written by the instruction. For
correctness, we also track the use of general purpose registers
even in ﬂoating point, MMX, and SSE instructions. Although
these type of instructions have their own set of registers, they
do use general purpose registers for memory references (e.g.,
as the fmul instruction in Fig. 1). We then proceed and apply
the in-place code transformations discussed in the following
section. These are applied only on the parts of the executable
segments that contain (intended or unintended [2]) instruction
sequences that can be used as gadgets. As a result of some
of the transformations, instructions may be moved from their
original locations within the same basic block. In these cases,
for instructions that contain an absolute address in some
of their operands, the corresponding entries in the .reloc
sections of the randomized PE ﬁle are updated with the new
offsets where these absolute addresses are now located.

Our prototype implementation processes each PE ﬁle indi-
vidually, and generates multiple randomized copies that can
then replace the original. Given the complexity of the analysis
required for generating a set of randomized instances of an
input ﬁle (in the order of a few minutes on average for the
PEs used in our tests), this allows the off-line generation of a
pool of randomized PE ﬁles for a given application. Note that
for most of the tested Windows applications, only some of the
DLLs need to be randomized, as the rest are usually ASLR-
enabled (although they can also be randomized for increased
protection). In a production deployment, a system service or a
modiﬁed loader can then pick a different randomized version
of the required PEs each time the application is launched,
following the same way of operation as tools like EMET [51].

IV. IN-PLACE CODE TRANSFORMATIONS

register reassignment are also used by compilers and poly-
morphic code engines for code optimization [52] and obfus-
cation [35], applying them at the binary level—without having
access to the higher-level structural and semantic information
available in these settings—poses signiﬁcant challenges.

A. Atomic Instruction Substitution

One of the basic concepts of code obfuscation and metamor-
phism [35] is that the exact same computation can be achieved
using a countless number of different instruction combina-
tions. When applied for code randomization, substituting the
instructions of a gadget with a functionally-equivalent—but
different—sequence of instructions would not affect any ROP
code that uses that gadget, since its outcome would be the
same. However, by modifying the instructions of the original
program code, this transformation in essence modiﬁes certain
bytes in the code image of the program, and consequently,
can drastically alter the structure of non-intended instruction
sequences that overlap with the substituted instructions.

Many of the gadgets used in ROP code consist of unaligned
instructions that have not been emitted by the compiler, but
which happen to be present in the code image of the process
due to the density and variable-length nature of the x86
instruction set. In the example of Fig. 1(a), the actual code
generated by the compiler consists of the instructions mov;
cmp; lea; starting at byte B0.1 However, when disassem-
bling from the next byte, a useful non-intended gadget ending
with ret is found.

Compiled code is highly optimized, and thus the replace-
ment of even a single instruction in the original program code
usually requires either a longer instruction, or a combination
of more than one instruction, for achieving the same purpose.
Given that our aim is to randomize the code of stripped
binaries, even a slight increase in the size of a basic block is
not possible, which makes the most commonly used instruction
substitution techniques unsuitable for our purpose.

In certain cases though, it is possible to replace an instruc-
tion with a single, functionally-equivalent instruction of the
same length, thanks to the ﬂexibility offered by the extensive
x86 instruction set. Besides obvious candidates based on
replacing addition with negative subtraction and inversely,
there are also some instructions that come in different forms,
with different opcodes, depending on the supported operand
types. For example, add r/m32,r32 stores the result of the
addition in a register or memory operand (r/m32), while add
r32,r/m32 stores the result in a register (r32). Although these
two forms have different opcodes, the two instructions are
equivalent when both operands happen to be registers. Many
arithmetic and logical instructions have such dual equivalent
forms, while in some cases there can be up to ﬁve equivalent
instructions (e.g., test r/m8,r8, or r/m8,r8, or r8,
r/m8, and r/m8,r8, and r8,r/m8, affect the ﬂags of the
EFLAGS register in the same way when both operands are

In this section we present in detail the different code trans-
formations used for in-place code randomization. Although
some of the transformations such as instruction reordering and

1The code of all examples throughout the paper comes from icucnv36.dll,
included in Adobe Reader v9.3.4. This DLL was used for the ROP code of
a DEP-bypass exploit for CVE-2010-2883 [53] (see Table II).

604

Figure 1. Example of atomic instruction substitution. The equivalent, but different form of the cmp instruction does not change the original program code
(a), but renders the non-intended gadget unusable (b).

the same register). In our prototype implementation we use
the sets of equivalent instructions used in Hydan [54], a tool
for hiding information in x86 executables, with the addition
of one more set that includes the equivalent versions of the
xchg instruction.

As shown in Fig. 1(b), both operands of the cmp instruction
are registers, and thus it can be replaced by its equivalent
form, which has different opcode and ModR/M bytes [55].
Although the actual program code does not change, the ret
instruction that was “included” in the original cmp instruction
has now disappeared, rendering the gadget unusable. In this
case, the transformation completely eliminates the gadget, and
thus will be applied in all instances of the randomized binary.
In contrast, when a substitution does not affect the gadget’s
ﬁnal indirect jump, then it is applied probabilistically.

B. Instruction Reordering

In certain cases, it is possible to reorder the instructions
of small self-contained code fragments without affecting the
correct operation of the program. This transformation can
signiﬁcantly impact the structure of non-intended gadgets, but
can also break the attacker’s assumptions about gadgets that
are part of the actual machine code.

1) Intra Basic Block Reordering: The actual instruction
scheduling chosen during the code generation phase of a
compiler depends on many factors,
including the cost of
instructions in cycles, and the applied code optimization
techniques [52]. Consequently, the code of a basic block is
often just one among several possible instruction orderings
that are all equivalent in terms of correctness. Based on this
observation, we can partially modify the code within a basic
block by reordering some of its instructions according to an
alternative instruction scheduling.

The basis for deriving an alternative instruction schedul-
ing is to determine the ordering relationships among the
instructions, which must always be satisﬁed to maintain code
correctness. The dependence graph of a basic block represents
the instruction interdependencies that constrain the possible in-
struction schedules [56]. Since a basic block contains straight-
line code, its dependence graph is a directed acyclic graph with
machine instructions as vertices, and dependencies between
instructions as edges. We apply dependence analysis on the
code of disassembled basic blocks to build their dependence
graph using an adaptation of a standard dependence DAG con-

struction algorithm [56, Fig. 9.6] for machine code. Applying
dependence analysis directly on machine code requires a care-
ful treatment of the dependencies between x86 instructions.
Compared to the analysis of code expressed in an intermediate
representation form, this includes the identiﬁcation of data
dependencies not only between register and memory operands,
but also between CPU ﬂags and implicitly used registers and
memory locations.

For each instruction i, we derive the sets use[i] and def [i]
with the registers used and deﬁned by the instruction. Besides
register operands and registers used as part of effective address
computations, this includes any implicitly used registers. For
example, the use and def sets for pop eax are {esp} and
{eax, esp}, while for rep stosb2 are {ecx, eax, edi} and
{ecx, edi}, respectively. We initially assume that all instruc-
tions in the basic block depend on each other, and then check
each pair for read-after-write (RAW), write-after-read (WAR),
and write-after-write (WAW) dependencies. For example, i1
and i2 have a RAW dependency if any of the following
conditions is true: i) def [i1] ∩ use[i2] (cid:3)= ∅, ii) the destination
operand of i1 and the source operand of i2 are both a memory
location, iii) i1 writes at least one ﬂag read by i2.

Note that condition ii) is quite conservative, given that i2
will actually depend on i1 only if i2 reads the same memory
location written by i1. However, unless both memory operands
use absolute addresses, it is hard to determine statically if the
two effective addresses point to the same memory location. In
our future work, we plan to use simple data ﬂow analysis
to relax this condition. Besides instructions with memory
operands, this condition should also be checked for instruc-
tions with implicitly accessed memory locations, e.g., push
and pop. The conditions for WAR and WAW dependencies are
analogous. If no conﬂict is found between two instructions,
then there is no constraint in their execution order.

Figure 2(a) shows the code of a basic block that contains
a non-intended gadget, and Fig. 3 its corresponding depen-
dence DAG. Instructions not connected via a direct edge are
independent, and have no constraint in their relative execution
order. Given the dependence DAG of a basic block, the pos-
sible orderings of its instructions correspond to the different

2stosb (Store Byte to String) copies the least signiﬁcant byte from
the eax register to the memory location pointed by the edi register and
increments edi’s value by one. The rep preﬁx repeats this instruction until
ecx’s value reaches zero, while decreasing it after each repetition.

605

Figure 2. Example of how intra basic block instruction reordering can affect a non-intended gadget.

Figure 3. Dependence graph for the code of Fig. 2.

Figure 4. Example of register preservation code reordering.

topological sorting arrangements of the graph [57]. Fig. 2(b)
shows one of the possible alternative orderings of the original
code. The locations of all but one of the instructions and the
values of all but one of the bytes have changed, eliminating the
non-intended gadget contained in the original code. Although
a new gadget has appeared a few bytes further into the block,
(ending again with a ret instruction at byte C3), an attacker
cannot depend on it since alternative orderings will shift it
to other locations, and some of its internal instructions will
always change (e.g., in this example, the useful pop ecx is
gone). In fact, the ret instruction can be eliminated altogether
using atomic instruction substitution.

An underlying assumption we make here is that basic
block boundaries will not change at runtime. If a computed
control transfer instruction targets a basic block instruction
other than its ﬁrst, then reordering may break the semantics
of the code. Although this may seem restrictive, we note that
throughout our evaluation we did not encounter any such case.
For compiler-generated code, IDA Pro is able to compute
all jump targets even for computed jumps based on the PE
relocation information. In the most conservative case, users
may choose to disable instruction reordering and still beneﬁt
from the randomization of the other techniques—Section V
includes results for each technique individually.

2) Reordering of Register Preservation Code: The calling
convention followed by the majority of compilers for Windows
on x86 architectures, similarly to Linux, speciﬁes that the ebx,
esi, edi, and ebp registers are callee-saved [58]. The remain-
ing general purpose registers, known as scratch or volatile
registers, are free for use by the callee without restrictions.
Typically, a function that needs to use more than the available
scratch registers, preserves any non-volatile registers before

modifying them by storing their values on the stack. This is
usually done at the function prologue through a series of push
instructions, as in the example of Fig. 4(a), which shows the
very ﬁrst and last instructions of a function. At the function
epilogue, a corresponding series of pop instructions restores
the saved values from the stack, right before returning to the
caller. Sequences that contain pop instructions followed by
ret are among the most widely used gadgets found in ROP
exploits, since they allow the attacker to load registers with
values that are supplied as part of the injected payload [59].
The order of the pop instructions is crucial for initializing
each register with the appropriate value.

As seen in the function prologue, the compiler stores the
values of the callee-saved registers in arbitrary order, and
sometimes the relevant push instructions are interleaved with
instructions that use previously-preserved registers. At
the
function epilogue, the saved values are pop’ed from the stack
in reverse order, so that they end up to the proper register.
Consequently, as long as the saved values are restored in
the right order, their actual order on the stack is irrelevant.
Based on this observation, we can randomize the order of the
push and pop instructions of register preservation code by
maintaining the ﬁrst-in-last-out order of the stored values, as
shown in Fig. 4(b). In this example, there are six possible
orderings of the three pop instructions, which means that
any assumption that
the attacker may make about which
registers will hold the two supplied values, will be correct
with a probability of one in six (or one in three, if only one
register needs to be initialized). In case only two registers
are preserved, there are two possible orderings, allowing the
gadget to operate correctly half of the time.

This transformation is applied conservatively, only to func-

606

tions with accurately disassembled prologue and epilogue
code. To make sure that we properly match the push and
pop instructions that preserve a given register, we monitor the
stack pointer delta throughout the whole function, as shown in
the second column of Fig. 4(a). If the deltas at the prologue
and epilogue do not match, e.g., due to call sites with unknown
calling conventions throughout the function, or indirect manip-
ulation of the stack pointer, then no randomization is applied.
As shown in Fig. 4(b), any non-preservation instructions in the
function prologue are reordered along with the push instruc-
tions by maintaining any interdependencies, as discussed in the
previous section. For functions with multiple exit points, the
preservation code at all epilogues should match the function’s
prologue. Note that there can be multiple push and pop pairs
for the same register, in case the register is preserved only
throughout some of the execution paths of a function.

C. Register Reassignment

Although the program points at which a certain variable
should be stored in a register or spilled into memory are chosen
by the compiler using sophisticated allocation algorithms, the
actual name of the general purpose register that will hold a
particular variable is mostly an arbitrary choice. Based on
this observation, we can reassign the names of the register
operands in the existing code according to a different—but
equivalent—register assignment, without affecting the seman-
tics of the original code. When considering each gadget as
an autonomous code sequence, this transformation can alter
the outcome of many gadgets, which will now read or modify
different registers than those assumed by the attacker.

Due to the much higher cost of memory accesses compared
to register accesses, compilers strive to map as many variables
as possible to the available registers. Consequently, at any
point in a large program, multiple registers are usually in use,
or live at the same time. Given the control ﬂow graph (CFG)
of a compiled program, a register r is live at a program point p
iff there is a path from p to a use of r that does not go through
a deﬁnition of r. The live range of r is deﬁned as the set of
program points where r is live, and can be represented as a
subgraph of the CFG [60]. Since the same register can hold
different variables at different points in the program, a register
can have multiple disjoint live regions in the same CFG.

For each correctly identiﬁed function, we compute the live
ranges of all registers used in its body by performing liveness
analysis [52] directly on the machine code. Given the CFG of
the function and the sets use[i] and def [i] for each instruction
i, we derive the sets in[i] and out[i] with the registers that
are live-in and live-out at each instruction. For this purpose,
we use a modiﬁed version of a standard live-variable analysis
algorithm [52, Fig. 9.16] that computes the in and out sets
at the instruction level, instead of the basic block level. The
algorithm computes the two sets by iteratively reaching a ﬁxed
point for the following data-ﬂow equations: in[i] = use[i] ∪
(out[i]−def [i]) and out[i] =
{in[s] : s ∈ succ[i]}, were succ[i]
is the set of all possible successors of instruction i.

(cid:2)

Figure 5. The live ranges of eax and edi in part of a function. The two
registers can be swapped in all instructions throughout their parallel, self-
contained regions a0 and d1 (lines 3–12).

Figure 5 shows part of the CFG of a function and the
corresponding live ranges for eax and edi. Initially, we
assume that all registers are live, since some of them may hold
values that have been set by the caller. In this example, edi
is live when entering the function, and the push instruction at
line 2 stores (uses) its current value on the stack. The following
mov instruction initializes (deﬁnes) edi, ending its previous
live range (d0). Note that although a live range is a sub-graph
of the CFG, we illustrate and refer to the different live ranges
as linear regions for the sake of convenience.

The next deﬁnition of edi is at line 15, which means that
the last use of its previous value at line 11 also ends its
previous live region d1. Region d1 is a self-contained region,
within which we can be conﬁdent that edi holds the same
variable. The eax register also has a self-contained live region
(a0) that runs in parallel with d1. Conceptually,
the two
live ranges can be extended to share the same boundaries.
Therefore, the two registers can be swapped across all the
instructions located within the boundaries of the two regions,
without altering the semantics of the code.

The call eax instruction at line 12 can be conveniently
used by an attacker for calling a library function or another
gadget. By reassigning eax and edi across their parallel
live regions, any ROP code that would depend on eax for
transferring control to the next piece of code, will now jump
to an incorrect memory location, and probably crash. For code
fragments with just two parallel live regions, an attacker can
guess the right register half of the times. In many cases though,
there are three or more general purpose registers with parallel
live regions, or other available registers that are live before
or after another register’s live region, allowing for a higher
number of possible register assignments.

607

The registers used in the original code can be reassigned
by modifying the ModR/M and sometimes the SIB byte of
the relevant instructions. As in previous code transforma-
tions, besides altering the operands of instructions in the
existing code, these modiﬁcations can also affect overlapping
instructions that may be part of non-intended gadgets. Note
that implicitly used registers in certain instructions cannot be
replaced. For example, the one-byte “move data from string
to string” instruction (movs) always uses esi and edi as its
source and destination operands, and there is no other one-byte
instruction for achieving the same operation using a different
set of registers [55]. Consequently, if such an instruction is
part of the live region of one of its implicitly used registers,
then this register cannot be reassigned throughout that region.
For the same reason, we exclude esp from liveness analysis.
Finally, although calling conventions are followed for most
of the functions, this is not always the case, as compilers
are free to use any custom calling convention for private or
static functions. Most of these cases are conservatively cov-
ered through a bottom-up call analysis that discovers custom
register arguments and return value registers.

First, all the external function deﬁnitions found in the import
table of the DLL are marked as level-0 functions. IDA Pro can
effectively distinguish between different calling conventions
that these external functions may follow, and reports their
declaration in the C language. Thus, in most cases, the register
arguments and the return value register (if any) for each of
the level-0 functions are known. For any call instruction to
a level-0 function, its register arguments are added to call’s
set of implicitly read registers, and its return value registers
are added to call’s set of implicitly written registers.

In the next phase, level-1 functions are identiﬁed as the
set of functions that call only level-0 functions or no other
function. Any registers read by a level-1 function, without
prior writing them, are marked as its register arguments.
Similarly, any registers written and not read before a return
instruction are marked as return value registers. Again, the
sets of implicitly read and written register of all the call
instructions to level-1 functions are updated accordingly. Sim-
ilarly, level-2 functions are the ones that call level-1 or level-0
functions, or no other function, and so on. The same process is
repeated until no more function levels can be computed. The
intuition behind this approach is that private functions, which
may use non-standard calling conventions, are called by other
functions in the same DLL and, in most cases, not through
computed call instructions.

V. EXPERIMENTAL EVALUATION

A. Randomization Analysis

1) Coverage: A crucial aspect for the effectiveness of in-
place code randomization is the randomization coverage in
terms of what percentage of the gadgets found in an executable
can be safely randomized. A gadget may remain intact for
one of the following reasons: i) it is part of data embedded
is part of code that could not
in a code segment,
ii) it
be disassembled, or iii) it
is not affected by any of our

s
e

l
i
f
 

E
P

 
f
o
 
n
o
i
t
c
a
r
f
 
e
v
i
t
a
u
m
u
C

l

Out of all gadgets
Out of the gadgets found only
 in the extracted code

1

0.8

0.6

0.4

0.2

0

0

10

20

40

30
70
Modifiable gadgets (%)

50

60

80

90

100

Figure 6.
Percentage of modiﬁable gadgets for a set of 5,235 PE ﬁles.
Indicatively, for the upper 85% of the ﬁles, more than 70% of all gadgets in
the executable segments of each PE ﬁle can be modiﬁed (shaded area).

Out of all gadgets
Out of the gadgets found only
 in the extracted code

Instruction
Substitution
Intra Basic Block
Reordering
Reg. Preservation
Code Reordering
Register
Reassignment
All
Transformations

0

20

40

60

80

100

Modifiable gadgets (%)

Figure 7. Percentage of modiﬁable gadgets according to the different code
transformations.

transformations. In this section, we explore the randomization
coverage of our prototype implementation using a large data
set of 5,235 PE ﬁles (both DLL and EXE), detailed in Table I.
We consider as a gadget [2] any intended or unintended
instruction sequence that ends with an indirect control trans-
fer instruction, and which does not contain i) a privileged
or invalid instruction (can occur in non-intended instruction
sequences), and ii) a control transfer instruction other than its
ﬁnal one, with the exception of indirect call (can be used
in the middle of a gadget for calling a library function). We
assume a maximum gadget length of ﬁve instructions, which
is typical for existing ROP code implementations [2], [33].
For larger gadgets, it is possible that the modiﬁed part of the
gadget may be irrelevant for the purpose of the attacker. For
example, if only the ﬁrst instruction of the gadget inc eax;
pop ebx; ret; is randomized, this will not affect any ROP
code that either does not rely on the value of eax at that
point, or uses the shorter gadget pop ebx; ret; directly.
For this reason, we consider all different subsequences with
length between two to ﬁve instructions as separate gadgets.

Figure 6 shows the percentage of modiﬁable gadgets out
of all gadgets found in the executable sections of each PE
ﬁle (solid line), as a cumulative fraction of all PE ﬁles in the
data set. In about 85% of the PE ﬁles, more that 70% of the
gadgets can be randomized by our code transformations. Many

608

MODIFIABLE (ELIMINATED VS. BROKEN) GADGETS FOR A COLLECTION OF VARIOUS PE FILES.

Table I

Software

PE Files

Code (MB)

Total

Modifiable (%)

Eliminated (%)

Broken (%)

Adobe Reader 9
Firefox 4
iTunes 10
Windows XP SP3
Windows 7 SP1

Total

43
28
75
1,698
3,391

5,235

6.7
3.5
3.7
134.4
324.8

1,250,959
458,760
396,478
8,305,177
16,951,300

943,506 (75.4)
381,011 (83.0)
293,392 (74.0)
6,452,895 (77.7)
12,970,844 (76.5)

108,614 ( 8.7)
56,800 (12.4)
31,779 ( 8.0)
770,589 ( 9.3)
1,637,082 ( 9.7)

834,892 (66.7)
324,211 (70.6)
261,613 (66.0)
5,682,306 (68.4)
11,333,762 (66.8)

473.1

27,362,674

21,041,648 (76.9)

2,604,864 ( 9.5)

18,436,784 (67.4)

t

h
g
n
e

l
 

n
e
v
g

i

 
f

o

 
s
t

 

e
g
d
a
g
n
e
k
o
r
b

 
l
l

a

 
f

 

o
%

100

80

60

40

20

0

(darkest color) leftmost instr.

(lightest color) rightmost instr.

5

   4

        3

   2

Gadget length (instructions)

Figure 8.
Impact of code randomization on the broken gadgets’ instructions
according to their location in the gadget. The order of the bars corresponds
to the order of the instructions in the gadget. Indicatively, the ﬁrst (leftmost)
instruction of two-instruction gadgets is altered in more than 80% of all broken
two-instruction gadgets.

of the unmodiﬁed gadgets are located in parts of code that have
not been extracted by IDA Pro, and which consequently will
never be affected by our transformations. When considering
only the gadgets that are contained within the disassembled
code regions on which code randomization can be applied,
the percentage of affected gadgets slightly increases (dashed
line). Given that we do not take into account code blocks that
have been identiﬁed by IDA Pro using speculative methods,
this shows that the use of a more sophisticated code extraction
mechanism will increase the number of gadgets that can be
modiﬁed. Figure 7 shows the total percentage of gadgets
modiﬁed by each code transformation technique for the same
data set. Note that a gadget can be modiﬁed by more than one
technique. Overall, the total percentage of modiﬁable gadgets
across all PE ﬁles is about 76.9%, as shown in Table I.

2) Impact: We identify two qualitatively different ways in
which a code transformation can impact a gadget. As discussed
in Sec. IV-A, a gadget can be eliminated, if any of the applied
transformations removes completely its ﬁnal control transfer
instruction. If the ﬁnal control transfer instruction remains
intact, a gadget can then be broken, if at least one of its internal
instructions is altered, and the CPU and memory state after
its execution is different than the original, i.e., the outcome
of its computation is not the same. As shown in Table I, in
the average case, about 9.5% of all gadgets contained in a PE
ﬁle can be rendered completely unusable. For a vulnerable
application, this already removes about one in ten of the
available gadgets for the construction of ROP code. Although
the rest of the modiﬁable gadgets (67.4%) is not eliminated,

609

they can be “broken” by probabilistically modifying one or
more of their instructions.

In case some of the instructions in a broken gadget can
never be altered, it is quite possible that part of its functionality
will remain unaffected, and thus an attacker could still use it
by relying only on its unmodiﬁable instructions. Especially
for larger gadget sizes,
if the possible modiﬁcations are
clustered only around a certain part of the gadget, e.g., its
ﬁrst instructions, then an attacker could predictably rely on
the rest of the gadget. We explore this issue by measuring the
number of broken gadgets in which an instruction at a given
position can be altered.

Figure 8 shows the impact of code randomization on a
broken gadget’s instructions, according to their location within
the gadget. Each group of bars corresponds to a different
gadget length, and in each group, the leftmost bar corresponds
to the leftmost instruction of the gadget. For all sizes, the
probability that an instruction at a given position will be
affected is quite evenly distributed and remains beyond 60%,
with the exception of the ﬁnal (control transfer) instruction.
This is expected, since most of the transformations cannot
affect the ﬁnal instruction of intended gadgets (e.g., ret).
As we observe, the locations of the modiﬁed instructions in
broken gadgets are almost equally unpredictable.

3) Entropy: Some of the code transformations can perturb
a given instruction within a gadget only in a limited num-
ber of ways, while others can generate a larger number of
permutations. For example, for instructions with only two
equivalent forms, atomic instruction substitution can modify
a particular location in a gadget only in one way, allowing
for two possible states. On the other hand, intra basic block
instruction reordering usually results to a large number of
possible permutations, especially for larger basic blocks that
contain many instructions with no interdependencies.

Usually though, a broken gadget can be modiﬁed at multiple
locations, and the same location can be altered in multiple
ways by more than one code transformations. Consequently,
the number of possible randomized states in which a broken
gadget can exist, or its randomization entropy, corresponds
to the product of the number of permutations that each of
the different transformations can generate for that gadget. In
the worst case, a broken gadget can exist in two possible
states: its original form, or its alternative after modiﬁcation.
For example, there are only two possible orderings for the pop
instructions in an intended gadget of the form pop reg; pop
reg; ret; given that no other transformation can alter it.

s
t

e
g
d
a
g

 
f

o

 

n
o

i
t
c
a
r
f
 

e
v
i
t

l

a
u
m
u
C

1

0.8

0.6

0.4

0.2

0

0

1 2 3

10

   2
10  

   3
10  

   4
10  

   5
10  

Number of possible randomized versions

Figure 9. Randomization entropy for broken gadgets.

Figure 9 shows the number of possible randomized versions
of each gadget (including its original), as a cumulative fraction
of all broken gadgets. As seen in the lower left corner, a small
amount of about 12% of the gadgets can be modiﬁed only in
one way, and thus can exist in two possible states. However,
the randomization entropy increases exponentially, and the
upper 80% of the gadgets have four or more randomized states.
As more of the different transformations are applied on the
same gadget, the randomization entropy increases to thousands
of possible modiﬁed states.

Although for a small amount of gadgets an attacker can have
a 50% chance of guessing the actual behavior of a gadget, ROP
code relies on a chain of many different gadgets to achieve
its purpose (11–18 unique gadgets in the exploits we tested).
Even if one of the gadgets behaves in a non-expected way,
then the ROP code will fail. Given that code randomization
typically breaks (or even eliminates) several of the gadgets
used in a ROP exploit, the number of possible randomized
states that can prevent the correct execution of the ROP code
is usually very high, as demonstrated in Sec. V-C.

B. Correctness and Performance

One of the basic principles of our approach is that the
different in-place code randomization techniques should be
applied cautiously, without breaking the semantics of the
program. A straightforward way to verify the correctness of
our code transformations is to apply them on existing code and
compare the outcome before and after modiﬁcation. Simply
running a randomized version of a third-party application and
verifying that it behaves in the expected way can provide a
ﬁrst indication. However, using this approach, it is hard to
exercise a signiﬁcant part of the code, and potentially incorrect
modiﬁcations may go unnoticed.

For this purpose, we used the test suite of Wine [61], a
compatibility layer that allows Windows applications to run
on Unix-like operating systems. Wine provides alternative
implementations of the DLLs that comprise the Windows API,
and comes with an extensive test suite that covers the imple-
mentations of most functions exported by the core Windows
DLLs. Each function is executed multiple times using various
inputs that test different conditions, and the outcome of each

610

execution is compared against a known, expected result. We
ported the test code for about one third of the 109 DLLs
included in the test suite of Wine v1.2.2, and used it directly on
the actual DLLs from a Windows 7 installation. Using multiple
randomized versions of each tested DLL, we veriﬁed that in
all runs, all tests completed successfully.

We took advantage of the extensive and diverse code exe-
cution coverage of this experiment to also evaluate the impact
of in-place code randomization to the runtime performance of
the modiﬁed code. Among the different code transformations,
instruction reordering is the only one that could potentially
introduce some non-negligible overhead, given that sometimes
the chosen ordering may be sub-optimal. We measured the
overall CPU user time for the completion of all tests by
taking the average time across multiple runs, using both the
original and the randomized versions of the DLLs. In all cases,
there was no observable difference in the two times, within
measurement error.

C. Effectiveness

1) ROP Exploits: We evaluated the effectiveness of in-place
code randomization using publicly available ROP exploits
against vulnerable Windows applications [53], [62], [63], as
well as generic ROP payloads based on commonly used
DLLs [64], [65]. These seven different ROP code imple-
mentations,
listed in Table II, bypass Windows DEP and
execute a second-stage shellcode, as described in Sec. II, and
work even in the latest version of Windows, with DEP and
ASLR enabled. The ROP code used in the three exploits
is implemented with gadgets from one or a few DLLs that
do not support ASLR, as shown in the second column of
Table II. The number of unique gadgets used in each case
varies between 10–18, and typically a large part of the gadgets
is repeatedly executed at many points throughout the ROP
code. When replacing the original non-ASLR DLLs of each
application with randomized versions, in all cases the exploits
were rendered unsuccessful. Similarly, we used a custom
application to test the generic ROP payloads and veriﬁed that
the ROP code did not succeed when the corresponding DLL
was randomized.

The ROP code of the exploit against Acrobat Reader uses
just 11 unique gadgets, all coming from a single non-ASLR
DLL (icucnv36.dll). From these gadgets, in-place code ran-
domization can alter six of them: one gadget is completely
eliminated, while the other ﬁve broken gadgets have 2, 2, 3,
4, and 6 possible states, respectively, resulting to a total of
287 randomized states (in addition to the always eliminated
gadget, which also alone breaks the ROP code). Even if we
assume that no elimination were possible, the exploit would
still succeed only in one out of the 288 (0.35%) possible
instances (including the original) of the given gadget set.
Considering that this is a client-side exploit, in which the
attacker will probably have only one or a few opportunities for
tricking the user to open the malicious PDF ﬁle, the achieved
randomization entropy is quite high—always assuming that
none of the gadgets could have been eliminated. As shown

ROP EXPLOITS [53], [62], [63] AND GENERIC ROP PAYLOADS [64], [65] TESTED ON WINDOWS 7 SP1.

Table II

ROP exploit/payload

non-ASLR DLLs:
used for ROP

Gadgets in
non-ASLR DLLs

Modifiable (total %:
Broken % Eliminated %)

Unique Gadgets Used:
Modifiable (Br.,El.)

Combinations

Adobe Reader v9.3.4 [53]
Integard Pro v2.2.0 [62]
Mplayer Lite r33064 [63]
msvcr71.dll [64]
msvcr71.dll [65]
mscorie.dll [64]
mfc71u.dll [65]

3: 1
1: 1
5: 2
1: 1
1: 1
1: 1
1: 1

36,760
5,137
117,822
10,301
10,301
1,616
86,803

28,637 (77.9: 70.1
4,027 (78.4: 70.5

7.8)
7.9)
104,671 (88.8: 70.0 18.8)
9.6)
9.6)
7.1)
5.1)

7,129 (69.2: 59.6
7,129 (69.2: 59.6
1,304 (80.6: 73.5
64,053 (73.8: 68.7

11:
6 (5, 1)
16: 10 (9, 1)
7 (6, 1)
18:
9 (8, 1)
14:
8 (8, 0)
16:
4 (4, 0)
10:
11:
6 (6, 0)

287
322,559
1,128,959
3,317,760
1,728,000
25,200
170,496

in Table II, the number of possible randomized states in the
rest of the cases is several orders of magnitude higher. This
is mostly due to the larger number of broken gadgets, as well
as due to a few broken gadgets with tens of possible modiﬁed
states, which both increase the number of states exponentially.
Next, we explored whether the affected gadgets could be
directly replaced with unmodiﬁable gadgets in order to reliably
circumvent our technique. Out of the six affected gadgets in
the Adobe Reader exploit, only four can be directly replaced,
meaning that the exploit cannot be trivially modiﬁed to bypass
randomization. Furthermore, two of the gadgets have only
one replacement each, and both replacements are found in
code regions that are not discovered by IDA Pro—both could
be randomized using a more precise code extraction method.
For the rest of the ROP payloads, there are at least three
irreplaceable gadgets in each case.

We should note that the relatively small number of gadgets
used in most of these ROP payloads is a worst-case scenario
for our technique, which however not only is able to prevent
these exploits, but also does not allow the attacker to directly
replace all the affected gadgets. Indeed, besides the more
complex ROP payloads used in the Integard and Mplayer
exploits,
the rest of the payloads use API functions that
are already imported by a non-ASLR DLL, and simply call
them directly using hard-coded addresses. This type of API
invocation is much simpler and requires fewer gadgets [26]
compared to ROP code like the one used in the Integard and
Mplayer exploits (16 and 18 unique gadgets, respectively),
which ﬁrst dynamically locates a pointer to kernel32.dll (al-
ways ASLR-enabled in Windows 7) and then gets a handle to
VirtualProtect.

2) Automated ROP Payload Generation: The fact

that
some of the randomized gadgets are not directly replaceable
does not necessarily mean that the same outcome cannot be
achieved using solely unmodiﬁable gadgets. To assess whether
an attacker could construct a ROP payload resistant to in-
place code randomization based on gadgets that cannot be
randomized, we used Q [26] and Mona [27], two automated
ROP code construction tools.

Q is a general-purpose ROP compiler that uses semantic
program veriﬁcation techniques to identify the functionality
of gadgets, and provides a custom language, named QooL,
for writing input programs. Its current implementation only
supports simple QooL programs that call a single function or
system call, while passing a single custom argument. In case

the function to be called belongs to an ASLR-enabled DLL,
Q can compute a handle to it through the import table of a
non-ASLR DLL [12], when applicable. We should note that
although Q currently compiles only basic QooL programs that
call a single API function, this does not limit our evaluation,
but on the contrary, stresses even more our technique. The
simpler the programs, the fewer the gadgets used, which makes
it easier for Q to generate ROP code even when our technique
limits the number of available gadgets.

Mona is a plug-in for

Immunity Debugger

[66]

for available gadgets, categorizes

that
automates the process of building Windows ROP payloads
for bypassing DEP. Given a set of non-ASLR DLLs,
Mona searches
them
according to their
to
automatically generate four alternative ROP payloads for
giving execute permission to the
embedded shellcode
and then invoking it, based on the VirtualProtect,
VirtualAlloc,
and
SetProcessDEPPolicy API functions (the latter two are
not supported in Windows 7).

functionality, and then attempts

NtSetInformationProcess,

Considering the functionality of the ROP payloads gener-
ated by the two tools, Mona generates slightly more complex
payloads, but its gadget composition engine is less sophisti-
cated compared to Q’s. Q generates payloads that compute
a function address, construct its single argument, and call it.
Payloads generated by Mona also call a single memory alloca-
tion API function (which though requires the construction of
several arguments), copy the shellcode to the newly allocated
area, and transfer control to it. Note that the complexity of
the ROP code used in the tested exploits is even higher, since
they rely on up to four different API functions [53], or “walk
up” the stack to discover pointers to non-imported functions
from ASLR-enabled DLLs [62], [63].

Table III shows the results of running Q and Mona on
the same set of applications and DLLs used in the previous
section (for applications, all non-ASLR DLLs are analyzed
collectively), for two different cases: when all gadgets are
available to the ROP compiler, and when only the non-
randomized gadgets are available. The second case aims to
build a payload that will be functional even when code
randomization is applied. Although both Q and Mona were
able to create payloads when applied on the original DLLs in
almost all cases, they failed to construct any payload using
only non-randomized gadgets in all cases.

Although our technique was able to prevent two different

611

Table III

RESULTS OF RUNNING Q [26] AND MONA [27] ON THE ORIGINAL

NON-ASLR DLLS LISTED IN TABLE II, AND THE UNMODIFIED PARTS OF
THEIR RANDOMIZED VERSIONS. IN ALL CASES, BOTH TOOLS FAILED TO
GENERATE A ROP PAYLOAD USING SOLELY NON-RANDOMIZED GADGETS.

Application/DLL

Orig.

Rand.

Q success

Mona success

Orig.

Rand.

Adobe Reader
Integard Pro
Mplayer
msvcr71.dll
mscorie.dll
mfc71u.dll

✔

✔

✔

✔

✘

✔

✘

✘

✘

✘

✘

✘

✔ (VA)
✘
✔ (VA)
✘

✘

✘

✘

✘

✘
✘
✔ (VA,VP) ✘

tools from automatically constructing reliable ROP code, this
favorable outcome does not exclude the possibility that a
functional payload could still be constructed based solely on
non-randomized gadgets, e.g., in a manual way or using an
even more sophisticated ROP compiler. However, it clearly
demonstrates that in-place code randomization signiﬁcantly
raises the bar for attackers, and makes the construction of
reliable ROP code much harder, even in an automated way.

This is reﬂected on the reduction in the number of avail-
able (non-randomized) gadgets after code randomization. Both
tools operate in two phases: gadget discovery and code com-
pilation. During the ﬁrst phase, they search for useful gadgets
and categorize them according to their functionality. Tables IV
and V show the number of useful gadgets as reported by Q
and Mona, respectively, that are available before and after
randomization. As shown by the percentage of the remaining
gadgets (last column), many gadget
types have very few
available gadgets or are eliminated completely, which makes
the construction of reliable ROP code much harder.

VI. DISCUSSION

In-place code randomization may not always randomize
a signiﬁcant part of the executable address space, and it is
hard to give a deﬁnitive answer on whether the remaining
unmodiﬁable gadgets would be sufﬁcient for constructing
useful ROP code. This depends on the code in the non-
ASLR address space of the particular vulnerable process, as
well as on the actual operations that need to be achieved
using ROP code. Note that Turing-completeness is irrelevant
for practical exploitation [26], and none of the gadget sets
used in the tested ROP payloads is Turing-complete. For this
reason, we emphasize that in-place code randomization should
be used as a mitigation technique, in the same fashion as
application armoring tools like EMET [51], and not as a
complete prevention solution.

As previous studies [2], [5], [26] have shown, though, the
feasibility of building a ROP payload is proportional to the
size of the non-ASLR code base, and reversely proportional
to the complexity of the desired functionality. Our experi-
mental evaluation shows that in all cases, the space of the
remaining useful gadgets after randomization is sufﬁciently
small to prevent the automated generation of a ROP payload.
At the same time, the tested ROP payloads are far from the
complexity of a fully blown ROP-based implementation of the

operations required for carrying out an attack, such as dumping
a malicious executable on disk and executing it. Currently, this
functionality is handled by the embedded shellcode, which in
essence allows us to view these ROP payloads as sophisticated
versions of return-to-libc. We should stress that the random-
ization coverage of our prototype implementation is a lower
bound for what would be possible using a more sophisticated
code extraction method [41], [49]. In our future work, we also
plan to relax some of the conservative assumptions that we
have made in instruction reordering and register reassignment,
using data ﬂow analysis based on constant propagation.

Given its practically zero overhead and direct applicability
on third-party executables, in-place code randomization can be
readily combined with existing techniques to improve diversity
and reduce overheads. For instance, compiler-level techniques
against ROP attacks [15], [16] increase signiﬁcantly the size
of the generated code, and also affect the runtime overhead.
Incorporating code randomization for eliminating some of the
gadgets could offer savings in code expansion and runtime
overheads. Our technique is also applicable in conjunction
with randomization methods based on code block reorder-
ing [17]–[19], to further increase randomization entropy.

the binary level

In-place code randomization at

is not
applicable for software that performs self-checksumming or
other runtime code integrity checks. Although not encountered
in the tested applications, some third-party programs may
use such checks for hindering reverse engineering. Similarly,
packed executables cannot be modiﬁed directly. However, in
most third-party applications, only the setup executable used
for software distribution is packed, and after installation all
extracted PE ﬁles are available for randomization.

VII. RELATED WORK

Almost a decade after the introduction of the return-to-libc
technique [28], the wide adoption of non-executable memory
page protections in popular OSes sparked a new interest in
more advanced forms of code-reuse attacks. The introduction
of return-oriented programming [2] and its advancements [3]–
[6], [8], [26], [33], [67]–[69] led to its adoption in real-
world attacks [10], [11]. ROP exploits are facilitated by the
lack of complete address space layout randomization in both
Linux [12], and Windows [6], which otherwise would prevent
or at least hinder [14] these attacks.

Besides address space randomization, process diversity can
also be increased by randomizing the code of each executable
segment, e.g., by permuting the order of functions or basic
blocks [17]–[19]. However, these techniques are applicable
only if the source code or the symbolic debugging information
of the application to be protected is available. Our approach
is inspired by these works, and attempts to bring the beneﬁts
of code randomization on COTS software, for which usually
no source code or debugging information is available.

Return-oriented code disrupts the normal control ﬂow of a
process by diverting its execution to (potentially unintended)
code fragments, most of which otherwise would never be tar-
gets of control transfer instructions. Enforcing the integrity of

612

NUMBER OF USEFUL GADGETS IDENTIFIED BY Q [26] IN THE ORIGINAL CODE SEGMENTS / IN THEIR UNMODIFIABLE PARTS AFTER IN-PLACE

RANDOMIZATION WAS APPLIED.

Table IV

Gadget Type

Reader

Integard

Mplayer

msvcr71

mscorie

mfc71u

total

(%)

Pivots
Storemem
Move
ArithmeticStore
ArithmeticLoad
JumpConsts
SwitchStack
Loadmem
LoadConst
Arithmetic

171/27
162/11

57/7
89/8

587/23

1/1

171/27
657/79
424/36
409/49

55/11
14/4
25/13

7/3
26/8
1/1

55/11
18/0

121/20
59/10

156/48
105/7

68/35
90/6

1194/40

1/1

156/48
314/129
621/138
517/66

89/18
33/6
31/12
31/4

147/24

1/1

89/18
71/36
155/23
167/41

13/5
1/1
7/3

-
-

1/1
13/5

-

14/3
8/2

65/20
69/15
62/60
16/8

549/129
384/44
250/130
233/29

290/104

2244/199

1/1

65/20

761/690
175/67
347/190

6/6

549/129
1821/934
1510/287
1507/358

(23.50)
(11.46)
(52.00)
(12.45)
(8.87)
(100.00)
(23.50)
(51.29)
(19.01)
(23.76)

control transfers [20] can effectively protect against code-reuse
attacks. Compile-time techniques also prevent the construction
of ROP code by generating machine code that does not
contain unintended instruction sequences ending with indirect
control transfer instructions, and by safeguarding any indirect
branches in the actual code using canaries or additional
indirection [15], [16]. In contrast to the above approaches,
although in-place code randomization does not completely
preclude the possibility that working ROP code can be con-
structed, it can be applied directly on third-party software
without access to source code or debugging information.

Another line of defenses are based on runtime solutions
that monitor either the frequency of ret instructions [22],
[23], or the integrity of the stack [21]. Besides the fact these
techniques are ineffective against ROP code that uses indirect
control transfer instructions other than ret, their increased
runtime overhead limits their adoption.

VIII. CONCLUSION

The increasing number of exploits against Windows appli-
cations that rely on return-oriented programming to bypass ex-
ploit mitigations such as DEP and ASLR, necessitates the de-
ployment of additional protection mechanisms that can harden
imminently vulnerable third-party applications against these
threats. Towards this goal, we have presented in-place code
randomization, a technique that offers probabilistic protection
against ROP attacks, by randomizing the code of third-party
applications using various narrow-scope code transformations.
Our approach is practical: it can be applied directly on
third-party executables without relying on debugging infor-
mation, and does not introduce any runtime overhead. At
the same time, it is effective: our experimental evaluation
using in-the-wild ROP exploits and two automated ROP code
construction toolkits shows that in-place code randomization
can thwart ROP attacks against widely used applications,
including Adobe Reader on Windows 7, and can prevent the
automated generation of ROP code resistant to randomization.
Our prototype implementation is publicly available, and as
part of our future work, we plan to improve its randomization
coverage using more advanced data ﬂow analysis methods,
and extend it to support ELF and 64-bit executables.

AVAILABILITY

Our prototype implementation is publicly available at http:

//nsl.cs.columbia.edu/projects/orp

ACKNOWLEDGEMENTS

We are grateful to the authors of Q for making it available to us,
and especially to Edward Schwartz for his assistance. We also thank
´Ulfar Erlingsson and Periklis Akritidis for their valuable feedback on
earlier versions of this paper. This work was supported by DARPA
and the US Air Force through Contracts DARPA-FA8750-10-2-0253 and
AFRL-FA8650-10-C-7024, respectively, and by the FP7-PEOPLE-2009-
IOF project MALCODE, funded by the European Commission under
Grant Agreement No. 254116. Any opinions, ﬁndings, conclusions, or
recommendations expressed herein are those of the authors, and do not
necessarily reﬂect those of the US Government, DARPA, or the Air Force.

REFERENCES

[1] M. Miller, T. Burrell, and M. Howard, “Mitigating software vulnera-
bilities,” Jul. 2011, http://www.microsoft.com/download/en/details.aspx?
displaylang=en&id=26788.

[2] H. Shacham, “The geometry of innocent ﬂesh on the bone: return-into-
libc without function calls (on the x86),” in Proceedings of the 14th ACM
conference on Computer and Communications Security (CCS), 2007.

[3] S. Checkoway, A. J. Feldman, B. Kantor, J. A. Halderman, E. W. Felten,
and H. Shacham, “Can DREs provide long-lasting security? the case of
return-oriented programming and the AVC advantage,” in Proceedings
of the 2009 conference on Electronic Voting Technology/Workshop on
Trustworthy Elections (EVT/WOTE), 2009.

[4] R. Hund, T. Holz, and F. C. Freiling, “Return-oriented rootkits: bypass-
ing kernel code integrity protection mechanisms,” in Proceedings of the
18th USENIX Security Symposium, 2009.

[5] T. Dullien, T. Kornau, and R.-P. Weinmann, “A framework for automated
the 4th

architecture-independent gadget search,” in Proceedings of
USENIX Workshop on Offensive Technologies (WOOT), 2010.

[6] D. A. D. Zovi, “Practical return-oriented programming.”

Boston, 2010.

SOURCE

[7] P. Sol´e, “Hanging on a ROPe,” http://www.immunitysec.com/downloads/

DEPLIB20 ekoparty.pdf.

[8] D. A. D. Zovi, “Mac OS X return-oriented exploitation.”

RECON,

2010.

[9] P. Vreugdenhil, “Pwn2Own 2010 Windows 7 Internet Explorer
http://vreugdenhilresearch.nl/Pwn2Ownl2010-Windows7-

8 exploit,”
InternetExplorer8.pdf.

[10] K. Baumgartner, “The ROP pack,” in Proceedings of the 20th Virus

Bulletin International Conference (VB), 2010.

[11] M. Parkour, “An overview of exploit packs (update 9) April 5 2011,”

http://contagiodump.blogspot.com/2010/06/overview-of-exploit-packs-
update.html.

[12] G. Fresi Roglia, L. Martignoni, R. Paleari, and D. Bruschi, “Surgically
returning to randomized lib(c),” in Proceedings of the 25th Annual
Computer Security Applications Conference (ACSAC), 2009.

[13] H. Li, “Understanding and exploiting Flash ActionScript vulnerabilities.”

CanSecWest, 2011.

613

[14] H. Shacham, M. Page, B. Pfaff, E.-J. Goh, N. Modadugu, and D. Boneh,
“On the effectiveness of address-space randomization,” in Proceedings
of the 11th ACM conference on Computer and Communications Security
(CCS), 2004.

[15] J. Li, Z. Wang, X. Jiang, M. Grace, and S. Bahram, “Defeating return-
oriented rootkits with “return-less” kernels,” in Proceedings of the 5th
European conference on Computer Systems (EuroSys), 2010.

[16] K. Onarlioglu, L. Bilge, A. Lanzi, D. Balzarotti, and E. Kirda, “G-Free:
defeating return-oriented programming through gadget-less binaries,”
in Proceedings of
the 26th Annual Computer Security Applications
Conference (ACSAC), 2010.

[17] S. Forrest, A. Somayaji, and D. Ackley, “Building diverse computer sys-
tems,” in Proceedings of the 6th Workshop on Hot Topics in Operating
Systems (HotOS-VI), 1997.

[18] S. Bhatkar, R. Sekar, and D. C. DuVarney, “Efﬁcient techniques for
comprehensive protection from memory error exploits,” in Proceedings
of the 14th USENIX Security Symposium, August 2005.

[19] C. Kil, J. Jun, C. Bookholt, J. Xu, and P. Ning, “Address space
layout permutation (ASLP): Towards ﬁne-grained randomization of
commodity software,” in Proceedings of the 22nd Annual Computer
Security Applications Conference (ACSAC), 2006.

[20] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti, “Control-ﬂow
integrity,” in Proceedings of the 12th ACM conference on Computer
and Communications Security (CCS), 2005.

[21] L. Davi, A.-R. Sadeghi, and M. Winandy, “ROPdefender: A practical
to protect against return-oriented programming,” in
the 6th Symposium on Information, Computer and

protection tool
Proceedings of
Communications Security (ASIACCS), 2011.

[22] P. Chen, H. Xiao, X. Shen, X. Yin, B. Mao, and L. Xie, “DROP:
Detecting return-oriented programming malicious code,” in Proceedings
of the 5th International Conference on Information Systems Security
(ICISS), 2009.

[23] L. Davi, A.-R. Sadeghi, and M. Winandy, “Dynamic integrity measure-
ment and attestation: towards defense against return-oriented program-
ming attacks,” in Proceedings of the 2009 ACM workshop on Scalable
Trusted Computing (STC), 2009.

[24] G. S. Kc, A. D. Keromytis, and V. Prevelakis, “Countering code-
injection attacks with instruction-set randomization,” in Proceedings of
the 10th ACM conference on Computer and Communications Security
(CCS), 2003.

[25] E. G. Barrantes, D. H. Ackley, T. S. Palmer, D. Stefanovic, and D. D.
Zovi, “Randomized instruction set emulation to disrupt binary code
injection attacks,” in Proceedings of
the 10th ACM conference on
Computer and Communications Security (CCS), 2003.

[26] E. J. Schwartz, T. Avgerinos, and D. Brumley, “Q: Exploit hardening
made easy,” in Proceedings of the 20th USENIX Security Symposium,
2011.

[27] Corelan Team, “Mona,” http://redmine.corelan.be/projects/mona.
[28] S. Designer, “Getting around non-executable stack (and ﬁx),” http:

//seclists.org/bugtraq/1997/Aug/63.

[29] T. Newsham, “Non-exec stack,” 2000, http://seclists.org/bugtraq/2000/

May/90.

[30] Nergal, “The advanced return-into-lib(c) exploits: PaX case study,”

Phrack, vol. 11, no. 58, Dec. 2001.

[31] S. Krahmer, “x86-64 buffer overﬂow exploits and the borrowed code
chunks exploitation technique,” http://www.suse.de/∼krahmer/no-nx.
pdf.
´U. Erlingsson, “Low-level software security: Attack and defenses,”
Microsoft Research, Tech. Rep. MSR-TR-07-153, 2007, http://research.
microsoft.com/pubs/64363/tr-2007-153.pdf.

[32]

[33] S. Checkoway, L. Davi, A. Dmitrienko, A.-R. Sadeghi, H. Shacham,
and M. Winandy, “Return-oriented programming without returns,” in
Proceedings of the 17th ACM conference on Computer and Communi-
cations Security (CCS), 2010.

[34] F. B. Cohen, “Operating system protection through program evolution,”

Computers and Security, vol. 12, pp. 565–584, Oct. 1993.

[35] P. Sz¨or, The Art of Computer Virus Research and Defense. Addison-

Wesley Professional, February 2005.

[36] E. Bhatkar, D. C. Duvarney, and R. Sekar, “Address obfuscation: an
efﬁcient approach to combat a broad range of memory error exploits,”
in In Proceedings of the 12th USENIX Security Symposium, 2003.

[37] “/ORDER (put functions in order),” http://msdn.microsoft.com/en-us/

library/00kh39zz.aspx.

[38] “Syzygy - proﬁle guided, post-link executable reordering,” http://code.

google.com/p/sawbuck/wiki/SyzygyDesign.

[39] “Proﬁle-guided optimizations,” http://msdn.microsoft.com/en-us/library/

e7k32f4k.aspx.

[40] C. Kruegel, W. Robertson, F. Valeur, and G. Vigna, “Static disassembly
of obfuscated binaries,” in Proceedings of the 13th USENIX Security
Symposium, 2004.

[41] M. Smithson, K. Anand, A. Kotha, K. Elwazeer, N. Giles, and
R. Barua, “Binary rewriting without relocation information,” Univer-
sity of Maryland, Tech. Rep., 2010, http://www.ece.umd.edu/∼barua/
without- relocation-technical-report10.pdf.

[42] P. Saxena, R. Sekar, and V. Puranik, “Efﬁcient ﬁne-grained binary
instrumentation with applications to taint-tracking,” in Proceedings of
the 6th annual IEEE/ACM international symposium on Code Generation
and Optimization (CGO), 2008.

[43] Skape, “Locreate: An anagram for relocate,” Uninformed, vol. 6, 2007.
[44] M. Pietrek, “An in-depth look into the Win32 portable executable ﬁle
format, part 2,” http://msdn.microsoft.com/en-us/magazine/cc301808.
aspx.

[45] I. Guilfanov, “Jump tables,” http://www.hexblog.com/?p=68.
[46] ——, “Decompilers and beyond.” Black Hat USA, 2008.
[47] Hex-Rays, “IDA Pro Disassembler,” http://www.hex-rays.com/idapro/.
[48] X. Hu, T.-c. Chiueh, and K. G. Shin, “Large-scale malware indexing
using function-call graphs,” in Proceedings of the 16th ACM conference
on Computer and Communications Security (CCS), 2009.

[49] S. Nanda, W. Li, L.-C. Lam, and T.-c. Chiueh, “Bird: Binary interpre-
tation using runtime disassembly,” in Proceedings of the International
Symposium on Code Generation and Optimization (CGO), 2006.

[50] L. C. Harris and B. P. Miller, “Practical analysis of stripped binary code,”
SIGARCH Comput. Archit. News, vol. 33, pp. 63–68, December 2005.
[51] Microsoft, “Enhanced Mitigation Experience Toolkit v2.1,” http://www.

microsoft.com/download/en/details.aspx?id=1677.

[52] A. V. Aho, M. S. Lam, R. Sethi, and J. D. Ullman, Compilers: Principles,
Boston, MA, USA: Addison-

Techniques, and Tools (2nd Edition).
Wesley Longman Publishing Co., Inc., 2006.

[53] “Adobe CoolType SING Table “uniqueName” Stack Buffer Overﬂow,”

http://www.exploit-db.com/exploits/16619/.

[54] R. El-Khalil and A. D. Keromytis, “Hydan: Hiding information in
program binaries,” in Proceedings of the International Conference on
Information and Communications Security, (ICICS), 2004.

[55] Intel 64 and IA-32 Architectures Software Developer’s Manual, ser.
Volume 2 (2A & 2B): Instruction Set Reference, A-Z, 2011, http:
//www.intel.com/Assets/PDF/manual/325383.pdf.

[56] S. S. Muchnick, Advanced compiler design and implementation.
Francisco, CA, USA: Morgan Kaufmann Publishers Inc., 1997.

San

[57] Y. L. Varol and D. Rotem, “An algorithm to generate all topological

sorting arrangements,” Comput. J., vol. 24, no. 1, pp. 83–84, 1981.

[58] A. Fog, “Calling conventions for different C++ compilers and operating

systems,” http://agner.org/optimize/calling conventions.pdf.

[59] Skape and Skywing, “Bypassing Windows hardware-enforced DEP,”

Uninformed, vol. 2, Sep. 2005.

[60] F. Bouchez, “A study of spilling and coalescing in register allocation as
two separate phases,” Ph.D. dissertation, ´Ecole normale sup´erieure de
Lyon, April 2009.

[61] “Wine,” http://www.winehq.org.
[62] “Integard Pro 2.2.0.9026 (Win7 ROP-Code Metasploit Module),” http:

//www.exploit-db.com/exploits/15016/.

[63] “MPlayer (r33064 Lite) Buffer Overﬂow + ROP exploit,” http://www.

exploit-db.com/exploits/17124/.

[64] “White Phosphorus Exploit Pack,” http://www.whitephosphorus.org/.
[65] Corelan Team, “Corelan ROPdb,” https://www.corelan.be/index.php/

security/corelan-ropdb/.

[66] “Immunity Debugger,” http://www.immunityinc.com/products-immdbg.

shtml.

[67] E. Buchanan, R. Roemer, H. Shacham, and S. Savage, “When good
instructions go bad: generalizing return-oriented programming to RISC,”
in Proceedings of the 15th ACM conference on Computer and Commu-
nications Security (CCS), 2008.

[68] T. Bletsch, X. Jiang, V. Freeh, and Z. Liang, “Jump-oriented program-
ming: A new class of code-reuse attack,” in Proceedings of the 6th
Symposium on Information, Computer and Communications Security
(ASIACCS), 2011.

[69] P. Sol´e, “Defeating DEP, the Immunitiy Debugger way,” http://www.

immunitysec.com/downloads/DEPLIB.pdf.

614

NUMBER OF USEFUL GADGETS IDENTIFIED BY MONA [27] IN THE ORIGINAL CODE SEGMENTS / IN THEIR UNMODIFIABLE PARTS AFTER IN-PLACE

Table V

RANDOMIZATION WAS APPLIED.

Gadget Type

Reader

Integard

Mplayer

msvcr71

mscorie

mfc71u

total

(%)

add eax -> ebx
add ebp -> eax
add ebp -> ebx
add ebp -> edi
add ebp -> edx
add ebx -> eax
add ebx -> ecx
add ebx -> edx
add ecx -> eax
add ecx -> ebp
add edi -> eax
add edi -> ecx
add edi -> edx
add edx -> eax
add esi -> eax
add esi -> ecx
add esi -> edi
add value to eax
add value to ebx
add value to edi
add value to edx
add value to esi
dec eax
dec ebp
dec ebx
dec ecx
dec edi
dec edx
dec esi
empty eax
empty edi
empty edx
inc eax
inc ebp
inc ebx
inc ecx
inc edi
inc edx
inc esi
move eax -> ebp
move eax -> ebx
move eax -> ecx
move eax -> edi
move eax -> edx
move eax -> esi
move eax -> esp
move ebp -> eax
move ebp -> ebx
move ebp -> edi
move ebp -> edx
move ebx -> eax
move ebx -> ecx
move ebx -> edi
move ebx -> edx
move ebx -> esp
move ecx -> eax
move ecx -> ebp
move ecx -> ebx
move ecx -> edi
move ecx -> edx
move ecx -> esi
move ecx -> esp
move edi -> eax
move edi -> ebp
move edi -> ebx
move edi -> ecx
move edi -> edx
move edi -> esi
move edi -> esp
move edx -> eax
move edx -> ebx
move edx -> ecx
move edx -> edi
move edx -> esi
move esi -> eax
move esi -> ebx
move esi -> ecx
move esi -> edi
move esi -> edx
move esi -> esp
move esp -> eax
move esp -> ebp
move esp -> ebx
move esp -> ecx
move esp -> edi
move esp -> esi
neg eax
neg edx
pickup pointer into eax
pickup pointer into ecx
pushad
xor ebp -> eax
xor edx -> eax
xor esi -> eax

1/0

1/0

1/0
5/0

4/0

3/0
9/0

3/2
1/0

-

-
-
-

-

-

-
-

-
-

-
-
-

-
-

-

-

24/9

2/0
2/0

111/87

1/0
156/2

2/0

51/19

6/2
0/5
3/0
3/0
14/1
3/0

-

1/0
4/0

-

2/0
11/2
34/0

5/0

96/0

1/0
1/0
4/0
26/1

-

-

-

-
-
-

2/0
1/0

-

125/0
1/0

1/0

17/1
1/0

1/0
1/0
488/0

2/0

-

-
-
-

-

-

-
-

1/0
1/0

-

5/0
8/0
37/0
20/0
3/1

-

-

7/0
1/0

-

1/0

1/1

2/1

5/5

1/0

2/0

1/0

1/1

2/0

1/1

3/2

-
-
-
-
-
-
-

-
-
-
-
-
-
-
-
-

-
-
-
-
-
-
-

-
-
-

-
-

-
-
-
-
-

-
-

-
-
-
-
-
-
-
-

-
-

-

-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-

-
-
-
-
-
-
-
-
-
-
-
-
-

-
-
-
-
-

3/0

1/0
2/0

2/0

2/2

1/1
1/0
89/0
1/0

-

1/1
12/1
1/0
2/0
1/0
3/0

3/0

1/0
2/0

8/0

1/0
2/1
10/4

-
-
-
-
-
-

-
-
-
-
-

-
-

-
-
-
-

-
-

-

-

-
-
-
-

-
-
-

-
-

-
-
-
-
-
-

-
-
-
-
-
-

-

-
-

-
-
-
-
-
-
-
-

-

1/0

2/0
7/0
1/0
2/1

1/0

-

-
-
-

-
-
-
-

2/0
4/0
1/0
1/0
4/0
3/1
3/0
8/0
4/0
5/0
5/0
16/0
3/0
2/2

-
-

-

1/0

84/24

3/0
4/3

18/12

2/0
3/2
5/3
133/0

-

2/0
53/6
134/0
9/3
9/0
1/1
37/1
2/0
23/2
52/0
7/1
7/0
10/1
19/0
30/3
80/2
2/0
2/0
6/0
151/0
1/0

-

1/0
2/0
46/1
3/1
4/0
1/0

-
-
-

-

92/8

1/0
8/0
19/0
3/0
19/0
92/1
3/0

-
-
-

136/0
2/0
16/0
3/0
8/0
17/0
1/0
1/0
85/0

-

10/0
4/0
1/1

-

12/3
2/0
26/4

1/0

-

-

615

15/0

6/0

1/0

1/0

1/1

2/0

58/0

12/1

15/10

1/0

22/4

1/1

63/59

1/1

186/177

108/95

9/2

281/141

1/1

2/1

5/0

1/0

1/1

1/0
1/0

-
-
-
-
-
-
-

-
-
-
-
-
-
-
-
-

-
-
-
-

-
-

-
-
-

-
-

-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-

-
-

-

-
-
-
-
-

-
-
-
-
-
-

-
-
-
-

-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-

-

1/0
1/1
1/1

1/0

1/0

-
-
-

-
-

-
-
-
-
-

-

-

-

4/4
4/1

1/0

1/0

33/11

1/1

2/2
3/2
1/0
196/4

-

5/0

2/1
6/1
12/8
7/0
1/1
11/1
5/1
2/1

17/1

-

-

13/1
43/23
17/1
1/1
2/1

37/1

3/0
1/0

41/2
3/1

6/0
2/0
5/0
2/0
96/1

5/5

6/0

1/0
1/0
513/2

4/4

2/0
5/0
9/8

23/15

17/12

-

-

-

-

-
-
-
-

-

-
-

-
-

-
-
-
-
-
-

-

-

-
-
-

3/0
2/0
1/1
1/1
2/0
5/0
1/0
6/2
11/0
3/1
8/0
8/0
4/0
8/0
16/0
16/0
7/4
15/9
1/0
1/0
1/0
1/0

164/49

4/1
4/3

275/254

6/2

118/92

8/3
580/6
1/0
9/0

504/263
137/2
33/7
22/13
13/1
42/2
31/2
31/3
57/1
9/2
28/1
10/1
34/1
85/28

133/3
3/1
9/1
6/0
295/1
1/0
4/0
6/2
8/1

127/10

7/2
4/0
7/0
4/0
6/0
2/0
334/9
1/0
1/0
9/0
19/0
8/5
19/0
117/3
4/0
1/0
2/0
2/0
1209/3
2/0
18/0
7/4
8/0
18/0
2/0
1/0
90/0
9/0
49/0
31/0
20/10

1/0

53/29

2/0

51/16

1/0
1/0
1/0

(0.00)
(0.00)
(100.00)
(100.00)
(0.00)
(0.00)
(0.00)
(33.33)
(0.00)
(33.33)
(0.00)
(0.00)
(0.00)
(0.00)
(0.00)
(0.00)
(57.14)
(60.00)
(0.00)
(0.00)
(0.00)
(0.00)
(29.88)
(25.00)
(75.00)
(92.36)
(33.33)
(77.97)
(37.50)
(1.03)
(0.00)
(0.00)
(52.18)
(1.46)
(21.21)
(59.09)
(7.69)
(4.76)
(6.45)
(9.68)
(1.75)
(22.22)
(3.57)
(10.00)
(2.94)
(32.94)
(2.26)
(33.33)
(11.11)
(0.00)
(0.34)
(0.00)
(0.00)
(33.33)
(12.50)
(7.87)
(28.57)
(0.00)
(0.00)
(0.00)
(0.00)
(0.00)
(2.69)
(0.00)
(0.00)
(0.00)
(0.00)
(62.50)
(0.00)
(2.56)
(0.00)
(0.00)
(0.00)
(0.00)
(0.25)
(0.00)
(0.00)
(57.14)
(0.00)
(0.00)
(0.00)
(0.00)
(0.00)
(0.00)
(0.00)
(0.00)
(50.00)
(0.00)
(54.72)
(0.00)
(31.37)
(0.00)
(0.00)
(0.00)

