White-box Cryptography Revisited: Space-Hard Ciphers

Andrey Bogdanov

Technical University of Denmark, Denmark

anbog@dtu.dk

Takanori Isobe

Sony Corporation, Japan

takanori.isobe@jp.sony.com

ABSTRACT
The need for software security in untrusted environments
is ever increasing. White-box cryptography aims to ensure
the security of cryptographic algorithms when the attacker
has full access to their implementations. However, there
is no secure white-box implementation of standard block
ciphers such as DES and AES known to date: All published
techniques have been practically broken.

In this paper, we revisit white-box cryptography and pro-
pose a family of white-box secure block ciphers SPACE with
several novel features. The design of SPACE is such that
the key-extraction security in the white box reduces to the
well-studied problem of key recovery for block ciphers (AES
in our example) in the standard black-box setting. More-
over, to mitigate code lifting, we introduce the notion of
space hardness.
It measures the diﬃculty of compressing
the white-box implementation of a cipher, and quantiﬁes se-
curity against code lifting by the amount of code that needs
to be extracted from the implementation by a white-box at-
tacker to maintain its functionality. SPACE includes several
variants with diﬀerent white-box code sizes. Therefore, it is
applicable to a wide range of environments and use cases.
One of the variants called N-SPACE can be implemented
with diﬀerent code sizes while keeping the cipher itself un-
changed.

SPACE oﬀers a high level of space hardness: It is diﬃ-
cult to ﬁnd a compact but still functional representation of
SPACE given its white-box implementation. This property
has several useful consequences for applications. First, it
gets more challenging for a DRM attacker (e.g. in a pay TV
setting) to scale a code-lifting attack and to distribute the
break. Moreover, this paves the way for mass-surveillance
resistant cryptography: If a large proportion of users dedi-
cates a signiﬁcant part of their computers’ storage (e.g. HDD)
to white-box SPACE implementations, it will be much more
complex or even infeasible for governmental agencies to deal
with the keys of all users simultaneously due to the limited
storage available, forcing them to focus on targeted attacks

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS’15, October 12–16, 2015, Denver, Colorado, USA.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-3832-5/15/10 ...$15.00.
DOI: http://dx.doi.org/10.1145/2810103.2813699.

instead. This consequence is especially important given
Snowden’s revelations on the extent of the mass surveil-
lance practice by NSA and GCHQ. Finally, the usage of
SPACE ciphers can mitigate the damage of having malware
in security-critical systems such as networks processing top-
secret data: As those are typically insulated from the Inter-
net, the capacity of the communication channel from inside
to outside the system is often limited, making it infeasible
for Trojans to transmit the necessary key material.

Categories and Subject Descriptors
K.6.5 [Management of Computing and Information
Systems]: Security and Protection

Keywords
white-box cryptography; space-hard cipher; code lifting; de-
composition; key extraction; DRM; pay TV; mass surveil-
lance; Trojans; malware

INTRODUCTION

1.
1.1 Background

White-box cryptography, introduced by Chow et al. in
2002, aims to protect software implementations of cryp-
tographic algorithms in untrusted environments [13, 14].
An increasing number of applications are emerging that re-
quire substantial security in purely software environments,
e.g. set-top boxes, PCs, tablets and smartphones, even if
hardware-assisted security mechanisms are available such
as the ARM TrustZone. Here, the attacker has full con-
trol over the execution environment of a cryptographic al-
gorithm, both in static and dynamic ways by decompiler
and debugger tools, e.g. IDA Pro and IL DASM.

The major goal of white-box cryptography is to protect
the conﬁdentiality of secret keys in such a white-box envi-
ronment. In addition, code lifting is a threat [13, 42, 33],
where the attacker attempts to isolate the program code
from the implementation environment and directly uses the
code itself as a larger key, instead of ﬁnding the underlying
compact secret key.

Given the spread of software-only applications in embed-
ded as well as desktop and server systems, it comes as no
surprise that white-box cryptography receives a lot of atten-
tion from industry, especially in pay TV and other DRM set-
tings. As it inherently addresses resistance to malware and
Trojans, white-box cryptography will ﬁnd more and more

1058applications in banking and other security-critical settings
as well.
1.2 Previous Work

White-box implementations of DES and AES were ﬁrst
proposed by Chow et al. in [13, 14]. Their approach was to
ﬁnd a representation of the algorithm as a network of look-
ups in randomized and key-dependent tables. In the wake
of these seminal papers, several further variants of white-
box implementations for DES and AES were proposed [12,
44, 23, 26]. However, all published white-box solutions for
DES and AES to date have been practically broken by key
extraction and table-decomposition attacks [3, 43, 35, 34,
25].

Security against key extraction and code lifting in those
white-box implementations is based upon external encod-
ings, which are randomly drawn bijections added to the in-
put and output of the target block cipher. Such a block
cipher becomes an encoded variant of the original algorithm,
which is inappropriate when standard encryption schemes
are required for interoperability, e.g. on the standard DRM
platform Marlin [27] or in banking.

Dedicated white-box block ciphers have recently been pro-
posed by Biryukov et al. in [4]. They are based on the
ASASA structure that consists of two secret nonlinear lay-
ers (S) and three secret aﬃne layers (A), with aﬃne and
nonlinear layers interleaved. Similarly to [13, 14], the white-
box implementation of ASASA uses table look-ups. The se-
curity of ASASA against key extraction in the white-box
setting relies on the hardness of the decomposition problem
for ASASA. To estimate the security against code lifting at-
tacks without external encodings, the work [4] introduces a
security requirement of weak white-box security: It should be
computationally hard for an attacker to ﬁnd any compact
equivalent representation of the cipher, i.e. table decompo-
sition in the white-box environment should be computation-
ally hard. Indeed, this makes code lifting attacks diﬃcult
in terms of the amount of data that needs to be extracted
from the white-box environment. Unfortunately, eﬃcient
decomposition attacks on ASASA have been proposed [19,
32, 22].

To summarize the design approaches so far, the secu-
rity against key recovery and table-decomposition attacks
of most existing white-box implementations relies on the
hardness of the decomposition problem given multiple se-
cret nonlinear and linear layers. It is pointed out in [4] that
the white-box implementations of AES and DES in [13, 14]
can be considered as the 3-layer ASA, which is much weaker
than the 5-layer ASASA. However, the decomposition of se-
cret nonlinear and linear layers is a relatively new problem
with only a few papers [7, 11, 40] dedicated to its study.
Indeed, although more layers make the construction more
secure, recent cryptanalysis [6] suggests that even as many
as 9 layers (SASASASAS) are susceptible to attacks. Thus,
the assurance on the security of (AS)i against decomposition
is yet to be provided.

In this paper, we take a diﬀerent approach and base the
decomposition security of our ciphers in the white box on
the problem of key recovery for block ciphers in the standard
black-box setting.

1.3 Our Contributions

In this paper, we propose a family of white-box secure
block ciphers. Our ciphers are designed to satisfy the fol-
lowing properties:

White-box security is based on black-box security:
In white-box environments, the security of our con-
structions relies on the well-studied problem of key re-
covery for block ciphers such as AES. Thus, key extrac-
tion and table-decomposition attacks are computation-
ally infeasible as long as the underlying block cipher
is secure against key recovery attacks in the standard
black-box setting.

Space hardness: To quantitatively evaluate the diﬃculty
of code lifting attacks, we introduce a security require-
ment called (M, Z)-space hardness which is a gener-
alization of the weak white-box security notion of [4].
The notion of (M, Z)-space hardness allows us to claim
that if the amount of code to be isolated from the white-
box implementation by an attacker is less than M , a
construction is secure against code lifting. Namely, the
success probability that the code correctly encrypts (or
decrypts) a random input is less than 2
Indeed,
weak white-box security corresponds to the case of
(M, 0)-space hardness.

−Z .

Furthermore, even if the attacker succeeds in code lift-
ing, the property of space hardness discourages him
from illegally distributing the code due to its large size,
as it is infeasible to ﬁnd any compact implementation
unless the secret key is known.

No external encoding: To be applicable to the wide range
of situations and use cases, our ciphers do not require
any external operations such as external encodings for
their white-box security.

Variable white-box implementation size: In order to
provide a high degree of compatibility across platforms
and resource restrictions, our constructions include sev-
eral variants with diﬀerent but ﬁxed code sizes as well
as a variant with variable code sizes while keeping the
cipher itself unchanged.

Our family of white-box secure block ciphers consists of

two types of constructions: SPACE and N-SPACE.

SPACE includes four variants: SPACE-8, -16, -24 and
-32, which are implementable in diﬀerent but ﬁxed sizes of
code, ranging from a few KB to some GB. The table sizes
of SPACE-8, -16, -24 and -32 are suited for L1/L2 cache
(e.g. 32 KB to 256 KB), L3 cache (e.g. 8 MB), RAM (e.g. a
few GB) and HDD (e.g. many GB), respectively. Moreover,
we propose 4-SPACE as an example of N-SPACE. It of-
fers four implementation variants with diﬀerent code sizes
from a few KB to several GB, while keeping the cipher itself
unchanged: 4-SPACE-8, -16, -24 and -32.

Our constructions oﬀer implementation advantages over
known white-box AES implementations and are competitive
to (AS)i structures in white-box environments. In particu-
lar, at the comparable levels of (M ,Z)-space hardness, the
white-box implementations of SPACE-16, -24, and -32 re-
quire exactly the same number of table look-ups as ASASA-
1, -2, and -3, respectively, see Table 4.

Since the underlying internal block cipher can be freely
chosen depending on the user requirements, a wide range of

1059implementation properties in the black box can be attained.
If one chooses a software-oriented lightweight block cipher
such as PRIDE [1] and SIMON/SPECK [2] as the under-
lying block cipher, an implementation with very low RAM
and code size requirements is possible [18]. With AES in-
side, the black-box performance can be optimized by using
bit-sliced implementations or AES-NI.
1.4 Related Work: Memory Hardness

The concept of memory hardness was proposed in the con-
text of password hashing [37, 21, 5]: It forces the attacker
to consume a large amount of memory while computing a
target function. The purpose is to prevent eﬃcient paral-
lel brute-force attacks by dedicated password-cracking hard-
ware and GPUs.

As opposed to that, the goal of (M, Z)-space hardness is
to mitigate the copying of functionality. It states a bound
on the data required to be extracted from the white-box
environment for successfully processing a random input with
−Z . In other words, it aims to
probability of more than 2
eﬀectively increase the key size to M .

2. ATTACK MODELS

In this paper, we deal with two attack models: black-box

model and white-box model.
2.1 In the Black Box

The black-box model is a classical attack model in the

ﬁeld of symmetric-key cryptography.
2.1.1 Attacker’s Abilities
This model assumes that the attacker is able to access
inputs and outputs of the cipher with known- or chosen-
plaintexts or ciphertexts. Adaptive queries can be allowed.
2.1.2 Security Requirements
As the attacker aims to recover the secret key or to distin-
guish the block cipher from a randomly drawn permutation,
some standard security requirements in the black-box model
can be informally summarized as follows.

Key recovery security: It is computationally hard to re-

cover the key of the block cipher.

Distinguishing security: It is computationally hard to dis-

tinguish the block cipher from a randomly drawn per-
mutation.

The hardness of a key recovery is evaluated by the time
complexity accompanied by data and memory complexities
of ﬁnding the key. For instance, a 128-bit security implies a
time complexity of at least 2128 encryptions. The complex-
ity of a distinguishing attack is formally evaluated by the
number of queries necessary.
2.2 In the White Box

The white-box model originates from the seminal results

by Chow et al. [13, 14].
2.2.1 Attacker’s Abilities
This model assumes that the attacker has full control over
the execution environment of a cipher, both in static and
dynamic ways with the aid of arbitrary trace execution, ex-
amination of sub-results and keys in memory, insertion of

Figure 1: Table-based white-box implementations:
The key K is scrambled by a network of table look-
ups

Security Requirements

break-points, modiﬁcation of internal variables, and many
more.
2.2.2
The main goal of the white-box attacker is to extract the
secret key given the full access to the cipher’s implementa-
tion and its internals. Therefore, typical security require-
ments in the white-box setting are as follows.

Key extraction security: It is computationally hard to

extract the secret key of the block cipher.

Code lifting security: Instead of a secret key, the attacker
can directly use the implementation itself as a larger
eﬀective key. In particular, he can isolate the program
code where the key is embedded in order to copy the
functionality of encryption/decryption routines and to
utilize it in a stand-alone manner.
In some aspects,
this is also referred to as global deduction by De Mul-
der [33].

If a code lifting attack succeeds, the attacker gets the advan-
tage which is almost the same as key extraction, i.e. he can
encrypt/decrypt any plaintext/ciphertext. Unless a public-
key primitive is used or external encodings are involved, it
is challenging to completely prevent code lifting attacks. To
evaluate the diﬃculty of this attack, the notions of weak
white-box security and incompressibility have been intro-
duced in [33, 4]. The details of these will be given in the
next section. In this paper, we adopt a more general security
notion: space hardness.

3. KNOWN WHITE-BOX TECHNIQUES

The white-box techniques published so far can be divided
into two groups: white-box implementations of existing block
ciphers such as DES and AES on the one hand, and dedi-
cated designs of block ciphers for the white-box environment
on the other.
3.1 White-box Implementation of DES/AES

White-box implementations of DES and AES were ﬁrst
proposed by Chow et al. in [13, 14]. Their approach was to
represent the block cipher EK as a network of look-ups in
randomized key-dependent tables, see Fig. 1. The key value

PBlock Cipher(e.g. AES-128)CPCK1060is masked by random variables and is scrambled into the
tables.

Each table is protected by applying secret invertible en-
codings before and after the table. For example, the white-
box implementation of AES [14] employs secret nonlinear
and linear components as secret encodings to protect the
tables. In order to preserve the functionality of the cipher,
the output encoding gi of the i-th table is the inverse func-
tion of the input encoding f i+1 of the (i + 1)-th input table,
that is, (gi)

−1 = f i+1.

Finally, external encodings IN and OU T are added to
the input and output of the block cipher EK . Therefore,
the action of the composite transform is OU T ◦ EK ◦ IN
−1,
where IN and OU T are secret bijections. The purpose of
external encodings is to protect the tables of the ﬁrst and
last rounds. This also mitigates code lifting by hiding the
actual block cipher EK between encodings.

Figure 2: External encodings for DRM: IN and OU T
are external encodings. Enc is the block cipher EK
and Dec is its inverse DK

′

For example, in the DRM setting, the external encoding
IN is ﬁrst applied on the server side after encrypting the
= IN ◦ EK (P ). Then, the DRM
content P and returns C
′
client software, running on the user’s device, decrypts C
= OU T ◦ DK ◦ IN
−1(C
to P
) and outputs the encoded
content P
= OU T (P ), where DK is the inverse of the block
cipher EK . The remaining encoding is removed in the user’s
content player which is placed closer to the playback device
to obtain the original content P , see Fig. 2.

′

′

′

Following the papers by Chow et al. [13, 14], several fur-
ther variants of white-box implementations of DES and AES
were proposed [12, 44, 23, 26].

3.1.1 Problems with Security
All published white-box implementations of DES and AES
are practically broken [3, 43, 35, 34, 25]. In addition to these
dedicated attacks, Michiels et al. [31] proposed a generic ta-
ble decomposition attack on a wide class of white-box im-
plementations of SPN ciphers.

As mentioned in [30], since AES and DES were designed
with the black-box security in mind, it seems diﬃcult to
provide white-box security at the same time. This is still an
open problem.

3.1.2 On External Encodings
The crucial drawback of this approach is the usage of ex-
ternal encodings. Due to external encodings at the input
and output of the block cipher EK , the algorithm becomes
an encoded variant of the cipher, i.e. a diﬀerent cipher. This
can be inappropriate when interoperability is necessary as
it is the case for the standard DRM platform Marlin which
speciﬁes AES-128 as the content protection algorithm [27].
Banking is also an application where interoperability plays
an important role.

Furthermore, to obtain original plaintexts after white-box
decryption, the additional decoding operation has to be per-
formed in a secure environment. The natural question arises
as to why the entire decryption is not performed in this
secure environment in the ﬁrst place. Therefore, as also
mentioned in [42, 33], the applications of white-box imple-
mentations with external encodings are mainly restricted to
proprietary DRM settings.

However, if the external encodings are removed to avoid
the issues mentioned above, the white-box implementation
becomes much weaker [14] because the ﬁrst- and last-round
tables become directly accessible to the attacker.

Figure 3: ASASA construction: 5 layers of inter-
leaved secret aﬃne and secret nonlinear (S-boxes)
operations

3.2 Dedicated Cipher: ASASA

Dedicated block ciphers for white-box environments were
proposed by Biryukov et al. in [4]. They are based on the
ASASA structure consisting of two secret nonlinear layers
(S-boxes, S) and three secret aﬃne layers (A) in the inter-
leaved order, see Fig. 3. The security of the block ciphers
against key recovery attacks relies on the hardness of de-
composing the ASASA structure. Unlike the white-box im-
plementations of AES and DES, the ASASA structure does
not require external encodings. To estimate the security
of ASASA against code lifting attacks, the notion of weak
white-box security was introduced.

Definition 1

(Weak White-box Security [4]).

The function F is an T -secure weak white-box implementa-
tion of EK if it is computationally hard to obtain an equiv-
alent key of size less than T given full access to F .

In other words, it should be computationally hard for an
attacker to ﬁnd any compact equivalent function which is
smaller than T . Accordingly, an attacker requires code of
size T to copy the functionality of the cipher completely.
Weak white-box security enables the estimation of the dif-
ﬁculty of code lifting by the amount of data needed to be
extracted from the white-box environment. This property
is also called incompressibility by De Mulder [33].

Biryukov et al. also deﬁne strong white-box security. This
property corresponds to MQ-problems used in public-key
cryptography and is related to one-wayness as deﬁned by
De Mulder [33].

Server SidePEncCINC’DecC’IN-1UntrustedOUTP’P’OUT-1PTrustedClient SoftwareplayerTrustedClient SideAAANonlinearNonlinearSSSSSSSSAffineAffineAffine10613.2.1 Security Issues
Decomposition and key recovery attacks on ASASA struc-
tures have recently been proposed [19, 32, 22]. The security
of constructions based on multiple secret nonlinear and lin-
ear layers is still to be explored and seems hard to evaluate,
despite several cryptanalytic eﬀorts [7, 11, 40]. Recent at-
tacks point out that even the 9-layer variant SASASASAS
does not oﬀer a suﬃcient security level [6]. The assurance
on the security of (AS)i against decomposition attacks is yet
to be provided.

4. OUR DESIGN GOALS

In this section, we outline our design goals for a new family

of white-box secure block ciphers.
4.1 Security

To quantitatively evaluate the diﬃculty of code lifting
without relying on external encodings, one could take the
notion of weak white-box security [4], which can assess the
amount of data required to copy the full functionality. How-
ever, the white-box security of a cipher when the size of the
available code (table) is less than M is unclear.

To reveal the tradeoﬀ between the data available and
attacker’s advantage, we introduce a novel security notion
coined (M, Z)-space hardness.

Definition 2

((M, Z)-space hardness). The imple-
mentation of a block cipher EK is (M, Z)-space hard if it
is infeasible to encrypt (decrypt) any randomly drawn plain-
−Z given any
text (ciphertext) with probability of more than 2
code (table) of size less than M .

(M, Z)-space hardness enables us to estimate the code size
M to be isolated from white-box environments to encrypt
(decrypt) any plaintext (ciphertext) with a success proba-
−Z as well as to derive more ﬁne-grained
bility larger than 2
security claims. Weak white-box security [4] can be seen as
a special case of (M ,Z)-space hardness and corresponds to
(M, 0)-space hardness.

Security requirements in the black- and white-box envi-

ronments are given as follows.

Security in the black box: The cipher should be secure
against key recovery attacks and distinguishing attacks,
i.e. there are no attacks more eﬃcient than generic
attacks such as brute force.

Security in the white box: The cipher should be secu-
rity against key extraction attacks, and mitigation of
code lifting attacks in terms of (M ,Z)-space hard-
ness: An attacker needs to obtain codes (tables) whose
size is larger than M to compute any plaintext or ci-
phertext with probability larger than 2

−Z .

4.2 Functionality

To be applicable to a wide range of situations and use
cases, the cipher should not require any additional functions
such as external encodings.
4.3 Performance

In both black-box and white-box environments, the per-
formance of the cipher should be competitive to known prim-
itives such as whitebox AES [14, 44] and ASASA construc-
tions [4].

Figure 4: Ciphers with ﬁxed code size: SPACE

To make our ciphers implementable in multiple settings
including those with restricted resources, we provide several
variants with diﬀerent code sizes (SPACE), and a variant
enabling multiple code sizes while keeping the cipher itself
unchanged (N-SPACE).

5. SPACE: FIXED SPACE

This section proposes a block cipher called SPACE, at-
taining our design goals in the black-box and white-box set-
tings as well as oﬀering several variants with diﬀerent but
ﬁxed code sizes.
5.1 The Design

SPACE is an ℓ-line target-heavy generalized Feistel net-
work [38] which encrypts an n-bit plaintext under a k-bit
secret key to an n-bit ciphertext, where the size of each line
is na (= n/ℓ) bits, as shown in Fig. 4.
},
Let the n-bit state of round r be X r = {xr
ℓ−1
i ∈ {0, 1}na . X 0 and X R are a plaintext and a ciphertext,
xr
respectively, where R is the number of rounds. Each round
updates the state as:
F r
na (xr

X r+1 =
na : {0, 1}na → {0, 1}nb . Here || denotes the con-
na (x) is deﬁned

2|| . . .||xr
ℓ−1)
where F r
catenation, and nb = n− na. The function F r
as
na (x) = (msbnb (EK (C0||x))) ⊕ r,
F r

)||xr

0) ⊕ (xr

1||xr

(

0, xr

1, . . . , xr

0,

where EK is a block cipher with n-bit block and k-bit key,
msbu(x) selects the most signiﬁcant u bits of x, and C0 is
an (nb (= n − na))-bit binary zero value. The last XOR of
r plays the role of a round constant (see Fig. 5).
na (x) = msbnb (EK (C0||x)). It is an na-bit to nb-
′

Let F

bit function. Each round updates the state by looking up
′
na (x), adding the
the leftmost line value in the table for F
constant r to the result to compute F r
na (x), XORing it to
the other lines, and rotating the lines by one position to the
left.

′
na (x) is implemented by
′
table look-ups. SPACE has only one table of F
na (x) that
is reused in each round. This single-table implementation
makes the evaluation of (M, Z)-space hardness easier.

In the white-box environment, F

x0r-1x1r-1x2r-1Fr-1FrFr+1n/lx3r-1xl-2r-1xl-1r-1x0r+2x1r+2x2r+2x3r+2xl-2r+2xl-1r+2nanana1062Figure 5: F-function: Fna (x) = F

na (x) ⊕ r
′

We instantiate the SPACE family with four concrete block
ciphers for k = 128 and AES-128 as the underlying block ci-
pher EK :

• SPACE-(8, R) : n = 128, ℓ = 16, na = 8, F r
8 :

{0, 1}8 → {0, 1}120

• SPACE-(16, R) : n = 128, ℓ = 8, na = 16, F r

16 :

{0, 1}16 → {0, 1}112

• SPACE-(24, R) *1 : n = 128, ℓ = 16, na = 24, F r

24 :

{0, 1}24 → {0, 1}104

• SPACE-(32, R) : n = 128, ℓ = 4, na = 32, F r

32 :

{0, 1}32 → {0, 1}96

5.2 Feistel

We aim to show security in the white box as deﬁned in
Section 4.1. Hence our approach is to construct the table
′
F
na (x) from a well-studied standard block cipher such as
AES by constraining the plaintext and truncating the ci-
phertext. Then, the hardness of extracting the key from the
table and ﬁnding a compact description of the table in the
white-box model relies on the diﬃculty of key recovery for
the underlying block cipher in the black-box model.

Since restricting the input and output of any secure un-
derlying block cipher is unlikely to deliver a permutation,
a Feistel-type construction is a natural candidate. We note
that the SPN structure adopted by the ASASA construc-
tion does require secret permutations as building blocks and,
therefore, cannot be based on the truncation of a standard
block cipher with a 128-bit block length such as AES-128
directly.

We also considered type-1, -2, -3 generalized Feistel con-
struction and source-heavy construction as the underlying
construction and opted for the target-heavy Feistel construc-
tion for performance reasons.
5.3 Security in the White Box
5.3.1 Key Extraction
In the white-box model, the attacker is able to fully access
inputs and outputs of tables in any round. To extract the
1Only in this variant, each round updates the state as
X r+1 = (xr
to keep the 128-bit block size.

)||xr

2)||(

0||xr

1||xr

1||xr

2) ⊕ (xr

3||xr

4|| . . .||xr

F r

24(xr

ℓ−1)

0

Figure 6: A compression attack on SPACE with
R ∈ {25, 64, 96, 128} in terms of (M, Z)-space hardness,
with T = (2na × nb) bits

na (x) = msbnb (EK (C0||x)) means to
′

key from the table F
recover the key of EK in the black-box model, with plain-
texts from a restricted space and truncated ciphertexts. The
underlying block cipher EK of our SPACE instantiation is
AES-128, for which no eﬃcient key recovery attack has been
published so far despite considerable cryptanalytic eﬀorts
over 15 years [9, 17, 20]. Thus, key extraction is computa-
tionally hard in the white-box model as long as the under-
lying block cipher is secure against key recovery attacks in
the black-box model.

More formally, the advantage of the key extraction in the
white-box model for SPACE, AdvKE-WB, is upper-bounded
by the advantage of the key recovery for the underlying block
cipher in the black-box model, AdvKR-BB:
AdvKE-WB ≤ AdvKR-BB.

5.3.2 Code Lifting: Space Hardness
As the attacker is unable to compute EK (C0||x) without
the knowledge of K if the underlying block cipher EK is
secure, it is computationally hard to ﬁnd any compact rep-
resentation of EK (C0||x). The table of EK (C0||x) consists
of 2na entries of nb bits each, and the total table (code)
size T is estimated as (2na × nb) bits. In other words, this
provides weak whitebox security at the level of (2na × nb)
bits [4].
Let us consider the case where a part of the table is leaked,
i.e. i ≤ 2na entries of table are extracted by the attacker,
where the leaked-table size M is (i× nb) bits. The probabil-
ity that a random input of the table is among the extracted
subset of entries is estimated as i/2na (= (i×nb)/(2na×nb)).
Thus, given a random plaintext/ciphertext, the correspond-
ing output after R rounds can be computed with i entries
of the table with a probability of about (i/(2na ))R. Fig. 6
shows this relation between M and Z in terms of (M, Z)-
space hardness for SPACE with R ∈ {25, 64, 96, 128}. This
evaluation is a basic white-box compression attack and its re-
sults should be seen as an upper bound on the actual space
hardness.

EKKCkxnarnb= n -nanadiscardF’nb= n -nana10635.4 Security in the Black Box
5.4.1 Key Recovery
In the black-box model, the attacker is unable to directly
′
na (x) =
msbnb (EK (C0||x)). Hence, a key recovery for SPACE in the

access the inputs and outputs of the internal tables F

black-box setting is at least as complex as a key recovery
for the underlying block cipher. Thus, in the black box,
dedicated distinguishing attacks with possible subsequent
table recovery are of more concern than key recovery attacks.
5.4.2 Generic Attacks
Generic attacks on target-heavy generalized Feistel con-
structions were proposed in [36, 41]. None of these proper-
ties spans more than 47, 23 and 11 rounds of SPACE-8, -16
and -32, respectively.
5.4.3 Differential Cryptanalysis
Here we analyze the diﬀerential properties of an na-bit to

na (x) : {0, 1}na → {0, 1}nb(=n−na).
′

nb-bit function F

Definition 3. The cardinality of a diﬀerential N (a, b)
for a function f is the number of pairs with input diﬀer-
ence a that have output diﬀerence b:

N (a, b) = #{(v, u)|u ⊕ v = a and f (v) ⊕ f (u) = b}

The distribution of N (a, b) over functions has been shown
to be binomial for suﬃciently large na and nb [16, 8].

Lemma 1. [16] For a non-trivial diﬀerential (a, b) with
ﬁxed a and b, the distribution of N (a, b) over na-bit to nb-
bit functions is binomial:

P r(N (a, b) = i) = (2

−nb )i(1 − 2

−nb )2na(cid:0)1−i

(

)

.

2na−1

i

Assuming that the diﬀerentials over a ﬁxed randomly drawn

permutation have a similar distribution of expected N (a, b)
and using the proof techniques of Theorem 2 in [8], we ob-
tain the following for a random function:

Theorem 1. Assuming that the distribution of N (a, b)
′
na (x) is binomial (Lemma 1), the probability
for a function F
qB that N (a, b) is at most B over all non-trivial values of a
and b can be lower-bounded by

(
1 − (2na−1 · 2

qB >

−nb )B+1

2n+1

.

(B + 1)!

)

Proof. The number of combinations of a and b is estimated
as 2n (=na+nb), hence:

qB = (1 − P r(N (a, b) > B))2n

,

)

(

2na−1

i

where we have:

P r(N (a, b) > B) =

<

<

j=B+1

2na(cid:0)1∑
2na(cid:0)1∑
2na(cid:0)1∑

j=B+1

−nb )i(1 − 2
(
(2

−nb )2na(cid:0)1−i
)

−nb )i
(2

2na−1

i

(2

−nb )i (2na−1)i
(B + 1)!
−nb )B+1

.

(B + 1)!

j=B+1

< 2 · (2na−1 · 2

Table 1: Lower bound on qB: The probability that
N (a, b) is at most B over all non-trivial values of a
and b for B = 1, 2 in F

′
24 and F

′
16, F

′
8, F

′
32

q1
1 − 2
′
F
8
1 − 2
′
F
16
1 − 2
′
F
24
32 1 − 2
′
F

q3
q2
1 − 2
−209 1 − 2
−96
−323
−161 1 − 2
1 − 2
−64
−259
−113 1 − 2
1 − 2
−195
−32
−0.66 1 − 2
−65 1 − 2
−131

′

′
8, F

′
24 and F

Table 1 shows qB for F

′
16, F
′
8 and F

′
32. The diﬀer-
(x) is estimated as B/2n/ℓ. Since q2
ential probability of F
′
32,
and q3 are very close to 1 in F
respectively, we assume the maximum diﬀerential probabil-
−15
ity of SPACE-8, -16, -24 and -32 to be 2
−30.4 (= 3/232), respec-
(= 2/216), 2
tively.

′
24 and F
−7 (= 2/28), 2

−22.4 (= 3/224) and 2

′
16, and F

Our search for the minimum number of diﬀerentially ac-
tive F-functions shows that SPACE-8, -16, -24 and -32 have
at least 17, 9, 6 and 5 active F-functions after 150, 44, 32
and 14 rounds.
5.4.4 Linear Cryptanalysis
′
Now we analyze the linear properties of the function F
na (x):
{0, 1}na → {0, 1}nb(=n−na).
Given an input mask α and an output mask β, α ∈
{0, 1}na and β ∈ {0, 1}nb , the correlation of a linear ap-
proximation (α, β) for a function f : {0, 1}na → {0, 1}nb is
deﬁned as

Cor = 2

−na [#{x ∈ {0, 1}na|α · x ⊕ β · f (x) = 0} −
#{x ∈ {0, 1}na|α · x ⊕ β · f (x) = 1}.

The linear probability LP of (α, β) is deﬁned as Cor2. LP
′
na (x) is assumed to be normally distributed [16], using
of F
Corollary 1. [16] The linear probability LP of a non-
trivial linear approximation over na-bit to nb-bit functions
with n ≥ 5 has mean µ(LP ) = 2
−na and variance σ2(LP ) =
2 × 2

−2na .

−4.5, 2

−12.5, 2

−20 and 2

−28, respectively.

Therefore, the linear probability LP of F

−na + 10σ with probability 1 − 2

′
na (x) with a ﬁxed
−148.
key is lower than 2
−n + 10σ for the F-functions of SPACE-8,
The value of 2
−20.5, and
-16, -24 and -32 is estimated as 2
−28.6, correspondingly. In our evaluation, we assume the
2
−4,
maximum linear probabilities of the F-functions to be 2
−12, 2
2
Our search for the minimum number of linearly active F-
functions in SPACE-8, -16, -24 and -32 shows that there are
at least 32, 11, 7 and 5 active F-functions after 33, 12, 10
and 6 rounds.
5.4.5
In SPACE-8, -16, -24 and -32, any input bit non-linearly
aﬀects all state bits after at least 17, 9, 15 and 5 rounds, re-
spectively. Following the miss-in-the-middle approach, after
34 (= 17 × 2), 18 (= 9 × 2), 30 (= 15 × 2), and 10 (= 5 × 2)
rounds, we have not found any useful impossible diﬀerentials
for the respective variants.

Impossible Differential Cryptanalysis

1064Table 2: Summary of security evaluation for SPACE
in the black box: Round numbers needed to resist
attacks.

Table 3: Performance of SPACE with recommended
round numbers

G F
17
47
23
9
15
-
5
11
-
17

SPACE-(8, R)
SPACE-(16, R)
SPACE-(24, R)
SPACE-(32, R)
4-SPACE-(R)
G : Generic attack [36, 41], F : Full Diﬀusion
D : Diﬀerential attack, L : Linear attack
ID : Impossible diﬀerential attack, I : Integral attack

D
150
44
32
14
48

I
19
12
17
10
19

L
33
12
10
6
16

ID
34
18
30
10
34

SPACE-(8, 300)
SPACE-(16, 128)
SPACE-(24, 128)
SPACE-(32, 128)

AES (Chow et al.) [14]

AES (Xiao-Lai) [44]
AES (Black-box) [15]

T

Performance
300 L1-TL
128 L3-TL

3.84 KB
918 KB
128 RAM-TL 218 MB
128 HDD-TL 51.5 GB
3008 L3-TL
752 KB
80 RAM-TL 20.5 MB
160 L1-TL

4 KB

5.4.6 Other Attacks
From the results by Suzaki et al. [39], it follows that there
are no useful integral distinguishers after 19, 12, 17 and
10 rounds of SPACE-8, -16, -24 and -32. We have also
considered further attacks including slide, higher order dif-
ferential, truncated diﬀerential, and algebraic attacks. The
details of this evaluation are omitted due to the page limi-
tation. Table 2 shows a summary of our security evaluation
for SPACE-8, -16, -24 and -32.
5.5 Recommended Numbers of Rounds

We conservatively recommend to choose the number R of
rounds to be equal to twice the number of rounds resist-
ing the basic white-box compression attack of Section 5.3.2
at the level of (T /4, 128)-space hardness or twice the num-
ber of rounds covered by the best black-box distinguisher of
Section 5.4, whichever is higher.

The recommended variants are SPACE-(8, 300), (16, 128),
(24, 128) and (32, 128). In the white box, the security claim
is the key extraction security at the level of 128 bits and
(T /4, 128)-space hardness. In the black box, we claim the
classical security of a 128-bit block cipher with a 128-bit key.
Note that lower numbers of rounds can be used for most
variants if a more aggressive space hardness level is accept-
able to the user.
5.6 Implementation Issues
5.6.1 Implementation in the White Box
In a white-box implementation, F

′
na (x) is implemented by
table look-ups. This is by far the most expensive operation
and the performance of encryption/decryption can be esti-
mated by the number of table look-ups (TL) along with the
table sizes. Such a table consists of 2na entries of nb bits
each, and the table size is T = (2na × nb) bits.

Table 3 shows the performance and the table size for each
recommended variant, where L1-TL, L3-TL, RAM-TL and
HDD-TL denote table accesses to L1/L2 cache, L3 cache,
RAM and HDD, respectively. The sizes of tables in SPACE-
(8, 300), -(16, 128), -(24, 128) and -(32, 128) are suited for
L1/L2 cache (e.g. 32 KB to 256 KB), L3 cache (e.g. 8 MB),
RAM (e.g. a few GB) and HDD (e.g. more than 10 GB),
respectively. Assuming that one random access to the table
stored in L1/L2 cache, L3 cache, RAM and HDD takes 5, 30,
100 and 1000 cycles, the white-box performance of SPACE-
(8, 300), -(16, 128), -(24, 128) and -(32, 128) is roughly esti-
mated as 93, 240, 800 and 8000 cycles per byte, respectively.

For example, SPACE-(16, 128) and the broken white-box
AES by Chow et al. [14] has almost the same code size (suit-
able for L3 cache), but SPACE-(16, 128) is 23 times faster.
A comparison with ASASA constructions will be provided

in Section 5.6.3.

Implementation in the Black Box

5.6.2
In the black-box environment, a compact implementation
is possible for the key owner by decomposing the table for
′
F
na (x). Performance is then estimated by the number of
internal block cipher calls. For SPACE-(8, 300), -(16, 128),
-(24, 128) and -(32, 128), it is 300, 128, 128 and 128 calls,
respectively.

A wide range of implementations is thinkable under the
freedom of choice of the underlying block cipher for SPACE.
With a lightweight block cipher such as PRIDE [1] and
SIMON/SPECK [2] inside, implementations with very low
RAM and code size requirements are possible [18].

If AES-128 is chosen, the implementation can be speeded
up using the AES-NI instructions. For example, on Intel
Haswell, if SPACE is used in a parallel mode such as CTR,
one F-function call would require at most 16 clock cycles.
This yields performance estimates of at most 300, 128, 128
and 128 cycles per byte for SPACE-(8, 300), -(16, 128), -
(24, 128) and -(32, 128), respectively.

While the white-box implementation of SPACE-8 is faster
than its black-box implementation, black-box implementa-
tions of SPACE-(16, 128), -(24, 128) and -(32, 128) with AES-
NI are much faster than those of white-box implementations.

5.6.3 Tradeoff between Performance and Security
The performance of our constructions depends on the num-
ber of rounds R, which in turn is mostly determined by
the desired level of (M, Z)-space hardness. There is an ef-
ﬁcient tradeoﬀ between R and (M, Z)-space hardness. Ta-
ble 4 shows the comparison between SPACE and (broken)
ASASA at similar levels of space hardness, where the max-
imum space hardness stands for the complexity of the basic
compression attack of Section 5.3.2.

At the same level of space hardness, the white-box imple-
mentation of SPACE oﬀers exactly the same performance
as the ASASA constructions. By no means do those num-
bers (T /4, 128) and (T /35, 128) claim white-box security for
the SPACE and ASASA variants in question.

The performance and compressibility of the white-box im-
plementation of (AS)i do not change even if more layers
are added to improve the security. Hence, the ﬁgures for
ASASA-1, 2 and 3 in Table 4 remain valid for any (AS)i.

1065Table 4: Comparison of SPACE and ASASA at sim-
ilar space-hardness levels

Performance

T

Maximum

space hardness

64 L3-TL

SPACE-(16, 64)
918 KB
SPACE-(24, 64) 64 RAM-TL 218 MB
SPACE-(32, 25)
25 HDD-TL 51.5 GB

(T /4, 128)
(T /4, 128)
(T /35, 128)
ASASA-1 [4]
(T /4, 128)
ASASA-2 [4]
64 RAM-TL 384 MB
(T /4, 128)
ASASA-3 [4]
25 HDD-TL 20 GB
(T /35, 128)
ASASA-1 : S-layer consists of 8 × 16-bit
ASASA-2 : S-layer consists of 24-bit + 6 × 16-bit + 8-bit
ASASA-3 : S-layer consists of 4 × 28-bit + 16-bit

64 L3-TL

8 MB

On the other hand, in the black-box implementation of
(AS)i, the number of cycles increases linearly with the num-
ber of rounds. ASASA-1, -2 and -3 do not beneﬁt from
AES-NI unlike SPACE with AES-128. However, since the
S-boxes are 8- or 10-bit, optimizations for L1 cache are pos-
sible for all variants in the black-box environment.
5.7 Strong Space Hardness

Here we discuss an extension of the notion of space hard-

ness that we call strong space hardness:

Definition 4

(Strong (M, Z)-space hardness). An
implementation of a block cipher EK is (M, Z)-space hard if
it is infeasible to obtain a valid plaintext/ciphertext pair with
−Z given the code (table) of size less
probability higher than 2
than M .

The diﬀerence to the notion of space hardness is that the
attacker tries to ﬁnd any valid input/output pair now, not
merely a valid output for a given randomly drawn input.
Strong space hardness is relevant to message authentication
codes in the context of forgeries.

0

ℓ−1

ℓ−1

0, . . . , xr

, . . . , xr+ℓ+1

} and X r+ℓ+1 = {xr+ℓ+1

Let us try to come up with some compression attacks
against strong space hardness for SPACE. If each entry of
ℓ consecutive tables of F r, . . . F r+ℓ is chosen, states X r =
{xr
} are de-
termined. The number of start states consisting of ℓ con-
secutive tables is estimated as (2i)ℓ, where 2i is the num-
ber of known table entries. Thus, the probability of ﬁnd-
ing a valid pair with i ≤ 2na table entries is estimated as
(i/(2na ))R−ℓ×(2i)ℓ, and the time complexity is estimated as
(2i)ℓ. If i < 27.35, 214 and 230 for SPACE-(8, 300), SPACE-
(16, 128) and -(32, 128), the probability becomes less than
−128, where the code size is 2.45 KB, 230 KB and 12.9 GB,
2
respectively. For SPACE-(24, 128), six consecutive tables
are enough to determine states X r and X r+7. If i < 222.95,
−128, where the code size
the probability becomes less than 2
is 105 MB.

This evaluation is a straightforward approach to ﬁnd a
valid plaintext/ciphertext. More sophisticated attacks seem
possible. Thus, we explicitly do not make any security
claims with respect to strong space hardness for SPACE-
(8, 300), SPACE-(16, 128), -(24, 128) and -(32, 128), but the
above values can be considered as upper bounds on the level
of their strong (M, 128)-space hardness.

5.8 Other Constructions

There are other possible constructions suitable to attain
space hardness. For instance, the following design is think-
able, which combines AES in counter mode and the idea of
secret sharing among Nk instances of AES.

Let Si be

Nk⊕

Si =

j=0

AESKj (i||IV ),

where AESKj() denotes an encryption using AES-128 with
the 128-bit key Kj, i is a 64-bit variable and IV is a 64-
bit nonce. Given a 128-bit plaintext Pi, the encryption is
performed as Ci = Pi ⊕ Si, in the stream cipher fashion.
This simple construction achieves (16×Nk bytes, 128)-space
hardness due to fact that it is infeasible to compute Si with-
out the knowledge of all but few key bits. However, it re-
quires Nk AES calls for encrypting a 128-bit plaintext, which
makes its use impractical: For example, in order to achieve
(218 MB, 128)-space hardness, Nk = 13, 625, 000 AES calls
are required.

6. N-SPACE: VARIABLE SPACE

This section presents our second block cipher. It is called
N-SPACE and allows implementations with multiple vari-
able code sizes while keeping the cipher itself unchanged.
6.1 The Design

N-SPACE is an ℓ-line target-heavy generalized Feistel
network with N diﬀerent sizes of F-functions. It encrypts
an n-bit plaintext under N k-bit secret keys to an n-bit
ciphertext as shown in Fig. 7.
Let the n-bit state of round r be X r = {xr
},
ℓ−1
i ∈ {0, 1}n/ℓ. Each round updates the state as follows. If
xr
(r mod N ) = j:

1, . . . , xr

0, xr

(j+1)n/ℓ(X

′r) ⊕ (xr

j+1|| . . .||xr

ℓ−1)

)||xr

0.

′r||(

X r+1 = X

where X

′r = (xr

The instantiation of the cipher with n = 128, ℓ = 16, N =
4, and R rounds is called 4-SPACE-(R) whose round trans-
forms are speciﬁed as follows.
If (r mod N ) = 0:

X r+1 =

0) ⊕ (xr

1|| . . .||xr

ℓ−1)

F r
8 (xr

F r
0|| . . .||xr
j ).
(
1||(
2||(
3||(

24(xr
F r

F r
16(xr

ℓ−1)

0.

)||xr
)||xr
)||xr
)||xr

ℓ−1)

0.

0.

If (r mod N ) = 1:

X r+1 = xr

If (r mod N ) = 2:

X r+1 = xr

1||xr

If (r mod N ) = 3:

0||xr

1) ⊕ (xr

2|| . . .||xr

0||xr

1||xr

2) ⊕ (xr

3|| . . .||xr

0.

1||xr

2||xr

X r+1 = xr

32(xr
F r
The four F-functions F r

0|| . . .||xr
8 (x), F r

3) ⊕ (xr
16(x), F r

4|| . . .||xr
24(x), and F r

ℓ−1)

32(x)
depend on four 128-bit keys, K1, K2 and K3 and K4, respec-
tively. The F-functions of 4-SPACE are based on AES-128
na of SPACE in Section
exactly in the same way as the F r
5.1.

The particularity of 4-SPACE-(R) is that it uses four dif-
ferently sized F-functions F r
32(x).
In the white-box implementation, depending on user re-
quirements for the code size, we can choose which of the

24(x) and F r

16(x), F r

8 (x), F r

1066largest table that will dominate the overall table size. All
other tables are assumed to be available to the attacker in
full. The probability that a random input of the table is
among the known entries is i/(2m), where m is 8, 16, 24
and 32 for 4-SPACE-(R)-8, -16, -24 and -32, respectively.
Given any random plaintext or ciphertext, the correspond-
ing output after R rounds can be computed by using i table
entries with probability of (i/(2m))(R/4). This corresponds
to (i × (n − m) bits, (i/(2m))(R/4))-space hardness.
6.3 Security in the Black Box

−15 (= 2/216), 2

−22.4 (= 3/224) and 2

6.3.1 Differential Cryptanalysis
According to Theorem 1, we assume that the maximum
−7
diﬀerential probabilities of F8, F16, F24 and F32 to be 2
−30.4 (=
(= 2/28), 2
3/232), respectively. Our search for the minimum number of
diﬀerentially active F-functions with the above values of the
diﬀerential probabilities shows that the probability of any
diﬀerential characteristic is expected to become less than
−128 after 48 rounds.
2
6.3.2 Linear Cryptanalysis
Similarly to the evaluation for SPACE, we assume that
linear probabilities of F8, F16, F24 and F32 are upper-bounded
−28, respectively. Our search for
by 2
the minimum number of linearly active F-functions with the
above values of the linear probabilities yields that the prob-
ability of the best linear characteristic becomes less than
−128 after 16 rounds.
2
6.3.3
Any input bit nonlinearly aﬀects all state bits after 17
rounds. With the miss-in-the-middle approach, we have
not found any useful impossible diﬀerentials after about 34
rounds.

Impossible Differential Cryptanalysis

−20 and 2

−12 , 2

−4, 2

6.3.4 Other Attacks
According to the results by Suzaki et al. in [39], after 19
rounds, there is no useful integral distinguisher either. We
also considered other attacks, and we expect that none of
them works signiﬁcantly better than the previously men-
tioned attacks.

6.4 Recommended Number of Rounds

As for SPACE, we recommend to choose the number of
rounds such that the basic white-box compression attack of
Section 6.2.2 covers at most half of the rounds at the level of
(T /4, 128)-space hardness and the best black-box property
in Section 6.3 covers at most half of the rounds. For the
instantiation of 4-SPACE at hand, following this guideline
gives 512 rounds. A less conservative claim for the space
hardness may be acceptable for many users resulting in a
signiﬁcantly lower number of rounds.

For the recommended number R = 512 of rounds, the
claimed white-box security for 4-SPACE is (T /4, 128)-space
hardness, see also Table 5. The claimed black-box security is
that of a 128-bit block cipher with a 128-bit key. We do not
claim any security against combined black- and white-box
attackers.

Figure 7: Ciphers with variable space: N-SPACE

8 (x), F r

16(x), F r

functions F r
32(x) to implement
by table look-ups. We deﬁne four implementation variants:
• 4-SPACE-(R)-32 : All four functions are implemen-

24(x) and F r

tation by table look-ups.

• 4-SPACE-(R)-24 : F

′
8(x), F
plemented by table look-ups.

′
16(x) and F

′
24(x) are im-

• 4-SPACE-(R)-16 : F

′
8(x) and F

′
16(x) are implemented

by table look-ups.

• 4-SPACE-(R)-8 : Only F

′
8(x) is implemented by table

look-ups.

The other respective F-functions are implemented by block
cipher calls with the corresponding keys. 4-SPACE-(R) re-
quires four 128-bit keys: K1, K2, K3 and K4. One can
derive those from a 128-bit master key K using a generic
key derivation function [24, 29].
6.2 Security in the White Box
6.2.1 Key Extraction
As for SPACE, it is hard to extract the key from the table
for an F-function as long as the underlying block cipher EK
is secure against key recovery. In 4-SPACE-(R)-24, -16 and
-8, the attacker can directly observe K4, (K3, K4) and (K2,
K3, K4) from the white-box implementation. However, (K3,
K2, K1), (K2, K1) and K1 are hard to extract, respectively.
6.2.2 Code Lifting
Since the attacker is unable to compute the F-function
without knowing of its key Ki, it is infeasible to ﬁnd a com-
pact representation of any of the variants, as at least one
F-function is implemented by table look-ups.

Let us mount a white-box compression attack and con-
sider the case where i entries of the largest table are isolated
by the attacker. In each implementation variant, it is the

x0r-1x1r-1x2r-1x3r-1xl-1r-1x0r+3x1r+3x2r+3x3r+3xl-1r+3x4r-1x5r-1x4r+3Fr-1F r+1F rF r+2n/ln/l2n/l3n/l4n/l1067Table 5: Performance and table sizes for the four 4-
SPACE implementation variants and recommended
round number: All of them oﬀer exactly the same
functionality

4-SPACE-(512)-8
4-SPACE-(512)-16

128 L1-TL+384 BC
128(L1-TL+L3-TL)+

3.84 KB
918 KB

Performance

T

4-SPACE-(512)-24

4-SPACE-(512)-32

256 BC

128(L1-TL+L3-TL)+ 218 MB
128 RAM-TL+128 BC
128(L1-TL+L3-TL)+ 51.5 GB

128(RAM-TL+HDD-TL)

6.5 Implementation Issues

Table 5 demonstrates the performance and table sizes for
each of the four implementation variants for 4-SPACE. The
sizes of 4-SPACE-(R)-8, -16, -24 and -32 are suited for
L1/L2 cache, L3 cache, RAM and HDD, respectively. All
implementation variants oﬀer exactly the same functional-
ity.

Under the rough assumption that a table access to L1/L2
cache, L3 cache, RAM and HDD costs 5, 30, 100, and 1000
cycles, respectively, and that an AES-128 encryption with
AES-NI takes 16 cycles (in a parallel mode of operation),
the performance of 4-SPACE-(512)-8, -16, -24 and -32 is
approximately evaluated as 424, 536, 1208 and 9080 cycles
per byte.

In the black box, implementations without tables are pos-
sible by decomposing the tables. The performance is then
estimated by the number of block function calls. A combi-
nation of F-functions implemented with table look-ups and
AES-NI is beneﬁcial.

7. CONCLUSIONS

We have opened up a new direction for white-box cryp-
tography, by introducing the idea that white-box security
can rely on key recovery problems for well-analyzed block
ciphers in the standard black-box setting and by propos-
ing the new security notion of (M, Z)-space hardness. This
enables us to demonstrate security against key extraction,
table decomposition and code lifting attacks in the white-
box environment, which have been the crucial limitation of
the published techniques.

As an example, we design the family of block ciphers
SPACE. It includes four variants with diﬀerent but ﬁxed
code sizes, and a variant N-SPACE with variable code sizes
while keeping the cipher itself unchanged.
Acknowledgments
We would like to thank Bart Preneel for his highly valu-
able and constructive feedback, which helped us to improve
the technical and editorial quality of the paper. Moreover,
we would like to thank the anonymous referees for their in-
sightful comments. Among others, we are grateful to the
referee who proposed the secret-sharing based construction
described in Section 5.8.

8. REFERENCES
[1] Martin R. Albrecht, Benedikt Driessen, Elif Bilge
Kavun, Gregor Leander, Christof Paar, and Tolga
Yal¸cin. Block Ciphers - Focus on the Linear Layer
(feat. PRIDE). In Advances in Cryptology - CRYPTO
2014, LNCS, Vol. 8616, pages 57–76, 2014.

[2] Ray Beaulieu, Douglas Shors, Jason Smith, Stefan
Treatman-Clark, Bryan Weeks, and Louis Wingers.
Simon and Speck: Block Ciphers for Internet of
Things. NIST Lightweight Cryptography Workshop
2015, 2015.

[3] Olivier Billet, Henri Gilbert, and Charaf Ech-Chatbi.
Cryptanalysis of a White Box AES Implementation.
In Selected Areas in Cryptography - SAC 2004, LNCS,
Vol. 3357, pages 227–240, 2004.

[4] Alex Biryukov, Charles Bouillaguet, and Dmitry

Khovratovich. Cryptographic Schemes Based on the
ASASA Structure: Black-Box, White-Box, and
Public-Key (Extended Abstract). In Advances in
Cryptology - ASIACRYPT 2014, LNCS, Vol. 8873,
pages 63–84, 2014.

[5] Alex Biryukov, Daniel Dinu, and Dmitry
Khovratovich. Fast and Tradeoﬀ-Resilient
Memory-Hard Functions for Cryptocurrencies and
Password Hashing. Cryptology ePrint Archive, Report
2015/430, 2015.

[6] Alex Biryukov and Dmitry Khovratovich.

Decomposition attack on SASASASAS. Cryptology
ePrint Archive, Report 2015/646, 2015.

[7] Alex Biryukov and Adi Shamir. Structural

Cryptanalysis of SASAS. J. Cryptology, Vol. 23(4),
pages 505–518, 2010.

[8] C´eline Blondeau, Andrey Bogdanov, and Gregor
Leander. Bounds in Shallows and in Miseries. In
Advances in Cryptology - CRYPTO 2013, LNCS, Vol.
8042, pages 204–221, 2013.

[9] Andrey Bogdanov, Dmitry Khovratovich, and

Christian Rechberger. Biclique Cryptanalysis of the
Full AES. In Advances in Cryptology - ASIACRYPT
2011, LNCS, Vol. 7073, pages 344–371, 2011.
[10] Andrey Bogdanov, Florian Mendel, Francesco

Regazzoni, Vincent Rijmen, and Elmar Tischhauser.
ALE: AES-Based Lightweight Authenticated
Encryption. In Fast Software Encryption - FSE 2013,
LNCS, Vol. 8424, pages 447–466, 2013.

[11] Julia Borghoﬀ, Lars R. Knudsen, Gregor Leander, and

Søren S. Thomsen. Slender-Set Diﬀerential
Cryptanalysis. J. Cryptology, Vol. 26(1), pages 11–38,
2013.

[12] Julien Bringer, Herv´e Chabanne, and Emmanuelle

Dottax. White Box Cryptography: Another Attempt.
IACR Cryptology ePrint Archive, 2006:468, 2006.

[13] Stanley Chow, Philip A. Eisen, Harold Johnson, and

Paul C. van Oorschot. A White-Box DES
Implementation for DRM Applications. In Security
and Privacy in Digital Rights Management, ACM
CCS-9 Workshop, pages 1–15, 2002.

[14] Stanley Chow, Philip A. Eisen, Harold Johnson, and
Paul C. van Oorschot. White-Box Cryptography and
an AES Implementation. In Selected Areas in
Cryptography - SAC 2002, LNCS, Vol. 2595, pages
250–270, 2002.

1068[15] Joan Daemen and Vincent Rijmen. The Design of

[30] Wil Michiels. Opportunities in White-Box

Rijndael: AES - The Advanced Encryption Standard.
Information Security and Cryptography. Springer,
2002.

Cryptography. IEEE Security & Privacy, vol. 8(1),
pages 64–67, 2010.

[31] Wil Michiels, Paul Gorissen, and Henk D. L.

[16] Joan Daemen and Vincent Rijmen. Probability

distributions of correlation and diﬀerentials in block
ciphers. J. Mathematical Cryptology, Vol. 1(3), pages
221–242, 2007.

Hollmann. Cryptanalysis of a Generic Class of
White-Box Implementations. In Selected Areas in
Cryptography - SAC 2008, LNCS, Vol. 7707, pages
414–428, 2008.

[17] Patrick Derbez, Pierre-Alain Fouque, and J´er´emy

[32] Brice Minaud, Patrick Derbez, Pierre-Alain Fouque,

Jean. Improved Key Recovery Attacks on
Reduced-Round AES in the Single-Key Setting. In
Advances in Cryptology - EUROCRYPT 2013, LNCS,
Vol. 7881, pages 371–387, 2013.

[18] Daniel Dinu, Yann Le Corre, Dmitry Khovratovich,
Leo Perrin, Johann Grosschadl, and Alex Biryukov.
Triathlon of Lightweight Block Ciphers for the
Internet of Things. NIST Lightweight Cryptography
Workshop 2015, 2015.

[19] Itai Dinur, Orr Dunkelman, Thorsten Kranz, and
Gregor Leander. Decomposing the ASASA Block
Cipher Construction. Cryptology ePrint Archive,
Report 2015/507, 2015.

[20] Orr Dunkelman, Nathan Keller, and Adi Shamir.

Improved Single-Key Attacks on 8-Round AES-192
and AES-256. J. Cryptology, Vol. 28(3), pages
397–422, 2015.

[21] Christian Forler, Stefan Lucks, and Jakob Wenzel.

Memory-Demanding Password Scrambling. In
Advances in Cryptology - ASIACRYPT 2014, LNCS,
Vol. 8874, pages 289–305, 2014.

[22] Henri Gilbert, J´erˆome Plˆut, and Joana Treger.

Key-Recovery Attack on the ASASA Cryptosystem
with Expanding S-Boxes. In Advances in Cryptology -
CRYPTO 2015, LNCS, Vol. 9215, pages 475–490,
2015.

[23] Mohamed Karroumi. Protecting White-Box AES with
Dual Ciphers. In Information Security and Cryptology
- ICISC 2010, LNCS, Vol. 6829, pages 278–291, 2010.

[24] Hugo Krawczyk. Cryptographic extraction and key

derivation: The HKDF scheme. In Advances in
Cryptology - CRYPTO 2010, LNCS, Vol. 6223, pages
631–648, 2010.

[25] Tancr`ede Lepoint, Matthieu Rivain, Yoni De Mulder,

Peter Roelse, and Bart Preneel. Two Attacks on a
White-Box AES Implementation. In Selected Areas in
Cryptography - SAC 2013, LNCS, Vol. 8282, pages
265–285, 2013.

[26] Hamilton E. Link and William D. Neumann.

Clarifying Obfuscation: Improving the Security of
White-Box DES. In International Symposium on
Information Technology: Coding and Computing -
ITCC 2005, IEEE Computer Society, Vol. 1, pages
679–684, 2005.

[27] Marlin Developer Community. Marlin architecture

overview. http://www.marlin-community.com, 2011.
[28] NIST Special Publication 800-38B. Recommendation

for Block Cipher Modes of Operation: The CMAC
Mode for Authentication. 2005.

[29] NIST Special Publication (SP) 800-108.

Recommendation for Key Derivation Using
Pseudorandom Functions. 2009.

and Pierre Karpman. Key-Recovery Attacks on
ASASA. Cryptology ePrint Archive, Report 2015/516,
2015.

[33] Yoni De Mulder. White-Box Cryptography: Analysis
of White-Box AES Implementations. PhD thesis, KU
Leuven, 2014.

[34] Yoni De Mulder, Peter Roelse, and Bart Preneel.
Cryptanalysis of the Xiao - Lai White-Box AES
Implementation. In Selected Areas in Cryptography -
SAC 2012, LNCS, Vol. 7707, pages 34–49, 2012.

[35] Yoni De Mulder, Brecht Wyseur, and Bart Preneel.

Cryptanalysis of a Perturbated White-Box AES
Implementation. In Progress in Cryptology -
INDOCRYPT 2010, LNCS, Vol. 6498, pages 292–310,
2010.

[36] Jacques Patarin, Val´erie Nachef, and Cˆome Berbain.
Generic Attacks on Unbalanced Feistel Schemes with
Expanding Functions. In Advances in Cryptology -
ASIACRYPT 2007, LNCS, Vol. 4833, pages 325–341,
2007.

[37] Colin Percival. Stronger Key Derivation via Sequential

Memory-Hard Functions. presented at BSDCan’09,
2009.

[38] Bruce Schneier and John Kelsey. Unbalanced Feistel
Networks and Block Cipher Design. In Fast Software
Encryption - FSE 1996, LNCS, Vol. 1039, pages
121–144, 1996.

[39] Tomoyasu Suzaki and Kazuhiko Minematsu.

Improving the Generalized Feistel. In Fast Software
Encryption - FSE 2010, LNCS, Vol. 6147, pages
19–39, 2010.

[40] Tyge Tiessen, Lars R. Knudsen, Stefan Kolbl, and

Martin M. Lauridsen. Security of AES with a Secret
S-box . In the preproceedings of FSE 2015, 2015.

[41] Emmanuel Volte, Val´erie Nachef, and Jacques Patarin.

Improved Generic Attacks on Unbalanced Feistel
Schemes with Expanding Functions. In Advances in
Cryptology - ASIACRYPT 2010, LNCS, Vol. 6477,
pages 94–111, 2010.

[42] Brecht Wyseur. White-Box Cryptography. PhD thesis,

KU Leuven, 2009.

[43] Brecht Wyseur, Wil Michiels, Paul Gorissen, and Bart

Preneel. Cryptanalysis of White-Box DES
Implementations with Arbitrary External Encodings.
In Selected Areas in Cryptography - SAC 2007, LNCS,
Vol. 4876, pages 264–277, 2007.

[44] Yaying Xiao and Xuejia Lai. A Secure Implementation

of White-box AES. In 2nd International Conference
on Computer Science and its Applications - CSA
2009, pages 1–6, 2009.

1069