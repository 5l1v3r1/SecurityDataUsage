VD-PSI: Veriﬁable Delegated Private Set Intersection on

Outsourced Private Datasets

Aydin Abadi, Sotirios Terzis, and Changyu Dong

Department of Computer and Information Sciences, University of Strathclyde, Glasgow, UK

firstname.surname@strath.ac.uk

Abstract. Private set intersection (PSI) protocols have many real world applica-
tions. With the emergence of cloud computing the need arises to carry out PSI on
outsourced datasets where the computation is delegated to the cloud. However,
due to the possibility of cloud misbehaviors, it is essential to verify the integrity
of any outsourced datasets, and result of delegated computation. Veriﬁable Com-
putation on private datasets that does not leak any information about the data is
very challenging, especially when the datasets are outsourced independently by
different clients. In this paper we present VD-PSI, a protocol that allows mul-
tiple clients to outsource their private datasets and delegate computation of set
intersection to the cloud, while being able to verify the correctness of the re-
sult. Clients can independently prepare and upload their datasets, and with their
agreement can veriﬁably delegate the computation of set intersection an unlim-
ited number of times, without the need to download or maintain a local copy of
their data. The protocol ensures that the cloud learns nothing about the datasets
and the intersection. VD-PSI is efﬁcient as its veriﬁcation cost is linear to the in-
tersection cardinality, and its computation and communication costs are linear to
the dataset cardinality. Also, we provide a formal security analysis in the standard
model.

1

Introduction

Private set intersection (PSI) allows parties to compute the intersection of their datasets
without revealing anything about the data beyond the intersection [11]. PSI has a variety
of real world applications like privacy preserving data mining [2], homeland security
[7], etc. Over the years, due to its importance researchers have designed a number of
PSI protocols [22, 9, 28, 18, 20, 23, 21, 29]. However, these typically require parties to
jointly compute the intersection with locally available datasets. With the growing im-
pact of cloud computing on businesses, due to its economic beneﬁts [25], the need arises
to delegate PSI computation on outsourced datasets to the cloud [1, 18].

Cloud computing offers ﬂexible and cost effective storage and computation re-
sources to clients. Nevertheless, past real-world incidents [5] and recent research (see
[17, 4] for surveys) have shown that the cloud cannot be fully trusted and it may misbe-
have by exposing or tampering with clients’ sensitive data, or ﬁddling with computation
results. These misbehaviors can have a serious impact on businesses. So, it is essential
for clients not only to protect the conﬁdentiality of their outsourced data, but also to ver-
ify the integrity of the data and the result of the computation delegated to the cloud. In
other words, there is a pressing need for veriﬁable delegated PSI on outsourced private
datasets.

Verifying the integrity of computation while preserving the conﬁdentiality of the
data is particularly challenging. This is even more the case when the data are outsourced
independently by different owners, and the data integrity is also a concern. Beyond pro-
tecting the conﬁdentiality, and verifying the integrity of any outsourced data and dele-
gated computation, there is a need for a mechanism that ensures outsourced data cannot
be used without the owner’s permission. But, this mechanism should not restrict the
particular clients that may come together to compute the intersection of their datasets,
by requiring that they are speciﬁed in advance; also it should not constraint the number
of clients that come together or the number of intersections that may be performed.

In this paper we present VD-PSI, a protocol that supports efﬁcient veriﬁable dele-
gated PSI on outsourced private datasets and satisﬁes the above requirements. VD-PSI
allows the result recipient to check whether the computation was performed correctly
on the requested intact datasets, without having to keep a local copy of the data, or
having any knowledge of the other clients’ data. The protocol imposes minimal com-
putational overheads to the veriﬁer (i.e. at most linear to the intersection cardinality).
It allows clients to independently prepare and upload their private datasets. It ensures
that outsourced datasets can only be used with the owner’s permission. It supports mul-
tiple clients who can veriﬁably delegate PSI computation an unlimited number of times
with no need to download or re-encode their outsourced data. Moreover, it achieves
all that while ensuring that the result recipient learns nothing beyond the intersection
about the other clients’ datasets, and the cloud learns nothing about the datasets and the
intersection. The computation and communication costs of VD-PSI are linear to the set
cardinality.

The rest of the paper starts with a survey of related work in section 2, while section
3 deﬁnes our security model and key concepts we rely on. Section 4 presents the design
of our protocol and its extension, while section 5 proves its security. Section 6 presents
an analysis of the protocol’s overheads and a comparison to work closest to it. Finally,
section 7 concludes the paper and identiﬁes directions for future work.

2 Related Work

Veriﬁable delegated PSI can be built either on top of generic veriﬁable computation pro-
tocols or as a standalone operation speciﬁc veriﬁable protocol. Veriﬁable computation
(VC) protocols allow a computationally weak client to securely delegate computation
of a function to a powerful but untrusted server. In this setting, the client can detect if
the server provides an incorrect result.

We ﬁrst consider generic VC protocols. A number of protocols such as [15, 14] are
designed to address the VC problem, where [15] is based on the concept of ringers,
and [14] uses the argument system and relies on private information retrieval. However,
they do not preserve the privacy of client data. As a result, the server may misbehave
and expose sensitive client data, i.e. the input and output of the computation. Other
protocols like [12] which uses fully homomorphic encryption (FHE) and Yao’s garbled
circuits, and [10] based on FHE and a homomorphic hashing technique, preserve the
privacy of client data; but, they have been designed for single-client scenarios.

There are practical scenarios in which multiple clients, who mutually distrust each
other, want to veriﬁably delegate computation to a server. In this case, the computation
should be veriﬁable and a client’s data should be protected from the other clients who
receive the result. These requirements integrate secure multi-party computation (MPC)
with VC. In secure MPC protocols, clients (jointly) perform some computation without
revealing to each other their private inputs. There are two protocols for such scenarios,
[6] based on Yao’s garbled circuits, FHE and non-interactive proxy oblivious transfer,
and [16] based on the same building blocks plus multi-sender attribute-based encryp-
tion. These protocols do not require clients to directly interact with each other at setup.
Nonetheless, they do not support outsourced data as they require each client to know the
public keys of all other clients when preparing its private data. Consequently, changing
the participating clients requires outsourced data to be downloaded and re-prepared.

The protocol in [24] also supports veriﬁable multi-client delegated generic compu-
tation, and allows clients to independently outsource their private data. In this protocol,
clients do not need to interact during setup, but they have to interactively decrypt the
result when receiving it. Although this protocol satisﬁes all the requirements set out
in section 1, it is not computationally efﬁcient as it is based on (multi-key) fully ho-
momorphic encryption and expensive generic zero-knowledge proofs. Moreover, the
protocol is not suitable when the number of inputs is large, as in order to verify the
result correctness a client needs to access all the (hash values of) encrypted inputs.

We now turn our attention to protocols designed speciﬁcally for PSI. PSI was ﬁrst
introduced in [11] based on additive homomorphic encryption and polynomial repre-
sentation of sets. Over the years, some efﬁcient protocols, like [9, 28, 27], have been
proposed. However, they are interactive in the sense that the clients jointly compute the
intersection of their sets. Thus, they need to have a local copy of their sets to compute
the set intersection. A number of protocols that support delegation of PSI to a server
are proposed in [18, 20, 23, 21, 29, 1]. Among them only [1], which is mainly based on
point-value polynomial representation of sets and additive homomorphic encryption,
supports delegation of both storage and the computation to the cloud, and is fully pri-
vate. However, it only considers a semi-honest adversary. As a result, the clients cannot
verify the correctness of the computation. The only protocols that support veriﬁable
delegated PSI are in [29, 18]. In the former, a client encrypts his data and uses tags
based on bilinear maps for veriﬁcation. However, as it is shown in [1], it is not fully pri-
vate and leaks information about the intersection to the server. The latter is based on a
pseudo-random function, whose key is generated jointly by the clients prior to encoding
the data and detects server misbehavior at the cost of replicating a number of times all
elements of the sets. Although the protocol is efﬁcient, it does not support outsourced
data.

From the above discussion, it should be clear that neither PSI protocols nor most of
generic computation protocols can meet all our requirements. Only [24] meets all the
requirements, but it is not efﬁcient. So, the quest for efﬁcient veriﬁable delegated PSI
on outsourced private datasets remains open.

3 Preliminaries

3.1 Security Model

We consider a static adversary who controls one of the parties at a time. The deﬁnition
and model are according to [13]. Without loss of generality we consider the three party
case where a cloud C, and two clients, A and B are involved. We allow an adversary
who corrupts C to be malicious. So, it may arbitrarily deviate from the prescribed pro-
tocol, but it does not collude with the clients. This is a reasonable assumption as it is
usually a well-established company and does not want to jeopardize its reputation by
colluding with others. The non-colluding assumption is well-accepted and widely used
in the literature [18, 16]. Moreover, we allow an adversary who corrupts a client to be
semi-honest.
We deﬁne a three-party protocol π computing function F where F : Λ× 2U × 2U →
Λ×Λ×f∩. Here, Λ denotes the empty string, 2U denotes the powerset of the set universe
and f∩ denotes the set intersection function. For every tuple of inputs Λ, SA and SB
belonging to C, A and B respectively, the function outputs nothing to C and A, and
outputs f∩(SA, SB) = SA ∩ SB to B. To show the protocol is secure, we deﬁne an ideal
model, which satisﬁes all the security needs. In the ideal model, there is an incorruptible
trusted third party (T T P ) which helps with the functionality. The protocol is said to be
secure if for every adversary in the real model there is an adversary in the ideal model
that can simulate the real adversary.
Real Model: Here, protocol π is executed between parties A, B, C and an adversary
denoted by R that is allowed to corrupt one party. In the beginning of the protocol, each
party I ∈ {A, B} receives its private input SI, the protocol’s public parameters, random
coins r, and an auxiliary input z, while the cloud C receives the public parameters, a
set of random coins r, and an auxiliary input z. At the end of the execution, an honest
party outputs whatever is prescribed by the protocol and the adversary outputs its view.
The joint output of the real model execution of π between the parties in the presence of
the adversary R is deﬁned as REALπ,R(z)(Λ, SA, SB).
Ideal Model: The ideal model takes place between parties A, B, C and a simulator
SIM that is allowed to corrupt at most one party at a time. Each party receives the
same input as the corresponding party in the real model. An honest party always sends
its input to the T T P . The corrupted party may abort or send arbitrary input. The cloud,
C, receives d (i.e. d ≥ |SI|, I ∈ {A, B}) from the T T P . The T T P computes the set
intersection and sends the result to B. If the T T P receives an abort message as an input,
it sends B the special symbol ⊥. The joint output of the parties in the ideal model in
the presence of SIM is deﬁned as IDEALF,SIM (z)(Λ, SA, SB).

Deﬁnition 1. Let π be a protocol and F a deterministic function deﬁned as above.
Protocol π is said to securely compute F in the presence of static adversaries if for
every probabilistic polynomial time (P P T ) adversary R in the real model, there exists
a P P T adversary SIM in the ideal model such that ∀I, I ∈ {A, B, C} :

IDEALF,SIM I (z)(Λ, SA, SB)

c≡ REALπ,RI (z)(Λ, SA, SB)

3.2 Additively Homomorphic Encryption

A semantically secure additively homomorphic encryption has the following properties:
(a) Given two ciphertexts Epk(a), Epk(b), Epk(a) · Epk(b) = Epk(a + b).
(b) Given a ciphertext Epk(a) and a constant b, Epk(a)b = Epk(a · b).
One such scheme is the Paillier public key cryptosystem [26]. It works as follows:
Key Generation: Choose two random large primes q1 and q2 according to a given
security parameter, and set N = q1 · q2. Let u be the Carmichael value of N, i.e.
u = lcm(q1 − 1, q2 − 1) where lcm stands for the least common multiple. Choose
a random g ∈ Z∗
N 2, and ensure that s = (L(gu mod N 2))−1 mod N exists where
L(x) = (x−1)
Encryption: To encrypt a plaintext m ∈ ZN, pick a random value r ∈ Z∗
N, and compute
the ciphertext: C = Epk(m) = gm · rN mod N 2.
Decryption: To decrypt a ciphertext C, Dsk(C) = L(C umod N 2) · s mod N = m.

N . The public key is pk = (N, g) and the secret key is sk = (u, s).

3.3 Representing Sets by Polynomials

ρ(x) =(cid:81)d

j = a||b and h’s output size, one can parse s(cid:48)

Polynomial representation of sets was introduced in [11] and is widely used [22, 8, 1].
For the universe of set elements, U, we can deﬁne a public ﬁnite ﬁeld R = Fp that
is big enough to encode all elements in U. Also, the ﬁeld is big enough that when an
element is picked uniformly at random from it, the probability that the value belongs to
the universe is negligible. Then, we can deﬁne a polynomial ring R[x], which consists
of all polynomials with coefﬁcients from R. We can represent a set, S, by polynomial
i=1(x − si), where si ∈ S,|S| = d and ρ(x) ∈ R[x]. The polynomial has
the property that every element si ∈ S is a root of it. Furthermore, we can always
i = si||h(si), where h is a cryptographic hash function, so that
encode every si as s(cid:48)
given s(cid:48)
j into a and b, and check b ?= h(a).
For two sets SA and SB represented by polynomials ρA and ρB respectively, poly-
nomial ρA · ρB represents the set union, SA ∪ SB, and gcd( ρA , ρB) represents the set
intersection, SA∩SB, where gcd stands for the greatest common divisor. For two degree
d polynomials ρA and ρB, and two degree d polynomials γA and γB picked uniformly
at random from R[x], it is proven in [22] that γA · ρA + γB · ρB = µ· gcd(ρA, ρB) where
µ is a uniformly random polynomial. This means that if ρA and ρB are polynomials
representing sets SA and SB, then the polynomial ρC = γA · ρA + γB · ρB contains
only information about SA ∩ SB and no information about other elements in SA or SB.
Given polynomial ρC, to ﬁnd the intersection, one can extract the polynomial’s roots1
and consider the roots that have the above structure (si||h(si)) as the intersection.
Based on the theorem of the interpolating polynomial, for a set {(x1, y1), ..., (xn, yn)}
with xi distinct, there exists a unique polynomial ρ(x) of degree at most n− 1 such that
∀i, 1 ≤ i ≤ n : yi = ρ(xi). Therefore, ρ(x) can be represented by the n pairs (xi, yi).
If the xi values are ﬁxed and public, we can represent the polynomial as a vector of
y-coordinates, #»y = [y1, ..., yn].

1 To ﬁnd the roots of a polynomial over a ﬁnite ﬁeld, we can ﬁrst factorize it to get a set of monic
polynomials (see [19] for some algorithms), then ﬁnd the monic polynomials’ roots.

Polynomial arithmetic in point-value representation can be done by adding or mul-
tiplying the corresponding y-coordinates. The key beneﬁt of point-value representation
is that multiplication complexity is O(d); whereas, multiplying polynomials in coefﬁ-
cient form has O(d2) complexity. We can convert a polynomial in point-value form to
regular coefﬁcient form, using polynomial interpolation [3].

4 The Proposed Scheme: VD-PSI

4.1 An Overview of VD-PSI

We give an overview of the protocol and depict the interaction between parties in Fig
1. Without loss of generality, we consider two clients A and B. At setup, each client
independently encodes, blinds, and stores his dataset in the cloud. Later on, when client
B becomes interested in the intersection of his dataset and client A’s, he obtains her
permission by sending a message to her. Client A authorizes the computation by using
the message sent by client B to compute a new message that she sends to the cloud. The
cloud uses the message and the clients’ outsourced datasets to compute the intersection,
and sends the result to client B. Client B, decodes the cloud’s response, retrieves the
intersection and checks its correctness. If the result was correct the client accepts it.

Fig. 1: The left-hand side ﬁgure: parties interaction at data outsourcing phase; the right-
hand side ﬁgure: parties interaction at computation delegation phase.

The main novelty of VD-PSI is a lightweight veriﬁcation mechanism that allows a
client to efﬁciently verify the correctness of the result without having access to his own
outsourced dataset and having any knowledge of the other client’s dataset. To achieve
this, when the clients decide to delegate the computation of the set intersection, they
agree on a secret value β and encode β in a way that reveals nothing to the cloud, then
send the encoded β to the cloud. When computing the intersection, the cloud uses the
clients’ outsourced datasets and the encoded β. If the cloud computes honestly, value β
will be inserted into the intersection. Since the outsourced data is blinded, when client

(3) (2) (1) Client AClient BClient AClient BStores Private DatasetStores Private DatasetAuthorizes the ComputationObtains PermissionSends ResultB receives the result from the cloud, he needs to unblind it to get the intersection. If
the cloud misbehaves or tampers with the result, then after unblinding client B gets
a random set, which will not contain β. Thus, by checking whether β is included in
the result set, client B knows whether the result set is correct. The veriﬁcation is very
lightweight because the only overhead is to check whether β is included in the result set.

4.2 VD-PSI Protocol

Without loss of generality, ﬁrst we consider the two-client case, where client A, client
B and a cloud engage in the protocol. We denote the multiplicative inverse and additive
inverse of value hi, by (hi)−1and (−hi), respectively. We use EpkI (hi) and DskI (hi)
to say that value hi is encrypted using client I’s public key, and decrypted using his
secret key, respectively.

1. Cloud-Side Setup. The cloud picks a public parameter d that is an upper bound of
the set cardinality. It constructs a ﬁnite ﬁeld Fp, where p is a large prime number. It
also constructs a vector #»x containing n = 2d + 3 distinct non-zero xi values ran-
domly picked from Fp. It picks a pseudo-random function f : {0, 1}m ×{0, 1}l →
Fp, which takes an l-bit key (i.e. where l is the security parameter) and an m-bit
message, and maps the message to an element in the ﬁeld pseudo-randomly. The
cloud publishes the description of the ﬁeld, the value n, the vector #»x along with
the pseudo-random function f.
2. Client-Side Setup and Data Outsourcing. Let client I ∈ {A, B} have a set SI,
where SI ⊂ U and |SI| ≤ d. Both clients do the following tasks:
(a) Compute a key pair (pkI, skI) for Paillier encryption and publish the public
for the pseudo-random

key pkI. Pick two random private keys, k(I)
function f. All keys are generated according to given security parameters.

and k(I)
(b) Generate a polynomial representation of the set. ∀s(I)

z

r

i ∈ SI:

τI(x) =(cid:81)|SI |

i=1 (x − s(I)
i ).

(c) Convert the polynomial into point-value form by evaluating τI(x) at every ele-

ment xi in vector #»x. This yields values τI(xi), where 1 ≤ i ≤ n.
(d) Blind every τI(xi) by ﬁrst computing pseudo-random values r(I)

i = f (k(I)

r , i)

· (τI(xi) + z(I)
i ).

and z(I)

(e) Send the blinded dataset #»o (I) = [o(I)

z , i), and then computing o(I)
1 , ..., o(I)

i = r(I)
n ] to the cloud.

i = f (k(I)

i

3. Set Intersection: Computation Delegation. In this phase, client B is interested in

the intersection of his set and client A’s.
(a) Client B picks a uniformly random value β R← F∗

p that will be inserted into the
, k(B)
that are used to

b

a

and k(B)
r(cid:48)

two datasets and chooses three fresh keys k(B)
blind the messages sent by client A to the cloud.
(b) Client B constructs a vector #»e (B) that will be used by client A to ask the
cloud to insert β to her dataset and switch her blinding factors. ∀i, 1 ≤ i ≤ n:
i = EpkB (σ(xi) · r
are the
e(B)
(cid:48)(B)
blinding factors used by client B in step 2d and r
i = f (k(B)
r(cid:48)
, k(B)
r(cid:48)

(c) Client B sends to client A: #»e (B), β, k(B)
(d) Client A generates #»v (A) and #»v (B) that allow the cloud to multiply each client
dataset by a random polynomial and insert β to it. Also, #»v (A) allows the cloud

), where σ(xi) = (xi − β), values r(B)

, and his ID, ID(B).

· r(B)

, k(B)

, k(B)

, i).

(cid:48)(B)

a

z

b

i

i

i

to switch the blinding factors of client A’s dataset. ∀i, 1 ≤ i ≤ n:

v(A)
i = (e(B)

i

)ωA(xi)·(r(A)
· r(cid:48)(B)

i

)−1
· ωA(xi) · σ(xi) · (r(A)

i

)−1)

= EpkB (r(B)

i

i = ωB(xi) · σ(xi) · r(cid:48)(B)
v(B)

i

i

(cid:48)(B)
i = f (k(B)
r(cid:48)

, i), key k(B)

are the
where r
blinding values used by client A in step 2d, ωA(x) and ωB(x) are two random
polynomials of degree d + 1 and σ(x) = (x − β).
(e) Client A generates #»v (cid:48)(A) and #»v (cid:48)(B) to allow the cloud to preserve the correct-
ness of the result. ∀i, 1 ≤ i ≤ n:

r(cid:48) was sent by client B in step 3c, r(A)

i

v(cid:48)(A)
i = (e(B)

i

i

)ωA(xi)·(−z(A)
) · r(B)
)ωB (xi)·(−z(B)
) · r(B)

i

i

= EpkB ((−z(A)

i

v(cid:48)(B)
i = (e(B)
· r

i

= EpkB ((−z(B)

i

)+ai

)+bi

· r(cid:48)(B)

i

· ωA(xi) · σ(xi) + ci)

· r(cid:48)(B)

· ωB(xi) · σ(xi) + di)

(cid:48)(B)

· σ(xi), di = bi · r(B)
where ci = ai · r(B)
bi = f (k(B)
the values used by client I ∈ {A, B} in step 2d.

, i),
are
(f) Client A sends to the cloud: #»v (A), #»v (cid:48)(A), #»v (B), #»v (cid:48)(B), ID(B), ID(A), and a re-

· σ(xi), ai = f (k(B)
sent by client B in step 3c, and z(I)

, i), the keys k(B)

and k(B)

· r

(cid:48)(B)

a

a

b

b

i

i

i

i

i

i

i

quest message Compute.

4. Set Intersection: Cloud-Side Computation.

i

i

i

(cid:48)(B)

· r

· v

)o(A)

(a) When the cloud receives client A’s message, it uses #»v (A), #»v (cid:48)(A) and client A’s
outsourced dataset #»o (A) to switch the dataset blinding factors, insert β to the
dataset, and multiply it by a random polynomial; this results #»
∀i, 1 ≤ i ≤ n: t(C1 )
EpkB (r(B)

i = (v(A)
· ωA(xi) · σ(xi) · τA(xi) + ci).

(b) The cloud uses #»o (B), #»v (B), #»v (cid:48)(B) to insert β into client B’s dataset, and multi-

(cid:48)(A)
i =

ply it by a random polynomial. This yields #»
∀i, 1 ≤ i ≤ n: t(C2 )
· o(B)
EpkB (r(B)

t (C2 ).
i = v
) =
· ωB(xi) · σ(xi) · τB(xi) + di).

· r
t (C3). ∀i, 1 ≤ i ≤ n: t(C3 )
ﬁnal result #»
(cid:48)(B)
· r
EpkB (r(B)

(c) The cloud combines the values computed in steps 4b and 4a to produce the
· (ωB(xi)· σ(xi)· τB(xi) + ωA(xi)· σ(xi)· τA(xi)) + ci + di).

· EpkB (v(B)

· t(C2 )
i =

i = t(C1 )

t (C1).

(cid:48)(B)

(cid:48)(B)

i

i

i

i

i

i

i

i

i

(d) The cloud sends to client B vector #»

t (C3 ).

5. Set Intersection: Client-Side Result Veriﬁcation and Retrieval.

(a) Client B obtains #»g by decrypting the cloud’s response #»

ing the decrypted values using his knowledge of (−ci), (−di), (r(B)
(cid:48)(B)
(r
i

)−1. ∀i, 1 ≤ i ≤ n:

t (C3), and unblind-
)−1 and

i

gi = (DskB (t(C3)

)−1 · (r(cid:48)(B)
= ωB(xi) · σ(xi) · τB(xi) + ωA(xi) · σ(xi) · τA(xi).

) + (−ci) + (−di)) · (r(B)

i

i

i

)−1

(b) Client B interpolates a polynomial, φ(x), using the n point-value pairs (xi, gi),
extracts its roots, and checks whether β is among them. If it is, he considers
the rest of the roots as elements of the intersection; otherwise, he aborts.
· (τI(xi) + z(I)

Remark 1. In step 2d, client I ∈ {A, B} blinds his private data τI(xi) as o(I)
r(I)

i =
i ) to preserve their privacy and to detect unauthorized modiﬁca-

i

i

tions. If the client does not blind τI(xi), the cloud can interpolate the polynomial
τI(x) and ﬁnd the client’s set elements. After blinding, every o(I)
is a uniformly
random value and does not leak any information about τI(xi). If the cloud changes
a subset of elements in #»o (I), in step 5b the corresponding values in #»g become
uniformly random. As a result, the polynomial interpolated using the n pairs of
(xi, gi) will not have root β (with a high probability), and the client will detect the
misbehavior. The same also occurs if the cloud deviates from the protocol.
Remark 2. We set n = 2d + 3, because in step 5b, polynomial φ(x) is of degree
2d + 2 and at least 2d + 3 pairs of (xi, yi) are required to interpolate it. Therefore,
given n pairs of (xi, yi), computed correctly, client B can always interpolate φ(x).
Remark 3. In section 3.3, we saw that the set of all roots of polynomial ωB(x) ·
τB(x) + ωA(x) · τA(x) is SA ∩ SB. Note that β is also a root of the polynomial
φ(x) = σ(x) · (ωB(x) · τB(x) + ωA(x) · τA(x)), where σ(x) = x − β. Hence, in
the protocol, a correctly computed result always contains value β.
Remark 4. Since for each computation, the fresh random polynomials ωA(x) and
ωB(x) are used, the result recipient cannot ﬁnd out anything beyond the intersec-
tion about the other client’s set. Also, the cloud cannot learn the exact number of
elements in the set; it only knows the upper bound of the set cardinality (i.e. d).
Remark 5. Every client I, after outsourcing his private dataset needs to keep locally
z . Moreover, client B who is interested in the
and k(I)
only two secret keys, k(I)
result generates keys k(B)
, k(B)
, k(B)
and value β on the ﬂy for each run of the
r(cid:48)
protocol and he can discard them after it ends. Furthermore, given p each client
I can always generate his own public key NI independently, such that NI > p +
2p2+p3 to preserve the computation correctness (i.e. to prevent any overﬂow during
homomorphic operations). To determine the lower bound of NI, we can calculate
the maximal value that message mi in E(mi) may have as a result of homomorphic
operations in the protocol (here, by E(mi) we mean encryption of message mi).
To do so, we start from step 3b and calculate the upper bound of value mi in each
i ∈ Fp). We continue this up to step 4d and then we set the lower
step (note that o(I)
bound of NI to the maximal upper bound of mi, that is p + 2p2 + p3.
Remark 6. We stress that the clients’ outsourced datasets remain unchanged. Also,
at the end of protocol all parties can discard all intermediate messages received.

a

r

b

4.3 Multiple Clients
With minor modiﬁcations two-client VD-PSI can be turned into q-client VD-PSI,
where q > 2. Below we outline how this can be done. We denote the result recipient
by client B and the other clients by Aj (∀j, 1 ≤ j ≤ m), where m = q − 1.
More speciﬁcally, in step 3c, client B sends to every client Aj the same message.
Each client Aj takes the same steps described above, except step 3d, where she
replaces #»v (B) with #»v (B)
B(x) is the
random polynomial picked by client Aj.
In step 4b, the cloud computes #»
Ak, and only using her vectors #»v (B)
the other clients Aj,∀j, 1 ≤ j ≤ m, j (cid:54)= k. As a result ∀i, 1 ≤ i ≤ n: t(C2)
(cid:48)(B)
v

t (C2), by selecting one of the clients, say client
generated by
k , #»v
=
· ωk

B(xi) · σ(xi) · τB(xi) + di).

B(xi) · σ(xi) · r

, discarding #»v (B)

i = EpkB (r(B)

· (v(B)

k,i )o(B)

, v(B)

j,i = EpkB (ωj

), where ωj

, #»v

j

(cid:48)(B)

· r

i

(cid:48)(B)

k

(cid:48)(B)

(cid:48)(B)

i

j

j

k,i

i

i

t (C2 ) · (cid:81)

#»

#»

i

i

i

(cid:48)(B)

i

)−1

1≤j≤m

(cid:48)(B)

i

1≤j≤m

t (C1)

j

i =

A(xi)))

)−1 · (r

t (C3) =

B(xi)·σ(xi)·τB(xi)+ (cid:80)

, ∀i, 1 ≤ i ≤ n: t(C3)
A(xi)·σ(xi)·τ j
ωj

) + m · (−ci) + (−di)) · (r(B)

In step 4c, the cloud computes #»
·(ωk
·r
EpkB (m·ci+di+(r(B)
and sends it to client B.
Finally, in step 5a, client B computes #»g as follows. ∀i, 1 ≤ i ≤ n:
gi = (DskB (t(C3)
The rest of the steps remain unchanged.
Remark 1: In the multi-client case, each client encrypts elements of vector #»v (B)
;
whereas, in the two client case it does not need to do that. Nonetheless, regardless
of the number of clients, every client’s computation complexity is linear to the set
cardinality.
Remark 2: Veriﬁcation complexity at the veriﬁer side is independent of the num-
ber of clients. Also, the number of messages every client, except the client who is
interested in result, sends and receives is independent of the number of clients, too.
The client who is interested in the result sends the same message to all other clients.
Remark 3: The security model we consider in this paper can be easily extended to
the multi-client case, security analysis of the multi-client case remains the same as
the two client case and we do not include it for the sake of brevity.

j

5 Proof of Security

In this section we sketch the security proof of the protocol. To this end, ﬁrst we
show that the cloud’s misbehaviors can be detected with high probability, then we
provide the main theorem.
Recall, the client encodes his set as blinded y-coordinates having the following
form: oi = ri · (τ (xi) + zi), where oi (cid:54)= 0, ri = f (kr, i) and zi = f (kz, i). If
oi = 0 the client replaces kr and kz with new random keys and encodes τ (xi)
again until ∀i, 1 ≤ i ≤ n : oi (cid:54)= 0. Note, oi is uniformly distributed in F∗
p. We can
show that if the cloud applies any change to oi, this will make the y-coordinate a
uniformly random value.
Lemma 1. Given oi = ri · (τ (xi) + zi), where ri and zi are two independent
pseudo-random values that are unknown to the cloud, if the cloud changes oi to o(cid:48)
i,
i − zi becomes a uniformly random value.
· o(cid:48)
then τ(cid:48)(xi) = r−1
Proof. When oi (cid:54)= o(cid:48)
i, τ(cid:48)(xi) is a uniformly random value in Fp, because ri and zi
are picked uniformly at random and independently of each other.
In step 5a of the protocol, client B after decrypting the server’s response obtains
blinded values of the form pi = ei · gi + zi, where ei and zi are pseudo-random
values. If the cloud misbehaves (e.g. deviates from the protocol, modiﬁes the out-
sourced client datasets, etc), some pi are changed to p(cid:48)
i, and Lemma 1 implies that
i − zi) will be a uniformly random value. So, any cloud misbehavior
g(cid:48)
i = e−1
turns some of the values gi into uniformly random values.
Now, we show that given a set of y-coordinates some of which are uniformly ran-
dom values, the polynomial that client B interpolates from them (see step 5b in the
protocol), will not contain the speciﬁc root β with a high probability.

· (p(cid:48)

2

i

i

Lemma 2. Let polynomial τ (x) be interpolated from S = {(x1, y1), ..., (xn, yn)},
and have a root β such that ∀i, 1 ≤ i ≤ n : β (cid:54)= xi. Let S(cid:48) = {(x1, y(cid:48)
n)},
where at least one of y(cid:48)
i is a uniformly random value and the rest of them are equal
j = yj). Let polynomial τ(cid:48)(x) be interpolated from
to the y-coordinates in S (i.e. y(cid:48)
S(cid:48). The probability that τ(cid:48)(x) has the root β is negligible.
Proof. Given S(cid:48), we interpolate a unique polynomial τ(cid:48)(x) of degree at most n− 1.
According to the Lagrange interpolation, the polynomial is
x − xk
xj − xk

1), ..., (xn, y(cid:48)

τ(cid:48)(x) =

y(cid:48)

We evaluate τ(cid:48)(x) at β:

i · (cid:89)
i · (cid:89)
As ∀i, 1 ≤ i ≤ n : β (cid:54)= xi, we would have (cid:81)

(cid:88)
(cid:88)

τ(cid:48)(β) =

1≤k≤n

1≤k≤n

1≤j≤n

1≤j≤n

y(cid:48)

j(cid:54)=k

j(cid:54)=k

β − xk
xj − xk

i · (cid:81)

1≤k≤n

j(cid:54)=k

1≤k≤n
j(cid:54)=k
β−xk
xj−xk

β−xk
xj−xk

(cid:54)= 0. Since, at least one

is uniformly random. Therefore,

of y(cid:48)

i is uniformly random, value y(cid:48)

2

p which is negligible.

τ(cid:48)(β) is uniformly random. Thus, P r[τ(cid:48)(β) = 0] = 1
Now we are ready to prove that the client can detect cloud misbehavior with high
probability.
Theorem 1. Let clients A and B have sets S (A) and S (B) respectively; also let
S∩ = S (A) ∩ S (B). In the protocol if the cloud sends S(cid:48) (where S(cid:48)
(cid:54)= S∩) to the
client, the client can detect it with high probability.
Proof. Due to Lemma 1, server misbehavior turns some of the y-coordinates (rep-
resenting S∩) into uniformly random values. Also, in the protocol, β is chosen uni-
p, so the probability that β = xk for some k, 1 ≤ k ≤ n,
formly at random from F∗
is negligible; due to Lemma 2, if the client interpolates a polynomial by using a set
of y-coordinates where at least one of them is a uniformly random value, the prob-
ability that the polynomial would have β as a root is negligible. Thus, if the server
computes an incorrect intersection the client can detect this with high probability
through the absence of β from the intersection.
2
Finally, we prove our main theorem.
Theorem 2. If the homomorphic encryption scheme is semantically secure, then
the protocol is secure in the presence of (1) a malicious cloud and honest clients,
(2) a semi-honest client and honest cloud.
Proof. We consider three cases where each party is corrupted at a time.
Case 1: Cloud is corrupted. We construct a simulator SIMC in the ideal model
that uses the adversary RC as a subroutine. Simulator SIMC executes the following
tasks.
(a) Pick two random sets SE and SD and choose the keys k(E)

, k(D)

, k(D)

, k(E)

, k(E)

b

z

r

z

r

,

a , k(E)
k(E)
r(cid:48)

.

(b) Generate polynomials τE(x) and τD(x) representing the sets. Then, evaluate
the polynomials at every element in #»x and blind the evaluated values. This
· (τI(xi) + z(I)
results in two vectors, #»o (E) and #»o (D). ∀o(I)
i ),
r(I)
i = f (k(I)
(c) Pick a random value β(cid:48), and construct polynomial σ(cid:48)(x) = (x − β(cid:48)). Then,
pick two random polynomials, ωE and ωD, of degree d + 1. Then, compute
#»v (E) and #»v (D) as follows. ∀i, 1 ≤ i ≤ n:

i ∈ #»o (I), o(I)
z , i), where I ∈ {D, E}.

i = f (k(I)

r , i), z(I)

i = r(I)

i

· r(cid:48)(E)

i

· ωD(xi) · σ(cid:48)(xi) · (r(D)

i

)−1)

i = f (k(E)

b

, i):

a , i), b(E)

i = f (k(E)
· ωD(xi) · σ(cid:48)(xi) + c(E)
· ωE(xi) · σ(cid:48)(xi) + d(E)

i

)

)

v(D)
i = EpkE (r(E)
i = ωE(xi) · r(cid:48)(E)
v(E)

i

· σ(cid:48)(xi)

i

, i).

where r

(d) Compute #»v (cid:48)(E) and #»v (cid:48)(D); ∀i, 1 ≤ i ≤ n, a(E)
· r(cid:48)(E)
) · r(E)
) · r(E)
· r(cid:48)(E)
z , i), c(E)
i = a(E)

(cid:48)(E)
i = f (k(E)
r(cid:48)
i = EpkE ((−z(D)
v(cid:48)(D)
i = EpkE ((−z(E)
v(cid:48)(E)
(cid:48)(E)
· r

where I ∈ {D, E}, z(I)
· σ(cid:48)(xi).
b(E)

i = f (k(I)

i

i

i

i

i

i

· r(E)

· r

(cid:48)(E)

i

· σ(cid:48)(xi), d(E)

i

i

i

i

i

i

· r(E)

i =
(e) Invoke RC and feed it with #»o (D), #»o (E), #»v (D), #»v (E), #»v (cid:48)(D), #»v (cid:48)(E), ID(D), ID(E),
t (C) from RC and decrypt the elements.

and message Compute. Then, receive #»
Next, remove the blinding factors. This yields #»g (cid:48); 1 ≤ i ≤ n, g(cid:48)
i = τE(xi) · σ(cid:48)(xi) · ωE(xi) + τD(xi) · σ(cid:48)(xi) · ωD(xi).
g(cid:48)
i). Extract the roots
of the polynomial. Check whether β(cid:48) is among the roots. If it is not, abort and
instruct the T T P to send abort message ⊥ to client B. Otherwise, ask T T P to
send the result to the client.

(f) Interpolate a polynomial using the n point-value pairs (xi, g(cid:48)

i ∈ #»g (cid:48):

(g) Output whatever the adversary outputs and terminate.
First, we consider the adversary’s output. In the real model the elements in #»o (A),
#»o (B), #»v (B) are blinded by the outputs of a pseudo-random function using random
secret keys of length l. The same is true in the ideal model for the elements in #»o (E),
#»o (D), #»v (E). Since the outputs of the pseudo-random function are computationally
indistinguishable, the distributions of #»o (A), #»o (B), #»v (B) and #»o (E), #»o (D), #»v (E) are
computationally indistinguishable, too. If the homomorphic encryption is seman-
tically secure then #»v (A), #»v (cid:48)(A), #»v (cid:48)(B) and #»v (D), #»v (cid:48)(D), #»v (cid:48)(E) are computationally in-
distinguishable. Moreover, in both models, the protocol outputs Λ (i.e. empty) to
the adversary. Therefore, we conclude that the adversary’s outputs in both models
are computationally indistinguishable.
Now we consider client B’s output. We show the honest client B aborts with
the same probability in both models. In the ideal model, if the cloud misbehaves,
SIMC would detect it with a high probability according to Theorem 1. In this case
it will send ⊥ to the client and accordingly the client will abort. Note that in this
case SIMC has not found the value β(cid:48) in the intersection. In the real model, since
the client knows the value β he can do the same checks that SIMC does. So, in
both models the client aborts with the same probability if the cloud misbehaves.
Finally, since client A has no output, her output is identical in both models.
From the above we conclude that:

IDEALF,SIMC(z)(Λ, SA, SB)

c≡ REALπ,RC(z) (Λ, SA, SB).

Case 2: Client B is corrupted. In this case we consider a semi-honest adversary
that controls client B. In the real execution, the joint outputs of the parties include
only client B’s view containing vector #»
t (C3), where the vector comprises the set in-
tersection. Now we construct a simulator, SIMB in the ideal model. The simulator
executes the following tasks.
(a) Invoke adversary RB, and receive #»e (B), SB, β, k(B)
(b) Send SB to T T P and receive the result f∩(SA, SB). Pick two random sets SE
and SD, where SE ∩ SD = f∩(SA, SB). Construct two polynomials τE(x) and
τD(x) representing set SE and SD, respectively.

from it.

,k(B)
r(cid:48)

, k(B)

, k(B)

a

z

b

i

b

a

, i).

, i),

(c) Pick two uniformly random polynomials, ωE(x) and ωD(x) of degree d + 1.
(d) Generate #»
ti = (e(B)
b(B)
i = f (k(B)

t containing ti such that
)ωE (xi)·τE (xi)+ωD(xi)·τD(xi)+a(B)

i where a(B)

i = f (k(B)

i +b(B)

t to RB. Output whatever the adversary outputs.

(e) Feed #»
Since the other parties have output Λ (i.e. no output), we only need to consider the
adversary’s view. Given the output vector, the adversary decrypts and unblinds the
elements. Next it interpolates a polynomial which is of the form ωE · τE + ωD ·
τD = µ · gcd(τE, τD), where µ is a uniformly random polynomial, and gcd(τE, τD)
represents the intersection of the sets (see subsection 3.3). Therefore, the result
polynomial only contains the information of the set intersection and has the same
distribution in both models, as the uniformly random polynomials ωA and ωB are
chosen by an honest party. Also, the value β has the same distribution in both
models.
From the above argument we conclude that:

IDEALF,SIMB(z) (Λ, SA, SB)

c≡ REALπ,RB(z) (Λ, SA, SB).

Case 3: Client A is corrupted. This is a trivial case, because client A has no
output, and she receives a set of uniformly random values and a vector of encrypted
values using semantically secure encryption scheme. A simulator can always be
constructed.
2

6 Evaluation

We evaluate VD-PSI by comparing its properties to those protocols that support veriﬁ-
able delegated PSI [18, 24] and preserve the privacy of the intersection in the cloud. We
also compare the protocols in terms of communication, computation and veriﬁcation
complexity. Table 1 summarises the results.
Properties. All the three protocols support multiple clients. In [24] the clients can se-
curely delegate an arbitrary computation to the cloud an unlimited number of times.
Nevertheless, every client needs to receive all the (hash values of encrypted) inputs of
the computation to verify the result. Therefore, the protocol is not suitable for cases
where the number of clients or the size of datasets is large. In [18] the clients need to
interact with each other in order to jointly generate a key for the pseudo-random func-
tion used to encode the datasets. Also, the clients need to re-encode their datasets each

Property

Non-interactive Setup

Multiple Clients

VD-PSI

Many Set Intersections Without Re-preparation

(cid:88)
(cid:88)
(cid:88)
(cid:88)
×
Using Expensive Generic Proof Systems (e.g. Zero Knowledge) ×

Computation Integrity Veriﬁcation
Supporting Arbitrary Computation

[18]
×
×
(cid:88)
(cid:88)
×
×

[24]
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)

Overall Communication Complexity

Overall Computation Complexity

Veriﬁcation Computation Complexity

O(d) O(d) O(m)
O(d) O(d) O(m)
O(k) O(λk) O(m)

Table 1: Comparison of the properties of veriﬁable delegated PSI protocols. We denote
set cardinality by d, set intersection cardinality by k, sum of the cardinality of all sets
by m, and the security parameter by λ.
time they compute the intersection. So, the protocol does not support outsourcing of the
datasets.

In VD-PSI, the clients can independently prepare and outsource the datasets to the
cloud. Furthermore, once the clients upload their datasets, they can securely delegate
PSI to the cloud an unlimited number of times. As a result, they do not need to download
and re-encode the outsourced datasets every time they delegate the computation.

Thus, VD-PSI and [24] support veriﬁable delegated PSI over outsourced private

datasets; whereas, [18] does not, as it lacks some of the properties.
Communication Complexity. In VD-PSI the communication complexity for client B
who receives the result is O(d), where d is the set cardinality; as client B sends to
client A vector #»e (B) containing n = 2d + 3 encrypted values (see step 3c). The com-
munication complexity for client A who grants the computation is O(d), because the
client sends to the cloud #»v (A), #»v (cid:48)(A), #»v (cid:48)(B), #»v (B) where each of the ﬁrst three vectors
contains n encrypted elements and the last one contains n random elements of the ﬁeld
(see step 3f). The communication complexity for the cloud is O(d), as it sends to client
B vector #»
t (C3) that contains n encrypted elements (see step 4d). Hence, the overall
communication complexity of our protocol is 6n, which is linear to the dataset size, so
it is O(d).

The protocol in [18] has also O(d) communication complexity. In [24], two pro-
tocols dealing with a malicious adversary are proposed. The overall communication
complexity of each protocol is linear to the total number of computation inputs m, i.e.
O(m). In one of the protocols, the cloud broadcasts all the encrypted inputs to the
clients; while in the other, the cloud broadcasts the hash value of the encrypted inputs.
Although all the three protocols have overall communication complexity linear to
the dataset size, most messages in VD-PSI are ciphertexts of Paillier encryption, in [24]
ciphertexts of fully homomorphic encryption, and in [18] ciphertexts of symmetric key
encryption.
Computation Complexity. Since computation complexity of VD-PSI is dominated by
the exponentiation operations, we evaluate its computational cost by counting the num-
ber of such operations. Client B in step 3b carries out n exponentiations to encrypt
the elements of #»e (B). Furthermore, in step 5a he performs n exponentiations to de-
crypt the elements of #»
t (C3 ). Client A carries out n exponentiations in steps 3d and 2n

exponentiations in step 3e. The cloud carries out 2n exponentiations in step 4a, 2n ex-
ponentiations in step 4b, and n exponentiations in step 4c. In total, 10n exponentiation
operations are carried out, so the overall computation complexity is linear to the dataset
size, i.e. O(d). In VD-PSI a veriﬁer only checks whether β is among the elements of
the intersection. Therefore, the veriﬁcation computation complexity is at most linear to
the intersection cardinality, i.e. O(k).

The computation complexity of the two protocols dealing with a malicious adver-
sary in [24] is dominated by fully homomorphic encryption operations. In each proto-
col, the overall number of such operations is linear to the size of the inputs m. So, the
overall computation complexity for each protocol is O(m). Moreover, in order for each
client to verify the computation correctness, he needs to access all the (encrypted) inputs
and perform generic proof system operations linear to the number of inputs. Therefore,
the veriﬁcation complexity at the veriﬁer side is O(m), too. While, in [18] each par-
ticipant has overall computation complexity linear to the dataset size d, i.e. O(d). In
order for the client to verify the integrity of the result, he checks whether λ copies of all
intersection elements exist in the result. So, its veriﬁcation complexity is O(λk) where
λ and k are the security parameter and intersection cardinality, respectively.

Thus, all the schemes have overall computation complexity linear to the dataset size;
while, VD-PSI uses Paillier encryption, [24] uses fully homomorphic, and [18] uses
symmetric key encryption. The veriﬁcation mechanisms in [24] is based on expensive
generic proof systems, while [18] and VD-PSI use lightweight mechanisms.
Remark. In VD-PSI after the client outsources its dataset, it has to keep locally only
two secret keys. During the computation, the client who is interested in the result gen-
erates four values that he needs to keep until he retrieves the result. At the end of the
protocol he can discard the four values. In contrast, a variant of the protocol in [24]
requires the client to have the hash value of his encrypted inputs for veriﬁcation. This
introduces a storage overhead linear to the number of his outsourced inputs. Similar
to VD-PSI, the clients in [18] need to locally store only the secret keys for a pseudo-
random function in order to verify the computation result.

In conclusion, although [18] is faster than VD-PSI (and [24]), VD-PSI enjoys two
properties that [18] lacks. First, VD-PSI supports non-interactive setup at client-side.
Second, it allows clients to upload their datasets once but veriﬁably delegate the com-
putation to the cloud an unlimited number of times. These properties are vital, because
in the real world individuals and businesses can upload their datasets to the cloud at dif-
ferent points in time without necessarily knowing the other cloud users. Also, the users
can fully beneﬁt from the cloud’s storage and computation capabilities. Compared to
[24], VD-PSI offers the same security properties much more efﬁciently. Thus, VD-PSI
allows businesses to get the full beneﬁts of the cloud in a more cost-effective way.

7 Conclusions and Future Work

Integrity and privacy of data and computation results are major concerns for clients
using the cloud. In this work we proposed VD-PSI, an efﬁcient protocol that allows a
client to delegate both storage and computation of private set intersection to the cloud
who may misbehave. VD-PSI allows a result recipient to efﬁciently detect if the cloud

tampers with the datasets, or deviates from the protocol, even though the client does
not know its own outsourced dataset and the other clients’ datasets. The protocol allows
clients to independently prepare and store their private datasets in the cloud, and later
on ask the cloud to compute the intersection of their outsourced datasets. It ensures that
the cloud can compute the intersection only when all the clients agree. Clients can dele-
gate PSI computation over their outsourced datasets an unlimited number of times with
no need to download and re-prepare the datasets. We have shown that our protocol is
secure in the presence of a malicious cloud and semi-honest clients. Its communication
and computation complexity is linear to the dataset size, and its veriﬁcation mecha-
nism is lightweight. Overall, VD-PSI is a clear step forward towards efﬁcient veriﬁable
delegated PSI on outsourced private datasets.

In the future we would like to investigate how to further improve the efﬁciency of
the protocol and how to support other privacy preserving delegated set operations on
outsourced private datasets such as set difference, set union and subset.

Acknowledgments We would like to thank the anonymous reviewers. This work was
partially supported by an EPSRC Doctoral Training Grant studentship and an EPSRC
research grant (EP/M013561/1).

References

1. Abadi, A., Terzis, S., Dong, C.: O-PSI: delegated private set intersection on outsourced
datasets. In: ICT Systems Security and Privacy Protection - 30th IFIP TC 11 International
Conference, SEC 2015, Germany. pp. 3–17 (2015)

2. Aggarwal, C.C., Yu, P.S. (eds.): Privacy-Preserving Data Mining - Models and Algorithms,

Advances in Database Systems, vol. 34. Springer (2008)

3. Aho, A.V., Hopcroft, J.E.: The Design and Analysis of Computer Algorithms. Addison-

Wesley Longman Publishing Co., Inc., Boston, MA, USA, 1st edn. (1974)

4. Ardagna, C.A., Asal, R., Damiani, E., Vu, Q.H.: From security to assurance in the cloud: A

survey. ACM Comput. Surv. 48(1), 2:1–2:50 (Jul 2015)
the

interview: A guide

5. BBC-NEW: The

to

cyber

attack

on

hollywood.

http://www.bbc.co.uk/news/entertainment-arts-30512032

6. Choi, S.G., Katz, J., Kumaresan, R., Cid, C.: Multi-client non-interactive veriﬁable compu-

tation. In: TCC. pp. 499–518 (2013)

7. Cristofaro, E.D., Kim, J., Tsudik, G.: Linear-complexity private set intersection protocols
secure in malicious model. In: Advances in Cryptology - ASIACRYPT 2010 - 16th Interna-
tional Conference on the Theory and Application of Cryptology and Information Security.
pp. 213–231 (2010)

8. Dong, C., Chen, L., Camenisch, J., Russello, G.: Fair private set intersection with a semi-
trusted arbiter. In: Data and Applications Security and Privacy XXVII - 27th Annual IFIP
WG 11.3 Conference, DBSec 2013, USA. pp. 128–144 (2013)

9. Dong, C., Chen, L., Wen, Z.: When private set intersection meets big data: an efﬁcient and
scalable protocol. In: 20th ACM Conference on Computer and Communications Security.
pp. 789–800 (2013)

10. Fiore, D., Gennaro, R., Pastro, V.: Efﬁciently veriﬁable computation on encrypted data. In:
21st ACM Conference on Computer and Communications Security, Scottsdale, AZ, USA.
pp. 844–855 (2014)

11. Freedman, M.J., Nissim, K., Pinkas, B.: Efﬁcient private matching and set intersection. In:
EUROCRYPT 2004, International Conference on the Theory and Applications of Crypto-
graphic Techniques, Interlaken, Switzerland. pp. 1–19 (2004)

12. Gennaro, R., Gentry, C., Parno, B.: Non-interactive veriﬁable computing: Outsourcing com-
putation to untrusted workers. In: Advances in Cryptology - CRYPTO 2010, 30th Annual
Cryptology Conference, , USA. pp. 465–482 (2010)

13. Goldreich, O.: The Foundations of Cryptography - Volume 2, Basic Applications. Cambridge

University Press (2004)

14. Goldwasser, S., Kalai, Y.T., Rothblum, G.N.: Delegating computation: interactive proofs for
muggles. In: Proceedings of the 40th Annual ACM Symposium on Theory of Computing, ,
Canada. pp. 113–122 (2008)

15. Golle, P., Mironov, I.: Uncheatable distributed computations. In: Topics in Cryptology - CT-
RSA 2001, The Cryptographer’s Track at RSA Conference 2001, San Francisco, CA, USA.
pp. 425–440 (2001)

16. Gordon, S.D., Katz, J., Liu, F., Shi, E., Zhou, H.: Multi-client veriﬁable computation with
stronger security guarantees. In: 12th Theory of Cryptography Conference, TCC , Poland.
pp. 144–168 (2015)

17. Huang, W., Ganjali, A., Kim, B.H., Oh, S., Lie, D.: The state of public infrastructure-as-a-

service cloud security. ACM Comput. Surv. 47(4), 68:1–68:31 (Jun 2015)

18. Kamara, S., Mohassel, P., Raykova, M., Sadeghian, S.: Scaling private set intersection to
billion-element sets. In: 18th International Conference on Financial Cryptography and Data
Security. pp. 863–874 (2014)

19. Kedlaya, K.S., Umans, C.: Fast polynomial factorization and modular composition. SIAM J.

Comput. 40(6), 1767–1802 (2011)

20. Kerschbaum, F.: Collusion-resistant outsourcing of private set intersection. In: 27th ACM

Symposium on Applied Computing, Riva, Trento, Italy. pp. 1451–1456 (2012)

21. Kerschbaum, F.: Outsourced private set intersection using homomorphic encryption. In:

Computer and Communications Security, ASIACCS ’12. pp. 85–86 (2012)

22. Kissner, L., Song, D.X.: Privacy-preserving set operations. In: CRYPTO 2005, 25th Interna-

tional Cryptology Conference. pp. 241–257 (2005)

23. Liu, F., Ng, W.K., Zhang, W., Giang, D.H., Han, S.: Encrypted set intersection protocol for
outsourced datasets. In: IEEE International Conference on Cloud Engineering. pp. 135–140.
IC2E ’14, IEEE Computer Society, Washington, DC, USA (2014)

24. L´opez-Alt, A., Tromer, E., Vaikuntanathan, V.: On-the-ﬂy multiparty computation on the
cloud via multikey fully homomorphic encryption. In: Symposium on Theory of Computing
Conference, USA. pp. 1219–1234 (2012)

25. Marston, S., Li, Z., Bandyopadhyay, S., Ghalsasi, A.: Cloud computing - the business
perspective. In: 44th Hawaii International International Conference on Systems Science
(HICSS-44 2011), USA. pp. 1–11 (2011)

26. Paillier, P.: Public-key cryptosystems based on composite degree residuosity classes. In: EU-
ROCRYPT ’99, International Conference on the Theory and Application of Cryptographic
Techniques, Prague, Czech Republic. pp. 223–238 (1999)

27. Pinkas, B., Schneider, T., Segev, G., Zohner, M.: Phasing: Private set intersection using
permutation-based hashing. In: 24th USENIX Security Symposium, USENIX Security 15,
Washington, D.C., USA, August 12-14, 2015. pp. 515–530 (2015)

28. Pinkas, B., Schneider, T., Zohner, M.: Faster private set intersection based on OT extension.

In: 23rd USENIX Security Symposium, San Diego, CA, USA. USENIX (2014)

29. Zheng, Q., Xu, S.: Veriﬁable delegated set intersection operations on outsourced encrypted

data. IACR Cryptology ePrint Archive p. 178 (2014)

