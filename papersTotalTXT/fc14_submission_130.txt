A Short Paper on How to Improve U-Prove Using

Self-Blindable Certiﬁcates(cid:63)

Lucjan Hanzlik and Kamil Kluczniak

Faculty of Fundamental Problems of Technology,

Wrocław University of Technology

{firstname.secondname}@pwr.wroc.pl

Abstract. U-Prove is a credential system that allows users to disclose informa-
tion about themselves in a minimalistic way. Roughly speaking, in the U-Prove
system a user obtains certiﬁed cryptographic tokens containing a set of attributes
and is able to disclose a subset of his attributes to a veriﬁer, while hiding the
undisclosed attributes. In U-prove the actual identity of a token holder is hidden
from veriﬁers, however each token has a static public key (i.e. token pseudonym),
which makes a single token traceable, by what we mean that, if a token is pre-
sented twice to a veriﬁer, then the veriﬁer knows that it is the same token. We
propose an extension to the U-Prove system which enables users to show U-Prove
tokens in a blinded form, so even if a single token is presented twice, a veriﬁer is
not able to tell whether it is the same token or two distinct tokens. Our proposition
is an optional extension, not changing the core of the U-Prove system. A veriﬁer
decides whether to use issuer signatures from U-Prove, or the blind certiﬁcates
from the extension.

Key words: U-Prove, Anonymous Credentials, Self-Blindable Certiﬁcates

1

Introduction

David Chaum in [1] sketched some of the problems related to identity certiﬁcates. One
of them is that service providers are able to track the activity of users. The idea to
hide the actual identity of a user is based on pseudonyms. A pseudonym is a unique
identiﬁer by which a user can authenticate against some parties in the system. Typi-
cally pseudonyms are issued by service providers in order to blind the actual identity
of a user. Pseudonymity can be differently understood. In some systems users appear
under just one pseudonym which sometimes is called a token. Other systems provide
unique pseudonyms for a user which are different in distinct service providers and even
if these service providers cooperate, the pseudonyms cannot be linked. This means that
having two or more pseudonyms it is infeasible to decide whether the pseudonym is
related to one user or many different users. The notion of unlinkability was also de-
scribed in [1] and can be differently understood. One situation is, as described above,
when a user presents different pseudonyms in different domains and the identity cannot

(cid:63) This research was conducted within project 2012-9/4 of the Ventures programme of Founda-

tion for Polish Science, coﬁnanced from European Union, Regional Development Fund.

2

Lucjan Hanzlik and Kamil Kluczniak

be linked between this domains, however within one domain a user appears under just
one pseudonym and thus is tracable in it [2]. Another situation is when each authentica-
tion session provides a new pseudonym. We will call the second situation untraceability
since the data which a user passes during two or more authentication sessions are un-
linkable, so it cannot be used to trace the activity of a particular user.

Generally, the anonymity notion appears in a range of different protocols and schemes.

The main goal of group signatures [3,4,5] , for instance, is to identify that a signer be-
longs to a group and the signatures made by any group member are unlinkable in the
sense that, a veriﬁer checks only if a signature was made by a relevant group member,
but it is infeasible to determine who exactly produced that signature.

A similar notion of anonymity can be observed in anonymous credential systems
where a user can prove different statements about himself, but without revealing any
other information to a veriﬁer. Such credential systems based on CL-Signatures [6] were
designed in [7] and are constructed for algebraic groups of unknown order. Another
credential system, designed by Microsoft, is called U-Prove [8] where a user obtains
authentication tokens and is able to proof statements about himself, which are contained
in that token. The token contains a public key, so in some sense it is a pseudonym of a
user, and an issuer certiﬁcate on that public key. Presenting one U-Prove token twice or
more requires to show the token public key and the certiﬁcate in an unblinded form, so
a set of veriﬁers can easily track a single token.

In this short paper we study the possibility to improve the U-Prove credential system
by providing the untraceability property for a U-Prove token. So in effect, many presen-
tations of a single token should be unlinkable. We believe that an interesting building
block introduced by Verhuel in [9], called self-blindable certiﬁcate, can naturally pro-
vide the untraceability property for credential systems such as U-Prove. The idea behind
a self-blindable certiﬁcate is, that a issuer generates a certiﬁcate under a users public
key, and the user can present such certiﬁcate in an blinded form to a veriﬁer.

Contribution We show an extension to the Microsoft U-Prove credential system
providing the untraceability property for U-Prove tokens using self-blindable certiﬁ-
cates. In short, instead of obtaining a linkable certiﬁcate on a token, we issue a self-
blindable certiﬁcate on the token public key, so a token holder can show statements
related to the token without revealing the token public key, i.e. show the token public
key in an blinded form and prove that it is genuine by showing the blinded certiﬁcate.
In effect two or more authentication sessions become unlinkable and veriﬁers cannot
track one particular token. Our extension don’t changes the U-Prove system substan-
tially. A veriﬁer can choose, depending on his intend, whether to verify the standard
U-Prove certiﬁcate or the self-blindable certiﬁcate. In the ﬁrst case, the protocols goes
unchanged as described in the speciﬁcation [8]. When self-blindable certiﬁcates are
used, then some steps of the protocol are modiﬁed. First in section 2 we describe a con-
struction for self-blindable certiﬁcates from [9]. Then, we give a high-level description
of the U-Prove system and indicate the changes between our contribution and the orig-
inal protocol in section 3. Finally in section 4 we give a brief security analysis of our
proposed extension.

A Short Paper on How to Improve U-Prove Using Self-Blindable Certiﬁcates

3

2 Self-Blindable Certiﬁcates

We ﬁrst recall the deﬁnition of Self-Blindable Certiﬁcates as described in [9] by Ver-
heul. Then, we present a construction that implements this deﬁnition.

2.1 Deﬁnition
We assume that the system consists of users and a trust provider. We deﬁne a certiﬁcate
on a users public key PU ∈ U, signed with the trust providers secret key ST , as:

{PU , Sig(PU , ST )}.

same trust provider secret key as the certiﬁcate C.
efﬁciently compute a transformation factor f(cid:48) ∈ F such that C1 = D(C2, f(cid:48)).

Let C be the set of all possible certiﬁcates and let F be a set called transformation
factor space. We call the certiﬁcates C self-blindable if there exist a efﬁciently com-
putable transformation map D : C × F → C such that:
– For any certiﬁcate C ∈ C and f ∈ F the certiﬁcate D(C, f ) is signed with the
– Let C1, C2 be certiﬁcates and let f ∈ F is known. If C2 = D(C1, f ) then one can
– The mapping D(., .) induces a mapping D(cid:48) : U × F → U namely if C1, C2 are
certiﬁcates on a users public key PU , then D(C1, f ) and D(C2, f ) are certiﬁcates
for the public key D(cid:48)(PU , f ), for any transformation factor f ∈ F .
– Let PU be the public key of a user and let f ∈ F be a transformation factor known
by the user. If the user possesses the private key for PU , then the user also knows
the private key for D(cid:48)(PU , f ).
random element in F , then D(cid:48)(PU , f ) is a uniformly random element in U.

– If the users public key PU is ﬁxed and the transformation factor f is a uniformly

Instantiation

2.2
Deﬁnition 1. Let G1, G2, GT be cyclic groups of prime order q. Let e : G1×G2 → GT
be a map with the following properties:
– for P ∈ G1, Q ∈ G2 and a, b ∈ Zq, we have e(aP, bQ) = e(P, Q)a·b,
– if P is a generator of G1 and Q is a generator of G2, then e(P, Q) generates GT ,
– there is an efﬁcient algorithm to compute e(P, Q) for P ∈ G1, Q ∈ G2.
We now say that the function e is a:
– Type 1 pairing function if G1 = G2,
– Type 2 pairing function if G1 and G2 are distinct groups and there exists a efﬁ-
– Type 3 pairing function if G1 and G2 are distinct groups and there is no known

ciently computable isomorphism ψ : G2 → G1,
isomorphism ψ : G2 → G1.

Type 1 pairing is also called symmetric, because G1 = G2. Type 2 and type 3 are called
asymmetric.

From now on, we will only use the multiplicative notation (even when the group is
additive) to simplify the description and to remain compatible with the U-Prove Crypto
Speciﬁcation V1.1 [8].

4

Lucjan Hanzlik and Kamil Kluczniak

In this case we deﬁne the set U as G3

Construction We present the second construction from [9]. However, we extend the
construction to type 2 pairing (so the security analysis in [9] is valid) and not only type
1 as is the original description.
q and
the certiﬁcate space C as G1. In addition let P1 be the generator of G1 and P2 be the
generator of G2.
Let z, f ∈ Zq be the private key of the trust provider and let r, rf , h, hz (for ran-
dom r, h ∈ G2) be his public key. The users public key takes the following form:
(g1, g2, gx1
1 and (x1, x2) is the pri-
1 gx2
vate key of the user. The certiﬁcate for the users public key is (gx1
2 )z. The certiﬁcate
can be easily veriﬁed by checking if:

2 ), where g1 is a random element in G1, g2 = gf

1, the transformation factor space F as Z2

1 gx2

e(gx1

1 gx2

2 , hz) ?= e((gx1

1 gx2

2 )z, h)

and

e(g1, rf ) ?= e(g2, r)

and by verifying that the user knows x1 and x2, which can be checked using the
Okamoto variant of Schnorr’s identiﬁcation scheme [10].

Note that, for a random (k, l) ∈ F , D(., .) and D(cid:48)(., .) deﬁned as follows:

D((gx1
D(cid:48)((g1, g2, gx1

1 gx2
1 gx2

2 )z, (k, l)) = (gx1
2 ), (k, l)) = (gl

1 gx2
1, gl

2 )z·l·k,
2, (gx1
1 gx2

2 )l·k)

fulﬁl the above deﬁnition of self-blindable certiﬁcates.

3 Our Contribution

In this section, we will present our extension. We describe it by embedding it into the U-
Prove Crypto Speciﬁcation V1.1 [8]. Due to space reasons we only show a sketch of the
system. Thus, we advise to read this section in conjunction with [8]. Our extension is an
optional feature. In short, a token issuer makes an additional self-blindable certiﬁcate
on the tokens public key. In the proof generation and veriﬁcation a user or veriﬁer,
depending on the use case, can choose whether to show the standard signature speciﬁed
in [8] or the self-blindable certiﬁcate from our proposed extension. We will denote as
[Standard] the situation when the signature from [8] is used, and as [Blinding] when
the self-blindable certiﬁcate is used. An exception from this is the issuing phase, where
both certiﬁcates are issued to the token holder.

3.1 System Parameters

The system parameters consist of the standard U-Prove parameters:

IP = (U IDP , desc(G1), U IDH, (g0, g1, . . . , gn, gt),

(e1, . . . , en), (z0, z1, . . . , zn, zt), S)

where

– U IDP is a unique identiﬁer of the token,
– desc(G1) is the description of a group of prime order q with a generator g ∈ G1

A Short Paper on How to Improve U-Prove Using Self-Blindable Certiﬁcates

5

– U IDH is the speciﬁcation of the hash function H,
– (g0, g1, . . . , gn, gt) is the issuers public key, where y0 is private, g0 = gy0 and

g1, . . . , gt are random group generators.

are hashed computing an UProve token.

– (e1, . . . , en) list of byte values indicating whether or not the attribute values A1, . . . , An
– (z0, z1, . . . , zn, zt) for each i ∈ {1, . . . , n, t}, zi = gy0
– S - speciﬁcation for the issuer parameters.

.

i

and the additional extension parameters:

IP[Blinded] = (q, p, pr, G2, GT , e, p0, p1).

where G2 is a cyclic group of order q generated by p, r is random in Zq, e is a Type 2
pairing in sense of Deﬁnition 1, p0 = pr·z, p1 = pf and (z, f ) is the issuers secret key.

3.2

Issuing U-Prove Token

The issuing protocol is similar to the one in the speciﬁcation [8]. In the issuing proce-
dure the user receives a U-Prove token of the form:

T = (U IDP , h, T I, IP, (σ(cid:48)

z, σ(cid:48)

c, σ(cid:48)

r)[STANDARD], (B)[BLINDED]).

n gxt

During the issuing procedure the user generates a private key α ∈ Zq which is asso-
z, σ(cid:48)
ciated with the public key h = (g0gx1
and σ(cid:48)

t )α of the token T . The values σ(cid:48)

r form the issuer signature on the public key h.

1 . . . gxn

In our extension, a user obtains a self-blindable certiﬁcate on the tokens public key
h. The issuer computes h2 = hf . The user then chooses two private keys b1 and b2,
computes a value hb1hb2
2 on which the issuer makes his signature using his private key
z. Finally, the self-blindable certiﬁcate with the corresponding public key, obtained by
the user is of the form B = (h, h2, hb1hb2
2 )z) and his private keys associated
to the certiﬁcate are b1 and b2.

2 , (hb1 hb2

c

3.3 Presenting U-Prove Token

In this subsection we describe the proof presentation procedure.

Input:

1. Disclosed attributes: D ⊂ {1, . . . , n},
2. Undisclosed attributes: U ⊂ {1, . . . , n}\D,
3. U-Prove token: T = (U IDP , h, T I, IP, (σ(cid:48)
4. Message: m ∈ {0, 1}∗,
5. Private key: α,
6. Attribute values: (A1, . . . , An) ∈ ({0, 1}∗)n.

z, σ(cid:48)

cσ(cid:48)

r)[STANDARD], (B)[BLINDED]),

Proof Generation:

2. [Standard] Compute a = H(hw0 ((cid:81)

1. For each i ∈ U, generate wi ∈ Zq and generate w0 ∈ Zq,

i∈U gwi

i )), or

6

Lucjan Hanzlik and Kamil Kluczniak

2. [Blinded] Choose a random blinding l and compute a = H(hw0·l((cid:81)

i∈U gwi

i ))

3. xt = ComputeXt(IP, T I),
4. For each i ∈ {1, . . . , n}, xi = ComputeXi(IP, Ai),
5. [Blinded] Compute the blinded token

and B4 = ((hb1hb2

(a) Blind the U-Prove public key B1 = hl, where l is chosen randomly,
(b) Blind the certiﬁcate for the token by computing B2 = hl
2 )z)l·k, where k is chosen randomly.
(c) Choose r1, r2 at random, and compute additionally B(cid:48)
2 = Br2
1 = Br1
2 .
(d) The blinded certiﬁcate consists of Bb = (B1, B2, B3, B4, B(cid:48)
(e) Set the blinded token as T = (U IDP , T I, IP,Bb) (note that the blinded U-

1 and B(cid:48)
1, B(cid:48)
2)

2, B3 = (hb1hb2

2 )l·k

Prove token is contained in Bb).

5. c = GenerateChallenge(IP,T , a, m, D,{xi}i∈D),
6. [Standard] Compute r0 = cα−1 + w0, or
6. [Blinded]

(a) Compute r0 = cα−1 · l−1 + w0,
(b) Compute s1 = r1 − c · k · b1 and s2 = r2 − c · k · b2
7. Compute ri = −cxi + wi for each i ∈ U, where wi is chosen randomly,
8. Return the U-Prove token proof ({Ai}i∈D, a, r0,{ri}i∈U ).
8. [Blinded] Additionally, return s1 and s2.

3.4 Verifying U-Prove Token

Input

1. Issuer parameter ﬁelds IP and if the token is blinded then additionally IP[Blinded].
2. Ordered indices of disclosed attributes: D ⊂ {1, . . . , n},
3. Ordered indices of undisclosed attributes: U ⊂ {1, . . . , n} \ D,
4. The UProve token in form

– [Standard] T = (U IDP , h1, T I, IP, σ(cid:48)
– [Blinded] T = (U IDP , T I, IP,Bb).

c, σ(cid:48)
z, σ(cid:48)
5. The presentation proof ({Ai}i∈D, a, r0,{ri}i∈U ),
6. [Blinded] The proof of knowledge s1, s2.

r), or

Proof Veriﬁcation:

(σ(cid:48)

c, σ(cid:48)

z, σ(cid:48)

r) (see [8]), or

1. [Standard] Run the V erif yT okenSignature(IP,T ) procedure which veriﬁes
1. [Blinded] Run V erif ySelf BlindableCertif icate(Bb,T , s1, s2).
2. xt = ComputeXt(IP, T I),
3. For each i ∈ D, xi = ComputeXi(IP, Ai),
4. Set c = GenerateChallenge(IP,T , a, m, D,{xi}i∈D),
5. [Standard] Extract k = h from T , or
5. [Blinded] Extract k = B1 from T ,
6. Verify that a ?= H((g0gxt
i∈D gxi

i )−ckr0 ((cid:81)

i∈U gri

(cid:81)

i )).

t

A Short Paper on How to Improve U-Prove Using Self-Blindable Certiﬁcates

7

3.5 Verify Self Blindable Certiﬁcate

Having as input the system parameters and the issuers parameters IP[Blinded], the chal-
lenge c the blinded token T in particular the values B1, B2, B3, B4, B(cid:48)
2, check
the following proof of knowledge:

1 and B(cid:48)

Bs1

1 Bs2

2 B−c

3

?= B(cid:48)

1B(cid:48)

2

Now, check whether the certiﬁcate was indeed issued by the issuer by verifying the

following equations:

e(B3, p0) ?= e(B4, pr)

and

e(B1, p1) ?= e(B2, p)

4 Security Analysis

Since this is a work in progress, we only present an intuition for the security proof. In
particular, we show two things:

1. the adversary, without any U-Prove tokens, cannot create an U-Prove token that

passes the veriﬁcation,

2. having k U-Prove tokens, the adversary cannot forge a k + 1 U-Prove token which
is different then each of the k tokens he possesses and that will pass the veriﬁcation.
3. having k tokens, the adversary cannot create an U-Prove token which is different

then each of the k tokens he possesses and that will pass the veriﬁcation.

The ﬁrst statement covers the case when the adversary, without any knowledge of U-
Prove tokens in the system, would like to exploit the extension to pass the veriﬁcation.
On the other hand, the second statement covers the case when the adversary would like
to exploit the extension to change some attributes in his U-Prove tokens.

Let us ﬁrst assume that there exists an adversary that without access to any U-Prove
token, creates a U-Prove token that passes the veriﬁcation. However, then we can use
such adversary to forge the underlying self-blindable certiﬁcates. Thus, since the self-
blindable certiﬁcates presented in subsection 2.2 are secure against forgery, as shown
in [9], so is our extension.

Now we show that the second statement is valid. Let for i ∈ {1, . . . , k}:

(hi, h2,i, hb1,i

i hb2,i

2,i , (hb1,i

i hb2,i

2,i )z)

be the U-Prove token extensions known to the adversary. Note that hi is the U-Prove to-
kens public key which contains all attributes. Without loss of generality we assume that
the adversary would like to change some attributes in token i = 1. We will now show
how he can change the token (h1, h2,1, hb1,1
2,1 )z) and the contained in
it attributes, in such a way that it will pass the veriﬁcation. Obviously, he can blind this
token according to the protocol but then the token contains the same attributes. Accord-
ing to the security proof of the used self-blindable certiﬁcates (see appendix in [9]) the
i∈I hri
i ,
for I ⊂ {1, . . . , k} and ri are known to the adversary.

adversary can only change h1 (the tokens public key) in such a way that h1 =(cid:81)

2,1 , (hi1b1,1hb2,1

1 hb2,1

8

Lucjan Hanzlik and Kamil Kluczniak

Let us now assume that |I| = 2. It follows that h1 is of the form:

(g0gx(cid:48)

1 . . . gx(cid:48)

1

for some key α, encodings x(cid:48)
x(cid:48)(cid:48)
1 , . . . , x(cid:48)(cid:48)
1, . . . , A(cid:48)
the standard U-Prove veriﬁcation. The veriﬁer checks whether:

n of attributes A(cid:48)

t

1

n

n

1

n gx(cid:48)(cid:48)

. . . gx(cid:48)(cid:48)

n gx(cid:48)
t g0gx(cid:48)(cid:48)
1, . . . , x(cid:48)
n of attributes A1, . . . , An and encodings
n. However, a public key of such form will not pass

t )α

t

a ?= H((g0gxt

t

i )−ckr0(
gxi

gri
i )).

(cid:89)

i∈D

(cid:89)

i∈U

j

j or x(cid:48)(cid:48)

x(cid:48)(cid:48)
j )−c will be canceled by the value (g

Let us consider one disclosed attribute under base gj, j ∈ {1, . . . , n}. The adversary
j . Without loss of generality, let the adversary disclose x(cid:48)(cid:48)
can choose to disclose x(cid:48)
j .
x(cid:48)(cid:48)
j )c, which will be computed
Then, the value (g
x(cid:48)
in kr0. However, note that the value (g
j ) is part of
the public key k = h1. Note further, that x(cid:48)
j cannot be part of the undisclosed attributes
since the veriﬁer uses only bases gi for i ∈ U and j (cid:54)∈ U. It follows that the adversary
would have to know loggi(gj) for a i ∈ U or ﬁnd a collision for the hash function H
(since c depends on the value of a).
The same argumentation works for |I| ∈ {3, . . . , k}. Thus, even if the adversary
has k tokens, he cannot create a new U-Prove token that contains a subset of attributes
from the k tokens he possesses.

x(cid:48)
j )c will also be computed, since (g

j

j

j

5 Conclusion

We have shown, that it is possible to create an extension for the U-Prove credential
system that allows to randomize the token. This extension allows to use the token mul-
tiple times in such a way that the veriﬁer cannot link two presentation proofs of the
same token. To assure, the validity of the token we use self-blindable certiﬁcates in-
stead of blind signatures used in the standard speciﬁcation. To give some intuition, for
the security of this construction, we give a brief rationale. Future work will include a
formal security proof of our extension in the sense that this extension is as secure as the
standard U-Prove speciﬁcation (which in fact has no formal security proof).

References

1. Chaum, D.: Security without identiﬁcation: transaction systems to make big brother obsolete.

Commun. ACM 28(10) (October 1985) 1030–1044 1

2. Brickell, E., Camenisch, J., Chen, L.: Direct anonymous attestation. In: Proceedings of the
11th ACM conference on Computer and communications security. CCS ’04, New York, NY,
USA, ACM (2004) 132–145 2

3. Ateniese, G., Camenisch, J., Hohenberger, S., de Medeiros, B.: Practical group signatures
without random oracles. Cryptology ePrint Archive, Report 2005/385 (2005) http://
eprint.iacr.org/. 2

A Short Paper on How to Improve U-Prove Using Self-Blindable Certiﬁcates

9

4. Bellare, M., Micciancio, D., Warinschi, B.: Foundations of group signatures: formal deﬁ-
nitions, simpliﬁed requirements, and a construction based on general assumptions. In: Pro-
ceedings of the 22nd international conference on Theory and applications of cryptographic
techniques. EUROCRYPT’03, Berlin, Heidelberg, Springer-Verlag (2003) 614–629 2

5. Boneh, D., Boyen, X., Shacham, H.: Short group signatures.

In: In proceedings of

CRYPTO’04, LNCS series, Springer-Verlag (2004) 41–55 2

6. Camenisch, J., Lysyanskaya, A.: A signature scheme with efﬁcient protocols. In: Proceed-
ings of the 3rd international conference on Security in communication networks. SCN’02,
Berlin, Heidelberg, Springer-Verlag (2003) 268–289 2

7. Camenisch, J., Van Herreweghen, E.: Design and implementation of the idemix anonymous
credential system. In: Proceedings of the 9th ACM conference on Computer and communi-
cations security. CCS ’02, New York, NY, USA, ACM (2002) 21–30 2

8. Paquin,

C.,

Zaverucha,

G.:

speciﬁcation
v1.1.
http://research.microsoft.com/pubs/166969/
U-ProveCryptographicSpecificationV1.1Revision2.pdf (April 2013) 2,
3, 4, 5, 6

cryptographic

U-prove

9. Verheul, E.R.: Self-blindable credential certiﬁcates from the weil pairing. In Boyd, C., ed.:
ASIACRYPT. Volume 2248 of Lecture Notes in Computer Science., Springer (2001) 533–
551 2, 3, 4, 7

10. Okamoto, T.: Provably secure and practical identiﬁcation schemes and corresponding sig-
nature schemes. In Brickell, E.F., ed.: CRYPTO. Volume 740 of Lecture Notes in Computer
Science., Springer (1992) 31–53 4

