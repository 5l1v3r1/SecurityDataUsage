Identity-Concealed Authenticated Encryption

and Key Exchange∗

Shanghai Key Laboratory of Data Science
Software School, Fudan University, China

State Key Laboratory of Cryptology, Beijing, China

Yunlei Zhao

ylzhao@fudan.edu.cn

ABSTRACT
Identity concealment and zero-round trip time (0-RTT) con-
nection are two of current research focuses in the design
and analysis of secure transport protocols, like TLS1.3 and
Google’s QUIC, in the client-server setting.
In this work,
we introduce a new primitive for identity-concealed authen-
ticated encryption in the public-key setting, referred to as
higncryption, which can be viewed as a novel monolithic inte-
gration of public-key encryption, digital signature, and iden-
tity concealment. We then present the security deﬁnitional
framework for higncryption, and a conceptually simple (yet
carefully designed) protocol construction.

As a new primitive, higncryption can have many applica-
tions. In this work, we focus on its applications to 0-RTT
authentication, showing higncryption is well suitable to and
compatible with QUIC and OPTLS, and on its applications
to identity-concealed authenticated key exchange (CAKE)
and unilateral CAKE (UCAKE). Of independent interest
is a new concise security deﬁnitional framework for CAKE
and UCAKE proposed in this work, which uniﬁes the tradi-
tional BR and (post-ID) frameworks, enjoys composability,
and ensures very strong security guarantee. Along the way,
we make a systematically comparative study with related
protocols and mechanisms including Zheng’s signcryption,
one-pass HMQV, QUIC, TLS1.3 and OPTLS, most of which
are widely standardized or in use.

1.

INTRODUCTION

Identity concealment and zero-round trip time (0-RTT)
connection are two of current research focuses in the de-
sign and analysis of cryptographic systems (in particular,
secure transport protocols for the client-server setting). By
identity concealment, we mean that the transcript of pro-
tocol run should not leak participants’ identity information,

∗This research was supported in part by NSFC (Grant Nos.

61472084, 61272012, U1536205, 61332019) and 973 Grant
No. 2014CB340601 and Shanghai Innovation Action Project
No. 16DZ1100200.

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’16, October 24 - 28, 2016, Vienna, Austria
c(cid:13) 2016 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ISBN 978-1-4503-4139-4/16/10. . . $15.00
DOI: http://dx.doi.org/10.1145/2976749.2978350

which is now deemed to be an important privacy concern and
is mandated or recommended by a list of widely standard-
ized and deployed cryptographic protocols like TLS1.3 [13],
QUIC [30], EMV [6]. Furthermore, informally speaking, a
player enjoys forward ID-privacy if its ID-privacy preserves
even when its static secret-key is compromised. By 0-RTT
option, we mean that when the client has a previously re-
trieved or cached public key of the server, it can optionally
transmit encrypted information already in the ﬁrst ﬂow of
the protocol run. 0-RTT connection is highly desirable be-
cause of its signiﬁcant impact on connection latency, a criti-
cal issue in most HTTP(S) content acquisitions. This option
is supported by QUIC and is now under discussion by the
IETF TLS1.3 working group.

The QUIC protocol, developed by Google and already im-
plemented with Chrome in 2013, currently stands as one of
the most promising solutions to decreasing latency while in-
tending to provide security properties similar to TLS [24].
According to Google’s measurement, currently at least 75%
of all QUIC connections use 0-RTT mode. Unfortunately,
QUIC now only supports 0-RTT mode without client au-
thentication. It is suggested that, in order for QUIC to be
ubiquitous, a suitable mechanism for 0-RTT client authen-
tication is needed.

To our knowledge, the literature lacks a cryptographic
mechanism that solidly and practically integrates public-
key encryption, entity authentication and ID-concealment
into a monolithic primitive. A natural solution to identity-
concealed 0-RTT client authentication is to encrypt client’s
0-RTT data and signature using server’s public-key [23].
However, this approach has several drawbacks and may not
be satisfactory enough.

• Firstly, composing public-key encryption and digital
signature serially may not be eﬃciency-economic. On
the other hand, a tailored protocol construction usu-
ally not only has eﬃciency improvements, but also
can have much more advantageous features, as wit-
nessed by the ongoing CAESAR competition on au-
thenticated encryption (AE) even though AE can be
generally achieved by composing CPA-secure encryp-
tion and MAC.

• Secondly, such a serial composition may not be sound
enough and may bring some security concerns [34, 33].
• Thirdly, viewing the cryptographic mechanism, which
integrates ID-concealment, public-key encryption and
entity authentication, as a separate primitive may con-
ceptually simplify the design and analysis of complex
protocols. However, the proper modeling of ID-concealed

1464authenticated encryption may not be so obvious and
deserves explorations, as already witnessed by the mod-
eling of composition of encryption and authentication
[1, 2, 11, 16, 17].

• Fourthly, sender’s signature leaves to the receiver an
undeniable proof of session participance, while in many
application scenarios certain kind of deniability is more
desirable for privacy considerations.

In the public-key setting, authenticated encryption refers
to signcryption [37], which is also standardized by ISO-
29150. It is shown that signcryption is functionally equiva-
lent to one-pass authenticated key-exchange [10, 16], which
in turn has applications in asymmetrical key-wrapping [17].
However, for Zheng’s signcryption [37, 2, 14] and one-pass
HMQV (HOMQV) [20, 17], sender’s public identity infor-
mation (including its certiﬁcate) has to be sent in clear, or
otherwise the receiver cannot derive the shared key. It would
be interesting to note that, although signcryption (1997) [37]
and one-pass MQV (1995) [27] have been proposed for about
two decades, the issue of ID concealment was not consid-
ered for them up to now, whether for protocol construction
or for security deﬁnition. It is also interesting to note that
HOMQV enjoys “receiver deniability”, in the sense that the
session transcript (in particular, the authentication value
σ) can be simulated from public parameters and receiver’s
secret-key. In comparison, the session transcript of Zheng’s
signcryption is undeniable, as the authentication value σ cor-
responding to sender’s signature cannot be generated by the
receiver. In addition, Zheng’s signcryption suﬀers from the
x-security deﬁned in [17]:1 the leakage of the DH-exponent
x causes the exposure of sender’s static secret-key a or the
pre-shared secrecy P S (for Zheng’s signcryption, both a and
P S are exposed). This leads us to the following motivating
question.

Motivating Question 1
Can we come up with a cryptographic mechanism
that satisﬁes: (1) forward ID-privacy, (2) being rel-
atively as eﬃcient as HOMQV, (3) receiver denia-
bility, and (4) x-security?

Authenticated key-exchange (AKE), in particular Diﬃe-
Hellman (DH), plays a fundamental role in modern cryp-
tography, and is the backbone of a list of network security
protocols that are widely standardized and in use. Up to
now, the most eﬃcient AKE protocols are (H)MQV [27, 20]
and OAKE [36], but none of them considers ID-concealment.
In the client/server setting, TLS1.3 and QUIC represent the
most eﬃcient secure channel establishment protocols, both
of which support ID-concealment. The protocol structure of
QUIC, brieﬂy described in Appendix B, is conceptually sim-
ple and enjoys the advantages of eﬃciency, receiver deniabil-
ity, and deployment ﬂexibility. However, QUIC (even with-
out 0-RTT connection) does not enjoy forward ID-privacy.
Speciﬁcally, the compromising of server’s static secret-key
will expose the shared-key K1 for encrypting server’s DH-
component Y , and consequently server’s ID-privacy is lost.
The basic authentication mechanism of TLS1.3 is based on
the SIGMA scheme [19], which is also brieﬂy described in
Appendix B. For presentation simplicity, by TLS1.3 we

1This is actually named as y-security in [17], where the
player pidB plays the role of sender.

mean the core authentication mechanism presented there.
TLS1.3 uses signature for server authentication, which has
the following eﬀects. On the one hand, when implemented
with EC-DSA, it can be less eﬃcient than QUIC, and suﬀers
from the shortcoming of DSA-type signature (i.e., the expo-
sure of random nonce, which can be oﬄine generated and
stored for online signature generation, will cause exposure
of static secret-key). Since its sixth version, TLS1.3 incor-
porates the OPTLS protocol [22], which is also described
in Appendix B. Brieﬂy speaking, OPTLS is as eﬃcient as
QUIC, while enjoys forward ID-privacy. But none of QUIC,
TLS1.3 and OPTLS enjoys x-security, i.e., the exposure of
DH-exponent in a session will expose the session-key (for
QUIC and TLS1.3) or server’s ID (for OPTLS). This leads
to the following motivating question.
Motivating Question 2
Can we come up with new AKE schemes, which
satisfy simultaneously: (1) forward ID-privacy, (2)
better eﬃciency than QUIC and OPTLS, (3) x-
security, (4) receiver deniability, and (5) being free
of signatures?

We note that existing security deﬁnition frameworks for
AKE or secure channel establishment are not well suitable
for identity-concealed AKE (CAKE). Traditional CK-framework
[8] and its variants (e.g., the post-ID CK-framework [9])
are not applicable to the analysis of CAKE. Session match-
ing, which is at the heart of deﬁning AKE security in CK-
framework, critically relies on the fact that players’ identi-
ties and public-keys are exchanged explicitly, and thus can
be publicly veriﬁed according to session transcripts alone.
Public veriﬁcation of session matching is, in turn, crucial for
provable composition with subsequent symmetric-key cryp-
tographic primitives [8, 5].

In the BR-framework [4], session matching is deﬁned w.r.t.
two sessions of the identical session transcript. Security ac-
cording to the BR-framework requires that two sessions of
diﬀerent transcripts must have diﬀerent session keys (other-
wise, the security can be trivially broken). Such a require-
ment appears to be too strict, which causes limited applica-
bility or more complex analysis, as the following examples
demonstrated: (1) An adversary could possibly cause two
un-matching sessions: one complete session, and one incom-
plete session where the last message is simply dropped by
the adversary, to be of the same session-key; (2) Consider
AKE protocols, e.g., the TLS handshake, where some pro-
tocol messages are encrypted by a probabilistic symmetric
encryption scheme using keys derived from some prelimi-
nary shared key (PSK). For such protocols, an adversary
could get P SK in one session (e.g., by a state reveal query),
and then use P SK to re-encrypt plaintext messages of the
exposed session in another session. This can also cause two
sessions of diﬀerent transcripts to have the same session-key;
(3) For AKE protocols deployed in a complex or critical sys-
tem, we may want them to enjoy some capability of fault
tolerance, in the sense that the loss or modiﬁcation of some
values (e.g., caused by transmission in a poor network) could
be tolerated or recovered. However, such an approach is not
well supported by the BR-framework.

Identity privacy for secure transport protocols was also
formulated in some existing works (e.g., [6]). But ID-privacy
was treated separately from the security deﬁnition for au-
thenticated key-exchange or channel establishment.

1465Recently, a new security deﬁnitional framework for multi-
stage key-exchange (MSKE) protocols was introduced [15,
12, 5], whose power is proven in analyzing secure transport
protocols like QUIC [15] and TLS1.3 [12]. We notice that
the MSKE framework is not well applicable to CAKE either,
on the following grounds.

Firstly, ID-privacy was not considered in the MSKE frame-
work [15, 12, 5]. Secondly, to apply the MSKE framework to
analyzing a CAKE protocol, we need to allow the adversary
to expose the intermediate key, denoted kid, used to encrypt
player’s identity information, as is done in [15, 12, 5]. This
means that we have to divide the (actually single) session
run of a CAKE protocol into several stages, such that the
partial session run upon agreeing kid should be treated as
one separate stage [15, 12]. In the MSKE framework, it is
assumed that during the session run, once a stage is ﬁn-
ished, the protocol execution is immediately suspended and
the control is returned to the adversary. This could lead to
several negative eﬀects, as discussed below.

• The way of dividing a single CAKE protocol run into
multiple stages, and suspending and giving control to
adversary immediately upon completion of each stage,
may be unnatural and even unrealistic. It may be the
case that the messages sent by a player in one round
(in a single ﬂow or even in a single packet) may have to
be divided into diﬀerent stages. For example, with our
CAKE protocol implementations, the DH-component
and the accompanying AEAD ciphertext sent in the
same round have to be divided into diﬀerent stages:
the DH-component belongs to an anterior stage which
agrees on the key kid (that will be exposed to adversary
to argue the security of the subsequent stage), while
the AEAD ciphertext belongs to a subsequent stage.
• It may result in unnatural modeling of secrecy ex-
posure. Speciﬁcally, the intermediate key kid is usu-
ally transient, particularly compared with some oﬄine
computed and stored values like DH-exponents and
static secret-keys. If we grant the adversary the abil-
ity to expose so temporal secrecy like kid, no security
guarantee could be made. On the other hand, if the
ephemeral secrecy like kid is allowed to be exposed but
the exposure of long-lived states (like DH-exponents
that can be oﬄine pre-computed and stored) is de-
nied, as is made in [15, 12], it leads to unnatural or
unrealistic modeling of secrecy exposure.

Thirdly, in this work we focus on deﬁnitional framework
allowing a powerful concurrent man-in-the-middle (CMIM)
adversary with adaptive party registration and strong capa-
bility of secrecy exposure. We note that, in the formulation
of the MSKE framework [15, 12], the adversary is not al-
lowed to adaptive register users, has limited capability of
secrecy exposure (where exposing DH-exponent is denied,
and static secret-key exposure is not distinguished from user
corruption), and is required to indicate the authentication
type upon session initiation.

As a consequence, it would be much desirable to develop
a new deﬁnitional framework for CAKE, which enjoys the
following advantages simultaneously. (1) Composability: it
veriﬁes session matching in public, thus salvaging the com-
posability; (2) Conciseness:
it integrates both AKE secu-
rity and identity privacy, simplifying security deﬁnition and
analysis; (3) Uniﬁcation: it uniﬁes the dominant frameworks

of BR, CK and post-ID CK; (4) Robustness and versatility:
it allows powerful CMIM adversary with adaptive party reg-
istration and strong capability of secrecy exposure, and im-
plies a list of important security properties in reality, like
unknown key share (UKS), key compromise impersonation
(KCI), concurrent non-malleability (CNM), perfect forward
security (PFS), strong resilience to secrecy exposure, some
of which are beyond the traditional CK or BR frameworks.

Motivating Question 3
Can we come up with a new deﬁnitional framework
for identity-concealed AKE, which enjoys simulta-
neously: (1) public checkability of session match-
ing, (2) conciseness (3) uniﬁcation, and (4) robust-
ness and versatility?

1.1 Contributions

In this work, we systematically solve the above three mo-
tivating questions. For the ﬁrst motivating question, we
introduce a new primitive, referred to as hiding-identity
signcryption (higncryption, for short), which integrates public-
key encryption, digital signature and ID-concealment into a
monolithic primitive in a solid and practical way. We then
present the security deﬁnitional framework for higncryption,
and a conceptually simple (yet carefully designed) construc-
tion of higncryption, with detailed comparisons with Zheng’s
signcryption and HOMQV.

As a new primitive, higncryption may be of independent
value and can have many applications. A direct applica-
tion of higncryption is one-pass ID-concealed authenticated
key-exchange protocol, which can, in turn, be applied to key-
wrapping. We make in-depth discussions on its applications
to 0-RTT authentication, showing higncryption is well suit-
able to (and compatible with) QUIC and OPTLS. Then, we
discuss the implication of higncryption to (identity-concealed )
AKE (CAKE) server-only authenticated unilateral CAKE
(UCAKE), with comparisons with QUIC, OPTLS and TLS1.3
in accordance with the second motivating question.

For the third motivating question, a new concise security
deﬁnitional framework for CAKE and UCAKE is proposed
in this work, which uniﬁes the traditional BR and (post-ID)
frameworks, enjoys public checkability of session matching,
and ensures very strong security guarantee.

All the protocols developed in this work are provably se-
cure under standard assumptions in the random oracle (RO)
model. In order to support more eﬃcient and ﬂexible deploy-
ments while still preserving provable security, we introduce a
new family of problems and assumptions related to a variant
of the DL-problem, referred to as ﬂexible DL (FDL) prob-
lem. We study the complexity of FDL and related problems
in the generic group model, showing their intractability hold
in the generic group model, which might be of independent
interest (e.g., to leakage-resilient cryptography).

2. PRELIMINARIES

If S is a ﬁnite set then |S| is its cardinality, and x ← S
is the operation of picking an element uniformly at random
from S. If S denotes a probability distribution, x ← S is the
operation of picking an element according to S. We overload
the notion for probabilistic or stateful algorithms, writing
V ← Alg to mean that algorithm Alg runs and outputs
value named V . If α is neither an algorithm nor a set then

1466x ← α is a simple assignment statement. A string or value
α means a binary one, and |α| is its binary length. For two
strings x, y ∈ {0, 1}∗, x||y denotes their concatenation.
Let G(cid:48) be an abelian group of order N , and G = (cid:104)g(cid:105) be a
unique subgroup of G(cid:48) generated by the generator g of prime
order q. Throughout this work, the group law is written
multiplicatively, and the length of q, i.e., |q|, serves as the
security parameter. Denote by 1G the identity element of
G(cid:48), by G \ 1G the set of elements of G except 1G, and by
ρ = N/q the cofactor value. When instantiated with groups
based on elliptic curves, G(cid:48) is the group of points E(L) on
an elliptic curve E deﬁned over a ﬁnite ﬁeld L, and G is a
subgroup of E(L) of prime order q. For elliptic curve based
groups, the cofactor ρ is typically very small.
The discrete logarithm (DL) assumption over G says that
given X = gx, where x ← Z∗
q , no probabilistic polynomial-
time (PPT) DL-solver algorithm can output x with non-
negligible probability. The computational Diﬃe-Hellman
(CDH) assumption says that given X = gx, Y = gy, where
x, y ← Z∗
q , no probabilistic polynomial-time CDH-solver al-
gorithm can compute CDH(X, Y ) = gxy with non-negligible
probability. The Gap Diﬃe-Hellman (GDH) assumption
says that the CDH assumption holds, even if the CDH solver
is equipped with a decisional Diﬃe-Hellman (DDH) oracle
for G and g, where on arbitrary input (U, V, Z) ∈ G3 the
DDH oracle outputs 1 if and only if Z = CDH(U, V ).

Authenticated encryption. Brieﬂy speaking, an au-
thenticated encryption with associated data (AEAD) scheme
transforms a message M and a public header information H
(e.g., a packet header, an IP address) into a ciphertext C in
such a way that C provides both privacy (of M ) and authen-
ticity (of C and H) [29]. In practice, when AEAD is used
within cryptographic systems, the associated data is usually
implicitly determined from the context (e.g., the hash of the
transcript of protocol run or some pre-determined states).

Let SE = (Kse, Enc, Dec) be a symmetric encryption scheme.

a ﬁnite and non-empty set K(cid:84){0, 1}κ. For presentation

The probabilistic polynomial-time algorithm Kse takes the
security parameter κ as input and samples a key K from
simplicity, we assume K ← K = {0, 1}κ. The polynomial-
time encryption algorithm Enc : K × {0, 1}∗ × {0, 1}∗ →
{0, 1}∗ ∪ {⊥} and the (deterministic) polynomial-time de-
cryption algorithm Enc : K×{0, 1}∗×{0, 1}∗ → {0, 1}∗∪{⊥}
satisfy: for any K ← K, any associate data H ∈ {0, 1}∗ and
any message M ∈ {0, 1}∗, if EncK (H, M ) outputs C (cid:54)= ⊥,
then DncK (C) always outputs M . Here, we assume the ci-
phertext C bears the associate data H in plain.

Let A be an adversary. Table 1 describes the security
game for AEAD. We deﬁne the advantage of A to be Advaead

SE returns true] − 1(cid:12)(cid:12). We say that the SE

=(cid:12)(cid:12)2 · Pr[AEADA

(A)

SE

scheme is AEAD-secure, if for any suﬃciently large κ the
advantage of any PPT adversary is negligible.

The above AEAD security is quite strong.

In partic-
ular, it means that, after adaptively seeing a polynomial
number of ciphertexts, an eﬃcient adversary is unable to
generate a new valid ciphertext in the sense its decryp-
tion is not “⊥”. Also, for two independent keys K, K(cid:48) ←
Kse and any message M and any header information H,
Pr[DecK(cid:48) (EncK (H, M )) (cid:54)= ⊥] is negligible [28].

main AEADA
K ← Kse
σ ← {0, 1}
σ(cid:48) = AEnc,Dec
Ret (σ(cid:48) = σ)

SE: proc. Enc(H, M0, M1): proc. Dec(C(cid:48)):
If σ = 1 ∧ C(cid:48) /∈ C
Ret DecK (C(cid:48))
Ret ⊥

If |M0| (cid:54)= |M1|, Ret ⊥
C0 ← EncK (H, M0)
C1 ← Enc(H, M1)
If C0 = ⊥ or C1 = ⊥
C ∪← Cσ; Ret Cσ

Ret ⊥

Table 1: AEAD security game

3. STRONG SECURITY MODEL FOR

HIGNCRYPTION

A higncryption scheme HC, with associated data, is speci-
ﬁed by four polynomial-time algorithms: setup, keygen, hign-
crypt and unhigncrypt.

setup: a PPT algorithm that takes the security parameter
κ as input, and outputs the system parameter params to
be used in the scheme. We assume the security parame-
ter is always (maybe implicitly) encoded in params.

key-gen: a PPT algorithm that takes params as input,
and outputs a public-private key pair (pk, sk) used for
higncryption and unhigncryption. For presentation sim-
plicity, we assume params is included in pk.

higncrypt: a PPT algorithm that takes as input a sender’s
private key sks, the sender’s public identity information
pids = (ids, pks, certs) where certs is sender’s certiﬁ-
cate issued by a certiﬁcate authority (CA), a receiver’s
public identity information pidr = (idr, pkr, certr), mes-
sage M ∈ {0, 1}∗ and associated data H ∈ {0, 1}∗ to
It returns a higncryptext C, or the
be higncrypted.
symbol ⊥ indicating higncryption failure. The associ-
ated data H, if any, appears in clear in the higncryptext
C (cid:54)= ⊥.
In this work, we allow a user to highcrypt a
message to itself; that is, pids = (ids, pks, certs) may be
equal to pidr = (idr, pkr, certr). Also, we assume that
some oﬄine-computable intermediate randomness, e.g.,
the DH-exponent used in generating the higncryptext C,
is speciﬁed and stored in a variable ST C that could be
exposed to allow for a more robust security deﬁnition.

unhigncrypt: a deterministic polynomial-time algorithm that
takes, as input, a receiver’s private key skr, the receiver’s
public identity information pidr = (idr, pkr, certr), and
a higncryptext C. It outputs either (pids, M ) or an error
symbol ⊥. Note that, unhigncrypt does not take sender’s
public identity information pids as input.

The correctness for higncryption can be trivially deﬁned.
Below, we focus on the strong security model for higncryp-
tion in the multi-user setting, where each user possesses a
single key pair for both higncryption and unhigncrypton and
can higncrypt messages to itself, and the adversary is allowed
to adaptively register (dishonest) users.

Let n be the number of users in the system, where n is
polynomial in the security parameter κ. The key pairs of all
the honest parties in the system are generated by the chal-
lenger according to the speciﬁed key generation algorithm.
The adversary is given the public keys of all the honest users
initially, and can register arbitrary public keys (for dishon-
est parties) on its own. Denote by HONEST (reps., DIS-
HONEST) the set of public identity information for all the
honest (resp., dishonest) parties in the system. Throughout
this work, denote by pidi, 1 ≤ i ≤ n, the pubic identity
information of user idi, and by pids (resp., pidr) the public

1467identity information of the sender (resp., the receiver). The
adversary is also given access to HO, UHO, EXO and Corrupt
oracles, as speciﬁed below.

HO: On input (pids, pidr, H, M ) where pidr ∈ HONEST(cid:83)

DISHONEST and pidr may be equal to pids, H, M ∈
{0, 1}∗, HO returns C = higncrypt(sks, pids, pidr, H, M ))
if pids ∈ HONEST; Otherwise, it returns ⊥. HO also
stores, in private, some speciﬁed oﬄine-computable in-
termediate randomness (in generating C) into ST C in
order to allow for later EXO query against C.

UHO: On input (pidr, C), it returns unhigncrypt(skr, pidr, C))

if pidr ∈ HONEST; Otherwise, it returns ⊥.

EXO (exposure oracle): On input C (cid:54)= ⊥, EXO returns the
value stored in ST C , i.e., the oﬄine-computable inter-
mediate randomness used in generating C, if C was
output by an earlier HO query. Otherwise, ⊥ is re-
turned. This renders the adversary additional power,
in contrast to traditional security deﬁnition of sign-
cryption, and reﬂects the reality of bad randomness,
various side-channel attacks and deployment in hostile
environments (plagued with spyware or virus) where
oﬄine-computable values are more vulnerable to ad-
versarial exposure.

Corrupt: On input pidi ∈ HONEST, 1 ≤ i ≤ n, this oracle

returns the private key ski of user idi.

Outsider unforgeability (OU). The goal of an OU-adversary
AOU against HC is to forge a valid higncryptext created by
an uncorrupted honest user pids∗ for another uncorrupted
honest user pidr∗ , where pids∗ may be equal to pidr∗ , 1 ≤
r∗, s∗ ≤ n. Toward this goal, AOU is allowed to issue
HO, UHO, EXO and Corrupt queries. At the end of its
execution, AOU outputs (pidr∗ , C∗) as its forgery, where
pidr∗ ∈ HONEST and the associated data contained in C∗
in clear is denoted H∗. The advantage of AOU for breaking
outsider unforgeability, denoted AdvAOU ,HC, is deﬁned to
be the probability that the following hold simultaneously:
– unhigncrypt(skr∗ , pidr∗ , C∗) = (pids∗ , M∗), where pids∗ ∈
HONEST.
– AOU has not issued Corrupt(pids∗ ) query or Corrupt(pidr∗ )
query. But AOU is allowed to query EXO(C∗) to expose
the intermediate randomness used in generating C∗.
– C∗ was not the output of HO(pids∗ , pidr∗ , H∗, M∗) issued
by AOU . But AOU is still allowed to query HO(pids(cid:48) , pidr(cid:48) ,
H(cid:48), M(cid:48)) for (pids(cid:48) , pidr(cid:48) , H(cid:48), M(cid:48)) (cid:54)= (pids∗ , pidr∗ , H∗, M∗),
in particular (pids∗ , pidr∗ , H(cid:48), M∗) where H(cid:48) (cid:54)= H∗, and
can even query HO(pids∗ , pidr∗ , H∗, M∗) as long as the
output returned is not equal to C∗. Also, parts of C∗
(e.g., H∗) may appear in the previous outputs of HO.

In traditional deﬁnitions of unforgeability for signcryption,
AOU is required to output (pids∗ , pidr∗ , M∗, C∗) as its forgery
at the end of its execution, which implies that it “knows” the
victim user pids∗ and the message M∗ being signcrypted.
In comparison, our formulation does not make such a re-
quirement. That is, AOU may know neither pids∗ nor M∗,
even if (pidr∗ , C∗) is a valid forgery. Our security deﬁnition
allows the exposure of ST C∗ , i.e., the intermediate random-
ness used for generating the target higncryptext C∗, which is
also not allowed in traditional models of signcryption. Also,
security of associated data was not considered in traditional
security deﬁnitions of signcryption, while strong unforge-
ability for the associated data is ensured by our deﬁnition.

Consequently, our unforgeability formulation provides much
more comprehensive and stronger security guarantee.
A higncryption scheme HC has outside unforgeability, if for
any PPT adversary AOU its advantage AdvAOU ,HC is negli-
gible for any suﬃciently large security parameter. The deﬁ-
nition of inside unforgeability is almost the same as that of
outside unforgeability, except that oracle query Corrupt(pidr∗ )
is allowed to the adversary.
Insider conﬁdentiality. The goal of an insider conﬁden-
tiality adversary AIC is to break the conﬁdentiality of the
message or the public identity information higncrypted to
an uncorrupted honest target receiver by any (possibly cor-
rupted ) honest sender, even if AIC is allowed to corrupt the
sender and to expose the intermediate randomness used for
generating other highcyptexts. For presentation simplicity,
throughout this work we assume that all the users in the sys-
tem have public identity information of equal length. But
our security model and protocol constructions can be ex-
tended to the general case of diﬀerent lengths of identities,
by incorporating length-hiding authenticated encryption in
the underlying security model and protocol constructions.
– Phase 1: AIC is allowed to issue HO, UHO, EXO and
– Challenge: At the end of phase 1, AIC outputs a pair
of equal-length messages (M0, M1), an associated data
H∗, and two pairs of (pids∗
, pidr∗ ) of
, pidr∗ ∈ HONEST, and
equal lengths, where pids∗
submits them to the challenger. The challenger takes
σ ← {0, 1}, and gives AIC the challenge higncryptext
C∗ = higncrypt(sks∗
(For sim-
plicity, we do not model receiver ID-privacy, which can
be extended by indicating a pair of challenge receivers.)
– Phase 2: AIC can continue executing as in phase 1, ex-
cept asking UHO(pidr∗ , C∗) or EXO(C∗) or Corrupt(pidr∗ )
that will cause AIC to trivially win the game. But AIC is
allowed to issue Corrupt(pids∗
), which
0
captures forward ID-privacy.
– Guess: Finally, AIC outputs a bit σ(cid:48), as the guess of the
random bit σ. AIC wins the game, if σ(cid:48) = σ.

σ , pidr∗ , H∗, Mσ).

) and Corrupt(pids∗

, pidr∗ ) and (pids∗

Corrupt queries.

σ , pids∗

, pids∗

A higncryption scheme HC has insider conﬁdentiality, if for
any PPT adversary AIC and any suﬃciently large security
parameter, its advantage deﬁned below is negligible:

AdvAIC ,HC =(cid:12)(cid:12)2 · P r[σ

= σ] − 1(cid:12)(cid:12) .

(cid:48)

1

0

0

1

1

4. CONSTRUCTION OF HIGNCRYPTION
Our starting point is the underlying mechanism, namely

non-malleable joint proof-of-knowledge (NMJPOK), for OAKE
[36] as follows. Given a challenge Y = gy, the prover with
static pidA = {idA, A = ga, certA} and ephemeral X = gx
can non-malleably prove its joint knowledge of (a, x), by
sending {pidA, X, N M JP OK(a, x) = Y a+xd} where d =
h(X, pidA, Y ). To hide user identity, a new mechanism, re-
ferred to as concealed non-malleable joint proof-of-knowledge
(CNJPOK), is introduced, which can be viewed as the dual
of NMJPOK. With CNJPOK, the prover sends {X = AX d, C =
AEK (pidA, X)}, where K is derived from CHD(X, Y ). This
directly leads to a two-round UCAKE protocol. Our hign-
cryption is built upon CNJPOK, by replacing Y with re-
ceiver’s public identity information.

Setup. On the security parameter κ, setup(1κ) returns
params = (G(cid:48), N, G, g, q) specifying the underlying group
over which the GDH assumption holds.

1468Key generation. On the parameters params, for each
honest user i, 1 ≤ i ≤ n, keygen takes xi ← Z∗
q , sets pki =
gxi ∈ G and ski = xi, and outputs the key-pair (pki, ski).
The binding between user identity idi and its public-key
pki is authenticated by a certiﬁcate certi issued by CA.
Throughout this paper, unless otherwise stated, we assume
that CA does not mandate proof-of-possession or proof-of-
knowledge of secret key during public key registration, but
it performs sub-group membership check for each registered
public key, i.e., checking pki ∈ G \ 1G.
In this work, we
assume users’ identities and public-key information to be of
equal lengths; Otherwise, we need stateful length-hiding au-
thenticated encryption (SLHAE) as deﬁned in [28, 21].
Higncryption. Let SE = (Kse, Enc, Dec) be an AEAD
scheme, h : {0, 1}∗ → {0, 1}l ∩ Z∗
q be a cryptographic hash
function where l = (cid:100)|q|/2(cid:101), M ∈ {0, 1}∗ be the message
to be higncrypted with associated data H, and KDF :
G × {0, 1}∗ → {0, 1}∗ be a key derivation function, where
K is the key space of Kse. For presentation simplicity, we
denote by Alice the sender who possesses public identity
information pidA = (idA, pkA = A = ga ∈ G, certA) and
secret-key skA = a ← Z∗
q , and by Bob the receiver who pos-
sesses public identity information pidB = (idB, pkB = B =
gb ∈ G, certB) and secret-key skB = b ← Z∗
q .
higncrypt(skA, pidA, pidB, H, M ) works as follows. (1) Take
x ← Z∗
q , compute X = gx ∈ G, d = h(X, pidA, pidB), and
X(cid:48) = X d. The DH-exponent x can be generated oﬄine, and
is speciﬁed to be stored into ST C that may suﬀer from ad-
versarial exposure. (2) Compute X = AX(cid:48) = AX d,2 and
pre-shared secrecy P S = CDH(X, B) = Ba+xd ∈ G. (3)
Derive keys (K1, K2) = KDF (P S, X||pidB), where K1 ∈
K, K2 is empty for higncryption, or K2 ∈ K for one-pass
identity-concealed AKE and in this case the joint distribu-
tion of (K1, K2) is computationally indistinguishable from
uniform distribution over K × K.
(4) Compute CAE ←
EncK1 (H, pidA||X||M ). Notice that the DH-component X
is sent being encrypted.
(5) Send the higncryptext C =
(H, X, CAE) to receiver.
Unhigncryption. After receiving C = (H, X, CAE), un-
higncrypt(skB = b, pidB, C) works as follows. (1) Compute
the pre-shared secrecy P S = CDH(B, X) = X
, and de-
rive the keys (K1, K2) = KDF (P S, X||pidB).
(2) Run
DecK1 (H, CAE). If DecK1 (H, CAE) returns ⊥, abort; oth-
erwise, get {pidA = (idA, A, certA), X, M )}. (3) Compute
d = h(X, pidA, pidB). If X = AX d and pidA is valid, accept
(pidA, M ); otherwise, abort.

b

This integrated scheme of higncryption and one-pass identity-

concealed AKE is also presented in Figure 1.
4.1 Discussion and Clariﬁcations
Note on subgroup test of X. In the above protocol descrip-
tion, we have assumed the receiver checks that X is in the
subgroup G of order q in G(cid:48). Note that, if the cofactor ρ is
small, the subgroup test of X can be essentially reduced to
check X ∈ G(cid:48) and X
ρ (cid:54)= 1G, which guarantees X is not in a
small subgroup of G(cid:48) of the order being a factor of ρ (though
it may not fully ensure X ∈ G). In practice, we recommend
the following variant with embedded subgroup test, where

2An alternative way is to set X = AdX, which does not
sacriﬁce provable security. We prefer to setting X = AX d,
for the reason that, as we shall see in Section 6, it allows
more ﬂexible and eﬃcient implementations.

pidA
P KA : A = ga
SKA : a ← Z∗
q
x ← Z∗
q , X = gx
d = h(X, pidA, pidB)
X = AX d, P S = Ba+xd
(K1, K2) = KDF (P S, X||pidB)

pidB
P KB : B = gb
SKB : b ← Z∗
q

H, X, CAE ← EncK1(H, pidA||X||M ))

b

P S = X
(K1, K2) = KDF (P S, X||pidB)
DecK1(H, CAE) = (pidA, X, M )
d = h(X, pidA, pidB)
Accept if pidA is valid and X = AX d

Figure 1: Protocol structure of higncryption

and the receiver will abort if X (cid:54)∈ G(cid:48)
P S = Bρ(a+xd) = X
or P S = 1G. We note that the subgroup test can be waived,
if the EXO queries are disallowed in the security model.

ρb

One-pass identity-concealed AKE. It is shown in [17, 16] that
signcryption implies one-pass AKE by setting the message
M just to be the random session-key. But the session-key
derived this way is dependent on the key generated for sign-
cryption. When casting our higncryption scheme into one-
pass identity-concealed AKE, we set the session-key to be K2
that is computationally independent of the key K1 used for
higncryption; that is, the exposure of K1 does not aﬀect the
session-key security. Another variant is to set the session-
key of one-pass AKE to be KDF (CDH(P S, X||pidA||pidB).
This provides extra security guarantee, as X is exchanged
in the encrypted form.

Flexible implementations. Our higncryption scheme allows
much ﬂexible implementations, according to priorities and
tradeoﬀs among security and eﬃciency in diﬀerent applica-
tion scenarios. Let X be a well-spread distribution over some
q with min-entropy λX > ω(log |q|). For ﬂexible
subsets of Z∗
implementations of higncryption, the only modiﬁcation is:
X = gx where x is taken according to X (rather than Z∗
q ).
As we shall show, provable security still holds with such a
ﬂexible implementation of higncryption.
In practice, at one’s own discretion according to applica-
tion scenarios, the sender can take x ← {0, 1}(cid:100)|q|/4(cid:101) ∩ Z∗
(referred to as light-higncryption), or x ← {0, 1}(cid:100)|q|/2(cid:101) ∩ Z∗
(referred to as medium-higncryption), or just x ← Z∗
q
q (re-
ferred to as full -higncryption). For example, if |q| = 512,
we suggest |x| = 128 = |q|/4 (i.e., light-higncryption) may
suﬃce for many applications. Note that the security of light-
higncryption, even if sender’s static secret-key is exposed to
adversary, is not reduced to solving a quarter DL-problem.
Actually, computing X from X(cid:48) = X h(X) seems already to be
hard, let along computing the exponent x ← {0, 1}(cid:100)|q|/4(cid:101)∩Z∗
q .
Brief comparison. A brief comparison, among l -higncryption

q

(referring to light-higncryption), (full ) higncryption, (Zheng’s)
signcryption, and HOMQV, is in Table 2. For eﬃciency com-
parison, we only count the number of modular exponentia-
tions (denoted “exp.”) with standard computation technique.
We note that, by using the speed-up technique of simulta-
neous exponentiation that may be less common, receiver ef-
ﬁciency of HOMQV and Zheng’s signcryption is about 1.2
exo. “x-security” refers to that the leakage of DH-exponent
should not expose session-key or sender’s identity.

1469hign-

sign-

eﬃciency

sender
receiver
forward ID-privacy

x-security

receiver-deniability

l-hign-
cryption
1.75exp.
1.5exp.

√
√
√

cryption
2.5exp.
1.5exp.

√
√
√

HOMQV

2exp.
1.5exp.

(cid:34)

√
√

cryption
1exp.
2exp.

(cid:34)
(cid:34)
(cid:34)

Table 2: Comparison with Zheng’s signcryption and HOMQV

5. SECURITY PROOF OF HIGNCRYPTION
In the following security analysis, KDF and h are mod-
eled to be random oracles (RO). As we concentrate on the
security of the higncryption scheme, for presentation sim-
plicity, for now we assume K1 = KDF (P S, X||pidB) (i.e.,
the session-key K2 for one-pass CAKE is set to be empty).
Throughout this work, for presentation simplicity, we also
write CDH(U,·) simply as CDH(pid,·) when U denotes the
public-key of user pid.

Theorem 5.1. The higncryption scheme presented in Fig-
ure 1 satisﬁes outsider unforgeability and insider conﬁden-
tiality in the random oracle model, under the AEAD security
and the GDH assumption (respectively, under the AEAD se-
curity and the HGDH and FGDL assumptions, for its ﬂex-
ible implementations when x ← X where X is a well-spread
distribution over Z∗
q ).
5.1 Security Proof of Outsider Unforgeability
Suppose that, after a series of adaptive oracle queries to
HO, UHO, EXO and Corrupt, with non-negligible probability
the forger AOU outputs a pair (pidr∗ , C∗), where C∗ con-
tains in clear the associated data H∗, satisfying:
– unhigncrypt(skr∗ , pidr∗ , C∗) = (pids∗ , M∗), but C∗ was
not the output of HO(pids∗ , pidr∗ , H∗, M∗) issued by
AOU . Note that AOU is still allowed to query HO(pids(cid:48) , pidr(cid:48) ,
H(cid:48), M(cid:48)) for (pids(cid:48) , pidr(cid:48) , H(cid:48), M(cid:48)) (cid:54)= (pids∗ , pidr∗ , H∗, M∗),
and can even query HO(pids∗ , pidr∗ , H∗, M∗) as long as
the output returned is not equal to C∗.
– pids∗ , pidr∗ ∈ HONEST, and AOU has not issued Cor-
rupt(pids∗ ) or Corrupt(pidr∗ ). But EXO(C∗) is allowed.
We assume the pair of honest users (pids∗ , pidr∗ ), for which
successful forgery occurs with non-negligible probability, are
ﬁxed in advance, which can actually be correctly guessed
n2 . We also assume that (pidr∗ , C∗) is the
with probability 1
ﬁrst successful forgery output by AOU ; that is, it did not
query UHO(pidr, C) such that (pidr, C) is also a successful
forgery before outputting (pidr∗ , C∗). All these assumptions
are only for presentation simplicity.
Denote by pks∗ (resp., pkr∗ ) the public-key of the sender
(resp., receiver) included in pids∗ (resp., pidr∗ ). Given (pids∗ ,
pidr∗ ), we construct a simulator S whose goal is to com-
pute CDH(pks∗ , pkr∗ ) with the aid of a DDH-oracle, condi-
tioned on that unforgeability is broken with non-negligible
probability. We present the proof directly for the case of
pids∗ = pidr∗ , which is commonly viewed as the relatively
harder case. The proof can be straightforwardly extended
to the case of pids∗ (cid:54)= pidr∗ .
For presentation simplicity, denote pids∗ = pidr∗ = pidA
with public-key A = ga, where a ← Z∗
q that is unknown to
S. The simulator S takes (params, pidA) as input, and its
goal is to compute CDH(A, A) = ga2
with the aid of a DDH
oracle. It is well known that computing CDH(A, A) is as
hard as breaking the standard CDH assumption. Toward

b

this goal, S sets the public-key for user s∗ = r∗ to be A, and
sets the public and secret keys for all the other honest users
in the system on its own. As a consequence, S can act on
behalf of all the honest users except pidA. Below, we focus
on the simulation of pidA by S in order to deal with oracle
queries made by the forger AOU against pidA.
First note S can perfectly handle all the Corrupt queries
allowed in the security game, where neither Corrupt(pids∗ )
nor Corrupt(pidr∗ ) is allowed.
Consider a query HO(pids, pidr, H, M ), where pidr is the
public identity information of an arbitrary user in the system
with public-key pkr. First note that, if pids ∈ DISHONEST,
the output of HO(pids, pidr, H, M ) is simply deﬁned to be
“⊥”. Also, if pids ∈ HONEST but pids (cid:54)= pidA, this ora-
cle query can be perfectly handled by the simulator itself.
Hence, we only consider the case of pids = pidA below, i.e.,
HO(pidA, pidr, H, M ).
If pidr ∈ HONEST but pidr (cid:54)= pidA, let pkr = B = gb
where b ← Z∗
q is the secret-key actually set by the simulator
itself. For this case, S works as the honest pidA does, except
that P S = CDH(X, B) is computed as X
. Otherwise (i.e.,
pidr (cid:54)∈ HONEST or pidr = pidA), S computes X = gx and
X = AX d, where x ← Z∗
q and d = h(X, pidA, pidr); S then
sets K1 to be a string taken uniformly at random from K
of AEAD, computes CAE = EncK1 (H, pidA||X||M ), and re-
turns C = (H, X, CAE) as the output of HO(pidA, pidr, H, M ).
S also stores the tuple (X||pidr, K1) into a list LDDH that
is maintained by S itself and is initiated to be empty. Note
that in the latter case, S cannot compute the pre-shared se-
crecy P S = CDH(X, pkr) and consequently KDF (P S, X||pidr).
In order to keep the consistency of the random oracle KDF ,
from now on whenever the adversary AOU makes an oracle
query of the form KDF (P S(cid:48), X||pidr), S checks, based on
the list LDDH , whether P S(cid:48) = CDH(X, pkr) with the aid
of the DDH oracle; if yes, it returns the pre-set value K1.
In any case, the DH-exponent x ← Z∗
q stored into ST C
is generated by the simulator S itself. As a consequence,
S can perfectly handle all the EXO queries. So far, all the
simulation for HO, Corrupt and EXO is perfect.
For a query UHO(pidr, C = (H, X, CAE)) made by AOU ,
we only consider the case of pidr ∈ HONEST and pidr =
pidA, as the other cases can be perfectly handled by the
simulator (note that, if pidr ∈ DISHONEST, UHO simply
outputs “⊥”). S ﬁrst checks whether C was ever output
by HO(pids, pidA, H, M ) for some M ∈ {0, 1}∗ and pids ∈
HONEST, and outputs (pids, M ) if so; Otherwise, for each
KDF oracle query of the form KDF (P S, X||pidA) made
by AOU , the simulator checks whether P S = CDH(X, A)
by the aid of the DDH oracle.
If so, the simulator gets
K1 = KDF (P S, X||pidA), uses K1 to decrypt CAE, and
returns the result to AOU ; Otherwise, S returns “⊥” indi-
cating C is an invalid higncryptext for user pidr. Denote by
“failure” the event that, for some (pidA, C = (H, X, CAE))
queried to UHO by AOU , the simulator outputs “⊥” while
UHO(pidA, C) does not. Conditioned on that the “failure”
event does not occur, the simulation for UHO is perfect. Be-
low, we show that the “failure” event can occur with at most
negligible probability.

Note that the failure event has already ruled out the pos-
sibility that C was the output of HO(pidi, pidA, H, M ) for
arbitrary pidi ∈ HONEST and arbitrary (H, M ). We now
consider the possibility that C = (H, X, CAE) is the output
of HO(pidi, pidj, H, M ) made by AOU for pidj (cid:54)= pidA (and

1470arbitrary pidi, H, M ). For this case, as X||pidj (cid:54)= X||pidA, it
means that the shared-key K1 generated by the random ora-
cle KDF for computing CAE, and that for decrypting CAE
when dealing with UHO(pidA, C) in deﬁning the “failure”
event, are independent of each other. By the security of
AEAD as discussed in Section 2, UHO(pidA, C) outputs ⊥
with overwhelming probability. Thus, when the “failure”
event occurs w.r.t. UHO(pidA, C = (H, X, CAE)) where
pidA is the receiver, with overwhelming probability it holds:
(1) C was not ever output by the HO oracle; (2) AOU did not
make the KDF (P S, X||pidA) query for P S = CDH(X, A);
and (3) (H, CAE) makes up a valid AEAD ciphertext w.r.t.
K1 = KDF (CDH(X, A), X||pidA).
Below, we further consider two cases.
Case-1: K1 = KDF (CDH(X, A), X||pidA) was set by the
simulator S when dealing with a query HO(pidA, pidA,
H(cid:48), M(cid:48)).
In this case, S sets K1 without querying
the KDF oracle (but using its DDH oracle to en-
sure the inconsistency of KDF ). This implies that
by the KDF security, with overwhelming probabil-
ity, X is part of the output of HO(pidA, pidA, H(cid:48), M(cid:48))
generated by the simulator. Denote by (H(cid:48), X, C(cid:48)
AE)
the output of the simulator S when dealing with the
query HO(pidA, pidA, H(cid:48), M(cid:48)). Note that (H(cid:48), C(cid:48)
AE)
is the only AEAD ciphertext output by S w.r.t. K1.
As we assume C = (H, X, CAE)) was not ever out-
put by S in simulating the HO oracle, it means that
AE) (cid:54)= (H, CAE). This implies AOU has out-
(H(cid:48), C(cid:48)
put a new valid AEAD ciphertext (H(cid:48), C(cid:48)
AE) w.r.t.
K1, which can occur with negligible probability by the
AEAD security.

Case-2: Otherwise, with overwhelming probability, K1 was
neither set by S nor ever deﬁned for the KDF oracle.
In this case, also by the AEAD security, “failure” occurs
with negligible probability.

AE)) the successful forgery

∗

∗

, C∗

Then, we conclude that the failure event can occur with at
most negligible probability, and consequently the view of
AOU in the simulation is indistinguishable from that in its
real attack experiment. Thus, successful forgery occurs also
with non-negligible probability in the simulation.
Denote by (pidr∗ , C∗ = (H∗, X
output by AOU , satisfying unhigncrypt(skr∗ , pidr∗ , C∗) =
(pids∗ , M∗) and C∗ was not ever output by HO(pids∗ , pidr∗ ,
H∗, M∗). Here, pids∗ and pidr∗ are the uncorrupted honest
users, which are assumed to have been correctly guessed by
the simulator for presentation simplicity. Recall that we are
considering (the hardest case of) pids∗ = pidr∗ = pidA.
For (pidr∗ , C∗ = (H∗, X
, C∗
AE)) to be a successful forgery,
AOU must have made the RO query h(X∗, pids∗ , pidr∗ ) = d∗
= pks∗ X∗d∗
= AX∗d∗
such that X
(that will be checked
in unhigncrypt), where X∗ may be generated by the ad-
versary itself. Otherwise, unhigncrypt(skr∗ , pidr∗ , C∗) re-
turns ⊥ with overwhelming probability in the random oracle
model. Then, similar to the above argument for showing fail-
ure occurs with negligible probability in the UHO simulation,
by the AEAD security the adversary AOU must have made
∗||pidr∗ ) =
the RO query to get KDF (CDH(X
∗||pidA) = K∗
KDF (CDH(X
1 .
The next idea is to rewind AOU to the point that it just
made the RO query h(X∗, pids∗ , pidr∗ ) = h(X∗, pidA, pidA),
and returns a new random output d∗(cid:48). Then, by the general
forking lemma [3], with non-negligible probability AOU will

, pkr∗ ), X

, A), X

∗

∗

∗

∗

∗||pidr∗ ) prior to h(X∗, pids∗ , pidr∗ ).
∗

∗

∗

∗(cid:48)

∗

∗(cid:48)

∗

∗

∗(cid:48)

∗(cid:48)

∗(cid:48)

, A), X

∗

, A), X

, pkr∗ ), X

, pkr∗ ), X

= AX∗d∗

∗||pidr∗ )

, pkr∗ ) = CDH(X

, pkr∗ ) = CDH(X

also output a successful forgery (pidr∗ , C∗(cid:48) = (H∗(cid:48),
X

AE)) in the rewound run, where X

= AX∗d∗(cid:48)

, C∗(cid:48)

. Finally, S computes

will make the query KDF (CDH(X

, and
∗(cid:48)||pidr∗ ) =
It means that the simu-
, A) =
, pkr∗ ) = (AX∗d∗(cid:48)

), which violates GDH assumption.

)a = AaX∗d∗a, and β = CDH(X

∗(cid:48)||pidA).
KDF (CDH(X
∗
lator S can get α = CDH(X
(AX∗d∗
)a
= AaX∗d∗(cid:48)a. From (α, β), S can compute γ = CDH(X∗, pidr∗ )
= CDH(X∗, A) = (α/β)(d∗−d∗(cid:48))−1
CDH(A, A) = α/(γd∗
Unfortunately, a subtlety for correctly applying the fork-
ing lemma [3] is buried, and has been overlooked, in the
above reasoning. The subtlety is speciﬁc to our higncryption
construction, and its clariﬁcation might be of independent
interest and be instrumental in analyzing future construc-
tions of higncryption (or other identity-hiding cryptographic
schemes). Speciﬁcally, to apply the forking lemma, we need
to ensure that the RO query KDF (CDH(X
∗||pidA) must be posterior to the
= KDF (CDH(X
RO query d∗ = h(X∗, pids∗ , pidr∗ ) = h(X∗, pidA, pidA).
Denote by P S∗ = CDH(X
, A), where
∗
is the value appeared in the successful forgery.
X
In the random oracle model, there is only one approach for
AOU to make KDF (P S∗, X
, CAE) =higncrypt(pidi, pidr∗ ,
In more detail, suppose (H, X
H, M ), where pidr∗ = pidA, pidi ∈ DISHONEST or pidi ∈
HONEST but corrupted. Denote by pki = C = gc, X
=
CX di
i = Cgxidi where di = h(Xi, pidi, pidr∗ ). That is, the
target X
(appeared in the successful forgery) has already
appeared in a former output of higncrypt(pidi, pidr∗ , H, M )
i = AX∗d∗
for some pidi (cid:54)= pids∗ , satisfying X
.
Such an event is referred to as collision event. With this
event, prior to the oracle query h(X∗, pids∗ , pidr∗ ) = d∗,
∗||pidr∗ ) oracle query was either made by
the KDF (P S∗, X
the adversary AOU itself or by the honest yet corrupted
user pidi. In either case, the adversary can compute P S∗ =
is either generated directly by AOU
CDH(X
(on behalf dishonest or corrupted user pidi) or derived by
corrupting pidi and exposing xi.
The observation here is that, the collision event can occur
with at most negligible probability assuming h is an RO.
Speciﬁcally, for any pair of (pidi, pidj, X) (cid:54)= (pidi(cid:48) , pidj(cid:48) , X(cid:48)),
(cid:48)h(X(cid:48),pidi(cid:48) ,pidj(cid:48) )] ≤ 2−l,
we have Pr[pkiX h(X,pidi,pidj ) = pki(cid:48) X
where l is the output length of h. As the adversary AOU is
of polynomial time t, the probability that A could cause the
t ·2−l <
collision event to occur during its attack is at most C 2
t2 · 2−(l+1) that is negligible. This saves the applicability of
the forking lemma to higncryption, and then ﬁnishes the
proof of outsider unforgeability.
5.2 Security Proof of Insider Conﬁdentiality
For presentation simplicity, we assume the challenger C has
already correctly guessed the target receiver pidr∗ , which
n . The input given to C is (B, X∗),
happens with probability 1
where B, X∗ ← G \ 1G. Denote by B = gb and X∗ = gx∗
,
q that are unknown to C. The goal of the
where b, x∗ ← Z∗
challenger C is to compute CDH(B, X∗) with the aid of a
DDH oracle. Towards this goal, C sets the public-key of the
target receiver to be B, i.e., pkr∗ = B. C generates and sets
the public/secret key pairs for all the rest users in the system
by itself, and will act on behalf of them. As a consequence,

, A), where X

∗

= CX di

∗

∗

1471∗

, B), X

, pids∗

1

0

1

∗

, B), X

∗

∗

, B).

AE = EncK1 (H, pids∗

s0 , pidr∗ ) and (pids∗

σ. Notice that it may be the case that pids∗

C can perfectly handle the oracle queries made by the ad-
versary AIC against all the users other than pidr∗ = pidB.
Similar to the proof of outsider unforgeability, C well simu-
lates the target receiver pidB with the aid of its DDH oracle.
When AIC outputs a pair of equal-length messages (M0, M1),
the associated data H and two pairs of public identity in-
formation (pid∗
, pidr∗ ) of equal lengths,
, pidr∗ ∈ HONEST and it is assumed that
where pids∗
pidr∗ = pidB, the challenger C chooses σ ← {0, 1} and
sets the target higncryptext C∗ as follows. For presenta-
tion simplicity, denote by A = pks∗
σ the public-key of the
user s∗
σ = pidr∗
C makes oracle query to get d∗ =
and thus A = B.
σ , pidr∗ ) = h(X∗, pidA, pidB), where X∗ is the
h(X∗, pids∗
= AX∗d∗
input of C, and computes X
. Then, C checks
∗
∗||pidr∗ )
, pkr∗ ), X
whether the oracle query KDF (CDH(X
∗||pidB) has been made, with the
= KDF (CDH(X
aid of its DDH-oracle. If so, it outputs “failure”. Otherwise,
it chooses K1 uniformly at random from the key space K of
∗||pidB, K1) into the list LDDH ,
AEAD, stores the tuple (X
σ||X∗||Mσ). From
computes and returns C∗
this point on, with the aid of its DDH oracle and based
upon the list LDDH , whenever C ﬁnds that AIC makes the
∗||pidB) it just returns K1
query of KDF (CDH(X
and records CDH(X
First observe that, in the random oracle model, X∗d∗
=
gx∗d∗
is distributed uniformly at random over G\ 1G, where
x∗ ← Z∗
q and h is assumed to be an RO. Consequently,
is distributed uniformly over G \ 1G and per-
X
fectly hides the sender’s identity information, even if AIC
knows sks∗
by user corruptions. Also, this ensures
that C outputs “failure” with negligible probability. Then, by
the AEAD security, to win the insider conﬁdentiality game,
AIC has to make the RO-query KDF (CDH(X
with non-negligible probability. We remark that, for the
proof here, it actually suﬃces if the distribution of X
is
only computationally indistinguishable from uniform distri-
bution over G \ 1G.
For the ﬂexible implementations of
higncryption where x is taken over a well-spread distribu-
tion with min-entropy greater than ω(log |q|), by the ﬂexible
gap DL (FGDL) assumption presented in Appendix A, X∗d∗
) has distribution computationally in-
(and consequently X
distinguishable from the uniform distribution over G\ 1G in
the random oracle model.
Then, C rewinds AIC to the point of making the oracle
query h(X∗, pidA, pidB), redeﬁnes d∗(cid:48) = h(X∗, pidA, pidB),
and re-runs AIC from this rewinding point. By the forking
lemma, with also non-negligible probability, AIC will make
∗(cid:48)||pidB) in the re-
the oracle query KDF (CDH(X
= AX∗d∗(cid:48)
, B) =
wound run, where X
AbX∗bd∗
, C computes
CDH(X∗, B) = (α/β)(d∗−d∗(cid:48))−1
, which violates the GDH
assumption.

, B) = AbX∗bd∗(cid:48)

. From α = CDH(X

and β = CDH(X

∗

= AX∗d∗

and sks∗

1

0

∗

, B), X

∗(cid:48)

, B), X

∗

∗(cid:48)

∗(cid:48)

∗

QUIC supports two connection modes [24]: 1-RTT handles
the case when the client tries to achieve a connection with
a server for the ﬁrst time in a particular time period; And
0-RTT considers the case when the client is trying to con-
nect to a server that it has already established at least one
connection within that time period. In the initial connection
within a time period, the server generates and sends to the
client a state information stk, which is an AEAD encryp-
tion of the concatenation of the IP addresses, port numbers,
(IPC , IPS, portC , portS) and the time-stamp tsS of the server.
stk plays a role similar to that of the session ticket in TLS,
which can be used by the client in later 0-RTT connections
(as long as it does not expire and the client does not change
its IP-address).

After getting stk and server’s public identity information
denoted pidB here, the basic structure of QUIC with hign-
cryption based 0-RTT connection is presented in Figure 2.
There, tsC is client’s time-stamp, kstk is the AEAD key for
generating stk by the server. γ is an indicator variable newly
introduced here, which is set to be 1 (resp., 0) for 0-RTT
with (resp., without) client authentication. “{···}K ” de-
notes AEAD encryption using key K, where the associated
data contains the initial vector of AEAD, cid and packet se-
quence numbers. K1 is derived from CDH(X, B) and some
auxiliary information determined by the session transcript
(including cid, pkt, nonc, stk, X, pidB, etc). The applica-
tion key K2 is derived from CDH(X, Y ) and some auxiliary
information (including cid, nonc, pkt, cY , etc). Note that,
while K1 does not provide perfect forward security (PFS)
and the security against key compromising impersonation
(KCI) attacks, the ﬁnal application key K2 does.

pidA
P KA : A = ga
SKA : a ← Z∗
q
pkt = (IPC, IPS, portC, portS)
cid ← {0, 1}64, r ← {0, 1}160, nonc = (tsC, r)
x ← Z∗
X = AX d

q , X = gx, d = h(X, pidA, pidB, stk, auxd)

pidB
P KB : B = gb
SKB : b ← Z∗
kstk ← K
q

pkt, cid, nonc, stk, X,{γ, pidA, X, early data}K1

cY = {Y = gy}K1,{data}K2

y ← Z∗

q

Figure 2: QUIC with higncryption based 0-RTT connection

In order for providing more robust binding of X to the
session it resides in and for preventing replay attacks, we
set d = h(X, pidA, pidB, stk, auxd), where auxd ∈ {0, 1}∗ is
recommended to include cid and nonc. At the server side,
it uses a mechanism, called the strike-register, to make sure
that it does not process the same connection twice, by keep-
ing track of used client’s nonces within a limited amount of
time in accordance with client’s time-stamp tsC . The server
rejects a connection request from a client if its nonc is al-
ready included in its strike register or contains a time-stamp
that is outside the allowed time range. Including client time-
stamp tsC in nonc also allows the server to detect clients
whose clocks are too out-of-sync with the server (and hence
vulnerable to expired certiﬁcates). For application scenarios
where timing information may constitute a privacy concern,
we may also suggest to get nonc, in particular tsC , protected
by the AEAD encryption, rather than being sent in clear.

∗||pidB)
∗

6. APPLICATIONS TO GOOGLE’S QUIC
We note that higncryption is well compatible with the 0-
RTT mode of QUIC, and can be easily implemented. Below,
we ﬁrst review the QUIC protocol according to the speciﬁ-
cations given in [24]. Here, for presentation simplicity, the
following protocol description does not fully coincide with
(and, actually, omits many of) the technical details of QUIC.

14727. SECURITY DEFINITIONAL FRAMEWORK

FOR IDENTITY-CONCEALED AKE

and U = {U1,··· , Un} = HONEST(cid:83) DISHONEST be all

Let n denote the largest number of users in the system,

the users in the system, where the public/secret key pairs
for honest users in HONEST (resp., DISHONEST) are set
by the system (resp., the adversary itself). There is also a
set CORRUPTED ⊆ HONEST for indicating honest yet cor-
rupted users. All the sets HONEST, DISHONEST and COR-
RUPTED may be initialized to be non-empty, and adaptively
evolve during the attack. The certiﬁcate certi, for each user
of identity idi ∈ U and public-key pki, 1 ≤ i ≤ n, is issued
by a single certiﬁcate authority (CA). The public identity
information for each user is set to be pidi = (idi, pki, certi).
Again, we assume the public identity information for all the
users to be of equal length (otherwise, we need to employ
length-hiding AEAD as underlying building tool in the pro-
tocol construction).

We assume each session has a unique session-identiﬁer sid
that is simply assigned by an incremental counter. Setting
session identiﬁers via a counter is just an artefact for security
modeling. Each session, with session-identiﬁer sid, keeps in
private a local state peersid (for indicating the interacting
peer player), a local state STsid (for storing intermediate
randomness) and a local state SKsid (for storing session-
key); all of them are originally initialized to be the empty
string (meaning “undeﬁned”), and are assigned during ses-
sion run according to the protocol speciﬁcations.
A session held at user Ui is called complete or completed,
if Ui has successfully ﬁnished that session with resultant
session-key, where Ui has sent or received the last message
of that session. We say a session is incomplete or on-going,
if the session owner is still waiting for the next protocol
message. We say a session is aborted, if it stops during the
session run because of some abnormal event (e.g., failure
in authentication, etc) according to the protocol speciﬁca-
tions. Whenever a session is aborted, all its local states are
removed from memory. Whenever a session sid is completed,
STsid is removed from memory but SKsidI is still kept in
private. A session can also be expired, and for expired ses-
sions the session-keys are also canceled.
7.1 Adversarial Setting
An adversary A against a (two-party) CAKE protocol is a
CMIM, who takes as the public identity information of all
the honest users in HONEST at the onset of its attack, and
gets access to the following oracles:
Initiator: This oracle keeps a counter CT RI that is initiated
to be 0, and keeps in private a random bit σ ← {0, 1}.

• Upon receiving a special “(Start, Ui)” instruction, 1 ≤
i ≤ n, for an honest yet uncorrupted user Ui ∈ HONEST\
CORRUPTED (otherwise, this instruction is ignored),3
it sets CT RI := CRTI + 1, creates a session for the
user Ui with session-identiﬁer sidI = CT RI , and re-
turns (sidI , msg(1)
denotes the ﬁrst
sidI
protocol message of sidI . It also creates, and keeps in
private, the local states peersidI , STsidI and SKsidI .
• Upon receiving an instruction of the form “(sidI , msg∗
I as the incoming message for session sidI ,

), where msg(1)
sidI

it treats msg∗

I )”,

3But Ui may still be possibly corrupted after this query.

and promptly responds with the next protocol mes-
sage if msg∗
I is not the last protocol message for that
session; otherwise, it works according to the protocol
speciﬁcations.

• Upon receiving an instruction of “(sidI , ST-Exposure)”,
it returns the value stored in STsidI , if sidI is incom-
plete; otherwise, it ignores this instruction.

• Upon receiving “(Test, Ut0 , Ut1 )” for Ut0 , Ut1 ∈ HONEST,
where 1 ≤ t0 (cid:54)= t1 ≤ n, it sets Ut = Utσ , and acts
just as receiving the “(Start, Ut)” instruction, where the
session-identiﬁer set is denoted as sidT .

• Upon receiving “(sidI , SK-exposure)”, it returns the session-

key SKsidI , if sidI (cid:54)= sidT and sidI has been com-
pleted yet not expired.
it returns
SKsidT if σ = 1; Otherwise, it returns a value taken
uniformly at random from {0, 1}sklen where sklen de-
notes the length of session-key.

If sidI = sidT ,

Responder: This oracle keeps a counter CT RR that is ini-
tiated to be 0, and embeds in private the random bit σ used
by Initiator.

• When receiving an instruction “(Start, Uj, msg(1)

R )”, 1 ≤
j ≤ n, for an honest yet uncorrupted user Uj (oth-
erwise, the instruction is ignored), it sets CT RR :=
CRTR+1, creates a session for the user Uj with session-
identiﬁer sidR = CT RR; it then treats msg(1)
R as the
ﬁrst-round incoming message of session sidR and re-
turns (sidR, msg(2)
R denotes the second-
round message of sidR. It also creates, and keeps in
private, the local states peersidR , STsidR and SKsidR .
We remark that the same user can be indicated to be
both initiator (in one session held at Initiator) and re-
sponder (in another session held at Responder).

R ), where msg(2)

• Upon receiving an instruction “(sidR, msg∗

R)”, it treats
msg∗
R as the incoming message for session sidR, and
promptly responds with the next protocol message if
msg∗
R is not the last protocol message of that session.
• Upon receiving “(sidR, ST-Exposure)”, it returns the
value stored in STsidR , if session sidR is incomplete;
otherwise, it ignores this instruction.
• Upon receiving “(Test, Ut0 , Ut1 , msg(1)

R )” for Ut0 , Ut1 ∈
HONEST, where 1 ≤ t0 (cid:54)= t1 ≤ n, it sets Ut = Utσ ,
and acts just as receiving the “(Start, Ut, msg(1)
R )” in-
struction, where the session-identiﬁer set is denoted as
sidT for presentation simplicity. We remark that the
Test-type query can be made by the adversary for only
one time during its attack, exclusively against Initiator
or Responder.

• Upon receiving “(sidR, SK-exposure)”,

it returns the
session-key SKsidR if sidR (cid:54)= sidT and the session sidR
has been completed yet not expired. If sidR = sidT ,
SKsidT is returned if σ = 1; Otherwise, a value taken
uniformly at random from {0, 1}sklen is returned.

Peer: Upon on an input “sid”, it returns the value stored
in peersid, if sid is an existing session held at Initiator or
Resonder (otherwise, the query is ignored). Note that the
value returned may be an empty string, in case the peer of
that session has not been determined.

1473StaKey: Upon receiving “Ui”, 1 ≤ i ≤ n, it returns the
static secret-key of Ui if Ui ∈ HONEST; otherwise, it ignores
the query.
Corrupt: Upon receiving “Ui”, 1 ≤ i ≤ n, if Ui ∈ HONEST
it returns all the information (including static secret-key, in-
termediate randomness, and session-keys, etc) in the mem-
ory part (maintained by Initiator and/or Responder) for Ui,
(cid:54)∈

and sets CORRUPTED = CORRUPTED(cid:83){Ui}.
user not in HONEST(cid:83) DISHONEST, it generates the pub-
of CA), returns pidi, and sets HONEST = HONEST(cid:83){Ui}.
pidj, and sets DISHONEST = DISHONEST(cid:83){Uj}. That is,

HONEST, the query is ignored.
Register: Upon receiving “(Ui, honest), where Ui is a new

Upon receiving “((Uj, pkj), dishonest) for a new user Uj, it
gets the certiﬁcate for (Uj, pkj) (with the aid of CA), returns

lic/secret key pair and gets the certiﬁcate for Ui (with the aid

If Ui

we allow the adversary to adaptively register users in the
system. Note that each user cannot have multiple certiﬁ-
cates (with the same CA), but the adversary can register a
dishonest user with the public-key of an honest user.
During its attack, the adversary A schedules all the oracle
queries adaptively as it wishes. At the end of the attack, A
outputs a bit σ(cid:48).
7.2 CAKE Security Deﬁnition
In our model, the label of a session is speciﬁed to be part
of the session transcript. Two sessions are matching, if they
have the same session label.
Let sidT be the completed test-session held at the user Ut =
Utσ with peersidT = Uk ∈ HONEST, 1 ≤ k ≤ n, where Ut
and Uk may be the same user. Denote by sid(cid:48)
T its matching
session (in case the matching session exists), which may be
still on-going. We say the test-session is exposed during the
attack, if any of the following events occurs:

• Ut0 or Ut1 is corrupted via the Corrupt query,4 or STsidT

was exposed via the (STsidT , ST-exposure) query;5

• The static secret-key of Uk is exposed;6
T}
• The query (sid, SK-exposure), where sid ∈ {sidT , sid(cid:48)

(in case the matching session exists), was issued;

• The query Peer(sid(cid:48)

T ) was issued.

Definition 7.1

(Strong CAKE-security). A two-party

key-exchange protocol is strongly CAKE-secure, if for any
PPT adversary A as deﬁned above, and for any suﬃciently
large security parameter, it holds:

Label-security: Any of the following events occurs with
negligible probability. (1) There exist more than two sessions
of the same session label. (2) There exist two matching ses-
sions: session sid held at user Ui and session sid(cid:48) held at
user Uj (where Ui may be equal to Uj), such that any of the
following events occurs:

• Ui and Uj play the same session role (i.e., both of them

are initiators or responders);

• SKsid (cid:54)= SKsid(cid:48) ;

4However, exposing the static secret-key of Ut0 and/or that
Ut1 does not necessarily expose the test-session.
5If Utσ = Uk, STsidT is allowed to be exposed.
6In case the matching session sid(cid:48)
that either static secret-key of Uk or STsid(cid:48)

T exists, this can be relaxed

is unexposed.

T

• Peer-view mismatching: either peersid (cid:54)= ⊥∧peersid (cid:54)=

Uj, or peersid(cid:48) (cid:54)= ⊥ ∧ peersid(cid:48) (cid:54)= Ui.7

We remark that label-security is w.r.t. arbitrary PPT ad-
versaries who can, in particular, expose the secret-keys of all
users and expose the local states of all existing sessions.

ID-concealed session-key (ICSK) security: On con-
dition that the test-session sidT is completed and unexposed,
both of the following quantities are negligible:

Impersonation security: The probability that the test-session

has no matching session.

2|.
ID-SK indistinguishability: | Pr[σ(cid:48) = σ] − 1

Discussion. Note that label-security implies the security
against unknown key share (UKS) attack. As the static
secret-keys of both Ut0 and Ut1 can be exposed, imperson-
ation security (resp., ID-SK indistinguishability) implies se-
curity against KCI attacks (resp., perfect forward security
and forward ID-privacy). Entity authentication, implied by
label security and impersonation security together, is very
strong, which says that the CMIM adversary cannot im-
personate an honest user in a session no matter whether
the matching session exists or not. Label security, together
with ID-SK indistinguishability, implies that: there are at
most two sessions can be matching, and matching sessions
have matched peer views and the same session-key, while
unmatched sessions must have diﬀerent (computationally in-
dependent) session-keys.

The security deﬁnition in accordance with CK or BR frame-
work can be viewed as a special case of our CAKE-security
formulation. When being cast into the CK-framework (resp.,
BR-framework), the session label needs to include players’
identity information (resp., the whole session transcript).
Note also that, in the security model of CAKE, the adver-
sary indicates the session holder when starting a session run,
but does not necessarily indicate the peer player for the ses-
sion. However, the session peer can be exposed via oracle
query to Peer. This way of formulation, on the one hand,
allows a more powerful adversary, and incorporates the post-
ID CK-framework [9] as a special case on the other hand.

In general, we can treat ID-indistinguishability (ID-IND)
and SK-indistinguishability (SK-IND) separately w.r.t. two
test-sessions: one for deﬁning ID-IND and one for SK-IND,
by embedding a pair of independent random bits (rather
than a single random bit σ). In this case, we can allow the
adversary to have more powerful ability of secrecy exposure.
7.3 Adaption to Unilateral CAKE (UCAKE)
For simplicity, we assume only the responder (server) au-
thenticates it to the initiator (client), while the client may
not necessarily possess public identity information. In this
setting, for a session sidR run at Responder, the local vari-
able peersidR is always empty indicating “undetermined”.
The adversarial setting is the same as that for CAKE with
mutual authentication, except that: (1) the output of either
7It implies that: (1) If both sid and sid(cid:48) are complete, then
peersid = Uj ∧ peersid(cid:48) = Ui. (2) if both of them are in-
complete, it could be peersid = peersid(cid:48) = ⊥. (3) if only one
session (w.l.o.g., the session sid) is completed while the other
session (say, sid(cid:48)) is incomplete, it could be: peersid = Uj
but peersid(cid:48) = ⊥. The last case models the asynchronism
between deﬁning peersid and deﬁning peersid(cid:48) , or the un-
avoidable dropping message attacks by adversary.

1474Corrupt(Ui) or StaKey(Ui), for an initiator user Ui who does
not possess public-key, includes a special symbol “⊥” in the
(2) We additionally
place allocated for static secret-key.
allow the adversary to register honest or dishonest client
users without public identity information, where no CA gets
involved. (3) For the pair of users (Ut0 , Ut1 ) speciﬁed by the
adversary in the test-query, we require that either both of
them have public-keys or both of them do not; and if the
test-query is against Responder they must both have public-
keys.8 For presentation consistency with the deﬁnitional
framework of CAKE, we still allow the adversary to indicate
the session holder when starting a session at Initiator.
Let sidT be the completed test-session held at the user
Ut = Utσ , where peersidT = Uk ∈ HONEST (in case sidT is
run at Initiator) or peersidT is an empty string representing
undeﬁned (if sidT is run at Responder). Denote by sid(cid:48)
T its
matching session held by a user Uj (in case the matching
session exists), which may still be on-going. We say the
test-session is exposed for UCAKE during the attack, if any
of the following events occurs:

• Ut0 or Ut1 is corrupted via the Corrupt query,9 or STsidT
• The query (sid, SK-exposure), sid = sidT or sid =

was exposed via the (STsidT , ST-exposure) query.10

sid(cid:48)

T , was issued.

is exposed.11

• sidT is run at Initiator but the static secret-key of Uk

• sidT is run at Responder but any of the following holds:
T does not exist, or Uj (i.e.,
T ) is corrupted, or STsid(cid:48)
is

the matching session sid(cid:48)
the session owner of sid(cid:48)
exposed, or the query Peer(sid(cid:48)

T ) was issued.

T

Definition 7.2

(UCAKE-security). The deﬁnition of
strong UCAKE-security is almost identical to that of strong
CAKE-security, with the following modiﬁcations:

Peer-view mismatching: peersid (cid:54)= ⊥(cid:86) peersid (cid:54)= Uj if
Uj is the responder, or peersid(cid:48) (cid:54)= ⊥(cid:86) peersid(cid:48) (cid:54)= Ui if

Ui is the responder.

Impersonation security: The probability that the test-session

sidT has no matching session, on condition that sidT
is run at Initiator.

8. CONSTRUCTION AND ANALYSIS

OF UCAKE AND CAKE

Our higncryption can be straightforwardly adapted into a
two-round UCAKE protocol (or identity-concealed SACCE
protocol [21]), by replacing the public identity information of
the receiver with a randomly generated DH-component. The
higncryption based UCAKE protocol is brieﬂy described in
Figure 3, where K2 serves as the resultant session-key, 12
HB denotes the associated data from the server for AEAD.
8Actually, if the test-query is against Initiator, specifying
(Ut0 , Ut1 ) does not make sense for UCAKE. The treatment
is for presentation consistency with the model of CAKE.
9Exposing the static secret-keys of both Ut0 and Ut1 does
not expose the test-session.
10If we only require session-key indistinguishability, STsidT
can be exposed if sidT is run at Responder.
11If the matching session sid(cid:48)
either of secret-key of Uk or STsid(cid:48)
12For identity-concealed SACCE, K1 serves the session-key
while K2 is set to be empty.

T exists, it can be relaxed that

is unexposed.

T

x ← Z∗

q

X = gx

pidB
PKB : B = gb
SKB : b ← Z∗
q

y ← Z∗

q, Y = gy, e = h(X, Y, pidB)
P S = X b+ye, (K1, K2) = KDF(P S, X(cid:107)Y )

HB, Y = BY e, CB = EncK1(HB, Y (cid:107)pidB)

x

, (K1, K2) = KDF(P S, X(cid:107)Y )

P S = Y
DecK1(HB, CB) = (Y, pidB), e = h(X, Y, pidB)
Check correctness of pidB and Y = BY e, and abort if not

Figure 3: Protocol structure of higncryption-based UCAKE

We assume the server always performs subgroup member-
ship test for the incoming DH-exponent X explicitly or im-
plicitly. In practice, we recommend the following protocol
variant with implicit subgroup test, where P S = X ρ(b+ye)
and the server will abort if X (cid:54)∈ G(cid:48) or P S = 1G. We also
note that the subgroup test can be waived, if oracle query
to EXO is denied in the UCAKE-security deﬁnition.

In comparison with QUIC, (EC-DSA based) TLS1.3 and
OPTLS, our higncryption-based UCAKE protocol is sig-
natureless, and more eﬃcient;13 Moreover, it has forward
ID-privacy, receiver deniability, and strong resilience to ex-
posure of intermediate state (whether y or b + ye, but not
both of them); Finally, it enjoys ﬂexible implementations
and deployments.

Theorem 8.1. The protocol presented in Fig. 3 is strongly
UCAKE-secure, under the AEAD security and the GDH as-
sumption in the random oracle model.

Proof. For a session run of the protocol described in Fig.
3, its label is deﬁned to be X||Y . The local state STsid is
speciﬁed to be (Y, y) (if sid is run at Responder) or x (if sid
is run at Initiator), which can be oﬄine computed.
Lemma 8.1. Assuming h : {0, 1}∗ → {0, 1}l ∩ Z∗

q is RO,
where l = (cid:100)|q|/2(cid:101), no PPT algorithm can output {aux ∈
{0, 1}∗, Y ∈ G, pidj = (idj, pkj, certj)} and {aux(cid:48) ∈ {0, 1}∗,
Y (cid:48) ∈ G, pidk = (idk, pkk, certk)}, such that pkjY h(aux,Y,pidj )
= pkkY (cid:48)h(aux(cid:48),Y (cid:48),pidk) but {aux, Y, pidj} (cid:54)= {aux(cid:48), Y (cid:48), pidk}.
Proof (of Lemma 8.1). For any pair of diﬀerent {aux, Y, pidj}
and {aux(cid:48), Y (cid:48), pidk}, 1 ≤ j, k ≤ n, the probability that
pkjY h(aux,Y,pidj ) = pkkY (cid:48)h(aux(cid:48),Y (cid:48),pidk) is
2l−1 assuming h
is an RO. Then, for any PPT algorithm who makes at most
m oracle queries to h, it succeeds with probability at most
(cid:3)
m2
2l−1 that is negligible.
We ﬁrst prove the label-security. It is straightforward that,
with overwhelming probability, not more than two sessions
can have the same label. Let session sid held at user Ui and
session sid(cid:48) held at user Uj, 1 ≤ i, j ≤ n, be matching (i.e.,
they have the same session label X||Y ). Note that, for hon-
estly generated X and Y , X (cid:54)= Y with overwhelming proba-
bility, which holds even if y is taken from a well-spread dis-
q with min-entropy greater than ω(log |q|).
tribution over Z∗
Then, label matching implies that Ui and Uj cannot play
the same session role, and the two matching sessions must

1

13For UCAKE based on medium (resp., light) higncryption,
the server performs only 2 (resp., 1.75) exponentiations.

1475have the same session-key. Finally, the property of peer-view
matching is established with Lemma 8.1.

(cid:48)

) the session label of sidT , and by (H(cid:48)

Next, we prove the ID-concealed session-key (ICSK) se-
curity. Let the test-session sidT , held at the uncorrupted
client user Ut = Utσ for σ ← {0, 1}, be completed and
unexposed, with peer server responder peersidT = Uk ∈
HONEST. Breaking impersonation security (i.e., making the
exposed test-session have no matching session) implies that
a PPT adversary can impersonate Uk.
B, C(cid:48)
Denote by (X, Y
B)
the AEAD ciphertext sent by A in the second round of the
test-session. As we assume sidT has been successfully com-
pleted, it means that (H(cid:48)
B) was decrypted to (pidk, Y (cid:48))
= pkkY (cid:48)h(X,Y (cid:48),pidk), where Y (cid:48) may be gener-
such that Y
ated by A itself. We consider two cases.
The ﬁrst case is that Y
(X(cid:48), Y
exists for sidT . This case is ruled out by Lemma 8.1.
The second case, referred to as Case-2, is Y
was never sent
by Uk (but may be sent by another user in another session
unmatched to sidT ). We have the following lemma, which
then establishes the impersonation security.

was sent by Uk in a session of label
), where X(cid:48) (cid:54)= X as we assume no matching session

B, C(cid:48)

(cid:48)

(cid:48)

(cid:48)

(cid:48)

Lemma 8.2. Case-2 occurs with at most negligible proba-
bility, under the AEAD security and the GDH assumption
in the random oracle model.
Proof (of Lemma 8.2). Assuming a PPT adversary A who
makes Case-2 occur with non-negligible probability, we con-
struct a GDH-solver S. S takes input (B, X), where B = gb
and X = gx for b, x ← Z∗
q that are unknown to S, and its
goal is to compute CDH(B, X) with a DDH oracle. For
presentation simplicity, S randomly guesses the victim re-
sponder user Uk, sets its public-key to be B and sets pidB
accordingly for Uk. S sets the public-key and secret-key for
any user Uj, 1 ≤ j (cid:54)= k ≤ n, by itself, and will act on its
behalf. S embeds a random bit σ ← {0, 1}, and runs A as a
subroutine, and answers its oracle queries (related to Uk of
pidB) as follows.
When A starts a session via the oracle query “(Start, Uk, X(cid:48) ∈
G)”, S works as Uk does, except that (K1, K2) are set to be
random strings chosen by S itself. S uses its DDH-oracle to
ensure the consistency of the random oracle KDF .
Upon receiving “(Test, Ut0 , Ut1 )” for uncorrupted Ut0 , Ut1 ∈
HONEST, where 1 ≤ t0 (cid:54)= t1 ≤ n, S sets Ut = Utσ ; Then,
S just sends X, the element given in its input, to A as the
ﬁrst-round message of the test-session.
It is easy to check that the view of A under the run of S is
identical to that in A’s real attack, which means Case-2 oc-
curs also with non-negligible probability in the simulation of
S. Denote by (X, Y
) the session label of the completed test-
session sidT , and by (H(cid:48)
B) the AEAD ciphertext sent by
(cid:48)
A in the second round of sidT . Case-2 means that Y
was
not generated by user pidB, but the decryption of (H(cid:48)
B, C(cid:48)
B)
= BY (cid:48)e for e = h(X, Y (cid:48), pidB),
gives (pidB, Y (cid:48)) such that Y
where Y (cid:48) = gy(cid:48)
It also
implies that A has made the oracle query h(X, Y (cid:48), B) to
= BY (cid:48)e holds (and consequently
get e, as, otherwise, Y
sidT can be successfully ﬁnished) only with negligible prob-
(cid:48)
ability. Denote by (K(cid:48)
).
As we assume sidT has no matching session and Y
was
not sent by pidB in Case-2, with overwhelming probabil-
B, pidB||Y (cid:48)) was not sent
ity the AEAD ciphertext EncK(cid:48)

may be generated by A itself.

2) = KDF (CDH(X, Y

), X||Y

B, C(cid:48)

1, K(cid:48)

(H(cid:48)

(cid:48)

(cid:48)

(cid:48)

(cid:48)

(cid:48)

1

(cid:48)

(cid:48)

(cid:48)

), X||Y

) = X b+y(cid:48)e.

redeﬁnes h(X, Y (cid:48), pidB) = e(cid:48) ← {0, 1}l(cid:84) Z∗

in any existing session other than the test-session. By the
AEAD security, the adversary A must have made the or-
), from which S gets
acle query KDF (CDH(X, Y
CDH(X, Y
S rewinds A to the point of RO query h(X, Y (cid:48), pidB), and
q , and runs A
from this rewinding point, where all RO queries to h after
the rewinding point are answered randomly and indepen-
dently. According to the general forking lemma [3], Case-2
occurs in the rewound run also with non-negligible prob-
ability, from which S will get CDH(X, Y
. By
and X b+y(cid:48)e/X y(cid:48)e =
computing X y(cid:48)
X b = CDH(X, B), S breaks the GDH assumption.
(cid:3)
Finally, we prove the ID-SK indistinguishability. For UCAKE

= (X b+y(cid:48)e/X b+y(cid:48)e(cid:48)

) = X b+y(cid:48)e(cid:48)

)e−e(cid:48)

(cid:48)

q

protocol, we only need to consider ID-indistinguishability
when sidT is run at the target server user Ut. As the test-
session sidT is completed and unexposed, and has matching
session, from now on denote by X||Y the session label of
sidT , where Y = UtY h(X,Y,Ut) and Y = gy are generated by
Ut. Note that STsidT = (Y, y) is unexposed. In this case,
the ﬁrst observation is that Y perfectly hides the responder’s
identity assuming h is an RO. Furthermore, it is easy to see
that, if y is taken from a well-spread distribution over Z∗
with min-entropy greater than ω(log |q|), Y computationally
hides the responder’s identity under the FGDL assumption
in the RO model.
Then, by the AEAD security, to break the ID-SK indis-
tinguishability, A has to query the KDF random oracle in
order to get the session-key of the sidT or its matching ses-
sion. We further examine two cases.
The ﬁrst case is that sidT is run at Responder.
In this
case, as the matching session sid(cid:48)
T must exist and neither
STsidT nor STsid(cid:48)
is exposed, the ability to break ID-SK
indistinguishability implies the ability to break the GDH
assumption assuming KDF is an RO. Speciﬁcally, we can
construct a GDH-solver S which, on input (X, Y ) (w.r.t.
the session label X||Y ), can with non-negligible probability
compute CDH(X, Y ) with the aid of a DDH-oracle.
The second case is that sidT is run at Initiator. By the
impersonation security, the matching session sid(cid:48) must exist
at the server user Uk. In this case, the ability of breaking
ID-SK indistinguishability is also reduced to the ability of
breaking the GDH assumption. Denote by B the public-
key of Uk for presentation simplicity. The GDH-solver S
takes (X, B) as input, and can with non-negligible proba-
bility compute CDH(X, B) with the aid of a DDH-oracle.
(cid:3)
This ﬁnishes the proof of Theorem 8.1.
Corollary 8.1. Let Y be a well-spread distribution over
q with min-entropy λY > ω(log |q|). The protocol described
Z∗
in Fig. 3, when y is taken according to Y, is UCAKE-secure,
under the AEAD security, the FGDH (actually HGDH) and
FGDL assumptions (as deﬁned in Appendix A), in the ran-
dom oracle model.

T

Finally, the (parallel) composition of two UCAKE renders
us a three-round protocol, which is strongly CAKE-secure
under the AEAD security and the GDH assumption in the
random oracle model. The details are deferred to the full
version due to space limitation.

14769. ACKNOWLEDGEMENT
We thank the anonymous referees for their insightful com-
ments. We are grateful to Boru Gong, Yue Guo and Hong-
bing Wang for many helpful discussions.

10. REFERENCES

[1] J. An, Y. Dodis, and T. Rabin. On the Security of

Joint Signature and Encryption. EUROCRYPT 2002:
83-107.

[2] J. Baek, R. Steinfeld, and Y. Zheng. Formal Proofs

for the Security of Signcryption. Journal of
Cryptology (2007) 20: 203-235.

[3] M. Bellare and G. Neven. Multi-Signatures in the
Plain Ppublic-Key Model and a General Forking
Lemma. ACM CCS, 2006: 390-399.

[4] M. Bellare and P. Rogaway. Entity Authentication

and Key Distribution. CRYPTO 1993: 273-289.
[5] C. Brzuska, M. Fischlin, B. Warinschi, and S.C.
Williams. Composability of Bellare-Rogaway key
exchange protocols. ACM CCS 2011: 51-62.

[6] C. Brzuska, N.P. Smart, B. Warinschi, G.J. Watson.

An Analysis of the EMV Channel Establishment
Protocol. ACM CCS 2013: 373-386.

[7] R. Canetti. Towards Realizing Random Oracles:

Hash Functions That Hide All Partial Information.
CRYPTO 1997: 455-469.

[8] R. Canetti and H. Krawczyk. Analysis of

Key-Exchange Protocols and Their Use for Building
Secure Channels. EUROCRYPT 2001: 453-474.

[9] R. Canetti and H. Krawczyk. Security Analysis of

IKE’s Signature-Based Key-Exchange Protocol.
CRYPTO 2002: 143-161.

[10] A.W. Dent. Hybrid Cryptography. Cryptology ePrint

Archive, Report No. 2004/210.

[11] Y. Dodis and J.H. An. Concealment and Its

Applications to Authenticated Encryption.
EUROCRYPT 2003: 312-329.

[12] B. Dowling, M. Fischlin, F. G¨unther and D. Stebila.
A Cryptographic Analysis of the TLS 1.3 Handshake
Protocol Candidates. ACM CCS 2015: 1197-1210.
[13] E. Rescorla. The Transport Layer Security (TLS)

Protocol Version 1.3, Draft-12, 2016.
https://tools.ietf.org/html/draft-ietf-tls-tls13-12

[14] J. Fan, Y. Zheng, and X. Tang. A Single Key Pair is

Adequate for the Zheng Signcryption. ACISP 2011:
371-388.

[15] M.Fischlin and F. G¨unther. Multi-Stage Key

Exchange and the Case of Google (cid:44)a´rs QUIC Protocol.
ACM CCS 2014: 1193-1204.

[16] M. Gorantla, C. Boyd, J. Gonzalez Nieto. On the

Connection Between Signcryption and One-Pass Key
Establishment. Cryptography and Coding 2007:
277-301.

[17] S. Halevi and H. Krawczyk. One-Pass HMQV and

Asymmetric Key-Wrapping. PKC 2011: 317-334.
[18] T. Jager and J. Schwenk. On the Equivalence of

Generic Group Models. ProvSec 2008: 200-209.

[19] H. Krawczyk. SIGMA: The “Sign-and-Mac”

Approach to Authenticated Diﬃe-Hellman and Its
Use in the IKE-protocols. CRYPTO 2003: 400-425.

[20] H. Krawczyk. HMQV: A High-Performance Secure
Diﬃe-Hellman Protocol. CRYPTO 2005: 546-566.
[21] H. Krawczyk, K.G. Paterson and H. Wee. On the

Security of the TLS Protocol: A Systematic Analysis.
CRYPTO 2013: 429-448.

[22] Hugo Krawczyk and Hoeteck Wee. The OPTLS

Protocol and TLS 1.3. EuroS&P 2016: 81-96.

[23] B. Libert and J.-J. Quisquater. Eﬃcient Signcryption
with Key Privacy from Gap Diﬃe´lCHellman Groups.
PKC 2004: 187-200.

[24] R. Lychev, S. Jeroy, A. Boldyrevaz and C.

Nita-Rotarux. How Secure and Quick is QUIC?
Provable Security and Performance Analyses. IEEE
S&P 2015: 214-231.

[25] U. Maurer. Abstract Models of Computation in

Cryptography. Cryptography and Coding 2005: 1-12.

[26] U. Maurer and S. Wolf. Lower Bounds on Generic
Algorithms in Groups. EUROCRYPT 1998: 72-84.

[27] A. Menezes, M. Qu, and S. Vanstone. Some New Key

Agreement Protocols Providing Mutual Implicit
Authentication. SAC 1995: 70–88.

[28] K. G. Paterson, T. Ristenpart, and T. Shrimpton.
Tag Size Does Matter: Attacks and Proofs for the
TLS Record Protocol. ASIACRYPT 2011: 372-389.

[29] P. Rogaway. Authenticated-Encryption with

Associated-Data. ACM CCS 2002: 98-107.

[30] J. Roskind. Quick UDP Internet Connections:

Multiplexed Stream Transport over UDP. 2012.

[31] C. P. Schnorr. Small Generic Hardcore Subsets for

the Discrete Logarithm. Information processing
Letters 79(2): 93-98, 2001.

[32] J. T. Schwartz. Fast Probabilistic Algorithms for

Veriﬁcations of Polynomial Identities. Journal of the
ACM, 27(3): 701-717, 1980.

[33] C.-H. Tan. Analysis of Improved Signcryption

Scheme with Key Privacy. Information Processing
Letters 99(4): 135-138, 2006.

[34] G. Yang, D.S. Wong and X. Deng. Analysis and
Improvement of a Signcryption Scheme with Key
Privacy. ISC 2005: 218-232.

[35] V. Shoup. Lower Bounds for Discrete Logarithms

and Related Problems. EUROCRYPT 1997: 256-266.

[36] A. C. Yao and Y. Zhao. OAKE: A New Family of
Implicitly Authenticated Diﬃe-Hellman Protocols.
ACM CCS 2013: 1113-1128.
[37] Y. Zheng. Digital signcryption or how to achieve
cost(Signature & encryption) (cid:28) cost(Signature)
+cost(Encryption). CRYPTO 1997: 165-179.

APPENDIX
A. FLEXIBLE DISCRETE LOGARITHM

(FDL) AND RELATED PROBLEMS

We say a distribution D is well-spread over a subset S ⊆
q , if the min-entropy λD = − log(maxs∈S (Pr[D = s])) >
Z∗
ω(log |q|) when |q| is suﬃciently large. Let X and Y be
well-spread distributions over some subsets of Z∗
q with min-
entropy λX and λY respectively. The ﬂexible discrete log-
arithm (FDL) problem is to compute x from X = gx for
x ← X . The ﬂexible CDH (FCDH) problem is to compute
CDH(X = gx, Y = gy) for x ← X and y ← Y. The ﬂexi-

1477ble DDH (FDDH) problem is to distinguish (X = gx, Y =
gy, gxy) and (X, Y, gz), where x ← X , y ← Y and z ← Z∗
q .
The ﬂexible gap Diﬃe-Hellman (FGDH) problem is to com-
pute CDH(X = gx, Y = gy), where x ← X and y ← Y,
with the aid of a DDH oracle. The ﬂexible gap DL (FGDL)
problem is to distinguish between gxy and gz, where x ← X ,
y ← Y and z ← Z∗
q , with the aid of a DDH oracle. Notice
the diﬀerence between FGDL and FDDH, where for FGDL
gx and gy are not given to the distinguisher as input.
Clearly, the traditional problems of DL, CDH, DDH, GDH
are special cases of their ﬂexible counterparts, when X and Y
are constrained to be the uniform distribution over Z∗
q with
min-entropy log(q − 1). The work [7] introduces a variant
of the DDH problem, referred to as hybrid DDH (HDDH)
for presentation simplicity, where X is a well-spread distri-
q but Y is the uniform distribution over Z∗
bution over Z∗
q ;
HDDH is a special case of FDDH and can be viewed as a hy-
brid of FDDH and traditional DDH. Similarly, we can deﬁne
hybrid CDH (CDH), resp., hybrid GDH (HGDH), where X
q but Y is the uniform
is a well-spread distribution over Z∗
distribution over Z∗
q . Actually, as shall see, what we need
in this work, only for the provable security of ﬂexible eﬃ-
cient implementations, are the HGDH assumption and the
FGDL assumption, where FGDL assumption is used only for
proving forward ID-privacy of the ﬂexible implementations.
We ﬁrst prove the following lemma, which is a generalized

version of the Schwartz-Shoup lemma [32, 35].

Lemma A.1. Let Xi, 1 ≤ i ≤ k, be well-spread distribu-
tion over subset Si ⊆ Z∗
q with min-entropy λi > ω(log |q|).
Let P (X1,··· , Xk) be a non-zero multivariate polynomial
over Zq of total degree d, where d and k are polynomials
in |q| (usually, they are small constants). The probability
P (x1,··· , xk) = 0, when xi is taken independently from Xi
(i.e., xi ← Xi) for 1 ≤ i ≤ k, is at most d·(2−λ1 +···+2−λk ).

Proof. We prove this lemma by induction on k. First note
that a univariate polynomial (i.e., for the case of k = 1)
over Zq has at most d roots. Thus, for x1 ← X1 we have
Pr[P (x1) = 0] ≤ d2−λ1 .
Now, supposing this lemma holds for the case of k − 1,
we consider the case of k. Let 1 ≤ ϑ ≤ d be the maxi-
mal degree of xk in any term in P (x1,··· , xk). The polyno-
mial P (x1,··· , xk) can be viewed as a univariate polynomial
Pk(xk) of degree ϑ, where the coeﬃcient of the term xϑ is
a polynomial eϑ(x1,··· , xk−1) of degree at most d − ϑ. Ac-
cording to the inductive hypothesis, Pr[eϑ(x1,··· , xk−1) =
0] ≤ (d − ϑ)(2−λ1 + ··· + 2−λk−1 ), which is also the proba-
bility upper-bound for causing Pk to be a zero polynomial.
On the other hand, conditioned on this event does not occur
(i.e., for all the values (x1,··· , xk) satisfying Pk is non-zero),
there are at most ϑ solutions of xk such that Pk(xk) = 0.
As λi > ω(log |q|), 1 ≤ i ≤ k, and d and k are polynomial
in |q|, we have that d(2−λ1 + ··· + 2−λk ) < 1 (when |q| is
In summary, for xi ← Xi, 1 ≤ i ≤ k,
suﬃciently large).
Pr[P (x1,··· , xk) = 0] ≤ (d− ϑ)(2−λ1 +··· + 2−λk−1 ) + (1−
(d − ϑ)(2−λ1 + ··· + 2−λk−1 ))ϑ2−λk ≤ (d − ϑ)(2−λ1 + ··· +
2−λk−1 ) + ϑ2−λk < d(2−λ1 + ··· + 2−λk ).
(cid:3)
For presentation simplicity, in the following analysis we use
Maurer’s generic group model [25] that is actually equivalent
to Shoup’s model [35, 18], and only count the complexity of
generic steps where each generic step corresponds to an ac-
cess to the generic group oracle for performing one group
operation or one relationship veriﬁcation. Also, we disre-

gard the probability of simply and correctly guessing x or
y, which happens with probability max{2−λX , 2−λY} that is
negligible.

Theorem A.1. For an algorithm of τ generic steps for
solving the FGDH problem, its success probability is upper
bounded by τ 3(2−λX + 2−λY ) in the generic group model.

Proof.
In Maurer’s generic group model for solving the
FGDH problem, the generic group oracle (GG-oracle) O
originally keeps three internal states (1, x, y) in a list L,
where x (resp., y) is taken independently according to the
well-spread distribution X (resp., Y). For presentation sim-
plicity, we denote by L[l] the value stored in the l-th entry of
L, and we assume L[1] = 1, L[2] = x and L[3] = y. The ad-
versary is given the indices of (1, x, y) in L, i.e., (1, 2, 3), and
has black-box access to the GG-oracle O. For the i-th GG-
oracle access corresponding to a group operation, 1 ≤ i ≤ τ ,
the value computed by the GG-oracle O can be viewed as a
linear polynomial of the form Fi(x, y) = aix+biy +ci, where
ai, bi, ci ∈ Zq are determined by the previous GG-oracle ac-
cesses. The value Fi(x, y) is not returned to A directly, but
is stored into a position in the internal list L where the posi-
tion index for storing Fi(x, y) is, however, determined by A.
A is always given the ability of verifying equality relation,
by which A queries O with (i, j) and gets the binary result
depending on whether L[i] = L[j] or not. For adversary
against the FGDH problem, the adversary A is additionally
allowed to query the GG-oracle with (i, j, k), where the GG-
oracle, corresponding to the DDH oracle in this case, returns
1 if and only if L[i]L[j] = L[k].

As discussed in [25], in this generic group model, we only
need to consider non-adaptive adversaries; And there are
only two approaches for A to win, other than simply guessing
x or y that is disregarded in the analysis. One approach is
to cause two diﬀerent Fi and Fj to collide, in the sense that
aix + biy + ci = ajx + bjy + cj where (ai, bi, ci) (cid:54)= (aj, bj, cj).
In other words, (ai − aj)x + (bi − bj)y + (ci − cj) = 0. By
Lemma A.1, this event can occur with probability at most
τ (2−λX + 2−λY ).
C 2
Another approach for A to win is to cause, for some (i, j, k),
the non-zero polynomial FiFj − Fk = 0 (note that, if the
polynomial FiFj−Fk is a zero-polynomial, it leaks nothing).
That is, (aix + biy + ci)(ajx + bjy + cj)− (akx + bky + ci) = 0
for x ← X and y ← Y. Note that FiFj − Fk is a quadratic
polynomial. By Lemma A.1 with d = 2, this event occurs
with probability at most C 3
Note that C 2
2−λY ).

τ (2(2−λX + 2−λY )).

(cid:3)

τ (2−λX +2−λY )+C 3

τ (2(2−λX +2−λY )) < τ 3(2−λX +

Theorem A.2. For an algorithm of τ generic steps for
solving the FGDL problem, its success probability is upper
bounded by 1
q−1 ) in the generic group
model.

2 + τ 3(2−λX + 2−λY + 1

Proof. Let x (resp., y) be taken according to the well-spread
distribution X (resp., Y), and z ← Z∗
q . In Maurer’s generic
group model for solving the FGDL problem, the GG-oracle
O originally keeps (1, T0, T1) in its internal list L, where
Tσ = xy and T1−σ = z for a random bit σ ← {0, 1}. Note
that O does not directly keep the value x or y. The goal of
the adversary A is to guess the random bit σ, with the aid
of a DDH oracle.
For the i-th GG-oracle access corresponding to a group
operation, 1 ≤ i ≤ τ , the value computed by O can be

1478viewed as a quadratic polynomial of the form Fi(xy, z) =
aixy + biz + ci, where ai, bi, ci ∈ Zq are determined by the
previous GG-oracle accesses. Deﬁne Gi(x, y, z) = Fi(xy, z).
The advantage obtained by A (over simply guessing the
random bit σ) is the probability of:
(1) for some (i, j),
making two diﬀerent quadratic polynomials Gi(x, y, z) and
Gj(x, y, z) colliding (i.e., Gi − Gj = 0); or (2) for some
(i, j, k), making the (non-zero) quartic polynomial GiGj −
Gk = 0. According to Lemma A.1, the advantage is at most
τ (2(2−λX +2−λY + 1
2 +C 2
1
q−1 )) <
(cid:3)
2 + τ 3(2−λX + 2−λY + 1
In the full version, we also prove the following theorem

τ (4(2−λX +2−λY + 1

1

q−1 ))+C 3
q−1 ).

regarding the intractability of FDL, FDL and FDDH.

Theorem A.3. For an algorithm of τ generic steps, its
success probability is upper bounded by τ 22−λX (for solving
the FDL problem), τ 2(2−λX + 2−λY ) (for solving the FCDH
problem), and 1
q−1 ) (for solving the
FDDH problem), in the generic group model.

2 + τ 2(2−λX + 2−λY + 1

Remark. The complexity of FDL and related problems
shows that they are hard for polynomial-time algorithms at
least in the generic group model. We remark that the upper-
bounds proved in the above theorems and corollaries are
quite loose, where we have given the solver algorithms the
beneﬁt of the doubt, and have assumed that the algorithm
will succeed with any collision. In a related work by Schnorr
[31], it is shown that if x is drawn uniformly at random from
a subset H ⊂ Z∗
upper-bound of a τ generic-step DL-solver is roughly τ|H|
(not τ 2
|H| as established with usual analysis), which implies

q of size |H| ≤(cid:112)|q|, the success probability
that DL deﬁned over a random subset of size(cid:112)|q| is as hard

as the traditional DL deﬁned over Z∗
q (at least for generic
algorithms)! But the result [31] critically relies on uniform
distribution over the subset H, while our result is for any
distribution with super-logarithmic min-entropy.

The result about FDL and related problems has two con-
sequences. On the one hand, it indicates that cryptosys-
tems based on the traditional DL and related problems have
strong resilience to randomness leakage, in the sense they
are still secure as long as super-logarithmic min-entropy re-
mains with each exponent secrecy. On the other hand, it
allows more ﬂexible and eﬃcient implementations of cryp-
tosystems based on DL and related problems, according to
priorities and tradeoﬀs among security and eﬃciency in dif-
ferent application scenarios.

B. RELATED PROTOCOLS

x ← Z∗

q

X = gx

Y = gy,{pidB, M ACK2(X, Y, pidB)}K1,{data}K

pidB
PKB : B = gb
SKB : b ← Z∗
q

y ← Z∗

q

Figure 4: Basic structure of OPTLS, where K1 is derived
from gxy, K2 from gxb, and K from both gxb and gxy.

pidA
P KA : A = ga
SKA : a ← Z∗
q
x ← Z∗
K = KDF (P S, A||B)
c ← EncK(M )
r = H(M, A, B, K)

q , P S = Bx

pidB
P KB : B = gb
SKB : b ← Z∗
q

pidA, c, r, σ = x/(r + a)

P S = (Agr)σb
K = KDF (P S, A||B)
DecK(c) = M
Accept if r = H(M, A, B, K)

Figure 5: Zheng’s signcryption, where H : {0, 1}∗ → Zq.

pidA
P KA : A = ga
SKA : a ← Z∗
q
x ← Z∗
q , X = gx
d = h(pidB, X), P S = Bx+da
(K1, K2) = KDF (P S, pidA||pidB||X)
σ = MACK1(0)

pidA, X, σ

pidB
P KB : B = gb
SKB : b ← Z∗
q

d = h(pidB, X), P S = (XAd)b
(K1, K2) = KDF (P S, pidA||pidB||X)
Accept if MACK1(0) = σ

Figure 6: HOMQV, with session-key set to be K2.

x ← Z∗

q

X = gx,{early data}+

K1

{Y = gy}K1,{data}K2

pidB
PKB : B = gb
SKB : b ← Z∗
q

y ← Z∗

q

Figure 7: Basic structure of QUIC. K1 (resp., session-key
K2) is derived from CDH(X, B) (resp., CDH(X, Y )) and
some auxiliary input.“{ }+
K ” means it is optionally generated
and sent only for 0-RTT mode.

x ← Z∗

q

X = gx

Y = gy,{pidB, σ}K1,{data}K2

pidB
PKB : B = gb
SKB : b ← Z∗
q

y ← Z∗

q

Figure 8: Basic structure of TLS1.3. σ is server’s signature
on the hash of session transcript, K1 and K2 are derived
from CDH(X, Y ) and some auxiliary information.

1479