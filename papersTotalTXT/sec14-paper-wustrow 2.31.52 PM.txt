TapDance: End-to-Middle Anticensorship  

without Flow Blocking

Eric Wustrow, Colleen M. Swanson, and J. Alex Halderman, University of Michigan
https://www.usenix.org/conference/usenixsecurity14/technical-sessions/presentation/wustrow

This paper is included in the Proceedings of the 23rd USENIX Security Symposium.August 20–22, 2014 • San Diego, CAISBN 978-1-931971-15-7Open access to the Proceedings of  the 23rd USENIX Security Symposium is sponsored by USENIXTapDance: End-to-Middle Anticensorship without Flow Blocking

Eric Wustrow

University of Michigan

ewust@umich.edu

Colleen M. Swanson
University of Michigan

cmswnsn@umich.edu

J. Alex Halderman

University of Michigan

jhalderm@umich.edu

Abstract

In response to increasingly sophisticated state-sponsored
Internet censorship, recent work has proposed a new ap-
proach to censorship resistance: end-to-middle proxying.
This concept, developed in systems such as Telex, Decoy
Routing, and Cirripede, moves anticensorship technology
into the core of the network, at large ISPs outside the
censoring country. In this paper, we focus on two techni-
cal obstacles to the deployment of certain end-to-middle
schemes: the need to selectively block ﬂows and the need
to observe both directions of a connection. We propose a
new construction, TapDance, that removes these require-
ments. TapDance employs a novel TCP-level technique
that allows the anticensorship station at an ISP to function
as a passive network tap, without an inline blocking com-
ponent. We also apply a novel steganographic encoding
to embed control messages in TLS ciphertext, allowing us
to operate on HTTPS connections even under asymmetric
routing. We implement and evaluate a TapDance proto-
type that demonstrates how the system could function
with minimal impact on an ISP’s network operations.

Introduction

1
Repressive governments have deployed increasingly so-
phisticated technology to block disfavored Internet con-
tent [5, 50]. To circumvent such censorship, many users
employ systems based on encrypted tunnels and proxies,
such as VPNs, open HTTPS proxies, and a variety of
purpose-built anticensorship tools [1, 2, 13, 25, 37]. How-
ever, censors are able to block many of these systems by
discovering and banning the IP addresses of the servers on
which they rely [46,47]. Some services attempt to remain
unblocked by frequently changing their IP addresses, but
they face a tension between the desire to make their net-
work locations known to would-be users and the need to
keep the same information secret from the censor.

To avoid this tension and escape the cat-and-mouse
game that results between censors and anticensorship

tools, researchers have recently introduced a new ap-
proach called end-to-middle (E2M) proxying [21, 26, 49].
In an E2M system, friendly network operators agree to
help users in other, censored countries access blocked
information. These censored users direct trafﬁc toward
uncensored “decoy” sites, but include with such trafﬁc a
special signal (undetectable by censors) through which
they request access to different, censored destinations.
Participating friendly networks, upon detecting this signal,
redirect the user’s trafﬁc to the censored destination. From
the perspective of the censor— or anyone else positioned
between the censored user and the friendly network —the
user appears to be in contact only with the decoy site.
In order to block the system, the censor would have to
block all connections that pass through participating ISPs,
which would result in a prohibitive level of overblocking
if E2M systems were widely deployed at major carriers.
Deployment challenges While E2M approaches ap-
pear promising compared to traditional proxies, they face
technical hurdles that have thus far prevented any of them
from being deployed at an ISP. All existing schemes as-
sume that participating ISPs will be able to selectively
block connections between users and decoy sites. Unfor-
tunately, this requires introducing new hardware in-line
with backbone links, which adds latency and introduces a
possible point of failure. ISPs typically have service level
agreements (SLAs) with their customers and peers that
govern performance and reliability, and adding in-line
ﬂow-blocking components may violate their contractual
obligations. Additionally, adding such hardware increases
the number of components to check when a failure does
occur, even in unrelated parts of the ISP’s network, po-
tentially complicating the investigation of outages and
increasing downtime. Given these risks, ISPs are reluc-
tant to add in-line elements to their networks. In private
discussions with ISPs, we found that despite being willing
to assist Internet freedom in a technical and even ﬁnan-
cial capacity, none were willing to deploy existing E2M
technologies due to these potential operational impacts.

USENIX Association  

23rd USENIX Security Symposium  159

Furthermore, our original E2M proposal, Telex, as-
sumes that the ISP sees trafﬁc in both directions, client-
decoy and decoy-client. While this might be true when
the ISP is immediately upstream from the decoy server,
it does not generally hold farther away. IP ﬂows are of-
ten asymmetric, such that the route taken from source to
destination may be different from the reverse path. This
asymmetry limits an ISP to observing only one side of a
connection. The amount of asymmetry is ISP-dependent,
but tier-2 ISPs typically see lower amounts of asymmetry
(around 25% of packets) than tier-1s, where up to 90%
of packets can be part of asymmetric ﬂows [48]. This
severely constrains where in the network E2M schemes
that require symmetric ﬂows can be deployed.

Our approach In this paper, we propose TapDance,
a novel end-to-middle proxy approach that removes these
obstacles to deployment at the cost of a moderate in-
crease in its susceptibility to active attacks by the censor.
TapDance is the ﬁrst E2M proxy that works without an
inline-blocking or redirecting element at an ISP. Instead,
our design requires only a passive tap that observes trafﬁc
transiting the ISP and the ability to inject new packets.
TapDance also includes a novel connection tagging mech-
anism that embeds steganographic tags into the ciphertext
of a TLS connection. We make use of this to allow the
system to support asymmetric ﬂows and to efﬁciently
include large steganographic payloads in a single packet.
Although TapDance appears to be more feasible to de-
ploy than previous E2M designs, this comes with certain
tradeoffs. As we discuss in Section 5, there are several
active attacks that a censor could perform on live ﬂows in
order to distinguish TapDance connections from normal
trafﬁc. We note that each of the previous E2M schemes is
also vulnerable to at least some active attacks. As a poten-
tial countermeasure, we introduce active defense mech-
anisms, which utilize E2M’s privileged vantage point in
the network to induce false positives for the attacker.

Even with these tradeoffs, TapDance provides a real-
istic path to deployment for E2M proxy systems. Given
the choice between previous schemes that appear not to
be practically ﬁeldable and our proposal, which better
satisﬁes the constraints of real ISPs but requires a careful
defense strategy, we believe TapDance is the more viable
route to building anticensorship into the Internet’s core.
Organization Section 2 reviews the three existing
E2M proposals. Section 3 introduces our chosen cipher-
text steganography mechanism, and Section 4 explains
the rest of the TapDance construction. In Section 5, we
analyze the security of our scheme and propose active
defense strategies. In Section 6, we compare TapDance to
previous E2M designs. We describe our proof-of-concept
implementation in Section 7 and evaluate its performance
in Section 8. We discuss future work in Section 9 and re-
lated work in Section 10, and we conclude in Section 11.

2 Review of Existing E2M Protocols

There are three original publications on end-to-middle
proxying: Telex [49], Decoy Routing [26], and Cirri-
pede [21]. The designs for these three systems are largely
similar, although some notable differences exist. Figure 1
show the Telex scheme, as one example.

In each design, a client wishes to reach a censored
website. To do so, the client creates an encrypted connec-
tion to an unblocked decoy server, with the connection to
this server passing through a cooperating ISP (outside the
censored country) that has deployed an ISP station. The
decoy can be any server and is oblivious to the operation
of the anticensorship system. The ISP station determines
that a particular client wishes to be proxied by recogniz-
ing a tag. In Telex, this is a public-key steganographic tag
placed in the random nonce of the ClientHello message of
a Transport Layer Security (TLS) connection [12]. In Cir-
ripede, users register their IP address with a registration
server by making a series of TCP connections, encoding
a similar tag in the initial sequence numbers (ISNs). In
Decoy Routing, the tag is placed in the TLS client nonce
as in Telex, but the client and the ISP station are assumed
to have a shared secret established out of band.

In both Telex and Cirripede, the tag consists of an el-
liptic curve Difﬁe-Hellman (ECDH) public key point and
a hash of the ECDH secret shared with the ISP station. In
Decoy Routing, the tag consists of an HMAC of the previ-
ously established shared secret key, the current hour, and
a per-hour sequence number. In all cases, only the station
can observe this tag, using its private key or shared secret.
Once the station has determined that a particular ﬂow
should be proxied, all three designs employ an inline
blocking component at the ISP to block further commu-
nication between the client and the decoy server. Telex
and Decoy Routing both block only the tagged ﬂow us-
ing an inline-blocking component. Cirripede blocks all
connections from a registered client. Cirripede’s inline
blocking is based on the client’s IP address and has a long
duration, possibly making it easier to implement than the
ﬂow-based blocking used in Telex and Decoy Routing.

After the TLS handshake has completed and the client-
server communication is blocked, all three designs have
the station impersonate the decoy server, receiving pack-
ets to and spooﬁng packets from its IP address. In Telex,
the station uses the tag in the TLS client nonce to com-
pute a shared secret with the client, which the client uses
to seed its secret keys during the key exchange with the
decoy server. Using this seed and the ability to observe
both sides of the TLS handshake, Telex derives the master
secret under which the TLS client-server communication
is encrypted, and continues to use this shared secret be-
tween station and client. In Cirripede and Decoy Routing,
the station changes the key stream to be encrypted under

160  23rd USENIX Security Symposium 

USENIX Association

Client 

Telex 

Server 

TLS 

Handshake 

Encrypted 

Data 

Inline block starts; 
Telex forwards packets 

Telex resets server and 
impersonates server to client 

Figure 1: Telex End-to-Middle Scheme — To establish communication with an ISP-deployed Telex station, the client performs a
TLS connection with an unblocked decoy server. In the TLS ClientHello message, it replaces the random nonce with a public-key
steganographic tag that can be observed by the Telex station at the on-path ISP outside the censored country. When the station detects
this tag with its private key, it blocks the true connection using an inline-blocking component and forwards packets for the remainder
of the handshake. Once the handshake is complete, Telex stops forwarding and begins to spoof packets from the decoy server in
order to communicate with the client. While here we only show the details of Telex, all of the ﬁrst generation ISP proxies (Telex,
Cirripede, and Decoy Routing) are similar in architecture; we note differences in Section 2.

the secret exchanged during registration (Cirripede) or
previously shared (Decoy Routing).

Changing the communication to a new shared secret
opens Cirripede and Decoy Routing to replay and preplay
attacks by the adversary. If an adversary suspects a user
is accessing these proxies, it can create a new connection
that replays parts from the suspected connection and re-
ceive conﬁrmation that a particular ﬂow uses the proxy.
For example, in Decoy Routing, the adversary can sim-
ply use the suspected connection’s TLS client nonce in a
new connection and send a request. If the ﬁrst response
cannot be decrypted with the client-server shared secret,
it conﬁrms that the particular nonce was tagged. For Cir-
ripede, a similar replay of the tagged TCP SYN packets
will register the adversary’s client, and a connection to the
decoy server over TLS will conﬁrm this: if the adversary
can decrypt the TLS response with the established mas-
ter secret, the adversary is not registered with Cirripede,
indicating that the TCP SYN packets were not a secret
Cirripede tag. Otherwise, if the adversary cannot decrypt
the response, this indicates that the SYN packets were
indeed a Cirripede tag.

Telex is not vulnerable to either of these attacks, be-
cause the client uses the client-station shared secret to
seed its half of the key exchange. This allows the station
to also compute the client-server shared master secret and
verify that the client has knowledge of the client-server

shared secret by verifying the TLS ﬁnished messages. If
an adversary attempted to replay the client random in a
new connection, Telex would be able to determine that the
user (in this case, the adversary) did not have knowledge
of the client-station shared secret, because the user did not
originally generate the Difﬁe-Hellman tag. Thus, Telex is
unable to decrypt and verify the TLS ﬁnished messages
as expected, and will not spoof messages from the server.
Both Cirripede and Decoy Routing function in the pres-
ence of asymmetric ﬂows. In Cirripede, the station only
needs to observe communication from the client to the
decoy server in order to establish its shared secret with
the client. In Decoy Routing, the client sends any missing
information (i.e., information contained in messages from
the server to the client) via another covert channel. In
contrast, Telex’s approach does not handle asymmetric
paths, as the station needs to see both sides of the commu-
nication in order to learn the client-server shared master
secret.

Unlike any of the existing schemes, TapDance func-
tions without an inline blocking component, potentially
making it much easier to deploy at ISPs. Unlike Telex, it
supports asymmetric ﬂows, but in doing so it sacriﬁces
some of Telex’s resistance to active attacks. We defer
a complete comparison between TapDance and the ﬁrst-
generation E2M schemes until Section 6, after we have
introduced the details of the system.

USENIX Association  

23rd USENIX Security Symposium  161

3 Ciphertext Covert Channel

3.1 Chosen-Ciphertext Steganography

Previous E2M covert channels have been limited in
size, forcing implementations to use small payloads or
several ﬂows in order to steganographically communicate
enough information to the ISP station. However, because
TapDance does not depend on inline ﬂow-blocking and
must work with asymmetric ﬂows, we need a way to
communicate the client’s request directly to the TapDance
station while maintaining a valid TLS session between
the client and the decoy server. We therefore introduce
a novel technique, chosen-ciphertext steganography,
which allows us to encode a much higher bandwidth
steganographic payload in the ciphertexts of legitimate
(i.e., censor-allowed) TLS trafﬁc.

The classic problem in steganography is known as the
prisoners’ problem, formulated by Simmons [41]: two
prisoners, Alice and Bob, wish to send hidden messages in
the presence of a jailer. These messages are disguised in
legitimate, public communication between Alice and Bob
in such a way that the jailer cannot detect their presence.
Many traditional steganographic techniques focus on em-
bedding hidden messages in non-uniform cover channels
such as images or text [4]; in the network setting, each
layer of the OSI model may provide potential cover traf-
ﬁc [19] of varying bandwidths. To avoid detection, these
channels must not alter the expected distribution of cover
trafﬁc [32]. In addition, use of header ﬁelds in network
protocols for steganographic cover limits the carrying
capacity of the covert channel.

We observe it is possible for the sender to use stream
ciphers and CBC-mode ciphers as steganographic chan-
nels. This allows a sender Alice to embed an arbitrary
hidden message to a third party, Bob, inside a valid ci-
phertext for Cathy. That is, Bob will be able to extract
the hidden message and Cathy will be able to decrypt the
ciphertext, without alerting outside entities (or, indeed,
Cathy, subject to certain assumptions) to the presence of
the steganographic messages.

Moreover, through this technique, we can place lim-
ited constraints on the plaintext (such as requiring it be
valid base64 or numeric characters), while encoding ar-
bitrary data in the corresponding ciphertext. This allows
us to ensure not only that Cathy can decrypt the received
ciphertext, but also that the plaintext is consistent with
the protocol used. Note that this is a departure from the
original prisoners’ problem, as we assume Alice is al-
lowed to securely communicate with Cathy, so long as
this communication looks legitimate to outside entities.
As our technique works both with stream ciphers and
CBC-mode ciphers, which are the two most common
modes used in TLS [28], we will use this building block to
encode steganographic tags and payloads in the ciphertext
of TLS requests.

To describe our technique, we start with a stream cipher in
counter mode. The key observation is that counter mode
ciphers, even with authentication tags, have ciphertexts
that are malleable from the perspective of the sender, Al-
ice. That is, stream ciphers have the general property
of ciphertext malleability, in that ﬂipping a single bit in
the ciphertext ﬂips a single corresponding bit in the de-
crypted plaintext. Alice can likewise change bits in the
plaintext to effect speciﬁc bits in the corresponding ci-
phertext. Since Alice knows the keystream for the stream
cipher, she can choose an arbitrary string that she would
like to appear in the ciphertext, and compute (decrypt)
the corresponding plaintext. Note that this does not in-
validate the MAC or authentication tag used in addition
to this cipher, because Alice ﬁrst computes a valid plain-
text, and then encrypts and MACs it using the standard
library, resulting in ciphertext that contains her chosen
steganographic data.

Furthermore, Alice can “ﬁx” particular bits in the plain-
text and allow the remaining bits to be determined by
the data encoded in the ciphertext. For example, Alice
could require that each plaintext byte starts with 5 bits
set to 00110, and allow the remaining 3 bits to be chosen
by the ciphertext. In this way, the plaintext will always
be an ASCII character from the set “01234567” and the
ciphertext has a steganographic “carrying capacity” to
encode 3 bits per byte.

While it seems intuitive that Alice can limit plaintext
bits for stream ciphers, it may not be as intuitive to see
how this is also possible for CBC-mode ciphers. How-
ever, while the ciphertext malleability of stream ciphers
allows Alice partial control over the resulting plaintext,
we show that it is also possible to use this technique in
other cipher modes, with equal control over the plaintext
values.

In CBC mode, it is possible to choose the value of
an arbitrary ciphertext block (e.g., C2), and decrypt it
to compute an intermediary result. This intermediary
result must also be the result of the current plaintext
block (P2) xored with the previous ciphertext block (C1)
in order to encrypt to the chosen ciphertext value. This
means that, given a ciphertext block, we can choose ei-
ther the plaintext value (P2), or the previous ciphertext
block (C1), and compute the other. However, we can
also choose a mixture of the two; that is, for each bit
we pick in the plaintext, we are “forced” to choose that
corresponding bit in the previous plaintext block and vise-
versa. Choosing any bits in a ciphertext block (C1) will
force us to repeat this operation for the previous plain-
text block (P1) and twice previous ciphertext block (C0).
We can choose to pick the value of plaintext blocks (ﬁx-
ing the corresponding ciphertext blocks), all the way

162  23rd USENIX Security Symposium 

USENIX Association

100  100 

110  111 

P1 

101  101 

P2 

P0 

4 TapDance Architecture

101  101 

IV 

001  001 
Enc 

110  011 
Enc 

001  101 
Enc 

000  100 

C0 

100  000 

000  000 

C2 

C1 

Figure 2: CBC Chosen Ciphertext Example — In this exam-
ple, bits chosen by the encoding are in black, while bits “forced”
by computation are red. For example, we choose all 6-bits to
be 0 in the last ciphertext block. This forces the block’s inter-
mediary to be “forced” to a value beyond our control; in this
case 001101. To obtain this value, we can choose a mixture
of bits in the plaintext, which forces the corresponding bits in
the previous ciphertext block. In this example, we choose the
plaintext block to be of the form 1xx1xx, allowing us to choose
4-bits in the ciphertext, which we choose to be 0s. Thus, the
ciphertext has the form x00x00. We solve for the unknown bits
in the ciphertext and plaintext (1xx1xx⊕ x00x00 = 001101) to
ﬁll in the missing “ﬁxed” values. We can repeat this process
backward until the ﬁrst block, where we simply compute the
IV in order to allow choosing all the bits in the ﬁrst plaintext
block.

back to the ﬁrst plaintext block, where we are left to
decide if we want to choose the value of the ﬁrst plain-
text block or the Initialization Vector (IV) value. At this
point, ﬁxing the IV is the natural choice, as this leaves
us greater control over the ﬁrst plaintext block. Figure 2
shows an example of this backpropagation, encoding a
total of 4-bits per 6-bit ciphertext block (plus a full ﬁnal
block).

This scheme allows us to restrict plaintexts encrypted
with CBC to the same ASCII range as before, while still
allowing us to encode arbitrary-length messages in the
ciphertext.

While the sender can encode any value in the ciphertext
in this manner, we do not wish to change the expected
ciphertext distribution. The counter and CBC modes of
encryption both satisfy indistinguishability from random
bits [38], so encoding anything that is distinguishable
from a uniform random string would allow third par-
ties (e.g., a network censor) to detect this covert chan-
nel. To prevent this, Alice encrypts her hidden message
if necessary, using an encryption scheme that produces
ciphertexts indistinguishable from random bits. The re-
sulting ciphertext for Bob is then encoded in the CBC
or stream-cipher ciphertext as outlined above. To an out-
side adversary, this resulting “ciphertext-in-ciphertext”
should still be a string indistinguishable from random, as
expected.

4.1 Protocol Overview

The TapDance protocol requires only a passive network
tap and trafﬁc injection capability, and is carefully de-
signed to work even if the station is unable to observe
communication between the decoy server and the client.
To accomplish this, we utilize several tricks gleaned from
a close reading of the TCP speciﬁcation [35] to allow the
TapDance station to impersonate the decoy server without
blocking trafﬁc between client and server.

Figure 3 gives an overview of the TapDance protocol.
In the ﬁrst step, the client establishes a normal TLS con-
nection to the decoy web server. Once this handshake
is complete, the client and decoy server share a master
secret, which they use to generate encryption keys, MAC
keys, and initialization vector or sequence state.

The TapDance protocol requires the client to leak
knowledge of the client-server master secret, thereby al-
lowing the station to use this shared secret to encrypt all
communications. The client encodes the master secret as
part of a steganographic tag visible only to the TapDance
station. This tag is hidden in an incomplete HTTP request
sent to the decoy server through the encrypted channel.
Since this request is incomplete, the decoy server will not
respond with data to the client; this can be accomplished,
for example, by simply withholding the two consecutive
line breaks that mark the end of an HTTP request. The
decoy server will acknowledge this data only at the TCP
level by sending a TCP ACK packet and will then wait
for the rest of the client’s incomplete HTTP request until
it times out. As shown in Figure 5, our evaluation reveals
that most TLS hosts on the Internet will leave such in-
complete request connections open for at least 60 seconds
before sending additional data or closing the connection.
When the TapDance station observes this encrypted
HTTP request, it is able to extract the tag (and hence the
master secret), as discussed in detail in Section 4.2. The
station then spoofs an encrypted response from the decoy
server to the client. This message acts as conﬁrmation
for the client that the TapDance station is present. In
particular, this message is consistent with a pipelined
HTTPS connection, so by itself does not indicate that
TapDance is in use.

At the TCP level, the client acknowledges this spoofed
data with a TCP ACK packet, and because there is no
inline-blocking between it and the server, the ACK will
reach the server. However, because the acknowledgment
number is above the server’s SND.NXT , the server will
not respond. Similarly, if the client responds with addi-
tional data, the acknowledgment ﬁeld contained in those
TCP packets will also be beyond what the server has sent.
This allows the TapDance station to continue to imper-

USENIX Association  

23rd USENIX Security Symposium  163

Client	  

K	  

2	  

TLS	  

Handshake	  

1	  

Decoy	  
Server	  

K	  

EncK(incomplete	  HTTP	  request):	  	  

“\x95\x1f\x6b\x27\xe2	  …	  	  	  	  	  	  	  	  	  	  	  	  	  	  \xc8\x3f\x22	  …”	  

Tag	  

TapDance	  Sta2on	  

3	  

Sta<on	  extracts	  	  	  	  	  	  	  	  	  	  	  	  	  ,	  recovers	  K	  	  

Tag	  

ACK	  [seq=Y,	  ack=X]	  

5	  

Sta<on	  sends	  conﬁrma<on	  

EncK(“Sta<on	  here”),	  [seq=Y,	  ack=X,	  len=M]	  

4	  

	  Server	  
sends	  ACK	  
and	  waits	  

6	  

ACK	  [seq=X,	  ack=Y+M]	  
EncK(“GET	  hSp://blocked.com/	  …”),	  [seq=X,	  ack=Y+M]	  

7	  

Sta<on	  sends	  blocked.com	  

EncK(“HTTP/1.1	  200	  OK	  	  …	  	  <html>	  	  ….”)	  

EncryptedAlert,	  FIN+ACK	  [seq=X’,	  ack=Y’,	  len=N]	  

8	  

EncryptedAlert,	  FIN+ACK	  [seq=Y’,	  ack=X’+N+1,	  len=N]	  

ACK	  [seq=X’+N,	  ack=Y’+N]	  

Connec<on	  
teardown	  
	  

9	  

Sta<on	  sends	  TCP	  RST	  

RST	  [seq=X,	  ack=Y]	  

Figure 3: TapDance Overview — (1) The client performs a normal TLS handshake with an unblocked decoy server, establishing a
session key K. (2) The client sends an incomplete HTTP request through the connection and encodes a steganographic tag in the
ciphertext of the request, using a novel encoding scheme (Section 4.2). (3) The TapDance station observes and extracts the client’s
tag, and recovers the client-server session secret K. (4) The server sends a TCP ACK message in response to the incomplete HTTP
request and waits for the request to be completed or until it times out. (5) The station, meanwhile, spoofs a response to the client from
the decoy server. This message is encrypted under K and indicates the station’s presence to the client. (6) The client sends a TCP
ACK (for the spoofed data) and its real request (blocked.com). The server ignores both of these, because the TCP acknowledgment
ﬁeld is higher than the server’s TCP SND.NXT. (7) The TapDance station sends back the requested page (blocked.com) as a spoofed
response from the server. (8) When ﬁnished, the client and TapDance station simulate a standard TCP/TLS authenticated shutdown,
which is again ignored by the true server. (9) After the connection is terminated by the client, the TapDance station sends a TCP RST
packet that is valid for the server’s SND.NXT, silently closing its end of the connection before its timeout expires.

164  23rd USENIX Security Symposium 

USENIX Association

sonate the server, acknowledging data the client sends,
and sending its own data in response, without interference
from the server itself.

4.2 Tag Format
In TapDance, we rely on elliptic curve Difﬁe-Hellman to
agree on a per-connection shared secret between the client
and station, which is used to encrypt the steganographic
tag payload. The tag consists of the client’s connection-
speciﬁc elliptic curve public key point (Q = eG), encoded
as a string indistinguishable from uniform, followed by
a variable-length encrypted payload used to communi-
cate the client-server TLS master secret (and intent for
proxying) to the station.

In order to properly disguise the client’s elliptic curve
point, we use Elligator 2 [8] over Curve25519 [7]. Elliga-
tor 2 is an efﬁcient encoding function that transforms, for
certain types of elliptic curves, exactly half of the points
on the curve to strings that are indistinguishable from
uniform random strings.

The client uses the TapDance station’s public key point
(P = dG) and its own private key (e) to compute an ECDH
shared secret with the station (S = eP = dQ), which is
used to derive the payload encryption key. The encrypted
payload contains an 8-byte magic value used by the sta-
tion to detect successful decryption, the client and server
random nonces, and the client-server master secret of the
TLS connection. With this payload, typically contained
in a single packet from the client, the station is able to
derive the TLS master secret between client and server.
We insert the tag, composed of the encoded point and
encrypted payload, into the ciphertext of the client’s in-
complete request to the server using the chosen cipher-
text steganographic channel described in Section 3. In
order to avoid the server generating unwanted error mes-
sages, we maintain some control over the plaintext that the
server receives using the plaintext-limiting technique as
described in Section 3. Speciﬁcally, we split the tag into
6-bit chunks and encode each chunk in the low order bits
of a ciphertext byte. This allows the two most signiﬁcant
bits to be chosen freely in the plaintext (i.e. not decided
by the decryption of the tag-containing ciphertext). We
choose these two bits so that the plaintext always falls
within the ASCII range 0x40 to 0x7f. We veriﬁed that
Apache was capable of handling this range of characters
in a header line without triggering an error.

5 Security Analysis

Our threat model is similar to that of previous end-to-
middle designs. We assume an adversarial censor that
can observe, alter, block, or inject network trafﬁc within
their domain or geographic region (i.e., country) and may

gain access to foreign resources, such as VPNs or private
servers, by leasing them from providers. Despite control
over its network infrastructure, however, we assume the
censor does not have control over end-users’ computers,
such as the ability to install arbitrary programs or Trojans.
The censor can block its citizens’ access to websites it
ﬁnds objectionable, proxies, or other communication end-
points it chooses, using IP blocking, DNS blacklists, and
deep-packet inspection. We assume the censor uses black-
listing to block resources and that the censor does not
wish to block legitimate websites or otherwise cut them-
selves off from the rest of the Internet, which may inhibit
desirable commerce or communication. In addition, we
assume that the censor allows end-to-end encrypted com-
munication, speciﬁcally TLS communication. As web-
sites increasingly support HTTPS, censors face increasing
pressures against preventing TLS connections [14].

While the threat model for TapDance is similar to those
assumed by prior end-to-middle schemes, our fundamen-
tally new design has a different attack surface than the
others. We perform a security analysis of TapDance and
compare it to the previous generation designs, focusing
on the adversarial goal of distinguishing normal TLS con-
nections from TapDance connections. In particular, we
do not attempt to hide the deployment locations of the
TapDance stations themselves.

5.1 Passive Attacks

TLS handshake
TLS allows implementations to sup-
port many different extensions and cipher suites. As a
result, implementations can be easy to differentiate based
on the ciphers and extensions they claim to support in
their ClientHello or ServerHello messages. In order to
prevent this from being used to locate suspicious imple-
mentations, our proxy must blend in to or mimic another
popular client TLS implementation. For example, we
could support the same set of ciphers and extensions as
Chrome for the user’s platform. Currently, our client
mimics Chrome’s cipher suite list for Linux.
Cryptographic attacks A computationally powerful
adversary could attempt to derive the station’s private
key from the public key. However, our use of ECC
Curve25519 should resist even the most powerful compu-
tation attacks using known discrete logarithm algorithms.
The largest publicly known ECC key to be broken is
only 112 bits, broken over 6 months in 2009 on a 200-
PlayStation3 cluster [9]. In contrast to Telex, TapDance
also supports increasing the key size as needed, as we are
not limited to a ﬁxed ﬁeld size for our tag.
Forward secrecy An adversary who compromises an
ISP station or otherwise obtains a station’s private key
can use it to trivially detect both future and previously

USENIX Association  

23rd USENIX Security Symposium  165

recorded ﬂows in order to tell if they were proxy ﬂows.
Additionally, they can use the key to decrypt the user’s
request (and proxy’s response), learning the censored
websites users have visited. To address the ﬁrst problem,
we can use a technique suggested in Telex [49]. The
ISP station generates many private keys ahead of time and
stores them in either a hardware security module or ofﬂine
storage, and provides all of the public keys to the clients.
Clients can then cycle through the public keys they use
based on a course-grained time (e.g., hours or days). The
proxy could also cycle through keys, destroying expired
keys and limiting access to future ones.

To address the second problem, TapDance is compat-
ible with existing forward-secure protocols. For example,
for each new connection it receives, the TapDance station
can generate a new ECDH point randomly, and establish a
new shared secret between this new point and the original
point sent by the client in the connection tag. The sta-
tion sends its new ECDH public point to the client in its
Hello message, and the remainder of the connection is en-
crypted under the new shared secret. This scheme has the
advantage that it adds no new round trips to the scheme
and only 32-bytes to the original ISP station’s response.

Packet timing and length
The censor could passively
measure the normal round-trip time between potential
servers and observe the set of packet lengths of encrypted
data that a website typically returns. During a proxy con-
nection, the round-trip time or the packet lengths of the
apparent server may change for an observant censor, as
the station may be closer or have more processing delay
than the true server. This attack is possible on all three
of the ﬁrst generation E2M schemes, as detailed in [40].
However, such an attack at the application level may be
difﬁcult to carry out in practice, as larger, legitimate web-
sites may have many member-only pages that contain dif-
ferent payload lengths and different processing overhead.
The censor must be able to distinguish between “blind
pages” it cannot conﬁrm are part of the legitimate site and
decoy proxy connections. We note that this is difﬁcult at
the application level, but TCP round-trip times may have
a more consistent and distinguishable difference.

Lack of server response
If the TapDance station fails
to detect a client’s ﬂow, it will not respond to the client.
This may appear suspicious to a censor, as the client sends
a request, but there is no response at the application level
from the server. This scenario could occur for three rea-
sons. First, the censor may disrupt the path between client
and TapDance station in order to cause such a timeout,
using one of the active attacks below (such as the routing-
around attack), in order to conﬁrm a particular ﬂow is
attempting to use TapDance. Second, such false pickups
may happen intermittently (due to ISP station malfunc-
tion). Finally, a client may attempt to ﬁnd new TapDance

stations by probing many potential decoy servers with
tagged TLS connections. Paths that do not contain ISP
stations will have suspiciously long server response times.
To address the last issue, probing clients could send
complete requests and tag their requests with a secret
nonce. The station could record these secret nonces, and,
at a later time (out of band, or through a different Tap-
Dance station), the client can query the station for the
secret nonces it sent. In this way, the client learns new
servers for which the ISP station is willing to proxy with-
out revealing the probing pattern. To address the ﬁrst two
problems, we could have clients commonly use servers
that support long-polling HTTP push notiﬁcation. In these
services, normal requests can go unanswered at the ap-
plication layer as long as the server does not have data
to send to the client, such as in online-gaming or XMPP
servers. Another defense is to have the client send com-
plete requests that force the server to keep the connection
alive for additional requests, and to have the TapDance
station inject additional data after the server’s initial re-
sponse. This requires careful knowledge of the timing
and length of the server’s initial response, which could
either be provided by active probing from the station or
information given by the client.
TCP/IP protocol ﬁngerprinting
The adversary could
attempt to observe packets coming from potential decoy
servers and build proﬁles for each server, including the
set of TCP options supported by the server, IP TTL val-
ues, TCP window sizes, and TCP timestamp slope and
offset. If these values ever change, particularly in the
middle of a connection (and only for that connection), it
could be a strong indication of a particular ﬂow using a
proxy at an on-path ISP. To prevent this attack, the station
also needs to build these proﬁles for servers, either by
actively collecting this proﬁle from potential servers, or
passively observing the server’s responses to non-proxy
connections and extracting the parameters. Alternatively,
the client can signal to the station some of the parame-
ters. First generation schemes varied in defense for this
type of attack; for example, Telex’s implementation is
able to infer and mimic all of these parameters from ob-
serving the servers’ responses, although Telex requires
a symmetric path in order to accomplish this. In theory,
parameters that the adversary can measure for ﬁngerprint-
ing can also be measured by the station and mimicked.
However, given that the adversary has only to ﬁnd one
distinguisher in order to succeed, server mimicry remains
difﬁcult to achieve in practice.

5.2 Active Attacks

TLS attacks
The censor may issue fake TLS certiﬁ-
cates from a certiﬁcate authority under its control and
then target TLS sessions with a man-in-the-middle attack.

166  23rd USENIX Security Symposium 

USENIX Association

While TapDance and previous designs are vulnerable to
this attack, there may be external political pressure that
discourages a censor from this attack, as it may be disrup-
tive to foreign e-commerce in particular. We also argue
that as the number of sites using TLS continues to in-
crease, this attack becomes more expensive for the censor
to perform without impacting performance. Finally, decoy
servers that use certiﬁcate pinning or other CA-protection
mechanisms such as Perspectives [45], CAge [27], or CA
country pinning [42], can potentially avoid such attacks.

Packet injection Because TapDance does not block
packets from the client to the true server, it is possible for
the censor to inject spoofed probes from the client that
will reach the server. If the censor can craft a probe that
will result in the server generating a response that reveals
the server’s true TCP state, the censor will be able to use
this response to differentiate real connections from proxy
connections. While the previous designs also faced this
threat [40], the censor had to inject the spoofed packet
in a way that bypassed the station’s ISP inline blocking
element. In TapDance, there is no blocking element, and
so the censor is able to simply send it without any routing
tricks. An example of this attack is the censor sending
a TCP ACK packet with a stale sequence number, or
one for data outside the server’s receive window. The
server will respond to this packet with an ACK containing
the server’s TCP state (sequence and acknowledgment),
which will be smaller than the last sequence and/or ac-
knowledgments sent by the station.

There are a few ways to deal with this attack if the cen-
sor employs it. First, we can simply limit each proxy con-
nection to a single request from the client and a response
from the station, followed immediately by a connection
close. This will dramatically increase the overhead of the
system but will remove the potential for the adversary to
use injected packets and their responses to differentiate
between normal and proxy connections. This is because
the TCP state between the station and real server will not
diverge until the station has sent its response, leaving only
a very small window where the censor can probe the real
server for its state and get a different response.

Active defense Alternatively, in order to frustrate the
censor from performing packet injection attacks, we can
perform active defense, where the station observes active
probes such as the TCP ACK and responds to them in
a way that would “reveal” a proxy connection, even for
ﬂows that are not proxy connections. To the censor, this
would make even legitimate non-proxy connections to the
server appear as if they were proxy connections.

As an example, consider a censor that injects a stale
ACK for suspected proxy connections. Connections that
are actually proxy connections will respond with a stale
ACK from the server, revealing the connection to the

censor. However, the station could detect the original
probe, and if it is not a proxied connection, respond with
a stale ACK so as to make it appear to the censor as if it
were. In this way, for every probe the censor makes, they
will detect, sometimes incorrectly, that the connection
was a proxy connection.

Replay attacks
The censor could capture suspected
tags and attempt to replay them in a new connection, to
determine if the station responds to the tag. To speciﬁcally
attack TapDance, the adversary could replay the client’s
tag-containing request packet after the connection has
closed and observe if the station appears to send back a
response. We note that both Cirripede and Decoy Routing
are also vulnerable to tag replay attacks, although Telex
provides some limited protection from them. To protect
against duplicated tags, the station could record previous
tags and refuse to respond to a repeated tag. To avoid
saving all tags, the station could require clients to include
a recent timestamp in the encrypted payload1.

However, such a defense may enable a denial of ser-
vice attack: the censor could delay the true request of
a suspected client and send it in a different connection
ﬁrst. In this preplay version of the attack, the censor is
also able to observe whether the station responds with the
ClientHello message. If it does, the censor will know the
suspected request contained a tag.

Denial of service
The censor could attempt to exhaust
the station’s resources by creating many proxy connec-
tions, or by sending a large volume of trafﬁc that the ISP
station will have to check for tags using an expensive ECC
function. We estimate that a single ISP station deploy-
ment of our implementation on a 16-core machine could
be overwhelmed if an attacker sends approximately 1.2
Gbps of pure TLS application data packets past it. This
type of attack is feasible for an attack with a small botnet,
or even a few well-connected servers. Because ISPs com-
monly perform load balancing by ﬂow-based hashing, we
can scale our deployment linearly to multiple branches of
machines and use standard intrusion detection techniques
to ignore packets that do not belong to valid connections
or that come from spoofed or blacklisted sources [34].

Routing around the proxy
A recent paper by
Schuchard et al. details a novel attack against our and
previous designs [40]. In this attack, the censor is able
to change local routing policy in a way that redirects
outbound ﬂows around potential station-deploying ISPs
while still allowing them to reach their destinations. This
prevents the ISP station from being able to observe the
tagged ﬂows and thus from being a proxy for the clients.
However, Houmansadr et al. investigate the cost to the

1The client random which is sent in the encrypted payload already

contains a timestamp for the ﬁrst 4 bytes

USENIX Association  

23rd USENIX Security Symposium  167

censor of performing such an attack and ﬁnd it to be pro-
hibitively expensive [23]. Although both of these papers
ultimately contribute to deciding which ISPs should de-
ploy proxies in order to be most resilient, we consider
such a discussion outside our current scope.
Tunneling around the proxy A more conceptually
simple attack is for the censor to transparently tunnel spe-
ciﬁc suspected ﬂows around the ISP station. For example,
the censor could rent a VPN or VPS outside the country
and send speciﬁc ﬂows through them to avoid their paths
crossing the ISP station. This attack is expensive for the
adversary to perform, and so could not reasonably be
performed for an entire country. However, it could be per-
formed for particular targets and combined with previous
passive detection attacks to aid the censor in conﬁrming
whether particular users are tagging their ﬂows.
Complicit servers A censor may be able to compro-
mise, coerce, or host websites that can act as servers for
decoy connections. The vantage point from a server al-
lows them to observe incomplete requests from clients,
including the plaintext that the client mangled in order to
produce the tag in the ciphertext. This allows the censor
to both observe speciﬁc clients using the ISP station and
also disrupt use of the proxy with the particular server.
There is little TapDance or previous designs can do to
avoid cooperation between servers and the censor, as the
two can simply compare trafﬁc received and detect proxy
ﬂows as ones that have different data at the two vantage
points. However, using this vantage point to disrupt proxy
use could be detected by clients and the server avoided
(and potentially notiﬁed in the case of a compromise).

6 Comparison

On the protocol level, TapDance bears more similarity
to Telex than Cirripede, in that clients participate in Tap-
Dance on a per-connection basis, rather than participating
in a separate registration phase as in Cirripede, and in
that client-station communication, after the initial Difﬁe-
Hellman handshake, is secured using the client-server
master secret. In order to conserve bandwidth, our design,
like both Telex and Cirripede, leverages elliptic curve
cryptography to signal intent to use the system and to
establish a shared secret between client and station.

However, TapDance exhibits several important differ-
ences from previous protocols, which has implications
for both security and functionality. As discussed in Sec-
tion 1, one of the largest challenges to deploying E2M
proxies at ISPs is the inline ﬂow-blocking component.
TapDance has the singular advantage in that it allows
client-server communication to continue unimpeded. In
fact, our design requires only that the TapDance station
be able to passively observe communication from client

to server and be able to inject messages into the network;
the station can be oblivious to communication passing
from server to client.

The advantages of the TapDance protocol stem from its
careful use of chosen-ciphertext steganography (described
in Section 3) to hide the client’s tag and the fact that a high
percentage of servers ignore stale TCP-level messages.
In contrast, previous proposals rely on inline blocking to
prevent server-client communication, and TCP sequence
numbers and TLS ClientHello random nonces to disguise
the client’s steganographic tag. In general, these ﬁelds are
useful in steganography because these strings should be
uniformly random for legitimate connections, providing a
good cover for the tag that replaces them, so long as this
tag is indistinguishable from random.

However, both of these ﬁelds are ﬁxed size; each TLS
nonce can be replaced with a 224-bit uniform random
tag, and each TCP sequence number with only 24 bits
of a tag. Cirripede, which encodes the client’s tag into
TCP sequence numbers, uses multiple TCP connections
to convey the full tag to the station. Telex and Decoy
Routing both use a single TLS nonce to encode the client’s
tag. Given the limited bandwidth of these covert channels,
they are useful to convey only short secrets, while the rest
of the payload (such as the request for a blocked website)
must take place in a future packet.

TapDance, on the other hand,

leverages chosen-
ciphertext steganography in order to encode stegano-
graphic tags in the ciphertext of a TLS connection, with-
out invalidating the TLS session itself. Encoding the tag
in the ciphertext has several advantages. First, the tag is no
longer constrained to a ﬁxed ﬁeld size of either 24 or 224
bits, allowing us to encode more information in each tag,
and use larger and more secure elliptic curves. Second,
because the ciphertext is sent after the TLS handshake has
completed, it is possible to encode the connection’s mas-
ter secret in this tag, allowing the station to decrypt the
TLS session from a single packet, and without requiring
the station to observe packets from the server.

In addition, TapDance takes advantage of recent work
by Bernstein et al. [8], in order to disguise elliptic curve
points as strings indistinguishable from uniform, namely
Elligator 2. Traditional encoding of elliptic curve points
is distinguishable from random for several reasons, which
are outlined in detail in [8]. Telex and Cirripede address
this concern by employing two closely related elliptic
curves, which is less efﬁcient than TapDance’s use of
Elligator 2, as the latter method requires only a single
elliptic curve to achieve the same functionality.

From a security perspective, the only attacks unique
to TapDance are the lack of server response and packet
injection attacks. Besides these, we ﬁnd our design has
no additional vulnerabilities from which all previous de-
signs were immune. While these two attacks do pose a

168  23rd USENIX Security Symposium 

USENIX Association

Steganographic channel
Works without inline components
Handles asymmetric ﬂows
Proxies per ﬂow
Replay/preplay attack resistant
Trafﬁc analysis defense

(cid:31)
(cid:31)
(cid:30)
(cid:30)
(cid:31)

(cid:31)
(cid:30)
(cid:31)
(cid:31)
(cid:31)

(cid:31)
(cid:30)
(cid:30)
(cid:31)
(cid:31)

(cid:30)
(cid:30)
(cid:30)
(cid:31)
(cid:31)

Telex [49]

TLS client random

Cirripede [21] Decoy Routing [26]
TLS client random

TCP ISNs

TapDance

TLS ciphertext

Table 1: Comparing E2M Schemes — Unlike previous work, TapDance operates without an inline ﬂow-blocking component at
cooperating ISPs. However, it is vulnerable to active attacks that some previous designs resist. No E2M system yet defends against
trafﬁc analysis or website ﬁngerprinting, making this an important area for further study.

threat to TapDance, the beneﬁts of a practical ISP sta-
tion deployment—at least as a bridge to stronger future
systems—may outweigh the potential risks.

In summary, our approach obviates the need for an in-
line blocking element at the ISP, which is a requirement
of Telex, Cirripede, and Decoy Routing, while preserv-
ing system functionality in the presence of asymmetric
ﬂows, which is an advantage over Telex. In addition, the
covert channel used in TapDance is higher bandwidth
than that of previous proposals and holds potential for
future improvements (e.g., in terms of number of commu-
nication rounds required and ﬂexible security levels) of
client-station protocols.

7

Implementation

We have implemented TapDance in two parts: a client
that acts as a local HTTP proxy for a user’s browser, and
a station that observes a packet tap at an ISP and injects
trafﬁc when it detects tagged connections. Our station
code is written in approximately 1,300 lines of C, using
libevent, OpenSSL, PF_RING [33], and forge_socket2.

7.1 Client Implementation
Our client is written in approximately 1,000 lines of C us-
ing libevent [29] and OpenSSL [36]. The client currently
takes the domain name of the decoy server as a command
line argument, and for each new local connection from
the browser, creates a TLS connection to the decoy server.
Once the handshake completes, the client sends the in-
complete response to prevent the server from sending ad-
ditional data, and to encode the secret tag in the ciphertext
as speciﬁed in Section 4.2. The request is simply an HTTP
request with a valid HTTP request line, “Host” header,
and an “X-Ignore” header that precedes the “garbage”
plaintext that will be computed to result in the chosen tag
appearing in the ciphertext. We have implemented our
ciphertext encoding for AES_128_GCM [39], although

2https://github.com/ewust/forge_socket/

it also works without modiﬁcation for AES_256_GCM
cipher suites. We have implemented Elligator 2 to work
with Curve25519, in order to encode the client’s public
point in the ciphertext as a string that is indistinguishable
from uniform random. After this 32-byte encoded point,
the client places a 144-byte encrypted payload. This pay-
load is encrypted using a SHA-256 hash of the 32-byte
shared secret (derived from the client’s secret and station’s
public point) using AES-128 in CBC mode. We use the
ﬁrst 16-bytes of the shared secret hash as the key, and the
last 16 bytes as the initialization vector (IV). The payload
contains an 8-byte magic value, the 48-byte TLS master
secret, 32-byte client random, 32-byte server random, and
a 16-byte randomized connection ID that allows a client
to reconnect to a previous proxy connection in case the
underlying decoy connection is prematurely closed.

7.2 Station Implementation

Our TapDance station consists of a 16-core Supermicro
server connected over a gigabit Ethernet to a mirror port
on an HP 6600-24G-4XG switch in front of a well-used
Tor exit node generating about 160 Mbps of trafﬁc. The
station uses PF_RING, a fast packet capture Linux kernel
module, to read packets from the mirror interface. In
addition to decreasing packet capture overhead, PF_RING
supports ﬂow clustering, allowing our implementation
to spread TCP ﬂow capture across multiple processes.
Using this library, our station can have several processes
on separate cores share the aggregate load.

For each unique ﬂow (4-tuple), we keep a small amount
of state whether we have seen an Application Data packet
for the ﬂow yet. If we have not, we verify the current
packet’s TCP checksum, and inspect the packet to deter-
mine if it is an Application Data packet. If it is, we mark
this ﬂow as having been inspected, and pass the packet
ciphertext to the tag extractor function. This function
extracts the potential tag from the ciphertext, decoding
the client’s public point using Elligator 2, generating the
shared secret using Curve25519, and hashing it to get
the AES decryption key for the payload. The extractor

USENIX Association  

23rd USENIX Security Symposium  169

decrypts the 144-byte payload included by the client, and
veriﬁes that the ﬁrst 8 bytes are the expected magic value.
If it is, the station knows this is a tagged ﬂow, and uses
the master secret and nonces extracted from the encrypted
payload to compute the key block, which contains encryp-
tion and decryption keys, sequence numbers or IVs, and
MAC keys (if not using authenticated encryption) for the
TLS session between the client and server.

This “ciphertext-in-ciphertext” is indistinguishable
from random to everyone except the client and station.
The 144-byte payload is encrypted using a strong symmet-
ric block cipher (AES-128) in CBC mode, whose key is
derived from the client-station shared secret. The remain-
der of the tag is the client’s ECDH public point, encoded
using Elligator 2 [8] over Curve25519 [7]. The encoded
point is indistinguishable from uniform random due to
the properties of the Elligator 2 encoding function.

Once the station has determined the connection is a
tagged ﬂow, it sets up a socket in the kernel to allow it
to spoof packets from and receive packets for the server
using the forge_socket kernel module. The station makes
this socket non-blocking, and attaches an SSL object ini-
tialized with the extracted key block to it. The station then
sends a response to the client over this channel, contain-
ing a conﬁrmation that the station has picked up, and the
number of bytes that the client is allowed to send toward
this station before it must create a new connection.

7.3 Connection Limits
Because the server’s connection with the client remains
open, the server receives packets from the client, includ-
ing data and acknowledgments for the station’s data. The
server will initially ignore these messages, however there
are two instances where the server will send data. When
it does so, the censor would be able to see this anoma-
lous behavior, because the server will send data with stale
sequence numbers and different payloads from what the
station sent.

The ﬁrst instance of the server sending data is when the
server times out the connection at the application level.
For example, web servers can be conﬁgured to timeout
incomplete requests after a certain time, by using the
mod_reqtimeout3 module in Apache. We found through
our development and testing the shortest timeout was 20
seconds, although most servers had much longer time-
outs. We measured TLS hosts to determine how long
they would take to time out or respond to an incomplete
request similar to one used in TapDance. We measured
a 1% sample of the IPv4 address space listening on port
443, and the Alexa top million domains using ZMap [15],
and found that many servers had timeouts longer than 5
minutes. Figure 5 shows the fraction of server timeouts.

3http://httpd.apache.org/docs/2.2/mod/mod_reqtimeout.html

Figure 4: Download Times Through TapDance — We used
Apache Benchmark to download www.facebook.com 5000
times (with a concurrency of 100) over normal HTTPS, through
a single-hop proxy, and through our TapDance proof-of-concept.

The second reason a server will send observable pack-
ets back to the client is if the client sends it a sequence
number that is outside of the server’s current TCP receive
window. This happens when the client has sent more than
a window’s worth of data to the station, at which point the
server will respond with a TCP ACK packet containing
the server’s stale sequence and acknowledgment numbers,
alerting an observant censor to the anomaly.

To prevent both of these instances from occurring in
our implementation, we limit the connection duration to
less than the server’s timeout, and we limit the number
of bytes that a client can send to the station to up to
the server’s receive window size. Receive window sizes
after the TLS handshake completes are typically above
about 16 KB. We note that the station is not limited to the
number of bytes it can send to the client per connection,
making the 16 KB limit have minimal impact on most
download-heavy connections.

In the event that the client wants to maintain its connec-
tion for longer than the duration or send more than 16 KB,
the client can reuse the 16-byte connection ID in a new
E2M TLS connection to the server. The station will de-
code the connection ID and reconnect the new ﬂow to the
old proxy connection seamlessly. This allows the browser
to communicate to the HTTP proxy indeﬁnitely, without
having to deal with the limitations of the underlying decoy
connection.

8 Evaluation

Throughout our evaluation, we used a client running
Ubuntu 13.10 connected to a university network over
gigabit Ethernet. For our decoy server, we used a Tor exit
server at our institution, with a gigabit upstream through
an HP 6600-24G-4XG switch. For our ISP station, we
used a 16-core Supermicro server with 64 GB of RAM,

170  23rd USENIX Security Symposium 

USENIX Association

 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 200 400 600 800 1000 1200CDFDownload Time (ms)DirectProxyISP stationgiven time, comprising up to 35 Mbps of TLS trafﬁc. The
CPU load during this time was less than 1%.

We used Apache Benchmark4 in order to issue 5,000
requests through our station proxy, with a concurrency of
100, and compared the performance for fetching a simple
page over HTTP and over HTTPS. We also compare fetch-
ing the same pages directly from the server and through a
single-hop proxy. Figure 4 shows the cumulative distri-
bution function for the total time to download the page.
Although there is a modest overhead for end-to-middle
proxy connections compared to direct or simple proxies,
the overhead is not prohibitive to web browsing habits;
users are still able to interact with the page, and pages
can be expected to load in a reasonable time period. In
particular, our proxy adds a median latency of 270 mil-
liseconds to a page download in our tests when compared
with a direct download.

We ﬁnd that the CPU performance is bottlenecked by
our single-threaded client. During our tests, the client
consumes 100% CPU on a single core, while each of the
8 processes on the ISP station consume between 4-7%
CPU. We also observe that a majority of the download
time is spent waiting for the connection handshake to
complete with the server. To improve this performance,
we could speculatively maintain a connection pool in or-
der to decrease the wait-time between requests. However,
care must be taken in order to mimic the same connection
pool behaviors that a browser might exhibit.

We also note that although the distribution of down-
load times appear different for ISP station vs. normal
connections, this does not necessarily indicate an observ-
able feature for a censor. This is because our download
involves a second round trip between client and server
before the data reaches the client. The censor would still
have to distinguish between this type of connection behav-
ior and innocuous HTTP pipelined connections. It still
may be possible for the censor to distinguish, however,
as we discussed in Section 5, trafﬁc analysis is an open
problem for existing network proxies, and outside the
scope of this paper.

Tag creation and processing
In order to evaluate the
overhead of creating and checking for tags, we timed the
creation and evaluation of 10,000 tags. We were able to
create over 2,400 tags/second on our client and verify over
12,000 tags/second on a single core of our ISP station. We
ﬁnd that the majority of time (approximately 80%) during
tag creation is spent performing the expected three ECC
point multiplications (an expected two to generate the
client’s Elligator-encodable public point and one to gen-
erate the shared secret). Similarly, during tag checking,
nearly 90% of the computation time is spent on the single
ECC point multiplication. Faster ECC implementations

4http://httpd.apache.org/docs/2.2/programs/ab.html

Figure 5: Timeouts for Decoy Destinations — To measure
how long real TLS hosts will leave a connection open after re-
ceiving the incomplete request used in TapDance, we connected
to two sets of TLS hosts (the Alexa top 1 million and a 1% sam-
ple of the IPv4 address space). We sent TapDance’s incomplete
request and timed how long the host would leave the connection
open before either sending data or closing the connection. We
ﬁnd that over half the hosts will allow connections 60 seconds
or longer.

connected via gigabit NICs to an upstream and to a mirror
port from the HP switch. Our ISP station is therefore able
to observe (but not block) packets to the Tor exit server,
which provides a reasonable amount of background traf-
ﬁc on the order of 160 Mbps. In our tests, the Tor exit
node generates a modest amount of realistic user trafﬁc.
Although not anywhere near the bandwidth of a Tier-1
ISP, Tor exit nodes generate a greater ratio of HTTPS
ﬂows than a typical ISP (due to the Tor browser’s inclu-
sion of the HTTPS Everywhere plugin), and we can use
this microbenchmark to perform a back-of-the-envelope
calculation to the loads we would see at a 40 Gbps Transit
ISP tap.

We evaluate our proof-of-concept implementation with
the goal of demonstrating that our system operates as de-
scribed, and that our implementation is able to function
within the constraints of our mock-ISP. To demonstrate
that our system operates as described, we set Firefox to
use our client as a proxy, and browsed several websites
while capturing packets on the client and the decoy server.
We then manually inspected the recorded packets to con-
ﬁrm that there were no additional packets sent by the
server that would reveal our connections to be proxied
connections. Empirically, we note that we are able to
easily browse the Internet through this proxy, for example
watching high-deﬁnition YouTube videos.

To evaluate the performance of our system, we created
8 proxy processes on our ISP station, using the same
PF_RING cluster ID in order to share the load across 8
cores. The background trafﬁc from the Tor exit server
does not appear to have a signiﬁcant impact on the proxy’s
load: each process handles between 20 and 50 ﬂows at a

USENIX Association  

23rd USENIX Security Symposium  171

0.00.20.40.60.81.00306090120150180240300Fraction of hosts that timeout after X secondsTimeout (seconds)Alexa top 1 millionIPv4 sample(such as tuned-assembly or ASICs) could have a signif-
icant impact toward improving the performance of tag
veriﬁcation on the ISP station.

Server support
In order to measure how many servers
can act as decoy destinations, we probed samples of the
IPv4 address space as well as the Alexa top million hosts
with tests to indicate support for TapDance. In our ﬁrst
experiment, we tested how long servers would wait to
timeout an incomplete request, such as the one used by
the client in TapDance. We scanned TLS servers in a 1%
sample of the IPv4 address space, as well as the Alexa top
million hosts, and sent listening servers a TLS handshake,
followed by an incomplete HTTP request containing the
full range of characters used in the TapDance client. We
timed how long each server waited to either respond or
close the connection. Servers that responded immediately
do not support the TapDance incomplete request, either
because they do not support incomplete requests, or the
request contained characters outside the allowed range.
Figure 5 shows the results of this experiment. For the
20-second timeout used in our implementation, over 80%
of servers supported our incomplete request.

We also measured how servers handled the out-of-
sequence TCP packets sent by the TapDance client, in-
cluding packets acknowledging data not yet sent by the
server. Again, we used a 1% sample of the IPv4 ad-
dress space and the Alexa top million hosts. For each
host, we connected to port 80 and sent an incomplete
HTTP request, followed by a TCP ACK packet and a
data-containing packet, both with acknowledgements set
100 bytes ahead of the true value. We ﬁnd that the ma-
jority of Alexa servers still allow such packets, however,
older or embedded systems often respond to our probes, in
violation of the TCP speciﬁcation. We conclude that Tap-
Dance clients must carefully select which servers they use
as end points, but that there is no shortage of candidates
from which to select.

9 Future Work

The long-term goal of end-to-middle proxies is to be im-
plemented and deployed in a way that effectively combats
censorship. While we have suggested a design that we
believe is more feasible than previous work, more engi-
neering must be done to bring it to maturity.

For example, deploying an end-to-middle proxy such
as TapDance at an ISP requires not only scaling up to
meet the demands of proxy users, but also of the deploy-
ing ISP’s non-proxy trafﬁc, which can be on the order of
gigabits per second. One potential solution to this prob-
lem is to make the ISP component as stateless as possible.
Extending TapDance, it may be possible to construct a
“single-packet” version of an end-to-middle proxy. In this

version the client uses the ciphertext steganographic chan-
nel to encode its entire request to the proxy. The proxy
needs only detect these packets, fetch the requesting page,
and inject a response. Such a design would not need to re-
construct TCP ﬂows or keep state across multiple packets,
allowing it to handle higher bandwidths of trafﬁc, at the
expense of making active attacks easier to perform by an
adversary. Further investigation may discover an optimal
balance between these tradeoffs.

Another open research question is where speciﬁcally in
the network such proxies should be deployed. Previously,
“Routing around Decoys” [40] outlined several novel at-
tacks that a censor could perform in order to circumvent
many anticensorship deployment strategies. There is on-
going discussion in the literature about the practical costs
of these attacks, and practical countermeasures deploy-
ments could take to protect against them [11, 23].

As mentioned in Section 5, trafﬁc ﬁngerprinting is a
concern for all proxies, and remains an open problem.
Previous work has discussed these attacks as they apply
to ISP-located proxies [40] and other covert channel prox-
ies [18, 20]. Future work in this direction could provide
insight into how to generate or mimic network trafﬁc and
protocols.

Finally, there is room to explore more active defense
techniques, as outlined in Section 5. As end-to-middle
proxies become more prominent, this is likely to become
an important problem, as China has already started to
employ active attacks in order to detect and censor Tor
bridge relays [13, 46, 47]. Collaborating with ISPs will
allow us to explore the technical capabilities and poli-
cies that would permit active defense against these at-
tacks.

10 Related Work

Other anticensorship schemes
Besides end-to-
middle proxies, previous anticensorship approaches, in-
cluding Collage [10] and Message in a Bottle [24], have
leveraged using user-generated content on websites to
bootstrap communication between censored users and a
centrally-operated proxy. However, these designs are not
intended to work with low-latency applications such as
web browsing. SkypeMorph [30], FreeWave [22], Cen-
sorSpoofer [43] and StegoTorus [44] are proxies or proxy-
transports that attempt to mimic other protocols, such as
Skype, VoIP, or HTTP in order to avoid censorship by
trafﬁc ﬁngerprinting. However, recent work appears to
suggest that such mimicry may be detectable under certain
circumstances by an adversary [18, 20]. Finally, browser-
based proxies work by running a small ﬂash proxy inside
non-censored users browsers (for example, when they
visit a website), and serve as short-lived proxies for cen-

172  23rd USENIX Security Symposium 

USENIX Association

sored users [17]. These rapidly changing proxies can be
difﬁcult for a censor to block in practice, though it is
essentially a more fast-paced version of the traditional
censor cat-and-mouse game.

Other

Related steganographic techniques
tech-
niques [3, 6, 31] leverage pseudorandom public-key en-
cryption (i.e., encryption that produces ciphertext indistin-
guishable from random bits) in order to solve the classic
prisoners’ problem. These techniques allow protocol par-
ticipants to produce messages that mimic the distribution
of an “innocent-looking” communication channel. The
problem setting differs from ours, however, and the en-
coding of hidden messages inside an allowed encrypted
channel (as valid ciphertexts) is not considered.

Dyer et al. [16] introduce a related technique called
format transforming encryption (FTE), which disguises
encrypted application-layer trafﬁc to look like an inno-
cent, allowed protocol from the perspective of deep packet
inspection (DPI) technologies. The basic notion is to
transform ciphertexts to match an expected format; as
DPI technologies typically use membership in a regular
language to classify application-layer trafﬁc, FTE works
by using a (bijective) encoding function that maps a ci-
phertext to a member of a pre-speciﬁed language. This
steganographic technique differs signiﬁcantly from ours,
in that we do not attempt to disguise the use of a partic-
ular internet protocol itself (i.e., TLS), but rather ensure
that our encoded ciphertext does not alter the expected
distribution of the selected protocol trafﬁc (i.e., TLS ci-
phertexts, in our system design).

11 Conclusion

End-to-middle proxies are a promising concept that may
help tilt the balance of power from censors to citizens.
Although previous designs including Telex, Cirripede,
and Decoy Routing have laid the ground for this new
direction, there are several problems when it comes to
deploying any of these designs in practice. Previous de-
signs have required inline blocking elements and some-
times assumed symmetric network paths. To address
these concerns, we have developed TapDance, a novel
end-to-middle proxy that operates without the need for
inline ﬂow blocking. We also described a novel way to
support asymmetric ﬂows without inline-ﬂow blocking,
by encoding arbitrary-length steganographic payloads in
ciphertext. This covert channel may be independently
useful for future E2M schemes and other censorship re-
sistance applications.

Ultimately, anticensorship proxies are only useful if
they are actually deployed. We hope that removing these
barriers to end-to-middle proxying is a step towards that
goal.

Acknowledgments

The authors thank Joe Adams, Karl Fogel, Derek Hark-
ness, Steven Kent, Michael Milliken, David Robinson,
Steve Schultze, Bob Stovall, Stelios Valavanis, and James
Vasile for helpful discussions and encouragement. We
also thank Roger Dingledine and the anonymous review-
ers. Eric Wustrow conducted this research as an OpenITP
Scholar at the New America Foundation. This work was
supported in part by TerraSwarm, one of six centers of
STARnet, a Semiconductor Research Corporation pro-
gram sponsored by MARCO and DARPA. This material
is based upon work supported by the National Science
Foundation under Grant Nos. CNS-1255153 and CNS-
1345254 and by an NSF Graduate Research Fellowship.

References
[1] GoAgent open source project. https://code.google.com/p/goagent/.

[2] Ultrasurf. https://ultrasurf.us/.

[3] L. Ahn and N. J. Hopper. Public-key steganography. In EURO-
CRYPT 2004, volume 3027 of LNCS, pages 323–341. Springer
Berlin Heidelberg, 2004.

[4] R. J. Anderson and F. A. P. Petitcolas. On the limits of steganog-

raphy. IEEE J. Sel. A. Commun., 16(4):474–481, Sept. 2006.

[5] S. Aryan, H. Aryan, and J. A. Halderman. Internet censorship
in Iran: A ﬁrst look.
In 3rd USENIX Workshop on Free and
Open Communications on the Internet – FOCI ’13. USENIX
Association, 2013.

[6] M. Backes and C. Cachin. Public-key steganography with active
attacks. In Theory of Cryptography Conference – TCC ’05, volume
3378 of LNCS, pages 210–226. Springer Berlin Heidelberg, 2005.

[7] D. J. Bernstein. Curve25519: New Difﬁe-Hellman speed records.
In Public Key Cryptography – PKC 2006, volume 3958 of LNCS,
pages 207–228. Springer Berlin Heidelberg, 2006.

[8] D. J. Bernstein, M. Hamburg, A. Krasnova, and T. Lange. Elliga-
tor: Elliptic-curve points indistinguishable from uniform random
strings. In ACM Conference on Computer and Communications
Security – CCS 2013, pages 967–980. ACM, 2013.

[9] J. W. Bos, M. E. Kaihara, T. Kleinjung, A. K. Lenstra, and P. L.
Montgomery. Playstation 3 computing breaks 260 barrier 112-bit
prime ECDLP solved. http://lacal.epﬂ.ch/112bit_prime, 2009.

[10] S. Burnett, N. Feamster, and S. Vempala. Chipping away at
censorship ﬁrewalls with user-generated content. In 19th USENIX
Security Symposium, pages 463–468. USENIX Association, 2010.

[11] J. Cesareo, J. Karlin, J. Rexford, and M. Schapira. Optimizing the
placement of implicit proxies. http://www.cs.princeton.edu/~jrex/
papers/decoy-routing.pdf, June 2012.

[12] T. Dierks and E. Rescorla. The Transport Layer Security (TLS)
Protocol Version 1.2. RFC 5246 (Proposed Standard), Aug. 2008.
Updated by RFCs 5746, 5878, 6176.

[13] R. Dingledine, N. Mathewson, and P. Syverson. Tor: The second-
generation onion router. In 13th USENIX Security Symposium,
pages 21–21. USENIX Association, 2004.

[14] Z. Durumeric, J. Kasten, M. Bailey, and J. A. Halderman. Analysis
of the HTTPS certiﬁcate ecosystem. In Internet Measurement
Conference – IMC ’13, pages 291–304. ACM, 2013.

USENIX Association  

23rd USENIX Security Symposium  173

[15] Z. Durumeric, E. Wustrow, and J. A. Halderman. ZMap: Fast
Internet-wide scanning and its security applications.
In 22nd
USENIX Security Symposium, pages 605–619. USENIX Associa-
tion, Aug. 2013.

[16] K. P. Dyer, S. E. Coull, T. Ristenpart, and T. Shrimpton. Protocol
misidentiﬁcation made easy with format-transforming encryption.
In ACM Conference on Computer and Communications Security –
CCS 2013, pages 61–72. ACM, 2013.

[17] D. Fiﬁeld, N. Hardison, J. Ellithorpe, E. Stark, D. Boneh, R. Din-
gledine, and P. Porras. Evading censorship with browser-based
proxies. In Privacy Enhancing Technologies – PETS 2012, volume
7384 of LNCS, pages 239–258. Springer Berlin Heidelberg, 2012.
[18] J. Geddes, M. Schuchard, and N. Hopper. Cover your ACKs:
Pitfalls of covert channel censorship circumvention.
In ACM
Conference on Computer and Communications Security – CCS
2013, pages 361–372. ACM, 2013.

[19] T. G. Handel and M. T. Sandford, II. Hiding data in the OSI
network model. In Information Hiding – IH ’96, volume 1174 of
LNCS, pages 23–38. Springer Berlin Heidelberg, 1996.

[20] A. Houmansadr, C. Brubaker, and V. Shmatikov. The parrot is
dead: Observing unobservable network communications. In IEEE
Symposium on Security and Privacy – SP ’13, pages 65–79. IEEE,
2013.

[21] A. Houmansadr, G. T. K. Nguyen, M. Caesar, and N. Borisov.
Cirripede: Circumvention infrastructure using router redirection
with plausible deniability. In ACM Conference on Computer and
Communications Security – CCS 2011, pages 187–200. ACM,
2011.

[22] A. Houmansadr, T. Riedl, N. Borisov, and A. Singer.

I want
my voice to be heard: IP over Voice-over-IP for unobservable
censorship circumvention. In Network and Distributed System
Security Symposium – NDSS 2013. Internet Society, 2013.

[23] A. Houmansadr, E. L. Wong, and V. Shmatikov. No direction
home: The true cost of routing around decoys. In Network and
Distributed System Security Symposium – NDSS ’14. Internet
Society, 2014.

[24] L. Invernizzi, C. Kruegel, and G. Vigna. Message in a bottle:
Sailing past censorship. In 29th Annual Computer Security Appli-
cations Conference – ACSAC 2013, pages 39–48. ACM, 2013.

[25] J. Jia and P. Smith. Psiphon: Analysis and estimation. http://www.
cdf.toronto.edu/~csc494h/reports/2004-fall/psiphon_ae.html, Oct.
2004.

[26] J. Karlin, D. Ellard, A. W. Jackson, C. E. Jones, G. Lauer, D. P.
Mankins, and W. T. Strayer. Decoy routing: Toward unblockable
Internet communication. In USENIX Workshop on Free and Open
Communications on the Internet – FOCI ’11. USENIX Associa-
tion, 2011.

[27] J. Kasten, E. Wustrow, and J. A. Halderman. CAge: Taming
certiﬁcate authorities by inferring restricted scopes. In Financial
Cryptography and Data Security – FC 2013, volume 7859 of
LNCS, pages 329–337. Springer Berlin Heidelberg, 2013.

[28] A. Langley. TLS symmetric crypto. https://www.imperialviolet.

org/2014/02/27/tlssymmetriccrypto.html, Feb. 2014.

[29] N. Mathewson and N. Provos.

library. http://libevent.org/.

libevent: An event notiﬁcation

[30] H. Mohajeri Moghaddam, B. Li, M. Derakhshani, and I. Goldberg.
SkypeMorph: Protocol obfuscation for Tor bridges.
In ACM
Conference on Computer and Communications Security – CCS
2012, pages 97–108. ACM, 2012.

[31] B. Möller. A public-key encryption scheme with pseudo-random
ciphertexts. In Computer Security – ESORICS 2004, volume 3193
of LNCS, pages 335–351. Springer Berlin Heidelberg, 2004.

[32] S. J. Murdoch and S. Lewis. Embedding covert channels into
TCP/IP. In Information Hiding – IH ’05, volume 3727 of LNCS,
pages 247–261. Springer Berlin Heidelberg, 2005.

[33] ntop.org. PF_RING: High-speed packet capture, ﬁltering and

analysis. http://www.ntop.org/products/pf_ring/.

[34] V. Paxson. Bro: A system for detecting network intruders in

real-time. Computer Networks, 31(23–24):2435–2463, 1999.

[35] J. Postel. Transmission Control Protocol. RFC 793 (Internet
Standard), Sept. 1981. Updated by RFCs 1122, 3168, 6093, 6528.
[36] O. Project. OpenSSL: Cryptography and SSL/TLS toolkit. http://

www.openssl.org/.

[37] D. Robinson, H. Yu, and A. An. Collateral freedom: A
snapshot of Chinese Internet users circumventing censorship.
Open Internet Tools Project, Apr. 2013. https://openitp.org/pdfs/
CollateralFreedom.pdf.

[38] P. Rogaway. Evaluation of some blockcipher modes of opera-
tion. Technical report, Cryptography Research and Evaluation
Committees (CRYPTREC) for the Government of Japan, Feb.
2011.

[39] J. Salowey, A. Choudhury, and D. McGrew. AES Galois Counter
Mode (GCM) Cipher Suites for TLS. RFC 5288 (Proposed Stan-
dard), Aug. 2008.

[40] M. Schuchard, J. Geddes, C. Thompson, and N. Hopper. Routing
around decoys. In ACM Conference on Computer and Communi-
cations Security – CCS 2012, pages 85–96. ACM, 2012.

[41] G. J. Simmons. The prisoners’ problem and the subliminal channel.

In CRYPTO ’83, pages 51–67. Springer US, 1984.

[42] C. Soghoian and S. Stamm. Certiﬁed lies: Detecting and defeating
government interception attacks against SSL (short paper). In
Financial Cryptography and Data Security – FC 2011, volume
7035 of LNCS, pages 250–259. Springer Berlin Heidelberg, 2012.
[43] Q. Wang, X. Gong, G. T. K. Nguyen, A. Houmansadr, and
N. Borisov. CensorSpoofer: Asymmetric communication using
ip spooﬁng for censorship-resistant web browsing. In ACM Con-
ference on Computer and Communications Security – CCS 2012,
pages 121–132. ACM, 2012.

[44] Z. Weinberg, J. Wang, V. Yegneswaran, L. Briesemeister, S. Che-
ung, F. Wang, and D. Boneh. StegoTorus: A camouﬂage proxy
for the Tor anonymity system. In ACM Conference on Computer
and Communications Security – CCS 2012, pages 109–120. ACM,
2012.

[45] D. Wendlandt, D. G. Andersen, and A. Perrig. Perspectives: Im-
proving SSH-style host authentication with multi-path probing. In
USENIX Annual Technical Conference – ATC ’08, pages 321–334.
USENIX Association, 2008.

[46] T. Wilde. Great Firewall Tor probing. https://gist.github.com/

twilde/da3c7a9af01d74cd7de7, 2012.

[47] P. Winter and S. Linkdskog. How the Great Firewall of China
is blocking Tor. In 2nd USENIX Workshop on Free and Open
Communications on the Internet – FOCI ’12, 2012.

[48] J. Wolfgang, M. Dusi, and K. C. Claffy. Estimating routing symme-
try on single links by passive ﬂow measurements. pages 473–478.
ACM, 2010.

[49] E. Wustrow, S. Wolchok, I. Goldberg, and J. A. Halderman. Telex:
Anticensorship in the network infrastructure. In 20th USENIX
Security Symposium, pages 459–474. USENIX Association, Aug.
2011.

[50] X. Xu, Z. Mao, and J. Halderman. Internet censorship in China:
Where does the ﬁltering occur? In 12th Passive and Active Mea-
surement Conference – PAM 2011, volume 6579 of LNCS, pages
133–142, 2011.

174  23rd USENIX Security Symposium 

USENIX Association

