Verifying Curve25519 Software

Yu-Fang Chen1

yfc@iis.sinica.edu.tw

Peter Schwabe4

peter@cryptojedi.org

Chang-Hong Hsu2
hsuch@umich.edu
Ming-Hsien Tsai1

mhtsai208@gmail.com

Hsin-Hung Lin3

h-lin@ait.kyushu-u.ac.jp

Bow-Yaw Wang1

bywang@iis.sinica.edu.tw

Bo-Yin Yang1
by@crypto.tw

Shang-Yi Yang1

ilway25@crypto.tw

1Institute of Information Science, Academia Sinica, Taiwan

2University of Michigan, Ann Arbor, USA

3Faculty of Information Science and Electrical Engineering, Kyushu University, Japan

4Institute for Computing and Information Sciences, Radboud University Nijmegen, The Netherlands

ABSTRACT
This paper presents results on formal veriﬁcation of high-
speed cryptographic software. We consider speed-record-
setting hand-optimized assembly software for Curve25519
elliptic-curve key exchange presented by Bernstein et al. at
CHES 2011. Two versions for diﬀerent microarchitectures
are available. We successfully verify the core part of the
computation, and reproduce detection of a bug in a previ-
ously published edition. An SMT solver supporting array
and bit-vector theories is used to establish almost all prop-
erties. Remaining properties are veriﬁed in a proof assistant
with simple rewrite tactics. We also exploit the composi-
tionality of Hoare logic to address the scalability issue. Es-
sential diﬀerences between both versions of the software are
discussed from a formal-veriﬁcation perspective.

Keywords
Elliptic-curve cryptography, optimized assembly, Hoare logic,
SMT solver, Boolector, Coq.

1.

INTRODUCTION

Optimization of cryptographic primitives and protocols
for high performance in software is a very active ﬁeld of
research. Papers that report new speed records for, e.g.,
elliptic-curve cryptography are published at top cryptogra-
phy venues like Crypto, Eurocrypt, Asiacrypt or CHES. See,
for example, [12, 29, 33, 24].

One might expect that the software described in these pa-
pers is quickly included in cryptographic libraries so that
users beneﬁt from the speedups; however this is often not
the case. Sometimes the reason is that the software is not

Public domain. This work was supported by the Ministry of Science and Technol-
ogy (MOST), Taiwan, through projects no 102-2221-E-001-017/018, and 103-2221-
E-001-019/020-MY3; by the Netherlands Organisation for Scientiﬁc Research (NWO)
through Veni 2013 project 13114; and by Academia Sinica, through the IIS Spe-
cialty Project and BY’s Career Advancement Award. Part of this work was done
while Schwabe was employed by Academia Sinica. Permanent ID of this document:
55ab8668ce87d857c02a5b2d56d7da38. Date: August 24, 2014.
CCS’14, November 3–7, 2014, Scottsdale, Arizona, USA.
ACM 978-1-4503-2957-6/14/11. http://dx.doi.org/10.1145/2660267.2660370.

(freely) available or that the primitive is incompatible with
existing cryptographic infrastructure. However,
in other
cases the reason is simply that we do not know whether the
software is correct. For example, the designers of the Net-
working and Cryptography library (NaCl) [18] announced
in 2011 that they would include Ed25519 signatures [13] in
NaCl. This has not happened until today; the reason is given
in [17]: “Auditing the NaCl source is a time-consuming job.”
All of the papers listed above that report speed records
for elliptic-curve cryptography rely on large portions of in-
line hand-optimized assembly code to achieve the speeds.
For example, the Ed25519 signature software consists of 4
diﬀerent implementations that together have 5521 lines of C
code and 16184 lines of qhasm code. The two speed-record-
setting Curve25519 [11] elliptic-curve Diﬃe-Hellman imple-
mentations, which were also presented in [13], consist of 342
lines of C and 4064 lines of qhasm code. The qhasm pro-
gramming language is a high-level assembler introduced by
Bernstein [9]. What is particularly interesting about this
Ed25519 and Curve25519 software from a correctness per-
spective is not only that it is waiting for inclusion in a widely
used cryptographic library but also that the software ini-
tially had a bug which is not found by extensive testing1.

In principle, there are three diﬀerent approaches to ensure

the correctness of software:

Testing: Every serious cryptographic library includes ex-
tensive test batteries. Software testing has many ad-
vantages:
it is relatively cheap, it does not conﬂict
with software performance, and it is able to catch a
large amount of bugs. The last aspect is ampliﬁed by
the nature of many cryptographic algorithms, which
require that each input bit inﬂuences each output bit
and typically also most intermediate values. For ex-
ample it is very hard to imagine AES software which
is correct for almost all inputs but fails in some rare
cases.

However, some bugs are naturally much harder to test
for. One such example is carries (borrows) in mod-
ern elliptic curve cryptography that often requires big

1This bug is documented, see http://cryptojedi.org/
crypto/#ed25519

299integer arithmetic modulo something very close to a
power of two. Thus, often one side in a conditional
statement would be extremely rare when considered as
a statistical event. The bug reported for the Ed25519
and Curve25519 software from [13] falls into this cat-
egory. Also the bug in the OpenSSL elliptic-curve
Diﬃe-Hellman implementation, which was exploited
in [22], falls into this category.

Auditing: One way to ﬁnd bugs that are not found by
testing are code audits. Such audits by experts are a
widely accepted means to ensure correctness and gen-
erally quality of software, but they come at a relatively
high cost. For example, a community eﬀort collected
more than US$50,000 for a now ongoing audit of True-
Crypt [37]. The cost for a full audit of OpenSSL has
recently been estimated to be US$250, 000 [34].

Another disadvantage of software auditing is a con-
ﬂict with performance. Software that is relatively easy
(and thus cheap) to audit is concise, has small amounts
of code, and is naturally portable. High-speed crypto-
graphic software is written in assembly with optimiza-
tions for multiple architectures and micro-architectures.
The core development team of NaCl, together with
Janssen, recently released TweetNaCl, a re-implemen-
tation of NaCl which is optimized for conciseness and
audit-ability [17]. The authors state that TweetNaCl
“allows correct functionality to be veriﬁed by human
auditors with reasonable eﬀort”. However, Curve25519
in TweetNaCl takes 2.5 million cycles on an Intel Ivy
Bridge processor – more than 10 times more than the
assembly implementation presented in [13].

Veriﬁcation: The third direction to ensure correctness of
(cryptographic) software is formal veriﬁcation; this di-
rection oﬀers the the strongest guarantees for the cor-
rectness of software. There are two major streams of
formal veriﬁcation approaches, namely model check-
ing and theorem proving. In the model checking ap-
proach, an abstract model is ﬁrst built for a program
and then automatically and exhaustively explored to
see if there is a counterexample of a property. In the
theorem-proving approach, a program and its proper-
ties have to be ﬁrst formalized in the meta-logic of a
proof assistant and then the proof of the properties are
manually deduced within the proof assistant. Theorem
proving requires more manual work, but it is capable
of proving harder properties.

The current state of the art in formal veriﬁcation is
far away from being able to verify a complete cryp-
tographic library, which is optimized for speed. From
a cryptographic-engineering perspective it is obvious
that veriﬁcation should prioritize those portions of code
that are expensive to audit and that may contain bugs
which are not revealed by testing. The formal veriﬁ-
cation of precisely this kind of code is the content of
this paper.

Contributions of this paper. We describe the formal
veriﬁcation of the central hand-optimized assembly routine
of each of the two implementations of Curve25519 Diﬃe-
Hellman key-exchange software presented in [13]. This soft-
ware is still today the speed-record holder for Curve25519;

see [15]. To the best of our knowledge, our work is the ﬁrst
to formally verify an inline hand-optimized assembly imple-
mentation of a real-world cryptographic protocol.

The correctness of the mathematical formulas in the com-
putation of Curve25519 Diﬃe-Hellman key exchange is en-
sured by Sage veriﬁcation scripts in [16]2. So we assume
that those formulas are correct and verify that the low-level
implementation correctly implements the formulas. Our ver-
iﬁcation shows that the core routine of one of the two im-
plementations was indeed correct right from the beginning,
reproduces detection of the bug in the other and shows that
the bug-ﬁxed version of that software is also correct.

We also present a hybrid methodology that integrates
compositional reasoning, SMT (Satisﬁability Modulo The-
ories) solvers, and proof assistants. A language is intro-
duced for annotating qhasm code with preconditions on in-
puts and postconditions on intermediate values and outputs.
With the annotations, the compositional reasoning in Hoare
logic [28] allows us to boil down the veriﬁcation of a large
program to the veriﬁcation of smaller programs. We then
automatically translate this annotated qhasm code to sev-
eral SMT formulas and use an SMT solver to prove that the
code matches the conditions speciﬁed in the annotations. To
achieve better veriﬁability, we develop heuristics to help the
SMT solver. For a small set of algebraic properties such as
modular congruence that are hard for SMT solvers, we rely
on proof assistants.

Related work. Cryptographic software forms the back-
bone of information security and it is thus widely accepted
that correctness of such software is important enough to jus-
tify formal veriﬁcation eﬀorts.

One approach is to re-implement cryptographic protocols
in languages and frameworks that allow eﬃcient veriﬁca-
tion. The most extensive work in this area is miTLS, a
“veriﬁed reference implementation of the TLS protocol” [20,
21]. This implementation of TLS is written in F# and spec-
iﬁed in F7 – the clear focus is on a veriﬁable (and veri-
ﬁed) re-implementation; not on verifying existing high-speed
cryptographic software. Note that miTLS relies on (unveri-
ﬁed) “cryptographic providers such as .NET or Bouncy Cas-
tle” for core cryptographic primitives. Also the CryptVer
project [26] aims at re-implementing cryptography such that
it can be formally veriﬁed. Their approach is to specify cryp-
tographic algorithms in higher-order logic and then imple-
ment them by formal deductive compilation.

Another approach to formally veriﬁed cryptographic soft-
ware are special-domain compilers. A recent example of this
is [4], where Almeida et al. introduce security-aware compi-
lation of a subset of the C programming language.

The theory of elliptic curve has been formalized in [36,
7]. In principle, the mathematical formulas in Curve25519
Diﬃe-Hellman key-exchange can be veriﬁed with the for-
malization. Low-level machine codes have been formalized
in proof assistants [1, 3, 2, 32]. Large-integer arithmetic
and cryptographic functions can be formally veriﬁed semi-
automatically. Our approach is very lightweight. Most of
the veriﬁcation is performed by an SMT solver automati-
cally. It hence requires much less human intervention.

the

2Speciﬁcally,
http://www.hyperelliptic.
org/EFD/g1p/auto-sage/montgom/coordinates.sage and
http://www.hyperelliptic.org/EFD/g1p/auto-sage/
montgom/xz/ladder/mladd-1987-m.sage

scripts

300Cryptographic software must be more than correct,

it
must avoid leaks of secret information through side chan-
nels. For example, if the execution time of cryptographic
software depends on secret data, this can be exploited by
an attacker in a so-called timing attack. As a consequence,
countermeasures against side-channel attacks have also been
formalized. For example, Bayrak et al. [8] use SAT solving
for the automated veriﬁcation of power-analysis countermea-
sures. Molnar et al. [30] describe a tool for static analysis of
control-ﬂow vulnerabilities and their automatic removal.

Availability of software. To maximize reusability of our
results we placed the tools and software presented in this
paper into the public domain. They are available at http:
//cryptojedi.org/crypto/#verify25519.

Organization of this paper. Section 2 gives the necessary
background on Curve25519 elliptic-curve Diﬃe-Hellman key
exchange. Section 3 reviews the two diﬀerent approaches for
assembly implementations of arithmetic in the ﬁeld F
2255−19
used in [13]. Section 4 gives the necessary background on
veriﬁcation techniques and describes the tools we use for
veriﬁcation. Section 5 details our methodology. Section 6
presents and discusses our results. We conclude the paper
and point to future work in Section 7.

2. CURVE25519

To establish context, we brieﬂy review the basics of elliptic-
curve cryptography. For more information see, for exam-
ple, [6, 27]. Let Fq be the ﬁnite ﬁeld with q elements. For
coeﬃcients a1, a2, a3, a4, a6 ∈ Fq, an equation of the form

E : y2 + a1xy + a3y = x3 + a2x2 + a4x + a6

deﬁnes an elliptic curve E over Fq (if certain conditions hold,
cf. [27], Chapter 3). The set of points (x, y) ∈ Fq × Fq that
fulﬁll the equation E, together with a “point at inﬁnity”,
form a group of size (cid:96) ≈ q, which is usually written ad-
ditively. Addition under this group law is eﬃciently com-
putable through a few operations in the ﬁeld Fq. Given a
point P on the curve and a scalar k ∈ Z it is easy to do a
scalar multiplication k · P ; the number of group additions
required for a such a scalar multiplication is linear in the
length of k (i.e., logarithmic in k).

In contrast, for a suﬃciently large ﬁnite ﬁeld Fq, a suit-
ably chosen curve, and random points P and Q, computing
the discrete logarithm logP Q, i.e., ﬁnding k ∈ Z such that
Q = k · P , is hard. More speciﬁcally, for elliptic curves
√
used in cryptography, the best known algorithms takes time
(cid:96)). Elliptic-curve cryptography is based on this diﬀer-
Θ(
ence in the complexity for computing scalar multiplication
and computing discrete logarithms. A user who knows a
secret k and a system parameter P computes and publishes
Q = k · P . An attacker who wants to break security of the
scheme needs to obtain k, i.e., compute logP Q.

Curve25519 is an elliptic-curve Diﬃe-Hellman key exchange

protocol proposed by Bernstein in 2006 [11]. It is based on
arithmetic on the elliptic curve E : y2 = x3 + 486662x2 + x
deﬁned over the ﬁeld F
2.1 The Montgomery ladder

2255−19.

Curve25519 uses a so-called diﬀerential-addition chain pro-
posed by Montgomery [31] to multiply a point, identiﬁed
only by its x-coordinate, by a scalar. This computation

is highly regular, performs one ladder step per scalar bit,
and is relatively easy to protect against timing attacks; the
whole loop is often called Montgomery ladder. An overview
of the structure of the Montgomery ladder and the oper-
ations involved in one ladder-step are given respectively in
Algs. 1 and 2. The inputs and outputs xP , X1, X2, Z2, X3, Z3,
and temporary values Ti are elements in F
2255−19. The per-
formance of the computation is largely determined by the
performance of arithmetic operations in this ﬁeld.

Algorithm 1 Curve25519 Montgomery Ladder
Input: scalar k, and x-coordinate xP of a point P on E.
Output: (XkP , ZkP ) fulﬁlling xkP = XkP /ZkP

t = (cid:100)log2 k + 1(cid:101)
X1 = xP ; X2 = 1; Z2 = 0; X3 = xP ; Z3 = 1
for i ← t − 1 downto 0 do

if bit i of k is 1 then

(X3, Z3, X2, Z2) ← ladderstep(X1, X3, Z3, X2, Z2)
(X2, Z2, X3, Z3) ← ladderstep(X1, X2, Z2, X3, Z3)

else

end if

end for
return (X2, Z2)

Algorithm 2 Single Curve25519 Montgomery Ladderstep

function ladderstep(X1, X2, Z2, X3, Z3)

1

2

T1 ← X2 + Z2
T2 ← X2 − Z2
T7 ← T 2
T6 ← T 2
T5 ← T6 − T7
T3 ← X3 + Z3
T4 ← X3 − Z3
T9 ← T3 · T2
T8 ← T4 · T1
X3 ← (T8 + T9)
Z3 ← (T8 − T9)

3

3

X3 ← X 2
Z3 ← Z 2
Z3 ← Z3 · X1
X2 ← T6 · T7
Z2 ← 121666 · T5
Z2 ← Z2 + T7
Z2 ← Z2 · T5
return (X2, Z2, X3, Z3)

end function

The biggest diﬀerence between the two Curve25519 im-
plementations of Bernstein et al. presented in [13, 14] is
the representation of elements of F
2255−19. Both implemen-
tations have the core part, the Montgomery ladder step, in
fully inlined, hand-optimized assembly. These core parts are
what we target for veriﬁcation in this paper.

3. ARITHMETIC IN F2255−19 FOR AMD64

Arithmetic in F

2255−19 means addition, subtraction, mul-
tiplication and squaring of 255-bit integers modulo the prime
p = 2255 − 19. No mainstream computer architecture oﬀers
arithmetic instructions for 255-bit integers directly, so op-
erations on such large integers must be constructed from
instructions that work on smaller data types. The AMD64
architecture has instructions to add and subtract (with and
without carry/borrow) 64-bit integers, and the MUL instruc-
tion returns the 128-bit product of two 64-bit integers, al-
ways in general-purpose registers rdx (higher half) and rax
(lower half).

3013(cid:88)

Section 3 of [13] describes two diﬀerent approaches to
implement Fp arithmetic in AMD64 assembly. Both ap-
proaches use the 64-bit-integer machine instructions. They
are diﬀerent in the representation of elements of Fp, i.e.,
they decompose the 255-bit ﬁeld elements into smaller pieces
which ﬁt into 64-bit registers in diﬀerent ways. We now re-
view these approaches and highlight the diﬀerences that are
most relevant to veriﬁcation.
3.1 Arithmetic in radix-264 representation

The obvious representation of an element X ∈ Fp (or any
256-bit number) with 64 bit integers is radix 264. A 256-
bit integer X is represented by 4 64-bit unsigned integers
(x0, x1, x2, x3), where the limbs xi ∈ {0, . . . , 264 − 1} and

X =

xi264i = x0 + 264x1 + 2128x2 + 2192x3.

i=0

We will focus our description on the most complex Fp op-
eration in the Montgomery ladder step, which is multiplica-
tion. Squaring is like multiplying, except that some partial
results are known to be the same and computed only once.
Addition and subtraction are straight forward and multipli-
cation by a small constant simply foregoes computation of
results known to be zero. Multiplication in Fp consists of
two steps: multiplication of two 256-bit integers to produce
a 512-bit intermediate result S, and reduction modulo 2p to
obtain a 256-bit result R. Note that the software does not
perform a full reduction modulo p, but only requires that
the result ﬁts into 256 bits. Only the very ﬁnal result of the
Curve25519 computation has to be fully reduced modulo
2255 − 19.
Multiplication of 256-bit integers. The approach for
multiplication in radix-264 chosen by [13] is a simple school-
book approach. Multiplication of two 256-bit integers X and
Y can be seen as a 4-step computation which in each step
involves one limb of Y and all limbs of X as follows:

A0 = Xy0,
A1 = 264Xy1 + A0,
A2 = 2128Xy2 + A1,
S = A3 = 2192Xy3 + A2.

(1)

Each step essentially computes and accumulates the 5-
limb partial product Xyi with 4 64 × 64-bit multiplications
and several additions as (x0yi+264x1yi+2128x2yi+2192x3yi).
Note that “multiplications by 264” are free and only deter-
mine where to add when summing 128-bit products. For
example, the result of x0yi is in two 64-bit registers t0 and
t1 with x0yi = 264t0 + t1, therefore t1 needs to be added
to the lower result register of x1yi which in turn produces a
carry bit which must go into the register holding the higher
half of x1yi. Instructions adding Ai−1 into Ai also produce
carry bits that need to be propagated through the higher
limbs.

Handling the carry bits, which occur inside the radix-264
multiplication, incurs signiﬁcant performance penalties on
some microarchitectures as detailed in [13]. Sec. 6 will ex-
plain why integrated multiplication and handling of carry
bits also constitutes a major obstacle for formal veriﬁcation.

Modular reduction. The multiplication of the two 256-

4(cid:88)

bit integers X and Y produced a 512-bit result in S =
(s0, . . . , s7). As 2256 = 2p + 38, the [13] code repeatedly
reduces modulo 2p to ﬁt the result into 256 bits. The reduc-
tion begins by computing

S(cid:48) =

(s0 + 264s1 + 2128s2 + 2192s3)+

38(s4 + 264s5 + 2128s6 + 2192s7)

with a 5-limb result S(cid:48) = (s(cid:48)
2256s(cid:48)
bits. A subsequent step computes

4). Note that s(cid:48)

0 + 264s(cid:48)

1 + 2128s(cid:48)

3 +
4, the highest limb of S(cid:48), has at most 6

2 + 2192s(cid:48)

(cid:48)(cid:48)

S

= (s

(cid:48)
0 + 264s

(cid:48)
1 + 2128s

(cid:48)
2 + 2192s

(cid:48)
(cid:48)
3) + 38s
4.

The value S(cid:48)(cid:48) = (s(cid:48)(cid:48)
0 + 264s(cid:48)(cid:48)
still have 257 bits, i.e., s(cid:48)(cid:48)
4-limb result R is obtained as

1 + 2128s(cid:48)(cid:48)
4 ) may
4 is either zero or one. The ﬁnal

2 + 2192s(cid:48)(cid:48)

3 + 2256s(cid:48)(cid:48)

(cid:48)(cid:48)
0 + 264s
R = (s

(cid:48)(cid:48)
1 + 2128s

(cid:48)(cid:48)
(cid:48)(cid:48)
(cid:48)(cid:48)
2 + 2192s
3 ) + 38s
4 .

3.2 Arithmetic in radix-251 representation
Due to the performance penalties in handling carries, [13]
proposes to represent elements of Fp in radix 251, i.e., X ∈
Fp is represented by 5 limbs (x0, . . . , x4) as

X =

xi251i = x0 + 251x1 + 2102x2 + 2153x3 + 2204x4.

i=0

Every element of Fp can be represented with all xi ∈
[0, 251 − 1]; however, inputs, outputs, and intermediate re-
sults inside the ladder step have relaxed limb-size restric-
tions. For example, inputs and outputs of the ladder step
have limbs in [0, 251 + 215]. For the inputs to the ﬁrst it-
eration this is ensured by C code which is not part of the
veriﬁcation, but which has been extensively tested. The
inputs of all other iterations are outputs of the previous it-
eration, so we verify that this property holds for outputs of
the ladder step. Additions are done limbwise, e.g., after the
ﬁrst operation T1 ← X2 + Z2, the limbs of T1 have at most
53 bits. Subtractions are done by ﬁrst adding a multiple of
p guaranteed to exceed the subtrahend limbwise. For exam-
ple, all limbs of the inputs of the subtraction T2 ← X2 − Z2
are in [0, 251 + 215] (see above). Subtraction is performed by
ﬁrst adding 0xFFFFFFFFFFFDA to the lowest limb of X2 and
0xFFFFFFFFFFFFE to the four higher limbs of X2, and then
subtracting corresponding limbs of Z2. The value added is
2p, which does not change the result (as element of Fp), yet
ensures that all limbs of the result T2 are positive and have
at most 53 bits.

The most complex operation—multiplication—is split in
two parts, but these now diﬀer from those of Sec. 3.1. The
ﬁrst step performs multiplication and modular reduction;
the second step performs the delayed carries.

Multiply-and-Reduce. To multiply X = x0 + 251x1 +
2102x2 + 2153x3 + 2204x4 and Y = y0 + 251y1 + 2102y2 +
2153y3 + 2204y4, start by precomputing 19y1, 19y2, 19y3 and
19y4, then compute 5 intermediate values t0, . . . , t4, where
each ti =
is a pair of 64-bit

i + 264 t(h)

:= t(l)

, t(h)

(cid:16)

(cid:17)

i

t(l)
i

i

302registers, with

t0 := x0y0 + x1(19y4) + x2(19y3) + x3(19y2) + x4(19y1),
t1 := x0y1 + x1y0 + x2(19y4) + x3(19y3) + x4(19y2),
t2 := x0y2 + x1y1 + x2y0 + x3(19y4) + x4(19y3),
t3 := x0y3 + x1y2 + x2y1 + x3y0 + x4(19y4),
t4 := x0y4 + x1y3 + x2y2 + x3y1 + x4y0.

(2)

All partial results in this computation are signiﬁcantly smaller
than 128 bits. For example, when 0 ≤ xi, yi < 254 (input
limbs are at most 54-bits), 0 ≤ t0, t1, t2, t3, 19t4 < 95· 2108 <
2115. Accumulation of each multiplication result can thus be
achieved by two 64-bit adds (one ADD, one ADC carry) where
all carries are absorbed in the “free” bits in each t(h)

Now X · Y = T = t0 + 251t1 + 2102t2 + 2153t3 + 2204t4, but
the two-register values ti are still much too large to be used
in subsequent operations and need to be carried.

.

i

i

Delayed carry. Carrying from the 2-register value ti to
ti+1 is done as follows: Shift t(h)
to the left by 13 and shift
the 13 high bits of t(l)
into the 13 low bits of the result
i
(which is achieved in just one SHLD instruction). Now set
to zero (logical AND with 251 − 1).
the high 13 bits of t(l)
i
Now do the same shift-by-13 operation on t(h)
i+1 and t(l)
i+1, set
the high 13 bits of t(l)
to t(l)
i+1 and discard
t(h)
. This carry chain is performed from t0 through t4; then
i
t(h)
is multiplied by 19 (using a single-word MUL) and added
4
to t(l)
0 .

i+1 to zero, add t(h)

1 , t(h)
Note: To avoid losing bits in the shift-by-13, t(h)
2 ,
3 , and 19t(h)
t(h)
(note the the multiply by 19 at the end) must
all be at most 51 bits (that is, < 251) before that carrying
begins. This condition is met, guaranteeing no overﬂows, if
limbs of X and Y are at most 54 bits as noted above.

0 , t(h)

4

i

This ﬁrst step of carrying yields XY = t(l)
4 , but the values in t(l)

2102t(l)
too big as subsequent operands.

2 + 2153t(l)

3 + 2204t(l)

0 + 251t(l)
1 +
i may still be

The second round of carries starts by copying t(l)
0
register t, shifts t to the right by 51, adds t to t(l)
1
discards the upper 13 bits of t(l)
way from t(l)
1
t(l)
4 . Finally t(l)
4
is added to t(l)
0 . The ﬁnal result is thus obtained in

to a
and
0 . Carrying continues this
to t(l)
2 , from t(l)
to
is reduced in the same way except that 19t

3 , and from from t(l)

to t(l)

2

3

R = (t(l)

0 + 251t(l)

1 + 2102t(l)

2 + 2153t(l)

3 + 2204t(l)

4 ).

4. BACKGROUND

Recall that in our approach, a qhasm program annotated
with input assumptions and expected properties is split into
smaller programs with their own input assumptions and re-
quired properties. Such splits are based on compositional
reasoning in Hoare logic with the help of midconditions.
These smaller annotated qhasm programs are then translated
to SMT formulas and veriﬁed by the SMT solver Boolec-
tor. For algebraic properties such as modular congruence
that are hard for SMT solvers, we rely on the proof assistant
Coq. In the following of this section, we describe some back-
ground about qhasm, Hoare logic, Boolector, and Coq.

4.1 Portable assembly: qhasm

The software we are verifying has not been written directly
in AMD64 assembly, but in the portable assembly language
qhasm developed by Bernstein [9]. The aim of qhasm is to
reduce development time of assembly software by oﬀering a
uniﬁed syntax across diﬀerent architectures and by assisting
the assembly programmer with register allocation. Most im-
portantly for us, one line in qhasm translates to exactly one
assembly instruction. Also, qhasm guarantees that “register
variables” are indeed kept in registers. Spilling to memory
has to be done explicitly by the programmer.

Verifying qhasm code. The Curve25519 software we veri-
ﬁed is publicly available as part of the SUPERCOP bench-
marking framework [10], but does not include the qhasm
source ﬁles, which we obtained from the authors. Our veri-
ﬁcation works on qhasm level. The obvious disadvantage is
that we rely on the correctness of qhasm translation. The
advantage of this approach is that we can easily adapt our
approach to assembly software for other architectures. In the
future, we plan to also formally verify the qhasm to assembly
translation to provide stronger correctness guarantees.
4.2 Hoare Logic

Hoare logic [28] is a system for proving the correctness of
imperative sequential programs. It contains axioms and in-
ference rules used to establish a valid Hoare triple (|P|) C (|Q|)
where P and Q are formulas in predicate logic and C is a pro-
gram. The Hoare triple (|P|) C (|Q|) is valid iﬀ the program
C ends in a state satisfying Q provided that C starts in a
state satisfying P . The formula P and Q are called pre- and
postconditions respectively. For example, a program C that
increments the value of a variable x by 1 can be speciﬁed
by the Hoare triple (|x = a|) C (|x = a + 1|) where a is a log-
ical variable that captures the value of x before C. Logical
variables must not appear in programs and are used only
for reasoning. We write |= (|P|) C (|Q|) if the Hoare triple
(|P|) C (|Q|) is valid and write (cid:96) (|P|) C (|Q|) if the Hoare triple
is proven in Hoare logic. The axioms and inference rules of
Hoare logic guarantee that |= (|P|) C (|Q|) iﬀ (cid:96) (|P|) C (|Q|).
Among the inference rules of Hoare logic, there is a rule

called Composition:

(cid:96) (|P|) C0 (|R|) (cid:96) (|R|) C1 (|Q|)

(cid:96) (|P|) C0; C1 (|Q|)

Composition

With the rule Composition, to prove (cid:96) (|P|) C0; C1 (|Q|), it
suﬃces to prove both (cid:96) (|P|) C0 (|R|) and (cid:96) (|R|) C1 (|Q|) where
R is a midcondition. Sometimes we may not just ﬁnd a
single midcondition in the middle. In this case, we can use
the following relaxed version of Composition:
(cid:96) (|P|) C0 (|R|) R → S (cid:96) (|S|) C1 (|Q|)

(cid:96) (|P|) C0; C1 (|Q|)

RelaxedComposition

In rule RelaxedComposition, R → S is a logic implication.
4.3 The Boolector SMT solver

Boolector is an eﬃcient SMT solver supporting the the-
ories of bit vectors and arrays [23]. To be brief, an instance
of the SMT problem can be viewed as an instance of the
Boolean satisﬁability (SAT) problem where a Boolean vari-
able corresponds to a predicate from some background the-
ory. For example, f (x, y) = g(z) ∧ z = x + y is an SMT
formula where f (x, y) = g(z) is a predicate from the theory
of equality and uninterpreted functions while z = x + y is

303a predicate from the theory of integers. This SMT formula
can be viewed as a Boolean formula a∧ b where (1) a is true
iﬀ f (x, y) = g(z) holds and (2) b is true iﬀ z = x + y holds.
In cryptographic software, arithmetic in large ﬁnite ﬁelds
requires hundreds of signiﬁcant bits. Standard algorithms
for linear (integer) arithmetic do not apply. Boolector re-
duces queries to instances of the SAT problem by bit blasting
and is hence more suitable for our purposes.

Theory of arrays is also essential to the formalization of
qhasm programs. In low-level programming languages such
as qhasm, memory and pointers are indispensable. We use
theory of arrays to model memory in Boolector. Each
qhasm program is of ﬁnite length. Sizes of program vari-
ables (including pointers) must be declared. Subsequently,
each variable is of ﬁnite domain and, more importantly, the
memory is ﬁnite. Since formal models of qhasm programs
are necessarily ﬁnite, they are expressible in theories of bit
vectors and arrays. Boolector therefore ﬁts perfectly in
this application.
4.4 The Coq proof assistant

The Coq proof assistant has been developed in INRIA for
more than twenty years [19]. The tool is based on a higher-
order logic called the Calculus of Inductive Construction
and has lots of libraries for various theories. Theorems are
proven with the help of Coq tactics. In contrast to model-
theoretic tools such as Boolector, proof assistants are op-
timized for symbolic reasoning. For instance, the algebraic
equation (x + y)2 = x2 + 2xy + y2 can be veriﬁed by the
Coq tactic ring instantaneously.
In this work, we use the Coq standard library ZArith
to formalize the congruence relation modulo 2255 − 19. For
non-linear modular relations in F
2255−19, Boolector may
fail to verify in a handful of cases. We verify them with our
formalization and simple rewrite tactics in Coq.

5. METHODOLOGY

We aim to verify the Montgomery ladder step of the record-
holding implementation of Curve25519 in [13, 14]. A ladder
step (Alg. 2) consists of 18 ﬁeld arithmetic operations. Con-
sidering the complexity of Fp multiplication (Sec. 3), the
correctness of manually optimized qhasm implementation for
the Montgomery ladder step is by no mean clear. The algo-
rithm itself is just a linearization of projective addition. The
implementation however changes the order of instructions
for eﬃciency and no longer a linearization of mathematical
operations. The correctness of the qhasm implementation is
not clear as illustrated by the early incorrect version, which
passed extensive tests.

Due to space limit, we only detail the veriﬁcation of Fp
multiplication. Other ﬁeld arithmetic and the Montgomery
ladder step (Alg. 2) itself are handled similarly.

We will use Hoare triples to specify properties about qhasm
implementations. We only use quantiﬁer-free pre- and post-
conditions. The typewriter and Fraktur fonts are used to
denote program and logical variables respectively in pre- and
postconditions.

Let P be a qhasm implementation for Fp multiplication.
Note that P is loop-free. When the pre- and postcondi-
tions are quantiﬁer-free, it is straightforward to translate
a Hoare triple (|Q|) P (|Q(cid:48)|) to a Boolector speciﬁcation.
This speciﬁcation is equivalent to the quantiﬁer-free SMT
formula R ∧ PSSA ∧ ¬R(cid:48) where PSSA is the qhasm fragment

P in static single assignment form [5, 35], and R and R(cid:48) are
respectively Q and Q(cid:48) with program variables replaced by
their indexed version. For example, (|r = 0|) r+=19∗x; r+=19∗
y (|r = 19x + 19y|) is translated to r0 = 0 ∧ r1 = r0 + 19x0 ∧
r2 = r1 + 19y0 ∧ r2 (cid:54)= 19x0 + 19y0. We then check whether
the quantiﬁer-free formula in the theory of bit-vectors is sat-
isﬁable. If not, we establish |= (|Q|) P (|Q(cid:48)|). In order to au-
tomate this process, we deﬁne a simple assertion language
to specify pre- and postconditions in qhasm. Moreover, we
build a converter that translates annotated qhasm fragments
into Boolector speciﬁcations.
5.1

Fp multiplication in radix-264

Let P 64 denote the qhasm program for Fp multiplication
in the radix-264 representation. The inputs X = x0+264x1+
2128x2 + 2192x3 and Y = y0 + 264y1 + 2128y2 + 2192y3 are
stored in memory pointed to by the qhasm variables xp and
yp respectively. qhasm uses a C-like syntax. Pointer deref-
erences, pointer arithmetic, and type coercion are allowed
in qhasm expressions. Thus, the limbs xi and yi corre-
spond to the qhasm expressions *(uint64 *)(xp + 8i) and
*(uint64 *)(yp + 8i) respectively for every i ∈ [0, 3]. We
introduce logical variables xi and yi to record the limbs xi
and yi respectively. Consider

Q64xy eqns

:=

64= *(uint64 *)(xp + 8i)∧

xi

yi

64= *(uint64 *)(yp + 8i).

3(cid:86)
3(cid:86)

i=0

i=0

The operator n= denotes the n-bit equality in the theory of
bit-vectors. The formula Q64xy eqns states that the values of
the logical variables xi and yi are equal to the limbs xi and
yi of the initial inputs respectively.

In P 64, the outcome is stored in memory pointed to by
the qhasm variable rp. That is, the limb ri of R = r0 +
264r1 + 2128r2 + 2192r3 corresponds to the qhasm expressions
*(uint64 *)(rp + 8i) for every i ∈ [0, 3]. Deﬁne

3(cid:86)
3(cid:80)

i=0

Q64r eqns :=

Q64prod := (

ri
xi264i) × (

3(cid:80)

64= *(uint64 *)(rp + 8i),

512≡ 3(cid:80)

yi264i)

ri264i

(mod p).

i=0

i=0

i=0

n≡ denotes the n-bit signed modulo operator
The operator
in the bit-vector theory and the operation × is an exact
product (without any truncation). The formula Q64r eqns
introduces the logical variable ri equal to the limb ri for
0 ≤ i ≤ 3. The formula Q64prod speciﬁes that the outcome
R is indeed the product of X and Y in ﬁeld arithmetic.

Consider the top-level Hoare triple

(|Q64xy eqns|) P 64 (|Q64r eqns ∧ Q64prod|) .

We are concerned about the outcomes of the qhasm fragment
P 64 from states where logical variables xi and yi are equal to
limbs of the inputs pointed to by the program variables xp
and yp respectively. During the execution of the qhasm pro-
gram P 64, program variables may change their values. Log-
ical variables, on the other hand, remain unchanged. The
logical variables xi, yi in the precondition Q64xy eqns eﬀec-
tively memorize the input limbs before the execution of P 64.
The postcondition Q64r eqns ∧ Q64prod furthermore speciﬁes
that the outcome pointed to by the program variable rp is
the product of the inputs stored in xi and yi. In other words,

3047(cid:86)

the top-level Hoare triple speciﬁes that the qhasm fragment
P 64 is Fp multiplication in the radix-264 representation.

The top-level Hoare triple contains complicated arithmetic
operations over hundreds of 64-bit vectors. It is perhaps not
unexpected that naive veriﬁcation fails. In order to verify
the qhasm implementation of Fp multiplication, we exploit
the compositionality of proofs for sequential programs. Ap-
plying the rule Composition, it suﬃces to ﬁnd a midcondi-
tion for the top-level Hoare triple. Recall that Fp multipli-
cation can be divided into two phases: multiply and reduce
(Sec. 3.1). It is but natural to verify each phase separately.
More precisely, we introduce logical variables to memorize
values of program variables at start and end of each phase.
The computation of each phase is thus speciﬁed by arith-
metic relations between logical variables.

Multiplication in radix-264 representation. Let P 64M
and P 64R denote the qhasm fragments for multiply and
reduce respectively. The multiply fragment P 64M com-
putes the 512-bit value S = (s0, . . . , s7) in (1) stored in
the memory pointed to by the qhasm variable sp. Thus
each 64-bit value si corresponds to the qhasm expression
*(uint64 *)(sp + 8i) for every i ∈ [0, 3]. Deﬁne

Q64s eqns

:=

Q64mult

64= *(uint64 *)(sp + 8i),
512= 264Xy1 + A0∧

si
512= Xy0 ∧ A1
512= 2128Xy2 + A1∧
512= 2192Xy3 + A2∧

3(cid:80)

xi264i ∧ 7(cid:80)

si264i 512= A3.

i=0
:= A0
A2
A3
X 512=

i=0

i=0

For clarity, we introduce the logical variable X for the input
X = x0 + 264x1 + 2128x2 + 2192x3 in Q64mult . Consider the
Hoare triple (|Q64xy eqns|) P 64M (|Q64s eqns ∧ Q64mult|) The
precondition Q64xy eqns memorizes the limbs of the inputs
X and Y in logical variables xi’s and yi’s. The formula
Q64s eqns records the limbs si’s after the qhasm fragment
P 64M in logical variables si’s. Q64mult ensures that the
limbs si’s are computed according to (1). In other words, the
Hoare triple speciﬁes the multiply phase of Fp multiplication
in the radix-264 representation.

i for the limbs s(cid:48)

Reduction in radix-264 representation. Following the
reduction phase in Sec. 3.1, we introduce logical variables s(cid:48)
i respectively for every i ∈ [0, 4].
and s(cid:48)(cid:48)
The formulas Q64s(cid:48) red , Q64s(cid:48)(cid:48) red , Q64r red are deﬁned for
the three reduction steps. The formulas Q64s(cid:48) bds , Q64s(cid:48)(cid:48) bds ,
and Q64r bds moreover give upper bounds.

i and s(cid:48)(cid:48)

i

s(cid:48)
i264i 320= s0 + 264s1 + 2128s2 + 2192s3+

i=0
38(s4 + 264s5 + 2128s6 + 2192s7)

Q64s(cid:48) red

:=

Q64s(cid:48) bds

:=

Q64s(cid:48)(cid:48) red

:=

Q64s(cid:48)(cid:48) bds

:=

Q64r red

:=

Q64r bds

:=

4(cid:80)
4(cid:86)
4(cid:80)
3(cid:86)
3(cid:80)
3(cid:86)

i=0

i=0

i=0

i=0

i=0

0 ≤ s(cid:48)
i < 264
s(cid:48)(cid:48)
i 264i 320= 38s(cid:48)
0 ≤ s(cid:48)(cid:48)
ri264i 256= 38s(cid:48)(cid:48)
0 ≤ ri < 264

4 +

s(cid:48)
i264i

i < 2 ∧ 0 ≤ s(cid:48)(cid:48)

4 < 2
s(cid:48)(cid:48)
i 264i

4 +

3(cid:80)
3(cid:80)

i=0

i=0

Consider the following Hoare triple

(|Q64mult|) P 64R

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)


Q64s(cid:48) red ∧ Q64s(cid:48) bds∧
Q64s(cid:48)(cid:48) red ∧ Q64s(cid:48)(cid:48) bds∧
Q64r red ∧ Q64r bds∧

Q64r eqns

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)
 .

The precondition Q64mult assumes that variables si’s are ob-
tained from the multiply phase. Recall the formula Q64r eqns
deﬁned at the beginning of this subsection. The postcondi-
tion states that outcome ri’s are obtained by the reduce
phase. Note that the logical variable s(cid:48)(cid:48)
4 is at
most 1. We are using Boolector to verify this fact in the
reduction phase.

4 for the limb s(cid:48)(cid:48)

Proposition 1. Assume
1. |= (|Q64xy eqns|) P 64M (|Q64s eqns ∧ Q64mult|);
Q64s(cid:48) red ∧ Q64s(cid:48) bds∧
Q64s(cid:48)(cid:48) red ∧ Q64s(cid:48)(cid:48) bds∧
Q64r red ∧ Q64r bds∧

2. |= (|Q64mult|) P 64R

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)


Q64r eqns

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)
.

=⇒ Q64prod

Then |= (|Q64xy eqns|) P 64M ; P 64R (|Q64prod ∧ Q64r bds|).
Note that the Hoare triples in the proposition do not estab-
lish Q64prod directly. Indeed, we need to show
Q64mult ∧ Q64s(cid:48) red ∧ Q64s(cid:48) bds∧
Q64s(cid:48)(cid:48) red ∧ Q64s(cid:48)(cid:48) bds ∧ Q64r red ∧ Q64r bds
in the proof of Proposition 1. Observe that the statement
involves modular operations in the bit-vector theory. Al-
though the statement is expressible in a quantiﬁer-free for-
mula in the theory of bit-vectors, the SMT solver Boolec-
tor could not verify it. We therefore use the proof assistant
Coq to formally prove the statement. With simple facts
about modular arithmetic such as 38 ≡ 2256 (mod p), our
formal Coq proof needs less than 800 lines.
Fp multiplication in radix-251
5.2

Let P 51 denote the qhasm fragment for Fp multiplication
in radix-251 representation. The inputs X = x0 + 251x1 +
2102x2 + 2153x3 + 2204x4, Y = y0 + 251y1 + 2102y2 + 2153y3 +
2204y4, and outcome R = r0 +251r1 +2102r2 +2153r3 +2204r4
are stored in memory pointed to by the qhasm variables xp,
yp, and rp respectively. We thus introduce logical variables
xi, yi, and ri to memorize the values of the qhasm expres-
sions *(uint64 *)(xp + 8i), *(uint64 *)(yp + 8i), and
*(uint64 *)(rp + 8i) respectively for every i ∈ [0, 4].

The formulas Q51xy eqns , Q51r eqns , Q51prod are deﬁned
similarly as in the radix-264 representation. The formulas
Q51xy bds and Q51r bds specify that the inputs and outcome
are in the radix-251 representation.

4(cid:86)
4(cid:86)

i=0

i=0

i=0

0 ≤ yi < 251

0 ≤ ri < 251

0 ≤ xi < 251 ∧ 4(cid:86)
(cid:18)(cid:12)(cid:12)(cid:12)(cid:12) Q51r eqns ∧ Q51r bds∧

(cid:12)(cid:12)(cid:12)(cid:12)(cid:19)

In the top-level Hoare triple
(|Q51xy eqns ∧ Q51xy bds|) P 51
,
the precondition Q51xy eqns ∧ Q51xy bds assumes that the in-
puts X and Y are in the radix-251 representation. The post-
condition Q51r eqns ∧ Q51r bds ∧ Q51prod speciﬁes that the

Q51prod

Q51xy bds

:=

Q51r bds

:=

305outcome is the product of X and Y in the radix-251 rep-
resentation. The top-level Hoare triple hence speciﬁes that
the qhasm fragment P 51 is Fp multiplication in the radix-251
representation.

Similar to the case in the radix-264 representation, the
top-level Hoare triple should be decomposed before veriﬁca-
tion. Recall that Fp multiplication in the radix-251 repre-
sentation has two phases: multiply-and-reduce and delayed
carry (Sec. 3.2). We therefore verify each phase separately.
Let P 51M R and P 51D denote the qhasm fragment for
multiply-and-reduce and delayed carry respectively. In the
multiply-and-reduce phase, the qhasm fragment P 51M R com-
putes si’s in (2). Since each si has 128 signiﬁcant bits,
P 51M R actually stores each si in a pair of 64-bit qhasm vari-
ables sil and sih. We will use the qhasm expression u.v to
denote u × 264 + v. Deﬁne

Q51s eqns

:=

Q51mult red

:=

si

128= sih.sil

Q51si

4(cid:86)
4(cid:86)

i=0

i=0

where

Q51s0
Q51s1
Q51s2
Q51s3
Q51s4

:= s0
:= s1
:= s2
:= s3
:= s4

128= (x0y0 + 19(x1y4 + x2y3 + x3y2 + x4y1))
128= (x0y1 + x1y0 + 19(x2y4 + x3y3 + x4y2))
128= (x0y2 + x1y1 + x2y0 + 19(x3y4 + x4y3))
128= (x0y3 + x1y2 + x2y1 + x3y0 + 19x4y4)
128= (x0y4 + x1y3 + x2y2 + x3y1 + x4y0) .

Q51s eqns states that the logical variable si is equal to the
qhasm expression sih.sil for every i ∈ [0, 4]. Q51mult red
speciﬁes that si are computed correctly for every i ∈ [0, 4].
Nonetheless, we ﬁnd the condition Q51mult red is too weak to
prove the correctness of the multiply-and-reduce phase. If
sih.sil indeed had 128 signiﬁcant bits, overﬂow could occur
during bitwise operations in multiply-and-reduce. To verify
multiplication, we estimate tighter upper bounds for si’s.

Recall that si’s are sums of products of xi’s and yj’s which
are bounded by 251. A simple computation gives us better
upper bounds for si’s. Deﬁne

Q51s bds

:= 0 ≤ s0 ≤ 2102 + 4 · 19 · 2102∧

0 ≤ s1 ≤ 2 · 2102 + 3 · 19 · 2102∧
0 ≤ s2 ≤ 3 · 2102 + 2 · 19 · 2102∧
0 ≤ s3 ≤ 4 · 2102 + 19 · 2102∧
0 ≤ s4 ≤ 5 · 2102

Consider the Hoare triple (|Q51xy eqns ∧ Q51xy bds|)P 51M R
(|Q51s eqns ∧ Q51s bds ∧ Q51mult red|), in addition to check-
ing whether qhasm variables sih’s and sil’s are computed
correctly, the qhasm fragment P 51M R for multiply-reduce is
required to meet the upper bounds in Q51s bds . The mid-
condition Q51s bds ∧ Q51mult red enables the veriﬁcation of
the qhasm fragment P 51D for the delayed carry phase.

The qhasm fragment P 51D for delayed carry performs car-
rying on 128-bit expressions sih.sil’s to obtain the product
of the inputs X and Y . The product must also be in the
radix-251 representation. Deﬁne

Q51delayed carry

:=

ri251i

(mod p).

The Hoare triple (|Q51s eqns ∧ Q51s bds ∧ Q51mult red|) P 51D
(|Q51delayed carry ∧ Q51r bds|) veriﬁes that the qhasm fragment

4(cid:80)

i=0

si251i 512≡ 4(cid:80)

i=0

P 51D computes a number

4(cid:80)

i=0

sentation, and it is congruent to

Proposition 2. Assume that

P 51M R

Q51xy bds

(cid:18)(cid:12)(cid:12)(cid:12)(cid:12) Q51xy eqns∧
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12) Q51s eqns∧
(cid:18)(cid:12)(cid:12)(cid:12)(cid:12) Q51xy eqns∧

Q51s bds∧
Q51mult red

Q51xy bds

(cid:12)(cid:12)(cid:12)(cid:12)(cid:19)
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)
 P 51D
(cid:12)(cid:12)(cid:12)(cid:12)(cid:19)

1. |=

2. |=

Then |=

ri251i in the radix-251 repre-

i=0

si251i modulo p.

4(cid:80)
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12) Q51s eqns∧
; and
(cid:18)(cid:12)(cid:12)(cid:12)(cid:12) Q51delayed carry∧
(cid:12)(cid:12)(cid:12)(cid:12)(cid:19)
(cid:18)(cid:12)(cid:12)(cid:12)(cid:12) Q51prod∧
(cid:12)(cid:12)(cid:12)(cid:12)(cid:19)

Q51s bds∧
Q51mult red

Q51r bds

Q51r bds

.

.

P 51M R; P 51D

The Hoare triples in Proposition 2 do not establish Q51prod
directly. Again, we formally show (cid:96) [Q51xy bds∧Q51mult red∧
Q51delayed carry ] =⇒ Q51prod in the proof assistant Coq.
Our Coq proof contains less than 600 lines.
5.3 Montgomery ladder step

The veriﬁcation of the Montgomery ladder step (Alg. 2)
is carried out after all implementations of used ﬁeld arith-
metic operations are veriﬁed separately. We replace frag-
ments for ﬁeld arithmetic in the Montgomery ladder step
by their corresponding pre- and postconditions with appro-
priate variable renaming. Alg. 2 is then converted to the
static single assignment form. A formula associating vari-
ables in Alg. 2 and corresponding variables in the actual
implementation is also added. We then assert the static
single assignments as the postcondition of Alg. 2. Using
Boolector, we verify that the postcondition holds, and
that the postcondition of every ﬁeld operation implies the
precondition of the following ﬁeld operation in Alg. 2. By
the rule RelaxedComposition, the record-holding implemen-
tation for the Montgomery ladder step in the radix-251 and
radix-264 representations are formally veriﬁed, that is, the
implementation indeed matches Alg. 2.

We did not verify the Montgomery ladder step with a big
annotated qhasm program due to an eﬃciency consideration.
For example, multiplication of two variables is performed
ﬁve times in Alg. 2. The codes for these multiplication op-
erations are essentially identical with one-to-one and onto
variable renaming. Thus, if we verify the Montgomery lad-
der step as a whole, we will waste time on verifying the
same code. Note that the same code with diﬀerent pre- and
postconditions is still needed to be veriﬁed separately.

6. RESULTS AND DISCUSSION

In this section, we present results and ﬁndings during the
veriﬁcation process. A summary of the experimental re-
sults is in Table 1. The columns are the number of limbs,
the number of midconditions used, and the veriﬁcation time
used in Boolector. We run Boolector 1.6.0 on a Linux
machine with 3.07-GHz CPU and 32-GB memory. We did
not set a timeout and thus a veriﬁcation task can run until it
is killed by the operating system. All the results in Table 1
are suﬃcient to verify the qhasm code, not the best.

We formally veriﬁed the ladder step in Algorithm 2 in
both radix-264 and radix-251. The pre- and postconditions
of each operators are obtained from the veriﬁcation of the

306File Name

Description

# of limb # of MC

Time

Table 1: Veriﬁcation of the qhasm code.

fe25519r64 mul-1
fe25519r64 add
fe25519r64 sub

fe25519r64 mul-2

fe25519r64 mul121666

fe25519r64 sq
ladderstepr64
fe19119 mul

mul1271

fe25519 add
fe25519 sub
fe25519 mul

fe25519 mul121666

fe25519 sq
ladderstep
mul25519

mul25519-p2-1
mul25519-p2-2
muladd25519

re15319

radix-264 representation

r = x ∗ y (mod 2255 − 19), a buggy version
r = x + y (mod 2255 − 19)
r = x − y (mod 2255 − 19)
r = x ∗ y (mod 2255 − 19), a ﬁxed version of
fe25519r64 mul-1
r = x ∗ 121666 (mod 2255 − 19)
r = x ∗ x (mod 2255 − 19)
The implementation of Algorithm 2
r = x ∗ y (mod 2191 − 19)
r = x ∗ y (mod 2127 − 1)

Operations of
Algorithm 2

radix-251 representation

Operations of
Algorithm 2

r = x + y (mod 2255 − 19)
r = x − y (mod 2255 − 19)
r = x ∗ y (mod 2255 − 19)
r = x ∗ 121666 (mod 2255 − 19)
r = x ∗ x (mod 2255 − 19)
The implementation of Algorithm 2
r = x ∗ y (mod 2255 − 19), a 3-phase implementation
The delayed carry phase of r = x ∗ y (mod 2255 − 19)
The delayed carry phase of r = x ∗ y (mod 2255 − 19) with two sub-phases
r = x ∗ y + z (mod 2255 − 19)
r = x ∗ y (mod 2153 − 19)

4
4
4

4

4
4
4
3
2

5
5
5
5
5
5
5
5
5
5
3

1
0
0

19

2
15
14
12
1

0
0
27
5
17
14
3
1
2
7
3

0m8.73s
0m3.15s
0m16.24s

73m55.16s

0m2.03s
3m16.67s
0m3.23s
8m43.07s

141m22.06s

0m16.35s
3m38.62s

5658m2.15s

0m12.75s
463m59.5s
1m29.05s

286m52.75s
2723m16.56s
263m35.46s
1569m11.06s
2409m16.89s

corresponding qhasm code fe25519r64 */fe25519 *. We are
able to reproduce a known bug in an old version of F
2255−19
multiplication (fe25519r64 mul-1). A counterexample can
be found in seconds with a pair of precondition and postcon-
dition for the reduction phase. Veriﬁcation time of squaring
is less than that of multiplication because (1) squaring is
simpler than multiplication which requires more low-level
multiplication operations, and (2) multiplication is veriﬁed
without the fourth heuristic to be introduced later in this
section, but squaring is veriﬁed with the heuristic.

The rows mul25519-p2-1 and mul25519-p2-2 are the re-
sults of verifying the delayed carry phase of mul25519, a
3-phase implementation of multiplication. The result shows
that if we add an additional midcondition to the delayed
carry phase of mul25519, the veriﬁcation time of the de-
layed carry phase can be reduced from 2723 minutes to
263 minutes. In general, inserting more midconditions al-
lows lower veriﬁcation time, with a cost of more manual
eﬀorts. Besides mul25519 and qhasm code in the ladder
step, we also successfully veriﬁed (1) a 3-phase implementa-
tion of multiplication with addition (muladd25519), and (2)
implementations of multiplication over diﬀerent ﬁnite ﬁelds
(fe19119 mul, mul1271, and re15319).

Note that all postconditions for the radix-264 are equali-
ties. Since Boolector can not verify modular congruence
relations in the radix-264 representation, we have to estab-
lish them in Coq. On the other hand, Boolector success-
fully veriﬁes the modular congruence relation Q51delay carry
for the radix-251 representation. Our Coq proof for the
radix-251 representation is thus simpliﬁed. The reason why
some congruence relations is veriﬁed in the radix-251 rep-
resentation is because we are able to divide P 51D further
into smaller fragments. A few extra carry bits can not only
reduce the time for execution but also veriﬁcation.

We found the following heuristics are quite useful to ac-

celerate veriﬁcation. We cannot verify many of the cases
without them. First, we split conjunctions of postcondi-
tions, i.e., translate (|Q0|) P (|Q1 ∧ Q2|) to (|Q0|) P (|Q1|) and
(|Q0|) P (|Q2|). This reduces the veriﬁcation time of the mul-
tiply phase of mul25519 from one day to one minute. Sec-
ond, we delay bit-width extension. For example, consider
a formula a 256= b ∗ c where a has 256 bits and b, c have 64
bits.
Instead of extending b and c to 256 bits before the
multiplication, we ﬁrst extend b and c to 128 bits, compute
the multiplication, and then extend the result to 256 bits.
Third, the sequence of mathematical operations in anno-
tations should match as much as possible the sequence of
operations executed in a program. For example, if a pro-
gram calculates the value of a variable r by adding 19x0y2
ﬁrst, then 19x1y1, and ﬁnally 19x2y0, the annotation is bet-
ter written as r = (19x0y2 + 19x1y1) + 19x2y0 instead of
r = 19(x0y2+x1y1+x2y0) or r = 19x0y2+(19x1y1+19x2y0).
If we really need to prove r = 19(x0y2 + x1y1 + x2y0), it
can be done in Coq very easily with rewrite tactics given
the fact that r = (19x0y2 + 19x1y1) + 19x2y0. Fourth, we
over-approximate Boolector speciﬁcations by automati-
cally reducing logical variables and weakening preconditions
such that the speciﬁcations become easier to be proven.
The validity of an over-approximated speciﬁcation guaran-
tees the validity of the original one, but not vice versa.
This heuristic can be viewed as program slicing with over-
approximation. To be more speciﬁc, given a speciﬁcation

(cid:12)(cid:12)(cid:1) P (|Q1|), our translator automatically
(cid:0)(cid:12)(cid:12)Q1
(cid:0)(cid:12)(cid:12)r = r1 ∧ r1 = r0 + x ∧ x ≤ 251(cid:12)(cid:12)(cid:1) r+=y (|r = r1 + y|), this heu-

removes logical variables that do not appear in Q1; it re-
moves Qi
0 neither appears in Q1
nor gets updated in P . For example, given a Hoare triple
ristic produces (|r = r1|) r+=y (|r = r1 + y|) where (1) r1 =
r0 + x is removed because the logical variable r0 does not
appear in the postcondition, and (2) x ≤ 251 is removed

0 if some variable in Qi

0 ∧ Q2

0 ∧ ··· ∧ Qn

0

307because x neither gets updated nor appears in the postcon-
dition. Traditional program slicing may not remove r0 and
x because both variables are related to r1, which appears
in the postcondition. We cannot verify fe25519r64 sq and
fe25519 sq without this heuristic.

7. FUTURE WORK

There are several avenues for future work. One interesting
topic could be to develop veriﬁcation approaches for ensur-
ing that the an assembly implementation is resistant against
side-channel attacks. Formal techniques in measuring worst-
case execution time (WCET) might be a starting point for
this line of research.

Currently, we need to manually provide midconditions
for veriﬁcations. Although the veriﬁcation steps between
preconditions and postconditions are done automatically, it
would be even better if we can increase the degree of au-
tomation further by investigating techniques for automatic
insertion of midconditions. We think the tools for automatic
assertion insertion could be relevant [25]. The tool obtains
assertions based on given templates of assertions and by syn-
thesizing them dynamically from observed executions traces.
Our translator currently can produce Boolector speci-
ﬁcations from annotated qhasm ﬁles. Recall that some prop-
erties that cannot be proved in Boolector are proved in
Coq. It would be good if the translator can produce both
Boolector speciﬁcations and Coq proof obligations from
an annotated qhasm ﬁle, which makes the qhasm ﬁle more
self-contained. Moreover, tactics of Coq may be developed
to solve some speciﬁc problems, for example, modular con-
gruence, to reduce human work.

8. REFERENCES
[1] R. Aﬀeldt. On construction of a library of formally

veriﬁed low-level arithmetic functions. Innovations in
Systems and Software Engineering, 9(2):59–77, 2013.
https://staff.aist.go.jp/reynald.affeldt/
documents/arilib-affeldt.pdf.

[2] R. Aﬀeldt and N. Marti. An approach to formal

veriﬁcation of arithmetic functions in assembly. In
M. Okada and I. Satoh, editors, Advances in
Computer Science – ASIAN 2006, volume 4435 of
Lecture Notes in Computer Science, pages 346–360.
Springer-Verlag Berlin Heidelberg, 2007.
https://staff.aist.go.jp/reynald.affeldt/
documents/affeldt-asian2006.pdf.

[3] R. Aﬀeldt, D. Nowak, and K. Yamada. Certifying
assembly with formal security proofs: The case of
BBS. Science of Computer Programming,
77(10–11):1058–1074, 2012.
http://www.sciencedirect.com/science/article/
pii/S0167642311001493.

[4] J. B. Almeida, M. Barbosa, G. Barthe, and

F. Dupressoir. Certiﬁed computer-aided cryptography:
eﬃcient provably secure machine code from high-level
implementations. In V. Gligor and M. Yung, editors,
Proceedings of the 2013 ACM SIGSAC conference on
Computer & communications security, pages
1217–1230. ACM New York, 2013.
http://eprint.iacr.org/2013/316/.

[5] B. Alpern, M. N. Wegman, and F. K. Zadeck.

Detecting equality of variables in programs. In ACM

Symposium on Principles of Programming Languages
– (POPL 1988), pages 1–11. ACM Press, 1988.
http://courses.cs.washington.edu/courses/
cse501/04wi/papers/alpern-popl88.pdf.

[6] R. Avanzi, H. Cohen, C. Doche, G. Frey, T. Lange,

K. Nguyen, and F. Vercauteren. Handbook of Elliptic
and Hyperelliptic Curve Cryptography. Chapman &
Hall/CRC, 2006.

[7] E.-I. Bartzia. Formalisation des courbes elliptiques en

coq. Master’s thesis, Universit´e de Vincennes-Saint
Denis – Paris VIII, 2011.
http://pierre-yves.strub.nu/research/ec/.

[8] A. G. Bayrak, F. Regazzoni, D. Novo, and P. Ienne.

Sleuth: Automated veriﬁcation of software power
analysis countermeasures. In G. Bertoni and J.-S.
Coron, editors, Cryptographic Hardware and Embedded
Systems – CHES 2013, volume 8086 of Lecture Notes
in Computer Science, pages 293–310. Springer-Verlag
Berlin Heidelberg, 2013.

[9] D. J. Bernstein. qhasm: tools to help write high-speed

software. http://cr.yp.to/qhasm.html.

[10] D. J. Bernstein. Supercop: System for uniﬁed

performance evaluation related to cryptographic
operations and primitives.
http://bench.cr.yp.to/supercop.html. Published
as part of ECRYPT II VAMPIRE Lab.

[11] D. J. Bernstein. Curve25519: new Diﬃe-Hellman

speed records. In M. Yung, Y. Dodis, A. Kiayias, and
T. Malkin, editors, Public Key Cryptography – PKC
2006, volume 3958 of Lecture Notes in Computer
Science, pages 207–228. Springer-Verlag Berlin
Heidelberg, 2006.
http://cr.yp.to/papers.html#curve25519.

[12] D. J. Bernstein. Batch binary Edwards. In S. Halevi,

editor, Advances in Cryptology – CRYPTO 2009,
volume 5677 of Lecture Notes in Computer Science,
pages 317–336. Springer-Verlag Berlin Heidelberg,
2009. http://cr.yp.to/papers.html#bbe.

[13] D. J. Bernstein, N. Duif, T. Lange, P. Schwabe, and
B.-Y. Yang. High-speed high-security signatures. In
B. Preneel and T. Takagi, editors, Cryptographic
Hardware and Embedded Systems – CHES 2011,
volume 6917 of Lecture Notes in Computer Science,
pages 124–142. Springer-Verlag Berlin Heidelberg,
2011. see also full version [14].

[14] D. J. Bernstein, N. Duif, T. Lange, P. Schwabe, and

B.-Y. Yang. High-speed high-security signatures.
Journal of Cryptographic Engineering, 2(2):77–89,
2012. http://cryptojedi.org/papers/#ed25519, see
also short version [13].

[15] D. J. Bernstein and T. L. (editors). eBACS: ECRYPT

Benchmarking of Cryptographic Systems.
http://bench.cr.yp.to (accessed May 17, 2014).

[16] D. J. Bernstein and T. L. (editors). Explicit-formulas

database. http://www.hyperelliptic.org/EFD/
(accessed May 17, 2014).

[17] D. J. Bernstein, W. Janssen, T. Lange, and

P. Schwabe. TweetNaCl: A crypto library in 100
tweets, 2013.
http://cryptojedi.org/papers/#tweetnacl.

[18] D. J. Bernstein, T. Lange, and P. Schwabe. The

security impact of a new cryptographic library. In

308A. Hevia and G. Neven, editors, Progress in
Cryptology – LATINCRYPT 2012, volume 7533 of
Lecture Notes in Computer Science, pages 159–176.
Springer-Verlag Berlin Heidelberg, 2012.
http://cryptojedi.org/papers/#coolnacl.

[19] Y. Bertot and P. Cast´eran. Interactive Theorem

Proving and Program Development Coq’Art: The
Calculus of Inductive Constructions. EATCS.
Springer, 2004.

[20] K. Bhargavan, A. Delignat-Lavaud, C. Fournet,

M. Kohlweiss, A. Pironti, P.-Y. Strub, and
S. Zanella-B´eguelin. miTLS: A veriﬁed reference TLS
implementation, 2014.
http://www.mitls.org/wsgi/home.

[21] K. Bhargavan, C. Fournet, M. Kohlweiss, A. Pironti,

and P.-Y. Strub. Implementing TLS with veriﬁed
cryptographic security. In IEEE Symposium on
Security and Privacy 2013, pages 445–459, 2013. full
version: http:
//www.mitls.org/downloads/miTLS-report.pdf.

[22] B. B. Brumley, M. Barbosa, D. Page, and

F. Vercauteren. Practical realisation and elimination
of an ECC-related software bug attack. In
O. Dunkelman, editor, Topics in Cryptology –
CT-RSA 2012, volume 7178 of Lecture Notes in
Computer Science, pages 171–186. Springer-Verlag
Berlin Heidelberg, 2012.
http://eprint.iacr.org/2011/633.

[23] R. Brummayer and A. Biere. Boolector: An eﬃcient

SMT solver for bit-vectors and arrays. In
S. Kowalewski and A. Philippou, editors, Tools and
Algorithms for the Construction and Analysis of
Systems – (TACAS 2009), volume 5505 of Lecture
Notes in Computer Science, pages 174–177.
Springer-Verlag Berlin Heidelberg, 2009. http:
//fmv.jku.at/papers/BrummayerBiere-TACAS09.pdf.

[24] C. Costello, H. Hisil, and B. Smith. Faster compact

diﬃe–hellman: Endomorphisms on the x-line. In P. Q.
Nguyen and E. Oswald, editors, Advances in
Cryptology – EUROCRYPT 2014, volume 8441 of
Lecture Notes in Computer Science, pages 183–200.
Springer-Verlag Berlin Heidelberg, 2014.
http://eprint.iacr.org/2013/692/.

[25] M. D. Ernst, J. H. Perkins, P. J. Guo, S. McCamant,
C. Pacheco, M. S. Tschantz, and C. Xiao. The daikon
system for dynamic detection of likely invariants. Sci.
Comput. Program., 69(1–3):35–45, 2007.
http://pgbovine.net/publications/
daikon-invariant-detector_SCP-2007.pdf.

[29] P. Longa and F. Sica. Four-dimensional

Gallant-Lambert-Vanstone scalar multiplication. In
X. Wang and K. Sako, editors, Advances in Cryptology
– ASIACRYPT 2012, volume 7658 of Lecture Notes in
Computer Science, pages 718–739. Springer-Verlag
Berlin Heidelberg, 2012.
https://eprint.iacr.org/2011/608.

[30] D. Molnar, M. Piotrowski, D. Schultz, and D. Wagner.

The program counter security model: Automatic
detection and removal of control-ﬂow side channel
attacks. In D. H. Won and S. Kim, editors,
Information Security and Cryptology – ICISC 2005,
volume 3935 of Lecture Notes in Computer Science,
pages 156–168. Springer-Verlag Berlin Heidelberg,
2005. Full version at
http://eprint.iacr.org/2005/368/.

[31] P. L. Montgomery. Speeding the Pollard and elliptic

curve methods of factorization. Mathematics of
Computation, 48(177):243–264, 1987.
http://www.ams.org/journals/mcom/1987-48-177/
S0025-5718-1987-0866113-7/
S0025-5718-1987-0866113-7.pdf.

[32] M. O. Myreen and M. J. C. Gordon. Hoare logic for
realistically modelled machine code. In O. Grumberg
and M. Huth, editors, Tools and Algorithms for the
Construction and Analysis of Systems, volume 4424 of
Lecture Notes in Computer Science, pages 568–582.
Springer-Verlag Berlin Heidelberg, 2007. http:
//www.cl.cam.ac.uk/~mom22/mc-hoare-logic.pdf.

[33] T. Oliveira, J. L´opez, D. F. Aranha, and

F. Rodr´ıguez-Henr´ıquez. Lambda coordinates for
binary elliptic curves. In G. Bertoni and J.-S. Coron,
editors, Cryptographic Hardware and Embedded
Systems – CHES 2013, volume 8086 of Lecture Notes
in Computer Science, pages 311–330. Springer-Verlag
Berlin Heidelberg, 2013. http:
//eprint.iacr.org/2013/131/20130611:205154.

[34] S. Ragan. Bugcrowd launches funding drive to audit

popenssl. News article on CSO, 2014.
http://www.csoonline.com/article/2145020/
security-industry/
bugcrowd-launches-funding-drive-to-audit-openssl.
html (accessed May 17, 2014).

[35] B. K. Rosen, M. N. Wegman, and F. K. Zadeck.

Global value numbers and redundant computations. In
ACM Symposium on Principles of Programming
Languages – (POPL 1988), pages 12–27. ACM Press,
1988. http://www.cs.wustl.edu/~cytron/cs531/
Resources/Papers/valnum.pdf.

[26] M. Gordon. CryptVer project. http:

[36] L. Th´ery and G. Hanrot. Primality proving with

//www.cl.cam.ac.uk/~mjcg/proposals/CryptVer/.

[27] D. Hankerson, A. Menezes, and S. A. Vanstone. Guide

to Elliptic Curve Cryptography. Springer-Verlag New
York, 2004.

[28] C. A. R. Hoare. An axiomatic basis for computer

programming. Communications of the ACM,
12(10):576–580, 1969. http://www.spatial.maine.
edu/~worboys/processes/hoare/20axiomatic.pdf.

elliptic curves. In K. Schneider and J. Brandt, editors,
Theorem Proving in Higher Order Logics, volume 4732
of Lecture Notes in Computer Science, pages 319–333.
Springer-Verlag Berlin Heidelberg, 2007. http:
//hal.inria.fr/docs/00/14/06/58/PDF/paper.pdf.

[37] K. White and M. Green. IsTrueCryptAuditedYet?

http://istruecryptauditedyet.com/
(accessed May 17, 2014).

309