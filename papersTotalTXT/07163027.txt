2015 IEEE Symposium on Security and Privacy
2015 IEEE Symposium on Security and Privacy

Secure Track Veriﬁcation

Matthias Sch¨afer

University of Kaiserslautern

Germany

Vincent Lenders

armasuisse
Switzerland

schaefer@cs.uni-kl.de

vincent.lenders@armasuisse.ch

Jens Schmitt

University of Kaiserslautern

Germany

jschmitt@cs.uni-kl.de

Abstract—We propose a new approach for securely verifying
sequences of location claims from mobile nodes. The key idea
is to exploit the inherent mobility of the nodes in order to
constrain the degree of freedom of an attacker when spooﬁng
consecutive location updates along a claimed track. We show
that in the absence of noise, our approach is able to securely
verify any 2-D track with a minimum of three veriﬁers or any
3-D track with four veriﬁers. Our approach is lightweight in
the sense that it considerably relaxes the system requirements
compared to previous secure location veriﬁcation schemes which
are all agnostic to mobility. As opposed to previous schemes, our
track veriﬁcation solution is at the same time (i) passive, (ii)
does not require any time synchronization among the veriﬁers,
(iii) does not need to keep the location of the veriﬁers secret,
(iv) nor does it require specialized hardware. This makes our
solution particularly suitable for large-scale deployments. We
have evaluated our solution in a realistic air trafﬁc monitoring
scenario using real-world data. Our results show that 25 position
claims on a track are sufﬁcient to detect spooﬁng attacks with
a false positive rate of 1.4% and a false negative rate of 1.2%.
For tracks with more than 40 claims, the false positive and false
negative rates drop to zero.

I. INTRODUCTION

The ability to track the motion of vehicles in airborne,
ground, or maritime trafﬁc control systems is a key feature to
enable safe navigation and collision avoidance. For example
in commercial air trafﬁc control systems, the tracks of all
aircraft are continuously monitored to inform pilots and safety
personnel on the ground about potential aircraft collisions.
Similarly, collision avoidance systems in future autonomous
car navigation systems will require car tracking to prevent
collisions at intersections [1].

A common paradigm for tracking the mobility of vehicles
is to let nodes determine their own positions and broadcast
them to nearby nodes. For example, in the next-generation air
transportation system, aircraft determine their own positions
with the aid of global navigation satellite systems such as
GPS. This information is then periodically broadcast over
the Automatic Dependent Surveillance - Broadcast (ADS-B)
system to surrounding aircraft and sensors on the ground [2].
While this autonomous paradigm has many advantages such
as relatively low costs, it makes the system vulnerable to
location spooﬁng attacks [3], [4]. As an example related to
ADS-B, Figure 1 shows the situation in which an attacker
injects false position messages in order to emulate the track
of a ghost aircraft into the air trafﬁc surveillance and collision
avoidance systems. This attack is performed by sending fake

© 2015, Matthias Schäfer. Under license to IEEE.
© 2015, Matthias Schäfer. Under license to IEEE.
DOI 10.1109/SP.2015.20
DOI 10.1109/SP.2015.20

199
199

Fig. 1. Attack scenario: an attacker injects ghost aircraft to mislead the
instruments of controllers and pilots. The confusion caused by such an attack
can have severe or even life-threatening consequences.

position reports of airplanes which do not exist. In that way,
an adversary could mislead collision avoidance systems and
unmanned air vehicles or confuse air trafﬁc controllers. It
has been shown that these attacks are easy to launch on real
systems [4] and the ability to verify the track claims in such
systems is therefore of high importance [5].

Many schemes have been proposed in the literature to
securely verify the location claims in wireless broadcast
networks [6]–[11]. However, most of these systems are ac-
tive and require specialized hardware or directional antennas.
A real implementation of these protocols remains therefore
often a challenge as they require expensive deployments or
upgrades of existing infrastructure. Passive schemes such as
multilateration [5], [12] or veriﬁcation with hidden and mobile
base stations [13] have also been proposed. However, passive
multilateration requires a very tight time synchronization on
the order of a few nanoseconds between the veriﬁers. Further-
more, proposals such as [13] require the verifying nodes to be
at locations that are kept secret from the attacker.

In this paper, we propose a secure track veriﬁcation tech-
nique which is completely passive, does not require a tight
time synchronization between the veriﬁers, and works even if
the attacker knows the positions of the veriﬁers. In addition, it
does neither require any specialized hardware nor directional
antennas. This makes the approach particularly suitable for
low-cost and large-scale deployments. The core idea of our
approach is to exploit the mobility of the prover to verify its
position securely as it moves along a track. As we show in this
work, the mobility of the prover is a useful dimension that can

be exploited to signiﬁcantly relax costly system requirements
of existing location veriﬁcation schemes which are agnostic to
the mobility of the prover.

Our novel scheme is based on the mobility-differentiated
time of arrival (ToA). In constrast
to existing point-wise
location veriﬁcation or multilateration schemes, our approach
veriﬁes a sequence of location claims of a prover. We show that
with this technique, it is possible to verify the track of mobile
nodes locally at each receiver and, hence, avoid the need for
tight synchronization among the veriﬁers. The veriﬁcation is
based on physical signal propagation constraints and local time
differences at the veriﬁer between messages that are sent by
the mobile node at different positions and times.

This technique is able to correctly verify tracks from honest
nodes. However, it is not secure against attacks on single
veriﬁers. An attacker could easily adjust the transmission times
of its messages to spoof any desired track for a given receiver.
We thus derive the requirements for using our technique for
secure veriﬁcation of track claims. We show that the resulting
track veriﬁcation scheme is secure against attacks from a
stationary adversary. The two-dimensional track of a mobile
node can be constrained to a unique solution when at least
three messages are received by at least three geographically
distributed veriﬁers. With four or more distributed veriﬁers,
any three-dimensional track can be securely veriﬁed as well.
In order to understand the performance of track veriﬁcation
under real-world conditions, we have further performed simu-
lations with different levels of noise and losses at the veriﬁers.
Additionally, we demonstrate the ability to securely verify
ﬂights as obtained from OpenSky [14], a large-scale ADS-
B sensor network deployed in Central Europe. Our results
suggest that our solution is able to effectively detect track
spooﬁng attacks under realistic noise and air trafﬁc conditions.

A. Contributions

The contributions of this work are as follows:
• We present a passive and lightweight solution to the
secure track veriﬁcation problem which exploits the mo-
bility of the provers in order to relax the costly system
requirements of existing solutions.

• We provide a formal analysis, proving the security of our
scheme for two-dimensional and three-dimensional track
veriﬁcation.

• We analyze the performance of our method by conducting

simulations with a realistic noise model.

• We demonstrate the feasibility to verify tracks in an air
trafﬁc monitoring scenario by using real tracks from the
OpenSky sensor network.

II. PROBLEM STATEMENT

Similar to secure location veriﬁcation as deﬁned by Sastry
et al. [6], we deﬁne the problem of secure track veriﬁcation
as follows: A set of veriﬁers V wish to check whether a
prover moves on a claimed track T . A track claim consists
of a sequence of location claims, that is T = {C1, . . . , Cn}.
Each location claim Ci is a tuple (ti, (cid:2)pi), where ti denotes

Δ1,3

Δ1,2

Δ2,3

t2

tx
1

t3

tx
2

Prover

t1

Veriﬁer Vx

time

tx
3

Δx
1

Δx
2

Δx

1,2

Δx
3

Δx

2,3

Δx

1,3

Fig. 2. The notation of time used in this paper. Timespans are denoted with
an Δ, points in time with t. The indexes refer to positions and the superscripts
to entities such as veriﬁers (x, y, . . . ) or an adversary (A).

a prover-local timestamp with its corresponding location (cid:2)pi.
Locations are assumed to be two- or three-dimensional Eu-
clidean coordinates. The location claim Ci is sent at time ti
and from location (cid:2)pi. In other words, by transmitting Ci, the
prover claims to be at position (cid:2)pi at the transmission time of
Ci and its local, unsynchronized clock shows the value ti.
Our goal is to verify tracks of moving nodes. Accordingly,
we further assume that |T| > 1 and pi (cid:2)= pj for at least one
pair of location claims Ci, Cj ∈ T . This assumption clearly
draws a distinction between our problem and that of location
or in-region veriﬁcation as deﬁned in [6].

A. Time Notation

We assume that both, prover and veriﬁers are equipped
with clocks which do not have to be synchronized – a major
advantage of our scheme. Timestamps represent the local time
of a node at a certain event. To distinguish between global time
and local timestamps, we denote global time with t and the
node-local time that corresponds to t (i.e., the timestamp at
time t) with t. For the theoretical analysis, we assume that
all clocks run at the same speed and positions as well as
timestamps are perfect, i.e., can be measured without error.
The effects of clock drift and measurement error are studied
in detail in Section IV.

The following temporal relationships and notations are sum-
marized in Figure 2. The timespan between the transmissions
of two location claims Ci and Cj is denoted by Δi,j = tj −ti.
The arrival time of a location claim Ci at veriﬁer Vx ∈ V
is denoted by tx
the timespan between the
arrivals of two location claims Ci and Cj at Vx is denoted
j − tx
by Δx
i . The propagation delay of Ci’s signal on
its way to a veriﬁer Vx is denoted by Δx

i . Analogously,

i − ti.

i,j = tx

i = tx

Values derived by local timestamps are overlined. For the
following analysis, it is worth noting that for two honest
location claims Ci and Cj, it holds that Δi,j = tj − ti = Δi,j.
B. System Model

The system model is motivated by air trafﬁc monitoring
(ATM) systems. In the upcoming next generation air trans-
portation system, aircraft determine their own position using

200200

satellite navigation and broadcast it periodically to surrounding
ground stations. These position reports can be considered as
location claims of the aircraft’s track. The receiving ground
stations are connected via ground networks. In aviation, fa-
cilities are usually well protected and therefore, the ground
stations and the network can be assumed to be secure.

In our model, a moving prover accordingly broadcasts a
sequence of location claims Ci (i = 1, 2, . . . ) to a set of sta-
tionary veriﬁers {Vx, Vy, . . .} using a wireless communication
channel. We assume that there is no compromised veriﬁer and
all veriﬁers are able to communicate securely with each other.
Each veriﬁer Vx knows its position (cid:2)px.

Besides ATM, other systems are also well conceivable areas
of application for our scheme. The key characteristic of our
system model is the mobility of the prover. Therefore, any
location-aware application with mobile stations (e.g., vehicular
ad hoc networks or cellular networks) might be a potential
target system for our scheme.

C. Adversarial Model

In order to analyze the security of our track veriﬁcation
scheme, we use the following threat model. We consider a
single adversary A located at position (cid:2)pA. We assume for our
theoretical analysis that it uses an omni-directional antenna to
broadcast the location claims. This strong assumption ensures
that all veriﬁers in the reception area of A receive the exact
same location claims during the veriﬁcation process. In section
V, we propose an extension to our scheme that allows to also
defend against attackers that are able to control exactly who
is receiving which location claim.

The adversary has full control of the location claim’s
content. In particular, (cid:2)pi and ti are chosen by the attacker and
the transmission time ti of Ci does not necessarily correlate
with the timestamp ti. In addition to these assumptions, the
adversary also knows the exact position of all veriﬁers. Further
adversarial models such as mobile attackers or attackers with
limited knowledge are discussed in section VIII.

With respect to the ATM scenario, a realization of our
threat model could be an adversary positioned close to an
airport that injects fake position reports to cause confusion
or prevent departures. As mentioned above, the feasibility of
such attacks has been successfully demonstrated, even with
low-cost hardware [3], [4].

III. BASIC VERIFICATION SCHEME

Using the above notations, we can conclude that for valid
location claims, the inter-arrival times of the location claims
Ci and Cj at veriﬁer Vx differ from the inter-transmission
times by the difference in propagation delays from (cid:2)pi and (cid:2)pj
to (cid:2)px:

Δx

i,j = Δi,j + (Δx

j − Δx
i )

(1)

Provers and veriﬁers do not have a common time base
since they are not assumed to be synchronized. Yet, based
on the reported and measured local timestamps, the veriﬁer
can calculate Δi,j and Δx
i,j. The propagation delays can be

201201

i/j = (cid:4)(cid:2)pi/j − (cid:2)px(cid:4)/c, where c denotes the

estimated using Δx
signal propagation speed and (cid:4) · (cid:4) the Euclidean distance.
At the core of our track veriﬁcation scheme, each veriﬁer
checks for all pairs Ci, Cj ∈ T whether the following property
holds:

Δx
i,j

?= Δi,j + (Δx

j − Δx
i )

(2)

It is easy to see that Equation (2) is the same as Equation
(1) if the prover reported its position and timestamps correctly.
Thus, Equation (2) holds if the prover claimed its track
honestly. Using the terminology of location veriﬁcation, our
scheme therefore satisﬁes the property of completeness [6].

Concerning the security property of our veriﬁcation scheme,
we claim that given a certain number of veriﬁers, a dishonest
prover cannot send false location claims without violating
Equation (2) for at least one veriﬁer. To prove this hypothesis,
we conduct a theoretical security analysis next.

A. Security Analysis

For our analysis, we assume that the adversary’s goal is to
claim a track with two location claims C1 = (t1, (cid:2)p1) and
C2 = (t2, (cid:2)p2) with (cid:2)p1 (cid:2)= (cid:2)p2. We can do so without loss
of generality, since Equation (2) constitutes a pairwise check
for all claims in T without particular order. Hence, if our
scheme is secure for arbitrary C1 and C2, it is also secure
for track T . To provide a better understanding how security is
established in our veriﬁcation scheme, we analyze it step by
step by increasing the number of veriﬁers |V | which receive
C1 and C2.

Case |V | = 1: With respect to the calculation done by the

veriﬁers, we can rewrite Equation (2) as
?= (t2 − t1) + (Δx

2 − tx
tx

1

2 − Δx
1 )

(3)

The adversary’s goal is to ﬁnd a transmission time t2 for C2
relative to t1, such that the inter-arrival time at Vx (left-hand
side of the equation) corresponds to the location claims C1 and
C2 (right-hand side). Therefore, it waits for the appropriate
time ΔA after the transmission of C1, i.e. t2 = t1 + ΔA. By
plugging this into Equation (3), we obtain

(cid:2) (cid:3)(cid:4) (cid:5)
(cid:4)
(cid:5)(cid:2)
A = (cid:4)(cid:2)pA − (cid:2)px(cid:4)/c being the propagation delay from
with Δx
the adversary to Vx. This equation can be solved for ΔA and
thus, the attacker can simply use

(cid:4)
(cid:5)(cid:2)
− (t1 + Δx
A)

= (t2 − t1) + (Δx

t1 + ΔA +Δx
A)

2 − Δx
1 )

(cid:3)

(cid:3)

=tx
2

=tx
1

=t2

(

ΔA = (t2 − t1) + (Δx

2 − Δx
1 )

to spoof C1 and C2.

This result means that adversaries are able to spoof arbitrary
tracks by simply adjusting the time between the transmissions
of the location claims if there is only one veriﬁer (and they
are close enough to the veriﬁer). An illustration of such an
attack is provided in Figure 3.

Spoofed track

Veriﬁer Vx

Adversary

Δx
1,2

Δx
2

Δx
1

t1

t2

t1

tx
1

Δx
A

ΔA

time

t2

tx
2

Δx
A

Fig. 3.
Illustration of an attack on a single veriﬁer. By adjusting the
transmission time t2 with respect to t1 and the desired Δx
i,j, the adversary’s
location claims C1 and C2 are received by the veriﬁer Vx as they were sent
from the spoofed track.

Case |V | = 2: As above, the adversary tries to forge a
location claim by adapting the difference in transmission times
Δ1,2 such that its location claims C1 and C2 seem honest for
two veriﬁers Vx and Vy. The difference to the previous case is
that the adversary’s signal now experiences two independent
propagation delays Δx
A and both veriﬁers expect
independent propagation delays Δx
i . As a result and
similar to the previous case, the adversary has to ﬁnd ΔA such
that the following system of equations is satisﬁed:

A and Δy

i and Δy

ΔA = (t2 − t1) + (Δx
ΔA = (t2 − t1) + (Δy

2 − Δx
1 )
2 − Δy
1)

Hence, the adversary is limited in its choice of (cid:2)p1 and (cid:2)p2.

In particular, it has to choose them such that

2 − Δx
Δx

1 = Δy

2 − Δy
1.

Without loss of generality, we ﬁx position (cid:2)p1 for the ﬁrst
location claim. Then,
the adversary can use any position
(cid:2)p2 ∈ H((cid:2)p1, (cid:2)px, (cid:2)py) for its second location claim C2 with

H((cid:2)p1, (cid:2)px, (cid:2)py) = {(cid:2)p ∈ R

n (cid:4)(cid:2)p − (cid:2)px(cid:4) − (cid:4)(cid:2)p − (cid:2)py(cid:4) =

(cid:4)(cid:2)p1 − (cid:2)px(cid:4) − (cid:4)(cid:2)p1 − (cid:2)py(cid:4) }

where n is the number of dimensions. In the two-dimensional
case, this set of positions H((cid:2)p1, (cid:2)px, (cid:2)py) corresponds to one
arm of a hyperbola with foci (cid:2)px and (cid:2)py and a difference of
distances to the foci of (cid:4)(cid:2)p1 − (cid:2)px(cid:4) − (cid:4)(cid:2)p1 − (cid:2)py(cid:4). With n = 3,
H is one sheet of a hyperboloid with the same parameters.

The key insight is that the adversary cannot claim arbitrary
tracks anymore. In particular, it loses one degree of freedom
with the introduction of a second veriﬁer. It is limited in
its choice for the second position (cid:2)p2 to positions that lie on
H((cid:2)p1, (cid:2)px, (cid:2)py).

In conclusion, the adversary can still spoof tracks that go
through one arbitrary position of interest. Although this might
be sufﬁcient for some attacks, being restricted to a hyperbola is
already a signiﬁcant limitation. Furthermore, the two veriﬁers
can easily check whether the locations of the track lie on such

a hyperbola. In case they do, they can consider the track
being suspicious. In scenarios where hyperbolic tracks are
impossible (e.g. roads in a vehicular network), attacks would
not remain undetected.

Case |V | = 3: Analogously to the previous case, we can

derive the constraint

2 − Δx
Δx

1 = Δy

2 − Δy

1 = Δz

2 − Δz

1

for two location claims C1 and C2 and three veriﬁers Vx, Vy,
and Vz. This constraint can only be satisﬁed by an adversary
if it forges the location claims C1 and C2 such that
the
pairwise hyperbolas (or hyperboloids, respectively) with the
three veriﬁers intersect at (cid:2)p1 and (cid:2)p2. That means, for a position
(cid:2)p1, (cid:2)p2 it must satisfy the following constraint:
(cid:2)p2 ∈ H((cid:2)p1, (cid:2)px, (cid:2)py)

(cid:6)

(4)

{Vx,Vy}∈V

Vx(cid:3)=Vy

We now analyze these intersections. For the sake of concise
presentation, we only consider the two-dimensional case.
Extending our results to three dimensions is straightforward:
intersections of hyperboloids instead of hyperbolas must be
considered.
With dxy((cid:2)p1) = (cid:4)(cid:2)p1−(cid:2)px(cid:4)−(cid:4)(cid:2)p1−(cid:2)py(cid:4) and (cid:2)pi = (xi, yi), we
can set up a system of equations for the intersections of two
hyperbolas H((cid:2)p1, (cid:2)px, (cid:2)py) and H((cid:2)p1, (cid:2)px, (cid:2)pz). Each intersection
(x, y) ∈ R
2 must be a solution for the system of equations
(cid:7)
(x − xx)2 + (y − yx)2 −(cid:7)
derived by the deﬁnition of H:
(x − xx)2 + (y − yx)2 −(cid:7)
(cid:7)
(cid:7)
By squaring and rearranging these equations, we obtain
(cid:7)
(x − xx)2 + (y − yx)2 = x · c1 + y · c2 + c3
(x − xx)2 + (y − yx)2 = x · c4 + y · c5 + c6

(x − xy)2 + (y − yy)2 = dxy((cid:2)p1)
(x − xz)2 + (y − yz)2 = dxz((cid:2)p1)

(5)
(6)

with constants

c1 = (xx − xy)/dxy((cid:2)p1)
c2 = (yx − yy)/dxy((cid:2)p1)
x − y2
c3 = (x2
c4 = (xx − xz)/dxz((cid:2)p1)
c5 = (yx − yz)/dxz((cid:2)p1)
x − y2
c6 = (x2

y − x2

z − x2

y + y2

z + y2

x + dxy((cid:2)p1)2)/(2dxy((cid:2)p1))

x + dxz((cid:2)p1)2)/(2dxz((cid:2)p1))

Subtracting Equation (6) from Equation (5) results in

y = x · c1 − c4
c5 − c2

c3 − c6
c5 − c2

+

Plugging this equation into one of the initial equations results
in a quadratic equation for x and y. Quadratic equations have
either zero, one, or two solutions. In our case, we even know
that by construction of the hyperbolas, it has at least one
solution, that is (cid:2)p1. Thus, there is either no or at most one
possible position left for the adversary to spoof a track without
violating Equation (2) for one of the veriﬁers.

202202

Fig. 4. Example with three veriﬁers and their pairwise hyperbolas for a
claimed position (cid:2)p1. No further position can be spoofed without being detected
since there is no other intersection.

A scenario with three veriﬁers and their pairwise hyperbolas
is depicted in Figure 4. The adversary wants to spoof a track
and claims to be at (cid:2)p1. As there is no further intersection of the
three hyperbolas, it cannot claim any second position without
being detected by at least one veriﬁer.

In three dimensions and similar to navigation methods based
on time-difference of arrival measurements (e.g. multilatera-
tion), a fourth veriﬁer would be necessary to pin the attacker
|V | veriﬁers result
down to a single position. In general,
in |V | − 1 pairwise hyperboloids. With three-dimensional
locations and |V | = 3, the two hyperboloids intersect on a
curve. As in the two-dimensional case, adding a fourth veriﬁer
reduces the number of intersections to at most two points in
space.

Case |V | > 3: Equation (4) is a general result which also
holds for more than three veriﬁers. For the two-dimensional
case,
the guarantees given by three veriﬁers are already
sufﬁcient since attacks using tracks with two intersections can
simply be prevented by requiring |T| ≥ 3. However, more
than three veriﬁers can be beneﬁcial to mitigate noise in the
veriﬁcation data such as measurement errors or clock drifts.
This interesting issue of imperfect veriﬁcation data and how
to use |V | > 3 to improve the accuracy of veriﬁcation is dealt
with below in Sections IV and VI.

B. Conclusions from the Analysis
The above analysis shows that

the adversary loses one
degree of freedom with each additional veriﬁer. The intuition
behind this is as follows: As the adversary is changing its
position between individual location claims, the propagation
delay to each veriﬁer must also change in order to satisfy
Equation (2) at all veriﬁers. Thus, adversaries would have to
vary the propagation delays to each of the veriﬁers indepen-
dently to successfully pretend movement. Since all veriﬁers
receive the same messages (due to the broadcast transmission),
this is not possible. As a result, the only spoofable track for
a stationary adversary is the track on which the difference in
propagation delay to each veriﬁer is constant. For two veriﬁers,
this is a hyperbola. For more than two veriﬁers, this property
only holds for the intersections of the pairwise hyperbolas (see
Figure 4).

In summary, we can generalize the assumptions for secure
track veriﬁcation as follows. Let n be the number of dimen-
sions, that is (cid:2)pi ∈ R
n. Then our scheme can detect track
spooﬁng attacks if any of the following two conditions is met:
1) |V | ≥ n ∧ ∃(cid:2)p1,(cid:2)p2∈T p2 (cid:2)∈ H((cid:2)p1, (cid:2)px, (cid:2)py): The location
claims of T are received by at least n veriﬁers and there are
two different positions in T , where one position does not lie
on the hyperbola (or the hyperboloid, respectively) spanned
by the other position and the two veriﬁers’ positions.
2) |T| ≥ 3 ∧ |V | ≥ n + 1: The track consists of at least
three location claims and the claims are received by at least
n + 1 veriﬁers.

IV. DEALING WITH NOISE

In practice, veriﬁers have to deal with imperfect veriﬁcation
data since time and position measurements are error-prone. For
instance, clocks have different speeds which results in non-
negligible drifts. In order to assess the practicality and perfor-
mance of our veriﬁcation scheme under realistic conditions,
we use the following error model.

A. Error Model

1) Clock Drift: The speed of clocks is highly dependent on
environmental conditions such as pressure or temperature [15].
However, we assume that the duration of the veriﬁcation pro-
cess is on the order of seconds or minutes. Most environments
(such as the interior of vehicles) are sufﬁciently stable within
such time periods. Hence, we assume that clock drift is linear
and thus increases at a constant rate during the veriﬁcation
process.

In accordance to that, we model clock drift as follows. The
error due to clock drift drift linearly depends on the duration
between two time measurements. It can be modeled by a drift
coefﬁcient tdrift for an entity X. Assuming that X wants to
measure a period of time Δi,j = tj − ti, the clock drift error
drift of X’s measurement ΔX

i,j is given by

drift = Δi,j · tdrift = (tj − ti) · tdrift .

2) Measurement & Channel Noise: Measuring points in
time at which events occur always involves measurement
errors. For instance, systems are clocked by an oscillator at
a certain rate and they only perform actions if a pulse or
pulse edge of the oscillator is present. Hence, observations
can only be made at discrete points in time. This leads to
measurement errors when events of interest (such as the arrival
of a signal) occur between two clock ticks. Besides timing
errors, wireless transmission characteristics such as multipath
propagation distort the signal. This may also results in noise
when determining timestamps for signal arrivals. In addition
to erroneous time measurements, our scheme may also suffer
from erroneous position information. If provers use GPS to
determine their positions, the location claims may contain
errors of up to 15 m.

We assume that measurement and channel noise are in-
dependent for each location claim and each of its associ-
ated timestamps. In accordance with [16], we summarize all

203203

sources of noise in a zero-mean Gaussian random variable
 ∼ N (0, σ2). The variance σ2 depends on the accuracy of
the system components involved in the veriﬁcation process.
For instance, if clocks with higher rates are used, σ2 becomes
smaller.

By combining clock drift and noise, we conclude that the
for our

error contained in measuring a time period Δi,j
veriﬁcation scheme can be modeled as

Δi,j − Δi,j = drift +  = (tj − ti) · tdrift + 

(7)
In the following, we propose two versions of our scheme:
local and global veriﬁcation. In local veriﬁcation, veriﬁers cal-
culate and check their veriﬁcation results locally. They do not
need to communicate with each other. This has the advantage,
that communication overhead is minimal and veriﬁers do not
have to be connected. They could simply send an alarm to a
central entity in case an attack was detected. This simplicity,
however, comes at a price. Local veriﬁcation does not take
full advantage of the total number of veriﬁers. Therefore, we
also propose a global scheme, which is based on the local
scheme but veriﬁers collaborate in order to reduce the impact
of noise. We conclude the section with a comparison of both
approaches.
B. Local Track Veriﬁcation Scheme

The noise in real systems makes a simple check of Equation
(2) to verify a track impractical. Therefore, we adapt our basic
veriﬁcation scheme to deal with noisy values. The idea is
to use all received location claims to estimate the error. As
shown in [16], jointly estimating clock drift and measurement
error is not feasible since the Cramer-Rao lower bound of
the estimation error is too large. Therefore, we perform our
veriﬁcation in two steps.

The ﬁrst step estimates the clock drift. This estimate is
then used in the second step to cancel out drift from our
measurements. Let n = |T| be the number of received location
claims. The clock drift coefﬁcient tx
drift of Vx can then be
estimated using

(cid:12)

Δx
i,j
Δi,j + (Δx

j − Δx
i )

− 1

(8)

(cid:11)

n(cid:10)

(cid:9) n−1(cid:10)
1(cid:8)

n
2

i=1

j=i+1

ˆtx
drift

=

From a security perspective, estimating the clock drift in
this way raises the question whether an adversary can take
advantage of pretending certain clock drifts or not. The answer
to that question is no. Since we do not make any assumptions
on clock drifts, a fake clock drift is just as good as a true one,
and both will be equally eliminated by Equation (8). Faking
different clock drifts during one track is even worse, since
the estimation error will be high and, thus, increase the ﬁnal
veriﬁcation result V x
T deﬁned below (which leads to a rejection
of the claimed track). Hence, fake clock drifts do not pose a
threat to our scheme.

The veriﬁcation is ﬁnally done in the second step by
calculating the mean squared error when subtracting the right-
hand side from the corrected left-hand side of Equation (2).

204204

We denote this local veriﬁcation result V x
a track T by

T of Veriﬁer Vx for

(Δi,j + (Δx

j − Δx

i )) · (1 + ˆtx

) − Δx

i,j

drift

(9)

n(cid:10)

(cid:13)

(cid:9) n−1(cid:10)
1(cid:8)

n
2

i=1

j=i+1

V x
T =

(cid:14)2

The results of our security analysis in Section III-A imply
that for honest track claims, V x
T should converge to the average
squared error. For dishonest claims, V x
T must be higher for at
least one veriﬁer due to the deviation caused by its dishonesty.
In our track veriﬁcation scheme, each veriﬁer Vx ∈ V
calculates V x
T and checks whether it is below a predeﬁned
threshold. In case a veriﬁer’s local result is higher than the
threshold, the veriﬁcation fails and the track is considered
to be dishonest. We call this veriﬁcation process local track
veriﬁcation as each veriﬁer calculates its veriﬁcation result
locally. Accordingly, the threshold for the local veriﬁcation
result is denoted by Tlocal.
The threshold for the local veriﬁcation should be chosen
based on the variance σ2 of the measurement error  and the
number of location claims n. As n increases, ˆtx
drift becomes
more accurate and V x
T is supposed to converge to a value close
to zero. An optimal Tlocal must fulﬁll the same properties as
a location veriﬁcation scheme according to [6]:
T < Tlocal
1) Completeness: If T is an honest track claim, V x
must hold for all veriﬁers Vx ∈ V .
T ≥ Tlocal must
2) Security: If T is a false track claim, V x
hold for at least one veriﬁer if one of the constraints given in
Section III-B holds.

If such an optimal threshold exists, the local veriﬁcation
scheme is able to perfectly distinguish between honest and
dishonest track claims. For later analyses and optimizations,
we measure the “optimality” of Tlocal and our system in terms
of false rejection and false acceptance rates. A false rejection
of a track means the detection of an attack, although the prover
is honest. A false acceptance occurs if a false track claim is not
rejected by the system. Both rates can be controlled with Tlocal.
On the one hand, if Tlocal is smaller than the highest possible
V x
T for honest tracks, false rejections can occur. On the other
hand, false acceptances are possible if Tlocal is greater than
the smallest possible V x
C. Global Track Veriﬁcation Scheme

T for false track claims.

As our evaluation below shows, bad hardware accuracy and
veriﬁer placement may result in false rejections and accep-
tances by our local veriﬁcation scheme. The local veriﬁcation
scheme, however, does not take advantage of the total number
of veriﬁers since it only considers local results. Given a higher
number of veriﬁers, a better veriﬁcation decision can be made
by obtaining all
local results instead of considering them
separately. We call this extension global track veriﬁcation.
their veriﬁcation results V x
average veriﬁcation result:
VT =

In our global veriﬁcation scheme, the veriﬁers exchange
T and each veriﬁer calculates the

(cid:10)

V x

(10)

T

1

|V | ·

Vx∈V

(cid:2)px

(cid:2)pA

(cid:2)py

(cid:2)pR

A

This attack is possible because our veriﬁcation scheme
implicitly assumes that location claims are always received
by all veriﬁers (in the transmission area of an omnidirectional
prover). To address this problem, we extend our scheme with
the following protocol.

A. Sanity Check Protocol

We assume that each veriﬁer knows its reception area and
can check whether a position (cid:2)p lies within the reception range
using an indicator function Rx((cid:2)p):

(cid:15)

Rx((cid:2)p) =

1 if (cid:2)p lies within Vx’s reception range
0 else

(11)

Fig. 5. Example scenario: three veriﬁers Vx, Vy, and R (located at (cid:2)px,
(cid:2)py, (cid:2)pR) are arranged such that the area of interest for R is covered by the
three veriﬁers reception ranges (dotted circles). The attacker (located at (cid:2)pA)
transmits its signal to R using a directed antenna (dashed area) and avoids
being detected by the other veriﬁers.

Similar to Tlocal, we can deﬁne a threshold Tglobal for VT . A
track T is then accepted by the system if VT < Tglobal and
rejected if VT ≥ Tglobal holds.

The choice, whether to use the local or the global veriﬁca-
tion scheme depends on hardware constraints and infrastruc-
ture. In case it is cheaper to distribute many low-cost veriﬁers
instead of a few high-end devices,
the global veriﬁcation
is preferable. If veriﬁers are equipped with very accurate
hardware, the local check might be the better choice as it is
more sensitive to anomalies. Besides that, the local veriﬁcation
scheme produces less communication overhead and does not
require a fully connected network of veriﬁers.

V. RECEPTION AREA SANITY CHECK

As discussed in Section II-C, we assume that the adversary
uses an omni-directional antenna. In this section, we discuss
a simple extension to our scheme to basically ”catch” an
adversary that does not conform to this assumption. The alert
reader might already have noticed the problem related to
an attacker not using an omni-directional antenna: Assume
receiver R wants to monitor tracks in a certain area of interest
A. To securely verify the claimed tracks in A, there are v ≥ 3
veriﬁers deployed such that their reception ranges cover A. R
itself is one of the veriﬁers.

Remember the practical example from the introduction
where a ground station receives tracks from aircraft and
provides them to air trafﬁc controllers who are responsible
for managing the trafﬁc in A. Now, an adversary wants to
inject false tracks in order to mislead the controllers. It could
transmit its track claim with a directional antenna such that
it is only received by R. As R would be the only receiver,
the attacker could adjust its transmission times as shown in
Section III-A (case |V | = 1) and the attack would not be
detected. This scenario is depicted in Figure 5.

205205

In an obstacle-free line-of-sight communication scenario,
where the communication is only limited by the free-space
path loss, Rx would be

(cid:15)

Rx((cid:2)p) =

1 if (cid:4)(cid:2)px − (cid:2)p(cid:4) ≤ r
0 else

for the maximum reception range r. For more complex recep-
tion areas, an initial sampling phase or a more sophisticated
propagation model can be used to determine Rx.

In principle, the following algorithm simply checks whether
the reception of the location claim Ci is normal or not. If
the location claim was received although the position is not
in its reception range, something is suspicious and an alarm
is raised. In case the reception range covers (cid:2)pi, the location
claim is accepted and the other veriﬁers are notiﬁed about the
reception. For each reception of a location claim Ci = (ti, (cid:2)pi),
veriﬁer Vx performs the following veriﬁcation procedure:

if Rx((cid:2)pi) = 0 then // I shouldn’t have received this claim

else

broadcastAlert(Ci) // alert all veriﬁers
if Ci (cid:2)∈ N then // I received it ﬁrst
end if
T = T ∪ {Ci} // add claim to track

broadcastNotiﬁcation(Ci) // notify all veriﬁers

end if

where N is the set of all received notiﬁcations.

The second part of the protocol checks whether location
claims are always received by all veriﬁers which cover (cid:2)pi.
Assuming that the notiﬁcation was sent by the veriﬁer with
the shortest distance to the prover, all other veriﬁers should
receive the claim at latest after the difference in propagation
delays. Let max be an upper bound for the maximum expected
measurement error. For each received reception notiﬁcation
Ni = (Ci) from Vy, veriﬁer Vx performs the following
procedure:

i − Δy

i + max) // wait for it

if Rx((cid:2)pi) = 1 then // I should also receive this claim
wait(Δx
if Ci (cid:2)∈ T then // I should have received it by now
end if
N = N ∪ {Ci} // save notiﬁcation

broadcastAlert(Ci) // alert all veriﬁers

else

end if

The protocol raises an alarm in two cases. First, a veriﬁer
receives a location claim from a position which is under
legitimate conditions not within its reception range. In this
case, the prover must either be at a position other than the
claimed one or use anomalous parameters such as a higher
transmit power. Second, a veriﬁer does not receive a claim it
should receive under normal conditions. Both cases indicate
a false track claim and attacks such as the one above are
detected.

B. Channel Loss

Message loss is a natural phenomenon in wireless channels.
In ADS-B for instance, message loss rates of up to 40% in
peak trafﬁc periods have been reported [4]. However, channel
loss results in alarms not caused by an adversary. Thus, a
single alarm does not necessarily indicate an attack and the
sanity check must tolerate some loss in practice. We propose
a simple statistical scheme here to do so.
Let m = |T| be the number of transmitted messages, v =
|V | the number of veriﬁers, and na the number of alarms due
to channel loss. Under the assumption that loss is a Bernoulli
process1 and the loss probability p is known, the expected
number of alarms due to channel loss is E(na) = v · m · p.
Furthermore, the number of alarms due to channel loss, na,
is binomially distributed and we can easily build a conﬁdence
interval for na. Thus, a track T only passes our sanity check
successfully, if na is within this conﬁdence interval for a given
conﬁdence level α. In other words, if T passes the sanity
check, we can be certain with a conﬁdence of α, that the
alarms are caused by channel loss, otherwise we detect an
attack.

C. Security

Using the conﬁdence interval check has certain advantages.
By choosing an appropriate conﬁdence level, a user can
control the false positive and false negative detection rate. For
instance, higher conﬁdence levels result in wider conﬁdence
intervals. This, on the one hand, offers the adversary a wider
scope for its attacks but, on the other hand, the false rejection
rate for legitimate tracks will be decreased. In practice, a trade-
off has to be found for the concrete application scenario.

For applications where provers report their track over longer
periods, another advantage is the behavior of the conﬁdence
interval if m increases. In particular, the conﬁdence interval
becomes smaller for each additional location claim at an ex-
ponential rate. Figuratively speaking and in terms of security,
the sanity check tightens the noose on the attacker with each
additional location claim.

Most importantly, by employing this sanity check along with
our track veriﬁcation scheme, we force adversaries to send
their location claims to all veriﬁers which cover the spoofed
positions. This requirement issues a big challenge for realistic
attackers. In order to launch an attack, they have to know the
exact reception ranges of all veriﬁers and have to be able to

OVERVIEW ON THE SIMULATION PARAMETERS FOR THE ERROR

PROPAGATION ANALYSIS.

TABLE I

Parameter
r
m
v

σ
σdrift

Constant
c

Description
The radius of the circular area around the veriﬁer
The number of messages per track, i.e. m = |T|
The number of veriﬁers that receive the provers location
claims, i.e. v = |V |
The standard deviation of the measurement error
The standard deviation of the random clock drift coef-
ﬁcient tx
Description/Value
The propagation speed of the signal is ﬁxed to the speed
of light (299792458 m/s)

drift of the veriﬁers

control exactly which veriﬁers receive which location claims.
In addition to that, they have to make sure, that the channel
loss of their claims is similar to that of honest provers.

VI. ERROR PROPAGATION ANALYSIS

This section provides insights on the requirements, perfor-
mance, and security of our approach. We conducted extensive
simulations and analyzed the effect of measurement error,
clock drift, and number of claims on the veriﬁcation result. To
draw conclusions on the security (i.e. on false rejection and
false acceptance rates), we compare the veriﬁcation results of
honest and dishonest track claims.

In order to keep the detection time low, it is desirable to
keep the number of required messages as small as possible.
Therefore we assume that the drift estimator ˆtx
drift is calculated
with the same set of claims as the veriﬁcation value V x
T . As
a result, they are not independent and since ˆtx
drift is used to
calculate V x
T , the error propagation in our scheme is complex
and hard to analyze formally. While we know that the variance
of ˆtx

drift can be estimated with

Var (ˆtx

drift

) =

(cid:16)m−1

(cid:16)m

(cid:8)

i=1

j=i+1

σ2

Δi,j + (Δx

j − Δx
i )

(cid:9)2

(cid:9)2 ·(cid:8)

m
2

and the average estimation error converges to zero with
increasing m, we cannot set up a trivial error model for
V x
T analogously. However, to analyze the error propagation
nevertheless, we implemented the local and global veriﬁcation
schemes as a discrete-event simulation.

A. Simulation Setup

Initially, we assigned a random clock drift tx

drift to each veri-
ﬁer Vx. We draw tx
drift from a zero-mean Gaussian distribution
with standard deviation σdrift. The signal propagation speed is
ﬁxed to the speed of light (299792458 m/s) for all simulations.
To cancel effects caused by tracks with special properties2,
the prover moves on random tracks for this analysis. Real
tracks are considered below in Section VII. The location
claims for each track are randomly chosen from a circular area
A with radius r around the veriﬁer’s position. The prover’s
maximal change in distance to the veriﬁer (and thus the

1more complex loss models or a sampling phase can be used analogously

2e.g. errors due to a bad dilution of precision

206206

mobility-differentiated time of arrival which is considered by
our veriﬁcation scheme) is limited by r. The unit for distances
is meters. Times and periods are in seconds. Our simulation
parameters and constants are summarized in Table I.

A result of our formal security analysis in Section III-A
is that an implementation of our scheme must always ensure
that an area of interest is always covered by at least three
veriﬁers. If this is the case, we know that for at least one
veriﬁer Vx, the period Δx
i,j differs from the expected inter-
arrival time (Equation (2)). To produce valid insights on the
security of our scheme, we are particularly interested in V x
T of
this veriﬁer. Without loss of generality, we consider only one
veriﬁer in each simulation run and assume that it is the one
we are interested in, namely the one for which Equation (2)
does not hold. We generate the deviation of the adversary’s
signal arrival times from those of the honest prover by simply
putting the adversary at a random but ﬁxed position within
A. The adversary then claims the same track as the honest
prover and uses the same transmission times. The magnitude
of the deviations can be controlled by r (larger r leads to
larger deviations).

B. Clock Drift & Measurement Error

To keep our simulations realistic, we had to ﬁnd appropriate
parameters for our error model. With regard to our later
analysis of our scheme’s performance in a realistic air trafﬁc
scenario, we choose σ and σdrift based on experiences from
the OpenSky Network3. The OpenSky Network is a low-cost
sensor network which monitors air trafﬁc at a large scale and
provides the data to researchers [14]. Low-cost receivers are
distributed to volunteers in Europe and these collect (among
other things) the position reports periodically broadcast by
aircraft. The receivers used by OpenSky provide timestamps
with a 50 ns precision for the arrival of position reports.
Besides that, most aircraft are using GPS to determine their
positions. The typical position accuracy of GPS is about 15 m.
That leads to an estimation error of propagation delays Δx
i
of about 50 ns. Therefore, choosing σ = 50 ns for the
measurement error seems appropriate.

It is worth mentioning here, that this is a rather pessimistic
assumption. The OpenSky network is using low-cost receivers
which are not equipped with particularly good clocks. For bet-
ter devices, timestamps with higher precision can be assumed.
Furthermore, the Federal Aviation Administration (FAA) in
the US is implementing navigation systems for civil aviation
which can reduce positioning error to less than a meter [17].
To determine an appropriate standard deviation for clock
drift errors, we considered the drift of OpenSky’s receivers
relatively to each other. To determine the clock drifts of the
sensors, we used position reports received by multiple stations.
By subtracting the difference in propagation delays to each
receiver from the reception timestamps, we were able to obtain
the offsets of the clocks over time and thus, the clock drift. We
observed the clock drifts of eight receivers over a period of one

3http://opensky-network.org

2
0

.

0

0
0

.

0

2
0

.

0
−

4
0

.

0
−

6
0

.

0
−

)
s
(
 
t
f
i
r

D

Recvr 1: 
Recvr 2: 
Recvr 3: 
Recvr 4: 
Recvr 5: 
Recvr 6: 
Recvr 7: 
Recvr 8: 

−20.6754 μs/s
−18.7449 μs/s
−6.8805 μs/s
0 μs/s
1.5228 μs/s
2.4455 μs/s
4.1657 μs/s
 8.6235 μs/s

0

500

1000

1500

2000

2500

3000

3500

Time (s)

Fig. 6. Estimated clock drifts of 8 receivers of the OpenSky network over
one hour. The drifts are relative to the clock of receiver 4.

hour and we found that they were constantly linear during that
period. At this point it must be mentioned that the receivers
are mostly indoors and not exposed to extreme temperature
variation. The results are shown in Figure 6. According to
these results, we choose a pessimistic standard deviation of
20 μs per second for the clock drifts of the veriﬁers σdrift.

C. Simulation Results

1) Local Veriﬁcation Scheme: We ﬁrst look at the local
veriﬁcation scheme as it is the basis for the global scheme. The
goal of this analysis is twofold. On the one hand, we want to
determine the least number of location claims needed to verify
a track under the above error model. On the other hand, we are
also interested in the beneﬁts of receiving more location claims
than actually needed. Ideally, the difference in V x
T between
honest and dishonest tracks becomes more pronounced with
each additional location claim as the estimators of our scheme
become more accurate.

To draw inferences from the local simulation results about
the overall performance of our veriﬁcation scheme, we com-
pare the maximum V x
T of 1000 honest tracks with the min-
imum V x
T of 1000 dishonest tracks. In doing so, we check
whether the worst veriﬁcation result of the honest tracks is
greater than the best veriﬁcation result of the dishonest tracks.
If this is the case, we can conclude that Tlocal does not exist
since we cannot perfectly distinguish honest from dishonest
tracks. Let maxhonest be the maximum veriﬁcation result for
the honest tracks and mindishonest the minimum veriﬁcation
result for dishonest tracks. We then use the “best-evil-to-worst-
good ratio”

EGR := mindishonest /maxhonest

as response variable for our simulations. This ratio can be
interpreted as follows. If the EGR ≤ 1, Tlocal does not exist.
Otherwise, there is a secure interval

Σ = (maxhonest , maxhonest · EGR)

207207

y
t
i
s
n
e
D

0
1

.

8
0

.

6
0

.

4
0

.

2
0

.

0
0

.

maxhonest

daniel



mindishonest

0

5·10-14

10-13

1.5·10-13

Verication Result

Fig. 7. Empirical cumulative distribution functions of the veriﬁcation results
for honest (left curve) and dishonest (right curve) tracks with r = 200 m,
σ = 50 ns, σdrift = 20 μs/s, and m = 19. Any Tlocal between maxhonest
and mindishonest (i.e. Tlocal ∈ Σ) perfectly separates honest and dishonest
tracks.

3
0
1

1

R
G
E

3
-
0
1

6
-
0
1

9
-
0
1

3

10

EGR=1

r=20km
r=2km
r=200m
r=20m

40

50

20

30

Number of location claims (|T|)

Fig. 8. Result of our simulation for different radii and increasing m. The “best
evil-to-worst good ratio” (EGR) is deﬁned as the ratio of the best dishonest
result divided by the worst honest result. If EGR > 1 holds, there exists
an optimal threshold Tlocal which perfectly separates honest from dishonest
tracks.

where any Tlocal ∈ Σ results in zero false rejections and zero
false acceptances for the 1000 simulated tracks and the given
conﬁguration.

Figure 7 shows the empirical cumulative distribution func-
tion of the local veriﬁcation results of an example simulation.
In this particular example, we used a radius of 200 m and 19
messages per track. The EGR is 2.854879 which is greater
than 1 and hence, Tlocal ∈ Σ exists. In fact, the estimated
secure interval for this conﬁguration is

Σ = (1.147019 · 10−14, 3.274601 · 10−14)

As mentioned above, the veriﬁcation result is directly de-
pendent on the simulation radius r. Therefore, we repeated our
simulations for different radii. Transferred into a real-world
scenario, a greater radius means larger distances between
location claims. The results of the simulations are shown in
Figure 8. For the radii 200 m, 2 km, and 20 km, the EGR

208208

becomes greater than 1 after a few location claims. In fact, for
radii on the order of kilometers, dishonest tracks are perfectly
distinguishable from honest tracks after 4 location claims.
If r becomes too small, Tlocal does not exist anymore. For
instance, the maximum EGR for r = 20 m is 0.34. That
means that there is no optimal threshold Tlocal which perfectly
separates honest from dishonest tracks. This result, however,
is natural since we have chosen a standard deviation for the
measurement error which does not enable us to measure such
small changes in propagation delay. For r = 20 m, the change
in distance (and thus propagation delay) for random tracks is
on average 10 m, but we have chosen a standard deviation of
15 m for the measurement error.

Figure 8 also illustrates that the EGR almost stagnates for
more than 15-20 location claims. This knowledge can be used
to include a notion of freshness into the veriﬁcation scheme. If
an adversary is claiming the correct path in the beginning but
lies about its track later on, the veriﬁcation might work better
if only the most recent 15 location claims are considered.

We can conclude that veriﬁcation only works for tracks
on which provers cover distances greater than the system’s
measurement error. For such tracks, we can say that the greater
the distances covered by the prover, the less messages we
need to verify tracks without false acceptances or rejections.
To provide a real-world example for distances covered by
potential provers, we again looked at data from the OpenSky
network. Airplanes in the en-route airspace (i.e. at an altitude
of about 30,000 ft) travel at a velocity of up to 300 m/s. That
means that they cover distances of the order of kilometers
within a few seconds, making them suitable provers for our
track veriﬁcation scheme.

2) Global Veriﬁcation Scheme:

In case the system has
many veriﬁers covering an area of interest, our global scheme
can be used to reduce false acceptances and rejections for
small m. To gain insights on the global veriﬁcation result, we
conducted simulations similar to the previous ones. We placed
a varying number of veriﬁers at random positions in a circular
area with radius r = 200 m and used the same error model
parameters (σ and σdrift) as above. We picked this radius
because it produces false rejections and acceptances with the
local veriﬁcation for m ≤ 13 (see Figure 8). Compared to
larger radii, this is a rather high number of least required
messages for doing local veriﬁcation without false rejections
and/or acceptances. Thus,
there is room for improvement
which makes this radius illustrative for the beneﬁts of the
global scheme. Besides that and as mentioned above, distances
on the order of hundreds of meters is realistic for location
claims in aviation.
As before, we run our simulations for 1000 random tracks
to derive maxhonest and mindishonest for each track length |T|
and number of veriﬁers |V |. Figure 9 shows the results. As in
the local veriﬁcation, tracks with just three location claims are
still not properly veriﬁable due to the small number of samples
for eliminating the noise. However, by increasing the number
of veriﬁers to 7, we can perfectly verify tracks already after
the ﬁfth location claim with our global veriﬁcation scheme.

1
0
1

1
-
0
1

R
G
E

3
-
0
1

5
-
0
1

EGR=1
m=3
m=5
m=10
m=15

0

5

10

Number of verifiers (|V|)

15

20

Fig. 9. Result of the simulation of the global veriﬁcation scheme for 1000
tracks with an increasing number of veriﬁers and different numbers of received
location claims (m = |T|). We used the following simulation parameters:
r = 200 m, σ = 50 ns, σdrift = 20 μs/s.

Fig. 10. The 1000 trajectories fetched from the OpenSky database for our
applicability analysis. To achieve a good distribution of the veriﬁers across the
considered area, we arranged 25 veriﬁers on a grid as marked by the bubbles.

Another result of this analysis is, that adding more than 7
veriﬁers does not result in a signiﬁcant increase of the EGR.

VII. APPLICABILITY TO AIR TRAFFIC

Besides analyzing error propagation, we conducted addi-
tional simulations with real ﬂight
tracks recorded by the
OpenSky Network [14]. This enables us to assess the per-
formance of our scheme with realistic tracks, proves the
applicability to air trafﬁc surveillance systems, and highlights
challenges for a secure deployment of our scheme.

A. Simulation Setup & Data Preparation

The OpenSky Network is an Automatic Dependent
Surveillance–Broadcast (ADS-B) sensor network which col-
lects real-world air transportation communication data. In

209209

ADS-B, airplanes (and other vehicles) broadcast their posi-
tion, velocity, and other status information periodically. The
position reports, for instance, are broadcast twice per second.
They contain the airplane’s longitude, latitude, and altitude.
Interpreting these position reports as location claims, ADS-B
perfectly ﬁts to our track veriﬁcation scheme. The tracks are
the trajectories of airplanes described by their ADS-B position
reports.

For our analysis, we fetched 1000 ﬂights from OpenSky’s
database which were received by one receiver. To have a large
variety of trajectories, we selected a receiver close to Zurich
Airport. This way, our simulations contain trajectories from
the en-route airspace as well as from the approach area of
the airport. We placed 25 veriﬁers in the reception area of the
OpenSky receiver. To achieve a good distribution of veriﬁers
across the reception area, we arranged the veriﬁers in a grid.
Figure 10 shows the 1000 trajectories and the positions of the
25 veriﬁers.

While OpenSky provides timestamps with nanosecond pre-
cision for the time of arrival of the position reports, ADS-B
does unfortunately not support timestamps for the transmission
times. An attempt to estimate Δi,j for two position reports
based on the airplane’s reported velocity and the distance
between the two reported positions failed due to the low
resolution of velocity reports.

It is worth noting here that ADS-B has a feature in which
transponders transmit position reports at discrete, known time
intervals (see A.1.4.2.3.1 of [18]). This allows a receiver to
estimate Δi,j very accurately without the need for explicit
transmission timestamps. Thus, our scheme is fully realizable
within the ADS-B standard. As of this writing, however,
the ADS-B deployment is still in an initial phase. Too few
airplanes support this mode at the moment and there are no
guarantees and information on the accuracy of the current
implementation as it is not yet certiﬁed for operational use.

Thus, we had to generate the timestamps ti artiﬁcially to
be able to apply our track veriﬁcation scheme to the data.
Therefore, we assumed that the track claimed by the airplane
was correct and used the veriﬁers positions to estimate the
propagation delay for each position report and veriﬁer. Noise
was added to these estimations in the same way as in the
previous simulations from Section VI. This way, we were able
to apply our scheme to trajectories with realistic properties
such as dilution of precision and real shapes.

As in the previous simulations,

the timestamps for the
position reports were generated with random clock drifts with
standard deviation σdrift = 20 μs/s for each airplane and
measurement error with σ = 50 ns for each timestamp. Then,
we calculated the local veriﬁcation results of all ﬂights for
each veriﬁer. In order to gain insights on the time needed to
verify a ﬂight, we replayed 50 random position reports of each
ﬂight and recalculated V x
T after the reception of each position
report.

0
8

0
6

0
4

)
s
(
 
e
m
T
n
o

 

i

i
t

a
c
i
f
i
r
e
V

0
2

0

0

10

20

30

Number of position reports (|T|)

Vx

Vy

Vx

Vy

time

e
c
n
a
t
s
i
d

Median
Mean

40

50

Fig. 11. Median and mean time needed to receive |T| position reports of 1000
ﬂights from OpenSky’s database. The mean (median) arrival rate is 0.54 (0.95)
messages per second.

Fig. 13.
Illustrative example scenario for a track which is highly linear for
Vx and non-linear for Vy. The RMSE for Vx is very small because of the
linear dependence of the distance on time. Vy cannot accurately approximate
the distance with the linear model which results in a large RMSE.

0

.
1

8
.
0

6
.
0

e
t
a
R

4
.
0

2
.
0

0
.
0

10

False Rejecection Rate
False Acceptance Rate

Honest Flights
Dishonest Flights

8
-
0
1

t
l

u
s
e
R
n
o

 

0
1
-
0
1

i
t

a
c
i
f
i
r
e
V

2
1
-
0
1

4
1
-
0
1

40

50

0

10000

20000

Linearity (RMSE)

30000

40000

20

30

Number of position reports (|T|)

Fig. 12. False rejection rate for Tlocal = mindishonest and false acceptance
rate for Tlocal = maxhonest of 1000 ﬂights recorded by one receiver of the
OpenSky Network.

B. Results
1) Veriﬁcation Time: The average and median veriﬁcation
time for different |T| is shown in Figure 11. The ADS-B
channel experiences high loss [2]. This loss results in a lower
arrival rate than the transmission rate (which is two position
reports per second). Altogether, the average message arrival
rate was 0.54 and the median rate 0.95 messages per second.
The difference in mean and median are a result of the high
loss close to the edge of the receiver’s reception range.
2) Veriﬁcation Result: The false acceptance rate for
Tlocal = maxhonest and the false rejection rate for Tlocal =
mindishonest are shown in Figure 12. For example, if we
set Tlocal such that all honest ﬂights get accepted, 2.4% of
the dishonest ﬂights get falsely accepted after 15 messages.
Conversely, setting Tlocal such that all dishonest ﬂights get
rejected, we observed a false rejection rate of 39.3%. Both,
the false acceptance and false rejection rate dropped to zero
after receiving 39 position reports.

A deeper analysis of the results revealed, that the false re-
jections and false acceptances are the result of some dishonest

Fig. 14. The local veriﬁcation result of 1000 real trajectories consisting of 50
position reports depending on their linearity. The less linear (i.e. the higher
the RMSE), the greater the difference between honest and dishonest ﬂights.

i − Δx

trajectories, which produce extremely small V x
T . The problem
are particular trajectories, on which the change in distance to
the receiving veriﬁers is monotonically and linearly increasing
or decreasing. If this is the case, the deviation of the attacker’s
signal arrivals to the expected signal arrivals (i.e. Δx
A) is
also monotonically and linearly decreasing or increasing since
Δx
A is constant. The issue is, however, that clock drift also
results in a linear deviation. As a consequence, our system
cannot distinguish between these two deviations. Our drift
estimator (Equation (8)) not only cancels out the clock drift, it
also cancels out the linear deviation caused be the adversary’s
dishonesty. This results in very small V x
T for dishonest tracks T
with a high linearity. Flights, especially en-route ﬂights, often
have a shape close to a straight line with linearly changing
Δx
i . This leads to the false acceptances in our simulations. An
illustrative example for the linearity property of a trajectory is
provided in Figure 13. The ﬂight has a high linearity for Vx
and a low linearity for Vy.

In order to further investigate this effect, we need an appro-
priate measure for the linearity property of tracks. Therefore,

210210

0
3

.

0

5
2
0

.

t

 

t

e
a
R
e
c
n
a
p
e
c
c
A
e
s
a
F

 

l

0
2

.

0

5
1

.

0

0
1
0

.

m = 10
m = 20
m = 30
m = 40
m = 50

5
0

.

0

0
0
0

.

5

10

50 100
Least Linearity (RMSE)

500

5000

Fig. 15. The false acceptance rates for Tlocal = maxhonest and different
m = |T|.

we quantiﬁed the linearity by doing a linear regression of the
distances (cid:4)(cid:2)pi − (cid:2)px(cid:4) on times ti. We then used the root-mean-
square error (RMSE) as a measure for non-linearity: the higher
the RMSE, the less linear the trajectory from the viewpoint of
Vx. Figure 14 shows the dependency of the veriﬁcation results
of 1000 ﬂights on the linearity. While the veriﬁcation result
stays constantly small for honest trajectory claims, the results
for dishonest trajectories increases along with the non-linearity
(i.e. with the RMSE).

We also considered the least required RMSE to achieve a
zero false acceptance and rejection rate for the local veriﬁ-
cation scheme. The results are shown in Figure 15. We can
conclude that the least required linearity becomes smaller the
more position reports we used to calculate V x
T .

it

As this section showed,

is challenging to deal with
linear tracks in combination with clock drift. This might
pose a problem for some scenarios. For instance, the least
number of required location claims increases if linear tracks
are considered. This is disadvantageous for scenarios where
fast detection rates are desired. To mitigate this problem, we
discuss several approaches to avoid or deal with linearity in
the next section.

C. Linearity Mitigation Approaches

Long reception ranges result in a high dilution of precision
(DOP) for tracks far away from the veriﬁers. Due to DOP,
distances between locations further away appear shorter which
leaves less room for non-linearity. To tackle this problem, we
recommend a linearity-aware placement of veriﬁers in the area
of interest. For instance, distributing the available veriﬁers
evenly across the area reduces the distances between tracks
and veriﬁers and thus the DOP. In cases where only certain
tracks are possible (e.g. provers are moving on roads or rails),
a linearity-aware placement of veriﬁers can even prevent linear
tracks completely.

Another way to deal with linearity is to reduce the least
required RMSE by bounding the estimated clock drift. If the
upper bound of clock drifts is known and ˆtx
drift exceeds it,

211211

the track claim might be dishonest. This approach is only
applicable, if the clock drift bound is lower than the linear
deviation caused by the dishonesty of the adversary.
Lastly, a collaborative scheme for estimating ˆtx

drift can
also prevent attacks which exploit linearity. Therefore, the
clock drift coefﬁcients relative to some (or all) of the other
veriﬁers must be determined. This knowledge can then be
used to agree on a global ˆtx
drift, making it impossible to
hide linear dishonesty in different clock drift estimations.
The pairwise clock drift coefﬁcients can be determined using
trusted provers. After a track with a sufﬁciently high non-
linearity has been accepted by the system, they exchange
their clock drift estimators and, by that, learn the clock drift
coefﬁcients for the other veriﬁers.

For cases in which none of the above approaches is feasible,
veriﬁers must calculate the RMSE as part of the veriﬁcation
process. Each veriﬁer can then assess whether it is in the posi-
tion to verify a track or not. Tracks too linear for veriﬁcation
should be rejected a priori in order to avoid laying the system
open to attacks.

VIII. DISCUSSION & FUTURE WORK

The strength of our track veriﬁcation scheme lies within its
simplicity. Any node which knows its own position and is able
to capture the timestamps of the received claims can calculate
V x
T . Besides that, the scheme works completely passive. Ex-
cept the track claims, there is no additional communication
between veriﬁers and provers necessary. Hence, veriﬁers are
simple devices which can be integrated into existing systems
easily. Furthermore, they can run in parallel to systems which
need to be secured without touching them.

This simplicity of our scheme enables many applications.
In some of them, different threat models might be interesting.
Therefore, we discuss several adjustments of our threat model.
A deeper analysis will be subject to future work.

A. Mobile Adversary

In section III-A, we have proven that our scheme is secure
for stationary adversaries by assuming a ﬁxed propagation
delay Δx
A. If we remove this assumption, the scheme might
not be secure anymore. However, the adversary must be able
to move in a way such that the propagation delays from the
attackers positions to all veriﬁers change exactly as they would
change on the claimed track. In scenarios where the adversary
cannot move freely (e.g. due to obstacles in a city), a mobile
adversary might not be able to claim arbitrary tracks. Yet,
this might be a valid threat in other scenarios. For instance,
if the attacker has more degrees of freedom than legitimate
nodes, it might be able to successfully claim dishonest tracks.
An example would be a vehicular ad hoc network and an
adversary that uses a helicopter or drone to claim dishonest
tracks. From a practical point of view, such an attack would
still be hard to realize since such an adversary will most likely
violate the reception area sanity check described in section V.
investigate the requirements
for successful GPS spooﬁng attacks. They derive placement

In [19], Tippenhauer et al.

constraints for a mobile attacker which tries to spoof the
GPS-derived location of several receivers. One of their results
is that the attacker’s transmission locations must lie on a
hyperboloid to spoof two receivers and on a hyperbola for
three receivers. In GPS, receivers use the TDoA of satellite
signals to calculate their locations. Since our scheme also
relies on ToA measurements, a mobile attacker would face
similar placement constraints in our scheme. In fact, pre-
liminary research on placement constraints suggests that the
additional degree of freedom of the mobile attacker can be
compensated by requiring an additional veriﬁer.

B. Adversary’s Knowledge

Another parameter of the threat model is the adversary’s
knowledge. In our security analysis, we assumed that the
attacker knows everything. In particular, it is aware of its
position and the positions of all veriﬁers. This knowledge
makes the veriﬁcation with |V | < 3 insecure.

ˇCapkun et al. proposed a scheme for secure location veriﬁ-
cation whose security is based on covert base stations (CBS)
[13]. By CBS, the authors mean veriﬁers whose locations are
not known to the attacker at the time of execution of the secure
location veriﬁcation. A potential attacker would have to guess
the CBSs positions right in order to time the transmissions of
its claims without causing inconsistencies at the veriﬁers.

This idea is also applicable to our scheme. It would beneﬁt
from CBSs in two ways. First, bypassing the reception area
sanity check is much harder if the adversary does not know
where its signal is expected. It could guess the area based
on signal propagation models, but the effort would be much
higher and the chance to be detected much larger. Second, the
number of veriﬁers required to securely verify tracks can be
reduced. In theory, just a single veriﬁer would be sufﬁcient as
long as it is covered. If the attacker is not able to estimate the
propagation delay Δx
A of its signal to veriﬁer Vx, it can only
guess ΔA and would be detected with a high probability (see
Figure 3).

Similar to CBSs, mobile veriﬁers would increase the detec-
tion probability of dishonest tracks signiﬁcantly. The adversary
must keep track of all veriﬁers to launch timing attacks and
bypass the reception area sanity check. Mobile veriﬁers are
indeed a realistic scenario. In air trafﬁc monitoring, honest
airplanes could also act as veriﬁers. Airplanes equipped with
ADS-B receivers and GPS meet all requirements for calcu-
lating V x
T for surrounding airplanes. If dishonest tracks are
detected, the pilot could warn the ground stations, e.g., using
voice communication. Another advantage of using airplanes
as veriﬁers is that at high altitudes, airplanes can have ranges
of more than thousand kilometers4. Together with the high
density of today’s air spaces, a world-wide coverage could
be easily achieved without the need of new infrastructure. In
OpenSky, a single sensor receives position reports of up to 60
airplanes at the same time during peak trafﬁc hours. Thus, high

4assuming that communication is possible if there is a line-of-sight con-

nection

numbers of veriﬁers |V | could be achieved by using trusted
airplanes for veriﬁcation.

C. Limits Of Our Scheme

As all location veriﬁcation schemes which rely on signal
arrival measurements, our scheme is not secure if an adversary
is able to transmit independent signals to all veriﬁers. The
attacker could use directional antennas or launch a coordinated
attack from different positions. In that way, it can time the
signal arrivals at the veriﬁers exactly as if they were sent
from the claimed positions. However, such attacks are very
sophisticated since they require an extremely accurate timing.
In addition to that, the attacker still has to know the exact
positions and reception ranges of all veriﬁers.

IX. RELATED WORK

This section gives a brief overview of work that is related
to ours. A more general overview of secure localization and
secure location veriﬁcation is available in [20].

1) Distance bounding protocols: Distance bounding pro-
tocols are two-way ranging protocols that rely on crypto-
graphic techniques to enable a veriﬁer to establish an upper
bound on the physical distance to a prover. These protocols
are based on timing the delay between sending out chal-
lenge bits and receiving back the corresponding response
bits. The idea was ﬁrst proposed by Brands and Chaum in
1994 [21]. Sastry et al. then proposed using it for secure
location veriﬁcation in 2003 [6]. Later, more general concepts
for using distance bounding for secure location veriﬁcation
were proposed among others by Singelee and Preneel [7]
and ˇCapkun and Hubaux [9]. Distance bounding protocols,
however, are active and require highly specialized hardware to
keep the processing time constant and as short as possible [8].
In contrast, our approach is passive and does not require any
specialized hardware or protocol.

2) Multilateration: Mutlilateration is a passive localiza-
tion technique based on the time difference of arrival (TDoA)
of signals at geographically distributed stations. Multilat-
eration is often used in radar systems for localization of
mobile targets [22] and has also been proposed for location
veriﬁcation [5], [12]. The major drawback of multilateration
is that it requires very precise time synchronization on the
order of nanoseconds at the veriﬁers. This requirement makes
the technique quite expensive and affordable only for smaller
deployments. Conversely, secure track veriﬁcation as we pro-
pose in this work does not require time synchronization which
dramatically reduces the costs of infrastructure.

The authors of [16] have used mobility-differentiated ToA
as a special form of TDoA for location surveying in sensor net-
works. However, the algorithms proposed in their work assume
non-adversarial settings whereas our approach is designed to
be secure against location spooﬁng attacks.

3) Angle-of-arrival: The location of wireless transmitters
can be estimated by using the angle-of-arrival of the incoming
signals. Systems have been proposed that rely on directional
antennas [10], [11] to prevent attacks and to localize emitters.

212212

[10] L. Hu and D. Evans, “Using Directional Antennas to Prevent Wormhole
Attacks ,” in Network and Distributed System Security Symposium
(NDSS), Feb. 2004.

[11] L. Lazos, R. Poovendran, and S.

ˇCapkun, “ROPE: Robust Position
Estimation in Wireless Sensor Networks,” in ACM/IEEE International
Symposium on Information Processing in Sensor Networks (IPSN), Apr.
2005.

[12] A. Smith, R. Cassell, T. Breen, R. Hulstrom, and C. Evers, “Methods
to Provide System-Wide ADS-B Back-Up, Validation and Security ,” in
IEEE/AIAA Digital Avionics Systems Conference, Oct. 2006.

ˇCapkun, K. Rasmussen, M.

ˇCagalj, and M. Srivastava, “Secure
location veriﬁcation with hidden and mobile base stations,” IEEE
Transactions on Mobile Computing, vol. 7, no. 4, pp. 470–483, Apr.
2008.

[13] S.

[14] M. Sch¨afer, M. Strohmeier, V. Lenders, I. Martinovic, and M. Wil-
helm, “Bringing Up OpenSky: A Large-scale ADS-B Sensor Network
for Research,” in ACM/IEEE International Symposium on Information
Processing in Sensor Networks (IPSN).

IEEE Press, April 2014.

[15] T. Schmid, “Time in wireless embedded systems,” Ph.D. dissertation,

University of California, Los Angeles, 2009.

[16] J. Luo, H. V. Shukla, and J.-P. Hubaux, “Non-Interactive Location
Surveying for Sensor Networks with Mobility-Differentiated ToA,” in
International Conference on Computer Communications (INFOCOM).
IEEE, April 2006.

[17] T. Witte and A. Wilson, “Accuracy of WAAS-enabled GPS for the deter-
mination of position and speed over ground,” Journal of Biomechanics,
vol. 38, no. 8, pp. 1717 – 1722, 2005.

[18] RTCA Inc., “Minimum Operational Performance Standards for 1090
MHz Extended Squitter Automatic Dependent Surveillance – Broadcast
(ADS-B) and Trafﬁc Information Services – Broadcast (TIS-B),” DO-
260B with Corrigendum 1, Dec. 2011.

[19] N. O. Tippenhauer, C. P¨opper, K. B. Rasmussen, and S. ˇCapkun, “On the
requirements for successful gps spooﬁng attacks,” in ACM Conference
on Computer and Communications Security (CCS), Oct. 2011.

[20] Y. Zeng, J. Cao, J. Hong, S. Zhang, and L. Xie, “Secure localization and
location veriﬁcation in wireless sensor networks: a survey,” The Journal
of Supercomputing, vol. 64, no. 3, pp. 685–701, Jun. 2013.

[21] S. Brands and D. Chaum, “Distance-bounding protocols,” in Advances

in Cryptology, ser. EUROCRYPT. Springer, 1994.

[22] J. J. Herrero, J. Portas, J. C. R. C. Corredera, J. B. Portas, and F. Ro-
driguez, “ASDE and multilateration mode-S data fusion for location and
identiﬁcation on airport surface,” in IEEE Radar Conference, Apr. 1999.
[23] S. Lakshmanan, K. Sundaresan, S. Rangarajan, and R. Sivakumar, “The
myth of spatial reuse with directional antennas in indoor wireless net-
works,” in International Conference on Passive and Active Measurement
(PAM), Apr. 2010.

[24] J. Krozel, D. Andrisani, M. Ayoubi, T. Hoshizaki, and C. Schwalm,
“Aircraft ADS-B Data Integrity Check,” in AIAA Aviation, Technology,
Integration, and Operations Conference (ATIO), Sep. 2004.

[25] K. Sampigethaya and R. Poovendran, “Visualization & assessment of
ADS-B security for green ATM,” in IEEE/AIAA Digital Avionics Systems
Conference (DASC), Oct. 2010.

[26] M. Strohmeier, V. Lenders, and I. Martinovic, “On the Security of the
Automatic Dependent Surveillance-Broadcast Protocol,” IEEE Commu-
nications Surveys & Tutorials, no. 99, 2014.

However, directional antennas with a high degree of direc-
tionality are costly and several antennas are required at each
veriﬁer in order to capture attacks from all possible directions.
In addition, angle-of-arrival methods are highly susceptible
to multi-path reﬂections of the signal [23] and directional
antennas typically exhibit side-lobes which can be exploited
by the attacker to fool the system in real-world scenarios.

4) Kalman Filters: Kalman ﬁlters are algorithms that use
a series of measurements observed over time to ﬁlter out noisy
input data and produce more accurate estimations of the output
state. Kalman ﬁlters have been proposed as a way to verify
the integrity of the tracks received from ADS-B data [24].
However as pointed out by [25], [26], Kalman ﬁlters assume
that the errors in the location claims are mainly because of
non-malicious factors such as mobility or channel interference.
Kalman ﬁlters are not secure against malicious injection of
spoofed position claims.

X. CONCLUCION

In this work, we presented a mechanism for securely verify-
ing tracks on which mobile nodes such as cars or aircraft claim
to move on. Our scheme exploits the prover’s mobility to avoid
the need for synchronization and additional communication.
Besides that,
it does not assume any restrictions on the
attacker’s knowledge. We have proven that three veriﬁers using
our scheme are able to securely detect stationary attackers.
Furthermore, we have conducted extensive simulations to ana-
lyze the performance of our scheme under realistic conditions.
We analyzed many different aspects such as error propagation,
system requirements, and practicality. In particular, we used
real trafﬁc data to demonstrate its applicability to air trafﬁc
monitoring. Based on insights from our simulations, we de-
rived requirements for a secure implementation of our scheme
and discussed different threat models.

REFERENCES

[1] T. Leinmuller, E. Schoch, and F. Kargl, “Position veriﬁcation approaches
for vehicular ad hoc networks,” IEEE Wireless Communications Maga-
zine, vol. 13, no. 5, pp. 16–21, 2006.

[2] M. Strohmeier, M. Sch¨afer, V. Lenders, and I. Martinovic, “Realities and
Challenges of NextGen Air Trafﬁc Management: The Case of ADS-B,”
IEEE Communications Magazine, vol. 52, no. 5, pp. 111–118, May
2014.

[3] Andrei Costin and Aur´elien Francillon, “Ghost is in the Air(trafﬁc): On
insecurity of ADS-B protocol and practical attacks on ADS-B devices,”
Black Hat USA, Jul. 2012, white paper.

[4] M. Sch¨afer, V. Lenders, and I. Martinovic, “Experimental Analysis of
Attacks on Next Generation Air Trafﬁc Communication,” in Applied
Cryptography and Network Security (ACNS). Springer, Jun. 2013.

[5] K. Pourvoyeur and R. Heidger, “Secure ADS-B usage in ATC tracking,”
in Tyrrhenian International Workshop on Digital Communications -
Enhanced Surveillance of Aircraft and Vehicles (TIWDC/ESAV).
IEEE,
Sep. 2014, pp. 35–40.

[6] N. Sastry, U. Shankar, and D. Wagner, “Secure veriﬁcation of location

claims,” in Workshop on Wireless Security (WiSe). ACM, 2003.

[7] D. Singelee and B. Preneel, “Location veriﬁcation using secure distance
bounding protocols,” in IEEE International Conference on Mobile Adhoc
and Sensor Systems Conference (MASS).

[8] K. B. Rasmussen and S. ˇCapkun, “Realization of RF Distance Bound-

IEEE, Nov. 2005.

ing,” in USENIX Security Symposium, 2010.

[9] S. ˇCapkun and J.-P. Hubaux, “Secure positioning of wireless devices
with application to sensor networks,” in International Conference on
Computer Communications (INFOCOM).

IEEE, March 2005.

213213

