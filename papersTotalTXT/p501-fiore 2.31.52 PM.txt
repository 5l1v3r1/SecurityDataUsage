Publicly Veriﬁable Delegation of Large Polynomials and

Matrix Computations, with Applications

Dario Fiore

New York University
ﬁore@cs.nyu.edu

ABSTRACT
Outsourced computations (where a client requests a server
to perform some computation on its behalf) are becoming in-
creasingly important due to the rise of Cloud Computing and
the proliferation of mobile devices. Since cloud providers
may not be trusted, a crucial problem is the veriﬁcation of
the integrity and correctness of such computation, possibly
in a public way, i.e., the result of a computation can be veri-
ﬁed by any third party, and requires no secret key – akin to
a digital signature on a message.

We present new protocols for publicly veriﬁable secure
outsourcing of Evaluation of High Degree Polynomials and
Matrix Multiplication. Compared to previously proposed so-
lutions, ours improve in eﬃciency and oﬀer security in a
stronger model. The paper also discusses several practical
applications of our protocols.

Categories and Subject Descriptors
K.6.5 [Management of Computing and Information
Systems]: Security and Protection

Keywords
Veriﬁable Computation, Pseudorandom Functions

1.

INTRODUCTION

The rise of Cloud Computing (a computational infras-
tructure that allows businesses to lease computing resources
from a service provider) raises several new security problems
that must be addressed by the research community. In par-
ticular, a fundamental component of any secure cloud com-
puting approach is a mechanism that enforces the integrity
and correctness of the computations done by the provider
on behalf of a client.

This problem can be modeled as following: a computa-
tionally weak client asks a powerful server to perform some
∗Work done while at IBM Research

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’12, October 16–18, 2012, Raleigh, North Carolina, USA.
Copyright 2012 ACM 978-1-4503-1651-4/12/10 ...$15.00.

Rosario Gennaro

City College of New York∗

rosario@cs.ccny.cuny.edu

computation on its behalf. The server must provide the
result of the computation together with a “certiﬁcate” of
its correctness. Crucially, the veriﬁcation of such correct-
ness proof must be substantially “easier” than the computa-
tion that was initially outsourced, since otherwise the client
would either not be able to verify the proof, or would per-
form the computation on its own to begin with. This ver-
iﬁcation mechanism should not come at the expense of in-
creasing the server’s overhead: in other words producing the
certiﬁcate should be “almost for free” for the server, which
might provide this service to many clients, and therefore it
should not become a computational bottleneck.

Outsourced computations are also increasingly important
for mobile devices, such as smart phones and netbooks,
which might resort to a network server to perform heavy
computations, e.g., a cryptographic operation or a photo
manipulation. Here too, an eﬃciently veriﬁable proof of the
correctness might be required.

An important question is whether the veriﬁcation of the
computation can be public: i.e., can any third party (possi-
bly diﬀerent from the client who outsourced the computa-
tion) verify it? This is important, for example, in contexts
where the computation has to be checked by several clients
who cannot necessarily share a secret key, or if the proof
of correctness must be transferable – similarly to a digital
signature on a message.

Our Contributions. The main results of this paper are
two new protocols for publicly veriﬁable secure outsourcing
of:

• Evaluation of High Degree Polynomials. In this case
the client stores a large (degree d) polynomial F with
the server and then requests the value y = F (x) for
several inputs x.

• Matrix Multiplication. Here the client stores a large
(n× d) matrix M with the server and then provides an
d-dimensional vector (cid:126)x and obtains (cid:126)y = M · (cid:126)x. Note
that this immediately generalizes to matrix multipli-
cation (providing input M(cid:48) and obtaining Y = M · M(cid:48)
by applying the above solution to each column of M(cid:48)).

Our schemes are in the amortized model of [8] in which the
client invests a one-time expensive computation phase (O(d)
in the polynomial case, O(nd) in the matrix case) when stor-
ing the data with the server. Then veriﬁcation of each eval-
uation will be fast (o(d) and o(nd) respectively).
Other Contributions: As a crucial tool to establish our
results, we rely on the use of pseudo-random functions with

501closed-form eﬃciency (as deﬁned in [4]). However for our
purposes we had to extend the deﬁnition in [4] to handle
larger classes of functionalities (for example we could not
see how to use the deﬁnition in [4] to handle matrix multi-
plication). Moreover, we develop new such PRFs based on
the Decisional Linear Assumption, that in particular can be
used in groups with bilinear maps. Both our new deﬁnition
and the new construction might be of independent interest.
Finally we discuss “multi-function” extensions of our pro-
tocols: this is the dual case in which the client stores a large
(say (cid:96)) number of inputs with the server in advance, and
then later queries diﬀerent functions (F or M ). Here the
technical challenge is that the authentication information
stored with the inputs must be ”oblivious” to any function
that will be applied later.
Applications: As discussed in [4], polynomial computa-
tions have a large number of applications, which – using our
solutions – now have publicly veriﬁable proofs:

• Proof of Retrievability: The client stores a large ﬁle
F with the server and later wants a short proof that
the entire ﬁle can be retrieved. Using our solution, the
client encodes the ﬁle as a polynomial F (x) of degree d
(each block representing a coeﬃcient), and a proof of
retrievability consists of the value F (r) together with a
proof of its correctness for a random input r provided
by the client.

• Veriﬁable Keyword Search: Consider a text ﬁle T =
{w1, . . . , w(cid:96)} where wi are the words contained in it.
Using our solution, encode T as the polynomial F (·)
of degree (cid:96) such that F (wi) = 0.

• Discrete Fourier Transform: Both our polynomial and
matrix protocols can be adapted to obtain a fast veriﬁ-
able computation protocol for the DFT. The challenge
here is that using the FFT algorithm such computa-
tion is already almost linear – O(n log n) – and there-
fore the veriﬁcation time had to be minimal, i.e., O(n)
linear in the input size.

• Linear Transformations: Consider the general problem
of applying a geometric transformation (such as the
ones largely used in computer graphics) to large d-
dimensional vectors. Since a linear transformation on
a vector (cid:126)x can be expressed by a matrix M (of size
n × d) multiplying (cid:126)x, a weak client can use our matrix
protocol to outsource and verify this computation in
the optimal time O(n + d), i.e., linear in the input and
the output size.

1.1 Related Work

The subject of veriﬁable outsourced computation has a
large body of prior work. In the theoretical arena this basic
question motivated the work on Interactive Proofs [2, 11], ef-
ﬁcient arguments based on probabilistically checkable proofs
(PCP) [13, 14], CS Proofs
[17] and the muggles proofs in
[10]. However, in PCP-based schemes, the client must store
the large data in order to verify the result, and therefore
these solutions might not be applicable to our setting. In
the past, more practical solutions, but of limited provable
security, were also proposed: e.g., solutions based on audit
(e.g. [19, 3]) or secure co-processors (e.g. [22, 23]) which
”sign” the computation as correct, under the assumption
that the adversary cannot tamper with the processor.

As mentioned above, our work follows the paradigm in-
troduced in [8] which is also adopted in [7, 1]. The protocols
described in those papers allow a client to outsource the
computation of an arbitrary function (encoded as a Boolean
circuit) and use fully homomorphic encryption (i.e. [9]) re-
sulting in solutions of limited practical relevance.

We follow [4] by considering only a very limited class of
computations in order to obtain better eﬃciency. In [4] the
problem of practical protocols for veriﬁable computation of
polynomials was ﬁrst proposed, however their solution only
oﬀers private veriﬁability. The problem of outsourcing lin-
ear algebra operations, such as matrix multiplications, has
been recently considered by Mohassel in [18]. The proposed
solutions are in a diﬀerent model, they oﬀer only private
veriﬁability, and allow to hide the computation’s inputs to
the server.

To the best of our knowledge, apart from the work of
[21] described below, no other prior work in the literature
discusses the multi-function case.
1.2 Recent Works with Public Veriﬁcation

Recently two works have considered public veriﬁcation
[20, 21]. Here we give a detailed comparison of their results
with our solutions.

Papamanthou, Shi and Tamassia in [20] consider the
case of polynomial evaluation. Their solutions are secure
under the d-SDH assumption which asymptotically depends
on the degree of the polynomial.
In contrast, an advan-
tage of our work is to achieve security under a “constant”
size assumption, which is independent of the size of the in-
put. Furthermore, our solutions can handle a larger class
of polynomial functions: their scheme supports polynomials
in m variables and total degree d – which we also support
– but we additionally consider also polynomials of degree
d in each variable. For the case we both support, we en-
joy a much faster veriﬁcation protocol: a constant amount
of work (one pairing computation and one exponentiation)
while they require O(m) pairings1.

Parno, Raykova and Vaikuntanathan in [21] explore
a connection between Attribute-Based Encryption and the
problem of veriﬁable computation, showing that for any
function for which an eﬃcient ABE exists, we can construct
an eﬃcient publicly veriﬁable computation scheme. The
class of functions for which we know an eﬃcient ABE scheme
is unfortunately very limited, and therefore the scheme in
[21] does not work for any arbitrary poly-time computa-
tion. However, it does work for computations that can be
expressed as poly-size Boolean Formulas, which in particu-
lar include polynomial evaluation and matrix multiplication.
Compared to [21], our scheme has three major advantages:
(i) when evaluating a polynomial/matrix over a ﬁeld with p
elements, the scheme in [21] incurs a multiplicative overhead
of O(log p) in its complexity compared to ours as they must
express the computation as a Boolean formula (i.e. bit by
bit)2; (ii) our protocol enjoys faster veriﬁcation, a constant

1In contrast the delegation phase is basically free in their
case, while our delegation step requires O(md) work – note
however that in publicly veriﬁable scheme, the veriﬁcation
algorithm might be run several times and therefore its eﬃ-
ciency is more important.
2One should remark that in our scheme the ﬁeld size p is
the same p as the order of the underlying bilinear groups

502amount of computation, whereas in [21] the veriﬁcation has
a O(log p) overhead; (iii) the result published in [21] is secure
only under a weaker “selective” notion of security, where the
adversary must commit in advance to the input point x on
which it is going to cheat (i.e. provide the client with an in-
correct value y(cid:48) (cid:54)= F (x)). In contrast, our protocols achieve
full security.

The selective security limitation in [21] is inherited from
the speciﬁc ABE scheme used in their protocol (the one
in [12]). Recently, a new ABE scheme has been presented
that removes the selective security issue [15], and therefore
when combined with [21] should yield a fully secure veriﬁ-
able computation solution. The eﬃciency of this new scheme
is no better than the original one in [21]. Moreover, the
new ABE scheme in [15] also requires a “non-constant-size”
computational assumption that depends on the size of the
Boolean Formula (i.e., of the polynomial or of the matrix,
when instantiated in [21]). Again our protocol only requires
constant-size assumptions.

In Table 1 we summarize a “features comparison” between

our scheme and these two recent schemes (and also [4]).

Properties

Const.
Secur. Assump.

Schemes

BGV11 [4]
PST11 [20]
PRV12 [21]

+ GPSV06 [12]

PRV12 [21]
+ LW12 [15]
This work

Public
Verif.
×
(cid:88)
(cid:88)
(cid:88)
(cid:88)

Full
(cid:88)
(cid:88)
×
(cid:88)
(cid:88)

Const.
Verif.
(cid:88)
×
×
×
(cid:88)

(cid:88)
×
(cid:88)
×
(cid:88)

Table 1: Comparisons with related work.

1.3 An overview of our solutions
Polynomial Evaluation. Our starting point is the proto-
col of [4]: assume the client has a polynomial F (·) of large
degree d, and it wants to compute the value F (x) for arbi-
trary inputs x. In [4] the client stores the polynomial in the
clear with the server as a vector of coeﬃcients ci in Zp. The
client also stores with the server a vector of group elements
ti of the form gaci+ri where g generates a cyclic group G of
order p, a ∈R Zp, and ri is the ith-coeﬃcient of a polynomial
R(·) of the same degree as F (·). When queried on input x,
the server returns y = F (x) and t = gaF (x)+R(x), and the
client accepts y iﬀ t = gay+R(x).
If R(·) was a random polynomial, then this is a secure
way to authenticate y, however checking that t = gay+R(x)
would require the client to compute R(x) – the exact work
that we set out to avoid! The crucial point, therefore, is
how to perform this veriﬁcation fast, i.e., in o(d) time. The
fundamental tool in [4] is the introduction of pseudo-random
functions (PRFs) with a special property called closed-form
eﬃciency: if we deﬁne the coeﬃcients ri of R(·) as P RFK (i)
(which preserves the security of the scheme), then for any
input x the value gR(x) can be computed very eﬃciently
(sub-linearly in d) by a party who knows the secret key K
for the PRF.

that we use to cryptographically prove security, therefore
our solution cannot handle small ﬁeld sizes.
In contrast,
[21] supports polynomials over any ﬁeld, in particular Z2.

Note, however, that this approach implies a private ver-
iﬁcation algorithm by the same client who outsourced the
polynomial in the ﬁrst place, since it requires knowledge of
the secret key K. To make this veriﬁcation public we ex-
tended these techniques as follows. First we use a cyclic
group G that admits a bilinear map e(·,·) from G × G to a
target group GT . Informally, (the actual protocol is slightly
more complicated), when the client sends x to the server it
also computes a public veriﬁcation key for x, A = e(g, g)a
and VKx = e(g, g)R(x) – note that this step will take o(d)
time thanks to the closed-form eﬃciency of the PRF. When
the server returns y, t, anybody who knows3 the correct
A, VKx can verify it by checking that e(t, g) = Ay · VKx.

A technical complication is that the PRFs in [4] are based
on the hardness of the Decisional Diﬃe-Hellman problem
which however is easy on groups that admit bilinear maps.
The ﬁrst solution we propose to this problem is to instantiate
our protocol in asymmetric bilinear groups, and assume that
these PRFs are secure based on the External Diﬃe-Hellman
Assumption. More interestingly, however, we also present
new solutions that rely on the much weaker Decision Linear
Assumption over bilinear groups, by devising closed-form
eﬃcient variants of the Lewko-Waters PRF [16]. This result
can be of independent interest.

As in [4], we have solutions not just for single-variable
polynomials of degree d, but also for multivariate polynomi-
als of degree d in each variable and of total degree d.
Matrix Multiplication. The client stores a n × d ma-
trix M = (mi,j) with the server and wants to compute the
value (cid:126)y = M · (cid:126)x for a d-dimensional vector (cid:126)x; the goal is to
verify y in O(n + d). Our solution also uses the concept of
closed-form eﬃcient PRFs: the client stores the matrix in
the clear together with another matrix W whose elements
are group elements of the form Wi,j = gami,j +ri,j , where
a ∈R Zp, and ri,j = P RFK (i, j) deﬁnes a n × d pseudo-
random matrix R. We propose new PRFs with closed-form
eﬃciency for matrix-vector multiplication, i.e., such that the
vector gR·(cid:126)x can be computed in time O(n + d) by somebody
who knows the key K. The veriﬁcation then proceeds as
in the polynomial case. The server returns (cid:126)y = M · (cid:126)x and
(cid:126)t = W · (cid:126)x (computed in the exponent) and private veriﬁca-
tion can be obtained by having the client check the vector
of equations (cid:126)t = ga(cid:126)y+R(cid:126)x using the closed form eﬃciency
for computing gR(cid:126)x eﬃciently. Public veriﬁcation can be ob-
tained by having the client publish A = e(g, g)a and the vec-
tor VKx = e(g, g)R·x (again computed fast using closed-form
eﬃciency of the PRF), and then anybody can verify the fol-
lowing vector equation e((cid:126)t, g) = A(cid:126)y · VKx (component-wise).
1.4 Paper Organization

In Section 2 we recall the security deﬁnitions and the com-
putational assumptions needed by our protocols.
In Sec-
tion 3 we present our new PRFs with closed form eﬃciency
based on the Decision Linear Assumption, which are the ba-
sic tools used by our protocols described in Section 4. We
discuss multi-function extensions of our techniques in Sec-

3Here we can assume that the client has a way of reliably
publishing the values A, VKx. One possible way is for the
client to sign them and give them to the server together with
x in the input submission state. The server then will have
to include the signed A, VKx in the “correctness proof” and
the veriﬁcation algorithm must also check the validity of the
client’s signature.

503tion 5, while the DFT application is discussed in Section
6.
2. BACKGROUND AND DEFINITIONS

In what follows we will denote with λ ∈ N a security pa-
rameter. We say that a function  is negligible if it vanishes
faster than the inverse of any polynomial. If S is a set, we
denote with x $← S the process of selecting x uniformly at
random in S. Let A be a probabilistic algorithm. We denote
with x $← A(·) the process of running A on some appropriate
input and assigning its output to x.
2.1 Computational Assumptions

The co-Computational Diﬃe-Hellman problem was intro-
duced by Boneh, Lynn and Shacham as a natural gener-
alization of the Computational Diﬃe-Hellman problem in
asymmetric bilinear groups [6]. It is deﬁned as follows.

Definition 1

(co-CDH). Let G1, G2, GT be groups of
prime order p, so that e : G1 × G2 → GT is a bilinear map.
Let g1 ∈ G1, g2 ∈ G2 be generators, and a, b $← Zp be chosen
at random. We deﬁne the advantage of an adversary A in
solving the co-Computational Diﬃe-Hellman problem as

AdvcdhA (λ) = Pr[A(p, g1, g2, ga

1 , gb

2) = gab
1 ]

We say that the co-CDH Assumption -holds in G1, G2 if for
every PPT algorithm A we have that AdvcdhA (λ) ≤ .
Notice that in symmetric bilinear groups, where G1 = G2,
this problem reduces to the standard CDH. For asymmetric
groups, it is also easy to see that co-CDH reduces to the
computational Bilinear Diﬃe-Hellman problem [5].

As it is well known the decisional version of the CDH As-
sumption (where the adversary cannot distinguish gab
from
1
a random value) is easy in symmetric bilinear groups where
G1 = G2. However in the case of asymmetric bilinear groups
G1, G2 where G1 (cid:54)= G2, then the DDH problem may still be
hard in G1. This is called External Diﬃe-Hellman (XDH)
assumption stated below.

Definition 2

(XDH). Let g1, g2, G1, G2, GT be as in
[1]. We deﬁne the advantage AdvxdhA (λ) of an ad-
Def.
versary A in deciding the External Diﬃe-Hellman (XDH)
problem as
| Pr[A(p, g1, g2, ga
1) = 1]|
where a, b, c $← Zp. We say that the XDH Assumption -
holds over G1, G2, GT if for every PPT algorithm A we have
that AdvxdhA (λ) ≤ .

1 ) = 1] − Pr[A(p, g, ga

1, gab

1 , gb

1 , gb

1, gc

An assumption more general than XDH which we are go-

ing to use in our protocols is Decision Linear.

Definition 3

(Decision Linear). Let G be a group of
$← Zp. We de-
prime order p, g0, g1, g2
ﬁne the advantage of an adversary A in deciding the Linear
problem in G as

$← G, and r0, r1, r2

AdvdlinA (λ) = | Pr[A(p, g0, g1, g2, gr1

1 , gr2
Pr[A(p, g0, g1, g2, gr1

2 , gr1+r2
1 , gr2
2 , gr0

0

) = 1]−
0 ) = 1]|

We say that the Decision Linear Assumption -holds in G if
for every PPT algorithm A we have AdvdlinA (λ) ≤ .
We note that we do not know of an eﬃcient way to solve the
Linear Problem even if the group G admits an eﬃciently
computable bilinear map.

2.2 Veriﬁable Computation

A veriﬁable computation scheme is a tuple of distributed
algorithms that enable a client to outsource the computation
of a function f to an untrusted worker, in such a way that
the client can verify the correctness of the result returned
by the worker. In order for the outsourcing to make sense,
it is crucial that the cost of veriﬁcation at the client must
be cheaper than computing the function locally.

In our work we are interested in computation schemes that
are publicly veriﬁable as deﬁned by Parno et al.
[21]: any
third party (possibly diﬀerent from the delegator) can verify
the correctness of the results returned by the worker.
Let F be a family of functions. A Veriﬁable Computation
scheme VC for F is deﬁned by the following algorithms:
KeyGen(1λ, f ) → (SKf , PKf , EKf ): on input a function f ∈
F, it produces a secret key SKf that will be used for
input delegation, a public veriﬁcation key PKf , used
to verify the correctness of the delegated computation,
and a public evaluation key EKf which will be handed
to the server to delegate the computation of f .

ProbGen(PKf , SKf , x) → (σx, VKx): given x ∈ Dom(f ), the
problem generation algorithm is run by the delegator
to produce an encoding σx of x, together with a public
veriﬁcation key VKx.

Compute(EKf , σx) → σy: given the evaluation key EKf and
the encoding σx of an input x, this algorithm is run by
the worker to compute an encoded version of y = f (x).
Verify(PKf , VKx, σy) → y ∪ ⊥: on input the public key PKf ,
the veriﬁcation key VKx, and an encoded output σy,
this algorithm returns a value y or an error ⊥.

Correctness. Informally, a veriﬁable computation scheme
VC is correct if the values generated by the problem gen-
eration algorithm allows a honest worker to output values
that will verify correctly. More formally, for any f ∈ F,
any (SKf , PKf , EKf ) $← KeyGen(1λ, f ), any x ∈ Dom(f ), if
(σx, VKx) $← ProbGen(PKf , SKf , x) and σy←Compute(EKf ,
σx), then f (x)←Verify(PKf , VKx, σy) holds with all but neg-
ligible probability.
Security. For any veriﬁable computation scheme VC, let
us deﬁne the following experiment:

Experiment ExpPubVerA

[VC, f, λ]

(SKf , PKf , EKf ) $← KeyGen(1λ, f )
For i = 1 to q:

xi←A(PKf , EKf , σx,1, VKx,1, . . . , σx,i−1, VKx,i−1)
(σx,i, VKx,i) $← ProbGen(SKf , xi)

x∗←A(PKf , EKf , σx,1, VKx,1, . . . , σx,q, VKx,q)
(σx∗ , VKx∗ ) $← ProbGen(SKf , x∗)
ˆσy←A(PKf , EKf , σx,1, VKx,1, . . . , σx,q, VKx,q, σx∗ , VKx∗ )
ˆy←Verify(PKf , VKx∗ , ˆσy)
If ˆy (cid:54)= ⊥ and ˆy (cid:54)= f (x∗), output 1, else output 0.

For any λ ∈ N, any function f ∈ F , we deﬁne the advantage
of an adversary A making at most q = poly(λ) queries in
the above experiment against VC as

AdvPubVerA

(VC, f, q, λ) = Pr[ExpPubVerA

[VC, f, λ] = 1].

504Definition 4. A veriﬁable computation scheme VC is se-
cure for F if for any f ∈ F, and any PPT A it holds that
AdvPubVerA

(VC, f, q, λ) is negligible.

Note that our deﬁnition captures full adaptive security, in
which the adversary decides “on the ﬂy” on which input x∗
it will try to cheat. The weaker selective security notion
achieved in [21] requires the adversary to commit to x∗ at
the beginning of the game.

3. CLOSED FORM EFFICIENT PRF

The notion of closed form eﬃcient pseudorandom func-
tions was introduced in [4]. Their deﬁnition however seemed
geared speciﬁcally towards the application of polynomial
evaluation and therefore proved insuﬃcient for our matrix
multiplication protocol. Here we extend it to include any
computations run on a set of pseudo-random values and a
set of arbitrary inputs.

A closed form eﬃcient PRF consists of a tuple of algo-
rithms (PRF.KG, F). The key generation PRF.KG takes as
input the security parameter 1λ, and outputs a secret key K
and some public parameters pp that specify domain X and
range Y of the function. On input x ∈ X , FK (x) uses the
secret key K to compute a value y ∈ Y. It must of course
satisfy the usual pseudorandomness property. Namely, a
PRF (PRF.KG, F) is -secure if for every PPT adversary A
it holds:

˛˛˛Pr[AFK (·)(1λ, pp) = 1] − Pr[AR(·)(1λ, pp) = 1]
˛˛˛ ≤ 

where (K, pp) $← PRF.KG(1λ), and R(·) is a random function
from X to Y.

In addition, it is required to satisfy the following closed-
form eﬃciency property. Consider an arbitrary computation
Comp that takes as input (cid:96) random values R1, . . . , R(cid:96) ∈ Y
and a vector of m arbitrary values (cid:126)x = (x1, . . . , xm), and as-
sume that the best algorithm to compute Comp(R1, . . . , R(cid:96),
x1, . . . , xm) takes time T . Let z = (z1, . . . , z(cid:96)) a (cid:96)-tuple of
arbitrary values in the domain X of F. We say that a PRF
(PRF.KG, F) is closed-form eﬃcient for (Comp, z) if there
exists an algorithm PRF.CFEvalComp,z such that

PRF.CFEvalComp,z(K, x) =

Comp(FK (z1), . . . , FK (z(cid:96)), x1, . . . , xm)

and its running time is o(T ). For z = (1, . . . , (cid:96)) we usually
omit the subscript z.
Note that depending on the structure of Comp, this prop-
erty may enforce some constraints on the range Y of F. In
particular in our case, Y will be an abelian group. We also
remark that due to the pseudorandomness property the out-
put distribution of PRF.CFEvalComp,z(K, x) (over the ran-
dom choice of K) is indistinguishable from the output dis-
tribution of Comp(R1, . . . , R(cid:96), x1, . . . , xm) (over the random
choices of the Ri).
3.1 Closed-Form Efﬁcient PRFs based on De-

cision Linear

In this section we show constructions of pseudorandom
functions that enjoy closed-form eﬃciency for multivariate
polynomials, and matrix multiplication. Their security is
based on the Decision Linear assumption.

3.1.1 Polynomials of degree d in each variable
As our ﬁrst construction, we show that the PRF of Lewko
and Waters [16] has closed form eﬃciency for polynomials
in m variables and degree at most d in each variable.

First, we recall the construction PRFLW of this PRF.

PRF.KG(1λ, s, m). Generate a group description (p, g, G) $←

G(1λ). Choose 4ms + 2 values

y0, z0,{yi,j, zi,j, wi,j, vi,j}1≤i≤m, 1≤j≤s
Output K = (y0, z0,{yi,j, zi,j, wi,j, vi,j}i,j).

$← Zp

FK (i). The domain of the function is i = (i1, . . . , im) ∈
[0..d]m, but we interpret each ij = (ij,1, . . . , ij,s) as
a binary string of s = (cid:100)log d(cid:101) bits. The function is
computed by the following algorithm:

Initialize a←y0, b←z0
For j = 1 to m:
For k = 1 to s:
If ij,k = 0, then a←a, b←b.
Else, a←a · yj,k + b · zj,k, b←a · wj,k + b · vj,k

Output ga

Except for a few changes in the notation, the function
above is the same as the one in [16]. Therefore, its security
follows from the following theorem.

Theorem 5

holds for G, then PRFLW is a pseudorandom function.

([16]). If the Decision Linear assumption

In what follows we show that PRFLW admits closed form

eﬃciency for polynomials.

Consider any polynomial p(x1, . . . , xm) in m variables of
degree at most d in each variable. This polynomial has up
to l = (d + 1)m terms which we can index with (i1, . . . , im)
with each 0 ≤ ij ≤ d. Our goal is to compute

Poly({R(i1,...,im)}0≤i1,...,im≤d, x1, . . . , xm) =

Y

0≤i1,...,im≤d

Y

0≤i1,...,im≤d

(x

1 ···xim
i1
m )

R

(i1,...,im) = gp(x1,...,xm)

where p(·) is the polynomial whose coeﬃcients are the dis-
crete logs of the R values. We now show that if we set
R(i1,...,im) = FK (i1, . . . , im), then there exists an algorithm
PRF.CFEvalPoly(K, x1, . . . , xm) that can compute

gp(x1,...,xm) =

FK (i1, . . . , im)x

1 ···xim
i1

m

in time O(m log d), instead of the regular computation run-
ning in time O(dm · m · log d).

For ease of exposition, we ﬁrst describe an alternative
equivalent algorithm for computing FK (i1, . . . , im). Let i =
(i1, . . . , im) and denote by fK (i) = (f 1
K (i)) the follow-
ing recursive function:

K (i), f 2

K (0) = y0 and f 2

If i1 = ··· = im = 0, then f 1
K (0) = z0.
Else:
let ¯m be such that i ¯m+1 = ··· = im = 0 and i ¯m (cid:54)= 0.
let i ¯m = 2j ¯m + (cid:96) ¯m for j ¯m = (cid:98)log i ¯m(cid:99), 0 ≤ (cid:96) ¯m ≤ 2j ¯m − 1
K (i1, . . . , im) = f 1
f 1
K (i1, . . . , i ¯m−1, (cid:96) ¯m, 0, . . . , 0)y ¯m,j ¯m+1+
f 2
K (i1, . . . , i ¯m−1, (cid:96) ¯m, 0, . . . , 0)z ¯m,j ¯m+1
K (i1, . . . , im) = f 1
f 2
K (i1, . . . , i ¯m−1, (cid:96) ¯m, 0, . . . , 0)w ¯m,j ¯m+1+
f 2
K (i1, . . . , i ¯m−1, (cid:96) ¯m, 0, . . . , 0)v ¯m,j ¯m+1

505Finally, the value of the function is FK (i) = gf 1

K (i).

Using this notation, we can now write

p(x1, . . . , xm) =

0≤i1,...,im≤d

f 1
K (i1, . . . , im)xi1

1 ··· xim

m

X

PRF.CFEvalPoly(K, x1, . . . , xm).
For j = 1, . . . , m, set sj = (cid:100)log d(cid:101), and ps1,...,sm (x1, . . . , xm)
= (p1
s1,...,sm (x1, . . . , xm)) be the fol-
lowing recursive function:

s1,...,sm (x1, . . . , xm), p2
If s1 = s2 = ··· = sm = 1, then:
p1
s1,...,sm (x1, . . . , xm) = y0, p2
s1,...,sm (x1, . . . , xm) = z0.
Else
let ¯m be such that s ¯m+1 = ··· = sm = 1 and s ¯m > 1.
p1
s1,...,sm (x1, . . . , xm) = p1
s1,...,s ¯m−1,0,...,0(x1, . . . , xm)+
s1,...,s ¯m−1,0,...,0(x1, . . . , xm)y ¯m,s ¯m +
p2
s1,...,s ¯m−1,0,...,0(x1, . . . , xm)z ¯m,s ¯m

x2s ¯m−1

¯m

p2
s1,...,sm (x1, . . . , xm) = p2

x2s ¯m−1

¯m

s1,...,s ¯m−1,0,...,0(x1, . . . , xm)+
s1,...,s ¯m−1,0,...,0(x1, . . . , xm)w ¯m,s ¯m +
p2
s1,...,s ¯m−1,0,...,0(x1, . . . , xm)v ¯m,s ¯m

`p1
`p1

´
´

The algorithm outputs gp(x1,...,xm) = gp1
We prove correctness of PRF.CFEvalPoly(K, x1, . . . , xm) by
induction on s1, . . . , sm. If s1 = ··· = sm = 1, then it is not
hard to see that the algorithm is correct. Without loss of
generality, assume that sm > 1. If the algorithm is correct
for (s1, . . . , sm − 1), i.e., p1

s1,...,sm−1(x1, . . . , xm) is

(x1,...,xm).

s1 ,...,sm

f 1
K (i1, . . . , im)xi1

1 ··· xim

m

i1,...,im−1≤d,im=0

and p2

s1,...,sm−1(x1, . . . , xm) is

2sm−1−1X

2sm−1−1X

f 2
K (i1, . . . , im)xi1

1 ··· xim

m

i1,...,im−1≤d,im=0

Then we show correctness for s1, . . . , sm.

First, by deﬁnition of our algorithm we have:
s1,...,sm (x1, . . . , xm) = p1
p1

·`p1

x2sm−1

m

s1,...,sm−1(x1, . . . , xm) +
s1,...,sm−1(x1, . . . , xm)ym,sm +
p2
s1,...,sm−1(x1, . . . , xm)zm,sm

´

If we then apply our inductive assumption we obtain:

f 1
K (i1, . . . , im)xi1

1 ··· xim

m + x2sm−1

m

·

2sm−1−1X
0@

i1,...,im−1≤d,im=0

2sm−1−1X

i1,...,im−1≤d,im=0

(f 1

K (i1, . . . , im)ym,sm +

”

1 ··· xim
Next, we can apply the deﬁnition of fK (i1, . . . , im):

f 2
K (i1, . . . , im)zm,sm )xi1

m

2sm−1−1X

i1,..,im−1≤d,im=0

2sm−1−1X

i1,..,im−1≤d,im=0

f 1
K (i1, .., im)xi1

1 ··· xim

m + (

K (i1, .., im + 2sm−1)xi1
f 1

1 ..xim+2sm−1

m

)

Finally, by simple rewriting this equation, we obtain:

2sm−1−1X
2sm−1X

i1,...,im−1≤d,im=0

0@

i1,...,im−1≤d,im=2sm−1

2sm−1X

=

i1,...,im−1≤d,im=0

f 1
K (i1, . . . , im)xi1

1 ··· xim

m +

f 1
K (i1, . . . , im)xi1

1 ··· xim

m

1A

f 1
K (i1, . . . , im)xi1

1 ··· xim

m

d

Analogously, one can show correctness of p2
xm).

s1,...,sm (x1, . . . ,

The algorithm makes only one recursive call at each step,

and thus it runs in time O(m log d).
3.1.2 Polynomials of degree d in each monomial
We show a variation of the PRF by Lewko and Waters,
described in the previous section, that achieves closed form
eﬃciency for polynomials in m variables and degree at most
d in each monomial. The previous construction PRFLW is
more general as it can support any polynomials where d is
an upper bound on each variable’s degree. However, PRFLW
is tailored to that type of polynomials that have (d + 1)m
terms. In contrast, m-variate polynomials of total degree d

´ = O(md) terms. These two quantities seem in-

have`m+d

comparable as they crucially depend on the size of m vs. d.
In particular, the PRFLW construction may not be suitable
for this case. So, here we propose another variant, which of-
fers closed form eﬃciency for m-variate polynomials of total
degree at most d.

Our construction PRFeLW works as follows.

PRF.KG(1λ, d, m). Generate a group description (p, g, G) $←

G(1λ). Choose 4(m + 1)d + 2 values

y0, z0,{yi,j, zi,j, wi,j, vi,j}1≤i≤d, 0≤j≤m
Output K = (y0, z0,{yi,j, zi,j, wi,j, vi,j}i,j).

$← Zp

FK (i). The domain of the function is i = (i1, . . . , id) ∈
[0..m]d, and we interpret each ij as an integer in [0..m].
The function FK (i1, . . . , id) is computed by the follow-
ing algorithm:

Initialize a←y0, b←z0
For j = 1 to d:
a←a · yj,ij + b · zj,ij , b←a · wj,ij + b · vj,ij
Output ga

This function can be seen as an extension of PRFLW as
follows. First, each ij is in [0..m] instead of [0..1]. Second,
the algorithm instead of “copying” a and b when ij = 0, it
always makes a new linear combination.

Theorem 6. If the Decision Linear assumption holds for

G, then PRFeLW is a pseudorandom function.

The proof of the theorem can be obtained by extending the
proof in [16] and is given in the full version of the paper.

In what follows we show that PRFeLW admits closed form
eﬃciency for polynomials p(x1, . . . , xm) in m variables and

total degree at most d. Such polynomials have`m+d

´ terms,

d

506but for our purposes we use slightly more values to deﬁne
the coeﬃcients: R1, . . . , Rl, for l = (m + 1)d. We interpret
each 1 ≤ i ≤ l as (i1, . . . , id), with each 0 ≤ ij ≤ m. We
want to compute

Poly({R(i1,...,id)}0≤i1,...,id≤m, x1, . . . , xm) =

Y

0≤i1,...,id≤m

Qd
j=1 xij
(i1,...,id) = gp(x1,...,xm)

R

We now show that if we set R(i1,...,id) = FK (i1, . . . , id)
(and we denote x0 = 1), then there exists an algorithm
PRF.CFEvalPoly(K, x1, . . . , xm) that can compute

gp(x1,...,xm) =

FK (i1, . . . , id)

j=1 xij

Qd

Y

0≤i1,...,id≤m

in time O(md), instead of the regular computation running
in time O(dmd).

For ease of exposition, we ﬁrst describe an alternative
equivalent algorithm for computing FK (i1, . . . , im). Denote
by fK (i) = (f 1

K (i)) the following recursive function:

K (i), f 2

Let i = (i1, . . . , id)
If i1 = ··· = id = *, then
K (*, . . . , *) = y0 and f 2
f 1
Else:
let ¯d be such that i ¯d+1 = ··· = id = * and i ¯d (cid:54)= *.
K (i1, . . . , i ¯d, *, . . . , *) = f 1
f 1

K (*, . . . , *) = z0.

K (i1, . . . , i ¯d−1, *, . . . , *)y ¯d,j ¯d

+

f 2
K (i1, . . . , i ¯d−1, *, . . . , *)z ¯d,j ¯d

K (i1, . . . , i ¯d, *, . . . , *) = f 1
f 2

K (i1, . . . , i ¯d−1, *, . . . , *)w ¯m,j ¯d +

f 2
K (i1, . . . , i ¯d−1, *, . . . , *)v ¯d,j ¯d

Finally, the function’s output is FK (i1, .., id) = gf 1

K (i1,...,id).

Using this notation, we can write

p(x1, . . . , xm) =

FK (i1, . . . , id)

xij

X

0≤i1,...,id≤m

dY

j=1

PRF.CFEvalPoly(K, x1, . . . , xm).
Let pd(x1, . . . , xm) = (p1
following recursive function (where −1 is denoted by *):

d(x1, . . . , xm), p2

d(x1, . . . , xm)) be the

If d = *, then:

p1
* (x1, . . . , xm) = y0, p2

Else:

d(x1, . . . , xm) = p1
p1
p2
d(x1, . . . , xm) = p1
p2
p2

* (x1, . . . , xm) = z0.

d−1(x1, . . . , xm)Pm
d−1(x1, . . . , xm)Pm
d−1(x1, . . . , xm)Pm
d−1(x1, . . . , xm)Pm

k=0 xkyk,ik +
k=0 xkzk,ik
k=0 xkwk,ik +
k=0 xkvk,ik

Finally, the algorithm outputs gp(x1,...,xm) = gp1

d(x1,...,xm).

We prove correctness of PRF.CFEvalPoly(K, x1, . . . , xm) by
induction on d. If d = *, then the algorithm is clearly cor-
rect. Without loss of generality, assume that d (cid:54)= *. If the
algorithm is correct for d − 1, i.e.,

X
X

p1
d−1(x1, . . . , xm) =

p2
d−1(x1, . . . , xm) =

f 1
K (i1, . . . , id−1, *)

0≤i1,...,id−1≤m

f 2
K (i1, . . . , id−1, *)

0≤i1,...,id−1≤m

d−1Y
d−1Y

j=1

j=1

xij

xij

Then we show its correctness for d.

First, by deﬁnition of our algorithm we have:

p1
d(x1, . . . , xm) = p1

d−1(x1, . . . , xm)

xkyk,ik +

k=0

mX
mX
mX
mX

k=0

k=0

d−1Y
d−1Y

j=1

xij

p2
d−1(x1, . . . , xm)

xkzk,ik

(1)

If we then apply our inductive assumption to (1) we obtain:

f 1
K (i1, . . . , id−1, *)

xkyk,ik +

X
X

0≤i1,...,id−1≤m

f 2
K (i1, . . . , id−1, *)

xij

xkzk,ik

that by rewriting becomes

0≤i1,...,id−1≤m

X

d−1Y

xij

0≤i1,...,id−1≤m

j=1

  mX

k=0

j=1

k=0

xk(f 1

K (i1, . . . , id−1, *)yk,ik +

K (i1, . . . , id−1, *)zk,ik )´

f 2

Next, we can apply the recursive deﬁnition of fK (i1, . . . , id):

X

d−1Y

0≤i1,...,id−1≤m

j=1

mX

k=0

xij

xkf 1

K (i1, . . . , id−1, k)

and for id = k we get the desired result for d:

X

f 1
K (i1, . . . , id)

xij

0≤i1,...,id≤m

dY

j=1

Analogously, one can show correctness of p2

d(x1, . . . , xm).

At each step, the algorithm makes only one recursive call
and m operations. Thus, pd(x1, . . . , xm) can be computed
in time O(dm).
3.1.3 Matrix-Vector Multiplication
In this case we deﬁne a PRF for a “small” input domain,
namely the set [1..n] × [1..d], where both n and d are poly-
nomial in the security parameter. The function PRFM is
deﬁned as follows.
PRF.KG(1λ, n, d). Generate a group description (p, g, G) $←
G(1λ). The key K consists of 2(n + d) random values:
$← Zp.
A1, B1, . . . , Ad, Bd
j Bβi
Theorem 7. If the Decision Linear assumption holds for

FK (i, j). For i ∈ [1..n], j ∈ [1..d] deﬁne FK (i, j) = Aαi

$← G and α1, β1, . . . , αn, βn

G, then PRFM is a pseudorandom function.

j

The proof of this theorem follows in a straightforward way
from the random self reducibility of the Decision Linear
problem (it is a simple extension of Lemma 1 in [16]).

eﬃciency for matrix-vector multiplication.

In what follows we show that PRFM admits closed form
Let R = [Ri,j] be an n × d matrix deﬁned over G. And
let (cid:126)x be a d-dimensional vector (cid:126)x = [x1, . . . , xd] deﬁned over
Zp. Denote with with Matrix(R, (cid:126)x) the n dimensional vector
i,j. We now show
an algorithm PRF.CFEvalMatrix(K, (cid:126)x) which computes this (cid:126)ρ
in O(n + d) time (rather than O(nd)) when R = (FK (i, j)).

(cid:126)ρ = [ρ1, . . . , ρn] ∈ Gn deﬁned by ρi =Q

j Rxj

507Compute A =Qd

j and B =Qd

j=1 Axj

j=1 Bxj

j

For i = 1 to n:
ρi = Aαi Bβi

Output (cid:126)ρ = [ρ1, . . . , ρn]

Correctness is easily seen since

ρi =

FK (i, j)xj =

Y

(Aαi

j Bβj

j )xj =

Y

j

Bxj

j )βi = Aαi Bβi

Y
Y

j

(

Axj

j )αi (

Remark. We note that by removing the Bj and βi values,
one can obtain a more eﬃcient version (twice as fast) of this
PRF, that is secure under the (stronger) DDH assumption.

p → Zl

1 ··· xim

the polynomial as f ((cid:126)x) = (cid:104) (cid:126)f , h((cid:126)x)(cid:105) =Pl

4. OUR PROTOCOLS
4.1 Polynomials of Degree d in each variable
In this section we propose the construction of a scheme,
VCPoly, for delegating the computation of multivariate poly-
nomials. Our scheme builds upon the techniques in [4], ad-
ditionally providing a mechanism for public veriﬁability.
The family of functions F supported by our protocol is the
set of polynomials f (x1, . . . , xm) with coeﬃcients in Zp (for
some large prime p that we deﬁne later), m variables, and
degree at most d in each variable. These polynomials have
up to l = (d + 1)m terms which we index by (i1, . . . , im),
for 0 ≤ ij ≤ d. For simplicity, we deﬁne the following func-
tion h : Zm
p which expands the input (cid:126)x to the vector
(h1((cid:126)x), . . . , hl((cid:126)x)) of all the monomials as follows:
for all
1 ≤ j ≤ l, write j = (i1, . . . , im) with 0 ≤ ik ≤ d, then
hj((cid:126)x) = (xi1
m ). So, using this notation we can write
j=1 fj · hj((cid:126)x) where
the fj’s are its coeﬃcients.
Our construction works over groups G1, G2, GT of the
same prime order p, equipped with a bilinear map e : G1 ×
G2 → GT . Let (cid:126)R ∈ Gl
1 be an l-dimensional vector of ran-
In the previous Section we deﬁned
dom group elements.
Our scheme VCPoly works generically for any family of
functions F as described above for which there exists a PRF
that has closed form eﬃciency relative to Poly( (cid:126)R, (cid:126)x), and has
range Y = G1. Its security is based on the security of the
PRF and on the hardness of solving co-CDH in these groups.
For the PRF we can use the ones presented in [4], which
have the required closed form eﬃciency, if we instantiate
them over the group G1. However those constructions are
based on assumptions (DDH, Strong-DDH) that in general
may not hold in bilinear groups. Therefore, to securely adapt
them to our case, we must use asymmetric bilinear groups
where the External Diﬃe-Hellman assumption holds in G1.
Details of this solution will appear in the ﬁnal version.

Poly( (cid:126)R, (cid:126)x) =Ql

j=1 Rhj ((cid:126)x)

.

j

A better approach is to use the PRF construction PRFLW,
PRFeLW given in Section 3.1, that are based on the Decision
Linear assumption for which we know no attacks even in the
presence of bilinear maps. As we describe, these PRFs have
closed form eﬃciency with respect to Poly. This allows to
base our scheme on a weaker assumption and to instantiate
it also with symmetric pairings, i.e., where G1 = G2.

The description of our scheme VCPoly follows.

KeyGen(1λ, f ). Generate the description of bilinear groups
(p, g1, g2, G1, G2, GT , e) $← G(1λ), and a key of a PRF,
K $← PRF.KG(1λ,(cid:100)log d(cid:101), m), with range in G1.
Choose a random α $← Zp, and compute Wi = gα·fi
FK (i), ∀i = 1, . . . , l. Let W = (W1, . . . , Wl) ∈ Gl
1
1.
Output EKf = (f, W ), PKf = e(g1, g2)α, SKf = K.

·

ProbGen(PKf , SKf , (cid:126)x). Output σx = (cid:126)x and
VKx = e(PRF.CFEvalPoly(K, h((cid:126)x)), g2).

pute y = f ((cid:126)x) = Pl

i=1 fi · hi((cid:126)x), V = Ql

Compute(EKf , σx). Let EKf = (f, W ) and σx = (cid:126)x. Com-
i=1 W hi((cid:126)x)
,

i

and return σy = (y, V ).

Verify(PKf , VKx, σy). Let σy be (y, V ). If e(V, g2) = (PKf )y

· VKx, then output y, otherwise output ⊥.

Theorem 8. If G is such that the co-CDH assumption
cdh-holds, and F is prf -secure, then any PPT adversary A
making at most q = poly(λ) queries has advantage
(VCPoly,F, q, λ) ≤ cdh + prf

AdvPubVerA

To prove the theorem, we deﬁne the following games, where
Gi(A) denotes the output of Game i run with adversary A:

Game 0:

this is the same as ExpPubVerA

(VCPoly,F, q, λ).

Game 1:

this game is similar to Game 0, except for the
following change in the evaluation of the ProbGen al-
gorithm. For any (cid:126)x asked by the adversary during
the game, instead of computing VKx using the eﬃ-
cient PRF.CFEval algorithm, the ineﬃcient evaluation

VKx =Ql

i=1 FK (i)hi((cid:126)x) is used.

Game 2:

this game is the same as Game 1, except that
$← G1

each value Fk(i) is replaced by an element Ri
chosen uniformly at random.

The proof of the theorem proceeds by a standard hybrid
argument, and is obtained by combining the proofs of the
following claims.

Claim 9. Pr[G0(A) = 1] = Pr[G1(A) = 1].
Proof. The only diﬀerence between the two games is in
the computation of the ProbGen algorithm. However, by
correctness of PRF.CFEval, such diﬀerence does not change
the distribution of the values VKx returned to the adversary.
Thus, the probability of the adversary winning in Game 1,
i.e., Pr[G1(A) = 1], cannot change.

Claim 10. | Pr[G1(A) = 1] − Pr[G2(A) = 1]| ≤ prf
Proof. The diﬀerence between Game 2 and Game 1 is
that we replaced the output of the pseudorandom function
FK , with uniformly random group elements. It is easy to
see that any adversary A for which such diﬀerence is greater
than prf can be reduced to an attacker that has the same
advantage against the security of the PRF.

Claim 11. Pr[G2(A) = 1] ≤ cdh.
Proof. Assume by contradiction that there exists a PPT
adversary A that has advantage greater than cdh of winning
in Game 2, then we show that we can build an eﬃcient

5082).

1 , gb

1 , gb

algorithm B which uses A to solve the co-CDH problem for
G with the same probability cdh.
B takes as input a group description (p, g1, g2, G1, G2, e)
and random elements ga
2, and it proceeds as follows. It
$← G1, sets EKf = (f, W ), and computes
chooses W1, . . . , Wl
PKf = e(ga
It is easy to check that the public and
evaluation keys are perfectly distributed as in Game 2. Next,
f ∈ GT . B
for i = 1 to l, it computes Zi = e(Wi, g2)/PKfi
runs A(PKf , EKf ) and answers its queries as follows. Let
i=1 Z hi((cid:126)x)
,
and returns it to A. By the bilinear property of e(·,·), this
computation of VKx is equivalent to the one in Game 2.
Finally, let ˆσy = (ˆy, ˆV ) be the output of A at the end
of the game, such that for some (cid:126)x∗ chosen by A it holds
Verify(PKf , VKx∗ , ˆσy) = ˆy, ˆy (cid:54)= ⊥ and ˆy (cid:54)= f ((cid:126)x∗). By veriﬁ-
cation, this means that

(cid:126)x be the queried value. B computes VKx = Ql

i

e( ˆV , g2) = e(ga

1 , gb

2)ˆy · VKx∗ .

Let y = f ((cid:126)x∗) be the correct output of the computation.
Then, by correctness it also holds:
1 , gb

e(V, g2) = e(ga

2)y · VKx∗

i

i=1 W hi((cid:126)x∗)
. So, dividing the two veriﬁcation
2)ˆy−y. B can
equations, we obtain that e( ˆV /V, g2) = e(ga
1 = ( ˆV /V )1/(ˆy−y). Therefore, if A wins in
thus compute gab
Game 2 with probability cdh, then B solves co-CDH with
the same probability.

1 , gb

where V =Ql

Efficiency Analysis. The oﬄine cost for running KeyGen
is O((d + 1)m), whereas the client’s online cost for outsourc-
ing a computation on (cid:126)x (i.e., running ProbGen) is O(m log d).
The cost at the server for running the Compute algorithm is
O((d + 1)m), speciﬁcally twice the cost of computing f ((cid:126)x).
Finally, the cost of verifying the result is completely inde-
pendent of the size of the input and the function, O(1). This
property is interesting because it means that clients (other
than the delegator) can verify the result of the computation
almost for free. To the best of our knowledge, this property
is not achieved by other protocols.
4.2 m-Variate Polynomials of Total Degree d
The protocol for this case is exactly the same as the pro-
tocol VCPoly described above, with the following changes: (i)
adjust the number of monomials to l = (m + 1)d; (ii) use
a PRF with closed-form eﬃciency for polynomials of this
form.

Again, we can use the PRFs in [4], provided we adapt
them to work over G1 and we use asymmetric bilinear groups
where the External Diﬃe-Hellman assumption holds in G1.
Or we can use the variation of the Lewko-Waters PRF,
PRFeLW, described in Section 3.1.2 which relies on the weaker
Decision Linear assumption.

The eﬃciency analysis of this solution is as follows: the of-
ﬂine cost for running KeyGen is O((m+1)d) which is also the
cost for the server’s computation. The client’s online cost
for outsourcing a computation on (cid:126)x (i.e., running ProbGen)
is O(md). Again, veriﬁcation is constant.
4.3 Matrix Multiplication
Let p be a large prime, and d ≥ 1 an integer. In this sec-
tion we propose a scheme VCMatrix that allows to veriﬁably
delegate computation for the following family of functions

p

F. F is the set of matrices M ∈ Zn×d
, for any n ≥ 1, and
the inputs are vectors (cid:126)x ∈ Zd
p. So, the function is the multi-
plication M · (cid:126)x. Given such a scheme, we observe that it is
straightforward to extend it to the case of matrix multipli-
cation, i.e., M · M(cid:48), where M(cid:48) ∈ Zd×m
KeyGen(1λ, M ). Let M ∈ Zn×d

be a matrix. Generate the
description of bilinear groups (p, g1, g2, G1, G2, GT , e)
$← G(1λ). Generate a key K for an algebraic PRF
with domain [1..n] × [1..d] and range G1.
For 1 ≤ i ≤ d, 1 ≤ j ≤ n, compute Wi,j = gα·Mi,j
FK (i, j), and let W = (Wi,j) ∈ Gn×d
Output SKM = K, EKM = (M, W ), and PKM = A.

·

p

p

.

.

1

1

ProbGen(SKM , (cid:126)x). Let (cid:126)x = (x1, . . . , xd) ∈ Zd

ρx,i = Qd

p be the in-
put. Let R be the matrix deﬁned by R = [FK (i, j)].
Compute (cid:126)ρx = PRF.CFEvalMatrix(K, x) in O(n + d) us-
ing the closed form eﬃciency. Recall that we have
j=1 FK (i, j)xj , and deﬁne τx,i = e(ρx,i, g2).
Finally, output the input encoding σ(cid:126)x = (cid:126)x, and the
veriﬁcation key VK(cid:126)x = (τx,1, . . . , τx,n).

Compute(EKM , σ(cid:126)x). Let EKM = (M, W ) and σ(cid:126)x = (cid:126)x. Com-
pute (cid:126)y = M · (cid:126)x and (cid:126)V = (V1, . . . , Vn) as follows:

i=1 W xi

i,j ). Output σy = ((cid:126)y, (cid:126)V ).

Vj = (Qd

Verify(PKM , VK(cid:126)x, σy). Parse σy as ((cid:126)y, (cid:126)V ).

If e(Vi, g2) =
(PKM )yi · τx,i ∀i = 1, . . . , n, then output (cid:126)y, otherwise
output ⊥.

The security of our protocol is shown via the following
theorem. The proof is similar to that of Theorem 8 and
appears in the full version.

Theorem 12. If G is such that the co-CDH assumption
cdh-holds, and F is prf -secure, then any PPT adversary A
making at most q = poly(λ) queries has advantage
(VCMatrix,F, q, λ) ≤ cdh + prf

AdvPubVerA

Efficiency Analysis Using our protocol, a client can
spend a single oﬄine cost O(dn) (for each matrix M – run-
ning the key generation algorithm), while keeping a secret
key of size O(d + n). It can then outsource the computation
of multiplying M·(cid:126)x on many (cid:126)x’s with an online cost O(d+n)
per vector (running ProbGen), whereas the veriﬁcation can
be performed in time O(n). The cost at the server for com-
puting the function, i.e., running Compute, is O(nd), and
more precisely it is twice the cost of performing M · (cid:126)x (once
for M and once for W ). We remark that the running times
of KeyGen and Verify are optimal as they are linear in the
size of their respective inputs.
Our protocol extends to the case of matrix multiplications
M · M(cid:48), where M ∈ Zn×d
by considering
each column of M(cid:48). In this case a client can outsource and
verify such computation with a total online cost O(dm +
nm), which is optimal as it is the cost of processing the
input M(cid:48) ∈ Zd×m
As we pointed out the server has to perform two ma-
trix multiplications: one (M · M(cid:48)) in Zp and the other one
(W · M(cid:48)) “in the exponent”. We note that the server can
perform both computations using one of the optimized algo-
rithms for rectangular matrix multiplication (e.g. Strassen’s

and the output M · M(cid:48) ∈ Zn×m

and M(cid:48) ∈ Zd×m

p

p

p

p

.

509algorithm), that require time strictly less than the trivial
O(nmd). Therefore the server’s computation is asymptoti-
cally the same as a basic matrix multiplication.

5. MULTI FUNCTION VERIFIABLE COM-

PUTATION

In this section we consider the problem of realizing multi-
function veriﬁable computation schemes.
In the following
section, we deﬁne the notion of multi-function veriﬁable com-
putation, and then we propose a new scheme.
5.1 Deﬁnition

Multi-Function veriﬁable computation [21] considers a set-
ting in which a client wants to delegate the computation of
multiple functions on some a-priori ﬁxed inputs. Techni-
cally, this means that the ProbGen algorithm must be com-
pletely decoupled from KeyGen, in the sense that one can
prepare the input before knowing which function will be ap-
plied on it. More formally, let F be a family of functions. A
multi-function veriﬁable computation scheme is deﬁned by
the following algorithms:
Setup(1λ,F) → (PK, SK): on input the security parameter
λ and the description of a family of functions F, the
setup algorithm generates a pair of public and private
parameters PK, SK. In particular, we assume that F
speciﬁes the domain Dom of the functions f ∈ F.

KeyGen(PK, SK, f ) → (EKf , VKf ): on input the security pa-
rameter λ and a function f ∈ F, this algorithm pro-
duces a veriﬁcation key VKf , used to verify the cor-
rectness of the delegated computations, and a public
evaluation key EKf which is handed to the server to
delegate computations of f .

ProbGen(PK, SK, x) → (σx, VKx): on input the public pa-
rameters, and a value x ∈ Dom, the problem gener-
ation algorithm produces an encoding σx of x together
with a veriﬁcation key VKx.

Compute(EKf , σx) → σy: given the evaluation key EKf and
the encoding σx of an input x, this algorithm is run
by the worker to compute an encoded version σy of
y = f (x).

Verify(VKf , VKx, σy) → y ∪ ⊥: given veriﬁcation keys VKf
and VKx, and an encoded output σy, this algorithm
returns a value y or an error ⊥.

According to whether VKf and VKx can be publicly revealed
or kept secret, we obtain a deﬁnition of a multi-function ver-
iﬁable computation that is public veriﬁable or secret veriﬁ-
able respectively. Moreover, if KeyGen and ProbGen do not
use the secret key SK, then the scheme is publicly delegatable.

Security. For any multi-function veriﬁable computation
scheme VC, consider the following experiment:

Experiment ExpPriVerif

A

[VC,F, λ]

(PK, SK) $← Setup(1λ,F)
(f, x∗, ˆσy)←AOKeyGen(·),OProbGen(·),OVerify(·,·,·)(PK)
ˆy←Verify(VKf , vkx∗ , ˆσy)
If ˆy (cid:54)= ⊥ and ˆy (cid:54)= f (x∗), output 1, else output 0.

In the above experiment, the adversary is given access to
three oracles that works as follows. On input a function
f ∈ F, OKeyGen(f ) runs (EKf , VKf ) $← KeyGen(PK, SK, f ),
returns EKf and stores VKf . On input x ∈ Dom, OProbGen(x)
runs (σx, VKx) $← ProbGen(PK, SK, x), returns σx and stores
VKx. On input f ∈ F, x ∈ Dom and a purported output σy,
OVerify(f, x, σy) runs y←Verify(VKf , VKx, σy) and returns y.
For any λ ∈ N, any family of functions F, we deﬁne the
advantage of A making at most q = poly(λ) queries in the
above experiment against VC as

A

(VC,F, q, λ) = Pr[ExpPriVerif

AdvPriVerif
Definition 13. Let λ ∈ N be the security parameter,
and F be a family of functions. A multi-function veriﬁable
computation scheme VC is secure for F if for any PPT A,
AdvPriVerif

(VC,F, q, λ) is negligible.

[VC,F, λ] = 1].

A

A

Our deﬁnition is in the private setting, though one in the
public veriﬁable or public delegatable settings can be easily
obtained by slightly changing the output of the oracles.
5.2 Tools: Homomorphic weak PRFs

A homomorphic weak pseudorandom function consists of
algorithms (wPRF.KG, G). The key generation wPRF.KG
takes as input the security parameter 1λ and outputs a secret
key k and some public parameters pp that specify domain
X and range Y of the function. On input X ∈ X , Gk(X)
uses the key k to output a value Y ∈ Y. First, we require
(wPRF.KG, G) to satisfy the usual weak pseudorandomness
property, i.e., it is -secure if for any PPT adversary A and
any polynomial t = t(λ):

˛˛Pr[A(1λ, pp,{Xi, Yi}t

− Pr[A(1λ, pp,{Xi, Zi}t

i=1) = 1]

i=1) = 1]˛˛ ≤ 

where (k, pp) $← wPRF.KG(1λ), and ∀i = 1, . . . , t, Xi
Yi = Gk(Xi), Zi
phic property as follows:
any integer coeﬃcients c1, c2 ∈ Z, it holds:

$← X ,
$← Y. In addition, we ask for a homomor-
for any inputs X1, X2 ∈ X , and

Gk(X c1

1 · X c2

2 ) = Gk(X1)c1 · Gk(X2)c2

An example based on DDH. Let G be a group of order
p. The following construction is an algebraic homomorphic
weak PRF. The key is a random k $← Zp, domain and range
are X = Y = G, and the function is Gk(X) = X k. It is triv-
ial to observe that it is homomorphic. Pseudoranomness fol-
lows in a straightforward way from random self-reducibility
of DDH. For the purpose of our applications, we remark
that if G1, G2 are asymmetric bilinear groups, this function
can be instantiated in G1 and proven secure under the XDH
assumption in G1.
An example based on Decision Linear Let G be a group
of order p. The following construction is an algebraic homo-
$← Zp,
morphic weak PRF. The key is a random pair k1, k2
the domain is X = G2, and the range is Y = G. On any pair
(X1, X2) ∈ X , the function is Gk1,k2 (X1, X2) = X k1
· X k2
2 .
If for every (X1, X2) ∈ X we deﬁne the operation (X1, X2)c
component-wise, i.e., (X1, X2)c = (X c
2), then it is easy
to verify the homomorphic property. The function is weak
pseudorandom based on the Decision Linear assumption.
The proof follows in a straightforward way from the ran-
dom self-reducibility of the Decision Linear problem, (it is a
simple extension of Lemma 1 in [16]).

1, X c

1

5105.3 Our Multi-Function Scheme
Here we propose a multi-function veriﬁable computation
scheme, VCM ultiF , that is publicly delegatable and private
veriﬁable. This construction works for any family of func-
tions F that is a vector space of dimension d over a ﬁnite
ﬁeld Zp for some large prime p.
A function f ∈ F is represented as a vector (cid:126)f = (f1, . . . ,
fd) ∈ Zd
p. For any

x ∈ Dom(F), we deﬁne f (x) =Pd

p, whereas the domain is Dom(F) = Zd
VCM ultiF is deﬁned by the following algorithms:

i=1 fi · xi.

Setup(1λ,F). Generate the description of a group G of prime
order p, and let g ∈ G be a generator. Let pp be the pa-
rameters for a homomorphic weak-PRF with domain
X and range Y = G. Select R = (R1, . . . , Rd) $← X d
at random, and output SK = ⊥ and PK = (p, g, G, R).

KeyGen(PK, SK, f ). Let R = (R1, . . . , Rd). Generate a key
k $← wPRF.KG(1λ) of a homomorphic weak PRF with
range Y = G. Choose random α $← Zp, for all i = 1 to
d compute Wi = gα·fi ·Gk(Ri). Let W = (W1, . . . , Wd)
∈ Gd. Output EKf = (f, W ), VKf = (α, k).

ProbGen(PK, SK, x). Let x = (x1, . . . , xd) ∈ Zd

p be the input.
Its encoding σx is x itself, whereas the veriﬁcation key

is VKx =Qd
Compute y = f (x) =Pd

i=1 Rxi
i .

and return σy = (y, V ).

Compute(PK, EKf , σx). Let EKf = (f, W ), and σx = x.
i=1 W xi
,

i

i=1 fi · xi, and V =Qd

Verify(VKf , VKx, σy). Parse σy as (y, V ).

Gk(VKx), then output y, otherwise output ⊥.

If V = (gα)y ·

Theorem 14. If the weak PRF (wPRF.KG, G) is wprf -
secure in a group G of order p, then any PPT adversary A
making at most q = poly(λ) queries has advantage

AdvPriVerif

A

(VCM ultiF ,F, q, λ) ≤ q · wprf + q/p

A

= Qd

(VCMatrix,F, q, λ).

To prove the Theorem we deﬁne the following games. Let
Gi(A) be the output of Game i when run with adversary A.
Game 0: this is the same as ExpPriVerif
Game 1: this game is similar to Game 0, except for the fol-
lowing change in the way veriﬁcation queries are answered.
Let OVerify(f, x, σy) be the query made by the adversary, and
let VKf = (α, k), VKx be the stored veriﬁcation keys. In-
stead of computing Gk(VKx), the challenger computes VK(cid:48)
i=1 Gk(Ri)xi and makes the comparison by checking
whether V = gαy · VK(cid:48)
x.
Game 2,j:
for all j = 0 to q, Game 2,j is the same as
Game 0, except that the ﬁrst j queries made by the adver-
sary to the oracle OKeyGen(·) are answered as follows. On
input a function f , instead of generating a key k for the
weak PRF, each Wi is computed as Wi = gα·fi · Zi, where
$← G is chosen uniformly at random, and it is stored in
Zi
VKf = (α, Z1, . . . , Zd). Accordingly, all veriﬁcation queries
OVerify(f, x, σy) where f was asked to OKeyGen(·) in the ﬁrst
j queries, are answered by checking whether V = gαy ·
. We notice that Game 1 is Game 2,0, and we

Qd

x

i=1 Z xi

i

rename Game 2,q as Game 3.

Claim 15. Pr[G0(A) = 1] = Pr[G1(A) = 1].

Claim 16. For any j = 1 to q, we have | Pr[G2,j−1(A) =

1] − Pr[G2,j(A) = 1]| ≤ wprf

Claim 17. Pr[G3 = 1] ≤ q/p.

We give the proof of the ﬁrst two claims in the full version
of our work, and we notice that the proof of the third claim
is a simple extension of the proof of Claim 5.6 in [4]. More
details appear in the full version.

Efficiency. The Setup, KeyGen, and ProbGen algorithms
run in time O(d), whereas the complexity of veriﬁcation is
independent of d, i.e., O(1). Our protocol VCM ultiF achieves
amortized eﬃciency in a setting in which the delegator com-
putes several functions f1, . . . , fn on some a-priori ﬁxed in-
puts x1, . . . , xm. While the cost of computing a single func-
tion on m inputs would be O(dm), using our scheme, a
client can outsource and verify the computation of f (x1),
. . . , f (xm) in time O(d + m).

6. DISCRETE FOURIER TRANSFORM

The Discrete Fourier Transform (DFT) of a n-dimensional
vector (cid:126)f is deﬁned as (cid:126)y = [f (x1), . . . , f (xn)] where f is the
(n − 1)-degree polynomial naturally deﬁned by (cid:126)f evaluated
over the n roots of unity. It is well known that using the
Fast Fourier Transform algorithm (FFT), the DFT can be
computed in O(n log n) time. Note that the vector (cid:126)y can
alternatively be computed as (cid:126)y = X · (cid:126)f where X is the n× n
Vandermonde matrix deﬁned by the xi’s.

To obtain a veriﬁable computation scheme for the DFT

using our protocols we have three options.

Using the Matrix Multiplication Scheme. This so-
lution works well for the client as it incurs O(n) delega-
tion and veriﬁcation cost. However, the computation at the
server is O(n2): indeed, the server can compute the DFT in
O(n log n) but to compute the veriﬁcation value (cid:126)V it cannot
use the FFT algorithm (as the matrix W is a pseudo-random
matrix without the “special” structure such as X). There-
fore with this approach the server’s computation is asymp-
totically higher and this could be unacceptable for large n.

Using the Polynomial Evaluation scheme over n in-
puts. To outsource the DFT of (cid:126)f the client would perform
the key generation part of our polynomial evaluation scheme,
and the delegation of the input xi’s all in one blow. The only
way this can be done in O(n) time is to use a closed-form
PRF that allows the delegation of a single variable input in
constant time. Unfortunately, our PRFs from Decision Lin-
ear require O(log n) time to delegate a single input. We can
however use the constant time scheme from [4] adapted to be
publicly veriﬁable. The drawback is that we need to assume
the External n-SDH Assumption over asymmetric bilinear
groups, which is a strong “non-constant size” assumption.

Using the Multi-Function Scheme. Finally, the Multi-
Function Scheme described in the previous section satisﬁes
the eﬃciency constraint given by FFT, but is only privately
veriﬁable.

7. ACKNOWLEDGEMENTS

The ﬁrst author was supported by the NSF grant CNS-
1017471. The research of the second author was sponsored

511by the U.S. Army Research Laboratory and the U.K. Min-
istry of Defence and was accomplished under Agreement
Number W911NF-06-3-0001. The views and conclusions
contained in this document are those of the author(s) and
should not be interpreted as representing the oﬃcial policies,
either expressed or implied, of the U.S. Army Research Lab-
oratory, the U.S. Government, the U.K. Ministry of Defence
or the U.K. Government. The U.S. and U.K. Governments
are authorized to reproduce and distribute reprints for Gov-
ernment purposes notwithstanding any copyright notation
hereon.

8. REFERENCES
[1] B. Applebaum, Y. Ishai, and E. Kushilevitz. From

secrecy to soundness: Eﬃcient veriﬁcation via secure
computation. In S. Abramsky, C. Gavoille,
C. Kirchner, F. Meyer auf der Heide, and P. G.
Spirakis, editors, ICALP 2010: 37th International
Colloquium on Automata, Languages and
Programming, Part I, volume 6198 of Lecture Notes in
Computer Science, pages 152–163, Bordeaux, France,
July 6–10, 2010. Springer, Berlin, Germany.

[2] L. Babai. Trading group theory for randomness. In

17th Annual ACM Symposium on Theory of
Computing, pages 421–429, Providence, Rhode Island,
USA, May 6–8, 1985. ACM Press.

[3] M. Belenkiy, M. Chase, C. C. Erway, J. Jannotti,

A. K¨up¸c¨u, and A. Lysyanskaya. Incentivizing
outsourced computation. In Workshop on Economics
of Networked Systems – NetEcon, pages 85–90, 2008.

[4] S. Benabbas, R. Gennaro, and Y. Vahlis. Veriﬁable

delegation of computation over large datasets. In
P. Rogaway, editor, Advances in Cryptology –
CRYPTO 2011, volume 6841 of Lecture Notes in
Computer Science, pages 111–131, Santa Barbara, CA,
USA, Aug. 14–18, 2011. Springer, Berlin, Germany.

[5] D. Boneh and M. K. Franklin. Identity-based

encryption from the Weil pairing. In J. Kilian, editor,
Advances in Cryptology – CRYPTO 2001, volume
2139 of Lecture Notes in Computer Science, pages
213–229, Santa Barbara, CA, USA, Aug. 19–23, 2001.
Springer, Berlin, Germany.

[6] D. Boneh, B. Lynn, and H. Shacham. Short signatures
from the Weil pairing. In C. Boyd, editor, Advances in
Cryptology – ASIACRYPT 2001, volume 2248 of
Lecture Notes in Computer Science, pages 514–532,
Gold Coast, Australia, Dec. 9–13, 2001. Springer,
Berlin, Germany.

[7] K.-M. Chung, Y. Kalai, and S. P. Vadhan. Improved
delegation of computation using fully homomorphic
encryption. In T. Rabin, editor, Advances in
Cryptology – CRYPTO 2010, volume 6223 of Lecture
Notes in Computer Science, pages 483–501, Santa
Barbara, CA, USA, Aug. 15–19, 2010. Springer,
Berlin, Germany.

[8] R. Gennaro, C. Gentry, and B. Parno. Non-interactive

veriﬁable computing: Outsourcing computation to
untrusted workers. In T. Rabin, editor, Advances in
Cryptology – CRYPTO 2010, volume 6223 of Lecture
Notes in Computer Science, pages 465–482, Santa
Barbara, CA, USA, Aug. 15–19, 2010. Springer,
Berlin, Germany.

[9] C. Gentry. Fully homomorphic encryption using ideal

lattices. In M. Mitzenmacher, editor, 41st Annual
ACM Symposium on Theory of Computing, pages
169–178, Bethesda, Maryland, USA, May 31 – June 2,
2009. ACM Press.

[10] S. Goldwasser, Y. T. Kalai, and G. N. Rothblum.

Delegating computation: interactive proofs for
muggles. In R. E. Ladner and C. Dwork, editors, 40th
Annual ACM Symposium on Theory of Computing,
pages 113–122, Victoria, British Columbia, Canada,
May 17–20, 2008. ACM Press.

[11] S. Goldwasser, S. Micali, and C. Rackoﬀ. The

knowledge complexity of interactive proof systems.
SIAM Journal on Computing, 18(1):186–208, 1989.

[12] V. Goyal, O. Pandey, A. Sahai, and B. Waters.

Attribute-based encryption for ﬁne-grained access
control of encrypted data. In A. Juels, R. N. Wright,
and S. Vimercati, editors, ACM CCS 06: 13th
Conference on Computer and Communications
Security, pages 89–98, Alexandria, Virginia, USA,
Oct. 30 – Nov. 3, 2006. ACM Press. Available as
Cryptology ePrint Archive Report 2006/309.

[13] J. Kilian. A note on eﬃcient zero-knowledge proofs

and arguments. In 24th Annual ACM Symposium on
Theory of Computing, pages 723–732, Victoria, British
Columbia, Canada, May 4–6, 1992. ACM Press.

[14] J. Kilian. Improved eﬃcient arguments. In

International Cryptology Conference on Advances in
Cryptology, pages 311–314, London (UK), 1995.
Springer-Verlag.

[15] A. Lewko and B. Waters. New proof methods for

attribute-based encryption: Achieving full security
through selective techniques. Crypto 2012, to appear.
[16] A. B. Lewko and B. Waters. Eﬃcient pseudorandom
functions from the decisional linear assumption and
weaker variants. In E. Al-Shaer, S. Jha, and A. D.
Keromytis, editors, ACM CCS 09: 16th Conference on
Computer and Communications Security, pages
112–120, Chicago, Illinois, USA, Nov. 9–13, 2009.
ACM Press.

[17] S. Micali. Cs proofs. In 35th Annual Symposium on

Foundations of Computer Science, Santa Fe, New
Mexico, Nov. 20–22, 1994.

[18] P. Mohassel. Eﬃcient and secure delegation of linear

algebra. Cryptology ePrint Archive, Report 2011/605.
[19] F. Monrose, P. Wyckoﬀ, and A. D. Rubin. Distributed

execution with remote audit. In ISOC Network and
Distributed System Security Symposium – NDSS’99,
San Diego, California, USA, Feb. 3–5, 1999. The
Internet Society.

[20] C. Papamanthou, E. Shi, and R. Tamassia. Signatures

of correct computation. Cryptology ePrint Archive,
Report 2011/587, 2011.

[21] B. Parno, M. Raykova, and V. Vaikuntanathan. How

to delegate and verify in public: Veriﬁable
computation from attribute-based encryption. TCC
2012.

[22] S. W. Smith and S. Weingart. Building a

high-performance, programmable secure coprocessor.
Computer Networks, 31:831–860, 1999.

[23] B. Yee. Using Secure Coprocessors. PhD thesis,

Carnegie Mellon University, 1994.

512