2015 IEEE Symposium on Security and Privacy
2015 IEEE Symposium on Security and Privacy

ADSNARK: Nearly Practical and

Privacy-Preserving Proofs on Authenticated Data
Raphael M. Reischuk∗

Manuel Barbosa

Michael Backes

Dario Fiore

CISPA, Saarland University

Germany

HASLab – INESC TEC

Minho University, Portugal

IMDEA Software Institute

Madrid, Spain

ETH Zurich
Switzerland

Abstract—We study the problem of privacy-preserving proofs
on authenticated data, where a party receives data from a trusted
source and is requested to prove computations over the data to
third parties in a correct and private way, i.e., the third party
learns no information on the data but is still assured that the
claimed proof is valid. Our work particularly focuses on the
challenging requirement that the third party should be able to
verify the validity with respect to the speciﬁc data authenticated
by the source — even without having access to that source. This
problem is motivated by various scenarios emerging from several
application areas such as wearable computing, smart metering,
or general business-to-business interactions. Furthermore, these
applications also demand any meaningful solution to satisfy
additional properties related to usability and scalability.

In this paper, we formalize the above three-party model,
discuss concrete application scenarios, and then we design,
build, and evaluate ADSNARK, a nearly practical system for
proving arbitrary computations over authenticated data in a
privacy-preserving manner. ADSNARK improves signiﬁcantly
over state-of-the-art solutions for this model. For instance,
compared to corresponding solutions based on Pinocchio (Oak-
land’13), ADSNARK achieves up to 25× improvement in proof-
computation time and a 20× reduction in prover storage space.

I. INTRODUCTION

With the emergence of modern IT services, many aspects of
the operation of our society have come to critically depend
on the ability to share information between multiple parties,
subject to complex information ﬂow restrictions. The advance
of information and communication technology has often led to
the deployment of systems that offer the desired functionality,
but do not offer a technical solution to enforcing the secure
information ﬂow restrictions. Instead, parties must simply trust
each other, often without reasonable grounds.

The last few years have seen exciting developments in
cryptography, where (quasi-)practical solutions to some of
these problems were proposed, prototyped, and sometimes
deployed (as we will see later in this section). In this paper,
we make further progress in this direction by proposing and
efﬁciently instantiating a new cryptographic primitive called
AD-SNARK, which targets an important class of applications
that is out of reach of current technology. Such applications
involve a potentially large set of secret data and three parties
with the following trust relationships:

* Some of the results of this paper also appear in [1].

© 2015, Michael Backes. Under license to IEEE.
© 2015, Michael Backes. Under license to IEEE.
DOI 10.1109/SP.2015.24
DOI 10.1109/SP.2015.24

271
271

• The data owner wishes to keep her data secret, but
is forced by circumstances to reveal partial information
on this data to a service provider. Typically, this is an
aggregated result computed by some public function f
on the secret data.

• The service provider does not trust the data owner to
correctly compute the partial information on the data, but
wants to be convinced of its validity.

• The data owner has access to a trusted source, who can be
given local access to the data, and who is trusted by the
service provider to vouch for the quality and legitimacy
of the data.

For concreteness, let us look at a few applications that fall
into this model, and where the public function that must be
applied to the data has varying degrees of complexity.

Health Risk Assessment. A wearable biosensor [2, 3]
collects ﬁne-grained health information of an individual; the
individual should give this information to a health insurance
company that wants to assess her health risk in order to
evaluate a corresponding premium. Privacy determines that the
ﬁne-grained health data collected by the sensor remains secret
as it may reveal more about the individual’s lifestyle and habits
than she wishes to reveal. The computation of the premium
due to the insurance company (or an aggregate, less privacy-
invasive, information of the collected data) should therefore be
carried out by the client. However, the client must convince
the insurance company that this computation is correct and
performed on legitimate data produced by the biosensor (we
call this property integrity). In this setting, the biosensor can
play the role of the trusted source, provided that it is equipped
to cryptographically authenticate the individual measurements
that it produces. Then the AD-SNARK primitive can be used
to provide the required assurance to the health insurance
company.

Smart Metering. The service provider of some commodity
installs a trusted device in the facilities of the client. This
trusted device periodically measures consumptions and pro-
duces a list of readings, which are delivered to the client;
the client should give these readings to the service provider
for billing purposes. For privacy, the client may not want to
disclose these measurements as they may reveal more about
the client’s habits than she wishes to reveal (see, e.g., [4]).
For integrity, the supplier wants to evaluate a correct bill

and prevent customers from cheating. As before, the customer
keeps all the readings provided by the local meter, which must
be able to authenticate the data and operate as a trusted source.
Then, the customer computes the amount due to the provider,
and uses AD-SNARK to prove that the result is correct.

Financial Audits. Organizations are often subject to ﬁnan-
cial audits. Auditors will typically look at speciﬁc parts of the
accounting data and assert that the results of relevant com-
putations are accurate. However the accounting data should
be treated as sensitive information due to its business-critical
nature, and minimizing the amount of information disclosed
to auditors is desirable. In this scenario, the auditor plays the
role of the service provider, and the organization the role of
the data owner. The natural entity to play the role of the
trusted source is the person (or third party) who is legally
responsible for certifying the accounts of the organization,
e.g., the ofﬁcial bookkeeper. This entity would authenticate
the accounting data, so that the organization could internally
compute the audit data in a way that is veriﬁable by the
auditors with respect to both correctness and legitimacy. As
intended, using AD-SNARK in this context will transfer the
responsibility of any wrongdoing to the ofﬁcial bookkeeper.

In the full version of this paper we present three more ex-
ample applications: pay-as-you-drive insurance, loyalty cards,
and health statistics. We believe that, with the rise of small
computing devices and an increased awareness with respect
to privacy protection, many more applications will come to
fall into this three-party scenario.

Although the trust model in all of the previous applications
is the same, the complexity of the associated computations
varies signiﬁcantly. Solutions have been proposed for smart-
metering, pay-as-you-drive insurance, and loyalty cards, e.g.,
in [5, 6], and [7], respectively (and also for other applications
of similarly low complexity). However, currently no generic
solution is able to scale in a satisfactory way to deal with
computations of arbitrary size such as those required for
scenarios like the ones of ﬁnancial audits or health statistics.
Furthermore, although some scenarios admit to a close relation
between the trusted source and the service provider that
could lead to secret information being shared between the
two (in the style of symmetric cryptography), other scenarios
require veriﬁcation for multiple parties, i.e., a form of public
veriﬁability that is even more challenging. The AD-SNARK
primitive and the efﬁcient instantiation that we propose in this
paper provides a practical solution for the moderately complex
computations, even with public veriﬁability. Furthermore, the
proposed AD-SNARK construction is as practical as the
existing state of the art solutions for computations of arbitrary
size on non-authenticated data.1

Formal Model. We now illustrate more formally the three
party model we have introduced above (see Figure 1). We
consider a scenario in which a prover P (the data owner) is
requested to prove certain computations C(D) on input data

1Hence the designation “nearly practical” in the title of the paper.

D to third parties V (one or more service providers), which we
call the veriﬁers. Since the two parties P and V may not trust
each other, we are interested in the simultaneous achievement
of two main security properties: (1) integrity, in the sense
that V should be convinced about the correctness of C(D).
In particular, in order to verify that this statement holds for
some speciﬁc input D, the data is assumed to be generated
and authenticated by some trusted source S; and (2) privacy,
in the sense that V should not learn any information about D
beyond what is trivially revealed by C(D).

In addition to the security requirements above, any meaning-
ful solution has to meet the following properties that have been
identiﬁed as key for practical scalability in previous work:
(3) efﬁciency, meaning that V’s veriﬁcation cost should be
much cheaper than the cost of computing C(D); and (4) data
independence, in the sense that the data source S should be
independent of P, i.e., S should be able to provide D without
knowing in advance what computations will be executed on D
(e.g., the billing function may change over time). In particular,
also D’s size should not be ﬁxed in advance, i.e., S can
continuously provide data to P, even after some proofs have
been generated.

Related Work. The simultaneous achievement of integrity
and privacy is a fundamental goal that has a long research
history starting with the seminal work on zero-knowledge
proofs [8]. In the last years, the efﬁciency of zero-knowledge
proofs has improved a lot, and nowadays we are on the verge
of having nearly practical schemes for general-purpose com-
putations [9–11]. Proofs on authenticated data are an important
class of proofs that have been considered earlier especially in
very specialized contexts such as credentials and electronic
cash [12–15]. In the more general case of proving arbitrary
computations over authenticated data, there is however little
prior work, especially if one is concerned about achieving
practical efﬁciency. While we review this related work later in
Section VI, at this point we mention that the recent work ZQL
[6] aimed to address this problem by considering a three party
setting such as the one we presented above. ZQL provides
an expression language for (privacy-preserving) processing of
data that can be originated (i.e., authenticated) by trusted data
sources, and proposes a cryptographic scheme that achieves
integrity, privacy, and data independence. However, the current
ZQL language has some intrinsic limitations that limit its ap-
plicability to arbitrary computations while achieving efﬁciency
(i.e., if the veriﬁer should perform less work than that required
to generate the proof). In summary, while we do have efﬁcient
zero-knowledge proof systems for arbitrary computations, in
the case of proofs on authenticated data the situation is not
satisfactory.

A. Detailed Contributions
Inspired by the goals of ZQL, we formalize a cryptographic
primitive for privacy-preserving proofs on authenticated data,
and we propose a new realization that achieves the desired
efﬁciency goal for arbitrary computations. We then build a
system called ADSNARK and evaluate its performance in

272272

P,

→

→ →

Prover
obtain witness w such that 
C(x,w)=0 with x =(x1,...,xn )
and compute π = Prove(C,x,w,σ )
→ → →
{(xk, σk )}k

π

→

p
r
i
v
a
c
y

S

Source
measure data {xk }k
and sign it
σk = Auth(sk,Lk,xk)

p
r
i
v
a
c
y

V

Veriﬁer
verify proof π
using L=(L1,...,Ln )
Ver(vk,L,π)

→

→

i

e
f
ﬁ
c
e
n
c
y

i

n
t
e
g
r
i
t
y
 
&

Figure 1. Three-party scenario in which a source S authenticates data xk,
and a prover P proves to a veriﬁer V the satisﬁability of a circuit C based
on xk. The source and the prover are interested in data privacy, whereas the
veriﬁer is interested in integrity and efﬁciency.

comparison with solutions based on the state of the art. More
in detail, our contributions are the following.

We fully formalize a model for the above problem by
deﬁning a new cryptographic primitive that we call Succinct
Non-Interactive Arguments of Knowledge on Authenticated
Data (or AD-SNARK, for short). Succinct Non-Interactive
Arguments, ﬁrst
introduced by Micali under the name of
“CS proofs” [16], are proof systems that provide succinct
veriﬁcation, i.e., the veriﬁer is able to check a long poly-
time computation in much less time than that required to
run the computation, given the witness. Our new notion of
AD-SNARKs extends SNARKs to explicitly capture proofs
of NP relations R(x, w) in which the statement x (or a part
of it) is authenticated. More precisely, the main difference
between SNARKs and AD-SNARKs is that in the former,
the veriﬁer always knows the statement, whereas in the latter,
the authenticated statements are not disclosed to the veriﬁer,
yet the veriﬁer can be assured about the existence of w such
that R(x, w) holds for the speciﬁc x authenticated by some
trusted source. Moreover, to model privacy (and looking ahead
to our applications) we deﬁne the zero-knowledge property to
hold not only for the witnesses of the relation, but also for
the authenticated statements. In particular, our zero-knowledge
deﬁnition holds also against adversaries who generate the
authentication keys.

Turning our attention to realizations, we show that
AD-SNARKs can be constructed in a generic fashion by em-
bedding digital signatures into SNARKs. However, motivated
by the fact that this “generic construction” is not efﬁcient in
practice, our second contribution is a direct and more efﬁcient
realization of AD-SNARKs, that from now on we refer to
as ADSNARK. Compared to instantiating the generic con-
struction with state-of-the-art SNARK schemes, ADSNARK
performs way better on the prover side, and achieves a level
of efﬁciency that makes it a plausible candidate for real-world
deployment. In what follows we give more details on this
efﬁciency aspect: We ﬁrst discuss the efﬁciency of the generic
construction with state-of-the-art instantiations, and then we
describe our solution.

(cid:2)

(cid:2)

(cid:2)

(cid:2)

, w

) with x

= (|x|, pk), w

ON THE (IN)EFFICIENCY OF THE GENERIC CONSTRUC-
TION. The idea of the generic (not very practical) construction
of AD-SNARK for an NP relation R(x, w) is to let the prover
P prove an extended NP relation R
(cid:2) which contains the set
= (w, x, σ), and
of tuples (x
σ = (σ1, . . . , σ|x|), such that there is a valid signature σi for
every statement value xi at position i under public key pk. The
problem with this generic construction is that, in practice, a
(cid:2) is much more expensive
proof for such extended relation R
(cid:2) needs to “embed” the
than a proof for R. The issue is that R
veriﬁcation algorithm of a signature scheme. If we consider
very efﬁcient SNARKs, such as the recent optimization of
Pinocchio [9] proposed in [11], then embedding the veriﬁca-
tion algorithm means encoding the veriﬁcation algorithm of
the signature with an arithmetic circuit over a speciﬁc ﬁnite
ﬁeld Fp (where p is a large prime, the order of some bilinear
groups), and then creating a Quadratic Arithmetic Program
[17], a QAP for short, out of this circuit. Without going into
the details of QAPs (we will review them later in Section
II), we note that the efﬁciency of the prover in these systems
depends on the size of the QAP, which in turn depends on
the number of multiplication gates in the relation satisﬁability
circuit.

Our main observation is that

the circuit resulting from
expressing the veriﬁcation algorithm of a digital signature
scheme is very likely to be quite inefﬁcient (from a QAP
perspective), especially for the prover. Such inefﬁciency stems
from the fact that the circuit would contain a huge number of
multiplication gates. In Section III-C we discuss why this is
the case for various examples of signatures in both the random
oracle and the standard model, and based on different algebraic
problems. Our conclusions indicate that a QAP encoding a
signature veriﬁcation circuit is likely to have signiﬁcantly more
that one thousand multiplications for every signature that must
be checked. If, for instance, we consider smart-metering, in
which the prover wants to certify about 1 000 (signed) meter
readings (amounting to approximately 1 month of electricity
measurements), the costs can become prohibitive!

OUR SOLUTION. In contrast, we propose ADSNARK, a new,
direct, AD-SNARK scheme that achieves the same efﬁciency
as state-of-the-art SNARKs, e.g., [11], yet
it additionally
allows for proofs on authenticated statements. Our scheme
builds upon an optimized version of Pinocchio proposed and
implemented in [11], and our key technical contribution is
a technique (illustrated in Section I-B) for embedding the
authentication veriﬁcation mechanism directly in the proof
system, without having to resort to extended relations that
would incur the efﬁciency loss discussed earlier. As a result,
the performance of our scheme is almost the same as that
of running [11], but with the additional beneﬁt of obtaining
proofs about authenticated values.

When comparing our direct construction with an instantia-
tion of the generic scheme with [11], ADSNARK introduces a
dramatic improvement (cf. Figure 2 above) in the generation
of setup keys (for the relation) and proofs, which is currently

273273

Key Generator
Prover
Veriﬁer

Proving key size
Veriﬁcation key size
Proof size

AD-PGHR
299 s
491 s
0.062 s

319 MB
31 KB
0.3 KB

ADSNARK
16 s
20 s
(PK) 0.61 s
(SK) 0.035 s
16 MB
31 KB
(PK) 126 KB
(SK) 0.4 KB

Improvement
18.7×
24.5×
0.1×
1.8×
19.9×
same
0.002×
0.75×

Figure 2.
Comparison between ADSNARK and the generic solution
(AD-PGHR) based on the [11] SNARK considering an arithmetic circuit
with 50K multiplication gates and 1000 authenticated inputs. Results obtained
by running libsnark for AD-PGHR and our implementation (based on
libsnark) of ADSNARK, both at a 128-bits security level.

the main bottleneck of state-of-the-art SNARKs (e.g., [9–11]).
Namely, while these schemes perform excellently in terms of
veriﬁcation time and proof size, the performances get much
worse when it comes to generating keys and proofs, espe-
cially for relations that have “unfriendly” arithmetic circuit
representations, such as signature veriﬁcation algorithms, as
discussed earlier. This is where our technique for avoiding
the explicit encoding of signature veriﬁcation in the circuits
allows us to use much smaller QAPs, thus saving at least
one thousand multiplication gates per authenticated input. This
improvement is clearly evident in our experimental results that
show that the prover can obtain up to a 25× speed-up (20 s vs.
8 mins) and a 20× reduction in storage (16 MB vs. 320 MB).
As we discuss later, on the veriﬁer side ADSNARK allows
for two different veriﬁcation modes: one using the secret
authentication key and one completely public. Although in
the secret-key case, ADSNARK essentially achieves the same
veriﬁcation efﬁciency and proof size of the generic solution,
our scheme pays more for public veriﬁcation. However, in
contrast to what happens on the prover side of the generic
solution, the public veriﬁcation of ADSNARK still achieves
timing (0.61 s) and proof size (126 KB) that can be deﬁnitely
considered practical.

B. An Intuitive Description of Our Techniques
The key idea for the construction of our AD-SNARK scheme
is to build upon SNARKs based on QAPs, and in particular
on the PGHR scheme in [11]. At a high level, our tech-
nique consists of extending PGHR by embedding a linearly-
homomorphic MAC that forces the prover to run the PGHR’s
Prove algorithm on correctly authenticated statements.

n

More precisely, the PGHR veriﬁer, given a statement x =
(cid:2)
(x1, . . . , xn), has to compute the linear combination ain =
k=1xk·ak(X) (where the ak(X) are the QAP polynomials).
However, recall that in AD-SNARKs the veriﬁer does not
know the statement x, and thus is not able to compute ain. Our
key idea to solve this issue is to shift the computation of the
linear combination ain from the veriﬁer to the prover. Then, to
force a cheating prover to provide the correct ain, we ask the
prover to additionally show that ain was indeed obtained by
using authenticated values xk. To this end, we employ another
proof system, namely efﬁcient linearly-homomorphic MACs
[18, 19], that are particularly suitable for linear computations

over authenticated data. Speciﬁcally, we designed a novel
homomorphic MAC (which is implicitly embedded in our
AD-SNARK construction) that ﬁts the above setting.

This technique, however, does not completely solve the
problem: a further complication arises from the fact that in
order to achieve zero-knowledge,
the value ain computed
by the prover must be randomized (by adding a random
multiple of the QAP target polynomial z(X)). Unfortunately,
homomorphic MACs are known to authenticate only determin-
istic computations. We solve this issue using the following
ideas. First, we provide a novel technique to publicly re-
randomize our homomorphic MACs: roughly speaking, by
publicly revealing a MAC of z(X). Second, we force the
prover to use the same random coefﬁcient for z(X) in both
ain and its MAC. Intuitively, this is achieved by asking the
prover to provide the linear combination ain in two distinct
subspaces. A ﬁnal observation is that by using a MAC we only
get secret-key veriﬁcation. Although this may not be an issue
in several applications, we also show how to further generalize
these techniques to obtain public veriﬁcation.

C. Organization
The paper is organized as follows. In Section II, we recall
common deﬁnitions and background information on QAPs.
Section III presents our deﬁnition of AD-SNARKs, the generic
construction, and a discussion on the efﬁciency of encoding
signature veriﬁcation with arithmetic circuits. We describe our
ADSNARK scheme in Section IV together with a theoretical
evaluation and comparison to the generic solution. In Section
V, we present our implementation and discuss the experimental
results. Section VI discusses further related work, and ﬁnally
Section VII concludes the paper. Extended proofs, and the
discussion of two extensions of AD-SNARKs – handling
multiple data sources, and achieving (amortized) constant-time
veriﬁcation – are deferred to the full version of our work [20].

II. BACKGROUND

In this section, we review the notation and some basic deﬁni-
tions that we will use in our work.
Notation. We will denote with λ ∈ N a security parameter. We
say that a function  is negligible if it vanishes faster than the
inverse of any polynomial. If not explicitly speciﬁed otherwise,
negligible functions are negligible with respect to λ. If S is
a set, x ←R S denotes the process of selecting x uniformly
at random in S. If A is a probabilistic algorithm, x ←R A(·)
denotes the process of running A on some appropriate input
and assigning its output to x. Moreover, for a positive integer
n, we denote by [n] the set {1, . . . , n}. We denote by F
a ﬁnite ﬁeld and Fn is the ﬁeld of size n. When n is a
prime number, then elements of Fn are represented as integers
modulo n. Elements of F are typically denoted by greek letters.
F[X] denotes the ﬁeld of polynomials in one variable X and
≤d[X] is the subring of polynomials
coefﬁcients in F, while F
in F[X] of degree at most d.

274274

s1

s2

s3

a=(7,3,-1,0,0,…)
b=(2,0,1,-4,0,…)

-1s2

3s1

2

7

+

s2

-4s3
+

x
s4

(a)

s1 s2

s3 s4

a=(4,2,1,0,0,0,0,0)
b=(5,1,3,0,0,0,0,0)

G5
s5

a=(1,0,0,4,3,0,0,0)
b=(3,0,0,0,2,0,0,0)

G6
s6

a=(0,0,0,0,0,1,0,0)
b=(0,0,0,0,0,0,1,0)

G7
s7

(b)

a0(r5)=4  b0(r5)=5 
a1(r5)=2  b1(r5)=1
a2(r5)=1  b2(r5)=3
c5(r5)=1        
a0(r6)=1  b0(r6)=3
a3(r6)=4  b4(r6)=2
a4(r6)=3  c6(r6)=1
a5(r7)=1  b6(r7)=1

c7(r7)=1

5

G
 
e
t
a
g

6

G
 
e
t
a
g

7

G
 
e
t
a
g

Figure 3. Part (a): A bilinear gate representing the arithmetic function (7 +
3s1 − 1s2) · (2 + s2 − 4s3) speciﬁed by coefﬁcients a and b.
Part (b): A QAP for an arithmetic circuit with 4 input wires, 1 output wire,
3 bilinear gates. The circuit encodes the function f (s1, s2, s3, s4) = (4 +
2s1 + s2) · (5 + s1 + 3s2) · (1 + 4s3 + 3s4) · (3 + 2s4). The non-zero
equations for the QAP polynomials are shown on the right.

Algebraic Tools. Let G(1λ) be an algorithm that, upon input
of the security parameter 1λ, outputs the description of (asym-
metric) bilinear groups bgpp = (p, G1, G2, GT , e,P1,P2)
where G1, G2, and GT are groups of the same prime order
p > 2λ; P1 ∈ G1 and P2 ∈ G2 are the respective generators;
and e : G1 × G2 → GT is an efﬁciently computable bilinear
map. We call such an algorithm G a bilinear group generator.
Note that G1 and G2 are additive groups, whereas GT is
a multiplicative group. In this work we rely on speciﬁc
computational assumptions in such bilinear groups: the q-DHE
[21], the q-BDHE [22], and the q-PKE [23] assumptions.
Arithmetic Circuits and QAPs. An arithmetic circuit C over
a ﬁnite ﬁeld F consists of addition and multiplication gates
and of a set of wires between the gates. The wires carry
values over F. As in previous work [11], here we consider
only arithmetic circuits with bilinear gates: a gate with inputs
#„x = (x1, . . . , xk) is bilinear if its output can be written
as inner product (cid:6) #„a , (1, x1, . . . , xk)(cid:7) · (cid:6) #„
b , (1, x1, . . . , xk)(cid:7) for
b ∈ Fk+1. Note that this deﬁnition includes addi-
some #„a ,
tion, multiplication, and constant gates (cf. Fig. 3(a) for an
example).

#„

Associated to any arithmetic circuit, we deﬁne a satisfaction

problem as follows.
Deﬁnition 1 (Arith. Circuit Satisfaction [11]): The circuit
satisfaction problem of a circuit C : Fn × Fh → Fl with
bilinear gates is deﬁned by the relation RC = {( #„x , #„w) ∈
Fn × Fh : C( #„x , #„w) = 0l} and its language is LC = { #„x ∈
Fn : ∃ #„w ∈ Fh, C( #„x , #„w) = 0l}.

The state-of-the-art SNARK schemes that we build on in
this paper directly operate on a different model to represent
computations called quadratic arithmetic programs (QAPs).
Deﬁnition 2 (QAP [17]): A quadratic arithmetic program
Q of size m and degree d over F consists of three vectors of
≤d−1[X] of degree at most
m + 1 polynomials #„a ,
d− 1, and a target polynomial z(X) ∈ F[X] of degree exactly
d.

b , #„c ∈ F

#„

Associated to any QAP,

deﬁned as follows.

there is a satisfaction problem

275275

#„

Deﬁnition 3 (QAP Satisfaction): The satisfaction problem
of a QAP Q = ( #„a ,
b , #„c , z) of size m and degree d is the
relation RQ of pairs ( #„x , #„s ) such that:
(1) #„x ∈ Fn, #„s ∈ Fm for some n ≤ m;
(2) xi = si for i ∈ [n], i.e., #„s extends #„x ;
(3) z(X) divides the polynomial p(X) deﬁned as
m(cid:4)

m(cid:4)

(cid:5)

(cid:3)
a0(X)+

p(X) =

siai(X)

b0(X)+

sibi(X)

(cid:5)·(cid:3)
m(cid:4)

i=1

− (cid:3)

c0(X) +

i=1
(cid:5)

sici(X)

i=1

The following result implies that one can use any QAP-
based SNARK scheme as an efﬁcient SNARK scheme taking
computations more conveniently represented as arithmetic
circuits.

#„

Lemma 1 (Constructing QAPs [11, 17]): There exist two
polynomial time algorithms QAPInst and QAPwit such that,
for any circuit C : Fn× Fh → Fl with u wires and v (bilinear)
b , #„c , z) = QAPInst(C) is a QAP of size m
gates, QC = ( #„a ,
and degree d over F satisfying the following properties:
Efﬁciency: m = u, and d = v + l + 1.
Completeness: For any ( #„x , #„w) ∈ RC, if it holds that #„s =
Proof of Knowledge: For any ( #„x , #„s ) ∈ RQC ,

QAPwit(C, #„x , #„w) then ( #„x , #„s ) ∈ RQC .
( #„x , #„w) ∈ RC where #„w is a preﬁx of #„s .

it holds

Non-Degeneracy: the polynomials a0(X), . . . , an(X) are all

nonzero and distinct.

#„

The very basic intuition for building a QAP according to
Lemma 1 is to encode the input-output correctness for each
bilinear gate in the polynomials #„a ,
b , #„c , z (see Fig. 3(b)
for a simple example). Slightly more in detail, for a gate
g this is done by ﬁrst selecting an arbitrary value rg ∈ F
(a “root”) and then, for every left wire i going to gate g,
one imposes ai(rg) = c, where c is the coefﬁcient which
multiplies the value of wire i in g’s left input (note that
c = 0 if wire i is not a left input). A similar process is
done for polynomials bi and ci w.r.t. right input and output
wires respectively.2 Once this procedure has been iterated for
every bilinear gate g (selecting distinct roots rg), one will have
essentially obtained three tables of size u·v with entries ai(rj),
bi(rj), and ci(rj), respectively, where i = 0 to u are all the
wires (where the 0 wire represents constants) and j = 1 to v
are all the bilinear gates. The ﬁnal QAP polynomials #„a ,
b , #„c
are built by extending each row i of the table into a polynomial
ai(X) (resp. bi(X), ci(X)) of degree v − 1 via interpolation
in F. The target polynomial z(X) is the degree-v polynomial
(cid:6)
deﬁned over the roots rg of the v bilinear gates: z(X) :=
g=1(X − rg).3 To see why the satisﬁability of the QAP
implies the satisﬁability of the circuit, the key observation is
that the third condition of Deﬁnition 3, i.e., z(X) | p(X),
2The case of ci is slightly different as coefﬁcients are only 0 or 1.
3More precisely,

in construction of Lemma 1 one needs to add one
“artiﬁcial” bilinear gate for every output wire, plus an additional constraint
to guarantee non-degeneracy: from which the ﬁnal degree is d = v + l + 1.

#„

v

#„

means that (cid:6)(1, #„s ), #„a (rg)(cid:7)·(cid:6)(1, #„s ),
b (rg)(cid:7) = (cid:6)(1, #„s ), #„c (rg)(cid:7)
for all roots rg of the target polynomial z(X). In other words,
given the speciﬁc construction of the polynomials, the input-
output correctness of every bilinear gate g of the circuit is
satisﬁed.

III. SNARKS OVER AUTHENTICATED DATA

In this section, we deﬁne the notion of SNARKs [16, 24]
on authenticated data (AD-SNARKs, for short). Let C :
Fn × Fh → Fl be an arithmetic circuit, and let RC =
{( #„x , #„w)} ⊆ Fn × Fh be the corresponding circuit satisfaction
relation, where #„x ∈ Fn is called the statement, and #„w ∈ Fh
is the witness.

In this work, we consider a setting in which (1) the
statement #„x (or part of it) is provided to the prover by a
trusted source S, and (2) the portion of #„x provided by S is
not known to V (see Figure 1 for illustration). Yet, V wants to
be convinced by P that ( #„x , #„w) ∈ RC holds for the speciﬁc
(cid:2) of P’s choice
#„x provided by S, and not for some other #„x
(which can still be in the language LC).
To formalize the idea that V checks that some values
unknown to V have been authenticated by S, we adopt the
concept of labeling used for homomorphic authenticators [19,
25]. Namely, we assume that the source S authenticates a set
of values Xauth = {xi, . . . , x(cid:3)} against a set of (public) labels
L = {Li, . . . , L(cid:3)} by using a secret authentication key (e.g., a
signing key). S then sends the authenticated Xauth to P. Later,
P’s goal is to prove to V that ( #„x , #„w) ∈ RC for a statement
#„x in which some positions have been correctly authenticated
by S, i.e., xi ∈ Xauth for some i ∈ [n].
For such a proof system, we deﬁne the usual properties
of completeness and soundness, and in addition, to model
privacy, we deﬁne a zero-knowledge property. Moreover, since
we are interested in efﬁcient and scalable protocols, we deﬁne
succinctness to model that the size of the proofs (and implicitly
the veriﬁer’s running time) should be independent of the
witness’ size h = | #„w|. Finally, we consider AD-SNARKs that
can have either public or secret veriﬁability, the difference
being in whether the adversary knows or not the veriﬁcation
key for the authentication tags produced by the data source S.
A. Deﬁnition of AD-SNARKs
Here we provide the formal deﬁnition for zero-knowledge
SNARKs over authenticated data.

Deﬁnition 4 (Zero-Knowledge AD-SNARK): A scheme
for Zero-Knowledge Succinct Non-interactive Arguments of
Knowledge over Authenticated Data for arithmetic circuit
satisﬁability consists of a tuple of algorithms (Setup, AuthKG,
Auth, AuthVer, Gen, Prove, Ver) satisfying authentication cor-
rectness, completeness, succinctness, adaptive proof of knowl-
edge, and zero-knowledge (as deﬁned below):
Setup(1λ): given the security parameter λ, output some com-
mon public parameters pp. The parameters also deﬁne
the ﬁnite ﬁeld F over which the circuits will be deﬁned.
AuthKG(pp): given the public parameters pp, the key gener-
ation algorithm outputs a secret authentication key sk, a

276276

veriﬁcation key vk, and public authentication parameters
pap.
Auth(sk, L, x): the authentication algorithm takes as input the
secret authentication key sk, a label L ∈ L, and a value
x ∈ F, and it outputs an authentication tag σ.
AuthVer(vk, σ, L, x): the authentication veriﬁcation algorithm
takes as input a veriﬁcation key vk, a tag σ, a label L ∈ L,
and a value x ∈ F. It outputs ⊥ (reject) or (cid:12) (accept).
Gen(pap, C): given the public authentication parameters pap
and an arithmetic circuit C : Fn×Fh → Fl, the algorithm
outputs an evaluation key EKC and a veriﬁcation key
VKC. Gen can hence be seen as a circuit encoding
algorithm.
Prove(EKC, #„x , #„w, #„σ ): on input an evaluation key EKC, a
statement #„x ∈ Fn, a witness #„w ∈ Fh, and authentication
tags for the statement #„σ = (σ1, . . . , σn), the proof algo-
rithm outputs a proof of membership π for ( #„x , #„w) ∈ RC.
We stress that #„σ does not need to contain authentication
tags for all positions: in case a value at position i is not
authenticated, the empty tag σi = (cid:6) is used instead.
L ,{xi}Li=(cid:4), π): given the veriﬁcation key vk,
a circuit veriﬁcation key VKC, labels #„
L = (L1, . . . , Ln)
for the statement, unauthenticated statement components
xi, and a proof π, the veriﬁcation algorithm outputs ⊥
(reject) or (cid:12) (accept).

Ver(vk, VKC,

#„

Intuitively,

CORRECTNESS.

authentication correctness

AUTHENTICATION
an
if
AD-SNARK scheme has
any tag σ generated by Auth(sk, L, x) authenticates x with
respect to L. More formally, we say that an AD-SNARK
scheme satisﬁes authentication correctness if for any value
x ∈ F, all keys (sk, vk, pap) in the range of AuthKG(1λ),
any label L ∈ L, and any authentication tag σ generated by
Auth(sk, L, x), we have that AuthVer(vk, σ, L, x) = (cid:12).
COMPLETENESS. This property aims at capturing that if the
Prove algorithm produces π when run on ( #„x , #„w, #„σ ) for some
( #„x , #„w) ∈ RC then veriﬁcation Ver(vk, VKC, L,{xi}Li=(cid:4), π)
will accept the proof whenever #„σ authenticates #„x with re-
spect to L. More formally, let us sample (sk, vk, pap) ←R
AuthKG(pp), ﬁx a circuit C : Fn × Fh → Fl and take
keys (EKC, VKC) ←R Gen(pap, C). Let ( #„x , #„w) ∈ RC
L = (L1, . . . , Ln) ∈ (L ∪ {(cid:6)})n be a
be given;
#„σ = (σ1, . . . , σn) be tags for
vector of labels, and let
the statement such that {AuthVer(vk, σi, Li, xi) = (cid:12)}Li(cid:4)=(cid:4).
Then if π ←R Prove(EKC, #„x , #„w, #„σ ), we require that
Ver(vk, VKC,
SUCCINCTNESS. Given a circuit C : Fn×Fh → Fl, the length
of the proof π is bounded by |π| = poly(λ)polylog(n, h).
ADAPTIVE PROOF OF KNOWLEDGE. Intuitively, the adaptive
proof of knowledge property captures that no malicious party
can produce proofs that verify correctly for a false state-
ment. We formalize our deﬁnition via an experiment, called
ExpAD-PoK
, which is described in Figure 4. The experiment is
parametrized by both an adversary A and an extractor E, and
it works for a class C of circuits. Both A and E run on the same

L ,{xi}Li=(cid:4), π) = (cid:12) with probability 1.

#„

let

#„

A,E

A,E (1λ, C, z):

ExpAD-PoK
pp ←R Setup(1λ)
(sk, vk, pap)←R AuthKG(pp)
GameOutput ← 0
S ← ∅, T ← ∅
AGen,Auth,Ver(pp, pap, z)

Return GameOutput

procedure Gen(C)
(EKC ,VKC )←R Gen(pap, C)
S ← S ∪ {(C, EKC , VKC )}
Return (EKC , VKC )

procedure Auth(L, x)
if (L, ·, ·) ∈ T Return ⊥
σ ←R Auth(sk, L, x)
T ← T ∪ {(L, x, σ)}
Return σ

L , {xi}Li=(cid:3), π)
procedure Ver(C, #„
if (C, ·, ·) /∈ S Return ⊥
fetch VKC with (C, ·, VKC ) ∈ S
L , {xi}Li=(cid:3), π)
v ← Ver(vk, VKC , #„
if v = (cid:8) then
if ∃ Li ∈ #„
L : (Li, ·, ·) /∈ T then
GameOutput ← 1
else
fetch #„x = (x1, . . . , xn) with
{(L1, x1, ·), . . . , (Ln, xn, ·)} ⊆ T
for all Li (cid:11)= (cid:4)
#„w ← E(pp, pap, z, S, aux E )
if ( #„x , #„w) /∈ RC then
GameOutput ← 1

// Type 1

// Type 2

Return v

Figure 4. Experiment for the adaptive proof of knowledge deﬁnition.

input and random tape, including some auxiliary input z. As
the only difference, E takes an additional input aux E which
includes: the secret authentication keys sk, vk, and all the
random coins used to run the Auth oracle. E is an algorithm
that, for every veriﬁcation query of A that is accepted by the
Ver algorithm, outputs a witness #„w. One should think of such
E as A itself, and the extraction capability intuitively means
that if A is able to produce an accepting proof, then A must
know the corresponding witness, and thus such witness can
be extracted from A’s memory. Note also that the additional
input aux E taken by E is generated independently of the
circuits in C, and thus it cannot help the extractor to generate
witnesses more than A can do. The three procedures Gen,
Auth, and Ver essentially give to the adversary oracle access
to the algorithms Gen, Auth, and Ver, respectively, with some
additional bookkeeping information, and under the restriction
that Gen is queried on a circuit C ∈ C. It is worth noting that
Ver returns the output of Ver, and additionally, checks whether
a proof accepted by Ver (i.e., v = (cid:12)) proves a false statement
according to RC. In this case, Ver sets GameOutput ← 1.
Adaptive proof of knowledge is formally deﬁned as follows.
Let C be a class of polynomially many circuits. We say
that a scheme satisﬁes adaptive proof of knowledge if for
any sufﬁciently large λ ∈ N, for any C and for every PPT
adversary A, there exists a PPT extractor E such that for
every polynomial-size auxiliary input z ∈ {0, 1}poly(λ) the
(C, 1λ, z) = 1] is negligible in λ.
probability Pr[ExpAD-PoK
Our deﬁnition above is inspired by the security deﬁnition
for homomorphic authenticators [18, 19, 25]. The catch here
is that there are essentially two ways to create a “cheating
proof”, and thus to break the adaptive proof of knowledge
of an AD-SNARK. The ﬁrst way, Type 1, is to produce an
accepting proof without having ever queried an authentication
tag for a label Li. This basically captures that, in order to create
a valid proof, one needs to have all authenticated parts of the
statement, each with a valid authentication tag. The second
way to break the security, Type 2, is the more “classical” one,
i.e., generating a proof that accepts for a tuple ( #„x , #„w) which

A,E

277277

ExpRealD,C (1λ) :
pp ←R Setup(1λ)
(sk, vk, pap) ←R D(1λ, pp)
(EKC , VKC ) ←R Gen(pap, C)
L , #„σ , #„w) ← D(EKC , VKC )
( #„x , #„
π ←R Prove(EKC , #„x , #„w, #„σ )
if ( #„x , #„w) /∈ RC ∨
∃i ∈ [n],

AuthVer(vk, σi, Li, xi ) = ⊥

then Return 0
else Return D(π)

ExpSimD,C (1λ) :
pp ←R Setup(1λ)
(sk, vk, pap) ←R D(1λ, pp)
(EKC , VKC , td)

←R Sim1(sk, vk, pap, pp, C)
L , #„σ , #„w) ← D(EKC , VKC )

( #„x , #„
π ←R Sim2(td, L, {xi}Li=(cid:3))
if ( #„x , #„w) /∈ RC ∨

then Return 0
else Return D(π)

∃i ∈ [n],

AuthVer(vk, σi, Li, xi ) = ⊥

Figure 5. Experiments for the zero knowledge deﬁnition.

is not the correct one, i.e., ( #„x , #„w) (cid:14)∈ RC.
Second, we note that the above game deﬁnition captures
the setting in which the veriﬁcation key vk is kept secret.
The deﬁnition for the publicly veriﬁable setting is obtained
by providing vk to the adversary.
ZERO-KNOWLEDGE. Loosely speaking, a zero-knowledge
AD-SNARK is an AD-SNARK in which the Prove algorithm
generates proofs π that reveal no information: neither about
the witness, nor about the authenticated statements. In other
words, the proofs do not reveal anything beyond what is known
by the veriﬁers when checking a proof.
Formally, let C ∈ C be an arithmetic circuit. Then an
AD-SNARK is zero-knowledge if there exists a simulator
Sim = (Sim1, Sim2), such that for all PPT distinguishers
D, the following difference is negligible | Pr[ExpRealD,C(1λ) =
1] − Pr[ExpSimD,C(1λ) = 1]|, where the experiments Real and
Sim are deﬁned as in Figure 5. We note that the distinguisher
D in these experiments has a shared state that is persistent
over all invocations of D.

We stress that the above zero-knowledge notion aims at
capturing, in the strongest possible sense, that the veriﬁer
cannot learn any useful information on the inputs, even if it
knows (or chooses) the secret authentication key. Indeed, as
one can see, our deﬁnition allows the distinguisher to choose
the authentication key pair as well as the authentication tags.
We also remark that the notion of AD-SNARKs immedi-
ately implies a corresponding notion of veriﬁable computation
on authenticated data (similar to [19]). In [24], it is dis-
cussed how to construct a veriﬁable computation scheme from
SNARGs for NP with adaptive soundness. This is simply
based on the fact that the correctness of a computation can be
described with an NP statement. It is not hard to see that, in
a very similar way, one can construct veriﬁable computation
on authenticated data from AD-SNARKs.
B. A Generic Construction
We show how to construct a zero-knowledge AD-SNARK
scheme from SNARKs and digital signatures. A similar con-
struction was informally sketched in [24][Appendix 10.1.2 of
the full version]. Here we make it more formal with the main
purpose of offering a comparison with our direct AD-SNARK
construction proposed in the next section.

The high-level idea of the generic construction is to em-
=

bed digital signatures into SNARKs. Let

therefore Π

(cid:2)

(cid:2)

(cid:2)
, Prove

(cid:2)

(Gen
Σ.Sign, Σ.Ver) be a signature scheme.

, Ver

) be a SNARK scheme, and Σ = (Σ.KG,

We will use the signature scheme to sign pairs consisting
of a label L and an actual message m. Although labels
and messages can be arbitrary binary strings, for ease of
description we assume that labels can take a special value
(cid:6). Also, we modify the signature scheme in such a way that
Σ.Sign(sk, (cid:6)|m) = (cid:6) and Σ.Ver(vk, (cid:6)|m
(cid:2)
, (cid:6)) = 1. Basically,
we let everyone (trivially) generate a valid signature on a
message with label (cid:6).

We deﬁne an AD-SNARK Π = (Setup, AuthKG, Auth,

AuthVer, Prove, Ver) as follows.
Setup(1λ): Output pp = 1λ.
AuthKG(pp): run (sk

, vk

(cid:2)

(cid:2)

(cid:2)
key pair of the signature scheme and return sk = sk
(cid:2)
vk = pap = vk

) ←R Σ.KG(1λ) to generate the
and

.

(cid:2)

(cid:2)

(cid:2)

(cid:2)

(cid:2)

(cid:2)

(cid:2)

(cid:2)

(cid:2)

).

, L

(vk

: Fn

, L|x, σ

Auth(sk, L, x): compute a signature on the concatenation of
, L|x).

(cid:2) ← Σ.Sign(sk

the label L and the value x, i.e., σ
Finally, output σ = (σ

signature veriﬁcation algorithm Ver

, L).
). Output the result of the
AuthVer(vk, σ, L, x): let σ = (σ
Gen(pap, C): for the given circuit C : Fn × Fh → Fl we
(cid:2) as the circuit that outputs 0l on all the pairs
deﬁne C
( #„x , #„w) such that C( #„x , #„w) = 0l and each xi is correctly
signed with respect to a set of labels and a public key.
(cid:2) × Fh
(cid:2) → Fl as the
More formally, deﬁne C
(cid:2)
(cid:2)
) with #„x
circuit that takes as inputs pairs ( #„x
, #„w
=
(cid:2)
(y1, L1, . . . , yn, Ln, vk) and #„w
= ( #„w, z1, σ1, . . . , zn, σn)
such that, by setting xi = yi if Li = (cid:6) and xi = zi other-
wise, for all i ∈ [n], it holds: (i) ((x1, . . . , xn), #„w) ∈ RC,
and (ii) Σ.Ver(vk, Li|xi, σi) = 1.
Finally, run Gen
(1λ, C
(cid:2)
output EKC = EK
C
Prove(EKC, #„x , #„w, #„σ ): Let EKC be an evaluation key as
deﬁned above, ( #„x , #„w) ∈ Fn × Fh be a statement-
witness pair, and #„σ = (σ1, . . . , σn) be a tuple of
the
authentication tags for
(cid:2)
tags verify correctly, deﬁne #„x
= (y1, L1, . . . , yn, Ln,
n) so that for all i ∈ [n]:
(cid:2)
(cid:2)
(cid:2)
vk), #„w
= ( #„w, z1, σ
1, . . . , zn, σ
zi = xi, yi = xi if σi = (cid:6) and yi = 0 otherwise. Next,
run π ←R Prove(EK
(cid:2)
) to generate a proof for
, #„w
) ∈ RC
(cid:2) and return π.
( #„x
L ,{xi}Li=(cid:4), π): given the veriﬁcation key vk,

#„x = (x1, . . . , xn). If all

(cid:2)
(cid:2), VKC = VK
C

) to generate (EK

Ver(vk, VKC,

(cid:2)
(cid:2) , #„x

(cid:2) ) and

(cid:2) , VK

, #„w

(cid:2)
C

(cid:2)
C

(cid:2)
C

(cid:2).

(cid:2)

(cid:2)

#„

(cid:2)

(cid:2)

a circuit veriﬁcation key VKC, statement labels #„
L =
(L1, . . . , Ln), unauthenticated statement components xi,
(cid:2)
and a proof π, the veriﬁcation algorithm deﬁnes #„x
=
(y1, L1, . . . , yn, Ln, vk) with yi = xi
if Li = (cid:6) and
yi = 0 otherwise. Finally,
it returns the output of
Ver

(cid:2)
(cid:2) , #„x

, π).

(VK

(cid:2)

(cid:2)
C

= n + n·|Li| +|vk| and h

(cid:2) is a circuit larger than C as
Note that the input size of C
= h + n + n·|σ|, where
(cid:2)
follows: n
|vk|, |Li|, and |σ| represent the size, in terms of ﬁeld elements,
of the public key, a label, and a signature, respectively. In terms
(cid:2) is at least as large as C plus the circuit
of gates and wires, C
size of Σ.Ver for every signature veriﬁcation, that is up to n

(cid:2)

of such circuits.

Theorem 1: If Π

(cid:2) is a zero-knowledge SNARK and Σ is a
secure digital signature, then the scheme described above is a
zero-knowledge AD-SNARK.

A proof sketch appears in the full version [20].

C. Signature Veriﬁcation Overhead
(cid:2) resulting from explicitly
We now discuss why the circuit C
encoding the veriﬁcation algorithm of a digital signature
scheme, as described in the generic construction, is bound to
render the construction very inefﬁcient. We consider various
examples of signatures in both the random oracle and the
standard model, and based on different algebraic problems.

If one considers signature schemes in the random oracle
model (which include virtually all the schemes used in prac-
tice), any such scheme uses a collision-resistant hash function
(e.g., SHA-1) which is thus part of the veriﬁcation algorithm
computation. Unfortunately, as shown also in [9], a QAP (just)
for a SHA-1 computation is terribly inefﬁcient due to the high
number of multiplication gates (roughly 24 000, for inputs
of 416 bits). On the other hand, if we focus on standard
model signature schemes, it does not get any better: These
schemes involve speciﬁc algebraic computations, and encoding
these computations into an arithmetic circuit over a ﬁeld Fp
is costly. For instance, signatures based on pairings [26, 27]
require pairing computations that amount to, roughly, 10 000
multiplications. RSA-based standard-model signatures (e.g.,
Cramer-Shoup [28]) require exponentiations over rings of large
order (e.g., 3 000 bits), and simulating such computations over
Fp ends up with thousands of multiplication gates as well.
Lattice-based signatures (in the standard model), e.g., [29], can
be cheaper in terms of the number of multiplications. However,
such multiplications typically work over Zq for a q much
smaller than our p. An option would be to implement mod-
q-reductions in Fp circuits, which is costly. Another option
would be to let these schemes work over Zp, but then one
has to work with higher dimensional lattices (or polynomial
rings) for security reasons, again incurring a large number of
multiplications.

This state of affairs suggests that a QAP encoding a signa-
ture veriﬁcation circuit is likely to require at least (and this
is a very optimistic estimate) one thousand multiplications for
every signature that must be checked.

IV. OUR CONSTRUCTION OF ZERO-

KNOWLEDGE AD-SNARKS

In this section we describe our construction of an AD-SNARK
scheme for the satisﬁability of arbitrary arithmetic circuits. The
scheme can be used with either secret or public veriﬁability.
The main difference between the two veriﬁcation modes is
that
the size of the proof in the secretly veriﬁable case
is a ﬁxed constant, whereas in the publicly veriﬁable case,
the proof grows linearly with the number of authenticated
statement values. Although we lose constant-size proofs for
public veriﬁability, we stress that: (i) proofs are linear only
in the number N ≤ n of authenticated values and their size

278278

does not depend on the complexity of the circuit, and (ii) the
veriﬁcation algorithm runs linearly in N in any case (even
in the generic construction). Furthermore, when considering
concrete implementations and applications, although the proof
size of ADSNARK with public veriﬁability is not constant, it
still scales very well, e.g., the size of an ADSNARK proof
for a monthly electricity bill is under 170 KB vs. a constant-
size proof of 0.3 KB when using the generic scheme with
[11]. In contrast, when considering the prover’s performance,
ADSNARK remains in the realm of practicality – 18 seconds
for a monthly bill – whereas for the generic scheme the timing
goes up to 10 minutes.

For veriﬁers that know the secret authentication key (e.g.,
as in a smart metering/insurance application where companies
install a symmetric key in the devices), ADSNARK proofs
have constant size, and – crucially – the knowledge of such a
secret key by the veriﬁer does not compromise privacy.

Our scheme is proven secure under two computational
assumptions in bilinear groups, the q-Difﬁe-Hellman Exponent
assumption (q-DHE) [21] and the q-Power Knowledge of
Exponent assumption (q-PKE) [23]. We note that the latter one
is a non-falsiﬁable assumption. As discussed in Section VI,
this kind of assumption is likely to be inherent for SNARKs
for NP. For privacy, we show that the scheme offers sta-
tistical zero-knowledge. We stress that this property holds
even against adversaries who know (and even generate) the
authentication keys.

A detailed description of our scheme follows.
Setup(1λ): On input the security parameter 1λ, run pp = (p,
G1, G2, GT , e,P1,P2) ←R G(1λ) to generate a bilinear
group description, where G1, G2, and GT are groups of the
same prime order p > 2λ, P1 ∈ G1 and P2 ∈ G2 are the
respective generators, and e : G1×G2 → GT is an efﬁciently
computable bilinear map. We let the ﬁnite ﬁeld F be the set
of integers modulo p.

(cid:2)

(cid:2)

, vk

)←R Σ.KG(1λ) for
AuthKG(pp): Create a key pair (sk
a regular signature scheme. Run (S, prfpp) ←R F.KG(1λ)
to obtain the seed S and the public parameters prfpp of
a pseudorandom function FS : {0, 1}∗ → F. Choose a
random value κ ←R F and compute K1 = κP1 ∈ G1,
K2 = κP2 ∈ G2. Return the secret key sk = (sk
, S, κ),
, K2), and the public
the public veriﬁcation key vk = (vk
authentication parameters pap = (pp, prfpp, K1).
Auth(sk, L, x): To authenticate a value x ∈ F with label L,
generate φ ← FS(L) using the PRF, compute μ = φ+κ·x ∈ F
and Φ = φP2 ∈ G2. Then compute a signature σ
(cid:2) ←R
).
Σ.Sign(sk

, Φ|L), and output the tag σ = (μ, Φ, σ

(cid:2)

(cid:2)

(cid:2)

(cid:2)

(cid:2)

, K2) be the veriﬁcation
AuthVer(vk, σ, L, x): Let vk = (vk
(cid:2)
) is a valid authentication
key. To verify that σ = (μ, Φ, σ
tag for a value x ∈ F with respect to label L, output (cid:12) if
μP2 = Φ + x K2 in G2, and if Σ.Ver(vk
) = 1.
Output ⊥ otherwise. In the secret key setting (i.e., if vk is
replaced by sk), the tag σ can be veriﬁed by checking whether

, Φ|L, σ

(cid:2)

(cid:2)

μ = FS(L) + κ·x.
Gen(pap, C): Let C : Fn × Fh → Fl be an arithmetic circuit.
To generate the keys, proceed as follows.
1) Compute QC = ( #„a ,
QAP of size m and degree d for C. Recall that #„a ,
are vectors of m + 1 polynomials in F
target polynomial z ∈ F[X] has degree d. Extend #„a ,
with 3 more polynomials each, by setting:

b , #„c , z) = QAPInst(C) to build a
b , #„c
≤d−1[X], while the
b , #„c

#„

#„

#„

am+1 = z
bm+1 = 0
cm+1 = 0

am+2 = 0
bm+2 = z
cm+2 = 0

am+3 = 0
bm+3 = 0
cm+3 = z

Let Ix , Imid be the following partitions of {1, . . . , m + 3}:
Ix = {1, . . . , n}, Imid = {n + 1, . . . , m + 3}. In other
words, we partition all the circuit wires into the n statement
wires Ix , and the remaining “internal” wires Imid (which
include the h witness wires).
2) Pick ρa, ρb, τ, αa, αb, αc, β, γ ←R F uniformly at ran-
dom, set ρc = ρa · ρb, and compute the following values:

Ka = z(τ ) ρa K1

Z = z(τ )ρc P2
∀k ∈ {0, ..., m + 3} :
k = αa ak(τ )ρa P1
Ak = ak(τ )ρa P1
(cid:2)
A
k = αb bk(τ )ρb P1
Bk = bk(τ )ρb P2
(cid:2)
k = αc ck(τ )ρc P1
Ck = ck(τ )ρc P1
(cid:2)
Ek = β(ak(τ )ρa + bk(τ )ρb + ck(τ )ρc)P1

B

C

3) Output the evaluation key EKC and the veriﬁcation key
VKC deﬁned as follows:

(cid:3)
EKC =

VKC =

(cid:2)

(cid:2)

#„
#„
#„
A
QC,
A,
C,
{τ i P1}
i∈{0,...,d}, Ka

#„
B,

#„
B

,

,

(cid:2)

#„
C
(cid:5)

#„
E,

,

(cid:3) P1, P2, αa P2, αb P1, αc P2, Z,
γ P2, β γ P1, β γ P2, {Ak}n

k=0

(cid:5)

Prove(EKC, #„x , #„w, #„σ ): Let EKC be an evaluation key deﬁned
as above, ( #„x , #„w) ∈ Fn× Fh be a statement-witness pair, and
σ = (σ1, . . . , σn) be a tuple of authentication tags for x such
that, for any i ∈ [n], either σi = (μi, Φi, σ
(cid:2)
i) or σi = (cid:6). We
deﬁne Iσ = {i ∈ Ix : σi (cid:14)= (cid:6)} ⊆ Ix as the set of indices
for which there is an authenticated statement value, and let
I(cid:4) = Ix \ Iσ be its complement. To produce a proof for the
satisﬁability of C( #„x , #„w) = 0l proceed as follows.
1) Compute #„s = QAPwit(C, #„x , #„w) ∈ Fm (and recall that
si = xi for all i ∈ [n]).
2) Randomly sample δσ
a + δmid
δσ
Fm+4.

, δb, δc ←R F, and set δa =
. Also, deﬁne the vector #„u = (1, #„s , δa, δb, δc) ∈

a , δmid

a

a

3) Solve the QAP QC by computing the coefﬁcients
(h0, . . . , hd) ∈ Fd+1 of the polynomial h ∈ F[X] such
that h(X)z(X) = a(X)b(X)− c(X), where a, b, c ∈ F[X]

279279

are

a(X) = a0(X) +

b(X) = b0(X) +

c(X) = c0(X) +

(cid:4)

k∈[m]
(cid:4)

k∈[m]
(cid:4)

k∈[m]

sk · ak(X) + δa · z(x)
sk · bk(X) + δb · z(x)
sk · ck(X) + δc · z(x)

Then compute H = h(τ )P1 using the values τ i P1
contained in the evaluation key EKC. Note that we have
a(X) = (cid:6) #„u , #„a(cid:7), b(X) = (cid:6) #„u ,
4) Compute the following values:

b (cid:7) and c(X) = (cid:6) #„u , #„c (cid:7).

#„

πc = (cid:6) #„u ,
c = (cid:6) #„u ,
(cid:2)

π

#„

C(cid:7)
(cid:2)(cid:7)
# „
C

π

πb = (cid:6) #„u ,
b = (cid:6) #„u ,
(cid:2)
πσ = (cid:6) #„u ,
σ = (cid:6) #„u ,
(cid:2)
π
πmid = (cid:6) #„u ,
mid = (cid:6) #„u ,
(cid:2)
π
πE = (cid:6) #„u ,

#„

B(cid:7)
(cid:2)(cid:7)
# „
B
A(cid:7)Iσ + δσ
#„
a Am+1
(cid:2)(cid:7)Iσ + δσ
(cid:2)
a A
m+1
− δσ
A(cid:7)Imid
a Am+1
(cid:2)(cid:7)Imid
− δσ
# „
A
a A
E(cid:7)
#„

(cid:2)
m+1

# „
A
#„

5) Authenticate the value πσ by computing

#„

πμ = (cid:6) #„μ ,
return
(cid:2)
mid , πb, π

A(cid:7)Iσ + δσ
proof
(cid:2)
b, πc, π

a Ka

π

as

and

tuple
the
6) Construct
(cid:2)
(cid:2)
c, πE, H). To make
(πμ, πσ, π
σ, πmid , π
}k∈Iσ.
the proof publicly veriﬁable, include also {Φk, σ
(cid:2)
k
Ver(vk, VKC, L,{xi}Li=(cid:4), π ): Let VKC be the veriﬁcation
key for the circuit C, #„
L = (L1, . . . , Ln) be a vector of labels,
and let π be a proof as deﬁned above. In a similar way as
in Prove, we deﬁne Iσ = {i ∈ Ix : Li (cid:14)= (cid:6)} ⊆ Ix and
I(cid:4) = Ix \ Iσ. The veriﬁcation algorithm computes A(cid:4) =
A0 + (cid:6) #„x ,
(A.1secret)
If veriﬁcation is done using the secret key sk =
(S, κ), check the authenticity of πσ against the labels #„
L
by checking whether the following equation holds in G1:4

A(cid:7)I(cid:3) and proceeds as follows:

#„

πμ = (cid:6)FS(

#„
L ),

#„

A(cid:7)Iσ + κ πσ

(A.1public)
If the veriﬁcation is performed using the public
, K2): ﬁrst, check the validity
veriﬁcation key vk = (vk
(cid:2)
of all Φk by verifying that Σ.Ver(vk
k) = 1
for all k ∈ Iσ; second, check the authenticity of πσ by
verifying that the following equation is satisﬁed over GT :

, Φk |Lk, σ

(cid:2)

(cid:2)

(cid:7)

e( πμ ,P2) =

e(Ak, Φk) · e( πσ , K2)

k∈Iσ

(A.2) Check the validity of knowledge commitments for the
authenticated values:
σ , P2) = e( πσ , αaP2)
(cid:2)
L ), #„A(cid:14)I is deﬁned as the component-wise appli-

e( π
4The expansion of (cid:13)FS ( #„

cation of F, i.e.,

(cid:2)

i∈I FS (Li) · Ai.

(P.1) Check the satisﬁability of the QAP:

e(A(cid:4) + πσ + πmid , πb ) = e( H , Z) · e( πc , P2)

(P.2) Check the validity of knowledge commitments:

e( π

mid , P2) = e( πmid , αaP2) ∧
(cid:2)
b ,P2) = e(αbP1, πb ) ∧
(cid:2)
e( π
c , P2) = e( πc , αcP2)
(cid:2)

e( π

(P.3) Check that all the QAP linear combinations use the
same coefﬁcients:
e( πE , γP2) =
e(A(cid:4) + πσ + πmid + πc , βγP2) · e(βγP1, πb )
If all checks above are satisﬁed, return (cid:12); otherwise ⊥.
ReRand(EKC, L,{xi}Li=(cid:4), π): The scheme also allows for
perfect re-randomization of an existing proof, say π given
(cid:2)
c, πE, H). If π
by tuple (πμ, πσ, π
veriﬁes for a set of labels L and a set of non-authenticated
values {xi}Li=(cid:4), then π can be re-randomized as follows.
, ˜δb, ˜δc ←R F, and set
First, choose random values ˜δσ
˜δa = ˜δσ

a
. Second, compute

(cid:2)
σ, πmid , π

(cid:2)
mid , πb, π

(cid:2)
b, πc, π

a , ˜δmid

a

(cid:2)
(cid:2)
(cid:2)
b + ˜δb B
˜π
b = π
m+2
(cid:2)
(cid:2)
c = πc + ˜δc C
˜π
m+3
(cid:2)
(cid:2)
(cid:2)
σ + ˜δσ
σ = π
a A
m+1

a + ˜δmid
˜πb = πb + ˜δb Bm+2
˜πc = πc + ˜δc Cm+3
˜πσ = πσ + ˜δσ
a Am+1
mid
˜πmid = πmid + ˜δ
a Am+1
(cid:2)
(cid:2)
mid
mid + ˜δ
˜π
a A
mid = π
˜πE = πE + ˜δa Em+1 + ˜δb Em+2 + ˜δc Em+3
˜πμ = πμ + ˜δσ
˜H = H + ˜δaπb + ˜δbπa + ˜δa˜δbz(τ )P1 − ˜δc P1

(cid:2)
m+1

a Ka

˜π

where z(τ )P1 can be included in EKC. Finally, output the
re-randomised proof ˜π as
(˜πμ, ˜πσ, ˜π
It is not hard to check that ˜π is identically distributed as a
fresh proof π generated by Prove.

(cid:2)
σ, ˜πmid , ˜π

(cid:2)
c, ˜πE, ˜H).

(cid:2)
mid , ˜πb, ˜π

(cid:2)
b, ˜πc, ˜π

The following theorem shows that the scheme ADSNARK

described above is a zero-knowledge AD-SNARK.

Theorem 2: If F is a pseudorandom function, and the q-PKE
[23] and the q-DHE [21] assumptions hold, then ADSNARK
is a secretly-veriﬁable zero-knowledge AD-SNARK. Fur-
thermore,
if additionally Σ is a secure signature scheme,
then ADSNARK is a publicly-veriﬁable zero-knwoledge
AD-SNARK.
Security Intuition. A proof of the theorem appears in the full
version [20]. Here we provide only an intuition. The complete-
ness of the scheme follows from the properties of the QAP
and from the construction of the authentication mechanism. As
an intuition for seeing why the scheme has adaptive proof of
knowledge, note that the adversary can fool the veriﬁcation
equation in three ways: (i) a false proof involving a label
that was never queried during the game; (ii) a false proof

280280

involving labels L1, . . . , Ln that were all queried during the
experiment for values x1, . . . , xn, but such that the element
πσ does not encode all x1, . . . , xn; (iii) a false proof in which
all labels L1, . . . , Ln were queried and the element πσ encodes
exactly the same x1, . . . , xn authenticated with the respective
labels during the security game. The hardness of breaking
the security in case (i) follows by the pseudorandomness of
the PRF: equation (A.1) will indeed use a value FS(Lk) that
was never seen by the adversary and that is pseudorandomly
distributed in F; roughly speaking, this means that (A.1) can be
satisﬁed only with negligible probability 1/p ≈ 2
−λ. Breaking
the security in case (ii) reduces to breaking the security of the
linearly-homomorphic MAC, i.e., the adversary should be able
to come up with a πμ and an incorrect πσ that satisfy equation
(A.1). Producing such incorrect values intuitively requires to
know the secret key κ: we formally prove this by showing that
any adversary breaking the security in this case can be reduced
to an adversary breaking the q-DHE assumption [21] in the
underlying bilinear groups. Breaking security in the last case
(iii) essentially means that the adversary is providing a false
proof using the same values that were correctly authenticated.
For this case the intuition is that the adversary must break the
PGHR SNARK; we formally prove this argument by relating
the security of the two schemes accordingly.

A very similar proof applies to the publicly veriﬁable setting
where the main difference is that the hardness of case (i) stems
from the hardness of breaking the signature scheme. Note that
in the publicly veriﬁable case, our AD-SNARK satisﬁes a
relaxed notion of succinctness in which the proof does not
depend on the complexity of the computation but may depend
linearly on the number of authenticated inputs.

Finally, the intuition behind the zero-knowledge property
of ADSNARK is that
the proof elements πσ, πmid , πb, πc
are statistically randomly distributed, while the remaining
elements are uniquely determined by the veriﬁcation equations
once the above elements are ﬁxed.

Performance and Comparison. Here we pause to discuss
the performance of our scheme ADSNARK in comparison
with the PGHR SNARK [9]. More precisely, we consider its
optimization proposed by Ben-Sasson et al. [11].

that

First, we note that the Gen algorithm is virtually the same
in both schemes except
in ADSNARK we have one
more exponentiation5 in G1 to generate Ka = z(τ ) ρa K1.
Also, from a bandwidth point of view, the evaluation key of
EKC of ADSNARK contains only one more G1 element, Ka,
compared to the evaluation key of PGHR. The veriﬁcation key
instead is the same in both schemes.

Second, let us focus on the differences in the Prove algo-
rithm. ADSNARK’s Prove has to compute three more G1 ele-
(cid:2)
ments: πσ, π
σ, and πμ. Generating these elements amounts to
performing three multi-exponentiations that involve N = |Iσ|
terms each. When looking at the proof size, ADSNARK’s

5We use the term “exponentiation” only for ‘historical’ reasons, as G1 is

actually an additive group.

n

(cid:2)

(cid:2)

proof contains such three additional elements in the group G1,
plus the signatures {σk}k∈Iσ in the publicly veriﬁable setting.
Third, we analyze the differences between ADSNARK and
PGHR in the Ver algorithm. The equations (P.1), (P.2), and
(P.3) are identical
in both schemes and thus require the
same computational effort. In PGHR one computes Ax =
k=1 xkAk ∈ G1, whereas in ADSNARK we compute
A0 +
k∈I(cid:3) xkAk ∈ G1 which involves
a similar value A(cid:4) = A0 +
fewer terms: precisely |I(cid:4)| = n − N. Then, ADSNARK
has to perform some additional computation for verifying
equations (A.1) and (A.2). (A.2) costs only two pairings – a
constant overhead. The ﬁrst equation instead requires different
computations according to whether we are in the secretly
veriﬁable case ((A.1)secret) or in the publicly veriﬁable case
((A.1)public). (A.1)secret
requires one multi-exponentiation
with N = |Iσ| terms (plus the cost of running the PRF which
is unnoticeable compared to the multi-exponentiation). Hence,
considering the cost of computing Ax in PGHR and the total
cost of computing A(cid:4) and (A.1)secret in ADSNARK, these
are essentially the same. In other words, ADSNARK’s secretly
veriﬁable case is slightly slower than PGHR for the cost of
computing two pairings in (A.2).
In the publicly veriﬁable case, equation (A.1)public requires
to check a total of N signatures, {σk}k∈Iσ, and then to com-
pute e(πμ,P2)e(πσ,−K2) and
k∈Iσ e(Ak, Φk). In general,
note that the veriﬁcation of such N signatures can be done
by using batching techniques, and the “multi pairings” can
also be computed efﬁciently. In particular, as we show in our
instantiation, this cost is close to the cost of computing Ax in
PGHR. In other words, ADSNARK’s publicly veriﬁable case
is slightly slower than PGHR for the cost of computing the
pairings in (A.1) and (A.2) and for checking the signatures.
In Section V, we give concrete comparisons resulting from
our experiments, which are consistent with the analysis above.
Indeed, we show based on concrete timings that ADSNARK
performs almost as PGHR used without authenticated data.
These results conclude that our technique added an important
property to the SNARK at almost no cost.

(cid:6)

However, for the sake of fairness, we should also consider
a comparison of the two protocols when they are used to pro-
vide equivalent guarantees, i.e., when proving statements on
authenticated data. To this end, we now compare ADSNARK
against the best possible instantiation of the generic construc-
tion of Section III-B, which we take to be PGHR working with
(cid:2). We call this scheme AD-PGHR. In
the “extended” circuit C
our analysis, we assume that the veriﬁcation of every signature
requires an arithmetic circuit with c multiplication gates, and
also assume (very optimistically) that this is the only additional
(cid:2). This means that: if C yields a QAP
cost for the design of C
(cid:2) yields a QAP of, at least,
of size m and degree d, then C
(cid:2)
= m + cN and degree d
= d + cN.
size m

(cid:2)

In AD-PGHR, the performance of Ver remains the same
as the one of Ver in PGHR discussed above. On the other
hand, the Prove algorithm of AD-PGHR heavily depends on
(cid:2). Precisely, Prove performs
the QAP size m

(cid:2) and degree d

281281

2

(cid:2)

d

(cid:2) and d
multi-exponentiations with m
division operation whose cost is O(d

(cid:2) terms, and a polynomial
(cid:2)
log

).

In conclusion, if we ﬁx a circuit C and a number N of
authenticated values, and we compare ADSNARK for circuit
C against AD-PGHR for the same C (i.e., PGHR with the
extended circuit C

(cid:2)), then we obtain:

For secret veriﬁcation, both schemes perform almost the
same,
the only difference being that we need to perform
two more pairings; for public veriﬁcation, ADSNARK has
an additional cost of one multi-pairing computation with N
terms plus the signature veriﬁcation. For proof generation,
AD-PGHR has to perform additional operations that involve a
factor at least linear in c · N. We recall from the discussion
in Section III-C that such c is likely to be larger than 1000.
Therefore, one can see that while our solution charges a
little more to the veriﬁer (and only in the public veriﬁcation
case), the costs of our scheme on the prover side can be
much cheaper, at least by a factor c · N. We conﬁrm the
above asymptotic comparison in Section V by showing the
experimental results obtained by running our implementation.

V. EVALUATION

We now describe our implementation of the ADSNARK
scheme proposed in Section IV and then present
the ex-
perimental results we obtained to support the efﬁciency and
practical applicability claims for our construction.
A. Implementation

We have implemented our ADSNARK scheme as an exten-
sion to the libsnark library6 [10, 11]. Our scheme extends the
PGHR SNARK implementation offered by this library and
supports the same class of statements expressed in the NP-
complete language R1CS (rank-1 constraint systems), which
is similar to arithmetic circuit satisﬁability. The resulting
implementation is totally generic, following the libsnark code
writing policies, and can be instantiated with arbitrary digital
signatures and PRF constructions (in addition to the various
parameterization options already offered by the libsnark li-
brary). The source code is available upon request.

The modiﬁcations to the original PGHR SNARK implemen-
tation required by our extensions were relatively small.7 In
the global parameter generation algorithm, the modiﬁcations
were limited to one additional exponentiation. In the sym-
metric veriﬁcation algorithm, we replaced the computations
performed on the (known) inputs with (essentially equivalent)
computations on the corresponding authentication elements.8

6libsnark is available from https://github.com/scipr-lab/libsnark. Details on

the publication of our libsnark extension can be found in the full version.

7This would be expected from the theoretical description of our scheme, but
praise should also go to the developers of the libsnark library, who produced
a nice, modular and well documented implementation on which it was easy
to build upon.

8We deviate slightly from the original implementation in the way we
store these input authentication elements. We use a simple (dense) vector
representation as opposed to the more elaborate (sparse) map representation
in the original. This originated a slight improvement in veriﬁcation times in
the experiments we conducted, but this is simply due to the fact that we did
not explore more complex input handling scenarios, where our representation
of inputs data might prove less adequate.

In the prover algorithm, the extra code comprises the three
multi-exponentiations required to compute the extra authenti-
cation elements. Finally, our extensions are most visible in the
public veriﬁcation algorithm where, in addition to the digital
signature veriﬁcation operations, the number of pairings to
be computed also increases linearly with the number of au-
thenticated inputs. Our implementation strategy was to employ
the optimizations available in the libsnark codebase whenever
possible, taking advantage of the existing multi- and batch-
exponentiation algorithms. The additional pairing computa-
tions required in public veriﬁcation are performed two-by-two,
exploiting the available double Miller loop optimization.

For the extra cryptographic components required by our
construction, i.e., the generic signature scheme and the PRF
mapping labels to ﬁeld elements, we have turned to the state-
of-the-art implementations offered by the most recent version
of the Supercop framework.9 For the signature scheme, we
have used the ed2551910 implementation described in [30],
which offers extremely fast batch veriﬁcation that we incor-
porated in the ADSNARK public veriﬁcation algorithm (recall
that one signature per input must be veriﬁed). For the PRF im-
plementation, we have ﬁxed labels to be 128-bit binary strings
and the PRF key to be a 256-bit string partitioned as two
AES keys. The PRF construction uses one AES computation
to map the input label to a 128-bit pseudorandom seed, applies
an independent instance of AES in counter mode to expand
the seed to 384 pseudorandom bits, and then uses modular
reduction to obtain a pseudorandom 254-bit ﬁeld element.11 To
select the best ed25519 and AES implementations, we have
simply run Supercop on our target machine to exhaustively
evaluate all available implementations, and then used the
recommendations that this framework produced for the fastest
implementations and corresponding compilation options.
Microbenchmarks. All measurements were taken in a modest
machine with two Dual-Core AMD Opteron 2218 processors
clocked at 1 GHz, with 12 GB RAM. The reported values for
every parameter correspond to the median of measurements
computed over at
least 100 runs. Following the original
implementation of the libsnark library, we have equipped our
implementation of the veriﬁcation algorithm with the capabil-
ity to perform part of the computation off-line. However, all
our results pessimistically report the full veriﬁcation time. The
security level was set at 128-bits.

B. Experiments Setup

We have conducted experiments to carry out two types of
performance evaluation: the ﬁrst targeting general circuits, and
the second focusing on a concrete application.
General circuits. To obtain our ﬁrst set of experimental
results, we have relied on the libsnark functionality that
permits generating random instances of constraint systems of

9http://bench.cr.yp.to/supercop.html
10http://ed25519.cr.yp.to/
11It is straightforward to prove that this construction yields a secure PRF,

assuming that AES is itself a secure PRF.

282282

arbitrary sizes. This allowed us to evaluate the performance
of our protocol when dealing with proof goals corresponding
to computations of growing complexity and with a varying
number of inputs. Our goal here was to corroborate the
theoretical analysis presented in Section IV, by benchmarking
our protocol against both the original (unauthenticated) PGHR
SNARK protocol and the generic AD-SNARK construction
described in Section III-B instantiated with PGHR, that we
call AD-PGHR.

We have arbitrarily ﬁxed the complexity of the computation
associated with the proof goal to involve 50K restrictions (or
equivalent, roughly 50K multiplication gates), which typically
corresponds to a computation of intermediate complexity
according to the state of the art (see for example [9]). The
concrete size of the computation is not important, since we will
be concerned with the relative degradation of the performance
of the various protocols, as we gradually increase the number
of (possibly authenticated) inputs to the computation from
100 to 1000. For the generic construction AD-PGHR, we
have (very optimistically) taken the penalty for including the
signature veriﬁcation circuit in the proof goal to be only of
1000 multiplications per signature. The fact that, in practice,
the cost will probably be higher only strengthens our claims.

Concrete Application. Our second set of experimental results
targets a real-world scenario, where the security guarantees
provided by an AD-SNARK are highly relevant: a concrete
smart-metering application like the one described in the in-
troduction. Analogous results can be obtained for similar
applications such as the pay-as-you-drive insurance or the
health risk assessment. Our goal here is to indeed demonstrate
the practical applicability of our ADSNARK implementation
and to show that the overhead incurred by the generic con-
struction can be prohibitive in practice, as it may lead to a
signiﬁcant increase in the complexity of the proof goal. This
is particularly true if the proof goal is reasonably simple to
start with, as is the case in the application that follows.

We focus on the smart-metering application described in [5,
6] where a (non-linear) cumulative price function is applied
to the consumption measurements in order to determine the
aggregated cost. The idea here is that the smart meter is able
to authenticate the measurements, and that the client locally
computes the monetary value corresponding to the measured
consumption. The client can then use an AD-SNARK protocol
to demonstrate to the supplier that the computation is correct
and based on legitimate measurements, without divulging
the details of the individual values. As a simple example
of a cumulative policy [5], one may think of a non-linear
function deﬁned by the following list of threshold/price pairs:
[(0, 2), (3, 5), (7, 8)]. This policy establishes four consumption
intervals and their corresponding prices, as follows: [0, 3] → 2,
(3, 7] → 5, (7,∞) → 8. For a measured consumption of 9,
the price due is 3 × 2 + 4 × 5 + 2 × 8 = 42.

In this application, the complexity of the price computation
depends on both the number of measurements and the number
of intervals prescribed by the cost function.

283283

We have implemented a generator of R1CS statements that,
for a speciﬁed number of measurements and a concrete cumu-
lative cost function, is able to construct a constraint system
for an arithmetic circuit that checks the correctness of the
computed cost, for any given set of measurements. The number
of multiplication gates in (i.e.,
the number of constraints
associated to) the resulting circuits is 36× #measurements×
#intervals + 1.12 For the generic construction AD-PGHR, we
have again used the estimate of 1000 additional multiplications
per signature veriﬁcation. We set the number of thresholds to
5 (a coarse level of granularity in specifying the non-linear
policy) so that we obtain a moderately sized circuit even for a
month’s worth of readings. We then take the indicative value
of 48 measurements per day, and vary the number of days
separating the price computation to be 1, 7, 14, 21, and 28
days. The policy is deﬁned by thresholds 5, 10, 15, 20, and
25. The measurement values were sampled at random in the
range 0 to 100.

C. Performance for General Circuits

Figure 6 shows the results we obtained in terms of execution
time. It is clear from the graphs the rapid degradation of the
global generation and proving times in the case of AD-PGHR.
This is a direct consequence of increasing the size of the
circuit and corresponding increase in the size of the proving
key, which for 1000 inputs in AD-PGHR approaches 320
MB, as opposed to 15 MB for ADSNARK and PGHR.13 The
(relatively) small penalty payed for using public veriﬁcation
in ADSNARK is visible in the veriﬁcation times. Furthermore,
it
the secret-key veriﬁcation
of ADSNARK is as fast as the one of AD-PGHR or the
(unauthenticated) PGHR. The size of the proof is under 500
bytes for all protocols except the public veriﬁcation version of
AD-PGHR, where the authentication data takes an additional
128 bytes per input. Even so, for 1000 inputs, the proof size
is under 126Kbytes.14

is interesting to observe that

D. Performance for Smart Metering Billing

Figure 7 shows the results we obtained in terms of execution
time. It is clear from the graphs that ADSNARK yields proving
times that are compatible with real-world deployment: even
for one month’s worth of measurements, the proving time
is around 18 seconds, the proof size is under 0.5 KB for
secret veriﬁcation and under 170 KB for public veriﬁcation.
The contrast to AD-PGHR is evident, where the proof size is
essentially the same as ADSNARK with secret veriﬁcation, but
the running time of the AD-PGHR’s prover goes up to over
10 minutes. Moreover, even for a month’s worth of readings,
ADSNARK would pay little more time for public veriﬁcation
(around 0.8 seconds vs. 0.08 seconds of AD-PGHR). Although

12The circuit implementation assumes that measurements and thresholds

are represented as 32-bit integer values.

13For PGHR and ADSNARK, the variations in generation and proving
times with the increasing number of inputs are barely visible due to the fact
that the number of constraints in the circuit is ﬁxed at 50K.

14In our implementation, each signature and public key takes 64 bytes, and

the group element takes 64 bytes per input.






















!"

!

 "

 

"



"





 "

"

#"





	
	

	


















%

$

#

"

!

 



 

!$

$

&$

 




















	
	

	

!(

!'

!&

!%

!$

!#

!"

!



	
	

	


	

"!!

#&!

&!!

(&!

"!!!



Generation Time (seconds)

Proving Time (seconds)

Inputs
100
250
500
750
1 000

Inputs
100
250
500
750
1 000

PGHR
16.259
16.312
16.317
16.344
16.350

PGHR
15 650
15 640
15 622
15 605
15 587

AD-PGHR
44.441
84.695
159.943
236.379
299.314

AD-PGHR
45 944
91 885
167 092
250 459
318 590

ADSNARK
16.269
16.358
16.335
16.307
16.276

PGHR
19.600
19.651
19.561
19.602
19.513

ADSNARK
15 657
15 657
15 657
15 657
15 657

PGHR
3.5
8.2
16.0
23.8
31.5

AD-PGHR
56.349
111.008
212.162
380.563
490.852

AD-PGHR
3.5
8.2
16.0
23.8
31.5

ADSNARK
19.558
19.597
19.473
19.672
19.612

ADSNARK
3.5
8.2
16.0
23.8
31.5

Proving Key Size (KBytes)

Veriﬁcation Key Size (KBytes)

PGHR
0.017
0.025
0.038
0.050
0.062

PGHR
0.3
0.3
0.3
0.3
0.3

Veriﬁcation Time (seconds)

AD-PGHR
0.017
0.025
0.038
0.050
0.062

ADSNARK SK
0.014
0.017
0.023
0.029
0.035

AD-PGHR
0.3
0.3
0.3
0.3
0.3

Proof size (Kbytes)
ADSNARK SK
0.4
0.4
0.4
0.4
0.4

ADSNARK PK
0.073
0.165
0.316
0.470
0.613

ADSNARK PK
12.9
31.6
62.9
94.1
125.4

Figure 6. Experimental results showing generation, proving and veriﬁcation times for random constraint systems of size 50K and varying number of inputs.
For AD-PGHR, the number of multiplication gates is 50K + 1000 × #inputs. For ADSNARK in the public veriﬁcation variant, the proof size is equal to
the SNARK proof size plus the size of the authentication data, which is 128 bytes per input.

this may not be very important for smart-metering, it shows,
once more, that the public veriﬁcation time scales very well.

VI. FURTHER RELATED WORK

As we mentioned earlier, our work extends the notion of
succinct non-interactive arguments of knowledge (SNARKs)
[16, 24], which in turn build on (succinct) interactive proofs
[8] and interactive arguments [31, 32]. In particular, we focus
on the so-called preprocessing model where the veriﬁer is
required to run an expensive but re-usable key generation
phase. In this preprocessing model, several works [17, 23,
33, 34] proposed efﬁcient realizations of SNARKs, and more
recent works [9–11] have shown efﬁcient, highly-optimized,
implementations that support general-purpose computations.
These schemes can also support zero-knowledge proofs. It is
worth mentioning that all known SNARKs are either in the
random oracle model or rely on non-standard non-falsiﬁable
assumptions [35]. Assumptions from this class have been
shown [36] likely to be inherent for SNARKs for NP.

The notion of SNARKs is also related to veriﬁable compu-
tation [37], in which a (computationally weak) client delegates
the computation of a function to a powerful server and wants
to verify the result efﬁciently. As noted in previous work, by
using SNARKs for NP, it is possible to construct a veriﬁable
computation scheme, and several works [9, 10, 17] indeed
follow this approach. However, alternative approaches to re-
alizing veriﬁable computation have been proposed, notably
based on fully homomorphic encryption [37–39] or attribute-
based encryption [40].

The Pantry system [41] considers an extension of veriﬁable
computation to a setting similar to ours, where the veriﬁer
may not know the full input. The Pantry solution in this
model combines memory-checking techniques with veriﬁable
computation. In particular, Pantry heavily relies on proving
the correctness of hash computations which suffer the same
efﬁciency problems as those discussed in Section III-C.

Another line of work which is closely related to ours is
the one on homomorphic authentication (comprising both
homomorphic/malleable signatures [42–45] and MACs [18,
19, 25]). The main idea of homomorphic authenticators is
that, given a set of messages (σ1, . . . , σn) authenticated using
a secret key sk, anyone can evaluate a program P on such
authenticated messages in a way that the result σ ← P ({σi})
is again authenticated with respect to the same key sk (or
some public key vk in the case of signatures). Some works in
this area [44, 45] considered various privacy notions (called
context-hiding) to model that signatures on the outputs of a
computation should not reveal information about the inputs.
In this sense, AD-SNARKs are closely related to the notion
of multi-input malleable signatures [45]. However, to the best
of our knowledge, none of these schemes achieves practical
efﬁciency for arbitrary computations.
The recent work Z∅ [7] aimed to combine the best of
different zero-knowledge proof systems by doing an efﬁciency
cost analysis to use the best one for every application. In
particular, Z∅ relies on both ZQL and Pinocchio [9]. However,
when using Pinocchio with authenticated data, Z∅ does not
provide any guarantee on the integrity of this data, i.e., on the

284284
























%  

$% 

$  

#% 

#  

"% 

"  

!% 

!  

% 

 

!
"'
$'

"!

!$

&

	

	


















)""

(""

'""

&""

%""

$""

#""

"

Days
1
7
14
21
28

Days
1
7
14
21
28

Mgates
8 641
60 481
120 961
181 441
241 921

Mgates
8 641
60 481
120 961
181 441
241 921

Generation Time (seconds)
AD-PGHR
ADSNARK
3.262
17.929
110.164
18.296
34.507
214.457
50.770
213.647
431.341
65.539

Proving Key Size (KBytes)
AD-PGHR
ADSNARK
2 500
17 463
17 641
124 274
35 282
248 547
52 923
364 661
497 094
70 563


 















#,

#+

#*

#)

#(

#'

#&

#%

#$

#

	

	

#
$*
&*

$#

#&

)

	

	


	

$

%+
%' 

$'

%$

*

Proving Time (seconds)

Veriﬁcation Time (seconds)

AD-PGHR
21.760
151.146
306.705
444.592
629.003

ADSNARK
0.622
4.463
9.078
14.314
18.426

Veriﬁcation Key Size (KBytes)
AD-PGHR
ADSNARK
1.9
1.9
10.9
10.9
21.4
21.3
31.8
31.8
42.2
42.3

AD-PGHR
0.013
0.030
0.047
0.062
0.077

AD-PGHR
0.3
0.3
0.3
0.3
0.3

ADSNARK SK
0.013
0.020
0.028
0.037
0.043

ADSNARK PK
0.042
0.219
0.421
0.628
0.823

Proof size (Kbytes)
ADSNARK SK
0.4
0.4
0.4
0.4
0.4

ADSNARK PK
6.4
42.4
84.4
126.4
168.4

Figure 7. Experimental results showing generation, proving, and veriﬁcation times for the smart metering application, with the number of measurements
varying from 1 day to 28 days (with 48 measurements per day). For AD-PGHR, the number of multiplication gates is #Mgates + 1000 × #days × 48. For
ADSNARK in the public veriﬁcation variant, the proof size is equal that of the SNARK proof plus the size of the authentication data (128 bytes per input).

validity of the corresponding signatures.

VII. CONCLUSIONS

This paper presents and addresses the problem of enabling
privacy-preserving (aka zero-knowledge) data processing with
a speciﬁc focus on the case where the input data is authen-
ticated, and solely the authentication guarantees “percolate”
to the resulting proof, without disclosing information on
the original data. Current approaches to solve this problem
are limited in either the class of computations that can be
supported [6], or in the prover’s scalability (as we show in
our experiments).

In this paper, we propose a formal approach to this three-
party problem via a new cryptographic primitive, AD-SNARK,
of which we propose an efﬁcient realization. Starting from
our realization, we build and evaluate a nearly practical
system, ADSNARK, for proving arbitrary computations over
authenticated data in a privacy-preserving way.

Our experimental evaluations show that ADSNARK per-
forms essentially as well as non-authenticated state of the
art solutions [9, 11], which means that it scales excellently
for modest computations. Moreover, ADSNARK dramatically
improves over generic solutions to the input authentication
problem. Furthermore, since ADSNARK leverages the recent
developments in zero-knowledge proof systems,
it permits
handling arbitrary computations in an easy and usable way.
Indeed, any of the available compilers (e.g., [9]) can be used
as a front-end tool for translating from high-level languages
(e.g., C++) into arithmetic circuit satisfaction problems that

can later be passed to the zero-knowledge backend, in our
case to ADSNARK.

ADSNARK also inherits some of the limitations of existing
SNARKs, such as the use of the circuit computation model.
Recent work [11] have shown how to move to more efﬁcient
representations such as RAM. We leave it as future work to
study the extension of AD-SNARKs to more convenient and
efﬁcient computation models.

ACKNOWLEDGMENT

The research of Dario Fiore has been partially supported by
the European Commission’s Seventh Framework Programme
Marie Curie Cofund Action AMAROUT II (grant no. 291803).
Manuel Barbosa was partially supported by: i. the BEST
CASE project (NORTE-07-0124-FEDER-000056) ﬁnanced by
the North Portugal Regional Operational Programme (ON.2
- O Novo Norte), under the National Strategic Reference
Framework (NSRF), through the European Regional Devel-
opment Fund (ERDF), and by national funds, through the
Foundation for Science and Technology (FCT); and ii. the
European Union’s Seventh Framework Program (FP7/2007-
2013) grant agreement n. 609611 (PRACTICE).

Michael Backes is supported by the BMBF competence

center CISPA.

REFERENCES

[1] R. M. Reischuk, “Declarative design and enforcement for secure cloud
applications,” Ph.D. dissertation, Saarland University, Saarbr¨ucken, Ger-
many, 2014.

[2] Vitalconnect, “Healthpatch,” http://www.vitalconnect.com, 2014.

285285

[3] BBC, “Google unveils ’smart contact lens’ to measure glucose levels,”

http://www.bbc.com/news/technology-25771907, 2014.

[4] R. Anderson and S. Fuloria, “On the security economics of electricity
metering,” in 9th Annual Workshop on the Economics of Information
Security, WEIS 2010, Harvard University, Cambridge, MA, USA, June
7-8, 2010, 2010.

[5] A. Rial and G. Danezis, “Privacy-preserving smart metering,” in
Proceedings of the 10th Annual ACM Workshop on Privacy in the
Electronic Society, ser. WPES ’11. New York, NY, USA: ACM, 2011,
pp. 49–60.
[Online]. Available: http://doi.acm.org/10.1145/2046556.
2046564

[6] C. Fournet, M. Kohlweiss, G. Danezis, and Z. Luo, “ZQL: A compiler
for privacy-preserving data processing,” in Proceedings of the 22Nd
USENIX Conference on Security, ser. SEC’13. Berkeley, CA, USA:
USENIX Association, 2013, pp. 163–178.

[7] M. Fredrikson and B. Livshits, “ZO: An optimizing distributing zero-

knowledge compiler,” in USENIX Security, 2014.

[8] S. Goldwasser, S. Micali, and C. Rackoff, “The knowledge complexity
of interactive proof systems,” SIAM Journal on Computing, vol. 18,
no. 1, pp. 186–208, 1989.

[9] B. Parno, C. Gentry, J. Howell, and M. Raykova, “Pinocchio: Nearly
practical veriﬁable computation,” in IEEE Symposium on Security and
Privacy, Oakland, 2013, corrected version (13 May 2013): http://eprint.
iacr.org/2013/279.

[10] E. Ben-Sasson, A. Chiesa, D. Genkin, E. Tromer, and M. Virza,
“SNARKs for C: Verifying program executions succinctly and in zero
knowledge,” in CRYPTO 2013, Part II, ser. LNCS, R. Canetti and J. A.
Garay, Eds., vol. 8043. Springer, Aug. 2013, pp. 90–108.

[11] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza, “Succinct non-
interactive zero knowledge for a von Neumann architecture,” in USENIX
Security, 2014, pp. 781–796.

[12] D. Chaum, “Security without identiﬁcation: Transaction systems to make
big brother obsolete,” Commun. ACM, vol. 28, no. 10, pp. 1030–1044,
Oct. 1985. [Online]. Available: http://doi.acm.org/10.1145/4372.4373

[13] I. Damg˚ard, “Payment systems and credential mechanisms with provable
security against abuse by individuals,” in CRYPTO’88, ser. LNCS,
S. Goldwasser, Ed., vol. 403. Springer, Aug. 1988, pp. 328–335.

[14] A. Lysyanskaya, R. L. Rivest, A. Sahai, and S. Wolf, “Pseudonym
systems,” in SAC 1999, ser. LNCS, H. M. Heys and C. M. Adams,
Eds., vol. 1758. Springer, Aug. 1999, pp. 184–199.

[15] S. Meiklejohn, C. C. Erway, A. K¨upc¸ ¨u, T. Hinkle, and A. Lysyanskaya,
“Zkpdl: A language-based system for
zero-knowledge
proofs and electronic cash,” in Proceedings of
the 19th USENIX
Conference on Security, ser. USENIX Security’10. Berkeley, CA,
USA: USENIX Association, 2010, pp. 13–13. [Online]. Available:
http://dl.acm.org/citation.cfm?id=1929820.1929838

efﬁcient

[16] S. Micali, “CS proofs (extended abstracts),” in 35th FOCS.

IEEE

Computer Society Press, Nov. 1994, pp. 436–453.

[17] R. Gennaro, C. Gentry, B. Parno, and M. Raykova, “Quadratic span
programs and succinct NIZKs without PCPs,” in EUROCRYPT 2013,
ser. LNCS, T. Johansson and P. Q. Nguyen, Eds., vol. 7881. Springer,
May 2013, pp. 626–645.

[18] D. Catalano and D. Fiore, “Practical homomorphic MACs for arithmetic
circuits,” in EUROCRYPT 2013, ser. LNCS, T. Johansson and P. Q.
Nguyen, Eds., vol. 7881. Springer, May 2013, pp. 336–352.

[19] M. Backes, D. Fiore, and R. M. Reischuk, “Veriﬁable delegation of
computation on outsourced data,” in ACM CCS 13, A.-R. Sadeghi, V. D.
Gligor, and M. Yung, Eds. ACM Press, Nov. 2013, pp. 863–874.

[20] M. Backes, M. Barbosa, D. Fiore, and R. M. Reischuk, “ADSNARK:
nearly practical and privacy-preserving proofs on authenticated data,”
Cryptology ePrint Archive, Report 2014/617, 2014.

[21] J. Camenisch, M. Kohlweiss, and C. Soriente, “An accumulator based
on bilinear maps and efﬁcient revocation for anonymous credentials,”
in PKC 2009, ser. LNCS, S. Jarecki and G. Tsudik, Eds., vol. 5443.
Springer, Mar. 2009, pp. 481–500.

[22] D. Boneh, X. Boyen, and E.-J. Goh, “Hierarchical

identity based
encryption with constant size ciphertext,” in EUROCRYPT 2005, ser.
LNCS, R. Cramer, Ed., vol. 3494. Springer, May 2005, pp. 440–456.
[23] J. Groth, “Short pairing-based non-interactive zero-knowledge argu-
ments,” in ASIACRYPT 2010, ser. LNCS, M. Abe, Ed., vol. 6477.
Springer, Dec. 2010, pp. 321–340.

286286

[24] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer, “From extractable
collision resistance to succinct non-interactive arguments of knowledge,
and back again,” in ITCS 2012, S. Goldwasser, Ed. ACM, Jan. 2012,
pp. 326–349.

[25] R. Gennaro and D. Wichs, “Fully homomorphic message authenticators,”
in ASIACRYPT 2013, Part II, ser. LNCS, K. Sako and P. Sarkar, Eds.,
vol. 8270. Springer, Dec. 2013, pp. 301–320.

[26] D. Boneh and X. Boyen, “Short signatures without random oracles,” in
EUROCRYPT 2004, ser. LNCS, C. Cachin and J. Camenisch, Eds., vol.
3027. Springer, May 2004, pp. 56–73.

[27] B. R. Waters, “Efﬁcient

identity-based encryption without random
oracles,” in EUROCRYPT 2005, ser. LNCS, R. Cramer, Ed., vol. 3494.
Springer, May 2005, pp. 114–127.

[28] R. Cramer and V. Shoup, “Signature schemes based on the strong RSA

assumption,” in ACM CCS 99. ACM Press, Nov. 1999, pp. 46–51.

[29] X. Boyen, “Lattice mixing and vanishing trapdoors: A framework for
fully secure short signatures and more,” in PKC 2010, ser. LNCS, P. Q.
Nguyen and D. Pointcheval, Eds., vol. 6056. Springer, May 2010, pp.
499–517.

[30] D. J. Bernstein, N. Duif, T. Lange, P. Schwabe, and B. Yang,
“High-speed high-security signatures,” J. Cryptographic Engineering,
vol. 2, no. 2, pp. 77–89, 2012. [Online]. Available: http://dx.doi.org/10.
1007/s13389-012-0027-1

[31] J. Kilian, “A note on efﬁcient zero-knowledge proofs and arguments
(extended abstract),” in 24th ACM STOC. ACM Press, May 1992, pp.
723–732.

[32] ——,

“Improved efﬁcient

arguments

(preliminary version),”

CRYPTO’95, ser. LNCS, D. Coppersmith, Ed., vol. 963.
Aug. 1995, pp. 311–324.

in
Springer,

[33] H. Lipmaa, “Progression-free sets and sublinear pairing-based non-
interactive zero-knowledge arguments,” in TCC 2012, ser. LNCS,
R. Cramer, Ed., vol. 7194. Springer, Mar. 2012, pp. 169–189.

[34] N. Bitansky, A. Chiesa, Y. Ishai, R. Ostrovsky, and O. Paneth, “Succinct
non-interactive arguments via linear interactive proofs,” in TCC 2013,
ser. LNCS, A. Sahai, Ed., vol. 7785. Springer, Mar. 2013, pp. 315–333.
[35] M. Naor, “On cryptographic assumptions and challenges (invited talk),”
in CRYPTO 2003, ser. LNCS, D. Boneh, Ed., vol. 2729. Springer, Aug.
2003, pp. 96–109.

[36] C. Gentry and D. Wichs, “Separating succinct non-interactive arguments
from all falsiﬁable assumptions,” in 43rd ACM STOC, L. Fortnow and
S. P. Vadhan, Eds. ACM Press, Jun. 2011, pp. 99–108.

[37] R. Gennaro, C. Gentry, and B. Parno, “Non-interactive veriﬁ-
able computing: Outsourcing computation to untrusted workers,” in
CRYPTO 2010, ser. LNCS, T. Rabin, Ed., vol. 6223.
Springer, Aug.
2010, pp. 465–482.

[38] K.-M. Chung, Y. Kalai, and S. P. Vadhan, “Improved delegation of
computation using fully homomorphic encryption,” in CRYPTO 2010,
ser. LNCS, T. Rabin, Ed., vol. 6223. Springer, Aug. 2010, pp. 483–501.
[39] B. Applebaum, Y. Ishai, and E. Kushilevitz, “From secrecy to soundness:
Efﬁcient veriﬁcation via secure computation,” in ICALP 2010, Part I,
ser. LNCS, S. Abramsky, C. Gavoille, C. Kirchner, F. Meyer auf der
Heide, and P. G. Spirakis, Eds., vol. 6198.
Springer, Jul. 2010, pp.
152–163.

[40] B. Parno, M. Raykova, and V. Vaikuntanathan, “How to delegate and
verify in public: Veriﬁable computation from attribute-based encryption,”
in TCC 2012, ser. LNCS, R. Cramer, Ed., vol. 7194.
Springer, Mar.
2012, pp. 422–439.

[41] B. Braun, A. J. Feldman, Z. Ren, S. Setty, A. J. Blumberg, and
M. Walﬁsh, “Verifying computations with state,” in ACM Symposium
on Operating Systems Principles, SOSP 2013, 2013.

[42] R. Johnson, D. Molnar, D. X. Song, and D. Wagner, “Homomorphic
signature schemes,” in CT-RSA 2002, ser. LNCS, B. Preneel, Ed., vol.
2271. Springer, Feb. 2002, pp. 244–262.

[43] D. Boneh and D. M. Freeman, “Homomorphic signatures for polynomial
functions,” in EUROCRYPT 2011, ser. LNCS, K. G. Paterson, Ed., vol.
6632. Springer, May 2011, pp. 149–168.

[44] J. H. Ahn, D. Boneh, J. Camenisch, S. Hohenberger, a. shelat, and
B. Waters, “Computing on authenticated data,” in TCC 2012, ser. LNCS,
R. Cramer, Ed., vol. 7194. Springer, Mar. 2012, pp. 1–20.

[45] M. Chase, M. Kohlweiss, A. Lysyanskaya, and S. Meiklejohn, “Mal-
leable signatures: New deﬁnitions and delegatable anonymous creden-
tials,” in Computer Security Foundation (CSF), 2014.

