Amortizing Secure Computation with Penalties

Ranjit Kumaresan

MIT

Cambridge, Massachusetts

vranjit@mit.edu

ABSTRACT
Motivated by the impossibility of achieving fairness in secure com-
putation [Cleve, STOC 1986], recent works study a model of fair-
ness in which an adversarial party that aborts on receiving output is
forced to pay a mutually predeﬁned monetary penalty to every other
party that did not receive the output. These works show how to de-
sign protocols for secure computation with penalties that guaran-
tees that either fairness is guaranteed or that each honest party ob-
tains a monetary penalty from the adversary. Protocols for this task
are typically designed in an hybrid model where parties have access
to a “claim-or-refund” transaction functionality denote F∗

In this work, we obtain improvements on the efﬁciency of these
constructions by amortizing the cost over multiple executions of
secure computation with penalties. More precisely, for computa-
tional security parameter λ, we design a protocol that implements
(cid:96) = poly(λ) instances of secure computation with penalties where
the total number of calls to F∗
Keywords: Secure computation, fairness, Bitcoin, amortization.

CR is independent of (cid:96).

CR.

1.

INTRODUCTION

Protocols for secure multiparty computation [23, 10] allow a set
of mutually distrusting parties to carry out a distributed computa-
tion without compromising on privacy of inputs or correctness of
the end result. Despite being a powerful tool, it is known that secure
computation protocols do not provide fairness or guaranteed output
delivery when a majority of the parties are dishonest [7]. Address-
ing this deﬁciency is critical if secure computation is to be widely
adopted in practice, especially given the current interest in practi-
cal secure computation. Several workarounds have been proposed
in the literature to counter adversaries that may decide to abort, pos-
sibly depending on the outcome of the protocol. In this work, we
are interested in the workaround proposed in [18, 17] where an ad-
versarial party that aborts on receiving output is forced to pay a mu-
tually predeﬁned monetary penalty to every other part that did not
receive the output. In practice, such mechanisms would be effective
if the compensation amount is rightly deﬁned. While the original
works [18, 17] depended on e-cash systems, recent works [4, 2, 6,
14, 1, 15, 12] have shown how to use a decentralized digital cur-
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’16, October 24 - 28, 2016, Vienna, Austria
c(cid:13) 2016 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ISBN 978-1-4503-4139-4/16/10. . . $15.00
DOI: http://dx.doi.org/10.1145/2976749.2978424

Iddo Bentov
Cornell University
Ithaca, New York

iddobentov@cornell.edu

rency (like Bitcoin) to design protocols for secure computation in
the penalty model.

In this work, we propose major improvements to the efﬁciency
of protocols for secure computation with penalties by amortizing
the cost over multiple executions (effectively making the amortized
“on-chain” cost zero). To better explain our contributions, we ﬁrst
discuss the model, efﬁciency metrics, settings, and the efﬁciency of
state-of-the-art protocols.
Claim-or-refund transaction functionality. In [6, 15], protocols
for secure computation with penalties are designed in a hybrid model
where parties have access to an ideal transaction functionality called
the claim-or-refund transaction functionality [6, 5, 19]. This func-
tionality, denoted as F∗
CR, takes care of handling “money/coins”
and allows protocols to be designed independently of the Bitcoin
CR implements the following func-
ecosystem.
tionality: (1) it accepts a deposit of coins(q), a Boolean circuit φ
and a time-limit τ from a designated sender S; and (2) waits until
time τ to get a witness w from a designated receiver R such that
φ(w) = 1; and (3) if such a witness was received within time τ
transfers coins(q) to R; (4) else returns coins(q) back to S.
CR explain its importance: (1) F∗

Three features of F∗

In a nutshell, F∗

CR-hybrid model work as long as F∗

CR can be
very efﬁciently implemented in Bitcoin (see Appendix A), and (2)
F∗
CR provides an abstraction which makes protocols designed in
the F∗
CR-hybrid model robust to changes in the Bitcoin architec-
ture, and (3) F∗
CR is “complete” for secure computation with penal-
ties. Protocols for secure computation with penalties designed in
the F∗
CR is implemented. Such
an implementation need not be tied to Bitcoin, i.e., banks and other
ﬁnancial institutions could, in principle, support F∗
CR transactions.
Capturing the cost of secure computation with penalties. A pro-
tocol for secure computation with penalties typically involves an
sequence of F∗
CR deposits. Thus the costs of such protocols can
be captured in a variety of ways such as (1) the total number of
calls to F∗
CR in the
sequence of deposits, and the complexity of the parameters, specif-
ically (3) the maximum/total size of Boolean circuits φ employed
in the sequence and (4) the maximum value of time-limit τ used in
the sequence. To realize F∗
CR in Bitcoin, we need at least one Bit-
coin transaction to be broadcasted by the sender (cf. Appendix A).
Thus, the number of calls to F∗
CR captures the number of Bitcoin
transactions that need to be broadcasted to and supported by the
Bitcoin network. The deposits made to F∗
CR capture the amount of
funds that need to be locked up in Bitcoin transactions during the
course of the protocol. The size of the Boolean circuit φ used in an
F∗
CR transaction captures the amount of time miners need to spend
to validate that F∗
CR transaction, consequently captures the load on
the network for verifying transactions. Additionally, Bitcoin trans-
actions currently offer limited support for Bitcoin “scripts” (essen-

CR, (2) the maximum/total deposits made to F∗

418tially the circuit φ). While this is expected to improve in the future
(and other alt-coins like Ethereum are already offer generous sup-
port for scripts), the size of the Boolean circuit does a good job in
capturing the complexity of the scripts that Bitcoin needs to sup-
port secure computation with penalties. We denote the total size
of the Boolean scripts (i.e., Bitcoin scripts) used in our protocols
as the “script complexity” of the protocol. Finally, the maximum
value of the time-limit used in the sequence of F∗
CR deposits cap-
tures the “round complexity” of the protocol. Sometimes we make
a distinction between “on-chain round complexity” and “off-chain
round complexity.” This distinction is expected to yield a tighter
grip on the efﬁciency of the protocol. The “on-chain round com-
plexity” refers to the number of sequential transactions that need
to be made on the blockchain. Since the time taken to conﬁrm a
transaction on the blockchain today is about 1 hour, an “on-chain
round complexity” of s implies that the protocol will take at least s
hours to complete. The “off-chain round complexity” refers to the
standard metric of round complexity used in traditional MPC pro-
tocols. Note that an off-chain round typically takes less than a few
seconds to complete. Thus, we believe that for a fair comparison
this distinction needs to be made.
Our contributions. We show how to amortize the cost of secure
computation with penalties. Let λ be a computational security pa-
rameter. Then for (cid:96) = poly(λ) we show how (cid:96) sequential in-
stances of an n-party non-reactive (resp. reactive) secure compu-
tation penalties can be realized with the same “on-chain” cost of
a single execution in [6] (resp. [15]). Since the on-chain latency
is typically very high and the on-chain costs capture the load on
the Bitcoin network, we believe that our results deliver major im-
provements to the efﬁciency of secure computation with penalties
and make it more easy to envision practical implementations on
the Bitcoin network (or other networks). Finally, in our protocols
neither the parameter (cid:96) nor the sequence of possibly different func-
tions that need to be evaluated need to be known in advance. (For
the reactive case, an upper bound on the transcript and rounds need
to be known in advance.)
Technical overview and differences from prior work. The main
difference from prior work is that we reuse a single initial set of
F∗
CR deposits for multiple instances of secure computation with
penalties. That is, parties make an initial set of F∗
CR deposits ﬁrst,
then locally execute secure computation protocols, and whenever
there is an abort in the local execution, they have recourse to the
F∗
CR deposits in order to get penalties. That is, in an optimistic
setting where all parties follow the protocol, the initial set of F∗
CR
deposits remain untouched throughout the (cid:96) local executions. In the
general case, the initial set of F∗
CR deposits will be claimed when
an abort occurs in one of the local executions.

To make things simple, we divide the implementation of (cid:96) in-
stances into three stages: (1) the master setup and deposit phase,
(2.1) a local setup phase for each execution, (2.2) a local exchange
phase for each execution, and (3) the master claim phase. In the
master setup and deposit phase, parties run an unfair standard se-
cure computation protocol that helps specify the Boolean circuits
required for the initial F∗
CR deposits, following which parties make
these F∗
CR deposits, referred to as the “master deposits.” Note that
parties do not yet know the inputs of any of the instances of secure
computation with penalties and thus all they supply to the mas-
ter setup phase is simply randomness. Consequently, the Boolean
circuits in the F∗
CR deposits will also be independent of the in-
puts/outputs of the (cid:96) executions. This is one of the fundamental
differences between the previous protocols [6, 15, 16] and ours.
For example in the non-reactive protocols of [6, 16], the Boolean
circuits in the F∗
CR deposits are commitments on the secret shares

of the ﬁnal output. That is, the function evaluation occurs ﬁrst even
before the F∗
CR deposits are made. On the other hand, in our case,
there are multiple function evaluations and the master deposits are
made before any of the function evaluations begin. Further, the
master deposits will need to allow honest parties to obtain penal-
ties in case any of the function evaluation instances are aborted by
the adversary. Our approach can be applied to the setting of [6,
15, 16] by setting (cid:96) = 1. By performing the master deposits be-
fore the function evaluation, our approach surprisingly makes the
security analysis easier. In particular, we no longer need to worry
about aborts that happen during the deposit phase. Even better,
all the master deposits can be made simultaneously, i.e., in O(1)
on-chain rounds, unlike prior protocols where the deposit phase re-
quired O(n) on-chain rounds. Also, in an optimistic setting where
all parties behave honestly, the master claim phase (described later)
can also be made simultaneously, i.e., in O(1) on-chain rounds.

Once all the master deposits have been made, parties sequen-
tially perform the local executions. At the beginning of each local
execution, parties run a secure computation protocol speciﬁed in
the local setup phase. The objective of this phase is to set things
up in a way such that penalties can be obtained from the parties
in case of aborts. Following this, parties enter the local exchange
phase for that execution, where they exchange messages that reveal
the output of that execution. Note that these phases do not involve
F∗
CR. It is only when there is an abort in any of these phases, do
parties enter the master claim phase where they try to claim these
deposits. We describe the three phases in more detail.
Master setup and deposit phase. In this phase, parties run a se-
cure computation protocol that implements the following function-
ality: (1) run the key generation algorithm of a signature scheme
to generate (mvk, msk), (2) secret share msk among all parties,
and output mvk to all parties. We refer to (mvk, msk) as the
master keys. Note that msk is unknown to the adversary. Fol-
lowing the secure computation protocol, parties make a series of
F∗
CR deposits. These are the master deposits. The Boolean cir-
cuits used in these deposits perform two checks: ﬁrst, they check
for one or more messages each of which contain a signature that
veriﬁes against the master veriﬁcation key mvk, and second, they
check that the messages obeys a certain structural relation between
them. The structural relation is necessary to ensure that the honest
parties obtain penalties if a local execution was aborted. More on
this later. Curiously, the sequence of F∗
CR deposits in the master
deposit phase is identical to the “see-saw” deposits of [15] in both
the non-reactive and reactive cases. Of course, we will be using
different (more complicated) scripts in each F∗
Local execution phase. In this overview, we will focus only on
handling the non-reactive case. In the k-th local setup phase (for
k ∈ [(cid:96)]), parties run a secure computation protocol that evaluates
the function fk on inputs provided by the parties, and then secret
shares the output among the parties. The secret shares of the out-
puts are authenticated twice: once under the msk and once under
a local signing key that is generated inside this MPC. Note that to
authenticate the output secret shares under msk, the parties will
need to provide the secret shares of msk to the MPC. Neither the
msk nor the local signing key will be revealed to the parties. Also,
the messages that are signed aren’t simply output secret shares but
will include the execution number k and the identity of the party.
That is, if si is the i-th output secret share, then signatures under
msk and the local signing key will be computed on the message
(i, k, si). Furthermore, the setup phase will also produce signatures
under msk on messages of the form (j, i, k) where j, i ∈ [n].1
1To avoid clutter in our presentation, we assume that the messages

CR deposit.

419These are referred to as the “lock witnesses.” Another caveat is
that we require that the MPC of the local setup phase to deliver
outputs in a particular order. This speciﬁc ordering, the use of lock
witnesses, and the structure of the messages containing the secret
shares all will be important ideas that will ensure that the honest
parties get compensated in the event of aborts.

Following the k-th local setup phase, parties enter the k-th local
exchange phase in which parties broadcast the output shares along
with the authentication under the local signing key to all parties.
Again, we will require a speciﬁc ordering in which the parties per-
form broadcasts. If all parties behave honestly, then parties will
obtain the output of the k-th local execution, and will proceed to
the next execution, and so on. If there was an abort in either the lo-
cal setup phase or the local exchange phase, parties enter the master
claim phase and do not engage in any further local executions. Note
that signatures under msk are never revealed during the local exe-
cutions; they will be revealed only during the claim of the master
deposits in the master claim phase.
Master claim phase. In this phase, parties take turns to claim mas-
ter deposits. The objective of this phase is to ensure that if a local
execution was aborted mid-way, then either this local execution is
continued to its completion in this phase, or else guarantee that
the honest parties obtain penalties. An important attack to defend
against is one where the adversary replays messages from an older
execution. Such an attack would end up allowing the adversary to
claim all the master deposits it is required to claim thereby the ad-
versary does not pay penalties to honest parties. Furthermore, it en-
sures that the most recent local execution remains aborted and only
the adversary learns the output of that execution. Such attacks are
taken care of (1) by the use of signatures under the master signing
keys that will be revealed only in the master claim phase, and (2) by
imposing certain conditions on the structural relations between the
messages used in the claim of a master deposit. Claiming a master
deposit involves revealing a partial transcript containing, say the
ﬁrst j output secret share messages that are of the form (i, k,∗) for
all i ∈ [j] and for some speciﬁc value k ∈ [(cid:96)].2 The messages
of this form alone are not sufﬁcient to claim the deposit; one has
to produce the corresponding signatures under msk as well. By
imposing such conditions, namely that j signatures on messages
(1, k,∗), . . . , (j, k,∗) are required to claim a deposit, we can en-
sure that the current local execution is continued. Signatures under
msk on messages of the form (i,∗,∗) will be revealed by honest
Pi for a unique value k (typically the most recent local execution).
This in turn will ensure that the k-th local execution is continued in
the master claim phase. Of course, if the adversary were to abort in
the master claim phase as well, we will show that this would result
in all honest parties obtaining the necessary penalty.
Important caveats. Note that the penalties can be obtained only at
the end of the master claim phase. The time-limits on the master
deposits will typically be high in order to let all the (cid:96) executions ﬁn-
ish. Suppose the very ﬁrst execution was aborted by the adversary.
Then the funds of the honest parties will remain locked up until
the time-limit on the master deposit expires. We note that for the
single instance case, i.e., (cid:96) = 1, more efﬁcient protocols are pre-
sented in [16]. Unfortunately, we were not able to take advantage
of the techniques in their work. Finally, our protocols can also im-
prove the efﬁciency of protocols for secure cash distribution with
penalties considered in [2, 15]. While our protocols may be used

of the form (i, k, si) and (j, i, k) are padded appropriately so that
signatures on messages of one form cannot be trivially used to forge
signatures on messages of the other form.
2We often use ‘*’ as the wildcard character.

to implement the protocol part of the construction in [15], the cash
distribution part will require fresh deposits per execution. Still, we
believe that the best venues for our results will be in applications
such as poker where repeated executions among the same set of
parties are likely.
Related work. The works of [4, 5] construct 2-party lottery proto-
cols using Bitcoin scripts which essentially implement F∗
CR. Other
notable works which are not in the F∗
CR model include the works
of [2, 1, 13, 12, 14]. The works of [13, 12] use a more power-
ful transaction functionality which implements a blockchain to im-
plement “smart contracts” and fair secure computation (under the
penalties notion). We wish to emphasize that protocols constructed
in the F∗
CR-hybrid model can be easily cast into protocols in any
of the above models. Also, we make an explicit distinction be-
tween the off-chain costs and the on-chain costs which is not al-
ways captured in other works. For instance, in Ethereum, the entire
smart contract (or the function) is put on the blockchain, and in a
naïve construction, every miner is involved in the computation of
the function as well as the state changes associated with executing
the contract. These are exactly the type of burdens on the miners
that we are trying to relieve via use of (possibly expensive) off-
chain mechanisms (e.g., secure computation). The works of [21,
8] are concerned with the establishment of a “payment channel”
to allows parties to do an unbounded number of money transfers
without burdening the blockchain.

2. PRELIMINARIES
A function µ(·) is negligible in λ if for every positive polynomial
p(·) and all sufﬁciently large λ’s it holds that µ(λ) < 1/p(λ). A
probability ensemble X = {X(a, λ)}a∈{0,1}∗,n∈N is an inﬁnite
sequence of random variables indexed by a and λ ∈ N. Two dis-
tribution ensembles X = {X(a, λ)}λ∈N and Y = {Y (a, λ)}λ∈N
c≡ Y
are said to be computationally indistinguishable, denoted X
if for every non-uniform polynomial-time algorithm D there exists
a negligible function µ(·) such that for every a ∈ {0, 1}∗,

|Pr[D(X(a, λ)) = 1] − Pr[D(Y (a, λ)) = 1]| ≤ µ(λ).

All parties are assumed to run in time polynomial in the security
parameter λ. We prove security in the “secure computation with
coins” (SCC) model proposed in [6]. Note that the main difference
from standard deﬁnitions of secure computation [9] is that now the
view of Z contains the distribution of coins. Let IDEALf,S,Z (λ, z)
denote the output of environment Z initialized with input z after
interacting in the ideal process with ideal process adversary S and
(standard or special) ideal functionality Gf on security parameter
λ. Recall that our protocols will be run in a hybrid model where
parties will have access to a (standard or special) ideal functionality
Gg. We denote the output of Z after interacting in an execution of
π in such a model with A by HYBRIDg
π,A,Z (λ, z), where z denotes
Z’s input. We are now ready to deﬁne what it means for a protocol
to SCC realize a functionality.

DEFINITION 1. Let n ∈ N. Let π be a probabilistic polynomial-
time n-party protocol and let Gf be a probabilistic polynomial-time
n-party (standard or special) ideal functionality. We say that π
SCC realizes Gf with abort in the Gg-hybrid model (where Gg is a
standard or a special ideal functionality) if for every non-uniform
probabilistic polynomial-time adversary A attacking π there exists
a non-uniform probabilistic polynomial-time adversary S for the
ideal model such that for every non-uniform probabilistic polynomial-
time adversary Z,
{IDEALf,S,Z (λ, z)}λ∈N,z∈{0,1}∗ c≡ {HYBRIDg

π,A,Z (λ, z)}λ∈N,z∈{0,1}∗ .

420session identiﬁer sid, an n-input, n(cid:48)-output function
Notation:
f, a hard-coded ordering of outputs χ = (χ1, . . . , χn(cid:48) ), parties
P1, . . . , Pn, adversary S that corrupts parties {Ps}s∈C, set H =
[n] \ C.
INPUT PHASE:
• Wait to receive a message (input, sid, ssid, r, yr) from Pr for all
• Wait to receive a message (input, sid, ssid, s, {ys}s∈C ) from S.
OUTPUT DELIVERY:
• Compute ((χ1, z1), . . . , (χn(cid:48) , zn(cid:48) )) ← f (y1, . . . , yn).
• For j ∈ [n(cid:48)], sequentially do: send (output, sid, ssid, zj ) to

r ∈ H.

Pχj . If χj ∈ C, then:

– If S sends (abort, sid, ssid), send (output, sid, ssid, ⊥)

to Pr for r ∈ H.

Figure 1: The ideal functionality F ord
ery of output.

f

enforcing ordered deliv-

DEFINITION 2. Let π be a protocol and f be a multiparty func-
tionality. We say that π securely computes f with penalties if π
SCC-realizes the functionality F (cid:63)

f according to Deﬁnition 1.

Throughout this paper, we deal only with static adversaries and
impose no restrictions on the number of parties that can be cor-
rupted. Our schemes also make use of a digital signature scheme
which we denote as (SigKeyGen, SigSign, SigVerify).
2.1 Ideal Functionalities
Secure function evaluation with ordered output delivery. In our
protocols, we ask parties to run secure computation protocols that
deliver output in a certain order. (Note that standard secure compu-
tation protocols do not guarantee fairness in the presence of a dis-
honest majority.) Such protocols can be obtained easily by tweak-
ing existing MPC protocols in the following way. First, the func-
tion is evaluated on the inputs to produce, say n outputs z1, . . . , zn.
Each zi is then secret shared among the parties. Once the outputs
are delivered to the parties, they then proceed to reconstruct the ac-
tual outputs in order. That is, in the ﬁrst reconstruction phase, all
parties broadcast their shares of z1. At the end of this phase, P1 ob-
tains z1. Then parties broadcast their shares of z2 in the next phase
and so on. Our protocols typically involve sending the outputs in
reverse order. The actual order is slightly more complicated, but the
idea above can be trivially generalized to accommodate our needs.
For clarity, we present the generalized deﬁnition of the functional-
ity in Figure 1. The values χj specify the index of the party that is
supposed to receive the output in the j-th phase. That is, in phase
j, party Pχj receives the output zj. Note that n(cid:48) > n is possi-
ble. In our protocols we will need n(cid:48) = O(n2) but simple round
reduction techniques can be applied to implement the desired func-
tionality in O(n) rounds. Note that the protocol realizing F ord
f does
not guarantee fairness. Also note that F ord
can be realized in the
FOT-hybrid model.
Claim-or-refund transaction functionality F∗
CR [6, 5, 19]. At a
high level, F (cid:63)
CR allows a sender Ps to conditionally send coins(x)
to a receiver Pr. The condition is formalized as the revelation of
a satisfying assignment (i.e., witness) for a sender-speciﬁed circuit
φs,r( · ; z) (i.e., relation) that may depend on some public input
z. Further, there is a “time” bound, formalized as a round num-
ber τ, within which Pr has to act in order to claim the coins. An

f

F (cid:63)
CR with session identiﬁer sid, running with parties P1, . . . , Pn, a
parameter 1λ, and an ideal adversary S proceeds as follows:
• Deposit
the
from Ps,

tuple
record
(deposit, sid, ssid, s, r, φs,r, τ, coins(x))
the message (deposit, sid, ssid, s, r, φs,r, τ, x) and send it to
all parties.
Ignore any future deposit messages with the same
ssid from Ps to Pr.

receiving

phase.

Upon

• Claim phase.

τ:

time

upon

Until

receiving
(1)
(claim, sid, ssid, s, r, φs,r, τ, x, w) from Pr, check if
recorded,
a
tuple
send
and (2)
send
(claim, sid, ssid, s, r, φs,r, τ, x, w)
(claim, sid, ssid, s, r, φs,r, τ, coins(x)) to Pr, and delete the
record (deposit, sid, ssid, s, r, φs,r, τ, x).

(deposit, sid, ssid, s, r, φs,r, τ, x) was
if φs,r(w) = 1.

If both checks pass,
parties,

all

to

• Refund

After

phase:

record
(deposit, sid, ssid, s, r, φs,r, τ, x) was not deleted,
then
send (refund, sid, ssid, s, r, φs,r, τ, coins(x)) to Ps, delete
record (deposit, sid, ssid, s, r, φs,r, τ, x).

time

the

τ:

if

Figure 2: The special ideal functionality F (cid:63)

CR.

important property that we wish to stress is that the satisfying wit-
ness is made public by F (cid:63)
CR. Any cryptocurrency that supports
time-dependent scripts can be used to realize F∗
CR. Earlier Bitcoin
implementations of F∗
CR were given in [6, 5, 19], and we provide
a more secure implementation in Appendix A. In a Bitcoin real-
ization of F∗
CR, sending a message with coins(x) corresponds to
broadcasting a transaction to the Bitcoin network, and waiting ac-
cording to some time parameter until there is enough conﬁdence
that the transaction will not be reversed. We denote an F (cid:63)
CR trans-
action where sender Ps asks receiver Pr for a witness for a predi-
cate φ in exchange for coins(q) with deadline τ by:

Ps

−−−−−−−−−−−−−→

φ

q,τ

Pr

Next, we deﬁne an important metric of protocols that involve a se-
quence of F∗
CR deposits called the “script complexity.” This metric
captures the load on the Bitcoin network for verifying the F∗
CR
transactions.

DEFINITION 3

(SCRIPT COMPLEXITY [14]). Let Π be a
protocol among P1, . . . , Pn in the F∗
CR-hybrid model. For circuit
φ, let |φ| denote its circuit complexity. For a given execution of
Π starting from a particular initialization Ω of parties’ inputs and
random tapes and distribution of coins, let VΠ,Ω denote the sum of
all |φ| such that some honest party claimed an F∗
CR transaction by
producing a witness for φ during an execution of Π. Then the script
♦
complexity of Π, denoted VΠ, equals maxΩ (VΠ,Ω).
Secure computation with penalties—multiple executions. We
now present the functionality F∗
MSFE which we wish to realize.
Recall that secure computation with penalties guarantees the fol-
lowing.

An honest party never has to pay any penalty.
If a party aborts after learning the output and does not deliver
output to honest parties, then every honest party is compen-
sated.

See Figure 3 for a formal description. The main difference between
the prior deﬁnitions in [6, 15] is that F∗
MSFE directly realizes multi-
ple invocations of secure computation with penalties. For simplic-
itly F∗
In the ﬁrst phase referred to as the deposit phase, the functional-
ity F∗
MSFE accepts safety deposits coins(d) from each honest party

MSFE deals only with the non-reactive case.

421Notation: session identiﬁer sid, parties P1, . . . , Pn, adversary S that
corrupts {Ps}s∈C, safety deposit d, penalty amount q, a time-limit τ,
set H = [n] \ C.
DEPOSIT PHASE: Initialize ﬂg = ⊥.
• Wait to get message (setup, sid, ssid, i, coins(d)) from Pi for all
i ∈ H. Then wait to get message (setup, sid, ssid, coins(hq))
from S where h = |H|.

EXECUTION PHASE: Set ﬂg = 0. For k = 1, . . ., sequentially do:
• Wait to receive a message (input, sid, ssid(cid:107)k, i, x(k)
• Wait until

, fk) from
Pi for all i ∈ H. Send (function, sid, ssid(cid:107)k, fk) to all parties.
time τ to receive a message (input, sid, ssid(cid:107)k,
s }s∈C , fk) from S. If no such message was received within

{x(k)
time τ, then go to the claim phase.

i

1 , . . . , z(k)

• Compute (z(k)
• Send message (output, sid, ssid(cid:107)k, {z(k)
• If S returns (continue, sid, ssid),

n ) ← fk(x(k)

1 , . . . , x(k)
n ).

s }s∈C ) to S.
then send (output, sid,

ssid(cid:107)k, z(k)

i

) to each Pi.

• Else if S returns (abort, sid, ssid), update ﬂg = 1, and go to the

claim phase.

CLAIM PHASE: At time τ, do:
• If ﬂg = 0 or ⊥, send (return, sid, ssid, coins(d)) to all Pr for
r ∈ H. If ﬂg = 0, send (return, sid, ssid, coins(hq)) to S.
• Else if ﬂg = 1, send (penalty, sid, ssid, coins(d + q + qi))
to Pi for all i ∈ H where qi = 0 unless S sent a message

(extra, sid, ssid, {qi}i∈H ,(cid:80)

i∈H coins(qi)).

Figure 3: Special ideal functionality F∗
quential SFE with penalties.

MSFE for multiple se-

and penalty deposit coins(hq) from the adversary. Note that the
penalty deposit sufﬁces to compensate each honest party in the
event of an abort. Once the deposits are made, parties enter the
next phase referred to as the execution phase where parties can en-
gage in unbounded number of secure function evaluations. In each
execution, parties submit inputs and wait to receive outputs. As
usual, the ideal adversary S gets to learn the output ﬁrst and then
decide whether to deliver the output to all parties. If S decides to
abort, then no further executions are carried out, parties enter the
claim phase, and honest parties get coins(d + q), i.e., their safety
deposit plus the penalty amount. Note that penalties are distributed
only at time τ. Now if S never aborts during a local execution,
then the safety deposits are returned back to the honest parties, and
S gets back its penalty deposit at time τ.
Note that we require S to deposit coins(hq) up front. This is
different from the deﬁnition of secure computation with penalties
in [6], where S may not submit coins(hq) and yet the computation
might proceed. We believe that our deﬁnition is more natural. We
are able to support this deﬁnition because in our protocol (unlike
the case in [6]), the computation happens only after all the deposits
are made. Next, we discuss the reactive case.
Reactive case. The deﬁnition for the secure computation with
penalties in the reactive setting F∗
MSFE ex-
cept that the function fk is composed of sub-functions for the dif-
ferent stages, i.e., fk = (fk,1, . . . , fk,ρ), where ρ denotes the num-
ber of stages. Now, S can abort between different stages of fk or
within a single stage, say fk,ρ(cid:48). In either case, the honest parties
will be compensated via the penalty deposit coins(hq) submitted
by S in the deposit phase. For lack of space, the formal deﬁnition
is presented in the full version.

MMPC is identical to F∗

3. TWO PARTY NON-REACTIVE CASE

j

j

We describe the protocol for the 2-party non-reactive case in Fig-
ure 4. For clarity, we annotate each of the steps in (1) the master
deposits as Txj, (2) the k-th local setup phase as sp(k)
, (3) the k-
th local exchange phase as ex(k)
, (4) the master claims as clmj.
Sometimes we treat these annotations as Boolean variables which
are set to 1 if the corresponding event occurred or else they are set
to 0. As an example, we say “sp(k)
delivered output
to P1. We now explain the design of the protocol and describe each
of the phases in more detail. In the presentation here we ignore
some details on the time-limits.

1 = 1” iff F ord(cid:98)fk

In the master setup phase, parties interact with an unfair ideal
functionality that runs the key generation algorithm for a digital
signature scheme, and outputs the master veriﬁcation key mvk to
both parties, and secret shares the master signing key msk. In ad-
dition, the master function will authenticate the shares of the mas-
ter signing key. Looking ahead we will need this authentication
because each subsequent local execution will need to produce sig-
natures veriﬁable by the master veriﬁcation key. To do so, these
subsequent local executions will reconstruct the master signing key
from the authenticated secret shares held by both parties. Follow-
ing this, parties enter the master deposit phase where they make
F∗
CR deposits as follows. In the following, τ2 > τ1.

P1

P2

φ2

−−−−−−−−−−−−−→
−−−−−−−−−−−−−→

q,τ2

φ1

q,τ1

P2

P1

(Tx2)

(Tx1)

Here, the predicates φ1, φ2 have the master veriﬁcation key mvk
hardcoded in them. The predicates essentially check if their input is
a valid signature against the master veriﬁcation key mvk. The mes-
sages that are signed under msk will be secret shares of the output
of a function evaluation (more on this in the next paragraph), and
we will append the player index and an execution number denoted
id, and then sign the message consisting of player id, nonce, and
secret share under the master signing key msk. As we will see be-
low, the predicate φ1 takes as input one message and a correspond-
ing signature, while the predicate φ2 takes as input two messages
and corresponding signatures. In addition to checking the validity
of the signatures, the predicates also verify an additional condition
on the nonces contained in the underlying signed messages. Below,
we explicitly specify the predicates φ1 and φ2:

φ1(id1, t1, σ1; mvk) = SigVerify(mvk, (1, id1, t1), σ1)
φ2(id1, t1, σ1, id2, t2, σ2; mvk) =

 (id1 = id2)
(cid:86) SigVerify(mvk, (1, id1, t1), σ1)
(cid:86) SigVerify(mvk, (2, id2, t2), σ2)



functionality F ord(cid:98)fk

Next, we describe the local setup phase. In the k-th local setup
phase, the parties submit their authenticated shares of the master
signing key, and further also submit the inputs to an unfair ideal
computing the function fk that is to be com-
puted in this phase. As described before, the k-th setup phase ﬁrst
reconstructs the master signing key from the authenticated shares
submitted by the parties. Then it computes the function fk on the
inputs submitted by the parties to obtain the output z(k). (For sim-
plicity, we assume that all parties obtain the same output.) Fol-
lowing this, the output z(k) is secret shared using an additive secret
sharing scheme to produce shares s(k)
2 . Each of these shares is
then authenticated twice: once using the reconstructed master sign-

1 , s(k)

422MASTER SETUP PHASE: P1 and P2 interact with an ideal func-

tionality F(cid:98)f that computes (mvk, msk) ← SigKeyGen(1λ)

and computes secret shares msk1, msk2 of msk and delivers
msk1, mvk, MAC(msk2) to P1 and msk2, mvk, MAC(msk1) to
P2 where MAC is (an information-theoretic) message authentication
code.
MASTER DEPOSIT PHASE: Parties make the following F∗

CR deposits:

P1

P2

−−−−−−−−−−−−−−−→

φ2
q,τ2

−−−−−−−−−−−−−−−→

φ1
q,τ1

P2

P1

(Tx2)

(Tx1)

where:

φ1(id1, t1, σ1; mvk) = SigVerify(mvk, (1, id1, t1), σ1)
φ2(id1, t1, σ1, id2, t2, σ2; mvk) =

 (id1 = id2)
(cid:86) SigVerify(mvk, (1, id1, t1), σ1)
(cid:86) SigVerify(mvk, (2, id2, t2), σ2)



interact with an ideal functionality F ord(cid:98)fk
and the corresponding MACs. F ord(cid:98)fk

EXECUTION PHASE: In the k-th local setup phase: Parties agree on
the function to be executed fk via broadcast.
If there is disagree-
ment, then parties enter the master claim phase. Else, P1 and P2
to which they input: (1) the
function fk and inputs to fk, and (2) mvk, secret shares of msk,
computes the output z(k) ob-
tained by evaluating fk on the inputs provided by the parties, then it
loc ) ←
secret shares z(k) = s(k)
SigKeyGen(1λ) and computes σ(k)
i = SigSign(msk, (i, k, s(k)
and ψ(k)

)). F ord(cid:98)fk
the following order (i.e., χ = (2, 1) for F ord(cid:98)fk

))
sends the outputs in

2 . It then computes (vk(k)

i = SigSign(sk(k)

loc , (i, k, s(k)

1 ⊕s(k)

loc , sk(k)

):

i

i

(sp(k)
2 )
(sp(k)
1 )

loc ) to P2,
loc ) to P1.

2. (s(k)

1. (s(k)

2 , σ(k)
1 , σ(k)

2 , ψ(k)
1 , ψ(k)

2 ; vk(k)
1 ; vk(k)
In the k-th local exchange phase:
1. P1 sends (s1, ψ1) = (s(k)
2. If SigVerify(vk(k)
2 ) to P1.

2 , ψ(k)

1 , ψ(k)

1 ) to P2.

loc , (1, k, s1), ψ1) = 1:

(ex(k)
1 )
P2 sends
(ex(k)
2 )
CLAIM PHASE: Parties enter this phase when either all local execu-
tions are completed or in the event of aborts after/during the master
deposit phase.

(s(k)

2. At

1. At time τ1:

1

1

If sp(k+1)

= 1,
, σ(k+1)

1 , σ(k)
time τ2,

1
1 ) if k > 0.

tion.
ness (k + 1, s(k+1)
(k, s(k)

let k denote the last completed local execu-
then P1 claims Tx1 using wit-
), else claim Tx1 using witness
(clm1)
if party P1 claimed Tx1 using witness
(id1, t1, σ1), then party P2 claims Tx2 at time τ2 using wit-
ness (id1, t1, σ1, id2 = id1, t2 = s(id1)
, σ2 = σ(id1)
).
If there exists k such that sp(k)
2 = 0, then
both parties output t1⊕t2 as the output of the k-th execution.
(clm2)

2 = 1 but ex(k)

2

2

Figure 4: 2-party realization of F∗

MSFE

ing key msk, and once using a local signing key sk(k)
loc generated
inside the unfair ideal functionality. We stress that the local sign-
ing key sk(k)
loc is never revealed to any party; recall that the global
signing key msk is never revealed to any party either. Finally, the
local outputs of the unfair ideal functionality in the k-th local setup
phase are distributed in the following order to the two parties:

1. Party P2 obtains its secret share of the output s(k)

2

on T (k)

a signature σ(k)
and a signature ψ(k)
corresponding local veriﬁcation key vk(k)
loc .

2 = (2, k, s(k)
on T (k)

2

2

2

along with
2 ) signed under msk
loc and the
(sp(k)
2 )

signed under sk(k)

1

1

1

1

on T (k)

signed under sk(k)

1 = (1, k, s(k)
on T (k)

2. Party P1 obtains its secret share of the output s(k)

a signature σ(k)
and a signature ψ(k)
corresponding local veriﬁcation key vk(k)
loc .

along with
1 ) signed under msk
loc , and the
(sp(k)
1 )
We will shortly discuss why the order of outputs as above is
needed (i.e., why P1 obtains the output of the local setup phase
after P2). Observe that to obtain the output of the local phase, par-
ties simply have to exchange the shares s(k)
2 , and the out-
put of the local phase equals s(k)
2 . The local exchange phase
happens in the following order:

1 ⊕s(k)

and s(k)

1

1. Party P1 ﬁrst sends T (k)

1

and ψ(k)

1

to P2.

(ex(k)
1 )

2

to P1.

2. If a valid message was received, then P2 sends T (k)

and ψ(k)
2
(ex(k)
2 )
After this, the local phase completes, and the parties have obtained
the outputs. Note that since signatures under sk(k)
loc are unforgeable
except with negligible probability (because each party only has an
additive share of sk(k)
loc ), it follows except with negligible proba-
bility that a valid (T (k)
) pair sent by party Pi has to be the
one generated by the local setup phase, and hence results in parties
generating the correct output. Following this, the parties can then
proceed to the next local phase and so on. Suppose (cid:96) denote the
total number of successfully completed local executions. Once all
the (cid:96) local executions are completed, the parties proceed to master
claim phase where the following happens in order:

, ψ(k)

i

i

1 , σ(k)
time τ2,

1. At time τ1:

If sp(k+1)

tion.
ness (k + 1, s(k+1)
(k, s(k)

let k denote the last completed local execu-
then P1 claims Tx1 using wit-
), else claim Tx1 using witness
(clm1)

= 1,
, σ(k+1)

1 ) if k > 0.

1

1

1

2. At

if party P1 claimed Tx1 using witness
(id1, t1, σ1), then party P2 claims Tx2 at time τ2 using wit-
ness (id1, t1, σ1, id2 = id1, t2 = s(id1)
If
there exists k such that sp(k)
2 = 0, then
both parties output t1⊕t2 as the output of the k-th execution.
(clm2)

2 = 1 but ex(k)

, σ2 = σ(id1)

).

2

2

The master claim phase is designed in a way that allows the hon-
est party to force the completion of the most recent local execu-
tion that is incomplete. For instance, P1 can force the comple-
tion of the (k + 1)-th execution by claiming Tx1 using witness
, σ(k+1)
(k + 1, s(k+1)
). This then forces P2 to reveal the secret
share s(k+1)
without which it cannot claim Tx2. This is because
the only signature under msk on messages of the form (2, k + 1,∗)
that P2 possesses is T (k+1)
). Thus, we have
that either P2 claims Tx2 or pays a penalty coins(q) to honest P1.

= (2, k + 1, s(k+1)

1

1

2

2

2

423On the other hand, if P1 was dishonest or if all local executions
were completed, then parties effectively replay some old execution.
That is, P1 will claim Tx1 using witnesses obtained from the k-th
local execution for which ex(k)
2 = 1. Following this P2 can claim
Tx2 using witness revealed by P1 and witness obtained from the
k-th local setup phase. We prove:

THEOREM 1. Assume one-way functions exist. There exists a
2-party protocol that SCC-realizes F∗
CR)-
hybrid model such that the number of calls to F∗
CR, its script com-
plexity, and deposit amounts are independent of the number of exe-
cutions.

MSFE in the (FOT,F∗

Proof sketch. Let Pj denote the party corrupted by the adversary A.
We describe the simulator S for the protocol of Figure 4. S begins
by acting as the unfair ideal functionality in the master setup phase,
and runs the key generation algorithm of a digital signature scheme
to produce (mvk, msk). It then chooses a random mskj to give
to A. If A aborts the master setup phase, then S outputs whatever
A outputs and terminates the simulation. Else, in the master de-
posit phase, S acts as F∗
CR. If j = 2, it waits to receive a deposit
from A. If the deposit was not received or the deposit is not of
the speciﬁed format, then S aborts outputting whatever A outputs.
Else, S obtains coins(q) from A which it forwards to F∗
MSFE as the
penalty deposit. On the other hand, if j = 1, then S acting as F∗
informs A that (honest) P2 made the deposit as instructed. Then
CR
it waits for A to make the deposit. Again if the deposit is not of
the correct form or was not made, then S terminates the simulation
outputting whatever A outputs. In this case, the simulation is in-
distinguishable from the real execution since honest P2 would have
got coins(q) refunded from Tx2 with all but negligible probability
(except in the case A manages to forge signatures under msk).
Else, it obtains coins(q) from A which it forwards to F∗
MSFE as
the penalty deposit. This concludes the simulation of the master
setup and deposit phases.
In the k-th local setup phase, S learns of the function to be evalu-
MSFE and acts as the unfair ideal functionality F ord(cid:98)fk
ated fk from F∗
,
and obtains the input for this execution from A. Note that if A
sends incorrect shares of msk, then S terminates the simulation,
and the simulation will be indistinguishable from the real execution
since the MAC checks won’t pass in the real execution except with
negligible probability. Then S runs the key generation algorithm
of a digital signature scheme to generate (vk(k)
loc ), and com-
putes the signature ψ(k)
j = (j, k, s)
If A
for random value s.
aborts in this step, then S rejects any further local executions and
goes directly to the simulation of the master claim phase (described
below). This still results in a valid simulation since A should not
be able to forge a signature under sk(k)
loc due to the unforgeability
property of the digital signature scheme. Otherwise, S begins the
simulation of the local exchange phase.
If j = 1, then it waits
to receive (T, ψ) from A.
), S termi-
nates the simulation (since this is a forgery that should happen
only with negligible probability). Otherwise, S contacts F∗
with the extracted input (obtained while acting as F ord(cid:98)fk
MSFE
) to obtain
the output of the local execution z(k). S acting as P2 sends the
2 = (2, k, z(k)⊕s) and the signature ψ(k)
value T (k)
to
A. The case when j = 2 is also handled similarly. S ﬁrst sub-
mits the extracted input to F∗
MSFE to get the output of the k-th
local execution z(k). Then S acting as honest P1 sends the value
1 = (1, k, s⊕z(k)) along with a signature ψ(k)
to A. It
T (k)

loc , sk(k)
loc on message T (k)
, vk(k)
loc

If (T, ψ) (cid:54)= (T (k)

It then sends T (k)

under sk(k)

on T (k)

to A.

on T (k)

, ψ(k)

, ψ(k)

2

j

j

j

j

j

2

1

1

1

. Now, S acting as F∗

is easy to see that the simulation is indistinguishable from the real
execution.
Finally, we describe the simulation of the master claim phase. S
enters this phase either because there were: (1) aborts in the local
setup phase, (2) aborts in the local exchange phase, or (3) all ex-
ecutions were successfully completed. We analyze separately the
case when P1 is corrupt and the case when P2 is corrupt. Suppose
j = 1. S waits until time τ1 to see if P1 claims Tx1. Suppose
P1 does not claim Tx1, then S waits to get its penalty deposit back
from F∗
MSFE and sends it to P1 as refund obtained from Tx2. The
simulation is indistinguishable from the real execution because P2
always obtains the output ﬁrst in the local execution; thus if P1
had received the output of a local execution phase, then so did P2.
Therefore, S will be able to get its penalty deposit coins(q) back
from F∗
MSFE. Now on the other hand, suppose P1 did claim Tx1
using some witness (id1, t1, σ1), then S checks if σ(id1)
1 = σ1 (i.e.,
if σ1 was handed to A during the simulation). The check will pass
with all but negligible probability since this corresponds to A forg-
ing a signature under msk. In the rest of the analysis we will as-
sume that σ1 = σ(id1)
CR will need to produce
coins(q) to A as the claim reward for claiming Tx1. To do so, S
will need to obtain its penalty amount from F∗
MSFE. As before, this
step is possible since P1 cannot learn the output of a local execution
before the honest party (recall P2 always obtains outputs ﬁrst in the
local exchange phase), and thus S will be able to get its penalty
deposit back from F∗
MSFE which it can send to P1 as the money
obtained by claiming Tx1. Now all that S needs to do is to produce
witnesses for claiming Tx2 in order to justify that coins(q) from
Tx2 are not going to be refunded back to P1. This is easy since
the witness (id1, t1, σ1, id2 = id1, t2 = z(id1)⊕t1, σ2 = σ(id2)
)
satisﬁes φ2. In other words, the secret shares and corresponding
signatures from the id1-th execution will allow honest P2 to claim
Tx2. This concludes the simulation in the case when P1 is corrupt.
It is easy to see that the simulation is indistinguishable from the
real execution.
Next, we consider the case when j = 2. Now S will need
to act ﬁrst (as honest P1) in the master claim phase. Let k de-
note the number of completed local executions, i.e., ex(k)
2 = 1. If
k = 0, then S does not have to act in the master claim phase. It
will simply get back its penalty deposit from F∗
MSFE and return it
to P2 as refund of Tx1. The simulation is indistinguishable from
real since except with negligible probability P2 will not be able
to produce signatures under msk to claim Tx2. In the rest of the
simulation, we assume k > 0. At time τ1, S will have to claim
Tx1. To do so, S ﬁrst checks if there was an incomplete local
execution, i.e., if sp(k+1)
= 1. If there was, this means that the
output of the (k + 1)-th execution was not obtained by both par-
ties (in fact, it is possible that only P2 obtained the output and not
P1). S will claim Tx1 using the witness (k + 1, s⊕z(k+1), σ(k+1)
)
where s was the secret share given to P2 as part of the output
of the (k + 1)-th local setup phase. Now, S waits to see if P2
claims Tx2. Suppose P2 does not claim Tx2, then this means that
in the real execution honest P1 would not obtain the output, but
only the penalty. Thus, to make the simulation indistinguishable
from real, S will send an abort message to F∗
MSFE, and termi-
nate the simulation (in particular, it will not get its penalty deposit
back from F∗
MSFE). On the other hand, if P2 did claim Tx2, then
except with negligible probability it has to do using the witness
(k + 1, s⊕z(k+1), σ(k+1)
). This is because the
only signature under msk on messages of the form (k + 1,∗,∗)
that A possesses is on the message (k + 1, s, σ(k+1)
) obtained dur-
ing the interaction with S. Thus, in this case, S asks F∗
MSFE to

, k + 1, s, σ(k+1)

2

1

1

2

2

1

424n,i < τi = τ unlock

i+1,i =

Note on time-limits: τ1 < τ2 < ··· < τn.
For each i ∈ [n − 1]: τ lock
i+1,i = ··· τ lock
··· τ unlock
ROOF DEPOSITS. For each j ∈ [n − 1]:

n,i

.

φn

Pj

−−−−−−−−−−−−−−−−→

Pn
LADDER DEPOSITS. For i = n − 1 down to 1:
• Rung unlock: For j = n down to i + 1:

q,τn

tially check if their input is a valid signature against the master
veriﬁcation key mvk. The messages that are signed under msk
will be secret shares of the output of a function evaluation (more
on this in the next paragraph), and we will append the player in-
dex and a nonce denoted id which essentially denotes an execution
number, and then sign the message consisting of player id, nonce,
and secret share under the master signing key msk. In addition to
checking the validity of the signatures, the predicates also verify an
additional structural relation on the nonces contained in the under-
lying signed messages. Below, we explicitly specify the predicates
{φlock

j,i },{φi},{φunlock

}:

j,i

−−−−−−−−−−−−−−−−→

φunlock

j,i

q,τ unlock

j,i

Pi

j,i (TT, id, σ; mvk) = tv(id)
φlock

i−1(TT)

SigVerify(mvk, (j, i, id), σ)

(Txn,j)

(Txunlock

j,i

)

(Txi)

(Txlock
j,i )

Pj

• Rung climb:

−−−−−−−−−−−−−−−−→
Pi
• Rung lock: For each j = n down to i + 1:

φi
i·q,τi

Pi+1

Pi

−−−−−−−−−−−−−−−→

φlock
j,i

q,τ lock
j,i

Pj

Figure 5: Locked ladder mechanism from [15].

1

deliver the output to P1 for execution k + 1, and obtains back the
penalty deposit from F∗
MSFE which it forwards to P2 as the reward
obtained for claiming Tx2. Finally, we consider the case when
sp(k+1)
= 0, i.e., the (k + 1)-th execution did not deliver outputs
In this case, S gets its penalty deposit coins(q)
to either party.
MSFE. Then S claims Tx1 using witnesses from the
back from F∗
k-th execution, i.e., (k, s⊕z(k), σ(k)
1 ) where s was the random se-
cret share sent to P2. Now if P2 claims Tx2, except with negligible
probability it has to do using witness (k, s⊕z(k), σ(k)
1 , k, s, σ(k)
2 ).
Suppose P2 claimed Tx2, then S produces the necessary coins(q)
from the returned penalty deposit. On the other hand, if P2 did not
claim Tx2, then S sends the returned coins(q) back to F∗
MSFE to
be delivered to the honest party as extra reward. It is easy to see
that the simulation is indistinguishable from real both in the stan-
dard sense as well as with respect to the distribution of coins. This
concludes the proof of the theorem.

4. MULTIPARTY CASE

We describe the protocol for the multiparty non-reactive case.

MASTER SETUP PHASE AND MASTER DEPOSIT PHASE. In the
master setup phase, parties interact with an unfair ideal functional-
ity that realizes the master setup function which runs the key gen-
eration algorithm for a digital signature scheme, and outputs the
master veriﬁcation key mvk to all n parties, and secret shares the
master signing key msk. In addition, the master function will au-
thenticate the shares of the master signing key. That is, in spirit,
the master setup phase is identical to the one in the 2-party case,
except now it caters to n parties. Next, parties enter the master
deposit phase where they make F∗
CR deposits as in Figure 5 (i.e.,
identical to the locked ladder mechanism in [15]). Note that rela-
tion between time-limits is speciﬁed in Figure 5.
j,i } all have the master
veriﬁcation key mvk hardcoded in them. The predicates essen-

Here, the predicates {φi}, {φunlock

}, {φlock

j,i

(cid:94)

(cid:94)

φi(TT, id; mvk) = tv(id)

(TT)

i

φunlock

j,i

(TT, id, σ; mvk) = tv(id)

i

(TT)

SigVerify(mvk, (j, i, id), σ)

In the above, we refer to the witness σ as the “lock witness.” The
description of the predicates use the transcript validator tv which
we deﬁne below:

Let TT = (T (id1)
tv(id)

1
(TT) = 1 iff

i

, σ(id1)

1

)(cid:107)···(cid:107)(T (idi)

i

, σ(idi)

i

).

Then

– id1 = ··· = idi ≥ id.
– for all j ≤ i: T (idj )

j

is a message of the form (j, idj,∗)

and σ(idj )

j

is a valid signature on T (idj )

j

under msk.

i

That is, tv(id)

puts to an unfair ideal functionality F ord(cid:98)fk

ensures that the witnesses reveal the partial tran-
script containing the ﬁrst i message-signature pairs, i.e., (T, σ)
pairs. Furthermore the relation between the transcript witness and
the lock witness is that the id’s contained in them are such that
id1 = ··· = idi ≥ id.
LOCAL SETUP PHASE. Next, we describe the local setup phase.
In the k-th local setup phase, the parties submit their authenticated
shares of the master signing key, and further also submit the in-
computing the function
fk. The k-th local setup phase ﬁrst reconstructs the master signing
key from the authenticated shares submitted by the parties. Then
it computes the function fk on the inputs submitted by the parties
to obtain the output z(k). Following this, the output z(k) is secret
shared using an additive secret sharing scheme to produce shares
s(k)
1 , . . . , s(k)
n . Each of these shares is then authenticated twice:
once using the reconstructed master signing key msk, and once
using a fresh local signing key sk(k)
. In ad-
dition signatures under msk are generated on messages (j, i, k) for
all i, j ∈ [n] × [n] such that j ≥ i. We stress that the local sign-
ing key sk(k)
loc is never revealed to any party; recall that the global
signing key msk is never revealed to any party either. Finally, the
local outputs of the unfair ideal functionality in the k-th local setup
phase are distributed in the following order to the parties:

loc generated inside F(cid:98)fk

For i = n down to 1:

(a) [Main witness signed under both local and global keys]
along with a
) signed under
loc and the
(sp(k)
)

Party Pi obtains its secret share of the output s(k)
signature σ(k)
i = (i, k, s(k)
msk and a signature ψ(k)
corresponding local veriﬁcation key vk(k)
loc .

on the message T (k)
on T (k)

signed under sk(k)

i

i

i

i

i

i

425Pj obtains a signature σ(k)
Observe that the witnesses delivered by F ord(cid:98)fk

(b) [Lock witness signed under global key] For j = n to i + 1:
j,i on “(j, i, k)” under msk. (sp(k)
j,i )
are in the reverse
order of the witnesses that are required to claim the master de-
posits. Later in the local exchange phase, these witnesses will be
exchanged among the parties in the reverse order in which they
were distributed in the setup phase.
LOCAL EXCHANGE PHASE. To obtain the output of the local phase,
parties simply have to exchange the shares {s(k)
i }, and the output of
i = z(k). The local exchange phase

the local phase equals(cid:76)

is(k)
happens in the following order:
For i = 1 to n:
(a) Party Pi broadcasts T (k)
(b) [Abort] Let µ(k)

i

i

i = (T (k)

and ψ(k)
, ψ(k)

(ex(k)
to all parties.
)
) denote the message sent
is not of the form (i, k,∗) or if
by Pi.
) (cid:54)= 1, then all parties terminate
SigVerify(vk(k)
the k-th local phase, do not participate in any further local ex-
ecutions, and enter the master claim phase.

If either T (k)

loc , T (k)

i
, ψ(k)

i

i

i

i

i

i

i

, ψ(k)

After this, the local phase completes, and the parties have obtained
the outputs. Note that since signatures under sk(k)
loc are unforgeable
except with negligible probability (because each party only has an
additive share of sk(k)
loc ), it follows except with negligible proba-
bility that a valid (T (k)
) pair sent by party Pi has to be the
one generated by the local setup phase, and hence results in parties
generating the correct output. Following this, the parties can then
proceed to the next local phase and so on. Alternatively, if some
party did not send a valid message, then the honest parties would
simply terminate the local executions and enter the master claim
phase. An important note is that it may be the case that at this point
the adversary already knows the output, therefore in these cases,
we have to ensure that the honest party is compensated. This will
be handled in the master claim phase.
MASTER CLAIM PHASE. From the discussion above, it is clear that
parties may enter the master claim phase if there was an abort that
happened during one of the earlier phases. We will handle all these
cases in our description of the master claim phase. Let k denote the
most recent completed execution, i.e., ex(k)
n = 1. It is possible that
the (k +1)-th execution was never started (either there was an abort
or the parties unanimously agreed to terminate all local executions),
or there was an abort in the middle which means sp(k+1)
= 1 or
even ex(k+1)
= 0
must hold (otherwise (k + 1)-th execution was also completed).
We describe the master claim phase for each Pi.
1. For j = 1 to i − 1: At time τ lock

= 1 for some i. Note however that ex(k+1)

n

i

i

i,j

if j = 1 or clmj−1 = 1 or
(clmlock
i,j )

clmunlock

i(cid:48),j−1 = 1 for some i(cid:48):

1

i,1

(a) If j = 1 and i (cid:54)= 1, then claim Txlock

i,1 using witness (TT0 =
=

) if sp(k+1)

NULL, k(cid:48), σ(cid:48)), where (k(cid:48), σ(cid:48)) = (k + 1, σ(k+1)
1, else (k(cid:48), σ(cid:48)) = (k, σ(k)
i,1 ).
(b) Else, let TT be the set of transcripts that were revealed dur-
ing the claim of Txj−1,{Txunlock
i(cid:48),j−1}. Let ID denote the set
of id’s that the transcripts in TT are consistent with, i.e., for
TT ∈ TT, there is an id ∈ ID, such that tv(id)
j−1(TT) = 1.
Let id(cid:48) denote the maximum value in ID and let TT(cid:48) de-
note the corresponding transcript. Claim Txlock
i,j using witness
TT(cid:48), id(cid:48), σ(id(cid:48))
i,j .

2. At time τi if (1) i = 1 or (2) clmi−1 = 1 or (3) clmunlock

j,i−1 = 1
(clmi)
where k(cid:48) is the

1

1

, σ(k(cid:48))

for some j or (4) clmlock

j,i = 1 for some j:
(a) If i = 1, then claim Tx1 using T (k(cid:48))
1 = 1.
j,i−1},{Txlock

maximum value such that sp(k(cid:48))
(b) Else, let TT be the set of transcripts that were revealed during
the claim of Txi−1,{Txunlock
j,i }. (Note that all these
transcripts contain the ﬁrst i − 1 secret shares.) Let ID denote
the set of id’s that the transcripts in TT are consistent with, i.e.,
for TT ∈ TT, there is an id ∈ ID, such that tv(id)
i−1(TT) = 1.
Let id(cid:48) denote the maximum value in ID and let TT(cid:48) denote
the corresponding transcript. Claim Txi using witness TTi =
(TT(cid:48)(cid:107)(T (id(cid:48))
), id(cid:48)). Save the value TTi to use in the next
step.

(cid:107)σ(id(cid:48))

i

i

(a) Claim Txunlock

j,i

3. For j = i + 1 to n: At time τ unlock

(clmunlock
)
using TTi (from the previous step), k(cid:48), σj,i

j,i = 1:

if clmlock

j,i

j,i

where (∗, k(cid:48), σj,i) was the witness used to claim Txlock
j,i .
This concludes the description of the master claim phase. We
present a series of propositions which will be useful to prove that
our protocol realizes F∗
MSFE. Detailed proofs of the propositions
are available in the full version. In the following, we assume that k
denotes the most recent completed execution, i.e., ex(k)

n = 1.

PROPOSITION 2. Honest parties never lose money during the

claim phase. That is, for every honest Pi:

1. If Txi−1 was claimed, then Pi will be able to claim Txi.

2. If Txlock

j,i was claimed by Pj for j > i, then Pi will be able to

claim Txunlock

.

j,i

3. If Txunlock

i,j was claimed by Pj for j > i,then it must hold that

Txlock

i,j was claimed by Pi.

Proof sketch. The main argument is that the local setup phase re-
leases witnesses in a way such that if Txi−1 can be claimed then
so can Txi. This is because Step sp(k)
i−1 occurs after Step sp(k)
.
j,i will require witnesses for claiming
Next, note that a claim of Txlock
Txi−1 and the lock witness σj,i. Now to claim Txunlock
, Pi needs
witnesses for claiming Txi and the lock witness σj,i. Therefore,
if Txlock
using witnesses for
j,i
claiming Txi (this follows from the argument for the previous case)
j,i . This
and the lock witness σj,i revealed during the claim of Txlock
completes the proof.

is claimed then Pi can claim Txunlock

j,i

j,i

i

PROPOSITION 3. There exists a unique k(cid:48) ≤ k + 1 such that
for each i ∈ H (i.e., Pi is honest), the only signatures under msk
on messages of the form (i, k(cid:48)(cid:48),∗) that are revealed to adversary
are for k(cid:48) = k(cid:48)(cid:48).

Proof sketch. The main argument is that the lexicographically ﬁrst
honest party, say Pi will reveal only one signature under msk on
messages of the form (i,∗,∗). That is there will be a unique k(cid:48)
for which Pi will release only one signature under msk on a mes-
sage of the form (i, k(cid:48),∗). Denote this message-signature pair as
(Ti, σi). Actually, (Ti, σi) = (T (k)
) where the latter is re-
ceived in Step sp(k)
. Clearly, (Ti, σi) is released when Pi claims
Txi. Let TTi be the witness used to claim Txi. The master claim
is designed in a way such that TTi along with a lock witness is
used to claim Txunlock
(see Steps (2b) and (3a)). Now given that

, σ(k)

i

i

i

j,i

426honest Pi releases signatures under msk only on Ti, it follows
that any valid partial transcript TTi(cid:48) released by honest party Pi(cid:48)
to claim Txi(cid:48) or Txunlock
i(cid:48),j for j > i will necessarily have
(Ti, σi) ∈ TTi(cid:48). Thus, for TTi(cid:48) to be a valid partial transcript, it
must hold that (Ti(cid:48) , σi(cid:48) ) ∈ TTi(cid:48) must be such that Ti(cid:48) = (i(cid:48), k(cid:48),∗).
This completes the proof.

or Txlock

j,i(cid:48)

PROPOSITION 4. Suppose the local setup phase of the (k + 1)-
th execution is successfully completed. Then, either the (k + 1)-th
execution was completed in the master claim phase, or all honest
parties obtained a penalty. More precisely, for every j ∈ [n], the
following holds right after the j-th unlock phase: either TTj con-
taining the transcript of the most recent execution up to the j-th se-
cret share was revealed by Pj, or all honest parties have obtained
a penalty already.

i,1

i,1

i,1 using the lock witness σ(k+1)

Proof sketch. Suppose the (k + 1)-th local setup phase was com-
pleted. This means that all honest parties obtained the local wit-
nesses for the (k + 1)-th execution. Thus, each honest party Pi
will begin claiming Txlock
on mes-
, party P1 must produce TT1
sage (i, 1, k + 1). To claim Txunlock
which contains main witness (1, k +1,∗), i.e., corresponding to the
(k + 1)-th execution. It no such main witness is released, then it
follows that honest parties claim penalty coins(q) from P1. (In this
case, by Proposition 2 we have that honest parties don’t lose money
elsewhere, so they end up with penalty coins(q).) The remainder
of the proof follows by an induction argument on each Pj (with
the base proved above for j = 1) for the statement exactly as in the
proposition. We note that for the general case, honest parties whose
index is less than j would have claimed penalty coins(q) from the
coins((j − 1)q) deposited in Txj−1, and the honest parties whose
index is above j would have claimed penalty coins(q) from the lock
deposits Txlock
i,j . Note that the proposition implies that if the adver-
sary gets the output of the (k + 1)-th execution, then either honest
parties also obtain the output or they obtain a penalty.

PROPOSITION 5. Suppose there was an abort in the (k + 1)-th
local setup phase. Then, the adversary obtains the output of the
(k + 1)-th execution only if (1) the honest parties also obtained the
output of (k + 1)-th execution, or (2) all honest parties obtained a
penalty.

1

1

Proof sketch. Suppose sp(k+1)
= 0. Then we argue that no party
gets the output of the (k +1)-th execution. This is because no party
obtains the ﬁrst secret share of the output. Then by Proposition 2
we have that honest parties don’t lose money, and this sufﬁces for
security. On the other hand if sp(k+1)
= 1, then it is possible
that the adversary obtains the output of the (k + 1)-th execution.
Note that since an abort happened in the (k + 1)-th local setup
phase, it follows that the honest parties would not have broadcasted
any messages in the (k + 1)-th local exchange phase. Thus, for
the adversary to get output, it needs honest parties to reveal the
main witnesses corresponding to the (k + 1)-th execution during
the master claim phase. By Proposition 3, it follows that the adver-
sary must ensure that the ﬁrst honest party, say Pi reveals the main
witness corresponding to the (k + 1)-th execution (even though the
adversary might have obtained this witness from the (k + 1)-th lo-
cal exchange phase). Then, by an argument similar to the proof of
Proposition 4 and starting the base case of the induction from in-
dex i + 1 we have that either the (k + 1)-th local execution was
completed or all honest parties obtained a penalty. On the other
hand, if the ﬁrst honest party does not produce a main witness cor-
responding to the (k + 1)-th execution, then the adversary will not

obtain the output of the (k + 1)-th execution. In this case, invoking
Proposition 2 is sufﬁcient to ensure security. We defer the proof of
the following theorem to the full version.

THEOREM 6. Assume one-way functions exist. There exists
CR)-hybrid
CRand its script complexity are

MSFE in the (FOT,F∗

a protocol that SCC-realizes F∗
model s.t. the number of calls to F∗
independent of the number of executions.
4.1 The Reactive Case

j, tv(cid:48)

j−1(TT(cid:48)

j}j∈[n]. Here tv(cid:48)

Due to space limitations, we only provide a short sketch of our
protocol. More details are avaiable in the full version. We will
follow the idea used in [15] to realize secure computation of re-
active functionalities with penalties. At a high level, the idea is
to let the parties run an MPC protocol π(cid:48) for the underlying reac-
tive functionality, and have the predicates in the F∗
CR transactions
check the validity of the partial protocol transcript. That is, let an
n-party m-message protocol π(cid:48) be deﬁned by pairs of algorithms
{nmf(cid:48)
j is the transcript validator function that
takes a transcript of the protocol up to the j-th message, and out-
puts 1 iff it is a valid transcript of π(cid:48). The algorithm nmf(cid:48)
j is the
next message function that takes a valid partial transcript TT(cid:48)
j−1
(i.e., tv(cid:48)
j−1) = 1), party Pj mod n’s input xj mod n and its
private randomness, say ωj mod n, and produces the j-th message
µ(cid:48)
j of the protocol signed under Pj mod n’s public key. We deﬁne
j−1(cid:107)µ(cid:48)
the j-th partial transcript TT(cid:48)
j.
Protocol transformation. As in [15], we will transform a n-party
j}j∈[m] into an equivalent n-
m-message protocol π(cid:48) = {nmf(cid:48)

message m-message protocol (cid:101)π = {(cid:103)nmf j,(cid:101)tvj}j∈[m] where the

j = TT(cid:48)
j, tv(cid:48)

protocol messages contain layers of signatures. That is, each party
signs each message it sends, so messages contain layers of sig-
natures. Also, parties do not accept messages which do not have
correct signatures.
Our construction. Surprisingly, our construction for the reactive
case is very similar to the protocol for the non-reactive case. In fact,
the master setup phase and the master deposit phase is identical.
That is, the sequence of deposits is the same as the locked ladder
mechanism presented in Figure 5. As it turns out, the predicate
descriptions are also identical as in the non-reactive case, of course
with the important difference that now tv will also need to include
the transcript validator of the MPC protocol realizing the reactive
functionality. Thus, our predicates are:

j,i (TT, id, σ; mvk) = tv(id)
φlock

i−1(TT)

SigVerify(mvk, (j, i, id), σ)

φi(TT, id; mvk) = tv(id)

(TT)

i

(cid:94)
(cid:94)

j,i

φunlock

(TT, id, σ; mvk) = tv(id)

The transcript validator tv deﬁned below, now depends on (cid:101)π =
{(cid:103)nmf j,(cid:101)tvj}j∈[m]:

SigVerify(mvk, (j, i, id), σ)

(TT)

i

1, id1, ψ1, T1, σ1)(cid:107)···(cid:107)(µ(cid:48)

i, idi, ψi, Ti, σi).

Let TT = (µ(cid:48)
Then tv(id)

i

(TT) = 1 iff

– (cid:101)tv(id)

i

– id1 = ··· = idi ≥ id.
– for all j ≤ i: Tj is a message of the form (j, idj,∗) and

σj is a valid signature on Tj under msk

(µ(cid:48)

1, id1, ψ1)(cid:107)···(cid:107)(µ(cid:48)
to

denote

i, idi, ψi) = 1.
of

We

use

(µj, idj, ψj, Tj, σj) and (cid:102)TT to denote concatenation of three-
tuples (µj, idj, ψj). tv,(cid:101)tv are the respective transcript validators

concatenation

ﬁve-tuples

TT

427Speciﬁcally,

of TT,(cid:102)TT. We give details on the rest of the protocol. At a

the main new argument

high level, all of the phases are very similar to the non-reactive
case except for the use of additional witnesses (µ(cid:48)
i, id, ψi) which
essentially correspond to the actual MPC execution of the reactive
functionality.
to prove
security will be the unforgeability of the signature ψi for honest Pi
on the message (µ(cid:48)
i, id) and that in a witness TTj used by corrupt
Pj, the id’s in TTj must be consistent with T (id)
for honest Pi
(the unique id under which honest parties release signatures under
msk) which in turn forces µ(cid:48)
i, id, ψi used as part of TTj to be
exactly as the ones released by Pi. As in the non-reactive case, we
will be able to prove that the id corresponds to an incomplete local
execution if there is one.
LOCAL SETUP PHASE. In the k-th local setup phase parties submit
the authenticated secret shares of the master signing key as input
that delivers outputs in the fol-

to an unfair ideal functionality F ord(cid:98)fk

i

lowing order:

For i = n down to 1:

(a) [Main witness signed under global keys] Party Pi obtains a
on the message
(sp(k)
)
(b) [Lock witness signed under global key] For j = n down to

along with a signature σ(k)
) signed under msk.

random value s(k)
i = (i, k, s(k)
T (k)

i

i

i

i

i + 1:
Pj obtains a signature σ(k)

j,i on message (j, i, k) under msk.
(sp(k)
j,i )

Observe that this phase is identical to the non-reactive case ex-

i

(k)
j

,(cid:101)tv(k)

are completely random.

cept now the values s(k)
LOCAL EXCHANGE PHASE. Parties start exchanging messages cor-
responding to the local reactive MPC evaluating reactive function

fk. We denote this reactive MPC protocol as(cid:101)π(k) deﬁned by a pair
of algorithms {(cid:103)nmf
above. Party P1 starts by running (cid:103)nmf

j }j∈[m]. Note that we will be using the
protocol obtained as a result of transformation procedure described
to generate the ﬁrst mes-
sage µ(k)
of the protocol π(k) realizing the reactive function fk.
Then party P2 upon receiving µ(k)
to
generate µ(k)
and broadcasts this to all parties. The protocol pro-
ceeds like this till the very end when Pn sends the message µ(k)
n .
More precisely, let µ(k)

0 = NULL, and let protocol(cid:101)π(k)

from P1, invokes (cid:103)nmf

(k)
1

(k)
2

1

1

2

be deﬁned as {(cid:103)nmf

0 = (cid:102)TT(k)
,(cid:101)tv(k)

(k)
j

j }j∈[n]. For j ∈ [n]:

j mod n and randomness ω(k)

Upon receiving µ(k)
with input x(k)

(cid:101)tv(k)
j−1) = 1 and if so, sets (cid:102)TT(k)
j = (cid:103)nmf
parties, and sets(cid:102)TT(k)
j−1; (x(k)
j−1(cid:107)µ(k)

j−1 from party Pj−1 mod n, party Pj mod n
j mod n checks if
j−2(cid:107)µ(k)
j−1,
j mod n)) to all
(ex(k)
)

((cid:102)TT(k)
j =(cid:102)TT(k)

j−1 = (cid:102)TT(k)

j−1(µ(k)
sends µ(k)

j mod n, ω(k)

(k)
j

.

j

j

MASTER CLAIM PHASE. Denote by k the most recent completed
execution, i.e., ex(k)
n = 1. It is possible that the (k + 1)-th execu-
tion was never started (either there was an abort or the parties unan-
imously agreed to terminate all local executions), or there was an
abort in the middle which means sp(k+1)
= 1
for some i. Note that party Pi needs to act only at time instances
{τ lock
}j>i We describe the master claim phase for
Pi:

i,j }i>j, τi,{τ unlock

= 1 or even ex(k+1)

j,i

i

i

1. For j = 1 to i − 1: At time τ lock

i,j

clmunlock

i(cid:48),j−1 = 1 for some i(cid:48):

if j = 1 or clmj−1 = 1 or
(clmlock
i,j )

1

i,1

(a) If j = 1 and i (cid:54)= 1, then claim Txlock

i,1 using witness (TT0 =
=

) if sp(k+1)

NULL, k(cid:48), σ(cid:48)), where (k(cid:48), σ(cid:48)) = (k + 1, σ(k+1)
1, else (k(cid:48), σ(cid:48)) = (k, σ(k)
i,1 ).
(b) Else, let TT be the set of transcripts that were revealed dur-
ing the claim of Txj−1,{Txunlock
i(cid:48),j−1}. Let ID denote the set
of id’s that the transcripts in TT are consistent with, i.e., for
TT ∈ TT, there is an id ∈ ID, such that tv(id)
j−1(TT) = 1.
Let id(cid:48) denote the maximum value in ID and let TT(cid:48) de-
note the corresponding transcript. Claim Txlock
i,j using witness
TT(cid:48), id(cid:48), σ(id(cid:48))
i,j .

1

1

1

1

1

1

1

1

.

(k(cid:48))
1

, T (k(cid:48))

j,i−1},{Txlock

on inputs x(k(cid:48))

for some j or (4) clmlock

2. At time τi if (1) i = 1 or (2) clmi−1 = 1 or (3) clmunlock

j,i−1 = 1
(clmi)
, σ(k(cid:48))
)
1 = 1, and µ(k(cid:48))
,
and ran-

j,i = 1 for some j:
(a) If i = 1, then claim Tx1 using (µ(k(cid:48))
is obtained by applying (cid:103)nmf

, k(cid:48), ψ(k(cid:48))
where k(cid:48) is the maximum value such that sp(k(cid:48))
ψ(k(cid:48))
domness ω(k(cid:48))
(b) Else, let TT be the set of transcripts that were revealed during
j,i }. (Note that all these
the claim of Txi−1,{Txunlock
transcripts contain the ﬁrst i − 1 secret shares.) Let ID denote
the set of id’s that the transcripts in TT are consistent with, i.e.,
for TT ∈ TT, there is an id ∈ ID, such that tv(id)
i−1(TT(cid:48)) = 1.
Let id(cid:48) denote the maximum value in ID and let TT(cid:48) denote the
corresponding transcript.
i. If ex(id(cid:48))

then set TTi−1 = (µ1, id(cid:48), ψ1, T1, σ1)(cid:107)
···(cid:107)(µi−1, id(cid:48), ψi−1, Ti−1, σi−1) where
the messages
µ1, . . . , µi−1 and the corresponding signatures ψ1, . . . , ψi−1
are obtained from the id(cid:48)-th local exchange phase (i.e.,
from a transcript before) and the values T1, . . . , Ti−1
and the corresponding signatures σ1, . . . , σi−1 are ob-
tained from TT(cid:48). Let (µ(id(cid:48))
) be the message
that Pi sent during the id(cid:48)-th local exchange phase. Set
, id(cid:48), ψ(id(cid:48))
TTi = TTi−1(cid:107)(µ(id(cid:48))
plying (cid:103)nmf

i
ii. Else: let (µ(id(cid:48))
) be the message obtained by ap-
i
(id(cid:48))
that is implicit in TT(cid:48), us-
i
ing input x(id(cid:48))
(i.e., exactly the in-
puts/random tape it would have used in the id(cid:48)-th local execu-
, T (id(cid:48))
tion). Set TTi = TT(cid:48)(cid:107)(µ(id(cid:48))
Claim Txi using witness TTi and save the value TTi to use in
the next step.

and randomness ω(id(cid:48))
, id(cid:48), ψ(id(cid:48))

on transcript (cid:102)TT

, id(cid:48), ψ(id(cid:48))
, T (id(cid:48))

, id(cid:48), ψ(id(cid:48))

, σ(id(cid:48))

, σ(id(cid:48))

= 1,

).

).

(cid:48)

i

i

i

i

i

i

i

i

i

i

i

i

i

3. For j = i + 1 to n: At time τ unlock

j,i

if clmlock

(clmunlock
)
using TTi (from the previous step), k(cid:48), σj,i

j,i = 1:

j,i

(a) Claim Txunlock

j,i

where (∗, k(cid:48), σj,i) was the witness used to claim Txlock
j,i .

This concludes the description of the master claim phase and of
the protocol. Please see the full version for the formal description
and the security proof.

5. CONCLUSIONS

We made a distinction between “on-chain” complexity (veriﬁ-
cation complexity imposed on miners) and “off-chain” complex-
ity (that is borne by the protocol participants).
In this paper we
showed how to amortize the “on-chain”cost of secure computation

428with penalties. Several important questions remain. Could we re-
duce the “on-chain” complexity of a single execution? Alterna-
tively, can we derive the amortization result for the reactive case
using only O(nr) initial deposits? Also, can we improve the prac-
ticality of our schemes by possibly removing the need to do the
signature generation/veriﬁcation part inside the MPC?

Acknowledgements
Research of the ﬁrst author is supported in part by NSF Grants
CNS-1350619 and CNS-1414119, in part by the Defense Advanced
Research Projects Agency (DARPA) and the U.S. Army Research
Ofﬁce under contracts W911NF-15-C-0226, and an MIT Transla-
tional Fellowship. Research of the second author is supported by
funding from the European Community’s Seventh Framework Pro-
gramme (FP7/2007-2013) under grant agreement number 240258
and NSF grant 1561209.
6. REFERENCES
[1] M. Andrychowicz, S. Dziembowski, D. Malinowski, and L.

Mazurek. Fair two-party computations via the bitcoin
deposits. In Bitcoin Workshop, FC, 2014.

[2] M. Andrychowicz, S. Dziembowski, D. Malinowski, and L.

Mazurek. Secure multiparty computations on bitcoin. In
IEEE Security and Privacy, 2014.

[3] Marcin Andrychowicz, Stefan Dziembowski, Daniel
Malinowski, and Lukasz Mazurek. How to deal with
malleability of bitcoin transactions, 2013. Available from
http://arxiv.org/pdf/1312.3230.pdf.

[4] A. Back and I. Bentov. Note on fair coin toss via bitcoin.

http://arxiv.org/abs/1402.3698, 2013.

[5] S. Barber, X. Boyen, E. Shi, and E. Uzun. Bitter to better -

how to make bitcoin a better currency. In Financial
Cryptography, 2012.

[6] I. Bentov and R. Kumaresan. How to use bitcoin to design

fair protocols. In Crypto, 2014.

[7] R. Cleve. Limits on the security of coin ﬂips when half the

processors are faulty. In STOC, 1986.

[8] C. Decker and R. Wattenhofer. A fast and scalable payment

network with bitcoin duplex micropayment channels.
http://www.tik.ee.ethz.ch/ﬁle/
716b955c130e6c703fac336ea17b1670/
duplex-micropayment-channels.pdf.

[9] O. Goldreich. Foundations of cryptography vol.2. 2004.
[10] Oded Goldreich, Silvio Micali, and Avi Wigderson. How to

play any mental game, or a completeness theorem for
protocols with honest majority. 1987.

[11] Ethan Heilman, Foteini Baldimtsi, and Sharon Goldberg.
Blindly signed contracts: Anonymous on-blockchain and
off-blockchain bitcoin transactions. In Bitcoin Workshop,
Financial Cryptography, 2016.

[12] A. Kiayias, H-S. Zhou, and V. Zikas. Fair and robust

multi-party computation using a global transaction ledger. In
Eurocrypt, pages 705–734, 2016.

[13] A. Kosba, A. Miller, E. Shi, Z. Wen, and C. Papamanthou.

Hawk: The blockchain model of cryptography and
privacy-preserving smart contracts. In IEEE S&P, 2016.

[14] R. Kumaresan and I. Bentov. How to use bitcoin to

incentivize correct computations. In CCS, 2014.

[15] R. Kumaresan, T. Moran, and I. Bentov. How to use bitcoin

to play decentralized poker. In CCS, 2015.

[16] R. Kumaresan, V. Vaikuntanathan, and P. Vasudevan.

Improvements to secure computation with penalties. In CCS,
2016.

[17] Alptekin Küpçü and Anna Lysyanskaya. Usable optimistic

fair exchange. In CT-RSA, 2010.

[18] Andrew Y. Lindell. Legally-enforceable fairness in secure

two-party computation. In CT-RSA, 2008.

[19] G. Maxwell. 2011. https:

//en.bitcoin.it/wiki/Zero_Knowledge_Contingent_Payment.

[20] Rafael Pass and Abhi Shelat. Micropayments for

decentralized currencies. In 22nd CCS, 2015.

[21] J. Poon and T. Dryja. The bitcoin lightning network:

Scalable off-chain instant payments.
https://lightning.network/lightning-network-paper.pdf.

[22] Peter Todd. OP_CLTV, 2014.

https://github.com/petertodd/bips/blob/checklocktimeverify/
bip-checklocktimeverify.mediawiki.

[23] Andrew Yao. How to generate and exchange secrets
(extended abstract). In FOCS, pages 162–167, 1986.

APPENDIX
A.

IMPLEMENTATION OF F∗

CR

Earlier works described how to realize F∗

CR in Bitcoin by means
[6, Appendix F]). This proposed im-
of refund transactions (cf.
plementation required an ideal Bitcoin system, since an actual de-
ployment in current Bitcoin network would be exposed to a mal-
leability [3] attack. However, the OP_CHECKLOCKTIMEVERIFY
[22] (abbrev. CLTV) softfork of November 2015 enables a simpler
F∗
CR implementation that does not rely a refund transaction, thus
avoiding transaction malleability altogether. The November 2015
softfork added the new CLTV opcode to the Bitcoin scripting lan-
guage, which enables execution of instructions conditioned upon
the requirement that the transaction resides in block whose index is
large enough (or that its timestamp is late enough).
ment F∗
script whose high-level description is as follows:

Given OP_CHECKLOCKTIMEVERIFY, we can easily imple-
CR (with φs,r(·) = 1 ⇔ Hash(·) = h0) by using a Bitcoin

CLTV Pseudocode: pkS, pkR, h0, τ are hardcoded.

if (block# > τ ) then

Ps can sign with skS to spend the coins(q)

else

Pr can spend the coins(q) by

signing with skR
AND
supplying w such that Hash(w) = h0

An actual implementation as a Bitcoin script can be given as

follows:

CLTV Bitcoin script:

<timeout> CHECKLOCKTIMEVERIFY IF HASH256
<h0> EQUALVERIFY <Pr> CHECKSIGVERIFY ELSE
<Ps> CHECKSIGVERIFY ENDIF

Irrespective of CLTV, let us note that our realization of F∗

The above script assumes that the redemption script will put on
the top of stack w, sigPr with SHA256d(w) = h0 in the ﬁrst case,
or sigPs in the second case.
(cf. Figure 4) relies on a sender-speciﬁed circuit φs,r(·) that veri-
ﬁes a signature. Thus, deployment of our protocols in Bitcoin re-
quires a script instruction that veriﬁes an arbitrary signature.
In
principle, such an instruction is not any more complex than the
standard OP_CHECKSIGVERIFY instruction, but the current Bit-
coin scripting language lacks this instruction. Since multiple other
proposals would also beneﬁt from an arbitrary signature veriﬁca-
tion instruction (see, e.g., [20, 11]), such an opcode might be added
to Bitcoin in the future.

MSFE

429