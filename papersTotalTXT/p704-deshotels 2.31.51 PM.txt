SandScout: Automatic Detection of

Flaws in iOS Sandbox Proﬁles

Luke Deshotels
North Carolina State

University

ladeshot@ncsu.edu

R˘azvan Deaconescu
University POLITEHNICA of
razvan.deaconescu@

Bucharest
cs.pub.ro

Mihai Chiroiu

University POLITEHNICA of

mihai.chiroiu@

Bucharest
cs.pub.ro

Lucas Davi

Technische Universität
Darmstadt, Germany

William Enck

North Carolina State

University

lucas.davi@trust.cased.de

whenck@ncsu.edu

Ahmad-Reza Sadeghi

Technische Universität
Darmstadt, Germany

ahmad.sadeghi@trust.cased.de

ABSTRACT
Recent literature on iOS security has focused on the ma-
licious potential of third-party applications, demonstrating
how developers can bypass application vetting and code-
level protections. In addition to these protections, iOS uses
a generic sandbox proﬁle called “container” to conﬁne ma-
licious or exploited third-party applications. In this paper,
we present the ﬁrst systematic analysis of the iOS container
sandbox proﬁle. We propose the SandScout framework to
extract, decompile, formally model, and analyze iOS sand-
box proﬁles as logic-based programs. We use our Prolog-
based queries to evaluate ﬁle-based security properties of the
container sandbox proﬁle for iOS 9.0.2 and discover seven
classes of exploitable vulnerabilities. These attacks aﬀect
non-jailbroken devices running later versions of iOS. We are
working with Apple to resolve these attacks, and we expect
that SandScout will play a signiﬁcant role in the develop-
ment of sandbox proﬁles for future versions of iOS.

1.

INTRODUCTION

The sale of smartphones has out-paced the sale of
PCs [15]. The two dominant platforms for these smart
phones are Android and iOS [16]. There has been a sig-
niﬁcant amount of academic research on Android, in part,
because of its open-source nature. In contrast, iOS is not
open-source, and studies of iOS may require signiﬁcant re-
verse engineering eﬀort.

Prior research on iOS security has focused on the follow-
ing three areas. First, works have demonstrated methods
for creating iOS malware [48, 22, 33, 52, 40, 47]. Second,
others emphasize methods to detect malicious behavior ei-
ther statically [29] or dynamically [28]. Third, new security
mechanisms [22, 26, 50] have been proposed that hook into

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’16, October 24-28, 2016, Vienna, Austria
c(cid:13) 2016 ACM. ISBN 978-1-4503-4139-4/16/10. . . $15.00
DOI: http://dx.doi.org/10.1145/2976749.2978336

application code to provide additional security. All of these
works rely on interacting with the code of third-party iOS
applications.

We investigate something diﬀerent: iOS sandbox proﬁles.
These sandbox proﬁles deﬁne access control policies for sys-
tem calls made by processes. There are 117 sandbox proﬁles
in the iOS 9.0.2 kernel, and many system daemons and ap-
plications have dedicated proﬁles. However, all third-party
applications, and some system applications, are conﬁned us-
ing the shared “container” sandbox proﬁle. The container
sandbox proﬁle is large and complex, leading to the research
question: what ﬂaws in the container sandbox proﬁle can
third-party iOS applications exploit?
Goals and Contributions:
In this paper, we present
the SandScout framework to answer this research question.
First, we create a tool, SandBlaster, which automatically
extracts compiled proﬁles from a ﬁrmware image and de-
compiles them into their original SandBox Proﬁle Language
(SBPL). Second, we formally model sandbox proﬁles using
Prolog by creating a compiler that automatically translates
SBPL policies into Prolog facts. Third, we develop Prolog
queries that test critical security properties of the container
sandbox policy. The queries identify potential security vul-
nerabilities in the policy. Finally, we create an iOS applica-
tion that provides assisted veriﬁcation of potential vulnera-
bilities on iOS devices.

We use SandScout to evaluate the container sandbox pro-
ﬁle for iOS 9.0.2. Sandbox proﬁles mediate all system calls
including ﬁle access and inter-process communication (IPC).
For this evaluation, we limit our security queries to ﬁle-based
sandbox policy rules for two reasons. First, non-ﬁle-based
sandbox policy rules require additional semantics that are
not available in the policy. Second, we ﬁnd signiﬁcant se-
curity vulnerabilities within the ﬁle-based sandbox policy
rules. We plan to expand our analysis to non-ﬁle-based pol-
icy rules in future work.

Our analysis of the ﬁle-based policy rules in the iOS
9.0.2 container sandbox proﬁle identiﬁed seven broad vul-
nerabilities that are exploitable by third-party applications:
(1) methods of bypassing iOS’s privacy settings for Con-
tacts; (2) methods of learning a user’s location search his-
tory; (3) methods of inferring sensitive information by ac-
cessing metadata of system ﬁles; (4) methods of obtaining

704the user’s name and media library; (5) methods of consum-
ing disk storage space that cannot be recovered by unin-
stalling the malicious app; (6) methods of preventing access
to system resources such as the AddressBook; (7) methods
for colluding applications to communicate without using iOS
sanctioned IPC. We have reported all of these vulnerabili-
ties to Apple and are working with them to ensure they are
ﬁxed in future versions of iOS.

This paper makes the following contributions:
• We develop the ﬁrst methods to automatically produce
human readable SBPL policies. Prior work was unable
to produce SBPL policies for human review or auto-
mated analysis. Our tool extracts and decompiles all
sandbox proﬁles in ﬁrmwares for iOS 7, 8, and 9.

• We formally model SBPL policies using Prolog. We
create an SBPL to Prolog compiler based on a context
free grammar we have deﬁned for SBPL.

• We perform the ﬁrst systematic evaluation of the con-
tainer sandbox proﬁle for recent versions of iOS and
discover vulnerabilities. We develop Prolog queries
representing security requirements. When applied to
the iOS 9.0.2 container sandbox proﬁle, we discover
seven classes of security vulnerabilities.

The remainder of the paper proceeds as follows. Section 2
provides background information. Section 3 provides an
overview of SandScout. Section 4 discusses our design. Sec-
tion 5 presents our results. Section 6 provides discussion of
our limitations. Section 7 presents related work. Section 8
concludes.

2. BACKGROUND

iOS is the operating system of the iPhone, iPod, iPad,
and older versions of AppleTV (newer AppleTV devices run
TVOS). iOS is based largely on Apple’s desktop operating
system, OS X, and the two share many internal similarities.
2.1 iOS Security Mechanisms

iOS relies on four broad types of security mechanisms: ap-
plication vetting, code signing, memory protection, and sand-
boxing. When developers submit an application to the App
Store [7] for vetting, they sign the application using their de-
veloper key. While the speciﬁc details of the vetting process
are only known to Apple, it is assumed that they use a com-
bination of static and dynamic analysis to detect malicious
behavior. If Apple approves of the application, it adds its
own signature to the application and makes the application
available on the App Store.

An iOS device will only execute code pages coming from
binaries with valid signatures. Generally, having a valid sig-
nature means the application is signed by Apple. However,
devices provisioned for developers or enterprises may also
run applications signed by speciﬁc developer and enterprise
keys. Finally, immutable capabilities called entitlements are
stored inside an application’s signature. Apple grants devel-
opers a certiﬁcate that determines which entitlements they
may apply to their applications.
In addition to code signing,

iOS uses data execution
prevention (DEP) and address space layout randomization
(ASLR) to mitigate memory attacks. DEP prevents code
injection attacks by ensuring that no code page is writable

and executable at the same time. ASLR mitigates code-
reuse attacks by randomizing code and data segments in
memory. Interestingly, code signing complicates the ASLR
design and limits its protection, because shuﬄing code re-
gions may invalidate signatures [2]. Prior work [48, 22, 42,
34] has demonstrated several techniques for bypassing ap-
plication vetting and memory protections.

iOS sandboxes all applications using a mandatory access
control policy to limit the abilities of exploited or malicious
code. Sandbox policies are enforced by the Trusted BSD
mandatory access control framework [18] using a kernel ex-
tension called Sandbox.kext. iOS uses diﬀerent sandbox poli-
cies (called proﬁles) for diﬀerent applications. Many system
applications and daemons have their own proﬁle. However,
all third-party applications are controlled by a generic sand-
box proﬁle called container. The container sandbox proﬁle
is also used by several system applications. In order to sup-
port the functionality of many diﬀerent applications, it is
the largest and most complex sandbox proﬁle.

Sandbox proﬁle rules deﬁne access to system calls (e.g.,
ﬁle read and write). To be generic, the container sandbox
proﬁle uses conditional rules that may require capabilities.
There are two primary types of capability considered by the
sandbox: entitlements and sandbox extensions. Mentioned
above, entitlements are static capabilities assigned by ap-
plication’s developer during development. Entitlements are
key-value pairs, which are stored in a dictionary structure
embedded in an application’s code signature. Note that en-
titlement keys are not cryptographic keys, and they simply
map to values in the entitlement dictionary. Once the ap-
plication has been signed, its entitlements cannot be mod-
iﬁed without invalidating the signature. In contrast, sand-
box extensions are dynamic capabilities that can be granted
or revoked at run time. System daemons such as the tccd
daemon, which helps enforce iOS’s user speciﬁed Privacy
Settings, can grant sandbox extensions.

Finally, while the vast majority of iOS’s access control
policy is enforced in Sandbox.kext using sandbox proﬁles,
there are various access control checks within system dae-
mons. These system daemons maintain their own policies
based on user preferences (e.g., for Privacy Settings) and
entitlements.
In this paper, we limit our investigation to
the sandbox proﬁles and leave these other daemon speciﬁc
access control policies to future work.
2.2 Sandbox Proﬁle Language (SBPL)

Sandbox proﬁles are written in the SandBox Proﬁle Lan-
guage (SBPL), which is derived from Scheme. Sandbox pro-
ﬁles are compiled from SBPL into binary blobs that are
structured as graphs for eﬃcient queries.

An SBPL sandbox proﬁle consists of a version indicator,
a default decision, and 0 or more rules. Sandbox rules can
allow or deny access to system calls based on capabilities
held by the sandboxed process. A default decision (i.e., deny
or allow) deﬁnes the decision to make if no sandbox rule
matches the evaluated system call. The container proﬁle
and the majority of sandbox proﬁles we have encountered are
whitelists that deny by default. Therefore, SBPL examples
provided in this paper assume a default deny policy.

Each sandbox rule consists of a decision (i.e., allow or
deny), an operation (e.g., file-read-data or file-write-
create), and 0 or more ﬁlters and metaﬁlters.
Filters: A ﬁlter considers the context of the system call

705Figure 1: Overview of SandScout.

and consists of a ﬁlter-type and 0 or more ﬁlter-values. A
ﬁlter-type indicates the ﬁlter’s type (e.g., subpath, literal,
or regex). Filter-values represent parameters for the ﬁlter-
type (e.g., a string indicating a ﬁle path).
Metaﬁlters: Metaﬁlters act as logical operations on ﬁlters.
There are three types of explicit metaﬁlters: require-all
requires all of its ﬁlters to be satisﬁed (i.e., logical AND);
require-any requires any of its ﬁlters to be satisﬁed (i.e.,
logical OR); and require-not requires that the ﬁlters not
be satisﬁed (i.e., logical NOT). Metaﬁlters can be, and fre-
quently are, nested.

Some ﬁlters imply the use of metaﬁlters. The regex ﬁlter
implies a require-any metaﬁlter applied to a list of one or
more reqular expressions that act as its ﬁlter values. The
require-entitlement ﬁlter implies a require-all metaﬁlter
applied to an entitlement key and the entitlement-value ﬁl-
ter. The entitlement-value ﬁlter may also have metaﬁlters
applied to it, but these are explicitly stated. Note that the
entitlements of a process are stored as key-value pairs in a
dictionary structure, so all entitlements have both keys and
values. Section 4.2 discusses our context free grammar for
parsing the SBPL language.

Ideally, a sandbox proﬁle should allow only those privi-
leges a process requires. The container sandbox proﬁle pro-
vides ﬂexibility by using metaﬁlters that only provide priv-
ileges if a process has required capabilities. Consider the
following example SBPL rule

( allow f i l e - r e a d *

( r e q u i r e - a l l

( subpath " / M e d i a / S a f a r i " )
( r e q u i r e - n o t

( literal " / M e d i a / S a f a r i / s e c r e t . t x t " )

)
( r e q u i r e - e n t i t l e m e n t

" p r i v a t e . s i g n i n g - i d e n t i f i e r "
( r e q u i r e - a n y

( e n t i t l e m e n t - v a l u e " m o b i l e s a f a r i " )
( e n t i t l e m e n t - v a l u e " s a f a r i f e t c h e r d " )

) ) ) )

capabilities called sandbox extensions, which can be granted
and revoked at runtime. The sandbox proﬁle can include
conditional rules that require sandbox extensions with syn-
tax similar to the example for shown for entitlements.

3. OVERVIEW

Apple’s application review process is not infallible [48, 22,
42, 34, 23, 51, 13, 1, 11]. The iOS container proﬁle is de-
signed to protect against abuse by third-party applications.
However, little is known about the actual policy it enforces.
Least privilege sandbox policies are diﬃcult to deﬁne cor-
rectly [20, 53, 44, 46, 39, 37]. Therefore, in this paper,
we ask the overarching research question, what ﬂaws in the
container sandbox proﬁle can third-party iOS applications
exploit? That is, we seek to systematically identify vulner-
abilities in the container proﬁle. Answering this question
requires addressing the following challenges:

• Sandbox policy extraction. Built-in sandbox policies
are stored in binary form as precompiled graphs. Ap-
ple sometimes changes the location and structure of
these built-in proﬁles in updates to iOS. We were un-
able to ﬁnd any sandbox decompilation tools that de-
compiled sandbox proﬁles into SBPL.

• Modeling sandbox policy semantics. The SandBox Pol-
icy Language is not oﬃcially documented and must
be reverse engineered. Unoﬃcial documentation of
SBPL [32, 42], is outdated and only documents a mi-
nority of the sandbox operations available for iOS.

• Automated discovery and veriﬁcation of potential vul-
nerabilities. We ﬁrst need to understand the mistakes
and misconﬁgurations made by developers working on
the Apple sandbox. Then we must deﬁne heuristics to
detect these misconﬁgurations. Finally, we must eval-
uate the consequences of abusing potential misconﬁg-
urations detected by these heuristics.

This rule allows the sandboxed process to read any ﬁle other
than secret.txt in the /Media/Safari/ subpath, if that pro-
cess has the required capabilities. In this case, the required
entitlement key is "private.signing-identifier", and the en-
titlement value must be either "mobilesafari" or "safar-
ifetcherd". In other words, this rule states that the Mobile
Safari app or the safarifetcherd daemon can read ﬁles other
than secret.txt in the /Media/Safari/ directory.

In addition to immutable entitlements, iOS uses dynamic

SandScout addresses these challenges in four parts as
shown in Figure 1. First, we created SandBlaster to auto-
matically extract sandbox proﬁles from iOS ﬁrmware images
and decompile them. Second, we created an SBPL to Pro-
log compiler to automatically convert sandbox proﬁles into
collections of Prolog facts. Third, we model security require-
ments as Prolog queries to systematically discover facts that
violate those requirements. Fourth, we have semi-automated
the attack veriﬁcation process.

2) Policy Modeling1) Sandbox Decompilation3) Policy AnalysisiOS FirmwareCompiledSandboxProﬁlesSBPL to Prolog Compiler4) Attack Veriﬁcation File PathsTo AttackProlog Engine (Uniﬁcation)Prolog QueriesProlog FactsVeriﬁed AttacksProlog RulesSBPL SemanticsSecurity RequirementsSBPL ProﬁlesProﬁle 1Proﬁle nAttack TesterSandbox Decompiler (SandBlaster)...706We chose to use Prolog for three reasons. First, Prolog
was used for evaluation of security policies in prior work [30,
24]. Second, Prolog is capable of handling the regular ex-
pressions that can appear in Apple sandbox proﬁles. Third,
Prolog is suﬃciently extensible for incorporating additional
iOS security mechanisms in future work.

Our analysis focuses on the container proﬁle because it
sandboxes third party applications, for which we can con-
struct a common set of security requirements. SandScout
can also analyze the other sandbox proﬁles extracted from
iOS; however since they are primarily used for trusted sys-
tem apps, the threat model is diﬀerent.
(1) Sandbox Decompilation: To extract and decompile
sandbox proﬁles, we created SandBlaster. SandBlaster de-
compiles sandbox proﬁles directly from iOS ﬁrmware images,
which can be downloaded directly from Apple [4]. Sand-
Blaster is the ﬁrst tool to fully decompile sandbox proﬁles
for iOS 7, 8, and 9 into human readable and compilable
SandBox Proﬁle Language (SBPL). While Blazakis [3] pre-
viously created a sandbox proﬁle decompiler, his tool cannot
decompile modern iOS sandbox proﬁles (i.e., iOS 7, 8, and
9). Esser [31] also created a sandbox analysis tool, but it
only produces intermediate information (i.e., graphs), which
are insuﬃcient for our analysis.

We chose to work with decompiled SBPL proﬁles for three
reasons. First, we want Apple to be able to use the origi-
nal SBPL proﬁles as input to our system. Second, under-
standing SBPL proﬁles provides insight into how developers
might make mistakes. Third, the ability to modify and run
our decompiled SBPL proﬁles helped us test our results and
reverse engineer SBPL semantics.
(2) Policy Modeling: We model iOS sandbox proﬁles as
collections of Prolog facts. We created a compiler, which
uses a context free grammar to automatically parse and
recursively translate SBPL into Prolog facts. Nesting of
metaﬁlters as shown in Section 2 makes converting from
SBPL to Prolog nontrivial. We handle combinations of log-
ical ANDs and logical ORs by formatting the Prolog facts
in disjunctive normal form.
(3) Policy Analysis: We model the security requirements
of stakeholders as Prolog queries. The queries discussed in
this paper are not intended to be comprehensive, but they
provide practical demonstrations of the ﬂaws SandScout can
detect. The following is an example of a security require-
ment: No third-party application should have direct write
access to system ﬁles. A query representing this require-
ment may match harmless sandbox rules (e.g., write access
to /dev/null), but we demonstrate that it can also detect
signiﬁcant vulnerabilities. SandScout is extensible and can
process more queries than those demonstrated in this paper.
We model proﬁle-independent semantics of SBPL as Pro-
log rules. For example, the knowledge that file-read* access
implies file-read-data and file-read-metadata can be rep-
resented as a Prolog rule. Since these Prolog rules are true
for every SBPL proﬁle, they only need to be deﬁned once.
Note that sandbox rules and Prolog rules are not the same
thing. A sandbox rule allows or denies an operation for a
given set of ﬁlters. A Prolog rule is a clause that represents
a logical relationship between Prolog facts.
(4) Attack Veriﬁcation: To remove any false positives
produced by our queries, we have created an iOS appli-
cation for testing attacks that abuse sandbox misconﬁgu-

rations. This app implements a collection of Objective-C
functions for testing operations on ﬁle paths (e.g., moving
ﬁles, querying databases, creating hard links, etc.). The ap-
plication also includes functions that perform more complex
attacks such as copying a given number of 10 MB ﬁles to a
given directory in order to consume storage space. The app
reports on which attacks are successful and outputs error
messages for those attacks that fail.
Summary of Findings: We have used SandScout to eval-
uate the container sandbox proﬁle from iOS 9.0.2. Sand-
Scout detected sandbox rules vulnerable to seven attacks.
Each of these attacks has been disclosed to Apple, and has
been successfully tested on iOS 9.3.1 (Latest version at the
time of experiments). These attacks can be more broadly
categorized as follows.

• Bypassing Privacy Settings: By creating a hard link to
the AddressBook database while an app has access to
it, that app can keep access even after the user revokes
access through Privacy Settings. The app can place
the hard link into a directory accessible to other apps
that have never been granted access to the AddressBook
through Privacy Settings.

• Privacy Leaks: We have identiﬁed several system ﬁles
containing sensitive user data that the container proﬁle
allows third-party applications to read. These unpro-
tected ﬁles contain information on the user’s location
search history, media contents, the user’s name, and
the names of computers that have synced to the de-
vice. Third-party apps can also read the metadata of
all directory ﬁles and learn potentially sensitive infor-
mation about the user and the device. We also iden-
tify 4 ﬁle paths that are both readable and writable to
third-party apps, which allows applications to easily
leak information to other apps.

• System Damage: Third-party apps can abuse write
access to system ﬁles by deleting, moving, or changing
permissions to prevent legitimate access to these ﬁles.
These apps can also consume all storage space on the
hard drive by creating new system ﬁles or appending
data to existing ones. This storage space is not released
by uninstalling the third-party app nor does it appear
in the Storage Manager as being used by the app.

4. DESIGN

SandScout detects attacks against iOS sandbox proﬁle
vulnerabilities in four steps. First, we automatically de-
compile the sandbox proﬁles with our tool, SandBlaster.
Second, we use our SBPL to Prolog compiler to automati-
cally model the decompiled sandbox proﬁles as Prolog facts.
Third, we use Prolog rules and queries to automatically de-
tect sandbox misconﬁgurations that violate security require-
ments. Fourth, we use our attack testing application to eval-
uate the consequences of abusing these misconﬁgurations.
4.1 Decompiling Sandbox Proﬁles

As discussed in Section 2, sandbox proﬁles are written in
the SandBox Proﬁle Language (SBPL) and compiled into
binary blobs representing graphs used to rapidly query the
policies they deﬁne. Our tool, SandBlaster, extracts and
decompiles sandbox proﬁles from this compiled format back
into their original language.

707Note that SandBlaster expands upon the work of Blaza-
kis [21] and Esser
[31]. Distinctions between SandBlaster
and prior work are discussed in Section 7. A full, techni-
cal description of SandBlaster is available in our technical
report [27]. Here, we limit our description to the key novel
contributions of the tool.

We use a combination of our own scripts, existing tools [9,
5, 10, 8, 19], and information shared by reverse engineers [21,
31] to perform the initial steps of sandbox proﬁle extraction.
This process consists of decrypting iOS ﬁrmware, extracting
binary proﬁles, and processing ﬁlter types and ﬁlter values.
The novelty of SandBlaster is the conversion of the graph
structure of a compiled sandbox proﬁle into valid, hu-
man readable SBPL. This conversion requires reconstructing
graph connections into their respective metaﬁlter compo-
nents. Within the compiled sandbox proﬁle, each sandbox
operation (e.g., file-read-data) is represented by a directed
acyclic graph. This graph contains two terminal nodes for
the allow and deny decisions. Nonterminal nodes represent
ﬁlters (e.g., literal "/var/myFile"). Edges represent the
presence or absence of metaﬁlters (e.g., require-all). An
example graph is shown in step 1 of Figure 2.

Each nonterminal node has two edges: match and unmatch.
The match edge is followed when the ﬁlter is matched, and
the unmatch edge is followed if the ﬁlter is not matched. The
decision to allow or deny a system call is made based on
the terminal node reached after traversing the graph. In a
default deny proﬁle, a match edge connecting to allow and
an unmatch edge connecting to deny means the node has no
metaﬁlters.
In this case, if the ﬁlter the node represents
is matched, the operation is allowed. However, other con-
nections for the match and unmatch edges can represent var-
ious metaﬁlters. Table 1 shows all possible match and un-
match combinations and the logical equivalent of the relevant
metaﬁlters. Note that metaﬁlters can be nested, so the value
of other is evaluated recursively when it appears.
Graph to SBPL Demonstration: We use Table 1 to
explain each of the four steps in converting the graph in
Figure 2 into SBPL. Note that in these graphs, a solid line
represents a match edge, and a dotted line represents an un-
match edge. 1) Node B moves to deny on a match and allow
on an unmatch, so we can apply the require-not metaﬁlter
to B. Negation has the eﬀect of swapping a node’s match and
unmatch edges. 2) Node C moves to allow on a match and
a nonterminal on an unmatch, so we can apply require-any
to C and the nonterminal. In other words, if C’s ﬁlter does
not match, then we should attempt to match the other non-
terminal’s ﬁlter before denying the system call. 3) Node A
moves to a nonterminal on a match and deny on an unmatch, so
we can apply require-all to A and the nonterminal. In other
words, if A’s ﬁlter does not match, then we should deny the
system call and not attempt to match the other nontermi-
nal’s ﬁlter. 4) Finally the result of processing and merging
all nonterminal nodes is a collection of SBPL metaﬁlters ap-
plied to ﬁlters.
4.2 Modeling Sandbox Proﬁles in Prolog

SandScout uses Prolog to analyze iOS sandbox proﬁles.
Each sandbox proﬁle rule is converted into a collection of
Prolog facts deﬁned as follows:

d e c i s i o n ( operation ,[ l i s t O f F i l t e r s ]).

Recall that each sandbox proﬁle rule may contain many lev-

Table 1: Logic for Match/Unmatch Edges∗

Match
allow
deny
allow
non-terminal
non-terminal
deny

Unmatch
deny
allow
non-terminal
allow
deny
non-terminal

Logical Equivalent
self
¬self
self ∨ other
¬self ∨ other
self ∧ other
¬self ∧ other
(self ∧ other1)∨
(¬self ∧ other2)

non-terminal1
∗ Assuming a default deny sandbox proﬁle

non-terminal2

Figure 2: Converting Graph to SBPL.

els of nested metaﬁlters.
Instead of encoding the nested
metaﬁlter logic directly in Prolog, we ﬁrst expand the
boolean equation into disjunctive normal form (DNF). The
DNF form lends itself nicely to encoding the logic in Prolog.
In the above Prolog fact template, [listOfFilters] repre-
sents the conjunction of list elements (i.e., require-all), and
multiple Prolog facts represent the disjunction of those con-
junctions (i.e., require-any). Finally, negation is represented
by a Prolog functor applied to a ﬁlter.

The following is an example of Prolog facts from a deny
default proﬁle. Here, the process gains file-read* access
to /myFile if it has the A extension or does not have the B
extension.

allow ( file - readSTAR ,

[ literal ("/ myFile ") , e x t e n s i o n (" A ")]).

allow ( file - readSTAR ,

[ literal ("/ myFile ") , not ( e x t e n s i o n (" B "))]).

Converting SBPL into such Prolog facts is non-trivial for
three reasons. First, each ﬁlter may require a diﬀerent set of
ﬁlter values. Second, metaﬁlters can be nested indeﬁnitely
and the regex and require-entitlement ﬁlters have implied
metaﬁlters. Third, we must output our Prolog facts in dis-
junctive normal form. To address these challenges, we cre-
ated an SBPL to Prolog compiler using the ply [14] Python
library for Lex and Yacc.

Lex uses regular expressions to tokenize an input. This
allows us to match reserve words and distinguish between
types (e.g., strings, regular expressions, and booleans). A

ABCAllowDenyANot(B)CAllowDenyAAny(Not(B), C)AllowAll(A, Any(Not(B), C))AllowDenyDeny1)2)4)3)708TK_ALLOW
TK_DENY
TK_VERSION
TK_DEFAULT
TK_REQANY
TK_REQALL
TK_REQNOT
TK_REQENT
TK_DEBUGMODE

TK_LP
TK_RP
TK_VARIABLE
TK_STRING
TK_REGEXP
TK_BOOL

profile
version
default
dec
ruleList
rule

objList

require
requireAny
requireAll
requireEnt

object

= "allow"
= "deny"
= "version"
= "default"
= "require-any"
= "require-all"
= "require-not"
= "require-entitlement"
= "debug-mode"

= r’\(’
= r’\)’
= r’[^\"\n#\ \(\)][^\n\ \(\)]*’
= r’"[^"]*"’
= r’\#"[^"]*"’
= r’\#[tf]’

: version default ruleList
: TK_LP TK_VERSION TK_VARIABLE TK_RP
: TK_LP dec TK_DEFAULT TK_RP
: TK_ALLOW | TK_DENY
: rule ruleList |
: TK_LP dec TK_VARIABLE objList TK_RP
| TK_LP dec TK_VARIABLE TK_RP
: TK_LP object TK_RP objList
| TK_LP object TK_RP
| require objList | require
: requireAny | requireAll | requireEnt
: TK_LP TK_REQANY objList TK_RP
: TK_LP TK_REQALL objList TK_RP
: TK_LP TK_REQENT TK_STRING objList TK_RP
| TK_LP TK_REQENT TK_STRING TK_RP
: TK_VARIABLE TK_STRING
| TK_VARIABLE regexList
| TK_VARIABLE TK_VARIABLE
| TK_VARIABLE TK_VARIABLE TK_STRING
| TK_REQNOT TK_LP object TK_RP
| TK_REQNOT TK_LP simpleReqEnt TK_RP
| TK_VARIABLE TK_BOOL
| TK_DEBUGMODE
| TK_VARIABLE TK_LP TK_VARIABLE TK_STRING

regexList

simpleReqEnt

TK_VARIABLE TK_RPAREN

: TK_REGEXP regexList
| TK_REGEXP
: TK_REQENT TK_STRING

Figure 3: SBPL Context Free Grammar.

simpliﬁed list of SBPL token deﬁnitions is provided in
Figure 3. A more complete listing would include many
more reserve words. However, for the sake of our com-
piler, it was suﬃcient to match most reserve words with
the TK VARIABLE token.

Yacc uses a context free grammar that recursively pro-
cesses a tokenized input. The grammar we deﬁned for SBPL
is presented in Figure 3. Our implementation assumes a
correctly written SBPL proﬁle is taken as input. However,
the implementation could be expanded to detect additional
syntactic or semantic errors in SBPL proﬁles. Our current
grammar allows us to recognize and process metaﬁlters and
implied metaﬁlters. For example, when Yacc detects a re-
quireAll expression we appropriately process the results of
the objList expression inside it.

While Yacc distinguishes metaﬁlters, we must produce our
output in DNF. Our algorithm produces DNF by processing
a list of strings for each sandbox rule. For requireAll ex-
pressions, we append all elements of the processed objList to
each string in our list. For requireAny expressions, we create
a new string for each element of the processed objList. Each
new string is prepended with existing strings from our list
of strings on the list. When a require-not metaﬁlter is de-
tected, we apply the not Prolog functor to the object inside

the require-not. Our grammar asssumes that require-not
metaﬁlters will not contain other metaﬁlters, however, they
may contain implied metaﬁlters.
If the object inside the
require-not is a regex ﬁlter, we must process the implied
require-any metaﬁlter. To do this, we use De Morgan’s laws
and treat the result as a require-all metaﬁlter applied to
each negated regex ﬁlter.

We attempt to preserve as much similarity as possible
when converting SBPL to Prolog, but some characters could
not be preserved. For example, the file-write* operation
must be converted to file-writeSTAR in Prolog because Pro-
log does not recognize ‘*’ as part of a functor name.
4.3 Policy Analysis

SandScout analyzes sandbox proﬁles using Prolog queries.
In this subsection, we describe how to construct useful
queries. Doing so also requires deﬁning a collection of Pro-
log rules that model SBPL semantics (e.g., file-readSTAR is
one of the read operations). Finally, we describe the three
queries used for our vulnerability evaluation in Section 5.

Note that our current queries are limited to ﬁle access
operations on the container sandbox proﬁle. The complete
information for ﬁle access control policy is available within
the policy itself. Other policies (e.g., those that protect
inter-process services and driver services) require a deeper
understanding of the semantic operations within system pro-
cesses. We plan to build automated program analysis tools
to consider these semantics in future work. Furthermore,
since we found the ﬁle access control operations to contain
a signiﬁcant number of vulnerabilities, we limit this paper
to those operations. Finally, while SandScout can process
other sandbox proﬁles, we chose to focus on the container
proﬁle because it is shared by all third-party applications
and hence provides the greatest attack surface.

4.3.1 Modeling SBPL and iOS Semantics
To eﬀectively query the Prolog version of a sandbox pro-
ﬁle, we must ﬁrst encode additional semantics of SBPL and
iOS. We accomplish this using additional Prolog rules.

The ﬁrst type of Prolog rules we deﬁne address ar-
eas where ﬁle access ﬁlters overlap. For example, sub-
path("/var") and literal("/var/myFile") will both match
/var/myFile. We use this technique to limit one of our
queries to those ﬁles in /private/var/mobile/ which are more
likely to contain user data than other system ﬁles. Our abil-
ity to detect overlaps for regular expressions is limited. We
use the regex [12] library package for SWI-Prolog [17] to de-
termine if a literal ﬁle path satisﬁes a regular expression.
However determining if two regular expressions or a regular
expression and a subpath overlap is more complex. If Pro-
log is provided with a ﬁnite set of literal ﬁle paths to test,
this can be accomplished, but it is not part of our current
implementation.

The container sandbox proﬁle is used to conﬁne a variety
of applications that may be assigned diﬀerent capabilities.
Therefore, it is desirable to ask queries from diﬀerent envi-
ronment settings. For example, we can deﬁne Prolog rules
for describing the set of all capabilities, system capabilities,
or capabilities of third party applications. Note that entitle-
ments and extensions are capabilities a process may possess,
but some capabilities are only available to system applica-
tions.

We found that all sandbox rules providing access to third

709party directories required the sandbox.container extension.
Note that all third party applications have dedicated direc-
tories where they may read and write private ﬁles. We con-
sider ﬁles outside of these dedicated third party directories
to be system ﬁles.

Finally, we encountered a special ﬁlter called vnode-type.
This ﬁlter matches any ﬁle that has the type speciﬁed by
the vnode-type’s ﬁlter value (e.g., vnode-type(directory)).
Therefore, this ﬁlter has the potential to match ﬁles regard-
less of their ﬁle path, and it should be considered when mak-
ing queries.

To encode the semantics of the iOS environment, we pro-
vide several predeﬁned lists. Note that the ‘ ’ character in
prolog will match any value. Caps is the list of all capabilities
(i.e., [extension(_), entitlement(_)]). SysCaps is the list of
all capabilities reserved for system applications. Files is
the list of all ﬁlters that match ﬁle paths (i.e., [literal(_),
subpath(_), regex(_)]). SysPaths is the list of all ﬁlters that
match ﬁle paths to system ﬁles. Note that we consider any
ﬁle not inside a directory dedicated to a third party applica-
tion to be a system ﬁle (e.g., the Address Book or Preference
ﬁles). Reads is the list of all read operations. Writes is the
list of all write operations.
4.3.2 Example Policy Queries
We now describe the three policy queries that we use to
analyze the container sandbox proﬁle in Section 5. These
queries are stated as invariants that must hold over the pol-
icy. Any Prolog facts that match these queries are potential
violations. Note that the queries listed below are simpliﬁed
for readability.

1. To prevent damage to the system, full write access
to system ﬁle paths, is reserved for apps with system
capabilities.

? - allow ( file - writeSTAR , Filters ) ,

member (X , Filters ) , member (X , S y s P a t h s ) ,
i n t e r s e c t i o n ( Filters , SysCaps ,[]).

2. To preserve user privacy, read access of any kind to
system ﬁle paths in /private/var/mobile/ must require
capabilities.

? - allow ( Operation , Filters ) ,

member ( Operation , Reads ) ,
(( member (X , Filters ) , member (X , S y s P a t h s ) ,
o v e r l a p P a t h s (X ,

subpath ("/ private / var / mobile /")));

( i n t e r s e c t i o n ( Filters , Files ,[]) ,
member ( vnode - type ( _ ) , Filters ))) ,
i n t e r s e c t i o n ( Filters , Caps ,[]).

3. To prevent unauthorized collusion among third-party
applications, rules providing any combination of write
and read access to system ﬁles must require capabili-
ties.

? - allow ( Operation1 , F i l t e r s 1 ) ,

allow ( Operation2 , F i l t e r s 2 ) ,
member ( Operation1 , Reads ) ,
member ( Operation2 , Writes ) ,
member (X , F i l t e r s 1 ) , member (X , S y s P a t h s ) ,
member (Y , F i l t e r s 2 ) , member (Y , S y s P a t h s ) ,
o v e r l a p P a t h s (X , Y ) ,
i n t e r s e c t i o n ( Filters1 , Caps ,[]).
i n t e r s e c t i o n ( Filters2 , Caps ,[]).

Table 2: Attack Veriﬁcation Functions

Parameters

Test
requestAddressBook
ﬁleExists
readFileMetaData
readFileContent
createDirectory
deleteAndHold
createFileWithContent
appendFileWithContent
deleteFile
lsDirectory
consumeStorage
queryDatabase
createSymLink
createHardLink
moveFile
setPermissions

ﬁlePath
ﬁlePath
ﬁlePath
ﬁlePath
ﬁlePath
ﬁlePath
ﬁlePath
ﬁlePath
directory
directory, numFiles
ﬁlePath, query
source, destination
source, destination
source, destination
ﬁlePath, permissions

4.4 Attack Testing Application

The example queries in Section 4.3.2 may direct us to ﬁle
paths that are not interesting or exploitable (e.g., a readable
system ﬁle that does not contain sensitive information). To
assist in validating the analysis results and detecting sig-
niﬁcant attacks, we created an application to test several
types of ﬁle system attacks against iOS. The attack testing
application also made it easier to create proof of concept
attacks when reporting our ﬁndings to Apple. If a test fails
because access is denied or the ﬁle path provided is invalid,
an appropriate error message is provided.

Note that it is important that the attacks are tested on an
iOS device, as the Xcode iOS simulator fails to validate at-
tacks conﬁrmed on real devices. We speculate that the iOS
simulator has a simpliﬁed ﬁle system in which the ﬁles we
attacked did not exist or were not accessible. The iOS de-
vice running the attack application does not need to be jail-
broken. However, jailbroken devices can provide additional
feedback and insight for creating and evaluating attacks.

Table 2 lists the functions provided by our application.
The setPermissions function changes the Unix permissions
(i.e., read, write, or execute) for a ﬁle or directory. The
deleteAndHold function deletes a ﬁle and replaces that ﬁle
with a directory of the same name. We use this attack to
prevent iOS from using the aﬀected ﬁle path. The con-
sumeStorage function copies a given number of 10 megabyte
ﬁles to a speciﬁed directory. The requestAddressBook func-
tion requests access to the AddressBook from the user. If
the user grants access, the application gains the AddressBook
sandbox extension.

5. RESULTS

In this section we quantify and categorize the sandbox
misconﬁgurations detected by our Prolog queries. We also
present seven classes of attacks that abuse the sandbox mis-
conﬁgurations detected by SandScout.
5.1 Prolog Query Results

We ran each of the Prolog Queries mentioned in Sec-
tion 4.3.2 on a collection of Prolog facts representing the
container proﬁle for iOS 9.0.2. The results of these queries

710Table 3: Query Results for iOS 9.0.2

Metrics
Matched Facts
False Negatives
Exploitable Facts
Exploitable Paths

Query 1 Query 2 Query 3
10
0
10
9

39
1
3
2

20
1
8
4

were then evaluated using our attack testing application on
a jailbroken iPhone 5s running iOS 9.0.2. For each Prolog
fact matched by a query, we conﬁrm that the ﬁle access op-
eration indicated by the fact was actually allowed on iOS
9.0.2. We also look for unique and signiﬁcant attacks that
are possible because of these facts. Table 3 presents the
results of our evaluation.

In total, SandScout produced 1520 Prolog facts to repre-
sent the container proﬁle from iOS 9.0.2. Prolog queries can
provide a signiﬁcant reduction in the search space of rules
an analyst must evaluate when searching for ﬂaws. For ex-
ample, Query 1 only produces 10 matching facts.

The False Negatives row represents facts that suggested
more restrictions than we encountered in testing. To the
best of our knowledge this occurred twice during our tests.
First, we encountered a regular expression suggesting that
we could write data to in a speciﬁc directory as long as the
ﬁle names matched the expression. During testing on our
jailbroken iOS 9.0.2 device, we found that we could cre-
ate and write data to any ﬁle in the directory. Second,
we were able to read the contents of the /private/var/-
mobile/Library/Preferences directory when we should have
only been allowed to read its metadata. Our non-jailbroken
iOS 9.3.1 device was not able to perform these unusual ac-
tions. Therefore, we speculate that these false negatives are
due to imperfections in SandBlaster or artifacts of the jail-
break process.

Some ﬁle paths could not be used for attacks for reasons
other than access control. Some allowed ﬁlepaths cannot be
used to read user data because there is no ﬁle at the path
we are allowed to read. If a third-party application has read
access to a ﬁlepath (e.g., /var/userSecrets.txt), but such a
ﬁle does not exist, then Apple may not consider the access to
be dangerous. Many of the system ﬁles our test application
was allowed to read did not contain interesting information.
Finally, ﬁles in /dev do not function as normal ﬁles, and we
do not consider them in our tests for Query 3. For example,
having read and write access to /dev/null does not mean it
can be used for collusion. Further investigation of attacks
against /dev ﬁles is left as future work.

The Exploitable Facts row shows the number of facts that
led us to unique, signiﬁcant attacks. The Exploitable Paths
row represents the number of unique ﬁle paths we were able
to attack. For example, there may be multiple exploitable
facts indicating access to the same ﬁle path, but we would
consider all of these to be 1 exploitable ﬁle path. Matches
to our queries that are not classiﬁed as Exploitable Facts
should not be ignored. For example, ﬁles that did not exist
in the ﬁle system during our testing might be created under
conditions we are not aware of. It is also possible that some
ﬁles are only present on devices with unique functionality,
such as AppleTV devices or an iPad Pro.
5.2 Veriﬁed Attacks

We have discovered seven classes of attacks that abuse
misconﬁgurations in the container sandbox proﬁle’s ﬁle ac-

cess rules. Each of these attack classes has been disclosed to
Apple and has been tested successfully on a non-jailbroken
iPod Touch 6 running iOS 9.3.1 (latest version at the time
of experiments).

Many of the vulnerabilities discovered by SandScout can
be addressed by modifying the sandbox proﬁle. Apple has
included ﬁxes for most of the vulnerabilities in the upcoming
release of iOS 10, which we did not yet have the opportu-
nity to verify at the time of writing. However, some of the
vulnerabilities required architectural changes, which are ac-
tively being addressed. To protect against these attacks,
Apple plans to monitor applications in the App Store for
corresponding behaviors.
5.2.1 Bypassing Privacy Settings
The following is a Prolog fact that matches Query 1 be-
cause the AddressBook extension is not a system capability.

allow ( file - writeSTAR ,

[ subpath ("/ Library / A d d r e s s B o o k /") ,

e x t e n s i o n (" A d d r e s s B o o k ")]).

(e.g.,

Full write access allows for the creation of a hard link
to the AddressBook database, while an app has access to
it. The hard link allows the application to maintain ac-
cess to the AddressBook even after the user revokes access
through Privacy Settings. Hard link based access is not
limited to the app’s home directory. Malware can also
place the hard link in a directory accessible to all third-
party applications
/private/var/mobile/Library/-
Caches/com.apple.keyboards/). We found that /private/-
var/mobile/Library/Caches/com.apple.keyboards/ could be
used for collusion with Query 3. This allows colluding ap-
plications to access the AddressBook regardless of the user’s
Privacy Settings. We disclosed this attack to Apple and
they partially resolved it through CVE-2015-7001 by adding
a new sandbox operation, ﬁle-link, which governs the ability
to create hard links. By using SandBlaster, we detected that
the following rule was added to the container proﬁle in iOS
9.1.

( allow f i l e - l i n k

( r e q u i r e - n o t

( subpath

" / L i b r a r y / A d d r e s s B o o k " ) ) )

This sandbox rule prevents us from creating hard links to
ﬁles in the AddressBook’s directory. However, we have identi-
ﬁed two methods to bypass this rule and perform the attack
despite Apple’s patch. First, we can simply move the Ad-
dressBook directory to a new location, make our hard links,
and move the AddressBook directory back to its original loca-
tion. This technique succeeds because we have file-write*
access to the AddressBook subpath, and moving a ﬁle does not
change the ﬁle’s inode. Second, our tests suggest that mali-
cious hard links to the AddressBook are not removed when up-
dating to newer versions of iOS. Therefore, devices attacked
before iOS 9 would still be compromised after upgrading to
later versions, because the new sandbox rule only prevents
the creation of new hard links to the protected ﬁle paths.

Due to the complexities of this attack, a policy-based so-
lution was not suﬃcient. Apple indicated that they plan to
move AddressBook access out of process to address the attack.
5.2.2 Privacy Leaks
The container sandbox proﬁle allows third-party applica-
tions to read several system ﬁles that contain user data.

711Some of these ﬁles contain sensitive data, and we consider
the leakage of this data to be a breach of user privacy.
The following are a subset of the Prolog facts that match
Query 2.

allow ( file - readSTAR ,

[ subpath ("/ Media / i T u n e s _ C o n t r o l / iTunes /")]).

allow ( file - readSTAR ,

[ subpath ("/ Library / Caches / G e o S e r v i c e s /")]).

allow ( file - read - metadata ,

[ vnode - type ( d i r e c t o r y )]).

iTunes Privacy Leaks: The /private/var/mobile/Medi-
a/iTunes_Control/iTunes directory is readable by any third-
party application. Within this directory are at least three
ﬁles containing private data related to iTunes and backing
up the iOS device. First, there is a database that contains
titles and metadata for iTunes purchases including books,
movies, music, podcasts, etc. Second, there is a ﬁle contain-
ing the user’s name and the names of computers the device
has backed up to. Third, there is a property list ﬁle that lists
applications the user has installed via iTunes. The informa-
tion leaked in this directory is valuable for targeted adver-
tising and device ﬁngerprinting. Even music taste alone has
been found to reveal signiﬁcant information about a user[45].
To address this attack, an additional privacy setting was
added to iOS. The new privacy setting regulates access to
user media.
Maps Privacy Leaks: The /private/var/mobile/Library/-
Caches/GeoServices directory is readable by any third-party
application. Within this directory are databases that con-
tain the locations a user has searched for in the Apple Maps
application. This application is the default mapping app
for iOS devices. Third-party applications can read these
databases and extract the locations a user has searched for
without obtaining permission to access location data. Third-
party applications can abuse this information to create tar-
getted ads or to blackmail users by threatening to reveal
the history of their location searches. To address this at-
tack, iOS 10 will move the geo-services cache to /Library/-
Caches/geod and make the directory only accessible by the
geod daemon.
Metadata Privacy Leaks: The container proﬁle makes
metadata of all directories and symbolic links on the iOS
ﬁle system readable by third-party applications. The size
and timestamps of various directories allows third-party ap-
plications to infer information about the user. The following
three examples are only a few of the inferences that can be
made with the metadata available: 1) time of each photo
taken; 2) the last time an audio recording was created; 3) the
last time a game was played. We also ﬁnd that drafts of
SMS messages are sometimes stored in directories named
after the phone number of the recipient of the message.
For example, a draft of a message to the phone number,
15551234567, would be stored in the directory in /var/mo-
bile/Library/SMS/Drafts/+15551234567/. A third-party ap-
plication can query the existence of directories named after
certain numbers to determine if the user is sending SMS
messages to certain people. Note that this last case is in-
teresting, because the metadata Prolog fact brought it to
our attention, but is not technically the cause of the ﬂaw.
The ability to read the metadata of the directory enhances
the attack by also leaking the times that the user began or
modiﬁed the SMS draft. However, we are not aware of SBPL

ﬁlters that can limit the ability to query for the existence
of ﬁles. Therefore, Apple may need to extend SBPL to ad-
dress the SMS privacy leak vulnerability. As a short-term
ﬁx, Apple plans to prevent third-party apps from using stat
on directories in mobile/Library/SMS.
Unauthorized Collusion: iOS provides oﬃcial inter-app
communication channels, but these require special capabil-
ities. However, Query 3 allowed us to identify 4 unique
ﬁle paths that can be abused for unauthorized commu-
nication between applications without such capabilities.
/private/var/mobile/Media/com.apple.itunes.lock_sync and
/private/var/mobile/Library/Keyboard/LocalDictionary are
ﬁles that third-party apps can read and write. /private/-
var/mobile/Library/Caches/com.apple.keyboards/ is a direc-
tory where third-party apps have full read and write ac-
cess. /private/var/mobile/Library/DeviceRegistry/ is a di-
rectory where third-party apps can create any directories
with names consisting of numbers and capital letters. To
send a message, an app could create such directories, and
to receive a message, another app could check for the ex-
istence of or read the metadata of those directories. To
address these attacks,
iOS 10 will remove write access
to com.apple.itunes.lock_sync, LocalDictionary, and De-
viceRegistry. Apple indicated an ongoing eﬀort to remove
the com.apple.keyboards directory from iOS.

System Damage

5.2.3
We have identiﬁed two types of write-based attacks that
cause system damage because of the misconﬁgurations de-
tected by Query 1. Each of these attacks can be used for
ransomware, because the malicious app can undo the dam-
age after the attacker is paid. These attacks can be undone if
the user performs a factory reset of the device which deletes
all user data. Restoring from a backup image of the device
can also undo the damage, but many users may not have
backups. Both solutions are troublesome for a user and may
cause the loss of valuable information. To address the be-
low described attacks, iOS 10 will remove write access to
respective ﬁles. However, some cases such as the Address-
Book directory require architectural changes, as discussed in
Section 5.2.1.
Storage Consumption: Third-party apps can consume
all available storage space on the device by creating ﬁles
in system directories or appending large amounts of data
to system ﬁles. This space is not recovered by uninstalling
the app, nor does it appear in the Storage Manager as be-
ing used by the app. We found that copying a large ﬁle is
the most eﬃcient and stealthy method of consuming space.
On an iPod Touch 6th generation, we can consume storage
space at a rate of approximately 100 megabytes per sec-
ond with negligible use of the CPU or memory. Attacking
the AddressBook directory in this way will cause the Storage
Manager to blame the Contacts application for consuming a
large amount of storage space. However, the Contacts appli-
cation is a system application, and it cannot be uninstalled.
Blocking Access To System Files: A third-party app
can delete system ﬁles if it has write access to, and replace
these ﬁles with directories of the same name. This prevents
iOS from repairing the ﬁle, because the directory is in the
way. The directory block is eﬀective because iOS often cre-
ates ﬁles with randomized ﬁle name extensions and then
renames them to a non-randomized ﬁle name. If the non-

712randomized ﬁle name is being held by a maliciously placed
directory, the renaming operation will fail. We speculate
that this technique helps evade link based attacks by replac-
ing any links via the renaming operation instead of directly
writing data to a predictable ﬁle path. Consider the follow-
ing Prolog fact from the container proﬁle of iOS 9.0.2.

allow ( file - writeSTAR ,

[ regex ("^/ E m o j i P r e f e r e n c e s [.] plist "/ i )]).

Note that the regular expression does not end in a $ sym-
bol, which means it only needs to match the beginning of
a string. This allows iOS to create ﬁles with randomized
names such as EmojiPreferences.plist.sfjk32a and rename
them to EmojiPreferences.plist. Deleting the AddressBook
database and replacing it with a directory causes observable
damage to the system. The four eﬀects of the attack are:
1) The Contacts app will show an empty list instead of con-
tacts. 2) Adding new contacts will fail. 3) The Contacts
app will not appear in the storage manager. 4) Backing up
the device with iTunes will fail.

Third-party applications can delete or move system direc-
tories they have write access to. They can also change the
Unix permissions of these directories. These actions prevent
system applications from being able to access the system
ﬁles in those directories.

6. LIMITATIONS

In this section we discuss the limitations of each compo-
nent of SandScout. We also propose future work to address
these limitations.
Sandbox Decompiler: SandBlaster is a reverse engineer-
ing tool, and the sandbox proﬁles it produces have not been
proven to be semantically equivalent to the originals. How-
ever, we ﬁnd that it provides signiﬁcant insight, and it was
suﬃcient to lead us to numerous vulnerabilities.
If Apple
adopts the SandScout framework, this will not be a concern
for them because they have the original proﬁles in SBPL
format.

Another limitation of SandBlaster is its dependence on
leaked ﬁrmware keys for decrypting iOS ﬁrmware. Firmware
keys for an iOS version are usually published [6] by reverse
engineers a few weeks after the ﬁrmware version is released.
Note that ﬁrmware keys are more readily available than jail-
breaks. At the time of writing, the latest public jailbreak
is for iOS 9.1, but the latest released ﬁrmware keys are for
iOS 9.3.1.
Policy Modeling: Our SBPL to Prolog compiler makes
four assumptions. First,
it assumes the SBPL proﬁle is
written correctly. With additional engineering, our compiler
could detect errors in SBPL, but we saw this as unnecessary
for SandScout. Second, we assume the version information
will appear on the ﬁrst line, and the default decision on the
second line. Third, we assume that the ﬁlters and metaﬁl-
ters we have encountered already are the only ones we need
to compile. A new ﬁlter or metaﬁlter may not match the
expressions in our grammar, and the implementation would
need to be updated. Fourth, we assume that require-not
metaﬁlters will not contain other metaﬁlters. SandBlaster
helps us control for this, and we can remove this assumption
through additional engineering.
Policy Analysis: Our Prolog queries are limited to ﬁle ac-
cess. Reverse engineering the other operations controlled by

the sandbox is left as future work. We do not claim that
our queries have comprehensively detected all ﬂaws in ﬁle
access. However, we believe that we have identiﬁed a suﬃ-
cient number of vulnerabilities to demonstrate SandScout’s
utility.

Our queries do not consider overlaps between regular ex-
pressions and regular expressions or regular expressions and
subpaths. We speculate that this can be accomplish by pro-
viding Prolog with a ﬁnite list of literal ﬁle paths. Prolog
could then determine if any of the ﬁle paths satisfy both reg-
ular expressions or the regular expression and the subpath.
Attack Veriﬁcation: We used a jailbroken iPhone 5s run-
ning iOS 9.0.2 for our attack veriﬁcation. We chose to use a
jailbroken device because it gave us more control and aware-
ness of the ﬁle system. We chose to analyze the container
proﬁles from iOS 9.0.2 because this was the latest version of
iOS that we had running on a jailbroken device. However, it
is possible that artifacts of the jailbreak aﬀected our tests.
In two cases, we encountered false negatives and were able to
perform actions that our decompiled proﬁle suggested would
be denied. To address this concern we conﬁrmed that each of
our 7 attack classes worked on a non-jailbroken iPod Touch
6 running iOS 9.3.1.

Finally, it is possible that we may have missed attack op-
portunities during attack veriﬁcation. For example, some of
the ﬁles we had read access to seemed to contain obfuscated
data. With more analysis these may be found to contain
sensitive information.

7. RELATED WORK

The initial

iOS security research in academic venues
focused on privacy threats in third-party applications.
PiOS [29] uses static taint analysis to detect privacy leaks.
Han et al.
[35] compare iOS and Android applications,
ﬁnding iOS applications access signiﬁcantly more privacy-
sensitive APIs than Android applications.

More recent iOS application security research has fo-
cused on the potential for malware. Wang et al. [48] pro-
posed Jekyll attacks, which consider a malicious developer
that hides vulnerabilities within an application. The work
demonstrates a fundamental limitation in Apple’s vetting
process. The concepts behind Jekyll apps were indepen-
dently discovered by Han et al. [33] and further enhanced
by Bucicoiu et al. [22]. Jekyll apps leverage the ability to
call APIs in private frameworks. Wang et al. [47] created
proof of concept attacks for infecting iOS devices with ma-
licious applications via exploiting the iTunes synching pro-
cess.
iRiS [28] uses a combination of static and dynamic
analysis to detect indirect invocation of APIs in private
frameworks and has detected an ad library that abuses pri-
vate frameworks. Xing et al. [52] demonstrate a new at-
tack vector for iOS malware by exploiting cross-application
interfaces. Finally, Kurtz et al. [40] studied ways for iOS
applications to ﬁngerprint devices. In the process of their
analysis, they identiﬁed ﬂaws in the iOS sandbox; however,
they give no detail on how the ﬂaws were discovered.

There have been several eﬀorts to improve iOS security.
Davi et al. [26] propose MoCFI to add control-ﬂow integrity
to iOS applications. If applied, MoCFI would signiﬁcantly
mitigate Jekyll apps. MoCFI was extended by Werthmann
et al. [50] to enforce ﬁne-grained access control rules. Their
PSiOS tool instruments each function call to validate the

713function to be called along with the provided parameters.
Unfortunately, PSiOS and MoCFI cause unacceptably high
performance overhead and require jailbreaks or signiﬁcant
changes to iOS for them to be implemented. To address
these issues, XiOS [22] deploys static binary instrumentation
to insert a reference monitor into existing iOS applications.
This reference monitor aims at hiding crucial runtime ad-
dresses populated by the dynamic loader. While XiOS pre-
vents the exploits used in existing Jekyll-related attacks, the
reference monitor resides in the same address space as the
malicious application. Therefore, an adversary can poten-
tially compromise the reference monitor or launch runtime
attacks to bypass the XiOS policy checks.

Much of the public knowledge about the Apple’s sandbox-
ing mechanism is due to the work of non-academic reverse
engineers. Blazakis was ﬁrst in describing the internals of
the Apple sandbox [21], and has released a set of tools to
aid sandboxing analysis. However, signiﬁcant changes to the
iOS sandbox in iOS 7 prevent his tool from functioning prop-
erly on iOS 7 or later. The container sandboxing proﬁle for
iOS 4 has been largely studied by Zovi [25]. He also shared
a simpliﬁed representation of the iOS 4 container proﬁle.
Iozzo [38] gave a presentation on Apple’s sandbox in which
he suggests potentially vulnerable areas where researchers
might ﬁnd attacks. His slides include graph visualizations
of some sandbox proﬁles for OS X. Kydyraliev [41] and the
iOS Hacker’s Handbook [42] describe the internal mecha-
nisms of Apple’s dynamic capabilities called sandbox exten-
sions. An unoﬃcial documentation of the Apple sandbox
language has been given in a public whitepaper [32]. How-
ever, this guide is signiﬁcantly outdated and now it only
covers a minority of the sandboxing operations available for
iOS. Esser [31] updated Blazakis’s tools to create a sand-
box extractor and pseudo-decompiler which converts builtin
iOS sandbox proﬁles into an intermediate graph representa-
tion. Our own sandbox decompiler uses functionality from
the tools of Blazakis and Esser, but ours is the ﬁrst tool to
fully decompile sandboxes for iOS 7, 8, and 9.

We are the ﬁrst to systematically analyze sandbox pro-
ﬁles for iOS. Watson [49] provided a brief overview of iOS
access control, but his work did not analyze speciﬁc poli-
cies. Policy analysis itself is a broad area of research. Here,
we highlight several works using logic-based programming
in Prolog. PALMS [36] models SELinux policy in Prolog to
study information ﬂow properties of its MLS enforcement.
Similarly, PIDSI [43] uses Prolog to verify ﬂow properties
of SELinux policy governing trusted programs. Note that
the iOS SBPL and SELinux policy languages are semanti-
cally diﬀerent. SBPL assumes one subject, whereas SELinux
includes many subjects (domains). Therefore, many proper-
ties modeled in Prolog (e.g., Trusted Computing Base iden-
tiﬁcation) for SELinux do not directly apply to SBPL. Chen
et al. [24] used Prolog to model SELinux and AppArmor
policies in order to evaluate the protection quality of the
policies with respect to various attack scenarios.
In con-
trast, we seek to automatically identify misconﬁgurations
that violate the security requirements of stakeholders. An
early version of Kirin [30] uses Prolog to deﬁne policy invari-
ants over Android permissions assigned to third-party appli-
cations to detect dangerous functionality. Our SandScout
queries are conceptually similar, but SBPL is signiﬁcantly
more complex than Android’s permission model, including
system calls and regular expressions.

8. CONCLUSIONS

This paper presented the ﬁrst systematic study of the iOS
container sandbox proﬁle, which conﬁnes third-party appli-
cations. Our SandScout framework automatically extracts
and decompiles binary sandbox proﬁles into human read-
able SBPL. SandScout then translates the SBPL policies
into Prolog facts. By modeling sandbox policy as a logic-
based program, we are able to construct queries to test secu-
rity properties. We construct three ﬁle-based queries for the
container sandbox proﬁle and use them to analyze iOS 9.0.2.
We then use an assisted veriﬁcation tool to further reﬁne the
set of potential policy vulnerabilities. In studying the query
results, we identify seven classes of exploitable vulnerabili-
ties. Each of these vulnerabilities was also conﬁrmed on a
non-jailbroken iOS 9.3.1 device.

Our analysis of the iOS container sandbox proﬁle is only
the ﬁrst step in systematically evaluating the access control
in iOS. First, our Prolog queries are limited to ﬁle-based
properties. The container sandbox proﬁle also governs other
security relevant system calls such as Mach IPC. Evaluat-
ing this policy requires additional semantics from the iOS
environment, which we plan to incorporate in future work.
Furthermore, we plan to extend our analysis to those aspects
of iOS access control outside of the sandbox.

9. ACKNOWLEDGMENTS

We thank Adwait Nadkarni, Micah Bushouse, Ben
Andow, Isaac Polinsky, Akash Verma, and the Wolfpack Se-
curity and Privacy Research (WSPR) lab as a whole for
their helpful comments. We also thank Dino Dai Zovi for
his advice on reverse engineering iOS sandbox proﬁles.

This work was supported in part by the Army Research
Oﬃce (ARO) grants W911NF-16-1-0299 and W911NF-
14-1-0537, the National Science Foundation (NSF) CA-
REER grant CNS-1253346, the German Science Foundation
(project S2, CRC 1119 CROSSING), the European Union’s
Seventh Framework Programme (643964, SUPERCLOUD),
and the German Federal Ministry of Education and Research
within CRISP. Any opinions, ﬁndings, conclusions, or rec-
ommendations expressed in this material are those of the
authors and do not necessarily reﬂect the views of the fund-
ing agencies.

10. REFERENCES
[1] AceDeceiver: First iOS Trojan Exploiting Apple DRM

Design Flaws to Infect Any iOS Device.
http://researchcenter.paloaltonetworks.com/2016/03/
acedeceiver-ﬁrst-ios-trojan-exploiting-apple-drm-
design-ﬂaws-to-infect-any-ios-device/. Accessed:
2016-05-05.

[2] Antid0te 2.0 - aslr in ios. http:

//conference.hackinthebox.org/hitbsecconf2011ams/
materials/D1T1%20-%20Stefan%20Esser%20-
%20Antid0te%202.0%20-%20ASLR%20in%20iOS.pdf.
Accessed: 2016-02-15.

[3] The apple sandbox. https:

//media.blackhat.com/bh-dc-11/Blazakis/BlackHat
DC 2011 Blazakis Apple%20Sandbox-Slides.pdf.
Accessed: 2016-02-15.

[4] Download.

https://developer.apple.com//ios/download/.
Accessed: 2016-04-20.

714[5] dsc extractor.cpp.

https://opensource.apple.com/source/dyld/dyld-195.
6/launch-cache/dsc extractor.cpp. Accessed:
2016-05-19.

[6] Firmware Keys.

https://www.theiphonewiki.com/wiki/Firmware Keys.
Accessed: 2016-04-19.

[7] iTunes Preview.

https://itunes.apple.com/us/genre/ios/id36?mt=8.
Accessed: 2016-05-04.

[8] Joker. http://newosxbook.com/tools/joker.html.

Accessed: 2016-05-19.
[9] Lekensteyn/dmg2img.

https://github.com/Lekensteyn/dmg2img. Accessed:
2016-05-19.

[10] lzssdec.cpp. http://nah6.com/˜itsme/cvs-

xdadevtools/iphone/tools/lzssdec.cpp. Accessed:
2016-05-19.

[11] Multiple iOS apps found to be harvesting Snapchat

user credentials. http://9to5mac.com/2016/03/08/ios-
apps-snapchat-harvest-credentials/. Accessed:
2016-05-05.

[12] Package ”regex”.

http://www.swi-prolog.org/pack/list?p=regex.
Accessed: 2016-05-19.

[13] Pirated App Store client for iOS found on Apple’s App
Store. https://www.helpnetsecurity.com/2016/02/22/
pirated-app-store-client-ios-found-apples-app-store/.
Accessed: 2016-05-05.

[14] PLY (Python Lex-Yacc).

the protection quality of security enhanced operating
systems. In NDSS, pages 11–16, 2009.

[25] D. A. Dai Zovi. Apple ios 4 security evaluation. Black

Hat USA, 2011.

[26] L. Davi, A. Dmitrienko, M. Egele, T. Fischer, T. Holz,
R. Hund, S. N¨urnberger, and A.-R. Sadeghi. Mocﬁ: A
framework to mitigate control-ﬂow attacks on
smartphones. In NDSS, 2012.

[27] R. Deaconescu, L. Deshotels, M. Bucicoiu, W. Enck,
L. Davi, and A.-R. Sadeghi. Sandblaster: Reversing
the apple sandbox. Technical Report
arXiv:1608.04303, Aug 2016.

[28] Z. Deng, B. Saltaformaggio, X. Zhang, and D. Xu.

iris: Vetting private api abuse in ios applications. In
Proceedings of the 22nd ACM SIGSAC Conference on
Computer and Communications Security, pages 44–56.
ACM, 2015.

[29] M. Egele, C. Kruegel, E. Kirda, and G. Vigna. Pios:
Detecting privacy leaks in ios applications. In NDSS,
2011.

[30] W. Enck, M. Ongtang, and P. McDaniel. Mitigating

Android Software Misuse Before It Happens. Technical
Report NAS-TR-0094-2008, Network and Security
Research Center, Department of Computer Science
and Engineering, Pennsylvania State University,
University Park, PA, USA, Sep 2008.

[31] S. Esser. ios8 containers, sandboxes and entitlements.
http://www.slideshare.net/i0n1c/ruxcon-2014-stefan-
esser-ios8-containers-sandboxes-and-entitlements.
Accessed: 2015-11-6.

http://www.dabeaz.com/ply/. Accessed: 2016-05-17.

[32] fG! Apple’s sandbox guide v 1.0.

[15] Smart phones overtake client PCs in 2011.

http://www.canalys.com/newsroom/smart-phones-
overtake-client-pcs-2011. Accessed: 2016-05-18.

[16] Smartphone OS Market Share, 2015 Q2. http://www.

idc.com/prodserv/smartphone-os-market-share.jsp.
Accessed: 2016-05-18.

[17] SWI Prolog. http://www.swi-prolog.org/. Accessed:

2016-05-19.

[18] Trustedbsd mandatory access control (mac)

framework. http://www.trustedbsd.org/mac.html.
Accessed: 2015-11-06.

[19] VFDecrypt.

https://www.theiphonewiki.com/wiki/VFDecrypt.
Accessed: 2016-05-19.

[20] M. Alam, J.-P. Seifert, Q. Li, and X. Zhang. Usage
control platformization via trustworthy selinux. In
Proceedings of the 2008 ACM symposium on
Information, computer and communications security,
pages 245–248. ACM, 2008.

[21] D. Blazakis. The apple sandbox. Arlington, VA,

January, 2011.

[22] M. Bucicoiu, L. Davi, R. Deaconescu, and A.-R.

Sadeghi. Xios: Extended application sandboxing on
ios. In ACM Symposium on Information, Computer
and Communications Security, ASIACCS ’15, 2015.

[23] S. Byford. Apple removes malware-infected App Store
apps after major security breach. The Verge, Sept. 15.
http://www.theverge.com/2015/9/20/9362585/
xcodeghost-malware-app-store-security.

[24] H. Chen, N. Li, and Z. Mao. Analyzing and comparing

http://reverse.put.as/wp-content/uploads/2011/09/
Apple-Sandbox-Guide-v1.0.pdf. Accessed: 2015-02-04.

[33] J. Han, S. M. Kywe, Q. Yan, F. Bao, R. Deng,

D. Gao, Y. Li, and J. Zhou. Launching generic attacks
on ios with approved third-party applications. In
Applied Cryptography and Network Security, pages
272–289. Springer, 2013.

[34] J. Han, S. M. Kywe, Q. Yan, F. Bao, R. Deng, D. Gao,
Y. Li, and J. Zhou. Launching generic attacks on iOS
with approved third-party applications. In Applied
Cryptography and Network Security, ACNS ’13, 2013.

[35] J. Han, Q. Yan, D. Gao, J. Zhou, and R. Deng.

Comparing mobile privacy protection through
cross-platform applications. 2013.

[36] B. Hicks, S. Rueda, L. S. Clair, T. Jaeger, and

P. McDaniel. A Logical Speciﬁcation and Analysis for
SELinux MLS Policy. ACM Transaction on
Information and System Security, 13(3), 2010.
[37] B. Hicks, S. Rueda, L. St Clair, T. Jaeger, and

P. McDaniel. A logical speciﬁcation and analysis for
selinux mls policy. ACM Transactions on Information
and System Security (TISSEC), 13(3):26, 2010.

[38] V. Iozzo. A sandbox odyssey. https://prezi.com/
lxljhvzem6js/a-sandbox-odyssey-inﬁltrate-2012/.
Accessed: 2015-11-7.

[39] T. Jaeger, R. Sailer, and X. Zhang. Analyzing

integrity protection in the selinux example policy. In
Proceedings of the 12th conference on USENIX
Security Symposium-Volume 12, pages 5–5. USENIX
Association, 2003.

715[40] A. Kurtz, H. Gascon, T. Becker, K. Rieck, and
F. Freiling. Fingerprinting mobile devices using
personalized conﬁgurations. Proceedings on Privacy
Enhancing Technologies, 2016(1):4–19, 2016.

[41] M. Kydyraliev. Mining mach services within os x

sandbox. http://2013.zeronights.org/includes/docs/
Meder Kydyraliev - Mining Mach Services within
OS X Sandbox.pdf. Accessed: 2015-11-6.

[42] C. Miller, D. Blazakis, D. DaiZovi, S. Esser, V. Iozzo,

and R.-P. Weinmann. iOS Hacker’s Handbook. John
Wiley & Sons, 2012.

[43] S. Rueda, D. H. King, and T. Jaeger. Verifying

Compliance of Trusted Programs. In Proceedings of
the USENIX Security Symposium, 2008.
[44] A. Sasturkar, P. Yang, S. D. Stoller, and

C. Ramakrishnan. Policy analysis for administrative
role based access control. In Computer Security
Foundations Workshop, 2006. 19th IEEE, pages
13–pp. IEEE, 2006.

[45] A. Voida, R. E. Grinter, N. Ducheneaut, W. K.

Edwards, and M. W. Newman. Listening in: practices
surrounding itunes music sharing. In Proceedings of
the SIGCHI conference on Human factors in
computing systems, pages 191–200. ACM, 2005.

[46] R. Wang, W. Enck, D. Reeves, X. Zhang, P. Ning,

D. Xu, W. Zhou, and A. M. Azab. Easeandroid:
Automatic policy analysis and reﬁnement for security
enhanced android via large-scale semi-supervised
learning. In 24th USENIX Security Symposium
(USENIX Security 15), pages 351–366, 2015.

[47] T. Wang, Y. Jang, Y. Chen, S. Chung, B. Lau, and
W. Lee. On the feasibility of large-scale infections of
ios devices. In 23rd USENIX Security Symposium
(USENIX Security 14), pages 79–93, 2014.

[48] T. Wang, K. Lu, L. Lu, S. Chung, and W. Lee. Jekyll

on ios: When benign apps become evil. In Usenix
Security, volume 13, 2013.

[49] R. N. M. Watson. TrustedBSD: Adding Trusted

Operating System Features to FreeBSD. In
Proceedings of the USENIX Annual Technical
Conference, FREENIX Track, 2001.

[50] T. Werthmann, R. Hund, L. Davi, A.-R. Sadeghi, and

T. Holz. Psios: bring your own privacy & security to
ios devices. In Proceedings of the 8th ACM SIGSAC
symposium on Information, computer and
communications security, pages 13–24. ACM, 2013.

[51] C. Xiao. Yispecter.

http://researchcenter.paloaltonetworks.com/2015/10/
yispecter-ﬁrst-ios-malware-attacks-non-jailbroken-ios-
devices-by-abusing-private-apis/. Accessed:
2015-10-21.

[52] L. Xing, X. Bai, T. Li, X. Wang, K. Chen, X. Liao,

S.-M. Hu, and X. Han. Cracking app isolation on
apple: Unauthorized cross-app resource access on mac
os. In Proceedings of the 22nd ACM SIGSAC
Conference on Computer and Communications
Security, pages 31–43. ACM, 2015.

[53] G. Zanin and L. V. Mancini. Towards a formal model
for security policies speciﬁcation and validation in the
selinux system. In Proceedings of the ninth ACM
symposium on Access control models and technologies,
pages 136–145. ACM, 2004.

716