Efﬁciently Veriﬁable Computation on Encrypted Data

Dario Fiore

IMDEA Software Institute

Madrid, Spain

dario.ﬁore@imdea.org

rosario@cs.ccny.cuny.edu

pastro@cs.ccny.cuny.edu

Rosario Gennaro

CUNY

New York, USA

Valerio Pastro

CUNY

New York, USA

ABSTRACT
We study the task of veriﬁable delegation of computation on
encrypted data. We improve previous deﬁnitions in order to
tolerate adversaries that learn whether or not clients accept
the result of a delegated computation. In this strong model,
we construct a scheme for arbitrary computations and highly
eﬃcient schemes for delegation of various classes of func-
tions, such as linear combinations, high-degree univariate
polynomials, and multivariate quadratic polynomials. No-
tably, the latter class includes many useful statistics. Using
our solution, a client can store a large encrypted dataset on a
server, query statistics over this data, and receive encrypted
results that can be eﬃciently veriﬁed and decrypted.

As a key contribution for the eﬃciency of our schemes,
we develop a novel homomorphic hashing technique that al-
lows us to eﬃciently authenticate computations, at the same
cost as if the data were in the clear, avoiding a 104 over-
head which would occur with a naive approach. We support
our theoretical constructions with extensive implementation
tests that show the practical feasibility of our schemes.

Categories and Subject Descriptors
K.6.5 [Management of Computing and Information
Systems]: Security and Protection

Keywords
Veriﬁable Computation; Homomorphic Encryption; Homo-
morphic MACs; Cloud Computing

1.

INTRODUCTION

Can an outside party compute for us, without learning our
private data? Can we eﬃciently check that it performed the
computation correctly? These are some central questions
related to the privacy and the security of cloud computing,
a paradigm where businesses buy computational time from
a service, rather than purchase and maintain their own re-
sources. Both questions have a long research history.

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’14, November 3–7, 2014, Scottsdale, Arizona, USA.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-2957-6/14/11 ...$15.00.
http://dx.doi.org/10.1145/2660267.2660366 .

Computing arbitrary functions on encrypted data was a
research interest recognized very early by cryptographers
[42], and it remained open until Gentry’s construction of
the ﬁrst fully homomorphic encryption (FHE) scheme [23].
Gentry’s work revealed a new set of techniques that were
immediately used for many more eﬃcient schemes [24, 46,
25, 16, 15, 26, 14]; today we seem to stand at the verge of
having FHE schemes which can be used in practice.

Eﬃcient veriﬁcation of arbitrarily complex computations
was the underlying goal of interactive proofs [3, 30], where
a powerful (e.g. super-polynomial) prover can (probabilisti-
cally) convince a weak (e.g. polynomial) veriﬁer of the truth
of statements that the veriﬁer could not compute on its own.
Research on making the veriﬁer as eﬃcient as possible led to
the concept of probabilistically checkable proofs (PCPs) [2,
5, 4], and their cryptographic applications: the arguments of
Kilian [34, 35] and Micali’s non-interactive CS Proofs [39].
The application to cloud computing has rekindled atten-
tion to this area, particularly in the search for protocols
where arbitrary poly-time (as opposed to superpoly-time)
computations can be eﬃciently veriﬁed by a linear (or quasi-
linear) veriﬁer, and performed by a prover without too much
overhead. Starting with the work on proofs for muggles
[28], a line of research revisited and “scaled down” the PCP
machinery [29, 10, 11]. Another line of work explored al-
ternative ways of arithmetizing computations to construct
eﬃcient proofs [31, 37, 21]. Yet another approach used FHE
as a tool to build eﬃcient veriﬁcation of arbitrary computa-
tions [20, 1, 17]. Several implementational eﬀorts [18, 43, 44,
48, 41, 8, 49] show that also in this area we are on the verge
of achieving practical eﬃciency, with the quadratic span pro-
gram techniques of [21, 41] showing particular promise.

1.1 Our Contribution

Given the practical and theoretical relevance of this topic,
as well as the level of maturity of the ﬁeld, it is somewhat
surprising that most of the research was focused on solving
either one of the two main questions. There are many results
about ﬁnding eﬃcient FHE schemes, and therefore eﬃcient
computation on encrypted data, but without veriﬁcation of
its correctness. On the other hand, the works on verifying
computation mostly focused on the case where the data is
in the clear or in a restricted model for privacy – a notable
exception is the construction of Goldwasser et al. [27], based
on functional encryption.

The protocols for veriﬁable computation (VC) in [20, 17,
1] use FHE as a tool for veriﬁability, and almost as a by-
product, they achieve data privacy as well, but in a restricted

844sense: namely, only if the client’s acceptance bit is kept
hidden from the server, i.e. the server is not allowed to issue
veriﬁcation queries. Also, in [20] only the topology of the
function is revealed [7]. In [20], a formal deﬁnition of all the
properties needed by a VC scheme is given, including input
privacy, but still in absence of veriﬁcation queries.

This model is quite restrictive in practice, as in real life
the client’s acceptance bit may leak due to multiple reasons:
error messages, protocol termination, recomputation, etc.

To the best of our knowledge, no deﬁnition of private and
secure VC with presence of veriﬁcation queries can be found
in the literature. We give such deﬁnitions, provide schemes
that satisfy them, and support our constructions with ex-
perimental results. Our contribution, in a list:
1. An upgrade to the deﬁnition in [20] that allows veri-
ﬁcation queries by the adversary, and an extension of
this deﬁnition that models adaptive security and func-
tion privacy. This is the strongest possible model in
which we can deﬁne security.

2. A protocol based on FHE for arbitrary computations.
3. Constructions for speciﬁc families of functions to com-

pute: multivariate quadratic polynomials, univariate poly-
nomials of high degree, linear combinations – all on en-
crypted data (details on Table 1). Using our schemes a
client can outsource the storage of large, privacy-sensitive,
data sets (e.g.
location, medical, genomic data) on a
server, and get statistics or distance measures (computed
by the server) on them, with guarantees of correctness
of the computation and privacy of the data.

4. A key technical contribution is the introduction of a ho-
momorphic hashing technique that allowed us to obtain
improvements of more than four orders of magnitude
compared to a naive approach.

5. Implementations and performance numbers of our schemes

for practical security parameters.

Now, we discuss our contribution more in detail.

Our Generic Protocol. Our protocol assumes the exis-
tence of an FHE scheme and a not-necessarily private, but
secure VC scheme, e.g. [21]. The basic idea is to encrypt the
data x with the FHE scheme, and to run the VC scheme on
the function EvalFHE(f ), instead of f , and on input EncFHE(x)
instead of x. This technique prevents the server from using
the client as a decryption oracle for the FHE, since the ac-
ceptance bit is determined before decryption, just according
to the correctness of the evaluation of EvalFHE(f ).

Ad-Hoc Protocols. We focus on the problem where a
client stores a large data set x = (x0, . . . , xt) on a server and
later asks the server to compute functions f over x. Our
solutions work in the amortized model in which the client
spends a single pre-processing phase whose cost is as run-
ning f (x), and later amortizes this one-time cost over several
function evaluations. Moreover, our protocols work also in
the so-called streaming model: clients can process and out-
source single data items xi in a separate fashion. This is
desirable for storing applications, since it enables clients to
work with a very small memory, independent of the size of
the (possibly huge) data set. As an example, think of a set of
weak devices that read the temperature in given locations,
and daily send the data to a server to store for later analysis
(e.g. calculate the mean temperature in a year).

We focus on the case where the data sets consist of ele-
ments in a ﬁnite ﬁeld Fp, and the outsourced functions can

be: (1) quadratic multi-variate polynomials, (2) univariate
polynomials of large degree, and (3) linear combinations. In
the full version [19] we also show a scheme for linear combi-
nations over Z

2k , omitted here for lack of space.

Scheme

Input Function Amort.
Priv.
Verif.

Priv.

Linear combinations
t-variables over Fp
Linear combinations
t-variables over Z
Univariate Poly
of degree t over Fp

2k

t-variate Poly

of degree 2 over Fp

t-variate Restricted Poly

of degree 2 over Fp

(cid:88)

(cid:88)

×

(cid:88)

(cid:88)

(cid:88)

×

(cid:88)

×

(cid:88)

O(t)

O(1)

O(1)

O(1)

O(1)

Table 1: Summary of our schemes.

Multi-Variate Quadratic Polynomials. We constructed
a VC scheme in the case the client stores several encrypted
data sets at the server, and then asks it to compute a quadratic
polynomial f on any of the outsourced sets. In our solution,
after a single pre-processing for every f , the client can ver-
ify results in constant time. Moreover, our scheme achieves
input and output privacy.

In terms of applications, this scheme allows to compute
several statistics (average, variance, covariance, RMS, lin-
ear regression, correlation coeﬃcient, and many more) on
remotely stored data sets in a private and veriﬁable man-
ner. We also consider the application in which a client
stores a large matrix X on the server, and then asks to com-
pute a distance measure (e.g. Euclidean distance) between
a given vector y and any row of X. We propose a variant
of our scheme that is function private for a restricted class
of quadratic polynomials (privacy holds only for the coeﬃ-
cients of the linear terms). Yet, since the above application
ﬁts such restriction, we give a solution in which both X and
y are private.

We are not aware of any other existing solution for pri-
vately evaluating multivariate quadratic polynomials, except
by instantiating our paradigm with existing tools [15, 6].
Even compared to these solutions, our experiments show
that our ad-hoc protocol improves signiﬁcantly: for instance,
in our scheme the computation of the variance function at
the server is more than 104 times faster! If we consider cloud
computing, in which clients pay for the server’s CPU cycles,
such improvement leads to worthwhile savings.
Polynomials of High Degree. We also constructed a
VC scheme for a setting which is complementary to the one
above. Namely, we think of x as the coeﬃcients of a uni-
j=0 xizi of degree t. With
our protocol the client stores the large polynomial Enc(Px)
at the server, and then asks it to compute Enc(Px(z)) on
many diﬀerent points z (provided in the clear). Here, after
the single preprocessing to outsource Px, the client can verify
all the computations in constant time. Moreover, our scheme
is function private as Px is encrypted.

variate polynomial Px(z) = (cid:80)t

We note that the task of evaluating univariate polynomi-
als of large degree was earlier considered in [9]. However, in
that protocol, when the polynomial is encrypted, the client’s
acceptance bit depends on the decrypted value, which cre-
ates the opportunity for a veriﬁcation query attack. Papa-

845manthou et al.
[40] also propose a scheme for outsourcing
polynomials of large degree, and suggest the use of FHE to
achieve privacy. However, this work too suﬀers the same
veriﬁcation query attack as in [9]. In contrast, our solution
(which builds on [9] in a slightly diﬀerent way) enjoys se-
curity in the stronger model where veriﬁcation queries are
allowed. In terms of applications, we discuss how this solu-
tion can be used to outsource the Discrete Fourier Transform
computation on encrypted vectors.
Linear Combinations. Finally, we considered the task of
outsourcing linear combinations. For this we constructed a
very clean and eﬃcient solution which provides both input
and function privacy, but has no eﬃcient veriﬁcation. How-
ever, the client can work with a very short memory in the
streaming model. We note that a solution with eﬃcient ver-
iﬁcation (achieving both input and function privacy) can be
obtained by using our variant scheme for quadratic polyno-
mials. Compared to the latter, the advantage of our dedi-
cated scheme is eﬃciency: we achieve veriﬁability by using
information-theoretic techniques that do not require expen-
sive, cryptographic computations (e.g. over bilinear groups).
We note that a protocol for the evaluation of linear combi-
nations over encrypted data has been recently proposed by
Libert et al. [36], using additively homomorphic encryption
and structure-preserving linearly homomorphic signatures.
However, their protocol is restrictive, since the linear com-
binations have to reside in a very small range in order for the
client to retrieve the correct result: the client’s decryption
consists in solving discrete log, by which the exponents must
be small. In contrast, our solutions for linear combinations
can support large domains and provide function privacy.
An Overview of Our Techniques. To design our pro-
tocols we follow the blueprint of our generic scheme and
we develop additional techniques that provide signiﬁcant
eﬃciency improvements. Our basic idea is to encrypt the
data with a somewhat homomorphic encryption scheme (for
privacy), and to add an authentication mechanism on top
of the ciphertexts (for security). For the encryption, we
chose a simpliﬁed version of the scheme by Brakerski, Gen-
try, and Vaikuntanathan (BGV) [15]. The server stores
µ = (µ0, . . . , µt) where µi is a BGV encryption of xi. For
authentication, we rely on homomorphic MACs [22]. In a
nutshell, this primitive enables a client to use a secret key
to authenticate a set of messages m1, . . . , mt by produc-
ing corresponding tags σ1, . . . , σt. Later, given such tags,
anyone (without any secret key) can produce a tag σ that
authenticates m = f (m1, . . . , mt) as the output of f on
the previously authenticated inputs. Interestingly, veriﬁca-
tion can be performed without knowing the original mes-
sages, and recently proposed schemes [6] allow to verify
more eﬃciently than running f . The generic idea for our
schemes is to generate a MAC σi for every ciphertext µi,
and then use the homomorphic property of the MAC to au-
thenticate the BGV homomorphic evaluation. While this
idea may work for appropriate choices of the MAC scheme
[6]), we note that BGV ciphertexts consist of several
(e.g.
p → Fp is
components over a ﬁeld Fq:
the desired function, the BGV evaluation circuit is a func-
tion ˆf : F2nt
q . We improve this situation using our
key technical contribution: homomorphic hash functions Hκ
that allow to compress a BGV ciphertext into a single Fq-
component, while preserving the homomorphic properties,
i.e. f (Hκ(µ1), . . . , Hκ(µt)) = Hκ( ˆf (µ1, . . . , µt)). By apply-

in detail, if f : Ft

q → F3n

ing a MAC on top of the hashed ciphertexts, we save at least
a factor of 3n in all operations (e.g. input outsourcing, com-
putation, veriﬁcation). Considering that for security reasons
(and technical details discussed later) n can be as large as
5000, applying the homomorphic hash leads to schemes that
are up to four orders of magnitude faster. Compare the last
two columns of Table 2 for the concrete example of comput-
ing the variance of 1000 items.

Without

Ours

Naive

Privacy [6]

(Sec.4.1) Approach

Server Comp.
Client Ver.

0.98sec
0.21ms

1.11sec
0.42ms

15210.61sec
3316.63ms

Table 2: Costs for variance (t = 1000, sec = 80bit).

Experiments. We implemented the above solutions, and
tested their practical performances. Remarkably, all our
protocols run considerably fast. See section 6 for details.

An interesting point is that the cost (in terms of CPU
time) of adding privacy to veriﬁability is relatively small.
As an example, for 80bit security, scheme in section 4.1: on
the server side, the total execution time of any operation,
is between 1.1 and 2.2 times the execution time for authen-
tication operations only (i.e. excluding encryptions, FHE
evaluations, etc. from the total cost), depending on the par-
ticular function. The highest privacy cost (deﬁned as: total
execution time over authentication time, as above), 2.9, oc-
curs in one-time operations: encrypting and authenticating
the data when loading it into the server. Finally, our veriﬁca-
tion algorithm has a privacy cost of 1.9×, due to decryption
of the result. Compare the ﬁrst two columns of Table 2 for a
concrete example, and see Table 3 for more details. Notice
that our timing for authentication only is comparable with
the timing of [6] (adapted with a secure pairing).

Finally, we point out that, even if minimal, the privacy
overhead can be mitigated by using the batching technique
of BGV: for 80bit (resp. 128 bit) security we could encrypt
165 (resp. 275) 32bit plaintext items in a single ciphertext.
This means the amortized cost (per plaintext item) of our
scheme is actually better than [6].
NOTE: For lack of space, further discussion on related
work, a full presentation of our generic protocol, proofs and
more detailed numbers on our experiments appear only in
the full version of this work [19].
2. PROBLEM DEFINITION

We work in the amortized model of [20] where the client
runs a one-time expensive phase to outsource the function
f to the server (this phase can cost as much as the com-
putation of f ). Later the client queries the server on (an
encrypted form of) input x and receives back (an encryption
of) the value f (x) and a proof of its correctness: this phase
should be eﬃcient for the client (ideally linear in |x|+|f (x)|).
In [20] the authors give a deﬁnition that includes both
security (i.e. the client only accepts correct outputs) and
privacy (i.e. the client’s input x is semantically hidden to the
server) but does not allow veriﬁcation queries. In this section
we upgrade the deﬁnition by adding veriﬁcation queries to
it. Moreover, we introduce the concept of adaptive security.

A veriﬁable computation scheme VC = (KeyGen, ProbGen,
Compute, Verify) consists of the following algorithms:
KeyGen(f, λ) → (P K, SK): Based on the security pa-
rameter λ, the randomized key generation algorithm gen-
erates a public key (that encodes the target function f )

846which is used by the server to compute f .
It also com-
putes a matching secret key, kept private by the client.
ProbGenSK (x) → (σx, τx): The problem generation algo-
rithm uses the secret key SK to encode the input x as a
public value σx that is given to the server to compute with,
and a secret value τx which is kept private by the client.
ComputeP K (σx) → σy: Using the client’s public key and
the encoded input, the server computes an encoded version
of the function’s output y = f (x).
VerifySK (τx, σy) → (acc, y): Using the secret key SK
and the secret τx, the veriﬁcation algorithm converts the
server’s output into a bit acc and a string y. If acc = 1
we say the client accepts y = f (x), if acc = 0 we say the
client rejects.
We now recall the main properties deﬁned in [20] for a ver-
iﬁable computation scheme: correctness, privacy, and our-
sourceability, but we deﬁne them in the presence of veriﬁca-
tion queries by the adversary. Next, we introduce function
privacy, and adaptive security.

The intuition for correctness is that if both parties are

honest, then the client accepts. More formally:

Definition 1

and returns only σx.

(Correctness). A veriﬁable computa-
tion scheme VC is correct if for all f, x:
if (P K, SK) ←
KeyGen(f, λ), (σx, τx) ← ProbGenSK (x), and σy ←
ComputeP K (σx), then (1, y = f (x)) ← VerifySK (τx, σy).
For the other notions, we need to deﬁne the following oracles.
• PProbGen(x) calls ProbGenSK (x) to obtain (σx, τx)
• PVerify(τ, σ) returns acc if and only if VerifySK (τ, σ) =
(acc, y). In other words, PVerify is the public accep-
tance/rejection bit which results from a veriﬁcation query.
When we write APVerify we mean that A is allowed to
query PVerify(τ,·) where τ can be the secret encoding
of any of the queries made in PProbGen, or also τb in
the case of the privacy experiments.

Input privacy is deﬁned based on a typical indistinguisha-
bility argument that guarantees that no information about
the inputs is leaked. Input privacy, of course, immediately
yields output privacy.

Intuitively, a veriﬁable computation scheme is private when

the public outputs of the problem generation algorithm ProbGen
over two diﬀerent inputs are indistinguishable. More for-
mally, consider the following experiment:

Experiment ExpP rivA [VC, f, λ]

(P K, SK) ← KeyGen(f, λ); b ← {0, 1};
(x0, x1) ← APVerify,PProbGen(P K)
(σ0, τ0) ← ProbGenSK (x0);
(σ1, τ1) ← ProbGenSK (x1);
ˆb ← APVerify,PProbGen(P K, x0, x1, σb)
If ˆb = b, output ‘1’, else ‘0’;

Definition 2

(Privacy). A veriﬁable computation scheme

VC is private for a function f , if for any adversary A run-
ning in probabilistic polynomial time,

Pr[ExpP rivA

[VC, f, λ] = 1] ≤ 1
2

+ negl(λ).

Function privacy is the requirement that the public key
P K, sampled via (P K, SK) ← KeyGen(f, λ), does not
leak information on the encoded function f , even after a
polynomial amount of runs of ProbGenSK on adversarially
chosen inputs. More formally, we deﬁne function privacy
based on an indistinguishability experiment as follows.

Experiment ExpF P rivA

[VC, λ]
(f0, f1) ← A(λ); b ← {0, 1};
(P K, SK) ← KeyGen(fb, λ);
For i = 1, . . . , (cid:96) = poly(λ);

xi ← APVerify(P K, x1, σ1, . . . , xi−1, σi−1);
(σi, τi) ← ProbGenSK (xi);

ˆb ← APVerify(P K, x1, σ1, . . . , x(cid:96), σ(cid:96));
If ˆb = b, output ‘1’, else ‘0’;

Definition 3

(Function Privacy). A veriﬁable com-
putation scheme VC is function private, if for any adversary
A running in probabilistic polynomial time,

Pr[ExpF P rivA

[VC, λ] = 1] ≤ 1
2

+ negl(λ).

Definition 4

The next property of a veriﬁable computation scheme is
that the time to encode the input and verify the output
must be smaller than the time to compute the function from
scratch.
(Outsourceability). A VC can be out-
sourced if it allows eﬃcient generation and eﬃcient veriﬁ-
cation. This implies that for any x and any σy, the time re-
quired for ProbGenSK (x) plus the time required for Verify(σy)
is o(T ), where T is the time required to compute f (x).

We now introduce the notion of adaptive security for a
veriﬁable computation scheme.
Intuitively, an adaptively
secure scheme is a scheme that is secure even if the adver-
sary chooses f after having seen many “encodings” σx for
adaptively-chosen values x. At ﬁrst sight, this property is
non-trivial to achieve, since not every scheme allows σx to
be computed before choosing f (in particular schemes based
on FE such as [27]). This observation leads us to ﬁrst deﬁne
a reﬁned class of schemes, for which adaptivity is not ruled
out by this restriction, and then proceed with the actual
deﬁnition of adaptivity.
(Split Scheme). Let VC = (KeyGen,
ProbGen, Compute, Verify) be a veriﬁable computation
scheme. We say that VC is a split scheme if the following
conditions hold:
• There exist PPT algorithms KeyGenE(λ), KeyGenV (f,
λ) such that: if (P K, SK) ← KeyGen(f, λ), then P K =
(P KE, P KV ) and SK = (SKE, SKV ), where
KeyGenE(λ) → (P KE, SKE) and
KeyGenV (f, λ, P KE, SKE) → (P KV , SKV ).
SKE (x),

• There exist PPT algorithms ProbGenE

Definition 5

SKV (x) such that: if

ProbGenV
(σx, τx) ← ProbGenSKE ,SKV (x), then σx = σE
ProbGenE
SKV (x).

x ← ProbGenV

SKE (x) and τx = τ V

x ←

Notice that for a split scheme one can generate valid val-
ues σx for any function f to be delegated before know-
ing f , since σx is independent of f . This can be done by
running (P KE, SKE) ← KeyGenE(λ), and setting σx ←
ProbGenE
SKE (x) before knowing f . The validity of this en-
coding applies for all keys (P K, SK) = (P KE, P KV , SKE,
SKV ) where (P KV , SKV ) ← KeyGenV (f, λ) for any f .

adaptive security for split schemes.

We can now describe the experiment that is used to deﬁne
Experiment ExpAdap−V erif

A

[VC, λ]
(P KE, SKE) ← KeyGenE(λ);
For i = 1, . . . , (cid:96)(cid:48) = poly(cid:48)(λ):
i ← A(P KE, x(cid:48)
1, σ(cid:48)
x(cid:48)
1, . . . , x(cid:48)
i ← ProbGenE
σ(cid:48)
SKE (x);
(cid:96)(cid:48) , σ(cid:48)
1, . . . , x(cid:48)
(cid:96)(cid:48) );

f ← A(x(cid:48)
(P KV , SKV ) ← KeyGenV (f, λ);
(P K, SK) ← (P KE, P KV , SKE, SKV );

i−1, σ(cid:48)

1, σ(cid:48)

i−1);

847For i = 1, . . . , (cid:96) = poly(λ):

xi ← APVerify(P K, x1, σ1, . . . , xi−1, σi−1);
(σi, τi) ← ProbGenSK (xi);
(i, ˆσy) ← APVerify(P K, x1, σ1, . . . , x(cid:96), σ(cid:96));
( ˆacc, ˆy) ← VerifySK (τi, ˆσy);
If ˆacc = 1 and ˆy (cid:54)= f (xi), output ‘1’, else ‘0’.

Definition 6

(Adaptive Security). A split scheme
VC is adaptively secure, if for any adversary A running in
probabilistic polynomial time,
Pr[ExpAdap−V erif

[VC, λ] = 1] ≤ negl(λ).

A

3. TOOLS

We now describe the tools used for our eﬃcient VC schemes.

Namely, an adapted version of the BGV homomorphic en-
cryption scheme, a new notion and realizations of homo-
morphic hash functions, and amortized closed-form eﬃcient
pseudorandom functions.
Our schemes use a bilinear group generator G(1λ) whose
output is bgpp = (q, G1, G2, GT , e, g, h), where G1, G2 and
GT are groups of prime order, g ∈ G1 and h ∈ G2 are two
generators, and e : G1×G2 is a non-degenerate bilinear map.
3.1 The BGV Homomorphic Encryption

We now describe a stripped down version of FHE scheme
by Brakerski, Gentry, and Vaikuntanathan [15] that we need
for our construction. The version below is only somewhat
homomorphic, and resembles the less recent scheme by Brak-
erski and Vaikuntanathan [16]. Also, since we need to evalu-
ate only polynomials of degree at most two, our description
does not need KeySwitch or ModulusSwitch.
BGV.ParamGen(λ). The message space M is the ring Rp :=
Fp[X]/Φm(X), where Φm(X) is the mth cyclotomic poly-
nomial in Fp[X], of degree n = Φ(m).
The ciphertext space is described as follows: pick a large q
which is co-prime to p (the size of q can be determined as it
is done in [16], section 2), and deﬁne Rq := Z/qZ[X]/Φ(X).
Ciphertexts can be thought of as elements in Rq[Y ]: level
1 ciphertexts (those created by the encryption procedure
and eventually manipulated via additive operations only)
are of degree 1, while level 0 ciphertexts (ciphertext manip-
ulated via one multiplication and possibly other diﬀerent
homomorphic operations) are of degree 2. Operations on
ciphertexts are the corresponding ring operations of Rq[Y ].
For any two ciphertexts a0 + a1Y + a2Y 2 and b0 + b1Y +
b2Y 2, addition is performed as: (a0 + a1Y + a2Y 2) + (b0 +
b1Y + b2Y 2) = a0 + b0 + (a1 + b1)Y + (a2 + b2)Y 2, and if
a2 = 0 = b2 multiplication is performed as: (a0 +a1Y )(b0 +
b1Y ) = a0b0 + (a1b0 + b1a0)Y + a1b1Y 2. Notice we are
interested only in multiplication of ciphertexts of level 1.
Finally, the algorithm deﬁnes the following distributions:
DZn,σ: the discrete Gaussian with parameter σ: it is the
random variable over Zn obtained from sampling x ∈
Rn with probability e−π·(cid:107)x(cid:107)2/σ2
and then rounding at
the nearest lattice point. Again, we refer to [16] for the
speciﬁc choice of σ.
ZOn: sample x = (x1, . . . , xn) with xi ∈ {−1, 0, +1} and
Pr[xi = −1] = 1/4; Pr[xi = 1] = 1/4; Pr[xi = 0] = 1/2.
In the following, we assume that the parameters generated
here are inputs of any subsequent algorithm.
BGV.KeyGen() → (pk, dk). Sample a $← Rq, and s, e $← DZn,σ.
Considering s and e as elements in Rq, compute b ←
a · s + p · e, and set dk ← s and pk ← (a, b).

BGV.Encpk(m, r) → (c0, c1, c2 = 0). Given m ∈ Rp, and r $←
(ZOn, DZn,σ, DZn,σ), the message m is parsed as an ele-
ment in Rq with inﬁnity norm bounded by p/2, and the
randomness r is parsed as r = (u, v, w) ∈ R3
q. The output
is c = c0 + c1 · Y ∈ Rq[Y ], where c0 ← b · v + p · w + m and
c1 ← a · v + p · u.
BGV.Decdk(c) → t mod p. Compute t ∈ Rq as t ← c0 − s ·
c1−s2·c2. The output is then t mod p, which is interpreted
as an element in Rp.

Lemma 1

([16], Lemma 4; and [16], Theorem 2).

For D = 1, 2, the public-key encryption scheme (BGV.ParamGen,
BGV.KeyGen, BGV.Enc, BGV.Dec), speciﬁed above, is seman-
tically secure under the PLWE assumption, and it allows the
computation of any polynomial f of degree D such that

(cid:107)f(cid:107)∞ ·(cid:0)p · σ · n1.5(cid:1)D ≤ q/2.

Batching. A nice capability of the BGV encryption scheme,
which will be used extensively in our implementations, is
the ability to encrypt many “small” plaintexts (e.g.
inte-
gers modulo a 32-bit prime) into the same ciphertext: each
small plaintext will then reside in its dedicated “slot” in the
ciphertext. This feature was ﬁrstly introduced by Smart and
Vercauteren [47], and we refer to [15, 47] for more details.
3.2 Homomorphic Hash Functions

We now introduce the notion of homomorphic hash func-
tions and we propose two realizations that will be used
throughout the paper.
Informally, a family of keyed ho-
momorphic hash functions H with domain X and range Y
consists of a tuple of algorithms (H.KeyGen, H, H.Eval) such
that:
• H.KeyGen generates the description of a function HK ,
• H computes the function,
• H.Eval allows to compute over Y.
In our case we are interested in computations of arithmetic
circuits, and thus H.Eval allows to compute additions and
multiplications over Y.

In the following we propose a homomorphic hash whose
key feature is that it allows to “compress” a BGV ciphertext
µ ∈ Rq[Y ] into a single entry ν ∈ Z/qZ in such a way that H
is a ring homomorphism, hence H.Eval(f, (H(µ1), . . . , H(µt))
= H(f (µ1, . . . , µt)). Turning our attention to security, we
show that this ﬁrst construction is universal one-way. Next,
we will show a variant of this construction that maps into
bilinear groups and can be proven collision-resistant.

A Universal One-Way Homomorphic Hash. Let q be a
prime and Rq[Y ] = Z/qZ[X, Y ]/Φm(X) be as in BGV. The
family of hash functions (H.KeyGen, H, H.Eval) with domain
Rq[Y ] and range Z/qZ is deﬁned as follows:
H.KeyGen: Pick α $← Rq and β $← Z/qZ, and set κ = (α, β).
Hκ(µ): On input µ ∈ Rq[Y ], the function Hα,β evaluates µ
at Y = α and then evaluates µ(α) ∈ Rq = Z/qZ[X]/Φ(X)
at β ∈ Z/qZ. More explicitly, Hα,β = evβ ◦ evα.
H.Eval(fg, ν1, ν2): on input two values ν1, ν2 ∈ Z/qZ and
an operation fg which is addition + or multiplication ×,
compute fg(ν1, ν2).

Theorem 2. The family of functions H deﬁned above is

homomorphic and universal one-way, i.e., for all µ (cid:54)= µ(cid:48):
Pr[Hα,β(µ) = Hα,β(µ

) : α $← Rq, β $← Z/qZ] ≤ 2/q2n + n/q

(cid:48)

which is negligible for an appropriate choice of q.

848A Collision-Resistant Homomorphic Hash. Notice
that the function Hα,β is secure only if the key (α, β) is
kept secret and the function is used only one time (other-
wise information on α and β is leaked). Below, we show how
to obtain a slightly diﬀerent version of Hα,β which can be
proven collision-resistant at the price of being “somewhat”
homomorphic – the homomorphic property holds only for
degree-2 functions. Moreover, in this construction we re-
strict to the case in which q is a prime.

Let bgpp = (q, G1, G2, GT , e, g, h) be some bilinear group
parameters as described before, and let Rq[Y ] be as in BGV.
The family of hash functions ( ˆH.KeyGen, ˆH, ˆH.Eval) with
domain Rq[Y ] and range G1 × G2 (or GT ) is as follows:
ˆH.KeyGen: To sample a member of the family, choose ran-
dom α $← Rq and β $← Fq. Parse α as (α1, . . . , αn) ∈ Fn
q .
Next, for i, j = 1, . . . , n k = 0, . . . , n−1, compute gαi , hαi ,
gαiαj , hαiαj , gαiαj βk
Output K and κ = (α, β).
ˆH(µ). On input µ ∈ Rq[Y ] such that degY (µ) ≤ 2, the func-
tion ˆH(µ) does the following. Let Hα,β be the function
If degY (µ) ≤ 1, then compute (T, U ) ←
deﬁned above.
(gHα,β (µ), hHα,β (µ)) ∈ G1 × G2. If degY (µ) = 2, compute
e(g, h)Hα,β (µ) ∈ GT .
Note that ˆH can be computed in two diﬀerent ways (the
ﬁrst one being computationally more eﬃcient): (1) by us-
ing the secret key κ, or (2) by using the values in the public
key K.

, and include them in K.

, hαiαj βk

ˆH.Eval(fg, ν1, ν2) We show how to compute degree-2 func-
tions on the outputs of ˆH in a homomorphic way.
Intu-
itively speaking, we want to compute degree-2 polynomi-
als f over Fq “in the exponent”. To this end we rely on
that the bilinear groups are isomorphic to Fq and simulate
additions via the group operation and multiplications by
using the bilinear pairing.
ˆT1, ˆT2 ∈
More precisely, given (T1, U1), (T2, U2) (resp.
GT ):
• Addition (in the exponent) is performed via (component-
wise) group operation, i.e., (T ← T1 · T2, U ← U1 · U2)
(resp. ˆT ← ˆT1 · ˆT2).
• Multiplication by a constant c ∈ Fq is performed as
• Multiplication of two values, is performed with the use

(T c, U c) (resp. ˆT c).
of the bilinear pairing: ˆT ← e(T1, U2) ∈ GT .

Definition 7

In the following theorem we show that the function ˆH
described above is homomorphic, and it is collision-resistant
under the (cid:96)-BDHI assumption which we recall below.
((cid:96)-BDHI Assumption [12]). Let G be a
bilinear group generator, and let bgpp = (q, G1, G2, GT , e,
g, h) $← G(1λ). Let z $← Fq be chosen uniformly at random.
We say that the (cid:96)-BDHI assumption holds for G if for every
PPT adversary A and any (cid:96) = poly(λ) the probability
Pr[A(bgpp, g, h, gz, hz, . . . , gz(cid:96)

) = e(g, h)1/z] = negl(λ).

, hz(cid:96)

Theorem 3. The function ˆH described above is homo-
morphic. Furthermore, if the (n + 1)-BDHI assumption
holds for G, then ˆH is collision-resistant, i.e., for (K, κ) $←
ˆH.KeyGen

Pr[ ˆH(µ) = ˆH(µ

(cid:48)

) ∧ µ (cid:54)= µ

(cid:48) | (µ, µ

(cid:48)

) ← A(K)] = negl(λ).

3.3 Amortized closed-form Efﬁcient PRFs

Here we recall the notion of pseudorandom functions with
amortized closed-form eﬃciency [6] which extend closed-
form-eﬃcient PRFs [9].

A PRF consists of two algorithms (F.KG, F) such that the
key generation F.KG takes as input the security parameter 1λ
and outputs a secret key K and some public parameters pp
that specify domain X and range R of the function, and the
function FK (x) takes input x ∈ X and uses the secret key K
to compute a value R ∈ R. As usual, a PRF must satisfy the
pseudorandomness property. Namely, we say that (F.KG, F)
is secure if for every PPT adversary A we have that:

| Pr[AFK (·)(1λ, pp) = 1] − Pr[AΦ(·)(1λ, pp) = 1] | ≤ (λ)

where (λ) is negligible, (K, pp) $← F.KG(1λ), and Φ : X →
R is a random function.

For any PRF (F.KG, F) amortized closed-form eﬃciency is

deﬁned as follows.

Definition 8

(Amortized Closed-Form Efficiency [6]).

Consider a computation Comp that takes as input n ran-
dom values R1, . . . , Rn ∈ R and a vector of m arbitrary
values (cid:126)z = (z1, . . . , zm), and assume that the computation of
Comp(R1, . . . , Rn, z1, . . . , zm) requires time t(n, m).
Let (cid:126)L = (L1, . . . , Ln) be arbitrary values in the domain
X of F such that each can be interpreted as Li = (∆, τi).
We say that a PRF (F.KG, F) satisﬁes amortized closed-form
eﬃciency for (Comp, (cid:126)L) if there exist algorithms CFEvaloﬀ
and CFEvalon
1. Given ω←CFEvaloﬀ

Comp, ˜τ (K, (cid:126)z), we have CFEvalon
ω) = Comp(FK (∆, τ1), . . . , FK (∆, τn), z1, . . . , zm)

Comp,∆ such that:

Comp,∆(K,

Comp, ˜τ

2. the running time of CFEvalon

Comp,∆(K, ω) is o(t).

t(cid:88)

t(cid:88)

An Example. Below we show a realization of amortized
closed-form eﬃcient PRFs based on the decision linear as-
sumption. The scheme is obtained by adapting the one of [6]
to work with asymmetric bilinear groups. This function will
be crucial to achieve eﬃciency for our schemes for quadratic
multi-variate polynomials.
q → Fq be a degree-2 arithmetic circuit, and

Let f : Ft

without loss of generality, parse

f (Z1, . . . , Zt) =

ηi,j · Zi · Zj +

ηk · Zk,

i,j=1

k=1

for some ηi,j, ηk ∈ Fq. We deﬁne ˆf : (G1 × G2)t → GT as
the compilation of f on group elements as:
e(Ai, Bj)ηi,j ·

ˆf (A1, B1, . . . , At, Bt) =

e(Ak, h)ηk .

t(cid:89)

t(cid:89)

i,j=1

k=1

Below, we describe the PRF with amortized closed-form eﬃ-
ciency for Comp(R1, S1, . . . , Rt, St, f ) = ˆf (R1, S1, . . . , Rt, St):
F.KG(1λ). Let bgpp be some bilinear group parameters, where
g ∈ G1 and h ∈ G2 are generators. Choose two seeds
K1,2 : {0, 1}∗ → F2
K1, K2 for a family of PRFs F(cid:48)
q, and out-
put K = (K1, K2). The parameters deﬁne F with domain
X = {0, 1}∗ × {0, 1}∗ and range R = G1 × G2.
K1 (τ ) and (a, b)←
FK (∆, τ ). First, generate values (u, v)←F(cid:48)
F(cid:48)
K2 (∆), and then output (R, S) = (gua+vb, hua+vb).
q → Fq.
CFEvaloﬀ
• For i = 1 to t, compute (ui, vi)←F(cid:48)

˜τ (K, f ). Let K = (K1, K2) and f : Ft

K1 (τi), and inter-
pret (ui, vi) as a linear form ρi that maps (z1, z2) to
ρi(zi, z2) = ui · z1 + vi · z2.

849• Next, run ρ←f (ρ1, . . . , ρt), i.e. compute a (possibly

quadratic) form ρ such that for all z1, z2 ∈ Fq

ρ(z1, z2) = f (ρ1(z1, z2), . . . , ρt(z1, z2)).

• Finally, output ωf = ρ.

CFEvalon
∆ (K, ωf ). Parse K = (K1, K2) as a secret key and
ωf = ρ as in the previous algorithm. The online evalu-
K2 (∆), computes w ←
ation algorithm generates (a, b)←F(cid:48)
ρ(a, b), and outputs W = e(g, h)w.
The function above is secure under the decision linear as-

sumption in asymmetric bilinear groups, recalled below.

Definition 9

(Decision Linear [13]). Let G be a bi-
linear group generator, and let bgpp $← G(1λ). Let r0, r1, r2,
x1, x2
Let T = (g, h, gx1 , gx2 , gx1r1 , gx2r2 , hx1 , hx2 , hx1r1 , hx2r2 ).
We deﬁne the advantage of an adversary A in solving the
decision linear problem as

$← Fq be chosen uniformly at random.

AdvdlinA (λ) = | Pr[A(bgpp, T, gr1+r2 , hr1+r2 ) = 1]−

Pr[A(bgpp, T, gr0 , hr0 ) = 1]|

We say that the decision linear assumption holds for G if for
every PPT algorithm A, AdvdlinA (λ) is negligible.

Theorem 4. If the Decision Linear assumption holds for
G, and F(cid:48) is a family of pseudorandom functions, then the
function F described above is a pseudorandom function with
amortized closed-form eﬃciency for Comp = ˆf .
The proof of theorem 4 follows the one of [6], theorem 2.
4. AD-HOC PROTOCOLS
4.1 Multi-Variate Quadratic Polynomials

In this section we propose an eﬃcient VC scheme for the
case of multi-variate polynomials of degree 2. The basic
idea of the construction is to apply the homomorphic MAC
scheme of [6] to the BGV homomorphic encryption, where
(in this section) q is choosen to be prime. Such homomor-
phic MAC indeed allows to authenticate degree-2 arithmetic
computations over Fq and achieves amortized eﬃcient ver-
iﬁcation, i.e., after a pre-computation phase whose cost is
the same as running f , every output of f can be veriﬁed
in constant time. However, a straightforward application of
the scheme [6] on top of BGV ciphertexts would require to:
(1) authenticate each of the 2n Fq-components of a BGV
ciphertext, and (2) authenticate the BGV evaluation circuit
q → Fq. Essentially, this
ˆf : F2nt
would incur into a O(n) blowup in all algorithms.

instead of f : Ft

q → F3n

q

In contrast, we signiﬁcantly improve over this approach
in two main ways. First, we apply our collision-resistant
homomorphic hash function ˆH which allows to compress a
BGV ciphertext into a pair of group elements (T, U ), yet it
is a ring homomorphism for Rq[Y ]. Second, we modify the
homomorphic MAC scheme of [6] so that it can authenticate
group elements (instead of Fq values). Combining these two
ideas allows us to avoid the O(n) blow-up (see section 6 for
a concrete comparison).

Our scheme VCquad is speciﬁed as follows:
KeyGen(f, λ) → (P K, SK):
• Run BGV.ParamGen(λ) to get the description of the pa-
rameters for the BGV encryption scheme; run (pk, dk) $←

BGV.KeyGen(). Let Rq := Fq[X]/Φm(X) be the poly-
nomial ring where Φm(X) is the mth cyclotomic poly-
nomial in Fq[X] of degree n = Φ(m). The message
space M is the ring Rq[Y ].

• Run bgpp $← G(1λ) to generate the description of asym-
metric bilinear groups bgpp = (q, G1, G2, GT , e, g, h),
where G1, G2 and GT are groups of the same prime
order q, g ∈ G1 and h ∈ G2 are two generators, and
e : G1 × G2 is a non-degenerate bilinear map.
• Choose a random member of the hash function family
ˆH : Rq[Y ] → G1 × G2 by running (κ, ˆK) $← ˆH.KeyGen.
For the convenience of our scheme we do not use the
public key of ˆH.

• Choose a random value a $← Fq, and run (K, pp) $←
PRF.KeyGen(1λ) to obtain the seed K of a function
FK : {0, 1}∗ × {0, 1}∗ → G1 × G2.
In particular,
FK is supposed to be computationally indistinguish-
able from a function that outputs (R, S) ∈ G1 × G2
such that DLogg(R) = DLogh(S) is uniform over Fq
(i.e., e(R, h) = e(g, S)).
• Compute a concise veriﬁcation information for f by
using the oﬄine closed-form eﬃcient algorithm of F,
i.e., ωf←CFEvaloﬀ
• Output the secret key SK = (pk, dk, κ, a, K, ωf ), and
ProbGenSK ((cid:126)x = (x1, . . . , xt)) → σx, τx:
• Choose an arbitrary string ∆ ∈ {0, 1}λ as an identiﬁer

the public evaluation key P K = (pk, pp, f ).

˜τ (K, f ).

for the input vector (cid:126)x.

• For i = 1 to t: ﬁrst run µi
$← BGV.Encpk(xi) to obtain a
BGV ciphertext µi ∈ R2
q, and compute its hash value
(Ti, Ui)← ˆHκ(µi). Next, run (Ri, Si)←FK (∆, i), com-
pute Xi ← (Ri·T
)1/a ∈ G2,
and set σi = (Ti, Ui, Xi, Yi, Λi = 1) ∈ (G1 × G2)2×GT .

)1/a ∈ G1, Yi ← (Si·U

−1
i

−1
i

• Output σx = (∆, µ1, σ1, . . . , µt, σt), and τx = ⊥.
Note that ProbGen can work in the streaming model in
which every input item xi can be processed separately.
ComputeP K (σx) → σy: Let σx = (∆, µ1, σ1, . . . , µt, σt).
First, run µ←BGV.Evalpk(f, µ1, . . . , µt) to homomorphically
evaluate f over the ciphertexts (µi). Next, homomorphi-
cally evaluate f over the authentication tags (σ1, . . . , σt)).
To do so, proceed gate-by-gate over f as described below.
GateEval(fg, σ(1), σ(2)) → σ . Parse σ(i) = (T (i), U (i), X (i),
Y (i), Λ(i)) ∈ (G1×G2)2×GT for i = 1, 2, where fg equals
+ or ×. Compute σ = (T, U, X, Y, Λ) as:
Addition. If fg = +:
T ← T (1) · T (2), U ← U (1) · U (2),
X ← X (1) · X (2), Y ← Y (1) · Y (2), Λ ← Λ(1) · Λ(2).
Multiplication by constant. If fg = × and one of the
two inputs, say σ(2), is a constant c ∈ Fq: T ← (T (1))c,
U ← (U (1))c, X ← (X (1))c, Y ← (Y (1))c, Λ ← (Λ(1))c.
Multiplication. If fg = ×: if deg(µ(1)) > 1 or deg(µ(2)) >
1, reject; else: T ← e(T (1), U (2)), U ← e(T (2), U (1)),
Λ ← e(X (1), Y (2)), X ← e(X (1), U (2))e(X (2), U (2)), Y ←
e(T (1), Y (2))e(T (2), Y (2)).
Note that after a multiplication, it is not necessary to
keep U and Y , as since (for honestly computed tags)
T = U and X = Y . We keep them only for ease of
description.

Output σy = (∆, µ, σ) where σ is the authentication tag

850F on ∆, to compute W←CFEvalon

obtained after evaluating the last gate of f .
VerifySK (σy = (∆, µ, σ), τx) → (acc, x(cid:48)):
• First, compute ˆν ← ˆHκ(µ).
• Next, run the online closed-form eﬃcient algorithm of
• Finally, if deg(f ) = 2, check the following equations:
T = U = ˆν, X = Y , W = T −1 · (X)a · (Λ)a2
If
deg(f ) = 1, check e(T, h) = e(g, U ) ∧ (T, U ) = ˆH(µ),
e(X, h) = e(g, Y ), W = ˆH(µ) · e(X, h)a.
If all equations are satisﬁed set acc = 1 (accept). Oth-
erwise, set acc = 0 (reject).
• If acc = 1, then set x(cid:48) ← BV.Decdk(µ). Otherwise set
x(cid:48) = ⊥. Finally, return (acc, x(cid:48)).

∆ (K, ωf ).

.

quad as follows. Let f : Ft

Theorem 5. If F is a pseudorandom function, ˆH is a
collision-resistant homomorphic hash function and BGV is
a semantically secure homomorphic encryption scheme, then
VCquad is correct, adaptively secure and input private.
A Variant with Function Privacy. In this section we
show that the previous scheme can be modiﬁed in order to
achieve function privacy. Precisely, if we see the polynomial
p → Fp as an arithmetic circuit, we can hide all the con-
f : Ft
stants c occurring in multiplication-by-constant gates that
take inputs of degree 1.
To obtain this construction, the scheme VCquad is modi-
ﬁed into VC∗
p → Fp be a degree-2
arithmetic circuit. For every gate fg in f which is a multi-
plication by a constant c ∈ Fp, compute γ $← BGV.Encpk(c),
νc←Hκ(γ) and (Tc, Uc)← ˆHK (γ). Then we deﬁne the func-
q → Fq as the same as f except that every mul-
tion fpri : Ft
tiplication by a constant c is replaced by a multiplication
by the corresponding νc ∈ Fq computed as described above.
q → Fq is the same as f except that every multi-
fpub : Ft
plication by a constant c is replaced by the corresponding
(Tc, Uc) computed as above.
quad, KeyGen(f, λ) algorithm proceeds as before ex-
cept that the value ωf is computed from fpri, i.e., ωf←
CFEvaloﬀ
˜τ (K, fpri), and EK contains fpub instead of f . In
ComputeP K (σx) the diﬀerence is that we slightly modify
GateEval for multiplication-by-constant gates as follows:
Multiplication by constant. Let σ = (T (1), U (1), X (1),
Y (1), Λ(1)) ∈ (G1 × G2)2 × GT with Λ(1) = 1, and re-
call that the constant c ∈ Fp is (publicly) encoded as
(Tc, Uc) ∈ G1 × G2. We compute σ = (T, U, X, Y, Λ)
as: T = e(T (1), Uc), U = e(Tc, U (1)), X = e(X (1), Uc),
Y = e(Tc, Y (1))
Theorem 6. Let F be the class of arithmetic circuits in
which multiplication by constants occur only for inputs of
degree 1. If F is a pseudorandom function, ˆH is a collision-
resistant homomorphic hash function and BGV is a seman-
tically secure homomorphic encryption scheme, then VC∗
quad
is correct, adaptively secure, input private and function pri-
vate with respect to F.

In VC∗

4.2 Computing Polynomials of Large Degree
We now look at the simpler task of delegation of univariate
polynomials of large degree t, evaluated on values x ∈ Fp
that do not need to be private.

We still use BGV [15] for q prime, but without using its
full power: we only need its additive homomorphic property.

where γi is the BGV encryption of gi, and g(x) =(cid:80)t

We then apply the technique of [9] on the hashing Hα,β(γi),
i=0 gi·xi
is the function to compute. Again, acceptance or rejec-
tion by the client depends only on the correct execution of
the computation over the ciphertexts. No useful decryption
query is performed. In detail, we assume that, as in [9], the
client and the server agreed on a group G of prime order q
in which the discrete logarithm problem is hard, and on a
generator g for G.

Before the speciﬁcations of the scheme, we shall make a ﬁ-
nal observation: due to the noise growth of the BGV scheme
summarized in lemma 1 (for D = 1), in order to achieve cor-
rectness of the result to be decoded by the client, we need q
to be larger than 2 · p · xt · σ · n1.5, where x is the evaluation
point of the scheme. In the worst case, x = p, but we prefer
to separate x and p, to state a more general result, that can
ﬁt better for applications in which x is smaller than p.

The scheme VCpoly is speciﬁed as follows:
KeyGen(g0, . . . , gt, λ) → (P K, SK):
• Run BGV.ParamGen(λ), (pk, dk) ← BGV.KeyGen().
• Specify a group (G,·) of order q and a generator g.
• Sample a uniform MAC key c ← Fq, k0, k ∈ Fq,
• Sample uniform α $← Rq, β $← Fq,
• Compute γi ← BV.Encpk(gi), Ti ← c· Hα,β(γi) + ki · k0,
• Set P K = (pk, G, g, γ0, GT,0, . . . , γd, GT,t) and SK =
ProbGenSK (x) → σx, τx:
• Set σx = x, and τx = x.
ComputeP K (σx = x) → σy:

(pk, G, g, dk, c, α, β, k, k0).

GT,i ← gTi ,

• Compute γ ←(cid:80)t

• Set σy = γ, Gt
VerifySK (σy = γ, GT , τx = x) → (acc, a(cid:48)):
• Compute the element X in Fq such that:

i=0 xi · γi, and GT ←(cid:81)t
X =(cid:0)(x · k)t+1 − 1(cid:1) · (x · k − 1)
(cid:16)
gHα,β (γ)(cid:17)c·(cid:0)gk0(cid:1)X

• If GT (cid:54)=

, reject. Otherwise, accept

i=0 (GT,i)xi

,

−1 ,

and compute a(cid:48) ← BV.Decdk(γ).

Theorem 7. The scheme VCpoly is correct, adaptively se-

cure, and function private.
4.3 Computing Linear Combinations

In this section we give a specialized construction for a par-
ticular setting. Namely, we are interested in getting an input
private and function private split scheme that is not neces-
sarily outsourceable, but that works in the streaming model.
Our scheme is focused on the delegation of the computation
of secret linear functions on encrypted data. Again, we use
BGV, but this time we require its somewhat homomorphic
property for polynomials of degree D = 2 (see lemma 1 for
the parameter choice), and do not require q be prime. The
scheme VCLC is speciﬁed as follows.
KeyGen(g = g0, . . . gt, λ) → (P K, SK):
• Run BGV.ParamGen(λ), (pk, dk) ← BGV.KeyGen().
• Sample a uniform MAC key c $← Rq, a key k for PRF,

α $← Rq, β $← Z/qZ, and compute ri ← PRFk(i).

• Compute γi ← BGV.Encpk(gi), Ti ← c · Hα,β(γi) + ri,
• Set P K = (pk, γ0, T0, . . . , γt, Tt), SK = (pk, dk, c, k, α, β).

851in Rt+1

q

(i.e. τx+ = ri · Hα,β(µi)).

ProbGenSK (x = x0, . . . , xt) → σx, τx: for i = 0, . . . , t
• If σx, τx are not deﬁned: initialize σx as the zero vector
, and τx ← 0 ∈ Z/qZ.
• Compute µi ← BGV.Encpk(xi).
• Compute ri ← PRFk(i), as in the keygen algorithm.
• Set the i + 1th entry of σx as µi.
• Update τx by adding ri · Hα,β(µi) to its previous value
ComputeP K (σx = µ0, . . . , µt) → σy:
i=0 Ti · µi.
• Set σy = γ, τ .
VerifySK (τx, σy = γ, τ ) → (acc, y(cid:48)):
If Hα,β(τ ) (cid:54)= c ·
Hα,β(γ) + τx: reject. Otherwise: accept, and compute
y(cid:48) ← BGV.Decdk(γ).
Theorem 8. The scheme VCLC is correct, adaptively se-

i=0 γi · µi ∈ Rq[Y ], τ ←(cid:80)d

• Compute γ ←(cid:80)t

cure, function private, input private.

Communication Complexity. If the linear combination
to compute were sparse, the client could improve the com-
munication complexity of the protocol by sending only the
encryptions of the non-zero inputs (and the indices they cor-
respond to). In this case, however, the client reveals which
indices are zero (but nothing more).

5. APPLICATIONS
Statistics. Consider the problem in which a client stores
several large data-sets (cid:126)x1, . . . , (cid:126)xN on a server, and wants to
compute a collection of statistics on the outsourced data
in a private and veriﬁable way. By using our scheme for
multi-variate quadratic polynomials of section 4.1, we can
provide eﬃcient solutions for the computation of several sta-
tistical functions, such as average, variance, standard devia-
tion, RMS, covariance, linear regression, Pearson’s and un-
centered correlation coeﬃcient. In appendix A we show how
these statistics can be decomposed in simpler non-rational
functions that can be supported by our scheme.
Distance and Correlation Measures. Consider the prob-
lem in which a client stores a large matrix X ∈ FL×N
on
a server, and then wants to compute the Euclidean dis-
tance between a given vector (cid:126)y ∈ FN
p and each row of the
matrix. Namely, on input (cid:126)y from the client, the server
computes a vector (cid:126)D = (D1, . . . , DL) where every entry
j=1(Xi,j − yj)2 is the (square of the) Euclidean dis-
tance1 between (cid:126)y and the i-th row of X. For security, we are
interested in a solution that guarantees both integrity and
privacy, i.e., results are eﬃciently veriﬁable by the clients
without having to store the matrix X, and the server does
not learn any information about X or the queried vector (cid:126)y.
To achieve a solution for this application we can employ
the function-private scheme VC∗
quad for degree-2 polynomials
(by explicitly relying on its split version) as follows:
• First, the client generates the secret key for the input-

Di =(cid:80)N

p

encoding (P KE, SKE) $← KeyGenE(λ).

• In a pre-processing phase, given the matrix X, the client
$← ProbGen(SKE, (cid:126)Xi) for all the rows
computes σ(cid:126)x,i
of X. Precisely, we can use batching to encode s rows in
the same σ(cid:126)x,i. The cost of this phase, which is performed
only once, is O(L · N ).

1For simplicity, we assume that the ﬁnal square root can be
directly computed by the client.

. . . , zN ) = (cid:80)N

• Given the vector (cid:126)y, the client deﬁnes the function fy(z1,
j=1(zj − yj)2, and runs (EKfy , SKfy ) $←
KeyGenV (fy, λ, P KE, SKE). Note that fy is an admis-
sible function for VC∗
quad as it is of degree-2 and all the
constants derived from the yj’s multiply degree-1 terms.
Moreover, notice that the client can compactly send fy
to the server by sending ˆH(yi). This phase costs O(N ).
• The server computes σDi←Compute(EKE, EKfy , σ(cid:126)x,i)
for every (packed) row of the encrypted matrix, and re-
turns (σD1 , . . . , σDL ) to the client.
• Finally, the client obtains the veriﬁed result by running
the veriﬁcation algorithm on each σDi . The cost of ver-
ifying each entry is O(1) which sums up to O(L).

To summarize, after the pre computation to outsource
the matrix, the work performed by the client to send (cid:126)y and
verify the result is O(N + L), which outperforms the cost
of running this computation, which is O(L · N ). Note also
that the pre computation cost can be amortized when asking
many queries (cid:126)y for the same matrix X. For privacy note that
by input privacy and function privacy the server does not
learn information about the matrix X or the vector (cid:126)y.

While the protocol above is described for the Euclidean
distance, it is easy to see that the same approach works
also for other degree-2 functions with the same properties.
Namely, for any f ((cid:126)y, Xi) such that by ﬁxing (cid:126)y, f is of degree-
2 and multiplications by yi involve only degree-1 monomials.
For example, this property holds for the covariance (or cor-
relation coeﬃcients) between (cid:126)y and each row of X.

Discrete Fourier Transform. The discrete Fourier trans-
form (DFT) of a t-dimensional vector (cid:126)f is deﬁned as the
vector (cid:126)y = (f (α1), . . . , f (αt)) where (cid:126)f is interpreted as the
coeﬃcients vector of a polynomial of degree (t − 1), and the
αi’s are the t roots of unity. It is easy to see that by using
our scheme for univariate polynomials of section 4.2, a client
can store encrypted vectors on a server and then request the
DFT transform of these vectors in a private and veriﬁable
way. In particular, note that the delegation and veriﬁcation
cost is optimal: O(t) (i.e., O(1) for every entry of (cid:126)y).

6. EXPERIMENTAL EVALUATION

To give the reader a glance at the practical applicability
of our procedures, we implemented the schemes in sections
4.1, 4.2, and 4.3, and reported the cost of each procedure.
6.1 Setup
Hardware and Software. Our timings were performed
on a 2011 MacBook Pro (Intel Core i5-2415M, 2 hyper-
threaded cores at 2.30GHz, 8GB RAM at 1.333GHz), on
Ubuntu (linux kernel 3.11, SMP, x86 64). Our implementa-
tions are single-threaded. We used (a tweaked version of)
HElib [32] for the BGV scheme [15], NTL [45] for operations
over Rq and Rq[Y ], and PBC [38] for group operations. Due
to recent discrete log attacks [33] on symmetric pairings, we
used asymmetric Type-3 pairings (using Type-F in PBC)
which, however, do not perform greatly on PBC. We are
conﬁdent that using a diﬀerent library can signiﬁcantly im-
prove some of our results.

Input. Our schemes are targeted at the encryption of a
database that can be thought of as a big table. Each row
of the table represents an input, and each column repre-
sents an attribute. For example, consider a sensor that reads

852the number of bicyles, cars, and trucks driving through Pa-
per Street each day. This sensor could generate a database
where each row corresponds to a day, and each column to a
type of vehicle (so that cell i, j corresponds to the number
of vehicles of type j on day i).

The schemes we implemented all use the BGV encryption
scheme [15], which, as pointed out in section 3.1 has the
nice feature batching. Therefore, for the computation of the
same function for each attribute (e.g. the average amount
of bicycles, cars, trucks, etc, going through Paper Street
in March), it is natural to encrypt each entire row of the
database into a single ciphertext, encoding each data set
element into a diﬀerent slot.

Parameters selection. In our implementations we covered
80bit and 128bit security, and we required the length of each
data set item to be at most 32bit. These choices lead to the
following parameters (s denotes the number of slots):
Polynomials (Section 4.2 and 4.1): For 80bit (respectively

128bit) security, we chose log q = 173 (log q = 272), n =
5418 (n = 8820), s = 165 (s = 275).

Linear Combinations (Section 4.3): For 80bit (respec-
tively 128bit) security, we chose log q = 123 (log q = 173),
n = 4050 (n = 6370), s = 125 (s = 196).
6.2 Timings

For lack of space we only present amortized, or per-attribute

costs. For total costs, multiply the columns by the appro-
priate number of slots (s, in “Parameters Selection” above).
Costs associated with procedures followed by “∗” are ob-
tained using exponentiations with precomputation. We in-
troduce the concept of PCost (a shorthand for “privacy cost”)
of a process, deﬁned as the ratio of the total execution time
of the process over the time taken by the process to compute
authentication operations (i.e. excluding privacy operations
such as encryption, FHE evaluation, hashing, etc). PCost
can therefore be seen as a measure for the cost for bringing
privacy to each operation of a VC scheme.

In the following, by “Amortized” cost, we mean the per-
attribute cost, which equals the “Raw” (or total) cost of an
operation divided by the number of attributes, according
to the above parameters choice. Moreover, costs associated
with procedures followed by “∗” are obtained using exponen-
tiations with precomputation.

Multi-Variate Quadratic Polynomials

Timing (ms) Amortized Cost

PCost

Security

80bit

128bit 80bit 128bit

ProbGen
ProbGen∗

0.15d
0.13d
Add 0.0009
0.09
1.11
0.42
0.37

Const. Mult.
Mult.
Verify
Verify∗

0.27d
0.24d
0.001
0.01
1.32
0.65
0.60

2.92
5.08
2.21
1.10
1.14
1.92
2.14

3.09
8.00
3.45
1.08
1.33
2.77
3.23

Table 3: Costs for the scheme in section 4.1.

On the Impact of Homomorphic Hashing. Our exper-
iments showed the improvement obtained by applying our
technique of homomorphic hashing. We compared our ad-
hoc protocols with some of the best possible instantiations of
our generic scheme and observed a remarkable speedup. For
instance, for the case of multivariate quadratic polynomials,
one may use BGV to encrypt and then use a homomorphic

i

T
m
e

(
s
e
c
)

103
102
101
100
10−1
10−2
10−3
10−4
10−5
10−6

Multi-Variate Quadratic Polynomials

f2
ProbGen
f3
f1

KeyGen2
KeyGen3
KeyGen1
Verify

101

102

103

104

105

106

Database Size

• f1, f2, and f3 denote the cost of the corresponding function
(as deﬁned in appendix A). Notice that f3 does not scale
linearly with the database size (a constant cost of one multi-
plication dominates for small databases).
• KeyGen1, KeyGen2, and KeyGen3 denote the cost of
KeyGen for the corresponding function. Here there is a con-
stant term (BGV.ParamGen) and a linear term that depends
on the cost of the function.
• ProbGen, and Verify denote the cost of the corresponding
function. Dashed lines depict costs obtained using precom-
putation. Notice that the cost of Verify is constant.

Figure 1: The scheme in section 4.1, 80bit security.

Univariate Polynomials of Large Degree

Timing (ms)

Amortized Cost

PCost

Security

80bit

128bit 80bit 128bit

KeyGen 0.008 + 0.125d 0.015 + 0.234d
KeyGen∗ 0.008 + 0.124d 0.015 + 0.233d
Compute
0.01d
0.19
Verify
Verify∗
0.18
Table 4: Costs for the scheme in section 4.2.

5.29
5.95
3.34
3.89
4.76

0.01d
0.11
0.10

8.26
9.62
2.65
5.78
7.46

Linear Combinations

Timing (ms)

Amortized Cost

PCost

Security

80bit

128bit 80bit 128bit

5.35
KeyGen 0.004 + 0.077d 0.007 + 0.111d
0.11d
ProbGen
5.35
0.12d 10.53
Compute
Verify
4.41

0.08d
0.07d
0.14

0.23

5.18
5.18
10.87
4.48

Table 5: Costs for the scheme in section 4.3.

MAC [6] to authenticate each of the 2n ciphertext entries.
However, this would further require to authenticate bigger
circuits: for example, one has to validate at least 4(n log n)
multiplications and 5n additions over Z/qZ for a single mul-
tiplication of two ciphertexts (estimate obtained with FFT;
a trivial method leads to 4n2 multiplications and 5n addi-
tions). In contrast, by applying our homomorphic hash we
can use the same original circuit and the additional cost
of computing the hash becomes negligible. As a concrete
example, computing the variance of a database without ho-
momorphic hashing is 13615 times slower than our scheme
of Section 4.1 (80bit security), as shown in Table 2.
Acknowledgments
The research of Dario Fiore has been partially supported
by the European Commission’s Seventh Framework Pro-
gramme Marie Curie Cofund Action AMAROUT II (grant
no. 291803), and by the Madrid Regional Government under
project PROMETIDOS-CM (ref. S2009/TIC1465). The re-
search of Rosario Gennaro was sponsored by the U.S. Army
Research Laboratory and the U.K. Ministry of Defense and

853was accomplished under Agreement Number W911NF-06-3-
0001. The views and conclusions contained in this document
are those of the author(s) and should not be interpreted as
representing the oﬃcial policies, either expressed or implied,
of the U.S. Army Research Laboratory, the U.S. Govern-
ment, the U.K. Ministry of Defence or the U.K. Government.
The U.S. and U.K. Governments are authorized to reproduce
and distribute reprints for Government purposes notwith-
standing any copyright notation hereon. The research of
Valerio Pastro was supported by NSF Grant No.1017660.

7. REFERENCES
[1] B. Applebaum, Y. Ishai, and E. Kushilevitz. From

secrecy to soundness: Eﬃcient veriﬁcation via secure
computation. In ICALP (1), pages 152–163, 2010.

[2] S. Arora and S. Safra. Probabilistic checking of proofs;

a new characterization of np. In FOCS, pages 2–13.
IEEE Computer Society, 1992.

[3] L. Babai. Trading group theory for randomness. In
R. Sedgewick, editor, STOC, pages 421–429. ACM,
1985.

[4] L. Babai, L. Fortnow, L. A. Levin, and M. Szegedy.
Checking computations in polylogarithmic time. In
C. Koutsougeras and J. S. Vitter, editors, STOC,
pages 21–31. ACM, 1991.

[5] L. Babai, L. Fortnow, and C. Lund. Non-deterministic
exponential time has two-prover interactive protocols.
In FOCS, pages 16–25. IEEE Computer Society, 1990.

[6] M. Backes, D. Fiore, and R. M. Reischuk. Veriﬁable

delegation of computation on outsourced data. In 2013
ACM Conference on Computer and Communication
Security. ACM Press, November 2013.

R. Safavi-Naini and R. Canetti, editors, CRYPTO,
volume 7417 of LNCS, pages 868–886. Springer, 2012.

[15] Z. Brakerski, C. Gentry, and V. Vaikuntanathan.

(leveled) fully homomorphic encryption without
bootstrapping. In S. Goldwasser, editor, ITCS, pages
309–325. ACM, 2012.

[16] Z. Brakerski and V. Vaikuntanathan. Fully

homomorphic encryption from ring-lwe and security
for key dependent messages. In P. Rogaway, editor,
CRYPTO, volume 6841 of Lecture Notes in Computer
Science, pages 505–524. Springer, 2011.

[17] K.-M. Chung, Y. T. Kalai, and S. P. Vadhan.

Improved delegation of computation using fully
homomorphic encryption. In CRYPTO, volume 6223
of LNCS, pages 483–501. Springer, 2010.

[18] G. Cormode, M. Mitzenmacher, and J. Thaler.
Practical veriﬁed computation with streaming
interactive proofs. In Innovations in Theoretical
Computer Science – ITCS, pages 90–112. ACM, 2012.

[19] D. Fiore, R. Gennaro, and V. Pastro. Eﬃciently
veriﬁable computation on encrypted data. IACR
Cryptology ePrint Archive, 2014:202, 2014.

[20] R. Gennaro, C. Gentry, and B. Parno. Non-interactive

veriﬁable computing: Outsourcing computation to
untrusted workers. In T. Rabin, editor, CRYPTO,
volume 6223 of Lecture Notes in Computer Science,
pages 465–482. Springer, 2010.

[21] R. Gennaro, C. Gentry, B. Parno, and M. Raykova.

Quadratic span programs and succinct nizks without
pcps. In T. Johansson and P. Q. Nguyen, editors,
EUROCRYPT, volume 7881 of LNCS, pages 626–645.
Springer, 2013.

[7] M. Bellare, V. T. Hoang, and P. Rogaway. Foundations

[22] R. Gennaro and D. Wichs. Fully homomorphic

of garbled circuits. In ACM Conference on Computer
and Communications Security, pages 784–796, 2012.

[8] E. Ben-Sasson, A. Chiesa, D. Genkin, E. Tromer, and
M. Virza. Snarks for c: Verifying program executions
succinctly and in zero knowledge. In CRYPTO,
volume 8043 of LNCS, pages 90–108. Springer, 2013.

[9] S. Benabbas, R. Gennaro, and Y. Vahlis. Veriﬁable

delegation of computation over large datasets. In
P. Rogaway, editor, CRYPTO, volume 6841 of Lecture
Notes in Computer Science, pages 111–131. Springer,
2011.

[10] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer.

From extractable collision resistance to succinct
non-interactive arguments of knowledge, and back
again. In S. Goldwasser, editor, ITCS, pages 326–349.
ACM, 2012.

[11] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer.
Recursive composition and bootstrapping for snarks
and proof-carrying data. IACR Cryptology ePrint
Archive, 2012. http://eprint.iacr.org/2012/095.

[12] D. Boneh, X. Boyen, and E.-J. Goh. Hierarchical

identity based encryption with constant size
ciphertext. In EUROCRYPT, volume 3494 of LNCS,
pages 440–456. Springer, 2005.

[13] D. Boneh, X. Boyen, and H. Shacham. Short group

signatures. In M. K. Franklin, editor, CRYPTO,
volume 3152 of LNCS, pages 41–55. Springer, 2004.

[14] Z. Brakerski. Fully homomorphic encryption without

modulus switching from classical gapsvp. In

message authenticators. In ASIACRYPT (2), volume
8270 of LNCS, pages 301–320. Springer, 2013.

[23] C. Gentry. Fully homomorphic encryption using ideal

lattices. In STOC, pages 169–178, 2009.

[24] C. Gentry. Toward basing fully homomorphic

encryption on worst-case hardness. In T. Rabin,
editor, CRYPTO, volume 6223 of Lecture Notes in
Computer Science, pages 116–137. Springer, 2010.

[25] C. Gentry and S. Halevi. Implementing gentry’s
fully-homomorphic encryption scheme. In K. G.
Paterson, editor, EUROCRYPT, volume 6632 of
LNCS, pages 129–148. Springer, 2011.

[26] C. Gentry, S. Halevi, and N. P. Smart. Fully

homomorphic encryption with polylog overhead. In
D. Pointcheval and T. Johansson, editors,
EUROCRYPT, volume 7237 of LNCS, pages 465–482.
Springer, 2012.

[27] S. Goldwasser, Y. T. Kalai, R. A. Popa,

V. Vaikuntanathan, and N. Zeldovich. Reusable
garbled circuits and succinct functional encryption. In
STOC, pages 555–564, 2013.

[28] S. Goldwasser, Y. T. Kalai, and G. N. Rothblum.

Delegating computation: interactive proofs for
muggles. In C. Dwork, editor, STOC, pages 113–122.
ACM, 2008.

[29] S. Goldwasser, H. Lin, and A. Rubinstein. Delegation

of computation without rejection problem from
designated veriﬁer CS-proofs. IACR Cryptology ePrint
Archive, 2011:456, 2011.

854[30] S. Goldwasser, S. Micali, and C. Rackoﬀ. The

71–89. Springer, 2013.

knowledge complexity of interactive proof systems.
SIAM J. Comput., 18(1):186–208, 1989.

[31] J. Groth. Short pairing-based non-interactive

zero-knowledge arguments. In ASIACRYPT, pages
321–340, 2010.

[32] S. Halevi and V. Shoup. Helib.

https://github.com/shaih/HElib. Accessed:
2014-05-14.

[33] A. Joux. A new index calculus algorithm with

complexity l(1/4+o(1)) in very small characteristic.
IACR Cryptology ePrint Archive, 2013:95, 2013.

[34] J. Kilian. A note on eﬃcient zero-knowledge proofs

and arguments (extended abstract). In S. R. Kosaraju,
M. Fellows, A. Wigderson, and J. A. Ellis, editors,
STOC, pages 723–732. ACM, 1992.

[35] J. Kilian. Improved eﬃcient arguments (preliminary

version). In D. Coppersmith, editor, CRYPTO,
volume 963 of LNCS, pages 311–324. Springer, 1995.
[36] B. Libert, T. Peters, M. Joye, and M. Yung. Linearly

homomorphic structure-preserving signatures and
their applications. In R. Canetti and J. A. Garay,
editors, CRYPTO (2), volume 8043 of LNCS, pages
289–307. Springer, 2013.

[37] H. Lipmaa. Progression-free sets and sublinear

pairing-based non-interactive zero-knowledge
arguments. In TCC, volume 7194 of LNCS, pages
169–189. Springer, 2012.

[38] B. Lynn. Pbc library.

http://crypto.stanford.edu/pbc/. Accessed:
2014-05-14.

[39] S. Micali. Cs proofs (extended abstracts). In FOCS,

pages 436–453. IEEE Computer Society, 1994.

[40] C. Papamanthou, E. Shi, and R. Tamassia. Signatures
of correct computation. In TCC, pages 222–242, 2013.

[41] B. Parno, J. Howell, C. Gentry, and M. Raykova.

Pinocchio: Nearly practical veriﬁable computation. In
IEEE Symposium on Security and Privacy, pages
238–252. IEEE Computer Society, 2013.

[42] R. Rivest, L. Adleman, and M. Dertouzos. On data
banks and privacy homomorphisms. pages 169–177.
Academic Press, 1978.

[43] S. T. V. Setty, R. McPherson, A. J. Blumberg, and

M. Walﬁsh. Making argument systems for outsourced
computation practical (sometimes). In NDSS, 2012.
[44] S. T. V. Setty, V. Vu, N. Panpalia, B. Braun, A. J.

Blumberg, and M. Walﬁsh. Taking proof-based
veriﬁed computation a few steps closer to practicality.
In USENIX Security Symposium, pages 253–268, 2012.

[45] V. Shoup. Ntl library. http://www.shoup.net/ntl/.

Accessed: 2014-05-14.

[46] N. P. Smart and F. Vercauteren. Fully homomorphic

encryption with relatively small key and ciphertext
sizes. In P. Q. Nguyen and D. Pointcheval, editors,
Public Key Cryptography, volume 6056 of LNCS,
pages 420–443. Springer, 2010.

[47] N. P. Smart and F. Vercauteren. Fully homomorphic

simd operations. IACR Cryptology ePrint Archive,
2011:133, 2011.

[48] J. Thaler. Time-optimal interactive proofs for circuit

evaluation. In CRYPTO, volume 8043 of LNCS, pages

[49] V. Vu, S. Setty, A. Blumberg, and M. Walﬁsh. A

hybrid architecture for interactive veriﬁable
computation. In IEEE Symposium on Security and
Privacy, pages 223–237. IEEE Computer Society,
2013.

APPENDIX
A. STATISTICAL FUNCTIONS

Below, we show how the statistical functions mentioned
in section 5 can be decomposed into simpler non-rational
functions that we can authenticate using our scheme. For
vectors (cid:126)x = (x1, . . . , xt), (cid:126)y = (y1, . . . , yt), we deﬁne the fol-
lowing basic functions:

f1((cid:126)x) = (cid:107)(cid:126)x(cid:107)1 =(cid:80)t

f3((cid:126)x, (cid:126)y) = f1((cid:126)x) · f1((cid:126)y) =(cid:0)(cid:80)t

j=1 xj,

f2((cid:126)x, (cid:126)y) = (cid:104)(cid:126)x, (cid:126)y(cid:105) =(cid:80)t
(cid:1) ·(cid:16)(cid:80)t

i=1 xi

j=1 yj

(cid:17)
j=1 xj · yj,

We now give a description that explains how to use our

scheme in section 4.1 for the following functions:
Average: Authenticate f1((cid:126)x), since

avg((cid:126)x) =(cid:80)t

j=1 xj/t = f1((cid:126)x)/t.

Variance: Authenticate f1((cid:126)x) and f2((cid:126)x, (cid:126)x), since

var((cid:126)x) =(cid:80)t
Standard deviation: Since stdev((cid:126)x) = (cid:112)var((cid:126)x), use the

j=1(xj − avg((cid:126)x))2/t = f2((cid:126)x, (cid:126)x)/t − f1((cid:126)x)2/t2

method for authenticating variance.

Root Mean Square: Authenticate f2((cid:126)x, (cid:126)x), since

(cid:113)(cid:80)t

RMS((cid:126)x) =

j=1 x2

j /t

cov((cid:126)x, (cid:126)y) = ((cid:80)t

Covariance: Authenticate f2((cid:126)x, (cid:126)y) and f3((cid:126)x, (cid:126)y), since
j=1(xj − avg((cid:126)x))(yj − avg((cid:126)y)))/t

= f2((cid:126)x, (cid:126)y)/t − f3((cid:126)x, (cid:126)y)/t2

Linear Regression: Given two sets of observations as two
vectors ((cid:126)x, (cid:126)y), the linear regression of (cid:126)y as a function of (cid:126)x
is deﬁned by two coeﬃcients ˆα, ˆβ such that
f2((cid:126)x, (cid:126)y) − f3((cid:126)x, (cid:126)y)/t
f2((cid:126)x, (cid:126)x) − f1((cid:126)x)/t

ˆβ =
ˆα = avg((cid:126)y) − ˆβ · avg((cid:126)x) = (f1((cid:126)y) − ˆβf1((cid:126)x))/t

cov((cid:126)x, (cid:126)y)

var((cid:126)x)

=

Hence, authenticate f1((cid:126)x), f1((cid:126)y), f2((cid:126)x, (cid:126)y), f2((cid:126)x, (cid:126)x), f3((cid:126)x, (cid:126)y).
Sample Pearson’s correlation coeﬃcient: Authenticate

f1((cid:126)x), f1((cid:126)y), f2((cid:126)x, (cid:126)y), f2((cid:126)x, (cid:126)x), f2((cid:126)y, (cid:126)y), f3((cid:126)x, (cid:126)y), since

r(cid:126)x,(cid:126)y =

=

cov((cid:126)x, (cid:126)y)

stdev((cid:126)x)stdev((cid:126)y)

t(cid:112)(f2((cid:126)x, (cid:126)x)/t − f1((cid:126)x)2/t2)(f2((cid:126)y, (cid:126)y)/t − f1((cid:126)y)2/t2)

f2((cid:126)x, (cid:126)y) − f3((cid:126)x, (cid:126)y)/t

Uncentered correlation coeﬃcient: Authenticate f2((cid:126)x, (cid:126)y),

f2((cid:126)x, (cid:126)x), f2((cid:126)y, (cid:126)y), since

(cid:113)(cid:80)t

(cid:80)t

i=1 xiyi

i ·(cid:113)(cid:80)t

i=1 x2

i=1 y2
i

ru
(cid:126)x,(cid:126)y =

(cid:112)f2((cid:126)x, (cid:126)x)f2((cid:126)y, (cid:126)y)

f2((cid:126)x, (cid:126)y)

=

855