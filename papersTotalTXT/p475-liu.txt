Blackbox Traceable CP-ABE: How to Catch People Leaking

Their Keys by Selling Decryption Devices on eBay

Shanghai Jiao Tong University

Shanghai Jiao Tong University

Zhen Liu

Shanghai, China

City University of Hong Kong
Hong Kong SAR, China
zhenliu7@cityu.edu.hk

Zhenfu Cao
Shanghai, China

zfcao@cs.sjtu.edu.cn

Duncan S. Wong
City University of Hong Kong
Hong Kong SAR, China
duncan@cityu.edu.hk

ABSTRACT
In the context of Ciphertext-Policy Attribute-Based Encryp-
tion (CP-ABE), if a decryption device associated with an
attribute set SD appears on eBay, and is alleged to be able
to decrypt any ciphertexts with policies satisﬁed by SD, no
one including the CP-ABE authorities can identify the mali-
cious user(s) who build such a decryption device using their
key(s). This has been known as a major practicality concern
in CP-ABE applications, for example, providing ﬁne-grained
access control on encrypted data. Due to the nature of CP-
ABE, users get decryption keys from authorities associated
with attribute sets. If there exists two or more users with
attribute sets being the supersets of SD, existing CP-ABE
schemes cannot distinguish which user is the malicious one
who builds and sells such a decryption device. In this pa-
per, we extend the notion of CP-ABE to support Blackbox
Traceability and propose a concrete scheme which is able to
identify a user whose key has been used in building a decryp-
tion device from multiple users whose keys associated with
the attribute sets which are all the supersets of SD. The
scheme is eﬃcient with sub-linear overhead and when com-
pared with the very recent (non-traceable) CP-ABE scheme
due to Lewko and Waters in Crypto 2012, we can consider
this new scheme as an extension with the property of fully
collusion-resistant blackbox traceability added, i.e. an adver-
sary can access an arbitrary number of keys when building a
decryption device while the new tracing algorithm can still
identify at least one particular key which must have been
used for building the underlying decryption device. We show
that this new scheme is secure against adaptive adversaries
in the standard model, and is highly expressive by support-
ing any monotonic access structures. Its additional trace-
ability property is also proven against adaptive adversaries
in the standard model.

As of independent interest, in this paper, we also consider
another scenario which we call it “found-in-the-wild ”. In this
scenario, a decryption device is found, for example, from

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for prof t or commercial advantage and that copies bear this notice and the full cita-
tion on the f rst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior specif c permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’13, November 4–8, 2013, Berlin, Germany.
Copyright 2013 ACM 978-1-4503-2477-9/13/11 ...$15.00.
http://dx.doi.org/10.1145/2508859.2516683.

a black market, and reported to an authority (e.g. a law
enforcement agency). The decryption device is found to be
able to decrypt ciphertexts with certain policy, say A, while
the associated attribute set SD is missing. In this found-in-
the-wild scenario, we show that the Blackbox Traceable CP-
ABE scheme proposed in this paper can still be able to ﬁnd
the malicious users whose keys have been used for building
the decryption device, and our scheme can achieve selective
traceability in the standard model under this scenario.

Categories and Subject Descriptors
E.3 [Data Encryption]: Public key cryptosystems

Keywords
Attribute-Based Encryption; Blackbox Traceability

1.

INTRODUCTION

Ciphertext-Policy Attribute-Based Encryption (CP-ABE),
introduced by Goyal et al. [11], is a versatile one-to-many en-
cryption mechanism which enables ﬁne-grained access con-
trol over encrypted data. Suppose Alice wants to encrypt a
message for all PhD students and alumni in the Department
of Mathematics, but she does not know or is not possible to
ﬁnd out the identities of all the eligible receivers, and the set
of eligible receivers could also be dynamic. Intuitively, Alice,
in this example, is to encrypt a message under “(Mathemat-
ics AND (PhD Student OR Alumni))”, which is an access
policy deﬁned over descriptive attributes, so that only those
receivers who have their decryption keys associated with the
attributes which satisfy this policy can decrypt.

Traditional public key encryption and identity-based en-
cryption [23, 3] are ineﬃcient to realize the requirement in
the example above as they are for one-to-one encryption.
Broadcast Encryption (BE) [8] may not be suitable either
as the encryptor in BE has to know and specify the exact
identities/indices of the receivers. In CP-ABE, an authority
issues diﬀerent decryption keys to each user based on the at-
tributes the user possesses. During encryption, an encryptor
speciﬁes an access policy for the resulting ciphertext. If and
only if a receiver’s attributes satisfy the access policy of the
ciphertext can the receiver decrypt the ciphertext.

Among the CP-ABE schemes recently proposed [2, 7, 10,
24, 15, 20, 12, 16], progress has been made on the schemes’
security, access policy expressivity, and eﬃciency. In [16],
Lewko and Waters proposed a new prooﬁng technique and

475obtained a CP-ABE which is fully secure (i.e. provably se-
cure against adaptive adversaries in the standard model),
highly expressive (i.e. supporting any monotonic access struc-
tures) and eﬃcient, and additionally eliminates the one-use
restriction that previous schemes [15, 20] have. Speciﬁcally,
the security proof in [15, 20] relies on the one-use restriction
that a single attribute can only be used once in a policy, and
directly extending the schemes in [15, 20] to allow attribute
reuse would incur signiﬁcant tradeoﬀs in eﬃciency.

One of the major practicality issues of CP-ABE to date is
the lacking of eﬀective solutions to identify malicious users
which intentionally expose their secret decryption keys, for
example, for ﬁnancial gain. Due to the nature of CP-ABE,
access policies associated with the ciphertexts do not have to
contain the exact identities of the eligible receivers. Instead,
access policies are role-based and the attributes are gener-
ally shared by multiple users. For example, both Bob (with
attributes {Bob, Alumni, Mathematics}) and Tom (with at-
tributes {Tom, Alumni, Mathematics}) could share a de-
cryption key corresponding to attributes {Alumni, Mathe-
matics} and be able to decrypt the ciphertext in the exam-
ple above, while the key has no identity information. As
a result, a malicious user, with his attributes shared with
multiple other users, might have an intention to leak the
corresponding decryption key or some decryption privilege
in the form of a decryption blackbox/device in which the
decryption key is embedded, for example, for ﬁnancial gain
or for some other incentives, as there is little risk of getting
caught.

This is an interesting problem in practice as leaking a de-
cryption key or a more advanced decryption device/blackbox
may entail ﬁnancial gain and even better, the malicious user
has very little risk of getting caught. To address this prob-
lem, we require a CP-ABE system to support traceability.
There are two levels of traceability. Level one is Whitebox
Traceability, by which given a well-formed decryption key as
input, a tracing algorithm can ﬁnd out the user which owns
the key. This also includes a scenario that a malicious user
sells a new well-formed decryption key for ﬁnancial gain, and
the new decryption key is created from his own key.

Level two is Blackbox Traceability, by which given a de-
cryption blackbox/device, while the decryption key and even
the decryption algorithm could be hidden, the tracing algo-
rithm, which treats the decryption blackbox as an oracle,
can still ﬁnd out the malicious user whose key must have
been used in constructing the decryption blackbox.

The problem of building a secure CP-ABE supporting
traceability has recently been studied in [18, 17, 19]. How-
ever, as we will review that an expressive Blackbox Traceable
CP-ABE is yet to be built: (1) the ciphertext access policies
in [18, 17] only support a single AND gate with wildcard; (2)
the traceable CP-ABE in [19] is as fully secure, highly ex-
pressive and eﬃcient as a conventional CP-ABE such as the
one in [15], but it only supports level one Whitebox Trace-
ability, i.e., it deters malicious users from leaking or selling
well-formed decryption keys, but it cannot deter them from
selling decryption blackboxes/devices. Below is an example
on the importance of achieving Blackbox Traceability.

Key-like Decryption Blackbox for Sale. Using his
decryption key (or the decryption keys from multiple col-
luded malicious users), a malicious user builds a decryption
blackbox/device (i.e. a CP-ABE Decryption Blackbox) and
sells it on eBay for ﬁnancial gain. To invalidate the possible

whitebox tracing algorithms, the seller keeps the embedded
decryption keys and (possibly complicated) algorithms hid-
den and the device works as a decryption blackbox. Then, to
attract potential buyers, the seller describes and advertises
that the decryption blackbox functions like a decryption key
associated with an attribute set SD, i.e., if a ciphertext ac-
cess policy can be satisﬁed by SD, the device can decrypt
the ciphertext. For simplicity, we call such a decryption
blackbox as a key-like decryption blackbox . In practice,
such a key-like decryption blackbox could be quite useful
and deemed to be very attractive to potential buyers, and
the resulting ﬁnancial gain could be a big incentive for ma-
licious users to build and sell such a blackbox.

1.1 Our Results

In this paper, we propose a new CP-ABE which is fully
secure (i.e. provably secure against adaptive adversaries in
the standard model), highly expressive (i.e. supporting any
monotonic access structures), and blackbox traceable. Fur-
thermore, this new CP-ABE achieves fully collusion-resistant
blackbox traceability, that is, the tracing algorithm can ﬁnd
out at least one of the malicious users even if there are an ar-
bitrary number of malicious users colluding by pulling all of
their decryption keys together when building a key-like de-
cryption blackbox. Note that collusion-resistant traceability
is orthogonal to collusion-resistant security, which is the pri-
mary requirement of CP-ABE. In this paper, traceability is
regarded as an additional feature besides the traditional CP-
ABE full security, high expressivity and eﬃciency.

In addition, the traceability of the scheme is public, that
is, anyone can run the tracing algorithm with no additional
secret needed. When compared with the most eﬃcient con-
ventional (non-traceable) highly expressive CP-ABE cur-
rently available, this new scheme adds the public and fully
collusion-resistant blackbox traceability with the price of

adding only O(√K) elements in the ciphertext and public
key, rather than expanding the sizes linearly with K, where
K is the number of users in the system, while the private
key size and decryption eﬃciency mainly remain compara-
ble and are independent of the value of K.
To the best of our knowledge, this is the ﬁrst CP-ABE that
simultaneously supports public and fully collusion-resistant
blackbox traceability, full security, high expressivity, and
without the one-use restriction, and for a system with fully
collusion-resistant blackbox traceability, sub-linear overhead
is the most eﬃcient one to date. Table 1.1 compares our
scheme with that in [15, 16, 19] in terms of performance
and features (i.e. traceability and one-use restriction), as all
the four schemes are fully secure and highly expressive.

In Sec. 2, following the standard deﬁnition of conventional
CP-ABE, we give a ‘functional’ deﬁnition of CP-ABE, in
which we specify a unique index k ∈ {1, . . . ,K} to each
decryption key, that later will enable us to deﬁne a trac-
ing algorithm Trace which supports fully collusion-resistant
blackbox traceability against key-like decryption blackbox.
We call the resulting scheme a Blackbox Traceable CP-ABE
(or BT-CP-ABE for short).

On the construction of BT-CP-ABE, instead of build-
ing one directly, we ﬁrst deﬁne a simpler primitive called
Augmented CP-ABE (or AugCP-ABE for short), then we
extend it to BT-CP-ABE. In Sec. 3.1, we deﬁne AugCP-
ABE as (SetupA, KeyGenA, EncryptA, DecryptA), which is sim-
ilar to BT-CP-ABE, except that the encryption algorithm

476Ciphertext Private Key Public Key Pairing Computation

Traceability

Without One-Use

[15]
[16]
[19]

this work

Size
2l + 2
2l + 3
2l + 3
2l

+17√K

Size
|S| + 2
|S| + 3
|S| + 4
|S| + 4

Size
|U| + 3
|U| + 4
|U| + 4
|U| + 3
+4√K

in Decryption

2|I| + 1
2|I| + 2
2|I| + 1
2|I| + 10

No
No

whitebox

public, blackbox,

fully collusion-resistant

Restriction

×
√
×
√

1 All the four schemes are fully secure and highly expressive (i.e. supporting any monotonic access structures).
2 Let l be the size of an access policy, |S| the size of the attribute set of a private key, |U| the size of the attribute universe,
and |I| the number of attributes in a decryption key that satisﬁes a ciphertext’s access policy.

Table 1: Comparison with the conventional CP-ABE in [15, 16] and the traceable CP-ABE in [19]

EncryptA(PP, M, A, ¯k) takes one more parameter ¯k ∈ {1, . . . ,
K+1}, and the encrypted message M can be recovered using
a decryption key SKk,S, which is identiﬁed by k ∈ {1, . . . ,K}
and described by an attribute set S, provided that (k ≥
¯k) ∧ (S satisﬁes A), where A is an access policy. Also, we
deﬁne the security of AugCP-ABE using message-hiding and
(encryption) index-hiding games. In Sec. 3.2, we show how
to transform an AugCP-ABE scheme with message-hiding
and index-hiding properties to a fully secure BT-CP-ABE
scheme. In Sec. 4, we propose an eﬃcient and highly expres-
sive AugCP-ABE scheme, and show that it is message-hiding
and index-hiding against adaptively adversaries in the stan-
dard model. Combining it with the result in Sec. 3.2, we
obtain an eﬃcient, fully secure and highly expressive BT-
CP-ABE scheme.

In Sec. 5, we consider the blackbox traceability for another
type of decryption blackboxes, which we refer to as policy-
speciﬁc decryption blackbox . A policy-speciﬁc decryption
blackbox is a decryption blackbox that is able to decrypt ci-
phertexts with some speciﬁc access policy, say AD. In other
words, unlike a key-like decryption blackbox which has an
attribute set, for example, SD attached as the alleged de-
cryption capability as the blackbox advertised by the seller,
a policy-speciﬁc decryption blackbox is only known to be
able to decrypt ciphertexts with some speciﬁc policy AD.
The policy-speciﬁc decryption blackbox reﬂects a diﬀerent
(and possibly more sophisticated) attacking scenario which
we call it “found-in-the-wild.” In this scenario, a decryption
blackbox is found, for example, from a black market, and
reported to an authority which could be a law enforcement
agency. The decryption blackbox’s associated attribute set
SD is missing as it is “found-in-the-wild” while after some
testing, it is found that the blackbox can decrypt ciphertexts
with certain access policy, say AD. Interestingly, we show
that our BT-CP-ABE scheme is also traceable (where the
traceability deﬁnition needs to be modiﬁed accordingly, the
modiﬁcation is minor) against this policy-speciﬁc decryp-
tion blackbox, although the traceability can only be proven
against selective adversaries.

2. DEFINITIONS

We ﬁrst review the deﬁnition of CP-ABE which is based
on the work of [15, 16] with the exception that in our ‘func-
tional’ deﬁnition, we explicitly assign and identify users us-
ing unique indices, and let K be the number of users in a
CP-ABE system. Then we introduce the traceability deﬁni-
tion against key-like decryption blackbox. Predeﬁning the
number of users is indeed a weakness as well as a neces-

sary cost for achieving blackbox traceability, but we stress
that in practice, this should not incur much concern, and
all the existing blackbox traceable systems (e.g.
[14, 5, 6,
9]) have the same setting. Also being consistent with the
conventional deﬁnition of CP-ABE [15, 16], the user indices
are not used in normal encryption (i.e. the encryptors do
not need to know the indices of any users in order to en-
crypt) and diﬀerent users (with diﬀerent indices) may have
the same attribute set.
2.1 CP-ABE and Security Models

A Ciphertext-Policy Attribute-Based Encryption (CP-ABE)

system consists of four algorithms:

Setup(λ,U, K) → (PP, MSK). The algorithm takes as in-
put a security parameter λ, the attribute universe U,
and the number of users K in the system, then runs in
polynomial time in λ, and outputs the public parame-
ter PP and a master secret key MSK.

KeyGen(PP, MSK, S) → SKk,S. The algorithm takes as in-
put the public parameter PP, the master secret key
MSK, and an attribute set S, and outputs a private
decryption key SKk,S, which is assigned and identiﬁed
by a unique index k ∈ {1, . . . ,K}.
Encrypt(PP, M, A) → CT . The algorithm takes as input
the public parameter PP, a message M , and an access
policy A over U, and outputs a ciphertext CT such
that only users whose attributes satisfy A can recover
M . A is implicitly included in CT .

Decrypt(PP, CT, SKk,S) → M or ⊥. The algorithm takes
as input the public parameter PP, a ciphertext CT ,
and a private key SKk,S.
If S satisﬁes CT ’s access
policy, the algorithm outputs a message M , otherwise
it outputs ⊥ indicating the failure of decryption.

Now we deﬁne the security of a CP-ABE system using
a message-hiding game, which is a typical semantic security
game and is based on that for conventional CP-ABE [15,
16] security against adaptive adversaries, except that each
key is identiﬁed by a unique index. Although the index of
each user is assigned by the KeyGen algorithm, to capture
the security that an attacker can adaptively choose keys to
corrupt, we allow the adversary to specify the index when
he makes a key query, i.e., to query a private decryption
key for an attribute set S, the adversary submits (k, S) to
the challenger, where k is the index to be assigned to the
corresponding decryption key.

It is worth noticing that: (1) for clarity, for i = 1 to q, the
adversary submits (index, attribute set) pair (ki, Ski ) to query a

477private key for attribute set Ski , where q ≤ K, ki ∈ {1, . . . ,K},
and ki 6= kj ∀1 ≤ i 6= j ≤ q (this is to guarantee that each
user/key can be uniquely identiﬁed by an index); and (2) for
ki 6= kj we do not require Ski 6= Skj , i.e., diﬀerent users/keys
may have the same attribute set. We remark that these two
points apply to the rest of the paper.

public parameter PP to A.
and the challenger responds with SKki,Ski

GameMH. The Message-hiding game is deﬁned between a
challenger and an adversary A as follows:
Setup. The challenger runs Setup(λ,U, K) and gives the
Phase 1. For i = 1 to q1, A adaptively submits (ki, Ski ),
Challenge. A submits two equal-length messages M0, M1
and an access policy A∗. The challenger ﬂips a random
coin b ∈ {0, 1}, and gives A an encryption of Mb under
A∗.
Phase 2. For i = q1+1 to q, A adaptively submits (ki, Ski ),
Guess. A outputs a guess b′ ∈ {0, 1} for b.
A wins the game if b′ = b under the restriction that
A∗ cannot be satisﬁed by any of the queried attribute sets
Sk1 , . . . , Skq . The advantage of A is deﬁned as MHAdvA =
| Pr[b′ = b] − 1
2|.

and the challenger responds with SKki,Ski

.

.

Definition 1. A K-user CP-ABE system is secure if for
all polynomial-time adversaries A the advantage MHAdvA
is negligible in λ.

It is clear that a secure CP-ABE system deﬁned as above
has all the appealing properties that a conventional CP-ABE
system [15, 16] has, that is, fully collusion-resistant security,
ﬁne-grained access control on encrypted data, and eﬃcient
one-to-many encryption.
2.2 BT-CP-ABE: Traceability

Now we deﬁne the traceability against key-like decryption
blackbox, and call the new system a Blackbox Traceable CP-
ABE (or BT-CP-ABE for short). Our deﬁnition is loosely
related to the traitor tracing feature in broadcast encryp-
tion [6, 9]. A key-like decryption blackbox D in our setting
is viewed as a probabilistic circuit that takes as input a ci-
phertext CT and outputs a message M or ⊥, and such a
decryption blackbox does not need to be perfect, namely,
we only require it to be able to decrypt with non-negligible
success probability. In particular, the adversary (i.e. seller)
describes a key-like decryption blackbox D with a non-empty
attribute set SD and a non-negligible probability value ǫ (i.e.
0 < ǫ ≤ 1 is polynomially related to λ), and advertises that
for any access policy A, if it can be satisﬁed by SD, this
blackbox D can decrypt the corresponding ciphertext associ-
ated with A with probability at least ǫ. Note that ǫ is the
lower-bound of D’s decryption ability, e.g., suppose A1 is a
ciphertext’s access policy satisﬁed by SD and D can decrypt
the ciphertext with probability 0.1, even if D can decrypt
ciphertexts under other valid access policies (satisﬁed by D)
with probability 1, the seller can only declare an ǫ ≤ 0.1.
Obviously for some attribute set SD, ǫ is closer to 1, which
implies that the decryption ability of D is closer to that of
a private key with attribute set SD, and hence D is more
attractive to potential buyers who are interested in decrypt-
ing ciphertexts with access policies which can be satisﬁed by
SD. We now deﬁne a tracing algorithm as follows.

TraceD(PP, SD, ǫ) → KT ⊆ {1, . . . ,K}. This is an oracle al-
gorithm that interacts with a key-like decryption blackbox D.
By given the public parameter PP, a non-empty attribute set
SD, and a probability value (lower-bound) ǫ, the algorithm
runs in time polynomial in λ and 1/ǫ, and outputs an index
set KT ⊆ {1, . . . ,K} which identiﬁes the set of malicious
users. Note that ǫ has to be polynomially related to λ.

The following Tracing Game captures the notion of fully
collusion-resistant traceability. In the game, the adver-
sary targets to build a decryption blackbox D that functions
as a private decryption key with attribute set SD (as the
name of key-like decryption blackbox implies). The tracing
algorithm, on the other side, is designed to extract the index
of at least one of the malicious users whose decryption keys
have been used for constructing D.
GameTR. The Tracing Game is deﬁned between a challenger
and an adversary A as follows:
Setup. The challenger runs Setup(λ,U,K) and gives the
Key Query. For i = 1 to q, A adaptively submits (ki, Ski ),

public parameter PP to A.
and the challenger responds with SKki,Ski

.

(Key-like) Decryption Blackbox Generation. A out-
puts a decryption blackbox D associated with a non-
empty attribute set SD ⊆ U and a non-negligible prob-
ability (lower-bound) value ǫ.
Tracing. The challenger runs TraceD(PP, SD, ǫ) to obtain

an index set KT ⊆ {1, . . . ,K}.

Let KD = {ki|1 ≤ i ≤ q} be the index set of keys cor-
rupted by the adversary. We say that the adversary A wins
the game if the following conditions hold:

1. For any access policy A that is satisﬁed by SD, we have

Pr[D(Encrypt(PP, M, A)) = M ] ≥ ǫ,

where the probability is taken over the random choices
of message M and the random coins of D. A decryp-
tion blackbox satisfying this condition is said to be a
useful key-like decryption blackbox.

2. KT = ∅, or KT 6⊆ KD, or (SD 6⊆ Skt ∀kt ∈ KT ).

We denote by TRAdvA the probability that adversary A
wins this game.

Definition 2. A K-user Blackbox Traceable CP-ABE sys-
tem is traceable if for all polynomial-time adversaries A the
advantage TRAdvA is negligible in λ.

Remark: For a useful key-like decryption blackbox D, the
traced KT must satisfy (KT 6= ∅) ∧ (KT ⊆ KD) ∧ (∃kt ∈
KT s.t. Skt ⊇ SD) for traceabililty. (1) (KT 6= ∅) ∧ (KT ⊆
KD) captures the preliminary traceability that the tracing
algorithm can extract at least one malicious user and the
coalition of malicious users cannot frame any innocent user.
Note that such a preliminary traceability is a weak trace-
ability that may not be useful enough in practice. Speciﬁ-
cally, consider a key-like decryption blackbox D built from
the private decryption keys of users k1 and k2 who were
authorized high-value attribute set Sk1 and low-value at-
tribute set Sk2 , respectively, and assume that Sk2 6⊇ Sk1
and the decryption ability of D is described by SD = Sk1 ,

478e.g., SD = Sk1 = {Senior Manager}, and Sk2 = {Intern}.
A scheme is considered to be weak traceable if its Trace
algorithm only extracts k2 from D as the malicious user.
This may not be satisfactory in practice as D having the
decryption ability of attribute set {Senior Manager} implies
that there must be some user having attribute “Senior Man-
ager” participated in building D yet the algorithm was only
able to trace D to an “Intern”, who has less to lose.
(2)
(∃kt ∈ KT s.t. Skt ⊇ SD) captures strong traceability that
the Trace algorithm can extract at least one malicious user
whose private key enables D to have the decryption ability
corresponding to SD, i.e., whose attribute set is a super-
set of SD. As a related work, comparable weak and strong
traceability notions in the setting of predicate encryption
were considered in [14]. In this paper we focus on the strong
traceability of CP-ABE, and unless stated otherwise, by the
traceability we mean the strong traceability.

Note that the tracing game above does not limit the num-
ber of colluded users. Also note that, as of [5, 6, 9, 14], we
are modeling a stateless (resettable) decryption blackbox –
the decryption blackbox is just an oracle and maintains no
state between activations.

3. AUGMENTED CP-ABE

Following the routes of [5, 6, 9], instead of constructing
a BT-CP-ABE directly, we deﬁne a simpler primitive called
Augmented CP-ABE (or AugCP-ABE for short) and its se-
curity notions ﬁrst, then we show that a secure AugCP-ABE
can be transformed to a secure and traceable BT-CP-ABE
scheme.
In Sec. 4, we propose a concrete construction of
AugCP-ABE.
3.1 Def nitions

An AugCP-ABE system consists of the following four al-
gorithms, in particular, diﬀerent from a conventional CP-
ABE, the encryption algorithm takes one more parameter
¯k ∈ {1, . . . ,K + 1}.
SetupA(λ,U,K) → (PP, MSK). The algorithm takes as in-
put a security parameter λ, the attribute universe U,
and the number of users K in the system, then runs in
polynomial time in λ, and outputs the public parame-
ter PP and a master secret key MSK.

KeyGenA(PP, MSK, S) → SKk,S. The algorithm takes as in-
put PP, the master secret key MSK, and an attribute
set S, and outputs a private key SKk,S, which is as-
signed and identiﬁed by a unique index k ∈ {1, . . . ,K}.
EncryptA(PP, M, A, ¯k) → CT . The algorithm takes as input
PP, a message M , an access policy A over U, and an
index ¯k ∈ {1, . . . ,K+1}, and outputs a ciphertext CT .
A is included in CT , but the value of ¯k is not.
DecryptA(PP, CT, SKk,S) → M or ⊥. The algorithm takes
as input PP, a ciphertext CT , and a private key SKk,S.
If S satisﬁes CT ’s access policy, the algorithm outputs
a message M , otherwise it outputs ⊥ indicating the
failure of decryption.

Correctness. For any attribute set S ⊆ U, k ∈ {1, . . . ,K},
access policy A over U, ¯k ∈ {1, . . . ,K + 1}, and message M ,
suppose (PP, MSK) ← SetupA(λ,U,K), SKk,S ← KeyGenA(
PP, MSK, S), CT ← EncryptA(PP, M, A, ¯k). If (S satisﬁes A)
∧(k ≥ ¯k) then DecryptA(PP, CT, SKk,S) = M .

It is worth noticing that during decryption if the attribute
set S of a private decryption key satisﬁes the access policy A
of a ciphertext, the decryption works, regardless of the value
of key index k or encryption index ¯k, but whether the output
message is equal to the encrypted message is determined by
the values of k and ¯k.
i.e., if and only if (S satisﬁes A) ∧
(k ≥ ¯k), can SKk,S correctly decrypt a ciphertext encrypted
using (A, ¯k). Note that if we always set ¯k = 1, then the
functions of AugCP-ABE are identical to that of BT-CP-
ABE. Actually, the idea behind converting an AugCP-ABE
scheme to a BT-CP-ABE scheme is to construct an AugCP-
ABE scheme with (encryption) index-hiding property, and
then always set ¯k = 1 in normal encryption, while use ¯k ∈
{1, . . . , K + 1} in generating ciphertexts for tracing.
Security. We deﬁne the security of AugCP-ABE in the fol-
lowing three games, where the ﬁrst two are for message-
hiding, and the third one is for the index-hiding property.
In the ﬁrst two message-hiding games between a chal-
lenger and an adversary A, ¯k = 1 (the ﬁrst game, GameA
MH1 )
and ¯k = K + 1 (the second game, GameA
Setup. The challenger runs SetupA(λ,U, K) and gives the
Phase 1. For i = 1 to q1, A adaptively submits (ki, Ski ),
Challenge. A submits two equal-length messages M0, M1
and an access policy A∗. The challenger ﬂips a random
coin b ∈ {0, 1}, and sends CT ← EncryptA(PP, Mb, A∗, ¯k)
to A.
Phase 2. For i = q1 + 1 to q, A adaptively submits
.
(ki, Ski ), and the challenger responds with SKki,Ski
Guess. A outputs a guess b′ ∈ {0, 1} for b.
GameA
MH1 . In the Challenge phase the challenger sends CT ←
EncryptA(PP, Mb, A∗, 1) to A. A wins the game if b′ = b un-
der the restriction that A∗ cannot be satisﬁed by any of
the queried attribute sets Sk1 , . . . , Skq . The advantage of A
is deﬁned as MHA

public parameter PP to A.
and the challenger responds with SKki,Ski

MHK+1 ).

.

1 AdvA = | Pr[b′ = b] − 1
2|.

MHK+1 .

GameA
In the Challenge phase the challenger sends
CT ← EncryptA(PP, Mb, A∗,K + 1) to A. A wins the game
if b′ = b. The advantage of A is deﬁned as MHA
K+1AdvA =
| Pr[b′ = b] − 1
2|.

Definition 3. A K-user Augmented CP-ABE system is
message-hiding if for all polynomial-time adversaries A the
advantages MHA
K+1AdvA are negligible in λ.

1 AdvA and MHA

GameA
IH. In the third game, index-hiding game, for any
non-empty attribute set S∗ ⊆ U, we deﬁne the strictest
access policy as AS ∗ = Vx∈S ∗ x, and require that an
adversary cannot distinguish between an encryption using
(AS ∗, ¯k) and (AS ∗, ¯k + 1) without a private decryption key
where S¯k ⊇ S∗. The game takes as input a parame-
SK¯k,S¯k
ter ¯k ∈ {1, . . . ,K} which is given to both the challenger and
the adversary A. The game proceeds as follows:
Setup. The challenger runs SetupA(λ,U, K) and gives the
Key Query. For i = 1 to q, A adaptively submits (ki, Ski ),

public parameter PP to A.
and the challenger responds with SKki,Ski

.

479Challenge. A submits a message M and a non-empty
attribute set S∗. The challenger ﬂips a random coin
b ∈ {0, 1}, and sends CT ← EncryptA(PP, M, AS ∗, ¯k +
b) to A.

Guess. A outputs a guess b′ ∈ {0, 1} for b.
A wins the game if b′ = b under the restriction that
none of the queried pairs {(ki, Ski )}1≤i≤q can satisfy (ki =
¯k) ∧ (Ski satisﬁes AS ∗), i.e.
(ki = ¯k) ∧ (Ski ⊇ S∗). The
advantage of A is deﬁned as IHAAdvA[¯k] = | Pr[b′ = b] − 1
2|.
Definition 4. A K-user Augmented CP-ABE system is
index-hiding if for all polynomial-time adversaries A the ad-
vantages IHAAdvA[¯k] for ¯k = 1, . . . ,K are negligible in λ.
3.2 Reducing BT-CP-ABE to AugCP-ABE

We now show that an AugCP-ABE with message-hiding
and index-hiding implies a secure and traceable BT-CP-
ABE. Let ΣA = (SetupA, KeyGenA, EncryptA, DecryptA) be
an AugCP-ABE with message-hiding and index-hiding, de-
ﬁne Encrypt(PP, M, A) = EncryptA(PP, M, A, 1), then Σ =
(SetupA, KeyGenA, Encrypt, DecryptA) is a BT-CP-ABE de-
rived from ΣA, and the tracing algorithm is deﬁned as
TraceD(PP, SD, ǫ) → KT ⊆ {1, . . . ,K}: Given a key-like de-
cryption blackbox D associated with a non-empty attribute
set SD and probability ǫ > 0, the tracing algorithm works
as follows: 1

1. For k = 1 to K + 1, do the following:

(a) The algorithm repeats the following 8λ(K/ǫ)2 times:
i. Sample M from the message space at random.
ii. Let CT ← EncryptA(PP, M, ASD , k), where
iii. Query oracle D on input CT which contains
ASD , and compare the output of D with M .
(b) Let ˆpk be the fraction of times that D decrypted

ASD is the strictest access policy of SD.

the ciphertexts correctly.

2. Let KT be the set of all k ∈ {1, . . . ,K} for which ˆpk −
ˆpk+1 ≥ ǫ/(4K). Then output KT as the index set of
the private decryption keys of malicious users.

Remark: Note that the strictest access policy used in the
index-hiding game GameA
IH and the tracing algorithm Trace
does not impose any limitation to traceable CP-ABE. In-
stead, it is an eﬃcient way to ensure that the traced mali-
cious users are the reasonable suspects. As a key-like decryp-
tion blackbox D is advertised that it functions like a private
decryption key with attribute set SD, a ciphertext associ-
ated with the strictest access policy ASD will be decrypted
by D accordingly. Although it might look more appealing
to have the index-hiding property for any access policy, the
following Theorem 1 shows that the strictest access policy
is suﬃcient for ensuring the traceability against key-like de-
cryption blackbox for the derived BT-CP-ABE scheme.

Theorem 1. If ΣA is an AugCP-ABE with message-hiding
and index-hiding properties, then Σ is a secure and traceable
BT-CP-ABE.

1The tracing algorithm uses a technique based on that in
broadcast encryption by [5, 6, 9].

Proof. Note that Σ is a special case of ΣA where the
encryption algorithm always sets ¯k = 1. Hence, GameMH
for Σ is identical to GameA
MH1 for ΣA, which implies that
MHAdvA for Σ in GameMH is equal to MHA
1 AdvA for ΣA in
GameA
MH1 ), then Σ
is secure.

MH1 , i.e., if ΣA is message-hiding (in GameA

Now we show that if ΣA is message-hiding (in GameA

MHK+1 )
and index-hiding, Σ is traceable. In the proof sketch below,
which is based on that of [5, 6, 9], we show that if the key-
like decryption blackbox output by the adversary is a useful
one then the traced KT will satisfy (KT 6= ∅)∧ (KT ⊆ KD)∧
(∃kt ∈ KT s.t. Skt ⊇ SD) with overwhelming probability,
which implies that the adversary can win the game GameTR
only with negligible probability, i.e., TRAdvA is negligible.
Let D be the key-like decryption blackbox output by the
adversary, and SD be the attribute set describing D. Deﬁne

p¯k = Pr[D(EncryptA(PP, M, ASD , ¯k)) = M ],

For any k ∈ KT (i.e., ˆpk − ˆpk+1 ≥ ǫ

where the probability is taken over the random choice of
message M and the random coins of D. We have that p1 ≥ ǫ
and pK+1 is negligible. The former follows the fact that D is
a useful key-like decryption blackbox, and the later follows
that ΣA is message-hiding (in GameA
MHK+1 ). Then there must
exist some k ∈ {1, . . . ,K} such that pk − pk+1 ≥ ǫ/(2K).
By the Chernoﬀ bound it follows that with overwhelming
probability, ˆpk − ˆpk+1 ≥ ǫ/(4K). Hence, we have KT 6= ∅.
4K ), we know, by
Chernoﬀ, that with overwhelming probability pk − pk+1 ≥
ǫ/(8K). Clearly (k ∈ KD) ∧ (Sk ⊇ SD) since otherwise, D
can be directly used to win the index-hiding game for ΣA.
Hence, we have (KT ⊆ KD) ∧ (SD ⊆ Sk ∀k ∈ KT ).
4. AN EFFICIENT AUGMENTED CP-ABE
Now we construct an AugCP-ABE scheme that is as se-
cure and expressive as the CP-ABE scheme in [16]. To ob-
tain traceability in the derived BT-CP-ABE scheme we will
use the standard tracing techniques which were used by [5,
6, 9] in the setting of broadcast encryption. The challenge
is to apply the tracing techniques to the setting of CP-ABE
securely and eﬃciently.
4.1 Preliminaries

Before proposing a concrete construction for AugCP-ABE,

we ﬁrst review some preliminaries.

Linear Secret-Sharing Schemes. As of previous work,
we use linear secret-sharing schemes (LSSS) to realize mono-
tonic access structures which specify the access policies as-
sociated with ciphertexts. The formal deﬁnitions of access
structures and LSSS can be found in [24, 15, 16]. Informally,
an LSSS is a share-generating matrix A whose rows {Ai} are
labeled by attributes through a function ρ. When we con-
sider the column vector ~v = (s, r2, . . . , rn), where s ∈ Zp is
the secret to be shared and r2, . . . , rn ∈ Zp are randomly
chosen, A~v is the vector of l shares of the secret s, and the
share λi = (A~v)i, i.e. the inner product Ai · ~v, belongs to
attribute ρ(i). A user’s attribute set S satisﬁes the LSSS
access matrix if the rows labeled by the attributes in S have
the linear reconstruction property, which means that there
exist constants {ωi} such that, for any valid shares {λi} of a
secret s according to the LSSS matrix, we have Pi ωiλi = s.
Essentially, a user will be able to decrypt a ciphertext with

480access matrix A if and only if the rows of A labeled by the
user’s attributes include the vector (1, 0, . . . , 0) in their span.
Composite Order Bilinear Groups. Let G be a group
generator, which takes a security parameter λ and outputs
(p1, p2, p3, G, GT , e) where p1, p2, p3 are distinct primes, G
and GT are cyclic groups of order N = p1p2p3, and e :
G×G → GT a map such that: (1) (Bilinear) ∀g, h ∈ G, a, b ∈
ZN , e(ga, hb) = e(g, h)ab, (2) (Non-Degenerate) ∃g ∈ G such
that e(g, g) has order N in GT . Assume that group opera-
tions in G and GT as well as the bilinear map e are com-
putable in polynomial time with respect to λ. Let Gp1 , Gp2
and Gp3 be the subgroups of order p1, p2 and p3 in G, re-
spectively. These subgroups are “orthogonal” to each other
if hi ∈ Gpi and hj ∈ Gpj for
under the bilinear map e:
i 6= j, then e(hi, hj) = 1 (the identity element in GT ). More
details can be found in [15, 16].

Complexity Assumptions. The message-hiding property
of our AugCP-ABE scheme will rely on four assumptions
(the Assumption 1 in [16], the General Subgroup Decision
Assumption, the 3-Party Diﬃe-Hellman Assumption in a
Subgroup, and the Source Group q-Parallel BDHE Assump-
tion in a Subgroup), which are used in [16] to achieve full
security of their CP-ABE scheme while eliminating the one-
use restriction. The index-hiding property will rely on two
assumptions (3-Party Diﬃe-Hellman Assumption and Deci-
sional Linear Assumption) that are used in [6] to achieve
traceability in the setting of broadcast encryption. We refer
to [16, 6] for the details of these assumptions.
Notations. Suppose the number of users K in the sys-
tem equals m2 for some m 2. We arrange the users in
an m × m matrix and uniquely assign a tuple (i, j) where
1 ≤ i, j ≤ m, to each user. A user at position (i, j) of the
matrix has index k = (i − 1) ∗ m + j. For simplicity, we
directly use (i, j) as the index where (i, j) ≥ (¯i, ¯j) means
that ((i > ¯i) ∨ (i = ¯i ∧ j ≥ ¯j)). The use of pairwise notation
(i, j) is purely a notational convenience, as k = (i − 1) ∗
m + j deﬁnes a bijection between {(i, j)|1 ≤ i, j ≤ m} and
{1, . . . ,K}. For a positive integer, say m, by [m] we mean
the set {1, 2, . . . , m}. For a given vector ~v = (v1, . . . , vd), by
g~v we mean the vector (gv1 , . . . , gvd). Furthermore, for g~v =
(gv1 , . . . , gvd) and g ~w = (gw1 , . . . , gwd ), by g~v · g ~w we mean
the vector (gv1+w1 , . . . , gvd+wd ), i.e. g~v · g ~w = g~v+ ~w, and
by ed(g~v, g ~w) we mean Qd
k=1 e(gvk , gwk ), i.e. ed(g~v, g ~w) =
Qd
k=1 e(gvk , gwk ) = e(g, g)(~v· ~w) where (~v · ~w) is the inner
product of ~v and ~w. Given a bilinear group order N , one can
randomly choose rx, ry, rz ∈ ZN , and set ~χ1 = (rx, 0, rz),
~χ2 = (0, ry, rz), ~χ3 = ~χ1 × ~χ2 = (−ryrz,−rxrz, rxry). Let
span{~χ1, ~χ2} be the subspace spanned by ~χ1 and ~χ2, i.e.
span{~χ1, ~χ2} = {ν1 ~χ1 + ν2 ~χ2|ν1, ν2 ∈ ZN}. We can see that
~χ3 is orthogonal to the subspace span{~χ1, ~χ2} and Z3
N =
span{~χ1, ~χ2, ~χ3} = {ν1 ~χ1 + ν2 ~χ2 + ν3 ~χ3|ν1, ν2, ν3 ∈ ZN}.
For any ~v ∈ span{~χ1, ~χ2}, we have (~χ3 · ~v) = 0, and for
random ~v ∈ Z3
N , (~χ3 · ~v) 6= 0 occurs with overwhelming
probability.
4.2 Our Approach

Note that the Traitor Tracing schemes in broadcast en-
cryption [5, 6, 9] achieved fully collusion-resistant blackbox
traceability at the cost of sub-linear overhead, which is the

2If the number of users is not a square, we add some
“dummy” users to pad to the next square.

most eﬃcient level to date. It will be tempting to try in a
straightforward way to combine such a Traitor Tracing sys-
tem and a CP-ABE for obtaining a BT-CP-ABE. However,
the resulting system cannot achieve the desired security (i.e.
strong traceability). Consider the following (misguided) ap-
proach. Suppose that we created both a CP-ABE and a
Traitor Tracing system each for K users, where each user
has the same index in both systems. To encrypt a mes-
sage M , an algorithm splits the message randomly into two
pieces MP and MI such that MP · MI = M , then encrypts
MP under CP-ABE and MI under the Traitor Tracing sys-
tem. To decrypt, we need to decrypt under both systems.
However, such an approach can only provide weak traceabil-
ity3. In particular, if two users, Alice with attribute set SA
in CP-ABE and index kA in both systems, and Bob with
attribute set SB in CP-ABE and index kB in both systems,
collude to make a decryption blackbox D with attribute set
SD ⊆ SA, while SB ∩ SA = ∅. The blackbox uses Alice’s key
(the part corresponding to SA) to decrypt the ciphertext
from the CP-ABE system and Bob’s key (the part corre-
sponding to kB) to decrypt the ciphertext from the Traitor
Tracing system. The tracing algorithm would identify Bob
as a malicious user, but SB is uncorrelated to SD.

The idea behind the techniques of achieving strong trace-
ability is to set a user’s private decryption key such that it
must be simultaneously used in both CP-ABE and the Trac-
ing part in a BT-CP-ABE. Boneh and Waters [6] handled
a similar situation where they intertwined a broadcast en-
cryption scheme [4] and a Traitor Tracing scheme [5] to build
an Augmented Broadcast Encryption (AugBE) scheme. In-
spired by their approach, we tried to intertwin a CP-ABE
[16] and a Traitor Tracing system [9] to build an AugCP-
ABE scheme. The obstacle comes from the setting that in
CP-ABE the decryption privilege of a user is determined by
his attributes rather than by his index as in broadcast en-
cryption. In particular, in AugBE [6, 9], the indices of users
are simultaneously used to determine users’ decryption priv-
ilege (for broadcast encryption part) and to identify users
(for Tracing), and the construction and the proof of index-
hiding of AugBE [6, 9] are based on this fact. In contrast,
in BT-CP-ABE, the attributes are used to determine users’
decryption privilege (for CP-ABE part) while the indices are
used to identify users (for Tracing part), and to intertwine
the two essentially uncorrelated parts, we need new ideas
and techniques.

A straightforward combination will result in schemes that
are either not provable or ineﬃcient with ciphertext of size

following, based on the CP-ABE in [16] with our particular
designs and contructions, we propose a secure AugCP-ABE

O(√K · |A|) where |A| is the size of an access policy. In the
which is also eﬃcient with ciphertext of size O(√K + |A|).
4.3 AugCP-ABE Construction
SetupA(λ,U,K = m2) → (PP, MSK). Let G be a bilinear
group of order N = p1p2p3 (3 distinct primes, whose
size is determined by λ), Gpi the subgroup of order pi
in G (for i = 1, 2, 3), and g, f, h ∈ Gp1 , g3 ∈ Gp3 the
generators of corresponding subgroups. The algorithm
randomly chooses exponents
{αi, ri, zi ∈ ZN}i∈[m], {cj ∈ ZN}j∈[m], {ax ∈ ZN}x∈U .

3A similar approach was used in [14] to introduce weak
traceability to predicate encryption.

481The public parameter PP includes the description of
the group and the following elements:

(cid:16) g, f, h, {Ei = e(g, g)αi , Gi = gri , Zi = gzi}i∈[m],
{Hj = gcj}j∈[m], {Ux = gax}x∈U (cid:17).

The master secret key is set to

MSK = ( α1, . . . , αm, r1, . . . , rm, c1, . . . , cm, g3 ).

A counter ctr = 0 is implicitly included in MSK.

KeyGenA(PP, MSK, S) → SK(i,j),S. The algorithm ﬁrst sets
ctr = ctr + 1 and computes the corresponding index
in the form of (i, j) where 1 ≤ i, j ≤ m and (i − 1) ∗
m + j = ctr. Then it randomly chooses σi,j , δi,j ∈ ZN
and R, R′, R′′, R′′′, Rx(x ∈ S) ∈ Gp3 , and outputs a
private key SK(i,j),S =
(cid:16) Ki,j = gαi gricj f σi,j hδi,j R,

K ′

i,j = gσi,j R′, K′′

i,j = gδi,j R′′, K′′′

i,j = Z

σi,j
i R′′′,

{Ki,j,x = U

σi,j

x Rx}x∈S (cid:17).

The value of (i, j) is implicitly contained in SK(i,j),S.
EncryptA(PP, M, A = (A, ρ), (¯i, ¯j)) → CT . A is an l ×
n LSSS matrix and ρ maps each row Ak of A to an
attribute ρ(k) ∈ U. The algorithm randomly chooses

κ, τ, s1, . . . , sm,

t1, . . . , tm ∈ ZN ,
~vc, ~w1, . . . , ~wm ∈ Z3
N ,
~u = (π, u2, . . . , un) ∈ Zn
N .

ξ1, . . . , ξl ∈ ZN ,

In addition, it randomly chooses rx, ry, rz ∈ ZN , and
sets ~χ1 = (rx, 0, rz), ~χ2 = (0, ry, rz), ~χ3 = ~χ1 × ~χ2 =
(−ryrz,−rxrz, rxry). Then it randomly chooses

N ∀i ∈ {1, . . . ,¯i},

~vi ∈ Z3
~vi ∈ span{~χ1, ~χ2} ∀i ∈ {¯i + 1, . . . , m},

i=1, ( ~Cj, ~C ′

and creates the ciphertext h(A, ρ), ( ~Ri, ~R′
i , Ti)m
Q′′′
1. For each row i ∈ [m]:

j=1, (Pk, P ′

i, Qi, Q′
k=1i as follows:

j )m

k)l

• if i < ¯i: randomly chooses ˆsi ∈ ZN , and sets

i, Q′′
i ,

i f π, Q′′

i = hsi , Q′′′

i = gti,

i = Gκsi~vi

,

i
i = f τ si(~vi·~vc)Zti
i = gti ,

i f π,

i = gκ~vi ,
i = f si Zti

~Ri = g~vi , ~R′
Qi = gsi , Q′
Ti = E ˆsi
i .

i

, ~R′

• if i ≥ ¯i: sets
~Ri = Gsi~vi
Qi = gτ si(~vi·~vc), Q′
i = hτ si(~vi·~vc), Q′′′
Q′′
Ti = M · Eτ si(~vi·~vc)
2. For each column j ∈ [m]:

.

i

• if j < ¯j: randomly chooses µj ∈ ZN , and sets

~Cj = H

τ (~vc+µj ~χ3)
j

· gκ ~wj , ~C ′

j = g ~wj .
· gκ ~wj , ~C ′

j = g ~wj .

• if j ≥ ¯j: sets ~Cj = H τ~vc

j

3. For each k ∈ [l]: sets Pk = f Ak·~uU −ξk

ρ(k) , P ′

k = gξk .

DecryptA(PP, CT, SK(i,j),S) → M or ⊥. The algorithm
i , Q′′′
i ,
k=1i. If S does not satisfy

parses CT to CT = h(A, ρ), ( ~Ri, ~R′
Ti)m
(A, ρ), the algorithm outputs ⊥, otherwise it

i=1, ( ~Cj , ~C ′

j=1, (Pk, P ′

i, Qi, Q′

i, Q′′

j)m

k)l

1. Computes constants {ωk ∈ ZN} such that

Pρ(k)∈S ωkAk = (1, 0, . . . , 0), then computes
k)(cid:1)ωk
DP = Y

i,j , Pk)e(Ki,j,ρ(k), P ′

(cid:0)e(K ′
(cid:0)e(gσi,j , f Ak ·~u)(cid:1)ωk = e(gσi,j , f )π.

ρ(k)∈S

= Y

ρ(k)∈S

e3( ~R′
i, ~C′
j )
e3( ~Ri, ~Cj )

e(Ki,j ,Qi)·e(K′′′
e(K′
i)·e(K′′

i,j ,Q′

i,j ,Q′′′
i )
i,j ,Q′′

i ) ·

.
2. Computes DI =
3. Computes M ′ = Ti/(DP · DI ) as the output mes-
sage. Assume the encrypted message is M and
the encryption index is (¯i, ¯j), it can be veriﬁed
that only when (i > ¯i) or (i = ¯i∧ j ≥ ¯j), M ′ = M
will hold. This follows from the facts that for i >
¯i, we have (~vi · ~χ3) = 0 (since ~vi ∈ span{~χ1, ~χ2}),
and for i = ¯i, we have that (~vi · ~χ3) 6= 0 hap-
pens with overwhelming probability (since ~vi is
randomly chosen from Z3

N ).

k)l

(i.e. Q′

i is diﬀerent and Q′′

i, Qi, Ti, ~Cj , ~C ′
i and Q′′′

Remark: In EncryptA, π is the secret shared according to the
LSSS (A, ρ), and is for generating ciphertext components
(Pk, P ′
k=1, so that only users with eligible attribute sets
can recover DP = e(g, f )πσi,j . To intertwine the CP-ABE
part and Tracing part, f π is embedded in Q′
i, i.e., in Tracing
ciphertext components, although ( ~Ri, ~R′
j) are
the same as that of [9], Q′
i are
new components we introduced. We stress that Zti
(in Q′
i)
i
is the crucial component that intertwines the Tracing part
(i.e. f τ si(~vi·~vc) for i ≥ ¯i and f si for i < ¯i) and the CP-ABE
part (i.e. f π) securely and eﬃciently. In a straightforward
combination without Zti
i = f τ si(~vi·~vc )f π for i ≥ ¯i
i
i = f si f π for i < ¯i), the index-hiding property will be
and Q′
hard to prove, and to obtain provable index-hiding, diﬀerent
πi has to be used for diﬀerent i (i.e. Q′
i = f τ si(~vi·~vc )f πi for
i ≥ ¯i and Q′
i = f si f πi for i < ¯i), but this will make the
CP-ABE part have ciphertext size of O(√K · l), rather than
O(l) as above. The using of Zti
i
Q′
erty while achieving (eﬃcient) ciphertext size of O(√K + l).

(and the introduction of
i ) enables us to prove the index-hiding prop-

In particular, when reducing the index-hiding property to
the 3-Party Diﬃe-Hellman assumption, f τ si(~vi·~vc) and f π
will contain terms of gbc and gac respectively, where the
simulator cannot compute, and only with the help of Zti
i
the simulator can cancel them and form the challenge ci-
phertext, i.e., let Zi contain the term gc and ti contain the
terms b and a, so that the terms gbc and gac in f τ si(~vi·~vc)
and f π can be canceled out by those in Zti
i = gti
can be formed using terms A = ga and B = gb. Details are
given in Appendix A.1, i.e. the proof of Lemma 1.
4.4 AugCP-ABE Security

i , while Q′′′

i and Q′′′

i, Q′′

The following Theorem 2 and 3 prove that our AugCP-
ABE scheme is message-hiding, and Theorem 4 prove that
our AugCP-ABE scheme is index-hiding.

482Theorem 2. Under the Assumption 1, the General Sub-
group Decision Assumption, the 3-Party Diﬃe-Hellman As-
sumption in a Subgroup, and the Source Group q-Parallel
BDHE Assumption in a Subgroup, no polynomial time ad-
versary can win GameA

MH1 with non-negligible advantage.

Proof. Note that the structures of CP-ABE part of our
AugCP-ABE scheme are similar to that of the CP-ABE
scheme in [16], the proof of Theorem 2 is also similar to
that of [16]. For simplicity, here we prove the theorem by
reducing the message-hiding property of our AugCP-ABE
scheme in GameA
MH1 to the security of CP-ABE scheme in
[16]. Complete proof will be given in the full paper.

Theorem 3. No polynomial time adversary can win the

game GameA

MHK+1 with non-negligible advantage.

Proof. The argument for message-hiding in GameA

MHK+1

is very straightforward since an encryption to index K + 1 =
(m + 1, 1) contains no information about the message. The
simulator simply runs actual SetupA and KeyGenA algorithms
and encrypts the message Mb by the challenge access policy
A∗ and index (m + 1, 1). Since for all i = 1 to m, the values
of Ti = E ˆsi
i contains no information about the message, the
bit b is perfectly hidden and MHA

K+1AdvA = 0.

Theorem 4. Suppose that the 3-Party Diﬃe-Hellman As-
sumption in a Subgroup (deﬁned in [16]), the 3-Party Diﬃe-
Hellman Assumption (deﬁned in [9]) and the Decisional Lin-
ear Assumption hold. Then no polynomial time adversary
can win GameA

IH with non-negligible advantage.

Proof. Theorem 4 follows from the following Lemma 1

and Lemma 2 immediately.

Lemma 1. Suppose that the 3-Party Diﬃe-Hellman As-
sumption in a Subgroup holds. Then no polynomial time ad-
versary can distinguish between an encryption to (¯i, ¯j) and
(¯i, ¯j + 1) in GameA

IH with non-negligible advantage.

Proof. In GameA

IH, the adversary A will eventually be-

have in one of two diﬀerent ways:
Case I: In Key Query phase, A will not submit ((¯i, ¯j), S(¯i,¯j))
for some attribute set S(¯i,¯j) to query the corresponding
private key. In Challenge phase, A submits a message
M and a non-empty attribute set S∗. There is not any
restriction on S∗.

Case II: In Key Query phase, A will submit ((¯i, ¯j), S(¯i,¯j))
for some attribute set S(¯i,¯j) to query the correspond-
ing private key. In Challenge phase, A submits a mes-
sage M and a non-empty attribute set S∗ with the
restriction that S(¯i,¯j) does not satisfy the correspond-
ing strictest access policy AS ∗ (i.e. S∗ \ S(¯i,¯j) 6= ∅).

The Case I is easy to handle using the similar proof ideas
in [9] as the adversary will not query a private key with
the challenge index (¯i, ¯j). The Case II captures the index-
hiding requirement for CP-ABE in that even if a user has
a key with index (¯i, ¯j) he cannot distinguish between an
encryption to (AS ∗, (¯i, ¯j)) and (AS ∗, (¯i, ¯j + 1)) if the corre-
sponding attribute set S(¯i,¯j) does not satisﬁes AS ∗. This
is the most challenging part of achieving the strong trace-
ability in CP-ABE securely and eﬃciently, and our particu-
lar construction (of the crucial components Zti
i) and
i
i = gti in the ciphertext) is driven by and serves this aim.
Q′′′

(in Q′

These ciphertext components are crucial for the proof to use
the underlying assumption to simulate the real attack game
when A behaves in Case II. The proof details of Lemma 1
can be found in Appendix A.1.

Lemma 2. Suppose that the 3-Party Diﬃe-Hellman As-
sumption in a Subgroup (deﬁned in [16]), the 3-Party Diﬃe-
Hellman Assumption (deﬁned in [9]) and the Decisional Lin-
ear Assumption hold. Then no polynomial time adversary
can distinguish between an encryption to (¯i, m) and (¯i + 1, 1)
in GameA

IH with non-negligible advantage.

Proof. Similar to the proof of Lemma 6.3 in [9], to prove
this lemma we deﬁne the following hybrid experiments: H1:
Encrypt to (¯i, ¯j = m); H2: Encrypt to (¯i, ¯j = m+1); and H3:
Encrypt to (¯i + 1, 1). Lemma 2 follows from the following
Claim 1 and Claim 2.

Claim 1. Suppose that the 3-Party Diﬃe-Hellman As-
sumption in a Subgroup holds. Then no polynomial time
adversary can distinguish between experiments H1 and H2
with non-negligible advantage.

Proof. The proof is identical to that of Lemma 1.

Claim 2. Suppose that the 3-Party Diﬃe-Hellman As-
sumption and the Decisional Linear Assumption hold. Then
no polynomial time adversary can distinguish between exper-
iments H2 and H3 with non-negligible advantage.

Proof. The indistinguishability of H2 and H3 can be
proven using a proof similar to that of Lemma 6.3 in [9],
which was used to prove the indistinguishability of similar
hybrid experiments for their Augmented Broadcast Encryp-
tion (AugBE) scheme. For simplicity, we will prove Claim 2
by a reduction from our AugCP-ABE scheme to the AugBE
scheme in [9]. Complete proof will be given in the full pa-
per.

5. POLICY-SPECIFIC DECRYPTION BLACK-

BOX

In previous sections, we considered the traceability against
key-like decryption blackboxes, which allow a seller (on eBay)
to advertise the alleged decryption privilege of a blackbox
D by an attribute set SD. The seller can claim that D can
decrypt a ciphertext (with at least a non-negligible proba-
bility) if the ciphertext access policy A is satisﬁed by SD.
Note that A can be any arbitrary access policy as long as
it can be satisﬁed by SD. This type of decryption black-
boxes are very powerful and therefore, could also be one of
the most crucial issues to solve in practice using a blackbox
tracing algorithm. In this section, we focus our attention on
another interesting scenario which requires us to deal with
another type of decryption blackboxes, which we call it a
policy-speciﬁc decryption blackbox.

Policy-Speciﬁc Decryption Blackbox on Sale. Attempt-
ing to invalidate the possible tracing algorithm (such as the
one we proposed above), a malicious user may build and
sell a decryption blackbox which decrypts ciphertexts with
a speciﬁc access policy only. Such a decryption blackbox,
which we call it a policy-speciﬁc decryption blackbox, has
weaker decryption ability than that of the previous key-like
decryption blackbox, as it decrypts ciphertexts with a spe-
ciﬁc access policy only rather than any arbitrary access pol-
icy as long as it is satisﬁed by a speciﬁc attribute set. In

483practice, a seller or a malicious user may set the price lower
for such a policy-speciﬁc decryption blackbox, and adver-
tises that it can decrypt any ciphertexts associated with ac-
cess policy AD. Below is another scenario, which we call it
“found-in-the-wild”, where policy-speciﬁc decryption black-
boxes may be concerned.

A law enforcement agency gets a warrant to search a sus-
pect’s computer and ﬁnds a decryption blackbox. As the
suspect might try to destroy evidence, the explicit descrip-
tion of the blackbox’s (decryption) ability might be gone,
while the law enforcement agency only has certain clue on
the certain access policy associated to the ciphertexts that
the blackbox can decrypt.

Though the corresponding attribute set is not available
and only a speciﬁc access policy AD is known that the asso-
ciated ciphertexts can be decrypted by a policy-speciﬁc de-
cryption blackbox, interesting, we notice that the AugCP-
ABE scheme in Sec. 4 also implies a fully secure BT-CP-
ABE scheme with (selective) traceability against this policy-
speciﬁc decryption blackbox. On its formal deﬁnition, it is
similar to that of key-like decryption blackbox, with the fol-
lowing diﬀerences:

1. Trace algorithm: The tracing algorithm takes an access
policy AD as input, i.e. TraceD(PP, AD, ǫ) and the rest
is the same as before.

2. GameTR:

In the (Policy-speciﬁc) Decryption Blackbox
Generation phase, the adversary A outputs a decryp-
tion blackbox D associated with an access policy AD
and a non-negligible probability ǫ. A wins GameTR if
(a) Pr[D(Encrypt(PP, M, AD)) = M ] ≥ ǫ, where the
probability is taken over the random choices of
message M and the random coins of D.

(b) KT = ∅, or KT 6⊆ KD,

or (∀kt ∈ KT , Skt does not satisf y AD ).

3. GameIH: We do not need the concept of strictest access
policy here, i.e., in the Challenge phase, A submits a
message M and an access policy A∗, and the challenger
sends CT ← EncryptA(PP, M, A∗, ¯k + b) to A. Here
we have to deﬁne a weaker model of GameIH, where
A is required to declare A∗ before seeing the public
parameter, and the deﬁned index-hiding property is
referred to as selective index-hiding.

4. Similar to Theorem 1, we can show that an AugCP-
ABE with message-hiding and (selective) index-hiding
properties implies a secure and (selectively) traceable
BT-CP-ABE against policy-speciﬁc decryption black-
box.

To prove the message-hiding and index-hiding properties
of the AugCP-ABE scheme under the deﬁnition above for
policy-speciﬁc decryption blackbox, we only need to modify
a few prooﬁng details of Lemma 1, and the proof idea is
similar to the current one for key-like decryption blackbox.
In the proof of Lemma 1 for key-like decryption blackbox,
as the challenge ciphertext is generated using the strictest
access policy of the challenge attribute set S∗, we can have
a guess on a particular attribute ¯x and consequently prove
the index-hiding against adaptive adversaries. However, in
the case of policy-speciﬁc decryption blackbox, the challenge
ciphertext is generated using the challenge access policy A∗,
where it is hard to have a successful guess unless we consider

only the selective adversaries.
In summary, the resulting
BT-CP-ABE scheme is fully secure and selectively traceable
against policy-speciﬁc decryption blackbox.
6. RELATED WORK

Sahai and Waters [22] introduced Attribute-Based En-
cryption (ABE) for addressing the fuzzy identity matching
problem in IBE. Goyal et al. [11] later formalized the notions
of CP-ABE and Key-Policy ABE (KP-ABE). KP-ABE sys-
tems available in the literature include [21, 15, 20, 1], how-
ever, these systems do not address the traceability problem.
Katz and Schr¨oder [14] introduced the notion of traceabil-
ity in the context of predicate encryption [13], where they
proposed a generic construction that adds traceability to any
inner-product predicate encryption (IPE) scheme with the
price of adding overhead linear in K (the number of users)
to the original scheme. Note that although IPE (e.g., the
most expressive schemes to date in [13]) implies IBE, BE
and KP-ABE, it cannot eﬃciently implement the functions
of expressive CP-ABE. The advances of our work is mak-
ing are twofold in the sense that we add traceability (1) to
an existing expressive CP-ABE scheme (2) at the expense of

sub-linear (i.e. √K) overhead, although our result is speciﬁc

rather than generic as [14] is.
7. CONCLUSION

In this paper, we proposed a new CP-ABE scheme that si-
multaneously supports fully collusion-resistant (and public)
blackbox traceability and high expressivity (i.e., support-
ing any monotonic access structures), as well as without the
one-use restriction. The scheme is proved secure against
adaptive adversaries in the standard model. For the trace-
ability against key-like decryption blackbox, the scheme is
proved traceable against adaptive adversaries in the stan-
dard model, and for the traceability against policy-speciﬁc
decryption blackbox, the scheme can be proved traceable
against selective adversaries in the standard model. Com-
pared with the most eﬃcient conventional (non-traceable)
CP-ABE schemes currently available with high expressivity
and full security in the standard model, the new CP-ABE
adds fully collusion-resistant (and public) blackbox trace-

ability with the price of adding only O(√K) elements in the

ciphertext and public key.
8. ACKNOWLEDGMENTS

The work was supported by the National Natural Science
Foundation of China (No. 61033014 and No. 61161140320)
and a grant from the RGC of the HKSAR, China (Project
No. CityU 123511).
9. REFERENCES
[1] N. Attrapadung, B. Libert, and E. de Panaﬁeu.

Expressive key-policy attribute-based encryption with
constant-size ciphertexts. In Public Key Cryptography,
pages 90–108, 2011.

[2] J. Bethencourt, A. Sahai, and B. Waters.

Ciphertext-policy attribute-based encryption. In IEEE
Symposium on Security and Privacy, pages 321–334.
IEEE Computer Society, 2007.

[3] D. Boneh and M. K. Franklin. Identity-based

encryption from the weil pairing. In CRYPTO, pages
213–229, 2001.

484[4] D. Boneh, C. Gentry, and B. Waters. Collusion

[20] T. Okamoto and K. Takashima. Fully secure functional

resistant broadcast encryption with short ciphertexts
and private keys. In CRYPTO, pages 258–275, 2005.

[5] D. Boneh, A. Sahai, and B. Waters. Fully collusion
resistant traitor tracing with short ciphertexts and
private keys. In EUROCRYPT, pages 573–592, 2006.

[6] D. Boneh and B. Waters. A fully collusion resistant

broadcast, trace, and revoke system. In ACM
Conference on Computer and Communications
Security, pages 211–220, 2006.

encryption with general relations from the decisional
linear assumption. In CRYPTO, pages 191–208, 2010.

[21] R. Ostrovsky, A. Sahai, and B. Waters.

Attribute-based encryption with non-monotonic access
structures. In ACM Conference on Computer and
Communications Security, pages 195–203, 2007.

[22] A. Sahai and B. Waters. Fuzzy identity-based

encryption. In EUROCRYPT, pages 457–473, 2005.

[23] A. Shamir. Identity-based cryptosystems and

[7] L. Cheung and C. C. Newport. Provably secure

signature schemes. In CRYPTO, pages 47–53, 1984.

ciphertext policy abe. In ACM Conference on
Computer and Communications Security, pages
456–465, 2007.

[8] A. Fiat and M. Naor. Broadcast encryption. In

CRYPTO, pages 480–491, 1993.

[9] S. Garg, A. Kumarasubramanian, A. Sahai, and

B. Waters. Building eﬃcient fully collusion-resilient
traitor tracing and revocation schemes. In ACM
Conference on Computer and Communications
Security, pages 121–130, 2010.

[10] V. Goyal, A. Jain, O. Pandey, and A. Sahai. Bounded

ciphertext policy attribute based encryption. In
ICALP (2), pages 579–591, 2008.

[11] V. Goyal, O. Pandey, A. Sahai, and B. Waters.

Attribute-based encryption for ﬁne-grained access
control of encrypted data. In ACM Conference on
Computer and Communications Security, pages 89–98,
2006.

[12] J. Herranz, F. Laguillaumie, and C. R`afols. Constant

size ciphertexts in threshold attribute-based
encryption. In Public Key Cryptography, pages 19–34,
2010.

[13] J. Katz, A. Sahai, and B. Waters. Predicate

encryption supporting disjunctions, polynomial
equations, and inner products. In EUROCRYPT,
pages 146–162, 2008.

[14] J. Katz and D. Schr¨oder. Tracing insider attacks in

the context of predicate encryption schemes. In
ACITA, 2011.

[15] A. B. Lewko, T. Okamoto, A. Sahai, K. Takashima,

and B. Waters. Fully secure functional encryption:
Attribute-based encryption and (hierarchical) inner
product encryption. In EUROCRYPT, pages 62–91,
2010.

[16] A. B. Lewko and B. Waters. New proof methods for

attribute-based encryption: Achieving full security
through selective techniques. In CRYPTO, pages
180–198, 2012.

[17] J. Li, Q. Huang, X. Chen, S. S. M. Chow, D. S. Wong,

and D. Xie. Multi-authority ciphertext-policy
attribute-based encryption with accountability. In
ASIACCS, pages 386–390, 2011.

[18] J. Li, K. Ren, and K. Kim. A2be: Accountable
attribute-based encryption for abuse free access
control. IACR Cryptology ePrint Archive, 2009:118,
2009.

[19] Z. Liu, Z. Cao, and D. S. Wong. White-box traceable

ciphertext-policy attribute-based encryption
supporting any monotone access structures. IEEE
Transactions on Information Forensics and Security,
8(1):76–88, 2013.

[24] B. Waters. Ciphertext-policy attribute-based

encryption: An expressive, eﬃcient, and provably
secure realization. In Public Key Cryptography, pages
53–70, 2011.

APPENDIX
A. PROOFS
A.1 Proof of Lemma 1

Proof. Suppose there exists a polynomial time adver-
sary A that breaks the index-hiding game with advantage
ǫ. We build a PPT algorithm B to solve a 3-Party Diﬃe-
Hellman problem instance in a subgroup as follows.
B receives the 3-Party Diﬃe-Hellman challenge in a sub-
group from the challenger as (N, G, GT , e, g, g2, g3, A =
ga, B = gb, C = gc, T ), where G is a bilinear group of order
N = p1p2p3, Gpi is the subgroup of order pi in G (i = 1, 2, 3),
g, g2 and g3 are generators of Gp1 , Gp2 and Gp3 respectively,
and a, b, c are randomly chosen from ZN . B’s goal is to de-
termine T = gabc or T is a random element from Gp1 .

Setup. Firstly, B randomly chooses an attribute ¯x ∈ U to
guess that ¯x will be in the challenge attribute S∗ (regardless
of whether A behaves in Case I or Case II) and will not be
in S(¯i,¯j) if A behaves in Case II. Then B randomly chooses
{αi ∈ ZN}i∈[m], {ri, z′
i ∈ ZN}i∈[m]\{¯i}, {cj ∈ ZN}j∈[m]\{¯j},
{ax ∈ ZN}x∈U \{¯x}, r′
¯i, z¯i, c′
and η, θ ∈ ZN . B gives A the public parameter PP:
(cid:16) g, f = C η, h = gθ, {Ei = e(g, g)αi}i∈[m],
{Gi = gri , Zi = C z′
i}i∈[m]\{¯i}, G¯i = Br′
{Hj = gcj}j∈[m]\{¯j}, H¯j = C c′
{Ux = gax}x∈U \{¯x}, U¯x = C a′

¯i , Z¯i = gz¯i

¯j ,
¯x (cid:17).

¯j , a′

¯x ∈ ZN ,

Note that B implicitly chooses r¯i, c¯j , a¯x ∈ ZN and {zi ∈
ZN}i∈[m]\{¯i} such that
¯i ≡ r¯i mod p1, cc′
br′
i ≡ zi mod p1 ∀i ∈ [m] \ {¯i}.
cz′

¯j ≡ c¯j mod p1, ca′

¯x ≡ a¯x mod p1,

Key Query. To respond to A’s query for ((i, j), S(i,j)),

• if (i, j) 6= (¯i, ¯j): B randomly chooses σi,j, δi,j ∈ ZN
and R, R′, R′′, R′′′, Rx(x ∈ S(i,j)) ∈ Gp3 , then cre-
i,j , K ′′
ates the private key SK(i,j),S(i,j) = (cid:0)Ki,j , K ′
i,j,

485K ′′′
i,j, {Ki,j,x}x∈S(i,j)(cid:1) as

Ki,j =


gαi gricj f σi,j hδi,j R,
gαi Br′
icj f σi,j hδi,j R,
gαi C ric′
j f σi,j hδi,j R,

i,j = gδi,j R′′, K ′′′

: i 6= ¯i, j 6= ¯j
: i = ¯i, j 6= ¯j
: i 6= ¯i, j = ¯j
i,j = Z

σi,j
i R′′′,

K ′

i,j = gσi,j R′, K ′′

Ki,j,x = U

σi,j

x Rx ∀x ∈ S(i,j).

• if (i, j) = (¯i, ¯j):

it means that A behaves in Case
II. If ¯x ∈ S(i,j), then B aborts and outputs a random
b′ ∈ {0, 1} to the challenger. Otherwise, B randomly
chooses σ′
¯i,¯j ∈ ZN and sets the value of σ¯i,¯j by implic-
itly setting σ′
¯ic′
¯i,¯j − br′
¯j /η ≡ σ¯i,¯j mod p1. In addition B
randomly chooses δ¯i,¯j ∈ ZN and R, R′, R′′, R′′′, Rx(x ∈
S(i,j)) ∈ Gp3 . B creates the private key SK(¯i,¯j),S(¯i,¯j)
=
(cid:0)K¯i,¯j , K′

¯i,¯j, K ′′′

¯i,¯j , K ′′
K¯i,¯j = gα¯i f σ′
K ′′
K¯i,¯j,x = (gσ′

¯i,¯j, {K¯i,¯j,x}x∈S(¯i,¯j)(cid:1) as
¯i,¯j B−r′
c′
¯j

¯i,¯j hδ¯i,¯j R, K′
¯i,¯j = (gσ′
¯i,¯j B−r′
¯ic′
¯j /η)ax Rx ∀x ∈ S(i,j).

¯i,¯j = gσ′
¯i,¯j B−r′

¯i,¯j = gδ¯i,¯j R′′, K′′′

/η)z¯i R′′′,

/ηR′,

c′
¯j

¯i

¯i

Challenge. A submits a message M and an attribute set
S∗. If ¯x /∈ S∗ then B aborts and outputs a random b′ ∈ {0, 1}
to the challenger. Otherwise, B constructs the LSSS matrix
(A∗, ρ) for AS ∗. Let l × n be the size of (A∗, ρ). Note that
S∗ \ {¯x} does not satisfy AS ∗, B ﬁrst computes a vector
~¯u ∈ Zn
N that has ﬁrst entry equal to 1 and is orthogonal to
all of the rows A∗
k of A∗ such that ρ(k) ∈ S∗ \ {¯x} (such a
vector must exist since S∗ \ {¯x} fails to satisfy (A∗, ρ), and
it is eﬃciently computable). B randomly chooses

τ ′, s1, . . . , s¯i−1, s′

¯i, s¯i+1, . . . , sm ∈ ZN ,
m ∈ ZN ,
m ∈ Z3
N ,
{ξ′
k ∈ ZN}∀k∈[l] s.t. ρ(k)=¯x, {ξk ∈ ZN}∀k∈[l] s.t. ρ(k)6=¯x,
π′ ∈ ZN , ~u′ ∈ Zn
N ,

t′
1, . . . , t′
¯i−1, t¯i, t′
~w1, . . . , ~w¯j−1, ~w′

¯i+1, . . . , t′
¯j , . . . , ~w′

with the ﬁrst entry of ~u′ equal to zero.
It also randomly
chooses rx, ry, rz ∈ ZN , and sets ~χ1 = (rx, 0, rz), ~χ2 =
(0, ry, rz), ~χ3 = ~χ1 × ~χ2 = (−ryrz,−rxrz, rxry).
B randomly chooses (νc,1, νc,2, νc,3) ∈ Z3
c =
νc,1 ~χ1 + νc,2 ~χ2 and ~vq
c = νc,3 ~χ3, implicitly setting ~vc =
a−1~vp
Q′′′

c , B creates the ciphertext h(A, ρ), ( ~Ri, ~R′
i=1, ( ~Cj, ~C ′
k=1i as follows:

c +~vq
i , Ti)m
1. For each row i ∈ [m]:

j=1, (Pk, P ′

N . Let ~vp

i, Qi, Q′

j )m

k)l

i, Q′′
i ,

N and ˆsi ∈ ZN ,
i = f si Zt′
i f π′
i , Ti = E ˆsi
i .

,

i

N , then sets

• if i < ¯i:
then sets
~Ri = g~vi , ~R′
Q′′

i = hsi , Q′′′

it randomly chooses ~vi ∈ Z3

i = B~vi , Qi = gsi , Q′
i = gt′
c )/z′

i Aητ ′s′

¯i(~v¯i·~vq

it randomly chooses ~v¯i ∈ Z3
s′
~v¯i , ~R′
¯i
¯i
(~v¯i·~vp

i = Br′

s′
~v¯i ,
¯i

(~v¯i·~vq

¯i

• if i = ¯i:
~Ri = gr′
Qi = gτ ′s′
c )Aτ ′s′
i = C ητ ′s′
c )Zt¯i
Q′
Ti = M · e(gαi , Qi).

(~v¯i·~vp

¯i

¯i

¯i

i f π′

c ),

, Q′′

i = Qθ

i , Q′′′

i = gt¯i ,

• if i > ¯i:
then sets

it randomly chooses ~vi ∈ span{~χ1, ~χ2},

~Ri = grisi~vi , ~R′
Qi = Bτ ′si(~vi·~vp

i = Brisi~vi ,
i = Zt′
c ), Q′

′

−ητ

′
i(~vi ·~v
s
z′
i

p
c )

A

i B

i = gt′
Q′′′
Ti = M · e(gαi, Qi).

, Q′′

i = Qθ
i ,
q
c )

·~v

i

i f π′
′
(~v¯i
s
¯i
z′
i

′

ητ

,

• if j < ¯j: it randomly chooses µ′

j ∈ ZN and implic-
j νc,3 −

itly sets the value of µj such that (ab)−1µ′
νc,3 ≡ µj mod N , then sets
~Cj = Bcj τ ′~vp
j ~vq
c · gcj τ ′µ′
c · B ~wj , ~C ′
¯j τ ′~vq
• if j = ¯j: ~Cj = T c′
j = g ~w′
c · B ~w′
j , ~C ′
j = g ~w′
c · B ~w′
• if j > ¯j: ~Cj = Bcj τ ′~vp
j , ~C ′

j = g ~wj .
¯j τ ′~vp
¯j · C −c′
c .
j · A−cj τ ′~vq

c .

2. For each j ∈ [m]:

3. For each k ∈ [l]:

• if ρ(k) 6= ¯x: it sets Pk = f A∗
• if ρ(k) = ¯x: it sets

k ·~u′

U −ξk
ρ(k) , P ′

k = gξk .

Pk = f π′A∗
k = gξ′
P ′

k·~¯uf A∗
k A−ητ ′s′

k ·~u′

¯i(~v¯i·~vq

C −a ¯xξ′
k ,
c )(A∗
k ·~¯u)/a ¯x.

Note that B implicitly chooses κ, τ, s¯i, ti(i ∈ [m] \ {¯i}) ∈
ZN , ~wj ∈ Z3
N , and {ξk ∈
ZN}k∈[l] s.t. ρ(k)=¯x such that

N (j ∈ {¯j, . . . , m}), π ∈ ZN , ~u ∈ Zn

b ≡ κ mod p1, abτ ′ ≡ τ mod p1, s′
¯i(~v¯i · ~vq

t′
i + ηaτ ′s′

¯i/b ≡ s¯i mod p1,
c )/z′
i ≡ ti mod p1,

c )(A∗

¯i(~v¯i · ~vq

ξ′
k − ηaτ ′s′

k · ~¯u)/a¯x ≡ ξk mod p1.
If T = gabc, then the ciphertext is a well-formed encryption
to the index (¯i, ¯j).
If T is randomly chosen, say T = gr
for some random r ∈ ZN , the ciphertext is a well-formed
encryption to the index (¯i, ¯j + 1) with implicitly setting µ¯j
such that ( r
Guess. A outputs a guess b′ ∈ {0, 1} to B, then B outputs
this b′ to the challenger.

abc − 1)νc,3 ≡ µ¯j mod p1.

Note that when B does not abort, the distributions of
the public parameter, private keys and challenge ciphertext
are same as the real scheme. As S∗ 6= ∅ and if A behaves
in Case II then the attribute set S(¯i,¯j) must satisfy S∗ \
S(¯i,¯j) 6= ∅, the event that B does not abort will happen
with probability at least 1/|U|. Thus, B’s advantage in the
3-Party Diﬃe-Hellman game will be at least ǫ/|U|. As of
the fully secure CP-ABE schemes in [15, 20, 16], the size of
attribute universe (i.e. |U|) in our scheme is also polynomial
in the security parameter λ. Thus a degradation of O(1/|U|)
in the security reduction is acceptable.

∀i ∈ {1, . . . ,¯i − 1} :
∀i ∈ {¯i + 1, . . . , m} :
i(~vi · ~vp

t′
i − ηbτ ′s′

∀j ∈ {¯j + 1, . . . , m} :

π′ − aτ ′s′
∀k ∈ [l] s.t. ρ(k) = ¯x :

c )/z′

c )/z′
i + ηaτ ′s′
¯i(~v¯i · ~vq
i ≡ ti mod p1,
~w′
¯j τ ′~vp
¯j − cc′
c ≡ ~w¯j mod p1,
~w′
j − acj τ ′~vq
c ≡ ~wj mod p1,
c ) ≡ π mod p1, ~u = π~¯u + ~u′,

¯i(~v¯i · ~vq

486