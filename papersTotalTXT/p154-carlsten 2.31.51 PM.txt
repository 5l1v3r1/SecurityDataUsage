On the Instability of Bitcoin Without the Block Reward

Miles Carlsten

carlsten@cs.princeton.edu

Harry Kalodner

kalodner@cs.princeton.edu

Arvind Narayanan

arvindn@cs.princeton.edu

S. Matthew Weinberg
smweinberg@princeton.edu

ABSTRACT
Bitcoin provides two incentives for miners: block rewards
and transaction fees. The former accounts for the vast ma-
jority of miner revenues at the beginning of the system, but
it is expected to transition to the latter as the block rewards
dwindle. There has been an implicit belief that whether
miners are paid by block rewards or transaction fees does
not aﬀect the security of the block chain.

We show that this is not the case. Our key insight is that
with only transaction fees, the variance of the block reward is
very high due to the exponentially distributed block arrival
time, and it becomes attractive to fork a “wealthy” block
to “steal” the rewards therein. We show that this results
in an equilibrium with undesirable properties for Bitcoin’s
security and performance, and even non-equilibria in some
circumstances. We also revisit selﬁsh mining and show that
it can be made proﬁtable for a miner with an arbitrarily low
hash power share, and who is arbitrarily poorly connected
within the network. Our results are derived from theoretical
analysis and conﬁrmed by a new Bitcoin mining simulator
that may be of independent interest.

We discuss the troubling implications of our results for
Bitcoin’s future security and draw lessons for the design of
new cryptocurrencies.

1.

INTRODUCTION

The security of Bitcoin’s consensus protocol relies on min-
ers behaving correctly. They are incentivized to do so via
mining revenues under the assumption that they are ratio-
nal entities. Any deviant miner behavior that outperforms
the default is thus a serious threat to the security of Bitcoin.
Miners receive two types of revenue: block rewards and
transaction fees. The former account for the vast majority
of miner revenues at the beginning of the system, but it
is expected to transition to the latter as the block rewards
dwindle (speciﬁcally, they halve every four years). There
has been an unexamined belief that in terms of the security
of the block chain (including incentives of the mining game),

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’16, October 24 - 28, 2016, Vienna, Austria
c(cid:13) 2016 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ISBN 978-1-4503-4139-4/16/10. . . $15.00
DOI: http://dx.doi.org/10.1145/2976749.2978408

Figure 1: One possible state of the block chain and
two possible actions a miner could take.

it is immaterial whether miners receive (say) 25 bitcoins in
each block as a block reward or 25 bitcoins in expectation as
transaction fees.

Illustrative example (Figure 1). Imagine a popula-
tion of rational, self-interested miners. Consider a block
chain with blocks of exponentially distributed rewards, as
we expect when the ﬁxed block reward runs out. A miner
has numerous options to consider when mining, but let’s fo-
cus on just two possibilities. She could extend the longest
chain (Option One), obtaining a reward of 5 and leaving a
reward of 0 for the next miner (at least until more transac-
tions arrive). Alternatively, she could fork it (Option Two),
obtaining reward of 55 while leaving a reward of 50 Bitcoin
unclaimed. The Bitcoin protocol dictates Option One, but
a quick reasoning suggests that Option Two is better.

To reason about this correctly, we must consider which
strategies the other miners are using. For instance, if all
other miners follow the heuristic of mining on the block they
heard about ﬁrst in the case of a 1-block fork (and if there
is no latency in the network), then forking is ineﬀective, and
Option One is clearly superior. On the other hand, since
other miners are rational, perhaps they will choose to build
on the fork instead of the older block, in which case Option
Two would yield more rewards.

Examples like these reveal novel incentive issues that sim-
ply don’t arise when block rewards are ﬁxed. The goal of this
paper is to understand the potential impact on Bitcoin’s sta-
bility by investigating the mining game in the regime where
the block reward has dwindled to a negligible amount, and
transaction fees dominate mining rewards. We ﬁnd new and
surprising incentive issues in a transaction-fee regime, even

154assuming that transactions (and associated fees) arrive at
a steady rate. To be clear: the incentive issues we uncover
arise not because transaction fees may arrive erratically, but
because the time-varying nature of transaction fees allows
for a richer set of strategic deviations that don’t arise in the
block-reward model.

At a high level, there is an analogy with pool hopping [21].
With certain mining pool reward schemes, the miner’s ex-
pected reward for participation varies over time, depend-
ing on how many shares have been contributed since the
pool found its last block. The concern is that miners would
respond by “hopping” in real time to the pool that max-
imizes their expected rewards. For another illustration of
this theme, consider a future where there are multiple cryp-
tocurrencies with time-varying rewards which can be mined
by the same hardware. Perhaps this will give rise to coin-
hopping, i.e., miners hopping to the cryptocurrency with the
largest transaction fee pool.

Contribution 1: A mining strategy simulator. While
we establish a number of theoretical results in Sections 5
and 6, the variety of possible parameters and assumptions
makes it completely infeasible to pose a perfectly accurate
Game-Theoretic model of Bitcoin that is also tractable. To
ﬁll the gaps and to conﬁrm our theoretical results, we’ve
built a mining strategy simulator. Theoretical results in
simple yet principled models provide good intuition to guide
practice, and simulations of more complex scenarios conﬁrm
that these results have applicability to more realistic models
where mathematical proofs are intractable.

Miners in our simulation learn over time which strate-
gies are successful using no-regret learning algorithms that
iteratively update a probability distribution over strategies
(Section 4.2). Our simulator is versatile and allows model-
ing diﬀerent numbers of miners, hash power distributions,
network latencies, and reward schemes. We show how it
allows researchers to quickly prototype and study new set-
tings within this parameter space. The simulator does have
limitations: it cannot model mining pools or a non-constant
arrival rate of transactions. We have made the simulator
open source.1

In addition to the versatility of settings, our simulator
allows exploring a large space of mining strategies, deﬁned
by the miner’s responses to three questions: which block to
extend, how much of the outstanding transactions to include
in the block, and when to publish found blocks. We deﬁne
a formal language to compactly express any strategy in this
space (Section 4).

Contribution 2: Undercutting attacks. The focus
of this paper is on analyzing deviant mining strategies in
the transaction-fee regime that can harm Bitcoin’s security.
We begin with the observation that if there is a 1-block
fork, it is more proﬁtable for the next miner to break the
tie by extending the block that leaves the most available
transaction fees rather than the oldest-seen block. We call
this strategy PettyCompliant.

Once any non-zero fraction of miners is PettyCompli-
ant, it enables various strategies that are more aggressive
and harmful to Bitcoin consensus. We call this the undercut-
ting attack, where miners will actively fork the head of the
chain and leave transactions unclaimed in the hope of incen-
tivizing PettyCompliant miners to build on their block.

1https://github.com/citp/mining simulator

In some scenarios, our simulation reveals a non-equilibrium
with increasingly aggressive undercutting. But with an ex-
panded strategy space, and suitable assumptions, we are
able to prove that an equilibrium exists. However, it is one
where miners include only a fraction of available transactions
into their blocks. This results in a backlog of transactions
whose size grows indeﬁnitely with time. We conﬁrm this
result using simulation.

Accurately predicting the steady-state mining behavior
requires modeling a vast number of variables such as miners’
cost structure, and is not the goal of our work.
Instead,
our results can be seen as an informal “lower bound” on
the departures from compliant behavior that are likely in
a transaction-fee regime. We can realistically predict that
PettyCompliant miners will arise, and that the existence
of such miners opens the ﬁeld for various more aggressive
strategies (Section 5).

Contribution 3: Revisiting selﬁsh mining. We re-
visit the selﬁsh mining strategy of Eyal and Sirer [9] and
show that, contrary to intuition, it performs even better in
the transaction-fee regime than in the block-reward regime.
Next, we propose a more sophisticated selﬁsh mining strat-
egy that accounts for the non-uniformity of rewards and out-
performs both default mining and “classic” selﬁsh mining.
Worse, unlike classic selﬁsh mining, this strategy works for
miners with arbitrarily low hash power and regardless of
their connectedness in the Bitcoin network. Moreover, the
attack is proﬁtable as soon as it is deployed, whereas classic
selﬁsh mining only becomes proﬁtable after a two-week dif-
ﬁculty adjustment period, arguably giving the community
a crucial window of time to detect and respond to such an
attack [10]. We validate these results via both theory and
simulation (Section 6).

Impact on Bitcoin security. If any of the deviant min-
ing strategies we explore were to be deployed, the impact
on Bitcoin’s security would be serious. At best, the block
chain will have a signiﬁcant fraction of stale or orphaned
blocks due to constant forks, making 51% attacks much eas-
ier and increasing the transaction conﬁrmation time. At
worst, consensus will break down due to block withholding
or increasingly aggressive undercutting.

This suggests a fundamental rethinking of the role of block
rewards in cryptocurrency design. Nakamoto appears to
have viewed the block reward as a necessary but temporary
evil to achieve an initial allocation of bitcoins in the absence
of a central authority, with the transaction fee regime being
the ideal, inﬂation-free steady state of the system. But our
work shows that incentivizing compliant miner behavior in
the transaction fee regime is a signiﬁcantly more daunting
task than in the block reward regime. Perhaps instead, de-
signers of new cryptocurrencies must resign themselves to
the inevitability of monetary inﬂation and make the block
reward permanent. Transaction fees would still exist, but
merely as an incentive for miners to include transactions in
their blocks.

2. RELATED WORK

Several recent works analyze incentives in Bitcoin min-
ing. Some examples include [12] and [8], which analyze how
strategic mining pools may attack competing pools in vari-
ous ways, and [15], which analyzes how strategic Ethereum
miners can trick others into wasting their computational

155power verifying the validity of complex scripts. Understand-
ing miner incentives in the Bitcoin system is important —
there is empirical evidence that miners/mining pools are
willing to attack others in order to maximize their own prof-
its (e.g. by launching DDoS attacks against other mining
pools) [23].

Eyal and Sirer develop the selﬁsh mining attack [9], a de-
viant mining strategy that enables miners to get more than
their fair share of rewards. We build on their results in Sec-
tion 6. Other works, notably Sapirshtein et al.
[22] have
analyzed selﬁsh mining in more detail using Markov Deci-
sion Processes (MDP). In an MDP, a player moves through a
discrete state space and tries to maximize reward (the state-
transition function and reward function are probabilistic).
This makes it a good ﬁt for modeling Bitcoin mining. How-
ever, in our case the state space (speciﬁcally, the amount of
remaining transaction fees) is continuous and not discrete,
so we do not use the machinery of MDPs.

There is some work on understanding the market for trans-
action fees and its relation to the block size (i.e. what fees
will users have to pay in order for transactions to be in-
cluded in a block?) [13, 11, 20, 17]. Our work avoids this
discussion; we show that undesirable behavior emerges even
if the market reaches an equilibrium where transaction fees
are non-negligible, and arrive steadily and reliably.
Inter-
estingly, M¨oser and B¨ohme reach the same conclusion as us
(that monetary inﬂation is a preferable mechanism to trans-
action fees) through very diﬀerent methods [17].

On the simulation side, numerous prior works have devel-
oped simulators for some aspect of Bitcoin. Some simulators
are aimed at aspects of Bitcoin aside from strategic min-
ing, such as privacy [3], or the peer-to-peer network [16].
Those developed in [9] and [8] also focus on simulating de-
viant mining strategies, but our understanding is that these
simulators are tailor-made for the speciﬁc deviant strategies
they wish to test. In comparison, our simulator allows for
easy implementation of a broad range of strategies in var-
ious environments. Indeed, the versatility of our simulator
is crucial for getting intuition for every result in this paper.
We have made it open-source and hope it will be a useful
tool for future research on strategic miner behavior.

3. MODEL AND STRATEGIES

In this section, we cover the model of Bitcoin that we
investigate. We will use this model to quickly illustrate how
the switch to transaction-fee dominated rewards may lead
to interesting and potentially harmful eﬀects for Bitcoin.
We also introduce a formal language for describing Bitcoin
strategies that we will use throughout the paper.
3.1 Model of the system

Brieﬂy, let us describe the theme of our model before get-
ting into speciﬁc details. The goal of this work is not to
accurately predict exactly what mining behavior will arise
in practice, but instead to uncover incentive issues that arise
solely due to the time-varying nature of transaction fees ver-
sus block rewards. To this end, our model is intentionally
simple because we want to isolate the eﬀects of time-varying
versus ﬁxed rewards. As an example, we will assume that
transactions (and their associated fees) arrive at a constant
and continuous rate. We make this assumption not be-
cause we necessarily predict it will hold in practice, but
because without it we can’t guarantee that we’ve isolated

time-varying transaction fees as the cause for any incentive
issues we uncover. Put another way, our results are only
made stronger by simplifying assumptions, because we are
claiming that weird and undesirable consequences arise even
if one is willing to grant simplifying assumptions.

Getting to details, the model of Bitcoin that we analyze is
after the block reward has dropped to zero. That is, trans-
action fees are the only source of revenue for miners, and
we model available transaction fees as arriving to the Bit-
coin system at a constant rate. Speciﬁcally, we assume that
for any time interval I of length t, the total sum of transac-
tion fees for transactions announced during I is t (the choice
of t instead of ct for some constant c is just normalization).
This is diﬀerent from Bitcoin as it is today with a large block
reward compared to the small transaction fees, but this sce-
nario is consistent with the vision of the long-term steady
state behaviour of Bitcoin after all Bitcoins have eventually
been minted.

We also assume that the diﬃculty is set so that a hash puz-
zle is solved by someone in the network every one time unit in
expectation (this is again just a normalization). Addition-
ally, for simplicity, in our theoretical results and reported
simulations we model the network having no latency (unless
otherwise stated). Once a miner publishes a block, all other
miners immediately gain knowledge of it. Similarly, once a
transaction is announced, all miners immediately learn of its
existence. However, our simulator is capable of simulating
latency of both types, and we do not see any substantive
change in our results as latency changes.

Finally, we assume that when there are R transaction fees
available, the miner can choose to include any real-valued
number of transaction fees between 0 and R in their block.
That is, transactions are ﬁne-grained enough that a miner
can selectively choose a set of transactions whose fees are
very close to whatever real-valued target they have in mind.
We believe this is a reasonable approximation due to the
large number of transactions per block.

We also assume that miners always have space to include
all available transactions.
If the block size is not large
enough to meet demand for transactions, we believe the
qualitative content of all our results continue to hold, but the
quantitative impact is mitigated. This belief is supported by
the following data, taken from the most recent 1000 blocks
(roughly one week’s worth) as of July 11, 2016: of these
1000 blocks, 702 are full. Of the full blocks, the total sum
of transaction fees ranges from 0.03 BTC to 4.51 BTC. The
mean is 0.49 BTC and the standard deviation is 0.25 BTC,
more than half the mean. It’s unclear how to extrapolate
these data to the future, but it is clear that there will indeed
be ﬂuctuation in the available fees that ﬁt in a block. So if
the block size is not large enough to meet demand for trans-
actions, even though the available fees immediately after a
block is found will not be zero (as in our analysis), they may
be signiﬁcantly lower than (say) ten minutes later. So even
though our exact analysis will not apply in this setting, the
intuition does carry over.
3.2 What could go wrong? The mining gap

Without a block reward, immediately after a block
is found there is zero expected reward for min-
ing but nonzero electricity cost, making it unprof-
itable for any miner to mine.

156structure. At each instant, every miner makes several dis-
tinct decisions:

• Which block to extend.
• How much of the available transactions (and associated

fees) to include in the block they are solving.

• For each unpublished block, whether or not to publish.

The ﬁrst decision is which block to extend. As an ex-
ample, the default compliant miner chooses to mine on the
longest chain that they are aware of, and in the case of multi-
ple blocks that are tied for the longest chain, they will favor
mining on the ﬁrst of these blocks that they became aware
of. This decision forms the basis for how a mining strat-
egy will determine which side of a fork it wants to support,
or, alternatively, if the miner wants to create a new fork.
The next decision is how much of the available transaction
fees to claim. Again, as an example, the default compliant
miner will include all of the unclaimed transaction fees they
are aware of in their block. The ﬁnal decision is when to
publish blocks. When a miner mines a block, only they are
aware of its existence. At each moment, miners can choose
whether or not to alert the other miners of the block that
they have found. This allows for mining strategies where
miners intentionally choose to not reveal their blocks (such
as selﬁsh mining [9]).

We deﬁne the following concepts in order to more rig-
orously describe the mining strategies: First, for a set of
transactions T , we will abuse notation and use T to also
denote the total transaction fees included for transactions
in T . For a block, B, we will denote Tx(B) to be the set
of transactions included in block B, and Rem(B) to denote
the remaining transactions after block B. That is, Rem(B)
contains all announced transactions in that are not included
in B or any of its predecessors (thus, this is a set that varies
over time). We will also use Height(B) to denote the height
of a block (i.e. the height of a chain that ends at block B),
denoting by H the height of the current longest chain that
has been announced,2 and Owner(B) to denote the miner
that produced block B.

When a miner m is deciding which block of height i to
extend in the case of a tie, all strategies considered in this pa-
per ﬁrst select a block that they themselves mined (Owner(B) =
m). Also, all strategies in this paper avoid mining multiple
blocks at the same height, so if a block with Owner(B) = m
at height i exists, it would be unique.
If m did not pro-
duce any blocks at height i, the default client would then
select the ﬁrst block that m became aware of. So we deﬁne
Oldestm
to be the unique block of height i produced by
i
miner m if it exists, or the ﬁrst block of height i that m
became aware of. Note that if i = H, then this is the block
m would extend using the default strategy. We also deﬁne
Mosti to be the block of height i that maximizes the remain-
ing transaction fees (formally: argmaxB|Height(B)=i{Rem(B)}).
Note that while Rem(B) changes over time, the block Mosti
can only change if a new block of height i is published. Fi-
nally, we denote by Mostm
the block of height i produced
i
by m (if it exists), or the block of height i that maximizes
the remaining transaction fees otherwise.

2So for instance, if a chain of height 2 has been announced,
but some miner is privately storing a chain of length 10, we
would deﬁne H = 2.

Figure 2: Illustration of Mining Gaps. Miners will
only mine when the instantaneous expected reward
exceeds the instantaneous cost.

In order to provide insight as to how time-varying rewards
could be harmful for Bitcoin, let’s walk through an example.
Imagine that we are in the model previously described, that
all miners are using the default compliant strategy (mine on
top of the longest chain, authorize all available transactions,
publish immediately), but also that that miners have some
cost in electricity to run their mining rigs (i.e., running one
rig for t units of time costs pt Bitcoin worth of electricity).
Now, immediately after a block is found, there will be no
more transactions in the network to be claimed by a miner
making the next block. This means that for the instant fol-
lowing the discovery of a new block, there is actually zero
expected reward for mining, but a non-zero electricity cost
for doing so! Figure 2 shows how to extend this reasoning to
the time period beyond. Essentially, every instant your rig
is running, you claim some expected reward, which increases
depending on the available transaction fees. But every in-
stant your rig is running, you also have to pay a constant
amount for electricity. So the expected reward for running
your rig won’t exceed the cost of electricity until some min-
imum number of transaction fees are available to include. If
a is the fraction of the total (eﬀective) hash power that a
single rig generates, then a miner must wait t = p/a time
steps after a block is found before mining becomes proﬁtable
again.

In the full version of this paper, we discuss in more detail
the eﬀects of such a mining gap, and ﬁnd that it leads to
miners mining for a smaller and smaller fraction of the time
between the arrival of blocks (with the diﬃculty dropping
to compensate). Clearly, this would have a negative im-
pact for Bitcoin security, as the eﬀective hash power in the
network would drop, and it would become easier for a mali-
cious miner to fork. Of course, turning a rig on and oﬀ every
ten minutes may be practically infeasible. Nevertheless, this
analysis illustrates that strategic miners might look for ways
to deviate when the default protocol would have them wast-
ing electricity to mine a near-valueless block.
3.3 Formal language for mining strategies

In the rest of this paper, we focus on mining strategies
that always mine within the same cryptocurrency, but may
deviate from the default protocol in choosing how to build
blocks and what to do with them once they’re found. We
consider a variety of known and novel Bitcoin mining strate-
gies. All of these can be formalized into the same general

157We can now formally deﬁne mining strategies we consider.

We model strategies as time-driven (rather than event-driven):
in every inﬁnitesimally small time step, the miner must de-
cide which block to extend (denoted by Mining(m)), what
set of transactions to include, and for each of their own
unpublished blocks, whether to publish. Note that by pub-
lishing a block B, we mean ensuring that every node in the
network is aware of B and all its predecessors, and aren’t
concerned with exactly what physical measures m takes to
ensure this. In this language, the default mining strategy
would be formalized as follows:

DefaultCompliant:
The default Bitcoin mining strategy, including all avail-
able transactions, mining on the end of the longest chain,
choosing the older block in a tie, and publishing all blocks.

Which Block: Mining(m) = Oldestm
H .

How much: include Rem(Mining(m)).

Publish(B)?: yes.

4. MINING STRATEGY SIMULATOR

In order to more clearly analyze what the game theoretic
landscape will look like once the Bitcoin mining incentive be-
comes transaction fee based instead of block reward based,
we have developed a versatile Bitcoin mining strategy sim-
ulator.3 Here we discuss the strategies our simulator is ca-
pable of implementing, the process by which our simulator
can explore a strategy space, the conﬁgurable parameters of
the simulator, and its limitations.
4.1 Strategies, Rounds, and Games

We ﬁrst describe the basic units of our simulator and how

they interact with each other before getting into details.
Strategies. The simulator is designed in such a way to be
able to run any strategy that ﬁts the strategy space detailed
in Section 3.3. That is, every strategy is fully deﬁned by
a function that outputs a block to extend, a set of trans-
actions to include, and a rule to decide whether to publish
any found blocks. All of these functions may take as input
any public information, including all published blocks and
all announced transactions.
Rounds. Our simulator is time-driven, as opposed to event-
driven. We made this decision because we want it to be easy
to add new strategies to the simulator. In an event-driven
simulation, new strategies would be limited by the current
list of possible events. However, in our time-based simula-
tions, any strategy that details how to make the decisions
above at any moment can be easily implemented.

A round is the smallest unit of time in our simulator (cur-
rently, 1/600 of the time it takes for the entire network to
ﬁnd a block). During a round, every miner ﬁrst takes as in-
put the block chain (that they’re aware of) and all transac-
tions (that they’re aware of) and decides which block to (try
to) extend, and which transactions to include. Then there
is a random check (as a function of that miner’s hash rate

3While this is the original motivation for developing our
simulator, it is indeed capable of simulating non-zero block
reward as well — more on that in Section 4.3.

and the current network diﬃculty) to determine whether the
miner successfully found a block or not. Then, the miner de-
cides which unpublished blocks to publish. The duration of a
round is a conﬁgurable parameter, which we discuss shortly
in Section 4.3.
Games. A game involves setting parameters such as choos-
ing a number of miners, assigning their strategies and hash
power, etc. (all detailed in Section 4.3). Once these parame-
ters are set, a game runs for several rounds, and keeps track
of the rewards earned by each miner.
Simulations. A simulation might consist of a single game
(to see how certain strategies fare against each other), or
several games with parameter adjustments in between. For
example, in order to model miners who learn over time, we
have them play several games and decide which strategies
to use in future games based on results of past games. In
principle, any parameters can be adjusted between games.
4.2 Strategy exploration

For several of our simulations we want miners to utilize the
strategies that are doing the best, to simulate how strate-
gic miners might adapt over time. In order to accomplish
this, we run several games, with hundreds of miners in each
game. Miners choose strategies proportional to how success-
ful those strategies have historically done. Formally, min-
ers in our simulator perform no-regret learning, a standard
notion of learning that is popular in game theoretic con-
texts. This is due to the fact that in any repeated game
where each player separately performs no-regret learning,
the repeated play converges to a coarse correlated equilib-
rium [1, 2]. Moreover, numerous simple no-regret learning
algorithms are known that converge quickly (i.e. in a num-
ber of rounds sublinear in the number of possible strate-
gies) [5, 6, 4, 14]. If a miner has no regret, their total re-
ward across all of time is at least as good as had they instead
picked “the best” strategy and used it in every game. Sim-
ilarly, a coarse correlated equilibrium is a joint distribution
over strategy proﬁles such that every miner gets more ex-
pected payoﬀ by following the equilibrium than deviating to
any possible strategy.

These learning algorithms all maintain a weight for every
strategy, and adjust the weights of the strategies from game
to game depending on how well they’re doing. Our simulator
oﬀers two alternatives for these update rules. The ﬁrst al-
ternative is an exact implementation of the EXP3 algorithm
for learning with adversarial bandits [5, 6]. This update rule
provides a theoretical guarantee on the regret of each miner
as a function of the number of games played and a tunable
parameter in the update rule, . The second alternative is
based on the multiplicative weights update rule (MWU) for
learning with experts [4, 14]. We ﬁnd that MWU is com-
putationally expensive, so we use a less expensive proxy in-
stead. That means there is no theoretical guarantee on the
regret bounds. But in practice this update rule is signiﬁ-
cantly faster and does converge quickly to coarse correlated
equilibrium. For a further discussion of these update rules,
see the full version.
4.3 Versatility

Our simulator has many conﬁgurable parameters:

Strategies. Just to reiterate: every miner in our simulator
is assigned a time-driven strategy that chooses which block
to extend, how many transactions to include, and whether

158to publish any found blocks. Any strategy that ﬁts this
framework can be implemented in the simulator. To design
a new strategy, a user would create a new function that takes
as input the current public state of Bitcoin network (the
blockchain and available transaction fees), and the miner
who is using the strategy. The function would then use this
information to determine which block to extend, and how
many of the transaction fees to include in the next block.
Finally, the user would go to the publication rules and add
a rule for how the strategy should choose whether or not to
publish any found blocks.
Hash Power. Every miner m is assigned a hash power αm.
m αm = 1

Any number of miners, and any αm such that(cid:80)

can be supported.
Round Duration. The size of a round can be set so the
network ﬁnds a block every r rounds in expectation, for any
r > 0.
Rewards. At the end of each game, miners are rewarded
based on their blocks within the longest chain. The reward
they receive is b per block (ﬁxed reward), plus any trans-
action fees. a transaction fees accrue in the system every
round. Both of these parameters are conﬁgurable.
Costs. There is a conﬁgurable parameter cm for every miner
m that denotes the cost (i.e. in electricity) for miner m to
mine. For our simulations, we always set cm = 0 because we
aren’t looking at this aspect of mining.
Latency. If desired, latency can be introduced to the simu-
lation. There is a conﬁgurable parameter λ such that when
blocks are published, it takes λ rounds before other miners
are aware of this blocks existence. Latency in hearing about
transactions can also be implemented — it is currently easi-
est to do this by modifying strategies to randomly “pretend”
they haven’t heard of some transactions.
Learning parameter. Our learning rules are parameter-
ized by an  ∈ [0, 1/2]. For EXP3, it is customary to set

 ≈ (cid:112)n ln n/T , where n is the number of strategies con-
 ≈ (cid:112)ln n/T . Smaller  encourages more exploration, and

sidered and T is the number of games played. For MWU
(and our “MWU-like” update rule), it is customary to set

larger  encourages more exploitation.
Atomic versus Non-Atomic Miners. We say miners
are atomic if there are ﬁnitely many of them, and each has
a ﬁnite fraction of the total hash power. Such miners may
have an interest in sacriﬁcing immediate gains related to a
block mined now in order to achieve greater gains for blocks
mined in the future. Non-atomic miners are inﬁnitesimally
small, but there are inﬁnitely many of them. When such
miners ﬁnd a block, they are only interested in maximizing
their gains related to that block (because they will never
ﬁnd another block in the future).

Obviously our simulation cannot create inﬁnitely many
miners, but we can functionally simulate them. To simulate
that an α fraction of non-atomic miners are using strategy s,
we instead create a single atomic miner with an α fraction of
the hash power, and ensure that all of this miner’s strategic
decisions take as input only the public information available
to the entire network, and does not treat “their own” blocks
any diﬀerently than generic blocks.

Of course, the real world is atomic. But it is extremely
helpful to compare simulation results between the two mod-
els to isolate behavior that arises only when miners are
atomic (example: selﬁsh mining), as intuitively this behav-
ior “gets worse” with big miners (as with selﬁsh mining).

4.4 Implementation and performance.

The simulator is written in C++, and has a running time
that is linearly proportional to the product of the number
of games, the number of rounds per game, and the number
of miners. As an optimization to the algorithm, we have the
miner determine if they ﬁnd a block at each time step prior
to actually computing which block they will extend and how
many transaction fees they will include. We ﬁnd that for
accurate results, the games need to include enough rounds
so that that for every strategy, the miners using it together
ﬁnd tens of blocks. We also ﬁnd that it takes on the order
of a few hundred games for our MWUs to converge to an
equilibrium. On a commodity laptop with a 2.7 GHz Intel
Core i5 processor, running a simulation of a single game with
200 miners, an average interarrival time of 600 rounds, and
a total of 6,000,000 rounds (≈10,000 blocks will be created),
takes approximately 400 seconds (6.5 minutes).
Limitations. A current limitation of the simulator is that
the transaction fees can only be modeled as coming in at
a uniform rate in time. Additionally, the simulator is not
capable of modeling mining pool dynamics beyond treating
them as a single miner with hash power equal to that of the
pool. This doesn’t allow for consideration of attacks such as
those presented in [8].

5. NEW DEVIANT MINING BEHAVIOR

In this section, we examine what deviant mining behavior
might unfold in the transaction fees model that doesn’t arise
in the block-reward model. Speciﬁcally, we argue that:

• It is reasonable to expect self-interested miners to be-
come PettyCompliant instead of DefaultCompli-
ant once transaction fees take over.

• The existence of PettyCompliant miners in the net-
work opens the ﬁeld for a range of aggressive strategies
with detrimental eﬀects to Bitcoin’s stability.

5.1 Phase One: Petty compliant

Observation: The default client behavior of min-
ing on the oldest block is not optimal. Miners
can do strictly better by mining on the block that
leaves the most transactions fees unclaimed.

Consider the case where there is a fork: two blocks are
tied for longest chain. The traditional behavior, and the one
programmed into the default client,4 would have the miner
select the older of the two potential block heads. However,
there is really no cost for that miner instead to tie-break
arbitrarily.
In particular, if the miner is planning to in-
clude all unclaimed transactions in their block, it would be
in that miner’s interest not to mine on the oldest block,
but instead the block that leaves the most remaining fees.
Therefore, a strategic miner would want to mine on Mostm
H
instead of Oldestm
H . We call this strategy petty compliant,
as it is still mining on a longest chain, including all available
transactions, and publishing all blocks that are found (like
a default compliant miner). It is just tie-breaking between
longest chains in a “petty” way to achieve greater revenue.

4Note: this is not a self-enforcing part of the protocol. It’s
purely client-side behavior.

159PettyCompliant:
Mine like a default compliant miner, except when choos-
ing between two sides in a fork; mine on the block that
has claimed the fewest transaction fees.

Which Block: Mining(m) = Mostm
H .

How much: include Rem(Mining(m)).

Publish(B)? yes.

If forks ever exist, then PettyCompliant strictly outper-
forms DefaultCompliant. The two are identical except for
the case where the miner is required to choose between two
equal height blocks to mine on. In this case PettyCompli-
ant always makes the decision to mine in a location that
maximizes their rewards, and DefaultCompliant might
In our mining strategy simulator, we compare De-
not.
faultCompliant to PettyCompliant and do in fact see
that PettyCompliant outperforms DefaultCompliant,
regardless of the breakdown of other miners in any simula-
tion where there is enough latency (in learning of both new
blocks and transactions) that forks naturally occur.

Note that the existence of petty compliant miners is not
necessarily harmful by itself:
so what if miners are tie-
breaking diﬀerently in the rare event that forks naturally
occur? The problem arises when other strategic miners no-
tice the existence of petty compliant miners and choose to
exploit this with more aggressive tactics. We’ll see some
examples of this in the remainder of this section. The ex-
istence of PettyCompliant miners impact other deviant
strategies in surprising ways too. For example, a selﬁsh
miner (discussed more in Section 6), performs better against
PettyCompliant miners than DefaultCompliant.
5.2 Phase Two: Lazy Undercutting

Observation: Once some fraction of miners is
petty compliant, other miners may proﬁt by in-
tentionally forking the chain.

The key insight for more aggressive strategies is that a
deviant miner can incentivize petty compliant miners to ex-
tend their block, even if an older block of the same height
was discovered several minutes earlier, for instance, by ex-
tending that block’s direct predecessor and including slightly
fewer transaction fees. If the current unauthorized transac-
tion fees are substantially fewer than those included by the
current MostH, then maybe it is in a miner’s interest to try
and replace MostH with a new block of height H, instead
of continuing on top of it. We call this undercutting.

So what might a strategic miner do to take advantage
of this? They might ﬁrst compare between the maximum
rewards they could get by continuing versus undercutting
(while still becoming the new MostH), and mine on top of
whichever block yields greater rewards. Then, to protect
themselves with certainty against future undercutters using
the same rule, they could take half of the remaining transac-
tions. Because of the somewhat lax reasoning used to choose
these parameters, we call this strategy LazyFork.

While the existence of PettyCompliant miners them-
selves is relatively benign, the existence of LazyFork min-
ers would be bad: they frequently decide to intentionally

orphan blocks in order to achieve greater rewards. In addi-
tion to creating uncertainty about when blocks are “safely”
in the eventual longest chain, this decreases the eﬀective
hash power of the network and makes Bitcoin more prone
to double spend attacks. For cleanliness in formally deﬁning
LazyFork and other undercutting strategies, we introduce
the notation Gapi = Rem(Mosti−1) − Rem(Mosti), the
maximum transaction fees that a miner could include while
mining on top of Mosti−1 to become the new Mosti.

LazyFork:
Forks the blockchain if the head block is more valuable
than the unclaimed transaction fees it leaves behind.
Only takes half of the possible transaction fees to prevent
other lazy forkers from forking their block.

if Owner(Mostm

H ) = m or Rem(Mostm

H ) ≥ GapH

Which Block:

Mining(m) = Mostm
H .

else

Mining(m) = Mostm

H−1.

How much: include Rem(Mining(m))/2.

Publish(B)?: yes.
5.3 Phase Three: Aggressive Undercutting

Simulation result: increasingly aggressive under-
cutting behavior evolves when miners strategize.

Once miners consider undercutting, they may also try to
aggressively optimize the tradeoﬀ between maximizing the
transaction fees included in blocks they mine and minimizing
the chance that their block will be undercut by other miners
in the system (as opposed to using the less-principled reason-
ing of LazyFork). We deﬁne these strategies so that when
they are presented with Rem(Mining(m)) = x, they will
authorize f (x) transactions, for some f (·) with f (x) ∈ [0, x]
for all x, and call them forkers.

While in principle, forkers could consider going back sev-
eral blocks to undercut, the strategies we study only consider
mining on top of a block of height H or H − 1. Certainly,
it would be an interesting direction for future work to see if
any additional gains can be achieved by considering blocks
of height H − 2 or less, but already we uncover interesting
behavior when forkers go back just a single block.

A function forking miner looks at potential blocks at height
H that they could extend, and within this set considers ex-
tending only Mostm
H , since it leaves the most remaining
transaction fees. If a miner indeed chooses to mine on top
of Mostm
H , we call this continuing. They also look at poten-
tial blocks of height H− 1, again considering only extending
the block Mostm
H−1 from this set. If a miner indeed chooses
to mine on top of Mostm
H−1, we call this undercutting. When
deciding whether to continue or undercut, a forker simply
observes that they will choose to claim f (Rem(Mostm
H )) by
H−1)), GapH} if they
continuing, versus min{f (Rem(Mostm
undercut (the min is taken because they must actually un-
dercut in order to incentivize future miners to select their
block). So for a given f , we can deﬁne:

Valcont(f ) = f (Rem(Mostm
Valunder(f ) = min{f (Rem(Mostm

H ))

H−1)), GapH}

160Figure 3: Normalized weights of diﬀerent linear co-
eﬃcient function forking strategies over a series of
games. Strategies that are slightly more aggressive
than the most common strategy perform the best
and have their normalized weights increase. This
simulation had 500 miners, 20 strategies and 1000
blocks per game.

If Valcont(f ) > Valunder(f ), then more rewards can be
achieved by continuing. Otherwise, more rewards can be
achieved through undercutting. Formally, for any function
f (·), this induces the following formal strategy:

Function-Fork(f ):
Always takes a certain function, f (·), of the possible
transactions it could claim. Always mines in the location
to maximize the size of the block they would make, with
the constraint that if they fork, they must undercut.

Which Block:

if Owner(Mostm

H ) = m or Valcont(f ) > Valunder(f )

Mining(m) = Mostm
H .

else

Mining(m) = Mostm

H−1.

How much:

if Mining(m) = Mostm
H

include Valcont(f ).

else

include Valunder(f ).

Publish(B)?: yes.
Any reasonable choice of f (·) will be monotonically in-
creasing, which means that f (Mostm
H−1) will always be larger
than f (Mostm
H ), so the decision on whether to continue or
undercut will come down to a comparison of f (Mostm
H ) ver-
sus GapH.
One natural family of f (·) to consider is linear functions
(that is, f (x) = kx for some k ∈ [0, 1]). If we take a group of
these strategies, and let non-atomic strategic miners learn
over many games which perform best, we get the plot in
Figure 3. What we see is the following: when the majority
of miners are using Function-Fork(kx), the best response
is to use Function-Fork(k(cid:48)x), for k(cid:48) a little smaller than

Figure 4: This is a simulation of atomic miners
undercutting more and more aggressively. We see
that more and more aggressive undercutters per-
form better until at some point the potential re-
ward of mining two blocks in a row dominates all
else, and PettyCompliant goes back to being the
strongest strategy, then the cycle repeats.

k, (i.e. to undercut just a little bit more aggressively). So
eventually the smallest coeﬃcient in our simulation becomes
dominant.
If we instead consider atomic miners, we ob-
serve the behavior in Figure 4: Once Function-Fork(kx)
is dominant for small enough k, the pool of available trans-
actions will grow pretty large (and stabilize around 1/k).
Therefore, PettyCompliant miners have the potential to
get a huge payoﬀ if they get lucky and mine two blocks in a
row (note that this probability is zero for non-atomic min-
ers). As the dominant k gets smaller and smaller, eventually
the huge reward from this unlikely event dominates, Petty-
Compliant becomes the dominant strategy again, and the
cycle repeats.
5.4 An Undercutting Equilibrium

Analytical result: An equilibrium exists where all
miners use the same undercutting strategy. It in-
duces a growing backlog of transactions.

Linear function-forking is of course a natural class of strate-
gies to consider, but our simulations in the previous section
show that long-term behavior may be erratic if miners only
consider these strategies. Our goal in this section is to un-
derstand what undercutting behavior is stable.
Our approach is to ﬁnd a function f (·) such that Function-
Fork(f ) is an equilibrium. That is, as long as every other
miner is using the strategy Function-Fork(f ), it is in your
interest to do so as well. In other words, we would like to
ﬁnd an f such that Function-fork(f ) is a best-response to
the case when all other miners themselves use Function-
fork(f ). We provide now intuition for why the f (·) we
present yields an equilibrium.

So what does it mean for a strategy to be a best-response
to other miner behavior? Recall that a strategy proposes
which block to extend, how many transaction fees to claim,
and which blocks to publish as a function of the currently
held information. A strategy is a best response if it maxi-
mizes the miner’s expected reward (taking into account fu-

161ture events, and in particular the probability that the cur-
rent block is in the eventual longest chain) over all potential
strategies that miner could have used instead. In particular,
a best-response must be at least as good as all other strate-
gies that mine at the same location and publish the same
blocks (but diﬀer in which transactions to include).

To get some intuition for what conditions a potential equi-
librium must satisfy, let’s ﬁrst consider the decision facing
a miner who has already decided to continue on top of the
longest chain and is just deciding how many transaction fees
to include. If F denotes the number of transaction fees in-
cluded, deﬁne π(F, f, x) to be the probability that this block
is included in the eventual longest chain, conditioned on
including F BTC worth of transaction fees in the block,
all other miners using strategy Function-Fork(f ), and
x = Rem(Mostm
H ) (note that π is well-deﬁned). Then the
miner’s expected reward, should they be fortunate enough
to ﬁnd a block right now would be F · π(F, f, x).
A best-response would then be to include argmaxF≤x{F ·
π(F, f, x)} transaction fees. The strategy Function-Fork(f )
would recommend including f (x) transaction fees. So for
Function-Fork(f ) to be a best-response to other min-
ers using Function-fork(f ),
it better be the case that
f (x) ∈ argmaxF≤x{F · π(F, f, x)} for all x. Note that this
is a somewhat strong condition on f , as the fact that the
other miners are using Function-fork(f ) aﬀects π(F, f, x),
whereas we also want this miner’s best response to have
f (x) ∈ argmaxF≤x{F · π(F, f, x)}.
At this point, we show that there is a continuous and
piece-wise diﬀerentiable function f (·) that satisﬁes this con-
dition. We also show that combined with the fact that
f (·) is monotonically non-decreasing, this is suﬃcient for
Function-fork(f ) to be an equilibrium under some as-
sumptions (which we will discuss post-theorem).
In the
theorem statement below, W0 is the upper branch of the
Lambert W function which satisﬁes W0(xex) = x for all
x ∈ [−1/e,∞), and W0(x) ∈ [−1,∞). The “Furthermore...”
portion of the theorem is proved by showing a connection
between the number of backlogged transactions and an un-
biased single-dimensional random walk.
Theorem 5.1. For any constant y ≤ 1/2 such that 2y −
ln(y) ≥ 2,5 deﬁne:

f (x) = x,

∀ x ≤ y

f (x) = −W0(−yex−2y),

∀ y < x < 2y − ln(y) − 1

f (x) = 1,

∀ x ≥ 2y − ln(y) − 1

(1)

(2)

(3)

Then it is an equilibrium for every miner to use the strategy
Function-fork(f ) as long as:

• Every miner is non-atomic.
• Miners may only mine on top of chains of length H or

H − 1.

Furthermore, in any such equilibrium, the expected number
of backlogged transactions after n time steps is Θ(

√
n).

A proof of Theorem 5.1 appears in the full version. To un-
derstand the impact of Theorem 5.1, ﬁrst consider the block
reward model. With non-atomic miners, DefaultCompli-
ant is trivially an equilibrium, and this result is robust to
5Such y exist. This range is (0,≈ 0.2].

Figure 5: Plot of the lambert function fork becom-
ing the strongest strategy in a learning simulation.
This simulation had 200 miners, and 1,000 blocks
per game. These miners are non-atomic and there
is no latency.

general models of latency (proof in the full version). But
as we move to atomic miners, strategies like selﬁsh mining
arise and equilibria get messy (if they exist at all).

Now, in the transaction-fee model, even when miners are
non-atomic, equilibrium behavior is complex and undesir-
able, as we have just shown. Therefore, we should expect
that analysis with atomic miners should conclude with even
more chaos.
5.5 Undercutting Non-strategic Miners

Analytical and simulation result: even if 66% of
miners remain default compliant, undercutting is
proﬁtable.

Our analysis and simulations in the previous sections as-
sumed that all miners were strategic learners. While we
clearly learn a lot from this analysis, it is perhaps more
realistic to also consider a setting where some miners will
stubbornly (or honestly, depending on your perspective),
continue running DefaultCompliant even if it is subop-
timal.
If a large fraction of the miners are non-strategic,
then function-forking becomes immediately less proﬁtable,
because only a small fraction of the network will actually
mine on top of your block when you undercut. In particu-
lar, if 100% of other miners are non-strategic, undercutting
serves no purpose.

In this section, we detail results from our simulation when
varying fractions of miners are non-strategic. In these sim-
ulations, we ﬁnd surprisingly that if we ﬁx a fraction of the
network to always mine DefaultCompliant, then after a
series of games the strategy distribution of the remaining
strategies resulting from our update rules will stabilize. Fur-
thermore, multiple strategies will be present in the stable
distribution (i.e., it would appear that this distribution of
strategies form an equilibrium). Figure 6 shows a stacked
area plot of our simulation results for equilibria at diﬀerent
fractions of miners refusing to abandon DefaultCompli-
ant. There are many interesting features of the plot, but

162we focus on one: even if the majority of miners choose to stay
DefaultCompliant (and the rest strategize), then forking
strategies start to become viable.

A theoretical analysis indeed predicts the continuing pres-
ence of FunctionFork(x) until 2/3 of the miners remain
DefaultCompliant. To see this, imagine that every miner
is the system is currently DefaultCompliant or Petty-
Compliant, and we want to see if it is proﬁtable for a Pet-
tyCompliant miner to switch to FunctionFork(x). At
any point in time, consider the current MostH. Then if the
miner runs PettyCompliant, they will always try to con-
tinue, and will get Rem(MostH) should they ﬁnd a block
(because no one else in the network is undercutting). If in-
stead they run FunctionFork(x), they will continue when-
ever Rem(MostH) > GapH and undercut otherwise. When
they continue, they will always get Rem(MostH). When
they undercut, they would include GapH transaction fees.
If the next miner to ﬁnd a block is PettyCompliant (or
this miner), then the undercut will be successful and the
miner will receive GapH in rewards. But if the next block
is found by a DefaultCompliant miner, the undercut fails
and they get nothing. So if y is the fraction of the network
that remains DefaultCompliant, we see that the expected
reward obtained by FunctionFork(x) is proportional to:6

E[Rem(MostH) · I(Rem(MostH) > GapH)]

+ (1 − y) · E[GapH · I(GapH > GapH)]

Finally, because Rem(MostH) and GapH are i.i.d. exponen-
tial random variables with mean 1, we have that E[GapH ·
I(GapH > Rem(MostH))] = E[Rem(MostH)·I(Rem(MostH) >
GapH)] = 3/4. Therefore, whenever y ≤ 2/3, the reward
from FunctionFork(x) is at least one, and therefore it is a
better choice than PettyCompliant (which gets expected
reward exactly one).

6. SELFISH MINING WITH TRANSACTION

FEES

Selﬁsh mining is a deviant strategy ﬁrst identiﬁed by Eyal
and Sirer [9]. Essentially, a selﬁsh miner chooses not to
release blocks immediately upon being found, instead with-
holding them in hopes of tricking the rest of the network
into wasting their mining power mining blocks that will be
orphaned.

Surprisingly, the selﬁsh mining strategy performs even
better in the transaction fees model than the block-reward
model. A priori, there’s no reason to expect this. In this sec-
tion we provide simulation results, along with some intuition
and a theoretical analysis proving this. Essentially what
winds up happening is that while the selﬁsh miner mines
the same fraction of blocks in either reward model, the self-
ish miner’s blocks will tend to be larger. In the block-reward
model, this doesn’t matter because all blocks are worth the
same, but in the transaction fees model this means the self-
ish miner gets greater reward.
6.1 The Selﬁsh Mining Strategy

Analytical and simulation result: selﬁsh mining
performs slightly better in the transaction fee model.

6E[X] denotes the expectation of the random variable X,
and I(E) denotes the indicator random variable for event E
(that is 1 when E occurs and 0 otherwise).

Figure 6: This is a stacked area chart showing the
equilibrium distributions of strategies covered thus
far for a fraction of miners that will use the de-
fault strategy regardless of its relative performance.
These simulations involved 200 miners, with 10,000
blocks per game. We found that the strategies would
reach an equilibrium around 120 games.

The goal of a miner employing the selﬁsh mining strategy
is to essentially trick the other miners in the Bitcoin network
to mine on top of a block that will be orphaned. By having
other miners waste their power, the selﬁsh miner is capa-
ble of exaggerating their own portion of the overall network
hash-rate. Selﬁsh miners do this by maintaining a chain in
private that only they know about. When the selﬁsh miner
initially ﬁnds a block, they will not announce their block to
the rest of the network. They will continue to mine on their
private block, hoping to ﬁnd a second block before the rest
of the network ﬁnds a block.

If the miner succeeds, now they’re in a very strong posi-
tion: they know of a block with height H + 2, whereas the
rest of the network only knows a block of height H. If the
rest of the network ﬁnds the next block at height H + 1, the
selﬁsh miner can reveal their private chain and the public
block will be immediately orphaned. Of course, maybe the
selﬁsh miner will ﬁnd the third block as well. In this case,
they’re in an even better position and can waste even more
of the network’s power. But the point is that with a lead of
two or more, the selﬁsh miner can guarantee that the rest
of the network is wasting power.

Of course, the selﬁsh miner might also fail to ﬁnd a sec-
ond block before the rest of the network ﬁnds their ﬁrst. In
this case, they immediately release their block and hope that
others hear about theirs ﬁrst. Obviously this is not ideal:
had they released their block immediately, they could have
guaranteed that it was heard about ﬁrst. So there’s a trade-
oﬀ - withholding the block has a chance to give the selﬁsh
miner a private chain of length two or more, in which case
the selﬁsh miner beneﬁts, but it also has the chance to cause
their own block to be orphaned, resulting in less proﬁts to
the selﬁsh miner.

163Assuming the selﬁsh miner has less than half of the overall
hash power of the network, they will eventually need to pub-
lish their private chain. In order to maintain our focus on the
diﬀerence between transaction fees and ﬁxed block-rewards,
we consider just “vanilla” selﬁsh mining, although it is an
interesting consideration for future work to consider selﬁsh
miners who also undercut, or various other generalizations
(e.g. [7, 19, 22]). Similarly to [9], we examine the potential
rewards a selﬁsh miner would receive assuming that the rest
of the network is default mining. In our analysis, we also
use α to denote the fraction of the total mining power pos-
sessed by the selﬁsh miner, and γ to be the probability that
in the event of a race (selﬁsh miner is triggered to release
a private block of length one) that ends with the honest
portion of the network ﬁnding the next block, that the self-
ish miner’s block is not orphaned. We introduce notation
Privatem to denote the height of the longest chain that m
is aware of (at least as long as H, and possibly longer if m
is keeping any blocks private). We also introduce notation
Racingm
i to be a boolean variable that is true iﬀ there exist
two blocks B1, B2 with Height(B1) = Height(B2) = i, and
Owner(B1) = m (cid:54)= Owner(B2). In other words, Racingm
i
denotes whether or not there are two competing blocks of
height i, one of which was produced by m.

Selfish-Mine:
Selﬁsh mining strategy from [9]. This miner hides their
blocks, which risks losing their ﬁrst block, in order to try
to get the rest of the network mining in a useless location,
amplifying their own apparent hash power.

Which Block: Oldestm

Privatem .

How much: include Rem(Mining(m)).

Publish(B)?:

if Height(B) = H

yes.

elseif Racingm

H , and Privatem = H + 1

yes.

else

no.

Analysis.

We proceed now with an analysis of the rewards obtained
in the transaction fee model by a selﬁsh miner. Parts will
look similar to the analysis done in [9]. For every inﬁnitesi-
mally small transaction fee that arrives, we wish to compute
the probability that it winds up in a block mined by the self-
ish miner. Note that if the selﬁsh miner just used default
mining instead, this probability would be exactly α.

The determining factor in this probability will be the size
of the selﬁsh miner’s private chain. To this end, let’s de-
ﬁne the following states (same states used in [9]), and we’ll
compute this probability separately for each state.

• State 0: Everyone agrees on the longest chain — Racingm

H =

false.

• State i > 0: The selﬁsh miner m has a private chain

of length i — Privatem = H + i.

• State 0(cid:48): There are competing blocks of height H, one
of which was produced by the selﬁsh miner, and the

selﬁsh miner has no private blocks — Racingm
and Privatem = H.

H = true

Let fs denote the probability that a transaction winds up
in a block mined by the selﬁsh miner in the eventual longest
chain, conditioned on the system being in state s when the
transaction is announced. We claim that we can compute
these probabilities and do so below.
If we then deﬁne ps
to be the probability that the system is in state s, we can
then observe that the expected fraction of transaction fees
s fs · ps. Eyal and
Sirer [9] have already computed ps for all s. The values for
ps are:

claimed by the selﬁsh miner is exactly(cid:80)

p0 =

p0(cid:48) =

1 − 2α

2α3 − 4α2 + 1
(1 − α)(α − 2α2)
2α3 − 4α2 + 1
α

)i−1

pi = (

1 − α

α − 2α2

2α3 − 4α2 + 1

, i > 0

To complete the analysis, we just need to compute fs for
each s. The full version of the paper contains the derivation
of fs for all s, which are stated below:

f0 = α2 + α(1 − α) (α + γ(1 − α)) .
f0(cid:48) = α.
f1 = α + (1 − α)α = α(2 − α).
fi = 1 − ((1 − α)i−1(1 − f0)).

Finally, when α ∈ (0, .5) and γ ∈ [0, 1], we show in the

full version that the selﬁsh miner’s rewards are given by

Reward(α, γ) =

5α2 − 12α3 + 9α4 − 2α5 + γ(α − 4α2 + 6α3 − 5α4 + 2α5)

2α3 − 4α2 + 1

We make the following observations:
• Simulation conﬁrms the above analytical formula for

Reward(α, γ) (Figure 7)

• This function is extremely close to the reward function
with block rewards ( α(1−α)2(4α+γ(1−2α))−α3
) from [9].
We ﬁnd, numerically, that the absolute diﬀerence never
exceeds 0.026 in the region of interest.

1−α(1+(2−α)α)

• For 0 ≤ γ < 0.55 (in particular, for γ = 0), for all α ∈
(0, 0.5), the reward is strictly greater in the transaction
fee model than in the block reward model.

We provide some intuition for this last point. First, it
is clear that the fraction of blocks mined by the selﬁsh vs.
default miners is independent of the reward model. So the
gap must come from the size of blocks found by the respec-
tive miners. Let’s assume just for the sake of example that
we are in state 100 and the selﬁsh miner has an α = 1/10
fraction of the mining power. Almost certainly, the next
un-orphaned block will be found by the selﬁsh miner. How
long will it take for this block to be found? The answer is

164Figure 7: We see simulation matching the theory for
selﬁsh mining in a transaction based model for γ =
0, 0.5, and 1.

approximately 10 time steps. This is because while the en-
tire network ﬁnds a block roughly every time step, because
the selﬁsh miner is the only miner extending his chain (and
he mines at 1/10 the speed of the full network) it will take
ten times as long. What this means is that blocks found by
the selﬁsh miner while the selﬁsh miner has a huge lead are
disproportionately large compared to blocks found when the
selﬁsh miner has no lead (or a tiny lead). So even though
the selﬁsh miner wins the same fraction of blocks, some of
these blocks are much larger than those won by the default
miners.
A brief discussion. The main point of this section is to
highlight one example of surprising incentive issues that dif-
fer between the transaction fees model and the block-reward
model, not to argue that selﬁsh mining becomes signiﬁcantly
better (the improvement is minor). Still, we wish to point
out two possibly salient diﬀerences between selﬁsh mining
in the two models. First, in the block-reward model, self-
ish mining is actually not ever immediately proﬁtable — it
only becomes proﬁtable once the diﬃculty readjusts to ac-
count for the fact that the eﬀective mining power in the
network is lower. This is because before the diﬃculty ad-
justs, the selﬁsh miner is literally just throwing blocks away,
but tricking the rest of the network into throwing blocks
away at a higher rate. In the transaction fees model, selﬁsh
mining is immediately proﬁtable — every transaction that
arrives goes somewhere, so neither the selﬁsh miner nor the
default miners are throwing rewards away. Note also that
our analysis in no way requires the diﬃculty to adjust before
it becomes accurate — our analysis would hold no matter
how the diﬃculty of hash puzzles adjusted or didn’t adjust
over time. Moreover, if some of the rest of the network
has switched to the PettyCompliant strategy, then the
selﬁsh miner’s block is actually more likely to win when a
race is triggered (because it was mined earlier and therefore
contains fewer transactions). So the existence of Petty-
Compliant miners in the transaction fees regime indirectly
improves Selfish-Mine’s performance by increasing γ.

Figure 8: We show the ideal cutoﬀ factor, β, for a
selﬁsh miner with mining power α, and γ = 0.

6.2 An Improved Selﬁsh-Mine

Analytical and simulation result: in the transac-
tion fee model, selﬁsh miners can make the de-
cision whether to hide their ﬁrst block based on
the value of the block. This improved selﬁsh min-
ing strictly and always outperforms both default
mining and traditional selﬁsh mining.

In this section we develop an improved selﬁsh mining
strategy. Essentially, we observe that in the transaction fees
model, a selﬁsh miner has additional information when de-
ciding whether to hide or publish their private chain (namely,
how many transactions are included). We show that, for
all α, γ < 1, our strategy strictly outperforms both default
mining and “vanilla” selﬁsh mining in the transaction fees
model. Our strategy will decide to hide only “small” blocks,
with at most β (some cutoﬀ parameter chosen by the strat-
egy as a function of α, γ) transaction fees included, but will
immediately publish any “large” blocks, with more than β
transaction fees in order to avoid the risk of losing them.

Intuitively, imagine you are mining and ﬁnd yourself solv-
ing a new block immediately after a previous block was
announced and before any new transactions have been an-
nounced. This block is literally worthless, so instead of pub-
lishing, why not use it to try and selﬁsh mine? There is
no cost, but a positive probability that you build a lead of
two, no matter your hash power. Similarly, imagine instead
that just by chance an hour goes by since the last block was
found and you just solved a new block including all trans-
actions that arrived during that period. This block is worth
roughly six “normal” blocks, so why risk losing it? Unless
your hash power is very close to 50%, the expected gains
from selﬁsh mining are dwarfed by the possibility of losing
this unusually wealthy block. So the trick is just choosing
the proper cutoﬀ β as a function of your hash power α and
network connectivity γ.
Note that Selfish-Mine(0) = DefaultCompliant, and
that Selfish-Mine(∞) = Selfish-Mine. So clearly, taking
the optimal choice of β will result in a strategy that equals
or outperforms both. Using an analysis similar to that of
Section 6.1, we are able to compute the expected reward
achieved by a miner with an α fraction of the mining power,

165Figure 9: Theory matching simulation for a variety
of cutoﬀ thresholds for selﬁsh mining, all with γ =
0. The smaller cutoﬀs do better for a miner with
a smaller hash-power (α) and the larger cutoﬀs do
better with a larger hash-power.
Intuitively, this
makes sense as a more powerful miner should be
willing to risk a larger block to try to selﬁshly mine.

a γ success probability of winning a race, and using strat-
egy Selfish-Mine(β). A derivation is included in the full
version.

Selfish-Mine(β):
An improvement to the selﬁsh mining strategy, where the
miner will chose to mine as a selﬁsh miner or a default
compliant miner based on the value of the block they risk
losing.

Which Block: Oldestm

Privatem .

How much: include Rem(Mining(m)).

Publish(B)?

if Height(B) = H or Tx(B) ≥ β

yes.

elseif Racingm

H , and Privatem = H + 1

yes.

else

no.

Reward(α, γ, β) =

(cid:18) 1 + β(1 − α)2(1 − γ)

eβ − 1

(cid:19)

− 2α2

(cid:19)

(cid:18)

+ 5α + (1 − α)2γ +

2α2
1 − 2α
α(1 − 2α)(1 − e−β)

1 − 2e−βα − 3(1 − e−β)α2

×

Figure 8 contains a plot showing the optimal choice of β as
a function of α when γ = 0. A few noteworthy points from
this plot: as α → 0, so does the optimal β. As α → 1/2,
the optimal β approaches ∞. Figure 9 plots our theoretical
predictions against simulation results, conﬁrming that the
analysis is correct.

We conclude this section with Figure 10 plotting the (the-
oretical) performance of default mining, selﬁsh mining, and

Figure 10: A selﬁsh miner using the optimal cutoﬀ
outperforms both the original selﬁsh mining proto-
col and default mining for all values of α, with γ = 0.
The simulation points conﬁrm that the theory is ac-
curate.

selﬁsh mining with the optimal cutoﬀ for a range of α and
γ = 0. Note that in some ranges, the gains are quite signif-
icant. Speciﬁcally, when α = 1/3, both selﬁsh mining and
default mining achieve expected reward of ≈ 1/3, but selﬁsh
mining with the optimal cutoﬀ achieves an expected reward
of ≈ .38, a 13.6% increase!

7.

IMPACT ON BITCOIN AND LESSONS FOR
CRYPTOCURRENCY DESIGN

We have argued that deviant mining strategies in a transaction-

fee regime could hurt the stability of Bitcoin mining and
harm the ecosystem. In a block chain with constant forks
caused by undercutting, an attacker’s eﬀective hash power
is magniﬁed because he will always mine to extend his own
blocks whereas other miners are not uniﬁed. This would
make a “51%” attack possible with much less than 51% of
the hash power.

Many other unanticipated side-eﬀects may arise. In the
block size debate, it is frequently argued or assumed that
space in the block chain will be a scarce resource and a
market will emerge, with users being able to speed up the
conﬁrmation of a transaction by paying a suﬃciently large
transaction fee. But if miners intentionally “leave money on
the table” when solving blocks, as is the case in undercutting
attacks, it breaks this assumption. That is because under-
cutting miners are not looking to maximize the transaction
fee that they can claim, and don’t have a strong reason to
prioritize a transaction with a high fee.7 Put another way,
the block size imposes a constraint on the total size of trans-
actions in a block and the threat of being undercut imposes
another constraint on the total fee. The two interact in
complex ways. We believe that qualitatively our results will

7They do have a weak reason: miners beneﬁt from creat-
ing the smallest possible block for a given value of the to-
tal transaction fee they seek to claim, since smaller blocks
propagate faster through the network and are less likely to
be orphaned.

166continue to hold in a world where the available block size is
much smaller than the demand, but quantitatively the im-
pact of undercutting will be mitigated (see end of Section
3.1). Still, it is an important direction for future research to
understand this connection more rigorously.

Despite the variety of our results, we believe we have only
scratched the surface of what can go wrong in a transaction-
fee regime. To wit: we have not presented an analysis of
miners whose strategy space includes both undercutting and
selﬁsh mining, primarily due to the complexity of the result-
ing models.

There has been scant attention paid to the transition to
a transaction-fee regime. The Nakamoto paper addresses it
brieﬂy: “The incentive can also be funded with transaction
fees... Once a predetermined number of coins have entered
circulation, the incentive can transition entirely to transac-
tion fees and be completely inﬂation free” [18]. Similar com-
ments on the Bitcoin Wiki and other places suggest that
the community views the transition as unremarkable. Some
altcoins (Monero, Dogecoin) have even opted to hasten the
block reward halving time.

Our results suggest a diﬀerent view. We see the block re-
ward as integral to the stability of the mining game. At a
minimum, analyzing equilibria in the transaction-fee regime
appears dramatically harder than in the block-reward regime,
which is a cause for concern by itself. The monetary inﬂa-
tion resulting from making the block reward permanent, as
Ethereum does, may be a small price to pay to ensure the
stability of a cryptocurrency.

8. ACKNOWLEDGMENTS

[9] I. Eyal and E. G. Sirer. Majority is not enough:

Bitcoin mining is vulnerable. In Financial
Cryptography and Data Security, pages 436–454.
Springer, 2014.

[10] K. Hill. Bitcoin is not broken. Forbes, 2013.

http://www.forbes.com/sites/kashmirhill/2013/11/
06/bitcoin-is-not-broken/#55d4a8812568.

[11] N. Houy. The economics of bitcoin transaction fees.

Working Paper GATE 2014-07. halshs-00951358.,
2014.

[12] B. Johnson, A. Laszka, J. Grossklags, M. Vasek, and

T. Moore. Game-theoretic analysis of ddos attacks
against bitcoin mining pools. In Proceedings of the
First Workshop on Bitcoin Research, 2014.

[13] J. A. Kroll, I. C. Davey, and E. W. Felten. The

economics of bitcoin mining, or bitcoin in the presence
of adversaries. In Proceedings of the Twelfth Annual
Workshop on the Economics of Information Security
(WEIS), 2013.

[14] N. Littlestone and M. K. Warmuth. The weighted
majority algorithm. Inf. Comput., 108(2):212–261,
1994.

[15] L. Luu, J. Teutsch, R. Kulkarni, and P. Saxena.

Demystifying incentives in the consensus computer. In
Proceedings of the ACM Conference on Computer and
Communications Security (CCS), 2015.

[16] A. Miller and R. Jansen. Shadow-bitcoin: scalable

simulation via direct execution of multithreaded
applications. In Proceedings of the eighth workshop on
Cybersecurity Experimentations and Test (CSET),
2015.

We are extremely grateful to Jiechen Chen, Kira Goldner,
Anna Karlin, and Rainer B¨ohme for very detailed feedback
on an earlier draft of this paper.

[17] M. M¨oser and R. B¨ohme. Trends, tips, tolls: A

longitudinal study of bitcoin transaction fees. In
Workshop on Bitcoin Research, pages 19–33, 2015.

[18] S. Nakamoto. Bitcoin: A peer-to-peer electronic cash

system, 2008.

[19] K. Nayak, S. Kumar, A. Miller, and E. Shi. Stubborn

mining: Generalizing selﬁsh mining and combining
with an eclipse attack. In IEEE European Symposium
on Security and Privacy (EuroS&P), 2016.

[20] R. Peter. A transaction fee market exists without a

block size limit. 2015.

[21] M. Rosenfeld. Analysis of bitcoin pooled mining

reward systems. CoRR, abs/1112.4980, 2011.

[22] A. Sapirshtein, Y. Sompolinsky, and A. Zohar.
Optimal selﬁsh mining strategies in bitcoin. In
Financial Cryptography and Data Security, 2016.
[23] M. Vasek, M. Thornton, and T. Moore. Empirical
analysis of denial-of-service attacks in the bitcoin
ecosystem. In Proceedings of the First Workshop on
Bitcoin Research, 2014.

9. REFERENCES
[1] Calibrated learning and correlated equilibrium. Games

and Economic Behavior, 21(1):40–55, 1997.

[2] A simple adaptive procedure leading to correlated
equilibrium. Econometrica, 68(5):1127–1150, 2000.

[3] E. Androulaki, G. O. Karame, M. Roeschlin,

T. Scherer, and S. Capkun. Evaluating user privacy in
bitcoin. In Proceedings of Financial Cryptography,
2013.

[4] S. Arora, E. Hazan, and S. Kale. The multiplicative

weights update method: a meta-algorithm and
applications. Theory of Computing, 8(1):121–164,
2012.

[5] P. Auer, N. Cesa-Bianchi, Y. Freund, and R. E.
Schapire. The nonstochastic multiarmed bandit
problem. SIAM Journal of Computing, 32(1):48–77,
2002.

[6] A. Blum and Y. Mansour. From external to internal

regret. Journal of Machine Learning Research,
8:1307–1324, 2007.

[7] N. T. Courtois and L. Bahack. On subversive miner

strategies and block withholding attack in bitcoin
digital currency. CoRR, abs/1402.1718, 2014.

[8] I. Eyal. The miner’s dilemma. In Security and Privacy
(SP), 2015 IEEE Symposium on, pages 89–103. IEEE,
2015.

167