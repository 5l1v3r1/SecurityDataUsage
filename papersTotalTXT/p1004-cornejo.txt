Characterization of Real-Life PRNGs under Partial State

Corruption

Mario Cornejo

École Normale Supérieure & INRIA, France

mario.cornejo@ens.fr

Sylvain Ruhault

École Normale Supérieure & Oppida, France

sylvain.ruhault@ens.fr

ABSTRACT
Pseudo-random number generators (PRNGs) are widely used
as a randomness source in cryptographic applications. It is
essential for their security that the internal state, in which
the entropy is accumulated, is kept secret. However, this
assumption is unrealistic for PRNGs that are implemented
in software, as the internal state can be partially corrupted
through memory corruption bugs such as buﬀer overﬂows
or through faults attacks. The recent Heartbleed bug gives
us a concrete illustration of this vulnerability. In this work
we study several widely used PRNGs from diﬀerent popu-
lar providers, including OpenSSL, OpenJDK, Android, IBM
and Bouncy Castle and we characterize how they handle
their internal states. We formalize a framework based on
the most recent and strongest security model called robust-
ness of PRNGs to analyze these PRNGs and their imple-
mentations. With this framework we capture the notion of
how much of the internal state must be corrupted in order
to generate a predictable output. Using this framework, we
determine the number of bits of the internal state that an
attacker needs to corrupt in order to produce a predictable
output. We also show that two of the PRNGs do not re-
quire state compromise to generate a non-random output.
To the best of our knowledge, we present the ﬁrst thorough
characterization of an IBM implementation of a PRNG.

Categories and Subject Descriptors
D.4.6 [Operating Systems]: Security and Protection—
Cryptographic controls; G.3 [Mathematics of Comput-
ing]: Probability and Statistics—Random number genera-
tion

Keywords
Randomness; Security models; OpenSSL; Android; Java

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS’14, November 3–7, 2014, Scottsdale, Arizona, USA. 
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-2957-6/14/11. . . $15.00
http://dx.doi.org/10.1145/2660267.2660377.

1.

INTRODUCTION

In cryptography, randomness plays a important role in
multiple applications.
It is required in fundamental tasks
such as key generation, masking and hiding values, nonces
and initialization vectors generation, etc. The security of
these cryptographic algorithms and protocols relies on a
source of unbiased and uniform distributed random bits.
The unpredictability of these bits is in practice achieved us-
ing a Pseudo-Random Number Generator (PRNG) which is
an algorithm that accumulates entropy from the environ-
ment and produces (pseudo-)random strings indistinguish-
able from the uniform distribution to a computationally-
bounded adversary. PRNGs designers assume that the in-
ternal state S remains secret to the adversary. However, for
software implementations this may be unrealistic as the in-
ternal state can be partially compromised through memory
corruption attacks such as buﬀer overﬂows or fault attacks.
Diﬀerent memory corruption attacks are presented by Er-
lingsson et al. in [20] and by van der Veen et al. in [31] and
faults attacks against cryptographic schemes are presented
by Biham and Shamir in [12] and by Boneh et al. in [13].
Recently, the Heartbleed bug [9] aﬀected the OpenSSL cryp-
tographic library. This bug allows an attacker to get the con-
tent of the memory of the OpenSSL process run by a server
(or a client). Although the attacker can control the size of
the compromised memory, she can not control its location,
therefore she can get total or partial access to sensitive in-
formation as the internal state of the PRNG.

Currently there are numerous implementations from dif-
ferent providers, and most of them rely on internal directives
and parameters that are poorly documented or even undoc-
umented.
In most implementations, a PRNG contains a
dedicated internal state S which is refreshed periodically
with the entropy I collected from its environment (such as
network input/output, keyboard presses, processor clock cy-
cles) and secondly used to compute pseudo-random strings.
The randomness collection task is harder and takes much
more time than the output generation task; this is the rea-
son why PRNGs typically maintains an internal state, which
is the most critical part of the PRNG and therefore needs to
be kept secure during its update. We give a formal deﬁnition
of a PRNG in Section 2.

Using recent theoretical results in the ﬁeld, we provide in
this work a new security model and we present it as a frame-
work in Section 3. We use this framework for the analysis of
widely used PRNGs and in Section 4 we identify new poten-
tial vulnerabilities due to the way they handle their internal
state during its update.

1004Only few concrete implementations have been analyzed
since the ﬁrst work of Gutmann in 1998 [21] and the guide-
lines for developing PRNGs given by Kelsey et al. in [24].
Recently Michaelis et al. in [26] have described and analyzed
several Java implementations; they have also identiﬁed some
weaknesses. There has been little research by theoretical
cryptographers in the area of PRNGs.
In one of the ﬁrst
works in this area, Desai et al. [15] modeled a PRNG as a
pair of algorithms: the Seed Generation algorithm and the
Output Generation algorithm. This model assumes the ex-
istence of an entropy pool, diﬀerent from the internal state,
in which randomness is accumulated, that is used to refresh
the internal state of the PRNG. An elegant and remark-
able work by Barak and Halevi [11] modeled a PRNG as a
pair of algorithms (refresh, next) and deﬁned a new security
property called robustness based on the design guidelines of
Kelsey et al.. This property assesses the behavior of a PRNG
after the compromise of its internal state, but fails to cap-
ture the small and gradual entropy accumulation present in
most real-life implementations. A follow-up paper by Dodis
et al. [16] identiﬁed the problem of this slow (and potentially
malicious) entropy accumulation and reﬁned the robustness
property of a PRNG deﬁned by Barak and Halevi. This new
property, still named robustness, captures the idea of how
the entropy of the input data should be accumulated in the
internal state after a state compromise. To our knowledge,
this last security model is the strongest one as it considers
the most powerful attacker against a PRNG. A recent work
by Dodis et al. in [17] extends the robustness model to ad-
dress the premature next attack where the internal state has
insuﬃcient entropy and an output is generated.

Our work complements the security model of [16] in a
diﬀerent way than [17] does. We propose a new attacker
proﬁle that captures real-life situations where a partial in-
ternal state corruption is possible. We also show an analysis
of real-life PRNGs using this security model and we demon-
strate how it can help to identify new vulnerabilities.
In
particular, we show that a full internal state corruption is
not necessary to compromise a PRNG, instead only a partial
one may be suﬃcient. We characterize how a PRNG can be
attacked in order to produce a predictable and we identify
how many bits of the internal state are required to mount
an attack against the PRNG.

Other Randomness Weaknesses. Several recent attacks
occurred due to an insuﬃcient understanding of PRNG im-
plementations. One striking example is the failure in the
Debian Linux distribution, where commented code in the
OpenSSL PRNG forced the only source of entropy to be
the PID. An analysis of Linux PRNGs dev/random and de-
v/urandom was done in 2006 by Gutterman et al. in [22],
completed by Dodis et al. in [16]. Gutterman et al. pre-
sented an attack for which a ﬁx has been published. Dodis
et al. presented attacks against these PRNG related to their
internal entropy estimator. Heninger et al. in [23] presented
an analysis of the behavior of Linux PRNG that explains
the generation of low entropy keys when these keys are gen-
erated at boot time. The Windows PRNG CryptGenRandom
was analyzed in 2006 by Dorrendorf et al. in [18]; the authors
showed an attack on the forward security of the PRNG im-
plemented in Windows 2000, for which a ﬁx has been pub-
lished. Argyros and Kiayias [10] showed practical attacks
on web applications exploiting randomness vulnerabilities
in PHP applications. More recently, a ﬂaw in the Android

Table 1: Summary of our Results
State Size

Instance

PRNG

OpenSSL
Android

OpenJDK

Bouncycastle

IBM

SHA1PRNG
SHA1PRNG

NativePRNG

SHA1PRNG
SHA1PRNG

8576
3136
352
5472
448
680

λ(∗)
320

0
32

1056

0
32

(*) λ denotes the size of the part of the internal state
an attacker needs to corrupt to attack the PRNG.

PRNG, identiﬁed by Kim et al. in [25], has been actively
exploited against Android-based Bitcoin wallets [27]. This
illustrates the need for precise evaluation of PRNG imple-
mentations based on clear security requirements.
Our Contributions. From a theoretical viewpoint, we
formally extend the security model of [16], to capture the
behavior of a PRNG against an attacker that has partial
access to its internal state. From a practical side, we char-
acterize and give a new security analysis of PRNG imple-
mentations from widely used providers in real-life appli-
cations: OpenSSL, OpenJDK, Android, Bouncycastle and
IBM. To our knowledge, while intensively used in practice,
these PRNGs have not been evaluated w.r.t. recent security
models. Our analysis reveals new vulnerabilities of these
PRNG due to the implementation of their internal state in
several ﬁelds that are not updated securely during PRNG
operations. Our results are summarized in Table 1. In this
table, we give the size in bits of the internal state of the
PRNG and the number of bits (named λ) that an attacker
needs to compromise in order to mount an attack against
the PRNG.

2. PRELIMINARIES

In this section we describe our notation and deﬁnitions

used, adapted from the work of Dodis et al., in [16].
Notation. We denote with [S||I] the concatenation of the
bit string S with the bit string I and we denote with |S|
the length (in bits) of the bit string S. We denote with
S[n] the nth byte of S and S[n,··· , m] (or [S]m
n ) the ex-
tracted bytes of S from the nth to the mth.
Instructions
and code references are denoted with the verbatim style as
in SecureRandom. When X is a discrete distribution, or a
random variable following this distribution, we denote with
x $← X that x is sampled according to X. We denote with
H∞(X) the min-entropy of a distribution X.
Pseudo-Random Number Generator. We recall the
deﬁnition of a PRNG given in [16].
It uses the following
notations: a state S ∈ {0, 1}n, an input I ∈ {0, 1}p, an
output R ∈ {0, 1}(cid:96).
Deﬁnition 1 (PRNG). A PRNG is a triple of algorithms
G = (setup, refresh, next) where:
• setup: A probabilistic algorithm that outputs some pub-
lic parameters seed.
• refresh: A deterministic algorithm that, given seed,
a state S and an input I, outputs a new state S(cid:48) =
refresh(S, I, seed) ∈ {0, 1}n.
• next: A deterministic algorithm that, given seed and
a state S, outputs a pair (S(cid:48), R) = next(S, seed) where
S(cid:48) is the new state and R is the output.

1005The parameter seed is public and common to all the above
algorithms; for clarity, we remove it and we write S(cid:48) =
refresh(S, I) instead of refresh(S, I; seed) and (S(cid:48), R) = next(S)
instead of next(S; seed).
Distribution Sampler As in [16], we divide the adversary
into two parts, the ﬁrst one is the adversary A whose goal is
to distinguish the outputs of the PRNG from random and
the second one is the distribution sampler D which is used
by A to produce (potentially biased) inputs.

Deﬁnition 2 (Distribution Sampler). A distribution sam-
pler D is a stateful and probabilistic algorithm which, given
the current state σ, outputs a tuple (σ(cid:48), I, γ, z) where:

• σ(cid:48) is the new state for D;
• I ∈ {0, 1}p will be the next input for the refresh algo-
• γ is some entropy estimation of I;
• z is the possible leakage about I given to A.

rithm;

We denote q the upper bound on the number of executions of
D. The distribution sampler D is provided by the adversary
A and its goal is to generate the inputs that will be used by
G to improve the quality of its entropy with the refresh al-
gorithm. The adversary has to provide the deﬁnition of the
distribution sampler before its knowledge of the seed. The
distribution sampler models the potentially adversarial en-
vironment of G, with biased inputs. A distribution sampler
is called legitimate if the min-entropy of every input Ij is not
smaller than the entropy estimate γj, even given all the addi-
tional information: H∞(Ij | I1, . . . , Ij−1, Ij+1, . . . , Iq, z1, . . . ,
zq, γ1, . . . , γq) (cid:62) γj, for all j ∈ {1, . . . , q} where (σi, Ii, γi, zi)
= D(σi−1) for σ0 = 0 and i ∈ {1, . . . , q}.

3. PRNG SECURITY

In this section, we present the security model that we use
to analyze PRNG implementations. First we analyze ex-
isting security models and then we identify implementation
details that should be taken into account. Finally, we illus-
trate our analysis on a concrete example and we give the
formalism.
3.1 From Theory to Practice
From Security Models to Implementations. We dis-
cuss brieﬂy some interesting common points in the security
models presented in [15, 11, 16] as well as their potential
use to assess PRNG implementations. Three security mod-
els consider an adversarial environment for the PRNG. The
security model of [15] does not take into account an attack
in which the PRNG is refreshed with adversarial inputs,
whereas this situation is considered in [11] and [16]. In [15],
the internal state of the PRNG is composed of two parts,
named key and initial state; the generation algorithm takes
as input both of them and updates the initial state.
In
concrete implementations the internal state is considered as
a single entity, as modeled in [11] and [16]. Finally, en-
tropy accumulation in the internal state is modeled clearly
only in [16]. Therefore we use the security model of [16]
as a starting point for our analysis. Furthermore, our code
source analysis shows that in certain situations, only a par-
tial compromise of the internal state is necessary to make
the PRNG predictable. As a partial compromise of the in-
ternal state is not captured by any of these security models,
we propose a slight modiﬁcation of the security model of [16]

to capture this new adversarial potential. Our modiﬁcation
allows to identify precisely the part of the internal state that
needs to be compromised to make the output of the PRNG
predictable.
From Implementations To Security Models. Deﬁni-
tion 1 describes a PRNG as a triple of algorithms G = (setup,
refresh, next), where setup is a probabilistic algorithm that
outputs a public parameter seed for the generator. As en-
tropy needs to be extracted from the inputs used to refresh
the PRNG, a randomness extractor is needed, ensuring that
each input actually gives entropy to the PRNG. However,
it is well known that no deterministic extractor can extract
good randomness from all entropy sources and therefore a
seeded extractor is necessary (see for example [30]). The pa-
rameter seed used in the security model is the seed of the ex-
tractor, which is completely public (the only requirement is
that it is random). None of the PRNG implementations use
an explicit extractor: all of them use the SHA1 function to
mix new input into the current internal state or to generate
outputs. We therefore assume for our analysis that the SHA1
function deﬁnes a hash functions family used as an extrac-
tor, whose seed is the public parameter K = K0||K1||K2||K3,
where K0 = 5A827999, K1 = 6ED9EBA1, K2 = 8F1BBCDC,
and K3 = CA62C1D6 are the round constants deﬁned in the
speciﬁcation [28]. Hence, for all PRNGs presented in this
work, we assume that the algorithm setup always outputs
this public parameter K, of size 128 bits and the underlying
extractor is the hash function family deﬁned in the speciﬁ-
cation [28], indexed by the parameter K. We will therefore
refer to the SHA1 function in our description as HK, to iden-
tity the underlying hash function family. As a consequence,
this assumption shows that our attacks on PRNGs are inde-
pendent of the hash function used and are related to their
design.

Assumption 1 (Hash Function Family). All PRNGs use
the hash function family HK as a randomness extractor.

All implementations contain instructions that can be eas-
ily related to the refresh and next algorithms. However,
while our security model considers PRNGs that may be re-
freshed with potentially biased inputs, in most applications,
the refresh algorithm is called just one time with a single
input. Hence after this single call, the entropy contained
in S (named hereafter γ∗) is bounded by the size of the
input (named hereafter p). An attacker may gain informa-
tion about the behavior of the environment and estimate the
entropy of this single input (named hereafter c) when col-
lected by the PRNG. An example of this idea is presented
in [26], where it was discovered that the input in the An-
droid SHA1PRNG implementation actually contains very low
entropy since it was not generated by several calls to system
variables. During our analysis, we discovered vulnerabilities
that are complementary to this work, as we focus on the
global behavior of the PRNG.
3.2 An Illustrative Example

Let us illustrate our analysis. In our security model, an
attacker can compromise the internal state (partially or to-
tally) and the PRNG security game ensures that enough
entropy is accumulated in the internal state to generate out-
put. The OpenSSL PRNG has an internal state of size 1072
bytes, which contains an entropy pool of size 1023 bytes and
internal counters. The structure of S is named hereafter

1006its decomposition, which is public for OpenSSL and known
to the attacker. We show that an attacker only needs to
compromise 40 bytes of the internal state and to control
23 bytes of an input of size 1023 bytes (with a legitimate
distribution sampler, as described hereafter in Deﬁnition 2)
to predict a future output of the PRNG. Hence, this shows
that OpenSSL PRNG does not resist a single internal state
compromise.
3.3 The Security Model

As explained in Section 3.1, we propose a slight modiﬁ-
cation of the robustness security model of [16] to identify
exactly the part of S that an attacker needs to compro-
mise to attack a PRNG. To formalize this idea, we con-
sider the internal state as a concatenation of several binary
strings (named hereafter its decomposition). We model the
adversarial capacity of an attacker A with two new functions
named M-get and M-set that allow A to set or get a part
of the internal state of the PRNG deﬁned with a mask M.
We assume that the attacker A knows the decomposition of
S and is able to choose M. The only diﬀerences between
our security game and [16] is that we replace the procedures
get-state and set-state, with new procedures M-get-state and
M-set-state, allowing to the attacker to get/set a part the
internal state identiﬁed by the mask.

Deﬁnition 3 (Decomposition). A decomposition of a bi-
nary string S ∈ {0, 1}n is a sequence of disjoint binary
strings (S1,··· , Sk), such that S = [S1||···||Sk]. Two bi-
nary strings S and M have the same decomposition if |S| =
|M|, M = [M1||···||Mk] and |Si| = |Mi| for i ∈ {1,··· , k}.
Deﬁnition 4 (M-get / M-set). The function M-get takes
as input a triple (S, M, J), where S, M ∈ {0, 1}n have the
same decomposition S = [S1||···||Sk], M = [M1||···||Mk]
and J ⊂ {1,··· , k}, then M-get(S, M, J) = S, where Sj =
Mj, for j ∈ J. The function M-set takes as input a couple
(S, J), where S = [S1||···||Sk] and J ⊂ {1,··· , k}, then
M-set(S, J) = {Sj}, for j ∈ J.
These function are adversarially provided, and their goal is
to let A choose the mask M over the internal state. Note
that if the mask is too large (so that G becomes insecure),
the security game will require that new input is collected.
They model partial memory corruption of the PRNG.
Security Model. We now describe our security model.
It is adapted from the security game ROB(γ∗) of [16] that
deﬁnes the robustness of a PRNG. We describe brieﬂy the
parameters of the security game:
• Integer γ∗: Deﬁnes the minimum entropy that is re-
• Integer c: Deﬁnes the estimate of A of the amount of
• Integer λ ≤ n: Deﬁnes the size of the mask M.
• Boolean ﬂag corrupt: It is set to true if c < γ∗ and false
• Boolean b: Used to challenge the attacker A.

quired in S for the PRNG to be secure.

Our security game uses procedures described in Figure 1.
The procedure initialize sets the parameter seed with a call
to algorithm setup, the internal state S of the PRNG, as well
as parameters c and b. Note that we initially set c to n and S
to a random value, to avoid giving any information on S to
the attacker A. After all oracle queries, A outputs a bit b∗,
given as input to the procedure ﬁnalize, which compares the
response of A to the challenge bit b. The other procedures
are deﬁned below:

collected entropy.

otherwise.

• Procedure D-refresh: A calls the distribution sampler
D for a new input and uses this input to refresh G. The
estimated entropy given by D is used by the procedure
to update the counter c (c ← c + γ) and if c ≥ γ∗, then
the ﬂag corrupt is set to false.
• Procedure M-set-state: Used by A to set part of S.
First A calls function M-set to update part of the
internal state. Then the counter is decreased with λ,
the size of the mask M (c ← c−λ) and as in the initial
set-state procedure, if c < γ∗, the ﬂag corrupt is set to
true.
• Procedure M-get-state : Used used by A to get part of
S. First A calls the function M-get. Then the counter
is decreased with λ, the size of the mask M (c ← c−λ)
and as in the initial get-state procedure, if c < γ∗, the
ﬂag corrupt is set to true.
• Procedure next-ror: It challenges A on its capability
to distinguish the output of G from random, where the
real output (R0) of G is obtained with a call to algo-
rithm next and the random string (R1) is generated by
the challenger. Attacker A responds to the challenge
with a bit b∗

The Security of a PRNG is given in Deﬁnition 5.
Deﬁnition 5 (Security of a PRNG). A PRNG G = (setup,
refresh, next) is called (T = (t, qD, qR, qS), γ∗, ε)-robust (resp.
resilient, forward-secure, backward-secure), if for any at-
tacker A running in time at most t, making at most qD calls
to D-refresh, qR calls to next-ror and qS calls to M-get-state
or M-set-state, and any legitimate distribution sampler D
inside the D-refresh procedure, the advantage of A in game
ROB(γ∗, λ) (resp, RES(γ∗), FWD(γ∗, λ), BWD(γ∗, λ)) is at
most ε, where:
• ROB(γ∗, λ) is the unrestricted game where A is allowed
to make the above calls and corrupt λ bits of S.
• RES(γ∗) is the restricted game where A makes no calls
to M-get-state/M-set-state (i.e., qS = 0 and λ = 0).
• FWD(γ∗, λ) is the restricted game where A makes no
calls to M-set-state and a single call to M-get-state
(i.e., qS = 1) which is the very last oracle call A is
allowed to make to corrupt λ bits of S.
• BWD(γ∗, λ) is the restricted game where A makes no
calls to M-get-state and a single call to M-set-state
(i.e., qS = 1) which is the very ﬁrst oracle call A is
allowed to make to corrupt λ bits of S.

Hence, resilience protects the security of the PRNG when
it is not corrupted against arbitrary distribution samplers
D, forward security protects past PRNG outputs in case the
state S gets compromised (partially or totally), backward
security security ensures that the PRNG can successfully
recover from state compromise (partial or total), provided
enough fresh entropy is injected into the system, robust-
ness ensures security against arbitrary combinations of the
above.

4. SECURITY OF REAL-LIFE PRNGS

In this section we present our analysis of PRNG imple-
mentations from diﬀerent providers: OpenSSL, Android,
OpenJDK, Bouncycastle and IBM. As described in Assump-
tion 1, the setup algorithm for all PRNG implementations
outputs the 128-bit value K, which indexes the hash func-
tion family HK. Notice that for all games, the total number
of calls is bounded polynomially by the security parameter
T described in Deﬁnition 5

1007proc. initialize(D)
seed $← setup; σ ← 0;
S $← {0, 1}n; c ← n;
corrupt ← true; b $← {0, 1};
OUTPUT seed
proc. ﬁnalize(b∗)
IF b = b∗
ELSE RETURN 0

RETURN 1

proc. D-refresh
(σ, I, γ, z) $← D(σ)
S ← refresh(S, I)
c ← c + γ
IF c ≥ γ∗,

corrupt ← false

OUTPUT (γ, z)

proc. M-set-state
S ← M-set(S, M, J)
c ← c − λ
IF c < γ∗,
corrupt ← true
c ← 0

proc. M-get-state
{Sj} ← M-get(S, J)
c ← c − λ
IF c < γ∗,
corrupt ← true
c ← 0

RETURN {Sj}

proc. next-ror
(S, R0) ← next(S)
$← {0, 1}(cid:96)
R1
IF c < γ∗,
corrupt ← true
c ← 0
RETURN R0
ELSE RETURN Rb

Figure 1: Procedures in Security Game ROB(γ∗, λ)

4.1 Analysis of OpenSSL PRNG
The OpenSSL cryptographic library contains a PRNG which
collects entropy from system calls.
Is has been ﬁrst ana-
lyzed by Gutmann in 1998 [21]; since then no new anal-
ysis has been made.
It is implemented in the source ﬁle
/crypto/rand/md rand.c, as part of the OpenSSL library.
The PRNG takes inputs of any size and generates outputs
of size 10 bytes. The PRNG is diﬀerent depending on a
choice made when building the library. This choice depends
on an internal parameter named MD_DIGEST_LENGTH, which
depends on the underlying hash function used. The hash
function is chosen with a dedicated ﬂag (USE_MD5_RAND for
the MD5 function, or USE_SHA1_RAND for the SHA1 func-
tion), which is by default USE_SHA1_RAND. Hence depending
on the environment, the size of S3 is equal to 16 bytes or
20 bytes. We assume that the SHA1 function is used in our
descriptions, hence we will refer to the hash functions family
HK described in Assumption 1. We veriﬁed that our attack
can be easily adapted if USE_MD5_RAND is chosen.

Internal State Decomposition. The internal state of
the PRNG is implemented with ﬁve ﬁelds: state_index,
of size 32 bits, state, of size 1043 bytes, md, of size 20
bytes, md_count_0, md_count_1, each of size 64 bits. Hence
the decomposition of the internal state is given by S =
(S1, S2, S3, S4, S5), where S1, S2, S3, S4, S5 stand respectively
for state_index, state, md, md_count_0, md_count_1. The
total size of the internal state is 8576 bits and the PRNG
uses this decomposition as follows: ﬁeld S1 is used as an
index to select bytes in S2; S2 and S3 are used to collect
entropy; S4 and S5 are counters used during PRNG opera-
tions.

The refresh Algorithm. This algorithm is implemented
with the instruction ssleay_rand_add, and fully described
in Algorithm 1. It takes as input the current internal state
(S1, S2, S3, S4, S5) and an input I of any size that is pro-
cessed by blocks of 20 bytes. Starting with a 20-bytes block
of S2 that is indexed by S1, successive blocks of S2 are mixed
with successive blocks of I. The mixing operation involves
the hash functions family HK. This mixing operation also
involves S3, S4 and S5, where S5 is incremented for each
block. When this mixing is ﬁnished, the ﬁeld S3 is xor-ed
with the last calculated hash. Hence after a refresh opera-
tion, |I| bits of S2 are modiﬁed, S3 is modiﬁed, S1 and S5
are incremented and S4 is not modiﬁed.

The next Algorithm. This algorithm is implemented in
ssleay rand bytes, and described in Algorithm 2.
It takes
as input the current internal state (S1, S2, S3, S4, S5), mixes
S2, S3, S4 and S5 together to produce the 10-byte output
R and updates S3. Only 10 bytes from S2 are modiﬁed,

Algorithm 1 OpenSSL PRNG refresh

Require: S = (S1, S2, S3, S4, S5), I
Ensure: S(cid:48)

2||I||S4||S5])

while |I| > 0 do
S∗
2 = S2[S1 mod 1023, . . . , S1 + 20 mod 1023]
U = HK([S3||S∗
S∗
2 = S∗
S1 = S1 + 20 mod 1023
S5 = S5 + 1
I = I \ [I]19
end while
S3 = S3 ⊕ U
return S(cid:48) = (S1, S2, S3, S4, S5)

2 ⊕ U

0

that are selected using ﬁeld S1, which behaves as an index
for this operation. A second mixing operation involves S3,
S4 and S5 to update S3. Hence S2 is modiﬁed sequentially
by blocks of 10 bytes with successive next calls, while S3 is
completely modiﬁed, S1 and S4 are incremented and S5 is
not changed. As for the refresh algorithm, the two mixing
operations involve the hash function family HK.
Note that directive ssleay_rand_bytes takes as input an
array named buf which is ﬁlled with the generated output,
but whose content is also used as input (referenced as I
in the description below). In addition, the next algorithm
uses as input the current system PID and the system time.
The system PID is obtained with a call to directive getpid,
system time is obtained from a call to directive time, and
from a call to directive gettimeofday (for simplicity, we re-
fer to these two calls as “Time” in the description of the
PRNG). These inputs during the next algorithm are not ex-
plicitly compliant with the security model that requests a
strict separation between the input collection and the gener-
ation, but we mention it for completeness of the description.
These calls have been explicitly set by OpenSSL commu-
nity to prevent a vulnerability related to a call to the fork
function that uses a common PID for two next calls. This
vulnerability is described in [6].

Attack. We mount an attack against OpenSSL PRNG,
that is based on the internal state decomposition and the
fact that this state is only partially updated by the refresh
and next algorithms. Our attack uses the ﬁeld S3, which is
implemented with md and the ﬁeld S2, which is implemented
with state. As described in Algorithms 1 and 2, when the
PRNG is refreshed, the ﬁeld S3 is updated with the last cal-
culated hash, whereas it is used as the entropy source for the
output of the PRNG with 10 bytes of S2. Suppose now that
one uses an input of size 1023 bytes (which is the size of S2

1008Algorithm 2 OpenSSL PRNG next

Require: S = (S1, S2, S3, S4, S5)
Ensure: S(cid:48), R

2 ⊕ V [0,··· , 9]

2 = S2[S1 mod 1023,··· S1 + 10 mod 1023]
S∗
V = HK([PID||Time||S3||S4||S5||I||S∗
2 ])
S∗
2 = S∗
R = V [10,··· , 19]
S3 = HK([S4||S5||V ||S3])
S1 = S1 + 10 mod 1023
S4 = S4 + 1
return S(cid:48) = (S1, S2, S3, S4, S5), R

– or state) where the ﬁrst 20 bytes and the last 3 bytes are
0, to refresh the PRNG. Clearly this input is independent
of the parameter seed and it is therefore legitimate to use it
to refresh the PRNG in our security model. Suppose now
that one asks for an output. This output, which only relies
on the ﬁrst 10 bytes of S2 and on S3, is predictable. Theo-
rem 1 gives the technical details of the attack. This attack
is related to the refresh function that mixes new entropy se-
quentially by blocks of 20 bytes in the internal state, and
to the next function that also reads sequentially the internal
state by blocks to produce new outputs. If a block is com-
promised and if the attacker controls the exact block of the
input that will be mixed with the compromised block of the
internal state, the output is predictable. Hence the attack
points a design error of the PRNG, because this behavior
should not be possible.

Theorem 1. Openssl PRNG is not backward secure. To
mount an attack against the PRNG, A needs to corrupt 40
bytes of the internal state.

0,··· , I i

0 = ··· = I 0

1022]) ← D(i); where I 0

Proof. Deﬁne the 1023-byte distribution D. On input a state
i, D updates its state to i + 1 and outputs a 1023-byte input
I i: (i + 1; [I i
19 = 0,
1019 = ··· = I 0
I 0
1022 = 0 and all other bytes are random
(i.e. D is legitimate with γi = 8000). Deﬁne the mask
M = [M1, M2, M3, M4, M5], where M1 = 0, [M2]19
0 = 0,
M3 = 0, M4 = 0, M5 = 0 and J = {2, 3} (i.e. this mask will
be used to set the ﬁrst 20 bytes of S2 and S3 to 0). Con-
sider an adversary A against the security of the PRNG that
chooses the distribution D, and that makes the following
oracle queries in the security game BWD: one M-set-state
with S, J and M , one D-refresh with I 0, one next-ror. Then
(following refresh and next algorithm notations):

• After M-set-state, S1 = 0, [S2]19

0 = 019, [S2]1023

20

is

random, S3 = 0, S4 = 0, S5 = 0.
• After D-refresh, S1 = 0, [S2]19

0 = HK([0||0||0||0||0]),
is random, S3 = HK([0||0||0||0||51]), S4 = 0,

• After next-ror, V = HK(PID||Time||S3||0||51||[S2]19
0 ),
10 , S3 = HK(0||51||V ||HK(0||0||0||0||51)), S1 =

[S2]1023
S5 = 51.

20

R = V 19
10, S4 = 1.

In this last next-ror-oracle query, A obtains a 10-bytes string
that is predictable as it only relies on PID and Time, whereas
this event should occur with probability 2−80. Therefore A
can distinguish an output of OpenSSL PRNG from random
in the game BWD(γ∗, 320), for all γ∗ ≤ 8000 and this PRNG
is not backward secure.

4.2 Analysis of Android SHA1PRNG
In the Android system, a full Java implementation is pro-
vided, as part of the package security.provider.crypto,
named SHA1PRNG. It has been analyzed by Michaelis et al.
in [26], where the authors identiﬁed an implementation weak-
ness that causes the internal state to be overwritten by
predictable values, decreasing its entropy to 64 bits. This
PRNG was also debated intensively recently, due to a weak-
ness in its initial seeding that caused a ﬂaw in Bitcoin wal-
lets. This weakness caused the Android community to pro-
pose a ﬁx to the PRNG, that simply consists in replacing it
by the OpenSSL PRNG, analyzed in Section 4.1. Full details
about the vulnerability and the proposed ﬁx are given in [7].
The PRNG is implemented with the class SHA1PRNG_Secure
RandomImpl and is an inheritance from the one included in
the library Apache Harmony from the package org.apache.
harmony. It follows the method named ”expansion of source
bits” of IEEE standard P.1363 [14].

Internal State Decomposition. The internal state of
the PRNG is implemented with the ﬁelds seed, of size 384
bytes, and counter, of size 8 bytes (many other ﬁelds are
used, but they are not useful to understand the PRNG op-
erations). Hence the decomposition of the internal state is
S = (S1, S2), where S1, S2 stand for seed and counter and
the total size of the internal state is 3136 bits. The PRNG
uses this decomposition as follows: S1 contains the collected
entropy and a hash of the collected entropy; S2 contains a
counter which is incremented at each output.

The refresh Algorithm. This algorithm is described in
Algorithm 3.
It takes as input the current internal state
(S1, S2), an input I of any size and updates the internal state
with I. It is implemented with method engineSetSeed as
follows: the ﬁrst 64 bytes of S1 collect the consecutive inputs
and the last 20 bytes of S1 contains a hash value. Two sub-
functions are used, implemented with SHA1Impl.updateHash
and SHA1Impl.computeHash. Note that these two functions
correspond respectively to the update of the internal state
of HK and a function hK that compresses the input of HK
to a ﬁxed length output, as deﬁned in the speciﬁcation [28].
The PRNG uses (wrongly, as we will see) the compression
function hK instead of HK for hash calculation. When the
collected input ﬁlls a block of hK (of size 64 bytes), the last
20 bytes of S1 are ﬁlled with hK, and then the block is set
to 0 and ﬁlled again. For clarity, we denote s the current
collected input and h the current calculated hash in S1 and
I∗ = [I]64−|S||I|

in Algorithm 3.

0

Algorithm 3 Android SHA1PRNG refresh
Require: S = (S1, S2) = ([s,··· , h], S2), I
Ensure: S(cid:48)

if |s||I| < 64 then S1[0,··· , 63] = [s||I] end if
if |s||I| = 64 then

S1[0,··· , 63] = 0, S1[328,··· , 347] = hK(s||I, h)

end if
if |s||I| > 64 then

S1[0,··· , 63] = I \ I∗, S1[328,··· , 347] = hK(s||I∗, h)

end if
return S(cid:48) = (S1, S2)

The next Algorithm. This algorithm is described in Algo-
rithm 4. It is implemented with engineNextBytes. It takes

1009as input an integer n and outputs R, of size n bytes and
the updated internal state S(cid:48). Twenty successive bytes out-
puts are generated as follows: the algorithm appends S1 and
S2, calculates the output with function hK (the compression
function) and increments the counter contained in S2. For
clarity, we suppose that n is a multiple of 20 (the imple-
mentation allows any value with intermediate arrays whose
description would complicate the understanding of the al-
gorithm) and we denote c the counter contained in S2. We
also use the same notation (s and h) used for the refresh
algorithm.

Algorithm 4 Android SHA1PRNG next
Require: S = (S1, S2) = ([s,··· , h], [c]), n(n mod 20 = 0)
Ensure: S(cid:48), R

for i = 0 to n − 1 do

S1[0,··· , 63] = [s||c], S1[328,··· , 347] = hK(s||c, h)
c = c + 1, S2 = [c]
Ri = S1[328,··· , 347]
i = i + 20

end for
return S(cid:48) = (S1, S2), R = ∪

i

Ri

Attack. We mount an attack against the Android SHA1PRNG
taking in consideration the internal state decomposition.
Our attack is possible because of the use of the compres-
sion function hK instead of the hash function HK, both in
the refresh and next algorithms. When using the compres-
sion function hK, the current hash value is used whereas the
hash should be calculated with the initialization vector de-
ﬁned in the speciﬁcation [28]. Again, this attack identiﬁes a
design ﬂaw of the PRNG. This attack shows that the PRNG
is not resilient because the attacker only needs to refresh the
PRNG with an input that forces S1 to be equal to [0]. In
addition, if at initialization the internal state is ﬁlled with
64 random bytes, the PRNG is not pseudo-random, because
no refresh is needed to mount the attack. The attack is
demonstrated in Theorem 2.

Theorem 2. Android SHA1PRNG is not resilient.

Proof. Consider an adversary A against the security of the
PRNG that chooses the following (one state) distribution D,
D(0) = I, where I is of size (cid:96), where (cid:96) ≤ 512 and random
(i.e. D is legitimate with γ0 = (cid:96)). Next A makes the follow-
ing oracle queries in the security game RES: one D-refresh,
one ﬁrst next-ror with an output R1 of size 20 bytes, and one
second next-ror, with an output R2 of size 20 bytes. Then:
0 = 0 with probability

• After D-refresh with I:

1/64, [S1]347

[S1]63
328 is random, S2 = 0.
• After next-ror with R0, [S1]63
328 and S2 = 1.
• After next-ror with R1, [S1]63

1/64, R0 = [S1]347

0 = 0 with probability

0 = [0||1], R0 = [S1]347
328,

but [S1]347

328 = hK(0, R0) with probability 1/64.

In this last next-ror-oracle query, A obtains a 20-byte string
that is known to A with probability 1/64 as it only relies
on the previous output, whereas ideally, this event should
occur only with probability 2−80. Therefore this PRNG is
not resilient.

4.3 Analysis of OpenJDK SHA1PRNG
The OpenJDK provider contains an implementation named
SHA1PRNG, directly given in the class SecureRandom. This
implementation follows the speciﬁcation given in the Digi-
tal Signature Standard [19]. This last speciﬁcation has been
analyzed in [24] and in [15], where the authors show that it
does not correspond to a resilient PRNG. Here we present
new attacks that are based on partial corruption of the in-
ternal state.

Internal State Decomposition. The internal state of the
PRNG is implemented with three private ﬁelds, the ﬁeld
state, of size 20 bytes, the ﬁeld remainder, of size 20 bytes
and an integer remCount. Hence the decomposition of the
internal state is S = (S1, S2, S3), where S1, S2, S3 stand for
state, remainder, remCount, respectively and the total size
of the internal state is 352 bits. The PRNG uses this de-
composition as follows: S1 contains the collected entropy, S2
contains random bytes before their output and S3 is used to
check if S2 contains enough random bytes that can serve as
output.

The refresh Algorithm. This algorithm is described in Al-
gorithm 5 and implemented with the method engineSetSeed.
It takes as input the current internal state S = (S1, S2, S3),
a new input I and outputs the new internal state by mixing
S1 with I using HK.

Algorithm 5 OpenJDK SHA1PRNG refresh

Require: S = (S1, S2, S3), I
Ensure: S(cid:48)

S1 = HK(S1||I)
return S(cid:48) = (S1, S2, S3)

The next Algorithm. This algorithm is described in Al-
gorithms 6 and 7. It is implemented with two methods; the
ﬁrst one, engineNextBytes, generates the output and the
second one, updateState, updates the internal state.
The method engineNextBytes takes as input the current
internal state S = (S1, S2, S3) and n, the number of bytes
requested. It outputs an n-byte output R and updates the
internal state. The internal counter S3 controls the update
of the internal state when output is generated: if S3 > 0, S2
contains some bytes that have not been used for a previous
output; these bytes can be used for the current output and
are then set to 0. Next, S2 and S1 are updated only if all
bytes from S2 have been used: at ﬁrst S2 is updated with S1
(S2 = HK(S1)) and ﬁnally S1 is updated using updateState
instruction, which is the implementation of the update algo-
rithm speciﬁed in [19]. The instruction updateState takes
as input two binary strings S1 and S2 of size 20 bytes and
mixes them together byte by byte.

Attack. We mount an attack against the OpenJDK SHA1-
PRNG taking in consideration the internal state decomposi-
tion. Our attack uses the fact that S2 and S3 are not up-
dated during refresh. After a refresh, if S3 is set by the
attacker to 1, the next output will be derived from a pre-
dictable value.

Theorem 3. OpenJDK SHA1PRNG is not backward secure.
To mount an attack against the PRNG, A needs to corrupt
4 bytes of the internal state.

1010Algorithm 6 OpenJDK SHA1PRNG next (engineNextBytes)

Require: S = (S1, S2, S3), n
Ensure: S, R

i = t = 0
if S3 > 0 then

t = min n − i, 20 − S3
R[0,··· , t − 1] = S2[S3,··· , S3 + t − 1]
S2[S3,··· , S3 + t − 1] = [0]

end if
while i < n − 1 do

S2 = HK(S1)
S1 = updateState(S1, S2)
t = min n − i, 20
R[i,··· , i + t − 1] = S2[0,··· , t − 1]
i ← i + t
end while
S3 = (S3 + n) mod 20
return S1, S2, S3, R

Algorithm 7 OpenJDK SHA1PRNG next (updateState)
Require: S1, S2, |S1| = |S2| = 160
Ensure: S1

(cid:96) = 1
for i = 0 to 19 do

v = (S1[i] + S2[i] + (cid:96))
S1[i] = v mod 28
(cid:96) = v/28

end for
return S1

Proof. Consider an adversary A against the security of the
OpenJDK SHA1PRNG that chooses the distribution D, such
that D(0) = I where I is of size 20 bytes and random (i.e. D
is legitimate with γ0 = 160). Next A makes the following
oracle queries in the security game BWD: one D-refresh,
one M-set-state with M = (0, 0, 1), J = {3} and one ﬁnal
next-ror with an output R of size 10 bytes. Then:
• After D-refresh with I, S1 = HK(I||0), S2 = 0 and
• After one M-set-state with M = (0, 0, 1), J = {3},
• After one next-ror with n = 10, S1 = HK(I||0), S2 = 0,
Therefore, A obtains a 10-byte string in the last next-ror-
oracle query that is predictable whereas this event should
occur with probability 2−80. Therefore this PRNG is not
backward secure for γ∗ ≤ 160. Note that as the ﬁelds S2
and S3 are not updated during the refresh Algorithm, A
could make suﬃcient calls to D-refresh to mount a similar
attack for a larger value of γ∗.

S3 = 0.
S1 = HK(I||0), S2 = 0 and S3 = 1.

S3 = 11 and R = 0.

A similar analysis can be made for the OpenJDK Native-
PRNG. In OpenJDK, a second implementation of a PRNG is
included, named NativePRNG, which mixes the output of the
OpenJDK SHA1PRNG with the output of the system PRNG
/dev/urandom using a xor instruction. Hence the internal
state of the OpenJDK NativePRNG is the concatenation of
the internal state of the PRNG /dev/urandom with the in-
ternal state of the OpenJDK SHA1PRNG. The analysis of /de-
v/urandom done in [16] gives the details about the PRNG
/dev/urandom and its internal state decomposition, and we

obtain directly that OpenJDK NativePRNG has an internal
state of size 5472 bits. Following their analysis, we can show
that OpenJDK NativePRNG is not robust, and that an at-
tacker needs to corrupt 128 bytes of /dev/urandom and 4
bytes of SHA1PRNG to mount an attack against NativePRNG.
4.4 Analysis of Bouncycastle SHA1PRNG
The Bouncycastle Crypto package is a Java implementation
of cryptographic algorithms; our analysis refers to release
1.5 [4]. The implementation of several PRNGs is contained
in the package org.bouncycastle.crypto.prng, where the
implementation of the SHA1PRNG is in the class DigestRandom-
Generator. The implementation combines a cryptographic
hash function (which is by default HK) with internal instruc-
tions that are used to update the internal state of the PRNG.
In our source code analysis, we identiﬁed several weaknesses:
ﬁrst a weakness related to the decomposition of the inter-
nal state, and second a weakness due to an incomplete state
update during the refresh algorithm. These weaknesses have
neither been identiﬁed in [26], nor by the Bouncycastle com-
munity.

Internal State Decomposition. The internal state of the
PRNG is implemented with the following ﬁelds: seed of
size 160 bits, state of size 160 bits, seedCounter of size 64
bits, and ﬁeld stateCounter, of size 64 bits. The two ﬁrst
ﬁelds contain the collected entropy and the two last ﬁelds
are counters that are used for PRNG operations. Hence, the
total size of the internal state is 448 bits and its decompo-
sition is S = (S1, S2, S3, S4), where S1, S2, S3, S4 stand for
seed, state, seedCounter, stateCounter, respectively.
The refresh Algorithm. This algorithm is described in
Algorithm 8.
It takes as input the current internal state
(S1, S2, S3, S4) and an input I; it outputs a new internal
state where only S1 is updated. It is implemented with the
method addSeedMaterial.

Algorithm 8 Bouncycastle SHA1PRNG refresh

Require: S = (S1, S2, S3, S4), I
Ensure: S(cid:48)

S1 = HK(S1||I)
return S(cid:48) = (S1, S2, S3, S4)

The next Algorithm. This algorithm is described in Al-
gorithms 9 and 10.
It is implemented with the method
NextBytes. It takes as input an integer n, the current the in-
ternal state (S1, S2, S3, S4) and outputs an n-byte string R.
The output R is derived from S2, while an internal method,
named generateState is used to update the state.

The generateState method increments the counters S3 and
S4 and calculates the new values of S1 and S2 accordingly.
Attack. We mount an attack against the Bouncycastle
SHA1PRNG taking into consideration the internal state de-
composition. This attack is similar as the attack against [19]
described in [24] and [15]: the attacker uses a previously gen-
erated ouput as an input to corrupt the PRNG: our attack
shows that Bouncycastle SHA1PRNG is not resilient.

Theorem 4. Bouncycastle SHA1PRNG is not resilient.
Proof. Consider an adversary A against the resilience of the
PRNG that chooses the following (2-state) distribution D,

1011Algorithm 9 Bouncycastle SHA1PRNG next (NextBytes)

Require: S = (S1, S2, S3, S4), n
Ensure: S(cid:48)

S = generateState(S)
j = n
for i = 0 to j do
if j = 20 then

S = generateState(S)
j = 0

end if
R[i] = S2[i]
i = i + 1

end for
return S(cid:48) = (S1, S2, S3, S4), R

Algorithm 10 Bouncycastle SHA1PRNG next (generateState)

Require: S = (S1, S2, S3, S4)
Ensure: S(cid:48)

S4 = S4 + 1
S2 = HK(S4||S2||S1)
if S3 mod 10 = 0 then

S3 = S3 + 1
S1 = HK(S1||S3)

end if
return S(cid:48) = (S1, S2, S3, S4)

D(0) = I,D(1) = J, where I and J are of size 20 bytes, I
is random and J is known by A (i.e. D is legitimate with
γ0 = γ1 = 160). Next A makes the following oracle queries
in the security game RES: one D-refresh, two next-ror with
two outputs R1 and R2, both of size 20 bytes, one D-refresh,
and one third next-ror, with one output R3 of size 20 bytes.
Then:
• After one D-refresh with I, S1 = HK(I||0), S2 = 0,
S3 = 1, S4 = 1.
• After one next-ror, with |R1| = 20, S1 remains the
same, S2 = HK(S4||S2||S1) = HK(2||0||S1), S3 = 1,
S4 = 2, R1 = S2.
• After one second next-ror, with |R2| = 20, S1 remains
the same, S2 = HK(S4||S2||S1) = HK(3||R1||S1), R2 =
S2.
• After one D-refresh with J = [3||R1], S1 = HK(J||S1) =
HK(3||R1||S1) = R2.
• After one last next-ror with |R3| = 20, S1 remains the
same, S2 = HK(S4||S2||S1) = HK(4||R2||R2), R3 = S2.
Therefore, A obtains a 20-byte string in the last next-ror-
oracle that is predictable (R3 = HK(4||R2||R2)), whereas
this event should occur with probability 2−80. Therefore
the Bouncycastle SHA1PRNG is not resilient.
4.5 Analysis of IBM SHA1PRNG
Besides Oracle’s Java Virtual Machine, IBM implements its
own JVM with some diﬀerences (in particular in perfor-
mance) compared to Oracle’s JVM. We analyze the IBM
SDK Version 7 Service Refresh 7 which contains a secu-
rity enhancement of the PRNG reported by Sethi in [8].
We analyze the implementation of the crypto provider IBM-
SecureRandom, in the package com.ibm.securerandom.pro-
vider. This (closed source) implementation consists of a

main entropy pool and a mixing function which internally
relies on the hash function family HK to update the pool.
Internal State Decomposition. The internal state of the
IBM SHA1PRNG is self-contained in the ﬁeld state of size 680
bits. For convenience, we refer to the ﬁeld state as the set
S = (S1||S2||S3||S4||S5||S6||S7). The IBM SHA1PRNG uses
this decomposition as follows: S1 contains the number of
bytes that has been used from the output pool, S2 = 0, S3
is the output, S4 is a ﬁrst entropy pool, S5 are 5 diﬀerent
internal counters, S6 is a second entropy pool and S7 is a ﬂag
indicating whether the input is provided or not. The initial
state is S1 = 0, S2 = 0, S3 = 0, S4 = 0, S5[0] = 0, S5[1] =
128, S5[2] = 30, S5[3] = 0, S5[4] = 0, S6 = 0, S7 = false
and it relies on the internal function reverse that simply
reverses binary the content of the input.
The refresh algorithm. This algorithm is described in Al-
gorithm 11.
It takes as input the current internal state
(S1, S2, S3, S4, S5, S6, S7), a input I and outputs the new
internal state by mixing S4 with I using HK.
It is imple-
mented with the method engineSetSeed.

Algorithm 11 IBM SHA1PRNG refresh

Require: S = (S1, S2, S3, S4, S5, S6, S7), I
Ensure: S(cid:48)

if |I| > 320 then

S6 = HK(I)

end if
¯I = reverse(I)
S4 = S4 ⊕ ¯I
S7 = true
S1 = |S3|
return S(cid:48) = (S1, S2, S3, S4, S5, S6, S7)

The next algorithm. This algorithm is described in Al-
gorithms 12 and 13.
It is implemented with the methods
engineNextBytes and updateEntropyPool. It takes as in-
put the current internal state S and n, the number of bytes
requested. It outputs an n-byte R and a new value for the
internal state. It relies on S1 to generate the output as fol-
lows: if S1 < |S4|, S3 still contains bytes that have not been
used in a previous output. When S1 reaches the size of the
entropy pool (i.e. S1 = |S4|), S3 and S4 are updated to
produce a fresh output. First entropy is added by the inter-
nal method updateEntropyPool and then the output pool
S3 = HK(S3||S4||S5||S6[1]) is updated. The instruction time
returns the timestamp, δ is another timestamp value, and
firstTime is an internal ﬂag in order to ensure that S3 is
indeed ﬁlled. This procedure is repeated for each |S3| bytes.1
Attack. We mount an attack similar to the attack on the
OpenJDK SHA1PRNG. As in the refresh algorithm the internal
state is not completely updated, an attacker can set the byte
S1 = 0 and make the counter of non-used bytes start reading
again from S3[0]. Notice that we need at least 3 bytes to set
S1, S5[4], S5[5] properly otherwise the algorithm will force to
add entropy; on the other hand, once all parameters are set
up, an attacker just needs to corrupt 1 integer (4 bytes) to
make the output predictable.

Theorem 5. IBM SHA1PRNG is not backward secure. To
mount an attack against the PRNG, A needs to corrupt 4
bytes of the internal state.
1In practice, the size of the output pool is 20 bytes.

1012Algorithm 12 IBM SHA1PRNG next (engineNextBytes)

Require: S = (S1, S2, S3, S4, S5, S6, S7), n
Ensure: S(cid:48), R

if firstTime = true then

if S1 = |S3| then

(S4, S5, S7) = updateEntropyPool(S)

end if
S3 = HK(S3||S4||S5[0]||S5[1])
S1 = 0

end if
R = S3[S1, . . . , n]
S1 = 1 + n
return S(cid:48) = (S1, S2, S3, S4, S5, S6, S7), R

Algorithm 13 IBM SHA1PRNG next (updateEntropyPool)

Require: S = (S1, S2, S3, S4, S5, S6, S7), I
Ensure: S4, S5, S7

if S5[1] > 0 and S7 = false then
if time ≥ S5[4] + S5[5] then

for S5[0] to S5[0] + 20 do

S4 = S4 ⊕ I
S5[4] = δ
S5[5] + S5[2] + time
S5[0] + 1

end if
end for

end if
return (S4, S5, S7)

Proof. Consider an adversary A against the security of IBM
SHA1PRNG that chooses a distribution D, such that D(0) = I
where I is of size 20 bytes and random (i.e. D is legiti-
mate with γ0 = 160). Next A makes the following ora-
cle queries in the security game BWD: one D-refresh, one
next-ror with an output of size 10 bytes, one M-set-state
with M = (0, 0, 0, 0, 0, 0, 0), J = {3} and one ﬁnal next-ror
with an output of size 10 bytes. Then:
• After one D-refresh with I, S1 = |S3|, S2 = 0, S3 =
0, S4 = 0⊕I, S5[0] = 0, S5[1] = 128, S5[2] = 30, S5[3] =
0, S5[4] = 0, S6 = 0, S7 = true.
• After one next-ror with n = 10, S1 = 10, S2 = 0, S3 =
HK(0||0 ⊕ I||0||128), S4 = 0 ⊕ I, S5[0] = 0, S5[1] =
128, S5[2] = 30, S5[3] = 0, S5[4] = 0, S6 = 0, S7 =
true. R = S3[0, . . . , 10]. The output R is random.
• After one M-set-state with M = (0, 0, 0, 0, 0, 0, 0), J =
{1}, S1 = 1, S2 = 0, S3 = HK(0||0⊕I||0||128), S4 = 0⊕
I, S5[0] = 0, S5[1] = 128, S5[2] = 30, S5[3] = 0, S5[4] =
0, S6 = 0, S7 = true.
• After one next-ror with n = 10, S1 = 10, S2 = 0, S3 =
SHA1(0||0 ⊕ I||0||128), S4 = 0 ⊕ I, S5[0] = 0, S5[1] =
128, S5[2] = 30, S5[3] = 0, S5[4] = 0, S6 = 0, S7 = true
and R = S3[0, . . . , 10].
Therefore, A obtains a 10-byte string in the last next-ror-
oracle query that is exactly the same as the previous next-ror-
oracle query, whereas ideally, this event occurs only with
probability 2−80. Therefore the IBM SHA1PRNG is not back-
ward secure for γ∗ ≤ 160. Note that as the ﬁelds S2 and
S3 are not updated during the refresh Algorithm, A could
make suﬃcient calls to D-refresh to mount a similar attack
for a larger value of γ∗.

4.6 Towards a Secure Implementation
In [16], Dodis et al. proposed a construction based on simple
operations in a ﬁnite ﬁeld. Let G : {0, 1}m → {0, 1}n+(cid:96)
be a (deterministic) pseudorandom generator where m < n.
The PRNG G is deﬁned as follows:

• setup(): output seed = (X, X(cid:48)) $← {0, 1}2n.
• S(cid:48) = refresh(S, I): Given seed = (X, X(cid:48)), current state
S ∈ {0, 1}n, and a sample I ∈ {0, 1}n, output: S(cid:48) :=
S · X + I, where all operations are over F2n .
• (S(cid:48), R) = next(S): Given seed = (X, X(cid:48)) and a state
S ∈ {0, 1}n, ﬁrst compute U = [X(cid:48) · S]m
1 . Then output
(S(cid:48), R) = G(U ).

In [16], Dodis et al. proved the following theorem:
Theorem 6. Let k, m, (cid:96), n be integers, where n ≥ m+9k +1
and γ∗ = m + 8k + 1. Let G be deﬁned as above. Then G
is a ((t(cid:48), 2k, 2k, 2k), γ∗, 2k+1 · ε + 2−k)-robust PRNG, where
t(cid:48) ≈ t.
Theorem 6 shows that the PRNG G resists a total internal
state corruption. In [16], Dodis et al. give concrete values
for a concrete instanciation of the PRNG G; Namely, they
obtain, with G(U ) = (AESU (0), . . . , AESU (6)), n = 705,
m = (cid:96) = 128 and γ∗ = 641. As our analysis shows, the
implementation of the PRNG (and especially the way the
internal state is updated during PRNG operations) may be
used by an attacker to corrupt the PRNG. Then starting
from the deﬁnition of the PRNG G and its concrete instan-
ciation given with G, n, m and (cid:96) above, one can implement
a secure PRNG provided the internal state decomposition
and its update during PRNG operation are analyzed with
care to ensure that the implementation does not contain any
vulnerability.
5. CONCLUSION

We proposed a new security model for PRNG analysis,
where an attacker has partial access to the internal state
and we model the expected properties of the PRNG. This
new security model is based on the most recent and strongest
security model called robustness of PRNG and it is closely
related to its real-life use and implementation. It states that
the PRNG should continue to generate non predictable out-
puts even if its internal state is partially corrupted, and mod-
els real-life situations, where a PRNG environments may be
adversarial and running applications can be partially cor-
rupted.
We analyzed several widely used PRNG (from providers
OpenSSL, OpenJDK, Android, IBM and Bouncycastle) by
clearly describing their operations in the security model. In
particular, we showed that all of them are highly sensitive to
a relatively small corruption of their internal state. This vul-
nerability is due to the concrete implementation of their in-
ternal state that relies on several ﬁelds between which trans-
fers are done, controlled by internal values that can be set
by the attacker. Moreover, we showed that for two providers
(Android and Bouncycastle), internal state corruption is not
required to break the PRNG. This work shows that proper
implementation of PRNG requires a lot of attention and
should therefore rely on proven constructions.
6. ACKNOWLEDGMENTS

The authors would like to thank the anonymous reviewers
for their valuable comments and suggestions to improve the
quality of the paper. They are also grateful to Bart Preneel
for his helpful and constructive comments.

10137. REFERENCES

[1] Java Decompiler project. http://jd.benow.ca.
[2] Java Platform Debugger Architecture (JPDA).

http://docs.oracle.com.

[3] Orchid is a Tor client implementation and library

written in pure Java.
http://www.subgraph.com/orchid.html.

[4] The Bouncy Castle Crypto package is a Java
implementation of cryptographic algorithms.
http://www.bouncycastle.org/.

[5] The Tor Project. https://www.torproject.org.
[6] OpenSSL PRNG Is Not (Really) Fork-safe, Aug 21st,

2013.
http://emboss.github.io/blog/2013/08/21/openssl-
prng-is-not-really-fork-safe/.

[7] Some SecureRandom Thoughts, Aug 14st, 2013, 2013.
http://android-developers.blogspot.fr/2013/08/some-
securerandom-thoughts.html.

[8] Recent Fixes in IBM SecureRandom, 2014.

http://www.cigital.com/justice-league-
blog/2014/05/06/recent-ﬁxes-ibmsecurerandom/.

[9] The Heartbleed Bug, 2014. http://heartbleed.com.
[10] Argyros, G., and Kiayias, A. I forgot your

password: randomness attacks against PHP
applications. In Proceedings of the 21st USENIX
conference on Security symposium (Berkeley, CA,
USA, 2012), Security’12, USENIX Association,
pp. 6–6.

[11] Barak, B., and Halevi, S. A model and

architecture for pseudo-random generation with
applications to /dev/random. pp. 203–212.

[12] Biham, E., and Shamir, A. Diﬀerential fault analysis

of secret key cryptosystems. pp. 513–525.

[13] Boneh, D., DeMillo, R. A., and Lipton, R. J. On
the importance of eliminating errors in cryptographic
computations. 101–119.

[14] Burton, and Kaliski. IEEE P1363: A Standard for
RSA, Diﬃe-Hellman, and Elliptic-Curve Cryptography
(Abstract). In Security Protocols Workshop (1996),
T. M. A. Lomas, Ed., vol. 1189 of Lecture Notes in
Computer Science, Springer, pp. 117–118.
[15] Desai, A., Hevia, A., and Yin, Y. L. A

practice-oriented treatment of pseudorandom number
generators. In EUROCRYPT (2002), L. R. Knudsen,
Ed., vol. 2332 of Lecture Notes in Computer Science,
Springer, pp. 368–383.

[16] Dodis, Y., Pointcheval, D., Ruhault, S.,

Vergnaud, D., and Wichs, D. Security analysis of
pseudo-random number generators with input:
/dev/random is not robust. In ACM Conference on
Computer and Communications Security (2013), A.-R.
Sadeghi, V. D. Gligor, and M. Yung, Eds., ACM,
pp. 647–658.

[17] Dodis, Y., Shamir, A., Stephens-Davidowitz, N.,
and Wichs, D. How to eat your entropy and have it
too - optimal recovery strategies for compromised
rngs. In CRYPTO (2) (2014), J. A. Garay and
R. Gennaro, Eds., vol. 8617 of Lecture Notes in
Computer Science, Springer, pp. 37–54.

[18] Dorrendorf, L., Gutterman, Z., and Pinkas, B.
Cryptanalysis of the random number generator of the

Windows operating system. ACM Trans. Inf. Syst.
Secur. 13, 1 (2009).

[19] Digital Signature Standard (DSS), FIPS PUB 186-2
with Change Notice. National Institute of Standards
and Technology (NIST), FIPS PUB 186-2, U.S.
Department of Commerce, Jan. 2000.

[20] Erlingsson, ´U., Younan, Y., and Piessens, F.

Low-level software security by example. In Handbook
of Information and Communication Security. 2010,
pp. 633–658.

[21] Gutmann, P. Software generation of practically

strong random numbers. In In Proceedings of the 8th
USENIX Security Symposium (1998), pp. 243–257.
[22] Gutterman, Z., Pinkas, B., and Reinman, T.

Analysis of the Linux Random Number Generator. In
IEEE Symposium on Security and Privacy (2006),
IEEE Computer Society, pp. 371–385.

[23] Heninger, N., Durumeric, Z., Wustrow, E., and
Halderman, J. A. Mining your Ps and Qs: Detection
of widespread weak keys in network devices. In
Proceedings of the 21st USENIX Security Symposium
(Aug. 2012).

[24] Kelsey, J., Schneier, B., Wagner, D., and Hall,

C. Cryptanalytic attacks on pseudorandom number
generators. In FSE (1998), S. Vaudenay, Ed.,
vol. 1372 of Lecture Notes in Computer Science,
Springer, pp. 168–188.

[25] Kim, S. H., Han, D., and Lee, D. H. Predictability

of Android OpenSSL’s Pseudo Random Number
Generator. In Proceedings of the 2013 ACM SIGSAC
Conference on Computer Communications Security
(New York, NY, USA, 2013), CCS ’13, ACM,
pp. 659–668.

[26] Michaelis, K., Meyer, C., and Schwenk, J.
Randomly Failed! The State of Randomness in
Current Java Implementations. In CT-RSA (2013),
E. Dawson, Ed., vol. 7779 of Lecture Notes in
Computer Science, Springer, pp. 129–144.

[27] SecurityTracker Alert ID: 1028916. SecurityTracker,

2013.

[28] Secure Hash Standard. National Institute of Standards

and Technology, NIST FIPS PUB 180-1, U.S.
Department of Commerce, Apr. 1995.

[29] Szekeres, L., Payer, M., Wei, T., and Song, D.

Sok: Eternal war in memory. In Proceedings of the
2013 IEEE Symposium on Security and Privacy
(Washington, DC, USA, 2013), SP ’13, IEEE
Computer Society, pp. 48–62.

[30] Trevisan, L. Extractors and pseudorandom

generators. J. ACM 48, 4 (2001), 860–879.

[31] van der Veen, V., dutt Sharma, N., Cavallaro,

L., and Bos, H. Memory errors: The past, the
present, and the future. In Proceedings of the 15th
International Conference on Research in Attacks,
Intrusions, and Defenses (Berlin, Heidelberg, 2012),
RAID’12, Springer-Verlag, pp. 86–106.

APPENDIX
A. MEMORY CORRUPTION

Partial memory corruption in some cases may be easier
than corruption of the entire memory. For example, by ex-

1014JAVA_OPTIONS=‘-Xdebug -Xrunjdwp:transport=
dt_socket,address=8998,server=y,suspend=n’

Figure 2: Modiﬁcation of the Java Virtual Machine

Java Debug Interface Comments
stop at Class:line
set variable = value

Stop execution at line
Change local variable value

Figure 3:

Internal State Modiﬁcation

cessively incrementing or decrementing an array pointer in
a loop without proper bound checking a buﬀer overﬂow may
happen, which can be exploited to read or overwrite sensitive
data. Using this technique it is possible to get a partial or to-
tal information from the memory as the Heartbleed bug [9].
A complete survey of memory attacks has been written by
Szekeres et al. in [29].

A.1 Proof of Concept

As a proof of concept, we describe the technical details
of a malicious program that partially sets the memory of a
Java PRNG. In a ﬁrst stage we present how to interact with
the Java Virtual Machine and in a second stage we present
how to interact with the PRNG.

The Java Virtual Machine. Our work is based on Java
execution model, particularly the Java 7 update 51. Java
source code is compiled into Java Virtual Machine instruc-
tions (or bytecodes) and is executed in a abstract comput-
ing machine called Java Virtual Machine (JVM). The JVM
translates the bytecode into speciﬁc machine code instruc-
tions and manages the memory for Java applications. One
way to establish a connection between an application run-
ning inside the Virtual Machine and an external application
is the Java Platform Debugger Architecture (JPDA) which is
a set of protocols and interfaces that provide a standardized
infrastructure for third-party debuggers. The JDPA is fully
described in [2]:
it deﬁnes a set of instructions to control
the application execution and memory management. The
JPDA deﬁnes a communication protocol which is called the
Java Debug Wire Protocol (JDWP). Using this communica-
tion protocol, it is possible to debug a running application
remotely or locally, modify local variables, etc. To use this,
the Java options must be enabled in the operating system
environment as described in Figure 2. Hence using standard
instructions that are deﬁned in [2], the malicious program
can simulate a debugger, get access to all memory ﬁelds used
by a Java application and set them to chosen values.

Internal State Modiﬁcation using the Debugging Fa-
cilities. All Java implementations studied in this paper use
one or more private ﬁeld(s) that are available for modiﬁ-
cation with a debugger connected to the Java application
using a socket. Once connected, the malicious program in-
teracts with the application with the standard instructions.
Precisely, it only needs to use instruction stop at to stop
the execution of the application and instruction set to set
a variable used by the application to a chosen value. These
instructions are described in Table 3.

Attack Description. First decompile the Java bytecode
to convert it in source code. The decompiled binary can
be attached to a debugger process in order to ease code

inspection, examine variables and watch control ﬂow. Using
this, we propose some simple stealthy malware:

1. Select an application to attack.
2. Decompile it, extract the source code and check whether

is susceptible to be attacked.

3. Export the JVM options to enable remote debugging.
4. Attach the source code generated to the debugger and

add breakpoints.

5. Modify variables and internal states after breakpoints

are triggered.

6. Continue with application execution.

A.2 An Attack against a Java Tor Client.

To illustrate our attack, we use the previously described
malware2 to compromise the PRNG of a pure Java Tor
Client named Orchid. This Tor client is implemented us-
ing the speciﬁcations of the Tor protocol, as described in [5]
and in [3]. First, we downloaded the JAR ﬁle from de-
veloper’s website [3]. As usual, the JAR (Java ARchive)
ﬁle is a container of the bytecode, resources and metadata.
We decompiled the archive using the Java decompiler avail-
able from [1] and we analyzed the extracted source code
to identify the PRNG used, where we could set the break-
points in order to stop the program execution and which
ﬁelds to compromise. With all this information, the mal-
ware is crafted and is delivered to the computer’s victim.
The ﬁrst task of the malware is to modify the JVM op-
tions, adding the command option describes in Figure 2 to
the environment variables in Linux/Unix or modifying the
Windows Registry in Windows. When adding this entry
to the environment, the JVM is launched listening to the
port selected (in this case, 8998) for a remote connection.
The malware can then connect from the same computer via
sockets, hence it does not need to send information to out-
side, preventing detection from networking monitors. Us-
ing the source code extracted from the binary code, we de-
duced that the Tor client Orchid instances SHA1PRNG from
provider SUN (equal to SHA1PRNG from provider OpenJDK
deduced in Section 4.3) as PRNG inside the TorRandom class.
Then, as described in Figure 2 the high-level malware con-
nects to port 8998. When the debugger connects to the
application, it waits for the nextInt() method call for ob-
tain a new random Integer. This method calls internally
engineNextBytes(), which is the method for random gen-
eration and is the target of our attack. As we showed in Sec-
tion 4.3, the critical ﬁeld of the internal state of the PRNG
to modify is the integer remCount. Once the application
has stopped, the malware inspects the internal state of the
PRNG, modiﬁes the identiﬁed critical ﬁeld in the PRNG and
continues with the execution of the application without user
awareness. As explained, no remote interaction is require to
perform this attack so these operations are only local. In
the context of the Tor network, the client takes a random
pathway to route the data packets and randomness is re-
quired to ensure privacy of the client on the network. The
Tor client Orchid generates this pathway with the method
named getRandomlyOrderedListOfExitCircuits. It makes
a call to nextInt(). Compromising the PRNG by making
the output predictable, we can force to select always one
particular path (probably compromised) for all data com-
munications of the node.

2Also can be performed using a 0-day Java exploit or similar.

1015