Anonymous Credentials Light

Foteini Baldimtsi
Brown University

foteini@cs.brown.edu

Anna Lysyanskaya

Brown University

anna@cs.brown.edu

ABSTRACT
We deﬁne and propose an eﬃcient and provably secure con-
struction of blind signatures with attributes. Prior notions
of blind signatures did not yield themselves to the construc-
tion of anonymous credential systems, not even if we drop
the unlinkability requirement of anonymous credentials. Our
new notion in contrast is a convenient building block for
anonymous credential systems. The construction we pro-
pose is eﬃcient:
it requires just a few exponentiations in
a prime-order group in which the decisional Diﬃe-Hellman
problem is hard. Thus, for the ﬁrst time, we give a prov-
ably secure construction of anonymous credentials that can
work in the elliptic group setting without bilinear pairings
and is based on the DDH assumption.
In contrast, prior
provably secure constructions were based on the RSA group
or on groups with pairings, which made them prohibitively
ineﬃcient for mobile devices, RFIDs and smartcards. The
only prior eﬃcient construction that could work in such el-
liptic curve groups, due to Brands, does not have a proof of
security.

Categories and Subject Descriptors
D.4.6 [Security and Protection]:
trols, Authentication]

[Cryptographic con-

Keywords
Anonymous credentials; attributes; blind signatures; light-
weight devices; private identity management.

1.

INTRODUCTION

Anonymous credentials, envisioned by David Chaum [17],
and ﬁrst fully realized by Camenisch and Lysyanskaya [13],
have proved to be a centrally important building block in
privacy-minded identity management systems currently un-
der development [43, 35, 16]. They allow users to prove
possession of credentials without revealing any other infor-
mation about themselves; when such a proof is carried out,

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’13, November 04–08 2013, Berlin, Germany.
Copyright 2013 ACM 978-1-4503-2477-9/13/11 ...$15.00.
http://http://dx.doi.org/10.1145/2508859.2516687.

it cannot be linked to previous uses of the same creden-
tial, or to any other identifying information about the user.
Additionally, they give the users the ability to privately
obtain credentials. The reason that they have become so
popular is that they strictly adhere to data minimization
principles [30]: no electronic transaction should require its
participants to needlessly reveal private information. These
principles are at the core of European privacy standards [37,
36] and also the National Strategy for Trusted Identities in
Cyberspace (NSTIC) published by the U.S. government [41].
Eﬃciency considerations are important when deploying
these algorithms in practice. While on a PC, the Camenisch-
Lysyanskaya credentials [13] and follow-up work [5, 10, 11,
14] take only a fraction of a second of CPU time, in mo-
bile devices, smartcards and RFID cards, they are not yet
as practical as we may wish for certain applications. The
issue is that all existing anonymous credential systems use
either the RSA group, or groups that admit bilinear pairings,
and the security parameter choice needed to provide secu-
rity under the required assumptions in these groups makes
these systems too expensive for smartcards and mobile de-
vices (i.e. original CL credentials require an RSA group with
bitlength 2048 or a pairing with 128 bits of security). Bichsel
et. al. [6] show an eﬃcient implementation of CL credentials
on a standard Java card, where they achieve an execution
time for an RSA exponentiation for a base of 1984 bits and
an exponent of 1024 bits of 1.3 seconds by using the hard-
ware accelerator for RSA of the chosen card. As a result,
more than 16 seconds are required in order to show one cre-
dential which is not practical for most applications. More-
over, hardware implementations have high development cost
(compared to software) and are not easy to update.

From the eﬃciency point of view, therefore, the UProve
credential system [35] (based on Brands’ work [8, 9], ac-
quired and implemented by Microsoft) seems attractive. UP-
rove does not allow unlinkable reuse of credentials: in order
to unlinkably use a credential again, a user must get it reis-
sued. Yet, these “linkable” credentials can serve as the basis
for e-cash, where a user is not supposed to use a coin more
than once, anyway. The UProve credential issuing proto-
col, as well as the algorithm for verifying a credential, are
practical enough for the more advanced end of RFID tech-
nology, since they can work in any group where the discrete
logarithm problem is hard (thus can be based on ECC), and
require just a few exponentiations in this group. Software
implementations of ECC multiplication are much faster than
the equivalent RSA exponentiation [27] (hardware accelera-
tors could also speed up both ECC and RSA implementa-

1087tions by an order of magnitude or more; today there exist
RFID chips that perform ECC multiplication in 0.4 seconds
[44]).

So perhaps one could use these “linkable” anonymous cre-
dentials and just have them reissued as many times as need-
ed. However, UProve is not provably secure! No proof of
security has been given under any reasonable assumption;
and in fact, recently, Baldimtsi and Lysyanskaya [4] showed
that all known approaches for proving security in the ran-
dom oracle model will fail for the Brands blind signature
scheme on which UProve is based, under essentially any as-
sumption.

One might ask what happens if, instead of the Brands
blind signature, one tries to construct linkable anonymous
credentials from a provably secure blind signature scheme.
Unfortunately, blind signatures as traditionally deﬁned [40,
39, 29, 1] do not give any consideration to users’ attributes.
In a blind signature, a user is free to choose whichever mes-
sage he wants signed. In a credential scheme, a user should
be able to get his particular attribute set signed by the
signer. The signers can verify that what they are signing
is the correct attribute set, even though they cannot see ex-
actly what they are signing. For example, a signer might
want to sign a user’s secret key, his age, and his citizenship
information, and wants to be able to verify that this is in-
deed what she is signing. Attributes are, in fact, essential:
without them, it is impossible to tie a credential to a partic-
ular user’s identity, and so users would be able to just pool
each others’ credentials as desired, instead of tying them to
a particular secret key. Moreover, giving the user the ability
to choose any message means that the content of the signed
messages has not been vetted by the signer at all.

Thus, a better question is: how do we extend the no-
tion of a blind signature so that it can eﬃciently accommo-
date anonymous credentials — if not full anonymous creden-
tials a-la Camenisch and Lysyanskaya, then at least linkable
lightweight anonymous credentials a-la Brands?
Blind Signature with Attributes. In this paper, for the
ﬁrst time, we deﬁne blind signatures with attributes. In such
a blind signature scheme, the signer and the user both get
as input a cryptographic commitment C to the user’s at-
tributes; this way, the user can prove that the commitment
contains the correct attributes via a separate zero-knowledge
proof. As output, the user obtains another, unlinkable, com-
mitment ˜C to the same attributes, and a signature on this
commitment and a message of the user’s choice. Blindness
ensures that, even upon seeing two signatures obtained this
way on commitments of his own choice, the signer cannot
link a signature to its issuing. Unforgeability ensures that
a user cannot produce more signatures than he was issued,
and also that the multiset of openings to the input commit-
ments is the same as the multiset of openings to the output
commitments.
From Blind Signatures with Attributes to Anony-
mous Credentials. It is easy to see that this is the right
building block for linkable anonymous credentials: a user
with a particular set of attributes can form a commitment
C to these attributes, prove in zero-knowledge that he has
committed to the correct attributes, and then obtain a cre-
dential by running a blind signature with attributes on input
this commitment. He can then prove that he has a credential
with the desired attributes by revealing his signature and the

output commitment ˜C, and proving in zero knowledge that
˜C corresponds to the needed attributes.

For example, suppose that we allow users to obtain and
anonymously show age credentials. Then Alice will form a
commitment C to her secret key sk and her age age, prove
to the signer, who serves as an identity validator, that she
has committed to sk that corresponds to her pk and to the
correct age, and run a blind signature with attributes proto-
col to obtain a fresh commitment ˜C on the same sk and age,
and a signature σ. Then, when she needs to prove her age,
she can reveal ( ˜C, σ) and prove that the age inside commit-
ment ˜C allows her entry to some age-restricted resource, for
example a video store that requires viewers to be over 13. If
she wants to do it again, she needs to run the blind signa-
ture with attributes protocol with the signer again. She can
further anonymously obtain credentials that are connected
to her identity: let’s say that the video store wants to give
her a credential for a free movie; she can obtain it by run-
ning a blind signature with attributes with the video store.
She will form her input commitment C(cid:48) by committing to
the same sk and age as in ˜C and proving to the video store
that she did so (by proving equality of committed values);
once she runs the protocol with the video store, she receives
an output ( ˜C(cid:48), σ), which is a credential from the video store
(and not from the original signer) on her (sk , age) — even
though the video store never saw the public key at all. More
interestingly, we can require the free movie to be a single-
use credential, by additional clever use of attributes (see
Section 4), so that Alice can be traced if she tries to get two
free movies using the same single-use credential more than
once. Thus we see that blind signatures with attributes are
the right building block for linkable anonymous credentials.
Construction. In addition to the deﬁnition, we solve the
open problem of constructing anonymous credentials based
on the DDH assumption. We give a lightweight construction
of blind signatures with attributes; because of the connection
to single use anonymous credentials we call our construc-
tion “anonymous credentials light” (ACL). In the random-
oracle model, our construction is unlinkable under the de-
cisional Diﬃe-Hellman assumption, and unforgeable under
the discrete-logarithm assumption for sequential composi-
tion (we leave extending it to concurrent self-composition
as an open problem). Our construction is inspired by the
Abe blind signature [1] in which, unlike other provably se-
cure blind signatures [7, 12, 34, 40, 22], blinding still pre-
serves some structural elements into which attributes can
be embedded. Unfortunately Abe’s construction, as it was
ﬁrst presented, had a faulty proof of security as it was later
found by Abe and Ohkubo [33]. The original proof was in
the RO model for concurrent composition but it turned out
to only be valid for an adversary with overwhelming success
probability so they ended up presenting a new proof in the
generic model. In the other hand, we manage to proof our
scheme in the RO model by limiting our attention to sequen-
tial composition only. Moreover, our analysis indicates that
Abe’s scheme may be provable under DDH in the RO model
for sequential composition.
Related Work and Comparisons. Let’s now take a
closer look in our ACL construction and compare it with
other well known blind signature and credential schemes.
For our comparisons we focus on the eﬃciency of signing
(which is analogous to the credential issuing), the cost of

1088Brands Abe ACL CL credentials [13]

[8]

[1] Scheme Rsa

Pairings

Eﬃciency
Signing3

Veriﬁcation

Sign. size

Blindness

Prov. Unforg.

Attributes

S1 U 2 S U S U S U
13 10 8
2

12 6 12 7

S

U

15

14p
NC4 5+6p 9+6p

1

0 11 1 11

7
6 elem. 9 elem. 9 elem. ∼ 05












GM6





∼ 05




1 Signer, 2 User, 3 In number of exponentiations
4 Non-comparable, 5 It can be used multiple times

6 Generic group model

(which, as we mentioned above, is a direct application of
“single-use” credentials). Our implementation is mostly a
proof of concept and we used a 160 bit elliptic curve group.
Brieﬂy, the signing/issuing takes a total of 300 milliseconds
including terminal, communication and smartphone execu-
tion time, while spending (i.e. veriﬁcation of the signature)
takes about 380 milliseconds when 2 attributes are revealed
which would be less if no attributes were revealed.

2. PRELIMINARIES
2.1 Basic Assumptions

The following two standard cryptographic assumptions

Table 1: Comparison of anonymous credentials

are useful in the paper.

veriﬁcation of the signature/credential, the size of the sig-
nature/credential, the security of the schemes i.e. blind-
ness and unforgeability and whether the schemes support
attributes which is obviously not going to be the case for a
“traditional” blind signature scheme.

The ACL construction consists of three phases: registra-
tion, preparation and validation. Registration is the most
expensive phase, but it need not be repeated for the same
user/signer pair should the user need his credential reissued
(as long as his attribute set is the same). Preparation and
validation require the signer to perform 7 exponentiations,
while the user performs 13; veriﬁcation requires 8 exponen-
tiations. These numbers are essentially the same as Abe’s
blind signature; Brands’ blind signature at the heart of UP-
rove requires essentially the same number of exponentiations
for signature issue, and 4 exponentiations fewer for veri-
ﬁcation. Thus, we get comparable eﬃciency to the most
eﬃcient examples of protocols that either lack essential fea-
tures (such as previously provable secure blind signatures)
or provable security (such as UProve). We also compare
ourselves to the Camenisch-Lysyanskaya [13] which is signif-
icantly less eﬃcient during issuing due to the use of pairings
or RSA group but is a multi-use credential, thus we denote
the signature/credential size to be close to zero since it can
be used multiple times. See Table 1 for the comparisons.

A related work is due to Guajardo et al. [25] where they
proposed “encrypted anonymous credentials”. The idea is
that an issuer can certify encrypted attributes in such a
way that none of the involved parties, including the user,
can learn the value of the attributes. This is an interesting
application but cannot be used as a building block so it is
incomparable to our work. Moreover, their construction [25]
is based on Brands scheme which as mentioned above cannot
be proven one-more unforgeable [4].
Recommended parameter setting. For 128 bit security
we recommend using a group of 576 bits1. In order to achieve
an equivalent security level with CL credentials keys of 3072
bits would be required.
Implementation.
In an independent work [28] we have
implemented the ACL scheme using an NFC enabled smart-
phone: the BlackBerry Bold 9900. The implementation has
been tailored for payments in transportation systems where
our ACL construction is being used as an e-cash scheme

1Please refer to the proof of Theorem 4 for a justiﬁcation of
this number.

Deﬁnition 1. (Discrete Logarithm Assumption) Let k be
the security parameter. Let Gk be a set of groups such that
Gk is a group of order q (k-bit prime) and generator g. Then,
for every polynomial time algorithm A it holds that:

P r[h ← G; x ← A(h) : x = logg h] ≤ ν(k)

where ν(k) is a negligible function.

Deﬁnition 2. (Decisional Diﬃe-Hellman Assumption) Let
DH be an instance generator that, on input the security
parameter 1k outputs (G, q, g, A, B, C) where G is a cyclic
group of order q (k-bit prime) with generator g, and, for
randomly chosen a, b ∈ Zq, A = ga, B = gb and C = gab.
Let Rand be an instance generator that, on input 1k outputs
(G, q, g, A, B, C) where G,q,g,A and B are as above, while
C = gc for a random c ∈ Zq. We assume that DH and Rand
are computationally indistinguishable.
2.2 Witness Relations and Interactive Proofs
A witness relation for a language L ∈ NP is deﬁned as:
Deﬁnition 3. (Witness relation [23]) A witness relation
for a language L ∈ NP is a binary relation RL that is poly-
nomially bounded (i.e., (h, x) ∈ RL implies |x| ≤ poly(|h|)),
is polynomial-time-recognizable and characterizes L by

L = {h : ∃x s.t. (h, x) ∈ RL}.

For h ∈ L, any x satisfying (h, x) ∈ RL is called a witness
(for the membership h ∈ L). By RL(h) we denote the set of
witnesses for the membership h ∈ L; that is, RL(h) = {x :
(h, x) ∈ RL}.

Deﬁnition 4. (Interactive Proof System [24] ) An interac-
tive proof system with soundness error s ∈ [0, 1] for a lan-
guage L with witness relation RL is a pair of algorithms
(P, V ) where v is probabilistic polynomial time and the fol-
lowing properties hold:

1. Completeness. For every h ∈ L and every x ∈ RL(h),

P r[(cid:104)P (x), V (cid:105)(h) = 1] = 1.

2. s-Soundness. For every h (cid:54)∈ L, every z ∈ {0, 1}∗ and

every interactive algorithm P ∗

P r[(cid:104)P

∗

(z), V (cid:105)(h) = 0] ≥ 1 − s.

A useful property in the above setting would be if the veriﬁer
V wouldn’t learn anything useful from P about the witness
x besides the fact that P knows x. This property is called
zero knowledge. If soundness error s is negligible, then this
interactive proof system has strong soundness.

1089Deﬁnition 5. (Honest Veriﬁable Zero Knowledge (HVZK))
An interactive proof system (P, V ) for a language L is said
to be honest veriﬁable zero knowledge if there exists a prob-
abilistic polynomial time algorithm S (the Simulator) such
that for all h ∈ L:

viewV [(cid:104)P, V (cid:105)](h) ≈ S(h),

where viewV is the view of the honest veriﬁer V of the in-
teraction between V and P on input h.
2.3 Σ-Protocols

Σ-protocols are a class of interactive proofs where the
Prover and the Veriﬁer (P, V ) have a common input h and
P proves in zero-knowledge that he knows a value x such
that (h, x) ∈ RL. Their main characteristic is that they
have exactly 3 rounds of the following type: (1) P sends a
message a to V , (2) V responds with a random challenge c
chosen from a domain of size Θ(k) and (3) P resents a reply
r. V decides whether to accept or not given the information
he has seen: (h, a, c, r). Formally:

Deﬁnition 6. (Σ-Protocol ) A protocol P is said to be a

Σ-protocol for a relation RL if:

• P is of the above three rounds form, and if (P, V )
follow the protocol, the veriﬁer always accepts.
• From any h and any pair of accepting conversations
on input h, (a, c, r), (a, c(cid:48), r(cid:48)) where c (cid:54)= c(cid:48), one can
eﬃciently compute x such that (h, x) ∈ RL (special
soundness).
• There exists a polynomial-time simulator S, which on
input h and a random c outputs an accepting conver-
sation of the form (a, c, r), with the same probability
distribution as conversations between the honest P, V
on input h (special honest-veriﬁer zero-knowledge).

An example of a Σ-protocol is the Schnorr Identiﬁcation
scheme [42]. Let G be a group of prime order q with gen-
erator g, and let Zq denote the ﬁeld of integers modulo q.
Schnorr’s identiﬁcation scheme works as follows:

Prover(q, g, h = gx)
y ← Zq, a = gy

r = y + cx mod q

Veriﬁer(q, g, h)

a−−−→
c←−−− c ← Zq
r−−−→ gr ?= ahc

Σ-protocols are an essential building block for blind signa-
tures and anonymous credentials. For example Brands’ [8]
and Abe’s [1] schemes are based on a Σ-protocol, while CL
anonymous credentials [13] uses ZK proofs which are based
on Σ-protocols.
2.4 Fiat-Shamir Heuristic

Fiat and Shamir [21] proposed a method to transform any
three-round interactive proof system with negligible sound-
ness error, such as Σ-protocols, into a digital signature using
a hash function, modeled as a random oracle.

To transform a three-round proof system into a signa-
ture scheme, one could, instead of a random c, compute
c = H(a, m), where H is a hash function. Then, the Fiat-
Shamir transformation uses c to create a signature σ(m) =
(a, r). Famous digital signatures that have been constructed
from Σ-protocols using the Fiat-Shamir heuristic include
Schnorr’s [42] and GQ signatures [26] and they have been
proven secure in the RO model [39].

2.5 OR-proof
Let P be a Σ-protocol for a relation RL, (h0, h1) be a
common input to (P, V ) and P knows a x such that hb, x ∈
RL for b ∈ {0, 1}. An OR-proof protocol POR is a Σ-protocol
for proving that either (h0, x) ∈ RL or (h1, x) ∈ RL [20]2.
The main idea of an OR-proof is that P will complete two
Σ protocols Σ0, Σ1, one for h0 and one for h1 in such a way
that the veriﬁer will not be able to tell for which of the two
P knows the corresponding witness. For hb the prover can
actually follow the real Σ protocol while for h1−b he will
have to use a simulator M to create his answers. A POR
protocol works as follows:

1. P computes the ﬁrst message of Σb, ab, using (hb, x)
as input. P randomly chooses c1−b and runs the simu-
lator M on input (h1−b, c1−b) and receives (a1−b, c1−b,
r1−b) as an output. Then, P sends a0, a1 to V .
2. V chooses a random string e and sends it to P .
3. P sets cb = e ⊕ cb−1 and computes the answer rb
to challenge cb using hb, ab, cb, x as input. He sends
c0, c1, r0, r1 to V .
4. V checks that e = c0 ⊕ c1 and that both (a0, c0, r0)

and (a1, c1, r1) are accepting conversations.

Let ROR = {((h0, h1), x)|(h0, x) ∈ RL or (h1, x) ∈ RL}.
Then:

Theorem 1

([20]). The POR protocol is a Σ-protocol
for ROR. Moreover, for any veriﬁer V ∗, the probability dis-
tribution of conversations between P and V ∗, where x is such
that (hb, x) ∈ RL, is independent of b.
2.6 Generalized Pedersen Commitment

A non-interactive commitment takes as input a message
(or set of messages) m and randomness R and outputs a
value that, on the one hand, reveals no information about
the message but, on the other hand, it is hard to ﬁnd a
(m(cid:48), R(cid:48)) such that Commit(m; R) = Commit(m(cid:48), R(cid:48)) but
m (cid:54)= m(cid:48) (see [31] for a standard deﬁnition and treatment).
The Pedersen commitment is a commitment scheme based
on the discrete logarithm assumption [38]. Here we give a
generalized version that allows a commitment to a set of
messages (L1, . . . , Ln). The scheme is deﬁned as follows:

1. Setup: On input the security parameter 1k and the
maximum number of messages n, pick a group G of
prime order q = Θ(2k) with generators h, h1, . . . , hn.
; and Li ∈ Zq.

2. Commit(L1, . . . , Ln; R) = hR(cid:81)n

i=1 hLi

i

The Pedersen commitment scheme (constructed from a cor-
responding Σ-protocol) is information theoretically hiding
and computationally binding. It is also important that there
are eﬃcient zero-knowledge proof protocols for proving that
a commitment C is to a particular set of values; or to a set
of values that satisfy a rich class of relations [8, 15, 19].
2.7 Combined Commitment Scheme

Let Commit 1 be a commitment scheme that takes as input
its parameters params 1, n messages (L1, . . . , Ln) to which
we will refer to as attributes from now on and randomness R1

2This is based on a more general result due to Cramer et.
al.
[18] where they present a protocol in which the prover
demonstrates knowledge of the solution to some subset of n
problem instances out of a collection of subsets.

1090and outputs a commitment C1. Let Commit 2 be a commit-
ment scheme that takes as input its parameters params 2,
an attribute L0 and randomness R2 and outputs a com-
mitment C2. Suppose that another commitment scheme,
Commit, is a combination of these two commitments; i.e.,
on input C1 and C2 it produces a commitment C to the com-
bined attributes (L0, L1, . . . , Ln) with combined randomness
R = R1 + R2.

For example, this can be instantiated by a generalized
Pedersen commitment scheme: the parameters for the com-
bined scheme are generators (h, h0, . . . , hn), Commit 1(L1,
0 hR2 ,
and a combined commitment can be obtained either by mul-
tiplying together the two component commitments, or by
computing it from scratch as Commit(L0, L1, . . . , Ln; R) =

. . . , Ln; R1) = ((cid:81)n
((cid:81)n

i )hR1 , Commit 2(L0; R2) = hL0

i=1 hLi

i=0 hLi

i )hR.

2.8 Blinded Pedersen Commitment Scheme

Here, we note that the Pedersen commitment scheme can
be further extended. Let (h, h1, . . . , hn) be the parameters of
the Pedersen commitment. Consider an additional parame-
ter z ∈ G, where z (cid:54)= 1. Let C = Commit(L1, . . . , Ln; R).
Then the values (zγ, C γ) can also be viewed as a commit-
ment to the same (L1, . . . , Ln) with randomness (R, γ). Let
us deﬁne a new commitment scheme, which we will call the
blinded Pedersen commitment scheme: Commit B(L1, . . . ,
Ln; R, γ) = (zγ, Commit(L1, . . . , Ln; R)γ), where Commit
is the Pedersen commitment.
It is easy to see that this
commitment is unconditionally hiding, same as Pedersen. It
is also easy to see that it is binding: given (zγ, C γ), γ is
uniquely deﬁned, and therefore so is C, which is binding.
Finally, using well-known Σ-protocols, it is easy to see that
the same set of relations that can be proven about values
inside a Pedersen commitment can be proven about values
inside a blinded Pedersen commitment.

3. DEFINITION OF SECURE BLIND SIG-

NATURES WITH ATTRIBUTES

In this section, for the ﬁrst time, we deﬁne what a blind
signature scheme with attributes is and its security proper-
ties. For deﬁnitions of standard (without attributes) blind
signatures please refer to [29].

Deﬁnition 7. (Blind signatures with attributes)

Let Commit(x; r) be a non-interactive commitment scheme
whose parameters params are generated by a trusted party
TP and let n be the maximum number of messages the
scheme can support. A blind signature scheme with n at-
tributes, for this commitment scheme, consists of three al-
gorithms: KeyGen, BlindSign, Verify where BlindSign is a
protocol between the Signer(S) and the User(U).

• KeyGen(1 k , params): is a probabilistic polynomial time
key generation algorithm.
It takes as input the se-
curity parameter k and the public parameters of the
commitment scheme and outputs (pk , sk ) where pk is
the signer’s public key and sk is his secret key.

is an interactive, probabilistic polynomial
time protocol between S and U . The common input
is the Signer’s public key pk, the parameters of the
commitment scheme params and C = Commit(L1,
. . . , Ln; R) where (L1, . . . , Ln) is the set of attributes
and R is some randomness. The Signer’s private input

• BlindSign:

is sk and User’s private input is (L1, . . . , Ln, R) and
the message, m, that he wishes to have signed. The
User’s output in the protocol is a pair ( ˜R, σ), where
σ = σ(m, ˜C) is the Signer’s signature on (m, ˜C), and
˜C = Commit(L1, . . . , Ln; ˜R) ; the Signer’s output is
“completed”.
• Verify(P K, m, ˜C, σ): is the signature veriﬁcation algo-
rithm; i.e. a deterministic polynomial time algorithm
that gets as input the public key, the message, a com-
mitment to the attributes and the blind signature on
the message and attributes and checks the validity of
the signature σ.
If it is valid the algorithm outputs
“1”, otherwise outputs “0”.

A blind signature scheme with attributes is secure if it is
both blind and unforgeable. Blindness is deﬁned in a similar
way as in blind signature schemes without attributes: the
Signer is unable to view the messages and the attributes
he signs (protection for the User). A malicious Signer, A,
cannot link a (m, ˜C, σ) tuple to any particular execution of
the protocol, even if A chooses m, L1, . . . , Ln.

Deﬁnition 8. (Blindness for blind signatures with attrib-
utes) Let A be a malicious Signer and b ∈ {0, 1} be a ran-
domly chosen bit which is kept secret from A. A will try to
guess the value b by performing the following steps:

−→
L0,

1. (pk, sk) ← KeyGen(1k)
2. {m0, m1,

−→
L1, R0, R1} ← A(1k, pk, sk) (i.e. A pro-
duces two messages {m0, m1}, polynomial in 1k, and
−→
−→
two attribute vectors
L1 with the corresponding
L0,
−→
−→
randomness).
3. A(1k, pk, sk, m0, m1,
L1, R0, R1) engages in two par-
L0,
allel (and arbitrarily interleaved as desired by A) in-
−→
teractive protocols, the ﬁrst with U (pk,{mb,
L0, R0})
−→
L1, R1}).
and the second with U (pk, {m1−b,
4. A only gets signatures and the corresponding blinded
commitments for the instances that didn’t fail; for the
ones that failed A gets nothing. If neither of the User
instances failed, then A gets two signatures and the
corresponding blinded commitments: σ(m0, ˜Cb), ˜Cb
and σ(m1, ˜C1−b), ˜C1−b. Otherwise, A outputs ⊥.

5. A outputs a bit b(cid:48).

Then the probability, taken over the choice of b, over coin-
ﬂips of the key-generation algorithm, the coin-ﬂips of A, and
(private) coin-ﬂips of both users (from step 3), that b(cid:48) = b
is at most 1

2 + ν(k), where ν(k) is a negligible function.

We give the deﬁnition of one-more unforgeability for the

sequential composition case.

Deﬁnition 9. (Sequential one-more ((cid:96), (cid:96) + 1) unforgeabil-
ity for blind signatures with attributes) (KeyGen, BlindSign,
Verify) is a one-more unforgeable blind signature scheme
with respect to Commit if ∀ probabilistic polynomial time
adversaries A, the probability that A wins in the following
game is negligible:

1. (pk, sk) ← KeyGen(1k)
2. A(pk , params) engages in polynomially many (in k)
adaptive, sequential interactive protocols with polyno-
mially many copies of the signer, where A decides in

1091an adaptive fashion when to stop. For every execution,
A forms a commitment Ci and picks a message mi and
invokes S(pk, sk, Ci). Let (cid:96) be the number of execu-
tions, where the Signer output “completed” in the end
of the protocol.
3. A outputs a collection {( ˜C1, m1, σ1), . . . , ( ˜Cj, mj, σj)}
where ( ˜Ci, mi, σi) for 1 ≤ i ≤ j are all accepted by
V erif y(pk, ˜Ci, mi, σi), and all ( ˜Ci, mi)’s are distinct.

We say that A wins the game if either:

1. j > (cid:96) (i.e. A outputs more ( ˜C, m, σ) tuples than he
2. A opens the sets of commitments {Ci} and { ˜Ci} and

received).

the resulting multisets do not match.

4. FROM BLIND SIGNATURES WITH AT-
TRIBUTES TO SINGLE-USE CREDEN-
TIALS

Single-use anonymous credentials ensure that a credential
cannot be used more than once: if used more than once, the
user’s identity can be discovered, and the user can be penal-
ized. This is a generalization of oﬀ-line electronic cash [17],
in that such a credential can also contain attributes, while
e-cash does not necessarily have any connection to a user’s
identity. Here we construct single-use anonymous creden-
tials from blind signatures with attributes using standard
techniques [17, 8, 11].

Recall our deﬁnition of combined commitment schemes
(Commit 1, Commit 2, Commit) from Section 2.7. Consider
the following construction of a single-use credential with
n attributes from a blind signature scheme with n + 1 at-
tributes. The common inputs to the User and Signer are the
Signer’s public key for verifying signatures, and a commit-
ment C1 to the User’s attributes (L1, . . . , Ln)3. We assume
that the attribute L1 contains the user’s identity, so that
learning that attribute will allow one to trace the user. The
Signer’s private input is its signing key, while the User’s pri-
vate input is the message m that the user wants signed (m
will serve as the serial number for this credential, so the user
needs to have chosen it at random during the signing pro-
tocol) and the opening to C1, (L1, . . . , Ln; R1). The com-
mitment C1 corresponds to this user’s identity and never
changes; each time this user obtains a signature, they input
the same C1.

First, the User forms a commitment C2 = Commit 2(L0;
R2) for random (L0, R2); this commitment is speciﬁc to this
credential, and the value L0 will be used in the double-
spending equation, below. Next, the user submits C2 to the
signer and provides a zero-knowledge proof of knowledge of
its opening.

Next, the User and the Signer carry out the blind signa-
ture protocol relative to the combined commitment scheme
Commit, whereby the User’s output is a fresh commitment
˜C to the values (L0, . . . , Ln) and randomness ˜R, and the
signature σ on (m, ˜C).

To use this credential to a veriﬁer V , the User reveals
(m, ˜C, σ), obtains from V a challenge c, and reveals the
double-spending equation cL1 + L0 (the multiplication and
addition is in whatever ring the committed values belong

3We assume that there exists an external procedure to vali-
date the user’s identity.

to) and whatever other attributes are needed for the trans-
action; the User then provides a zero-knowledge proof that
these values were revealed correctly, relative to commitment
˜C.

To trace a user who spent a single-use credential twice, it
is suﬃcient to examine two double-spending equations for
the same credential. If double spending occurred, then the
attribute L1, which encodes the User’s identity, will be re-
vealed.

The following theorem is stated informally because we
omitted a formal deﬁnition of single-use anonymous creden-
tials.

Theorem 2. (Informal) Let KeyGen, BlindSign, Verify be
a blind signature scheme with n + 1 attributes, associated
with the commitment scheme Commit which is a combina-
tion of Commit 1 and Commit 2 as explained above. Then the
above construction is a single-use credential scheme with n
attributes.

5. OUR CONSTRUCTION: ACL

Let’s now describe our proposed construction of a blind
signature scheme with attributes, called “Anonymous Cre-
dentials Light” (ACL). ACL is based on Abe’s blind signa-
ture scheme [1] which has been modiﬁed appropriately so
that it will also allow the users to encode attributes in the
signatures they get in a provably secure way. Abe’s scheme
is a witness indistinguishable variant of the Schnorr signa-
ture scheme where the Signer owns a real public key y = gx
and a tag public key z = gw. The idea is that the signature
can be issued only with the real secret key x but no one can
distinguish which of the two (real or tag) secret keys was
used (remember the OR-proof technique presented above).
Although the modiﬁcation seems straightforward, proving
the security of the resulting scheme turns out to be challeng-
ing as we will see later in the next section.
5.1 Setup
Let G be a group of prime order q and g be a generator
of this group. Let H : {0, 1}∗ → Zq be a hash function.
We assume the existence of a trusted party, T P , which
chooses G, g and outputs params = (q, G, g, h, h0, . . . , hn)
where h, h0, . . . , hn ∈ G and n is the maximum number of at-
tributes a User can possibly have. We will use (h0, . . . , hn) as
parameters of the combined Pedersen commitment scheme
Commit.
The Signer picks his secret key x ∈R Zq and computes
his real public key to be y = gx mod q. The T P given
(G, q, g, h, y) outputs z which is the tag public key of the
Signer (this can also be done using a hash function Hz :
{0, 1}∗ → G that acts as a random oracle). The public key
of the Signer is (G, q, g, h, y, z), and the private key is x. We
will use (z, h0, . . . , hn) as parameters for the blinded Peder-
sen commitment scheme Commit B.
5.2 Signature/ Credential Issuing

The signature issuing protocol will be described in three
phases: registration, preparation and validation. The regis-
tration phase actually only needs to happen once for each
user/set of attributes and also, preparation and validation
phases can happen simultaneously (we choose to present
them separately in order to describe the construction in a
more modular way).

1092The signature issuing protocol is basically a POR-protocol

for proving knowledge of one of the following:
• y-side: proof of knowledge x of y = gx
• z-side: proof of knowledge (w1, w2) of z1 = gw1 , z2 =
hw2 (where z1, z2 are the so called “one-time” tag keys
created by the signer using input from the user).

Notice that the z-side witness in not known to the Signer,
so the z-side proof will be done by simulation following the
OR-proof technique paradigm described in Appendix 2.5.

5.2.1 Registration
The User’s input includes the system parameters params,
the signer’s real public key y, the message m to be signed
and (L1, . . . , Ln; R) where L1, . . . , Ln is a set of attributes
and R is some randomness. The Signer also gets as in-
put the system parameters params, a commitment C =
Commit(L1, . . . , Ln; R) and his secret key x. During reg-
istration the User and the Signer carry out a standard in-
teractive zero-knowledge proof of knowledge protocol where
the User creates a proof π1 to convince the Signer that he
knows an opening of the commitment C.

5.2.2 Preparation
The Signer prepares z1 and z2 (the z-side proof). He
ﬁrst picks rnd ∈ Zq and creates the “one-time” tag keys:
z1 = Cgrnd and z2 = z/z1. The Signer sends rnd to the
User in order to convince him that logg z1 is not known to
him. The User ﬁrst checks that rnd (cid:54)= 0 and then computes
himself z1 = Cgrnd and then picks γ ∈ Z∗
q and blinds z, z1, z2
into ζ = zγ, ζ1 = zγ
1 , ζ2 = ζ/ζ1 so that logz z1 = logζ ζ1
holds.
Finally, the User picks τ ∈ Zq and computes η = zτ (this
will serve as an element of an additional Schnorr signature
that proves knowledge of γ such that ζ = zγ).

5.2.3 Validation
In this phase two Σ protocols are going to take place and
combined according to the OR-proof. By (a, c, r) we are
going to denote the transcript of Σy and by (a(cid:48), c(cid:48), r(cid:48)) we
will denote the transcript of Σz. The Signer will compute
Σz himself and Σy in interaction with the user.

1 zc(cid:48)

2 zc(cid:48)

1, r(cid:48)

2 into α(cid:48)
2 . We denote α(cid:48) = {α(cid:48)

1, a(cid:48)

2. The User checks whether a, a(cid:48)

2 . Finally he sends to the User a, a(cid:48) = {a(cid:48)

2 ∈ Zq}. and sets a(cid:48)
1, a(cid:48)

1. The Signer begins by creating a for Σy by picking a
random u ∈ Zq and computing a = gu. Then, for Σz,
following the OR-proof he picks random c(cid:48) ∈ Zq and
1 = gr(cid:48)
r(cid:48) = {r(cid:48)
1 and a(cid:48)
2 =
hr(cid:48)
2}.
1, a(cid:48)
2 ∈ G and then picks
blinding factors t1, t2, t3, t4, t5 ∈R Zq and blinds a into
(cid:48)γ
α = agt1 yt2 and a(cid:48)
1 gt3 ζ t4
2 =
(cid:48)γ
2}. Then, computes
2 ht5 ζ t4
a
ε = H(ζ, ζ1, α, α(cid:48), η, m) where m is the message to be
signed. The User sends to the Signer e = (ε − t2 −
t4) mod q.
3. The Signer, according to the OR-proof technique, com-
putes c = e − c(cid:48) mod q and r = u − cx mod q. Then,
sends (c, r, c(cid:48), r(cid:48)) to the User.
gets: ρ = r + t1 mod q, ω = c + t2 mod q, ρ(cid:48)
2 = γr(cid:48)
t3 mod q, ρ(cid:48)
µ = τ − ω(cid:48)γ mod q.

4. Finally, the User “unblinds” the received values and
1 +
2 + t5 mod q, ω(cid:48) = c(cid:48) + t4 mod q,

1 and α(cid:48)

1 = a
1, α(cid:48)

1 = γr(cid:48)

Signer(params, x, C)

User(params, y, m, (L1, . . . , Ln; R))

Registration

Preparation
rnd ∈R Zq
z1 = Cgrnd
z2 = z/z1

π1←−−→

rnd−−−−→

0 hL1

1 hL2

2

C = hR
π1

. . . hLn
n

q

check if rnd (cid:54)= 0
z1 = Cgrnd
γ ∈R Z∗
ζ = zγ
ζ1 = zγ
1
ζ2 = ζ/ζ1
τ ∈R Zq
η = zτ

1, r(cid:48)

Validation
2, c(cid:48) ∈R Zq
u, r(cid:48)
a = gu y-side
1 = gr(cid:48)
a(cid:48)
2 = hr(cid:48)
a(cid:48)

1 zc(cid:48)
2 zc(cid:48)

1

2

z-side

c = e − c(cid:48) mod q
r = u − cx mod q

a, a(cid:48) = {a(cid:48)
2}
1, a(cid:48)
−−−−−−−−−−−−−→

e←−−−

1, a(cid:48)

2 ∈ G
check if a, a(cid:48)
t1, t2, t3, t4, t5 ∈R Zq
α = agt1 yt2
y-side
α(cid:48)
1 = a
α(cid:48)
z-side
2 = a
ε = H2(ζ, ζ1, α, α(cid:48)
1, α(cid:48)
e = (ε − t2 − t4) mod q

(cid:48)γ
1 gt3 ζ t4
(cid:48)γ
2 ht5 ζ t4

2

1

2, η, m)

2}
1, r(cid:48)

c, r, c(cid:48), r(cid:48) = {r(cid:48)
−−−−−−−−−−−−−−−−→ ρ = r + t1 mod q
ω = c + t2 mod q
ρ(cid:48)
1 = γr(cid:48)
1 + t3 mod q
ρ(cid:48)
2 = γr(cid:48)
2 + t5 mod q
ω(cid:48) = c(cid:48) + t4 mod q
µ = τ − ω(cid:48)γ mod q

Table 2: Proposed ACL construction

A signature is a 8-tuple σ = (m, (ζ, ζ1, ρ, ω, ρ(cid:48) = {ρ(cid:48)

2},
ω(cid:48), µ)) where ζ1 encodes the attributes of the User ((ζ, ζ1)
corresponds to ˜C, which is a blinded Pedersen commitment
to (L1, . . . , Ln) with randomness (R, γ)).

1, ρ(cid:48)

In Table 2 we describe all the phases of our construction.
5.2.4 Veriﬁcation
A signature tuple (m, ζ1, σ) (where ζ1 corresponds to ˜C)
veriﬁes if ζ (cid:54)= 1 and

(cid:48)

ω + ω

= H(ζ, ζ1, gρyω, gρ(cid:48)

1 ζ ω(cid:48)
1 , hρ(cid:48)

2 , zµζ ω(cid:48)
2 ζ ω(cid:48)

, m) mod q.

5.3 Discussion

As brieﬂy mentioned in the description of our construc-
tion there are certain “tricks” we can do to improve its eﬃ-
ciency. First of all notice that the Registration phase only
needs to happen once for each User and a corresponding set
of attributes. The Signer stores the attribute commitment
C together with some identiﬁcation information asked from
the User (e.g. passport, ID). Then, it is suﬃcient if every
time in the beginning of the Signature Issuing protocol the
User identiﬁes himself to the Signer in order to prove owner-
ship of his account. Moreover, notice that Preparation and
Validation phases can be combined and executed simulta-
neously. As a result, the whole signing protocol consists of
three rounds.

Let’s now discuss the diﬀerences between our ACL con-
struction and the blind signature protocol described by Abe
[1]. The basic advantage of ACL is that allows for the encod-
ing of users’ attributes in the signatures they receive from

1093the Signer. In order for this to happen we need the Regis-
tration phase during which the User commits to his set of
attributes. Those attributes are then encoded in the signa-
ture in ζ1. The crucial diﬀerence from Abe’s approach is
that z1 can no longer be computed as the result of some
hash function given a random input rnd. In ACL, z1 needs
to include the attribute commitment C so z1 = Cgrnd (we
need the grnd factor so that two diﬀerent signature issuings
with the same user cannot be linked to each other). This is
the step where the blinded signature inherits some structure
from the values the signer can see in the signing step, and
allows the encoding of attributes. The fact that z1 is not the
result of a hash function H(cid:48) makes our security analysis dif-
ferent from Abe’s. We can no longer deﬁne H(cid:48) so that it will
return the output we need, instead we will have to make use
of ZK extractors. Unfortunately, we cannot take advantage
of Abe’s analysis because it only applied to special types of
adversaries [33]. Of independent interest, our analysis indi-
cates that, for sequential composition, Abe’s blind signature
may still be provably secure under DDH in the RO model.
The formal analysis follows in the next section.

6. PROOF OF SECURITY

The correctness of the scheme is straightforward, see our

full version [3].

Theorem 3

(Blindness). The proposed scheme satis-
ﬁes blindness under the Decisional Diﬃe-Hellman assump-
tion in the random oracle model.

1, ρ(cid:48)

Proof. We wish to show that, when interacting with a
challenger as described in the deﬁnition of blindness, the
adversary cannot guess which signature is which (i.e. the
adversary should not be able to tell which signature corre-
sponds to each instance and each attribute set). We dis-
tinguish between two types of signatures that a challenger
might output: a signature σ = (m, (ζ, ζ1, ρ, ω, ρ(cid:48)
2, ω(cid:48), µ))
is correct for a particular interaction with the signer if there
exists a value γ such that ζ = zγ and ζ1 = zγ
1 where z1 is
the value corresponding to this interaction with the signer,
and the signature veriﬁes. A signature is fake if no such
γ exists. Note that it is easy for a challenger to generate
both kinds of signatures: a correct signature can simply be
output by correctly following the user’s side of the proto-
col. With control of the random oracle, a fake signature is
computed as follows: ﬁrst, the challenger picks ζ and ζ1 at
random from G, and let ζ2 = ζ/ζ1. Next, it picks random
ρ, ω, ρ(cid:48)
2, ω(cid:48), µ from Zq and sets the random oracle such
1 , hρ(cid:48)
that ω + ω(cid:48) = H(ζ, ζ1, gρyω, gρ(cid:48)
, m), which
ensures that the fake signature veriﬁes.

2 , zµζ ω(cid:48)

1 ζ ω(cid:48)

2 ζ ω(cid:48)

1, ρ(cid:48)

We will prove the theorem by a hybrid argument. Con-
sider the following three games in which the adversarial
signer engages in two signature issuing instances with a chal-
lenger who outputs two signatures:

1. Real: The challenger outputs two correct signatures,
σ1, σ2, in random order by honestly following the pro-
tocol. A correct signature is one that is honestly gener-
ated by interacting with the signer. Thus, in a correct
signature the user blinds z, z1 by the same γ so that
logz(z1) = logζ(ζ1).

2. Hybrid: The challenger’s output consists of a ran-
domly picked correct signature and a fake signature,
in random order.
In a fake signature the challenger

doesn’t use the same random γ to blind z and z1 so
that logz(z1) (cid:54)= logζ(ζ1) except for negligible probabil-
ity. Above, we explained how a fake signature can be
generated, assuming that the challenger controls the
random oracle.

3. Fake: The challenger outputs two fake signatures.

(j)

1

(j)

1 = Ak

1 grnd(j)

Now, what we need to prove is that Real≈Hybrid and Hy-
brid≈Fake. Then, it holds that Real ≈ Fake which proves
the blindness of the ACL scheme since the view of the adver-
sary is indistinguishable no matter if he receives two correct
or two fake signatures.
Case 1: Real≈Hybrid
Suppose that there exists a poly-time adversary A who is
successful in distinguishing between Real and Hybrid with
probability 1/2 + , where the advantage  is not negligible.
We then show that there exists a poly-time algorithm B that
solves the DDH problem with non-negligible advantage.
The reduction B gets as input an instance (g, A, B, D)
where (g, A, B, D) is a DDH instance. B ﬁrst ﬁxes z = A
and then sets h0 = ge0 , and h1, . . . , hn to Ae0 , . . . , Aen for
randomly chosen ei ∈ Zq. B sends the parameters to A. The
adversary A creates his public key y and sends y to B along
−→
−→
with messages m0, m1, commitments C0, C1 and openings
L1) which are two attributes vectors of size n. A and B
(
L0,
engage in two interleaving registration and signature issuing
instances. During the registration phase we have: C(j) =
1 = e0R + e1Lj,1 + ··· + enLj,n) honestly created,
1 , (k(j)
Ak
for j ∈ {0, 1}. Note that the value k(j)
is known to the
reduction B.
Then, during the two signature issuing instances, A com-
where rnd(j) was sent to B. B re-
putes z(j)
sponds with random e(j) and then computes two signatures
σ1, σ2 in the following way:
B ﬂips two random coins: coin, b ∈ {0, 1}. Then, lets
σ2−coin be the correct signature on (m0, ˜Cb) (where ˜C is
denoted as ζ1 in our scheme) for the corresponding instance,
and σcoin+1 be a signature on (m1, ˜C1−b) generated from the
input to B, as follows: set ζ (j) = D and ζ (j)
1 Brnd(j)
;
2, ω(cid:48), µ, and
1 , randomly choose ρ, ω, ρ(cid:48)
let ζ (j)
then deﬁne H so that the signature veriﬁes.
After receiving the signatures, A outputs Real or Hybrid.
If A outputs Real then B outputs “DH” or B outputs “ran-
dom” otherwise.
Let us analyze the success of B in distinguishing Diﬃe-
Hellman tuples from random tuples. If the input (g, A, B, D)
is a DH tuple, then: ζ (j) = D = gab = Ab = zb and
ζ (j)
1 = Dk
)b =
(Ak
1 so, the signature σcoin+1 is distributed
identically to a correct signature, and this is precisely the
Real game. Similarly, if the input is not a DH tuple then
it is the Hybrid game. Therefore, B will be correct exactly
when A is and will distinguish a DH tuple with probability
1/2 + , which contradicts to the DDH assumption.
Case 2: Hybrid≈Fake
Similarly, we build a reduction B which given an adversary
A, who distinguishes between Hybrid and Fake with proba-
bility 1/2 + , solves the DDH problem.
Working in a similar way we did before, B will now create
a fake signature and one using the input tuple. If A outputs

1 Brnd(j)
)b = zb

1 = Dk
1, ρ(cid:48)

2 = ζ (j)/ζ (j)

1 gbrnd(j)

1 grnd(j)

= (gak

(j)

1 grnd(j)

(j)

(j)

(j)

= gabk

(j)

1094Hybrid then B will output “DH” or “not DH” otherwise. If
the input is a DH instance then the output will correspond
to the Hybrid game and to the Fake otherwise. So, B will be
successful whenever A is and will break the DDH assumption
with non-negligible advantage  which is a contradiction.
Finally, since Real≈Hybrid and Hybrid≈Fake it follows that
Real≈Fake.

Theorem 4

(One-More Unforgeability). The sig-
nature issuing protocol is ((cid:96), (cid:96)+1)−unforgeable for polynomi-
ally bounded (cid:96) if the discrete logarithm problem is intractable
and H is a random oracle.

Outline of the proof We ﬁrst discuss the witness indistin-
guishability of the protocol (Lemma 1), which allows us to
to simulate the Signer with either y-side or z-side witness(es)
to extract the witness of the other side. Then, in Lemma 2
we prove that in order for the User to get a valid signature,
he has to blind (z, z1) into (ζ, ζ1) only in such a way that
ζ1. In Lemma 3 we prove that is infeasible to
logz ζ = logz1
create a valid signature without engaging in the issuing pro-
tocol with the legitimate Signer. From Lemmas 2 and 3 we
see that if a User engages in the signature issuing protocol (cid:96)
times and outputs (cid:96) + 1 signatures, then, there exist at least
two valid signatures linked to a particular run of the issuing
protocol. Finally, it needs to be proven that a forger who
manages to produce two signatures from a single protocol
run can be used to solve the discrete logarithm problem.

We will denote the i-th execution of the issuing protocol by
runi. Recall that a transcript of runi of the issuing protocol
contains values (z1,i, z2,i); by the z-side witness of runi we
denote (w1,i, w2,i) such that z1,i = gw1,i and z2,i = hw2,i .

Consider an alternative signing algorithm that, instead of
using the y-side witness in the issuing protocol, uses the z-
side witness. Let params = (q, G, h, z,{hj}) be the public
parameters, and y be the public key of the Signer. Sup-
pose that the registration and the preparation phases of the
signing protocol for runi resulted in the signer and the user
setting up the values z1,i = gw1,i , z2,i = hw2,i . The alter-
native signing algorithm takes as input the public parame-
ters params, the public key y, the preparation phase output
(z1, z2) and the values (w1,i, w2,i) instead of the secret key
x, and works as follows:

∈U Zq.

1,i := gu1,i and a(cid:48)
1,i, a(cid:48)

1. Generate ci, ri ∈U Zq and set ai := gri yci .
2. Compute a(cid:48)
3. Sends ai, a(cid:48)
2,i to the user.
4. Given ei from user, compute c(cid:48)
5. Send ri, ci, r(cid:48)

iw1,i mod q and r(cid:48)

u1,i − c(cid:48)

i to the user.

1,i, r(cid:48)

2,i, c(cid:48)

i := ei−ci mod q, r(cid:48)
iw2,i mod q.

2,i := u2,i − c(cid:48)

2,i := hu2,i with u1,i, u2,i

1,i :=

Deﬁnition 10. The signing protocol that was described

above is called the z-side signer.

Lemma 1. The signer’s output is perfectly indistinguish-

able from the output of a z-side signer.

Proof. Follows from the result of Cramer [18].

extraction techniques in order to learn the representations
of C; if the reduction is, in addition, given the discrete log-
arithms of all the public parameters to the base g, it will be
able to compute the z-side witness, and so, inside a reduc-
tion, the z-side signer can be invoked.

1, ρ(cid:48)

Lemma 2. (Restrictive Blinding) Let A be a User that
engages in the signature issuing protocol (cid:96) times, and outputs
a valid signature σ = (m, (ζ, ζ1, ρ, ω, ρ(cid:48)
2, ω(cid:48), µ)). Let runi
denote the i-th execution of the protocol and z1,i denote z1
used by the signer S in runi. For polynomially bounded (cid:96)
and for all polynomial-time A, the probability that logz ζ (cid:54)=
ζ1 holds for all i, is negligible if the discrete logarithm
logz1,i
problem is intractable and H is a random oracle.

Proof. Let A have at most qh accesses to H and ask at
most (cid:96) signatures to B. Let σ = (m, (ζ, ζ1, ρ, ω, ρ(cid:48)
2, ω(cid:48), µ))
be a signature that A outputs and satisﬁes logz ζ (cid:54)= logz1,i
ζ1
for all i with probability 0 which is not negligible in n (qh
and (cid:96) are bounded by a polynomial in the security parameter
n). We randomly ﬁx an index I ∈ {1, . . . , (cid:96)} and regard A as
successful only if the RO query for the resulting signature
was during the I-th run.
(If the resulting signature does
not correspond to any query, then A is successful only with
negligible probability due to the randomness of H.) Let
(G; q; g; Y) be an instance of the DL problem.
Reduction Algorithm: B ﬁrst sets (p, q, g) := (p, q, g).
Then, it ﬂips a coin χ ∈U {0, 1} to either select y := Y
(case χ = 0), or h := Y (case χ = 1) and also guesses a
random index I ∈ {1, . . . , (cid:96)}.
Case y = Y: (extracting y-side witness)

1, ρ(cid:48)

and deﬁnes K = k0R +(cid:80)n

1. Key Generation: B selects k, k(cid:48),{kj} ∈U Zq, for 0 ≤
j ≤ n, and sets h := gk and hj := gkj , z = gk(cid:48)
.
As a result of setting the parameters this way, B will
always be able to compute z-side witnesses, as long
as B can successfully extract the user’s attributes and
randomness in the registration phase.
2. Registration: B extracts values (L1, . . . , Ln; R) using a
knowledge extractor for proof π1 (since we only worry
about sequential composition the extractor may rewind)
ij1 kjLj (so that C = gK ).
3. Preparation: B selects w1,i ∈ Zq and sets rnd = w1,i −
K. Then, computes w2,i = (k(cid:48) − w1,i)/k mod q (so we
have z1,i = gw1,i , z2,i = hw2,i ). B sends rnd to A.
4. Validation: B runs A using the z-side signer described
above. At the end of each runi the z-side signer sends:
i to A. B simulates H by returning
ri, ci, r(cid:48)
ε ∈U Zq to the random oracle queries issued by A. A
outputs a signature σ = (ζ, ζ1, ρ, ω, ρ(cid:48)
2, ω(cid:48), µ), that
corresponds to some ε.

1,i, r(cid:48)

2,i, c(cid:48)

1, ρ(cid:48)

5. If the RO query for the resulting signature σ happened
in runI then move to the next step, otherwise the re-
duction fails.
6. Rewinding: Reset and restart A with the same setting.
For runI and after, B simulates H with ˜ε ∈U Zq. A
outputs a signature, say ˜σ = (ζ, ζ1, ˜ρ, ˜ω, ˜ρ(cid:48)
2, ˜ω(cid:48), ˜µ).
If ω (cid:54)= ˜ω, B outputs x := (ρ − ˜ρ)/(˜ω − ω) mod q. The
simulation fails, otherwise.

1, ˜ρ(cid:48)

Note that, in order to run the z-side signer, it is necessary
to somehow get the corresponding witness. We will see later
that, with black-box access to an adversarial user in the
registration phase, a reduction can use standard Σ-protocol

Case h = Y: (extracting z-side witness)

1. Key generation: B selects x,{kj} ∈U Zq and sets y :=
gx and hj := gkj . It also selects w1, w2 ∈U Zq and sets
z := gw1 hw2 .

10952. Signature Issuing: B runs A simulating the signer as

follows.
(a) For i (cid:54)= I, B follows the protocol with y-side wit-

ness, x.

(b) For i = I, B engages in the issuing protocol using

the z-side witness (w1, w2) as follows.

(cid:80)n

i=1 kiLi (so that C = gK ).

i. Registration: Extract values (L1, . . . , Ln; R)
using a ZK extractor and deﬁne K = k0R +
ii. Preparation: Set rnd = w1 − K (so we have
iii. Validation: B runs A using the z-side signer
2I , c(cid:48)
I )

z1,I = gw1 , z2,I = hw2 ). B sends rnd to A.
and at the end of runI sends (rI , cI , r(cid:48)
1I , r(cid:48)
to A.

1, ρ(cid:48)

3. A outputs a signature, say σ = (ζ, ζ1, ρ, ω, ρ(cid:48)

B simulates H by returning ε ∈U Zq to the RO queries
made by A.
2, ω(cid:48), µ),
that corresponds to some ε. If the RO query for the
forged signature didn’t happen in runI then fail, else
move to the next step.
4. Rewinding: Rewind and restart A∗ with the same set-
ting. For runI and forward, B simulates H by return-
ing ˜ε ∈U Zq.
1, ˜ρ(cid:48)
2, ˜ω(cid:48), ˜µ),
that corresponds to some ˜ε. If ω(cid:48) (cid:54)= ˜ω(cid:48), B computes
2)/(µ −
2 − ˜ρ(cid:48)
1)/(µ − ˜µ) mod q, w(cid:48)
w(cid:48)
1 = (ρ(cid:48)
2−w2) mod q
˜µ) mod q, and outputs w = (w1−w(cid:48)
(where w = logg h). Simulation fails otherwise.

5. A outputs a signature, say ˜σ = (ζ, ζ1, ˜ρ, ˜ω, ˜ρ(cid:48)
2 = (ρ(cid:48)
1)/(w(cid:48)

1 − ˜ρ(cid:48)

Evaluation of success probability The reduction is suc-
cessful when it gets ω (cid:54)= ˜ω for χ = 0 or when it gets ω(cid:48) (cid:54)= ˜ω(cid:48)
for χ = 1. What we need to argue about is that, indepen-
dently of the choice of χ, the above will happen with non
negligible probability. Note that we construct the reduction
by giving diﬀerent responses after the Ith run (for a ran-
domly chosen I ∈ {1, . . . , (cid:96)}) when rewinding and we let the
reduction fail if the forgery didn’t happen in runI .
Let us now ﬁx the adversary’s view and his RO tape. Once
everything is ﬁxed, we notice that A’s forgery, is uniquely
determined by c(cid:48) and ε. We now consider two cases: (1)
ω(cid:48) = ω with non negligible probability even if ε and c(cid:48) change
In this case ω(cid:48) = ˜ω(cid:48) and thus ω (cid:54)= ˜ω:
(after rewinding).
ω + ω(cid:48) = ε (cid:54)= ˜ε = ˜ω + ˜ω(cid:48), so the y-side witness can be
extracted. (2) ω(cid:48) (cid:54)= ω with non negligible probability if ε and
c(cid:48) change. So, when we run the adversary again with access
to z-side witness and with diﬀerent ˜ε we get two signatures
from him where ω = ˜ω and thus ω(cid:48) (cid:54)= ˜ω(cid:48) and thus we can
extract the z-side witness. Since we fail if the forgery didn’t
happen in runI we do not need to consider what happens
when we run A with y-side witness for χ = 1 and i (cid:54)= I.
What is left to show is that for χ = 1, the z-side witness,
(w(cid:48)
1, w(cid:48)
2), extracted is not the one that B already knows. Re-
member that the reduction in the beginning, selects w1, w2
∈U Zq and sets z := gw1 hw2 and in runI sets rnd so that
z1,I = gw1 , z2,I = hw2 . The signature that A produces
contains proofs that ζ = zγ, ζ1 = gw(cid:48)
2 , so
w(cid:48)
1 = γw1 and w(cid:48)
2 by
rewinding. For the forgery that A outputs it holds logz ζ (cid:54)=
logz1,I
ζ1 (by deﬁnition of Lemma 2) which guarantees that
we will obtain two diﬀerent representations of z.

2 = γw2 and we can extract those w(cid:48)

1 and ζ2 = hw(cid:48)
1, w(cid:48)

Lemma 3. Any poly-time adversary A outputs a valid sig-
nature without interacting with the Signer only with negligi-
ble probability if the discrete logarithm problem is intractable
and H is a random oracle.

Proof. (sketch) In order to prove this we are going to
use the oracle replay attack suggested by Pointcheval and
Stern to prove unforgeability of blind signatures [40]. Similar
to the proof of Lemma 2 we randomly ﬁx an index I ∈
{1, . . . , (cid:96)} and regard A as successful only if the RO query for
the resulting signature was during the I-th run. Accordingly,
it is equivalent to assuming an adversary, we will call it A∗,
that asks H only once and succeeds with probability 1 ≥
0/qh. Given this modiﬁed A∗ we construct the reduction B
that solves the discrete logarithm problem by simulating the
interaction. Given Y ∈ G, we construct a reduction B that
ﬁnds logg Y in Zq. During key generation, B ﬁrst selects
ω, ξ,{ki} randomly and sets y = Y, h = gw, hi = gki z =
Ygξ. (B does not need to simulate the signer, so it can put
Y in both y and z.) Then, B invokes A∗ twice with the
same initial settings and diﬀerent ε and ˜ε as answers of H.
The resulting signatures are σ = (ζ, ζ1, ρ, ω, ρ(cid:48)
2, ω(cid:48), µ) and
2, ˜ω(cid:48), ˜µ). Since ω + ω(cid:48) = ε (cid:54)= ˜ε = ˜ω + ˜ω(cid:48),
˜σ = (ζ, ζ1, ˜ρ, ˜ω, ˜ρ(cid:48)
at least one of ω (cid:54)= ˜ω or ω(cid:48) (cid:54)= ˜ω(cid:48) happens.
In the case that ω (cid:54)= ˜ω, B computes logg Y = (ρ− ˜ρ)/(˜ω−
ω) mod q. For the case ω(cid:48) (cid:54)= ˜ω(cid:48), B computes γ = logz ζ =
1)/(ω(cid:48) −
(µ − ˜µ)/(ω(cid:48) − ˜ω(cid:48)) mod q, w1 = logg ζ1 = (ρ(cid:48)
2)/(ω(cid:48) − ˜ω(cid:48)) mod q, and
˜ω(cid:48)) mod q, w2 = logg ζ2 = (ρ(cid:48)
logg Y = logg z − ξ = (w1 + w2/w)/γ − ξ mod q.

1 − ˜ρ(cid:48)

2 − ˜ρ(cid:48)

1, ρ(cid:48)

1, ˜ρ(cid:48)

Proof. (Theorem 4). Suppose that there exists adver-
sary A that outputs (cid:96) + 1 valid signatures with probability
 not negligible after interacting with the Signer at most (cid:96)
times. The case (cid:96) = 0 has been ruled out by Lemma 3. We
consider (cid:96) ≥ 1.

By Lemmas 2 and 3, among the (cid:96)+1 signatures, there exist
at least two signature-message pairs which contain (ζ, ζ1)
and (¯ζ, ¯ζ1) such that logζ ζ1 = log ¯ζ
¯ζ1 = logz z1I holds for
z1I used in runI for some I in {1, . . . , (cid:96)}. Now, there exist
two queries to H that correspond to those signatures. In a
similar way as in the proof of Lemma 2, we guess the indices
of these queries and regard A as being successful only when
the guess is correct. We consider an equivalent adversary
A∗ that asks H only twice and succeeds with probability

(cid:1) in producing two signatures in the expected

∗ = /(cid:0)qh

We construct a reduction B that, given (p, q, g, Y), solves

relation.
logg Y in Zq by using A∗.
Reduction Algorithm: B sets (p, q, g) := (p, q, g).
It
then ﬂips a coin, χ ∈U {0, 1}, to select either y := Y (case
χ = 0), or y := gx with randomly chosen x (case χ = 1).

2

1. Setup: If χ = 0, set up and use the z-side signer. Set
h, h0, . . . , hn such that their discrete logarithm base
g is known. Else, set up the y-side signer by letting
y = gx for a randomly chosen x; set up h, h0, . . . , hn
such that their discrete logarithm base Y is known.

2. Registration: If χ = 0, extract (R, L0, . . . , Ln). Else

follow the protocol.

3. Preparation: Follow the protocol.
4. Validation: If χ = 0, use the z-side signer, else follow

the protocol.

10961 , ρ(cid:48)(1)
1 , ρ(cid:48)(2)

1 , ρ(1), ω(1), ρ(cid:48)(1)
1 , ρ(2), ω(2), ρ(cid:48)(2)

5. Responding to the RO queries: B simulates H by re-
turning random values, say ε1 and ε2, to the two RO
queries.
6. Rewinding: When A∗ outputs two signatures (σ(1) =
2 , ω(cid:48)(1), µ(1))) and (σ(2) =
(ζ (1), ζ (1)
2 , ω(cid:48)(2), µ(2))) correspond-
(ζ (2), ζ (2)
ing to ε1 and ε2, B resets the adversary and this time
responds to the two RO queries with ˜ε1 and ˜ε2.
7. Interacting with A∗ after rewinding is the same as be-
8. Extracting: When A∗ again outputs two signatures
(˜σ(1) = (ζ (1), ζ (1)
, ˜µ(1)) and
(˜σ(2) = (ζ (2), ζ (2)
, ˜µ(2)) cor-
responding to ˜ε1 and ˜ε2, do: if χ = 0 and ω(1) (cid:54)= ˜ω(1)
or ω(2) (cid:54)= ˜ω(2), then extract the y-side witness as de-
scribed in the proof of Lemma 2; else if χ = 1 and
ω(cid:48)(1) (cid:54)= ˜ω(cid:48)(1)
, then extract the z-side
witness as described in Lemma 2.

1 , ˜ρ(1), ˜ω(1), ˜ρ(cid:48)(1)
1 , ˜ρ(2), ˜ω(2), ˜ρ(cid:48)(2)

fore, according to the value of χ.

or ω(cid:48)(2) (cid:54)= ˜ω(cid:48)(2)

2 , ˜ω(cid:48)(1)
2 , ˜ω(cid:48)(2)

1 , ˜ρ(cid:48)(1)
1 , ˜ρ(cid:48)(2)

Evaluation of success probability. Here we need to show
that B will extract the witness that it doesn’t already know
with non-negligible probability (otherwise, χ is revealed).
Consider all the q2 possible (ε1, ε2) pairs that can be given
as responses to A∗’s two RO queries. Let succ be the set
of pairs (ε1, ε2) for which A∗ succeeds: succ = {(ε1, ε2)|
A breaks the seq. one-more unforgeability}. What we want
to show is that for a random pair (ε1, ε2) ∈ succ there exists
( ˜ε1, ˜ε2) ∈ succ such that A∗ produces the same e with non-
negligible probability in the run where the ﬁrst RO query
happened. Notice that the transcript (i.e.
the messages
exchanged between the Signer and A∗) of these two runs
has to be the same. We call such a pair ( ˜ε1, ˜ε2) good for
(ε1, ε2).
Consider A∗ is run twice: once with (ε1, ε2) and once
with ( ˜ε1, ˜ε2), both times producing two message-signature
pairs corresponding to z1I . Taken together, (ε1, ε2), ( ˜ε1, ˜ε2),
the transcript of the runs and the four message-signature
pairs allow the reduction to compute either a y side or a
z side witness. However, we need to argue that, with non-
negligible probability, this will be a witness the reduction
doesn’t already know. Since the transcripts are identical,
the joint distribution of the two views (A∗’s view in the ﬁrst
run and its view, after the rewinding, in the second run) is
independent of χ.

1, ε∗

First, note that there are only q possible e’s but q2 pos-
sible ( ˜ε1, ˜ε2), and so there can only be a negligible fraction
of (ε1, ε2) for which no good ( ˜ε1, ˜ε2) exists. Suppose that
( ˜ε1, ˜ε2) is good for (ε1, ε2) but (ε∗
2) is not; moreover, the
reduction that gives (ε1, ε2) before rewinding, and (ε∗
1, ε∗
2)
after rewinding, can only compute the witness it already
knows (i.e.
if χ = 0, it can compute the z-side witness,
and for χ = 1 the y-side). Then for the same choice of χ,
the reduction would be computing the witness it does not
already know if, instead, it used ( ˜ε1, ˜ε2) and (ε∗
2). For
example, if χ = 0 we would have ω (cid:54)= ˜ω and ω = ˜ω∗ re-
spectively, which implies that ˜ω (cid:54)= ˜ω∗ and thus by choosing
(ε1, ε2) and (ε∗
2) the y side witness could be extracted.
Since it is just as likely to pick (ε1, ε2) or ( ˜ε1, ˜ε2) for the
values before rewinding, it is just as likely to succeed as to
fail, independently of χ (this analysis was ﬁrst given by Abe
and Okamoto [2]).
Finally, the only thing left to prove is that an adversary
cannot open the sets of commitments {C (i)} and {ζ (i), ζ (i)
1 }

1, ε∗

1, ε∗

1

such that ζ (i)

1 = (z(i(cid:48))

to two diﬀerent multisets. Note that ζ (i) uniquely deter-
mines γ(i), and by Lemma 2, it follows that for every i, there
exists some z(i(cid:48))
)γ(i)
. Thus, an alter-
native opening of the commitment {ζ (i), ζ (i)
1 } gives rise to an
alternative representation of z(i(cid:48))
in bases h, h1, . . . , hn, g. In
turn, by standard techniques, this breaks the discrete loga-
rithm assumption. (The reduction will just honestly emulate
the signer, and embed the DL instance into the parameters
h, h1, . . . , hn, g.)

1

1

2

(cid:1) ≈ /q2

bility /(cid:0)qh

Setting parameters. Note that our reduction is not tight:
an adversary A whose success probability is  gives rise to
the reduction B with the same runtime but success proba-
h. This, in other words means that if A
takes time t to break unforgeability with probability , then
our reduction, B, in order to break the discrete logarithm
assumption with the same success probability would need
h. So, if A breaks unforgeability faster than in time
time t· q2
2k, then B breaks DL in time faster than 2k·q2
h = 2k+2 log qh .
Thus, we need to set the parameters to be suﬃciently large
so that is reasonable to assume that the reduction would
take time 2k+2 log qh to break DL directly.

As suggested by NIST [32] in order to tolerate an adver-
sary whose computational power is 2k, one needs an elliptic
curve group of size 22k which for our reduction should be
22(k+2 log qh). Now, let’s be very conservative and assume

that qh = 280, thus the factor (cid:0)qh

(cid:1) we lose is of 160-bits.

Thus, if we want to achieve 128-bit security we would need
an elliptic curve group where the bit size of an element is
2(128 + 2 · 80) = 576-bits. Note that the equivalent security
level for RSA requires 3072-bit keys.

2

7. ACKNOWLEDGMENTS

We thank the anonymous reviewers for their helpful com-
ments and suggestions. We also thank our collaborators
at the Pay-As-You-Go project for discussions on the use of
anonymous credential systems in lightweight devices and es-
pecially Gesine Hinterw¨alder. This work was supported by
NSF grants 0964379 and 1012060.

8. REFERENCES
[1] M. Abe. A secure three-move blind signature scheme

for polynomially many signatures. In
EUROCRYPT’01, pages 136–151, 2001.

[2] M. Abe and T. Okamoto. Provably secure partially

blind signatures. In CRYPTO’00, pages 271–286.
Springer-Verlag, 2000.

[3] F. Baldimtsi and A. Lysyanskaya. Anonymous

credentials light. Cryptology ePrint Archive, Report
2012/298, 2012.

[4] F. Baldimtsi and A. Lysyanskaya. On the security of

one-witness blind signature schemes. Cryptology
ePrint Archive, Report 2012/197, 2012.

[5] M. Belenkiy, M. Chase, M. Kohlweiss, and

A. Lysyanskaya. Compact e-cash and simulatable vrfs
revisited. In Pairing ’09, pages 114–131, 2009.

[6] P. Bichsel, J. Camenisch, T. Groß, and V. Shoup.

Anonymous credentials on a standard java card. CCS
’09, pages 600–610. ACM, 2009.

[7] A. Boldyreva. Threshold signatures, multisignatures

and blind signatures based on the

1097gap-diﬃe-hellman-group signature scheme. PKC ’03,
pages 31–46, London, UK, UK, 2003. Springer-Verlag.

[8] S. Brands. Untraceable oﬀ-line cash in wallets with

observers. In CRYPTO’93, pages 302–318, 1993.

[9] S. A. Brands. Rethinking public key infrastructures

and digital certiﬁcates: Building in privacy. MIT
Press, Cambridge-London, August 2000.

[10] J. Camenisch and T. Groß. Eﬃcient attributes for
anonymous credentials. In Proceedings of the 15th
ACM conference on Computer and communications
security, CCS ’08, 2008.

[11] J. Camenisch, S. Hohenberger, and A. Lysyanskaya.
Compact e-cash. In EUROCRYPT ’05, volume 3494
of LNCS, pages 302–321. Springer-Verlag, 2005.
[12] J. Camenisch, M. Koprowski, and B. Warinschi.

Eﬃcient blind signatures without random oracles.
SCN’04, pages 134–148, 2005.

microprocessor minimizing both transmission and
memory. In EUROCRYPT ’88, pages 123–128, 1988.
[27] N. Gura, A. Patel, A. Wander, H. Eberle, and S. C.
Shantz. Comparing elliptic curve cryptography and
rsa on 8-bit cpus. In CHES’04, pages 119–132, 2004.

[28] G. Hinterw¨alder, C. T. Zenger, F. Baldimtsi,

A. Lysyanskaya, C. Paar, and W. P. Burleson.
Eﬃcient e-cash in practice: NFC-based payments for
public transportation systems. In Privacy Enhancing
Technologies - PETS’13, pages 40–59, 2013.

[29] A. Juels, M. Luby, and R. Ostrovsky. Security of blind

digital signatures (extended abstract). In
CRYPTO’97, pages 150–164. Springer-Verlag, 1997.

[30] M. Langheinrich. Privacy by design - principles of

privacy - aware ubiquitous systems. In Ubicomp 2001:
Ubiquitous Computing, volume 2201, pages 273–291.
Springer Berlin, Heidelberg, 2001.

[13] J. Camenisch and A. Lysyanskaya. An eﬃcient system

[31] A. J. Menezes, P. C. V. Oorschot, and S. A. Vanstone.

for non-transferable anonymous credentials with
optional anonymity revocation. EUROCRYPT ’01,
pages 93–118, London, UK, 2001. Springer-Verlag.

[14] J. Camenisch and A. Lysyanskaya. Signature schemes

and anonymous credentials from bilinear maps. In
CRYPTO’04, LNCS 3152, pages 56 – 72, 2004.

[15] J. Camenisch and M. Michels. Proving in

zero-knowledge that a number is the product of two
safe primes. EUROCRYPT’99. Springer-Verlag, 1999.

[16] J. Camenisch, F.-H. Simone, and K. Rannenberg.

Privacy and identity management for life. In ISBN
978-3-642-20316-9. Springer, 2012.

[17] D. Chaum. Blind signatures for untraceable payment.

In Crypto’82, pages 199–203, 1982.

[18] R. Cramer, I. Damg˚ard, and B. Schoenmakers. Proofs

of partial knowledge and simpliﬁed design of witness
hiding protocols. In CRYPTO ’94, pages 174–187.
Springer-Verlag, 1994.

Handbook of applied cryptography, 1997.

[32] NIST. The case for elliptic curve cryptography, 2009.
http://www.nsa.gov/business/programs/elliptic_
curve.shtml.

[33] M. Ohkubo and M. Abe. Security of three-move blind

signature schemes reconsidered. In SCIS’03,
Symposium on Cryptography and Information
Security, 2003.

[34] T. Okamoto. Eﬃcient blind and partially blind
signatures without random oracles. In TCC’06,
volume 3876 of Lecture Notes in Computer Science,
pages 80–99. Springer, 2006.

[35] C. Paquin. U-prove cryptographic speciﬁcation v1.1.

In Microsoft Technical Report,
http://connect.microsoft.com/site1188, February 2011.

[36] E. Parliament and C. of the European Union.

Regulation (ec) 45/2001. In Oﬃcial Journal of the
European Union, 2001.

[19] I. Damg˚ard. Commitment schemes and zero-knowledge

[37] E. Parliament and C. of the European Union.

protocols. In Lectures on Data Security, Modern
Cryptology in Theory and Practice, Summer School,
Aarhus, Denmark, July 1998. Springer-Verlag, 1999.

[20] I. Damg˚ard. On σ- protocols. In Course Notes,

http: // www. daimi. au. dk/ ~ivan/ Sigma. ps , 2002.

[21] A. Fiat and A. Shamir. How to prove yourself:

Practical solutions to identiﬁcation and signature
problems. In CRYPTO ’86, pages 186–194.
Springer-Verlag, 1986.

[22] S. Garg, V. Rao, A. Sahai, D. Schr¨oder, and

D. Unruh. Round optimal blind signatures. In
CRYPTO’11, pages 630–648, 2011.

[23] O. Goldreich. Foundations of Cryptography, vol. 1:

Basic Tools. Cambridge University Press, 2001.

[24] S. Goldwasser, S. Micali, and C. Rackoﬀ. The

knowledge complexity of interactive proof systems.
SIAM J. Comput., 18:186–208, February 1989.

[25] J. Guajardo, B. Mennink, and B. Schoenmakers.

Anonymous credential schemes with encrypted
attributes. In Cryptology and Network Security, pages
314–333. Springer, 2010.

[26] L. C. Guillou and J.-J. Quisquater. A practical

zero-knowledge protocol ﬁtted to security

Directive 2009/136/ec. In Oﬃcial Journal of the
European Union, 2009.

[38] T. P. Pedersen. Non-interactive and

information-theoretic secure veriﬁable secret sharing.
CRYPTO ’91. Springer-Verlag.

[39] D. Pointcheval and J. Stern. Security arguments for

digital signatures and blind signatures. In Journal Of
Cryptology, volume 13, pages 361–396, 2000.

[40] D. Pointcheval and J. Stern. Provably secure blind

signature schemes. In Asiacrypt ’96, LNCS 1163,
pages 252–265. Springer-Verlag, Feb 2011.

[41] H. A. Schmidt. National strategy for trusted identities

in cyberspace. In Cyberwar Resources Guide, Item
163, http: // www. projectcyw-d. org/ resources/
items/ show/ 163 , 2010.

[42] C. P. Schnorr. Eﬃcient identiﬁcation and signatures
for smart cards. CRYPTO ’89, pages 239–252, 1989.

[43] I. S. Team. Speciﬁcation of the identity mixer

cryptographic library, version 2.3.0. In IBM Research
Report, 2010.

[44] G. J. R. B. Zhang, H. and K. Fu. Moo: A batteryless

computational rﬁd and sensing platform. In Tech.
Rep. UM-CS-2011-020, UMass Amherst Department
of Computer Science, 2011.

1098