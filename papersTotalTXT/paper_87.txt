A Non-Interactive Range Proof with Constant Communication(cid:63)

Raﬁk Chaabouni1,2, Helger Lipmaa1, and Bingsheng Zhang1

1 Institute of Computer Science, University of Tartu, Estonia
2 Security and Cryptography Laboratory, EPFL, Switzerland

Abstract. In a range proof, the prover convinces the veriﬁer in zero-knowledge that he has en-
crypted or committed to a value a ∈ [0, H] where H is a public constant. Most of the previous
non-interactive range proofs have been proven secure in the random oracle model, that is, heuristi-
cally. We show that one of the few previous non-interactive range proofs in the common reference
string (CRS) model, proposed by Yuen et al. in COCOON 2009, is insecure. We then construct a
secure non-interactive range proof that works in the CRS model. The new range proof can have
(by diﬀerent instantiations of the parameters) either very short communication (14 080 bits) and
veriﬁer’s computation (81 pairings), short combined CRS length and communication (log1/2+o(1) H
group elements), or very eﬃcient prover’s computation (Θ(log H) exponentiations).
Keywords. NIZK, pairings, progression-free sets, range proof.

1 Introduction

In a range proof, the prover convinces the veriﬁer in zero-knowledge that he has encrypted or committed
to a value a ∈ [0, H], where H is a public constant. Range proofs are needed in a wide variety of crypto-
graphic protocols, like e-voting [CGS97,DJ01] (to show that a ballot corresponds to a valid candidate),
e-auctions [LAN02], anonymous credentials, e-cash [CHL05], or any other protocol that needs for its
correctness that the inputs are from a valid range. Given the need for range proofs in a large variety of
protocols, it is not surprising that there is a large amount of research on this topic.

Most of the existing eﬃcient range proofs fall

that a = (cid:80)n
that a =(cid:80)n
Clearly, a ∈ [0, 2d − 1] iﬀ a =(cid:80)d

in one of the next two categories. The ﬁrst
four
category uses a classical result of Lagrange that every non-negative integer is a sum of
squares [Lip03,Gro04,YHM+09]. However, in this case the underlying group has to be of unknown order
which seriously limits the available cryptographic techniques. In particular, all known secure Lagrange’s
theorem based range proofs are based on operations in Z∗
n for a hard-to-factor n. Since to achieve 128-
bit security level, n must be at least 3072 bits long, arithmetic in Z∗
n is relatively slow. One also has
to compute the four squares of the Lagrange’s theorem which is ineﬃcient by itself. Furthermore, this
means that it is not known how to instantiate such schemes with bilinear groups. (This is exempliﬁed by
the fact that we break the range proof of [YHM+09] where the Lagrange theorem is used in the bilinear
setting with known group order.)
Due to such considerations, one usually considers the second approach. There, one uses the fact
that a ∈ [0, H], if and only if for some well chosen coeﬃcients Gi, there exist bi ∈ [0, u − 1] such
i=1 Gibi. Here, u (cid:28) H and n is also small. One then proves separately for every bi that
bi ∈ [0, u − 1], and uses additively homomorphic properties of the used commitment scheme to verify
i=1 2i−1bi and bi ∈ {0, 1}. Then one can prove that a ∈ [0, H] for
arbitrary H by showing that both a and H − a belong to [0, 2(cid:98)log2 H(cid:99)+1 − 1]. Showing that bi ∈ {0, 1}
is straightforward, e.g., by using an AND of two Σ-protocols [CDS94]. This means that one has to
execute two basic range proofs for [0, 2d − 1]. Lipmaa, Asokan and Niemi showed in [LAN02] that by
choosing the coeﬃcients Gi cleverly, one obtains a simpler result that a ∈ [0, H], for any H > 1, iﬀ
In [CCs08], the authors considered the general case u ≥ 2, following the fact that a ∈ [0, ud − 1] iﬀ
i=1 uibi and bi ∈ [0, u− 1]. They show that bi ∈ [0, u− 1] by letting the veriﬁer to sign every integer
in [0, u − 1], and then letting the prover to prove that he knows the signature on committed bi. One can
show that a ∈ [0, H] for general H by using again an AND of two Σ-protocols. Nontrivially generaliz-
ing [LAN02] (by using methods from additive combinatorics), Chaabouni, Lipmaa and shelat [CLs10]

i=1 Gibi. The goal is to minimize the communication of that type of range proofs.

a =(cid:80)(cid:98)log2 H(cid:99)+1
a =(cid:80)d

i=1

Gibi and bi ∈ {0, 1}.

(cid:63) Full preproceedings version, January 27, 2012. Final full version might diﬀer.

a =(cid:80)(cid:100)logu((u−1)·H+1)(cid:101)

showed that there exist (eﬃciently computable) coeﬃcients Gi such that (u − 1)a ∈ (u − 1) · [0, H] iﬀ
Gibi for some bi ∈ [0, u− 1]. The CLS range proof has communication complexity
of Θ(logu H +u) group elements, which obtains minimal value Θ(log H/ log log H) if u ≈ log H/ log log H.
(See [Gro11] for recent related work.)

i=1

Usually, it is desired that the range proof is non-interactive. For example, in the e-voting scenario,
range proof is a part of the vote validity proof that is veriﬁed by various parties without any active
participation of the voter. Most of the previous non-interactive range proofs ﬁrst construct a Σ-protocol
which is then made non-interactive in the random oracle model by using the Fiat-Shamir heuristic. While
the random oracle model allows to construct eﬃcient protocols, it is also known that there exist protocols
that are secure in the random oracle models and insecure in the plain model.

Motivated by this,

[CHS04,YHM+09,RKP09] have proposed non-interactive range proofs with-
out random oracles. The range proof from [CHS04] is of mainly theoretical value. The range proof
from [YHM+09] uses Lagrange’s theorem, but we will demonstrate an attack on it. The range proof
from [RKP09] combines the range proof of [CCs08] with the Groth-Sahai non-interactive zero-knowledge
(NIZK) proofs [GS08] and P-signatures. The [RKP09] range proof is not claimed to be zero-knowledge
(only NIWI, that is, non-interactive witness-indistinguishable).

We ﬁrst show that the protocol from [YHM+09] is insecure. The main idea of the attack comes
from using Pedersen commitments in a group of known order. In this case, using Lagrange’s theorem to
prove that a non-negative number is the sum of four squares fails. We can only conclude that the sum
of four squares is computed modulo the group order. Hence an attacker can prove that any number is
“non-negative” and completely break the protocol in [YHM+09]. See Sect. 4 for more information.

that (u − 1)a ∈ (u − 1) · [0, H] iﬀ a =(cid:80)n
method from [LAN02,CLs10]) that bi =(cid:80)nv

We then construct a new NIZK range proof (for an encrypted a — if one needs a to be committed, one
can use the same cryptosystem as a perfectly binding commitment) that works in the common-reference
string model. We do this by using recent NIZK arguments by Groth and Lipmaa [Gro10,Lip12]. We also
use the additive combinatorics results from [CLs10], that is, we base a range proof a ∈ [0, H] on the fact
i=1 Gibi and bi ∈ [0, u − 1], where Gi are as deﬁned in [CLs10].
However, diﬀerently from [CLs10], we prove that bi ∈ [0, u − 1] by proving (by a recursive use of the
ji ∈ [0, 1]. Here, nv := (cid:98)log2(u− 1)(cid:99). By using
jb(cid:48)
j=0 G(cid:48)
ji with b(cid:48)
the commitment scheme of [Gro10,Lip12] that enables to succinctly commit to a vector (b1, . . . , bn), and
the Hadamard product argument of [Gro10,Lip12], we can do all nv + 1 small range proofs in parallel.
In addition, in Sect. 5 we construct a new non-interactive argument that a knowledge-commited value
is equal to a BBS-encrypted [BBS04] value. (Due to the use of knowledge assumptions, this proof is
computationally more eﬃcient than the one constructed by using Groth-Sahai proofs [GS08].) The new
range proof does not rely on the random oracle model or use any proofs of knowledge of signatures.

The complexity of the new protocol is described in Tbl. 1. Setting u = 2 results in a constant argument
length (but CRS of Θ((log H)1+o(1)) group elements). By using an eﬃcient variation of Barreto-Naehrig
curves (where the group elements are either 256 or 512 bits), the communication drops to 14 080 bits.
The range proof of [RKP09] does not allow for constant communication. Moreover, if u = 2 then the
communication is even smaller than that of the known range proofs based on the Lagrange’s theorem
like [Lip03]. We note that constant communication is achieved since the new range proof uses permutation
arguments only for permutations that do not depend on the statement. On the other hand, setting u = H
results in summatory CRS and argument length of log1/2+o(1) H, and setting u = 2
log H results in
prover’s computational complexity dominated by Θ(log H) exponentiations. The previous non-interactive
range proofs did not allow for such a ﬂexibility.

√

This is the full version that corresponds to the publication at FC 2012.
One can obtain a zap [DN00,Gro10] (that is, a 2-message public-coin witness-indistinguishable proof)
from the NIZK range proof by ﬁrst letting the veriﬁer create and send a CRS to the prover, and then
letting the prover to send the range proof to the veriﬁer. This zap works in the standard model (without
needing a CRS since it is generated on run) and has total communication log1/2+o(1) H in the case u = H.

2 Preliminaries
Let [L, H] = {L, L + 1, . . . , H − 1, H} and [H] = [1, H]. Let Sn be the set of permutations from [n] to
[n]. By a, we denote the vector a = (a1, . . . , an). If A is a value, then x ← A means that x is set to A.
If A is a set, then x ← A means that x is picked uniformly and randomly from A. If y = hx, then let

2

CRS length Argument length

Prover comp. Veriﬁer comp.

[RKP09]
[RKP09]

Θ(1)
log h )

Θ( h

Θ(h)
log h )

Θ( h

Θ(h)
log h )

Θ( h

Θ(h)
log h )

Θ( h

This paper

General
u = 2
√
u = 2
u = H

h

n1+ε
h1+ε
h1/2+ε
Θ(1)

5nv + 40 Θ(n2nv)M + Θ(n1+o(1)nv)E
√
Θ(h2)M + h1+εE
40
≈ 5
Θ(h3/2)M + h1+εE ≈ (9
h + 40
≈ 5h + 40

(9nv + 81) P
√
81 P
h + 81) P
Θ(h)E ≈ (9h + 81) P

Table 1. Comparison of NIZK arguments for range proof. Here, M/E/P means the number of multiplica-
tions, exponentiations and pairings. Communication is given in group elements. Here, nv = (cid:98)log(u− 1)(cid:99),
n ≈ log H/ log u and ε = o(1), and the basis of all logarithms is 2. To ﬁt in page margins, in this table
only, we write h = log2 H.

logh y := x. Let κ be the security parameter. We abbreviate probabilistic polynomial-time as PPT. We
say that Λ = (λ1, . . . , λn) ⊂ Z is an (n, κ)-nice tuple, if 0 < λ1 < ··· < λi < ··· < λn = poly(κ).
group (Z or Zp within this paper), then

By using notation from additive combinatorics [TV06], if Λ1 and Λ2 are subsets of some additive

is their sum set and

Λ1 + Λ2 = {λ1 + λ2 : λ1 ∈ Λ1 ∧ λ2 ∈ Λ2}

Λ1 − Λ2 = {λ1 − λ2 : λ1 ∈ Λ1 ∧ λ2 ∈ Λ2}

is their diﬀerence set. If Λ is a set, then

is an iterated sumset, and

kΛ = {λ1 + ··· + λk : λi ∈ Λ}

k · Λ = {kλ : λ ∈ Λ}

is a dilation of Λ. Let

2(cid:98)Λ = {λ1 + λ2 : λ1 ∈ Λ ∧ λ2 ∈ Λ ∧ λ1 (cid:54)= λ2} ⊆ Λ + Λ

denote a restricted sumset [TV06].

A set {λ1, . . . , λn} ⊂ Z+ is progression-free [TV06], if no three of the numbers are in arithmetic
progression, so that λi + λj = 2λk only if i = j = k. Let r3(N ) denote the cardinality of the largest
progression-free set that belongs to [N ]. Recently, Elkin [Elk11] showed that

r3(N ) = Ω((N · log1/4

2 N )/22

2 log2 N ) .

√

It is also known that r3(N ) = O(N (log log N )5/ log N ) [San11]. Thus, the minimal N such that r3(N ) = n
is ω(n), while according to Elkin, N = n1+o(1).

Fact 1 (Lipmaa [Lip12]) For any ﬁxed n > 0, there exists N = n1+o(1), such that [N ] contains a
progression-free subset Λ of odd integers of cardinality n.

Bilinear Groups. Let Gbp(1κ) be a bilinear group generator that outputs a description of a bilinear
group gk := (p, G1, G2, GT , ˆe) ← Gbp(1κ) such that p is a κ-bit prime, G1, G2 and GT are multiplicative
cyclic groups of order p, ˆe : G1 × G2 → GT is a bilinear map (pairing) such that ∀a, b ∈ Z, t ∈ {1, 2} and
2) = ˆe(g1, g2)ab. If gt generates Gt for t ∈ {1, 2}, then ˆe(g1, g2) generates GT . Moreover, it
gt ∈ Gt, ˆe(ga
is eﬃcient to decide the membership in G1, G2 and GT , group operations and the pairing ˆe are eﬃciently
computable, generators are eﬃciently sampleable, and the descriptions of the groups and group elements
each are O(κ) bit long. One can implement an optimal (asymmetric) Ate pairing [HSV06] over a subclass
of Barreto-Naehrig curves [BN05,PSNB11] very eﬃciently. In that case, at security level of 128-bits, an
element of G1/G2/GT can be represented in respectively 256/512/3072 bits.

1 , gb

3

t )2,

 − Pr

(σ, τ ) ← Z2
p :
A(gk; f, h, f σ, hτ , gσ+τ

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)Pr
 gk ← Gbp(1κ), (f, h) ← (G∗
 gk ← Gbp(1κ), (f, h) ← (G∗

(cid:34) gk := (p, G1, G2, GT , ˆe) ← Gbp(1κ), g1 ← G1 \ {1}, g2 ← G2 \ {1}, x ← Zp :
(cid:35)

(σ, τ, z) ← Z3
p :
A(gk; f, h, f σ, hτ , gz

t ) = 1

) = 1

t )2,

.

t

Let Λ be an (n, κ)-nice tuple for some n = poly(κ). We say that a bilinear group generator Gbp is

Λ-PSDL secure, if for any non-uniform PPT adversary A,

A bilinear group generator Gbp is DLIN (decisional linear) secure [BBS04] in group Gt, for t ∈ {1, 2},

if for all non-uniform PPT adversaries A, the next probability is negligible in κ:

Pr

A(gk; (gxs

1 , gxs

2 )s∈{0}∪Λ) = x

for Λ-PSDL requires time Ω((cid:112)p/λn) where p is the group order and λn is the largest element of Λ.

is negligible in κ. Let Λ be an (n, κ)-nice tuple. According to [Lip12], any successful generic adversary

The soundness of NIZK arguments (for example, an argument that a computationally binding com-
mitment scheme commits to 0) seems to be an unfalsiﬁable assumption in general. We will use a weaker
version of soundness in the case of subarguments, but in the case of the range proof, we will prove sound-
ness. Similarly to [Gro10,Lip12], we will base the soundness of that argument on an explicit knowledge
assumption.
For two algorithms A and XA, we write (y; z) ← (A||XA)(x) if A on input x outputs y, and XA
on the same input (including the random tape of A) outputs z. Let Λ be an (n, κ)-nice tuple for some
n = poly(κ). Consider t ∈ {1, 2}. The bilinear group generator Gbp is Λ-PKE secure in group Gt if for
any non-uniform PPT adversary A there exists a non-uniform PPT extractor XA,
p, crs ← (gk; (gxs

 gk := (p, G1, G2, GT , ˆe) ← Gbp(1κ), gt ← Gt \ {1}, (ˆα, x) ← Z2

(c, ˆc; (as)s∈{0}∪Λ) ← (A||XA)(crs) : ˆc = c ˆα ∧ c (cid:54)=

)s∈{0}∪Λ),

(cid:89)



, g ˆαxs

Pr

gasxs
t

t

t

s∈{0}∪Λ

is negligible in κ. Groth [Gro10] proved that the [n]-PKE assumption holds in the generic group model;
his proof can be modiﬁed to the general case.

BBS Cryptosystem. A public-key cryptosystem (Gpkc,Enc,Enc) is a triple of eﬃcient algorithms, key
generation, encryption, and decryption. It is required that for any (sk, pk) ← Gpkc(1κ) and any valid
m and randomizer r, one has Decsk(Encpk(m; r)) = m. A cryptosystem is IND-CPA secure, if for any
(sk, pk) ← Gpkc(1κ) and any two messages m0 and m1, the distributions Encpk(m0;·) and Encpk(m1;·) are
computationally indistinguishable. In the lifted BBS cryptosystem [BBS04] (in group G1), the system
parameters are equal to (gk; g1), where gk ← Gbp(1κ) and g1 ← G1\{1}. The secret key sk is (sk1, sk2) ←
(Z∗

p)2, the public key pk is (f, h) ← (g1/sk1

). One encrypts a ∈ Zp as

, g1/sk2

1

1

Encpk(ck1; a; rf , rh) ← (cg, cf , ch) = (grf +rh+a

1

, f rf , hrh) ,

where (rf , rh) ← Z2
BBS cryptosystem is IND-CPA secure under the DLIN assumption.

p. One decrypts (cg, cf , ch) by returning the discrete logarithm of cg/(csk1

f csk2

h ). The

Commitment Schemes in the CRS Model. A (batch) commitment scheme (Gcom,Com) in a bilinear
group consists of two PPT algorithms: a randomized CRS generation algorithm Gcom, and a randomized
commitment algorithm Com. Here, Gt
com(1κ, n), t ∈ {1, 2}, produces a CRS ckt, and Comt(ckt; a; r), with
a = (a1, . . . , an), outputs a commitment value A in Gt (or Gb
t for b > 1). We assume that a commitment
Comt(ckt; a; r) is opened by revealing (a, r).
A commitment scheme (Gcom,Com) is computationally binding in group Gt, if for every non-uniform
PPT adversary A and positive integer n = poly(κ), the probability
com(1κ, n), (a1, r1, a2, r2) ← A(ckt) :

(cid:34) ckt ← Gt

(cid:35)

Pr

(a1, r1) (cid:54)= (a2, r2) ∧ Comt(ckt; a1; r1) = Comt(ckt; a2; r2)

4

is negligible in κ. A commitment scheme (Gcom,Com) is perfectly hiding in group Gt, if for any positive
integer n = poly(κ) and ckt ∈ Gt
com(1κ, n) and any two messages a1, a2, the distributions Comt(ckt; a1;·)
and Comt(ckt; a2;·) are equal.

∗
ation algorithm inputs t, n and 1κ and outputs a CRS ck
and a trapdoor td, (b) a randomized trapdoor commitment that takes ck
and outputs the value Comt(ck
∗
as an input and outputs an r(cid:48) such that Comt(ck
∗
; a; r(cid:48)).
∗

A trapdoor commitment scheme has three additional eﬃcient algorithms: (a) A trapdoor CRS gener-
com(1κ, n))
and a randomizer r as inputs
, td, a and r
An extractable commitment scheme [Di 02,ACP09] is a commitment scheme (Gcom,Com) with an
additional extractor (Extr1, Extr2) such that: Extrt
(indistinguishable from the
, td; A) returns (a; r) such that A = Com(ck; a; r), given
∗
real CRS ck) and a trapdoor td, and Extr2(ck
that A is a valid commitment. An extractable commitment scheme can only be computationally hiding.

(that has the same distribution as Gt

; 0; r), and (c) a trapdoor opening algorithm that takes ck

1(1κ) creates a CRS ck

; 0; r) = Comt(ck

∗

∗

∗

We use the knowledge commitment scheme, deﬁned in [Lip12], as follows.

CRS generation: Let Λ be a (n, κ)-nice tuple with n = poly(κ). Deﬁne λ0 = 0. Given a bilinear group
generator Gbp, set gk := (p, G1, G2, GT , ˆe) ← Gbp(1κ). Let g1 ∈ G1 and g2 ∈ G2 be generators,
and choose random ˆα, x ← Zp. Fix t ∈ {1, 2}. The CRS is ckt ← (gk; (gt,λi, ˆgt,λi)i∈{0,...,n}), where
gt,λi = gxλi

, and ˆgt,λi = g ˆαxλi

.

p , one chooses a random r ← Zp, and computes

t

Commitment: To commit to a = (a1, . . . , an) ∈ Zn
Comt(ckt; a; r) := (gr

t · n(cid:89)

t

t · n(cid:89)

i=1

gai
t,λi

, ˆgr

ˆgai
t,λi

) .

i=1

G2

Let t = 1. Fix a commitment key ck1 that in particular speciﬁes g2, ˆg2 ∈ G2. A commitment (A, ˆA) ∈
1 is valid, if ˆe(A, ˆg2) = ˆe( ˆA, g2). The case of t = 2 is dual.
According to [Lip12], the knowledge commitment scheme is statistically hiding in group Gt, and com-
putationally binding in group Gt under the Λ-PSDL assumption in group Gt. If the Λ-PKE assumption
holds in group Gt, then for any non-uniform PPT algorithm A, that outputs some valid knowledge com-
mitments, there exists a non-uniform PPT extractor XA that, given as an input the input of A together
with A’s random coins, extracts the contents of these commitments. The knowledge commitment scheme
is also trapdoor, with the trapdoor being td = x: after trapdoor-committing A ← Comt(ck; 0; r) = gr
t for

r ← Zp, the committer can open it to (a; r −(cid:80)n

i=1 aixλi ) for any a.

Non-Interactive Zero-Knowledge. Let R = {(C, w)} be an eﬃciently computable binary relation
such that |w| = poly(|C|). Here, C is a statement, and w is a witness. Let L = {C : ∃w, (C, w) ∈ R} be an
NP-language. Let n = |C| be a ﬁxed input length. For ﬁxed n, we have a relation Rn and a language Ln.
A non-interactive argument for R consists of the next PPT algorithms: a common reference string (CRS)
generator Gcrs, a prover P, and a veriﬁer V. For crs ← Gcrs(1κ, n), P(crs; C, w) produces an argument ψ.
The veriﬁer V(crs; C, ψ) outputs either 1 (accept) or 0 (reject).
A non-interactive argument (Gcrs,P,V) is perfectly complete, if for all values n = poly(κ), all crs ←
Gcrs(1κ, n) and all (C, w) ∈ Rn, V(crs; C,P(crs; C, w)) = 1. A non-interactive argument (Gcrs,P,V) is
computationally (adaptively) sound, if for all non-uniform PPT adversaries A and all n = poly(κ), the
probability

Pr[crs ← Gcrs(1κ, n), (C, ψ) ← A(crs) : C (cid:54)∈ L ∧ V(crs; C, ψ) = 1]

is negligible in κ.

A non-interactive argument (Gcrs,P,V) is perfectly witness-indistinguishable, if (given that there
are several possible witnesses) it is impossible to tell which witness the prover used. That is, for all
n = poly(κ), if crs ∈ Gcrs(1κ, n) and ((C, w0), (C, w1)) ∈ R2
n, then the distributions P(crs; C, w0) and
P(crs; C, w1) are equal. A non-interactive argument (Gcrs,P,V) is perfectly zero-knowledge, if there ex-
ists a polynomial-time simulator S = (S1,S2), such that for all stateful interactive non-uniform PPT
adversaries A and n = poly(κ),

 crs ← Gcrs(1κ, n), (C, w) ← A(crs),

 = Pr

Pr

ψ ← P(crs; C, w) :
(C, w) ∈ Rn ∧ A(ψ) = 1
Here, td is the simulation trapdoor.

 (crs, td) ← S1(1κ, n), (C, w) ← A(crs),

ψ ← S2(crs, C, td) :
(C, w) ∈ Rn ∧ A(ψ) = 1

 .

5

t and ˆgt(cid:96) ← g ˆαx(cid:96)

g2 ← G2 \ {1}. Denote gt(cid:96) ← gx(cid:96)

for t ∈ {1, 2} and (cid:96) ∈ {0} ∪ ˆΛ. Let D ←(cid:81)n

System parameters: Let n = poly(κ). Let Λ = {λi : i ∈ [n]} be a progression-free set of odd integers, such
CRS generation Gcrs(1κ): Let gk := (p, G1, G2, GT , ˆe) ← Gbp(1κ). Let ˆα, x ← Zp. Let g1 ← G1 \ {1} and
i=1 g2,λi . The

that λi+1 > λi > 0. Denote λ0 := 0. Let ˆΛ := {0} ∪ Λ ∪ 2(cid:98)Λ.
CRS is crs ← (gk; (g1(cid:96), ˆg1(cid:96))(cid:96)∈{0}∪Λ, (g2(cid:96), ˆg2(cid:96))(cid:96)∈ ˆΛ, D). Let (cid:98)ck1 ← (gk; (g1(cid:96), ˆg1(cid:96))(cid:96)∈{0}∪Λ).
Common inputs: (A, ˆA, B, ˆB, B2, C, ˆC), where (A, ˆA) ← Com1((cid:98)ck1; a; ra), (B, ˆB) ← Com1((cid:98)ck1; b; rb), B2 ←
2 ·(cid:81)n
i∧λi+λj = (cid:96)}. For (cid:96) ∈ 2(cid:98)Λ, the prover sets µ(cid:96) ←(cid:80)
·(cid:81)
(cid:81)
(i,j)∈I1((cid:96))(aibj−ci). He sets ψ ← grarb
(cid:96)∈2(cid:98) Λ ˆgµ(cid:96)
(cid:96)∈2(cid:98) Λ gµ(cid:96)

Argument generation P×(crs; (A, ˆA, B, ˆB, B2, C, ˆC), (a, ra, b, rb, c, rc)): Let I1((cid:96)) := {(i, j) : i, j ∈ [n] ∧ j (cid:54)=
·
i=1 grabi+rbai−rc
2 to the veriﬁer as
Veriﬁcation V×(crs; (A, ˆA, B, ˆB, B2, C, ˆC), ψ×): accept iﬀ ˆe(A, B2)/ˆe(C, D) = ˆe(g1, ψ) and ˆe(g1, ˆψ) = ˆe(ˆg1, ψ).

, (C, ˆC) ← Com1((cid:98)ck1; c; rc), s.t. aibi = ci for i ∈ [n].

2(cid:96) . He sends ψ× ← (ψ, ˆψ) ∈ G2

2(cid:96) , and ˆψ ← ˆgrarb

i=1 ˆgrabi+rbai−rc

·(cid:81)n

·(cid:81)n

the argument.

2,λi

grb

i=1 gbi

2,λi

2

2,λi

t

2

Protocol 1: Hadamard product argument [[(A, ˆA)]] ◦ [[(B, ˆB, B2)]] = [[(C, ˆC)]] from [Lip12]

3 Groth-Lipmaa Arguments

In this section, we describe two of our building-blocks, an Hadamard product argument and a (known)
permutation argument. In both cases, Groth [Gro10] proposed eﬃcient (weakly) sound and non-
interactive witness-indistinguishable (NIWI) arguments that were further reﬁned by Lipmaa [Lip12],
who used the theory of progression-free sets to optimize Groth’s arguments. Since [Lip12] is very new,
we will give here a full description of Lipmaa’s NIWI arguments. We refer to [Lip12] (and its full ver-
sion, [Lip11]) for details.

3.1 Hadamard Product Argument
Assume that (Gcom,Com) is the knowledge commitment scheme. Recall that an Hadamard product of two
vectors a and b is equal to their entrywise product vector c, that is, cj = aj·bj for j ∈ [n]. In an Hadamard
product argument, the prover aims to convince the veriﬁer that for given three commitments (A, ˆA),
(B, ˆB) and (C, ˆC), he knows how to open them as (A, ˆA) = Com1(ck; a; ra), (B, ˆB) = Com1(ck; b; rb),
and (C, ˆC) = Com1(ck; c; rc), such that cj = aj · bj for j ∈ [n]. Prot. 1 has a full description of Lipmaa’s
Hadamard product argument [[(A, ˆA)]] ◦ [[(B, ˆB, B2)]] = [[(C, ˆC)]], where B2 is the equivalent of B in G2:
B2 ← grb

2 ·(cid:81)n

i=1 gbi

.

2,λi

Fact 2 (Lipmaa [Lip12]) The above Hadamard product argument is perfectly complete and perfectly
witness-indistinguishable. If the bilinear group generator Gbp is ˆΛ-PSDL secure, then a non-uniform PPT
adversary has negligible chance of outputting inp× ← (A, ˆA, B, ˆB, B2, C, ˆC) and an accepting argument
ψ× ← (ψ, ˆψ) together with opening witness w× ← (a, ra, b, rb, c, rc, (f(cid:48)

s)s∈ ˆΛ) such that

– (A, ˆA) = Com1((cid:98)ck1; a; ra),
– (B, ˆB) = Com1((cid:98)ck1; b; rb),
– (C, ˆC) = Com1((cid:98)ck1; c; rc),
(cid:80)

2 ·(cid:81)n
i=1 gbi
2i,
(cid:80)

– B2 = grb

s∈ ˆΛ f(cid:48)
sxs
– (ψ, ˆψ) = (g
– and for some i ∈ [n], aibi (cid:54)= ci.
2

s∈ ˆΛ f(cid:48)

, ˆg
2

sxs

),

For the product argument to be useful in more complex arguments, we must also assume that the
veriﬁer there additionally veriﬁes that ˆe(A, ˆg2) = ˆe( ˆA, g2), ˆe(B, ˆg2) = ˆe( ˆB, g2), ˆe(g1, B2) = ˆe(B, g2), and
ˆe(C, ˆg2) = ˆe( ˆC, g2). Note that (f(cid:48)
Fact 3 (Lipmaa [Lip12]) For any n > 0 and y = n1+o(1), let Λ ⊂ [y] be a progression-free set of
odd integers as guaranteed by Fact 1, such that |Λ| = n. The communication (argument size) of the
Hadamard product argument is 2 elements from G2. The prover’s computational complexity is Θ(n2)
scalar multiplications in Zp and n1+o(1) exponentiations in G2. The veriﬁer’s computational complexity
is dominated by 5 bilinear pairings. The CRS consists of n1+o(1) group elements.

s)s∈ ˆΛ is the opening of (ψ, ˆψ).

6

System parameters: Same as in Prot. 1, but let

˜Λ := Λ ∪ {2λk − λj}i,k∈[n] ∪ 2(cid:98)Λ ∪ ({2λk + λi − λj}i,j,k∈[n]∧i(cid:54)=j \ 2 · Λ) .

t

t , ˆgt(cid:96) ← ˆgx(cid:96)

t and ˜gt ← ˜g ˜α

g2 ← G2 \ {1}. Let ˆgt ← ˆg ˆα

i=1 g2,λi ,(cid:81)n

for t ∈ {1, 2}. Denote gt(cid:96) ← gx(cid:96)
i=1 ˜g2,λi ). The CRS is

crs ← (gk; (g1(cid:96), ˆg1(cid:96), ˜g1(cid:96))(cid:96)∈{0}∪Λ, (g2(cid:96))(cid:96)∈{0}∪ ˜Λ, (ˆg2(cid:96))(cid:96)∈ ˆΛ, (˜g2(cid:96))(cid:96)∈ ˜Λ, D, ˜D) .

CRS generation Gcrs(1κ): Let gk := (p, G1, G2, GT , ˆe) ← Gbp(1κ). Let ˆα, ˜α, x ← Zp. Let g1 ← G1 \ {1} and
for

t ∈ {1, 2} and (cid:96) ∈ {0} ∪ ˜Λ. Let (D, ˜D) ← ((cid:81)n
Let (cid:98)ck1 ← (gk; (g1(cid:96), ˆg1(cid:96))(cid:96)∈{0}∪Λ), (cid:101)ck1 ← (gk; (g1(cid:96), ˜g1(cid:96))(cid:96)∈{0}∪Λ).
(B, ˜B) ← Com1((cid:101)ck1; b; rb), s.t. bj = a(j) for j ∈ [n].
,(cid:81)n
2. Let ra∗ ← Zp, (A∗, ˆA∗) ← Com1((cid:98)ck1; TΛ(−1(1), ) · a1, . . . , TΛ(−1(n), ) · an; ra∗ ). Create an argument
i=1 gTΛ(−1(i),)

Common inputs: (A, ˜A, B, ˆB, ˜B, ), where  ∈ Sn, (A, ˜A) ← Com1((cid:101)ck1; a; ra), (B, ˆB) ← Com1((cid:98)ck1; b; rb), and

Argument generation Pperm(crs; (A, ˜A, B, ˆB, ˜B, ), (a, ra, b, rb)):

,(cid:81)n
i=1 ˆgTΛ(−1(i),)

2 ) ← ((cid:81)n

t , and ˜gt(cid:96) ← ˜gx(cid:96)

i=1 gTΛ(−1(i),)

1. Let (T ∗, ˆT ∗, T ∗

ψ× for [[(A, ˆA)]] ◦ [[(T ∗, ˆT ∗, T ∗

 := 2(cid:98)Λ ∪ ({2λ(j) + λi − λj : i, j ∈ [n] ∧ i (cid:54)= j} \ 2 · Λ) ⊂ {−λn + 1, . . . , 3λn}.

2 )]] = [[(A∗, ˆA∗)]].

, I1((cid:96)) as in Prot. 1, and I2((cid:96)) := {(i, j) : i, j ∈ [n] ∧ j (cid:54)= i ∧ 2λ(i) + λj (cid:54)= λi + 2λ(j) ∧ 2λ(j) +

3. Let ˜Λ(cid:48)
4. For (cid:96) ∈ ˜Λ(cid:48)

1,λi

1,λi

2,λi

).

t

λi − λj = (cid:96)}, set

5. Let (E, ˜E) ← ((cid:81)n

µ,(cid:96) ← (cid:88)

i=1 g2,2λ(i)−λi ,(cid:81)n
·(cid:81)

i=1 ˜g2,2λ(i)−λi ).
−rb


a · ˜E

(i,j)∈I1((cid:96))

(i,j)∈I2((cid:96))

bi .

∗
a

i − (cid:88)
·(cid:81)

−rb


a · E

Veriﬁcation Vperm(crs; (A, ˜A, B, ˆB, ˜B, ), ψperm): Let E and (T ∗, ˆT ∗, T ∗

6. Let ψ ← Dr∗
Send ψperm ← (A∗, ˆA∗, ψ×, ψ, ˜ψ) ∈ G2
2 ) be computed as in Pperm. If ψ×
veriﬁes, ˆe(A∗, D)/ˆe(B, E) = ˆe(g1, ψ), ˆe(A∗, ˆg2) = ˆe( ˆA∗, g2), and ˆe(g1, ˜ψ) = ˆe(˜g1, ψ), then Vperm accepts.
Otherwise, Vperm rejects.

, ˜ψ ← ˜Dr∗
1 × G4

2 to the veriﬁer as the argument.

µ,(cid:96)
g
2(cid:96)

µ,(cid:96)
˜g
2(cid:96)

(cid:96)∈ ˜Λ(cid:48)

(cid:96)∈ ˜Λ(cid:48)

,





Protocol 2: Permutation argument ([[(A, ˜A)]]) = [[(B, ˜B)]] from [Lip12]

Finally, as noted in [Lip12], if a, b and c are Boolean vectors then the prover’s computational complexity
is Θ(n2) scalar additions in Zp and n1+o(1) exponentiations in G.

3.2 Permutation Argument
In a permutation argument, the prover aims to convince the veriﬁer that for given permutation  ∈ Sn
and two commitments (A, ˜A) and (B, ˜B), he knows how to open them as (A, ˜A) = Com1(ck; a; ra) and
(B, ˜B) = Com1(ck; b; rb), such that bj = a(j) for j ∈ [n]. We denote this non-interactive argument by
([[(A, ˜A)]]) = [[(B, ˜B, B2)]], where B2 is again the equivalent of B in G2. As in the case of the Hadamard
product argument, we describe a version of the argument due to [Lip12]. See Prot. 2.
Let TΛ(i, ) := |{j ∈ [n] : 2λ(i) + λj = 2λ(j) + λi}|, clearly TΛ(i, ) ≥ 1. One proves that a(i) = bi
(i) = TΛ(i, ) · bi for
for i ∈ [n] by using a subargument that shows that for separately committed a∗
i , a∗
i ∈ [n]. Showing in addition that a∗
(i) = TΛ(i, ) · a(i)),
i = TΛ(−1(i), ) · ai (which is equivalent to a∗
one obtains that a(i) = bi for i ∈ [n]. We only consider the case where  is ﬁxed and thus the element
E can be put to the CRS. We also use the fact that ˆΛ ∪ ˜Λ = {0} ∪ ˜Λ, where ˜Λ is deﬁned in Prot. 2.

We denote the full permutation argument by ([[(A, ˜A)]]) = [[(B, ˆB, ˜B)]].

Fact 4 (Lipmaa [Lip12]) The above permutation argument is perfectly complete and perfectly witness-

indistinguishable. If the bilinear group generator Gbp is (cid:101)Λ-PSDL secure, then a non-uniform PPT ad-
ψperm ← (A∗, ˆA∗, ψ×, ˆψ×, ψ,(cid:101)ψ) together with a witness

versary has negligible chance of outputting inpperm ← (A, ˜A, B, ˆB, ˜B, ) and an accepting argument

wperm ← (a, ra, b, rb, a∗, ra∗ , (f(cid:48)

(×,(cid:96)))(cid:96)∈ ˆΛ, (f(cid:48)

(,(cid:96)))(cid:96)∈(cid:101)Λ) ,

such that

7

– (A, ˜A) = Com1((cid:101)ck1; a; ra),
– (B, ˆB) = Com1((cid:98)ck1; b; rb),
– (B, ˜B) = Com1((cid:101)ck1; b; rb),
– (A∗, ˆA∗) = Com1((cid:98)ck1; a∗; ra∗ ),
(cid:80)
(cid:80)
(cid:96)∈ ˆΛ f(cid:48)
, ˆg
2
(cid:96)∈ ˜Λ f(cid:48)

(×,(cid:96))

(,(cid:96))

2

(×,(cid:96))

(cid:80)
(cid:80)
(cid:96)∈ ˆΛ f(cid:48)
– (ψ×, ˆψ×) = (g
(cid:96)∈ ˜Λ f(cid:48)
– (ψ, ˆψ) = (g
, ˜g
2
2
– a∗
– for some i ∈ [n], a(i) (cid:54)= bi.
For the permutation argument to be useful in more complex arguments, we must also assume that the
veriﬁer there veriﬁes that ˆe( ˜A, g2) = ˆe(A, ˜g2), ˆe( ˆB, g2) = ˆe(B, ˆg2), and ˆe( ˜B, g2) = ˆe(B, ˜g2).

i = TΛ(−1(i), ) · ai (for i ∈ [n]), and

(,(cid:96))

),

),

Fact 5 (Lipmaa [Lip12]) The permutation argument has a common reference string of length n1+o(1)
and communication of 4 group elements. The prover’s computational complexity is Θ(n2) scalar additions
in Zp and n1+o(1) exponentiations in G. The veriﬁer’s computational complexity is dominated by 12
bilinear pairings.

4 Breaking the COCOON 2009 Range Proof

In [YHM+09], the authors proposed a non-interactive range proof. In what follows, we show that their
argument is not secure.
Their goal is to prove that a committed secret w is in some range [a, b]. To do so they prove that
both w− a and b− w are non-negative by making use of Lagrange theorem stating that any non-negative
integer can be decomposed as the sum of four squares. Hence,

4(cid:88)

4(cid:88)

w − a =

w2
1j

and b − w =

w2

2j ,

(1)

j=1

j=1

for some wij. The range proof of [YHM+09] is based on (symmetric) bilinear groups of composite order,
that is, on bilinear groups (n, G, GT , ˆe), where n = pq. To commit to a message w, the committer picks
a random1 r ∈ Zq and computes C = gwur, where g is a random generator of G (of order n), and u is a
random generator of subgroup Gq (of order q). Given C, w is uniquely determined in Zp, as C q = gwq.

In their range proof, the prover ﬁnds the witnesses wij in Eq. (1) and outputs a proof

ψ = ({C1j, C2j}j∈[4], Cw, ϕ1, ϕ2) ,

where

The veriﬁer checks if

and

j=1 r2

(cid:80)4
j=1 r1j w1j · u
(cid:80)4
j=1 r2j w2j · u

Cw ≡gwurw ∈ G ,
Cij ≡gwij urij ∈ G for i ∈ [2] and j ∈ [4] ,
ϕ1 ≡g−rw+2(cid:80)4
1j ∈ G ,
ϕ2 ≡grw+2(cid:80)4
2j ∈ G .
4(cid:89)
4(cid:89)

e(C1j, C1j) = ˆe(u, ϕ1)

ˆe(gaC−1

w , g)

j=1 r2

j=1

e(C2j, C2j) = ˆe(u, ϕ2) .

ˆe(Cwg−b, g)

Now assume that a malicious prover P (cid:63) picks an integer w∗ ∈ {0, . . . , p − 1} \ [a, b]. We have that
2j}j∈[4]

either w∗ − a or b − w∗ is negative as an integer. Suppose b − w∗ < 0, then P (cid:63) chooses {w∗
1 In [YHM+09], the scheme uses r ∈ Zn to facilitate their security proof (crs switching).

j=1

8

such that n + (b − w∗) = (cid:80)4
grw+2·(cid:80)4

(cid:80)4
2j · u

j=1 r2j w∗

j=1 r2

still holds:

ˆe(Cwg−b, g)

4(cid:89)

j=1

j=1(w∗

2j ur2j , ϕ1 as above, and ϕ2 ←
2j . Let u = gα for some α. It is easy to see that the second veriﬁcation equation

2j)2, sets Cw ← gw∗

urw , C2j ← gw∗

ˆe(C2j, C2j) =ˆe(g, g)(w∗−b)+αrw+(cid:80)4
=ˆe(g, g)(w∗−b)+αrw+(cid:80)4
=ˆe(g, g)α·(rw+2(cid:80)4

j=1 r2j w∗

j=1(w∗

2j +αr2j )2

j=1(w∗

2j )2+(cid:80)4
2j +α·(cid:80)4

j=1 r2

2j +2(cid:80)4

j=1 α2r2

j=1 αr2j w∗

2j

2j ) = ˆe(u, ϕ2) .

We have successfully constructed a polynomial time adversary who can always break the scheme. There-
fore, the NIZK range proof in [YHM+09] is not sound.

5 New Subargument for Correct Encryption

In the new range proof of Sect. 6, we need a subargument that if (Ac, ¯Ac) is a knowledge-commitment
of some a (with n = 1 and some randomness r), and (Ag, Af , Ah) is a BBS ciphertext of some a(cid:48), then
a = a(cid:48). That is, Ac = gr
, f rf , hrh) for randomness (rf , rh) and public
key (f, h). (The generator g1,λ1 is required in Sect. 6.)

and (Ag, Af , Ah) = (grf +rh+a

1ga

1,λ1

1

We will construct this argument in the current section, by combining ideas from [GS08]
and [Gro10,Lip12]. Intuitively, for every multi-exponentiation ha1
m = t that we want to prove,
we write down a veriﬁcation equation ˆe(h1,Com(a1))····· ˆe(hm,Com(am)) = ˆe(ψ, g2)ˆe(t,Com(1)), where
ψ “compensates” for the fact that Com(am) are probabilistic commitments. In addition, we use knowl-
edge commitments (though for small values 0 or 1 of n) so that one can extract all committed values.
Since the argument uses three committed values (a, rf and rh) and three equations, according to Fig. 6
of [GS07] (the full version of [GS08]), the corresponding pure Groth-Sahai argument will have length
of 15 group elements. Our combination argument has the same length, but is computationally more
eﬃcient.

1 . . . ham

System parameters: An (n, κ)-nice tuple Λ = (λ1, . . . , λn).
Common reference string generation Gcrs(1κ): Set

gk := (p, G1, G2, Gt, ˆe) ← Gbp(1κ) .

, g2,λ1 ← gxλ1

Generate random αg, αf , αh, ¯α, αg/c, x ← Zp. Let g1 ← G1 \ {1} and g2 ← G2 \ {1}. Denote g1,λ1 ←
, ˚g1,g/c ←
gxλ1
1
αg/c·(1−xλ1 )
αg/c·(1−xλ1 )
, ˚g2,g/c ← g
g
2 . The
1
2
common reference string is

2 , ¯g2,λ1 ← g ¯α
1 , and ˚g2,h ← gαh

1 , ¯g1,λ1 ← g ¯α
1 , ˚g2,f ← gαf

, ¯g2 ← g ¯α
2 , ˚g1,h ← gαh

2 , ¯g1 ← g ¯α
, ˚g1,f ← gαf

1 , ˚g2 ← gαg

, ˚g1 ← gαg

2,λ1

1,λ1

2

crs ← (gk; g1, g1,λ1, g2, g2,λ1,˚g1,˚g2, ¯g1, ¯g1,λ1, ¯g2, ¯g2,λ1 ,˚g1,g/c,˚g2,g/c,˚g1,f ,˚g2,f ,˚g1,h,˚g2,h) .

A third party also creates sk := (sk1, sk2) ← (Z∗

p)2, and sets

pk := (f, h, ˚f ,˚h) ← (g1/sk1

1

, g1/sk2

1

,˚g1/sk1

1,f

,˚g1/sk2

1,h ) .

Common inputs: (crs; pk, Ag, Af , Ah, Ac), where pk = (f, h, ˚f ,˚h),

(Ag, Af , Ah) = (grf +rh+a

1

, f rf , hrh) ,

and Ac = grf +rh

1

ga
1,λ1

.

Argument P(crs; (Af , Ag, Ah, Ac), (a, rf , rh)): let ¯Ac ← ¯grf +rh

1

¯ga
1,λ1

,

˚Ag/c ← ˚ga

1,g/c. Let Rf , Rh ← Zp. Let (Cf , ¯Cf ) ← (gRf

( ˚Af , ˚Af , ˚Ah) ← (˚grf +rh+a
2 grf
2,λ1

1

, ˚f rf ,˚hrh ) ,

, ¯gRf

),

2 ¯grf
2,λ1
) ∈ G2
2 .

, ¯gRh

2 ¯grh
2,λ1

(Ch, ¯Ch) ← (gRh

2 grh
2,λ1

9

Let

(ψg, ˚ψg) ← (gr+Rf +Rh

1

,˚gr+Rf +Rh

1

) ∈ G2
1 ,

(ψf , ˚ψf ) ← (f Rf , ˚f Rf ) ∈ G2
Send ψce ← ( ˚Ag, ˚Af , ˚Ah, ˚Ac, ψg, ˚ψg, Cf , ¯Cf , ψf , ˚ψf , Ch, ¯Ch, ψh, ˚ψh, ˚Ag/c) to the veriﬁer.

1, (ψh, ˚ψh) ← (hRh ,˚hRh ) ∈ G2
1.

Veriﬁcation V(crs; (Af , Ag, Ah, Ac), ψce): Verify that ˆe(˚f , g2) = ˆe(f,˚g2,f ), ˆe(˚h, g2) = ˆe(h,˚g2,h),
ˆe(Ag,˚g2) = ˆe( ˚Ag, g2), ˆe(Af ,˚g2,f ) = ˆe( ˚Af , g2), ˆe(Ah,˚g2,h) = ˆe( ˚Ah, g2), ˆe(Ac, ¯g2) = ˆe( ¯Ac, g2),
ˆe(ψg,˚g2) = ˆe(˚ψg, g2), ˆe(ψf ,˚g2,f ) = ˆe(˚ψf , g2), ˆe(ψh,˚g2,h) = ˆe(˚ψh, g2), ˆe(¯g1, Cf ) = ˆe(g1, ¯Cf ),
ˆe(¯g1, Ch) = ˆe(g1, ¯Ch), and ˆe(Ag/Ac,˚g2,g/c) = ˆe( ˚Ag/c, g2).
Verify that ˆe(f, Cf ) = ˆe(ψf , g2) · ˆe(Af , g2,λ1 ), ˆe(h, Ch) = ˆe(ψh, g2) · ˆe(Ah, g2,λ1), and ˆe(g1, Cf Ch) =
ˆe(ψgA−1

, g2) · ˆe(Ag, g2,λ1 ).

c

1,λ1

1ga

Theorem 1. The argument of this subsection is a perfectly argument that for some a, rf , rh ∈ Zp,
and (Ag, Af , Ah) = (grf +rh+a, f rf , hrh ). If the {λ1}-PSDL assumption and the {λ1}-
Ac = gr
PKE assumption (in both G1 and G2) hold, then this argument is computationally sound. If the DLIN
assumption holds in group G1, then this argument is computationally zero-knowledge.
Clearly, this argument has CRS of length Θ(1), its argument consists of 13 elements of G1 and 2 ele-
ments of G2. The prover’s computational complexity is dominated by 20 exponentiations. The veriﬁer’s
computational complexity is dominated by 33 pairings.

6 New Range Proof
In the next range proof, the prover has an encrypted a ∈ Zp, and he aims to convince the veriﬁer that
a ∈ [0, H]. We will use the lifted BBS cryptosystem (Gpkc,Enc,Dec) that can be thought of as a perfectly
binding commitment scheme if decryption is not necessary. Since we are interested in obtaining a sublinear
argument, we will also use the (computationally binding) knowledge commitment scheme (Gcom,Com).
We use the following result that was stated for u = 2 in [LAN02] and for general u in [CLs10].
Fact 6 Let H > 0 and u > 1. Let (cid:96)(u, H) ≤ logu(H + 1) be deﬁned as in [CLs10]. Then a ∈ [0, H] if
and only if for some bi ∈ [0, u − 1],

(cid:96)(u,(u−1)H)(cid:88)

(u − 1)a =

where Gi ∈ Z are values deﬁned in [CLs10]. That is, (u − 1) · [0, H] = (cid:80)(cid:96)(u,(u−1)H)
particular, [0, H] =(cid:80)(cid:98)log2 H(cid:99)

(cid:98)(H + 2i)/2i+1(cid:99) · [0, 1].

i=1

i=1

i=0

Gibi ,

Gi · [0, u − 1]. In

The precise values of (cid:96)(u, H) and Gi are not important in the next description. It suﬃces to know that
they can be eﬃciently evaluated. We note that

Gi = (cid:98)H/ui+1(cid:99) + (cid:98)(Hi + (

Hj mod (u − 1)) + 1)/u(cid:99) ,

j=0

where H =(cid:80) 2iHi [CLs10].
According to Fact 6, a ∈ [H] iﬀ for Gi computed as in Fact 6, one has (u − 1)a =(cid:80)n
bi ∈ [0, u− 1]. The latter is done by writing bi as bi =(cid:80)(cid:98)log2(u−1)(cid:99)
The prover then commits to the vector (c1, . . . , cn), where cj =(cid:80)n

The basic idea of the next range proof is as follows. Choose a u > 1, and let n = (cid:96)(u, (u − 1)H).
i=1 Gibi for some
bi ∈ [u − 1]. The prover shows by using a parallel version of range proof from [LAN02] that for i ∈ [n],
G(cid:48)
jb(cid:48)
ji (by again using Fact 6) and then
ji ∈ [0, 1] by using an Hadamard product arguments from [Lip12]. This will be achieved
showing that b(cid:48)
with commitments on (b(cid:48)

i=j Gibi, and shows that the values
cj are correctly computed by using a small constant number of Hadamard product and permutation
arguments. More precisely, he commits to (G1b1, . . . , Gnbn) (and shows this has been done correctly),

jn) for j ∈ [(cid:98)log2(u − 1)(cid:99)].

j1, . . . , b(cid:48)

j=0

i−1(cid:88)

10

then to (c2, . . . , cn, c1) (and shows this was done correctly), then to (c2, . . . , cn, 0) (and shows this was
done correctly), and then shows that

(c1, . . . , cn) = (G1b1, . . . , Gnbn) + (c2, . . . , cn, 0) .

i=j Gibi. But then by Fact 6, c1 =(cid:80)n

Thus, the veriﬁer is convinced that cj =(cid:80)n
i=1 Gibi ∈ (u − 1) · [H],
and thus the prover has to show, by using a single product argument, that (Au−1
) commits to
As in [Lip12], in a few cases, instead of computing two diﬀerent commitments Comt((cid:98)ckt; a; r) =
(c1, 0, . . . , 0) and that (Ag, Af , Ah) is a lifted BBS encryption of A with randomizer (rf , rh) where
t ·(cid:81) gai
r = rf + rh.

), we compute a composed commitment

t ·(cid:81) ˆgai

, ˆAu−1

c

, ˜gr

(gr

c

, ˆgr

t,λi

tλi

gai
t,λi

, ˆgr
t

ˆgai
t,λi

, ˜gr

˜gai
t,λi

) .

t ·(cid:81) gai
) and Comt((cid:101)ckt; a; r) = (gr
t ·(cid:89)

Comt(ckt; a; r) = (gr

t,λi

t ·(cid:81) ˜gai
(cid:89)

t,λi

t ·(cid:89)

Λ = {λi}i∈[n] be an (n, κ)-nice tuple. Denote λ0 := 0. Let (cid:98)Λ := {0} ∪ Λ ∪ 2(cid:98)Λ, and ˜Λ as in Sect. 3.2.

The common input to both parties is equal to a BBS encryption (Ag, Af , Ah) of a, accompanied by a
knowledge component ˆA such that (A, ˆA) is at the same time a knowledge commitment to a.
Theorem 2. Let u > 1. Let H = poly(κ) and n = (cid:96)(u, (u − 1)H) where (cid:96) is deﬁned as in Fact 6. Let
Let rot ∈ Sn be a permutation, where rot(i) = i − 1 if i > 1, and rot(1) = n. Deﬁne Gi as in Fact 6.
The argument in Prot. 3 is perfectly complete. If Gbp is Λ-PKE secure and DLIN secure in G1, then the
argument in Prot. 3 is computationally zero-knowledge. If Gbp is ˜Λ-PSDL secure and Λ-PKE secure in
both G1 and G2, then the argument in Prot. 3 is computationally sound.

This argument is computationally zero-knowledge because (Ac, ˆcc) that was provided by a prover and not
generated during the argument. To achieve zero-knowledge, one must be able to open (Ac, ˆc) given only
the CRS trapdoor. That is, one has to use an extractable commitment scheme [Di 02,ACP09]. It is easy
to see that the knowledge commitment scheme is extractable, however, extractability is only achieved
under the PKE assumption. The use of a cryptosystem also makes achieving perfect zero-knowledge
impossible.
Theorem 3. Let u > 1. Let Λ be as in Fact 1 and let n = (cid:96)(u, (u − 1)H) ≤ (cid:98)logu((u − 1)H + 1)(cid:99) ≈
log H/ log u + 1, where (cid:96)(·,·) is deﬁned as in Fact 6. Let nv = (cid:100)log2(u − 1)(cid:101). Assume that we use the
Hadamard product argument and the permutation argument from Sect. 3. The range proof in Prot. 3 has
a length-n1+o(1) common reference string, communication of 2nv + 25 elements from G1 and 3nv + 15
elements from G2, the prover’s computational complexity of Θ(n2nv) scalar multiplications in Zp and
n1+o(1)nv exponentiations in G1 or G2. The veriﬁer’s computational complexity is dominated by 9nv + 81
pairings.

The communication complexity is minimized when nv (and thus u) is as small as possible, that is, u = 2.
Then nv = (cid:98)log2 1(cid:99) = 0. In this case the communication consists of 12 elements from G1 and 13 elements
from G2. The same choice u = 2 is also optimal for veriﬁer’s computational complexity (81 pairings). As
noted before, at the security level of 2128, elements of G1 can be represented in 256 bits, and elements of
G2 in 512 bits. Thus, at this security level, if u = 2 then the communication is 25· 256 + 25· 512 = 14 080
bits, that is, only about 4 to 5 times longer than the current recommended length of a 2128-secure RSA
modulus. Therefore, the communication of the new range proof is even smaller than that of Lagrange
theorem based arguments like [Lip03].
The optimal prover’s computational complexity is achieved when the number of exponentiations,
n1+o(1) · nv = (log H/ log u)1+o(1) · (cid:98)log2(u − 1)(cid:99), is minimized. This happens if u = H, then the prover’s
computation is dominated by Θ(log H) scalar multiplications and exponentiations. Moreover, in this case
the CRS length n1+o(1) is constant. Finally, we might want the summatory length of the CRS and the
communication to be minimal, that is, n1+o(1) + Θ(nv). Considering n ≈ logu H and nv ≈ log2 u, we get
that the sum is (log H/ log u)1+o(1) + Θ(log u). One can approximately minimize the latter by choosing
ln H . Then the summatory length is log1/2+o(1) H. (In this case, it would make sense to change
u = e
the role of groups G1 and G2 to get better eﬃciency.) The eﬃciency of the new range proof in all three
cases is given in Tbl. 1.

√

11

t

j := (cid:98)(u + 2j)/2j+1(cid:99).

˜gts ← g ˜αxs
˚g2,g/c ← g

System parameters: H, Gi, n, u, nv := (cid:98)log2(u − 1)(cid:99), and G(cid:48)
Common reference string generation Gcrs(1κ): Set gk := (p, G1, G2, GT , ˆe) ← Gbp(1κ). Generate random
, ˆgts ← g(cid:98)αxs
,

(cid:98)α, ˜α, αg, αf , αh, ¯α, αg/c, x ← Zp. Let g1 ← G1 \ {1} and g2 ← G2 \ {1}. Denote gts ← gxs
2 . Set D ← (cid:81)n
2,λ1 , ˚g1,g/c ← g
1 , ˚g2 ← gαg
(cid:81)n
i=1 g2,2λrot(i)−λi , and (cid:101)Erot ← E ˜α
, ˚g1,f ← g
crs ← (gk; (g1,s, ˆg1,s, ˜g1,s)s∈{0}∪Λ, g2, (ˆg2,s)s∈(cid:98)Λ, (g2,s, ˜g2,s)s∈ ˜Λ, D, Erot, (cid:101)Erot) .
Set ck1 ← (gk; (g1s, ˆg1s, ˜g1s)s∈{0}∪Λ), (cid:98)ck1 ← (gk; (g1s, ˆg1s)s∈{0}∪Λ) and (cid:101)ck1 ← (gk; (g1s, ˜g1s)s∈{0}∪Λ). The

2 , ¯g1 ← g ¯α
1 , ˚g2,f ← g
rot. The common reference string is

αg/c·(1−xλ1 )
,
1
=1 g1,λi , Erot ←

, ˚g1 ← gαg
αg/c·(1−xλ1 )
2

1 , and ˚g2,h ← gαh

2 , ˚g1,h ← gαh

1,λ1 , ¯g2 ← g ¯α

1 , ¯g1,λ1 ← g ¯α

2 , ¯g2,λ1 ← g ¯α

αf

αf

t

t

prover creates a secret key sk := (sk1, sk2) ← Z2
Here, Encpk(m; (rf , rh)) := (g
, f rf , hrh ).
Common inputs: (pk, Ag, Af , Ah, Ac, ˆAc), where
Argument P(crs; (pk, Ag, Af , Ah, Ac, ˆAc), (a, rf , rh)): The prover does the following:

(Ag, Af , Ah) = (gr+a

p, and sets pk ← (f, h, ˚f ,˚h) ← (g1/sk1

1,λ1 ), for r = rf + rh.

rf +rh+m
1

, f rf , hrh )

1 ˆga

1

1

, g1/sk2

1 ˚g1/sk1

1,f

,˚g1/sk2

1,h ).

and (Ac, ˆAc) =

1,λ1 , ˆgr

gr
1ga
1. Compute (b1, . . . , bn) ∈ Zn
2. For i ∈ [n] do: compute (b(cid:48)
3. For j ∈ [0, nv] do:

u such that (u − 1)a =(cid:80)n
j) ← Com1((cid:98)ck1; b(cid:48)

nv ,i) ∈ Znv +1

0i, . . . , b(cid:48)

2

j1, . . . , b(cid:48)
j, ˆB(cid:48)

j)]] ◦ [[(B(cid:48)

i=1 Gibi.

such that bi =(cid:80)nv
2 ·(cid:81)n

j2 ← grj
j2)]] = [[(B(cid:48)
j, B(cid:48)

jn; rj), B(cid:48)
j, ˆB(cid:48)

j=0 G(cid:48)

j) for [[(B(cid:48)

j · b(cid:48)
ji.

b(cid:48)
ji
2,λi
j)]].

i=1 g
j, ˆB(cid:48)

.

j, ˆB(cid:48)

5. Set r(cid:48)

– Let rj ← Zp, (B(cid:48)
– Create an argument (ψ(cid:48)

4. For i ∈ [n], let ci ←(cid:80)n
[[(Com1((cid:98)ck1; G1, . . . , Gn; 0),(cid:81)n

j, ˆψ(cid:48)
k=i Gkbk.

6. Create

1, r(cid:48)

0, r(cid:48)

(Crot, ˆCrot, ˜Crot) ← Com1(ck1; c2, . . . , cn−1, cn, c1; r(cid:48)
2).
×
×
1 , ˆψ
1 )

argument

an

2 ← Zp, (B†, ˆB†) ← Com1((cid:98)ck1; G1b1, . . . , Gnbn; r(cid:48)

i=1 gGi
2,λi
×
×
7. Create an argument (A∗, ˆA∗, ψ
2 , ˆψ
2 , ψrot
×
×
3 , ˆψ
for
8. Create
3 )

an argument

(ψ

[[(C/B†, ˆC/ ˆB†)]].

(ψ

[[((cid:81)nv

0), (C, ˆC, ˜C) ← Com1(ck1; c; r(cid:48)
j)G(cid:48)

j ,(cid:81)nv
[[(Crot, ˆCrot)]] ◦ [[(Com1((cid:98)ck1; 1, 1, . . . , 1, 0; 0),(cid:81)n−1
4 ) for [[(C, ˆC)]] ◦ [[(Com1((cid:98)ck1; 1, 0, . . . , 0, 0; 0), g2,λ1 )]] = [[(Au−1

2 ) for rot([[(C, ˜C)]]) = [[(Crot, ˆCrot, ˜Crot)]].

)]] = [[(B†, ˆB†)]].
2 , ˆψrot

j=0(B(cid:48)

j=0( ˆB(cid:48)

, ˆAu−1

j)G(cid:48)

for

c

)]].

1), and
◦

j )]]

i=1 g2,λi )]] =

×
×
4 , ˆψ
9. Create an argument (ψ
10. Create an argument ψce
5 that Ac commits to the same value that (Ag, Af , Ah) encrypts.
11. Send

c

ψ ←((B
(cid:48)
(cid:48)
(cid:48)
(cid:48)
(cid:48)
j, ˆψ
, ˆB
j, ˆB
j)j∈[0,nv ], (B
j2, ψ
j, B
×
×
∗
∗
×
×
3 , ˆψ
2 , ˆψrot
2 , ˆψ
, ˆA
2 , ψrot
3 ), (ψ
(A

2 ), (ψ

, ψ

†

†

×
×
4 , ˆψ
4 ), ψce
5 )

), (C, ˆC, ˜C), (Crot, ˆCrot, ˜Crot), (ψ

×
×
1 , ˆψ
1 ),

Veriﬁcation V(crs; (pk, Ag, Af , Ah, Ac, ˆAc), ψ): V does the following.

to V.

1. For j ∈ [0, nv] do:

j, ˆψ(cid:48)

j, g2) = ˆe(g1, B(cid:48)

(a) Check that ˆe(B(cid:48)
(b) Verify (ψ(cid:48)

j2) and ˆe(B(cid:48)
j) for inputs as speciﬁed above.
2. For K ∈ {Ac, B†, C, Crot}: check that ˆe(K, ˆg2) = ˆe( ˆK, g2).
3. For K ∈ {C, Crot}: check that ˆe(K, ˜g2) = ˆe( ˜K, g2).
×
×
2 , ˆψ
2 , ψrot
4. Verify the arguments (ψ

×
×
1 ), (A∗, ˆA∗, ψ
1 , ˆψ

j, ˆg2) = ˆe( ˆB(cid:48)

2 , ˆψrot

j, g2).

2 ), (ψ

×
×
3 , ˆψ
3 ), (ψ

×
×
4 , ˆψ
4 ), ψce

5 for inputs as speciﬁed

above.

Protocol 3: The new range proof for some u > 1.

12

Acknowledgments. The ﬁrst author was supported by European Social Fund’s Doctoral Studies and
Internationalization Programme DoRa. The second and the third authors were supported by Estonian
Science Foundation, grant #8058, and European Union through the European Regional Development
Fund.

References

BBS04.

BN05.

CCs08.

CDS94.

CLs10.

Di 02.

CGS97.

CHL05.

ACP09. Michel Abdalla, C´eline Chevalier, and David Pointcheval. Smooth Projective Hashing for Condition-
ally Extractable Commitments. In Shai Halevi, editor, CRYPTO 2009, volume 5677 of LNCS, pages
671–689, Santa Barbara, California, USA, August 16–20, 2009. Springer, Heidelberg. 2, 6
Dan Boneh, Xavier Boyen, and Hovav Shacham. Short Group Signatures. In Matthew K. Franklin,
editor, CRYPTO 2004, volume 3152 of LNCS, pages 41–55, Santa Barbara, USA, August 15–19, 2004.
Springer, Heidelberg. 1, 2, 2
Paulo S. L. M. Barreto and Michael Naehrig. Pairing-Friendly Elliptic Curves of Prime Order. In Bart
Preneel and Staﬀord E. Tavares, editors, SAC 2005, volume 3897 of LNCS, pages 319–331, Kingston,
ON, Canada, August 11–12, 2005. Springer, Heidelberg. 2
Jan Camenisch, Raﬁk Chaabouni, and abhi shelat. Eﬃcient Protocols for Set Membership and Range
Proofs. In Josef Pieprzyk, editor, ASIACRYPT 2008, volume 5350 of LNCS, pages 234–252, Mel-
bourne, Australia, December 7–11, 2008. Springer, Heidelberg. 1
Ronald Cramer, Ivan Damg˚ard, and Berry Schoenmakers. Proofs of Partial Knowledge and Simpliﬁed
Design of Witness Hiding Protocols. In Yvo G. Desmedt, editor, CRYPTO 1994, volume 839 of LNCS,
pages 174–187, Santa Barbara, USA, August 21–25 1994. Springer, Heidelberg. 1
Ronald Cramer, Rosario Gennaro, and Berry Schoenmakers. A Secure and Optimally Eﬃcient Multi-
Authority Election Scheme.
In Walter Fumy, editor, EUROCRYPT 1997, volume 1233 of LNCS,
pages 103–118, Konstanz, Germany, 11–15 May 1997. Springer, Heidelberg. 1
Jan Camenisch, Susan Hohenberger, and Anna Lysyanskaya. Compact E-Cash. In Ronald Cramer,
editor, EUROCRYPT 2005, volume 3494 of LNCS, pages 302–321, Aarhus, Denmark, May 22–26,
2005. Springer, Heidelberg. 1
Giovanni Di Crescenzo, Javier Herranz, and Germ´an S´aez. Reducing Server Trust in Private Proxy
Auctions.
In TrustBus 2004, volume 3184 of LNCS, pages 80–89, Zaragoza, Spain, August 30 –
September 1, 2004. Springer, Heidelberg. 1
Raﬁk Chaabouni, Helger Lipmaa, and abhi shelat. Additive Combinatorics and Discrete Logarithm
Based Range Protocols. In Ron Steinfeld and Philip Hawkes, editors, ACISP 2010, volume 6168 of
LNCS, pages 336–351, Sydney, Australia, July 5–7, 2010. Springer, Heidelberg. 1, 6, 6
Giovanni Di Crescenzo. Equivocable And Extractable Commitment Schemes.
In Stelvio Cimato,
Clemente Galdi, and Giuseppe Persiano, editors, Security in Communication Networks, 3rd Interna-
tional Conference, SCN 2002, volume 2576 of LNCS, pages 74–87, Amalﬁ, Italy, September 11–13,
2002. Springer Verlag. 2, 6
Ivan Damg˚ard and Mads Jurik. A Generalisation, a Simpliﬁcation and Some Applications of Paillier’s
Probabilistic Public-Key System. In Kwangjo Kim, editor, PKC 2001, volume 1992 of LNCS, pages
119–136, Cheju Island, Korea, February 13–15, 2001. Springer, Heidelberg. 1
Cynthia Dwork and Moni Naor. Zaps and Their Applications. In FOCS 2000, pages 283–293, Redondo
Beach, California, USA, November 12–14, 2000. IEEE Computer Society Press. 1
Michael Elkin. An Improved Construction of Progression-Free Sets. Israeli Journal of Mathematics,
184:93–128, 2011. 2
Jens Groth. Honest Veriﬁer Zero-Knowledge Arguments Applied. PhD thesis, University of ˚Arhus,
Denmark, October 2004. 1
Jens Groth. Short Pairing-Based Non-interactive Zero-Knowledge Arguments.
In Masayuki Abe,
editor, ASIACRYPT 2010, volume 6477 of LNCS, pages 321–340, Singapore, December 5–9 2010.
Springer, Heidelberg. 1, 2, 3, 5
Jens Groth. Eﬃcient Zero-Knowledge Arguments from Two-Tiered Homomorphic Commitments. In
Dong Hoon Lee and Xiaoyun Wang, editors, ASIACRYPT 2011, volume 7073 of LNCS, pages 431–448,
Seoul, South Korea, December 4–8, 2011. Springer, Heidelberg. 1
Jens Groth and Amit Sahai. Eﬃcient Non-Interactive Proof Systems for Bilinear Groups. Technical
Report 2007/155, International Association for Cryptologic Research, April 27, 2007. Available at
http://eprint.iacr.org/2007/155 (version 20100222:192509), retrieved in December, 2011. 5
Jens Groth and Amit Sahai. Eﬃcient Non-interactive Proof Systems for Bilinear Groups. In Nigel
Smart, editor, EUROCRYPT 2008, volume 4965 of LNCS, pages 415–432, Istanbul, Turkey, April 13–
17, 2008. Springer, Heidelberg. 1, 5

DN00.

Elk11.

Gro04.

Gro10.

GS07.

GS08.

CHS04.

DJ01.

Gro11.

13

HSV06.

Florian Hess, Nigel P. Smart, and Frederik Vercauteren. The Eta Pairing Revisited. IEEE Transactions
on Information Theory, 52(10):4595–4602, 2006. 2

Lip03.

LAN02. Helger Lipmaa, N. Asokan, and Valtteri Niemi. Secure Vickrey Auctions without Threshold Trust. In
Matt Blaze, editor, FC 2002, volume 2357 of LNCS, pages 87–101, Southhampton Beach, Bermuda,
March 11–14, 2002. Springer-Verlag. 1, 6, 6
Helger Lipmaa. On Diophantine Complexity and Statistical Zero-Knowledge Arguments. In Chi Sung
Laih, editor, ASIACRYPT 2003, volume 2894 of LNCS, pages 398–415, Taipei, Taiwan, November
30–December 4, 2003. Springer, Heidelberg. 1, 6
Helger Lipmaa. Progression-Free Sets and Sublinear Pairing-Based Non-Interactive Zero-Knowledge
Arguments. Technical Report 2011/009, International Association for Cryptologic Research, Jan-
uary 5, 2011. Available at http://eprint.iacr.org/2011/009. 3
Helger Lipmaa. Progression-Free Sets and Sublinear Pairing-Based Non-Interactive Zero-Knowledge
Arguments. In Ronald Cramer, editor, TCC 2012, volume 7194 of LNCS, pages ?–?, Taormina, Italy,
March 18–21, 2012. Springer, Heidelberg. 1, 1, 2, 2, 1, 3, 2, 3, 2, 3.1, 3.2, 4, 5, 5, 6

Lip11.

Lip12.

PSNB11. C. C. F. Pereira Geovandro, Marcos A. Simpl´ıcio Jr., Michael Naehrig, and Paulo S. L. M. Barreto. A
Family of Implementation-Friendly BN Elliptic Curves. Journal of Systems and Software, 84(8):1319–
1326, 2011. 2

San11.

RKP09. Alfredo Rial, Markulf Kohlweiss, and Bart Preneel. Universally Composable Adaptive Priced Obliv-
ious Transfer. In Hovav Shacham and Brent Waters, editors, Pairing 2009, volume 5671 of LNCS,
pages 231–247, Palo Alto, CA, USA, August 12–14, 2009. Springer, Heidelberg. 1
Tom Sanders. On Roth’s Theorem on Progressions. Annals of Mathematics, 174(1):619–636, July
2011. 2
Terrence Tao and Van Vu. Additive Combinatorics. Cambridge Studies in Advanced Mathematics.
Cambridge University Press, 2006. 2

TV06.

YHM+09. Tsz Hon Yuen, Qiong Huang, Yi Mu, Willy Susilo, Duncan S. Wong, and Guomin Yang. Eﬃcient
Non-interactive Range Proof. In Hung Q. Ngo, editor, COCOON 2009, volume 5609 of LNCS, pages
138–147, Niagara Falls, NY, USA, July 13–15, 2009. Springer, Heidelberg. 1, 4, 4, 1

A Proof of Thm. 1

Proof. Perfect completeness: correctness veriﬁcations are straightforward. Clearly,

ˆe(f, Cf ) = ˆe(f, gRf
Analogously, ˆe(h, Ch) = ˆe(ψh, g2) · ˆe(Ah, g2,λ1 ). Finally,

) = ˆe(f, gRf

2 grf
2,λ1

2,λ1

2 ) · ˆe(f, grf

) = ˆe(f Rf , g2) · ˆe(f rf , g2,λ1 ) = ˆe(ψf , g2) · ˆe(Af , g2,λ1) .

ˆe(Acψ−1

g , g2) · ˆe(g1, Cf Ch) =ˆe(gr
=ˆe(ga

−r−Rf−Rh
1

· g
−Rf−Rh
1

· g

1ga

1,λ1

1,λ1

, g2) · ˆe(g1, gRf +Rh

2

, g2) · ˆe(gRf +Rh

, g2) · ˆe(grf +rh

1

) · ˆe(g1, grf +rh
2,λ1
, g2,λ1)

)

1
, g2,λ1 ) .

=ˆe(ga

1 , g2,λ1 ) · ˆe(grf +rh

1

, g2,λ1 ) = ˆe(grf +rh+a

1

Computational Soundness: By the {λ1}-PKE assumption in G1/G2, one can open the next values:

) ,

1,λ1
1,g/c) ,

(Ag/Ac, ˚Ag/c) =((g1g−1
1 ,˚ga(cid:48)(cid:48)

1,λ1

1,λ1

1ga

(Ac, ¯Ac) =(gr

1 ¯ga
, ¯gr
)a(cid:48)
,˚ga(cid:48)
(Ag, ˚Ag) =(ga(cid:48)(cid:48)
1 ) ,
(Af , ˚Af ) =(f rf , ˚f rf ) ,
(Ah, ˚Ah) =(hrh,˚hrh ) ,
r(cid:48)
(Cf , ¯Cf ) =(gRf
2 g
2,λ1
2 gr(cid:48)
(Ch, ¯Ch) =(gRh
1 ,˚gr(cid:48)(cid:48)
(ψg, ˚ψg) =(gr(cid:48)(cid:48)
1 ) ,
r(cid:48)(cid:48)
r(cid:48)(cid:48)
(ψf , ˚ψf ) =(g
1 ,˚g
1,f ) , and
1 ,˚gr(cid:48)(cid:48)
(ψh, ˚ψh) =(gr(cid:48)(cid:48)

1,h) .

2,λ1

h

h

h

a

a

f

f

f

f

r(cid:48)
, ¯gRf
2 ¯g
2,λ1
2 ¯gr(cid:48)
, ¯gRh

2,λ1

h

) ,

) ,

14

1ga

Since Ac = gr

, Ag = ga(cid:48)(cid:48)

1 = gr+a(cid:48)
. Thus, if
a (cid:54)= a(cid:48), one can compute xλ1 ← (a(cid:48)(cid:48) − r − a(cid:48))/(a − a(cid:48)), and from this compute x and thus break the
{λ1}-PSDL assumption. (To verify whether x is the correct root, one can check that gxλ1
1 = g1,λ1.) Thus
a = a(cid:48), and thus also a(cid:48)(cid:48) = r + a and Ag = gr+a

and Ag/Ac = (g1g−1

, we have that ga(cid:48)(cid:48)

ga−a(cid:48)

)a(cid:48)

1,λ1

1,λ1

1,λ1

1

1

.

1

Due to Cf = gRf
2 g

r(cid:48)
2,λ1

f

, ψf = g

r(cid:48)(cid:48)
1 , Af = f rf and ˆe(f, Cf ) = ˆe(ψf , g2) · ˆe(Af , g2,λ1 ), we have

f

ˆe(f, gRf
2 g

r(cid:48)
2,λ1

f

) = ˆe(g

r(cid:48)(cid:48)
1 , g2)ˆe(f rf , gxλ1

2

f

)

f + rf xλ1/sk1, or (rf − r(cid:48)

for unknown x. Taking the discrete logarithm of the both sides of the last equation, we get that Rf /sk1 +
r(cid:48)
f xλ1/sk1 = r(cid:48)(cid:48)
f , then we can compute
xλ1 , and ﬁnd from this x, and thus break the {λ1}-PSDL assumption. Thus, rf = r(cid:48)
f and therefore also
Cf = gRf

f · sk1. Thus, if rf (cid:54)= r(cid:48)

f )xλ1 = Rf − r(cid:48)(cid:48)

f

2 grf
2,λ1

. Moreover, ψf = g

r(cid:48)(cid:48)
1 = f Rf .
Analogously, we get that rh = r(cid:48)
Due to Cf = gRf

, Ch = gRh

2 grf
2,λ1

, g2) · ˆe(Ag, g2,λ1 ), we have

ˆe(ψgA−1

c

h and therefore Ch = gRh
1 grh
1,λ1

1 grh
1,λ1
1 , Ac = gr

, ψg = gr(cid:48)(cid:48)

a

and ψh = hRh .

1ga

1,λ1

, Ag = gr+a

1

and ˆe(g1, Cf Ch) =

ˆe(g1, gr+Rf +Rh+(rf +rh)xλ1

2

) = ˆe(gr(cid:48)(cid:48)

1 g−r

1 g−a

a

1,λ1

, g2) · ˆe(gr+a

1

, g2,λ1) = ˆe(gr(cid:48)(cid:48)

1

a −r+rxλ1

, g2)

1

, f rf , hrh ).

a = r + Rf + Rh. This means that Ac = grf +rh

for unknown x. Taking the discrete logarithm of both sides of the last equation, we get r + Rf + Rh +
a − r + rxλ1. Again, if rf + rh (cid:54)= r, then one can compute xλ1 and thus also x. Thus,
(rf + rh)xλ1 = r(cid:48)(cid:48)
r = rf + rh, and thus also r(cid:48)(cid:48)
and (Af , Ag, Ah) =
(grf +rh+a
Computational Zero-knowledge: we construct the next simulator (S1,S2). S1 creates a CRS
according to the protocol together with a trapdoor td = (αg, αf , αh, ¯α, αg,c, x). On input td, S2 creates
zf , zh ← Zp. He then sets Cf ← gzf
/Axλ1
.
He creates the knowledge elements ( ˚Ag, ˚Af , ˚Ah, ˚Ac, ˚ψg, ¯Cf , ˚ψf , ¯Ch, ˚ψh, ˚Ag/c) by using the trapdoor. For
example, ˚Ag/c ← (Ag/Ac)αg/c. One can now check that the veriﬁcation succeeds. For example,

h , and ψg ← gzf +zh

2 , ψh ← hzh /Axλ1

2 , ψf ← f zf /Axλ1

, Ch ← gzh

ga
1,λ1

1

1

g

f

ˆe(ψf , g2)ˆe(Af , g2,λ1) =ˆe(f zf /Axλ1

f

, g2) · ˆe(Af , g2,λ1) = ˆe(f zf , g2)/ˆe(Axλ1

f

, g2)ˆe(Af , g2,λ1 )

=ˆe(f zf , g2) = ˆe(f, Cf ) ,

and ﬁnally,

ˆe(Acψ−1

g , g2) · ˆe(g1, Cf Ch) = ˆe(g

−zf−zh
1

g Ac, g2) · ˆe(g1, gzf +zh
Axλ1

2

) = ˆe(Ag, g2,λ1 ) .

If the DLIN assumption is true, then (Ag, Af , Ah) is indistinguishable from an encryption of 0 ∈ [0, H],
(cid:117)(cid:116)
and thus the whole argument is computationally knowledge.

B Proof of Thm. 2
Proof. Perfect completeness: Recall that in the case of the product arguments, the inputs of P are
(A, ˆA, B, ˆB, B2, C, ˆC). Within this proof we say that (B, ˆB, B2) (assuming B2 is correctly deﬁned, that
is, ˆe(B, g2) = ˆe(g1, B2)) commits to the same values as (B, ˆB).
Since (B(cid:48)

The pairing veriﬁcations (for example, that ˆe(K, ˆg2) = ˆe( ˆK, g2)) hold by construction of the protocol.

ji then the argument (ψ(cid:48)

j) commits to (b(cid:48)

j, ˆψ(cid:48)

Note that ((cid:81)nv

j, ˆB(cid:48)

j=0(B(cid:48)

j)G(cid:48)

j ,(cid:81)nv

j1, . . . , b(cid:48)
j=0( ˆB(cid:48)

jn) for binary b(cid:48)
j)G(cid:48)

j ) commits to (b1, . . . , bn). Thus argument (ψ×

2 , ˆψ×

2 , ψrot

2 , ˆψrot

1 ) veriﬁes. Since
2 ) veriﬁes. Since (Crot, ˆCrot)

j) veriﬁes.
1 , ˆψ×

(Crot, ˆCrot) commits to a rotation of (C, ˆC), then (A∗, ˆA∗, ψ×
commits to (0, c1, . . . , cn−1) and (C/B†, ˆC/ ˆB†) commits to

(c1 − G1b1, c2 − G2b2, . . . , cn − Gnbn) = (0, c1, . . . , cn−1) ,

3 ) veriﬁes. Finally, since (u − 1)a =(cid:80)n

i=1 Gibi and cn =(cid:80)n

then (ψ×

3 , ˆψ×

i=1 Gibi, then (ψ×

4 , ˆψ×

4 ) veriﬁes.

15

Computational soundness: let A be a non-uniform PPT adversary who creates a statement
(pk, Ag, Af , Ah, Ac, ˆAc) and an accepting range proof ψ. By the DLIN assumption, the BBS cryptosystem
is IND-CPA secure, and thus the adversary obtains no information from (Ag, Af , Ah). By the Λ-PKE
assumption, there exists a non-uniform PPT extractor XA that, running on the same inputs and seeing
A’s random tape, extracts the following openings:

j; rj)for j ∈ [0, nv] ,

(B(cid:48)

(ψ×

1 ) =(

0) ,
1) ,

f(cid:48)
(×1,s)
g
2s

(Ac, ˆAc) =Com1((cid:98)ck1; a; r) ,
j) =Com1((cid:98)ck1; b(cid:48)
(B†, ˆB†) =Com1((cid:98)ck1; b†; r(cid:48)
j, ˆB(cid:48)
(C, ˆC) =Com1((cid:98)ck1; c; r(cid:48)
(Crot, ˆCrot) =Com1((cid:98)ck1; crot; r(cid:48)
(cid:89)
1 , ˆψ×
(A∗, ˆA∗) =Com1((cid:98)ck1; a∗; ra∗ ) ,
(cid:89)
2 , ˆψ×
(cid:89)
(cid:89)
(cid:89)

(cid:89)
(cid:89)
(cid:89)
(cid:89)
(cid:89)

f(cid:48)
(×2,s)
g
2s

f(cid:48)
(×3,s)
g
2s

3 , ˆψ×

2 , ˆψrot

2 ) =(

3 ) =(

2 ) =(

(ψ×

(ψ×

f(cid:48)
g
2s

f(cid:48)
˜g
2s

(ψrot

s∈ ˆΛ

s∈ ˆΛ

s∈ ˆΛ

s∈ ˆΛ

s∈ ˆΛ

s∈ ˜Λ

s∈ ˜Λ

s∈ ˆΛ

(rot2,s)

,

,

,

,

(ψ×

4 , ˆψ×

4 ) =(

f(cid:48)
(×4,s)
g
2s

,

s∈ ˆΛ

s∈ ˆΛ

2) ,
f(cid:48)
(×1,s)
ˆg
2s

f(cid:48)
(×2,s)
ˆg
2s

) ,

) ,

(rot2,s)

) ,

f(cid:48)
(×3,s)
ˆg
2s

f(cid:48)
(×4,s)
ˆg
2s

) , and

) .

j)G(cid:48)

j, ˆψ(cid:48)

Since ˆe(B(cid:48)

j ,(cid:81)nv

j, g2) = ˆe(g1, B(cid:48)

j) veriﬁes, then b(cid:48)

It will also create the openings that correspond to ψce
5 . If any of the openings fails, we are done. Since
˜Λ-PSDL assumption is supposed to hold, all the following is true. (If it is not true, one can eﬃciently
test it, and thus we have broken the PSDL assumption.)

j2) for j ∈ [0, nv], then (Bj1, ˆBj1, Bj2) commits to b(cid:48)
the ˆΛ-PSDL assumption, the fact that the adversary knows the openings of (B(cid:48)
and the last statement of Fact 2, since (ψ(cid:48)

i ∈ [1, n]. Thus, by Fact 6, b = (b1, . . . , bn) := ((cid:80)nv
((cid:81)nv

j=0 G(cid:48)
jb(cid:48)
j ) commits to b with bi ∈ [0, u − 1].

j. Therefore, due to
j, ˆB(cid:48)
j, ˆψ(cid:48)
j),
ji ∈ {0, 1} for all j ∈ [0, nv] and
jn) ∈ [0, u − 1]n, and thus
jb(cid:48)
j=0 G(cid:48)

j=0(B(cid:48)
Due to the ˆΛ-PSDL assumption, the fact that the adversary knows the openings of (B(cid:48)

1 ), and the last statement of Fact 2, since (ψ×
2 , ˆψ×

j), (B†, ˆB†)
†
and (ψ×
1 , ˆψ×
1 ) veriﬁes, then b
i = Gibi. Due to
the ˜Λ-PSDL assumption, the fact that the adversary knows the openings of (C, ˜C), (Crot, ˆCrot) and
(A∗, ˆA∗, ψ×
2 , ˆψ×
2 ) veriﬁes,
then crot,1 = cn and crot,i+1 = ci for i ≥ 1.
Due to the ˆΛ-PSDL assumption, the fact that the adversary knows the openings of (Crot, ˜Crot), (C, ˆC),
3 ) veriﬁes, then c1 − G1b1 = 0
(B†, ˆB†), and (ψ×
and ci − Gibi = crot,i = ci−1 for i > 1. Therefore, c1 = G1b1, c2 = G2b2 + G1b1, and by induction

2 ), and the last statement of Fact 2, since (A∗, ˆA∗, ψ×

3 ), and the last statement of Fact 2, since (ψ×

j1, . . . ,(cid:80)nv

j) and (ψ(cid:48)

j=0( ˆB(cid:48)

3 , ˆψ×

1 , ˆψ×

2 , ˆψrot

2 , ˆψrot

2 , ψrot

2 , ψrot

j, ˆB(cid:48)

j)G(cid:48)

3 , ˆψ×
i=1 Gibi for bi ∈ [0, u − 1].

j=1 Gibi for i ≥ 1. In particular, cn =(cid:80)n
ci =(cid:80)n
commits to (a, 0, . . . , 0) such that (u − 1)a = (cid:80)n

4 , ˆψ×

and (ψ×
a ∈ [0, H].

4 ), and the last statement of Fact 2, since (ψ×

Due to the ˆΛ-PSDL assumption, the fact that the adversary knows the openings of (C, ˆC), (Ac, ˆAc),
)
i=1 Gibi for bi ∈ [0, u − 1], and therefore by Fact 6,
5 veriﬁes, then (Ag, Af , Ah) encrypts a ∈ [0, H].

Due to the {λ1}-PSDL assumption and since ψce
Computational zero-knowledge: we construct the following simulator S = (S1,S2). First, S1
creates a correctly formed common reference string together with a simulation trapdoor td = (ˆα, ˜α, . . . , x).
After that, the prover creates a statement inpr := (pk, Ag, Af , Ah, Ac, ˆAc) and sends it to the simulator.
Second, S2(crs; inpr; td) uses a knowledge extractor to extract (a, r) from the prover’s random coins and

4 ) veriﬁes, then (Ac, ˆAc) = (gr

4 , ˆψ×

1 ˆga

1ga

, ˆgr

1,λ1

1,λ1

16

(Ac, ˆAc). Since we are only interested in the case of a honest prover, we have that a = (a, 0, . . . , 0) with
a ∈ [0, H]. Thus, using the fact that the knowledge commitment scheme is also trapdoor, the simulator
computes r(cid:48)(cid:48) ← axλn +r; clearly A = gr(cid:48)(cid:48)
1 . Since both r and r(cid:48)(cid:48) are uniformly random, r(cid:48)(cid:48) does not leak any
information on the prover’s input. After that, the simulator creates all commitments (B(cid:48)
j2)j∈[0,nv],
(B†, ˆB†), (C, ˆC, ˜C) and (Crot, ˆCrot, ˜Crot) as in the argument, but replacing a with 0 and r with r(cid:48)(cid:48). (Note
that all the mentioned commitments just commit to 0.) Thus, the simulator can simulate all product and
permutation arguments and the argument of Sect. 5. Clearly, this simulated argument ψsim is perfectly
(cid:117)(cid:116)
indistinguishable from the real argument ψ.

j, ˆB(cid:48)

j, B(cid:48)

C Proof of Thm. 3
Proof. The communication complexity: nv + 1 tuples (B(cid:48)
j2, ψj) (each has 2 elements of G1 and 3
elements of G2), and then 8 extra elements from G1, 3 Hadamard product arguments (2 elements from
G2 each), 1 permutation argument (2 elements from G1 and 4 elements from G2), and argument ψce (13
elements from G1 and 2 elements from G2). In total, thus 2(nv + 1) + 8 + 2 + 13 = 2nv + 25 elements
from G1 and 3(nv + 1) + 3 · 2 + 4 + 2 = 3nv + 15 elements from G2.

j, B(cid:48)

j, ˆB(cid:48)

The prover’s computational complexity is dominated by (nv + 1) + 3 = nv + 4 Hadamard product
arguments and 1 permutation argument (Θ(n2) scalar multiplications and bilinear-group n1+o(1) ex-
ponentiations each), that is in total Θ(n2 · nv) = Θ(n2 · log u) scalar multiplications and n1+o(1) log u
exponentiations.

The veriﬁer’s computational complexity is dominated by verifying nv + 4 Hadamard product argu-
ments (5 pairings each), 1 permutation argument (12 pairings), and the argument ψce (33 pairings). In
addition, the veriﬁer performs 2 · (2(nv + 1) + 6) = 4nv + 16 pairings. The total number of pairings is
(cid:117)(cid:116)
thus 9nv + 81. The rest follows.

17

