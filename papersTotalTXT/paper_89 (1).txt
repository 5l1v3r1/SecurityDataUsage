Sorting and Searching Behind the Curtain

Foteini Baldimtsi1 and Olga Ohrimenko2

1 Boston University, USA and University of Athens, Greece {foteini@bu.edu}

2 Microsoft Research, UK {oohrim@microsoft.com}

Abstract. We propose a framework where a user can outsource his data
to a cloud server in an encrypted form and then request the server to per-
form computations on this data and sort the result. Sorting is achieved
via a novel protocol where the server is assisted by a secure coproces-
sor that is required to have only minimal computational and memory
resources. The server and the coprocessor are assumed to be honest but
curious, i.e., they honestly follow the protocol but are interested in learn-
ing more about the user data. We refer to the new protocol as private
outsourced sorting since it guarantees that neither the server nor the
coprocessor learn anything about user data as long as they are non-
colluding. We formally deﬁne private outsourced sorting and present an
eﬃcient construction that is based on an encryption scheme with semi-
homomorphic properties.
As an application of our private sort we present MRSE: the ﬁrst scheme
for outsourced search over encrypted data that eﬃciently answers multi-
term queries with the result ranked using frequency of query terms in
the data, while maintaining data privacy.
Keywords: Private sort · privacy in the cloud · ranked search on en-
crypted data.

1

Introduction

Consider the following scenario: Mr. Smith owns an array of data elements A that
he outsources to an honest-but-curious untrusted party, Brad. Mr. Smith then
asks Brad to perform various linear operations on the elements of A resulting
in an array B and then, sort B and return the sorted result, Bsorted, back to
him. However, Mr. Smith does not trust Brad and wishes to keep A, B and
Bsorted secret. Thus, he decides to encrypt every element of A using a public
key semantically secure cryptosystem. To let Brad perform computations on the
encrypted array A, Mr. Smith can simply use a semi-homomorphic cryptosystem
that supports addition of ciphertexts. Hence, the remaining question is: how is
Brad going to sort the encrypted B?

If the array A was encrypted under a fully homomorphic encryption scheme
(FHE) [14, 28], then Brad could perform sorting himself. FHE allows one to per-
form both homomorphic addition and multiplication, thus, Brad could simply
translate a sorting network into a circuit and apply it to B. Unfortunately,
all known FHE schemes are still too far away from being practical for real
life applications and cannot be implemented by Brad. Hence, Brad suggests

to Mr. Smith to use order preserving encryption (OPE) [7] for A since this
makes sorting a trivial task for him. Mr. Smith gets excited but soon realizes
that an encryption scheme that supports homomorphic addition and compari-
son of ciphertexts is not secure even against a ciphertext attack (as shown by
Rivest et al. [26]). If Mr. Smith just wanted Brad to sort A, then OPE would
be suﬃcient but it is crucial to Mr. Smith that Brad can also perform certain
operations on A. Moreover, allowing Brad to learn the relative order of elements
in A violates owner’s privacy requirements.

Mr. Smith is determined to design a protocol for private outsourced sort-
ing that will be eﬃcient, preserve his data privacy and allow Brad to perform
certain computations on his data. Thus he decides to encrypt his data with a
semi-homomorphic cryptosystem and add another party to the model: Angelina.
Angelina is given the decryption key and her sole role is to help Brad with sort-
ing. Mr. Smith assumes that Brad and Angelina are not colluding with each other
but both are interested in learning more about his data. Hence, he extends his
privacy requirements as follows: after Brad’s and Angelina’s interaction Brad re-
ceives Bsorted which is the sorting of an encrypted B, while neither of them learns
anything about the plaintext values of B nor Bsorted. It follows from the privacy
requirement that Angelina never sees an encryption of neither B nor Bsorted,
otherwise she could trivially decrypt them.

The Brad and Angelina model is often encountered in reality. We can see
Brad as the provider of cloud storage and computation (i.e., cloud server) who
is trusted to perform operations on clients’ data but at the same time may be
curious to learn something about them. Angelina models a secure coprocessor
(e.g., the IBM PCIe3 or the Freescale C29x4) that resides in the cloud server and
is invoked only to perform relatively small computations. Secure coprocessors
provide isolated execution environments, which is important for our model since
it ensures that the two parties are separated. We note that the assumption of
non-collusion is justiﬁed since the cloud provider and secure coprocessor usually
are supplied by diﬀerent companies and, hence, have also commercial interests
not to collude.

In this paper, we present private outsourced sort executed by two
parties such that neither of them learns anything about the data in-
volved. This setting is perfect for letting one use not only storage but also
computing services of the cloud environment without sacriﬁcing privacy. We
give the formal deﬁnition and present an eﬃcient construction that implements
private outsourced sort by relying only on additive homomorphic properties of
an encryption scheme. Sorting is, arguably, one of the most common and well
studied computations [18] over data in the “before cloud era” which indicates
that it will be of interest as an outsourced computation to the cloud. Our model
is of particular interest since it does not only allow the cloud server to privately
and eﬃciently sort encrypted data, but also allows certain computations on the

3

4

http://www-03.ibm.com/security/cryptocards/pciecc/overview.shtml

http://www.freescale.com/webapp/sps/site/prod_summary.jsp?code=C29x

data. Hence, it can be a useful tool for answering sophisticated queries on an
encrypted database and, for example, returning top results satisfying the query.
The main component of most of the sorting algorithms is the pairwise com-
parison of elements. A few methods for comparison of encrypted data have been
proposed in the literature, where the most well known ones either depend on
homomorphic encryption or on garbled circuits. The protocol by Veugen [29] de-
pends on homomorphic encryption and presents a private comparison protocol
where the cloud server learns the result of the comparison, while the coprocessor
learns nothing. To use a garbled circuits solution, as Bost et al. [8] suggest, one
could use the comparison circuit by Kolesnikov et al. [19] in combination with
the eﬃcient garbled circuit implementation of Bellare et al. [6] and an oblivious
transfer protocol like the one due to Asharov et al. [3]. However, this solution
requires the parties to generate a fresh circuit for each pairwise comparison. For
our construction we choose to use homomorphic encryption techniques due to
its simplicity and eﬃciency.
Outsourced Ranked Text Search. We give a concrete application of our
new sorting framework through the problem of outsourcing ranked search over
encrypted data to the cloud. The goal is to rank the result according to its
relevance to the query by using the standard frequency (tf) and inverse document
frequency (idf) method [30]. In order to perform a ranked search of this type
eﬃciently, a search index is created in advance where an idf of every term in every
document in the collection is stored. In the cloud based information retrieval
setting, where the cloud server is not trusted, the client outsources the search
index to the server in an encrypted format and then submits keyword search
queries to the server. If we only allow single term queries then a solution is
relatively easy: the client creates the search index where each term is stored
with a list of documents sorted by relevance. Then, he encrypts the index using
some symmetric searchable encryption scheme (SSE) and outsources it to the
server. When the client wants to search for a term, he submits a trapdoor to
the server, who locates the term in the index and returns the encrypted list of
documents to the user.

However, precomputing sorted results becomes infeasible and not scalable
when the system is required to handle multi-term queries, since the result de-
pends on all the keywords in the query which is not known in advance. Hence,
the client has to upload the search index where frequencies (idfs) for every term
are ordered according to document identiﬁers. When querying the system, the
client creates a trapdoor for every term in the query and submits them to the
server. The server then locates the corresponding rows in the SSE encrypted
search index and is left with two tasks: (a) add the located rows of encrypted
frequencies together in order to compute the score of every document w.r.t. the
query, and (2) sort the resulting list of encrypted scores.

It is easy to see that our private outsourced sorting is the perfect tool for the
scenario described above. The client can encrypt the keyword frequencies using
a semi-homomorphic encryption scheme (e.g., Paillier [25]) and then outsource
them to the cloud server, S1. S1 is equipped with a secure coprocessor, S2, who

Fig. 1: Ranked Multi-keyword Searchable Encryption (MRSE) Model.

stores the decryption key. Our mechanism allows the cloud server to ﬁrst add
the encrypted frequencies of the keywords in the query and then sort them with
the help of S2. We refer to our proposed construction as Multi-keyword Ranked
Searchable Encryption (MRSE) and give its overview in Figure 1.
Our contributions are summarized below:

– Formally deﬁne private outsourced sorting (Deﬁnition 1) and present a sim-

ulation based privacy deﬁnition (Deﬁnition 2).

– We present an eﬃcient implementation of private outsourced sorting in Sec-
tion 3.2 that requires O(N (log N )2) time for sorting, where N is the total
number of elements to be sorted.

– In Section 4.1 we present MRSE, the ﬁrst system that eﬃciently supports
multi-keyword search and computes a ranked result based on word frequen-
cies in a secure and private way.

2 Preliminaries

In Table 1 we summarize the notation used throughout the paper. Then, we
present the building blocks used for our construction.

2.1 Homomorphic Cryptosystem Protocols

Paillier Cryptosystem The Paillier cryptosystem [25] is a semantically secure
public key encryption scheme based on the Decisional Composite Residuosity as-
sumption. We use [m] to denote an encryption of a message under Paillier cryp-
tosystem with a public, secret key pair KP = (PKP, SKP). Paillier cryptosystem
is homomorphically additive, that is, [m1] · [m2] = [m1 + m2].

Generalized Paillier Our construction relies on the generalization of the Pail-
lier cryptosystem introduced by Damg˚ard and Jurik [13] along with its special
property that allows to doubly encrypt messages and use the additive homomor-
phism of the inner encryption layer under the same secret key [1, 20]. By [m] we
denote an encryption of m using the ﬁrst layer (basic Paillier encryption) and
by [[m]] we denote encryption of m using the second layer.

S1 Queries	  S2 Private	  sort	  Homomorphic	  addi3on	  Knows	  	  decryp3on	  key	  Encrypted	  keyword	  &	  frequency	  index	  Ranked	  encrypted	  document	  ids	  Client Table 1: Notation.

Symbol

k

Meaning
security parameter

KQR = (PKQR, SKQR) QR public/secret keys

KP = (PKP, SKP) Paillier public/secret keys
[m], [[m]],(cid:107)m(cid:107)

m encrypted using ﬁrst and second layers of Paillier, and QR

GenStE, EStE, SKStE StE keygen, encr. and secret key
D = {D1, . . . , DN} document collection of size N

M
t, T

q = (t1, . . . , tlq )

F
I

number of unique terms/keywords in D
term/keyword and its StE trapdoor
query of lq terms
frequency table
secure search index

The extension allows a ciphertext of the ﬁrst layer to be treated as a plaintext
at the second layer. Moreover, the nested encryption preserves the structure over
inner ciphertexts and allows one to manipulate it as follows [1]:

[[[m1]]][m2] = [[[m1][m2]]] = [[[m1 + m2]]].

We note that this is the only homomorphic property that our protocols rely on
(i.e., we do not require support for ciphertext multiplication).

Private Selection of Encrypted Data Additive homomorphism and gener-
alized Paillier encryption can be used to select one of two plaintexts without
revealing which one was picked. We adopt this operation from [1] (with sev-
eral modiﬁcations) and deﬁne [[[c]]] ← EncSelect(PKP, SKP, [a], [b], [[v]]5) where
(PKP, SKP) is a pair of Paillier public, secret keys as before, a and b are the two
plaintext values and v is a bit that indicates whether a or b should be returned. If
v is 0, EncSelect returns a re-encryption of a, otherwise it returns a re-encryption
of b. Hence, EncSelect imitates the computation c = (1 − v) × a + v × b but over
ciphertexts as follows:

EncSelect ([a], [b], [[v]]) = ([[1]][[v]]−1)[a][[v]][b] = [[(1 − v)[a] + v[b]]] = [[[c]]].

Note that the result c is doubly encrypted. For our purposes we require the
output values to be encrypted using the ﬁrst layer of Paillier encryption only.
Simply sending [[[c]]] for re-encryption would be insecure since S2 would learn
the value of c. Instead, we propose a protocol StripEnc, where S1 randomizes the
encryption of the value x he wants S2 to re-encrypt, receives the re-encryption
and removes the randomization. Hence, when S2 decrypts the element he receives

5

We note that v has to be encrypted using the second layer of Paillier in order to use the homo-
morphic properties of the cryptosystem.

Table 2: [x] ← StripEnc(PKP, SKP, [[[x]]]): Interactive protocol between S1
and S2 for stripping oﬀ one layer of Paillier encryption.

S1(PKP, [[[x]]])
pick r ∈ {0, 1}(cid:96)+1
[[[x + r]]] := [[[x]]][r]

[x] := [x + r][r]−1

S2(PKP, SKP)

[[[x + r]]]
−−−−−→

[x + r]←−−−−

decrypt [[[x + r]]]
encrypt [x + r]

a random value and learns nothing about x. The complete protocol StripEnc is
presented in Table 2 where we rely on the homomorphic properties of layered
Paillier encryption.

We analyze the privacy guarantees of StripEnc and EncSelect in the full ver-
sion of the paper [4] and show that each primitive can be simulated due to
semantical properties of Paillier encryption.

Private Comparison of Encrypted Data In this work, we are interested in
the following private comparison setting: the ﬁrst server S1 owns two encrypted
numbers [a] and [b] and the second server S2 owns the secret key SKP. The goal
of the protocol is for S1 to obtain the encryption of the relation between a and b
without learning neither the actual numbers nor the comparison result v, where
v = 1 if a ≥ b and v = 0, otherwise. We also require S2 to learn nothing about
the relation between a and b but just help S1 to obtain an encryption of the
comparison result. For this purpose, we adapt the protocol of Bost et al. [8] and
deﬁne [[v]] ← EncCompare(PKP, SKP, PKQR, SKQR, [a], [b]), an interactive compar-
ison protocol between S1 and S2 that gives the above security guarantees.

The protocol is given in Table 3 and it proceeds as follows. S2 knows the en-
cryption and decryption keys for both Paillier and QR, (PKP, SKP, PKQR, SKQR),
while S1 knows the corresponding public keys (PKP, PKQR) and two values a and
b encrypted under Paillier’s scheme. S1 ﬁrst computes [z] = [a]·[b]−1·[2(cid:96)] mod n2
and blinds it with a random value r before sending it to S2 (or else S2 would
learn the comparison result). S2 computes ˜d = d mod 2(cid:96), S1 similarly computes
˜r = r mod 2(cid:96) and they engage in a private input comparison protocol (we can
use the DGK protocol [12] as suggested by Bost et al. [8]) that compares ˜d and
˜r. At the end of this protocol, S1 receives an encrypted bit λ that shows the
relation between ˜d and ˜r (λ = 1 ⇔ ˜d < ˜r). The output λ from the private input
comparison protocol is encrypted using QR scheme. Finally, S1 computes the
most signiﬁcant bit of z, denoted by v, by computing (cid:107)v(cid:107) = (cid:107)d(cid:96)(cid:107)·(cid:107)r(cid:96)(cid:107)·(cid:107)λ(cid:107). The
important security property of this protocol is that S1 never sees the comparison
result in the clear and S2 never receives an encryption of it.

Table 3: [[v]] ← EncCompare(PKP, SKP, PKQR, SKQR, [a], [b]): Interactive Private Com-
parison between two parties S1 and S2 such that only S1 learns an encryption of the
comparison bit [[v]]. For simplicity, QR keys are omitted when EncCompare is called
from private sort protocol in Table 5. This protocol is an adaptation of the comparison
protocol from [8].

S2(PKP, SKP, PKQR, SKQR)

S1(PKP, PKQR, [a], [b])
[z] := [2(cid:96)] · [a] · [b]−1 mod n2
pick r ∈ {0, 1}(cid:96)+k.
[d] := [z] · [r] mod n2

[d]−→

˜r := r mod 2(cid:96)

(cid:107)λ(cid:107) ← Compare ˜r, ˜d
−−−−−−−−−−−−−−−→
←−−−−−−−−−−−−−−−

(cid:107)d(cid:96)(cid:107)←−−

decrypt [d]
˜d := d mod 2(cid:96)

encrypt d(cid:96)

encrypt r(cid:96)
(cid:107)v(cid:107) := (cid:107)d(cid:96)(cid:107) · (cid:107)r(cid:96)(cid:107) · (cid:107)λ(cid:107)

[[v]] ← ReEncryptBit(PKP, SKP, PKQR, SKQR,(cid:107)v(cid:107))
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→
←−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

The above protocol returns as a result bit v encrypted using QR cryptosys-
tem, (cid:107)v(cid:107), for which only S2 knows the secret key SKQR. However, for the purpose
of our sorting task (where we require private comparison and a call to EncSelect)
S1 needs to know this bit encrypted using second layer of generalized Paillier
cryptosystem, that is, [[v]]. Below we introduce [[v]] ← ReEncryptBit(PKP, SKP,
PKQR, SKQR,(cid:107)v(cid:107)) protocol to securely re-encrypt the bit v such that neither S1
nor S2 learns its value. The privacy guarantees of the complete EncCompare can
be found in the full version of the paper [4].

equal to v ⊕ 0 and v ⊕ 1, respectively.

The ReEncryptBit protocol consists of the following steps:
– S1 picks a random bit r.
– S1 computes two values (cid:107)sr(cid:107) := (cid:107)v(cid:107) · (cid:107)0(cid:107) and (cid:107)s1−r(cid:107) := (cid:107)v(cid:107) · (cid:107)1(cid:107) which are
– S1 sends (cid:107)s0(cid:107) and (cid:107)s1(cid:107) to S2 (i.e., using r as a secret permutation).
– S2 decrypts them (always gets a “0” and a “1” in an order that is independent
of v), re-encrypts them using second layer of Paillier scheme and sends them
back to S1 in the same order as he received them.

– Given that S1 knows the permutation bit r, he outputs [[sr]] which corre-

sponds to the relation between a and b.

2.2 Searchable Encryption

Symmetric searchable encryption (SSE) allows a user that has in his possession
a collection of documents D = {D1, . . . , DN} to compute a “secure search in-
dex”, I, over these documents and then outsource the index to the server. The

server should be able to search on I without learning anything about the actual
collection D. In traditional deﬁnitions of searchable encryption the user gives as
input the actual document collection and his SSE secret key and receives back
a secure index I and a set of ciphertexts [11]. Here we consider a generalized
notion of SSE called: structured encryption (StE), that was given by Chase and
Kamara [10] and allows SSE for arbitrarily-structured data. In particular, a data
type T is deﬁned by a universe U = {Uk}k∈Z and an operation Query: U×Q → R
with Q = {Qk}k∈N being the query space and R = {Rk}k∈N being the response
space, where k is the security parameter. The StE scheme then consists of the
following algorithms:
SKStE ← Gen StE(1k) run by the owner of the data. The output is owner’s secret
I ← EStE(SKStE, δ) run by the owner to encrypt a data structure δ of type T ,
under his secret key SKStE. The output is the secure index (encrypted data
structure) I sent to the server.
T ← Trpdr (SKStE, t) is a deterministic algorithm run by the owner to generate
a trapdoor T for a query t ∈ Q. It outputs either T or the failure symbol ⊥.
a ← Search(I, T ) is run by the server to perform a search for a trapdoor T and
outputs an answer a ∈ R.

key SKStE for the security parameter k.

The construction of ranked search discussed in Section 4.2 uses a dictionary data
type for StE. In particular, the keys (or queries) of a dictionary are keywords
of the document collection D. The value (or a response) that corresponds to a
particular keyword in the dictionary is a sequence of pairs of document ids and
encrypted frequency scores.

2.3 Text Search and Ranking

We represent a document collection using an inverted index [30]. Each unique
term, or keyword, t appearing in the collection is associated with a set of doc-
ument ids Jt, where each document id d ∈ Jt corresponds to a document con-
taining t. We refer to Jt as a posting list of term t.

We consider free text queries [21]. A free text query q is a set of terms and
the result to q is a set of documents Jq that contain at least one of the terms in

q. We can deﬁne Jq in terms of posting lists as Jq =(cid:83)∀t∈q Jt.

In this paper we use a common ranking of search results based on frequency
of query terms in each document and the collection, namely tf-idf [30]. Let N be
the number of documents in the collection and cft be the frequency of term t in
the collection then inverse document frequency, idf, is deﬁned as: idft = log N
.
cft
Document frequency of term t in document d is deﬁned as: tf-idft,d = tft,d × idft,
where tft,d is frequency of term t in document d. If a document d does not
contain t, tf-idft,d = 0.
Given a free text query q for each document d ∈ Jq a score based on fre-
t∈q tf-idft,d. Documents in Jq can then
be sorted according to the output of the score function. We use F to denote the
frequency table of all tf-idft,d entries including zero entries.

quencies is computed as score(q, d) =(cid:80)

3 Private Sort

In this section we deﬁne a new tool for secure outsourced computation: a private
sort, or private outsourced sort, protocol and present its eﬃcient construction.

3.1 Model
Private sort6 is executed between two parties S1 and S2 as follows. S1 has an
array A encrypted using a secret key SK that is known to S2 but not S1. The goal
of private sort is for S1 to obtain B, a re-encryption of a sorted array A, such
that neither S1 nor S2 learn anything about the plaintext values of A (e.g., their
initial order, frequency of the values) while running the protocol. We consider
the honest-but-curious model: our servers honestly follow the protocol but might
try to analyze the protocol transcript to infer more information about the data
in the array. We formally capture the deﬁnition of private sort below.

Deﬁnition 1. (EncSort) An encrypted sorting functionality EncSort(PK, SK, A)
takes as input a public/secret key pair (PK,SK) of a semantically secure cryp-
tosystem {GenSS, ESS, DSS}, and an array A = [ESS(vi)]i∈{1,N} of N elements
where each element is encrypted individually using PK. Let π be a permutation of
indices 1 to N that corresponds to the indices of A’s elements sorted using its un-
encrypted values vi. Then, the output of EncSort is an array B = [ESS(v(cid:48)
j)]j∈{1,N}
j = vπ(i) and i ∈ {1, N}.
where v(cid:48)
In the deﬁnition above, though v(cid:48)
j = vπ(i), it holds with very high probability
j) (cid:54)= ESS(vπ(i)) since fresh randomness is used during re-encryption.
that ESS(v(cid:48)
We note that Deﬁnition 1 can be easily expanded to take as input an array A
that stores (key, value) pairs and the output is required to be sorted using values.
We describe the privacy property of the encrypted sorting functionality stated
above using the paradigm for deﬁning privacy in the semi-honest model given
by Goldreich [15].

Deﬁnition 2. (EncSort Privacy) Let ΠEncSort be a two party protocol for com-
puting EncSort functionality. S1 takes as input (PK, A) and S2 takes as input
(PK, SK). When ΠEncSort terminates S1 receives the output B of EncSort. Let
VIEWΠEncSort
(PK, SK, A) be all the messages that Si receives while running the
protocol on inputs PK, SK, A and OUTPUTΠEncSort be the output of the protocol
received by S1.

Si

We say that ΠEncSort privately computes EncSort, i.e., ΠEncSort is a private
outsourced sort, if there exists a pair of probabilistic polynomial time (PPT)
simulators (SimS1, SimS2) such that

(1) (SimS2(PK, A),EncSort(PK, SK, A)) (cid:117)

(VIEWΠEncSort

(PK, SK, A), OUTPUTΠEncSort (PK, SK, A));

S1

(2) SimS1(PK, SK,N ) (cid:117) VIEWΠEncSort

S2

(PK, SK, A),

6

We note that one should not confuse our problem with Multi-Party Computation protocols for
sorting [16, 17], where every party has an input array and the goal is to output to every partici-
pating party the sorting of all inputs combined.

where N is the size of the array A and (cid:117) denotes computational indistinguisha-
bility for all tuples PK, SK, A.

The intuition behind the privacy deﬁnition of EncSort is as follows. S1 has an
array A encrypted using a semantically secure encryption and by the end of
the protocol he receives an array B which contains the values of A sorted and
encrypted using fresh randomness, i.e., a property of semantic security. S2 has
the corresponding secret key SK and receives nothing as an output. VIEWSi
captures messages that Si receives while participating in Π EncSort. In order to
capture that S1 does not learn anything about SK, and plaintext of A or B
as a consequence, one has to show that there exists a simulator of S2, SimS2.
SimS2 knows exactly what is known to S1 and nothing more. The main property
of SimS2 is that S1 should not be able to distinguish if he is interacting with
SimS2 or with S2 who knows the secret key of the encryption scheme. Hence,
S1 learns nothing more than he knew already. The privacy guarantee for S1 is
similar. One shows that there is a simulator SimS1 that knows the key pair of
the cryptosystem and only the size of A.

3.2 Construction

In this section we develop a construction for the private sort functionality
EncSort(PK, SK, A) presented in Deﬁnition 1. From now on we assume that the
array A is encrypted using the ﬁrst layer of Paillier cryptosystem (Section 2.1),
however, the system can be adapted to higher levels with corresponding adjust-
ment to the protocols.

Our private sort protocol relies on (a) homomorphic properties of the gen-
eralized Paillier cryptosystem from Section 2.1 to allow S1 and S2 to privately
compare and swap pairs of ciphertexts, and (b) a data independent sorting net-
work, Batcher’s sort [5], which allows to sort the data such that comparisons
alone do not reveal the order of the encrypted elements. We ﬁrst describe a
protocol for sorting just two elements and then use it as a blackbox for general
sorting. Finally, we show how to extend the protocol to sort an array where an
element is not a single ciphertext value but a (key, value) pair where key and
value are individually encrypted and sorting has to be performed on value.

Two Element Sort We develop a protocol between two parties S1 and S2 to
blindly sort two encrypted values. In particular, S1 possesses encryptions of a
and b, [a] and [b], while S2 has the corresponding decryption key SKP. S1 and S2
engage in an interactive protocol, EncPairSort, by the end of which S1 has a pair
of values ([c], [d]) such that (c, d) = (a, b) if a ≤ b and (c, d) = (b, a), otherwise.
Informally, EncPairSort has the following privacy guarantees. S1 and S2 should
learn nothing about values a and b nor their sorted order. The formal deﬁnition
of EncPairSort is a special case of EncSort in Deﬁnition 1 with N = 2.

The EncPairSort makes use of the comparison protocol EncCompare from
Section 2.1 to help S1 to acquire an encryption of the bit v that denotes whether

Table 4: ([c], [d]) ← EncPairSort(PKP, SKP, [a], [b]): Interactive protocol between S1
and S2 for sorting two encrypted elements such that only S1 receives the result. The
key pair for Paillier cryptosystem is denoted as KP = (PKP, SKP).

S1(PKP, [a], [b])

S2(PKP, SKP)

[[v]] ← EncCompare(KP, [a], [b])
% Compare a, b: v := a ≥ b.
[[[c]]] ← EncSelect(KP, [a], [b], [[v]])
% c := (1 − v)a + vb.
[[[d]]] ← EncSelect(KP, [a], [b], [[1]][[v]]−1) % d := va + (1 − v)b.
[c] ← StripEnc(KP, [[[c]]])
[d] ← StripEnc(KP, [[[d]]])

% Strip a layer of encryption
% for c and d.

a ≥ b or not. Given a Paillier encryption of v we can then use a ciphertext
selection EncSelect from Section 2.1 to blindly swap a and b according to v, i.e.,
their sorted order. The last step of the protocol brings the encryption of swapped
a and b back to the ﬁrst layer of Paillier. The complete protocol EncPairSort is
shown in Table 4.

Theorem 1. The EncPairSort protocol in Table 4 is a private outsourced sorting
protocol according to Deﬁnition 2 for the case N = 2.

Proof. (Sketch) In order to show that EncPairSort in Table 4 is secure according
to Deﬁnition 2 we need to construct two simulators SimS1 and SimS2 that show
that behavior of S1 and S2 can be simulated without their corresponding private
inputs and hence cannot reveal any information about these inputs to S2 and
S1, correspondingly.

We construct SimS2 as follows. SimS2 has access to private inputs of S1 in the
protocol. The VIEW of S1 consists of VIEW’s from EncCompare and two invoca-
tions of EncSelect and StripEnc protocols. In the full version [4] we show that there
exist simulators for each of these functionalities. Then SimS2 for EncPairSort sim-
ply invokes EncCompare simulator once, and EncSelect and StripEnc simulators
twice each. The construction of SimS1 is symmetrical.

General Sort In the previous section we developed an interactive method
EncPairSort for blindly sorting two elements (Table 4). In this section, we use
EncPairSort as a blackbox to build a protocol EncSort for privately sorting N
elements according to Deﬁnition 2. Recall that EncSort is an interactive protocol
between S1 and S2. S1 has an encrypted array A that he wishes to sort and S2
has a secret key of the underlying encryption scheme. In the end of the protocol,
S1 obtains a re-encryption of his array A with S2’s help while neither of them
learn anything about A nor its sorting.

Privacy properties of two element sorting EncPairSort guarantee that S1 does
not learn the result of the comparison of two encrypted elements nor anything
about the elements being compared. Hence, sorting algorithms that make calls
to a comparison function depending on the data are not applicable in our scheme
(e.g., quick sort performs a diﬀerent sequence of comparisons depending on the

Table 5: B ← EncSort(PKP, SKP, A): Interactive protocol between S1 and S2 for pri-
vately sorting an array A of N elements encrypted using Paillier encryption such that
only S1 acquires the sorted result B (see Deﬁnition 2). Paillier key pair is denoted
using KP = (PKP, SKP). See Figure 2 for an illustration for the case when N = 4.

S2(PKP, SKP)

S1(PKP, A)
A1 ← A
for i ∈ {1, . . . , k − 1}
(x, y) ← pairsi.next
while((x, y) (cid:54)= ⊥)
(Ai+1{x}, Ai+1{y}) ← EncPairSort(KP, Ai{x}, Ai{y})
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−→
←−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
(x, y) ← pairsi.next

B ← Ak

% k = O((log N )2), N = |A|.
% ith level of Batcher’s sort.

% Sort x, y entries of Ai.

% Next pair of Ai to sort.

layout of the data it is sorting, giving O(N log N ) comparisons on average).
For our purposes we require a sorting network that performs comparisons in a
data-independent manner and guarantees that after performing a deterministic
sequence of comparisons the result is sorted. We pick Batcher’s sorting [5] for
our purposes. Even though asymptotically AKS [2] is more eﬃcient, it has high
hidden constants that in practice make it inferior to Batcher’s sorting network.

Batcher’s sorting network sorts an array of N elements using O(N (log N )2)
data independent calls to a comparator function (i.e., the number of rounds is
the same for a ﬁxed N independent of the data). One can view the network in
O((log N )2) consecutive levels where O(N ) pairs of elements are compared and
swapped at every level. In particular, let Ai be an array of elements at ith level
such that A1 is the input array, where Ai{j} denotes the jth element of array Ai.
Each level i takes as input array Ai and produces Ai+1 where the pairs scheduled
to be sorted at level i are in sorted order in Ai+1. For example, A2{0} and A2{1}
contain A1{0}, A1{1} in sorted order, A2{2} and A2{3} contain A1{2}, A1{3}
in sorted order and so on. We use pairsi to denote an iterator over pairs that need
to be sorted in the ith level and pairsi.next returns the next pair to be sorted.

In Table 5 we present our protocol EncSort where S1 performs Batcher’s
sorting network using S2 to help him sort the elements of pairs at every level
of the network. To sort every pair, S1 and S2 run EncPairSort. Recall that the
output of EncPairSort is encrypted using the ﬁrst layer of Paillier cryptosystem,
hence, the result of pairwise sorting at level i can be used as input for calls
to EncPairSort in the next level i + 1. (See Figure 2 for an illustration of EncSort
on an example array of size 4.) Recall that S1 and S2 are two non-colluding
honest but curious adversaries and hence will execute their side of the protocol
faithfully.

Fig. 2: Example of EncSort protocol
in Table 5 for sorting an encrypted
array of four elements 5, 1, 2, 9 where
[m] denotes a Paillier encryption of
message m and pairsi denotes a pair
of elements to be sorted. Note that
only S1 stores values in the arrays Ai
while S2 blindly assists S1 in sorting
the values.

Theorem 2 (EncSort Privacy). The EncSort protocol in Table 5 is a private
outsourced sorting protocol according to Deﬁnition 2.

Proof. (Sketch) The protocol EncSort in Table 5 makes O(N (log N )2) calls to
EncPairSort protocol in Table 4. In Theorem 1 we showed that there exist sim-
ulators SimS1 and SimS2 for EncPairSort. Hence, the simulators for EncSort can
be trivially constructed by calling corresponding simulators of EncPairSort.

Theorem 3 (EncSort Performance). The EncSort protocol in Table 5 has the
following performance guarantees:

– The storage requirement of S1 is O(N );
– The total computation required by S1 and S2 is O(N (log N )2);
– The communication complexity between S1 and S2 consists of O(N (log N )2)

rounds;

– If S2 has O(1) storage, the time overhead of the protocol is O(N (log N )2);
– If S2 has O(N ) storage, the time overhead of the protocol is O((log N )2).

Proof. (Sketch) S1 needs to have O(N ) storage space in order to store the original
array A of size N along with the intermediate sorting results. The intermediate
storage is at most two arrays Ai and Ai+1 since after ﬁnishing the ith level of
sorting S1 can safely discard array Ai. S2, on the other hand, is only required
to store the keys of the encryption schemes used and perform ﬁeld arithmetic to
run encryption and decryption algorithms on constant number of elements.

The protocol requires O(N (log N )2) roundtrips between S1 and S2 where
S1 and S2 perform a constant computation after every round. If S2 has O(N )
memory then a highly parallelizable nature of the Batcher’s sorting network can
be exploited. It allows all invocations of EncPairSort during a single round i to
be run in parallel since they operate on diﬀerent pairs of the array Ai.

Key-Value Sort In the previous section we described how to sort an array
where every element of an array is an encrypted plaintext used for comparison.

[5]	  	  [1]	  	  [2]	  	  [9]	  	  [1]	  	  [5]	  	  [2]	  	  [9]	  	  A1	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  A2	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  A3	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  A4	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  [1]	  	  [5]	  	  [2]	  	  [9]	  	  [1]	  	  [2]	  	  [5]	  	  [9]	  	  pairs1={(1,2),	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  (3,4)}	  pairs2={(1,3),	  	  	  	  	  	  	  	  	  	  	  	  	  	  	  (2,4)}	  pairs3={(2,3)}	  Invoca’on	  of	  EncPairSort	  protocol	  between	  S1	  and	  S2	  that	  returns	  two	  re-­‐encrypted	  sorted	  values	  to	  S1.	  However, the protocol is easily expandable to work on arrays where every element
is a pair of ciphertexts representing a (key, value) pair and value is used to sort
the array. The main alternations happen in EncPairSort protocol where the input
is not two ciphertexts as in Table 4 but two pairs of ciphertexts: ([k1], [v1]) and
([k2], [v2]), and similarly in the output. Since comparison is performed only on
values EncCompare is called only on [v1] and [v2]. Once the bit representing
the result of the comparison is computed, EncSelect is used not only on the
ciphertexts of the values but also on the keys. That is, if values have to be
swapped so do their corresponding keys. This functionality is used in Section 4.2
when sorting document identiﬁers using their query score. There, the key is an
encrypted document id and value is an encryption of the corresponding score.

4 Private Ranked Search (MRSE)

We now give an overview our Multi-keyword Ranked Searchable Encryption
(MRSE) framework that allows an owner of a data collection to outsource his
documents to a server S1 and then search on them and receive ranked results,
using our private sort protocol.

4.1 MRSE Security Model

MRSE builds on the SSE model [11] where a server, given an encrypted docu-
ment collection and the corresponding secure search index, while answering mul-
tiple search queries, should not be able to deduct anything regarding the data
collection or the corresponding search index apart from the access and search
patterns. By the term access pattern we denote the identiﬁers of the documents
that contain a query keyword, while the search pattern refers to any connection
between queries that the server may derive (e.g., if speciﬁc query terms have
been queried before and how many times). The MRSE model assumes that it
is suﬃcient to return to the client only document identiﬁers and not the actual
document. This is consistent with related work on searchable encryption with
ranking, e.g., [9].

Our setting consists of two servers S1 and S2, where the user queries only S1.
S1 is required to return the document id’s that match the search query sorted by
relevance criteria (i.e., tf-idf) by running private sort with S2. We examine the
privacy of the client against S1 and S2 separately. This is suﬃcient for the overall
privacy given that S1 and S2 are non-colluding and the privacy of the interaction
between them is limited to using private sort as speciﬁed in Deﬁnition 2.

Informally, MRSE privacy deﬁnitions capture the following: S1 learns the
number of documents and unique keywords in the collection (he can infer this
from the size of the encrypted index), as well as the search pattern of client
queries since he observes the “encrypted” queries of the user. However, S1 learns
nothing about the access pattern. S2, on the other hand, only learns the number
of documents in the collection and knows when the client is querying the system.
However, S2 learns nothing about the access and search patterns, and hence

does not know anything about the content of the queries. We note that S1’s
capabilities are similar to those of the server in the original SSE deﬁnition [11]
while S2 learns much less. The formal deﬁnitions can be found in [4].

4.2 MRSE Construction

We are now ready to present the details of our MRSE construction. We split our
description into two phases: the setup phase and the query phase.

Setup and Initialization The client sets up the system by generating a secret
key for StE, SKStE, and a public/secret key pair for Paillier cryptosystem (PKP,
SKP). Then, shares PKP with S1 and (PKP, SKP) with S2. We omit exact details
of how the client sends the secret key to S2 but any eﬃcient key wrapping
algorithm suﬃces for our purposes. S1 and S2 are honest but curious and interact
with each other faithfully only using the private sort protocol from Section 3.2.
The client ﬁrst extracts all M unique terms7 from his collection of docu-
ments D and associates every unique term t with an array Ft of size N . An
element in position d of list Ft corresponds to the frequency of term t in doc-
ument with id d, i.e., tf-idft,d as deﬁned in Section 2.3. Note that tf-idft,d is
zero if the term t does not appear in document d. Given all tf-idft,d entries the
client obtains the frequency table F where the number of rows is M (number
of unique terms in D) and the number of columns is N (number of documents
in D). The client then maps every frequency score tf-idft,d to an integer and
encrypts it using the ﬁrst layer of Paillier encryption (Section 2.1). The map-
ping to integers ensures that we can use Paillier cryptosystem whose plaintext
space is deﬁned over Zn. Note that, once encrypted, the table representing fre-
quencies of terms does not reveal the number of documents that every term
appears in, i.e., the length of the posting list. We overload the notation and
deﬁne [Ft] = {[tf-idft,d] | ∀d ∈ {1, N}}.

The client then wishes to upload encrypted term and frequency index to S1
and query it later. For this purpose, he uses a structured encryption scheme as
deﬁned in Section 2.2. Since the frequencies are already in an encrypted form,
it is suﬃcient to create a searchable index for all the terms and allow S1 to ﬁnd
the corresponding frequency array [Ft] only if he is given a trapdoor for t. To
do so, we consider a simpliﬁed version of the labeled data structured encryption
scheme described in [10]. Let SKStE consist of two random k-bit strings K1, K2
and let GK1 and G(cid:48)
be two diﬀerent pseudo-random functions (PRF) with keys
K1 and K2, respectively.
The client ﬁrst sorts the terms using the lexicographic order and numbers
each term in this order as {t1, t2, . . . , tM}. Then, he picks a pseudo-random
permutation π and creates an auxiliary index of pairs (ti, π(i)) ∀i ∈ {1, M}. He
also appends π(i) to the corresponding [Fti ] and permutes the pairs (π(i), [Fti]),
i.e., creates a dictionary that maps a keyword ti to a list of encrypted scores

K2

7

Stemming and removal of stop words is outside of the scope of our paper.

for all the documents in the collection (not only the documents in which the
keyword appears at).
Then, the encryption algorithm of StE, EStE, works as follows. For every
(ti) and the value (π(i), [Fti]) ⊕ GK1(ti)
i ∈ {1, M}, the search key kti = G(cid:48)
are computed. Both are stored together in the secure index I which is sent as
an input to S1. We do not give to S1 the encryption of the document collection
since this is outside of our model.

K2

K2

ery document d computes an encrypted score ed = [score(q, d)] =(cid:80)

Query Phase During the query phase, the client computes the trapdoor T ←
Trpdr (SKStE, t) for each keyword t in the query q. In our scheme, Trpdr sets
T to (GK1 (t), G(cid:48)
(t)). The client then sends the trapdoors of all the query
terms (i.e., an “encrypted” representation of the query) T = {T | ∀t ∈ q}
to S1. Server S1, upon receiving client’s query T, can locate each encrypted
keyword t ∈ q using the corresponding trapdoors by running Search(I, T ) ∀T ∈
T. The Search algorithm parses T as (α, β) and computes the answer as I(β)⊕α,
where I(β) is the value stored in I under the search key β. The answer is a vector
[Ft] = {[tf-idft,d] | ∀d ∈ {1, N}} for every term t in the query.
Computing Document Scores: Recall that [Ft] is an array of individually en-
crypted tf-idft,d scores for d ∈ {1, N}. In order to compute the document scores,
S1 uses the additive property of the homomorphic encryption scheme and for ev-
t∈q[tf-idft,d].
Note that ed is simply an encryption of score(q, d). S1 then creates an array A
of (key, value) pairs where a key is an encryption of a document id and value is
the corresponding encrypted score: A = {([1], e1), ([2], e2), . . . , ([N ], eN )}.
Sorting Document Scores: The server S1 has acquired the ﬁnal scores for every
document identiﬁer, however, these scores are encrypted which prohibits S1 from
sorting them and returning the document identiﬁers sorted by their relevance
to the query q. To sort the documents, S1 engages with S2 in the private sort-
ing protocol EncSort deﬁned in Table 5 and its extension to (key,value) pairs in
Section 3.2. The protocol returns to S1 an array B = {([d1], ed1 ), ([d2], ed2), . . . ,
([dN ], edN )} which corresponds to a re-encryption of array A sorted using docu-
ment scores, that is D(ed1) ≤ D(ed2) ≤ . . . ≤ D(edN ) where D is a decryption
algorithm of Paillier cryptosystem and di are document identiﬁers.

Finally, S1 sends to the client array B. According to client preference, S1
can send document identiﬁers with scores, omit scores, or send only the top k
results. The client has the Paillier decryption key and can easily decrypt the
ordered sequence of document identiﬁers (and scores) received from S1.

4.3 MRSE Analysis

Here, we give an informal analysis of why MRSE is secure against S1 and S2
and refer the reader to [4] for a proof. The client’s document collection D and
the scores are represented as the encrypted index I which is stored semantically
encrypted with S1 only. The client encrypts frequency scores for all documents
and unique terms in F , including zeroes, hence, S1 does not learn anything

about the collection except the number of documents N and the number of
unique terms M in D. The client sends his queries to S1 and, hence, S1 learns
the search pattern, i.e., if the keywords were queried before or not. Note that
the search pattern is also leaked in the original StE scheme since StE generates
a deterministic trapdoor for the same term.

The security properties of private sort in Deﬁnition 2 guarantee that as long
as S1 and S2 behave honestly neither one learns anything about the array of
document scores they are sorting. Since S2 is invoked to participate in private
sort he learns N , the number of documents in the collection, and that a client
has queried S1 but learns nothing more about query keywords or query length.
The performance of MRSE is summarized in the following theorem.

Theorem 4 (MRSE Performance). MRSE protocol presented in Section 4.2
gives the following performance guarantees:
– The client takes O(N × M ) time and space to setup the system, and O(|q|)

time to generate a query;
O(|q| + N );

– The communication cost between the client and S1 during the query phase is
– The space requirements for S1 and S2 are O(N × M ) and O(1), respectively;
– The query phase takes O(N (log N )2) for both S1 and S2;
where N is the number of documents and M is the number of unique terms in
the collection, and |q| is the query size.
A proof of Theorem 4 can be found in the full version [4].

4.4 Comparison with Related Work

In this section we compare MRSE with other multi-keyword searchable encryp-
tion schemes with ranked results. Cao et al. [9] provide one of the ﬁrst schemes
that allow ranked multi-keyword search. The scheme sorts documents using the
score based on “inner product similarity” (ips) where a document score is simply
the number of matches of query keywords in each document. This ranking is not
as standard in information retrieval as tf-idf since it loses information about key-
word importance to the document collection w.r.t. document lengths and other
keywords (e.g., documents which contain all query keywords are ranked equally).
The scheme of [9] also proposes a heuristic to hide the search and access patterns
by adding dummy keywords and noise. As a result, the returned document list
may contain false negatives and false positives. Query phase of the scheme is
expensive for the client since query generation time is O(M 2), i.e., quadratic in
the number of unique keywords in the original collection, M , and the length of
the trapdoor for every query is O(M ). To answer the query, the server has to
perform O(N × M 2) computation, where N is the number of documents in the
collection. In comparison, the client of our scheme is required to generate only
a constant size trapdoor for every term in the query which is likely to be much
smaller than M . Also, the work for the server in MRSE is O(N (log N )2).

¨Orencik and Sava¸s [23, 24] also propose protocols for ranked multi-keyword
search. Their ranking is loosely based on frequency of a word in the document

Table 6: Comparison of MRSE with multi-keyword searchable encryption schemes re-
turning ranked results in terms of soundness of the result, the ranking technique, the
client query generation time, server(s) time to compute the result and the privacy
guarantees. We note that schemes [9] and [27] are single server solutions. Inner prod-
uct similarity is denoted as ips, N is the number of documents and M is the number
of unique terms in the collection, |q| is the query length, ∗ denotes the use of FHE
techniques, CCA-2 is security against chosen ciphertext attack for SSE schemes [11].
All the time complexities are asymptotic.

g
n

d
n
u
o
S

Scheme
Cao et al. [9]
¨Orencik et al. [22] (cid:88) tf-idf
Strizhov-Ray [27] ∗ (cid:88) ips†
Our scheme MRSE (cid:88) tf-idf

t
n
e
i
l

C

Server(s)

i
k
n
a
R
ips M 2 N × M 2
|q| N log N
|q|N |q|N + M 2
|q| N (log N )2

Privacy

Precision-privacy tradeoﬀ
CCA-2 v.s. S1, but not S2

CCA-2

‡
CCA-2 v.s. S1 and S
2

† the client receives document scores and sorts them himself.

‡ security against S1, S2 is in fact stronger than CCA-2 (see Section 4.1).

where fake keywords and documents are added, hence, their scheme also may
return false negatives and positives. Recent proposal by ¨Orencik et al. [22] is
a solution with two non-colluding servers. Their ﬁrst server works similar to
our S1, however, the interaction between the two servers is very diﬀerent and
gives much weaker privacy guarantees than our system. In particular, the second
server has access to the result of every query in the clear, revealing information
about user’s data collection as well as the search and access patterns. Recall that
in our scheme S2 is merely assisting S1 during sorting and never sees neither the
queries nor the data. Finally, storage requirement of the second server is linear
in the size of the collection, while it is constant for S2 in MRSE.

Another recent work that uses tf-idf and inner product similarity based rank-
ing is the one due to Strizhov and Ray [27]. Their model assumes a single server
that performs only the search functionality and not the sorting of the results.
In particular, the client generates N trapdoors for every term in the query, the
server ﬁnds the required encrypted documents and scores, returns them to the
client who performs the sorting based on tf-idf himself. Moreover, the frequency
table has to be encrypted under a fully homomorphic encryption (FHE) scheme
in order for the server to be able to perform ranking. Using FHE in such a setting
is a direct solution but unfortunately is very ineﬃcient.

In Table 6 we present a comparison of our MRSE scheme with the schemes
discussed above. We compare them in terms of soundness of the returned result
(e.g., if the result contains false positives), ranking method, client query gener-
ation time and search complexity for the server(s). The last column of the table
presents privacy guarantees of the schemes. We note that privacy of [9] is harder
to compare with since a heuristic is used to hide access and search patterns.

Acknowledgments

The authors would like to thank Seny Kamara, Markulf Kohlweiss and Roberto
Tamassia for useful discussions and suggestions on how to improve the results
and the write-up in hand. Olga Ohrimenko worked on this project in part while
at Brown University, where her research was supported in part by the Na-
tional Science Foundation under grants CNS–1012060 and CNS–1228485. Foteini
Baldimtsi was supported by the Center for Reliable Information Systems and Cy-
ber Security (RISCS) and grant CNS–1012910 (Boston University), and also in
part by the FINER project by Greek Secretariat of Research Technology (Uni-
versity of Athens) and CNS–0964379 (Brown University).

References

1. Ben Adida and Douglas Wikstr¨om. How to shuﬄe in public. In Conference on

Theory of Cryptography, TCC’07, pages 555–574. Springer-Verlag, 2007.

2. Mikl´os Ajtai, J´anos Koml´os, and Endre Szemer´edi. An O(n log n) sorting network.
In ACM Symposium on Theory of Computing, STOC’83, pages 1–9. ACM, 1983.
3. Gilad Asharov, Yehuda Lindell, Thomas Schneider, and Michael Zohner. More
eﬃcient oblivious transfer and extensions for faster secure computation. In ACM
conference on Computer and communications security, CCS ’13, pages 535–548.
ACM, 2013.

4. Foteini Baldimtsi and Olga Ohrimenko. Sorting and searching behind the cur-
tain: Private outsourced sort and frequency-based ranking of search results over
encrypted data. Cryptology ePrint Archive, Report 2014/1017, 2014.

5. Kenneth E. Batcher. Sorting networks and their applications. In AFIPS Spring

Joint Computing Conference, 1968.

6. Mihir Bellare, Viet Tung Hoang, Sriram Keelveedhi, and Phillip Rogaway. Eﬃ-
cient garbling from a ﬁxed-key blockcipher. In IEEE Symposium on Security and
Privacy, SP ’13, pages 478–492. IEEE, 2013.

7. Alexandra Boldyreva, Nathan Chenette, and Adam O’Neill. Order-preserving en-
cryption revisited: Improved security analysis and alternative solutions. In Con-
ference on Advances in Cryptology, CRYPTO’11, pages 578–595. Springer-Verlag,
2011.

8. Raphael Bost, Raluca Ada Popa, Stephen Tu, and Shaﬁ Goldwasser. Machine
learning classiﬁcation over encrypted data. Cryptology ePrint Archive, Report
2014/331, 2014.

9. Ning Cao, Cong Wang, Ming Li, Kui Ren, and Wenjing Lou. Privacy-preserving
multi-keyword ranked search over encrypted cloud data. In Conference on Infor-
mation Communications, INFOCOM’11, pages 829–837. IEEE, 2011.

10. Melissa Chase and Seny Kamara. Structured encryption and controlled disclosure.
In Advances in Cryptology - ASIACRYPT 2010, volume 6477 of Lecture Notes in
Computer Science, pages 577–594. Springer Berlin Heidelberg, 2010.

11. Reza Curtmola, Juan Garay, Seny Kamara, and Rafail Ostrovsky. Searchable sym-
metric encryption: improved deﬁnitions and eﬃcient constructions. In ACM con-
ference on Computer and communications security, CCS ’06, pages 79–88. ACM,
2006.

12. Ivan Damgard, Martin Geisler, and Mikkel Kroigard. A correction to eﬃcient and
secure comparison for on-line auctions. Int. J. Appl. Cryptol., 1(4):323–324, 2009.

13. Ivan Damg˚ard and Mats Jurik. A generalisation, a simpliﬁcation and some ap-
plications of paillier’s probabilistic public-key system. In International Workshop
on Practice and Theory in Public Key Cryptography, PKC ’01, pages 119–136.
Springer-Verlag, 2001.

14. Craig Gentry. A fully homomorphic encryption scheme. PhD thesis, Stanford

University, 2009. crypto.stanford.edu/craig.

15. Oded Goldreich. Foundations of Cryptography, vol. 2. Cambridge University Press,

2001.

16. Yan Huang, David Evans, and Jonathan Katz. Private set intersection: Are garbled

circuits better than custom protocols? In NDSS, 2012.

17. Kristj´an Valur J´onsson, Gunnar Kreitz, and Misbah Uddin. Secure multi-party
sorting and applications. In Applied Cryptography and Network Security, ACNS’11,
2011.

18. Donald E. Knuth. The Art of Computer Programming, Volume 3: (2Nd Ed.)

Sorting and Searching. Addison Wesley Longman Publishing Co., Inc., 1998.

19. Vladimir Kolesnikov, Ahmad-Reza Sadeghi, and Thomas Schneider.

Improved
garbled circuit building blocks and applications to auctions and computing minima.
In Cryptology and Network Security, volume 5888 of Lecture Notes in Computer
Science, pages 1–20. Springer Berlin Heidelberg, 2009.

20. Helger Lipmaa. An oblivious transfer protocol with log-squared communication. In
Proceedings of the 8th International Conference on Information Security, ISC’05,
pages 314–328. Springer-Verlag, 2005.

21. Christopher D. Manning, Prabhakar Raghavan, and Hinrich Sch¨utze. Introduction

to information retrieval. Cambridge University Press, 2008.

22. Cengiz ¨Orencik, Murat Kantarcioglu, and Erkay Sava¸s. A practical and secure
multi-keyword search method over encrypted cloud data. In International Confer-
ence on Cloud Computing, CLOUD ’13, pages 390–397. IEEE, 2013.

23. Cengiz ¨Orencik and Erkay Sava¸s. Eﬃcient and secure ranked multi-keyword search
on encrypted cloud data. In Proceedings of the 2012 Joint EDBT/ICDT Work-
shops, EDBT-ICDT ’12, pages 186–195. ACM, 2012.

24. Cengiz ¨Orencik and Erkay Sava¸s. An eﬃcient privacy-preserving multi-keyword
search over encrypted cloud data with ranking. Distributed and Parallel Databases,
2014.

25. Pascal Paillier. Public-key cryptosystems based on composite degree residuosity
classes. In International Conference on Theory and Applications of Cryptographic
Techniques, EUROCRYPT’99, pages 223–238. Springer-Verlag, 1999.

26. Ronald L. Rivest, Len Adleman, and Michael L. Dertouzos. On data banks and
privacy homomorphisms. In Foundations of Secure Computation, pages 169–177.
Academic Press, 1978.

27. Mikhail Strizhov and Indrajit Ray. Multi-keyword similarity search over encrypted
cloud data. In ICT Systems Security and Privacy Protection, volume 428, pages
52–65, 2014.

28. Marten van Dijk, Craig Gentry, Shai Halevi, and Vinod Vaikuntanathan. Fully
homomorphic encryption over the integers. In International Conference on The-
ory and Applications of Cryptographic Techniques, EUROCRYPT’10, pages 24–43.
Springer-Verlag, 2010.

29. Thijs Veugen. Comparing encrypted data. Manuscript, 2010. http://isplab.

tudelft.nl/sites/default/files/Comparingencrypteddata.pdf.

30. Justin Zobel and Alistair Moﬀat.

Inverted ﬁles for text search engines. ACM

Comput. Surv., 38(2), 2006.

