Algebraic MACs and Keyed-Veriﬁcation

Anonymous Credentials

Melissa Chase
Microsoft Research

melissac@microsoft.com

Sarah Meiklejohn

University College London
smeiklej@cs.ucsd.edu

Gregory M. Zaverucha
gregz@microsoft.com

Microsoft Research

ABSTRACT
We consider the problem of constructing anonymous creden-
tials for use in a setting where the issuer of credentials is also
the veriﬁer, or more generally where the issuer and veriﬁer
have a shared key. In this setting we can use message au-
thentication codes (MACs) instead of public key signatures
as the basis for the credential system.

To this end, we construct two algebraic MACs in prime-
order groups, along with eﬃcient protocols for issuing cre-
dentials, asserting possession of a credential, and proving
statements about hidden attributes (e.g., the age of the cre-
dential owner). We prove the security of the ﬁrst scheme in
the generic group model, and prove the security of the sec-
ond scheme — using a dual-system-based approach — under
decisional Diﬃe-Hellman (DDH). Our MACs are of inde-
pendent interest, as they are the only uf-cmva-secure MACs
with eﬃcient proofs of knowledge.

Finally, we compare the eﬃciency of our new systems to
two existing constructions of anonymous credentials: U-
Prove and Idemix. We show that the performance of the
new schemes is competitive with U-Prove (which does not
have multi-show unlinkability), and many times faster than
Idemix.

INTRODUCTION

1.
An anonymous credentials system [14, 9, 11] allows for a
landscape in which users can be known in diﬀerent con-
text by diﬀerent pseudonyms. For example, a user Alice
might be known to Bob under one pseudonym nym, and
to Carol under a diﬀerent pseudonym nym(cid:48). Her behavior
under these two pseudonyms should be unlinkable, meaning
no one can discern that the two pseudonyms belong to the
same user, yet she should be able to prove possession of a
credential issued to one given pseudonym to any other user,
without revealing the pseudonym (e.g., if Carol issued a cre-
dential to nym(cid:48), Alice should nevertheless be able to prove
to Bob — using nym — that she is in possession of the cre-
dential). Beyond proving basic possession of a credential,
 
Permission to make digital or hard copies of all or part of this work for personal 
or  classroom  use  is  granted  without  fee  provided  that  copies  are  not  made  or 
distributed  for  profit  or  commercial  advantage  and  that  copies  bear this  notice 
and the full citation on the first page. Copyrights for components of this work 
owned by others than the author(s) must be honored. Abstracting with credit is 
permitted. To copy otherwise, or republish, to post on servers or to redistribute to 
lists, requires prior specific permission and/or a fee. Request permissions from 
permissions@acm.org. 
CCS’14, November 3–7, 2014, Scottsdale, Arizona, USA. 
Copyright is held by the owner/author(s). Publication rights licensed to ACM. 
ACM 978-1-4503-2957-6/14/11…$15.00. 
http://dx.doi.org/10.1145/2660267.2660328

Alice may want to furthermore prove that it certiﬁes certain
attributes about her (e.g., her age).

Many of the potential applications of anonymous creden-
tials involve authentication. For example, a transit author-
ity might issue monthly passes and then check for possession
of such a pass when the user boards a bus; similarly, a uni-
versity might issue keycards to access certain buildings, and
then require a user to swipe his card upon entering one of
these buildings. For each of these situations, the author-
ity needs to know only that an authorized user is gaining
entry, yet current implementations of such access systems
allow the authority to learn the patterns of each individual
participant (e.g., who is entering which building and when).
Anonymous credentials present a solution that simultane-
ously preserves the integrity of the system through an un-
forgeability guarantee that a user cannot prove possession
of credentials he wasn’t issued (e.g., cannot gain access to a
building without having been granted access) but also pre-
serves the anonymity of the individual participants. If the
anonymity is preserved throughout multiple presentations of
the credential (e.g., each time a user boards the bus), it is
said to satisfy multi-show unlinkability.

Traditionally, the models for anonymous credentials have as-
sumed that a user must be prepared to prove possession of
his credentials to many other participants in the system; as
such, all existing constructions are built on top of public-key
primitives such as digital signatures. In both of the above
examples, however, the issuer and veriﬁer are in fact the
same entity; e.g., the transit authority both sells (i.e., is-
sues) monthly passes and veriﬁes them when users enter the
system. In these scenarios, and more generally in any set-
ting in which the party controlling access to a resource also
manages the accounts of authorized parties, constructions
can take advantage of this symmetry to use symmetric-key
primitives — which are typically signiﬁcantly more eﬃcient
than their public-key counterparts — to construct a keyed-
veriﬁcation credential.

If we deﬁne keyed-veriﬁcation credentials as allowing the
issuer and veriﬁer to share access to some secret key, then
symmetric-key primitives can be further adopted beyond the
setting in which the issuer and veriﬁer are the exact same
entity. As long as a user does not need to authenticate him-
self to any other user in the system, the issuer can share
a separate secret key with each veriﬁer, and then issue cre-
dentials speciﬁc to each of these veriﬁers. In a purely non-
interactive setting this might require the issuer to provide
credentials for each veriﬁer all at once (which might become

1205fairly unattractive beyond a small number of veriﬁers), but
in a more online setting the user might request credentials
from the issuer as needed. (Interestingly, the blind issuance
allows the user to do this in an anonymous fashion, as they
can request a credential on the same attributes without the
issuer’s knowledge.)

More generally, it is also possible to translate a publicly ver-
iﬁable credential into a more eﬃcient keyed-veriﬁcation cre-
dential with the same attributes and functionality. Another
use case is thus as follows: when a user wishes to interact
with a new veriﬁer, he ﬁrst enrolls with the veriﬁer by pre-
senting a traditional credential; the veriﬁer checks this cre-
dential, then issues a new credential that only he can verify.
Importantly, this protocol does not require that the user re-
veal the attributes in the traditional credential, or allow the
issuer and veriﬁer together to link the credential used dur-
ing enrollment with a run of the issuance protocol. When
the user returns, the eﬃcient keyed-veriﬁcation credential is
used, and it is impossible to link this use with previous pre-
sentations of the credential or with the user’s initial enroll-
ment. Translating credentials in this manner provides the
appealing trade-oﬀ that public veriﬁability is still possible
when necessary, but credential use becomes more eﬃcient
with repeat veriﬁers.

Our contributions. In this paper, we introduce keyed ver-
iﬁcation credentials, which formalize the intuition outlined
above. By using message authentication codes (MACs) in
place of more traditional public-key signatures, we show that
we can achieve performance improvements over existing con-
structions of anonymous credentials.

In order to integrate nicely with primitives such as zero-
knowledge proofs (which are typically needed to construct
anonymous credentials), we require an algebraic MAC, mean-
ing a MAC constructed using group operations rather than
block ciphers or hash functions. In Section 3, we present two
such MACs, both constructed in prime-order groups. The
ﬁrst, MACGGM, is a generalization of a MAC presented by
Dodis et al. [18]. While Dodis et al. show that this MAC
provides only a very weak notion of security under the DDH
assumption, we generalize the scheme to allow for blocks of
messages, and then prove it satisﬁes the standard notion (uf-
cmva security) of MAC unforgeability, albeit in the generic
group model. The second, MACDDH, is a new construction
which we propose, and which we prove to be uf-cmva secure
under the DDH assumption.

Both MACs are of potential independent interest, as they
avoid techniques such as collision-resistant hash functions
and bit-wise decompositions, which have often been relied
upon to construct eﬃcient MACs. MACGGM is quite eﬃcient;
MACDDH only slightly less eﬃcient and is based on a mild
assumption. Interestingly, the proof of security for MACDDH
follows the dual-system approach introduced by Waters [33],
which makes it (to the best of our knowledge) the ﬁrst appli-
cation of this technique outside of the pairing-based setting.

Next, in Section 4, we present keyed-veriﬁcation credentials.
We ﬁrst present a formal security model, and then present
two constructions, one based on each of our MACs. For
each construction, we describe how to eﬃciently issue and

prove possession of credentials. Our constructions consider
credentials certifying many attributes at once to reﬂect sit-
uations with a complex access policy (e.g., in the transit
setting, a monthly pass could encode an expiration date,
the area of usage, etc.); allow for blind issuance of creden-
tials, in which one or more of the attributes may remain
hidden from the issuer (e.g., a senior citizen might need to
provide their date of birth or other sensitive information in
order to receive a discount transit pass, or one might want
to transfer attributes from a publicly veriﬁable credential as
discussed above); and allow for presentation of credentials
with attributes satisfying a given statement. We then prove
the security of our MACDDH-based construction under DDH.
(The second scheme is secure under DDH and the assump-
tion that MACGGM is secure.)

Finally, in Section 5, we provide a detailed eﬃciency compar-
ison of our new keyed-veriﬁcation credentials to U-Prove [8,
26] and Idemix [10, 23], the two most eﬃcient anonymous
credential schemes to date. Our comparison indicates that,
depending on the parameters of the presentation, our new
constructions both have the same or slightly higher cost
when compared to U-Prove, and are always many times
faster than Idemix (by our estimates, anywhere between 4
and 16 times faster).

Related work. The state of the art in MACs based on
number-theoretic assumptions are the schemes by Dodis et
al. [18]. (Their paper also contains a survey of prior work.)
Of the nine MACs presented in [18], all either (1) satisfy a
weaker security notion than uf-cmva, or (2) use hash func-
tions or bitwise decomposition of the message, thus pre-
venting an eﬃcient proof of knowledge. Since our keyed-
veriﬁcation credential constructions require both of these
properties, we cannot use these existing MACs directly. Sec-
tion 3 describes the diﬀerences in more detail.

Anonymous credentials were introduced by Chaum [14] as
a way to provide individuals more control over the disclo-
sure of personal data. U-Prove [26] is a credential system
constructed from a blind version of Schnorr signatures [8].
It is deﬁned in a prime-order group, and is thus very com-
putationally eﬃcient. A U-Prove credential is constructed
as a number of tokens, where each token may be used once
unlinkably, so the size of U-Prove credentials is linear in the
number of unlinkable uses. A recent paper of Baldimtsi and
Lysyanskaya [3] presents a construction similar to U-Prove
(without multi-show unlinkability), but with a security proof
assuming the DDH assumption in the random oracle model
(U-Prove does not have a formal proof of security). As the
construction of [3] is strictly less eﬃcient than U-Prove (see
[3], Table 1), we chose not to include it in our eﬃciency
comparison.

Idemix [23] is based on the Camenisch-Lysyanskaya [11] sig-
nature scheme (CL signatures).
In terms of performance,
Idemix and U-Prove credentials have an opposite trade-oﬀ:
Idemix credentials have constant size, but are considerably
more expensive to present. The computational cost is in-
creased because the underlying signature scheme is con-
structed in a group where the strong RSA problem (SRSA)
is hard. While there are no guidelines for choosing param-
eters for the strong RSA problem, they must be at least as

1206large as RSA parameters, e.g., 3072 bits for 128-bit security.1
With multiple attributes, and advanced presentation proof
predicates, this cost quickly becomes too high for lightweight
provers such as smartcards [6].

There are also versions of the CL signature scheme deﬁned
in bilinear groups [1, 11], and Belenkiy et al. [4] construct
anonymous credentials that support delegation. However,
the algorithms in this setting are considerably more expen-
sive, and the computational costs of creating a presenta-
tion proof and verifying it are still signiﬁcantly greater than
in U-Prove. We will estimate some of the costs of the CL
scheme [11] in Section 5 to support this claim. The stan-
dardization of cryptographic schemes based on SRSA and
bilinear groups also lags further behind prime-order groups,
presenting another hurdle to deployment.

Given the trade-oﬀs of each system, our design goal is a
credential system with the strengths of U-Prove (eﬃcient
presentation and standard parameters), and those of Idemix
(constant credential size and multi-show unlinkability).

1 xi, and(cid:81)n

1 xi are shorthand for {xi}n

1 ,(cid:80)n
and(cid:81)n

2. PRELIMINARIES
Notation. We use the notation x ∈R X or x $←− X to mean x
is chosen uniformly at random from the set X. The notation
{xi}n
i=1 xi,
i=1 xi respectively. This shorthand is used only when
the set, sum or product has a single index. The notation
(cid:126)x is used to denote the vector (x1, . . . , xn), where n will be
clear from the context.

i=1,(cid:80)n

We use games in the deﬁnition of MAC security and in
proofs. A game G has a main procedure whose output is
the output of the game. Pr[G] denotes the probability that
this output is 1.

Zero-Knowledge Proofs. The protocols that comprise our
credential system make use of zero-knowledge (ZK) proofs
to prove knowledge of, and relations between, discrete loga-
rithms. We abstract these protocols with a notation intro-
duced by Camenisch and Stadler [12]. Proofs are expressed
with the notation

PK{(x, y, . . .) : statements about x, y, . . .}

where (x, y, . . .) are secrets (discrete logarithms) which sat-
isfy statements. The prover asserts knowledge of (x, y, . . .),
and all other values in the protocol are public.

There are many choices to implement these protocols, es-
pecially since the types of statements required by our pro-
tocols are relatively simple (knowledge of a representation
and proof of logarithm equality). In particular, all the state-
ments we prove can be captured by eﬃcient sigma protocols.

For our application, we need a proof system that is zero
knowledge and satisﬁes a weak form of online extraction [20].
We propose two approaches to instantiate the proof sys-
tem. The ﬁrst is to use the Damg˚ard protocol [17], which
converts any sigma protocol into a three-round interactive
1Note the optimizations that apply to the RSA signing oper-
ation are available only to the issuer in Idemix, not the user
or veriﬁers, as in that case the group order is unknown and
exponents must be large to satisfy privacy requirements.

zero-knowledge proof of knowledge secure under concurrent
composition. This protocol requires trusted parameters, but
this restriction can be omitted in the random oracle model.
The second option is to make the assumption that Fiat-
Shamir based proofs [19] in the random oracle model satisfy
the required extraction property. For more discussion and
a more precise description of the necessary extraction prop-
erty, see the full version[2].

Parameter Generation. Some of the parameters of our
constructions include a group element h, chosen such that
logg h is unknown, where g is a generator of the group.
In practice, this can be done by deterministically deriving
h from arbitrary public information using a cryptographic
hash function. All protocol participants may then verify that
h was derived correctly by repeating the derivation process.
One such derivation procedure is speciﬁed in [26]. Formally,
we model this as a trusted setup algorithm which generates
g, h where logg h is unknown to all parties.

Cryptographic Assumptions. The decisional Diﬃe-Hellman
problem (DDH) is the following: Let G be a cyclic group of
prime order p with generator g and let a, b, c ∈R Fp; given
(A = ga, B = gb, C) ∈ G3, determine whether C = gab
or C = gc. The DDH assumption is that this problem is
intractable for all polynomial time adversaries when p is ex-
ponential.

For some of our constructions we will also give security re-
sults in the generic group model (GGM). Intractability re-
sults in this model essentially mean that problems are in-
tractable provided the adversary only performs a series of
group operations. The GGM was ﬁrst used by Shoup to
prove lower bounds on DDH and related problems [7, 29].

Concrete examples of groups that are thought to satisfy
these assumptions are certain elliptic curve groups over Fp,
such as those standardized by NIST in [25].

3. MACS IN PRIME-ORDER GROUPS
In this section we present two MACs constructed using a
cyclic group of prime order. Both schemes use the same
system parameters, created with the following algorithm.

Setup(1k). Choose a group G with order p, where p is a
k-bit prime. Let g and h be generators of G such
that logg h is unknown. The system parameters are
params := (G, p, g, h).

In addition to the Setup algorithm, MACs have a key gener-
ation function KeyGen, a MAC function MAC that produces
an authentication tag on a message, and a verify function
Verify that veriﬁes a tag is valid with respect to a key and
message. While we do not include it as an explicit param-
eter, the MAC and Verify functions are assumed to have
params. This could easily be captured by including it in
the secret key; we omit it to simplify the descriptions. The
message space of both schemes is Fn
p , where n > 0 is a pa-
rameter.

We say that (Setup, KeyGen, MAC, Verify) is a secure MAC if
it is existentially unforgeable under chosen message attack,
given a veriﬁcation oracle (deﬁned as uf-cmva in [18]). We

1207augment the deﬁnition slightly to guarantee security even
when the signer publishes some parameters iparams associ-
ated with his secret key. In our application to anonymous
credentials, iparams are the issuer parameters and we use
them to implement an eﬃcient presentation protocol.

MAC(sk , (cid:126)m): Choose u ∈R G \ {1} and compute the tag

σ = (u, u(cid:48)), where u(cid:48) := uHx( (cid:126)m).

Verify(sk , (cid:126)m, σ): Parse σ = (u, u(cid:48)) ∈ G2. Accept if u (cid:54)= 1

and u(cid:48) = uHx( (cid:126)m).

Definition 1

KeyGen, MAC, Verify), deﬁne Advuf-cmva
where GA
uf-cmva(k) is deﬁned as follows:

(uf-cmva security). For a MAC (Setup,
uf-cmva(k)],

mac,A (k) = Pr[GA

uf-cmva(k)

main GA
Q ← ∅; params $←− Setup(1k);
(iparams, sk ) $←− KeyGen(params)
(m, σ) $←− AMac,Verify(params, iparams)
return (m /∈ Q) ∧ (Verify(sk , m, σ) = 1)

Procedure Macsk (m)
Q ← Q ∪ {m}
return MAC(sk , m)

Procedure Verifysk (m, σ)
return Verify(sk , m)

Then the MAC is uf-cmva secure if Advuf-cmva
mac,A (k) < ν(k)
for all PPT adversaries A, where ν is a negligible function.

A stronger security notion for MACs is sometimes used,
where A may win by outputting (m, σ), even if m ∈ Q,
provided σ was not output by the MAC oracle for m. The
schemes we present were expressly designed not to provide
this type of security, to allow tags to be re-randomized (or
blinded) and thus allow for more eﬃcient zero-knowledge
proofs of possession of a MAC.

3.1 The MACGGM Construction
Our ﬁrst MAC is a generalization of a scheme due to Dodis
et al. [18]. The original MAC works in a cyclic group G of
prime order p, and the secret key is a pair (x0, x1) ∈ F2
p. To
compute the MAC of a message m ∈ Fp, choose u ∈R G,
and compute (u, umx1+x0 ) as the tag. To verify a tag (u, u(cid:48))
for a message m, check whether umx1+x0 = u(cid:48).

We extend the scheme to support n attributes, where the se-
cret key becomes (x0, x1, . . . , xn) and tags are computed as
(u, ux1m1+...+xnmn+x0 ). Note that m1, . . . , mn are n mes-
sages, each in Fp, rather than the binary decomposition of
a single message m. We refer to this scheme as MACGGM
(the single message and binary message schemes were re-
spectively called MAChwPRF and MACWhwPRF in [18]). KeyGen
has an optional step that is required only when MACGGM is
used for keyed-veriﬁcation credentials.

In what follows (including for MACDDH), we use (cid:126)m = (m1, . . . ,
mn) to mean a list of n messages in Fp, and use Hx( (cid:126)m) :=

x0 +(cid:80)n

i ximi.

KeyGen(params): Choose a secret key sk := (cid:126)x ∈R Fn+1
.
Optionally, choose ˜x0 ∈R Fp and compute Cx0 :=
gx0 h˜x0 and (X1 := hx1 , . . . , Xn := hxn ), and publish
the issuer parameters, denoted iparams := (Cx0 , X1,
. . . , Xn).

p

Dodis et al. [18] prove that under the DDH assumption,
MACGGM is suf-cma secure when n = 1. In this deﬁnition, se-
curity is called selective unforgeability, because the attacker
must select the message he will use in a forgery before seeing
any tags, and is not allowed veriﬁcation queries. For our cre-
dential system, however, we require uf-cmva security. (Se-
lective unforgeability gives only limited protection against
misbehaving adversaries, and veriﬁcation queries are inher-
ent in anonymous credentials as the adversary is always able
to present credentials and observe the veriﬁer’s reaction.)

We stress that Dodis et al. give no evidence that MACGGM
is not in fact uf-cmva secure. Rather, it appears that their
proof technique does not extend to also prove security under
the stronger deﬁnition. A simple (but ineﬃcient) reduction
exists between uf-cma and suf-cma. A uf-cma adversary
is transformed into an suf-cma adversary by an algorithm
which guesses the message to be forged by the uf-cma adver-
sary. The success probability of the new adversary is /|M|
where M is the message space of the scheme, and  is the
success probability of the uf-cma adversary. If the size of M
is constrained, the loss in security may be acceptable (i.e., it
may be acceptable to use an suf-cma-secure scheme). This
may be of use in our application, in the very limited setting
where credentials contain a small number of attributes from
a small set, known to the issuer, and where during presen-
tation the user is required to prove that all the attributes in
his credential are within this set.

To ensure security in the more realistic case of unconstrained
messages (attributes), and when veriﬁcation queries are al-
lowed (as in a credential system), we prove that MACGGM
is uf-cmva secure in the generic group model. Additionally,
we include iparams in our analysis. A proof of the following
theorem is given in the full version of this paper [2].

Theorem 2. In the generic group model, a uf-cmva ad-
√
versary attacking the MACGGM scheme, succeeding with non-
p) group operations.
negligible probability, performs Ω(

3.2 The MACDDH Construction
In this section, we describe another MAC construction, called
MACDDH. Recall that params are created by Setup(1k) and
are assumed to be available to all algorithms, that (cid:126)m =
(m1, . . . , mn) is a list of n messages in Fp, and that the op-
tional step in KeyGen is required only when MACDDH is used
for keyed-veriﬁcation credentials.

KeyGen(params): Pick z, x0, y0 . . . , xn, yn

$←− Fp. Output
sk := ((cid:126)x, (cid:126)y, z). Optionally, choose ˜x0, ˜y0, ˜z ∈R Fp and
compute Cx0 := gx0 h˜x0 , Cy0 = gy0 h˜y0 , Cz = gzh˜z,
compute Xi := hxi and Yi := hyi for each i ∈ {1, . . . n},
and publish iparams := (Cx0 , Cy0 , Cz, (cid:126)X, (cid:126)Y ).2

2Since Cx0 , Cy0 , Cz are statistically independent of sk and
the rest of the parameters, we can ignore them for the un-
forgeability proof.

1208MAC(sk , (cid:126)m): Pick r $←− Fp and set σw := gr, σx := grHx( (cid:126)m),
σy := grHy ( (cid:126)m), and σz := gzr. Output (σw, σx, σy, σz).
Verify(sk , (cid:126)m, σ): Parse σ = (σw, σx, σy, σz) ∈ G4. Check
, and σz = σz
w.

that σw (cid:54)= 1, σx = σHx( (cid:126)m)
Accept if these checks pass and reject otherwise.

, σy = σHy ( (cid:126)m)

w

w

Theorem 3. If the DDH assumption holds in G, then

MACDDH is uf-cmva secure.

Our proof takes inspiration both from the dual system tech-
nique introduced by Waters [33], and from the twin Diﬃe-
Hellman techniques of Cash, Kiltz, and Shoup[13]. Roughly,
we use the twin DH approach to argue that we can switch to
a veriﬁcation procedure which does not require the full dis-
crete logarithms (cid:126)x, (cid:126)y, z. As in [13] this allows us to reduce to
DDH even in the presence of this veriﬁcation oracle. Then
we use the dual system approach to gradually add noise into
the MACs, while still ensuring that our reduction can verify
that the adversary’s forgery is correctly formed. Finally we
arrive at a game where part of the secret key is statistically
hidden, so we can guarantee that the adversary can produce
a correctly formed forgery only with negligible probability.

Proof. Let A be a PT adversary playing game GA

uf-cmva(k)
that makes qm Mac queries and qv Verify queries, where
qm = qm(k) and qv = qv(k) for polynomials qm(·) and qv(·).
Deﬁne two games, GA

1 (k) as follows:

0 (k) and GA

• GA

0 (k): Pick additional values s, t, v0, . . . , vn

$←− Fp
and include these in the secret key sk .
If iparams
are to be generated, compute Xi = gxi hvi and Yi =
−s for i ∈ {1, . . . , n}. In the Macsk ( (cid:126)m) proce-
gyi Xi
dure, continue to pick a random value r $←− Fp, but
compute instead σw ← hr, σx ← (gHx( (cid:126)m)hHv ( (cid:126)m))r,
σy ← (gHy ( (cid:126)m)−sHx( (cid:126)m)h−sHv ( (cid:126)m))r, and σz ← (gzh−t)r.
In the Verifysk ( (cid:126)m, σ) procedure, check instead that
w)Hy ( (cid:126)m)) ∧ (σw (cid:54)= 1), and at the end
((σyσs
w)Hy ( (cid:126)m∗)) ∧
of the game check that ((σyσs
((σ
• GA

xσy)Hx( (cid:126)m∗)) ∧ (σw (cid:54)= 1).

1 (k): Continue to run the setup and the veriﬁcation
procedure (both in the Verifysk ( (cid:126)m, σ) algorithm and
0 (k). In Macsk ( (cid:126)m),
at the end of the game) as in GA
pick r, ω, χ $←− Fp and compute σw ← hω, σx ← hχ,
σy ← grHy ( (cid:126)m)h−χs, and σz ← gzrh−ωt.

σx)Hy ( (cid:126)m∗) = (σs

x)z = (σzσt

x)z = (σzσt

−Hv ( (cid:126)m∗)

w

Now, we provide a PT adversary B and negligible functions
ν0(·) and ν(·) such that

Advuf-cmva

mac,A (k) ≤ qvν0(k) + qmAdvddh

B (k) + ν(k)

for all k ∈ N, from which the theorem follows. To do this,
we build B , ν0(·), and ν(·) such that for all k ∈ N we have

Pr[GA

uf-cmva(k)] − Pr[GA
0 (k)] − Pr[GA
Pr[GA
Pr[GA

0 (k)] ≤ qvν0(k)
1 (k)] ≤ qmAdvddh
1 (k)] ≤ ν(k).

B (k)

(1)

(2)

(3)

We then have

Advuf-cmva

mac,A (k) = Pr[GA
uf-cmva(k)]
uf-cmva(k)] − Pr[GA
= (Pr[GA
0 (k)] − Pr[GA
+ (Pr[GA
≤ qvν0(k) + qmAdvddh

0 (k)])

1 (k)]) + Pr[GA
B (k) + ν(k).

1 (k)]

i, y(cid:48)

i, vi
i/β + vi and yi := y(cid:48)

To ﬁrst prove Equation 1, we consider a modiﬁed version
of GA
uf-cmva(k) as an intermediate game: rather than pick (cid:126)x
$←− Fp, let β = logg(h), and
and (cid:126)y randomly, pick x(cid:48)
i/β − sxi for all i, 0 ≤ i ≤ n;
set xi := x(cid:48)
furthermore, rather than pick z $←− Fp, pick z(cid:48) $←− Fp and set
z := z(cid:48)/β − t. In the Mac oracle, use r := r(cid:48)β for r(cid:48) $←− Fp
rather than r $←− Fp. These values are distributed identically
to the values used in GA
uf-cmva(k), so the distribution in this
modiﬁed game is identical. Furthermore, we have
w = gr = gr(cid:48)β = hr(cid:48)
(cid:48)
σ
x = grHx( (cid:126)m) = gr(cid:48)β(Hx(cid:48) ( (cid:126)m)/β+Hv ( (cid:126)m)) = (gHx(cid:48) ( (cid:126)m)hHv ( (cid:126)m))r(cid:48)
(cid:48)
σ
y = grHy ( (cid:126)m) = gr(cid:48)β((Hy(cid:48) ( (cid:126)m)−sHx(cid:48) ( (cid:126)m))/β−sHv ( (cid:126)m))
(cid:48)
σ
= (gHy(cid:48) ( (cid:126)m)−sHx(cid:48) ( (cid:126)m)h
z = grz = gr(cid:48)β(z(cid:48)/β−t) = (gz(cid:48)
(cid:48)
σ
so the Mac responses in the modiﬁed game are identical to
those in GA

−sHv ( (cid:126)m))r(cid:48)
−t)r(cid:48)

h

,

0 (k).

To address the changes in veriﬁcation, we proceed through a
series of hybrids: deﬁne HA
i (k) to be a game in which the ﬁrst
i Verify queries are answered using Verify, the last qv−i are
answered using the veriﬁcation procedure deﬁned in GA
0 (k)
(referred to in the sequel as SimVerify), and the veriﬁcation
at the end is considered the qv + 1st query; then HA
qv +1(k)
is the intermediate game and HA
0 (k). To transition
from HA
i−1(k) for i < qv + 1, we therefore need only
consider the i-th query ( (cid:126)m, σ) (as the two games are identical
both before and after this query), and the probability that
Verify(sk , (cid:126)m, σ) (cid:54)= SimVerify(sk , (cid:126)m, σ); i.e., that HA
i−1(k) and
HA
i (k) produce diﬀerent responses on the i-th query. We
refer to this event as Ei, and show that Pr[Ei] ≤ ν0(k) for
a negligible function ν0(k).

i (k) to HA

0 (k) is GA

(Hy(cid:48) ( (cid:126)m)−sHx(cid:48) ( (cid:126)m))/β−sHv ( (cid:126)m)

σs(Hx(cid:48) ( (cid:126)m)/β+Hv ( (cid:126)m))

w

)z(cid:48)

If Verify(sk , (cid:126)m, σ) = accept then
)z(cid:48)

= (σHy ( (cid:126)m)

σsHx( (cid:126)m)
w

(σyσs

x)z(cid:48)

w

= (σ

w
Hy(cid:48) ( (cid:126)m)/β
= (σ
w
= (σz
wσt
= (σzσt

w)Hy(cid:48) ( (cid:126)m)
w)Hy(cid:48) ( (cid:126)m),

)β(z+t)

so SimVerify(sk , (cid:126)m, σ) = accept and event Ei happens only
if SimVerify(sk , (cid:126)m, σ) = accept but Verify(sk , (cid:126)m, σ) = reject.
Consider Rx, Ry, and Rz such that σx = RxσHx( (cid:126)m)
, σy =
RyσHy ( (cid:126)m)
w; then Verify accepts only if Rx =
Ry = Rz = 1. If SimVerify(sk , (cid:126)m, σ) = accept then, since

, and σz = Rzσz

w

w

1209Hy( (cid:126)m) + sHx( (cid:126)m) = Hy(cid:48) ( (cid:126)m)/β and z(cid:48) = β(z + t), we have

We then show that

(RyσHy ( (cid:126)m)

w

Rx

x)z(cid:48)
(σyσs
)z(cid:48)
sσsHx( (cid:126)m)
(z+t)Hy(cid:48) ( (cid:126)m)
sRy)β(z+t)σ
w
sRy)z(cid:48)

(Rx

w

(Rx

w)Hy(cid:48) ( (cid:126)m)

= (σzσt
= (Rzσz

w)Hy(cid:48) ( (cid:126)m)
wσt
Hy(cid:48) ( (cid:126)m)
z
Hy(cid:48) ( (cid:126)m)
z

σ

.

= R

= R

(z+t)Hy(cid:48) ( (cid:126)m)
w

As up until the i-th query A, the values of z(cid:48) and (cid:126)y(cid:48) are
information theoretically hidden, it has at most a negligible
probability (in fact, probability 1/2k) of coming up with Rx,
Ry, and Rz that satisfy this equation but such that it is not
sRy = Rz = 1. Similarly, we can argue that
the case that Rx
the value of s is information theoretically hidden from A’s
sRy = 1 but it is not
view so far, so the probability that Rx
the case that Rx = Ry = 1 is also negligible. We therefore
have that Pr[Ei] ≤ ν0(k) for a negligible function ν0(·), for
all queries to the Verify oracle.

To ﬁnally address the case of i = qv + 1, in which we ad-
xσy)Hx( (cid:126)m∗),
σx)Hy ( (cid:126)m∗) = (σs
ditionally check that (σ
we observe that if Verify(sk , (cid:126)m∗, σ∗) = accept then
)Hy(cid:48) ( (cid:126)m∗)

−Hv ( (cid:126)m∗)

−Hv ( (cid:126)m∗)

(σ

w

w

σx)Hy(cid:48) ( (cid:126)m∗) = (σ
= (σ

w

−Hv ( (cid:126)m∗)
−Hv ( (cid:126)m∗)
Hy(cid:48) ( (cid:126)m∗)/β

w

= (σ

w

w

w

σHx( (cid:126)m∗)
σHx(cid:48) ( (cid:126)m∗)/β+Hv ( (cid:126)m∗)
)Hx(cid:48) ( (cid:126)m∗)
Hy(cid:48) ( (cid:126)m∗)/β−sHx( (cid:126)m)
)Hx(cid:48) ( (cid:126)m∗)

w

)Hy(cid:48) ( (cid:126)m∗)

)Hx(cid:48) ( (cid:126)m∗)

= (σsHx( (cid:126)m)

σ

w
= (σs
= (σs

w

xσHy ( (cid:126)m∗)
xσy)Hx(cid:48) ( (cid:126)m∗).

This means that if Verify accepts (cid:126)m∗, σ∗ , then the ﬁnal
veriﬁcation query in GA
0 (k) will also accept. Finally, since
the ﬁnal veriﬁcation check in GA
0 (k) includes verifying that
w)Hy(cid:48) ( (cid:126)m), the argument above implies that
(σyσs
if this check succeeds then Verify would also accept. This
proves Equation 1.

= (σzσt

x)z(cid:48)

0 (k); HA

We now prove Equation 2. To do this, we consider a se-
ries of hybrids: in each hybrid HA
i (k), the ﬁrst i queries use
1 (k), and the last qm − i use the
the MAC values from GA
values from GA
0 (k), and
HA
i (k) is in-
distinguishable from HA
i−1(k), we cannot proceed in a single
Instead, we gradually change the value of the i-th
step.
query across two additional games HA
i,2(k) that
proceed as follows:

0 (k) is then equivalent to GA
1 (k). To argue that HA

qm (k) is equivalent to GA

i,1(k) and HA

• HA

0 (k).

i,1(k):

In the Macsk ( (cid:126)m) procedure, if j < i then
compute σ as speciﬁed in GA
1 (k), and if j > i compute
If j = i, pick r, ω $←− Fp
σ as speciﬁed in GA
and compute σw ← hω, σx ← grHx( (cid:126)m)hωHv ( (cid:126)m), σy ←
gr(Hy ( (cid:126)m)−sHx( (cid:126)m))h−sωHv ( (cid:126)m), and σz ← gzrh−ωt.
i,2(k): In the Macsk ( (cid:126)m) procedure, continue to be-
have as in HA
i,1(k) in the cases that j < i or j > i.
If j = i, then pick r, ω, χ $←− Fp, and continue to
i,1(k), but compute σx ←
compute σw and σz as in HA
grHx( (cid:126)m)hrHv ( (cid:126)m)+χ and σy ← grHy ( (cid:126)m)σ−s
x .

• HA

Pr[HA
Pr[HA
Pr[HA

i,1(k)] − Pr[HA
i,2(k)] − Pr[HA
i (k)] − Pr[HA

i−1(k)] ≤ Advddh
i,1(k)] = 0

B (k)

i,2(k)] = 0

(2.1)

(2.2)

(2.3)

for all k ∈ N, from which Equation 2 follows.

To prove Equation 2.1, the construction of B is as follows:

B (p, G, g, A, B, C)
Q ← ∅; h ← A;
x0, . . . , xn, v0, . . . , vn, y0, . . . , yns, z, t ← Fp
Xi ← gxi hvi ; Yi ← gyi X
∀ i ∈ {1, . . . , n};
iparams ← ( (cid:126)X, (cid:126)Y )
( (cid:126)m∗, σ∗) $←− ASimMac,Verify((p, G, g, h), iparams)
b ← ((σyσs
∧((σ
return b(cid:48) = (( (cid:126)m∗ /∈ Q) ∧ b)

σx)Hy ( (cid:126)m∗) = (σs

x)z = (σzσt
−Hv ( (cid:126)m∗)

w)Hy ( (cid:126)m∗))

−s
i

w

xσy)Hx( (cid:126)m∗)) ∧ (σw (cid:54)= 1)

Procedure SimMacsk ( (cid:126)m)
On queries j < i or j > i: use (cid:126)x, (cid:126)v, (cid:126)y, s, z, t, h to compute
σ as in GA
On query i: compute σw ← C; σx ← BHx( (cid:126)m)C Hv ( (cid:126)m);
σy ← BHy ( (cid:126)m)−sHx( (cid:126)m)C−sHv ( (cid:126)m); σz ← BzC−t
and return (σw, σx, σy, σz)

0 (k) respectively.

1 (k) or GA

Procedure Verifysk ( (cid:126)m, σ)
return ((σyσs

x)z = (σxσt

w)Hy ( (cid:126)m)) ∧ (σw (cid:54)= 1)

To see that B successfully simulates the Mac oracle, observe
that if we implicitly use r = b then, if C = gab, on the ith
query we have

σw = gab = hb = hr
σx = gbHx( (cid:126)m)gabHv ( (cid:126)m) = (gHx( (cid:126)m)hHv ( (cid:126)m))r
σy = gb(Hy ( (cid:126)m)−sHx( (cid:126)m))g
= (gHy ( (cid:126)m)−sHx( (cid:126)m)h
−abt = (gzh

−absHv ( (cid:126)m)
−sHv ( (cid:126)m))r
−t)r,

σz = gbzg

which are distributed identically to the values in HA
i−1(k). If
instead C is random, then in particular we can write it as
C = hω for some ω $←− Fp. In this case

σw = hω
σx = grHx( (cid:126)m)hωHv ( (cid:126)m)
σy = gr(Hy ( (cid:126)m)−sHx( (cid:126)m))h
σz = gzrh

−ωt,

−sωHv ( (cid:126)m)

which are distributed identically to the values in HA

i,1(k).

To prove Equation 2.2, we remind ourselves of the transition:
in both games, the ﬁrst i− 1 queries are answered using hχj
$←− Fp and the last qm − i queries are answered us-
for χj
$←− Fp. The i-th query then
ing (gHx( (cid:126)mj )hHv ( (cid:126)mj ))rj for rj
uses either griHx( (cid:126)mi)hχi (in HA
i,2(k)) or griHx( (cid:126)mi)hωHv ( (cid:126)mi)
(in HA
i,1(k)); if we can argue that the value of Hv( (cid:126)mi) is

1210independent of any other values in the game, then in par-
ticular Hv( (cid:126)mi) could take on any value and the distribution
over these two values is identical. To do this, we ﬁrst ob-
serve that SimVerify, and thus Verify, is independent of
(cid:126)v. The ﬁrst i − 1 Mac responses are also independent of
(cid:126)v, so we must prove only two properties: (1) the value of
(gHx( (cid:126)mj )hHv ( (cid:126)mj ))rj in the last qm − i Mac responses is in-
dependent of (cid:126)v, and (2) the value of Hv( (cid:126)mi) is independent
of the value of Hv( (cid:126)m∗), and thus changing the i-th query
does not aﬀect the distribution at the end of the game.
To ﬁrst prove this latter property, we observe that Hv(·) is a
pairwise independent function. As the winning conditions of
the game require that m∗ /∈ Q and thus (cid:126)mi (cid:54)= (cid:126)m∗, this means
that for any α1, α2 ∈ Fp, Pr[Hv( (cid:126)mi) = α1 ∧ Hv( (cid:126)m∗) =
α2] = 1/p2, which in turn implies that the values of Hv( (cid:126)mi)
and Hv( (cid:126)m∗) are independent as desired.

To prove the former property, we perform a similar argument
to that in the proof of Equation 1: consider a modiﬁed game
in which xi = x(cid:48)

i − βvi; then for the last qm − i queries,

(g(Hx( (cid:126)mj )hHv ( (cid:126)mj ))rj = grj (Hx( (cid:126)mj )+βHv ( (cid:126)mj ))) =

grj (Hx(cid:48) ( (cid:126)mj )−βHv ( (cid:126)mj )+βHv ( (cid:126)mj )) = grj Hx(cid:48) ( (cid:126)mj ),

so these values information-theoretically hide (cid:126)v. For the i-th
query, however, if we use griHx( (cid:126)mi)hωiHv ( (cid:126)mi) then for σx we
have
gri(Hx(cid:48) ( (cid:126)mi)−βHv ( (cid:126)mi))gβωiHv ( (cid:126)mi) = griHx(cid:48) ( (cid:126)mi)h(ωi−ri)Hv ( (cid:126)mi),
which, given that as we have argued Hv( (cid:126)mi) is indepen-
dent of all other values, will be distributed identically to
griHx(cid:48) ( (cid:126)mi)hχ = griHx( (cid:126)mi)hriHv ( (cid:126)mi)+χ for χ ← Fp. Thus,
this is identical to the value in HA
i,2(k), and we can argue
about σy similarly.

To prove Equation 2.3, we consider a modiﬁed version of
i (k) in which, rather than pick χ $←− Fp, pick χ(cid:48) $←− Fp and
HA
set χ := rHx( (cid:126)m)/β + rHv( (cid:126)m) + χ(cid:48). Then the distribution
over χ is still uniformly random and thus identical to the
distribution in HA

i (k), and

hχ = hrHx( (cid:126)m)/β+rHv ( (cid:126)m)+χ(cid:48)

= gβ(rHx( (cid:126)m)/β+rHv ( (cid:126)m)+χ(cid:48))
= grHx( (cid:126)m)hrHv ( (cid:126)m)+χ(cid:48)

,

so the distribution over σx in the modiﬁed game is identical
to that in HA
i,2(k) (and, consequently, so is the distribution
over σy).

w

−Hv ( (cid:126)m∗)

Finally, we prove Equation 3. If the forgery ( (cid:126)m∗, σ∗) out-
σx)Hy ( (cid:126)m∗) =
put by A passes veriﬁcation, then (σ
xσy)Hx( (cid:126)m∗) by deﬁnition. Since x0 and v0 are not used
(σs
in any values given to A and thus Hx( (cid:126)m∗) and Hv( (cid:126)m∗) are
information-theoretically hidden, however, A has a negligi-
ble probability of producing ( (cid:126)m∗, σ∗) such that this equality
holds and σw (cid:54)= 1, meaning the probability that it passes
ﬁnal veriﬁcation is bounded by ν(k) for a negligible function
ν(·).

4. KEYED-VERIFICATION CREDENTIALS
In this section we ﬁrst describe the set of algorithms that
form a keyed-veriﬁcation credential scheme. We then infor-
mally describe the desired security and privacy properties
(formal deﬁnitions are in the full version [2]), present con-
structions of keyed-veriﬁcation credentials based on MACGGM
and MACDDH, and prove our MACDDH-based construction se-
cure assuming DDH. The proof of security for our MACGGM-
based construction is a trivial simpliﬁcation of the MACDDH-
based proof, so we omit it.

A keyed-veriﬁcation credential system consists of the follow-
ing algorithms:

Setup(1k) deﬁnes the system parameters params. We will
assume that params is available to all algorithms, and
that all parties have assurance it was created correctly.

CredKeygen(params) is run by the issuer on input params to
generate a secret key sk and (public) issuer parameters
iparams.

BlindIssue(sk , S) ↔ BlindObtain(iparams, (m1, . . . , mn)) is a
potentially interactive protocol where a user can obtain
a credential on attributes (m1, . . . , mn) from an issuer
who is only given some subset S of those attributes.

Show(iparams, cred , (m1, . . . , mn), φ) ↔ ShowVerify(sk , φ) is
an interactive protocol between a user and a veriﬁer.
Show is run by a user to generate a proof of possession
π of a credential cred certifying some set of attributes
(m1, . . . , mn) satisfying a set of statements φ under
the key corresponding to iparams, and ShowVerify is
run by the veriﬁer in possession of sk to verify proof π
claiming knowledge of a credential satisfying the state-
ments φ.

While we deﬁned our presentation protocol in terms of a
single credential, we could generalize our deﬁnitions and
constructions to allow the user to prove relationships be-
tween attributes across multiple credentials that he owns.
We chose the above variant because it allows for fairly sim-
ple deﬁnitions, yet still allows us to consider properties of a
credential scheme as it would be used.

Note that the standard approach of requiring that the Show
protocol be a proof of knowledge of a credential cannot be
directly applied here because the veriﬁer must know the is-
suer secret key in order to verify the credential. This is
somewhat similar to a designated veriﬁer proof [24], but it
has the additional complication that the statement (validity
of the credential) depends on the veriﬁer’s secret key.

4.1 Security properties
A keyed-veriﬁcation credential system should have the fol-
lowing security properties (deﬁned formally in [2]).
Infor-
mally, correctness requires that every credential generated
by Issue for attribute set {m1, . . . , mn} can be used to gener-
ate a proof for any statement satisﬁed by that attribute set.
Unforgeability requires that an adversary cannot produce an
accepting proof for a statement φ that is not satisﬁed by
any of the attribute sets for which it has received creden-
tials. Anonymity requires that the proofs produced by Show
reveal nothing more than the statement being proved. Blind

1211issuance requires that BlindIssue, BlindObtain deﬁne a secure
two-party protocol for generating credentials on the user’s
attributes. Finally, key-parameter consistency requires that
the probability that an adversary can ﬁnd two secret keys
that correspond to the same set of issuer parameters is neg-
ligible; this guarantees that the issuer cannot use diﬀerent
secret keys with diﬀerent users and thus compromise their
anonymity.

4.2 Keyed-veriﬁcation credentials from DDH
We now give a construction of a keyed-veriﬁcation creden-
tial system from an algebraic MAC, as presented in Sec-
tion 3. We describe each protocol ﬁrst in the abstract, and
then using the speciﬁc algorithms for MACDDH = (SetupDDH,
KeyGenDDH, MACDDH, VerifyDDH). (The MACGGM algorithms
are a straightforward simpliﬁcation of the ones here, and we
present them separately in the full version [2].)

We ﬁrst deﬁne the following setup algorithms for the creden-
tial system. Brieﬂy, Setup runs the MAC setup to generate
system parameters for the MAC scheme, and CredKeygen
runs the MAC key generation to generate a MAC key which
will be the issuer secret key and additional values iparams
which will be used as the issuer’s public key.
Setup(1k): Output (G, p, g, h) $←− SetupDDH(1k).
CredKeygen(params): Compute ﬁrst the MAC keys as (( (cid:126)X,
(cid:126)Y ), ((cid:126)x, (cid:126)y, z)) $←− KeyGenDDH(params). Now commit to
the secret values by picking ˜x, ˜y, ˜z ∈R Fp and form-
ing commitments Cx0 := gx0 h˜x, Cy0 := gy0 h˜y, and
Cz := gzh˜z. Output iparams = ( (cid:126)X, (cid:126)Y , Cx0 , Cy0 , Cz)
and sk = ((cid:126)x, (cid:126)y, z, ˜x, ˜y, ˜z).

Issuance. Brieﬂy, to issue a credential on a set of attributes,
when all the attributes are known to the issuer, the issuer
will generate a MAC on those attributes, and prove that
it has done so correctly. More speciﬁcally, to issue a cre-
dential with the attributes (cid:126)m ∈ Fn
q , the issuer computes
$←− MACDDH(sk , (cid:126)m), and returns σ to
σ = (σw, σx, σy, σz)
the user with a proof π that proves knowledge of the secret
key needed to compute σ. For MACDDH,

π := PK{((cid:126)x, (cid:126)y, z, ˜x, ˜y, ˜z) : VerifyDDH(sk , (cid:126)m, σ)
∧ Cx0 = gx0 h˜x ∧ Cy0 = gy0 h˜y ∧ Cz = gzh˜z
∧ Xi = hxi ∧ Yi = hyi ∀i ∈ {1, . . . , n}}.

The proof π proves that the credential is well-formed with
respect to the system and issuer parameters. If this proof
veriﬁes, the user outputs σ; otherwise it outputs ⊥.
If some subset H ⊆ {1, . . . , n} of the attributes must be
hidden, we can proceed as follows: the user can generate
encryption keys and then encrypt each of the hidden at-
tributes. Now, rather than sending the attributes to the is-
suer, the user can send these ciphertexts along with a proof
of knowledge of the plaintext. If the encryption scheme has
the appropriate homomorphic properties, the issuer can ap-
ply them to form an encryption of the MAC, along with
a proof that this encryption has been generated correctly.
Upon receiving this proof and ciphertext, the user rejects if
the proof does not verify, and otherwise decrypts the cipher-
text to obtain the credential.

$←− Fp, computes σw = gb, σz = σz

tion Ex of σx = gbx0(cid:81)n
σy = gby0(cid:81)n

Concretely, the user generates an ElGamal keypair (d, γ =
gd) and encrypts each hidden attribute mi as Ei = (gri , gmi γri )
for ri ∈R Fp. Upon receiving these ciphertexts (along with
the proof of knowledge of {ri, mi}i∈H), the issuer chooses
b
w, and uses the ho-
momorphic properties of ElGamal to generate an encryp-
1 (gmi )bxi and an encryption Ey of
1 (gmi )bxi . It then randomizes these to obtain
$←− Fp and multiplying in an encryption
E(cid:48)
x (by picking rx
(grx , g0γrx ) of 0) and E(cid:48)
y) to the
user and gives a proof that these values have been generated
correctly with respect to ( (cid:126)X, (cid:126)Y , Cx0 , Cy0 , Cz) (i.e., a proof
of knowledge of the appropriate ((cid:126)x, (cid:126)y, z, ˜x, ˜y, ˜z, b, rx, ry)). If
the proof does not verify, the user outputs ⊥. Otherwise,
the user decrypts E(cid:48)
y to get σx and σy respectively,
and outputs σ = (σw, σx, σy, σz).

y. It sends (σw, σz, E(cid:48)

x and E(cid:48)

x, E(cid:48)

Credential translation. In addition to proving that the
ciphertexts Ei are well formed, the user can include proofs
about the attributes the ciphertexts encrypt. For example,
the user may prove that some of the attributes mi are the
same as in another credential, such as one that is more ex-
pensive to use (e.g., an Idemix credential), or one that can-
not be presented multiple times unlinkably (e.g., a U-Prove
credential).

Credential presentation. Here we present a construction
for Show and ShowVerify. We focus on how to show that the
credential certiﬁes attributes matching those in a given set
of commitments. Once commitments have been established,
the user can prove a large variety of statements about the
committed values, using e.g. the techniques in [8].

Roughly, the protocol proceeds as follows: The prover forms
Pedersen commitments to the MAC, and the messages, and
proves that these were computed correctly. Using the homo-
morphic property of the commitments, the veriﬁer is able to
recompute the MAC and compare it to the committed value.
However, because of the randomness in the commitments,
there will be some additional terms in the MAC the veriﬁer
computes; the user will use (cid:126)X, (cid:126)Y from iparams to compute
exactly those values necessary to cancel these terms, and
again prove that these values are correctly computed.
Show(params, iparams, φ, cred ,{mi}n

i ): The prover chooses
$←− Fp and parses cred = (σw, σx,
r, rx, ry, z1, . . . , zn
σy, σz). It ﬁrst randomizes the credential by comput-
ing σw = σr
z , and
then computes {Cmi
i=1, Cσx := σxgrx ,
n(cid:89)
Cσy := σygry ,

x, σy = σr
w hzi}n
:= σmi

y, and σz = σr

w, σx = σr

n(cid:89)

−rx

−ry

Vx := g

X zi

i , and Vy := g

Y zi
i

.

i=1

i=1

It then sends σ = (σw, σz, Cσx , Cσy , Vx, Vy,{Cmi}n
i )
along with a proof of knowledge π, which it computes
as
π = PK{ (cid:126)m, (cid:126)z,−rx,−ry) : φ(m1, . . . , mn) = 1

n(cid:89)
w hz1 ∀ i ∈ {1, . . . , n}
∧ Cmi = σm1
zi ∧ Vy = g
∧ Vx = g
−ry
−rx

Xi

n(cid:89)

i }.
Y zi

i=1

i=1

1212ShowVerify(params, iparams, φ,{xi, yi}n

parses σ = (σw, σy, σz, Vx, Vy,{Cmi}n
veriﬁes that
σx0
w

(cid:81)n

(cid:81)n

Vx =

and Vy =

i=1 C xi
mi
Cσx

σy0
w

i=1 C yi
mi
Cσy

i , z, σ, π): The veriﬁer
i , Cσx , Cσy ) and

MACDDH, and Idemix credentials are smaller than U-Prove
credentials once s > 5.

.

Credential size for s shows, n attributes
Asymptotic

Concrete (in bits)

It then veriﬁes the proof π. If the proof is valid and if
σz = σz
w it accepts and outputs (Cm1 , . . . , Cmn ), and
otherwise it rejects and outputs ⊥.

Security. A proof of the following theorem can be found in
Appendix A.

Theorem 4. If DDH holds and the proof system is a ZK
proof of knowledge with the strengthened extraction prop-
erty3, the algorithms (CredKeygen, Issue, CredVerify, Show
ShowVerify, BlindIssue, BlindObtain) deﬁned above make up a
secure keyed-veriﬁcation credential system.

Intuitively, credential unforgeability follows from the un-
forgeability of the MAC (which is based on DDH); credential
anonymity follows from the zero knowledge property of the
proofs; blind issuance follows from the extractability of the
proofs and the IND-CPA security of the encryption scheme
(which, for ElGamal, follows from DDH); and key-parameter
consistency follows from the binding property of the com-
mitment scheme (which, for Pedersen commitments, follows
from the discrete log assumption, which is implied by DDH).

5. EFFICIENCY
In this section we compare the eﬃciency of our new schemes
to U-Prove and Idemix. We focus on the computational cost
of creating a presentation proof, as this operation typically
must be done by the largest range of devices. We consider
the MACGGM- and MACDDH-based schemes, where the proof
system is implemented with Fiat-Shamir (full details for
MACGGM are given in [2], and MACDDH is very similar). Using
the interactive proof system from [17] will have essentially
the same computational cost. Complete descriptions of Ide-
mix and U-Prove are available in [23] and [26] respectively.
As the recent scheme of Baldimtsi and Lysyanskaya [3], is
strictly less eﬃcient than U-Prove, we omit it from our com-
parison. For the bilinear CL signature schemes [1, 11], de-
tailed speciﬁcations and parameter choices are not available;
we made a rough estimate assuming the scheme was imple-
mented with a 256-bit elliptic curve group, and that a pair-
ing requires 1ms on our benchmark hardware. We ignored
the cost of arithmetic in the target group (i.e., GT the range
of the pairing), thus underestimating the cost.

Credential Size. Table 1 shows the size of a credential in all
four schemes, both asymptotically, and for a concrete choice
of parameters. The parameter s is the number of times the
credential may be shown unlinkably (which is relevant for
U-Prove). The size only counts the cryptographic compo-
nents of the credential, the metadata and attribute values
are assumed to be the same for all systems. The overhead
of MACGGM is the lowest, followed by MACDDH, which is the
size of a single U-Prove token. The size of SRSA group el-
ements makes Idemix credentials larger than MACGGM and
3See discussion in 2 and the full version[2].

U-Prove
Idemix
Bilinear CL
MACGGM
MACDDH

O(s)
O(1)
O(n)
O(1)
O(1)

1024s
5369

512n + 768

512
1024

Table 1: Comparison of credential sizes of U-Prove,
Idemix, MACGGM and MACDDH. The number of times
the credential may be shown is denoted s. U-Prove,
bilinear CL, MACGGM and MACDDH use a 256-bit ellip-
tic curve group. Idemix uses a 2048-bit modulus.

Computation Cost for Presentation. We estimate the cost
of creating a presentation proof and compare the four schemes.
Our estimate is formed by counting the number of multi-
exponentiations required to create a presentation proof. We
use the notation (cid:96)-exp to denote computing the product of (cid:96)
powers. To realistically estimate the performance of Idemix,
the bitlengths of the exponents must also be considered, so
we use the notation (cid:96)-exp(b1, . . . , b(cid:96)) to denote the prod-
uct of (cid:96) powers when the bitlengths of the exponents are
b1, . . . , b(cid:96). These bitlengths are calculated from the Idemix
speciﬁcation [23]. For U-Prove, MACGGM and MACDDH the
bitlength of the exponent is always the length of the group
order (256-bits in our comparison).

Table 2 gives the number of multi-exponentiations in terms
of three parameters: n is the number of attributes in a cre-
dential, r is the number of revealed attributes in a presenta-
tion proof, and c is the number of committed attributes. (As
discussed in section 4, we focus on the part of the protocol
which proves that certiﬁed attributes match those in a set
of commitments; the rest of the presentation is essentially
the same in all of the schemes we consider. We diﬀerentiate
between revealed and committed attributes because one can
simplify the protocols in the case where attributes will be di-
rectly revealed. For details see the full version [2].) For each
committed attribute m, a separate Pedersen commitment is
output. As a further comparison, Table 2 includes the time
required to compute these multi-exponentiations for a given
choice of parameters (n, c, r). Our multi-exponentiation im-
plementation in G uses the NIST 256-bit elliptic curve, and
for Idemix uses the parameters in [23]. The benchmarks
were computed on an Intel Xeon CPU (E31230, quad core,
3.2 GHz) on an HP Z210 workstation running Windows 7
(64-bit). The times are in milliseconds, and are the average
of 100 runs.

The times given in Table 2 show that the new schemes
are competitive with U-Prove, especially when most of the
attributes are committed, and that they are much faster
than Idemix.
In particular, in the ﬁrst benchmark (when
(n, c, r) = (10, 2, 2)), MACGGM is 6.28 times faster than Ide-
mix, and MACDDH is 4.7 times faster than Idemix. Com-
pared to U-Prove, MACGGM and MACDDH are 3.4 and 4.5
times slower, much less than the 21.2 times slowdown for
Idemix.

1213U-Prove
MACGGM

MACDDH

Idemix

Number of exponentiations
1 (n − r + 1)-exp, 2c 2-exp
3 1-exp, 1 (n − r + 1)-exp
2(n − r) 2-exp
6 1-exp, 2 (n − r + 2)-exp
2(n − r + 1) 2-exp
1 1-exp(2048)
c 2-exp(256, 2046)
c 2-exp(592, 2385)
1 (n − r + 2)-exp(456,3060,592,. . . ,592)

Time (in ms) when (n, c, r) =
(10,2,2)

(10,10, 0)

3.38
11.42

15.31

71.72

12.43
13.93

18.10

226.79

Bilinear CL 3 + n pairings

20.98

28.32

(3 + n) 1-exp, 2c 2-exp

Table 2: Comparison of estimated presentation proof generation cost. U-Prove, bilinear CL, MACGGM and
MACDDH use 256-bit elliptic curve parameters, and Idemix uses a 2048-bit modulus.

In the second benchmark, when (n, c, r) = (10, 10, 0), the
performance of U-Prove, MACGGM and MACDDH are very
similar. MACGGM and MACDDH are only 1.04 and 1.5 times
slower than U-Prove.
Idemix is 18.2, 16.3 and 12.5 times
slower than U-Prove, MACGGM and MACDDH, respectively.

Discussion. These performance estimates show that the
new schemes do provide a considerable performance advan-
tage when compared to Idemix, and a small decrease com-
pared to U-Prove. The other protocols, namely issuance and
veriﬁcation, have similar relative performance (for the user
and issuer). In the case of issuance, our new schemes are
expected to have slightly higher computational cost than is-
suing a single U-Prove token, but with one less round of
interaction (when implemented with Fiat-Shamir proofs).
When issuing multiple tokens, MACGGM and MACDDH have
the best performance. In all protocols, the cost of veriﬁca-
tion is within a small factor of the cost of proof generation.

We note some limitations of our comparison. First, the com-
parison is limited to applications where the issuer and ver-
iﬁer share a key; otherwise MACGGM and MACDDH are not
applicable. The parameter set used for Idemix is not be-
lieved to provide 128-bit security, so this favors Idemix in
the comparison. For RSA, a 3072-bit modulus is required
for 128-bit security, and for strong RSA we are unaware of
any published guidance on choosing the modulus size. (Ide-
mix would need at least a 3072-bit modulus for 128-bit se-
curity.) Another limitation is our choices of (n, c, r), which
will be diﬀerent across applications. Once an application
is ﬁxed, optimizations may be possible, such as creating a
single commitment to multiple attributes, or re-using the
same commitment in multiple presentations (e.g., when the
commitment is used as a pseudonym).

Acknowledgments
This work was done in part while Sarah Meiklejohn was
an intern at MSR Redmond and in part while she was a
graduate student at UC San Diego, funded by CNS-1237264
and support from the UCSD Center for Networked Systems
(CNS).

6. REFERENCES

[1] M. Au, W. Susilo, and Y. Mu. Constant-size dynamic k-TAA.

Proceedings of SCN 2006, LNCS 4116 (2006), 111-125.

[2] M. Chase, S. Meiklejohn, and G. Zaverucha. Full version of this

paper. IACR Cryptology ePrint Archive, Report 2013/516.

[3] F. Baldimtsi and A. Lysyanskaya. Anonymous Credentials Light.
Proceedings of ACM CCS 2013, ACM Press, (2013). To appear.

[4] M. Belenkiy, J. Camenisch, M. Chase, M. Kohlweiss, A.
Lysyanskaya and H. Shacham. Randomizable proofs and
delegatable anonymous credentials. Proceedings of CRYPTO
2009, LNCS 5677, (2009), 108–125.

[5] M. Bellare and O. Goldreich. On Deﬁning Proofs of Knowledge.

Proceedings of CRYPTO 1992, LNCS 740 (1993), 390–420

[6] P. Bichsel, J. Camenisch, T. Groß, and V. Shoup. Anonymous
Credentials on a Standard Java Card. Proceedings ACM CCS
2009, ACM Press, (2009) 600–610.

[7] D. Boneh. The Decision Diﬃe-Hellman Problem. Proceedings of

ANTS-III, LNCS 1423 (1998), 48–63.

[8] S. Brands. Rethinking Public Key Infrastructures and Digital

Certiﬁcates. The MIT Press, August 2000.

[9] J. Camenisch and A. Lysyanskaya. An Eﬃcient System for

Non-Transferable Anonymous Credentials with Optional
Anonymity Revocation. Proceedings of EUROCRYPT 2001,
LNCS 2045 (2001), 93–118.

[10] J. Camenisch and A. Lysyanskaya. A Signature Scheme with

Eﬃcient Protocols. Proceedings of SCN 2003, LNCS 2576
(2003), 268–289.

[11] J. Camenisch and A. Lysyanskaya. Signature Schemes and
Anonymous Credentials from Bilinear Maps. Proceedings of
CRYPTO 2004, LNCS 3152 (2004), 56–72.

[12] J. Camenisch and M. Stadler. Proof Systems for General

Statements About Discrete Logarithms. Technical Report TR
260 (1997), Institute for Theoretical Computer Science, ETH
Zurich.

[13] D. Cash, E. Kiltz, and V. Shoup. The Twin Diﬃe-Hellman

Problem and Applications Proceedings of Eurocrypt 2008,
LNCS 4965 (2008), 127–145.

[14] D. Chaum. Security without Identiﬁcation: Transaction

Systems to Make Big Brother Obsolete. Communications of the
ACM 28(10) (1985), 1030–1044.

[15] J. Chen, H. Lim, S. Ling, H. Wang, and H. Wee. Shorter IBE

and Signatures via Asymmetric Pairings. Proceedings of Pairing
2012, LNCS 7708,(2012), 122–140.

[16] R. Cramer, R. Gennaro, and B. Schoenmakers. A Secure and

Optimally Eﬃcient Multi-Authority Election Scheme.
Proceedings of EUROCRYPT’97, LNCS 1233, (1997), 103–118.

[17] I. Damg˚ard. Eﬃcient Concurrent Zero-Knowledge in the

Auxiliary String Model. Proceedings of EUROCRYPT 2000,
LNCS 1807 (2000), 418-430.

[18] Y. Dodis, E. Kiltz, K. Pietrzak, D. Wichs. Message

Authentication, Revisited. Proceedings of EUROCRYPT’12,
LNCS 7237 (2012), 355–374.

[19] A. Fiat and A. Shamir. How to Prove Yourself: Practical

Solutions to Identiﬁcation and Signature Problems. Proceedings
of CRYPTO 1986, LNCS 263 (1987), 186-ˆa ˘A¸S194.

1214[20] M. Fischlin. Communication-Eﬃcient Non-Interactive Proofs of

Knowledge with Online Extractors. Proceedings of CRYPTO
2005, LNCS 3621 (2005), 152–168.

[21] M. Gerbush, A. Lewko, A. O’Neill, and B. Waters Dual Form

Signatures: An Approach for Proving Security from Static
Assumptions. Proceedings of ASIACRYPT 2012, LNCS 7658
(2012), 25–42.

[22] O. Goldreich. The Foundations of Cryptography - Volume 2

Basic Applications. Cambridge University Press, New York,
2004.

[23] IBM. Speciﬁcation of the Identity Mixer Cryptographic Library

(Revised version 2.3.0). IBM Research Report RZ 3730, April
2010.

[24] M. Jakobsson, K.Sako, and R. Impagliazzo. Designated Veriﬁer

Proofs and Their Applications. Proceedings of EUROCRYPT
1996, LNCS 1070 (1996) 143–154.

[25] NIST. FIPS 186-3: Digital Signature Standard (DSS), Federal

Information Processing Standards Publication (2009).
[26] C. Paquin and G. Zaverucha. U-Prove Cryptographic

Speciﬁcation V1.1 (Revision 2). April 2013. Available online:
www.microsoft.com/uprove.

[27] C. Schnorr. Eﬃcient Signature Generation by Smart Cards.

Journal of Cryptology 4 (1991), 161-174.

[28] C. Schnorr. Security of Blind Discrete Log Signatures Against

Interactive Attacks. ICICS 2001, LNCS 2229 (2001), 1–12.

[29] V. Shoup. Lower Bounds for Discrete Logarithms and Related

Problems. Proceedings of EUROCRYPT’97, LNCS 1233
(1997), 256–266.

[30] Y. Tsiounis and M. Yung On the security of ElGamal based

encryption. Proceedings of PKC 1998, LNCS 1431 (1998),
117–134.

[31] N. Smart. The Exact Security of ECIES in the Generic Group

Model. Proceedings of Cryptography and Coding, IMA Int.
Conf., LNCS 2260 (2001), 73–84.

[32] R. Steinfeld, J. Pieprzyk and H. Wang. How to strengthen any

weakly unforgeable signature into a strongly unforgeable
signature. Proceedings of CT-RSA 2007, LNCS 4377 (2007),
357–371.

[33] B. Waters. Dual System Encryption: Realizing Fully Secure

IBE and HIBE under Simple Assumptions. Proceedings of
CRYPTO 2009, LNCS 5677 (2009), 619–636.

APPENDIX
A. A PROOF OF THEOREM 4
We present the following algorithms, which we use when
we prove security of the scheme. Issue deﬁnes the distribu-
tion of honestly generated credentials, and CredVerify deﬁnes
whether or not a given credential is valid.

Issue(sk , (m1, . . . , mn)): Output cred

$←− MACDDH(sk , (m1,

. . . , mn), ).

CredVerify(sk , (m1, . . . , mn), cred ): Output the result of

VerifyDDH(sk , (m1, . . . , mn), cred ).

Proof. We show that these algorithms satisfy correct-

ness, unforgeability, anonymity, and blind issuance.

Correctness. For correctness we need to show two proper-
ties. First, that any credential generated as deﬁned in Issue
is accepted by CredVerify, which follows directly from cor-
rectness of the MAC. The second is that if a credential is
generated as deﬁned by Issue and then used in Show, then
it is accepted. To see this, consider the following:

ux0+(cid:80)n

1 ximi , uy0+(cid:80)n

Issue(sk , (m1, . . . , mn)) generates credentials of the form (u,
1 yimi , uz). If both Show and ShowVerify
are executed honestly, then the proof π is accepted by com-
pleteness of the proof system. Also, the honest Show com-

putes

Vx =

=

=

σw

Cσx

x0(cid:81)n
x0(cid:81)n
ux0(cid:81)n
grx ux0+(cid:80)n

1 σw
σxgrx

σw

x0(cid:81)n

mixi hxiwi

1 σw
σxgrx

1 Cmi

xi

σw

mixi

X wi

i

=

n(cid:89)
n(cid:89)

i=1

i=1

1 umixi
1 ximi

X wi

i = g

n(cid:89)

i=1

−rx

X wi

i

so the veriﬁer’s check on Vx succeeds. A similar equality
holds for Vy. Finally, since Issue produces σz = uz, the
veriﬁer’s ﬁnal check succeeds and the veriﬁer will accept.

Unforgeability. Here we prove unforgeability when A is
given credentials generated by Issue. Blind issuance then
shows that this also holds with the blind issuance protocol.
We have shown (Theorem 3) that MACDDH is unforgeable
under DDH. Suppose there exists an adversary A who can
break the unforgeability property of our credential system.
Then we can construct an algorithm B that breaks unforge-
ability of MACDDH as follows:

B receives params, iparams DDH and chooses random Cx0 , Cy0 ,
Cz
It then sends params, iparams = (iparams DDH,
Cx0 , Cy0 , Cz) to A.

$←− Fp.

When A queries the Issue oracle, B forwards the query to
its MAC oracle and returns the resulting tag.

When A queries the ShowVerify oracle: A sends σw, σz,
Cm1 , . . . , Cmn , Cσx , Cσy , Vx, Vy, and gives a proof π. If the
proof π is invalid, B returns ⊥. Otherwise B runs the proof
of knowledge extractor to extract {mi}n
1 , rx, ry. Then it
computes σx = Cσx g−rx and σy = Cσy g−ry . Finally, it
queries its Verify oracle with (m1, . . . mn), (σw, σx, σy, σz),
and outputs the result.
In the ﬁnal show protocol, B again extracts {mi}n
1 , rx, ry,
and outputs (m1, . . . mn), (σw, Cσx g−rx , Cσy g−ry , σz) as its
forgery.

First, note that B ’s response to Issue queries is identical to
the honest Issue algorithm. Then, we argue that its response
to ShowVerify queries is also with overwhelming probabil-
ity identical to the output of the honest algorithm. To see
this, note that the proof of knowledge property guarantees
that the extractor succeeds in producing a valid witness with
all but negligible probability. Furthermore, if the extractor
gives valid {mi}n

1 , rx, ry then

x0(cid:81)n

1 Cmi

Cσx

Xi

wi =

σw

Vx =

⇐⇒g

−rx

⇐⇒g

−rx

σw

n(cid:89)
n(cid:89)

1

xi

x0(cid:81)n
x0+(cid:80)n

1 (σw
Cσx

σw

mi hwi )xi

1 mixi(cid:81)n

1 hwixi

(hxi )wi =

x0+(cid:80)n

1 mixi

Cσx

⇐⇒Cσx g

1

−rx = σw

1215y0 (cid:81)n

yi

Cσy

1 Cmi

Cry σw

Similarly Vy =

if and only if Cσy g−ry =
y0+(cid:80)n
1 yimi . The ﬁnal check that the honest veriﬁer makes
σw
z. Thus, the honest veriﬁer al-
guarantees that σz = σw
gorithm accepts if and only if (σw, Cσx g−rx , Cσy g−ry , σz)
would be accepted by VerifyDDH for message (m1, . . . , mn).

Similarly, we can argue that B extracts a valid MAC from
the ﬁnal show protocol whenever ShowVerify would have
output 1. Thus, if A can cause ShowVerify to accept for
some statement φ that is not satisﬁed by any of the at-
tribute sets queried to Issue, then B extracts a new message
(m1, . . . , mn) and a valid tag for that message.

Anonymity. Suppose the user is trying to prove that he
has a credential for attributes satisfying some statement
φ. Then we want to show that there exists an algorithm
SimShow that for the adversary is indistinguishable from
Show, but that only takes as input the statement φ and the
secret key sk . Let φ ∈ Φ and (m1, . . . , mn) ∈ U be such
that φ(m1, . . . , mn) = 1. Let (iparams, sk ) be in the range
of CredKeygen, and let cred be such that CredVerify(sk , cred ,
(m1, . . . , mn)) = 1.

Then SimShow(sk , φ) behaves as follows:
dom values σw, Cσx , Cσy , Cm1 , . . . , Cmn
{xi, yi}n
0 , z from sk to compute σz = σw
and Vy =
. It runs A with these values as the
ﬁrst message, and then simulates the proof of knowledge,
and outputs whatever A outputs at the end of the proof.

It chooses ran-
$←− G. It then uses
1 Cmi
z, Vx =

x0 (cid:81)n

y0 (cid:81)n

1 Cmi

Cσx

Cσy

σw

xi

σw

yi

y0+(cid:80)n

x0+(cid:80)n

1 yimi , and σz = σw

First note Cσx , Cσy , Cm1 , . . . , Cmn are distributed identi-
cally to those produced by Show. Next, note that for any
cred such that CredVerify(sk , cred , (m1, . . . , mn)) = 1, ran-
domizing the credential produces the same distribution as
1 ximi ,
choosing random σw and computing σx = σw
z for the values z,{xi, yi}n
σy = σw
0
in sk . Thus, σw, σz is also distributed identically to those
produced by Show.
Finally, note that if we deﬁne rx, ry,{wi}i to be the values
1 yimi gry ,
such that Cσx = σw
and Cmi = umi hwi for the random values Cσx , Cσy , Cm1 , . . . ,
Cmn chosen by SimShow, then the calculation above in the
proof of correctness shows that the Vx, Vy that SimShow
computes is identical to those that the honest Show would
have produced.

1 ximi grx , Cσy = σw

x0+(cid:80)n

y0+(cid:80)n

By the zero knowledge property of the proof of knowledge,
we conclude that the resulting view is indistinguishable from
that produced by the adversary interacting with Show.

Blind issuance. First, we consider the setting where all of
the attributes are known to the issuer and we use the sim-
pler algorithm. Consider the case where the user is corrupt.
Then our 2PC simulator on shared input (S, iparams) re-
ceives the user’s list of attributes (m1, . . . , mn) and forward
it to the functionality. The functionality returns “attribute
error” if S (cid:54)= (m1, . . . , mn) and otherwise it returns cred . If
the error does not occur, the 2PC simulator then sends cred
and runs the proof of knowledge ZK simulator to simulate

the proof of correctness for cred . By zero knowledge, this is
indistinguishable from the real world.

Next, we consider the case where the issuer is corrupt. In
this case our 2PC simulator receives cred = (σw, σx, σy, σz)
from the issuer and runs the veriﬁer for the proof system.
If the proof accepts, it runs the proof of knowledge extrac-
tor to extract sk = ({xi}n
It
sends (sk , r) to the ideal functionality. By the proof of
knowledge property, the credential sent in the real world
z)
is σw, σw
which is exactly what would be produced by the ideal func-
tionality on input the (sk , r) described above.

0 , ˜x, ˜y, ˜z) and r = σw.

x0(cid:81)n

y0(cid:81)n

mi )xi , σy = σw

mi )yi , σz = σw

0 ,{yi}n

1 (σw

1 (σw

Then, we consider the more complex algorithm which allows
hidden attributes. Consider the case where the user is cor-
rupt. Then our 2PC simulator on shared input (S, iparams)
receives the user’s list of ciphertexts (E1, . . . , En), and run
the veriﬁcation for the proof of knowledge. If the proof ac-
cepts, it then uses the proof of knowledge extractor to ex-
tract {mi}i∈H and send it along with the set S to the func-
tionality. The functionality returns cred = (σw, σx, σy, σz).
The 2PC simulator then computes an encryption E(cid:48)
x of σx
and an encryption E(cid:48)
y) to the
user, and uses the ZK simulator to simulate the correct-
ness proof. Note that in the real BlindIssue protocol,
if
E1, . . . , En are encryptions of gm1 , . . . , gmn , then the result-
ing Ex, Ey is distributed identically to a fresh encryption of
mi )yi . Thus, these are iden-
σw
tical to what the simulator produces.

y of σy, send (σw, σz, E(cid:48)

x0(cid:81)n

y0(cid:81)n

mi )xi , σw

x, E(cid:48)

1 (σw

1 (σw

,

0 ,{yi}n

0 , ˜x, ˜y, ˜z) and r = σw.

Next, we consider the case where the issuer is corrupt. In
this case our 2PC simulator generates encryptions Ei of 1
for all i ∈ H, sends them to A, and simulates the proof.
It then receives cred = (σw, σx, σy, σz) from A and runs
the veriﬁcation of the proof of knowledge; if the proof is
accepting, it runs the proof of knowledge extractor to ex-
tract sk = ({xi}n
It sends
(sk , r) to the ideal functionality. To see that this is in-
distinguishable from the real game, consider the following
series of games. The ﬁrst game G1 is identical to the real
game, except that instead of computing σx, σy by decrypt-
ing the ciphertexts Ex, Ey, we run the proof of knowledge
extractor to extract sk , r and use those to form the cre-
dential by running Issue. By the proof of knowledge prop-
erty and correctness and homomorphic properties of the en-
cryption scheme, the credential sent in the real world is
z, mn) which is
(σw, σw
exactly what would be produced by the ideal functionality
on input the (sk , r) described above. Next, in game G2 we
replace the proof of knowledge of the messages in Ei with a
simulated proof - by zero knowledge this is indistinguishable.
Finally, we note that the only diﬀerence between this game
and the simulated game is that Ei is generated as an en-
cryption of gmi rather than 1; thus the two games are indis-
tinguishable by CPA-security of Elgamal encryption (which
follows from DDH [30]).

x0(cid:81)n

y0(cid:81)n

mi )xi , σw

mi )yi , σw

1 (σw

1 (σw

Key-parameter consistency. This follows under the dis-
crete log assumption from the binding property of the Ped-
ersen commitment scheme. (Note that the discrete log as-
sumption is implied by DDH.)

1216