Fast Non-Malleable Commitments

Hai Brenner∗

Vipul Goyal†

Silas Richelson‡

Alon Rosen§

Margarita Vald¶

ABSTRACT
The notion of non-malleability in cryptography refers to the
setting where the adversary is a man-in-the-middle (MIM)
who takes part in two or more protocol executions and tries
to use information obtained in one, to violate the security
of another. Despite two decades of research, non-malleable
commitments (NMCs) have remained too ineﬃcient to be
implemented in practice, without some sort of trusted setup.

In this work, we give a fast implementation of NMC in
the plain model, based on the DDH assumption being hard
over elliptic curve groups. Our main theoretical result is
a new NMC scheme which can be thought of as a “high
dimensional” generalization of the one in the recent work
of [GRRV14]. Central to our eﬃciency improvements is a
method of constraining challenges sent by the receiver. This
new approach enables us to obtain dramatically improved
parameters over those suggested in [GRRV14]. In particu-

Research,

Bangalore.

∗Eﬁ Arazi School of Computer Science, IDC Herzliya, Is-
rael. Email: haibrenner@gmail.com Research supported by
the ERC under the EU’s Seventh Framework Programme
(FP/2007-2013) ERC Grant Agreement n. 307952.
†Microsoft
Email:
vipul@microsoft.com.
Part of this work done while
visiting IDC Herzliya.
‡UCLA. Email: SiRichel@ucla.edu. Work done while vis-
iting IDC Herzliya. Supported by the European Research
Council under the European Union’s Seventh Framework
Programme (FP/2007-2013) / ERC Grant Agreement n.
307952
§Eﬁ Arazi School of Computer Science, IDC Herzliya, Is-
rael. Email: alon.rosen@idc.ac.il. Work supported by
ISF grant no.
1255/12 and by the European Research
Council under the European Union’s Seventh Framework
Programme (FP/2007-2013) / ERC Grant Agreement n.
307952.
¶The Blavatnik School of Computer Science, Tel Aviv
University, Israel. Email: margarita.vald@cs.tau.ac.il.
Work supported in part by ISF grant no. 1255/12.

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS’15, October 12–16, 2015, Denver, Colorado, USA.
c(cid:13) 2015 ACM. ISBN 978-1-4503-3832-5/15/10 ...$15.00.
http://dx.doi.org/10.1145/2810103.2813721 .

lar, our work opens the door to implementations based on
Elliptic Curves.

Our prototype implementation gives evidence of our pro-
tocol’s eﬃciency. Additionally, like the Elgamal commit-
ment it is built on top of, our scheme allows for homom-
rphic operations on committed values, and is amenable to
fast Schnorr proofs of knowledge. Thus, it will work well
when used as a building block inside larger cryptographic
protocols. As an example of its performance, our protocol
allows a committer to commit to a 1.9−KB message using
a scheme supporting 220 identities in less than one second.

Categories and Subject Descriptors
F.2.0 [Theory of Computation]: Analysis of Algorithms
and Problem Complexity—General

General Terms
Cryptography, Theory

Keywords
Non-malleable Commitments; Elliptic Curve Cryptography;
Protocols; Practical implementation

1.

INTRODUCTION

Secure computation was introduced in the 1980s and still
remains an active area of research. Over the years classical
feasibility results [Yao86, GMW87, BGW88] have given way
to constructions which are both more eﬃcient and which
satisfy stronger notions of security.
In recent works we
have seen a push towards obtaining “practice-oriented” pro-
tocols [IKO+11, Lin13, FJN+13, LR14, AMPR14] (and the
references there-in). Several concrete secure computation
systems building upon these improvements have been imple-
mented (e.g. the JustGarble system [BHKR13]). The goal
of this work is to initiate and promote the study of non-
malleable commitments from the practical eﬃciency per-
spective.
1.1 Non-Malleable Commitment

Non-malleable cryptography models the scenario where
the adversary is a man-in-the-middle (MIM) who partici-
pates in two or more instantiations of a protocol and tries to
use information obtained in one execution to harm the secu-
rity of another. Many tasks in cryptography are susceptible
to such an attack, and thus non-malleable security arises

1048naturally in many settings (e.g. commitment, encryption,
coin-ﬂipping witness-indistinguishable and zero-knowledge
proofs, etc.). Interest in non-malleable security is motivated
both by the strong security guarantees it provides, and by
the unfortunate reality that many widely used protocols are
actually highly malleable.

Non-malleable commitment (NMC), introduced by Dolev,
Dwork and Naor [DDN91], is especially well studied, and has
proven to be an immensely useful primitive. Very brieﬂy we
say that a commitment scheme is non-malleable if for ev-
ery message m, no MIM adversary, intercepting a commit-
ment Com(m) and modifying it at will, is able to eﬃciently
generate a commitment to a related message ˜m. NMC is
extremely versatile and is often used as a building block in
more complex protocols. For example, it is known how to
use NMC to construct several other non-malleable primitives
such as zero-knowledge proofs.

Because of its applications across cryptography, the ef-
ﬁciency of NMC has been studied extensively. Beginning
with [DDN91], who gave a protocol for NMC with O(log n)
rounds, research over the last two decades has improved
the round complexity from logarithmic to constant [Bar02,
PR05, Goy11, LP11] and recently to just 4 rounds [GRRV14].
However common to most of these works is that they use
computationally heavy tools (such as generic zero-knowledge
proofs) leading to quite ineﬃcient protocols. The focus of
our work is on obtaining eﬃcient non-malleable commit-
ments, usable in practice.
1.2 Motivation

Constant Round Multi-Party Computation. Non-malleable
commitments are important building blocks in round-eﬃcient
multi-party computation (MPC) protocols. Without some
form of non-malleability, any MPC protocol must have round
complexity that is at least linear in the number of parties,
since in protocols with sublinear round complexity, multiple
parties must commit to their inputs in parallel. When the
fraction of corrupt parties is less than 1/2, one can use in-
formation theoretic veriﬁable secret sharing (VSS). However
when the corruption threshold increases above 1/2, infor-
mation theoretic techniques fail and cryptographic subpro-
tocols are needed.
It is known how to construct constant
round MPC protocols with high corruption tolerance using
constant round NMC [Pas04, Wee10, Goy11] (essentially by
replacing the VSS with NMC). Traditionally VSS is thought
to be much more eﬃcient than NMC, however in this work
we give evidence that this isn’t the case. Our prototype
implementation has computation and communication com-
plexity which is comparable with that of widely used VSS
schemes. In this way our work allows one to increase the
corruption tolerance of an eﬃcient MPC scheme above 1/2
without incurring a penalty.

Composable Security. Another application of NMC is
to the area of secure protocol composition [DNS98, Fei90,
Can01]. So far, all work on eﬃcient secure computation
that we are aware of focuses on the standalone setting. De-
signing protocols which are secure in the more demanding
(though realistic) models which allow for protocol composi-
tion is vastly more diﬃcult. Over the past decade [CLOS02,
BS05, Goy12] has shown that non-malleability lies at the
heart of protocol composition; MIM attacks seem to be the

most devastating. Our work takes an important step toward
the goal of attaining eﬃcient protocols which are provably
secure in composition.

Sigma Protocols. Probably the most useful aspect of
the Elgamal commitment scheme is its seamless compatibil-
ity with Schnorr proofs of knowledge, thus allowing a com-
mitter to prove knowledge of his committed value, or that
two committed values are equal.
In fact, the recent work
of [AMPR14] shows that these plus several other techniques
“go all the way” to an eﬃcient protocol for general 2PC.
Our NMC prototype is instantiated on top of the Elgamal
commitment scheme and inherits all of the fast Σ−protocols
available to the original. NMC is most commonly used as a
subprotocol, so compatibility with usual cryptographic op-
erations is an important feature. Such compatibility is not
oﬀered by most schemes which use a random oracle.

Comparison with NMC in the Random Oracle Model.
Prior to this work, we are not aware of any attempts to
implement non-malleable commitments in the plain model.
In part this is because such a simple solution exists in the
random oracle model: Com(m; r) = H(m, r) where H is
the random oracle. However our construction has some ad-
vantages over this trivial one. First, our implementation is
provably secure under well understood and widely accepted
assumptions. This is in contrast to the random oracle heuris-
tic which is known to break down as soon as the random or-
acle is replaced by a speciﬁc hash function. Second, as men-
tioned above, our protocol is compatible with fast proofs of
knowledge of committed values and Σ−protocols for prov-
ing that these values satisfy certain relations. The above
and other random oracle constructions (such as the recent
one from [CJS14]) need to use cut-and-choose techniques
for such proofs, which introduces extra rounds of interac-
tion and requires more communication than our protocol.
1.3 Results

The recent work of [GRRV14] gives a relatively simple,
round-eﬃcient NMC. However (as remarked by the authors),
the proof of non-malleability requires choosing parameters
which are much too large to be used in practice. In fact, at-
tempting to instantiate their protocol with more reasonable
parameter choices opens the door to actual attacks. Exact
communication/computation complexities are shown in Ta-
ble 2, but just to give an idea: one execution of the protocol
instantiated over the DDH group Zq with 2−80 security and
supporting 216 identities (for background on the identities,
see Section 2.4) requires the committer to compute about
4000 exponentiations in Zq where q is a 6000−bit prime. In
this work we give a new NMC scheme which is similar to that
of [GRRV14] (in particular, it is provably secure in the plain
model) but has much better performance. For example, for
the security and identity parameters mentioned, our scheme
requires C to compute fewer than 600 exponentiations in
elliptic curve over GF (p), where p can be few hundred bit
prime of our choice. 1

Theorem 1. There exists a four-round, statistically bind-
ing, non-malleable commitment scheme which, when instan-
1R has to compute many more exponentiations than C in
the na¨ıve protocol. However, since these are during the veri-
ﬁcation phase, optimization techniques such as batching are
available to reduce R’s workload considerably.

1049tiated over any DDH group, requires C (resp. R) to perform
18k (resp. 4k2) exponentiations where k is the length of
identities supported (in bits). Furthermore, all of R’s expo-
nentiations take place during the decommitment phase (and
so may be done oﬄine, and are subject to optimizations).

Our prototype implementation is instantiated over an ellip-
tic curve group G and is secure assuming that DDH is hard
over G. This is the ﬁrst implementation of a NMC scheme
whose proof of security does not use random oracles, or some
other form of trusted setup. Our implementation capitalizes
on several optimizations. For example, we use batching to
reduce the computation complexity of the receiver during
veriﬁcation to below what are shown in Table 2. Speciﬁc
performance numbers for a variety of parameters is shown
in Table 1.

We stress that our scheme can be instantiated over any
DDH group; it does not place restrictions on the size of the
group. See Table 2 for more eﬃciency-related information.
Additionally, we note that our new scheme is general (it
can be instantiated from any one-way function), and though
we have chosen to focus on a DDH−based instantiation, it
could be implemented, giving similar results, starting from
any homomorphic commitment scheme.

Next we increase the message space of our new NMC
scheme. The basic protocol allows a committer C to com-
mit to a vector m ∈ Z(cid:96)
q where q is any prime speciﬁed by the
the protocol and (cid:96) depends linearly on the length of iden-
tites the scheme can support (for most choices of q, (cid:96) = 2k
where the scheme can support 2k identities is natural). The
overall communication complexity of our scheme, however, is
Ω(k2 log q), meaning that our rate (i.e., the message length
1
Ω(k) . This
divided by the communication complexity) is
is lower than we would like, especially since there are well
known ordinary commitment schemes with constant rate.

It turns out that increasing the rate of NMC can be done
trivially: simply commit non-malleably to a short seed s,
then use s to encrypt (malleably) a longer message m. This
construction, however, destroys the structure of the NMC
scheme in the sense that any fast Σ−protocols available to
the original NMC needn’t (and likely will not) be compatible
with the high rate NMC. For example, if the NMC protocol
of Theorem 1 is instantiated on top of the Elgamal com-
mitment scheme it inherits homomorphic operations and
Schnorr-like Σ−protocols for proving that the committed
value satisﬁes a linear relation. However, if the amortiza-
tion technique just mentioned is used on top to increase the
message size, these fast proofs are lost. This lack of compati-
bility with common cryptographic operations severely limits
the utility of this NMC when used as a building block for
larger protocols. We show that our scheme is amenable to
an amortization technique which is as eﬃcient as the general
one, and which also preserves the Σ−protocols available to
the original.
1.4 Central Idea: From Subsets to Subspaces
Our techniques expand on the algebraic techniques put

forth in [GRRV14]. Brieﬂy recall their scheme.

1. C → R commitments to the coeﬃcients of n linear
polynomials all with the same constant term. We

denote the i−th polynomial fi(x) = rix + m where
m ∈ Zq is the value C is committing to non-malleably,
and the ri ∈ Zq are random.

2. R → C a random query vector α = (α1, . . . , αn) ∈ Zn
q .
3. C → R response vector a = (a1, . . . , an) ∈ Zn
q where

ai = fi(αi).

4. C proves to R in ZK that the values sent in step 1 are
valid commitments, consistent with the responses in
step 3.

Crucial for the proof of non-malleability is the fact that
the challenges αi are actually drawn from proper subsets
Vi ⊂ Zq, the sizes of which depend on C’s identity. Since
C’s identity and M’s identity are distinct, M will be asked
queries from diﬀerent challenge spaces than he will be al-
lowed to use to query C. It is then possible to show that
by carefully controlling the Vi, M will not be able to use
C’s answer to construct his own, and thus the protocol is
non-malleable.

Unfortunately, the requirements needed on the Vi for the
proof to work mean that, for example, the size of Vi+1 is at
least a constant multiple of the size of Vi for each i. Since
in [GRRV14], each Vi ⊂ Zq, this and other requirements on
the Vi necessitate q = 2Ω(k2). The main advantage of our
new protocol is that for us each Vi will be a subset of the
vector space Z(cid:96)
q for some (cid:96) which may be controlled. This
allows us to keep q ﬁxed to a small value and still make sure

(cid:12)(cid:12) is large.

that(cid:12)(cid:12)Z(cid:96)

q

The proof of non-malleability in [GRRV14] is delicate
enough to where even this small change threatens to de-
stroy the proof and much care is needed. The key is setting
the Vi ⊂ Z(cid:96)
q to be vector subspaces rather than just proper
subsets. This allows most of the algebraic ideas in the proof
to carry over unchanged. Instead of the fi(·), we use maps
vi (cid:55)→ (cid:104)zi, vi(cid:105) where the vector zi = (m, ri) ∈ Z(cid:96)
q. Our proof
uses similar ideas such as collinearity testing, though our
setting is more complicated as we work in vector spaces of
high dimension.
2. PRELIMINARIES
let [n] = {1, . . . , n}. A function
ε : N → R+ is negligible if it tends to 0 faster than any in-
verse polynomial i.e., for all constants c there exists nc ∈ N
such that for every n > nc it holds that ε(n) < n−c. We use
negl(·) to specify a generic negligible function. We abbrevi-
ate “probabilistic polynomial time” with PPT. We assume
familiarity with computational indistinguishability and zero-
knowledge proofs (and related protocols).
2.1 Commitment schemes

For positive n ∈ N,

Commitment schemes are protocols which enable a party,
known as the committer C, to commit himself to a value
while keeping it secret from the (potentially cheating) re-
ceiver, R. This property is known as hiding. Additionally,
upon receiving the commitment from C, R is ensured that
even if C cheated, there is at most one value that C can de-
commit to during a later, decommitment phase (binding).
In this work, we consider commitment schemes that are
statistically-binding which means that the hiding property
only holds against computationally bounded adversaries.

1050Table 1: Implementation Time Comparisons in DDH Implementation. The complexity is measured in Giga clock-cycles. For
example, considering identities domain of size 216 with 2−96 security our proposed implementation runs in about 0.07 seconds
on the committer’s side, and about 0.41 seconds on the receiver’s side. This is highly eﬃcient in comparison to [GRRV14]
whose duration is about 50 seconds for the committer and about 46 seconds for the receiver (given matching parameters of
identity space and slightly worse security). Measurements were taken on a Core i7 Intel Ivy Bridge architecture (with 2.9 GHz
frequency) using only a single core. We note that for id’s of size larger than 230 the [GRRV14] scheme is already infeasible.

Scheme
[GRRV14]
this paper
this paper
this paper

IDs Prime Size (log q) Msg size Clock Cycles (C + R)
216
216
232
232

146G + 134G
0.2G + 1.15G
0.4G + 4.1G
0.82G + 8.7G

6400
12288
24576
28672

6400
192
192
224

Security
2−80
2−96
2−96
2−112

Table 2: Complexity Comparisons in DDH Implementations. Communication is computed in terms of ﬁeld elements.

Scheme
[GRRV14]
this paper
this paper

IDs
2k
2k
2k

Prime Size
log q = Ω(k2)

any
any

Msg Space

Zq
Z4k

q

ZK
q , K = Ω(k2)

Comm.

Exponentiations (C+R)

96k
2k2

14K + 2k2

32k + 96k
18k + 4k2
6K + 2Kk

Definition 1

(Statistically Binding). Let (cid:104)C, R(cid:105) be
an interactive protocol between C and R. We say that (cid:104)C, R(cid:105)
is a statistically binding commitment scheme if the following
properties hold:

Correctness: If C and R do not deviate from the pro-
tocol, then R should accept (with probability 1) during
the decommit phase.
Binding: For every C∗, there exists a negligible func-
tion negl(·) such that C∗ succeeds in the following game
with probability at most negl(λ): On security param-
eter 1λ: C∗ ﬁrst interacts with R in the commit phase
to produce commitment c. Then C∗ outputs two de-
commitments (c, m0, d0) and (c, m1, d1), and succeeds
if m0 (cid:54)= m1 and R accepts both decommitments.
Hiding: For every PPT receiver R∗ and every two mes-
sages m0, m1, the view of R∗ after participating in the
commitment phase, where C committed to m0 is in-
distinguishable from its view after participating in a
commitment to m1.

[Nao91] gives a 2-round, statistically binding bit commit-
ment scheme that can be built from any OWF [HILL99].
2.2 Non-malleable commitments

We wish for our commitment scheme to be impervious to
a MIM adversary, M, who takes part in two protocol exe-
cutions (in the left interaction M acts as the receiver while
in the right, M plays the role of the committer), and tries
to use the left interaction to aﬀect the right. The security
property we desire can be summarized:

For any MIM adversary M, there exists a stan-
dalone machine who plays only one execution as
the committer, yet whose commitment is indis-
tinguishable from M’s commitment on the right.

At ﬁrst glance, non-malleability seems impossible as surely
nothing can be done to protect against a MIM who sim-
ply copies messages from one protocol execution to another.
For this reason, non-malleable security oﬀers protection only

against any MIM who tries to change messages in a mean-
ingful way.

On the Existence of Identities. In this work, just as
in [DDN91], we assume that the committer has an identity
id ∈ {0, 1}k. In order to perform a successful mauling at-
tack, a MIM has to maul a commitment corresponding to
C’s identity into a commitment of his own, distinct iden-
tity. Though this sounds like a strong assumption on the
network, essentially requiring that “you know who you are
talking to”, for our purposes, it is actually equivalent to the
requirement discussed above, that the MIM does something
other than simply copy messages. This is because our proto-
col is interactive, and the ﬁrst committer message contains
a statistically binding commitment to m. This means that
if we set the committer’s identity to be the ﬁrst committer
message, C’s and M’s identities will be distinct unless M
copied C’s ﬁrst message.

Moving forward, we assume that the committer’s id is
externally given and we require that non-malleability holds
only in the case when C and M’s identities are diﬀerent. We
also assume for simplicity that player identities are known
before the protocol begins, though strictly speaking this is
not necessary, as the identities do not appear in the protocol
until after the ﬁrst committer message. We point out that
M can choose his identity adversarially, as long as it is not
equal to C’s.

Deﬁnition of Non-Malleable Commitments. In this
work, we consider the notion of non-malleability with respect
to commitment and we will frequently refer to the “message
committed to by a MIM adversary M during the commit-
ment phase”. We note that this is uniquely deﬁned, as all
commitment schemes in this work are statistically binding,
and so for all but a negligible fraction of the possible tran-
scripts T of the interaction between M and an honest receiver
R, there exists at most one message m that is consistent with
T (i.e., for which there exist random coin tosses which give
T). We recall the deﬁnition of non-malleable commitments
of Lin et al et al. [LPV08].

1051The man-in-the-middle execution.

In the man-in-
the-middle execution, the MIM adversary M is simultane-
ously participating in two interactions called the left and
the right interaction. In the left interaction M is the receiver
and interacts with a honest committer whereas in the right
interaction M is the committer and interacts with a hon-
est receiver. We deﬁne a random variable MIM(cid:104)C,R(cid:105)(m, z)
describing ( ˜m, v): the value M commits to in the right in-
teraction, and M’s view in the full experiment. Speciﬁcally,
M has auxiliary information z and interacts on the left with
an honest committer C with input message m and identity
id and on the right with honest receiver R. M attempts to
commit to a value ˜m that is related to m using an identity
˜id of its choice. If the right commitment (as determined by
the transcript) is invalid or undeﬁned, or id = ˜id its value is
set to ⊥.

The simulated execution. In the simulated execution
a simulator S interacts with an honest receiver R. S receives
security parameter 1λ and auxiliary information z and inter-
acts with the honest receiver R. Let SIMS
(cid:104)C,R(cid:105)(1λ, z) denote
the random variable describing ( ˜m, v): the value S commits
to in the right interaction, and S’s view during the entire
experiment. If the commitment produced by S is invalid or
undeﬁned, its value is set to ⊥.

Definition 2. Let (cid:104)C, R(cid:105) be a commitment scheme. (cid:104)C, R(cid:105)
is non-malleable with respect to commitment if for every
PPT MIM adversary M, there exists a PPT simulator S
such that the following ensembles are indistinguishable for
all m ∈ {0, 1}λ:

{MIM(cid:104)C,R(cid:105)(m, z)}z∈{0,1}(cid:63) ;{SIM
2.3 Σ-protocols

(cid:104)C,R(cid:105)(1λ, z)}z∈{0,1}(cid:63),id∈{0,1}k
S

The notion of a Σ-protocol generalizes the identiﬁcation
protocols by Schnorr [Sch91], and Guillou and Quisquater
[GQ88], as well as many others. A Σ-protocol is required to
be zero-knowledge against an honest veriﬁer only. Despite
this limitation, Σ-protocols are building blocks in many pro-
tocols due to their remarkable eﬃciency.

Let R = {(x, w)} ⊆ {0, 1}∗×{0, 1}∗ be a binary relation,
where x denotes the common input to the prover and the
veriﬁer, and w denotes a witness, which is the private input
to the prover. Let LR = {x : ∃w such that(x, w) ∈ R}
denote the language corresponding to relation R.

Definition 3. A Σ-protocol for relation R is a protocol
between a prover P and a veriﬁer V of the following 3-move
form:

Satisfying the following three properties:

3-move form. Given a common input x to P, V and a
w such that(x, w) ∈ R is private input to P :

1. P sends a message a.

2. V sends a random t-bit string e.

3. P sends a reply z, and V decides to accept or

reject based on x, a, e, z.

Completeness. if P , V follow the protocol on input x
and private input w to P where (x, w) ∈ R, the veriﬁer
always accepts.

Special soundness. From any input x and any pair
of accepting conversations on input x, (a, e, z) and
(a, e(cid:48), r(cid:48)) with e (cid:54)= e(cid:48), one can eﬃciently compute wit-
ness w such that (x, w) ∈ R.

Special honest-veriﬁer zero-knowledge . There ex-
ists a polynomial-time simulator S, which on input x
and a random e outputs an accepting conversation of
the form (a, e, z), with the same probability distribu-
tion as conversations between the honest P, V on input
x

2.4 Challenge Space Generation

In this section, we describe how to derive the tags from
C’s identity, highlighting the properties we will use moving
forward. Let id ∈ {0, 1}k be C’s identity and {ti}i=1,...,n the
tags resulting from it in as described below. Note that we
have already touched on the role that the tags play in our
protocol: the size of the challenge space in coordinate i is
determined by ti. In particular, Vi will be a ti−dimensional
vector space over Zq, and so its order is qti . Of particular
importance is the quantity |Vi+1|/|Vi|. We will always have
ti < ti+1 so this quantity will always be at least q = 2160
(our general protocol can be tuned to handle other sizes
of q using techniques presented in [GRRV14]; however since
q ≈ 2160 in our implementation, we do not discuss this point
further). In particular, |Vi|/|Vi+1| is negligible for all i. The
other property we need from the tags is the following:
if
i (cid:54)= j then ti (cid:54)= ˜tj; moreover ti < ˜ti holds for at least one
i ∈ [n] (as does ti > ˜ti).

The tags are generated according to the “DDN trick”,
namely ti = 2i + idi where idi is the i−th bit of C’s identity.
This ensures that if id (cid:54)= ˜id that ti (cid:54)= ˜ti for some i. To
arrange that ti > ˜ti for some i, we deﬁne a ﬁnal tag tk+1 =
2(k + 1) − |id| where |id| is the Hamming weight of id. Our
ﬁnal parameters therefore, are n = k + 1 and (cid:96) = 2(k + 1).

3. THE BASIC PROTOCOL
In this section, we describe our protocol given a large
prime q ≈ 2160 and vector spaces V1, . . . , Vn ⊂ Zq as de-
scribed in Section 2.4. We use Naor’s two round, statisti-
cally binding bit commitment scheme [Nao91] as a building
block.2. We use boldface to denote vectors, and (cid:104)·,·(cid:105) to
In particular we denote
denote inner product of vectors.
our challenge vector set as {vi}i=1,...,n and our response set
{wi}. We write Com for the entire ﬁrst commitment mes-
sage. Our non-malleable commitment scheme (cid:104)C, R(cid:105)BASIC
shown in Figure 1. The decommitment phase is done by
having the committer C send m and the randomness it used
during the protocol.

Proposition 1. The commitment scheme (cid:104)C, R(cid:105)BASIC is

computationally hiding and statistically binding.

Proof. Computational hiding follows from the hiding of
Com, the ZK property and having having n + (cid:96)− 1 variables
and only n equations, where each equation has an indepen-
dent, random component. Statistical binding follows from

2Brieﬂy recall Naor’s scheme: 1) R sends random initial-
ization message σ, and 2) C responds with Comσ(m; s), a
commitment to m ∈ {0, 1} using randomness s (we will feel
free to just write Com(m), surpressing σ and s for simplic-
ity)

1052Public Parameters: A large prime q, an integer (cid:96) and
vector spaces V1, . . . , Vn ⊂ Z(cid:96)
q obtained from identities as
described in Section 2.4.
Commiter’s Private Input: m ∈ Z(cid:96)−1
to.

to be committed

q

Commit Phase:

1. R → C: Send the ﬁrst message σ of the Naor

commitment scheme.

2. C → R: Choose random values r1, . . . , rn ∈ Zq. This
q where zi = (ri, m). C

deﬁnes vectors z1, . . . , zn ∈ Z(cid:96)
sends commitments to every coordinate of the zi.

3. R → C: Send random challenge vectors {vi}i=1,...,n

where each vi ∈ Vi ⊂ Z(cid:96)
q.

4. C → R: Send evaluations {wi}, where each

wi = (cid:104)zi, vi(cid:105) ∈ Zq.

5. C ←→ R Consistency proof: Parties engage in a
zero-knowledge argument protocol where C proves to
R that

∃(cid:0)(m1, s1), . . . , (m(cid:96)−1, s(cid:96)−1), (r1, s(cid:48)
n)(cid:1)
• Com =(cid:0)Comσ(m1; s1), . . . , Comσ(m(cid:96)−1; s(cid:96)−1),

1), . . . , (rn, s(cid:48)

such that:

n)(cid:1); and

Comσ(r1; s(cid:48)

1), . . . , Comσ(rn; s(cid:48)

• wi = (cid:104)zi, vi(cid:105) ∀ i = 1, . . . , n.

Figure 1: Non-malleable commitment scheme (cid:104)C, R(cid:105)BASIC.

the statistical binding property of the underlying commit-
ment scheme Com.

Theorem 2. The commitment scheme (cid:104)C, R(cid:105)BASIC is non-

malleable.
3.1 Discussion of the Proof of Non-Malleability
We now mention some of the key points from the proof of
non-malleability. See the full version for more details. We
ﬁrst deﬁne the notion of ε−dependence.

Definition 4. Fix a commitment message Com. We

say that vi(cid:48) ∈ Vi(cid:48) is ε−dependent on ˜vi ∈ ˜Vi if

i(cid:48) ∈ Span{vi(cid:48)}(cid:12)(cid:12)˜v

(cid:48)

i ∈ Span{˜vi}(cid:1) ≥ ε.

(cid:48)

i}(cid:0)v

Pr{˜v(cid:48)

Deﬁnition 4 implicitly assumes we are given a completed
transcript with ﬁrst message Com and right (resp.
left)
challenges {˜vi} (resp. {vi}). Then M is rewound to the
beginning of the second message and given new challenges
{˜v(cid:48)
i ∈ Span{˜vi}, and we are interested in the prob-
i} with ˜v(cid:48)
ability that the resulting left challenges {v(cid:48)
i} are such that
i(cid:48) ∈ Span{vi(cid:48)}. Intuitively, vi(cid:48) being dependent on ˜vi is
v(cid:48)
a result of M performing a mauling attack. Suppose that
M mauls Com(zi(cid:48) ) in order to obtain Com(˜zi). Then M
does not know ˜zi and so cannot hope to answer ˜vi except
by mauling C’s answer to vi(cid:48) . Therefore, if M is rewound to
the beginning of the right session’s query phase and asked a
diﬀerent query {˜v(cid:48)
i ∈ Span{˜vi}, M will have

i} such that ˜v(cid:48)

i} such that v(cid:48)

i(cid:48) ∈ Span{vi(cid:48)} if he wants to answer
to ask {v(cid:48)
successfully. The proof of non-malleability proceeds in cases,
depending on how the right queries can depend on the left
queries. This is exactly the same high-level structure of the
proof of non-malleability in [GRRV14], though some of the
speciﬁcs diﬀer.

Consider the bipartite graph G = (V, E) with vertex set
V = [n] × [n] and an edge (i(cid:48), i) ∈ E exactly when vi(cid:48) is
ε−dependent on ˜vi. We consider four cases:

• IND: There exists i such that (i(cid:48), i) /∈ E for all i(cid:48).
• L < R: There exist i(cid:48) < i such that (i(cid:48), i) ∈ E.
• L > R: There exist i(cid:48) > i such that (i(cid:48), i) ∈ E.

• L = R: E =(cid:8)(i, i) : i = 1, . . . , n(cid:9).

We think of IND, L < R, L > R, L = R as events whose prob-
ability of occuring depends on M. Notice however that re-
gardless of M’s behavior,

Pr(cid:0)IND or L < R or L > R or L = R(cid:1) = 1.
Pr(cid:0)M mauls (cid:104)C, R(cid:105)BASIC & E(cid:1) =

1

poly

Therefore, it suﬃces to prove that if there exists a PPT M
such that

for any E ∈ {IND, L < R, L > R, L = R}, then M breaks the
hiding of Com. This is the same approach taken in [GRRV14]
and many supporting lemmas carry over directly to our set-
ting. In particular, the case of E = IND is handled in Claim 9
of [GRRV14]. Additionally, Claims 5 through 7 of [GRRV14]
show that the cases for the other values of E follow from
the same lemma which we state below and prove in Ap-
pendix 3.1. Our main technical lemma is much the same
as Claim 8 from [GRRV14]. We prove it formally, how-
ever, as it is the point in which the diﬀerences between our
high-dimensional setting and their linear setting are most
apparent.

Note that once Com is ﬁxed, M deﬁnes a map from right
challenges {˜vi} to left challenges {vi}. Fix (as a function of
λ), ω = ω(1). Given a transcript with left challenges {vi},
say that the event SUPER−POLY occurs if the preimage of

{vi} has superpolynomial size: (cid:12)(cid:12)M−1(cid:0){vi}(cid:1)(cid:12)(cid:12) ≥ λω.
Pr(cid:0)M mauls (cid:104)C, R(cid:105)BASIC & SUPER−POLY(cid:1) ≥ σ

Lemma 1. Fix non-negligible σ. If

then there exists a PPT algorithm A who breaks the hiding
of (cid:104)C, R(cid:105)BASIC.
Proof. We give a reduction from a MIM who mauls
(cid:104)C, R(cid:105)BASIC given that the event SUPER−POLY occurs, to
a PPT A who breaks the hiding of Com. Our A proceeds
as follows.

• A chooses random m0, m1 ∈ Z(cid:96)−1

q

and begins the hid-
ing game, sending (m0, m1) to the challenger C. Then
A instantiates M and runs two sessions of (cid:104)C, R(cid:105)BASIC
forwarding the messages it receives as C to C.
In
the left interaction, C commits to mu for unknown
u ∈ {0, 1}. Let the resulting transcript be T, and let
{vi} and {wi} be the query and response messages in
the left interaction. Similarly {˜vi} and { ˜wi} are the
query and response messages in the right.

1053• A chooses random u(cid:48) ∈ {0, 1} and sets vectors zi ∈ Z(cid:96)
q
to be the unique such vectors which correspond to mu(cid:48)
and so that (cid:104)zi, vi(cid:105) = wi for all i.

i}, {˜v(cid:48)(cid:48)

i } such that {˜vi, ˜v(cid:48)

• A chooses random {˜v(cid:48)

i }
i, ˜v(cid:48)(cid:48)
are collinear for all i. He rewinds M twice back to
the beginning of the right execution’s second message
i }, receiving left queries {v(cid:48)
asking {˜v(cid:48)
i} and
{v(cid:48)(cid:48)
i} and {w(cid:48)(cid:48)
i }
i(cid:105) for all i (and similarly for w(cid:48)(cid:48)
where w(cid:48)
i ),
receiving right responses { ˜w(cid:48)

i }. A responds to M’s queries with {w(cid:48)
i} and { ˜w(cid:48)(cid:48)
i }.
i), (˜v(cid:48)(cid:48)
i , ˜w(cid:48)(cid:48)

• A checks whether(cid:8)(˜vi, ˜wi), (˜v(cid:48)

i} and {˜v(cid:48)(cid:48)
i = (cid:104)zi, v(cid:48)

are collinear for all i. A outputs u(cid:48) if so, 1 − u(cid:48) if not.

i )(cid:9)

i, ˜w(cid:48)

The following is Fact 1 from [GRRV14].

Fact 1. Let E be an event such that
• Pr(E) ≥ ξ;

• Pr(cid:0)(cid:8)(˜vi, ˜wi), (˜v(cid:48)
• Pr(cid:0)(cid:8)(˜vi, ˜wi), (˜v(cid:48)

ξ(cid:48);

ξ(cid:48)(cid:48),

i )(cid:9) col. ∀ i(cid:12)(cid:12)u(cid:48) = u & E(cid:1) ≥
i )(cid:9) col. ∀ i(cid:12)(cid:12)u(cid:48) (cid:54)= u & E(cid:1) ≤

i, ˜w(cid:48)

i), (˜v(cid:48)(cid:48)

i , ˜w(cid:48)(cid:48)

i, ˜w(cid:48)

i), (˜v(cid:48)(cid:48)

i , ˜w(cid:48)(cid:48)

for non-negligible values ξ, ξ(cid:48), ξ(cid:48)(cid:48) satisfying ξ(cid:48)(cid:48) = O(ξξ(cid:48)).
Then A breaks the hiding of (cid:104)C, R(cid:105)BASIC.

So it suﬃces to construct such an E. We have already deﬁned
the event SUPER−POLY. We additionally deﬁne the events
HONEST and EXT as follows:

• HONEST occurs if {˜vi} is such that M gives correct
answers { ˜wi} provided his queries {vi} are answered
correctly;

• EXT occurs if {˜vi} is such that M gives correct an-
swers with non-negligible probability even he receives
random answers to his queries {vi}.

Note that HONEST, EXT and SUPER−POLY are all deter-
mined by Com and {˜vi}. Since A ﬁxes Com and rewinds M
asking three challenges, we will think of these events as de-

pending only on {˜vi}. We may assume Pr(cid:0)HONEST(cid:1) = 1
Pr(cid:0)M mauls & EXT(cid:1) = negl. This is because if M answers

poly
because otherwise M is not completing the protocol success-
fully (and so cannot be mauling) except with negligible prob-
ability. It can also be shown (Claim 2 in [GRRV14]) that
{˜vi} correctly with non-negligible probability given random
answers to his queries {vi} then he knows his message ˜m (it
can be extracted in polynomial time). It therefore cannot
depend on C’s commitment m, which is computationally
hidden from M.

We use the event

E = HONEST & (¬EXT) & SUPER−POLY.

It remains to prove
(cid:48)
i), (˜v

Pr(cid:0)(cid:8)(˜vi, ˜wi), (˜v
Pr(cid:0)(cid:8)(˜vi, ˜wi), (˜v

(cid:48)
i), (˜v

(cid:48)
i, ˜w

(cid:48)
i, ˜w

(cid:48)(cid:48)
i , ˜w

(cid:48)(cid:48)
i , ˜w

(cid:48)(cid:48)

i )(cid:9) col. ∀ i(cid:12)(cid:12)u
i )(cid:9) col. ∀ i(cid:12)(cid:12)u

(cid:48)(cid:48)

(cid:48)

= u & E(cid:1) =
(cid:48) (cid:54)= u & E(cid:1) = negl.

poly

1

To prove the ﬁrst, note that if u(cid:48) = u then M receives correct
answers to his queries {˜vi}, {˜v(cid:48)
i }, so by deﬁnition

i}, and {˜v(cid:48)(cid:48)

correct answers then certainly(cid:8)(˜vi, ˜wi), (˜v(cid:48)

of HONEST he will provide correct answers { ˜wi}, { ˜w(cid:48)
{ ˜w(cid:48)(cid:48)
i), (˜v(cid:48)(cid:48)

i}, and
i } with non-negligible probability. However, if M gives
i , ˜w(cid:48)(cid:48)

i )(cid:9)

i, ˜w(cid:48)

i

are collinear for all i.

i )(cid:9)

i} to his queries {v(cid:48)

i} to {˜v(cid:48)
i , ˜w(cid:48)(cid:48)
i), (˜v(cid:48)(cid:48)

by the points(cid:8)(˜v(cid:48)
(cid:96)−planes (cid:8)(˜v,(cid:104)˜v, ˜zi(cid:105))(cid:9) to which the points (cid:8)(˜vi, ˜wi)(cid:9)

To prove the second, note that if u(cid:48) (cid:54)= u then M receives
random answers {w(cid:48)
i}, so by deﬁnition of
EXT, his responses { ˜w(cid:48)
i} on the right will be incorrect
with high probability. This means that the lines spanned
i, ˜w(cid:48)
are not contained in the
be-
long.
It follows that the intersections of these lines and
these (cid:96)−planes is at most a single point. By deﬁnition of
SUPER−POLY, the probability that this {˜vi} in the in-
tersection is chosen out of all the superpolynomially many
preimages of {vi} is negligible.

i

i

4. AMORTIZING NMC
We now show that the scheme from the previous section
(cid:104)C, R(cid:105)BASIC can be amortized as eﬃciently as the trivial con-
struction mentioned in the introduction, while still preserv-
ing any fast proofs available to the original scheme. Our
protocol (cid:104)C, R(cid:105)AMOR is shown in Figure 2.

The proof that (cid:104)C, R(cid:105)AMOR is non-malleable is almost ex-
actly the same as the proof of non-malleability for (cid:104)C, R(cid:105)BASIC.
Recall that most of the proof for (cid:104)C, R(cid:105)BASIC involved view-
ing M as a map from right challenges {˜vi} to left challenges
{vi} and proving that in all cases, M cannot be mauling.
The challenge space for (cid:104)C, R(cid:105)AMOR is the same as the chal-
lenge space for (cid:104)C, R(cid:105)BASIC and so the same analysis for M
as a function from right to left challenge spaces carries over.
The only thing that must be changed is that the extractor
must be modiﬁed in order to extract all of the ˜mi. This,
however, is a minor change which we omit.

Note that when k is large, the communication complexity
of (cid:104)C, R(cid:105)AMOR is dominated by the second message when C
sends commitments to the ˜mi. If Com has constant rate,
then so does (cid:104)C, R(cid:105)AMOR. Finally, if Com is homomorphic
then so is (cid:104)C, R(cid:105)AMOR, and similarly, any fast Σ−protocols
available to Com for proving knowledge of committed values
or that these values satisfy a linear relation will likewise be
available to (cid:104)C, R(cid:105)AMOR.

5.

IMPLEMENTATION

We now discuss some of the speciﬁcs of our prototype im-
plementation. The two cryptographic building blocks needed
for our protocol are statistically binding homomorphic com-
mitment and zero-knowledge proof of knowledge. Any sta-
tistically binding commitment can be used, but for the sake
of eﬃciency, we instantiate our protocol using ElGamal com-
mitments [EG85]. Zero-knowledge is instantiated with Schnorr
protocol [Sch91] as follows: a receiver proves knowledge
of a trapdoor followed by a schnorr based Σ-OR proto-
col [CDS94], where the committer proves knowledge of either
the committed message or receiver’s trapdoor.

Optimized performance is achieved by aggregating many
of the operations of the atomic protocols together. Our
main most valuable tool is the modular exponentiation with

1054Public Parameters: A large prime q = λω(1), integers
(cid:96), k and vector spaces V1, . . . , Vn ⊂ Z(cid:96)
q obtained from C’s
identity.

Commiter’s Private Input: Messages
m1, . . . , mk ∈ Z(cid:96)−1
to be committed to.

q

Commit Phase:

1. R → C: Send the ﬁrst message σ of the Naor

commitment scheme.

2. C → R: Choose random values r1, . . . , rn ∈ Zk

deﬁnes vectors zi,j ∈ Z(cid:96)
q for i = 1, . . . , n and
j = 1, . . . , k where zi,j = (ri,j, mj). C sends
commitments to every coordinate of the zi,j using
Com.

q . This

3. R → C: Send random challenge vectors {vi}i=1,...,n

where each vi ∈ Vi ⊂ Z(cid:96)
q.

4. C → R: Send evaluation vectors {wi}, where each

wi ∈ Zk

q is such that wi,j = (cid:104)zi,j, vi(cid:105) ∈ Zq.

5. C ←→ R Consistency proof: Parties engage in a
zero-knowledge argument protocol where C proves to
R that
i,j)}1≤i≤n,1≤j≤k

∃(cid:0){(mj,l, sj,l)}1≤j≤k,1≤l≤(cid:96)−1,{(ri,j, s(cid:48)
• Com =(cid:0){Comσ(mj,l, sj,l)}1≤j≤k,1≤l≤(cid:96)−1,
(cid:1); and

i,j)}1≤i≤n,1≤j≤k

{Comσ(ri,j, s(cid:48)

such that:

• wi,j = (cid:104)zi,j, vi(cid:105) ∀ 1 ≤ i ≤ n, 1 ≤ j ≤ k.

Figure 2:
scheme (cid:104)C, R(cid:105)AMOR.

Constant Rate Non-malleable commitment

precomputation [BGMW92]. This provides a tremendous
improvement for both parties. We also use batch veriﬁca-
tion [LL94, BGR98] for each of the parties’ veriﬁcation of
repeated equations.
In particular, we use the bucket test
with small exponents. For further optimization we use the
Comba multiplication [Com90].

We implement our protocol over elliptic curves. Note
that [GRRV14] required the group size to be exponential in
the tag values, and therefore required approximately 6000
bits group size to achieve decent security. Our protocol,
on the other hand, allows using any group size (as long as
it is secure) regardless of the tags values. This allows us
to use more standard elliptic curves groups. We choose to
use NIST GF(P) elliptic curves, and construct our imple-
mentation in MIRACL SDK – an open source C software
library for elliptic curve cryptography. Our implementation
is generic for any EC parameters. Concrete measurements
of performance for our protocol are presented in table 3. For
example, to commit to a message of size 24,576 bits with El-
Gamal modulus of size 192 bits, tags of size 32 bits, it takes
approximately 4.5 giga clock cycles. That is, on average for
every committed bit we run approximately 0.19 mega clock
cycles.

Prime Size

(log q)

Msg size Clock Cycles (C+R)

192

192

192

224

224

12288

24576

49152

14336

28672

0.2 G + 1.15 G

0.4 G + 4.1 G

0.79 G + 15.3 G

0.4 G + 2.46 G

0.82 G + 8.7 G

IDs
216
232
264
216
232

Sec.
2−96
2−96
2−96
2−112
2−112

Table 3: Implementation time measurements in DDH Imple-
mentation. The complexity is measured in Giga clock-cycles.
Measurements were taken on a Core i7 Intel Ivy Bridge ar-
chitecture (with 2.9 GHz frequency) using only a single core.

6. REFERENCES
[AMPR14] Arash Afshar, Payman Mohassel, Benny

[Bar02]

Pinkas, and Ben Riva. Non-interactive secure
computation based on cut-and-choose. In
Eurocrypt, 2014.
Boaz Barak. Constant-Round Coin-Tossing
with a Man in the Middle or Realizing the
Shared Random String Model. In Proceedings
of the 43rd Annual IEEE Symposium on
Foundations of Computer Science, FOCS ’02,
pages 345–355, 2002.

[BGMW92] Ernest F. Brickell, Daniel M. Gordon,

(cid:1)

Kevin S. McCurley, and David Bruce Wilson.
Fast exponentiation with precomputation
(extended abstract). In Rainer A. Rueppel,
editor, Advances in Cryptology -
EUROCRYPT ’92, Workshop on the Theory
and Application of of Cryptographic
Techniques, Balatonf¨ured, Hungary, May
24-28, 1992, Proceedings, volume 658 of
Lecture Notes in Computer Science, pages
200–207. Springer, 1992.

[BGR98] Mihir Bellare, Juan A. Garay, and Tal Rabin.

Fast batch veriﬁcation for modular
exponentiation and digital signatures. pages
236–250. Springer-Verlag, 1998.

[BGW88] Michael Ben-Or, Shaﬁ Goldwasser, and Avi

Wigderson. Completeness Theorems for
Non-Cryptographic Fault-Tolerant Distributed
Computation (Extended Abstract). In
Proceedings of the 20th Annual ACM
Symposium on Theory of Computing, STOC
’88, pages 1–10, 1988.

[BHKR13] Mihir Bellare, Viet Tung Hoang, Sriram

Keelveedhi, and Phillip Rogaway. Eﬃcient
garbling from a ﬁxed-key blockcipher. In 2013
IEEE Symposium on Security and Privacy, SP
2013, Berkeley, CA, USA, May 19-22, 2013,
pages 478–492. IEEE Computer Society, 2013.
Boaz Barak and Amit Sahai. How To Play
Almost Any Mental Game Over The Net -
Concurrent Composition via Super-Polynomial
Simulation. In Proceedings of the 46th Annual
IEEE Symposium on Foundations of
Computer Science, pages 543–552, 2005.
Ran Canetti. Universally composable security:
A new paradigm for cryptographic protocols.
pages 136–147, 2001. Preliminary full version

[BS05]

[Can01]

1055[CDS94]

[CJS14]

available as Cryptology ePrint Archive Report
2000/067.
Ronald Cramer, Ivan Damg˚ard, and Berry
Schoenmakers. Proofs of partial knowledge
and simpliﬁed design of witness hiding
protocols. In Desmedt [Des94], pages 174–187.
Ran Canetti, Abhishek Jain, and Alessandra
Scafuro. Practical UC security with a global
random oracle. In Proceedings of the 2014
ACM SIGSAC Conference on Computer and
Communications Security, Scottsdale, AZ,
USA, November 3-7, 2014, pages 597–608,
2014.

[Goy11]

[Goy12]

[GQ88]

[CLOS02] Ran Canetti, Yehuda Lindell, Rafail

Ostrovsky, and Amit Sahai. Universally
composable two-party and multi-party secure
computation. In Proceedings of the 34th
Annual ACM Symposium on Theory of
Computing, STOC ’02, pages 494–503, 2002.
Paul G. Comba. Exponentiation
cryptosystems on the ibm pc. IBM systems
journal, 29(4):526–538, 1990.
Danny Dolev, Cynthia Dwork, and Moni Naor.
Non-Malleable Cryptography (Extended
Abstract). In Proceedings of the 23rd Annual
ACM Symposium on Theory of Computing,
STOC ’91, pages 542–552, 1991.
Yvo Desmedt, editor. Advances in Cryptology
- CRYPTO ’94, 14th Annual International
Cryptology Conference, Santa Barbara,
California, USA, August 21-25, 1994,
Proceedings, volume 839 of Lecture Notes in
Computer Science. Springer, 1994.
Cynthia Dwork, Moni Naor, and Amit Sahai.
Concurrent zero-knowledge. In STOC, pages
409–418, 1998.
Taher El Gamal. A public key cryptosystem
and a signature scheme based on discrete
logarithms. In Proceedings of CRYPTO 84 on
Advances in Cryptology, pages 10–18, New
York, NY, USA, 1985. Springer-Verlag New
York, Inc.
Uriel Feige. Ph.d. thesis, alternative models
for zero knowledge interactive proofs.
Weizmann Institute of Science, 1990.

[Com90]

[DDN91]

[Des94]

[DNS98]

[EG85]

[Fei90]

[Lin13]

[LL94]

Annual ACM Symposium on Theory of
Computing, 1987, New York, New York, USA,
pages 218–229, 1987.
Vipul Goyal. Constant Round Non-malleable
Protocols Using One-way Functions. In
Proceedings of the 43rd Annual ACM
Symposium on Theory of Computing, STOC
’11, pages 695–704. ACM, 2011.
Vipul Goyal. Positive results for concurrently
secure computation in the plain model. In
FOCS, 2012.
Louis C. Guillou and Jean-Jacques
Quisquater. A practical zero-knowledge
protocol ﬁtted to security microprocessor
minimizing both transmission and memory. In
Christoph G. G¨unther, editor, Advances in
Cryptology - EUROCRYPT ’88, Workshop on
the Theory and Application of of
Cryptographic Techniques, Davos, Switzerland,
May 25-27, 1988, Proceedings, volume 330 of
Lecture Notes in Computer Science, pages
123–128. Springer, 1988.

[GRRV14] Vipul Goyal, Silas Richelson, Alon Rosen, and

[HILL99]

Margarita Vald. An algebraic approach to
non-malleability. In FOCS, 2014.
Johan H˚astad, Russell Impagliazzo, Leonid A.
Levin, and Michael Luby. A Pseudorandom
Generator from any One-way Function. SIAM
J. Comput., 28(4):1364–1396, 1999.
[IKO+11] Yuval Ishai, Eyal Kushilevitz, Rafail

Ostrovsky, Manoj Prabhakaran, and Amit
Sahai. Eﬃcient non-interactive secure
computation. In Eurocrypt, 2011.
Yehuda Lindell. Fast cut-and-choose based
protocols for malicious and covert adversaries.
In Ran Canetti and Juan A. Garay, editors,
Advances in Cryptology - CRYPTO 2013 -
33rd Annual Cryptology Conference, Santa
Barbara, CA, USA, August 18-22, 2013.
Proceedings, Part II, volume 8043 of Lecture
Notes in Computer Science, pages 1–17.
Springer, 2013.
Chae Hoon Lim and Pil Joong Lee. More
ﬂexible exponentiation with precomputation.
In Desmedt [Des94], pages 95–107.
Huijia Lin and Rafael Pass. Constant-round
Non-malleable Commitments from Any
One-way Function. In Proceedings of the 43rd
Annual ACM Symposium on Theory of
Computing, STOC ’11, pages 705–714, 2011.
Huijia Lin, Rafael Pass, and
Muthuramakrishnan Venkitasubramaniam.
Concurrent Non-malleable Commitments from
Any One-Way Function. In Theory of
Cryptography, 5th Theory of Cryptography
Conference, TCC 2008, pages 571–588, 2008.
Yehuda Lindell and Ben Riva. Cut-and-choose
yao-based secure computation in the
online/oﬄine and batch settings. In Juan A.
Garay and Rosario Gennaro, editors, Advances
in Cryptology - CRYPTO 2014 - 34th Annual
Cryptology Conference, Santa Barbara, CA,

[FJN+13] Tore Kasper Frederiksen, Thomas Pelle

[LP11]

Jakobsen, Jesper Buus Nielsen,
Peter Sebastian Nordholt, and Claudio
Orlandi. Minilego: Eﬃcient secure two-party
computation from general assumptions. In
Thomas Johansson and Phong Q. Nguyen,
editors, Advances in Cryptology -
EUROCRYPT 2013, 32nd Annual
International Conference on the Theory and
Applications of Cryptographic Techniques,
Athens, Greece, May 26-30, 2013. Proceedings,
volume 7881 of Lecture Notes in Computer
Science, pages 537–556. Springer, 2013.
[GMW87] Oded Goldreich, Silvio Micali, and Avi

Wigderson. How to play any mental game or
A completeness theorem for protocols with
honest majority. In Proceedings of the 19th

[LPV08]

[LR14]

1056[Nao91]

[Pas04]

[PR05]

USA, August 17-21, 2014, Proceedings, Part
II, volume 8617 of Lecture Notes in Computer
Science, pages 476–494. Springer, 2014.
Moni Naor. Bit Commitment Using
Pseudorandomness. J. Cryptology,
4(2):151–158, 1991.
Rafael Pass. Bounded-Concurrent Secure
Multi-Party Computation with a Dishonest
Majority. In Proceedings of the 36th Annual
ACM Symposium on Theory of Computing,
STOC ’04, pages 232–241, 2004.
Rafael Pass and Alon Rosen. New and
improved constructions of non-malleable
cryptographic protocols. In Proceedings of the
37th Annual ACM Symposium on Theory of
Computing, STOC ’05, pages 533–542, 2005.

[Sch91]

[Wee10]

[Yao86]

Claus-Peter Schnorr. Eﬃcient signature
generation by smart cards. J. Cryptology,
4(3):161–174, 1991.
Hoeteck Wee. Black-Box, Round-Eﬃcient
Secure Computation via Non-malleability
Ampliﬁcation. In Proceedings of the 51th
Annual IEEE Symposium on Foundations of
Computer Science, pages 531–540, 2010.
Andrew Chi-Chih Yao. How to generate and
exchange secrets. In FOCS, 1986.

1057