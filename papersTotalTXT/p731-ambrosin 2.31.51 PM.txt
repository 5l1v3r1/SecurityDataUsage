SANA: Secure and Scalable Aggregate Network Attestation

Moreno Ambrosin1, Mauro Conti1, Ahmad Ibrahim2∗, Gregory Neven3,

Ahmad-Reza Sadeghi2, and Matthias Schunter4

1University of Padua, Italy
3IBM Research - Zurich, Switzerland

2Technische Universität Darmstadt, Germany
4Intel Labs - Darmstadt, Germany

{ahmad.ibrahim, ahmad.sadeghi}@trust.tu-darmstadt.de,

{ambrosin, conti}@math.unipd.it, schunter@acm.org, NEV@zurich.ibm.com

ABSTRACT
Large numbers of smart connected devices, also named as the In-
ternet of Things (IoT), are permeating our environments (homes,
factories, cars, and also our body—with wearable devices) to collect
data and act on the insight derived. Ensuring software integrity (in-
cluding OS, apps, and conﬁgurations) on such smart devices is then
essential to guarantee both privacy and safety. A key mechanism to
protect the software integrity of these devices is remote attestation:
A process that allows a remote veriﬁer to validate the integrity of
the software of a device. This process usually makes use of a signed
hash value of the actual device’s software, generated by dedicated
hardware. While individual device attestation is a well-established
technique, to date integrity veriﬁcation of a very large number of
devices remains an open problem, due to scalability issues.

In this paper, we present SANA, the ﬁrst secure and scalable pro-
tocol for efﬁcient attestation of large sets of devices that works under
realistic assumptions. SANA relies on a novel signature scheme to
allow anyone to publicly verify a collective attestation in constant
time and space, for virtually an unlimited number of devices. We
substantially improve existing swarm attestation schemes [5] by sup-
porting a realistic trust model where: (1) only the targeted devices
are required to implement attestation; (2) compromising any device
does not harm others; and (3) all aggregators can be untrusted. We
implemented SANA and demonstrated its efﬁciency on tiny sensor
devices. Furthermore, we simulated SANA at large scale, to assess
its scalability. Our results show that SANA can provide efﬁcient
attestation of networks of 1, 000, 000 devices, in only 2.5 seconds.

1.

INTRODUCTION

Smart devices are rapidly spreading into every domain of our life.
These devices range from tiny wearables to larger industrial devices,
which could be also integrated among them, e.g., setting up building
automation (which involves physical access control, lighting, sheath-
ing, ventilating, and air conditioning). Unlike traditional computing
devices, smart devices that are deployed in massive numbers are
∗Corresponding author.

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than ACM
must be honored. Abstracting with credit is permitted. To copy otherwise, or republish,
to post on servers or to redistribute to lists, requires prior speciﬁc permission and/or a
fee. Request permissions from permissions@acm.org.
CCS’16, October 24-28, 2016, Vienna, Austria
c(cid:13) 2016 ACM. ISBN 978-1-4503-4139-4/16/10. . . $15.00
DOI: http://dx.doi.org/10.1145/2976749.2978335

often limited in cost, computing power, and size. Moreover, embed-
ded devices are often security and privacy critical, since they sense
the environment, collect private information, or controls physical
equipment, possibly causing damages also in the physical world.
Unfortunately, smart devices usually lack the security capabilities of
general purpose computers. Indeed, an adversary can easily attack
such devices, and compromise both their privacy and safety. One
common attack is to modify or replace a device’s ﬁrmware, as part
of a larger attack scenario [2, 1]. In order to prevent such attacks and
ensure the safe and secure operation of a device, it is important to
guarantee its software integrity, e.g., via remote software attestation.
Remote software attestation is an interactive protocol that allows
a prover to prove its software integrity to a remote veriﬁer. The
prover demonstrates to the veriﬁer that its software is in a known
“good state”, which has not been modiﬁed. This is usually achieved
by signing integrity-protected memory regions. Attestation of indi-
vidual smart devices is a well established research area. However,
to date there is a lack of viable approaches to securely scale device
attestation to a very large number of devices: Indeed, today’s Inter-
net of Things (IoT) infrastructures often rely on a cloud backend to
handle each individual device. However, this traditional approach
has some shortcomings, in particular in terms of communication
and computation cost for the cloud infrastructure, which is linear in
the number of attested devices. Recently, one proposed approach,
SEDA [5], moved a ﬁrst step towards a more scalable and efﬁcient
protocol for attesting a large population of devices. SEDA assumes
a software-only adversary, i.e., an adversary that can compromise
only the software of the target device. It uses (symmetric key based)
hop-by-hop attestation within a group of devices, transitively collect-
ing and aggregating attestation responses along an aggregation tree.
SEDA merely reports the number of devices that passed attestation,
and does not provide additional information about the identity of
devices that failed attestation.

Unfortunately, while SEDA substantially increased the scalability
of network attestation, it also requires trust in all intermediaries. As
a consequence, all devices involved in the attestation protocol are
required to: (1) be equipped with a trusted execution environment;
and (2) participate in the attestation process. These requirements
represent a signiﬁcant limitation when not all the devices in a given
area are “trusted" to the same single entity (e.g., to the entity that
acts as a veriﬁer of the attestation process). Moreover, in presence
of a stronger adversary capable of physical attacks, i.e., capable of
tampering with the hardware of even a limited number of devices,
SEDA fails to guarantee the security of all other devices.
Contributions. In this paper, we propose SANA, the ﬁrst attesta-
tion scheme for large collections of devices that: (i) is scalable, i.e.,
it efﬁciently veriﬁes the integrity of a large collection of devices

731Figure 1: Collective attestation in a network of seven devices (four aggregators and ﬁve provers)

by means of a novel signature scheme, which allows aggregation
of attestation proofs; (ii) is publicly veriﬁable, i.e., the produced
aggregate signature can be veriﬁed by any one knowing the (ag-
gregate) public key; and (iii) enables untrusted aggregation, i.e.,
compromise (including physical tampering) of aggregating nodes
does not affect the integrity of the attestation process. Similar to all
other conventional attestation schemes, SANA does not deal with
privacy concerns, such as linking the software conﬁguration with a
device’s identity. Our main focus is providing standard attestation
capabilities for large IoT deployments. Required privacy can be
provided using secure channels. Our new approach brings the
following three technical contributions:

Novel Optimistic Aggregate Signature Scheme. We present a novel
signature scheme, called Optimistic Aggregate Signature (OAS).
OAS allows the aggregation of signatures on different attestation
responses, while having a veriﬁcation overhead that is constant in
the size of the network. The idea of combining aggregate and multi-
signature is to take the best-of-both-worlds. This has been necessary
since none of the existing schemes satisﬁed the novel requirements
we identiﬁed for secure collective attestation.

Secure Collective Attestation Scheme. We designed SANA, the
ﬁrst collective attestation scheme for networks of embedded devices
that supports high dynamicity and adheres to common assumptions
made in single-prover attestation. SANA leverages OAS over ag-
gregation trees to provide highly scalable attestation of large device
populations, in a single round-trip. SANA is applicable in settings
consistent with large scale IoT device deployments, where aggrega-
tor devices can be untrusted routers or cloud servers and is secure in
presence of a strong adversary capable of physical attacks.

Evaluation and Performance Analysis. We analyze the perfor-
mance of SANA on three state-of-the-art security architectures for
low-end embedded devices (e.g., SMART [12], TrustLite [17], and
TyTAN [11]), and present the simulation results for networks of up
to 1, 000, 000 devices, in order to demonstrate its scalability.
Outline. We introduce SANA in Section 2 and we present our nota-
tion in Section 3. We describe our signature scheme in Section 4,
and present the SANA protocol in Section 5. We describe an imple-
mentation of SANA in Section 6, and report performance results
in Section 7. In Section 8, we describe an extension of SANA. In
Section 9 we overview the related work, and the paper concludes in
Section 10.

2. SANA

2.1 System Model

We consider large groups of embedded devices, e.g., industrial
control systems, IoT devices in smart environments, and prospecting
robots. Each group consists of a number of interconnected devices
Di forming a network G, with either static or dynamic topology. G
may not have a routing protocol in place. However, devices in G are

able to identify and communicate to their direct neighbors, which is
a minimal assumption in such networks [29].
We formally deﬁne SANA as a protocol between the following
logical entities: prover (P), aggregator (A), owner (O), and veri-
ﬁer (V). As shown in Figure 1, a prover Pi composes a proof of
integrity of its software conﬁguration, i.e., an attestation response,
to be delivered via aggregators to a remote veriﬁer. In our setting,
provers can have different software and hardware conﬁguration.
However, we expect the majority of them to have a good software
conﬁguration (i.e., the latest non-compromised software version).

We refer to this type of provers as good provers(cid:101)Pi, while we refer
to the rest of the provers as bad provers(cid:98)Pi (i.e., devices with mali-

cious or outdated software). An aggregator Ai has the purpose of
relaying messages between entities, and collecting and aggregating
attestation responses from provers, or other aggregators. The entity
O represents the network owner or operator, responsible for the
deployment, as well as the maintenance, of every prover Pi in G.
Note that, a physical device in G can embed the functionalities of
every logical component described above, or a combination of them.

As an example, in Figure 1 device D3 acts both as a prover(cid:98)P3, and
an aggregator A2, while D5 acts only as a prover(cid:98)P4.

The goal of a collective attestation protocol is to assure a veriﬁer
V, which is typically, but not necessarily, the same entity as O, of
the overall integrity of G, i.e., the software integrity of every prover
Pi in G. Provided that none of the provers is physically attacked, G
is considered trustworthy if all the provers in G are good, i.e., have
the latest non-compromised software version approved by V. How-
ever, unlike existing attestation schemes that assume a software-only
attacker, SANA also considers the presence of physically tampered
devices, which may evade their detection. Consequently, we con-
sider G to be trustworthy, if at least all but physically tampered
provers are good. SANA can identify bad devices, as well as their
current software conﬁguration.

2.2 Protocol Overview

Figure 1 illustrates the concept of SANA, in a setting where G
is composed of seven physical devices D1, D2, D3, D4, D5, D6,
and D7. SANA is executed between the following (logical) entities:

four aggregators, A1, A2, A3, and A4, ﬁve provers,(cid:101)P1,(cid:98)P2,(cid:101)P3,(cid:101)P4,
and(cid:98)P5, the owner O, and a veriﬁer V. Each prover Pi is initialized
attestation protocol (operation 1 shown for (cid:101)P1 in Figure 1). The

with the cryptographic material needed to execute SANA collective

initialization is performed in a secure environment, and preferably,
but not necessarily, by O. At a given time, a veriﬁer V, which
possesses an appropriate attestation token generated by O, may
attest G. Note that, if V and O are two distinct entities, the token is
securely exchanged ofﬂine (operation 2 in Figure 1).
In order to attest the network, V chooses an aggregator (randomly
or based on physical proximity with the corresponding device; A1 in
Figure 1) and sends it an attestation request containing an attestation

732token (operation 3 in Figure 1). The request is ﬂooded in the
network forming a logical aggregation tree, that has provers as leaf
nodes, and aggregators as intermediate nodes.

Leaf nodes of the aggregation tree, i.e., provers(cid:101)P1,(cid:98)P2,(cid:101)P3,(cid:98)P4
and(cid:101)P5, create their attestation response and send it to their parent

nodes (operation 4 in Figure 1). Aggregators, i.e., non-leaf nodes
(A1, A2, A3 and A4), in turn, aggregate the attestation responses
received from their child nodes (operation 5 in Figure 1), and
forward the result to their parents. Finally, the aggregated report is
received and veriﬁed by V.
2.3 Requirements and Assumptions
Objectives. Following the collective attestation literature and the
discussion in Section 1, a scalable attestation protocol for collections
of devices should, under a strong adversary model, possess the
following properties:
• Unforgeability and Freshness. If the attestation hardware of a
prover is unchanged and a correct veriﬁer was able to validate
the aggregate attestation result including a given prover, then
the claimed integrity measurement reﬂects an actual software
conﬁguration of this prover at a time during this protocol run.
• Completeness. If the attestation hardware of provers is un-
changed and a correct veriﬁer was able to validate the ag-
gregate attestation result for a given set of provers, then all
provers actually reported their software conﬁguration in the
given protocol run.
• Scalablity. The protocol allows a veriﬁer to attest a large
network of devices. The communication and computational
complexity for prover and veriﬁer must be at most logarithmic
in the number of devices in the collection.
• Public Veriﬁability. In a public key domain, the collective
attestation evidence collected by a veriﬁer can be veriﬁed by
any party. In this case, the Unforgeability requirement only
proves the state of the prover within the time window between
generation of the challenge by the owner, and the receipt of
the evidence from the veriﬁer.
• Privacy Preservation. Veriﬁcation does not require detailed
knowledge of the conﬁguration of G (e.g., its topology ).
• Heterogeneity. The protocol is applicable to networks with
heterogeneous devices. The scheme can use any integrity
measurement mechanism used by devices in G.
• Availability. If all participants are honest and the network
is available then the protocol produces collective attestation
evidence.
• Limiting DoS. It should not be possible to run a global DoS

attack over the whole network through one device.

Unforgeability, completeness, and scalability are the main ob-
jectives of collective attestation. However, a collective attestation
scheme should also be DoS limiting. These four properties form
the crux of SANA’s contribution. Public veriﬁability and privacy
preservation are required in scenarios where network conﬁguration
should not be disclosed to the verifying entity (e.g., when the mainte-
nance in a smart factory is outsourced), and can be achieved through
digital signatures and aggregation. Heterogeneity, on the other hand,
is needed to support new device types and future attestation schemes,
and is achieved by separating the measurement and the reporting
mechanisms used for attestation [5].
Adversary Model. During initial key exchange, we assume the
existence of secure channels between any two honest participants.
Afterwards, we assume an adversary A can eavesdrop, insert, or
modify all messages exchanged between all devices in G. Further-
more, we assume two types of attacker: (1) a software only attacker,
as common in the attestation literature, which can manipulate (i.e.,

compromise) the software of all provers in G, but not physically
attack them; and (2) an attacker capable of physically tampering
with aggregator devices, i.e., extract their cryptographic material
or modify their software. However, in both cases we assume A is
not capable of forging an Optimistic Aggregate Signature (OAS)
according to Deﬁnition 3. Finally, while we consider DoS attacks in
general to be out of scope, we aim to limit these attacks by prevent-
ing A from running a global DoS on the whole network through one
single device.
Security Assumptions. We assume all provers in G correctly im-
plement the minimal hardware features required for secure remote
attestation described in [12], and adapted in [5]. A potential imple-
mentation of Pi could have: (1) a Read Only Memory (ROM) that
stores the protocol code and the related cryptographic key(s); and
(2) a simple Memory Protection Unit (MPU), that restricts access to
cryptographic key(s) to protocol code only, and ensures secrecy of
the key(s) through non-interruptible, and clean execution of the pro-
tocol code. We also assume the owner O to be trusted. Finally, we
assume all cryptographic schemes used in our protocol are secure.

3. PRELIMINARIES AND NOTATIONS

Let |M| denote the number of elements in a ﬁnite set M. If n
is an integer (or a bit-string), (cid:96)n indicates the bit-length of n. Let
m ←R M denote the assignment of a uniformly sampled element
of M to variable m. Furthermore, let {0, 1}(cid:96) be the set of all
bit-strings of length (cid:96). If E is some event (e.g., the result of a
security experiment), then Pr[E] denotes the probability that E
occurs. Probability ((cid:96)) is called negligible if, for all polynomials
f, ((cid:96)) ≤ 1/f ((cid:96)) for all sufﬁciently large (cid:96) ∈ N.
Let A be a probabilistic algorithm. Then y ← A(x) means that
on input x, A assigns its output to variable y. We occasionally
overload notation to let A(x) denote the set of all outputs y that
have non-zero probability of being returned by A on input x. K is
the set of key pairs (pk , sk ) that have non-zero probability of being
returned by KeyGen((cid:96)Sign).

We denote with AB an algorithm A that arbitrarily inter-
acts with algorithm B while it
The term
prot [A : xA; B : xB; ∗ : xpub] → [A : yA; B : yB] denotes an in-
teractive protocol prot between two probabilistic algorithms A and
B. Hereby, A (resp. B) gets private input xA (resp. xB) and public
input xpub. While A (resp. B) is operating, it can interact with B
(resp. A). As a result, A (resp. B) outputs yA (resp. yB).

is executing.

A multi-signature scheme [15, 23] allows n different signers to
sign the same message m in a constant-size signature, i.e., with
signature length independent of n. Most multi-signature schemes
also have veriﬁcation time quasi-independent of n, meaning that the
number of core cryptographic operations (e.g., exponentiations or
pairing computations) is independent of n. An aggregate signature
scheme [10] allows n different signers to sign n different messages
m1, . . . , mn with a constant-size signature, but all known schemes
have veriﬁcation time linear in n.

4. PROPOSED OAS SCHEME

We propose Optimistic Aggregate Signatures (OAS) as a general-
ization of aggregate and multi-signatures, where n different signers
can sign different messages m1, . . . , mn, but most signers are ex-
pected to sign the “default” message M . Individual signatures can
be aggregated into an aggregate signature that, in the optimistic
case where most signers sign M , is signiﬁcantly shorter and can be
veriﬁed signiﬁcantly faster than n separate signatures. In particular,
aggregate signature size and veriﬁcation time should be independent
of the number of signers who signed M . Our construction has aggre-

733gate signature size linear in the number of messages different from
M and in the number of signers signing those messages. Veriﬁcation
time is linear in the number of different messages that were signed,
but independent of the number of signers.
4.1 Deﬁnition of an OAS Schemes

An OAS scheme provides both scalability and heterogeneity and
is thus applicable for secure collective attestation. Deﬁnition 1
provides a formal deﬁnition of OAS schemes, while Deﬁnition 3
deﬁnes the unforgeability property for OAS schemes.

tuple

of

polynomial

probabilistic

DEFINITION 1

(OAS)
time

(OPTIMISTIC AGGREGATE SIGNATURES).
is
An Optimistic Aggregate Signature
scheme
a
algorithms
the se-
(KeyGen, AggPK, Sign, AggSig, Verify). On input of
curity parameter (cid:96)Sign ∈ N, KeyGen outputs a secret signing
key sk i and a public veriﬁcation key pk i, for each device Di,
i.e., (sk i, pk i) ← KeyGen(1(cid:96)Sign ). On input a set of public keys
{pk 1, . . . , pk n}, the public key aggregation algorithm AggPK
outputs an aggregate public key apk. On input a secret key sk,
a message m ∈ {0, 1}∗, and the default message M ∈ {0, 1}∗,
Sign outputs a signature α on m, i.e., α ← Sign(sk , m, M ). Note
that, the signature α is already considered an aggregate signature,
containing only pk’s signature on m. On input two aggregate
signatures α1, α2 and the default message M ,
the signature
aggregation algorithm AggSig outputs a new aggregate signature
α that includes all signatures in α1 and α2. To verify an aggregate
signature, the Verify algorithm takes an aggregate public key apk,
a set of public keys S⊥ of signers who did not contribute a signature
to the aggregate, an aggregate signature α, and the default message
M as input, and outputs either ⊥ to indicate that the signature is
invalid, or a set B = {(mi, Si) : i = 1, . . . , µ}, indicating that the
signers with public key pk i ∈ Si signed message mi, and that all
other signers whose keys were included in the aggregated public key
apk but not in any of S⊥, S1, . . . , Sµ signed the default message
M .

Intuitively, the correctness of an OAS scheme is deﬁned as fol-
lows: if all signers behave honestly and contribute at most one
signature to the aggregate, then the veriﬁcation algorithm pro-
duces the output that attributes the correct message to the cor-
rect signer. Deﬁning this formally is a bit tedious, however, due
to the many different orders in which signatures can be aggre-
gated. To simplify notation, for two sets B1,B2 containing tu-
ples (m, S) ∈ {0, 1}∗ × ({0, 1}∗)∗, let B = B1 (cid:116) B2 be the
“merged” set of tuples (m, S) where S = S1∪S2 if ∃(m, S1) ∈ B1
and ∃(m, S2) ∈ B2, where S = S1 if ∃(m, S1) ∈ B1 and
(cid:54) ∃(m, S2) ∈ B2, and where S = S2 if ∃(m, S2) ∈ B2 and
(cid:54) ∃(m, S1) ∈ B1.

(CORRECTNESS OF OAS). An OAS scheme is
DEFINITION 2
correct if:
(i) signing works, i.e., for all (cid:96)Sign ∈ N, all m, M ∈ {0, 1}∗,
all (pk , sk ) ← KeyGen((cid:96)Sign), all sets S⊥ such that pk (cid:54)∈ S⊥, it
holds that Verify(apk , S⊥, α, M ) returns ∅ if m = M and returns
{m,{pk}} if m (cid:54)= M whenever apk ← AggPK(S⊥ ∪ {pk}) and
α ← Sign(sk , m, M ).
(ii) aggregation works, i.e., for all aggregate signatures α1, α2,
all disjoint sets S1, S2, all subsets S⊥,1 ⊆ S1 and S⊥,2 ⊆ S2, and
all messages M ∈ {0, 1}∗, if Verify(apk 1, S⊥,1, α1, M ) = B1
and Verify(apk 2, S⊥,2, α2, M ) = B2 for apk 1 ← AggPK(S1),
apk 2 ← AggPK(S2), and apk ← AggPK(S1 ∪ S2), then it holds
that Verify(apk , S⊥,1 ∪ S⊥,2, α, M ) = B1 (cid:116) B2.

DEFINITION 3

(UNFORGEABILITY OF OAS).

Unforgeability of an OAS scheme requires that, even if all
other signers are dishonest, an adversary cannot produce an
aggregate signature that attributes a message to an honest
signer that never signed such message. More formally, for any
polynomial-time adversary A,
the following experiment must
return 0 with negligible probability:
(pk , sk ) ← KeyGen((cid:96)Sign)
(α, S⊥, (pk 1, . . . , pk n), (sk 1, . . . , sk n)) ← ASign(sk ,·)(pk )
If ∃ i : pk i (cid:54)= pk ∧ (pk i, sk i) (cid:54)∈ KeyGen((cid:96)Sign) then return 0
Let S ← {pk 1, . . . , pk n}
apk ← AggPK(S)
B ← Verify(apk , S⊥, α, M )
If S⊥ (cid:54)⊆ S or ∃(mi, Si) ∈ B : Si (cid:54)⊆ S then return 0
If ∃(mi, Si) ∈ B : pk ∈ Si and mi (cid:54)∈ Q then return 1
(mi,Si)∈B Si
If pk ∈ SM and M (cid:54)∈ Q then return 1
Else return 0

Let SM ← S \(cid:0)S⊥ ∪(cid:83)

(cid:1)

where Q is the set of messages that A queried from its Sign(sk ,·)

oracle.

The unforgeability notion in Deﬁnition 3 requires the adversary
to know the secret keys of all corrupt signers, which is modeled in
the game by requiring the adversary to output those secret keys as
part of his forgery. In practice, this can either be realized by letting a
trusted entity generate the keys of all signers, or by letting all signers
perform an extractable proof of knowledge of their secret key, either
interactively with a trusted entity, or non-interactively and include
it in their public keys. Alternatively, Ristenpart and Yilek [28]
showed that with minor modiﬁcations to some schemes, including
Boldyreva’s multi-signature scheme [9], it sufﬁces to let signers
create a simpler proof of possession, that is essentially a signature
on a challenge message. Therefore, being our OAS construction
in Section 4.2 based on Boldyreva’s multi-signature scheme, this
technique can be applied to our scheme as well. Also, note that the
above deﬁnition insists that the sets of public keys S⊥ and Si are
subsets of S = {pk 1, . . . , pk n}. It is up to the veriﬁer to perform
this check, either by looking up the relevant keys in S, or, if the
veriﬁer does not know S, by letting signers prove that their keys
were included in apk, e.g., through a certiﬁcate.
4.2 Our OAS Scheme from pairings

In what follows, we introduce our OAS construction from pair-
ings. Our scheme can be seen as a combination of Boldyreva’s
multi-signature scheme [9] and Boneh et al.’s aggregate signature
scheme [10]. In a multi-signature scheme, all signers sign the same
message and the signature can be veriﬁed in constant time. In the
aggregate signature scheme of Boneh et al., all signers have to sign
different messages and veriﬁcation is linear in the number of ag-
gregated signatures. Our construction essentially uses Boldyreva’s
multi-signature scheme to compress the signatures of those signers
who sign the same message, and uses Boneh et al.’s scheme on top
of it to aggregate the multi-signatures. Even though anyone familiar
with these schemes immediately sees that the algebra works out,
one has to tread very carefully in terms of security. Indeed, aggre-
gate signatures are notorious for having subtle restrictions on key
setup, signer composition, and the messages being signed, which,
when not adhered to, can ruin the scheme’s security [7]. We refer
the reader to Appendix B for a formal proof that our construction
indeed does satisfy the security notion of Deﬁnition 3. We note that
Syta et al. [32] already suggested to use Boneh et al.’s aggregate sig-
nature scheme in distributed signing applications, but they require
all nodes to sign the same message and lacked a detailed security
proof, which, given the subtleties mentioned above, is more than
just a formality.

734Let G1, G2, Gt be multiplicative groups of prime order p with
generators g1, g2, gt, respectively, with an efﬁciently computable
bilinear map e : G1 × G2 → Gt so that e(gx
for
all x, y ∈ Zp, and with an efﬁciently computable isomorphism
ψ : G2 → G1 so that ψ(g2) = g1. Let H : {0, 1}∗ → G1 be a
hash function modeled as a random oracle [8].
Key generation. Each signer chooses random secret key x ←R Zp

2 ) = gxy

1 , gy

t

Public key aggregation. The aggregate public key for individual

and sets its public key to pk ← gx
2 .

public keys pk 1, . . . , pk n is apk =(cid:81)n

i=1 pk i.

Signing. The signature on a message m is α ← (H(m)x,∅) if

m = M and is α ← (H(m)x,{(m,{pk})}) otherwise.

Signature aggregation. Aggregating two aggregate signatures
α1 = (τ1,B1) and α2 = (τ2,B2) can be done by computing
τ ← τ1 · τ2 and “merging” B1 and B2 into B ← B1 (cid:116) B2.
The resulting aggregate is α = (τ,B).
Veriﬁcation. To verify an aggregate signature α = (τ,B =
{(m1, S1), . . . , (mµ, Sµ)}) under aggregate public key apk,
non-contributing public keys S⊥, and default message M , let

.

(1)

pk(cid:1) . (2)

pk

(cid:89)

pk∈Si

apk M ←

apk

(cid:81)
pk∈S⊥ pk ·(cid:81)µ
(cid:1) · µ(cid:89)

(cid:81)
e(cid:0)H(mi),

i=1

pk∈Si

Verify that

e(τ, g2) = e(cid:0)H(M ), apk M

If so, then return B, otherwise return ⊥.

i=1

As mentioned earlier, and as is the case for other multi-signature
schemes [9, 20], the signers’ keys either have to be generated by
a trusted entity, or the signers have to prove possession of their
secret keys. For our scheme, the latter is most easily achieved by
signing an arbitrary message using a different hash function than
for normal signatures [28]1 and adding it to the public key, or by
including a Schnorr signature from which the corresponding secret
keys can be extracted by applying the generalized forking lemma of
Bagherzandi et al. [6].

5. PROTOCOL DESCRIPTION
SANA consists of algorithms and protocols executed by a veriﬁer
V, the owner O, and a set of aggregators and provers in the network
G. Table 1 provides an overview of the variables and parameters
used in the protocol speciﬁcation.

At its core, SANA distributes a challenge, asks each prover to
produce a signed attestation, and aggregates the resulting attestation
signatures. Since Denial of Service (DoS) attacks on tiny devices
are easy, SANA additionally provides an authorization scheme that
allows only authorized veriﬁers to execute this protocol.
Initialization. Each prover Pi is initialized in a trusted environment
by the network owner O with an OAS key pair (sk i ←R Zp, pk i ←
2 ), and an identity certiﬁcate cert(pk i), signed by O, certifying
gsk i
that pk i is a valid OAS public key of Pi with identity id i. Formally:

init(1(cid:96)) → (sk i, pk i, cert(pk i)) .

Token request. In order to attest a network G, a veriﬁer V must
possess a valid authorization token T generated and signed by the
1The same hash function also works as long as the message space
for proofs of possession is separated from that of regular signatures.

Table 1: Variables, parameters and procedures

Entities
O
V
Di

(cid:101)Pi
(cid:98)Pi

Ai
Network G parameters
a
n
gi
pi ≤ gi − 1
Prover Pi parameters

id i
h

(sk i, pk i)
skO (resp. V )
pkO (resp. V )

cert(pk i)
cert(pkO) (resp. V )

(c1, v1) . . . (cs, vs)
SANA parameters

T

N
H

texp
δt
Ch
apk
Si
S⊥

mi

M
α
Procedures
Enc(), Dec()
Sign()
Verify()
checkPolicy()

getFreeCounter()

checkCounter()

getSoftConf()
getGoodConﬁgs()

Owner or operator of the network
Veriﬁer (entity attesting the network)
Device i
Good prover i, i.e., a prover with one of the latest non-
compromised software conﬁgurations
Bad prover i, i.e., a prover with an outdated or malicious
software conﬁguration.
Untrusted aggregator i

Total number of aggregators in G
Total number of provers in G
Number of neighbors of Ai
Number of children of Ai in the aggregation tree

ID of Pi
Platform software conﬁguration (e.g., hash digest of bi-
nary code)
OAS secret and public key pair of Pi
Secret signing key of O (resp. V) (not based on OAS)
Public signature veriﬁcation key O (resp. V) (not based
on OAS)
Identity certiﬁcate of Pi (issued by O)
Public key certiﬁcates for O (resp. V) (issued by a
trusted third party)
List of attestation counters and corresponding values

Token used by V to perform attestation (T =
{H, cl , vl , texp , σ1})
A random nonce
The set of software conﬁgurations for the latest software
versions of all devices in G
Expiry time of a token T
Expiry period of a token T
An attestation challenge (Ch = {N, T})
Aggregate public key of all provers in G
Set of public keys grouped by same message signed mi
Set of public keys that did not participate in generating
the OAS signature
Software conﬁguration on which public keys are
grouped
The default message signed by OAS
An OAS signature

Public key encryption and decryption
Creating a digital (or OAS) signature
Veriﬁcation of a digital (or OAS) signature
Application speciﬁc procedure that determines whether
to accept a token request. Outputs δt > 0 if the request
is accepted
Searches for an unused counter cl in c1 . . . cs. Sets cl
status to “busy”, increments vl and outputs cl and vl
Checks whether the value of the received counter is
greater than the value of the local counter; in this case,
sets value of local counter to value of received ones
Measures the software conﬁguration
Retrieves the set H of software conﬁguration for the
latest software versions of all devices in G

owner O of the network. V acquires T = {H, cl , vl , texp, σ1} by
executing an ofﬂine protocol tokenReq (see Figure 2) with O. The
main purpose of tokenReq is at the same time mitigating DoS at-
tacks (that are based on the attestation protocol, and can be launched
through one single device on the entire network), while allowing
attestation service to be public.
The network owner O keeps a list of counters c1, . . . , cs with
values v1, . . . , vs. A counter can be assigned by O to a valid token
request until an expiry time texp, associated to the request, i.e., the
counter is marked as “busy” until texp. After receiving a valid token

735Figure 2: Protocol tokenReq

request from V, O searches for a free (i.e., not busy) counter cl,
with value vl, increments vl by one, and returns the tuple (cl , vl ) to
the requesting veriﬁer – getFreeCounter(). Counters are necessary
to protect the network against replay attacks: Indeed, each prover
Pi also keeps a list of s counters with corresponding values; once it
received an attestation request, Pi checks whether the counter value
associated with the request is greater than the value locally stored,
and, only in this case, updates its local value and proceeds with the
evaluation of the attestation request – checkCounter().
The details of tokenReq are as follows: V initiates the protocol by
sending O a random challenge NV, showing its interest in attesting
G. Upon receiving NV, O creates a random challenge NO and
sends it to V. V then creates a signature σV 2 on NO and a protocol
parameter δt and sends it back to O along with δt, and its identity
certiﬁcate cert(pkV ). Parameter δt indicates the required expiration
period of the requested T . Based on idV and the requested δt, O
decides whether to accept V’s request, according to an application
speciﬁc policy – checkPolicy().
If the request is accepted and
σV veriﬁed correctly, O retrieves the set H = {h1, . . . , hz} of
software conﬁguration of benign software in G (i.e., the software
conﬁguration of latest software version on different devices in G)
– getGoodConﬁgs(). The list is then hashed into one single good
conﬁguration hg = hash(h1| . . .|hz). Finally, O sends to V: (1)
the aggregate public key apk of all provers in G; (2) A signature
σ2 over apk; and (3) An encrypted 3 token . Finally, V veriﬁes σ2,
decrypts and veriﬁes T , and stores it along with apk. Formally:

tokenReq[V : δt , skV ; O : skO, apk ;

∗ : cert(pkO), cert(pkV )] → [V : T , apk ; O : texp] .

Attestation: After obtaining an attestation token T , V can attest the
network. Before texp, V chooses a random (gateway) aggregator A1,
through which it runs the collective attestation attest of the whole
network (see Figure 3). In detail, V sends A1 an attestation request
2Signatures in tokenReq are not based on our OAS scheme, but use
an existing public key infrastructure (PKI) between O and V.
3Encryption is based on the public key pkV of V.

Ch = {N, T} including a random challenge N. Upon receiving
this request, A1 veriﬁes the counter value vl – checkCounter(),
and the signature σO using owner’s O public key. We denote this
procedure by verifyChallenge(). If the veriﬁcation succeeds, A1
forwards the request to its neighbors. Each neighbor, in turn, veriﬁes
and forwards the request to its neighbors, and so forth, until the
request is received by all provers in the network. Consequently an
aggregation tree rooted at A1 is formed.

As a next step in the protocol, each prover Pi (at the leaf nodes)
in the generated aggregation tree, generates its own software conﬁg-
uration hi – getSoftConf(). If hi is a benign software conﬁguration
(i.e., hi ∈ H), Di creates an Optimistic Aggregate Signature (OAS)
αi over the good software conﬁguration hg, the challenge N, the
counter id cl, and the counter value vl (using its OAS secret key
ski), Otherwise (if hi /∈ H), αi is created over Di’s software con-
ﬁguration hi. αi is then sent to Di’s parent in the aggregation tree.
We denote this procedure as createResponse().

Aggregators at intermediate nodes of the tree aggregate responses
coming from their children according to the procedure AggSig de-
ﬁned in Deﬁnition 1, which we denote as aggregateResponse(),
i.e., signatures are aggregated by M = hg|N|cl|vl being the de-
fault message. Consequently, attestation responses from provers are
propagated, in reverse, along the aggregation tree toward the root
A1. Upon receiving all the responses from its children, node A1
forwards the ﬁnal aggregated signature α1 to V.
Finally, V veriﬁes α1 according to Verify in Deﬁnition 1. If the
veriﬁcation succeeds and B = φ, V concludes that the network
is trustworthy. If B (cid:54)= φ, V learns the identity and the software
conﬁguration of all bad devices (i.e., with malicious or outdated
software). Formally:

attest1 [V : T , apk ; A1 : −; ∗ : pkO] → [V : r; A1 : Ch] .
attest2 [Ai : Ch; Dj : (sk j ); ∗ : pkO] → [Ai : αj ; Dj : Ch] .

The reader may refer to Appendix A for the security analysis of
SANA.

736Figure 3: Protocol attest (attest1 and attest2)

6. SANA IMPLEMENTATION

We implemented SANA based on three recently proposed se-
curity architecture for low end embedded devices: SMART [12],
TrustLite [17], and TyTAN [11]. In this section, we discuss our
implementation based on TyTAN shown in Figure 4.

Figure 4: Implementation of SANA based on TyTAN [11]
TyTAN [11] is a security architectures for embedded systems,
that is based on TrustLite [17]4. TyTAN provides hardware-assisted
isolation of system components with real-time execution. Isolation
is fundamental to protect critical components against unintended ac-
cess by other potentially malicious components. In TyTAN, a Mem-
ory Protection Unit (MPU) restricts access to data, to the task that
owns this data. Moreover, both authenticity and conﬁdentiality of the
4TrustLite is based on Intel’s Siskiyou Peak research platform.

tasks’ code and data are based on secure boot. We implemented the
components of SANA (i.e., verifyChallenge(), createResponse(),
and aggregateResponse()) on TyTAN as isolated tasks, which are
protected via secure boot. Further, we conﬁgured the MPU such
that only SANA’s tasks can access the protocols secret data. For
example, according to rule #2 in the MPU table in Figure 4, the
OAS secret key sk i (which resides in memory address Addr 6 to
Addr 7) is only read accessible to createResponse() (i.e., code re-
siding in memory address Addr 3 to Addr 4). Finally, we developed
a proof-of-concept implementation of our OAS scheme for both
the low-end device in exam (i.e., TyTAN [11]), and for commodity
hardware. Our OAS scheme implementation uses the library in [34]
for pairing-based cryptographic operations, which we found particu-
larly suitable for our target platforms. OAS operations are deﬁned
over the BN254 pairing-friendly elliptic curve [34], which provides
a strong security level of 128-bit.

7. PERFORMANCE EVALUATION

We now evaluate computational, memory, communication, and
energy costs of SANA based on our implementation in Section 6.
Computational cost. The major part of the computational cost on
provers and aggregators, is due to the cryptographic operations, i.e.,
creating and aggregating Optimistic Aggregate Signature (OAS)
signatures, and creating the good software conﬁguration hg. The
gateway aggregator A1, which directly communicates to the veriﬁer
V, aggregates at most g1 signatures, where g1 is the number of
neighbors of A1 and creates one hash. Every aggregator Ai also
creates one hash, and aggregates at most pi signatures, where pi ≤
gi − 1 and gi is the number of neighbors of Ai in the network.
Finally, each Pi creates one OAS signature and one hash.

737Communication cost. Our OAS implementation has a signature
size of (cid:96)Sign = 256 bits. We also use (cid:96)N = 160, (cid:96)c = 64, and
(cid:96)(cid:48)
Sign = 320. Consequently, counter values are 8 bytes, counter
ids are 2 bytes, nonces are 20 bytes, OAS signatures are 32 bytes,
public keys are 32 bytes, digital signatures are 40 bytes, and software
conﬁgurations are 20 bytes. A token T with z good conﬁgurations
consists of 20z + 58 bytes, and a challenge Ch of 20z + 78 bytes.
A response αi has size 32 + 32w + 20µ bytes, where µ is the
number of distinct bad software conﬁgurations h1, . . . , hµ and w
is the number of distinct OAS public keys of bad provers. The
communication overhead of the each aggregator Ai is, sending at
most 32 + (20z + 78)gi + 32w + 20µ bytes and receiving at most
20z + 78 + 32gi + 32w + 20µ bytes. Finally, every prover Pi sends
84 bytes and receives 20z + 78 bytes.
Memory cost. Each Pi in G stores the ids (c1 . . . cs) and values
(v1 . . . vs) of s counters, its OAS secret key (sk i), its identity cer-
tiﬁcate (cert(pk i)), and the public key pkO of O. The storage
overhead for every Pi is estimated as 10s + 228 bytes, where s is
the number of counters used by O. Low-end embedded devices
targeted by SANA (e.g., the TI MSP430) have at least 1024 bytes
of non-volatile memory. SANA consumes less than 32% of this
memory, assuming that ten veriﬁers could attest G within the same
time frame.
Run-time. SANA is optimized so that the communication overhead
is constant when all provers are correctly conﬁgured. On the other
hand, the aggregation tree approach allows provers, and aggrega-
tors on the same depth of the tree, to perform their computations
in parallel. However, the OAS signature aggregation at depth d
depends on the signature creation computations at depth d + 1.
Consequently, the overall run-time of the SANA depends on the
depth (d = f (n + a) ∈ O(log(n + a))) of the aggregation tree
generated for the graph of the network, the number of neighbors of
each aggregator, and the number of bad provers. Let tsign, tagg, tver,
thash and ttx be the times needed to create and aggregate an OAS sig-
natures, verify a digital signature, create the good conﬁguration hg,
and transmit a single byte to a neighbor, respectively. The run-time
t of SANA is estimated as:

t ≤(cid:2)110d +
+(cid:0) d(cid:88)

d(cid:88)
(32wi + 20mi)(cid:3) · ttx+
(cid:1) · tagg + d · (tver + thash) + tsign.

i=0

pi

i=0

Table 2 presents an evaluation of the cryptographic operations
required by our OAS, on both TyTAN [11] and a t2.micro Ama-
zon EC2 instance [3]5. Results are an average over 100 executions.
Table 3 shows the estimated execution time for each of the OAS algo-
rithms we presented in Section 4, where pi is the number of children
of a node in the aggregation tree, µ is the number of conﬁgurations
in G, and n is the number of provers in G.
Energy costs. Let Esend, Ercv, Esign, Eagg, Ever, and Ehash be the
energy required to send one byte, receive one byte, create or aggre-
gate OAS signatures, verify a digital signature, and create the good
conﬁguration hg respectively.
Then the energy consumption E(Ai) of each aggregator in G is:

E(Ai) ≤(cid:0)32 + (20z + 78)gi + 32w + 20m(cid:1) · Esend
+(cid:0)20z + 78 + 32gi + 32w + 20m(cid:1) · Ercv

+

+

+ pi · Eagg + Ever + Ehash.

And the energy consumption E(Pi) of each prover in G is:
E(Pi) ≤ 84 · Esend + (20z + 78) · Ercv + Esign + Ehash.

Table 2: Performance of cryptographic operations

Function

TyTAN [11]
Run-time (ms)

EC2 t2.micro [3]
Run-time (ms)

(*)

921.52
1282.71

H : {0, 1}l → G1
gx, g ∈ G1
gx, g ∈ G2
ab, a, b ∈ G1
ab, a, b ∈ G2
ab, a, b ∈ GT
e : G1 · G2 → GT
(*) Operation not performed by provers or aggregators in SANA

3.39
4.71
11.60
0.32
0.33
0.07
7.67

86.48
(*)

(*)

(*)

Table 3: Performance of OAS algorithms.
EC2 t2.micro [3]
Run-time (ms)

TyTAN [11]
Run-time (ms)

Function

Sign

PubKeyGen

PubKeyAggr

SignatureAggr

AggregateVerify

2204.23

(*)

(*)

86.48 · pi

(*)

8.1

11.60
0.33 · n
0.32 · pi

0.33 ·(cid:80)µ

2 (|Si| − 1) + (8.16) · µ

(*) Operation not performed by provers or aggregators in SANA

Simulation results. We simulated SANA for large networks using
the OMNeT++ [25] event simulator. We implemented our protocol
at the application layer and used delays, based on measurements for
TyTAN (Table 2), to simulate the different cryptographic operations.
We set the communications rate for links between two devices to
250 Kbps, which is the deﬁned data rate of ZigBee – a common
communication protocol for IoT devices. We simulated different
network topologies including trees (with fan-out degree 2, 4, 8, and
12), and networks with ﬁxed number of neighbors (4, 8 and 12). We
varied the size of the network from ten to 1, 000, 000 devices. For
a fair comparison with SEDA [5], we carried out our simulations
assuming all devices in the network to be low-ended devices that
needs to be attested. Figure 5 and Figure 6 show the results of
our simulations. To better assess the performance of SANA, we
also simulated it in its targeted setting, where untrusted aggregator
devices are more powerful, i.e., 50% Raspberry Pi devices6, 30%
Intel Galileo devices7, and 20% t2.micro EC2 instances [3], and the
communication rate is 5 Mbps. We also simulated the extension
of SEDA, described in [5], that is capable of identifying malicious
devices. We denote this extension by SEDA-ID. From our results,
we can see that, if the number of bad provers is ﬁxed, then the run-
time of SANA, for a tree topologies (Figure 5(a)) and for networks
with ﬁxed number of neighbors (Figure 5(b)), is logarithmic in the
size of the network.

As shown in Figure 6(a), SEDA shows better performance com-
pared to SANA. However, while SEDA imposes a strong require-
ment on the devices participating in the attestation protocol, which
are low-end devices equipped with trusted hardware, SANA gives
a signiﬁcantly improved ﬂexibility in the type of devices that can
act as aggregators, and resiliency to a stronger attacker model. In
fact, SANA does not impose any constraint or requirement on the
devices acting as aggregators, which can be completely untrusted.
This better serves typical practical deployments, where data ag-

5Amazon EC2 is running Ubuntu server 14.04 equipped with an
Intel Xeon Processor CPU (up to 3.3 GHz), and 1 Gbyte of RAM.

6Raspberry Pi has a 700 MHz CPU and 512 MByte of RAM
7Intel Galileo has a 400MHz CPU and 256 MByte of RAM

738(a) Tree topologies

(b) Fixed number of neighbors

Figure 5: Performance evaluation of SANA

(a) Low-end only devices

(b) Realistic setting for SANA

Figure 6: Performance comparison between SANA and SEDA

gregation is performed by more powerful but untrusted devices in
the network, such as routers or cloud servers. Figure 6(b) further
stresses the advantage of SANA in more realistic scenarios, showing
its run-time adopting more powerful devices as aggregators. As
can be seen from Figure 6(b), the difference in the run-time of the
two schemes in such scenario, can become as little as 1.5 seconds.
Finally, while SEDA merely reports the number of devices that
failed attestation, SANA enables the veriﬁer to identify bad provers
as well as their software conﬁguration. Figure 6(b) shows the per-
formance of SEDA when modiﬁed to report the ids of devices that
failed attestation as suggested in the original paper [5]. Our perfor-
mance analysis demonstrates that, in its targeted setting, SANA can
perform as good as SEDA, regardless of the digital signature, and
DoS mitigation included. Note that, digital signatures may leverage
hardware acceleration (as already done for base symmetric crypto
operations) leading to a better performance than SEDA.

8. THRESHOLD ATTESTATION

Although constant in the size of the network, the overhead of
SANA is linear in the number of bad provers (i.e., malicious de-
vices). However, as described in Section 1, we aim at providing
a constant-time network attestation protocol, through which a re-
source constrained veriﬁer V (e.g., a smartphone) can verify a very
large (e.g., in order of millions) network of devices. In this section
we brieﬂy discuss a possible extension of SANA that allows such a
constant-time veriﬁcation.

We base this extension on the following observation: While in
some applications the number of malicious devices might be linear
in the size of the network (i.e., a certain percentage), typically the
maximum number of accepted compromise is ﬁxed. We believe
that this assumption is reasonable, since the number of devices to
tolerate is related to the redundancy rather than to the size of the
network. Consequently, we can set a threshold (i.e., an upper
bound) for the number of bad devices to verify. The threshold is
set by V, and embedded inside the token T . During attestation
responses aggregation, aggregators keep aggregating signatures on
bad software conﬁgurations only until the threshold is reached. Ev-
ery signature received afterwards is simply dropped. Consequently,
since dropping signatures renders the ﬁnal report unveriﬁable, if

report veriﬁcation fails, V deduces that the number of bad devices
has exceeded the threshold.

As shown in Figure 7, threshold attestation run in constant- time.
However, besides reaching the upper bound in the number of al-
lowed bad conﬁgurations, other factors, such as benign errors and
active (DoS) attacks, may cause a failure in the veriﬁcation of the
aggregate attestation response. For this reason, it is important to
verify that this result is indeed due to the existence of too many bad
devices. In order to tackle this problem, a potential solution is to
split the OAS signature into two parts: An aggregate signature (over
bad conﬁgurations), and a multi-signature (over the good conﬁgu-
ration). In this way, verifying the aggregate signature (in constant
time), gives V an assurance that the number of devices with bad
conﬁguration has exceeded the threshold. Additionally, V learns
identities and software conﬁgurations of such bad devices.

Figure 7: Run-time of SANA on an EC2 t2.micro [3] veriﬁer

9. BACKGROUND AND RELATED WORK
Individual Device Attestation is a well-established research area.
The main goal of an attestation process is to allow a veriﬁer to check
the integrity of the software running on a (potentially remote) device
(prover). We can distinguish three main approaches of attestation:
software-based, co-processor-based, and hybrid. Software-based
attestation [16, 31, 14, 19] requires no secure hardware and does
not rely on cryptographic secrets, making it particularly attractive
for low-end devices with limited resources. Unfortunately, the se-
curity of software-based attestation has been challenged [35], since
it is based on strong assumptions that are hard to achieve in prac-
tice [4]. As an example, software-based attestation assumes that
the attestation algorithm and its implementation are optimal, and
that the adversary is passive during the whole execution of the at-
testation protocol. Moreover, software-based attestation relies on
strict estimation of round trip times, requires an out-of-band authen-
tication channel, and is thus restricted to one hop communication,
and not suitable for remote attestation. Co-processor based attes-
tation schemes [27, 33, 18, 30, 22, 21], on the other hand, offer
improved security guarantees. However, they are more suitable for
general-purpose computing platforms, since their underlying secu-
rity hardware is often too complex and/or expensive for low-end
embedded devices. A third recently presented approach for attes-
tation is based on a hardware/software co-design [12, 17, 13, 11],
and aims for minimizing the hardware security features required for
enabling secure remote attestation. Such security features can be
as simple as a Read Only Memory (ROM), and a simple Memory
Protection Unit (MPU). SANA requires the same minimal hardware
support to implement collective attestation on the attested devices.
Collective Attestation. SEDA, the solution recently proposed
in [5], made a ﬁrst step towards a collective attestation, i.e., the
scalable attestation of large groups of interconnected devices. The
main focus of SEDA is efﬁciency and applicability to low-end de-
vices, rather than security in the presence of a strong adversary. To
that end, SEDA extends the software-only attacker assumed by most

739single-prover attestation schemes to, so-called, swarms of devices.
With this in mind, security hardware, used for protecting attesta-
tion code, is exploited to enable: (1) neighbors’ veriﬁcation, which
decreases the load on the veriﬁer; and (2) secure hop-by-hop aggre-
gation, which reduces the communication overhead. SEDA achieves
high efﬁciency and scalability through the distribution of the attesta-
tion burden across the whole network. It merely reports the number
of devices in the network that passed attestation. SEDA requires
(minimal) trust anchor in hardware for all involved nodes [5], and
therefore, it cannot operate in presence of a stronger attacker, i.e.,
an attacker capable of physically tampering devices. Indeed, if an
attacker violates the hardware security of one node, it may break the
overall security of the scheme for all other devices.

Our proposed collective attestation protocol SANA overcomes
the limitations of SEDA by: (i) requiring minimal trust anchor in
hardware only for the attested devices, (ii) allowing aggregation to
be performed by largely untrusted nodes, which are only required
for availability, and (iii) limiting the effect of successful attacks
on the hardware of an attested device to the device itself, i.e., it
will not affect the attestation of other devices. Similarly, Denial-of-
Service attacks on one device in SANA will not affect other devices.
Finally, SANA informs the veriﬁer with ids as well as software
conﬁgurations of the devices that failed attestation.
In Network Aggregation. To meet the aforementioned goals,
SANA employs in network aggregation. Several secure in network
aggregation protocols have been proposed in the sensor network
area, and in wireless sensor networks in particular, to provide scal-
able data collection from sensors [26]. In general, such aggregation
schemes allow a collection of sensors to collaboratively and securely
compute arbitrary aggregation functions on collected data, to reduce
message complexity. However, all these protocols have either a
veriﬁcation complexity which is linear in the number of nodes in
the network, or are built in multiple protocol rounds.
Aggregate Multi-Signatures. SANA requires a scalable aggregat-
able signature scheme, to allow attested devices in the network to
sign their state. Such scheme allows different signers with different
public keys to sign distinct messages. Moreover, it allows inter-
mediate nodes to securely aggregate individual signatures into a
single veriﬁable short signature. Unfortunately, all known aggregate
signature schemes have a veriﬁcation overhead that is linear in the
number of messages and signers, which renders them unsuitable for
scalable attestation. Additionally, they either require all messages to
be distinct, or a complex key agreement protocol [24], require a se-
quential order [9, 20], or all the signatures to be created on the same
message [6]. As a consequence, we consider none of the known
scheme as suitable for our collective attestation scheme. Recently,
the work in [32] proposed CoSi, a scalable witness cosigning system
for certiﬁcation, logging, and timestamping authorities that com-
bines existing multi-signature schemes with communication trees.
However, the protocol proposed in [32] considers static communica-
tion trees, constitutes multiple round-trips, and has communication
and computational overhead that are also linear in the number of
signers. Moreover, CoSi does not allow signing different messages,
and is thus not applicable to large scale network attestation.

For the reasons above, in this paper we present a new signature
scheme, Optimistic Aggregate Signature (OAS), that: (1) allows
signatures on distinct messages to be aggregated; and (2) provides
a signature veriﬁcation algorithm that is constant in the number of
signers. The communication overhead of the scheme is linear in the
number of different messages, while the computational overhead is
linear in the number signers who signed a different message than
the default one. However, this number is assumed limited. To the
best of our knowledge, our proposed OAS is the ﬁrst scheme that

satisﬁes the requirements of a secure collective attestation. Finally,
we present a pairings-based construction of OAS, and combine it
with aggregation trees, providing unlimited scalability. Our OAS
construction is also applicable to witness cosigning at certiﬁcation,
logging, and timestamping authorities [32].

10. CONCLUSIONS

Collective attestation is a key building block for securing the
Internet of Things. For very large numbers of devices, to enable
enterprises to validate the conﬁguration and software and ensure
that all devices are indeed up-to-date. In this paper, we have pro-
posed the ﬁrst practical and secure collective attestation scheme
SANA. It substantially improves the state of the art (e.g. SEDA
[5]) in three aspects: (1) it is easy to deploy since it can use any
untrusted aggregator; (2) its output is publicly veriﬁable since a
short aggregate attestation can be publicly veriﬁed by anyone; (3) it
provides superior security since it ensures that if a device is fully
compromised (including its hardware and keys), then other devices
are not affected at all; and (4) it allows a realistic trust model, where
only the attested devices are required to be trusted. We have demon-
strated that the protocol is truly scalable and can be implemented on
lightweight devices.

Acknowledgements
We thank anonymous reviewers for their useful comments. This
research was co-funded by the German Science Foundation, as part
of project S2 within CRC 1119 CROSSING, EC-SPRIDE, the Eu-
ropean Union’s 7th Framework Programme, under grant agreement
No. 609611, PRACTICE project, and Intel Collaborative Research
Institute for Secure Computing (ICRI-SC). This work is also par-
tially supported by the EU TagItSmart! Project (agreement H2020-
ICT30-2015-688061), and the EU-India REACH Project (agree-
ment ICI+/2014/342-896). Mauro Conti is supported by a Marie
Curie Fellowship funded by the European Commission (agreement
PCIG11-GA-2012-321980).

11. REFERENCES
[1] Target attack shows danger of remotely accessible HVAC

systems. http://www.computerworld.com/article/2487452/
cybercrime-hacking/target-attack-shows-danger-of-
remotely-accessible-hvac-systems.html, 2014.

[2] Jeep Hacking 101. http://spectrum.ieee.org/cars-that-think/

transportation/systems/jeep-hacking-101, 2015.

[3] Amazon EC2 Instance Types.

https://aws.amazon.com/ec2/instance-types/, 2016.

[4] F. Armknecht et al. A security framework for the analysis and

design of software attestation. In ACM CCS’13.

[5] N. Asokan et al. SEDA: Scalable Embedded Device

Attestation. In ACM CCS’15.

[6] A. Bagherzandi et al. Multisignatures secure under the

discrete logarithm assumption and a generalized forking
lemma. In ACM CCS’08.

[7] M. Bellare, C. Namprempre, and G. Neven. Unrestricted

aggregate signatures. In ICALP ’07.

[8] M. Bellare et al. Random oracles are practical: A paradigm

for designing efﬁcient protocols. In ACM CCS ’93.

[9] A. Boldyreva. Threshold signatures, multisignatures and blind

signatures based on the gap-difﬁe-hellman-group signature
scheme. In PKC ’03.

[10] D. Boneh et al. Aggregate and veriﬁably encrypted signatures

from bilinear maps. In EUROCRYPT’03.

[11] F. Brasser et al. Tytan: Tiny trust anchor for tiny devices. In

ACM/EDAC/IEEE DAC’15.

[12] K. Eldefrawy et al. SMART: Secure and minimal architecture

for (establishing a dynamic) root of trust. In NDSS’12.

740[13] A. Francillon et al. A minimalist approach to remote

attestation. In DATE’14.

[14] R. Gardner et al. Detecting code alteration by creating a

temporary memory bottleneck. IEEE Transactions on
Information Forensics and Security, 2009.

[15] K. Itakura et al. A public-key cryptosystem suitable for digital

multisignatures. NEC Research & Development, 1983.
[16] R. Kennell et al. Establishing the genuinity of remote

computer systems. In USENIXSec’03.

[17] P. Koeberl et al. TrustLite: A security architecture for tiny

embedded devices. In ACM EuroSys’14.

[18] X. Kovah et al. New results for timing-based attestation. In

IEEE S&P’12.

[19] Y. Li et al. VIPER: Verifying the integrity of peripherals’

ﬁrmware. In ACM CCS’11.

[20] S. Lu et al. Sequential aggregate signatures, multisignatures,
and veriﬁably encrypted signatures without random oracles.
Journal of Cryptology, 2012.

[21] J. McCune et al. TrustVisor: Efﬁcient TCB reduction and

attestation. In IEEE S&P ’10.

[22] J. McCune et al. Flicker: An execution infrastructure for TCB

minimization. SIGOPS Operating Systems Review, 2008.

[23] S. Micali et al. Accountable-subgroup multisignatures:

extended abstract. In ACM CCS’01.

[24] S. Micali et al. Accountable-subgroup multisignatures:

Extended abstract. In ACM CCS’01.

[25] OpenSim Ltd. OMNeT++ discrete event simulator.

http://omnetpp.org/, 2015.

[26] S. Ozdemir and Y. Xiao. Secure data aggregation in wireless

sensor networks: A comprehensive overview. Computer
Networks, 2009.

[27] J. Petroni et al. Copilot — A coprocessor-based kernel

runtime integrity monitor. In USENIXSec’04.

[28] T. Ristenpart et al. The power of proofs-of-possession:

Securing multiparty signatures against rogue-key attacks. In
EUROCRYPT’07.

[29] M. Rubenstein et al. Programmable self-assembly in a

thousand-robot swarm. Science, 2014.

[30] D. Schellekens et al. Remote attestation on legacy operating
systems with trusted platform modules. Science of Computer
Programming, 2008.

[31] A. Seshadri et al. SAKE: Software attestation for key

establishment in sensor networks. In Ad Hoc Networks. 2011.

[32] E. Syta et al. Keeping authorities"honest or bust"with

decentralized witness cosigning. In IEEE S&P ’15.

[33] Trusted Computing Group (TCG). Website.

http://www.trustedcomputinggroup.org, 2015.

[34] T. Unterluggauer et al. Efﬁcient pairings and ECC for

embedded systems. In CHES ’14.

[35] G. Wurster et al. A generic attack on checksumming-based

software tamper resistance. In IEEE S&P ’05.

APPENDIX
A. SECURITY OF SANA
The security goal of any collective attestation scheme is to ensure
a veriﬁer V that all the devices in a network are running a software
that is known to, and accepted by V. In other words, V should
accept the attestation result, and declare the network G as benign,
if and only if all devices in G (at least those that are not physically
attacked) are running a software it agrees on. We formalize this
goal as a security experiment ExpA between an adversary A (as
deﬁned in Section 2.3), G and V. In this experiment, A physically
attacks a number of provers P1, . . . Pp, and modiﬁes the software
of at least one prover Pc that it did not physically attack. A may
have full control of all aggregators. After a polynomial number (in
terms of the security parameters (cid:96)N , (cid:96)c, and (cid:96)Sign) of steps by A, V
outputs its decision r = 1 indicating it accepts the attestation result,

or r = 0 otherwise. The result of the experiment is deﬁned as the
output of V, i.e., ExpA = r. A secure collective attestation scheme
is deﬁned as follows:

collective attestation scheme is secure if Pr(cid:2)r = 1|ExpA(1(cid:96)) = r(cid:3)

(SECURE COLLECTIVE ATTESTATION). A

DEFINITION 4

is negligible in (cid:96) = f ((cid:96)N , (cid:96)c, (cid:96)Sign), where the function f is
polynomial in (cid:96)N , (cid:96)c, and (cid:96)Sign.

THEOREM 1

(SECURITY OF SANA). SANA is a secure col-
lective attestation scheme (Deﬁnition 4) if the underlying Aggregate-
Multi Signature (OAS) scheme is not forgeable (Deﬁnition 3).

B = φ, and M = (cid:0)hash(h1| . . .|hz)(cid:1)|N|cl|vl. N is the nonce,

PROOF (SKETCH) OF THEOREM 1. The veriﬁer V returns r =
i.e., accepts an attestation response α1 only if B =
1,
{(m1, S1), . . . , (mµ, Sµ)} = Verify(apk , S⊥, M , α1), where
apk is the OAS aggregate public key of all provers in G, S⊥ = φ,
h1, . . . , hz are all the benign software conﬁgurations included in H,
and cl (resp. vl) is the id (resp. value) of the counter previously sent
by V. To avoid detection of a compromised prover Pc, A can use
one of the following strategies: (1) A does not alter the response
from Pc; (2) A uses an old signature αold previously generated
by Pc on the good software conﬁguration hg; (3) A modiﬁes H
to include the software conﬁguration of Pc; (4) A generates an
aggregate signature that attributes a response M = hg|N|cl|vl to
Pc; or (5) A modiﬁes the aggregate public keys apk sent from the
owner O to V during tokenReq protocol.
We start with strategy (1). According to our assumptions in Sec-
tion 2, A can neither tamper with the code performing integrity
measurements on Pc nor extract its secret signing key sk c. Con-
sequently, the response of Pc will include an OAS signature on
hc|N|cl|vl, where hc is the current software conﬁguration of Pc.
Since hc is the security conﬁguration of a maliciously modiﬁed
software, V will always return r = 0, if the underlying integrity
measurement mechanism that generates the software conﬁguration
can detect this modiﬁcation (i.e., hc /∈ H). On the other hand, if
A uses an old signature αold over Mold = hg|Nold|cl|vl (Strategy
(2)), B will be equal to φ only if N = Nold, which is negligible
in (cid:96)N , where (cid:96)N represents the size of the nonce. Consequently, V
will always return r = 0.
Next, we consider strategy (3), where the adversary modiﬁes
H to include the software conﬁguration hc of Pc. Since H is
part of the authenticated token T , A should forge the signature σ1
generated by the owner O. The success probability of this strategy
is negligible in (cid:96)(cid:48)
Sign represents the security parameter
of the digital signature scheme used. Note that, H is also included
in αc. Therefore, any modiﬁcation to H consequently changes αc.
According to strategy (4), A may generate an aggregate signa-
ture that attributes m = hg|N|cl|vl to Pc, where N is the fresh
nonce sent by V. Since the current software of Pc is not in H, and
since N is a fresh nonce, the probability of Pc signing hg|N|cl|vl
is negligible in (cid:96)N . Consequently, as OAS is unforgeable accorf-
ing to Deﬁnition 3, the probability of ﬁnding such an aggregate is
negligible in (cid:96)Sign, where (cid:96)Sign represents OAS security parameter.
Finally, we consider A modifying the aggregate public key apk,
and replacing pkc with pkA, to which it knows the secret key skA.
A can at this point sign arbitrary messages (including attestation
responses) on behalf of Pc, regardless of Pc’s current software
conﬁguration. However, since the integrity of apk is protected
with a digital signature, the probability of success of this attack is
negligible in (cid:96)N and (cid:96)(cid:48)
Consequently, the probability of A making V return r = 1, when
it has maliciously modiﬁed the software of one prover Pc in G

Sign, where (cid:96)(cid:48)

Sign.

741Sign.

(that it did not physically attacked), is negligible in (cid:96)N , (cid:96)Sign, and
(cid:96)(cid:48)
Sign. Similarly, if none of the provers is physically attacked, the
probability of A making V return r = 1, when at least one device
has a malicious software is negligible in (cid:96)N , (cid:96)Sign, and (cid:96)(cid:48)
B. CORRECTNESS AND SECURITY OAS
Correctness.
If sk = x and all parties behave honestly, then
2 and apk = AggPK(S⊥ ∪ {pk}) =
we have that pk = gx
If m = M , then α = Sign(sk , m, M ) =
gx
2
(τ,B) = (H(M )x,∅) so that during veriﬁcation we have that
2 , and e(τ, g2) =
e(H(M )x, g2) = e(H(M ), apk M ) as required. If m (cid:54)= M , then
α = Sign(sk , m, M ) = (τ,B) = (H(m)x,{(m,{pk})} so that
during veriﬁcation we have that µ = 1, apk 1 = pk = gx
2 , apk M =
pk(cid:48)inS⊥ pk(cid:48)) = 1, and, since e(H(M ), 1) = 1, that
e(τ, g2) = e(H(m)x, g2) = e(H(m), apk1) as required.
works,
if
see
Verify(AggPK(Sj), S⊥,j, αj, M ) = Bj for j = 1, 2, by the
veriﬁcation equation (2) it holds that

(cid:81)
pk(cid:48)∈S⊥ pk(cid:48).
µ = 0, apk M = apk /(cid:81)
apk /(pk ·(cid:81)

pk(cid:48)∈S⊥ pk(cid:48) = gx

aggregation

that

To

e(cid:0)H(mi,j ), apk i,j

(cid:1) ,

pk for
Si,j. Multiplying the veriﬁca-

pk∈SM ,j

i=1

µj(cid:89)

(cid:1) ·

tion equations for j = 1, 2 gives

pk∈Si,j
(mi,j ,Si,j )∈Bj

pk and apk M ,j = (cid:81)

e(τj , g2) = e(cid:0)H(M ), apk M ,j
where apk i,j = (cid:81)
SM ,j = Sj \ S⊥,j \(cid:83)
e(τ1τ2, g2) = e(cid:0)H(M ), apk M ,1apk M ,2
(cid:1)
· µ1(cid:89)
(cid:1) · µ2(cid:89)
e(cid:0)H(mi,1), apk i,1
(cid:1) · (cid:89)
= e(cid:0)H(M ), apk M
pk, apk i = (cid:81)
where apk M = (cid:81)

(mi,Si)∈B

i=1

i=1

(cid:1)

e(cid:0)H(mi,2), apk i,2
e(cid:0)H(mi), apk i
(cid:1) .

pk∈SM ,1∪SM ,2

pk and
B = B1 (cid:116) B2. The second equality follows from the disjointness of
S1 and S2 and the deﬁnition of the merging operator (cid:116).
Security. We now prove the security of our OAS scheme based on
the computational co-Difﬁe-Hellman assumption, that is deﬁned as
follows.

pk∈Si

DEFINITION 5. We say that

the computational co-Difﬁe-
Hellman problem in (G1, G2) is hard if the probability that a
polynomial-time adversary A, on input g2, ga
2 , h where a ←R Zp
and h ←R G1, outputs ha is negligible.

THEOREM 2. If the computational co-Difﬁe-Hellman (co-CDH)
problem is hard in (G1, G2), then the above OAS scheme is unforge-
able in the random-oracle model.

PROOF. Given an adversary A against the unforgeability of the
OAS scheme as per Deﬁnition 3, we construct an adversary B that
solves the co-CDH problem in (G1, G2). Algorithm B gets as input
2 , h. It runs A on input pk = ga
2 , answering its oracle queries
g2, ga
as follows:
• Random-oracle queries H(m): Without loss of generality, we
assume that A never asks the same random-oracle query twice
and always queries H(m) before querying a signature on m
or using it as part of its forgery. B guesses one query index
q∗ ←R {1, . . . , qH}, where qH is (an upper bound on) the
number of random-oracle queries issued by A. B answers all
of A’s random-oracle queries other than the q∗th query so that
it can generate a valid signature by choosing r ←R Zp, storing
(m, r) and returning gr
1 as random-oracle response. For the
q∗th query, B stores (m,⊥) and returns h as response.

2

{pk 1, . . . , pk n}\S⊥\(cid:83)

r = ⊥ then B aborts. Otherwise, it returns ψ((ga
as the target signer’s signature for m.

• Signature queries Sign(sk , m): B looks up a tuple (m, r). If
2 )r) = gar
1
When A produces its output (α = (τ,B), S⊥, (pk 1, . . . , pk n),
(sk 1, . . . , sk n)), it checks that pk i = gsk i
for all i = 1, . . . , n
such that pk i (cid:54)= pk, and runs apk ← AggPK({pk 1, . . . , pk n}). It
veriﬁes the signature as B ← Verify(apk , S⊥, α, M ). Let SM =
(mi,Si)∈B Si. For A to be successful in its
attack, it must hold that S⊥ ⊆ S and Si ⊆ S for all (mi, Si) ∈ B,
and hence by consequence that SM ⊆ S. Also, there must either
exist (m∗, S∗) ∈ B such that pk ∈ S∗ and m∗ was never queried
from the Sign oracle, or it must hold that pk ∈ SM and A never
queried M from the Sign oracle. In the ﬁrst case, with probability
1/qH, m∗ was A’s q∗th random-oracle query. If not, B aborts;
otherwise, B knows the discrete logarithms rM of H(M ) and ri
of H(mi) for mi (cid:54)= m∗. It can compute a solution to the co-CDH
problem as follows. From the veriﬁcation equation, we know that

e(τ, g2) = e(cid:0)H(M ), apk M
= e(cid:0)ψ(apk M )rM , g2
· e(cid:0) (cid:89)
ψ(apk M )rM · (cid:89)

pk i∈Si\{pk}

(cid:18)

τ·

One can therefore compute ha as

(cid:89)

(cid:1) · (cid:89)
(cid:1) · (cid:89)

(mi,Si)∈B

hsk i , g2

pk(cid:1)

pk∈Si

(cid:89)
e(cid:0)H(mi),
e(cid:0) (cid:89)
(cid:1).

pk∈Si

(cid:1)

ψ(pk )ri , g2

(mi , Si ) ∈ B
mi (cid:54)= m∗

(cid:1) · e(cid:0)ha, g2
ψ(pk )ri· (cid:89)

(cid:19)−1

.

hsk i

(mi , Si ) ∈ B
mi (cid:54)= m∗

pk∈Si

pk i∈Si\{pk}

In the second case that m∗ = M , again with probability 1/qH we
have that M was A’s q∗th random-oracle query. If so, then B knows
all discrete logarithms ri of H(mi), so that the veriﬁcation equation
becomes

e(τ, g2) = e(cid:0) (cid:89)
· (cid:89)

pk i∈SM

hsk i , g2

e(cid:0) (cid:89)

(mi,Si)∈B

pk∈Si

(cid:1) · e(cid:0)ha, g2)

ψ(pk )ri , g2

(cid:1).
(cid:19)−1

B can compute ha as

pk i∈SM

τ ·

(cid:18) (cid:89)
 (cid:89)

pk j∈S∗\{pk}

ω ←

hsk i · (cid:89)
(cid:89)

H(m∗)

(mi,Si)∈B

(cid:89)

pk∈Si

(cid:89)

(mi,Si)∈B

pk j∈Si

ψ(pk )ri

.

H(mi)sk j · (cid:89)

i : pk i = pk
∧mi (cid:54)= mi∗



(ga

2 )ri

σ ← τ /ω

Note that, for this reduction to work, we really rely on the fact that
S⊥ and Si are all subsets of S, because otherwise B does not know
the necessary secret keys.

742