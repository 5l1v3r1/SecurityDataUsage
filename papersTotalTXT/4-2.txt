Hey, You, Get Oﬀ of My Clipboard -

On How Usability Trumps Security in Android Password Managers

Sascha Fahl, Marian Harbach, Marten Oltrogge, Thomas Muders, and

Matthew Smith

Distributed Computing & Security Group

Leibniz University of Hannover

Hannover, Germany

lastname@dcsec.uni-hannover.de

Abstract. Password managers aim to help users manage their ever in-
creasing number of passwords for online authentication. Since users only
have to memorise one master secret to unlock an encrypted password
database or key chain storing all their (hopefully) diﬀerent and strong
passwords, password managers are intended to increase username/pass-
word security. With mobile Internet usage on the rise, password managers
have found their way onto smartphones and tablets. In this paper, we
analyse the security of password managers on Android devices. While en-
cryption mechanisms are used to protect credentials, we will show that
a usability feature of the investigated mobile password managers puts
the users’ usernames and passwords at risk. We demonstrate the conse-
quences of our ﬁndings by analysing 21 popular free and paid password
managers for Android. We then make recommendations how to over-
come the current problems and provide an implementation of a secure
and usable mobile password manager.

Keywords: Android, Security, Apps, Password Managers, Vulnerability

1

Introduction

Today, using text-based passwords is the most prominent authentication scheme
in computer systems. Although researchers have been criticising this scheme as
being hard to use in a secure way, it is still the most widely adopted system
for authenticating users. Previous research has shown that passwords chosen by
users are often easy to compromise by attackers [1,2,3,7,10].

Another problem with the wide-spread application of passwords is password
re-use. Users register with many services on the Internet, each requiring them to
create a new username/password tuple. Previous research has shown that users
often deal with this password overload by re-using the same or similar passwords
for multiple accounts [8,13].

Multiple mechanisms have been proposed to support the user in choos-
ing more secure passwords (cf. [12,14]), all trying to alleviate the challenges
password-based authentication holds for their users.

However, due to the bounded cognitive abilities and motivation of users, pass-
word re-use is still commonplace. Password managers (PMs) aim to overcome
this problem: they help the user to handle a large number of diﬀerent passwords
by storing them in encrypted form. To access the encrypted passwords, the user
usually has to enter a single master secret that decrypts the password database.
Password managers often include a password generator to simplify the creation of
new unique and secure passwords. For convenience, login forms are pre-ﬁlled and
account information for new websites is captured on the ﬂy. Another prominent
feature is the synchronisation of password databases between multiple devices.
While early password manager applications were limited to desktop comput-
ers and their browsers [11], current implementations oﬀer mobile password man-
ager apps, that can be synchronised over the cloud to ensure that the password
database is available on all of the users’ devices. While users of desktop password
managers beneﬁt from a smooth integration into browsers, password manager
apps on mobile platforms oﬀer less comfort. First, web browsers on smartphones
and tablets often do not provide a plugin interface, that would allow for a smooth
integration of password managers. Second, the existence of dedicated apps for
many online services steadily increases the number of users that access online
services through an app instead of a website in a general-purpose web browser.
This circumstance requires that mobile password managers have to be able to
manage passwords not only for browsers but also for apps.

Unfortunately, there is a fundamental problem with password manager apps
on Android: The OS does not oﬀer an API to integrate password managers with
the browser or other apps. This has led to the adoption of a highly insecure
practice to overcome this weakness: Password managers use the OS clipboard
to transfer credentials from a password manager app to the browser or other
apps. This method eﬀectively broadcasts credentials to all apps installed on the
smartphone.

We analysed the security of 21 password manager apps on Android, hav-
ing a combined install base of 2,500,000 to 10,900,000 devices1. We found that
apps mostly use AES, Blowﬁsh or a combination of both to encrypt credential
databases, although some apps use their own crypto implementations and do
not rely on a proven open-source library. Seven apps use a key derivation func-
tion to derive the symmetric encryption key from the user’s master secret to
strengthen the security of encrypted credentials. We found one PM that directly
inputs the user’s password as the encryption key and truncates passwords longer
than 16 characters. In case the password has less than 16 characters, the string
‘FEDCBA9876543210” is appended to “strengthen” the password. Another PM
app uses an HMAC algorithm with SHA-256 and the ﬁxed initialisation vec-
tor ”notverysecretiv” for key derivation for every encrypted credential tuple.
Three password manager apps provide their own cloud synchronisation feature
to easily share passwords between multiple devices. Two of them synchronise
the users’ databases over a broken TLS channel (i. e. the apps are vulnerable

1 The numbers are based on information provided by Google’s Play Market. Google

does not provide more ﬁne-grained numbers for an app’s install base.

due to incomplete TLS certiﬁcate validation) and hence allow a Man-In-The-
Middle attacker to capture the databases. We investigated this problem in [5]
in more detail and analysed 13,500 popular Android apps and found that many
app developers failed to apply TLS appropriately. However, most critically, all
apps use the clipboard feature to transfer credentials from the password man-
ager to browsers or other apps. Two apps automatically copy credentials to the
clipboard when the user clicks the URL for the given online account. Only one
app allows a user to disable the clipboard feature.

While there is known malware on desktop computers that threatens pass-
words copied to the computer’s clipboard2, this circumstance has not been in-
vestigated in detail yet. Hence, to the best knowledge of the authors, this paper
is the ﬁrst analysis of password managers’ security on mobile devices.

The remainder of the paper is organised as follows: Section 2 gives background
information on password managers and discusses peculiarities of password man-
agers on desktops and mobile devices. Section 3 describes our attack against
password managers on Android and illustrates how captured credentials can be
linked to online services and how stolen information can be transferred to the
attacker’s server without giving the user a chance to notice. Section 4 gives more
details on the security of the PMs we analysed. To understand why developers
added the clipboard features to their apps, Section 5 summarises open inter-
views with app developers. Section 6 discusses countermeasures and presents an
implementation of a secure and usable password manager that overcomes the
presented vulnerabilities. In Section 7, we conclude the paper and discuss future
work.

2 Background

While early password managers were simply a username/password database em-
bedded in desktop computers’ browsers, the features of modern password man-
agers are much more extensive and can be categorised as follows:

Browser-Embedded PM: Most web browsers, such as Google Chrome, Microsoft
Internet Explorer, Mozilla Firefox or Apple’s Safari, include an embedded pass-
word management feature. In case a user logs into a website for the ﬁrst time,
the PM inquires whether the login credentials should be saved to ease future
logins by automatically ﬁlling the username and password into the login form.
These embedded password managers traditionally store credentials locally on the
user’s computer, but are increasingly syncing them between multiple devices us-
ing proprietary Cloud services. Some browsers do not encrypt credentials stored
locally or require the user to set a master secret to enable encryption. For exam-
ple, Chrome uses the Google Account password to encrypt the synced password
database by default, but oﬀers to use a dedicated secret as an advanced feature.

2 e. g.: http://www.f-secure.com/v-descs/trojan_w32_qhost_je.shtml

Browser Plugins The majority of modern desktop web browsers provide an API
to extend their functionality by allowing the user to install third-party plugins
or extensions. Many password managers are hence available as browser plugins.
KeePass3, 1Password4 and Lastpass5 are prominent examples of plugin-based
password managers. They encrypt passwords and protect them with a master
secret. These third-party password managers often provide further functionality
and act as encrypted storage for more than just usernames and passwords: other
sensitive information such as credit card numbers, online banking information
or secret notes can be stored as well.

2.1 Password Managers on Desktops

Password managers on desktop computers are generally well integrated into the
users’ everyday Internet-facing software, such as browsers and email clients. Re-
gardless of whether an embedded password manager or a third-party plugin is
used, when the user accesses an online account for the ﬁrst time or creates a
new account, the password manager automatically comes into play and oﬀers
the user to securely store the new account information. The plugin APIs of
modern browsers oﬀer a very comfortable integration of password managers into
the users’ workﬂows. When a user visits a website that requires authentication,
a password manager typically auto-ﬁlls the username and password and might
even automatically submit the login form.

Early password managers for desktop computers (e. g. [11]) assumed a single
device environment. Nowadays users often work with multiple devices such as
desktops, notebooks, smartphones and tablet PCs, which makes it necessary to
synchronise password databases between multiple devices to have credentials
available whenever needed. For this reason, some password managers oﬀer to
sync databases between multiple devices by storing credentials in the Cloud or by
putting the database on USB drives. A popular way to sync password databases
is the Dropbox service. The encrypted password database is stored in the user’s
Dropbox account and can be accessed from all the user’s devices. 1Password for
example maintains an encrypted database for sensitive information and allows
users to store and share the database via their Dropbox account.

2.2 Password Managers on Mobile Devices

While password managers in desktop environments are well integrated into
browsers and users’ workﬂows, the situation for third-party password managers
on mobile platforms is diﬀerent. Neither of the major mobile platforms (Android,
iOS and Windows Mobile) nor mobile browsers provide a plugin API comparable
to desktop computers. Additionally, the paradigm shift away from the browser

3 cf.: http://keepass.info/
4 cf.: https://agilebits.com/onepassword
5 cf.: https://lastpass.com

as a generic tool to surf the Internet towards the „there is an app for everything”
approach makes integrating PMs into mobile ecosystems even harder.

API limitations and the requirement to support arbitrary apps creates a
diﬀerent usage pattern for mobile PMs. Instead of storing new account informa-
tion automatically and auto-ﬁlling authentication forms, the workﬂows of mobile
PMs typically consist of the following steps:

1. The user has to switch to the PM app,
2. then needs to ﬁnd the appropriate username/password tuple from a list of

stored credentials,

3. copies the password to the clipboard,
4. switches back to the app that requires authentication, and
5. ﬁnally pastes the password into the corresponding text ﬁeld before submit-

ting the login form.

6. In case the user does not remember the username for a given service, these

steps (except step 2) are repeated for the username as well.

Although this workﬂow’s usability is far from optimal, it is the best mobile
password managers can provide so far. To understand why users nevertheless
use password managers on mobile devices, we analysed 2,000 user reviews in
Google’s Play Market. To this end, we downloaded user reviews, manually ex-
tracted factors that motivate users to use PMs on their Android device and
identiﬁed the following reasons to be substantial:

Protection: Users feel that embedded PMs do not store the passwords in a way
they believe to be secure (e. g. some users were angry that Android’s stock
browser does not encrypt stored usernames and passwords).

Conﬁdentiality Users do not trust embedded PMs in keeping their data conﬁ-
dential (e. g. users were afraid that their credentials could be sent to Google).
Features: Embedded PMs are usually limited to usernames/passwords. Users

often want to store other conﬁdential data, such as banking information.

Availability: Embedded PMs are usually limited to a single browser. Since
many users need access to their information on multiple devices and browsers,
a vendor-independent PM is preferred.

After having outlined background information on password managers, the
next section presents our attack on PM apps on Android and illustrates its
consequences for the user.

3 Password Sniﬃng on Android

As illustrated in Section 2.2, the workﬂow of mobile password managers requires
the user to copy account credentials to the clipboard before switching to the tar-
get app and pasting them before actually logging in. There are some problems
with this practice: On Android, writing data to or reading data from the clip-
board does not require any permission. Therefore, every app currently running
on an Android device can read the items stored in the clipboard at any time.

To make matters worse for password managers, the Android SDK provides the
android.content.ClipboardManager.OnPrimaryClipChangedListener inter-
face, which deﬁnes a listener callback that is invoked each time the primary
item on the clipboard changes. This can be used by malicious apps to harvest
passwords as they are passed through the clipboard. As a proof of concept we
implemented a password sniﬀer named PWSniﬀ using this mechanism. PWSniﬀ
runs as a background service and does not require any Android permission to
work properly.

As long as no changes to the clipboard occur, the background service idles
and therefore does not consume any CPU cycles. Directly after a new item is
copied to the clipboard, the listener callback is invoked by Android and the idling
PWSniﬀ background service is notiﬁed and then reads the primary item. Next,
PWSniﬀ determines the app which is currently in the foreground. This informa-
tion can also be acquired without requesting any permission. We assume that
the foreground app at the time of copying is the app from which a user copied
data (cf. Section 2.2 step 1). In case this app is a known password manager, we
assume that the primary clipboard item is either a service URL, a username or
a password (cf. Section 2.2 step 3). Whether the app is a password manager can
be determined based on the app’s user ID, which is assigned at install time and
can be mapped to the a unique app market ID. The third step in our attack
is to wait for a foreground app switch by checking the current foreground app
in a loop and waiting until the user brings another app to the foreground. In
case we identiﬁed the primary clipboard item as possibly conﬁdential data (no
matter if it is a username or a password) copied from a password manager, the
new foreground app is assumed to be the destination of the credentials-copy-
operation (cf. Section 2.2 step 4). Hence, by exploiting features of the Android
SDK that require no special permissions in combination with a typical workﬂow
in the context of using password manager apps on Android, it is easily possi-
ble to harvest (still potentially noisy) usernames and passwords from the world
readable clipboard.

At this point, an attacker cannot be sure which item is the username and
which the password. But, in many cases it is possible to diﬀerentiate between
both items based on their structure. Usernames are often chosen to be easily
memorable (e. g. an email address) while passwords, especially those which are
managed with PM software, usually are more “cryptic”. Even in cases where the
username and password cannot be easily distinguished, an attacker could ﬁrst
try one combination of the sniﬀed items and in a second attempt the reversed
order. In both cases, breaking into an account is straightforward.

Advanced Username Capture: The attack described above relies on the user copy-
ing and pasting both the username and the password. Since users might just type
their usernames from memory or use browser or app autoﬁll features to save this
eﬀort, it might become necessary to acquire the username through an alternative
method. For this, PWSniﬀ can be equipped with the GET_ACCOUNTS per-
mission. The permission allows the app to see usernames that other apps handle

on the smartphone and which are registered with the AccountManager 6. This
also includes all email addresses used on the device. Since many online services
use email addresses as usernames, this list oﬀers a good basis from which to
guess usernames for many services.

The downside of this extension is that it involves the danger of a user be-
coming suspicious of the app’s permissions, which are presented to the user at
install time. However, Felt et al. [6] demonstrated that users pay little attention
to the permissions of an app and mostly do not understand the permissions’
meaning. While Felt et al’s. results account for Android’s permission system in
general, an app’s permissions are also grouped and classiﬁed based on their secu-
rity relevance. In this respect, the GET_ACCOUNTS permission does not rank
particularly high and thus is not often shown on the ﬁrst page. To ensure that
the GET_ACCOUNTS permission is not shown on the ﬁrst page, an attacker
only needs to add more than three popular permissions such as INTERNET,
LOCATION and STORAGE which are used by many apps to his malware app.
The best composition of permissions to mask the GET_ACCOUNTS permission
is outside the scope of this work.

Advanced Account Capture: In Section 3, we illustrated that an Android app
which holds no special permissions is able to sniﬀ online account credentials
that are copied to the clipboard when working with any password manager on
Android in most cases. It is also possible to learn from which app a value was
copied to the clipboard and into which app the value was pasted. If the target
app has a special purpose (e. g. the Skype app only logs into Skype), it is easy to
guess to which online service the harvested credentials belong. However, in case
the target app is a multi-purpose Internet client such as a web browser, ﬁnding
the intended service is not quite as straightforward.

To learn for which account a password is used, an attacker can beneﬁt from
Android’s ProcFS features. The ProcFS is an interface to the kernel and pro-
vides information about a device such as information about the CPU, memory
and network details. On Linux-based systems such as Android, the ProcFS is
usually mounted at /proc. Most entries in /proc and its subdirectories can be
read by everyone. The /proc/net/tcp ﬁle contains information about all TCP
connections on an Android device and is also world-readable and hence accessi-
ble by every app without requiring any permissions. Information such as source
IP and port, destination IP and port and the UID of the process that created
the network connection are listed there. Since Android creates a static mapping
of Apps to a UID at install time, one can easily learn which app connects to
which Internet hosts based on the UID entry in /proc/net/tcp. Having the
destination IP for an app’s network connection at hand allows an attacker to
easily infer to which online service a credential pair is connected by logging all
network connections of an app, immediately after a copy operation from a PM
to another app was discovered.

6 cf.: http://developer.android.com/reference/android/accounts/AccountManager.html

In [5], we found that 92.8 % of 13,500 popular An-
Exﬁltrating the Data:
droid apps request Internet access. Adding the Internet permission to PWS-
niﬀ should thus not raise undue concern. With this permission, transmitting
the harvested data is of course trivial. However, if a zero permission attack
app is desired, exﬁltration of the harvested data can still be done using an-
other ﬂaw in Android’s permission system. Egners et al. [4] describe a loophole
in Android’s permission system that we adopt for our purposes and which al-
lows PWSniﬀ to send gathered credential information to a remote HTTP server
without requiring the Internet permission. After the account login information
was gathered, the harvested data is cached until the device’s display is turned
oﬀ. When this happens, an HTTP URL with the following structure is built:
http://<pwsniff-master>/pw#username#service. This URL is used to invis-
ibly open Android’s stock browser when the display is turned oﬀ by running
the following code in PWSniﬀ. We explicitly call Android’s stock browser since
some third-party browsers do not hand back control for unknown protocols to
the Android OS, which is required to keep the attack stealthy.

The server behind the URL replies with a location header containing a custom
protocol, for example: ’Location:pwsniff://all.ok’. Since PWSniﬀ includes
an activity that previously registered for the custom pwsniff:// protocol, the
browser passes handling for the URI pwsniff://all.ok to PWSniﬀ. Staying
invisible, the activity then simply terminates.

After demonstrating how credentials can be sniﬀed when Android password
managers are used, how they can be mapped to online accounts and how this
information can be exﬁltrated stealthily, the next section gives some relevant
excerpts of our detailed security analysis of PMs on Android.

4 Security in Detail

We analysed 13 free and 8 paid Android PM apps in detail. Our intention was
to analyse which apps include the clipboard feature for credential copy & paste,
which encryption algorithms protect the password database, whether or not the
app includes an embedded browser, whether or not the SD card is used to store
the password database and whether or not the app removes itself from the recent
apps view. For analysis, we installed all apps on a Samsung Galaxy Nexus with
Android 4.0. We applied forensic techniques7 to learn database and conﬁguration
ﬁles’ structures of the installed password manager apps. To learn internals of the
password managers, we decompiled them8 and conducted manual static code
analysis.

7 We used the adb tool (cf.: http://developer.android.com/tools/help/adb.html) for

tools:
apktool
dex2jar

JD-GUI
(cf.:
(cf.:

logical extraction.

used

a

8 We
(cf.:
http://code.google.com/p/android-apktool/)
http://code.google.com/p/android-apktool/)

bundle

http://java.decompiler.free.fr/?q=jdgui),

of

decompilation

and

We also conducted static code analysis on the same dataset as in [5] and found
that only two apps in this dataset registered for the clipboard change listener.
We analysed both apps manually and found no malicious behaviour in the apps.
907 apps (6.7 %) in the sample access the clipboard API programatically to
share more complex objects than simple text strings such as images, video or
audioﬁles.

Table 1 in the Appendix shows an overview of the security parameters we

analysed.

4.1 Encryption

One important aspect of PM security is the encryption mechanism to store cre-
dential databases. Android’s stock browser does not encrypt stored passwords in
any way but protects them from unauthorised access by ﬁle system permissions.
Android’s AccountManager mechanism provides centralised credential storage
and also protects user credentials from unauthorised access by ﬁle system per-
missions, but the accounts.db database is not protected with an extra layer of
encryption. This does not protect the password from forensic analysis.

All third party PMs we analysed apply some encryption mechanism to protect
the data. Android supports (3)DES, RC2, and RC59 to encrypt data out of
the box. Other encryption algorithms require the developer to add third-party
libraries to their app. We decompiled the PMs to ﬁnd out what kind of encryption
algorithm is applied in each PM app. To provide stronger security, most password
managing apps use the Advanced Encryption Standard (AES) with several key
lengths. aWallet uses a combination of AES, Blowﬁsh and 3DES.

A critical aspect of encrypting password databases is the derivation of the
encryption key [9] that is directly connected to the master secret used to un-
lock/decrypt the password database. Seven apps use a dedicated key derivation
function to derive the symmetric encryption key from the user’s master secret
to strengthen the security of encrypted credentials. We found one app that di-
rectly inputs the user’s password as the encryption key, truncating passwords
longer than 16 characters. In case the password has less than 16 characters, the
string ”FEDCBA9876543210” is appended to ”strengthen” the password. Another
app uses an HMAC algorithm with SHA-256 and the ﬁxed initialization vector
”notverysecretiv” for key derivation.

4.2 Storage

Most password managers, including Android’s stock browser, store password
databases in ﬁles or SQLite databases that are only accessible by the password
manager app itself. Hence, other Android apps cannot access account infor-
mation regardless of whether it is encrypted or not. Ten of the analysed PMs

9 cf.:

summary.html

http://developer.android.com/reference/javax/crypto/spec/package-

store databases on the SD card that is world readable without requiring fur-
ther permissions on all devices with Android 4.0 and older. In combination with
inappropriate database structures (not encrypting all information stored in the
password manager), an attacker is for instance able to learn for which services a
user holds accounts or for which services the same username and/or passwords
are used.

4.3 Recent Apps
An essential feature of Android devices is an overview of the currently running
apps, also called the Recent Apps View. The Recent Apps View shows thumbnails
of current foreground activities of all running apps. While a security feature
of all analysed password managers is the automatic locking of the password
database either immediately after the password manager app was left or after
a conﬁgurable amount of time, we found only three apps that also replace their
thumbnails in the recent apps view (cf. Table 1). In case the user copied online
account information (usually the location, username and password) and then
leaves the password manager app to paste the information into another app, the
account information is left in the recent apps view and can be seen by anyone
with physical access to the user’s device. Although this threat is orthogonal to
our attack (cf. Section 3), it outlines a security risk for users’ online credentials.

4.4 Cloud Sync
While all password managers store their databases locally and allow synchroni-
sation of their databases, most oﬀer a more manual functionality using Dropbox
or similar services. LastPass, SecureSafe and RoboForm provide dedicated Cloud
storage features to automatically synchronise all passwords remotely. In [5] we
analysed popular Android apps and found that many app developers fail to ap-
ply TLS appropriately, being vulnerable to active Man-In-The-Middle attacks.
Although LastPass, SecureSafe and RoboForm protect their network communi-
cation with TLS, SecureSafe and RoboForm fail to verify the cloud servers’ TLS
certiﬁcates. Instead, they accept all certiﬁcates. In case of SecureSafe this how-
ever has not further security implications since in addition to TLS, SecureSafe
uses a session-speciﬁc symmetric key, which is set up during the SRP-login10, to
additionally encrypt password-data end-to-end. However, RoboForm leaks the
users’ credentials which are used for password encryption in the default case (i. e.
the user did not choose an extra password for encryption). Hence, an attacker
can gain access to the data in cleartext under this circumstances.

5 The Developers View

After analysing Android password managers on a technical basis, we contacted
their developers via email and informed them about a possible security threat
10 cf. RFC2945

for their users. We oﬀered them to get in contact either via email or telephone to
discuss the details of the PWSniﬀ attack. We also posed the following questions:

– Why was the C&P feature used in the password manager app?
– Were developers aware of the security threats arising from using the clip-
board for username/password sharing, and, if so, why did they add the C&P
feature nonetheless?

– Which features, if any, do developers miss in Android’s SDK for developing

a password manager app?

15 of the 21 developers agreed to participate in the email interview and are

anonymously referred to as P1, . . . , P15 in the following.

5.1 Results
During the discussions with developers, we were able to identify three diﬀerent
reasons to add the usability-enhancing clipboard feature to PM apps. One was
because the developers themselves were users of their apps and desired the fea-
ture themselves. (“As I’m a [. . . ] program user too, I added the copy feature
because I needed to transfer usernames (that are usually long email addresses)
and passwords to login forms in web browsers.”; P7). The second reason provided
by PM developers was the wish to come as close as possible to PM functionality
on the desktop, because developers believed that users would reject their apps
if they were not suﬃciently usable. (“Copy to clipboard has been in [. . . ] An-
droid from early on. [. . . ] It was something that we knew we needed to make the
application usable at all”; P4). Lastly, developers reported that users directly
requested a C&P feature for their app (“The feature was highly requested by
users. The most common example: users want to login to a website on their
mobile device, so he/she copies credentials from [our PM] to the clipboard and
then pastes them into the browser.”; P15).

All but one developer were aware of security threats resulting from putting
passwords into a device’s clipboard. Developers who were aware of the security
threat justiﬁed adding the clipboard integration, stating that they had no other
choice. They described it as a tradeoﬀ between usability and security which was
decided in favour of increasing usability (“It’s a balance between ease of use
and security. Of course it would be much more secure to not use the clipboard,
however people accept the risk of doing so; the alternative of not using a password
manager is worse.”; P3). One developer interestingly described his decision not
as a usability-security tradeoﬀ but as a “one type of security versus another type
of security” decision, alluding to the fact that without password managers users
would choose less secure passwords. Additionally, P4 stated: “On the whole,
I think that password reuse [. . . ] is currently the biggest single problem with
password security today. And so, if a password manager gets people to use unique
passwords for each site, the dangers of a publicly readable clipboard is a security
risk that can be worthwhile. [. . . ] What’s the alternative?”.

All developers criticised Android’s missing support for password manager
apps. A native integration into third party apps and browsers was described as

the most eﬀective countermeasure against the password sniﬃng security threat
(“Android doesn’t oﬀer hooks into the native default browser [. . . ] and does not
allow our app to access input ﬁelds of other apps [. . . ] which makes it necessary
that password managers make heavy use of the clipboard.”; P3).

5.2 Discussion

Based on the lack of API support for third-party password managers on the
Android OS, developers decided to opt for the best usability they could achieve
by including the clipboard feature to allow users to copy-and-paste usernames
and passwords from their apps to other apps. Although all but one developer
were aware of the possible security threat, they decided that better usability
was more important than stronger security. A justiﬁcation multiple developers
oﬀered was that they had no other choice and that it was necessary to add the
best possible usability even if security was threatened.

6 Countermeasures

With the results of our analysis and the developers’ comments in mind, we
ﬁrst discuss possible countermeasures to improve the security of a smartphone’s
clipboard facilities as a global shared memory. Additionally, we present a PM
implementation for Android based on a customised soft-keyboard that provides
usability features similar to desktop PMs and does not leak credentials over
public channels.

Secure Clipboard Architecture: Sniﬃng conﬁdential information on Android de-
vices is currently easy since on the one hand, a proper plugin API for integrating
password managers is missing and, on the other hand, the design of the current
clipboard mechanism on Android is not made for sharing conﬁdential information
between apps. The current clipboard model allows an arbitrary app to access
clipboard items deposited by any other app. With the assumption that both,
the copy as well as the paste operation are triggered by the user, such a clip-
board model does not cause security concerns. However, on Android, two other
API features open the door for malicious activity: Android’s background service
feature for apps and the ClipboardManager.OnPrimaryClipChangedListener
allow for stealthy harvesting of clipboard items (cf. Section 3). Therefore, we
present two possible modiﬁcations to improve Android’s clipboard model when
it is accessed using API functionalities:

Permissions The current clipboard model allows every app to programmat-
ically read data from and write data to the clipboard, without requiring
permission for that. While user-triggered clipboard operations can remain
unchanged, we propose two new permissions for API-based access to clip-
board functionality: WRITE_TO_CLIPBOARD and READ_FROM_CLIPBOARD. Al-
though the limited eﬀects of Android’s permission model for the average

app user have been discussed (cf. Felt et al. [6]), these permissions should be
added for completeness. This way, at least the tech-savvy users would have
a chance to see if an app is capable of accessing the clipboard programmati-
cally and can warn the rest of the community. Since we identiﬁed only very
few apps to access the clipboard programatically (cf. Section 4), the proposed
changes would only impact a small number of apps. Regular, user-triggered
copy-and-paste operations would not be inﬂuenced by this modiﬁcation.

Targeted Clipboard Copying a value to the clipboard on current Android
smartphones is equivalent to broadcasting the information to all other apps.
This is contrary to the users’ intuition of using a copy-and-paste feature that
is generally used to transfer information from one app to another. Therefore
we propose to extend API calls to the clipboard with a “target app” param-
eter that the app may request from the user. Keeping usability in mind, the
number of target apps should be kept to a minimum. Apps providing an
API-based copy feature may let the user choose target apps from a list of
all apps or suggest useful targets as well as remember previous preferences.
If clipboard operations are triggered by the user, reading the clipboard’s
contents should only be possible through explicit user interaction as well.

The modiﬁcations to Android’s current clipboard model proposed above do
not only protect credentials from unwanted disclosure, but can also serve to
shield any other (possibly conﬁdential) information (such as ﬁnancial or medical
information), that a user might copy to the clipboard.

USecPassBoard: While the above solutions would alleviate the current security
problems of PMs, they would also require modiﬁcation of the Android OS itself.
Additionally, these measures cannot address the usability issues of mobile PMs,
i. e. that the user needs to manually select credentials, switch apps and manually
paste. To oﬀer both better security and usability we propose a novel password
manager: USecPassBoard. To overcome the issues plaguing the traditional ap-
proach of mobile password managers, we went down a diﬀerent path. We created
a soft-keyboard which integrates a password manager. Since soft-keyboards are
available in every app and can access a shared credential database, they integrate
well with most scenarios where credentials need to be entered. A custom soft-
keyboard implementation on Android replaces the default keyboard and provides
a custom means to input data into user-input ﬁelds. Figure 1 in the Appendix
shows the user interface of the USecPassBoard PM. Besides preserving the reg-
ular keyboard functionality, it essentially adds two operations: (1) Creating a
new username/password entry and (2) inserting a username/password tuple at
the user’s discretion. Since USecPassBoard is a soft-keyboard, it is available in
every application, including the browser and stores passwords in a master secret-
protected AES-256 encrypted database11 to protect username/password tuples
from unauthorized access. This eﬀectively avoids the use of copy-and-paste on
usernames and passwords while maintaining the ﬂexibility of all available pass-
word managers.
11 We use the SQLCipher (cf.: http://sqlcipher.net/sqlcipher-for-android/) database.

New Account: USecPassBoard analyses the context of user input to determine if
credentials are being entered. The password context is determined by identifying
which app is currently used (i. e. which app is in the foreground) and in case
the foreground app is a browser, it determines the website which is displayed by
reading the browser’s ﬁrst item cached in the history. Apps are uniquely identiﬁed
based on their package names managed by the Android operating system12.
USecPassBoard then caches the input of all textﬁelds in the foreground activity.
This is possible since soft-keyboards on Android are triggered when a textﬁeld
is activated by the user. Additionally, a soft-keyboard receives a reference of the
EditorInfo class13 which identiﬁes an input as a text or a password ﬁeld. After
the user completes the input and the keyboard loses the focus on a password
ﬁeld, a notiﬁcation is displayed in the status bar that a new dataset was created
(cf. Figure 1) if there is no identical username/password tuple for the current
context in the database. New username/password tuples are bound to the target
app – based on its package name – and are not available for possibly malicious
apps. In case the user would like to share credentials between diﬀerent apps
(e. g. between two Facebook client apps), we allow this in the settings menu of
USecPassBoard.

Credential Insertion: In case USecPassBoard recognises a known password con-
text (i. e. a package name of an app for which credentials are stored in the
database), the user can choose to insert this information by tapping into the in-
put ﬁeld for the username or password. A popup message appears after the user
tapped onto the key button (cf. Figure 1) and a list of available credentials for
the given password context is displayed. Subsequently the selected username/-
password tuple is inserted at the user’s discretion and the login process can be
started.

Security Considerations: All interactions between the USecPassBoard virtual
keyboard and a target app must be initiated by the user by tapping into a text
input ﬁeld. This creates a communication channel between the keyboard and the
target app through Android’s InputMethodManager14 which is not accessible
from other third party apps. This allows the automatic storage of new account
credentials and insertion of stored credentials into uniquely identiﬁable target
apps.

Target apps are uniquely identiﬁed based on their package name that is
managed by the Android OS and cannot be spoofed by malicious apps15. In
case the target app is the browser, a password context consists of the browser’s
package name and a target website. We identify the target website by read-
ing the top item from the browser’s history. This is accessible with Android’s
READ_HISTORY_BOOKMARKS permission and gives us the currently viewed
website. Hence, we can avoid that users falsely insert credentials another website.
12 cf.: http://developer.android.com/guide/topics/manifest/manifest-element.html
13 cf.: https://developer.android.com/reference/android/view/inputmethod/EditorInfo.html
14 cf.: http://developer.android.com/reference/android/view/inputmethod/InputMethodManager.html
15 cf.: http://source.android.com/tech/security/

7 Conclusions

With the rise of mobile devices, mobile password manager apps could be an
integral security tool for smartphone and tablet PC users. Since Android based
devices lack APIs for the integration of password managers, current solutions rely
heavily on the clipboard to share credentials between the PM and other apps.
We analysed 21 popular password managers on Android which all are vulnerable
to credential sniﬃng because a device’s clipboard is a publicly available storage
that can be accessed from any app. We showed that, using additional context
information, malware is able to link the stolen credentials to the corresponding
online account in many cases. We interviewed developers of the analysed PM
apps and found that the majority of them were aware of possible security threats
but accepted the risk to provide better usability. Based on the analyses’ ﬁnd-
ings and developers’ feedback, we discuss modiﬁcations to Android’s clipboard
mechanism to increase security for sensitive information. Finally, we present a
soft-keyboard that integrates a secure and easy-to-use password manager which
prevents the leakage of usernames/passwords via the clipboard. This password
manager design is the ﬁrst to oﬀer both usability and security for Android-based
password managers.

Since, in addition to security, usability is crucial for a password manager,
in future work we plan to conduct multiple user studies for the USecPassBoard
password manager.

References

1. M. Bishop and D. V Klein.

Improving system security via proactive password

checking. Computers & Security, 14(3):233–249, 1995.

2. J. Bonneau. The Science of Guessing: Analyzing an Anonymized Corpus of 70
Million Passwords. Security and Privacy (SP), 2012 IEEE Symposium on, pages
538–552, 2012.

3. M. Dell’Amico, P. Michiardi, and Y. Roudier. Password Strength: An Empirical

Analysis. In INFOCOM, 2010 Proceedings IEEE, pages 1–9, 2010.

4. A. Egners, B. Marschollek, and U. Meyer. Messing with Android’s Permission
Model. In IEEE International Conference on Trust, Security and Privacy in Com-
puting and Communications, (IEEE TrustCom-12), May 2012.

5. S. Fahl, M. Harbach, T. Muders, L. Baumgärtner, B. Freisleben, and M. Smith.
Why eve and mallory love android: an analysis of android ssl (in)security. In Pro-
ceedings of the 2012 ACM conference on Computer and communications security,
CCS ’12, pages 50–61, New York, NY, USA, 2012. ACM.

6. A. P. Felt, E. Ha, S. Egelman, A. Haney, E. Chin, and D. Wagner. Android
permissions: user attention, comprehension, and behavior. In Proceedings of the
Eighth Symposium on Usable Privacy and Security, SOUPS ’12, pages 3:1–3:14,
New York, NY, USA, 2012. ACM.

7. D. Florencio and C. Herley. A large-scale study of web password habits. Proceedings

of the 16th international conference on World Wide Web, pages 657–666, 2007.

8. S. Gaw and E. W. Felten. Password management strategies for online accounts. In
Proceedings of the second symposium on Usable privacy and security, SOUPS ’06,
pages 44–55, New York, NY, USA, 2006. ACM.

9. B. Kaliski. PKCS #5: Password-Based cryptography speciﬁcation version 2.0. RFC

2898, Internet Engineering Task Force, Sept. 2000.

10. D. Malone and K. Maher. Investigating the distribution of password choices. In
Proceedings of the 21st international conference on World Wide Web, WWW ’12,
pages 301–310, New York, NY, USA, 2012. ACM.

11. B. Ross, C. Jackson, N. Miyake, D. Boneh, and J. C. Mitchell. Stronger password
authentication using browser extensions. In Proceedings of the 14th conference on
USENIX Security Symposium - Volume 14, SSYM’05, pages 2–2, Berkeley, CA,
USA, 2005. USENIX Association.

12. R. Shay, P. G. Kelley, S. Komanduri, M. L. Mazurek, B. Ur, T. Vidas, L. Bauer,
N. Christin, and L. F. Cranor. Correct horse battery staple: exploring the usability
of system-assigned passphrases. In Proceedings of the Eighth Symposium on Usable
Privacy and Security, SOUPS ’12, pages 7:1–7:20, New York, NY, USA, 2012.
ACM.

13. R. Shay, S. Komanduri, P. G. Kelley, P. G. Leon, M. L. Mazurek, L. Bauer,
N. Christin, and L. F. Cranor. Encountering stronger password requirements: user
attitudes and behaviors. In Proceedings of the Sixth Symposium on Usable Privacy
and Security, SOUPS ’10, pages 2:1–2:20, New York, NY, USA, 2010. ACM.

14. B. Ur, P. G. Kelley, S. Komanduri, J. Lee, M. Maass, M. L. Mazurek, T. Passaro,
R. Shay, T. Vidas, L. Bauer, N. Christin, and L. F. Cranor. How does your password
measure up? the eﬀect of strength meters on password creation. In Proceedings
of the 21st USENIX conference on Security symposium, Security’12, pages 5–5,
Berkeley, CA, USA, 2012. USENIX Association.

A Investigated Password Managers

KD

EM
AES
AES
AES1
AES
AES
AES
AES
AES
AES
AES2
AES
AES
◦4

Installs1
100-500k
100-500k
500k-1m
100-500k
100-500k
10-50k
100-500k
10-50k
100-500k
100-500k
10-50k
1-5m
100-500k

Table 1. Overview of
the analysed Android password manager apps.
(EM=Encryption Method, KD=Key Derivation, C&P=copy&paste functional-
ity, EB=Embedded Browser, SD=Writes database to SD card, RA=Removes
itself from the recent apps view)
Free
App
PassDroid
1Password
KeePassDroid
UPM
Pocket
NS Wallet
LastPass
PasswdSafe
OI Safe
aWallet
Moxier Wallet
Keeper
RoboForm
Paid
100-500k
mSecure
50-100k
Secret Safe
10-50k
SafeWallet
10-50k
SPB Wallet
eWallet
10-50k
Handy Safe Pro 10-50k
DataVault
Password Box

C&P EB SD RA
(cid:88) – Backup (cid:88)
SHA-256
PBKDF2 (cid:88) (cid:88) Always (cid:88)
(cid:88) – Always (cid:88)
SHA-256
(cid:88) – Backup (cid:88)
(cid:88) – Backup (cid:88)
(cid:88) –
(cid:88)
(cid:88) (cid:88)
–
(cid:88)
(cid:88) –
(cid:88) –
(cid:88)
(cid:88) – Backup (cid:88)
(cid:88) –
(cid:88)
(cid:88) (cid:88) Backup (cid:88)
(cid:88) (cid:88) Backup (cid:88)

SHA-256
SHA-256
SHA-1
◦4

PBE
PBE
–
◦4
–

1-5k
5-10k

(cid:88)
–
(cid:88)
(cid:88)

PBE

(cid:88)

Blowﬁsh SHA-256

(cid:88) –
–
SHA-2563 (cid:88) – Backup (cid:88)
AES3
(cid:88)
AES HmacSHA1 (cid:88) –
(cid:88)
(cid:88) –
AES
(cid:88) –
–
AES
(cid:88) –
(cid:88)
(cid:88) – Backup (cid:88)
(cid:88) –
(cid:88)

◦4
PBE

AES
AES

(cid:88)
(cid:88)
(cid:88)
–

Blowﬁsh

–
–
–

(cid:88)

–

1 KeePassDroid combines AES and Twoﬁsh
2 aWallet combines AES, Blowﬁsh and 3DES
3 Secret Safe combines AES and Twoﬁsh for encryption and multiple rounds

of SHA-256 and Whirlpool for key derivation.

4 This information could not be found by reverse engineering.

B USecPassBoard User Interface

(a) Asking the user to store new
credential tuple.

(b) Successfully stored new cre-
dential tuple.

(c) Selecting existing credential
tuple.

(d) Credentials ﬁlled in.

Fig. 1. The USecPassBoard workﬂow for storing new credential tuples and ﬁlling in
stored credentials.

