ARMageddon: Cache Attacks on Mobile Devices
Moritz Lipp, Daniel Gruss, Raphael Spreitzer, Clémentine Maurice, and Stefan Mangard, 

Graz University of Technology

 https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/lipp

This paper is included in the Proceedings of the 25th USENIX Security SymposiumAugust 10–12, 2016 • Austin, TXISBN 978-1-931971-32-4Open access to the Proceedings of the 25th USENIX Security Symposium is sponsored by USENIX ARMageddon: Cache Attacks on Mobile Devices

Moritz Lipp, Daniel Gruss, Raphael Spreitzer, Cl´ementine Maurice, and Stefan Mangard

Graz University of Technology, Austria

Abstract

In the last 10 years, cache attacks on Intel x86 CPUs have
gained increasing attention among the scientific com-
munity and powerful techniques to exploit cache side
channels have been developed. However, modern smart-
phones use one or more multi-core ARM CPUs that have
a different cache organization and instruction set than
Intel x86 CPUs. So far, no cross-core cache attacks have
been demonstrated on non-rooted Android smartphones.
In this work, we demonstrate how to solve key chal-
lenges to perform the most powerful cross-core cache at-
tacks Prime+Probe, Flush+Reload, Evict+Reload, and
Flush+Flush on non-rooted ARM-based devices without
any privileges. Based on our techniques, we demonstrate
covert channels that outperform state-of-the-art covert
channels on Android by several orders of magnitude.
Moreover, we present attacks to monitor tap and swipe
events as well as keystrokes, and even derive the lengths
of words entered on the touchscreen. Eventually, we are
the first to attack cryptographic primitives implemented
in Java. Our attacks work across CPUs and can even
monitor cache activity in the ARM TrustZone from the
normal world. The techniques we present can be used to
attack hundreds of millions of Android devices.

1

Introduction

Cache attacks represent a powerful means of exploit-
ing the different access times within the memory hi-
erarchy of modern system architectures. Until re-
cently,
these attacks explicitly targeted cryptographic
implementations, for instance, by means of cache tim-
ing attacks [9] or the well-known Evict+Time and
Prime+Probe techniques [43].
The seminal paper
by Yarom and Falkner [60] introduced the so-called
Flush+Reload attack, which allows an attacker to infer
which specific parts of a binary are accessed by a vic-
tim program with an unprecedented accuracy and prob-
ing frequency. Recently, Gruss et al. [19] demonstrated

the possibility to use Flush+Reload to automatically ex-
ploit cache-based side channels via cache template at-
tacks on Intel platforms. Flush+Reload does not only al-
low for efficient attacks against cryptographic implemen-
tations [8,26,56], but also to infer keystroke information
and even to build keyloggers on Intel platforms [19]. In
contrast to attacks on cryptographic algorithms, which
are typically triggered multiple times, these attacks re-
quire a significantly higher accuracy as an attacker has
only one single chance to observe a user input event.

Although a few publications about cache attacks on
AES T-table implementations on mobile devices ex-
ist [10, 50–52, 57], the more efficient cross-core attack
techniques Prime+Probe, Flush+Reload, Evict+Reload,
and Flush+Flush [18] have not been applied on smart-
phones. In fact, there was reasonable doubt [60] whether
these cross-core attacks can be mounted on ARM-based
devices at all. In this work, we demonstrate that these
attack techniques are applicable on ARM-based devices
by solving the following key challenges systematically:
1. Last-level caches are not inclusive on ARM and thus
cross-core attacks cannot rely on this property. In-
deed, existing cross-core attacks exploit the inclu-
siveness of shared last-level caches [18, 19, 22, 24,
35, 37, 38, 42, 60] and, thus, no cross-core attacks
have been demonstrated on ARM so far. We present
an approach that exploits coherence protocols and
L1-to-L2 transfers to make these attacks applicable
on mobile devices with non-inclusive shared last-
level caches, irrespective of the cache organization.1
2. Most modern smartphones have multiple CPUs that
do not share a cache. However, cache coherence
protocols allow CPUs to fetch cache lines from re-
mote cores faster than from the main memory. We
utilize this property to mount both cross-core and
cross-CPU attacks.

1Simultaneously to our work on ARM, Irazoqui et al. [25] devel-
oped a technique to exploit cache coherence protocols on AMD x86
CPUs and mounted the first cross-CPU cache attack.

USENIX Association  

25th USENIX Security Symposium  549

1

3. Except ARMv8-A CPUs, ARM processors do not
support a flush instruction.
In these cases, a fast
eviction strategy must be applied for high-frequency
measurements. As existing eviction strategies are
too slow, we analyze more than 4 200 eviction
strategies for our test devices, based on Rowham-
mer attack techniques [17].

4. ARM CPUs use a pseudo-random replacement pol-
icy to decide which cache line to replace within a
cache set. This introduces additional noise even for
robust time-driven cache attacks [50, 52]. For the
same reason, Prime+Probe has been an open chal-
lenge [51] on ARM, as an attacker needs to predict
which cache line will be replaced first and wrong
predictions destroy measurements. We design re-
access loops that interlock with a cache eviction
strategy to reduce the effect of wrong predictions.

5. Cycle-accurate timings require root access on
ARM [3] and alternatives have not been evaluated so
far. We evaluate different timing sources and show
that cache attacks can be mounted in any case.

Based on these building blocks, we demonstrate prac-
tical and highly efficient cache attacks on ARM.2 We
do not restrict our investigations to cryptographic im-
plementations but also consider cache attacks as a
means to infer other sensitive information—such as
inter-keystroke timings or the length of a swipe action—
requiring a significantly higher measurement accuracy.
Besides these generic attacks, we also demonstrate that
cache attacks can be used to monitor cache activity
caused within the ARM TrustZone from the normal
world. Nevertheless, we do not aim to exhaustively list
possible exploits or find new attack vectors on crypto-
graphic algorithms. Instead, we aim to demonstrate the
immense attack potential of the presented cross-core and
cross-CPU attacks on ARM-based mobile devices based
on well-studied attack vectors. Our work allows to ap-
ply existing attacks to millions of off-the-shelf Android
devices without any privileges. Furthermore, our investi-
gations show that Android still employs vulnerable AES
T-table implementations.

Contributions. The contributions of this work are:

• We demonstrate the applicability of highly efficient
cache attacks like Prime+Probe, Flush+Reload,
Evict+Reload, and Flush+Flush on ARM.

• Our attacks work irrespective of the actual cache or-
ganization and, thus, are the first last-level cache
attacks that can be applied cross-core and also
cross-CPU on off-the-shelf ARM-based devices.
More specifically, our attacks work against last-

2Source code for ARMageddon attack examples can be found at

https://github.com/IAIK/armageddon.

level caches that are instruction-inclusive and data-
non-inclusive as well as caches that are instruction-
non-inclusive and data-inclusive.

• Our cache-based covert channel outperforms all ex-
isting covert channels on Android by several orders
of magnitude.

• We demonstrate the power of

these attacks
by attacking cryptographic implementations and
by inferring more fine-grained information like
keystrokes and swipe actions on the touchscreen.

Outline. The remainder of this paper is structured as
follows. In Section 2, we provide information on back-
ground and related work. Section 3 describes the tech-
niques that are the building blocks for our attacks.
In
Section 4, we demonstrate and evaluate fast cross-core
and cross-CPU covert channels on Android.
In Sec-
tion 5, we demonstrate cache template attacks on user
input events. In Section 6, we present attacks on crypto-
graphic implementations used in practice as well the pos-
sibility to observe cache activity of cryptographic com-
putations within the TrustZone. We discuss countermea-
sures in Section 7 and conclude this work in Section 8.

2 Background and Related Work

In this section, we provide the required preliminaries and
discuss related work in the context of cache attacks.

2.1 CPU Caches
Today’s CPU performance is influenced not only by the
clock frequency but also by the latency of instructions,
operand fetches, and other interactions with internal and
external devices.
In order to overcome the latency of
system memory accesses, CPUs employ caches to buffer
frequently used data in small and fast internal memories.
Modern caches organize cache lines in multiple sets,
which is also known as set-associative caches. Each
memory address maps to one of these cache sets and ad-
dresses that map to the same cache set are considered
congruent. Congruent addresses compete for cache lines
within the same set and a predefined replacement policy
determines which cache line is replaced. For instance,
the last generations of Intel CPUs employ an undocu-
mented variant of least-recently used (LRU) replacement
policy [17]. ARM processors use a pseudo-LRU replace-
ment policy for the L1 cache and they support two dif-
ferent cache replacement policies for L2 caches, namely
round-robin and pseudo-random replacement policy. In
practice, however, only the pseudo-random replacement
policy is used due to performance reasons. Switching
the cache replacement policy is only possible in privi-

550  25th USENIX Security Symposium 

USENIX Association

2

leged mode. The implementation details for the pseudo-
random policy are not documented.

CPU caches can either be virtually indexed or phys-
ically indexed, which determines whether the index is
derived from the virtual or physical address. A so-called
tag uniquely identifies the address that is cached within
a specific cache line. Although this tag can also be based
on the virtual or physical address, most modern caches
use physical tags because they can be computed simul-
taneously while locating the cache set. ARM typically
uses physically indexed, physically tagged L2 caches.

CPUs have multiple cache levels, with the lower lev-
els being faster and smaller than the higher levels. ARM
processors typically have two levels of cache. If all cache
lines from lower levels are also stored in a higher-level
cache, the higher-level cache is called inclusive.
If a
cache line can only reside in one of the cache levels at
any point in time, the caches are called exclusive. If the
cache is neither inclusive nor exclusive, it is called non-
inclusive. The last-level cache is often shared among
all cores to enhance the performance upon transitioning
threads between cores and to simplify cross-core cache
lookups. However, with shared last-level caches, one
core can (intentionally) influence the cache content of all
other cores. This represents the basis for cache attacks
like Flush+Reload [60].

In order to keep caches of multiple CPU cores or CPUs
in a coherent state, so-called coherence protocols are em-
ployed. However, coherence protocols also introduce
exploitable timing effects, which has recently been ex-
ploited by Irazoqui et al. [25] on x86 CPUs.

In this paper, we demonstrate attacks on three smart-
phones as listed in Table 1. The Krait 400 is an ARMv7-
A CPU, the other two processors are ARMv8-A CPUs.
However, the stock Android of the Alcatel One Touch
Pop 2 is compiled for an ARMv7-A instruction set and
thus ARMv8-A instructions are not used. We generically
refer to ARMv7-A and ARMv8-A as “ARM architec-
ture” throughout this paper. All devices have a shared L2
cache. On the Samsung Galaxy S6, the flush instruction
is unlocked by default, which means that it is available
in userspace. Furthermore, all devices employ a cache
coherence protocol between cores and on the Samsung
Galaxy S6 even between the two CPUs [6].

2.2 Shared Memory
Read-only shared memory can be used as a means of
memory usage optimization. In case of shared libraries it
reduces the memory footprint and enhances the speed by
lowering cache contention. The operating system imple-
ments this behavior by mapping the same physical mem-
ory into the address space of each process. As this mem-
ory sharing mechanism is independent of how a file was

opened or accessed, an attacker can map a binary to have
read-only shared memory with a victim program. A sim-
ilar effect is caused by content-based page deduplication
where physical pages with identical content are merged.
Android applications are usually written in Java and,
thus, contain self-modifying code or just-in-time com-
piled code. This code would typically not be shared.
Since Android version 4.4 the Dalvik VM was gradu-
ally replaced by the Android Runtime (ART). With ART,
Java byte code is compiled to native code binaries [1] and
thus can be shared too.

2.3 Cache Attacks
Initially, cache timing attacks were performed on cryp-
tographic algorithms [9, 30, 31, 40, 41, 44, 55]. For ex-
ample, Bernstein [9] exploited the total execution time
of AES T-table implementations. More fine-grained
exploitations of memory accesses to the CPU cache
have been proposed by Percival [45] and Osvik et al.
[43]. More specifically, Osvik et al. formalized two con-
cepts, namely Evict+Time and Prime+Probe, to deter-
mine which specific cache sets were accessed by a victim
program. Both approaches consist of three basic steps.
Evict+Time:

1. Measure execution time of victim program.
2. Evict a specific cache set.
3. Measure execution time of victim program again.

Prime+Probe:

1. Occupy specific cache sets.
2. Victim program is scheduled.
3. Determine which cache sets are still occupied.
Both approaches allow an adversary to determine
which cache sets are used during the victim’s compu-
tations and have been exploited to attack cryptographic
implementations [24, 35, 43, 54] and to build cross-VM
covert channels [37]. Yarom and Falkner [60] proposed
Flush+Reload, a significantly more fine-grained attack
that exploits three fundamental concepts of modern sys-
tem architectures. First, the availability of shared mem-
ory between the victim process and the adversary. Sec-
ond, last-level caches are typically shared among all
cores. Third, Intel platforms use inclusive last-level
caches, meaning that the eviction of information from the
last-level cache leads to the eviction of this data from all
lower-level caches of other cores, which allows any pro-
gram to evict data from other programs on other cores.
While the basic idea of this attack has been proposed by
Gullasch et al. [21], Yarom and Falkner extended this
idea to shared last-level caches, allowing cross-core at-
tacks. Flush+Reload works as follows.
Flush+Reload:

1. Map binary (e.g., shared object) into address space.
2. Flush a cache line (code or data) from the cache.

USENIX Association  

25th USENIX Security Symposium  551

3

Device
OnePlus
One
Alcatel One
Touch Pop 2

SoC
Qualcomm
Snapdragon 801
Qualcomm
Snapdragon 410

Samsung
Galaxy S6

Samsung Exynos
7 Octa 7420

Table 1: Test devices used in this paper.

CPU (cores)
Krait 400 (2)
2.5 GHz
Cortex-A53 (4)
1.2 GHz
Cortex-A53 (4)
1.5 GHz
Cortex-A57 (4)
2.1 GHz

L1 caches
2× 16 KB,
4-way, 64 sets
4× 32 KB,
4-way, 128 sets
4× 32 KB,
4-way, 128 sets
4× 32 KB,
2-way, 256 sets

L2 cache
2 048 KB,
8-way, 2 048 sets
512 KB,
16-way, 512 sets
256 KB,
16-way, 256 sets
2 048 KB,
16-way, 2 048 sets

Inclusiveness
non-inclusive

instruction-inclusive,
data-non-inclusive
instruction-inclusive,
data-non-inclusive
instruction-non-inclusive,
data-inclusive

3. Schedule the victim program.
4. Check if the corresponding line from step 2 has

been loaded by the victim program.

Thereby, Flush+Reload allows an attacker to deter-
mine which specific instructions are executed and also
which specific data is accessed by the victim program.
Thus, rather fine-grained attacks are possible and have
already been demonstrated against cryptographic im-
plementations [22, 27, 28]. Furthermore, Gruss et al.
[19] demonstrated the possibility to automatically ex-
ploit cache-based side-channel
information based on
the Flush+Reload approach. Besides attacking crypto-
graphic implementations like AES T-table implementa-
tions, they showed how to infer keystroke information
and even how to build a keylogger by exploiting the
cache side channel. Similarly, Oren et al. [42] demon-
strated the possibility to exploit cache attacks on Intel
platforms from JavaScript and showed how to infer vis-
ited websites and how to track the user’s mouse activity.
Gruss et al. [19] proposed the Evict+Reload technique
that replaces the flush instruction in Flush+Reload by
eviction. While it has no practical application on x86
CPUs, we show that it can be used on ARM CPUs. Re-
cently, Flush+Flush [18] has been proposed. Unlike
other techniques, it does not perform any memory ac-
cess but relies on the timing of the flush instruction to
determine whether a line has been loaded by a victim.
We show that the execution time of the ARMv8-A flush
instruction also depends on whether or not data is cached
and, thus, can be used to implement this attack.

While the attacks discussed above have been proposed
and investigated for Intel processors, the same attacks
were considered not applicable to modern smartphones
due to differences in the instruction set, the cache or-
ganization [60], and in the multi-core and multi-CPU
architecture. Thus, only same-core cache attacks have
been demonstrated on smartphones so far. For instance,
Weiß et al. [57] investigated Bernstein’s cache-timing at-
tack [9] on a Beagleboard employing an ARM Cortex-
A8 processor. Later on, Weiß et al. [58] investigated this
timing attack in a multi-core setting on a development

board. As Weiß et al. [57] claimed that noise makes
the attack difficult, Spreitzer and Plos [52] investigated
the applicability of Bernstein’s cache-timing attack on
different ARM Cortex-A8 and ARM Cortex-A9 smart-
phones running Android. Both investigations [52, 57]
confirmed that timing information is leaking, but the at-
tack takes several hours due to the high number of mea-
surement samples that are required, i.e., about 230 AES
encryptions. Later on, Spreitzer and G´erard [50] im-
proved upon these results and managed to reduce the key
space to a complexity which is practically relevant.

Besides Bernstein’s attack, another attack against AES
T-table implementations has been proposed by Bog-
danov et al. [10], who exploited so-called wide collisions
on an ARM9 microprocessor. In addition, power analysis
attacks [13] and electromagnetic emanations [14] have
been used to visualize cache accesses during AES com-
putations on ARM microprocessors. Furthermore, Spre-
itzer and Plos [51] implemented Evict+Time [43] in or-
der to attack an AES T-table implementation on Android-
based smartphones. However, so far only cache attacks
against AES T-table implementations have been consid-
ered on smartphone platforms and none of the recent ad-
vances have been demonstrated on mobile devices.

3 ARMageddon Attack Techniques

We consider a scenario where an adversary attacks a
smartphone user by means of a malicious application.
This application does not require any permission and,
most importantly,
it can be executed in unprivileged
userspace and does not require a rooted device. As our
attack techniques do not exploit specific vulnerabilities
of Android versions, they work on stock Android ROMs
as well as customized ROMs in use today.

3.1 Defeating the Cache Organization
In this section, we tackle the aforementioned challenges
1 and 2, i.e., the last-level cache is not inclusive and mul-
tiple processors do not necessarily share a cache level.

552  25th USENIX Security Symposium 

USENIX Association

4

Core 0

Core 1

L1I

L1D

L1I

L1D

s
t
e
S

s
t
e
S

(

1

)

L2 Unified Cache

(

2

)

(3)

s
e
s
s
e
c
c
a

f
o

r
e
b
m
u
N

3

2

1

0

Hit (same core)
Miss (same core)

Hit (cross-core)
Miss (cross-core)

·104

0

200

400

600

800

1,000

Measured access time in CPU cycles

Figure 1: Cross-core instruction cache eviction through
data accesses.

When it comes to caches, ARM CPUs are very hetero-
geneous compared to Intel CPUs. For example, whether
or not a CPU has a second-level cache can be decided by
the manufacturer. Nevertheless, the last-level cache on
ARM devices is usually shared among all cores and it can
have different inclusiveness properties for instructions
and data. Due to cache coherence, shared memory is
kept in a coherent state across cores and CPUs. This is of
importance when measuring timing differences between
cache accesses and memory accesses (cache misses), as
fast remote-cache accesses are performed instead of slow
memory accesses [6]. In case of a non-coherent cache, a
cross-core attack is not possible but an attacker can run
the spy process on all cores simultaneously and thus fall
back to a same-core attack. However, we observed that
caches are coherent on all our test devices.

To perform a cross-core attack we load enough data
into the cache to fully evict the corresponding last-level
cache set. Thereby, we exploit that we can fill the last-
level cache directly or indirectly depending on the cache
organization. On the Alcatel One Touch Pop 2, the last-
level cache is instruction-inclusive and thus we can evict
instructions from the local caches of the other core. Fig-
ure 1 illustrates such an eviction. In step 1, an instruc-
tion is allocated to the last-level cache and the instruc-
tion cache of one core. In step 2, a process fills its core’s
data cache, thereby evicting cache lines into the last-level
cache. In step 3, the process has filled the last-level cache
set using only data accesses and thereby evicts the in-
structions from instruction caches of other cores as well.
We access cache lines multiple times to perform trans-
fers between L1 and L2 cache. Thus, more and more
addresses used for eviction are cached in either L1 or L2.
As ARM CPUs typically have L1 caches with a very low
associativity, the probability of eviction to L2 through
other system activity is high. Using an eviction strategy
that performs frequent transfers between L1 and L2 in-
creases this probability further. Thus, this approach also
works for other cache organizations to perform cross-
core and cross-CPU cache attacks. Due to the cache co-
herence protocol between the CPU cores [6,33], remote-
core fetches are faster than memory accesses and thus
can be distinguished from cache misses. For instance,

Figure 2: Histograms of cache hits and cache misses
measured same-core and cross-core on the OnePlus One.

Figure 2 shows the cache hit and miss histogram on the
OnePlus One. The cross-core access introduces a latency
of 40 CPU cycles on average. However, cache misses
take more than 500 CPU cycles on average. Thus, cache
hits and misses are clearly distinguishable based on a sin-
gle threshold value.

3.2 Fast Cache Eviction
In this section, we tackle the aforementioned challenges
3 and 4, i.e., not all ARM processors support a flush in-
struction, and the replacement policy is pseudo-random.
There are two options to evict cache lines: (1) the
flush instruction or (2) evict data with memory accesses
to congruent addresses, i.e., addresses that map to the
same cache set. As the flush instruction is only available
on the Samsung Galaxy S6, we need to rely on eviction
strategies for the other devices and, therefore, to defeat
the replacement policy. The L1 cache in Cortex-A53 and
Cortex-A57 has a very small number of ways and em-
ploys a least-recently used (LRU) replacement policy [5].
However, for a full cache eviction, we also have to evict
cache lines from the L2 cache, which uses a pseudo-
random replacement policy.

Eviction strategies. Previous approaches to evict data
on Intel x86 platforms either have too much over-
head [23] or are only applicable to caches implement-
ing an LRU replacement policy [35, 37, 42]. Spreitzer
and Plos [51] proposed an eviction strategy for ARMv7-
A CPUs that requires to access more addresses than
there are cache lines per cache set, due to the pseudo-
random replacement policy. Recently, Gruss et al. [17]
demonstrated how to automatically find fast eviction
strategies on Intel x86 architectures. We show that
their algorithm is applicable to ARM CPUs as well.
Thereby, we establish eviction strategies in an automated
way and significantly reduce the overhead compared to
[51]. We evaluated more than 4 200 access patterns on
our smartphones and identified the best eviction strate-
gies. Even though the cache employs a random replace-

USENIX Association  

25th USENIX Security Symposium  553

5

Table 2: Different eviction strategies on the Krait 400.

Table 3: Different eviction strategies on the Cortex-A53.

N
-
11
12
13
16
24
13
11
11
10

A D
-
-
2
2
3
1
5
1
1
1
1
1
2
1
1
3
1
4
2
2

Cycles
549
1 578
2 094
2 213
3 026
4 371
2 372
1 608
1 948
1 275

Eviction rate
100.00%
100.00%
100.00%
100.00%
100.00%
100.00%
99.58%
80.94%
58.93%
51.12%

ment policy, average eviction rate and average execu-
tion time are reproducible. Eviction sets are computed
based on physical addresses, which can be retrieved via
/proc/self/pagemap as current Android versions al-
low access to these mappings to any unprivileged app
without any permissions. Thus, eviction patterns and
eviction sets can be efficiently computed.

We applied the algorithm of Gruss et al. [17] to a set
of physically congruent addresses. Table 2 summarizes
different eviction strategies, i.e., loop parameters, for the
Krait 400. N denotes the total eviction set size (length of
the loop), A denotes the shift offset (loop increment) to
be applied after each round, and D denotes the number of
memory accesses in each iteration (loop body). The col-
umn cycles states the average execution time in CPU cy-
cles over 1 million evictions and the last column denotes
the average eviction rate. The first line in Table 2 shows
the average execution time and the average eviction rate
for the privileged flush instruction, which gives the best
result in terms of average execution time (549 CPU cy-
cles). We evaluated 1863 different strategies and our best
identified eviction strategy (N = 11, A = 2, D = 2) also
achieves an average eviction rate of 100% but takes 1578
CPU cycles. Although a strategy accessing every address
in the eviction set only once (A = 1, D = 1, also called
LRU eviction) performs significantly fewer memory ac-
cesses, it consumes more CPU cycles. For an average
eviction rate of 100%, LRU eviction requires an eviction
set size of at least 16. The average execution time then
is 3026 CPU cycles. Considering the eviction strategy
used in [51] that takes 4371 CPU cycles, clearly demon-
strates the advantage of our optimized eviction strategy
that takes only 1578 CPU cycles.

We performed the same evaluation with 2295 different
strategies on the ARM Cortex-A53 in our Alcatel One
Touch Pop 2 test system and summarize them in Table 3.
For the best strategy we found (N = 21, A = 1, D = 6), we
measured an average eviction rate of 99.93% and an av-
erage execution time of 4275 CPU cycles. We observed
that LRU eviction (A = 1, D = 1) on the ARM Cortex-

N
-
23
23
22
21
20
800
200
100
48

A D
-
-
2
5
6
4
6
1
6
1
6
4
1
1
1
1
1
1
1
1

Cycles
767
6 209
16 912
5 101
4 275
13 265
142 876
33 110
15 493
6 517

Eviction rate
100.00%
100.00%
100.00%
99.99%
99.93%
99.44%
99.10%
96.04%
89.77%
70.78%

Flush (address cached)

Flush (address not cached)

100

200

300

400

500

600

Measured execution time in CPU cycles

s
e
s
a
c

f
o

r
e
b
m
u
N

3 ·104

2

1

0

0

Figure 3: Histograms of the execution time of the flush
operation on cached and not cached addresses measured
on the Samsung Galaxy S6.

A53 would take 28 times more CPU cycles to achieve an
average eviction rate of only 99.10%, thus it is not suit-
able for attacks on the last-level cache as used in previous
work [51]. The reason for this is that data can only be al-
located to L2 cache by evicting it from the L1 cache on
the ARM Cortex-A53. Therefore, it is better to reaccess
the data that is already in the L2 cache and gradually add
new addresses to the set of cached addresses instead of
accessing more different addresses.

On the ARM Cortex-A57 the userspace flush in-
struction was significantly faster in any case. Thus,
for Flush+Reload we use the flush instruction and for
Prime+Probe the eviction strategy.
Falling back to
Evict+Reload is not necessary on the Cortex-A57. Sim-
ilarly to recent Intel x86 CPUs, the execution time of the
flush instruction on ARM depends on whether or not the
value is cached, as shown in Figure 3. The execution
time is higher if the address is cached and lower if the
address is not cached. This observation allows us to dis-
tinguish between cache hits and cache misses depending
on the timing behavior of the flush instruction, and there-
fore to perform a Flush+Flush attack. Thus, in case of
shared memory between the victim and the attacker, it is
not even required to evict and reload an address in order
to exploit the cache side channel.

554  25th USENIX Security Symposium 

USENIX Association

6

A note on Prime+Probe. Finding a fast eviction strat-
egy for Prime+Probe on architectures with a random
replacement policy is not as straightforward as on In-
tel x86. Even in case of x86 platforms, the problem of
cache trashing has been discussed by Tromer et al. [54].
Cache trashing occurs when reloading (probing) an ad-
dress evicts one of the addresses that are to be accessed
next. While Tromer et al. were able to overcome this
problem by using a doubly-linked list that is accessed
forward during the prime step and backwards during the
probe step, the random replacement policy on ARM also
contributes to the negative effect of cache trashing.

We analyzed the behavior of the cache and designed
a prime step and a probe step that work with a smaller
set size to avoid set thrashing. Thus, we set the evic-
tion set size to 15 on the Alcatel One Touch Pop 2. As
we run the Prime+Probe attack in a loop, exactly 1 way
in the L2 cache will not be occupied after a few attack
rounds. We might miss a victim access in 1
16 of the cases,
which however is necessary as otherwise we would not
be able to get reproducible measurements at all due to set
thrashing. If the victim replaces one of the 15 ways occu-
pied by the attacker, there is still one free way to reload
the address that was evicted. This reduces the chance of
set thrashing significantly and allows us to successfully
perform Prime+Probe on caches with a random replace-
ment policy.

3.3 Accurate Unprivileged Timing

In this section, we tackle the aforementioned challenge 5,
i.e., cycle-accurate timings require root access on ARM.
In order to distinguish cache hits and cache misses,
timing sources or dedicated performance counters can be
used. We focus on timing sources, as cache misses have
a significantly higher access latency and timing sources
are well studied on Intel x86 CPUs. Cache attacks on
x86 CPUs employ the unprivileged rdtsc instruction
to obtain a sub-nanosecond resolution timestamp. The
ARMv7-A architecture does not provide an instruction
for this purpose.
Instead, the ARMv7-A architecture
has a performance monitoring unit that allows to mon-
itor CPU activity. One of these performance counters—
denoted as cycle count register (PMCCNTR)—can be
used to distinguish cache hits and cache misses by re-
lying on the number of CPU cycles that passed during
a memory access. However, these performance counters
are not accessible from userspace by default and an at-
tacker would need root privileges.

We broaden the attack surface by exploiting timing
sources that are accessible without any privileges or per-
missions. We identified three possible alternatives for
timing measurements.

Hit (PMCCNTR)
Miss (PMCCNTR)
Hit (syscall×.25)
Miss (syscall×.25)

Hit (clock gettime×.15)
Miss (clock gettime×.15)
Hit (counter thread×.05)
Miss (counter thread×.05)

·104

0

20

40

80

140
60
Measured access time (scaled)

100

120

160

180

200

s
e
s
s
e
c
c
a

f
o

r
e
b
m
u
N

4

2

0

Figure 4: Histogram of cross-core cache hits/misses on
the Alcatel One Touch Pop 2 using different methods.
X-values are scaled for visual representation.

layer

Unprivileged syscall. The
is an abstract

perf_event_open
to access perfor-
syscall
indepen-
mance information through the kernel
dently of the underlying hardware.
For instance,
PERF_COUNT_HW_CPU_CYCLES returns an accurate
cycle count including a minor overhead due to the
syscall. The availability of this feature depends on the
Android kernel configuration, e.g., the stock kernel on
the Alcatel One Touch Pop 2 as well as the OnePlus
One provide this feature by default. Thus, in contrast
to previous work [51], the attacker does not have to
load a kernel module to access this information as the
perf_event_open syscall can be accessed without
any privileges or permissions.

POSIX function. Another alternative to obtain suf-
ficiently accurate timing information is the POSIX
function clock_gettime(), with an accuracy
in the range of microseconds
to nanoseconds.
Similar
information can also be obtained from
/proc/timer_list.

Dedicated thread timer. If no interface with sufficient
accuracy is available, an attacker can run a thread
that increments a global variable in a loop, provid-
ing a fair approximation of a cycle counter. Our ex-
periments show that this approach works reliably on
smartphones as well as recent x86 CPUs. The resolu-
tion of this threaded timing information is as high as
with the other methods.

In Figure 4 we show the cache hit and miss histogram
based on the four different methods, including the cycle
count register, on a Alcatel One Touch Pop 2. Despite the
latency and noise, cache hits and cache misses are clearly
distinguishable with all approaches. Thus, all methods
can be used to implement cache attacks. Determining
the best timing method on the device under attack can be
done in a few seconds during an online attack.

USENIX Association  

25th USENIX Security Symposium  555

7

4 High Performance Covert Channels

To evaluate the performance of our attacks, we measure
the capacity of cross-core and cross-CPU cache covert
channels. A covert channel enables two unprivileged ap-
plications on a system to communicate with each other
without using any data transfer mechanisms provided by
the operating system. This communication evades the
sandboxing concept and the permission system (cf. col-
lusion attacks [36]). Both applications were running in
the background while the phone was mostly idle and an
unrelated app was running as the foreground application.
Our covert channel is established on addresses of a
shared library that is used by both the sender and the re-
ceiver. While both processes have read-only access to the
shared library, they can transmit information by loading
addresses from the shared library into the cache or evict-
ing (flushing) it from the cache, respectively.

The covert channel transmits packets of n-bit data, an
s-bit sequence number, and a c-bit checksum that is com-
puted over data and sequence number. The sequence
number is used to distinguish consecutive packets and
the checksum is used to check the integrity of the packet.
The receiver acknowledges valid packets by responding
with an s-bit sequence number and an x-bit checksum.
By adjusting the sizes of checksums and sequence num-
bers the error rate of the covert channel can be controlled.
Each bit is represented by one address in the shared
library, whereas no two addresses are chosen that map
to the same cache set. To transmit a bit value of 1, the
sender accesses the corresponding address in the library.
To transmit a bit value of 0, the sender does not access
the corresponding address, resulting in a cache miss on
the receiver’s side. Thus, the receiving process observes
a cache hit or a cache miss depending on the memory ac-
cess performed by the sender. The same method is used
for the acknowledgements sent by the receiving process.
using
Evict+Reload, Flush+Reload, and Flush+Flush on
our smartphones. The results are summarized in Table 4.
On the Samsung Galaxy S6, we achieve a cross-core
transmission rate of 1 140 650 bps at an error rate of
1.10%. This is 265 times faster than any existing covert
channel on smartphones. In a cross-CPU transmission
we achieve a transmission rate of 257 509 bps at an error
rate of 1.83%. We achieve a cross-core transition rate of
178 292 bps at an error rate of 0.48% using Flush+Flush
on the Samsung Galaxy S6. On the Alcatel One Touch
Pop 2 we achieve a cross-core transmission rate of
13 618 bps at an error rate of 3.79% using Evict+Reload.
This is still 3 times faster than previous covert channels
on smartphones. The covert channel is significantly
slower on the Alcatel One Touch Pop 2 than on the
Samsung Galaxy S6 because the hardware is much

implemented

channel

We

this

covert

slower, Evict+Reload is slower than Flush+Reload, and
retransmission might be necessary in 0.14% of the cases
where eviction is not successful (cf. Section 3.2). On the
older OnePlus One we achieve a cross-core transmission
rate of 12 537 bps at an error rate of 5.00%, 3 times faster
than previous covert channels on smartphones. The
reason for the higher error rate is the additional timing
noise due to the cache coherence protocol performing a
high number of remote-core fetches.

5 Attacking User Input on Smartphones

In this section we demonstrate cache side-channel at-
tacks on Android smartphones. We implement cache
template attacks [19]
to create and exploit accu-
rate cache-usage profiles using the Evict+Reload or
Flush+Reload attack. Cache template attacks have a pro-
filing phase and an exploitation phase. In the profiling
phase, a template matrix is computed that represents how
many cache hits occur on a specific address when trig-
gering a specific event. The exploitation phase uses this
matrix to infer events from cache hits.

To perform cache template attacks, an attacker has
to map shared binaries or shared libraries as read-only
shared memory into its own address space. By us-
ing shared libraries, the attacker bypasses any potential
countermeasures taken by the operating system, such as
restricted access to runtime data of other apps or address
space layout randomization (ASLR). The attack can even
be performed online on the device under attack if the
event can be simulated.

Triggering the actual event that an attacker wants to
spy on might require either (1) an offline phase or (2)
privileged access. For instance, in case of a keylogger,
the attacker can gather a cache template matrix offline
for a specific version of a library, or the attacker relies on
privileged access of the application (or a dedicated per-
mission) in order to be able to simulate events for gath-
ering the cache template matrix. However, the actual ex-
ploitation of the cache template matrix to infer events
neither requires privileged access nor any permission.

5.1 Attacking a Shared Library
Just as Linux, Android uses a large number of shared li-
braries, each with a size of up to several megabytes. We
inspected all available libraries on the system by man-
ually scanning the names and identified libraries that
might be responsible for handling user input, e.g., the
libinput.so library. Without loss of generality, we re-
stricted the set of attacked libraries since testing all li-
braries would have taken a significant amount of time.
Yet, an adversary could exhaustively probe all libraries.

556  25th USENIX Security Symposium 

USENIX Association

8

Table 4: Comparison of covert channels on Android.

Work
Ours (Samsung Galaxy S6)
Ours (Samsung Galaxy S6)
Ours (Samsung Galaxy S6)
Ours (Alcatel One Touch Pop 2)
Ours (OnePlus One)
Marforio et al. [36]
Marforio et al. [36]
Schlegel et al. [48]
Schlegel et al. [48]
Schlegel et al. [48]

Type
Flush+Reload, cross-core
Flush+Reload, cross-CPU
Flush+Flush, cross-core
Evict+Reload, cross-core
Evict+Reload, cross-core
Type of Intents
UNIX socket discovery
File locks
Volume settings
Vibration settings

Bandwidth [bps]
1 140 650
257 509
178 292
13 618
12 537
4 300
2 600
685
150
87

Error rate
1.10%
1.83%
0.48%
3.79%
5.00%
–
–
–
–
–

We automated the search for addresses in these shared
libraries and after identifying addresses, we monitored
them in order to infer user input events.
For in-
stance, in the profiling phase on libinput.so, we sim-
ulated events via the android-debug bridge (adb shell)
with two different methods. The first method uses
the input command line tool to simulate user input
events. The second method is writing event messages
to /dev/input/event*. Both methods can run entirely
on the device for instance in idle periods while the user is
not actively using the device. As the second method only
requires a write() statement it is significantly faster, but
it is also more device specific. Therefore, we used the
input command line except when profiling differences
between different letter keys. While simulating these
events, we simultaneously probed all addresses within
the libinput.so library, i.e., we measured the number
of cache hits that occurred on each address when trig-
gering a specific event. As already mentioned above, the
simulation of some events might require either an offline
phase or specific privileges in case of online attacks.

Figure 5 shows part of the cache template matrix
for libinput.so. We triggered the following events:
key events including the power button (key), long touch
events (longpress), swipe events, touch events (tap), and
text input events (text) via the input tool as often as pos-
sible and measured each address and event for one sec-
ond. The cache template matrix clearly reveals addresses
with high cache-hit rates for specific events. Darker col-
ors represent addresses with higher cache-hit rates for a
specific event and lighter colors represent addresses with
lower cache-hit rates. Hence, we can distinguish differ-
ent events based on cache hits on these addresses.

We verified our results by monitoring the identified
addresses while operating the smartphone manually, i.e.,
we touched the screen and our attack application reliably
reported cache hits on the monitored addresses. For in-
stance, address 0x11040 of libinput.so can be used to
distinguish tap actions and swipe actions on the screen of
the Alcatel One Touch Pop 2. Tap actions cause a smaller

t
n
e
v
E

key
longpress
swipe
tap
text

0
4
8
x
0

0
8
8
x
0

0
8
2
3
x
0

0
0
7
7
x
0

0
8
0
8
x
0

0
0
1
8
x
0

0
4
1
8
x
0

0
4
8
8
x
0

0
8
8
8
x
0

0
0
9
8
x
0

0
4
9
8
x
0

0
8
9
8
x
0

0
0
0
1
1
x
0

0
4
0
1
1
x
0

0
8
0
1
1
x
0

Addresses

Figure 5: Cache template matrix for libinput.so.

200

150

100

50

e
m

i
t

s
s
e
c
c
A

Tap Tap Tap Swipe Swipe Swipe

Tap Tap Tap

Swipe Swipe

0

5

10

15

Time in seconds

Figure 6: Monitoring address 0x11040 of libinput.so
on the Alcatel One Touch Pop 2 reveals taps and swipes.

number of cache hits than swipe actions. Swipe actions
cause cache hits in a high frequency as long as the screen
is touched. Figure 6 shows a sequence of 3 tap events,
3 swipe events, 3 tap events, and 2 swipe events. These
events can be clearly distinguished due to the fast access
times. The gaps mark periods of time where our program
was not scheduled on the CPU. Events occurring in those
periods can be missed by our attack.

Swipe input allows to enter words by swiping over
the soft-keyboard and thereby connecting single charac-
ters to form a word. Since we are able to determine the
length of swipe movements, we can correlate the length
of the swipe movement with the actual word length in
any Android application or system interface that uses
swipe input without any privileges. Furthermore, we can
determine the actual length of the unlock pattern for the
pattern-unlock mechanism.

USENIX Association  

25th USENIX Security Symposium  557

9

Figure 7 shows a user input sequence consisting of 3
tap events and 3 swipe events on the Samsung Galaxy
S6. The attack was conducted using Flush+Reload.
An attacker can monitor every single event. Taps and
swipes can be distinguished based on the length of the
cache hit phase. The length of a swipe movement can
be determined from the same information. Figure 8
shows the same experiment on the OnePlus One using
Evict+Reload. Thus, our attack techniques work on co-
herent non-inclusive last-level caches.

t
u
p
n
I

alphabet
enter
space
backspace

0
4
1
5
4
x
0

0
4
9
6
5
x
0

0
8
2
7
5
x
0

0
8
4
8
5
x
0

0
8
2
0
6
x
0

0
4
3
0
6
x
0

0
8
5
0
6
x
0

0
4
3
6
6
x
0

0
8
3
6
6
x
0

Addresses

Figure 9: Cache template matrix for the default AOSP
keyboard.

400

200

e
m

i
t

s
s
e
c
c
A

Tap

Tap

Tap

Swipe

Swipe

Swipe

0

2

4

6
Time in seconds

8

e
m

i
t

s
s
e
c
c
A

300

200

100

Key
Space

t h i

s

Space

i

s

Space

a Space m e s

s

a g

e

0

1

2

3

4

5

6

7

Time in seconds

Figure 7: Monitoring address 0xDC5C of libinput.so
on the Samsung Galaxy S6 reveals tap and swipe events.

1,000

800
600
400
200

e
m

i
t

s
s
e
c
c
A

Tap

Tap

Tap

0

2

Swipe
4

Swipe

Swipe

6

Time in seconds

Figure 8: Monitoring address 0xBFF4 of libinput.so
on the OnePlus One reveals tap and swipe events.

5.2 Attacking ART Binaries
Instead of attacking shared libraries, it is also possible
to apply this attack to ART (Android Runtime) executa-
bles [1] that are compiled ahead of time. We used this
attack on the default AOSP keyboard and evaluated the
number of accesses to every address in the optimized ex-
ecutable that responds to an input of a letter on the key-
board. It is possible to find addresses that correspond to
a key press and more importantly to distinguish between
taps and key presses. Figure 9 shows the correspond-
ing cache template matrix. We summarize the letter keys
in one line (alphabet) as they did not vary significantly.
These addresses can be used to monitor key presses on
the keyboard. We identified an address that corresponds
only to letters on the keyboard and hardly on the space
bar or the return button. With this information it is pos-

Figure 10: Evict+Reload on 2 addresses in custpack@
app@withoutlibs@LatinIME.apk@classes.dex on
the Alcatel One Touch Pop 2 while entering the sentence
“this is a message”.

sible to precisely determine the length of single words
entered using the default AOSP keyboard.

We illustrate the capability of detecting word lengths
in Figure 10. The blue line shows the timing measure-
ments for the address identified for keys in general, the
red dots represent measurements of the address for the
space key. The plot shows that we can clearly determine
the length of entered words and monitor user input accu-
rately over time.

5.3 Discussion and Impact
Our proof-of-concept attacks exploit shared libraries and
binaries from Android apk files to infer key strokes. The
cache template attack technique we used for these attacks
is generic and can also be used to attack any other li-
brary. For instance, there are various libraries that han-
dle different hardware modules and software events on
the device, such as GPS, Bluetooth, camera, NFC, vi-
brator, audio and video decoding, web and PDF viewers.
Each of these libraries contains code that is executed and
data that is accessed when the device is in use. Thus,
an attacker can perform a cache template attack on any
of these libraries and spy on the corresponding device
events. For instance, our attack can be used to monitor
activity of the GPS sensor, bluetooth, or the camera. An
attacker can record such user activities over time to learn
more about the user.

558  25th USENIX Security Symposium 

USENIX Association

10

We can establish inter-keystroke timings at an ac-
curacy as high as the accuracy of cache side-channel
attacks on keystrokes on x86 systems with a physi-
cal keyboard. Thus,
the inter-keystroke timings can
be used to infer entered words, as has been shown by
Zhang et al. [61]. Our attack even has a higher res-
olution than [61], i.e., it is sub-microsecond accurate.
Furthermore, we can distinguish between keystrokes on
the soft-keyboard and generic touch actions outside the
soft-keyboard. This information can be used to enhance
sensor-based keyloggers that infer user input on mobile
devices by exploiting, e.g., the accelerometer and the gy-
roscope [7,11,12,39,59] or the ambient-light sensor [49].
However, these attacks suffer from a lack of knowledge
when exactly a user touches the screen. Based on our at-
tack, these sensor-based keyloggers can be improved as
our attack allows to infer (1) the exact time when the user
touches the screen, and (2) whether the user touches the
soft-keyboard or any other region of the display.

Our attacks only require the user to install a malicious
app on the smartphone. However, as shown by Oren et al.
[42], Prime+Probe attacks can even be performed from
within browser sandboxes through remote websites using
JavaScript on Intel platforms. Gruss et al. [16] showed
that JavaScript timing measurements in web browsers
on ARM-based smartphones achieve a comparable ac-
curacy as on Intel platforms. Thus, it seems likely that
Prime+Probe through a website works on ARM-based
smartphones as well. We expect that such attacks will be
demonstrated in future work. The possibility of attack-
ing millions of users shifts the focus of cache attacks to
a new range of potential malicious applications.

In our experiments with the predecessor of ART, the
Dalvik VM, we found that the just-in-time compilation
effectively prevents Evict+Reload and Flush+Reload at-
tacks. The just-in-time compiled code is not shared and
thus the requirements for these two attacks are not met.
However, Prime+Probe attacks work on ART binaries
and just-in-time compiled Dalvik VM code likewise.

6 Attack on Cryptographic Algorithms

this

section we

show how Flush+Reload,
In
Evict+Reload,
and Prime+Probe can be used to
attack AES T-table implementations that are still in use
on Android devices. Furthermore, we demonstrate the
possibility to infer activities within the ARM TrustZone
by observing the cache activity using Prime+Probe. We
perform all attacks cross-core and in a synchronized
setting, i.e., the attacker triggers the execution of cryp-
tographic algorithms by the victim process. Although
more sophisticated attacks are possible, our goal
is
to demonstrate that our work enables practical cache
attacks on smartphones.

6.1 AES T-Table Attacks
Many cache attacks against AES T-table implementa-
tions have been demonstrated and appropriate counter-
measures have already been proposed. Among these
countermeasures are, e.g., so-called bit-sliced implemen-
tations [29, 32, 46]. Furthermore, Intel addressed the
problem by adding dedicated instructions for AES [20]
and ARM also follows the same direction with the
ARMv8 instruction set [4]. However, our investiga-
tions showed that Bouncy Castle, a crypto library widely
used in Android apps such as the WhatsApp messen-
ger [2], still uses a T-table implementation. Moreover,
the OpenSSL library, which is the default crypto provider
on recent Android versions, uses T-table implementa-
tions until version 1.0.1.3 This version is still officially
supported and commonly used on Android devices, e.g.,
the Alcatel One Touch Pop 2. T-tables contain the pre-
computed AES round transformations, allowing to per-
form encryptions and decryptions by simple XOR oper-
ations. For instance, let pi denote the plaintext bytes,
ki the initial key bytes, and si = pi ⊕ ki the initial state
bytes. The initial state bytes are used to retrieve pre-
computed T-table elements for the next round. If an at-
tacker knows a plaintext byte pi and the accessed ele-
ment of the T-table, it is possible to recover the key bytes
ki = si ⊕ pi. However, it is only possible to derive the
upper 4 bits of ki through our cache attack on a device
with a cache line size of 64 bytes. This way, the attacker
can learn 64 key bits. In second-round and last-round at-
tacks the key space can be reduced further. For details
about the basic attack strategy we refer to the work of
Osvik et al. [43, 54]. Although we successfully mounted
an Evict+Reload attack on the Alcatel One Touch Pop
2 against the OpenSSL AES implementation, we do not
provide further insights as we are more interested to per-
form the first cache attack on a Java implementation.

Attack on Bouncy Castle. Bouncy Castle is imple-
mented in Java and provides various cryptographic prim-
itives including AES. As Bouncy Castle 1.5 still employs
AES T-table implementations by default, all Android de-
vices that use this version are vulnerable to our presented
attack. To the best of our knowledge, we are the first to
show an attack on a Java implementation.

During the initialization of Bouncy Castle, the T-tables
are copied to a local private memory area. Therefore,
these copies are not shared among different processes.
Nevertheless, we demonstrate that Flush+Reload and
Evict+Reload are efficient attacks on such an implemen-

3Later versions use a bit-sliced implementation if ARM NEON is
available or dedicated AES instructions if ARMv8-A instructions are
available. Otherwise, a T-table implementation is used. This is also the
case for Google’s BoringSSL library.

USENIX Association  

25th USENIX Security Symposium  559

11

s
s
e
r
d
d
A

s
s
e
r
d
d
A

0
0
x
0

0
1
x
0

0
2
x
0

0
3
x
0

0
4
x
0

0
5
x
0

0
6
x
0

0
7
x
0

0
8
x
0

0
9
x
0

0
A
x
0

0
B
x
0

0
C
x
0

0
D
x
0

0
E
x
0

0
F
x
0

Plaintext byte values

0
0
x
0

0
1
x
0

0
2
x
0

0
3
x
0

0
4
x
0

0
5
x
0

0
6
x
0

0
7
x
0

0
8
x
0

0
9
x
0

0
A
x
0

0
B
x
0

0
C
x
0

0
D
x
0

0
E
x
0

0
F
x
0

Plaintext byte values

6,000

4,000

2,000

s
e
s
a
c

f
o

r
e
b
m
u
N

Victim access

No victim access

0

1,500

2,500

3,000
2,000
Execution time in CPU cycles

3,500

Figure 11: Attack on Bouncy Castle’s AES using
Evict+Reload on the Alcatel One Touch Pop 2 (left) and
Flush+Reload on the Samsung Galaxy S6 (right).

Figure 12: Histogram of Prime+Probe timings depend-
ing on whether the victim accesses congruent memory
on the ARM Cortex-A53.

tation if shared memory is available. Further, we demon-
strate a cross-core Prime+Probe attack without shared
memory that is applicable in a real-world scenario.

Figure 11 shows a template matrix of the first T-table
for all 256 values for plaintext byte p0 and a key that
is fixed to 0 while the remaining plaintext bytes are
random. These plots reveal the upper 4 key bits of
k0 [43, 51]. Thus, in our case the key space is reduced
to 64 bits after 256–512 encryptions. We consider a first-
round attack only, because we aim to demonstrate the
applicability of these attacks on ARM-based mobile de-
vices. However, full-key recovery is possible with the
same techniques by considering more sophisticated at-
tacks targeting different rounds [47, 54], even for asyn-
chronous attackers [22, 26].

We can exploit the fact that the T-tables are placed on
a different boundary every time the process is started. By
restarting the victim application we can obtain arbitrary
disalignments of T-tables. Disaligned T-tables allow to
reduce the key space to 20 bits on average and for spe-
cific disalignments even full-key recovery without a sin-
gle brute-force computation is possible [51, 53]. We ob-
served not a single case where the T-tables were aligned.
Based on the first-round attack matrix in Figure 11, the
expected number of encryptions until a key byte is iden-
tified is 1.81 · 128. Thus, full key recovery is possible
after 1.81· 128· 16 = 3707 encryptions by monitoring a
single address during each encryption.

Real-world cross-core attack on Bouncy Castle.
If
the attacker has no way to share a targeted mem-
ory region with the victim, Prime+Probe instead of
Evict+Reload or Flush+Reload can be used. This is the
case for dynamically generated data or private memory
of another process. Figure 12 shows the Prime+Probe
histogram for cache hits and cache misses. We observe a
higher execution time if the victim accesses a congruent
memory location. Thus, Prime+Probe can be used for
a real-world cross-core attack on Bouncy Castle and also
allows to exploit disaligned T-tables as mentioned above.

t
e
s
f
f

O

0x240
0x280
0x2C0
0x300
0x340
0x380
0x3C0

0
0
x
0

0
1
x
0

0
2
x
0

0
3
x
0

0
4
x
0

0
5
x
0

0
6
x
0

0
7
x
0

0
8
x
0

0
9
x
0

0
A
x
0

0
B
x
0

0
C
x
0

Plaintext byte values

0
D
x
0

0
E
x
0

0
F
x
0

Figure 13: Excerpt of the attack on Bouncy Castle’s AES
using Prime+Probe.

In a preprocessing step,

the attacker identifies the
cache sets to be attacked by performing random encryp-
tions and searching for active cache sets. Recall that the
cache set (index) is derived directly from the physical ad-
dress on ARM, i.e., the lowest n bits determine the offset
within a 2n-byte cache line and the next s bits determine
one of the 2s cache sets. Thus, we only have to find a
few cache sets where a T-table maps to in order to iden-
tify all cache sets required for the attack. On x86 the
replacement policy facilitates this attack and allows even
to deduce the number of ways that have been replaced in
a specific cache set [43]. On ARM the random replace-
ment policy makes Prime+Probe more difficult as cache
lines are replaced in a less predictable way. To launch a
Prime+Probe attack, we apply the eviction strategy and
the crafted reaccess patterns we described in Section 3.2.
Figure 13 shows an excerpt of the cache template ma-
trix resulting from a Prime+Probe attack on one T-table.
For each combination of plaintext byte and offset we per-
formed 100000 encryptions for illustration purposes. We
only need to monitor a single address to obtain the upper
4 bits of si and, thus, the upper 4 bits of ki = si ⊕ pi.
Compared to the Evict+Reload attack from the previous
section, Prime+Probe requires 3 times as many measure-
ments to achieve the same accuracy. Nevertheless, our
results show that an attacker can run Prime+Probe at-
tacks on ARM CPUs just as on Intel CPUs.

560  25th USENIX Security Symposium 

USENIX Association

12

6.2 Spy on TrustZone Code Execution

The ARM TrustZone is a hardware-based security tech-
nology built into ARM CPUs to provide a secure exe-
cution environment [4]. This trusted execution environ-
ment is isolated from the normal world using hardware
support. The TrustZone is used, e.g., as a hardware-
backed credential store, to emulate secure elements for
payment applications, digital rights management as well
as verified boot and kernel integrity measurements. The
services are provided by so-called trustlets, i.e., applica-
tions that run in the secure world.

Since the secure monitor can only be called from the
supervisor context, the kernel provides an interface for
the userspace to interact with the TrustZone. On the
Alcatel One Touch Pop 2, the TrustZone is accessible
through a device driver called QSEECOM (Qualcomm
Secure Execution Environment Communication) and a
library libQSEEComAPI.so. The key master trustlet on
the Alcatel One Touch Pop 2 provides an interface to
generate hardware-backed RSA keys, which can then be
used inside the TrustZone to sign and verify signatures.
Our observations showed that a Prime+Probe at-
tack on the TrustZone is not much different from a
Prime+Probe attack on any application in the normal
world. However, as we do not have access to the source
code of the TrustZone OS or any trustlet, we only con-
duct simple attacks.4 We show that Prime+Probe can be
used to distinguish whether a provided key is valid or not.
While this might also be observable through the overall
execution time, we demonstrate that the TrustZone isola-
tion does not protect against cache attacks from the nor-
mal world and any trustlet can be attacked.

We evaluated cache profiles for multiple valid as well
as invalid keys. Figure 14 shows the mean squared er-
ror over two runs for different valid keys and one in-
valid key compared to the average of valid keys. We
performed Prime+Probe before and after the invocation
of the corresponding trustlet, i.e., prime before the invo-
cation and probe afterwards. We clearly see a difference
in some sets (cache sets 250–320) that are used during
the signature generation using a valid key. These cache
profiles are reproducible and can be used to distinguish
whether a valid or an invalid key has been used in the
TrustZone. Thus, the secure world leaks information to
the non-secure world.

On the Samsung Galaxy S6, the TrustZone flushes the
cache when entering or leaving the trusted world. How-
ever, by performing a Prime+Probe attack in parallel,
i.e., multiple times while the trustlet performs the corre-
sponding computations, the same attack can be mounted.

4More sophisticated attacks would be possible by reverse engineer-

ing these trustlets.

s
e
l
c
y
c
U
P
C
n
i

e
m

i
t

g
n
i
b
o
r
P

1.5 ·106

1

0.5

0

Valid key 1
Valid key 2
Valid key 3
Invalid key

260

280

300

320

340

Set number

Figure 14: Mean squared error between the average
Prime+Probe timings of valid keys and invalid keys on
the Alcatel One Touch Pop 2.

7 Countermeasures

Although our attacks exploit hardware weaknesses,
software-based countermeasures could impede such at-
tacks. Indeed, we use unprotected access to system in-
formation that is available on all Android versions.

As we have shown, the operating system cannot pre-
vent access to timing information. However, other in-
formation supplied by the operating system that facil-
itates these attacks could be restricted. For instance,
we use /proc/pid/ to retrieve information about any
other process on the device, e.g., /proc/pid/pagemap
is used to resolve virtual addresses to physical ad-
dresses. Even though access to /proc/pid/pagemap
and /proc/self/pagemap has been restricted in Linux
in early 2015, the Android kernel still allows access to
these resources. Given the immediately applicable at-
tacks we presented, we stress the urgency to merge the
corresponding patches into the Android kernel. Further-
more, we use /proc/pid/maps to determine shared ob-
jects that are mapped into the address space of a victim.
Restricting access to procfs to specific privileges or per-
missions would make attacks harder. We recommend this
for both the Linux kernel as well as Android.

We also exploit the fact that access to shared li-
braries as well as dex and art optimized program bi-
naries is only partially restricted on the file system
level. While we cannot retrieve a directory listing of
/data/dalvik-cache/, all files are readable for any
process or Android application. We recommend to allow
read access to these files to their respective owner ex-
clusively to prevent Evict+Reload, Flush+Reload, and
Flush+Flush attacks through these shared files.

In order to prevent cache attacks against AES T-tables,
hardware instructions should be used. If this is not an op-
tion, a software-only bit-sliced implementation must be
employed, especially when disalignment is possible, as it
is the case in Java. Since OpenSSL 1.0.2 a bit-sliced im-
plementation is available for devices capable of the ARM

USENIX Association  

25th USENIX Security Symposium  561

13

562  25th USENIX Security Symposium 

USENIX Association

NEONinstructionsetanddedicatedAESinstructionsareusedonARMv8-Adevices.Cryptographicalgorithmscanalsobeprotectedusingcachepartitioning[34].How-ever,cachepartitioningcomeswithaperformanceim-pactanditcannotpreventallattacks,asthenumberofcachepartitionsislimited.Weresponsiblydisclosedourattacksandthepro-posedcountermeasurestoGoogleandotherdevelopmentgroupspriortothepublicationofourattacks.Googlehasappliedupstreampatchespreventingaccessto/proc/pid/pagemapinearly2016andrecommendedinstallingthesecurityupdateinMarch2016[15].8ConclusionInthisworkwedemonstratedthemostpowerfulcross-corecacheattacksPrime+Probe,Flush+Reload,Evict+Reload,andFlush+FlushondefaultconfiguredunmodifiedAndroidsmartphones.Furthermore,theseattacksdonotrequireanypermissionorprivileges.Inordertoenabletheseattacksinreal-worldscenarios,wehavesystematicallysolvedallchallengesthatpre-ventedhighlyaccuratecacheattacksonARMsofar.Ourattacksarethefirstcross-coreandcross-CPUat-tacksonARMCPUs.Furthermore,ourattacktech-niquesprovideahighresolutionandahighaccuracy,whichallowsmonitoringsingulareventssuchastouchandswipeactionsonthescreen,touchactionsonthesoft-keyboard,andinter-keystroketimings.Inaddition,weshowthatefficientstate-of-the-artkey-recoveryat-tackscanbemountedagainstthedefaultAESimple-mentationthatispartoftheJavaBouncyCastlecryptoproviderandthatcacheactivityintheARMTrustZonecanbemonitoredfromthenormalworld.Thepresentedexampleattacksarebynomeansex-haustiveandlaunchingourproposedattackagainstotherlibrariesandappswillrevealnumerousfurtherex-ploitableinformationleaks.Ourattacksareapplicabletohundredsofmillionsoftoday’soff-the-shelfsmart-phonesastheyallhaveverysimilarifnotidenticalhard-ware.Thisisespeciallydauntingsincesmartphoneshavebecomethemostimportantpersonalcomputingdevicesandourtechniquessignificantlybroadenthescopeandimpactofcacheattacks.AcknowledgmentWewouldliketothankouranonymousreviewersfortheirvaluablecommentsandsuggestions.SupportedbytheEUHorizon2020pro-grammeunderGANo.644052(HEC-TOR),theEUFP7programmeunderGANo.610436(MATTHEW),andtheAus-trianResearchPromotionAgency(FFG)undergrantnumber845579(MEMSEC).References[1]ANDROIDOPENSOURCEPROJECT.ConfiguringART.https://source.android.com/devices/tech/dalvik/configure.html,Nov.2015.RetrievedonNovember10,2015.[2]APPTORNADO.AppBrain-Androidlibrarystatistics-SpongyCastle-BouncyCastleforAndroid.http://www.appbrain.com/stats/libraries/details/spongycastle/spongy-castle-bouncy-castle-for-android,June2016.Re-trievedonJune6,2016.[3]ARMLIMITED.ARMArchitectureReferenceManual.ARMv7-AandARMv7-Redition.ARMLimited,2012.[4]ARMLIMITED.ARMArchitectureReferenceManualARMv8.ARMLimited,2013.[5]ARMLIMITED.ARMCortex-A57MPCoreProcessorTechnicalReferenceManualr1p0.ARMLimited,2013.[6]ARMLIMITED.ARMCortex-A53MPCoreProcessorTechnicalReferenceManualr0p3.ARMLimited,2014.[7]AVIV,A.J.,SAPP,B.,BLAZE,M.,ANDSMITH,J.M.Prac-ticalityofAccelerometerSideChannelsonSmartphones.InAnnualComputerSecurityApplicationsConference–ACSAC(2012),ACM,pp.41–50.[8]BENGER,N.,VANDEPOL,J.,SMART,N.P.,ANDYAROM,Y.”OohAah...JustaLittleBit”:ASmallAmountofSideChannelCanGoaLongWay.InCryptographicHardwareandEmbeddedSystems–CHES(2014),vol.8731ofLNCS,Springer,pp.75–92.[9]BERNSTEIN,D.J.Cache-TimingAttacksonAES,2004.URL:http://cr.yp.to/papers.html#cachetiming.[10]BOGDANOV,A.,EISENBARTH,T.,PAAR,C.,ANDWIENECKE,M.DifferentialCache-CollisionTimingAttacksonAESwithApplicationstoEmbeddedCPUs.InTopicsinCryptology–CT-RSA(2010),vol.5985ofLNCS,Springer,pp.235–251.[11]CAI,L.,ANDCHEN,H.TouchLogger:InferringKeystrokesonTouchScreenfromSmartphoneMotion.InUSENIXWorkshoponHotTopicsinSecurity–HotSec(2011),USENIXAssociation.[12]CAI,L.,ANDCHEN,H.OnthePracticalityofMotionBasedKeystrokeInferenceAttack.InTrustandTrustworthyComputing–TRUST(2012),vol.7344ofLNCS,Springer,pp.273–290.[13]GALLAIS,J.,KIZHVATOV,I.,ANDTUNSTALL,M.ImprovedTrace-DrivenCache-CollisionAttacksagainstEmbeddedAESImplementations.InWorkshoponInformationSecurityApplica-tions–WISA(2010),vol.6513ofLNCS,Springer,pp.243–257.[14]GALLAIS,J.-F.,ANDKIZHVATOV,I.Error-ToleranceinTrace-DrivenCacheCollisionAttacks.InCOSADE(2011),pp.222–232.[15]GOOGLEINC.NexusSecurityBulletin-March2016.https://source.android.com/security/bulletin/2016-03-01.html,Mar.2016.RetrievedonJune6,2016.[16]GRUSS,D.,BIDNER,D.,ANDMANGARD,S.PracticalMem-oryDeduplicationAttacksinSandboxedJavascript.InEuropeanSymposiumonResearch–ESORICS(2015),vol.9326ofLNCS,Springer,pp.108–122.14[17] GRUSS, D., MAURICE, C., AND MANGARD, S. Rowham-
mer.js: A Remote Software-Induced Fault Attack in JavaScript.
In DIMVA’16 (2016).

[18] GRUSS, D., MAURICE, C., WAGNER, K., AND MANGARD, S.
Flush+Flush: A Fast and Stealthy Cache Attack. In DIMVA’16
(2016).

[19] GRUSS, D., SPREITZER, R., AND MANGARD, S. Cache
Template Attacks: Automating Attacks on Inclusive Last-Level
Caches. In USENIX Security Symposium (2015), USENIX Asso-
ciation, pp. 897–912.

[20] GUERON, S. White Paper: Intel Advanced Encryption Stan-
dard (AES) Instructions Set, 2010. URL: https://software.
intel.com/file/24917.

[21] GULLASCH, D., BANGERTER, E., AND KRENN, S. Cache
Games – Bringing Access-Based Cache Attacks on AES to Prac-
tice. In IEEE Symposium on Security and Privacy – S&P (2011),
IEEE Computer Society, pp. 490–505.

[22] G ¨ULMEZOGLU, B., INCI, M. S., APECECHEA, G. I., EISEN-
BARTH, T., AND SUNAR, B. A Faster and More Realistic
Flush+Reload Attack on AES.
In Constructive Side-Channel
Analysis and Secure Design – COSADE (2015), vol. 9064 of
LNCS, Springer, pp. 111–126.

[23] HUND, R., WILLEMS, C., AND HOLZ, T. Practical Timing Side
Channel Attacks against Kernel Space ASLR. In IEEE Sympo-
sium on Security and Privacy – S&P (2013), IEEE, pp. 191–205.
[24] IRAZOQUI, G., EISENBARTH, T., AND SUNAR, B. S$A: A
Shared Cache Attack that Works Across Cores and Defies VM
Sandboxing – and its Application to AES. In IEEE Symposium
on Security and Privacy – S&P (2015), IEEE Computer Society.
[25] IRAZOQUI, G., EISENBARTH, T., AND SUNAR, B. Cross Pro-
cessor Cache Attacks. In ACM Computer and Communications
Security – ASIACCS (2016), ACM, pp. 353–364.

[26] IRAZOQUI, G., INCI, M. S., EISENBARTH, T., AND SUNAR, B.
Wait a Minute! A fast, Cross-VM Attack on AES. In Research
in Attacks, Intrusions and Defenses Symposium – RAID (2014),
vol. 8688 of LNCS, Springer, pp. 299–319.

[27] IRAZOQUI, G., INCI, M. S., EISENBARTH, T., AND SUNAR,
B. Know Thy Neighbor: Crypto Library Detection in Cloud.
Privacy Enhancing Technologies 1, 1 (2015), 25–40.

[28] IRAZOQUI, G., INCI, M. S., EISENBARTH, T., AND SUNAR, B.
Lucky 13 Strikes Back. In ACM Computer and Communications
Security – ASIACCS (2015), ACM, pp. 85–96.

[29] K ¨ASPER, E., AND SCHWABE, P. Faster and Timing-Attack Re-
sistant AES-GCM. In Cryptographic Hardware and Embedded
Systems – CHES (2009), vol. 5747 of LNCS, Springer, pp. 1–17.
[30] KELSEY, J., SCHNEIER, B., WAGNER, D., AND HALL, C. Side
Channel Cryptanalysis of Product Ciphers. Journal of Computer
Security 8, 2/3 (2000), 141–158.

[31] KOCHER, P. C. Timing Attacks on Implementations of Diffie-
Hellman, RSA, DSS, and Other Systems. In Advances in Cryp-
tology – CRYPTO (1996), vol. 1109 of LNCS, Springer, pp. 104–
113.

[32] K ¨ONIGHOFER, R. A Fast and Cache-Timing Resistant Imple-
mentation of the AES. In Topics in Cryptology – CT-RSA (2008),
vol. 4964 of LNCS, Springer, pp. 187–202.

[33] LAL SHIMPI, ANANDTECH.

Answered by the Experts:
ARM’s Cortex A53 Lead Architect, Peter Greenhalgh.
http://www.anandtech.com/show/7591/answered-
by-the-experts-arms-cortex-a53-lead-architect-
peter-greenhalgh, Dec. 2013. Retrieved on November 10,
2015.

[34] LIU, F., GE, Q., YAROM, Y., MCKEEN, F., ROZAS, C. V.,
HEISER, G., AND LEE, R. B. CATalyst: Defeating Last-Level
Cache Side Channel Attacks in Cloud Computing. In IEEE In-
ternational Symposium on High Performance Computer Archi-
tecture – HPCA (2016), IEEE Computer Society, pp. 406–418.

[35] LIU, F., YAROM, Y., GE, Q., HEISER, G., AND LEE, R. B.
Last-Level Cache Side-Channel Attacks are Practical. In IEEE
Symposium on Security and Privacy – SP (2015), IEEE Computer
Society, pp. 605–622.

[36] MARFORIO, C., RITZDORF, H., FRANCILLON, A., AND CAP-
KUN, S. Analysis of the Communication Between Colluding Ap-
plications on Modern Smartphones. In Annual Computer Security
Applications Conference – ACSAC (2012), ACM, pp. 51–60.

[37] MAURICE, C., NEUMANN, C., HEEN, O., AND FRANCILLON,
A. C5: Cross-Cores Cache Covert Channel.
In Detection of
Intrusions and Malware, and Vulnerability Assessment – DIMVA
(2015), vol. 9148 of LNCS, Springer, pp. 46–64.

[38] MAURICE, C., SCOUARNEC, N. L., NEUMANN, C., HEEN, O.,
AND FRANCILLON, A. Reverse Engineering Intel Last-Level
Cache Complex Addressing Using Performance Counters.
In
Research in Attacks, Intrusions, and Defenses – RAID (2015),
vol. 9404 of LNCS, Springer, pp. 48–65.

[39] MILUZZO, E., VARSHAVSKY, A., BALAKRISHNAN, S., AND
CHOUDHURY, R. R. Tapprints: Your Finger Taps Have Finger-
prints. In Mobile Systems, Applications, and Services – MobiSys
(2012), ACM, pp. 323–336.

[40] NEVE, M. Cache-based Vulnerabilities and SPAM Analysis. PhD

thesis, UCL, 2006.

[41] NEVE, M., SEIFERT, J., AND WANG, Z. A Refined Look at
Bernstein’s AES Side-Channel Analysis. In ACM Computer and
Communications Security – ASIACCS (2006), ACM, p. 369.

[42] OREN, Y., KEMERLIS, V. P., SETHUMADHAVAN, S., AND
KEROMYTIS, A. D. The Spy in the Sandbox: Practical Cache
Attacks in JavaScript and their Implications. In Conference on
Computer and Communications Security – CCS (2015), ACM,
pp. 1406–1418.

[43] OSVIK, D. A., SHAMIR, A., AND TROMER, E. Cache Attacks
and Countermeasures: The Case of AES. In Topics in Cryptology
– CT-RSA (2006), vol. 3860 of LNCS, Springer, pp. 1–20.

[44] PAGE, D. Theoretical Use of Cache Memory as a Cryptanalytic

Side-Channel. IACR Cryptology ePrint Archive 2002/169.

[45] PERCIVAL, C.

Cache Missing for Fun and Profit,
2005. URL: http://daemonology.net/hyperthreading-
considered-harmful/.

[46] REBEIRO, C., SELVAKUMAR, A. D., AND DEVI, A. S. L. Bit-
slice Implementation of AES. In Cryptology and Network Secu-
rity – CANS (2006), vol. 4301 of LNCS, Springer, pp. 203–212.
[47] SAVAS, E., AND YILMAZ, C. A Generic Method for the Analysis
of a Class of Cache Attacks: A Case Study for AES. Comput. J.
58, 10 (2015), 2716–2737.

[48] SCHLEGEL, R., ZHANG, K., ZHOU, X., INTWALA, M., KA-
PADIA, A., AND WANG, X. Soundcomber: A Stealthy and
Context-Aware Sound Trojan for Smartphones. In Network and
Distributed System Security Symposium – NDSS (2011), The In-
ternet Society.

[49] SPREITZER, R. PIN Skimming: Exploiting the Ambient-Light
Sensor in Mobile Devices.
In Security and Privacy in Smart-
phones & Mobile Devices – SPSM@CCS (2014), ACM, pp. 51–
62.

[50] SPREITZER, R., AND G ´ERARD, B. Towards More Practical
Time-Driven Cache Attacks. In Information Security Theory and
Practice – WISTP (2014), vol. 8501 of LNCS, Springer, pp. 24–
39.

USENIX Association  

25th USENIX Security Symposium  563

15

[51] SPREITZER, R., AND PLOS, T. Cache-Access Pattern Attack on
Disaligned AES T-Tables.
In Constructive Side-Channel Anal-
ysis and Secure Design – COSADE (2013), vol. 7864 of LNCS,
Springer, pp. 200–214.

[57] WEISS, M., HEINZ, B., AND STUMPF, F. A Cache Timing At-
tack on AES in Virtualization Environments. In Financial Cryp-
tography and Data Security – FC (2012), vol. 7397 of LNCS,
Springer, pp. 314–328.

[52] SPREITZER, R., AND PLOS, T. On the Applicability of Time-
Driven Cache Attacks on Mobile Devices. In Network and System
Security – NSS (2013), vol. 7873 of LNCS, Springer, pp. 656–662.
[53] TAKAHASHI, J., FUKUNAGA, T., AOKI, K., AND FUJI, H.
Highly Accurate Key Extraction Method for Access-Driven
Cache Attacks Using Correlation Coefficient.
In Australasian
Conference Information Security and Privacy – ACISP (2013),
vol. 7959 of LNCS, Springer, pp. 286–301.

[54] TROMER, E., OSVIK, D. A., AND SHAMIR, A. Efficient Cache
Attacks on AES, and Countermeasures. Journal Cryptology 23,
1 (2010), 37–71.

[55] TSUNOO, Y., SAITO, T., SUZAKI, T., SHIGERI, M., AND
MIYAUCHI, H. Cryptanalysis of DES Implemented on Com-
puters with Cache. In Cryptographic Hardware and Embedded
Systems – CHES (2003), vol. 2779 of LNCS, Springer, pp. 62–76.
[56] VAN DE POL, J., SMART, N. P., AND YAROM, Y. Just a Little
Bit More. In Topics in Cryptology – CT-RSA (2015), vol. 9048 of
LNCS, Springer, pp. 3–21.

[58] WEISS, M., WEGGENMANN, B., AUGUST, M., AND SIGL, G.
On Cache Timing Attacks Considering Multi-core Aspects in Vir-
tualized Embedded Systems.
In Trusted Systems – INTRUST
(2014), vol. 9473 of LNCS, Springer, pp. 151–167.

[59] XU, Z., BAI, K., AND ZHU, S. TapLogger: Inferring User In-
puts on Smartphone Touchscreens Using On-board Motion Sen-
sors. In Security and Privacy in Wireless and Mobile Networks –
WISEC (2012), ACM, pp. 113–124.

[60] YAROM, Y., AND FALKNER, K. FLUSH+RELOAD: A High
Resolution, Low Noise, L3 Cache Side-Channel Attack.
In
USENIX Security Symposium (2014), USENIX Association,
pp. 719–732.

[61] ZHANG, K., AND WANG, X. Peeping Tom in the Neighborhood:
In USENIX

Keystroke Eavesdropping on Multi-User Systems.

Security Symposium (2009), USENIX Association, pp. 17–32.

564  25th USENIX Security Symposium 

USENIX Association

16

