DeepDroid: Dynamically Enforcing Enterprise Policy on Android Devices

Xueqiang Wang∗†, Kun Sun‡, Yuewu Wang∗ and Jiwu Jing∗
∗ Data Assurance and Communication Security Research Center,
Institute of Information Engineering, Chinese Academy of Sciences

{wangxueqiang, ywwang, jing}@is.ac.cn
†University of Chinese Academy of Sciences

‡Department of Computer Science, College of William and Mary

ksun@wm.edu

Abstract—It is becoming a global trend for company
employees equipped with mobile devices to access compa-
ny’s assets. Besides enterprise apps, lots of personal apps
from various untrusted app stores may also be installed
on those devices. To secure the business environment,
policy enforcement on what, how, and when certain apps
can access system resources is required by enterprise IT.
However, Android, the largest mobile platform with a
market share of 81.9%, provides very restricted interfaces
for enterprise policy enforcement. In this paper, we present
DeepDroid, a dynamic enterprise security policy enforce-
ment scheme on Android devices. Different from existing
approaches, DeepDroid is implemented by dynamic mem-
ory instrumentation of a small number of critical system
processes without any ﬁrmware modiﬁcation. DeepDroid
can be easily deployed on various smartphone platforms
with a wide range of Android versions. Moreover, based
on the context information extracted from Binder intercep-
tion, a ﬁne-grained policy can be enforced. We develop a
prototype of DeepDroid and test it on various smartphones
and Android versions. The experimental results show
that DeepDroid can effectively enforce enterprise resource
access policies with negligible performance overhead.

I.

INTRODUCTION

Nowadays, an increasing number of employees are
allowed to use mobile devices in workplace and con-
nect to enterprise assets. Cisco surveyed that 51% of
end users rely on smartphones to perform their daily
business activities in 2013 [1]. This trend will continue

Permission to freely reproduce all or part of this paper for non-
commercial purposes is granted provided that copies bear this notice
and the full citation on the ﬁrst page. Reproduction for commercial
purposes is strictly prohibited without the prior written consent of the
Internet Society, the ﬁrst-named author (for reproduction of an entire
paper only), and the author’s employer if the paper was prepared
within the scope of employment.
NDSS ’15, 8-11 February 2015, San Diego, CA, USA
Copyright 2015 Internet Society, ISBN 1-891562-38-X
http://dx.doi.org/10.14722/ndss.2015.23263

to inﬂuence the design and usage of mobile devices in
the enterprise environments. While users are blurring the
lines between company and personal usage, enterprises
demand a secure and robust mobile device management
to protect their business assets. For instance, in a building
that forbids any audio recording, all mobile devices’
microphones should be disabled when the users check
in the building and be enabled when the users check
out.

The permission model on Android, the largest mobile
platform with a market share of 81% [2], only grants
an “all-or-nothing” installation option for mobile users
to either accept all the permissions an app asks for or
simply decline to install the app. After installation, the
app can keep accessing the approved system resources
all the time. In Android 4.3, an experimental feature
called “App Ops” [3] is added to permit mobile users
to conﬁgure one app’s runtime permissions. However,
this feature has been removed from Android 4.4.2 due
to “the increasing burden for user conﬁguration and the
impacts on advertisement market” [4]. SEAndroid has
evolved from Permissive mode in Android 4.2 and 4.3
to Enforcing mode in Android 4.4 and later to provide
ﬂexible mandatory access control (MAC) mechanism in
the Linux kernel. However, until now, even the newest
Android 5.0 has not fully integrated MAC mechanism
in Android middleware [5]. Moreover, SEAndroid is
not available on legacy systems running old versions of
Android.

Since Android 2.2, Google provides Device Adminis-
tration APIs [6] to help enforce enterprise security poli-
cies; however, these APIs only provide a limited set of
functionalities that vary among different Android releas-
es. The Mobile Device Management concept (MDM) [7]
has also been introduced to enterprise administrators
for a long time; however, OEMs usually develop their

own proprietary MDM solutions [8], [9]. For instance,
Samsung Knox provides a complete enterprise solution,
including secure boot, kernel
integrity checking, and
SEAndroid [9]; however, it is only available on Samsung
devices [10].

In this paper, we propose an enterprise-level security
policy enforcement mechanism called DeepDroid that
can be easily ported on various Android devices to
dynamically enforce a ﬁne-grained system service and re-
source access control policy by enterprise administrators.
The basic idea is to apply dynamic memory instrumen-
tation on the app runtime environment in Android. All
current versions of Android share a common structure
feature that system services and resource access are
controlled by a small number of system processes. Thus,
we only need to instrument these system processes whose
structures are almost the same on all Android versions.
DeepDroid dynamically hooks system server process in
Android and uses it as a centralized controller to enforce
the enterprise-level permissions when an app requests to
access a system service. It also tracks the zygote process
to authorize native code’s access requests. Moreover,
DeepDroid can intercept the Binder interactions between
apps and a few system processes to retrieve details of
apps’ requests for a ﬁne-grained access control.

DeepDroid needs root privilege to instrument and
track system processes. It can be satisﬁed in a corporate
environment where companies usually either rent or
purchase mobile devices from telecommunication com-
panies and request vendors to customize the software
image before distributing the devices to employees. S-
ince DeepDroid does not need to statically change the
Android middleware and the Linux kernel, it carries little
burden on vendors for device customization.

Our enterprise-level policy enforcement solution has
several good properties. First, it is portable. Our solution
can be deployed on almost all Android mobile devices
with very small customization efforts. Instead of tailoring
various Android systems from different OEMs, we use
dynamic instrumentation and process tracing techniques
to hook the Android app runtime environment. The code
base of our system remains largely unchanged when
deployed on different Android versions. Our solution
only requires minimal conﬁguration changes in Android
OS during the installation stage and does not need any
changes on any app. We have evaluated our system on a
variety of Android devices from different OEMs running
Android 2.3 through Android 4.4.

Second,

it

is ﬂexible

to provide ﬁne-grained
enterprise-level control over each app. The enterprise
administrators can dynamically update the policy rules
for each mobile device’s individual app. We cannot only
enforce a general rule to constrain one speciﬁc service/re-
source access for an app, but also achieve a context-
aware access control by inspecting the communications
between apps and service processes through Android
Binder. In this paper, we focus on providing security
mechanisms instead of developing detailed policy rules
given an enterprise’s security requirements.

Finally, it has minimal impacts on user experience.
DeepDroid is transparent to mobile users and supports
location-aware automatic conﬁguration. For instance, the
enterprise policy enforcement mechanism only needs to
be enabled when a user enters the workplace; when the
user leaves the workplace, the policy enforcement mech-
anism can be automatically disabled. Moreover, since
our mechanism only needs to instrument a very small
number of critical Android processes and perform simple
checkings, it has negligible performance overhead.

In summary, we make the following contributions.
• We solve the portability problems of enforcing
enterprise’s security policies on various Android de-
vices. Our approach is based on dynamic code instru-
mentation and process tracing, which enforce access
control policies in Android middleware and Linux
kernel, respectively. Our system can be ported on
different Android mobile devices with small changes.
• We can achieve a ﬁne-grained control policy over
each Android app. By hooking and tracing critical
Android components, we can extract request details to
better regulate one app’s operations. Thus, it enables
enterprise administrators to set ﬁne-grained policy
rules considering temporal and spatial constraints for
each app.
• We minimize the impacts of our mechanism on
Android system. Only a few critical processes (e.g.,
system server) need to be dynamically instrumented
in their memory spaces, and the performance overhead
is minimal. Also,
its impacts on Android system
is temporary and can be easily removed when the
policies are no longer desired. It is compatible with
the existing permission mechanism.
• We develop a DeepDroid prototype and evaluate
its effectiveness and efﬁciency on a number of main-
stream Android devices with various Android versions.
The evaluation results show that DeepDroid can work

2

process ensures that supplementary groups are properly
set to the app process by initiating setgroups. Next, the
app’s process will have the privilege to access resources
available to those groups.

III. GOALS, CHALLENGES AND ASSUMPTIONS
DeepDroid targets at effectively enforcing enterprise
security policies on Android devices, and it is designed
to meet the following goals:

Portability. Our scheme should be easily deployed to
various Android versions and different Android mobile
devices. Current state-of-the-art solutions add proprietary
enterprise mobile management interfaces into Android
source code, so the interfaces are typically customized
to speciﬁc Android versions and devices. When one
company wants to adopt one mobile device that has not
integrated the management interfaces, the development
cost will increase and the delivery time will be extended.
Our goal is to support various kinds of Android devices
through making minimal conﬁguration changes.

Fine granularity. Our scheme should support ﬁne-
grained service and resource access control on individual
apps. It cannot only supervise the permission privileges
of an app, but also regulate the service provision proce-
dure. Thus, our solution can support various enterprise
policies. For instance, during working hours, SMS is
only allowed between employees. In this case, we need
to limit
the receiver of a SMS message rather than
prohibiting all SMS messages blindly. Location Based
Service (LBS) apps may lead to location privacy leakage;
however, blindly forbidding location related operations
may generate except signals, which leak the information
that the user may be at workplace. This problem can
be solved by regulating each location operation and
replacing some sensitive locations with fake information.
Trustworthy. All access control policy rules should
be completely enforced, so that malicious apps cannot
violate any rules. We trust the Android middleware and
the low-level Linux kernel. In Android, resource access
operations through system services are controlled by
Android permission mechanism; however, an app may
access resources using native system calls that totally
bypass the permission checking. Thus,
to assure all
resource accesses are being supervised, our scheme must
enforce the policy rules in both Android middleware and
Linux kernel layers.

Ease of use. Our mechanism could be promptly acti-
vated and deactivated according to the enterprise policy

settings. For instance,
it should be quickly activated
when the user enters the workplace and removed imme-
diately when the user leaves the workplace. Moreover,
its impacts on Android system performance should be
minimal.

DeepDroid requires root privilege for installation.
This requirement is common among enterprise mobile
management solutions, and typically the root privilege
can be obtained from OEMs. With OEM support, since
DeepDroid does not change the framework and the
kernel of Android system, its installation is simple and
straightforward. We assume the enterprise administrators
can be trusted. Some keying material is shared between
the smartphone and enterprise policy center to generate
secret keys for communication protection. We assume
the keying material is well protected and secure.

We assume the Android OS kernel can be trusted.
Users have the freedom to install their favorite apps on
their Android smartphones. Though some apps may be
malicious, we assume they cannot compromise the OS
kernel or get the root privilege. A malicious or uncoop-
erative device user may attempt to disable our policy
enforcement mechanism, so we should guarantee that
DeepDroid is reliably active in the workplace. DeepDroid
opens a management interface for policy enforcement,
which may increase the attack surface for some new
attacks misusing the interface.

IV. DEEPDROID SYSTEM ARCHITECTURE

DeepDroid consists of two parts: Enterprise Policy
Center and DeepDroid On-device, as shown in Figure 2.

A. Enterprise Policy Center

Enterprise Policy Center consists of three modules
to authenticate the mobile devices, distribute enterprise
policies, and monitor the mobile devices, respectively.
The authentication module is responsible for authen-
ticating the mobile devices. After being successfully
authenticated, a device can share a temporary secret
key with enterprise policy center. A policy repository
provides policy rules according to enterprise’s security
requirements and the user’s role. Since all communica-
tions between the policy center and the mobile device
are protected by the secret key, the policy rules can
be securely distributed to mobile devices. Moreover, the
status of mobile devices should be continuously reported
to the policy center for logging and auditing purpose.
Particularly, the policy center can use encrypted heartbeat

4

TABLE II: Binder Resource Accessing Interfaces

Resource

IMEI
Phone #
location
contacts*
camera
account

Process
phone
phone

system server
system server
mediaserver
system server

SMS/MMS

phone

Service

iphonesubinfo
iphonesubinfo

location
activity

media.camera

account

isms

Function

Code

getDeviceInfo
getLine1Number

getLastKnownLocation

getContentProvider

connect

getAccounts

sendText

1
5
17
29
3
4
5

it is difﬁcult to deﬁne and enforce policy criterion on
high volume media-related resources (such as camera and
audio) without an efﬁcient support on image or voice
recognition. It is much easier for apps using Android
APIs to perform operations like locating or photograph-
ing. However, an App may have multiple ways to bypass
it using normal Android APIs. To solve this problem, we
can extend DeepDroid with a behavior detection model
similar to what has been proposed in FireDroid [14].

D. Native Code Context Enforcement

The process creation guard in Section V-B constrains
the access privileges of native operations with a course-
grained Granted or Denied decision; however, enterprises
may request a more ﬁne-grained control on native op-
erations. For instance, instead of disconnecting an app
completely from the Internet, the app may be allowed
to access some speciﬁc trusted web servers. Therefore,
besides conﬁguring inet group, we develop a native
code context enforcement module to regulate network
accessing operations by conﬁning the context of socket
calls, such as connect, recvfrom and sendto.

is important

We trace system calls of the target process to con-
strain its native behaviors. Since it
to
guarantee that the tracing code is executed before any
operation of target process, we must detect the launching
of the target process and monitor the process through
its entire life cycle. To achieve this goal, we trace fork
calls of the processes (e.g., zygote, adbd) that are in
charging of new app process creation and then map
newly created processes to applications by matching
their uid. Once the target app is identiﬁed, system calls
of its process tree are traced recursively by setting
ptrace options including TRACEFORK, TRACEVFORK
and TRACECLONE. Since our module works as a tracer
on a target process, when the target process is attached
successfully, the tracer can receive signals at both the
entry and exit of system calls, and meanwhile the target

process is suspended after entering syscall-enter-stop
and syscall-exit-stop. We maintain a ﬂag for each target
process to distinguish its system call entries from system
call exits. In a typical work ﬂow, this module ﬁrst uses
ptrace to extract CPU register information of a suspended
target. According to routines of ARM Procedure Call
Standard [15], the parameters of system calls are stored
in registers R0∼R3 and SP, and the result of a system
call is always stored in register R0. Therefore, our traces
can easily parse the parameters and return value of the
system calls. According to the policy rules, we can either
simply decline a resource access request or send a fake
return value.

Again, our work focuses on providing a mechanism
to support native code context enforcement, instead of
designing detailed policy rules. For various applications,
different parsers may be required to inspect their unique
context information. For instance, to restrict datagram
communication with a certain remote server, we need
to regulate system calls like sendto, sendmsg, recvmsg
and recvfrom. At the entry of sendto, the destination
address is extracted from sockaddr structure. Then, the
system calls can go through if the destination address
is valid or be stopped otherwise. Similarly, at the exit
of recvfrom, we can recognize received buffer data and
mask its content accordingly.

VI. DEEPDROID EVALUATION

Our goal of DeepDroid evaluation is threefold: (1) to
demonstrate that security policies on resource accessing
can be effectively enforced; (2) to demonstrate that
DeepDroid can be easily deployed to various Android
platforms, and (3) to measure its performance overhead.
We also analyze security and reliability of DeepDroid.

A. Functional Evaluation

To test the effectiveness of DeepDroid, we choose
the prevalent resources of Android identiﬁed in [13]

9

TABLE III: Tested Resources

Resource

Permission

Group

IMEI
Phone #
location
contacts
camera
account

logs

network

SMS/MMS message

READ PHONE STATE
READ PHONE STATE

ACCESS FINE LOCATION

READ CONTACTS

CAMERA

GET ACCOUNTS

READ LOGS
SEND SMS
INTERNET

camera

log

inet

PEP1
package
package
package
package

package

PCG

package

package/PCG

package/PCG

Result2

√
√
√
√
√
√
√
√
√

1 PEP is the policy enforcement point.
2 The policy is enforced either in package service or by Process Creation Guard (PCG).

and run a number of popular apps that access these
resources. For each resource, 5 most widely used apps
that access this resource are chosen from Google Play. In
our experiment, we manually instrument each resource
related method call to check if the operations can be
successfully regulated when we activate DeepDroid to
prohibit accessing this resource. Table III shows the e-
valuation results, which verify that all resource accessing
operations are controlled effectively.

B. Portability Evaluation

We run DeepDroid on a series of smart phones
with Android OS from version 2.3 to 4.x. As Table IV
summarizes, DeepDroid can be successfully deployed on
mainstream commercial Android devices with very small
system modiﬁcation.

1) Permission Enforcement Overhead: Permission en-
forcement overhead is mainly introduced by Permission
Conﬁgurator in the system server and behavior moni-
toring from binder interception. Permission Conﬁgurator
overrules system original permission checking procedure
with enterprise permission rules, and the Binder wrapper
parses the binder messages to perform app’s behavior
monitoring.

Since most benchmarks focus on overhead of the
entire process or the whole system, we need to design a
mechanism to benchmark the overhead of permission en-
forcement operations. To minimize measurement errors,
we choose sensitive operations that do not depend on a
certain hardware module or volatile surroundings (e.g.,
stability of network signal). As shown in Table V, we
construct a test case from a subset of prevalent resources
described in [13].

TABLE IV: DeepDroid Portability

TABLE V: Tested Permission Checking Transactions

Device

Nexus S(Samsung)

Sony LT29i

Galaxy Nexus(Samsung)
Samsung Galaxy Note II
Samsung Galaxy Note 3

Nexus 5(LG)
Meizu MX II

HUAWEI Honor 3c

Android

Android OS 2.3.6
Android OS 4.1.2
Android OS 4.2.2
Android OS 4.0
Android OS 4.1
Android OS 4.3
Android OS 4.4

Flyme 3.21

Android OS 4.2

Result

√
√
√
√
√
√
√
√
√

1 Flyme 3.2 is a customized version of Android OS 4.2.1

C. Performance Evaluation

DeepDroid’s system overhead is mainly introduced
by the operations on permission enforcement, binder
message interception, and system call tracing. Since a
permission checking is always accompanied by a binder
transaction, we combine the ﬁrst two overhead factors.

10

Class

phone state

contacts

SMS

messages

Permission

android.permission.

READ PHONE STATE

android.permission.
READ CONTACTS
android.permission.

SEND SMS

Trigger Point

TelephonyManager.

getDeviceId

ContentResolver.

SmsManager.

sendTextMessage

query(Phone.CONTENT URI...)

We evaluate the performance by initiating resource
access operations that require a permission checking
procedure in the following scenarios.
• Normal mode (S). The tested apps are granted re-
quired permissions by original permission mechanism
and the trigger points are executed successfully.
• Intercepted mode (S). The tested apps are granted
required permissions by Permission Conﬁgurator and
the trigger points are intercepted and monitored by the
binder.
• Normal mode (F). The tested apps are denied required

D. Security Analysis

Our system can ensure an enterprise security policy
enforcement on Android device through dynamic mem-
ory instrumentation of several critical system processes.
Malicious apps. DeepDroid may allow device users
to install their favorite apps on their Android smart-
phones. Some apps may be malicious and target at com-
promising our policy enforcement mechanism. However,
since the user-level malicious processes are securely
isolated into separate containers, they cannot manipulate
the code or the control ﬂow of DeepDroid unless they
have the root privilege, which is strictly protected and
monitored by enterprise administrators. We assume the
Android OS can be trusted. Therefore, without the root
privilege, malicious apps cannot compromise our mech-
anism.

Permission escalation attacks. An Android system
may suffer from permission escalation attacks, such as
confused deputy attack and collusion attack [18], [19],
[20]. In confused deputy attack, a malicious application
exploits the vulnerable interfaces of another privileged
(but confused) application to perform unauthorized op-
erations. This kind of attack usually happens when a
privileged app unintentionally exposes interfaces of sen-
sitive operation to an app without required permissions.
In collusion attack, malicious apps collude and combine
their permissions in order to perform actions beyond their
individual privileges. DeepDroid can be used to regulate
two apps’ communications that go through the binder
and system calls; however, if two apps may communicate
through some covert channels that are out of the control
of DeepDroid, we need to deploy other mechanisms to
help remove the covert channels.

Uncooperative user. Some employees may be re-
luctant to conform to enterprise’s security policies due
to various reasons, and they may simply deactivate our
system. Therefore, it is critical to guarantee that Deep-
Droid is correctly running on employees’ mobile devices,
and we use heartbeat messages to prove it. Therefore,
a mobile device that stops sending encrypted heartbeat
messages will trigger further investigation. Moreover, we
can use software based attestation approach [21], [22],
[23] to make sure the integrity of DeepDroid. On the
mobile platforms with TrustZone hardware support [24],
we can also use TrustZone to keep monitoring the
integrity of DeepDroid, similar to what has been done
in Knox [9].

DeepDroid misuse. An attacker may impersonate the

enterprise administrators to send false policy rules to the
mobile devices; however, since the attacker cannot obtain
the keying material shared between the device and the
enterprise server, it cannot perform this type of attacks.
DeepDroid exposes one control
interface of Android
system to third parties; however, since the code base of
DeepDroid is small and may be formally veriﬁed, the
attacker can hardly misuse our mechanism to attack the
system. Moreover, since all the communications between
the trusted enterprise server and the mobile device are
protected by a shared secret key, an external attacker
cannot steal the policy rules through eavesdropping.

VII. DISCUSSION

At Google I/O 2014 conference, Android L was un-
veiled and the previously experimental Android Runtime
(ART) [25] has replaced Dalvik as a default environment.
ART compiles byte code into executable ELF only once
during app installation. In spite of the runtime transfor-
mation, foundations of DeepDroid, including permission
mechanism, system service architecture, and binder IPC,
are barely changed. In other words, DeepDroid can
be easily ported to ART. Only the implementation of
runtime method interception in section V-A needs to be
changed accordingly. In ART, the .oat executable ﬁle
compiled from Java byte code is mapped into process by
calling dlopen function, and all Methods refer to their
native code in oatexec segment of .oat. ART runtime
method interception can be achieved by native code
inline-hooking. Hence, DeepDroid can also work on
ART-enabled devices with little modiﬁcation.

DeepDroid requires root privilege for installation.
This requirement is common among enterprise mobile
management solutions, and usually the root privilege can
be obtained from OEMs. With OEM support, DeepDroid
installation is simple and straightforward. OEMs only
need to modify the “init.rc” ﬁle and import DeepDroid as
a service. Then DeepDroid can run with a root privilege
and all other Android security features remain intact.
Since DeepDroid does not change the framework and
the kernel of Android system, the above conﬁguration
incurs very little impact on OEMs. Some other work
such as FireDroid [14] adopts a similar idea to obtain
root privilege from OEMs. Alternatively, with the support
of ARM TrustZone mechanism [24], DeepDroid may
use the secure domain for the installation in the normal
domain.

There exists a number of system access control solu-
tions for enterprise management, but our solution has

12

some advantages when comparing to those solutions,
particularly, SELinux [26] and Knox [9]. SEAndroid
enforces mandatory access control (MAC) in Android
kernel. Android’s support for SELinux has evolved from
permissive in 4.3 to full enforcement in 5.0 (L). SELinux
enhances system security by conﬁning privileged pro-
cesses and enforce policies on various domains. How-
ever, it is unavailable or disabled by default on Android
versions older than 4.4. Thus, old devices cannot be well
protected by SEAndroid. Moreover, it requires manufac-
turers to have a better understanding of SELinux im-
plementations. Until now, SEAndroid has not been fully
supported since Android 5.0 does not include middleware
MAC mechanism [5]. On the contrary, DeepDroid does
not rely on any unique kernel features and thus works
well on almost all Android versions and platforms. We
may enhance the security of DeepDroid with SEAndroid
mechanism.

Samsung Knox has risen up to provide a complete
enterprise solution. It focuses on providing capabili-
ties including Trusted Boot, TrustZone-based Integrity
Measurement Architecture (TIMA), SE for Android,
and Knox container, to protect Android system from
adversaries and isolate different working scenarios [9].
Through secure boot and kernel integrity checking, Knox
can ensure a trusted OS in the normal world based on
ARM TrustZone hardware. As for policy enforcement,
Knox integrates SEAndroid and provides management
APIs to customize security policies. Despite that Knox
APIs are integrated into Android 5.0 [27], its adoption
is limited to Samsung devices [10]. Moreover, Knox
requires ARM TrustZone hardware support, which limits
its deployment to only certain Android platforms. Our
DeepDroid system is a software-based solution that can
be deployed on almost all Android platforms. Mean-
while, on TrustZone-enabled platforms, DeepDroid may
utilize TrustZone to obtain the root privilege of the
normal domain and protect the integrity of the rich OS
in the normal domain.

VIII. RELATED WORK

Enterprise demands system resource access control
interfaces in Android when employees are equipped
with Android smartphone in workspace. Android access
control mechanisms can be generally categorized into
four classes by their technical approaches.

Modifying Android source code. Android source
code can be directly modiﬁed to support new access

control mechanisms when we can access the source code
for the enterprise-customized Android system. Because
Android permission framework does not provide ﬂexible
runtime conﬁguration interface [28] and permission priv-
ilege leaks happen to commercial images [20], several
security extensions have been proposed to the permission
framework [29], [30], [31], [32], [33], [26], [34], [13],
[35], [36]. Apex [29] enables users to grant a selected set
of permissions and supports user-deﬁned restrictions on
apps. CRePE [30] can enforce ﬁne-grained permission
policies by using context
information of the mobile
devices. By introducing a privacy mode, TISSA [31] em-
powers users to deﬁne what kinds of personal informa-
tion are accessible to apps. To mitigate security problems
aroused by a certain third-party component, Compac [32]
manages to distribute a narrowed set of permissions to
one component. While the above approaches focus on
protection of system resources, Saint [33] provides an
infrastructure that protects apps’ interfaces and resources.

Another way to enhance access control is achieved
by introducing Security Enhanced Linux (SELinux). A
ﬂexible mandatory access control (MAC) can be support-
ed on both Android’s middleware and kernel layers [26],
[34]. Besides directly hardening access control system,
privacy data can be further protected by being replaced
with some dummy data before providing it to apps [13].
TaintDroid [35] monitors usage of sensitive data by
dynamic taint tracking and analysis. Based on Taintdroid,
TreeDroid
[36] presents a novel scheme to monitor
security policies on data processing.

Since all these approaches require Android source
code modiﬁcation, they have portability problem due to
the high cost incurred when customizing a speciﬁc An-
droid branch from different OEMs. Our system performs
dynamic memory instrumentation on the stable Android
structures, so it can be deployed similarly on various
Android versions.

Rewriting apps. Compared with modifying Android
system code, app code can be rewritten to ensure a
resource access policy. Due to good portability, enforcing
security on apps themselves becomes a competitive ap-
proach. It is mainly implemented by integrating security
measures into Android app with app rewriting.
[37]
enables identifying and interposing of Security Sensitive
APIs by dalvik bytecode rewriting. [38] supports retroﬁt
of app’s behaviors by static and dynamic method inter-
ception. [39] is an on-the-phone instrumentation scheme,
which enables ﬂexible policies on apps by intercepting

13

high-level java calls. Security policies of [40] are en-
forced by low-level libc.so rewriting.

Interactions between an app and Android system can
be recovered from system calls. [41] helps to perfor-
m ﬁne-grained permissions on resource accessing by
introducing a new module that supports parameterized
permissions. Any access to sensitive resources from apps
is forwarded to this module. To support behavior study-
ing, [42] allows user to insert instrumentation code into
an app from a high-level of abstraction. App rewriting
is an effective way that requires no modiﬁcation to
Android ROM. However, incomplete implementations of
bytecode rewriting may result in several potential attack-
s [43]. It is difﬁcult to assure that all apps are rewritten
which is critical to enterprise security management. In
addition, due to signature difference of repackaging
process, all history information of the original app cannot
be shared by the rewritten app.

Isolating business apps. Besides adding extra control
measures on Android system or apps, creating an isolated
secure domain is another promising solution for running
business related apps. It divides all user apps into two
categories: personal apps and business apps. Business
apps are running in a secure isolated environment,
and thus attacks originated from personal domain can
be blocked out. Trustdroid [44] is an isolation frame-
work based on modifying Android system source code.
KNOX [45] provides a complete enterprise management
solution including an integrity checking component in the
secure domain. All these solutions do not directly aim
at enforcing enterprise security policies on employee’s
mobile device. It also has the portability problem due to
the changing of Android system or hardware supports.
Modifying Android runtime. Our system relies on
dynamically modifying the Android runtime environ-
ment. Patchdroid [46] uses a similar technique to apply
security patches for the entire Android system, while
our work focuses on enforcing enterprise policies on all
installed apps.

IX. CONCLUSIONS

of process structures in various versions. Thus, Deep-
Droid may be deployed on various Android versions
with a similar installation procedure. Since DeepDroid
can regulate each app’s service access operations by
intercepting Binder transactions and tracing system calls,
it can achieve a ﬁne-grained context-aware policy en-
forcement. The evaluation results of a prototype show
that DeepDroid can work effectively on various Android
platforms with negligible performance overhead.

X. ACKNOWLEDGMENT

The authors would like to thank the shepherd, Xi-
aofeng Wang from Indiana University, and the anony-
mous reviewers for their valuable comments and sug-
gestions. This work is partially supported by National
973 Program of China under award No. 2013CB338001
and No. 2014CB340603. Dr. Kun Sun’s work is sup-
ported by U.S. Ofﬁce of Naval Research under award
number N00014-11-1-0471 and U.S. Army Research
Ofﬁce under Grant W911NF-12-1-0448. This paper’s
corresponding author is Yuewu Wang.

REFERENCES

[1]

[2]

[3]

[4]

[5]

[6]

[7]

4.3’s

hidden

app

ops: Android

permission
individual apps!” http:

“Cisco global work your way study,” http://www.cisco.
com/c/dam/en/us/solutions/collateral/borderless-networks/
uniﬁed-access/ua survey infographic.pdf.
“Android pushes past 80156.0http://www.idc.com/getdoc.jsp?
containerId=prUS24442013.
“App
manager, control permissions for
//www.androidpolice.com/2013/07/25/app-ops-android-4-3s/
hidden-app-permission-manager/-control-permissions-for/
-individual-apps/.
“App
4.4.2
App-Ops-removed-by-Google-in-Android-4.4.2-update
id50340/.
“Merge
html.
“Device administration,” http://developer.android.com/guide/
topics/admin/device-admin.html.
“Mobile device management,” http://en.wikipedia.org/wiki/
Mobile device management.

android
http://www.phonearena.com/news/

http://seandroid.bitbucket.org/MergeStatus.

removed

update,”

status,”

ops

by

google

in

[8] Samsung, “Samsung For Enterprise,” http://www.samsung.

com/us/business/samsung-for-enterprise/index.html.

In this paper, we present a mechanism named Deep-
Droid to enforce enterprise security policy on Android
devices. DeepDroid provides good properties including
portability, ﬁne-grained control, and minimal perfor-
mance overhead through dynamically injecting control
code into Android framework, which has a stable set

[10]

[11]

[12]

14

[9] S. Electronics, “Samsung KNOX,” http://www.samsung.com/

supported

workspace

global/business/mobile/solution/security/samsung-knox.
“Knox
devices,”
//www.samsungknox.cn/en/solutions/knox/technical/
knox-supported-devices.
“Openbinder,” http://www.angryredplanet.com/ hackbod/open-
binder/docs/html/.
“System permissions,”
topics/security/permissions.html.

http://developer.android.com/guide/

https:

[33] M. Ongtang, S. McLaughlin, W. Enck, and P. McDaniel,
“Semantically rich application-centric security in android,”
Computer Security Applications Conference, Annual, 2009.

[34] S. Bugiel, S. Heuser, and A.-R. Sadegh, “Flexible and Fine-
Grained Mandatory Access Control on Android for Diverse
Security and Privacy Policies,” in 22nd USENIX Security
Symposium (USENIX Security ’13), 2013.

[35] W. Enck, P. Gilbert, B. gon Chun, L. P. Cox, J. Jung,
P. McDaniel, and A. Sheth, “TaintDroid: An Information-
Flow Tracking System for Realtime Privacy Monitoring on
Smartphones,” in OSDI, 2010, pp. 393–407.

[36] A. L. Mads Dam, Gurvan Le Guernic, “Treedroid: A tree au-
tomaton based approach to enforcing data processing policies,”
in CCS, 2012.

[37] B. Davis, B. S, A. Khodaverdian, and H. Chen, “I-arm-
droid: A rewriting framework for in-app reference monitors for
android applications,” in In Proceedings of the Mobile Security
Technologies 2012, MOST 12. IEEE, 2012.

[38] B. Davis and H. Chen, “RetroSkeleton: Retroﬁtting Android
Apps,” in Proceeding of the 11th Annual International Confer-
ence on Mobile Systems, Applications, and Services, 2013.

[39] M. Backes, S. Gerling, C. Hammer, M. Maffei, and P. von
Styp-Rekowsky, “AppGuard: Enforcing User Requirements on
Android Apps,” in Proceedings of the 19th International Con-
ference on Tools and Algorithms for the Construction and
Analysis of Systems, 2013.

[41]

[40] R. Xu, H. Sa¨ıdi, and R. Anderson, “Aurasium: Practical Policy
Enforcement for Android Applications,” in Proceedings of the
21st USENIX Conference on Security Symposium, 2012.
J. Jeon, K. K. Micinski, J. A. Vaughan, A. Fogel, N. Reddy,
J. S. Foster, and T. Millstein, “Dr. Android and Mr. Hide: Fine-
grained Permissions in Android Applications,” in Proceedings
of the Second ACM Workshop on Security and Privacy in
Smartphones and Mobile Devices, 2012.

[42] S. Hao, D. Li, W. G. Halfond, and R. Govindan, “SIF: A S-
elective Instrumentation Framework for Mobile Applications,”
in Proceeding of the 11th Annual International Conference on
Mobile Systems, Applications, and Services, 2013.

[43] H. Hao, V. Singh, and W. Du, “On the Effectiveness of API-
level Access Control Using Bytecode Rewriting in Android,”
in Proceedings of the 8th ACM SIGSAC Symposium on Infor-
mation, Computer and Communications Security, 2013.

[45] Samsung Electronics,

[44] A. D. S. H. A.-R. S. B. S. Sven Bugiel, Lucas Davi, “Practical
and lightweight domain isolation on android,” in SPSM, 2011.
“White Paper: An Overview of
Samsung KNOX,” http://www.samsung.com/global/business/
business-images/resource/white-paper/2013/06/Samsung
KNOX whitepaper June-0.pdf.

[46] C. Mulliner, J. Oberheide, W. Robertson, and E. Kirda, “Patch-
Droid: Scalable Third-party Security Patches for Android De-
vices,” in Proceedings of the 29th Annual Computer Security
Applications Conference, 2013.

[13] P. Hornyack, S. Han, J. Jung, S. Schechter, and D. Wetherall,
“These aren’t the droids you’re looking for: Retroﬁtting android
to protect data from imperious applications,” in Proceedings of
the 18th ACM Conference on Computer and Communications
Security, ser. CCS ’11, 2011.

[15]

[14] G. Russello, A. B. Jimenez, H. Naderi, and W. van der Mark,
“FireDroid: Hardening Security in Almost-stock Android,” in
Proceedings of the 29th Annual Computer Security Applica-
tions Conference, 2013.
http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042e/
IHI0042E aapcs.pdf.
“Caffeinemark 3.0,” http://www.benchmarkhq.ru/cm30/.
“Quadrant
apps/details?id=com.aurorasoftworks.quadrant.ui.standard.

standard edition,” https://play.google.com/store/

[16]
[17]

[18] A. D. T. F. A.-R. S. B. S. Sven Bugiel, Lucas Davi, “Towards
taming privilege-escalation attacks on android,” in NDSS, 2012.
[19] A. P. Felt, H. J. Wang, A. Moshchuk, S. Hanna, and E. Chin,
“Permission Re-Delegation: Attacks and Defenses,” in USENIX
Security Symposium, 2011.

[20] Z. W. X. J. Michael Grace, Yajin Zhou, “Systematic detection

of capability leaks in stock android,” in NDSS, 2012.

[21] V. K. Y. K. Mark Shaneck, Karthikeyan Mahadevan, “Remote
software-based attestation for wireless sensors,” Security and
Privacy in Ad-hoc and Sensor Networks, vol. 3813, pp. 27–41,
2005.
v. D. L. K. P. Seshadri. A, Perrig A, “Swatt: software-based
attestation for embedded devices,” in IEEE Symposium on
Security and Privacy, 2004.

[22]

[23] M. Dietz, S. Shekhar, Y. Pisetsky, A. Shu, and D. S. Wallach,
“Quire: Lightweight Provenance for Smart Phone Operating
Systems,” in Proceedings of the 20th USENIX Conference on
Security, 2011, pp. 23–23.

[24] T. Alves and D. Felton, “TrustZone: Integrated hardware and

software security,” ARM white paper, vol. 3, no. 4, 2004.
http://source.android.com/devices/tech/dalvik/art.html.

[25]
[26] S. Smalley and R. Craig, “Security Enhanced (SE) Android:

[27]

Bringing Flexible MAC to Android,” in NDSS, 2013.
“A closer look at knox contribution in android,” https://www.
samsungknox.cn/en/androidworkwithknox.

[28] X. Wei, L. Gomez, I. Neamtiu, and M. Faloutsos, “Permis-
sion Evolution in the Android Ecosystem,” in Proceedings of
the 28th Annual Computer Security Applications Conference,
2012.

[29] M. Nauman, S. Khan, and X. Zhang, “Apex: Extending An-
droid Permission Model and Enforcement with User-deﬁned
Runtime Constraints,” in Proceedings of the 5th ACM Sympo-
sium on Information, Computer and Communications Security,
2010.

[30] M. Conti, V. T. N. Nguyen, and B. Crispo, “CRePE: Context-
related Policy Enforcement for Android,” in Proceedings of the
13th International Conference on Information Security, 2011.
[31] X. J. Yajin Zhou, Xinwen Zhang and V. W. Freeh, “Taming
Information-Stealing Smartphone Applications (on Android),”
in In: Trust and Trustworthy Computing, 2011.

[32] Y. Wang, S. Hariharan, C. Zhao, J. Liu, and W. Du, “Compac:
Enforce Component-level Access Control in Android,” in Pro-
ceedings of the 4th ACM Conference on Data and Application
Security and Privacy, 2014.

15

