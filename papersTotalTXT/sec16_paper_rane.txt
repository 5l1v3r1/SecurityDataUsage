Secure, Precise, and Fast Floating-Point  

Operations on x86 Processors

Ashay Rane, Calvin Lin, and Mohit Tiwari, The University of Texas at Austin
 https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/rane

This paper is included in the Proceedings of the 25th USENIX Security SymposiumAugust 10–12, 2016 • Austin, TXISBN 978-1-931971-32-4Open access to the Proceedings of the 25th USENIX Security Symposium is sponsored by USENIX Secure, Precise, and Fast

Floating-Point Operations on x86 Processors

Ashay Rane, Calvin Lin

Department of Computer Science
The University of Texas at Austin

{ashay, lin} @cs.utexas.edu

Mohit Tiwari

Dept. of Electrical and Computer Engineering

The University of Texas at Austin

tiwari@austin.utexas.edu

Abstract
Floating-point computations introduce several side chan-
nels. This paper describes the ﬁrst solution that closes
these side channels while preserving the precision of
non-secure executions. Our solution exploits micro-
architectural features of the x86 architecture along with
novel compilation techniques to provide low overhead.

Because of the details of x86 execution, the evaluation
of ﬂoating-point side channel defenses is quite involved,
but we show that our solution is secure, precise, and fast.
Our solution closes more side channels than any prior so-
lution. Despite the added security, our solution does not
compromise on the precision of the ﬂoating-point oper-
ations. Finally, for a set of microkernels, our solution is
an order of magnitude more efﬁcient than the previous
solution.

1

Introduction

To secure our computer systems, considerable effort has
been devoted to techniques such as encryption, access
control, and information ﬂow analysis. Unfortunately,
these mechanisms can often be subverted through the use
of side channels, in which an adversary, with the knowl-
edge of the program, monitors the program’s execution
to infer secret values. These side channels are signiﬁ-
cant because they have been used to discover encryption
keys in AES [26], RSA [27], and the Difﬁe-Hellman key
exchange protocol [14], thereby rendering these sophis-
ticated schemes useless.

Numerous side channels exist, including instruction
and data caches [27, 26], branch predictors [2], mem-
ory usage [12, 35], execution time [31, 4], heat [22],
power [15], and electromagnetic radiation [9], but one
particularly insidious side channel arises from the exe-
cution of variable-latency ﬂoating-point instructions [3,
10], in which an instruction’s latency varies widely de-
pending on its operands, as shown in Table 1.

Zero Normal

7

11

Subnormal

153

Inﬁnity NaN

7

7

Table 1: Latency (in cycles) of the SQRTSS instruction for
various operands.

Both x861 and ARM2 provide variable-latency
ﬂoating-point instructions. This variable latency stems
from the desire to have graceful ﬂoating-point arithmetic
behavior, which, as we explain in Section 3, requires the
use of so-called subnormal values [8], which are pro-
cessed using special algorithms. Since subnormal values
are rare, hardware vendors typically support such values
in microcode, so as not to slow down the common case.
The resulting difference in instruction latency creates a
timing side channel, which has been used to infer cross-
origin data in browsers and to break differential privacy
guarantees of a remote database [3].

However, variable latency ﬂoating-point instructions
represent only a part of the problem, since higher level
ﬂoating-point operations, such as sine and cosine, are
typically implemented in software. Thus, the implemen-
tation of these ﬂoating-point operations can leak secret
information through other side channels as well. De-
pending on the secret values, programs can throw excep-
tions, thereby leaking the presence of abnormal inputs
through termination. Programs can also contain condi-
tional branches, which can leak secrets through the in-
struction pointer, branch predictor, or memory access
count. Finally, programs that index into lookup tables
can leak secrets through the memory address trace.

To prevent information leaks in both ﬂoating-point in-
structions and ﬂoating-point software, a strong solution
should ensure at least four key properties, which cor-
respond to the side channels that we discussed above:

1http://www.agner.org/optimize/instruction tables.pdf
2http://infocenter.arm.com/help/index.jsp?topic=/com.

arm.doc.ddi0344k/ch16s07s01.html

USENIX Association  

25th USENIX Security Symposium  71

(1) ﬁxed-time operations that are independent of secret
values, (2) disabled exceptions, (3) sequential control
ﬂow, and (4) uniform data accesses that are independent
of the value of secret variables. Previous solutions [3, 5]
are inadequate because they do not ensure all four prop-
erties, are slow, are orders of magnitude less precise, or
are difﬁcult to implement.

This paper presents a novel solution that closes side
channels arising from both hardware and software im-
plementations of ﬂoating point operations, providing all
four properties mentioned above. Our compiler-based
solution has two components.

The ﬁrst component creates building blocks of ele-
mentary ﬂoating-point operations for instructions that are
natively supported by the hardware (addition, subtrac-
tion, multiplication, division, square root, and type con-
version). Our solution leverages unused SIMD lanes so
that fast operations on normal operands are accompanied
by slower dummy computations on subnormal operands,
yielding a consistent yet low instruction latency for all
types of operands.

The second component is a software library of higher-
level ﬂoating-point operations like sine and cosine.
The key to creating this second component is a new
code transformation that produces ﬁxed-latency func-
tions through normalized control ﬂows and data access
patterns. Code generated by our compiler closes digital
side-channels, which have been deﬁned to be those side
channels that carry information over discrete bits [28].
Whereas previous work in closing digital side channels
employs a runtime system [28], our solution shifts much
of the work to compile time, yielding a signiﬁcantly
smaller runtime overhead.

This paper makes the following contributions:

1. We present a novel compiler-based system, called
Escort, for closing digital side channels that arise
from the processing of ﬂoating-point instructions.

2. Secure: We demonstrate that our solution is secure
not just against timing but also against digital side
channels. We demonstrate Escort’s capabilities by
defeating a machine-learning side-channel attack,
by defending against a timing attack on the Firefox
web browser, by conducting extensive performance
measurements on an x86 processor, and by verify-
ing our solution’s code using typing rules.

3. Precise: We show that Escort provides precision
that is identical to that of the standard C math li-
brary. By contrast, the previous solution’s precision
is off by several million ﬂoating-point values.

4. Fast: We show that our solution is fast. On a
set of micro-benchmarks that exercise elementary

ﬂoating-point operations, Escort is 16× faster than
the previous solution [3].

5. As an ancillary contribution, we introduce a
methodology for evaluating the precision and se-
curity of ﬂoating-point operations, which is fraught
with subtleties.

The rest of this paper is organized as follows. Sec-
tion 2 describes our threat model, related work, and sys-
tem guarantees. We provide background in Section 3 be-
fore presenting our solution in Section 4. We evaluate
our solution in Sections 5–7 . Finally, we conclude in
Section 8.

2 Threat Model and Related Work

This section begins by describing our threat model,
which shapes our subsequent discussion of related work
and of Escort’s security guarantees.

Threat Model. Our goal is to prevent secret ﬂoating-
point operands from leaking to untrusted principals that
either read digital signals from the processor’s pins or
that are co-resident processes.

We assume that the adversary is either an external en-
tity that monitors observation-based side channels (e.g.
time [14], memory address trace [11], or the /proc
pseudo-ﬁlesystem [12]) or a co-resident process/VM that
monitors contention-based side channels (e.g. cache [27]
or branch predictor state [2]).

For off-chip observation-based channels, we assume
that the processor resides in a sealed and tamper-proof
chip that prevents the adversary from measuring physi-
cal side channels like heat, power, electromagnetic radi-
ation, etc. We assume that the CPU encrypts data trans-
ferred to and from DRAM. All components other than
the processor are untrusted, and we assume that the ad-
versary can observe and tamper with any digital signal.
For on-chip contention-based channels, we assume that
the OS is trusted and does not leak the victim process’s
secret information. We also assume that the adversary
cannot observe or change the victim process’s register
contents. Our trusted computing base includes the com-
pilation toolchain.

Side-Channel Defenses. Decades of prior research
have produced numerous defenses against side channels,
the vast majority of which close only a limited number
of side channels with a single solution. For instance,
numerous solutions exist that close only the cache side
channel [6, 36, 39, 37, 16] or only the address-trace
side channel [33, 20, 32, 29]. Raccoon [28] is the ﬁrst
solution that closes a broad class of side channels—in

72  25th USENIX Security Symposium 

USENIX Association

particular, the set of digital side channels—with a sin-
gle solution. Similar to Raccoon, Escort also closes
digital side channels with a single solution, but unlike
Raccoon, Escort focuses on closing ﬂoating-point digi-
tal side channels, which can arise from variable latency
ﬂoating-point instructions and from software implemen-
tations of ﬂoating-point libraries, in which points-to set
sizes are typically small. Given Escort’s narrower focus
on ﬂoating-point computations, Escort is faster than Rac-
coon by an order of magnitude.

Timing Side-Channel Defenses. Prior
defenses
against timing side-channel attacks utilize new algo-
rithms [30], compilers [23], runtime systems [21], or
secure processors [18]. However, these solutions only
address one source of timing variations—either those
stem from the choice of the algorithm [31] or those
that stem from the microarchitectural design [10]. By
contrast, Escort closes timing variations from both
sources.

Floating-Point Side-Channel Defenses. Andrysco et
al. [3] present libfixedtimefixedpoint (FTFP), the
ﬁrst software solution for closing the ﬂoating-point tim-
ing channel. FTFP has some weaknesses, as we now
discuss, but the main contribution of their paper is the
demonstration of the signiﬁcance of this side channel,
as they use variable-latency ﬂoating-point operations to
break a browser’s same-origin policy and to break dif-
ferential privacy guarantees of remote databases. FTFP
is a ﬁxed-point library that consists of 19 hand-written
functions that each operates in ﬁxed time, independent
of its inputs. FTFP is slow, it is imprecise, and it ex-
poses secrets through other side channels, such as the
cache side channel or the address trace side channel.
Cleemput et al. [5] introduce compiler transformations
that convert variable-timing code into ﬁxed-timing code.
Their technique requires extensive manual intervention,
applies only to the division operation, and provides weak
security guarantees. Both solutions require manual con-
struction of ﬁxed-time code—a cumbersome process that
makes it difﬁcult to support a large number of operations.
By contrast, Escort implements a ﬁxed-time ﬂoating-
point library, while preventing information leaks through
timing as well as digital side channels. Escort includes a
compiler that we have used to automate the transforma-
tion of 112 ﬂoating-point functions in the Musl standard
C library, a POSIX-compliant C library. Escort also pro-
vides precision identical to the standard C library.

Escort’s Guarantees. Escort rejects programs that
contain unsupported features—I/O operations and recur-
sive function calls. Unlike prior work [18, 28], Escort

does transform loops that leak information through trip
counts. Escort is unable to handle programs contain-
ing irreducible control ﬂow graphs (CFGs), but standard
compiler transformations [24] can transform irreducible
CFGs into reducible CFGs. Escort assumes that the in-
put program does not use vector instructions, does not
exhibit undeﬁned behavior, does not terminate abnor-
mally through exceptions, and is free of race conditions.
Given a program that abides by these limitations, Es-
cort guarantees that the transformed code produces iden-
tical results as the original program, does not leak se-
crets through timing or digital side channels, and that the
transformed code does not terminate abnormally.

3 Background

The variable latency of ﬂoating-point instructions creates
security vulnerabilities. In this section, we explain sub-
normal numbers, which are the cause of the variable la-
tency, and we explain the difﬁculty of ﬁxing the resulting
vulnerability. We also explain how the Unit of Least Pre-
cision (ULP) can be used to quantify the precision of our
and competing solutions.

Next smallest
positive number

Next smallest
positive number

Large gap

10-38

0

. . .
Small gap

10-45

Smallest
positive
number

. . .

Equal gaps
   10-45

0

Smallest
positive
number

(a) Without subnormal values.

(b) With subnormal values.

Figure 1: Impact of allowing subnormal numbers. With-
out subnormal values, there exists a much larger gap be-
tween zero and the smallest positive number than be-
tween the ﬁrst two smallest positive numbers. With sub-
normal numbers, the values are more equally spaced.
(The ﬁgure is not drawn to scale.)

3.1 Subnormal Numbers
Subnormal numbers have tiny exponents, which result
in ﬂoating-point values that are extremely close to zero:
10−45 < |x| < 10−38 for single-precision numbers and
10−324 < |x| < 10−308 for double-precision numbers.
Subnormal values extend the range of ﬂoating-point
numbers that can be represented, but more importantly,
they enable gradual underﬂow—the property that as
ﬂoating-point numbers approach zero along the number
scale, the difference between successive ﬂoating-point
numbers does not increase3. Figures 1a and 1b show the

3https://www.cs.berkeley.edu/∼wkahan/ARITH 17U.pdf

USENIX Association  

25th USENIX Security Symposium  73

differences between zero and the two smallest positive
ﬂoating-point numbers. With subnormal numbers, the
gap between any two consecutive ﬂoating-point values is
never larger than the values themselves, thus exhibiting
Gradual Underﬂow. Subnormal numbers are indispens-
able because gradual underﬂow is required for reliable
equation solving and convergence acceleration [8, 13].

To avoid the added hardware complexity of supporting
subnormal numbers, which occur infrequently, vendors
typically process subnormal values in microcode, which
is orders of magnitude slower than hardwired logic.

The resulting difference in latencies creates a security
vulnerability. An adversary that can measure the latency
of a ﬂoating-point instruction can make reasonable esti-
mates about the operand type, potentially inferring secret
values using the timing channel. While subnormal values
occur infrequently in typical program execution, an ad-
versary can deliberately induce subnormal values in the
application’s inputs to enable subnormal operand timing
attacks.

3.2 Floating-Point Error Measurement
Unlike real (inﬁnite precision) numbers, ﬂoating-point
numbers use a limited number of bits to store values,
thus making them prone to rounding errors. Rounding
errors in ﬂoating-point numbers are typically measured
in terms of the Unit of Least Precision (ULP) [25]. The
ULP distance between two ﬂoating-point numbers is the
number of distinct representable ﬂoating-point numbers
between them, which is simply the result of subtracting
their integer representations. If the result of the subtrac-
tion is zero, the ﬂoating-point numbers must be exactly
the same.

4 Our Solution: Escort

Escort offers secure counterparts of ordinary non-secure
ﬂoating-point operations, including both elementary op-
erations and higher-level math operations. The elemen-
tary operations include the six basic ﬂoating-point op-
erations that are natively supported by the ISA—type
conversion, addition, subtraction, multiplication, divi-
sion, and square root—and a conditional data copy op-
eration. The 112 higher-level math operations are those
that are implemented using a combination of native in-
structions. Examples of higher-level functions include
sine, cosine, tangent, power, logarithm, exponentiation,
absolute value, ﬂoor, and ceiling.

The next subsections describe Escort’s design in three
parts. First, we describe the design of Escort’s secure el-
ementary operations. These operations collectively form
the foundation of Escort’s security guarantees. Second,
we describe Escort’s compiler, which accepts non-secure

code for higher-level operations and converts it into se-
cure code. This compiler combines a code transforma-
tion technique with Escort’s secure elementary opera-
tions. Third, we present an example that shows the syn-
ergy among Escort’s components.

4.1 Elementary Operations
The key insight behind Escort’s secure elementary opera-
tions is that the latencies of SIMD instructions are deter-
mined by the slowest operation among the SIMD lanes
(see Figure 2), so the Escort compiler ensures that each
elementary instruction runs along side a dummy instruc-
tion whose operand will produce the longest possible la-
tency. Our analysis of 94 x86 SSE and SSE2 instruc-
tions (which includes single- and double-precision arith-
metic, comparison, logical, and conversion instructions)
reveals: (1) that only the multiplication, division, square
root, and single-precision to double-precision conver-
sion (upcast) instructions exhibit latencies that depend
on their operands and (2) that subnormal operands in-
duce the longest latency.

In particular, Escort’s ﬁxed-time ﬂoating-point opera-
tions utilize SIMD lanes in x86 SSE and SSE2 instruc-
tions. Our solution (1) loads genuine and dummy (sub-
normal) inputs in spare SIMD lanes of the same input
register, (2) invokes the desired SIMD instruction, and
(3) retains only the result of the operation on the genuine
inputs. Our tests conﬁrm that the resulting SIMD instruc-
tion exhibits the worst-case latency, with negligible vari-
ation in running time (standard deviation is at most 1.5%
of the mean). Figure 3 shows Escort’s implementation of
one such operation.

Escort includes Raccoon’s conditional data copy op-
eration (see Figure 4) which does not leak information
through digital side channels. This operation copies the
contents of one register to another register if the given
condition is true. However, regardless of the condition,
this operation consumes a ﬁxed amount of time, executes
the same set of instructions, and does not access applica-
tion memory.

4.2 Compiling Higher-Level Operations
Escort’s compiler converts existing non-secure code into
secure code that prevents information leakage through
digital side channels. First, our compiler replaces all ele-
mentary ﬂoating-point operations with their secure coun-
terparts. Next, our compiler produces straight-line code
that preserves control dependences among basic blocks
while preventing instruction side effects from leaking se-
crets. Our compiler then transforms array access state-
ments so that they do not leak information through mem-
ory address traces. Finally, our compiler transforms

74  25th USENIX Security Symposium 

USENIX Association

A * B

(intended 
operation)

[next instr.]

e
m

i
t

C * D

(intended 
operation)

[next instr.]

e
m

i
t

 (a) Original

(non-secure) code

After 

transformation

e
m

i
t

A * B

(intended 
operation)

P * Q

(dummy
operation)

e
m

i
t

C * D

(intended 
operation)

P * Q

(dummy
operation)

[next instr.]

[next instr.]

(b) Transformed 

(secure) code

Figure 2: The key idea behind Escort’s secure elementary operations. The operation is forced to exhibit a ﬁxed latency
by executing a ﬁxed-latency long-running operation in a spare SIMD lane.

double escort_mul_dp(double x, double y) {

const double k_normal_dp = 1.4;
const double k_subnormal_dp = 2.225e-322;

double result;
__asm__ volatile(

%1, %%xmm14;"
%2, %%xmm15;"
$8, %1;"
$8, %2;"
%3, %1;"
%4, %2;"
%2, %0;"
%1, %0;"
$8, %0;"
%%xmm14, %1;"
%%xmm15, %2;"

"movdqa
"movdqa
"pslldq
"pslldq
"por
"por
"movdqa
"mulpd
"psrldq
"movdqa
"movdqa
: "=x" (result), "+x" (x), "+x" (y)
: "x" (k_subnormal_dp), "x" (k_normal_dp)
: "xmm15", "xmm14");

return result;

}

01: copy(uint8_t pred, uint32_t t_val, uint32_t f_val) {
02:
03:
04:
05:
06:
07:
08:
09:
10:
11:
12:
13: }

%2, %0;"
"mov
%1, %1;"
"test
%3, %0;"
"cmovz
"test
%2, %2;"
: "=r" (result)
: "r" (pred), "r" (t_val), "r" (f_val)
: "cc"

uint32_t result;
__asm__ volatile (

);
return result;

Figure 4: Code for conditional data copy operation that
does not leak information over digital side channels. This
function returns t val if pred is true; otherwise it re-
turns f val. The assembly code uses AT&T syntax.

Figure 3: Escort’s implementation of double-precision
multiplication, using the AT&T syntax.

loops whose trip count reveals secrets over digital side
channels. We now describe each step in turn.

4.2.1 Step 1: Using Secure Elementary Operations

The Escort compiler replaces x86 ﬂoating-point type-
conversion, multiplication, division, and square root as-
sembly instructions with their Escort counterparts. How-
ever, Escort’s secure elementary operations can be up
to two orders of magnitude slower than their non-secure
counterparts. Hence, our compiler minimizes their usage
by using taint tracking and by employing the quantiﬁer-
free bit-vector logic in the Z3 SMT solver [7], which is
equipped with ﬂoating-point number theory. If the solver
can prove that the operands can never be subnormal val-
ues, then Escort refrains from replacing that instruction.
In effect, the Escort compiler constructs path-sensitive
in the

Z3 expressions for each arithmetic statement

LLVM IR. For every Φ-node that produces an operand
for an arithmetic expression, Escort creates one copy of
the expression for each input to the Φ-node. If the solver
reports that no operand can have a subnormal value, then
Escort skips instrumentation of that ﬂoating-point opera-
tion.

We set a timeout of 40 seconds for each invocation of
the SMT solver. If the solver can prove that the instruc-
tion never uses subnormal operands, then Escort skips
replacing that ﬂoating-point instruction with its secure
counterpart. Figure 5 shows the percentage of ﬂoating-
point instructions in commonly used math functions that
are left untransformed by Escort.

This optimization is conservative because it assumes
that all ﬂoating-point instructions in the program have
subnormal operands unless proven otherwise. The cor-
rectness of the optimization is independent of the code’s
use of pointers, library calls, system calls, or dynamic
values. The static analysis used in this optimization is
ﬂow-sensitive, path-sensitive, and intra-procedural.

USENIX Association  

25th USENIX Security Symposium  75

if entry block(bb) then

pred[bb] ← true
pred[bb] ← false

else

end if

br ← branch(bb)
if unconditional branch(br) then

1: for each basic block bb in function do
2:
3:
4:
5:
6:
7: end for
8:
9: for each basic block bb in function do
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22:
23:
24:
25:
26:
27:
28:
29: end for

{s} ←successors(bb)
pred[s] ← pred[s]∨ pred[bb]
pred[s] ← simpli f y(pred[s])
{s1,s2} ←successors(bb)
if loop condition branch(br) then

end if
pred[s1] ← simpli f y(pred[s1])
pred[s2] ← simpli f y(pred[s2])

pred[s1] ← pred[s1]∨ pred[bb]
pred[s2] ← pred[s2]∨ pred[bb]
p ← condition(br)
pred[s1] ← pred[s1]∨ (pred[bb]∧ p)
pred[s2] ← pred[s2]∨ (pred[bb]∧¬p)

else

(cid:31) Conditional Branch.

(cid:31) Skip branches that represent loops.

else

end if

Figure 6: Algorithm for predicating basic blocks.

Memory Access Side Effects. To ensure proper mem-
ory access side effects, the Escort compiler replaces store
instructions with conditional data-copy operations that
are guarded by the basic block’s predicate, so memory
is only updated by instructions whose predicate is true.

Unfortunately, this na¨ıve approach can leak secret in-
formation when the program uses pointers. Figure 7
illustrates the problem: If store instructions are not al-
lowed to update a pointer variable when the basic block
predicate is false, then the address trace from subsequent
load instructions on the pointer variable will expose the
fact that the pointer variable was not updated.

The Escort compiler prevents such information leaks
by statically replacing pointer dereferences with loads or
stores to each element of the points-to set4. Thus Escort
replaces the statement in line 8 (Figure 7) with a store
operation on b. When the points-to set is larger than a

4Escort uses a ﬂow-sensitive, context-insensitive pointer analysis:
https://github.com/grievejia/tpa. Replacing a pointer derefer-
ence with a store operation on all elements of the points-to set is feasi-
ble for Escort because points-to set sizes in the Musl C library are very
small.

Figure 5: Percentage of instructions that are left uninstru-
mented (without sacriﬁcing security) after consulting the
SMT solver.

4.2.2 Step 2: Predicating Basic Blocks

Basic block predicates represent the conditions that dic-
tate whether an instruction should execute. These pred-
icates are derived by analyzing conditional branch in-
structions. For each conditional branch instruction that
evaluates a predicate p, the Escort compiler associates
the predicate p with all basic blocks that execute if the
predicate is true, and it associates the predicate ¬p with
all basic blocks that execute if the predicate is false. For
unconditional branches, the compiler copies the predi-
cate of the previous block into the next block. Finally,
if the Escort compiler comes across a block that already
has a predicate, then the compiler sets the block’s new
predicate to the logical OR of the input predicates. At
each step, the Escort compiler uses Z3 as a SAT solver to
simplify predicates by eliminating unnecessary variables
in predicate formulas. Figure 6 shows the algorithm for
basic block predication.

4.2.3 Step 3: Linearizing Basic Blocks

The Escort compiler converts the given code into
straight-line code so that every invocation of the code
executes the same instructions. To preserve control de-
pendences, the basic blocks are topologically sorted, and
then the code is assembled into a single basic block with
branch instructions removed.

4.2.4 Step 4: Controlling Side Effects

We now explain how Escort prevents side effects from
leaking secrets. Here, side effects are modiﬁcations to
the program state or any observable interaction, includ-
ing memory accesses, exceptions, function calls, or I/O.
Escort controls all side effects except for I/O statements.

76  25th USENIX Security Symposium 

USENIX Association

  0 % 20 % 40 % 60 % 80 %100 %fabsffabsexp10fexp10expflog10powlog2powfexp2floglog10fexp2ceilﬂoorlog2flogfsincossinfcosftanceilfﬂoorftanfOptimized ﬂoating-point instructions(cid:31) Assume input() returns true.

1: p ← &a
2: secret ← input()
3: if secret = true then
4:
5: else
6:
7:

...

...
p ← &b (cid:31) Instruction does not update pointer p,
since basic block’s execution-time predicate is false.
(cid:31) Accesses a instead of b!
∗p ← 10

8:
9: end if

Figure 7: The use of pointers can leak information. If
store instructions are not allowed to access memory
when the basic block’s predicate is false, then pointer
p will dereference the address for a instead of b, thus
revealing that secret is true.

singleton set, Escort uses the conditional data copy op-
eration on all potential pointees i.e. the elements of the
points-to set. The predicate of the conditional copy oper-
ation checks whether the pointer points to the candidate
pointee. If the predicate is false, the pointee’s existing
value is overwritten, whereas if the predicate is true, the
new value is written to the pointee.

Function Call Side Effects. Adversaries can observe
the invocation of functions (or lack thereof) using side
channels like the Instruction Pointer. Thus, a solution in-
capable of handling function calls will leak information
to the adversary. While inlining functions is a potential
solution, inlining is impractical for large applications.

Escort handles side effects from function calls by
propagating the predicate from the calling function to the
callee. Thus, each user-deﬁned function is given an ad-
ditional argument that represents the predicate of the call
site’s basic block. The callee ensures correct handling of
side effects by ANDing its own predicates with the caller’s
predicate.

Side Effects from Exceptions. Program termination
caused by exceptions will leak the presence or absence
of abnormal operands. To prevent such information leak-
age, Escort requires that exceptions not occur during pro-
gram execution5.

Escort manages ﬂoating-point and integer exceptions
differently. Escort requires that the programmer disable
ﬂoating-point exceptions (e.g. using feclearexcept()).
For
integer exceptions, Escort borrows ideas from
Raccoon by replacing abnormal operands with benign
operands (e.g. Escort prevents integer division-by-zero
by replacing a zero divisor with a non-zero divisor).

5Escort assumes that the input program does not throw exceptions,
so masking exceptions does not change the semantics of the program.

4.2.5 Step 5: Transforming Array Accesses
Array index values reveal secrets as well. For instance,
if the adversary observes that accesses to array[0] and
array[secret index] result in accesses to locations 10
and 50, then the adversary knows that secret index =
40. To eliminate such information leaks, the Escort com-
piler transforms each array access into a linear sweep
over the entire array, which hides from the adversary the
address of the program’s actual array index.

Of course, the transformed code is expensive, but this
approach is feasible because (1) math library functions
typically use only a few small lookup tables, thus requir-
ing relatively few memory accesses and (2) the proces-
sor’s caches and prefetchers dramatically reduce the cost
of sweeping over the arrays.

4.2.6 Step 6: Transforming Loops
Some loops introduce timing channels because their trip
counts depend on secret values. The Escort compiler
transforms such loops using predictive mitigation [38].
The loop body executes as many times as the smallest
power of 2 that is greater than or equal to the loop trip
count. For instance, if the actual loop trip count is 10,
then the loop body is executed 16 times. The basic block
predicate ensures that dummy iterations do not cause side
effects. With this transformed code, an adversary that ob-
serves a loop trip count of l can infer that the actual loop
trip count l(cid:29) is between l and 0.5× l. However, the exact
value of l(cid:29) is not revealed to the adversary.
Unfortunately, this naive approach can still leak infor-
mation. For instance, if two distinct inputs cause the loop
to iterate 10 and 1000 times respectively, the transformed
codes will iterate 16 and 1024 times respectively—a
large difference that may create timing variations. To
mitigate this problem, Escort allows the programmer to
manually specify the minimum and maximum loop trip
counts using programmer annotations. These annota-
tions override the default settings used by the Escort
compiler.

4.3 Example Transformation: exp10f

We now explain how Escort transforms an exam-
ple non-secure function (Figure 8a) into a secure func-
tion (Figure 8c). To simplify subsequent analyses and
transformations, the Escort compiler applies LLVM’s
mergereturn transformation pass, which uniﬁes all exit
nodes in the input function (see Figure 8b).

First,

the Escort compiler

replaces elementary
ﬂoating-point operations in lines 8 and 10 with their se-
cure counterpart function shown in lines 21 and 22 of the
transformed code. Second, using the algorithm shown in
Figure 6, the Escort compiler associates predicates with

USENIX Association  

25th USENIX Security Symposium  77

float e10(float x) {

float n, y = mf(x, &n);
if (int(n) >> 23 & 0xff < 0x82) {

float p = p10[(int) n+
if (y == 0.0f) {

7];

return p;

}
return exp2f(3.322f * y) * p;

}
return exp2(3.322 * x);

}

(a) Original code for exp10f().

float n, y = mf(x, &n);
if (int(n) >> 23 & 0xff < 0x82) {

01: float e10(float x) {
02:
03:
04:
05:
06:
07:
08:

float p = p10[(int) n+
if (y == 0.0f)
result = p;

7];

else

result =

exp2f(3.322f * y) * p;

} else

result = exp2(3.322 * x);

return result;

09:
10:
11:
12: }

return e10_cloned(x, true);

12: float e10(float x) {
13:
14: }
15:
16: float e10_cloned(float x, uint pred) {
float n, y = mf_cloned(x, &n, pred);
17:
float p = write(int(n) >> 23 & 0xff
18:
< 0x82, stream_load(p10, (int) n+

19:
20:
21:

bool p2 = y == 0.0f;
write(pred & p1 & p2, p, &result);
write(pred & p1 & !p2,

7]));

escort_mul(
escort_mul(

exp2f_cloned(3.322f,
pred & p1 & !p2),

y),

p),

&result);

22:

write(!p1,
escort_mul(

exp2_cloned(3.322, pred & !p1),
escort_upcast(x))),

result);

return result;

23:
24: }

(b) Result after applying LLVM’s mergereturn pass. This
code becomes the input for the Escort compiler.

(c) Result of the Escort compiler’s transformation.

Figure 8: Escort’s transformation of exp10f().

A: y = mf(x, &n)

Yes

(n >> 23 
& 0xff) 
< 0x82?

B: p = p10[n + 7]

No

C: result = exp2

(3.332 * x)

y = 0?

Yes

D: result = p

No

E: result = exp2f
(3.332f * y) * p

F: return result

Figure 9: Control ﬂow graph with labeled statements for
the code in Figure 8b. A, B, D, E, C, F is one possible
sequence of basic blocks when linearized by the Escort
compiler.

Line #
2, 3, 11

4, 5
6
8
10

Predicate

TRUE

(n >> 23 & 0xff) < 0x82

(n >> 23 & 0xff) < 0x82 ∧ y = 0
(n >> 23 & 0xff) < 0x82 ∧ y (cid:30)= 0

¬((n >> 23 & 0xff) < 0x82)

Table 2: Predicates per line for function in Figure 8b.

each basic block, which we list in Table 2. Third, the Es-
cort compiler linearizes basic blocks by applying a topo-
logical sort on the control ﬂow graph (see Figure 9) and
fuses the basic blocks together. Finally, the Escort com-
piler replaces the array access statement in line 4 with a
function that sweeps over the entire array. The resulting
code, shown in Figure 8c, eliminates control ﬂows and
data ﬂows that depend on secret values. In addition to
closing digital side channels, the code also uses secure
ﬂoating-point operations.

78  25th USENIX Security Symposium 

USENIX Association

5 Security Evaluation

This section demonstrates that Escort’s ﬂoating-point op-
erations run in ﬁxed time and do not leak information
through digital side channels. Since precise timing mea-
surement on x86 processors is tricky due to complex
processor and OS design, we take special measures to
ensure that our measurements are accurate.
In addi-
tion to Escort’s timing and digital side channel defense,
we also demonstrate Escort’s defense against a ﬂoating-
point timing channel attack on the Firefox web browser.

5.1 Experimental Setup
We run all experiments on a 4-core Intel Core i7-2600
(Sandy Bridge) processor. The processor is clocked at
3.4 GHz. Each core on this processor has a 32 KB pri-
vate L1 instruction cache, a 32 KB private L1 data cache,
and a 256 KB private L2 cache. A single 8 MB L3 cache
is shared among all four cores. The host operating sys-
tem is Ubuntu 14.04 running kernel version 3.13. We im-
plement compiler transformations using the LLVM com-
piler framework [17] version 3.8.

We measure instruction latencies using the RDTSC in-
struction that returns the number of elapsed cycles since
resetting the processor. Since the latency of executing
the RDTSC instruction is usually higher than the latency
of executing operations, our setup measures the latency
of executing 1024 consecutive operations and divides the
measured latency by 1024. Our setup uses the CPUID in-
struction and volatile variables for preventing the pro-
cessor and the compiler from reordering critical instruc-
tions. Finally, our setup measures overhead by execut-
ing an empty loop body—a loop body that contains no
instructions other than those in the test harness. By plac-
ing an empty volatile
asm block in the empty loop
body, our setup prevents the compiler from deleting the
empty loop body.

5.1.1 Outlier Elimination

Many factors outside of the experiment’s control, like in-
terrupts, scheduling policies, etc., may result in outliers
in performance measurements. We now explain our pro-
cedure for eliminating outliers, before demonstrating that
the elimination of these outliers does not bias the conclu-
sions.

We use Tukey’s method [34] for identifying outliers,
but we adapt it to conservatively classify fewer values as
outliers (thus including more values as valid data points).
The original Tukey’s method ﬁrst ﬁnds the minimum
(Mn), median (Md), and maximum (Mx) of a set of values.
The ﬁrst quartile, Q1, is the median of values between Mn
and Md. The third quartile, Q3, is the median of values

between Mx and Md. The difference between the ﬁrst and
the third quartiles (Q3 − Q1) is called the Inter-Quartile
Range, RIQ. Tukey’s method states that any value v, such
that v > Q3 + 3×RIQ or v < Q1 − 3×RIQ is a probable
outlier. In our evaluation, we weaken our outlier elim-
ination process (i.e. we count fewer values as outliers),
by (1) setting the RIQ to be at least equal to 1.0, and
(2) classifying v as an outlier when v > Q3 + 20×RIQ
or v < Q1 − 20×RIQ. Results presented in the following
sections use the relaxed Tukey method described above.

Different
Operands

Same

Operands

Mean
847,323
(0.81%)
929,703
(0.89%)

Median
1,066,270
(1.02%)
1,139,961
(1.09%)

Std. Dev.
381,467

364,192

Table 3: Number of discarded outliers from 100 million
double-precision square-root operations. The results in-
dicate that our outlier elimination process is statistically
independent of the input operand values.

To demonstrate that our outlier elimination process
does not bias conclusions, we compare the distribution
of outliers between (a) 100 million operations using
randomly-generated operands, and (b) 100 million op-
erations using one ﬁxed operand. The two experiments
do not differ in any way other than the difference in their
input operands. Table 3 shows the mean, median, and
standard deviation of outliers for the double-precision
square-root operation. Results for other ﬂoating-point
operations are similar and are elided for space reasons.
Since the difference in mean values as well as the dif-
ference in median values is within a quarter of the stan-
dard deviation from the mean, we conclude that the dis-
carded outlier count is statistically independent of the in-
put operand values.

5.2 Timing Assurance of Elementary Op-

erations

Since exhaustively testing all possible inputs for each op-
eration is infeasible, we instead take the following three-
step approach for demonstrating the timing channel de-
fense for Escort’s elementary operations: (1) We char-
acterize the performance of Escort’s elementary opera-
tions using a speciﬁc, ﬁxed ﬂoating-point value (e.g. 1.0),
(2) using one value from each of the six different types
of values (zero, normal, subnormal, +∞, -∞, and not-
a-number), we show that our solution exhibits negligi-
ble variance in running time, and (3) to demonstrate that
each of the six values in the previous experiment is rep-
resentative of the class to which it belongs, we generate
10 million normal, subnormal, and not-a-number (NaN)

USENIX Association  

25th USENIX Security Symposium  79

80  25th USENIX Security Symposium 

USENIX Association

values,andshowthatthevarianceinrunningtimeamongeachsetof10millionvaluesisnegligible.Ourkeyﬁnd-ingsarethatEscort’soperationsruninﬁxedtime,arefast,andthattheirperformanceiscloselytiedtotheper-formanceofthehardware’ssubnormaloperations.Figure10:Comparisonofrunningtimesofelementaryoperations.spidentiﬁesEscort’ssingle-precisionopera-tions,dpidentiﬁesEscort’sdouble-precisionoperations,andﬁxidentiﬁesFTFP’sﬁxed-pointoperations.Num-bersatthetopofthebarsshowthetotalcyclecount.WeseethatEscort’sexecutiontimesaredominatedbythecostofsubnormaloperations,andweseethatFTFP’soverheadsaresigniﬁcantlygreaterthanEscort’s.Figure10comparestherunningtimesofelementaryoperationsofEscortandofprevioussolutions(FTFP).First,weobservethattherunningtimesofEscort’ssingle-anddouble-precisionoperationsareanorder-of-magnitudelowerthanthoseofFTFP’sﬁxed-precisionoperations.Second,Escort’srunningtimeisalmosten-tirelydominatedbytheprocessor’soperationonsubnor-malnumbers.Third,conversionbetweenﬁxed-pointandﬂoating-pointtakesanon-trivialamountoftime,furtherincreasingtheoverheadofFTFP’soperations.Overall,Escortelementaryoperationsareabout16×fasterthanFTFP’s.Table4showsthevariationinrunningtimeofele-mentaryoperationsacrosssixdifferenttypesofinputs(zero,normalvalue,subnormalvalue,+∞,−∞,andnot-a-numbervalue)andcomparesitwiththevariationofSSE(native)operations.WhileSSEoperationsexhibithighvariation(themaximumobservedstandarddevia-tionis176%ofthemean),Escort’soperationsshowneg-ligiblevariationacrossdifferentinputtypes.Finally,wemeasureEscort’srunningtimefor10mil-lionrandomnormal,subnormal,andnot-a-numberval-ues.Weobservethatthestandarddeviationofthesemea-surements,showninTable5,isextremelylow(atmostFunctionEscortNative(SSE)add-sp00add-dp00sub-sp00sub-dp00mul-sp049.2(175%)mul-dp049.2(175%)div-sp0.66(0.4%)65.67(163%)div-dp1.66(0.8%)69.08(164%)sqrt-sp1.49(0.8%)62.7(170%)sqrt-dp2.98(1.5%)66.87(169%)upcast040.99(178%)Table4:Comparisonofstandarddeviationofrunningtimesofelementaryoperationsacrosssixtypesofvalues(zero,normal,subnormal,+∞,−∞,andnot-a-number).Numbersinparenthesisshowthestandarddeviationasapercentageofthemean.The-spsufﬁxidentiﬁessingle-precisionoperationswhilethe-dpsufﬁxidenti-ﬁesdouble-precisionoperations.ComparedtoSSEop-erations,Escortexhibitsnegligiblevariationinrunningtimes.3.1%ofthemean).Wethusconcludethatourchosenvaluesforeachofthesixclassesfaithfullyrepresenttheirclass.02,0004,0006,0008,00010,00012,00014,000ﬂoorceilfabslog10loglog2sincostanexppowProcessor CyclesFTFPEscort-SPEscort-DPFigure11:Comparisonofrunningtimesofcommonlyusedhigher-levelfunctions.Errorbars(visibleforonlyafewfunctions)showthemaximumvariationinrunningtimefordifferentkindsofinputvalues.5.3TimingAssuranceofHigher-LevelOp-erationsUsingdifferenttypesofﬂoating-pointvalues(zero,nor-mal,subnormal,+∞,−∞,andnot-a-number),Figure11comparestheperformanceofmostofthecommonlyusedFn.
add-sp
add-dp
sub-sp
sub-dp
mul-sp
mul-dp
div-sp
div-dp
sqrt-sp
sqrt-dp
upcast

NaN

0.21 (3.1%)
0.21 (3.0%)
0.18 (2.6%)
0.19 (2.7%)
0.98 (0.7%)
0.90 (0.6%)
1.22 (0.6%)
1.39 (0.7%)
1.15 (0.6%)
1.29 (0.7%)
1.03 (0.9%)

Normal

0.21 (2.9%)
0.20 (2.9%)
0.19 (2.7%)
0.19 (2.7%)
0.94 (0.7%)
1.04 (0.7%)
1.27 (0.7%)
1.37 (0.6%)
1.13 (0.6%)
1.41 (0.7%)
0.89 (0.8%)

Subnormal
0.19 (2.7%)
0.21 (3.0%)
0.20 (2.9%)
0.19 (2.7%)
1.05 (0.7%)
1.02 (0.7%)
1.23 (0.6%)
1.17 (0.6%)
1.14 (0.6%)
1.33 (0.7%)
0.95 (0.8%)

Table 5: Standard deviation of 10 million measurements
for each type of value (normal, subnormal, and not-a-
number). All standard deviation values are within 3.1%
of the mean. Furthermore, the mean of these 10,000,000
measurements is always within 2.7% of the representa-
tive measurement.

single- and double-precision higher-level operations6.
Overall Escort’s higher-level operations are about 2×
slower than their corresponding FTFP operation, which
is the price for closing side channels that FTFP does not
close.

Figure 12: Performance breakdown of Escort’s com-
monly used higher-level functions. The baseline (non-
secure) execution and exception handling together cost
less than 250 cycles for each function, making them too
small to be clearly visible in the above plot.

Figure 12 shows the breakdown of the performance
of commonly used higher-level functions. We observe
that the performance of most higher-level functions is
dominated by the latency of operations on subnormal
operands, which is closely tied to the performance of the
underlying hardware. A handful of routines (exp10(),

6We exclude the exp2() (6,617 cycles), exp10() (14,910 cycles),
exp2f() (1,693 cycles), and exp10f() (9,134 cycles) from Figure 11
because FTFP does not implement these operations.

exp10f(), exp2(), and exp2f()) use lookup tables
that are susceptible to address-trace-based side-channel
information leaks, so the code transformed by Escort
sweeps over these lookup tables for each access to the
table. Finally, we see that the cost of control ﬂow ob-
fuscation (i.e. the cost of executing all instructions in the
program) contributes the least to the total overhead.

5.4 Side-Channel Defense in Firefox
We now evaluate Escort’s defense against the timing
channel attack by Andrysco et al. [3] on the Firefox web
browser. The attack reconstructs a two-color image in-
side a victim web page using only the timing side chan-
nel in ﬂoating-point operations. The attack convolves the
given secret image with a matrix of subnormal values.
The convolution step for each pixel is timed using high
resolution Javascript timers. By comparing the measured
time to a threshold, each pixel is classiﬁed as either black
or white, effectively reconstructing the secret image.

We integrate Escort into Firefox’s convolution code7
and re-run the timing attack. The results (see Figure 13c)
show that Escort successfully disables the timing attack.

5.5 Control- and Data-Flow Assurance
We now show that Escort’s operations do not leak infor-
mation through control ﬂow or data ﬂow. We ﬁrst use
inference rules over the LLVM IR to demonstrate non-
interference between secret inputs and digital side chan-
nels. We run a machine-learning attack on Escort and
demonstrate that Escort successfully disables the attack.

5.5.1 Non-Interference Using Inference Rules

Since Escort’s elementary operations are small and
simple—they are implemented using fewer than 15 lines
of assembly code, they do not access memory, and they
do not contain branch instructions—they are easily veri-
ﬁed for non-interference between secret inputs and digi-
tal side channels. Using an LLVM pass that applies the
inference rules from Table 6, tracking labels that can be
either L (for low-context i.e. public information) or H (for
high-context i.e. private information), we verify that Es-
cort’s higher-level operations close digital side channels.
This compiler pass initializes all function arguments with
the label H, since arguments represent secret inputs.

Inference rules for various instructions dictate updates
to the labels. The environment Γ tracks the label of each
pointer and each address. The Escort compiler tags load

7Speciﬁcally, we replace three single-precision multiplication oper-
ations with invocations to the equivalent Escort function. All source
code changes are limited to the code in the ConvolvePixel() function
in SVGFEConvolveMatrixElement.cpp.

USENIX Association  

25th USENIX Security Symposium  81

05,00010,00015,000fabsffabsceilﬂoorﬂoorfceilflogflog2flog10fexp2flogexpflog2log10expexp2powfpowtanexp10fcossintanfcosfsinfexp10MEANProcessor Cyclesbaseline (non-secure) executioncontrol ﬂow obfuscationdata access obfuscationsubnormal operands82  25th USENIX Security Symposium 

USENIX Association

(a)Originalimage.(b)Reconstructedimageusingtimingattack.(c)Reconstructedimagesin3independent,consec-utiveexperimentsafterpatchingFirefoxwithEscort.Figure13:ResultsofattackanddefenseonavulnerableFirefoxbrowserusingtiming-channelinformationleaksarisingfromtheuseofsubnormalﬂoating-pointnumbers.andstoreinstructionsassecretifthepointeristainted,orpublicotherwise.Unlikeapublicloadorstorein-struction,asecretloadorstoreinstructionisallowedtouseataintedpointersinceEscortgeneratescorrespond-ingloadsandstorestoallstatically-determinedcandi-datevaluesinthepoints-toset.Thesanitizationrulere-setsthevalue’slabeltoLandisrequiredtosuppressfalsealarmsfromEscort’sloopconditiontransformation.Es-cort’stransformedcodeincludesinstructionswithspe-cialLLVMmetadatathattriggerthesanitizationrule.Duringveriﬁcation,thecompilerpassiteratesovereachinstructionandcheckswhetheraruleisapplica-bleusingtherule’santecedents(thestatementabovethehorizontalline);ifso,itupdatesitslocalstateaspertherule’sconsequent(thestatementbelowthehorizon-talline).Ifnoapplicableruleisfound,thenthecom-pilerpassthrowsanerror.ThecompilerpassprocessesthecodeforEscort’s112higher-leveloperationswithoutthrowingerrors.5.5.2DefenseAgainstMachine-LearningAttackWeusetheTensorFlow[1]librarytodesignamachine-learningclassiﬁer,whichweusetolaunchaside-channelattackontheexecutionoftheexpf()function,wheretheinputtotheexpf()functionisassumedtobesecret.Usingthreedistinctinputs,werunthisattackontheim-plementationsinthe(non-secure)MuslClibraryandinthe(secure)Escortlibrary.WeﬁrstusethePindynamicbinaryinstrumentationtool[19]togatherthefullinstruc-tionaddresstracesofbothexpf()implementations8.WetraintheTensorFlowmachine-learningclassiﬁerbyfeed-ingtheinstructionaddresstracestotheclassiﬁer,asso-ciatingeachtracewiththesecretinputtoexpf().WeusecrossentropyasthecostfunctionforTensorFlow’strainingphase.Inthesubsequenttestingphase,weran-domlyselectoneofthecollectedaddresstracesandasktheclassiﬁertopredictthesecretinputvalue.WeﬁndthatfortheMuslimplementation,theclassi-ﬁerisaccuratelyabletopredictthecorrectsecretvaluefromtheaddresstrace.Ontheotherhand,fortheEscort8Usingthemd5sumprogram,weobservethatEscort’saddresstracesforallthreeinputsareidentical.implementation,theclassiﬁer’saccuracydropsto33%,whichisnobetterthanrandomlyguessingoneofthethreesecretinputvalues.6PrecisionEvaluationWeexaminetheprecisionofEscortandFTFPbycom-paringEscort’sandFTFP’sresultswiththoseproducedbyastandardClibrary.6.1ComparisonUsingUnitofLeastPreci-sionMethodology.Weadoptanempiricalapproachtoesti-mateprecisionintermsofUnitofLeastPrecision(ULP),sinceformalderivationofmaximumULPdifferencere-quiresanintricateunderstandingoftheoremproversandﬂoating-pointalgorithms.Werunvariousﬂoating-pointoperationson10,000randomlygeneratedpairs(usingdrand48())ofﬂoating-pointnumbersbetweenzeroandone.Forelementaryoperations,wecomparetheoutputsofEscortandFTFPwiththeoutputsofnativex86in-structions.Forallotheroperations,wecomparetheout-putsofEscortandFTFPwiththeoutputsproducedbycorrespondingfunctionfromtheMuslClibrary.Results.WeobservethatEscort’sresultsareidenti-caltotheresultsproducedbythereferenceimplemen-tations,i.e.thenative(x86)instructionsandtheMuslClibrary.Moreprecisely,theULPdifferencebetweenEscort’sresultsandreferenceimplementation’sresultsiszero.Ontheotherhand,FTFP,whichcomputesarithmeticinﬁxed-pointprecision,producesoutputthatdifferssubstantiallyfromtheoutputofMusl’sdouble-precisionfunctions(seeTable7).TheIEEE754standardrequiresthataddition,subtraction,multiplication,divi-sion,andsquarerootoperationsarecomputedwithULPdifferenceofatmost0.5.Well-knownlibrariescomputeresultsformosthigher-leveloperationswithin1ULP.T-PUBLIC-LOAD

Γ(ptr) = L

P = ptset(ptr)
Γ(addr)
m = max
addr∈P
Γ(cid:30) = Γ[val (cid:29)→ m]

T-PUBLIC-STORE

T-SECRET-LOAD

T-SECRET-STORE

T-BRANCH

T-OTHER

T-COMPOSITION

T-SANITIZER

Γ(ptr) = L

Γ (cid:27) val := public-load ptr : Γ(cid:30)
∀ addr ∈ ptset(p)
m = max(Γ(val),Γ(addr))
Γ(cid:30) = Γ[addr (cid:29)→ m]
Γ (cid:27) public-store ptr, val : Γ(cid:30)

Γ(cid:30) = Γ[val (cid:29)→ H]

Γ (cid:27) val := secret-load ptr : Γ(cid:30)

∀ addr ∈ ptset(p)
Γ(cid:30) = Γ[addr (cid:29)→ H]

Γ (cid:27) secret-store ptr, val : Γ(cid:30)

Γ(cond) = L

Γ (cid:27) br cond,block1,block2 : Γ

Γ(cid:30) = Γ[x (cid:29)→ Γ(y)]
Γ (cid:27) x:=y : Γ(cid:30)

Γ (cid:27) S1 : Γ(cid:30), Γ(cid:30) (cid:27) S2 : Γ(cid:30)(cid:30)

Γ (cid:27) S1;S2 : Γ(cid:30)(cid:30)

Γ(cid:30) = Γ[x (cid:29)→ L]
Γ (cid:27) S(x) : Γ(cid:30)

Function Min.
16
1,312
317
829
562
0
0
1,698
262
981
132
1,316
2,166
717
522
352

add
sub
mul
div
sqrt
ﬂoor
ceil
log
log2
log10
exp
sin
cos
tan
pow
fabs

Median
1,743,272
6,026,976
8,587,410
5,834,095
2,815,331
0
0
5,908,547
5,812,840
10,105,199
1,409,624
4,173,786
2,241,360
5,576,540
3,425,870
3,129,984

Max.
210,125,824
84,089,503,744
112,134,679,849
30,899,033,427
21,257,836,468
0
0
2,705,277,8104
13,890,632,367
40,631,590,323
6,066,894
40,138,955,131
10,127,702
40,126,401,802
26,876,068,127
40,134,770,688

Table 7: Floating-point difference for 10,000 operations
on random inputs in terms of Unit of Least Precision
(ULP) in FTFP versus Musl C library. Since we ob-
serve zero ULP distance between Escort’s results and
Musl’s results, this table omits Escort’s results.

<
10−5
49%

10−5 to
10−3
9%

10−3 to

100
21%

100 to
>
103
103
10% 11%

Table 6: Inference rules for verifying the security of Es-
cort’s higher-level operations.

Table 8: Distribution of differences in answers produced
by MINPACK-FTFP and MINPACK-C. In all, 321 values
differ between the outputs of the two programs.

6.2 Comparison of Program Output
Methodology. Since differences in program outputs
provide an intuitive understanding of the error intro-
duced by approximate arithmetic operations, we com-
pare the output of the test suite of Minpack9, a li-
brary for solving non-linear equations and non-linear
least squares problems. We generate three variants of
Minpack: MINPACK-C uses the standard GNU C li-
brary, MINPACK-ESCORT uses the Escort library, and
MINPACK-FTFP uses the FTFP library. We run the 29
programs in Minpack’s test suite and compare the out-
puts produced by the three program variants.

Results. We observe that MINPACK-ESCORT produces
output that is identical to MINPACK-C’s output. We also
observe that all outputs of MINPACK-FTFP differ from
MINPACK-C. Speciﬁcally, 321 values differ between the
outputs of MINPACK-FTFP and MINPACK-C. We ana-

9https://github.com/devernay/cminpack

lyze all 321 differences between MINPACK-FTFP and
MINPACK-C by classifying them into the following ﬁve
categories: (1) smaller than 10−5, (2) between 10−5 and
10−3, (3) between 10−3 and 100, (4) between 100 and
103, and (5) larger than 103. As seen in Table 8, almost
half of the differences (49%) are extremely small (less
than 10−5), possibly arising from relatively small dif-
ferences between ﬁxed-point and ﬂoating-point calcula-
tions. However, we hypothesize that differences amplify
from propagation, since nearly 42% of the differences
are larger than 10−3.

7 Performance Evaluation

We now evaluate the end-to-end application performance
impact of Escort’s ﬂoating-point library and Escort’s
control ﬂow obfuscation.

USENIX Association  

25th USENIX Security Symposium  83

Application

Escort

Overhead

433.milc
444.namd
447.dealII
450.soplex
453.povray

470.lbm

480.sphinx3

MEAN

29.33×
57.32×
20.31×
4.74×
82.53×
56.19×
52.46×
32.63×

(geo. mean)

Static (LLVM)
Floating-Point

Instruction

Count
2,791
9,647
21,963
4,177
25,671

711
629
9,370

(arith. mean)

Table 9: Overhead of SPEC-ESCORT (SPECfp2006
using Escort operations)
to SPEC-LIBC
(SPECfp2006 using libc).

relative

Impact of Floating-Point Library

7.1
This section evaluates the performance impact of Escort
on the SPEC ﬂoating point benchmarks, as well as on a
security-sensitive program SVMlight, a machine-learning
classiﬁer.

Evaluation Using SPEC Benchmarks. We use the C
and C++ ﬂoating-point applications in the SPEC CPU
2006 benchmark suite with reference inputs. We gen-
erate two versions of each program—the ﬁrst version
(SPEC-LIBC) uses the standard C library functions, and
the second version (SPEC-ESCORT) uses functions from
the Escort library10. We compile the SPEC-LIBC pro-
gram using the Clang/LLVM 3.8 compiler with the -O3
ﬂag, and we disable auto-vectorization while compil-
ing the SPEC-ESCORT program. The following results
demonstrate the worst case performance overhead of Es-
cort for these programs, since we transform all ﬂoating-
point operations in SPEC-ESCORT to use the Escort li-
brary. More precisely, we do not reduce the number of
transformations either using taint tracking or using SMT
solvers.

Table 9 shows that Escort’s overhead is substantial,
with a geometric mean of 32.6×. We expect a lower av-
erage overhead for applications that use secret data, since
taint tracking would reduce the number of ﬂoating-point
operations that would need to be transformed.

Evaluation Using SVMlight. To evaluate Escort’s
overhead on a security-sensitive benchmark, we mea-
sure Escort’s performance on SVMlight, an implemen-

10We also ran the same programs using the FTFP library, but the
programs either crashed due to errors or ran for longer than two hours,
after which they were manually terminated.

Test Case Overhead for

#1
#2
#3
#4
GEO
MEAN

Training
8.66×
30.24×
1.41×
12.75×
8.28×

Overhead for
Classiﬁcation

1.34×
0.96×
1.11×
0.92×
1.07×

Table 10: Overhead of Escort on SVMlight program.

tation of Support Vector Machines in C, using the four
example test cases documented on the SVMlight web-
site11. We mark the training data and the classiﬁcation
data as secret. Before replacing ﬂoating-point computa-
tions, Escort’s taint analysis discovers all ﬂoating-point
computations that depend on the secret data, thus re-
ducing the list of replacements. We also instruct Es-
cort to query the Z3 SMT solver to determine whether
candidate ﬂoating-point computations could use subnor-
mal operands. Escort then replaces these computations
with secure operations from its library. We compile the
baseline (non-secure) program using the Clang/LLVM
3.8 compiler with the -O3 ﬂag, and we disable auto-
vectorization while compiling SVMlight with Escort. We
measure the total execution time using the RDTSC instruc-
tion. Table 10 shows that Escort’s overhead on SVMlight.
We observe that Escort’s overhead on SVMlight is sub-
stantially lower than that on SPEC benchmarks. Using
the md5sum program, we verify that the output ﬁles be-
fore and after transformation of SVMlight are identical.

Impact of Control Flow Obfuscation

7.2
To compare the performance impact of Escort’s con-
trol ﬂow obfuscation technique with that of Raccoon,
we use the same benchmarks that were used to eval-
uate Raccoon [28], while compiling the baseline (non-
transformed) application with the -O3 optimization ﬂag.
Although both Escort and Raccoon obfuscate control
ﬂow and data accesses, we compare the cost of control
ﬂow obfuscation only, since both Escort and Raccoon ob-
fuscate data accesses using the identical technique. Ta-
ble 11 shows the results.

We ﬁnd that programs compiled with Escort have a
signiﬁcantly lower overhead than those compiled with
Raccoon. Escort’s geometric mean overhead is 32%,
while that of Raccoon is 5.32×. The worst-case over-
head for Escort is 2.4× (for ip-tree).
The main reason for the vast difference in overhead
is that Raccoon obfuscates branch instructions at execu-
tion time, which requires the copying and restoring of

11http://svmlight.joachims.org/

84  25th USENIX Security Symposium 

USENIX Association

Benchmark

ip-tree

matrix-mul
radix-sort
ﬁndmax
crc32

genetic-algo

heap-add
med-risks
histogram

map

bin-search
heap-pop
classiﬁer

tax

dijkstra

GEO MEAN

Raccoon
Overhead
1.01×
1.01×
1.01×
1.01×
1.02×
1.03×
1.03×
1.76×
1.76×
2.04×
11.85×
45.40×
53.29×
444.36×
859.65×
5.32×

Escort

Overhead
2.40×
1.01×
1.06×
1.27×
1.00×
1.03×
1.27×
1.99×
2.26×
1.01×
1.01×
1.44×
1.24×
1.67×
1.10×
1.32×

Table 11: Performance comparison of benchmarks com-
piled using Raccoon and Escort. We only compare the
control ﬂow obfuscation overhead, since both Raccoon
and Escort use the same technique for data access obfus-
cation.

the stack for each branch instruction. Since the stack
can be arbitrarily large, such copying and restoring adds
substantial overhead to the running time of the program.
On the other hand, Escort’s code rewriting technique ob-
fuscates code at compile time using basic block predi-
cates, which enables signiﬁcant performance boosts on
the above benchmarks.

8 Conclusions

In this paper, we have presented Escort, a compiler-based
tool that closes side channels that stem from ﬂoating-
point operations. Escort prevents an attacker from in-
ferring secret ﬂoating-point operands through the tim-
ing channel, though micro-architectural state, and also
through off-chip digital side channels, such as memory
address trace.

Escort uses native SSE instructions to provide speed
and precision. Escort’s compiler-based approach enables
it to support a signiﬁcantly larger number of ﬂoating-
point operations (112) than FTFP (19).

Escort’s design motivates further research into hard-
ware support for side-channel resistant systems. For ex-
ample, by allowing software to control the timing of in-
teger instruction latencies and their pipelined execution,
Escort’s guarantees could be extended to instructions be-
yond ﬂoating-point instructions.

Acknowledgments. We thank our shepherd Stephen
McCamant and the anonymous reviewers for their help-
ful feedback. We also thank David Kohlbrenner for giv-
ing us the Firefox timing attack code. We are grateful
to Jia Chen for providing us the pointer analysis library,
and to Joshua Eversmann for help with code and discus-
sions. This research was funded in part by NSF Grants
DRL-1441009, CNS-1314709, and CCF-1453806, C-
FAR (one of the six SRC STARnet Centers sponsored
by MARCO and DARPA), and a gift from Qualcomm.

References
[1] ABADI, M., ET AL. Tensorﬂow: Large-scale machine learn-
ing on heterogeneous distributed systems. Computing Research
Repository abs/1603.04467 (2016).

[2] ACIIC¸ MEZ, O., KOC¸ , C¸ . K., AND SEIFERT, J.-P. On the Power
of Simple Branch Prediction Analysis. In Symposium on Informa-
tion, Computer and Communications Security (2007), pp. 312–
320.

[3] ANDRYSCO, M., KOHLBRENNER, D., MOWERY, K., JHALA,
R., LERNER, S., AND SHACHAM, H. On Subnormal Floating
Point and Abnormal Timing. In Symposium on Security and Pri-
vacy (S&P) (2015), pp. 623–639.

[4] BRUMLEY, D., AND BONEH, D. Remote Timing Attacks are

Practical. Computer Networks 48, 5 (2005), 701–716.

[5] CLEEMPUT, J. V., COPPENS, B., AND DE SUTTER, B. Com-
piler Mitigations for Time Attacks on Modern x86 Processors.
Transactions on Architecture and Code Optimization 8, 4 (Jan.
2012), 23:1–23:20.

[6] CRANE, S., HOMESCU, A., BRUNTHALER, S., LARSEN, P.,
Thwarting Cache Side-Channel Attacks
In Network and Dis-

AND FRANZ, M.
Through Dynamic Software Diversity.
tributed System Security Symposium (2015).

[7] DE MOURA, L., AND BJØRNER, N. Z3: An Efﬁcient SMT
Solver. In International Conference on Tools and Algorithms for
the Construction and Analysis of Systems (2008), pp. 337–340.

[8] DEMMEL, J. W. Effects of Underﬂow on Solving Linear Sys-
tems. Tech. Rep. UCB/CSD-83-128, EECS Department, Univer-
sity of California, Berkeley, Aug 1983.

[9] GANDOLFI, K., MOURTEL, C., AND OLIVIER, F. Electromag-
netic Analysis: Concrete Results. In Third International Work-
shop on Cryptographic Hardware and Embedded Systems (2001),
pp. 251–261.

[10] GROSSSCH ¨ADL, J., OSWALD, E., PAGE, D., AND TUNSTALL,
M. Side-Channel Analysis of Cryptographic Software via Early-
terminating Multiplications. In International Conference on In-
formation Security and Cryptology (2010), pp. 176–192.

[11] ISLAM, M. S., KUZU, M., AND KANTARCIOGLU, M. Access
Pattern Disclosure on Searchable Encryption: Ramiﬁcation, At-
tack and Mitigation. In Network and Distributed System Security
Symposium, NDSS (2012).

[12] JANA, S., AND SHMATIKOV, V. Memento: Learning Secrets
from Process Footprints. In Symposium on Security and Privacy
(S&P) (2012), pp. 143–157.

[13] KAHAN, W.

Interval Arithmetic Options in the Proposed
IEEE Floating-Point Arithmetic Standard. Interval Mathematics
(1980), 99–128.

[14] KOCHER, P. C. Timing Attacks on Implementations of Difﬁe-
Hellman, RSA, DSS, and Other Systems. In Advances in Cryp-
tology (1996), pp. 104–113.

USENIX Association  

25th USENIX Security Symposium  85

[33] STEFANOV, E., VAN DIJK, M., SHI, E., FLETCHER, C. W.,
REN, L., YU, X., AND DEVADAS, S. Path ORAM: An Ex-
tremely Simple Oblivious RAM Protocol. In Conference on Com-
puter and Communications Security (2013), pp. 299–310.

[34] TUKEY, J. Exploratory Data Analysis. Pearson, 1977.
[35] WANG, Y., FERRAIUOLO, A., AND SUH, G. E. Timing Chan-
nel Protection for a Shared Memory Controller. In International
Symposium on High Performance Computer Architecture (2014),
pp. 225–236.

[36] WANG, Z., AND LEE, R. B. New Cache Designs for Thwarting
In International

Software Cache-based Side Channel Attacks.
Symposium on Computer Architecture (2007), pp. 494–505.

[37] WANG, Z., AND LEE, R. B. A Novel Cache Architecture with
Enhanced Performance and Security. In International Symposium
on Microarchitecture (2008), pp. 83–93.

[38] ZHANG, D., ASKAROV, A., AND MYERS, A. C. Predictive
Mitigation of Timing Channels in Interactive Systems. In Confer-
ence on Conference on Computer and Communications Security
(2011), pp. 563–574.

[39] ZHANG, Y., AND REITER, M. K. Duppel: Retroﬁtting Com-
modity Operating Systems to Mitigate Cache Side Channels in
the Cloud. In Conference on Computer and Communications Se-
curity (2013), pp. 827–838.

[15] KOCHER, P. C., JAFFE, J., AND JUN, B. Differential Power
Analysis. In 19th Annual International Cryptology Conference
on Advances in Cryptology (1999), pp. 388–397.

[16] KONG, J., ACIIC¸ MEZ, O., SEIFERT, J., AND ZHOU, H.
Hardware-Software Integrated Approaches to Defend Against
Software Cache-Based Side Channel Attacks.
In International
Conference on High-Performance Computer Architecture (2009),
pp. 393–404.

[17] LATTNER, C., AND ADVE, V. S. LLVM: A Compilation Frame-
work for Lifelong Program Analysis & Transformation.
In In-
ternational Symposium on Code Generation and Optimization
(2004), pp. 75–88.

[18] LIU, C., HARRIS, A., MAAS, M., HICKS, M., TIWARI, M.,
AND SHI, E. GhostRider: A Hardware-Software System for
Memory Trace Oblivious Computation. In International Confer-
ence on Architectural Support for Programming Languages and
Operating Systems (2015), pp. 87–101.

[19] LUK, C., ET AL. Pin: Building Customized Program Analysis
Tools with Dynamic Instrumentation. In Conference on Program-
ming Language Design and Implementation (2005), pp. 190–200.
[20] MAAS, M., LOVE, E., STEFANOV, E., TIWARI, M., SHI, E.,
ASANOVIC, K., KUBIATOWICZ, J., AND SONG, D. PHAN-
TOM: Practical Oblivious Computation in a Secure Processor. In
Conference on Computer and Communications Security (2013),
pp. 311–324.

[21] MARTIN, R., DEMME, J., AND SETHUMADHAVAN, S. Time-
Warp: Rethinking Timekeeping and Performance Monitoring
Mechanisms to Mitigate Side-Channel Attacks. In International
Symposium on Computer Architecture (2012), pp. 118–129.

[22] MASTI, R. J., ET AL. Thermal Covert Channels on Multi-core
Platforms. In USENIX Security Symposium (2015), pp. 865–880.
[23] MOLNAR, D., PIOTROWSKI, M., SCHULTZ, D., AND WAG-
NER, D. The Program Counter Security Model: Automatic De-
tection and Removal of Control-Flow Side Channel Attacks. In
International Conference on Information Security and Cryptol-
ogy (2005), pp. 156–168.

[24] MUCHNICK, S. Advanced Compiler Design and Implementation.

Morgan Kaufmann Publishers Inc., 1997.

[25] MULLER, J.-M. On the deﬁnition of ulp(x). Tech. Rep. 2005-

009, ENS Lyon, February 2005.

[26] OSVIK, D. A., SHAMIR, A., AND TROMER, E. Cache Attacks
and Countermeasures: the Case of AES. In RSA Conference on
Topics in Cryptology (2006), pp. 1–20.

[27] PERCIVAL, C. Cache Missing for Fun and Proﬁt. In Proceedings

of the Technical BSD Conference (2005).

[28] RANE, A., LIN, C., AND TIWARI, M. Raccoon: Closing Dig-
In USENIX

ital Side-channels Through Obfuscated Execution.
Conference on Security Symposium (2015), pp. 431–446.

[29] REN, L., YU, X., FLETCHER, C., VAN DIJK, M., AND DE-
VADAS, S. Design Space Exploration and Optimization of Path
Oblivious RAM in Secure Processors. In International Sympo-
sium on Computer Architecture (2013), pp. 571–582.

[30] SAKURAI, K., AND TAKAGI, T. A Reject Timing Attack on an
IND-CCA2 Public-key Cryptosystem. In International Confer-
ence on Information Security and Cryptology (2003), pp. 359–
374.

[31] SCHINDLER, W. A Timing Attack Against RSA with the Chi-
nese Remainder Theorem. In International Workshop on Crypto-
graphic Hardware and Embedded Systems (2000), pp. 109–124.
[32] SHI, E., CHAN, T. H., STEFANOV, E., AND LI, M. Oblivious
RAM with O((logN)3) Worst-Case Cost. In Advances in Cryp-
tology (2011), pp. 197–214.

86  25th USENIX Security Symposium 

USENIX Association

