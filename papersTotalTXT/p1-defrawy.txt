Founding Digital Currency on Secure Computation

Karim El Defrawy
HRL Laboratories

3011 Malibu Canyon Rd
kmeldefrawy@hrl.com

Malibu, CA 90265

Department of Mathematics, UCLA

Box 951555

∗
Joshua Lampkins

Los Angeles, CA 90095

jlampkins@math.ucla.edu

ABSTRACT
Most current digital currency schemes and associated ledgers
are either centralized or completely distributed similar to
the design adopted by Bitcoin. Centralized schemes en-
able accountability, but leave the privacy of users’ identi-
ties and transactions in the hands of one organization. Dis-
tributed schemes can ensure better privacy but provide little
accountability. In this paper we design a privacy-preserving
proactively-secure distributed ledger and associated transac-
tion protocols that can be used to implement an accountable
digital currency that inherits the ledger’s privacy and secu-
rity features. One of the main technical challenges that we
address is dealing with the increase in ledger size over time,
an unavoidable aspect as the currency spreads and the ledger
is required to be maintained for a long time in the future. We
accomplish this by reducing the distributed (secret-shared)
storage footprint and the required bandwidth and computa-
tion for proactively refreshing the ledger to ensure long-term
con(cid:12)dentiality and security.

1.

INTRODUCTION

Despite the large number of digital currency schemes that
have been proposed, e.g., [18, 19, 9, 10, 7], few have been
implemented and adopted by a large number of users. Bit-
coin [37] is currently the scheme that enjoys the widest adop-
tion and is attracting the most attention. In existing digital
currency designs either the scheme is decentralized, similar
to Bitcoin and its replicas [1, 2], or centralized [18, 19, 9, 10,
7]. The completely decentralized nature of digital currencies
such as Bitcoin prevents accountability and oversight from
being e(cid:11)ectively implemented. If a Bitcoin wallet’s private
keys are lost or stolen (a common occurrence lately [35]),
there is no way to recover coins from such wallets. Thieves
can hardly be identi(cid:12)ed when bitcoins are stolen.
If bit-
coins are used to sell illegal goods, it is very di(cid:14)cult for law
enforcement to identify the vendor. On the other hand, a
∗
 
Permission to make digital or hard copies of all or part of this work for personal 
or classroom use is granted without fee provided that copies are not made or 
distributed for profit or commercial advantage and that copies bear this notice 
and the full citation on the first page. Copyrights for components of this work 
owned  by  others  than  ACM  must  be  honored.  Abstracting  with  credit  is 
permitted. To copy otherwise, or republish, to post on servers or to redistribute 
to  lists,  requires  prior  specific  permission  and/or  a  fee.  Request  permissions 
from permissions@acm.org. 
CCS’14, November 3–7, 2014, Scottsdale, Arizona, USA. 
Copyright © 2014 ACM  978-1-4503-2957-6/14/11…$15.00. 
http://dx.doi.org/10.1145/2660267.2660293.

Work performed while at HRL Laboratories.

major concern with centralized digital currencies is that an
institution issuing them can undermine user’s privacy and
is a single point of failure, in sharp contrast to decentralized
schemes.

Stepping back, we observe that most (physical and digi-
tal) currencies today e(cid:11)ectively exist in the form of a ledger.
For example, when someone stores money in a bank ac-
count, the bank keeps a centralized ledger indicating how
much that person owns. In the case of a fully distributed
scheme such as Bitcoin, the distributed ledger is stored (and
veri(cid:12)ed) by a large number of nodes scattered throughout
the Internet. By striking a balance between the centralized
and decentralized frameworks, we present the design of a
privacy-preserving and proactively-secure distributed ledger
that can be used to implement a digital currency in which:
(1) The ledger is kept not by an individual server or entity,
but by a large (possibly dynamic) group of Ledger Servers
preferably owned/operated by di(cid:11)erent entities. (2) Com-
putation on the ledger is performed without revealing secret
values of account balances or the identities of users.
(3)
The ledger is stored such that an adversary would have to
corrupt a signi(cid:12)cant fraction, e.g., approaching 1/3 or 1/2,
of the servers in order to alter or even recover the ledger.
(4) The ledger is periodically refreshed so that even if por-
tions of it are obtained by an attacker, they cannot be used
with other ones obtained in the future to uncover any trans-
actions or ledger entries. Such a ledger and the function-
alities required to implement a digital currency’s necessary
transaction protocols can be cast as a special case of secure
multiparty computation (MPC).

A scheme satisfying the above properties can be used to
instantiate a multi-organization, or multi-government issued
currency where each Ledger Server is controlled by one of
the organizations or governments.
In the case of a multi-
government currency, Ledger Servers would (ideally) be lo-
cated in multiple countries to prevent any single government
from shutting them down.1

Finally, we stress that it is critically important to deter-
mine how the ledger of a digital currency scheme can be
stored and maintained e(cid:14)ciently for a long period of time.
If the ledger is to contain a record of every transaction, its
size will only increase with time. For example, at time of
writing, the size of the Bitcoin ledger has increased from
7GB to 17GB over the past year.2 The costs of storing the

1We note that the politics of how this ledger is deployed and
regulatory issues concerning it are interesting questions but
are outside the scope of this paper.
2 http://blockchain.info/charts/blocks-size.

1Bitcoin ledger could become prohibitive if Bitcoin ever sees
widespread adoption as pointed out by some researchers [32].
In our digital currency scheme, the transaction data is ini-
tially secret-shared among the Ledger Servers. This could
present long-term storage and maintenance problems, since
secret sharing increases the total amount of memory re-
quired for storing data, and refreshing secret-shared data
consumes a lot of bandwidth. We solve this problem by de-
signing a new secure protocol (outlined in Section 3.4.3) for
e(cid:14)ciently converting secret sharings into batch sharings [28]
without reconstructing stored secrets; this reduces both the
storage and bandwidth required for maintaining and refresh-
ing ledger entries and data.

Outline: In Section 2 we discuss related work. In Sec-
tion 3, we provide the technical details and assumptions of
the design and operation of the new ledger and the trans-
action and accountability protocols and the digital currency
scheme that can be built using it.
In Section 4, we dis-
cuss some possible modi(cid:12)cations to the scheme, speci(cid:12)cally
focusing on anonymity and increasing the threshold for tol-
erated corruption in ledger nodes.
In the Appendices we
provide a functionality, simulator, and security proof for
the novel protocol that converts single-sharings to batch-
sharings, and sketch a security proof for the entire digital
currency scheme. In the full version [23], we provide per-
formance analysis of some of the subprotocols to estimate
the time required to perform transactions and the proactive
refreshing of the ledger.

2. RELATED WORK

Research Proposals for Digital Currency Schemes: E-cash
was initially introduced by Chaum [18] in 1982.
In [18],
the author describes how blind digital signatures could be
used to issue electronic coins that could be anonymously
spent at a merchant.
In [19], this idea was applied using
blind RSA digital signatures;
[19] also addresses double-
spending. E-cash schemes that provide the ability for some
authority to revoke the anonymity of transactions are called
fair payment systems, which were independently introduced
in [43],[8], and [6]. The scheme in [43] uses RSA moduli,
whereas [6] and [8] are based on discrete logarithms.
In
[34], the group signature scheme of [14] was altered to con-
struct a group blind signature scheme, and implemented e-
cash in a manner similar to schemes that used single-signer
blind signatures. A publicly veri(cid:12)able secret sharing (PVSS)
scheme is presented in [40], and the author suggests e-cash
as one possible application. The idea is to take the e-cash
scheme of either [11] or [27] and share some of the data
using the PVSS scheme. An e-cash scheme with multiple
issuing authorities that uses blind threshold signatures was
presented in [31]; any t out of n issuers can issue coins us-
ing the blind signatures. In theory, one could construct a
digital currency scheme from an existing scheme by hav-
ing multiple banks/coin issuers and requiring coins from a
threshold number of issuers in order to spend. However,
this would require some mechanism for ensuring that the is-
suers keep copies of the same ledger. In addition, the issuers
must coordinate to ensure that a user cannot double-spend
by requesting n coins from n issuers and spending n/2 coins
at each of two merchants (since n/2 would be more than
a threshold amount). Exploring such a scheme may be an
area for future work.

Deployed Distributed Digital Currencies: Bitcoin’s [37]
success may be largely attributed to being the (cid:12)rst imple-
mentation of a completely decentralized digital currency; the
ledger of Bitcoin transactions is stored and veri(cid:12)ed by a
group of \miners". The miners are rewarded for verifying
transactions and preserving the integrity of the ledger with
\mined" bitcoins and transaction fees provided by Bitcoin
users. An adversary that controls less than 50% of the min-
ing network will, with high probability, be incapable of caus-
ing inconsistencies in the ledger. However, a recent paper
suggests that the corruption threshold for certain attacks is
likely no more than 25% [26]. In the wake of Bitcoin’s suc-
cess, several other digital currencies have been implemented
that use the same basic design as Bitcoin but add features
to it, e.g., Litecoin [1] and Primecoin [2]. As these coins are
marketed largely as alternatives to Bitcoin, they are some-
times referred to as \altcoins." Zerocoin [36] improves the
anonymity of Bitcoin using zero-knowledge proofs. The case
of Zerocoin notwithstanding, there have been minor di(cid:11)er-
ences in altcoin designs, typically varying the utilized proof-
of-work scheme. Finally, [3] proposes to certify Bitcoin ad-
dresses to provide users with opt-in guarantees to send (and
receive) bitcoins only to (from) certi(cid:12)ed users. The scheme
in [3] also enables the control of creation of Bitcoin addresses
by trusted authorities. Certi(cid:12)ed addresses prevent man-in-
the-middle attacks and provide assurance that entities users
are interacting with have been certi(cid:12)ed, though it is still
possible to lose private keys of certi(cid:12)ed addresses or have
them stolen and thus losing bitcoins associated with them.
Our Work Compared To Other Schemes: To our knowl-
edge, this is the (cid:12)rst digital currency proposal (which we call
Proactively-private Digital Currency, PDC ) that uses se-
cure multiparty computation (MPC) to keep a secret-shared
ledger among a (possibly dynamic) group of servers. In this
paper, we mainly focus on a version that provides revoca-
ble (escrowed) anonymity; however, Section 4 describes how
adding a couple of modi(cid:12)cations can provide non-revoca
ble anonymity if desired. Most digital currency schemes
(e.g., [19, 43, 6, 34]) do not hide the value being trans-
mitted or the balances in users’ accounts. PDC hides both
transmission values and balances (unless suspicious activ-
ity is reported) while still preventing overdrawing.
If the
values stored at addresses were known to an adversary, the
adversary could then target users with a large number of
coins and try to compromise their personal computers to
steal such coins. Furthermore, law enforcement often views
transactions involving large amounts of cash as inherently
suspicious, regardless of whether there is any evidence of il-
legal activity; PDC eliminates concerns about such scrutiny.
Our design allows de-anonymizing and freezing of sus-
pect addresses, allows users to retrieve lost coins, and allows
the Ledger Servers to implement analytics on the accounts
and transactions without violating user privacy. Although
schemes with revocable anonymity have been presented ([13,
12, 6]), PDC provides a unique incentive for those entrusted
with the user’s identity to preserve anonymity unless it is
necessary to de-anonymize. In the schemes mentioned above,
the entities that revoke anonymity are not involved with
the transactions. In PDC, the Ledger Servers are responsi-
ble for processing transactions and for de-anonymizing ma-
licious users. Since the Ledger Servers collect a transaction
fee on each transaction, they will each possess a (presum-
ably) large amount of the currency. If the Ledger Servers

2de-anonymize users without proper justi(cid:12)cation, this could
make the public less inclined to use the currency, hence de-
valuing it. This devaluation would have a direct, negative,
(cid:12)nancial impact on the Ledger Servers.

3. PRIVACY-PRESERVING PROACTIVELY-

SECURE DIGITAL CURRENCY

This section provides an overview of the operation of the
Proactively-private Digital Currency (PDC) scheme and
outlines some cryptographic preliminaries. The section also
describes details of maintaining the ledger, protocols to per-
form individual operations required in (cid:12)nancial transactions,
protocols for enforcing accountability, and the main loop ex-
ecuted by the Ledger Servers. The section ends with a sketch
of the security arguments for our protocols (more details in
the Appendices).
3.1 Overview of the PDC Scheme

The main idea behind the PDC scheme is to design a digi-
tal currency in which the ledger of balances and transactions
is kept by a group of Ledger Servers in secret-shared form.
The group of servers can be dynamic if mobile secret sharing
is used [41]. Apart from the Ledger Servers, there are users
who own units of the currency, which we call coins, and who
may want to transfer coins to other users. Each user may
have multiple addresses, which are just public keys. The
address serves the same purpose as an account number at
a bank. To ensure that the identities of users can be re-
covered if malicious activity occurs, an Identity Veri(cid:12)cation
Server (IVS) will be used to facilitate linking identities to
addresses with (threshold) revocable anonymity.
(We de-
scribe in Section 4 a completely anonymous version of PDC
with no IVS.)

The operation of the PDC scheme using the proposed

ledger proceeds as follows:

Initialization: When a user wants to create an address,
the user provides her identity to an IVS. The IVS checks
that the provided identity is the identity of a real person
who can be located and be accountable if illegal activity is
detected, similar to existing Bitcoin payment systems such
as Coinbase. If the veri(cid:12)cation succeeds, the IVS sends back
to the user a signature on the identity. The user then gener-
ates a private/public key pair, with the public key serving as
her address. The user sends to each ledger server a request
to initialize an address; the request includes the public key
that serves as the address, a share of the identity, and a share
of the IVS’s signature on the identity. The Ledger Servers
then invoke an MPC-based signature veri(cid:12)cation protocol
without revealing the identity. This MPC-based signature
veri(cid:12)cation protocol is only executed once per address and
does not have to work in real time. If the signature is valid,
the Ledger Servers add the address, with zero balance, to
the balance ledger.
(Details of initializing an address are
given in Section 3.5.1.)

Sending and Receiving Coins: When a user wants to send
coins to some address, she sends to each Ledger Server the
sending address, the receiving address, and a share of each
bit in the binary representation of the transaction value.
The ledger servers use a secure comparison protocol to en-
sure that the user is not overdrawing the balance stored at
the address; the comparison protocol does not reveal the
value stored at the address or the value being transmitted.

If the user is not overdrawing, the transaction value and
a transaction fee (collected by the Ledger Servers) is sub-
tracted from the sending address, and the transaction value
is added to the receiving address. The transactional data is
then stored in the transaction ledger. (Details of processing
transactions are given in Section 3.5.2.)

Balance Checking: When a user wants to check the bal-
ance of an address or view recent transactions to/from that
address, she sends a request to each of the Ledger Servers,
and each replies with its share(s) of the requested value(s).
(Details of balance checks are given in Section 3.5.3.)

Accountability: If some law enforcement or other agencies
have evidence that an address is associated with illegal ac-
tivity, it can send this evidence to each of the Ledger Servers,
and so long as more than a su(cid:14)cient (function of tolerated
corruption threshold) number of the Ledger Servers agree,
they can de-anonymize the address by sending their shares
of the associated identity to said agency. The address may
also be frozen pending legal action. In addition, PDC can
implement retrieval of lost coins. (An overview of such ac-
countability protocols are given in Section 3.6.)

Long Term Con(cid:12)dentiality: The ledger maintained by the
Ledger Servers contains (possibly highly) sensitive (cid:12)nancial
data, so it is imperative to ensure secure, long-term storage
of such data. To keep the ledger secure, the Ledger Servers
will periodically perform a proactive refresh protocol on all
data that has been secret-shared. One technical challenge
that must be solved is dealing with the increase in ledger
entries over time and reducing its storage footprint and the
bandwidth and computation required for the proactive re-
fresh. (Details of proactive refresh and how these challenges
are solved are given in Section 3.4.3.)
3.2 Cryptographic Preliminaries

The parties involved in PDC are the n Ledger Servers
S1, . . . , Sn, the Identity Veri(cid:12)cation Server(s), V , and the
users; an individual user is denoted U . For the protocols
used in this paper, the threshold of corruption for the Ledger
Servers is t < (1/3− ϵ)n for some positive constant ϵ. Oper-
ations occur over a (cid:12)nite (cid:12)eld Zp for some prime p > 2γ+κ,
where γ is the number of bits needed to represent the total
amount of coins in circulation and κ is a security parameter.
We use both Shamir single secret sharing [42] and Franklin-
Yung batch sharing [28]. To share a single secret s, a party
selects a degree t polynomial that is uniformly random sub-
ject to f (0) = s and sends to each server Si the point f (i).
To batch-share a collection of secrets s(1), . . . , s(ℓ), a party
selects a polynomial g of degree d = ℓ + t − 1 such that
g(−k) = s(k) for k = 1, . . . , ℓ and g(−ℓ − k) is random for
k = 1, . . . , t, and then sends to each server Si the point g(i).
We set the batch size ℓ to n − 3t.

For both single secret sharing and batch sharing, the Berle
kamp-Welch algorithm [5] is used to interpolate polynomials
whenever interpolation is needed in the proposed protocols.
We assume a public key signature and encryption scheme.
The operations of encrypting using key K and signing us-
ing the private key corresponding to K are denoted EncK
and SigK . By abuse of notation, we write SigV to denote
signatures using party V ’s private key. We assume secure,
authenticated channels between all parties, as well as an
authenticated broadcast channel. In practice, a broadcast
channel would likely be implemented via a broadcast proto-
col; our timing analysis in the full version [23] assumes t + 1

3communication rounds for broadcast, which can be achieved
using, e.g., the broadcast protocol in [29].

The PDC scheme requires the use of cryptographic proto-
cols from the MPC literature. In particular, it requires a pro-
tocol for secret sharing (denoted Share), for generating secret
sharings of random values (Random), for generating secret
sharings of zero values (Zero), for multiplying shared val-
ues (Mult), for publicly opening sharings (Open), for proac-
tively refreshing secret sharings (Refresh, see details in Sec-
tion 3.4.3), and for secure comparison (Compare). Except
for secure comparison, we require protocols that can per-
form these operations with both single-sharings and batch-
sharings. The batch sharing versions of the protocols will be
subscripted with B (i.e., the protocol for generating a batch
sharing of all zeros is ZeroB). Any protocols that perform
these tasks will work for PDC, so long as the corruption
threshold for the protocols is not lower than t and the pro-
tocols are unconditionally secure.3 In particular, we could
use the comparison protocol of [24], the proactive refresh
protocol of [4], and use [21] for the other protocols. There
is no Zero protocol in [21], but the secret sharing protocol
in [21] can be modi(cid:12)ed to do this. The protocols in [21] are
for single secret sharings, but they can easily be modi(cid:12)ed to
work with batch sharings.
3.3 Adversary Model

We assume a fully malicious adversary that corrupts the
Ledger Servers in a Byzantine manner, i.e., corrupted Ledger
Servers may behave arbitrarily. The adversary is mobile so
any number of Ledger Servers may be corrupted over the
course of the protocol. The adversary is limited in how
many Ledger Servers may be corrupt at any one time as
follows: The computation is divided into phases. The pe-
riod between consecutive executions of the proactive refresh
protocol is one phase; the refresh protocol itself is considered
to be in both adjacent phases. The adversary is allowed to
corrupt and decorrupt Ledger Servers at will, so long as no
more than t Ledger Servers are corrupted in any phase. See
section 3.4.3 for a discussion of how long term security is
maintained against a mobile adversary.

We assume that the Identity Veri(cid:12)cation Server is always
passively corrupted, but never maliciously corrupted; this is
necessary to guarantee that users cannot generate addresses
without providing valid identities. Any number of users may
be statically corrupted, meaning that the adversary decides
at the outset of the protocol which users she wants to cor-
rupt, and cannot corrupt users during protocol execution.
3.4 Ledger Details

3.4.1 Overview of Ledger
We require two ledgers to be maintained by the Ledger
Servers. The (cid:12)rst ledger keeps track of the balance in each
address, and the second records transaction history; these
are called the balance ledger and transaction ledger, respec-
tively.

For the balance ledger, an individual entry for Ledger
Server Si will be of the form (A, D(i), b(i), c), where A is
the address, D(i) is a share of the identity associated with
the address, b(i) is a share of the current balance stored in
the address, and c is a counter that keeps track of how many

3By \unconditionally secure," we mean that the protocols
do not make any computational hardness assumptions.

transactions have been sent from address A (not counting
transactions to A). The counter c is used when transferring
coins to prevent double-spending attacks.

Entries in the transaction ledger are stored in one of two
formats. Initially, the transaction values are shared among
the Ledger Servers using normal single secret sharing. Once
the number of secret-shared ledger entries is at least ℓ, groups
of ℓ secret sharings are converted into individual batch shar-
ings of size ℓ. Batch sharing reduces the amount of data the
Ledger Servers need to store, and considerably reduces the
cost of proactively refreshing the transaction ledger. Details
of the conversion from secret sharings to batch sharings are
given in Section 3.4.3. The protocol that achieves such con-
version is one of the main contributions of this paper and
can be used in other secure computation contexts.

An individual secret-shared transaction ledger entry for
Ledger Server Si will be of the form (Afrom, Ato, c, B, s(i)),
where Afrom is the sending address, Ato is the receiving ad-
dress, c is a counter indicating that this was the cth trans-
action from address Afrom, B is the number of the block
in which the transaction was processed, and s(i) is a share
of the amount sent. An individual batch-shared transac-
tion ledger entry for Ledger Server Si will be of the form
{(A(k)
to , c(k),
B(k)) is the data corresponding to the transaction value
stored in batch location k in the polynomial s.

to , c(k), B(k))}ℓ

from, A(k)

(

)

k=1, s(i)

, where (A(k)

from, A(k)

3.4.2 Ledger Server Synchronization and Communi-

cation

Most existing secret sharing and MPC protocols assume
a synchronous network setting. Real computer networks,
such as the Internet, are asynchronous; synchronous proto-
cols can work in an asynchronous setting assuming loosely
synchronized clocks and bounded message delays, as shown
in [33]. Any institution operating a Ledger Server will (pre-
sumably) have ample technological resources to provide ac-
curate clocks and bandwidth su(cid:14)cient to ensure messages
arrive in a timely manner. However, there is no way to guar-
antee even loose synchrony on the part of the clients that use
PDC. To coordinate Ledger Servers with clients, data from
clients will be collected into blocks. There is a (cid:12)xed time
interval, M , that de(cid:12)nes the length of each block of data.
Assuming the operation of the system begins at time zero,
the data an individual Ledger Server receives between times
0 and M goes into the (cid:12)rst block, and in general, the data
received between times (T − 1) · M and T · M goes into the
T th block. Once the Ledger Servers (cid:12)nish collecting data
for an individual block, they broadcast the contents of their
block to all the other Ledger Servers.

If one of the Ledger Servers receives a secret share of some
data, it will need to be sure that a su(cid:14)cient number of the
other servers have received shares of the same data before
processing that data. So when the Ledger Servers broad-
cast their blocks of data, each will look at the blocks of the
other Ledger Servers to determine if enough of the shares
have been received by the servers.
If enough shares have
been received, the Ledger Servers will process the data in a
synchronous fashion.

We assume that the delay for transmission from user to
Ledger Server is less than M (which we assume to be a
couple of seconds). In the case that network latency or ma-
licious intent causes the client’s shares to arrive at di(cid:11)erent

4servers at di(cid:11)erent times, the delay may be enough that the
shares are collected into the T th block for some servers and
the (T + 1)th block for other servers. To account for this
possibility, messages will not be processed in the (cid:12)rst block
in which they are broadcast. Instead, they will be carried
over into the next block and re-broadcast. Messages cannot
be retained inde(cid:12)nitely, so no message is broadcast in more
than 2 (consecutive) blocks for an individual Ledger Server.
If a Ledger Server broadcasts a message in two consecutive
blocks, and there are still not enough shares from the other
Ledger Servers in the second block, the message is deleted.
Due to the lack of synchrony between the users and the
Ledger Servers, each protocol that the user engages in with
the Ledger Servers is broken into two protocols: a user
part and a server part. When the user wants to perform
some action, she runs the user protocol. The servers col-
lect messages from users as a part of the main protocol,
the Ledger Server Loop described in Section 3.7. When the
user’s data is broadcast in a block, the servers then engage
in the server part of the protocol. We use a subscript of
U to denote the user part of the protocol and a subscript
of S to denote the server part of the protocol. So for in-
stance, when a user wants to initialize an address, the user
runs Initialize AddressU ; once the Ledger Servers are ready to
process the received data, they run Initialize AddressS. We
refer to the two protocols together as Initialize Address.
3.4.3 Ensuring Long-term Conﬁdentiality by Proac-

tively Refreshing the Ledgers

In standard multiparty computation protocols, it is as-
sumed that an adversary can corrupt no more than a (cid:12)xed
fraction of the parties performing the computation. How-
ever, it is more realistic to assume that a sophisticated ad-
versary could eventually corrupt every party given a long
enough period of time. In the proactive security model, an
adversary can corrupt any number of parties, but can only
corrupt a (cid:12)xed fraction in any given time; such an adversary
is called a mobile adversary in [38]. Since safeguarding the
ledger of a digital currency is highly critical, we argue that
one should design the ledger to be secure in the proactive
security model.

Protocols for proactively refreshing shared secrets proceed
in two phases. In the (cid:12)rst phase, a secret s shared with a
polynomial P (such that P (0) = s) is updated by setting
P ← P + Q, where Q is a polynomial of the same degree as
P which is random subject to the constraint that Q(0) = 0.4
Thus if an adversary learns no more than a threshold num-
ber of shares for the old P , this will give her no information
about the secret when combined with shares of the new P ,
because the shares are independently distributed. In the sec-
ond phase, parties who had previously been corrupted and
may have lost or corrupted data (either due to alteration of
memory by malware or by a hard reboot to remove malware)
recover the lost shares by interacting with the other parties.
There are multiple proposals for proactive refresh schemes
[30, 41, 4]. We provide an instantiation of PDC with the
scheme from [4], as it only assumes secure channels, whereas
the other two schemes use the discrete logarithm assump-
tion. Although in practice secure channels would be imple-
mented with a public key infrastructure (PKI), we would like
to assume only a generic PKI instead of discrete logarithm-

4If P is a batch sharing, then Q will be a sharing of a batch
of all zeros.

based PKI. When refreshing the ledger we utilize the pro-
tocol from [4] (called Block-Redistribute) with a threshold of
t < (1/3 − ϵ) and a batch size of ℓ = n − 3t, but we do
not use player virtualization, and we do not require that ℓ
be a power of two as in [4]. Although the protocol in [4]
was designed for refreshing batch sharings, it can easily be
modi(cid:12)ed to refresh secret sharings as well.

Recall that all entries in the transaction ledger are initially
secret-shared. Before we describe how the Ledger Servers
coordinate proactive refresh, we (cid:12)rst present a new proto-
col for converting secret sharings into batch sharings, Con-
vert Sharings, which is one of the main contributions of this
paper. We note that since the ledger is only expected to
grow in size, converting secret-shared values into batched
secret-shared values saves storage requirements and speeds
up the proactive-refresh process.

′

.

The following protocol takes as input a group of poly-
nomials that share secrets in batches of size ℓ and out-
puts a group of polynomials that share the same secrets
in batches of size ℓ
In our PDC scheme, this protocol
will be used to convert Shamir sharings (i.e., sharings with
ℓ = 1) into sharings of batch size greater than 1. For this
protocol, we use the notation [X] to denote the set of in-
tegers from 1 to X. Thus the Cartesian product [X] × [Y ]
is {(x, y) : 1 ≤ x ≤ X, 1 ≤ y ≤ Y }. The protocol Con-
vert Sharings uses a set Corr to keep track of which parties
may be corrupt. In step 10, when one party accuses another,
the parties make a worst-case assumption that both parties
are corrupt. Note that this set is distinct from any set of
disputes which may be used in the MPC sub-protocols.

Convert Sharings

b

a

a }(a,k)∈[ℓ′]×[K] of batch size ℓ.

Parties: S1, . . . , Sn.
Input: Each Ledger Server holds shares of batch shar-
ing polynomials {H (k)
Output: Each Ledger Server holds shares of batch
sharing polynomials {V (k)
}(b,k)∈[ℓ]×[K] of batch size ℓ
′
that contain the same secrets as did the H (k)
a .
1. Set Corr = ∅.
2. The servers use RandomB to generate polynomials
H (K+1)
]. (These
polynomials are used for masking and will be dis-
carded later.)

of degree d = ℓ + t − 1 for a ∈ [ℓ
′

+ t − 1 such that U (k)

3. Each Si selects polynomials {U (k)

}k∈[K+1] of degree
a (i) for all
] × [K + 1] and shares them via ShareB.
4. The servers invoke Random K times to generate K

′
d
(a, k) ∈ [ℓ
sharings of random values {r(k)}k∈[K].
{r(k)}k∈[K].

6. De(cid:12)ne eHa and eUi for (a, i) ∈ [ℓ

5. The servers invoke Open K times to publicly reveal

(−a) = H (k)

= ℓ

′

′

i

i

7. Each server sends all their shares of eHa and eUi to

Each server locally computes their shares of these
polynomials.
each other server for each (a, i) ∈ [ℓ
that this is not done using broadcast.)

] × [n]. (Note

′

∑
∑

eHa =
eUi =

′

] × [n] by
a + H (K+1)
i + U (K+1)

a

.

i

K

k=1 r(k)H (k)
k=1 r(k)U (k)

K

5′

] × [n].

] × [n].

9. Each server uses Berlekamp-Welch on the shares of

8. Each server uses Berlekamp-Welch on the shares

of eUi received in the previous step to interpolate
eUi(−a) for each (a, i) ∈ [ℓ
eHa to interpolate eHa(i) for each (a, i) ∈ [ℓ] × [n].
10. Each Sj checks if eUi(−a) = eHa(i) for each (a, i) ∈
If this does not hold for some eUi, then
11. Each server erases all their shares of eHa and eUi,

′
[ℓ
Sj broadcasts (Sj, J’accuse, Si). All servers add Si
and Sj to Corr. (After a server is added to Corr, any
further accusations from that server are ignored.)
] × [K + 1], and
shares of H (k)
shares of U (K+1)
12. De(cid:12)ne G to be the set of the (cid:12)rst n − 2t servers
not in Corr. Let {z1, . . . , zn−2t} denote the set of
indices of servers in G. Let λb,i denote the Lagrange
coe(cid:14)cients for interpolating the evaluation at −b of
∑
a degree-d polynomial from the shares of servers in
G (i.e., for a polynomial f of degree ≤ d, f (−b) =

for each (a, k) ∈ [ℓ
for each i ∈ [n].

a

′

i

n−2t
m=1 λb,mf (zm)).

∑

Each Ledger Server locally computes its share of
V (k)
b =

n−2t
m=1 λb,mU (k)

zm for each (b, k) ∈ [ℓ] × [K].
∑

To see that the interpolation in step 12 results in batch
(−a)
a (−b)
] × [ℓ] × [K]. Thus the sharings V (k)

∑
sharings of
=
for each (a, b, k) ∈ [ℓ
hold the same secrets as H (k)
a .

correct values, note
n−2t
m=1 λb,mH (k)

that V (k)
a (zm) = H (k)

the
n−2t
m=1 λb,mU (k)

zm (−a) =

′

b

b

The Convert Sharings protocol is used in the Ledger Server
Loop (see Section 3.7) to convert single secret sharings to
batch sharings as needed to conserve space.

The Ledger Servers use the protocol Refresh Ledge to proac-
tively refresh their ledger secret sharings and batch sharings.

Refresh Ledger

Parties: S1, . . . , Sn.
Input: Each Ledger Server use all its ledger entries as
input.
Output: Each Ledger Server holds refreshed shares of
the shared data in the ledger.
1. Each Ledger Server broadcasts a list of all addresses
that they have stored in the balance ledger. Any
address that is broadcast by at least n − t of the
servers is added to a list SA of addresses.

2. Each Ledger Server broadcasts a list of all transac-
tion ledger entries whose sending and receiving ad-
dresses are in SA (although they do not broadcast
their shares of the transaction values). Any trans-
action broadcast by at least n − t of the servers is
added to a list ST of transactions.

3. For each address in SA and each secret-shared trans-
action in ST , the Ledger Servers locally add the as-
sociated secret sharings into a list, (f (1), . . . , f (m1)).
Similarly, the batch-shared transactions in ST are
added into a list (g(1), . . . , g(m2)).
invoke

4. The

Servers

Ledger

Refresh with
input and RefreshB with

(f (1), . . . , f (m1)) as
(g(1), . . . , g(m2)) as input.

5. Each server adds its refreshed shares to the balance

and transaction ledgers.

Since refreshing the ledger adds to the computational and
communication cost of maintaining the system, the transac-
tion ledger entries need not be retained inde(cid:12)nitely. They
could be deleted after some (cid:12)xed amount of time.
3.5 Transaction Protocols

Initializing an Address

This section describes the protocols used to initialize ad-
dresses, transfer coins from one address to another, and to
retrieve data from the ledger of balances and transactions.
3.5.1
The user, U , has an Identity Veri(cid:12)cation Server, V , verify
that the user’s ID is legitimate, the user generates a private
key and corresponding address, then the ID is secret-shared
among the Ledger Servers. This allows the Ledger Servers
to de-anonymize an address if needed at some point in time.
Each message sent to the Ledger Servers will contain a
nonce. The nonce will contain both a time-stamp (used to
prevent replay attacks) and a κ-bit random number.

Initialize AddressU

Parties: U , V , S1, . . . , Sn.
Input: U ’s identifying information, ID.
Output: Signed messages mi (described in the last
step) to each Si.
1. U sends ID to V .
2. V veri(cid:12)es that ID is the identity of a real person.
If so, V returns SigV (ID) to U . If not, V sends the
message reject to U and the protocol terminates.
3. U generates a private key and corresponding public

key A.

4. V generates polynomials f and g of degree t such
that f (0) = ID and g(0) = SigV (ID) and sends
mi = (init_addr, nonce, A, V, f (i), g(i)) along with
SigA(mi) to each Si.

As discussed in Section 3.4.2, after U runs Initialize AddressU ,

the Ledger Servers collect the received data into blocks the
Ledger Server Loop, and after broadcasting these blocks, they
run Initialize AddressS.

Initialize AddressS

Parties: S1, . . . , Sn.
Input: A, V ; at least n − t of the Si hold vi, wi. (The
values vi, wi are the (purported) shares f (i), g(i) re-
ceived from the user in Initialize AddressU .)
Output: Each Si has a balance ledger entry for A.
1. The servers invoke Random twice to generate degree
t polynomials r1 and r2, and each Si that had input
vi, wi broadcasts vi + r1(i) and wi + r2(i).

2. Each server performs the Berlekamp-Welch algo-
rithm to determine if the values broadcast in the
previous step lie on two degree t polynomials, and
if so compute the constant terms. If the Berlekamp-
Welch algorithm fails for either polynomial, the pro-
tocol terminates without initializing the address.

6′

′

′

3. Let v denote the constant term interpolated from
the vi + r1(i), and let w denote the constant term
interpolated from the wi + r2(i). Each Si locally
(i) = v − r1(i). This de(cid:12)nes
computes its share of f
a new polynomial f
(0) = f (0) = ID,
where f is the polynomial from Initialize AddressU
(if U is honest). Similarly, the servers de(cid:12)ne and
(x) = w − r2(x) such that
compute shares of g
′
g

(0) = g(0) = SigV (ID).

such that f

4. The servers run an MPC protocol for verifying that
the value of SigV (ID) received from U is, in fact,
a valid signature for ID. This is performed using
f
as inputs. If the signature is invalid, the
protocol terminates.

and g

′

′

′

5. The servers invoke Zero to generate a polynomial
(i), b(i), 0) to the balance

′

b, and each Si adds (A, f
ledger.

The use of an MPC protocol to verify a secret-shared sig-
nature for a secret-shared identity is the slowest part of the
protocol, but note that this process need only be performed
once for each address. The complexity of the protocol will
vary depending on which public key scheme is being used.
Protocols from [20] for modular arithmetic on secret-shared
values can be used for implementing that step.

3.5.2 Transfer
To transfer coins from one address to another, the sender
secret-shares the amount to be transferred, the Ledger Servers
use a secure comparison protocol to check that the sender is
not overdrawing the address, and then the amount is sub-
tracted from the sender’s balance and added to the recip-
ient’s balance. However, it is also necessary to verify that
the amount being transferred falls into the proper range;
namely, it must be less than 2γ. Therefore, instead of the
sender secret sharing the value as a single (cid:12)eld element, the
sender will secret-share each of the γ bits of the value sepa-
rately.

The transfer protocol must prevent replay attacks in which
the adversary re-sends the transfer request, thereby mov-
ing more coins out of the sender’s address than anticipated.
Therefore, the (signed) transaction will contain a counter;
the counter will be set to j for the jth transaction out of the
address. If the user forgets the value of the counter, she can
perform a balance check (described later).

We allow the Ledger Servers to collect a transaction fee,
z, for each transaction. For simplicity, we assume there is
a single address, X, to which all fees are sent, although
one could modify the protocol to divide the fees among the
Ledger Servers if desired.

TransferU

Parties: U , S1, . . . , Sn.
Input: Sending address A1, receiving address A2, and
transfer value, s.
Output: Signed messages mi (described in the last
step) to each Si.
1. U decomposes s into its binary representation,
p , where s(γ−1) is the most sig-

(s(γ−1), . . . , s(0)) ∈ Zγ
ni(cid:12)cant bit and s(0) is the least signi(cid:12)cant bit.

2. U constructs γ degree t polynomials f (γ−1), . . . , f (0)
such that f (k)(0) = s(k) for each k = 0, . . . , γ − 1.
(tx, nonce, A1, A2, j,
(f (γ−1)(i), . . . , f (0)(i))) and SigA1
to each
Si.

sends mi

3. U

(mi)

=

After receiving the requests to transfer coins from the user,

the Ledger Servers run their portion of the protocol.

TransferS

i

i

i

).

, . . . , v(0)

Parties: S1, . . . , Sn.
Input: A1, A2, j; at least n − t of the Si hold
(v(γ−1)
(The value v(k)
is the (purported)
share f (k)(i) received in TransferU .)
Output: Each Ledger Server has a new entry in the
transaction ledger; additionally, the balance ledger en-
tries for A1 and A2 are updated to re(cid:13)ect the transac-
tion.
1. The Ledger Servers invoke Random γ times to gener-
ate polynomials (r(γ−1), . . . , r(0)), and each Si that
had input (v(γ−1)
, . . . , v(0)
i + r(k)(i)
for each k = 0, . . . , γ − 1.

) broadcasts v(k)

i

i

2. Each server performs the Berlekamp-Welch algo-
rithm to determine if the values broadcast in the
previous step lie on γ degree t polynomials, and if
so compute the constant terms. If the Berlekamp-
Welch algorithm fails for any polynomial, the pro-
tocol terminates without transferring the coins.

i + r(k)(i). Each Si

3. Let C (k) denote the constant term interpolated from
the v(k)
locally computes its
share of g(k)(i) = C (k) − r(k)(i) for each k =
0, . . . , γ − 1. This de(cid:12)nes new polynomials g(k) such
that g(k)(0) = f (k)(0) = s(k), where the f (k) are the
polynomials from TransferU (if U is honest).
4. The servers invoke Zero γ times to generate polyno-
mials {µ(k)}γ−1
k=0, invoke Mult to generate a sharing of
(g(k) + µ(k) − 1)g(k), and invoke Open on the sharing
of the product for each k = 0, . . . , γ−1. If any of the
∑
opened values is not zero, the protocol terminates.
5. Each server locally computes its share s(i) =

γ−1
k=0 2kg(k)(i) of the degree t polynomial s.

6. Let b1 and b2 denote the polynomials stored in the
balance ledger that represent the balances in the ad-
dresses A1 and A2 (respectively). The servers invoke
Compare to verify that b1(0) ≥ z + s(0). If this does
not hold, the protocol terminates.
7. The servers locally update their shares of the bal-
ances in addresses A1 and A2 as follows: b1(i) ←
b1(i) − s(i) − z and b2(i) ← b2(i) + s(i).

8. Each server locally updates the balance ledger entry

for the address X, incrementing its share by z.

9. Each server

locally increments the transaction
counter in the balance ledger for address A1 by one.
10. Each Si adds the entry (A1, A2, j, B, s(i)) to the
transaction ledger, where B is the block in which
this transaction was processed.

3.5.3 Balance Checks and Transaction Conﬁrmations
In the balance check protocol, the user sends a request
for the data, and each Ledger Server sends its copy of the

7transaction \meta-data" (addresses, counter numbers, and
block numbers) as well as shares of the required values. As
far as secret sharings are concerned, this is relatively simple:
Each Ledger Server sends the share as-is. For batch-shared
transactions, some computation by the Ledger Servers is
required before sending shares.

Suppose that U has requested some transactional data
that is stored in a batch with other users’ data. If U ’s re-
quested data is stored in locations k1, k2, . . . , km within the
batch, the Ledger Servers construct a canonical sharing of
a batch with ones in locations k1, k2, . . . , km and zeros else-
where. By canonical sharing, we mean a polynomial g such
that g(−kj) = 1 for each j = 1, . . . , m and g(−k) = 0 for all
other k = 1, . . . , t + ℓ. Since a canonical sharing for a known
set {k1, k2, . . . , km} is completely deterministic, the Ledger
Servers can compute their shares locally without any inter-
action. This sharing is then added to a random sharing of
a batch of all zeros for privacy reasons. The Ledger Servers
invoke MultB to multiply this sum by the batch sharing in
the transaction ledger. The shares of the resultant product
are then sent to the user.

The user looks up transactions that she authorized by
the counter number of the transaction. However, she has
no way to know what the counter number for transactions
she receives will be. Therefore, she looks them up by block
number, which is equivalent to looking them up by the time
at which the coins were received.

Check BalanceU

Parties: U , S1, . . . , Sn.
Input: Address A, for which U holds the private key.
Output: U holds values of the requested ledger entries.
If U wants to view some transactions with A as the
1.
sending address, then U sets j1 to be the earliest
transaction counter value requested and j2 to be the
latest. Otherwise, U sets j1 = j2 =⊥. If U wants
to view some transactions with A as the receiving
address, then U sets B1 to be the earliest block num-
ber requested and B2 to be the latest. Otherwise,
U sets B1 = B2 =⊥.

2. U sends m = (check_bal, nonce, A, j1, j2, B1, B2)

along with SigA(m) to each server Si.

3. U waits some pre-determined amount of time for the
Ledger Servers to respond. Upon receiving shares
of the requested data, U uses the Berlekamp-Welch
algorithm to reconstruct the shared data.

After receiving balance check requests from users in the
main loop, the Ledger Servers run their portion of the pro-
tocol.

Check BalanceS

Input: A, j1, j2, B1, B2.

Parties: U , S1, . . . , Sn.
Output: Requested ledger entries are sent to U .
1. Each server looks for the entry for address A in the
balance ledger, all entries in the transaction ledger
with A as the sending address with counter values
between j1 and j2, and all entries in the transaction
ledger with A as the receiving address with block
numbers between B1 and B2. (If j1 or j2 equals ⊥,
then the server assumes that U does not want infor-

2.

3. Let K (j) = {k(j)

mation on transactions sent from A, and similarly
for B1, B2.)
If none of the data requested is batch-shared, then
skip to step 6. Otherwise, let f (1), . . . , f (w) denote
all the batch-sharings that contain requested data.
} denote the locations in
batch f (j) that correspond to U ’s data, and let g(j)
denote the canonical sharing of the batch with ones
in locations K (j) and zeros elsewhere.

1 , . . . , k(j)
mj

4. The servers invoke ZeroB w times to generate poly-
nomials r(1), . . . , r(w) and locally compute their
shares of h(j) = g(j) + r(j) for each j = 1, . . . , w.

5. The servers invoke MultB to multiply each pair
for j =

resulting in sharings s(j)

(f (j), h(j)),
1, . . . , w.

6. The servers send their shares of all the requested se-
cret sharings to U , along with their shares of each
s(j) if any batch-shared data was requested. Addi-
tionally, the servers send U the associated transac-
tion meta-data and the current transaction counter
in the balance ledger entry for A.

3.6 Accountability Protocols

One of the advantages of secret sharing the identity of
the users is to prevent accidental or malicious loss of coins.
This is a considerable problem with deployed schemes such
as Bitcoin as they exist today. Bitcoin users often loose their
private keys, and hence their coins. There have been several
bitcoin thefts, in one case totaling $1.2 million [35]. Even
though the addresses to which the stolen coins are sent are
often public knowledge, there is no means by which to return
the coins to the victim or at least freeze the suspect address
until the issue is resolved [25]. In theory, addresses could be
frozen and transactions reversed in decentralized schemes,
but this would require coordination among a decentralized
group of ledger operators who have disparate interests and
frequently operate anonymously. Each of the above prob-
lems can be easily addressed in PDC. We brie(cid:13)y describe
solutions to these problems in this section (see the full ver-
sion [23] for more details).

3.6.1 Address Freezing and De-anonymization
Suppose that some law enforcement or investigative entity,
R, has reason to believe that a particular address, A, is
associated with criminal or illegal activity. So long as more
than 2t Ledger Servers agree that the address is suspect,
the secret-shared identity can be revealed, and the Ledger
Servers can refuse to process further transactions from/to
that address. This provides some level of privacy guarantee
to the user, in that the user knows her address cannot be
de-anonymized unless there is some consensus.

The protocol for freezing operates as follows: Each Ledger
Server that receives a properly signed message of the form
(freeze, nonce, A, E) from R examines the evidence, E, and
determines whether or not the address, A should be frozen
and de-anonymized. Each Ledger Server that agrees to coop-
erate with R its share of the identity to R. If R receives more
than 2t shares, R interpolates the identity D(0) of the user
associated with address A. Each Ledger Server that decides
that address A is suspect will ignore any further transaction
requests that send coins to or from that address.

83.6.2 Lost Coin Retrieval
Since the private key associated with an address is used
to sign all messages sent to the Ledger Servers, loosing the
private key is tantamount to loosing the coins stored in the
address, as the coins can no longer be accessed. Loss of pri-
vate keys has been a persistent problem for Bitcoin users, as
there is no way to retrieve such lost coins. Because the user’s
identity is linked to the address in PDC, one can retrieve lost
coins.

Suppose the user has lost the private key for address L
and wants to send the coins in L to a new address A. She
constructs a degree t polynomial Q that is uniformly ran-
dom subject to the constraint that Q(0) = ID, where ID is
her identity. The user sends (ret_coins, nonce, L, A, Q(i))
signed by the identity veri(cid:12)cation server, IV S, to Si for each
i = 1, . . . , n. The Ledger Servers verify IV S’ signature then
subtract the sharing Q provided by the user from the shar-
ing of the identity in the balance ledger entry for L. This
sharing is then multiplied by a random number, and the
product is publicly opened. If the opened value is zero, this
means that the identity provided by the user is the same
as the secret-shared identity stored in the balance ledger, so
the Ledger Servers transfer the coins in L to A as requested.
3.7 Ledger Server Loop

The main protocol run by the Ledger Servers continues in
an inde(cid:12)nite loop, since we assume the currency will exist
for a long time. The core of the PDC scheme is the collection
of data into blocks and the broadcasting of those blocks to
the other servers. Di(cid:11)erent actions are taken according to
what is found in those blocks. The servers are loosely syn-
chronized so as to broadcast their blocks at approximately
the same time. We refer to these points in time as broad-
cast points. We refer to the block broadcast by server Si at
broadcast point T as B(T )

.

Each message received by the Ledger Servers consists of
a header and a collection of shares (although the collection
of shares may be empty). These parts are denoted [header]
and [shares], respectively. (For example, the [header] part
of the message mi sent in Initialize AddressU is (nonce, A, V )
and the [shares] part is (f (i), g(i))). Each header contains
a nonce, and each nonce contains a time-stamp. Recall from
Section 3.4.2 that the Ledger Servers assume that the delay
for transmission from the user is less than M . A time-stamp
is considered out of date if it varies from the Ledger Server’s
clock by at least M .

i

Ledger Server Si performs the following steps:

Ledger Server Loop

1. Set T = 1.
2. Set B(T )

i = ∅. If T ≥ 2, add all messages in B(T−1)

i

that were not in B(T−2)

i

to B(T )

.

i

3. Collect all properly formed and signed messages re-
ceived from users, adding them to the set B(T )
as
they are received. Messages that are out of date,
messages that are duplicates of messages already in
B(T )
, and tx messages with incorrect transaction
counters are deleted. (Duplicates are de(cid:12)ned to be
messages with the same nonce, init_addr messages
with the same address, or tx messages with the same
sending address.)

i

i

i

7.

6.

5.

4. When the broadcast point T is reached (at time T ·
M ), broadcast the headers of all messages in B(T )
.
If some [header] is broadcast by at least n−t Ledger
Servers, and if this is the second broadcast contain-
ing messages with that header, then one of steps 6
through 8 is performed:
If [header] = (init_addr, nonce, A, V ), and if the
address A does not already exist in the balance
ledger, then run Initialize AddressS with A, V as pub-
lic input and Si using the [shares] = (vi, wi) portion
of its message as private input.
If [header] = (tx, nonce, A1, A2, j), and if the ad-
dresses A1, A2 already exist in the balance ledger,
then run TransferS with A1, A2, j as public input
and Si using the [shares] = (v(γ−1)
) por-
tion of its message as private input.
If [header] = (check_bal, nonce, A, j1, j2, B1, B2),
and if
in the
then run Check BalanceS with
balance ledger,
A, j1, j2, B1, B2 as public input. (Here, [shares] =
∅.)
If there are m ≥ ℓ secret sharings in the transaction
ledger, the Ledger Servers run Convert Sharings on
the (cid:12)rst ⌊m/ℓ⌋ℓ of these sharings.

the address A already exists

, . . . , v(0)

9.

8.

i

i

10. Set T ← T + 1.
11. Jump to step 2.

Note that we have not added the protocol Refresh Ledger
to the main loop. It could either be added between steps 10
and 11 in the main loop, or the Ledger Servers could run
a separate loop in parallel with the main loop, constantly
refreshing shared data.
3.8 Security Analysis

The PDC protocols described in this paper build upon
protocols from the MPC literature (listed in Section 3.2)
that are already proven secure in the Universal Composabil-
ity (UC) framework in their respective papers, so security
of our protocols can be proven using the UC composition
theorem [17]. Since the share conversion protocol, Con-
vert Sharings, is one of the main technical contribution of
this paper, we provide its functionality, simulator, and se-
curity proof in Appendix A. We sketch a proof of security
for the entire PDC scheme in Appendix B. (Due to space
constraints, we cannot provide a full security analysis and
proof for each protocol in this version of the paper. Such
details will be provided in the full version [23])

4.

INCREASING ANONYMITY GUARAN-
TEES AND CORRUPTION THRESHOLD
Increasing Anonymity Guarantees: PDC can be made
strictly anonymous, without the user ever revealing her iden-
tity to anyone. The Identity Veri(cid:12)cation Server can be elim-
inated entirely, and the addition of an address to the balance
ledger can be performed in essentially the same way as Bit-
coin: The user generates a private key and corresponding
public key as an address, and the Ledger Servers add this
address to the balance ledger the (cid:12)rst time that a user sends
value to it. Note that lost coins cannot be restored using the
protocol above in this case.

9Anonymizing Tra(cid:14)c: We sketch a protocol allowing a
group of k users to transfer funds from k addresses to k
addresses without any Ledger Server learning which input
address maps to which output address.

Let k be some power of 2. Then k users will send transfer
requests to the Ledger Servers as speci(cid:12)ed in the Transfer
protocol, except that the receiving address will be secret-
shared. The transfer values will be subtracted from the
sending addresses. Then each Ledger Server in turn will
apply a permutation (unknown to the other Ledger Servers)
to the secret-shared transfer values, and apply the same per-
mutation to the secret-shared receiving addresses. This pre-
vents any one Ledger Server from mapping input to output
address.

A secret permutation is applied by server Sq as follows:
Sq picks a random permutation π, and the Ledger Servers
invoke PermuteLayer from the full version of [4] (found in
refrence [2] in that paper) twice with the same permutation,
once the sharings of the transfer values, and once on the
sharings of the receiving addresses. Since the batch size ℓ in
this case is 1, the only subprotocol used will be PermuteBe-
tweenBlocks. Since the permutation is not publicly known,
the Ledger Servers do not known their shares of fI and fI
without input from Sq. So Sq generates polynomials fI and
fI as needed. The Ledger Servers need to prove that one
of these polynomials stores a zero and the other stores a
one. They do this by opening the sum of the sharings and
checking that it is one, and by invoking a secure multiplica-
tion protocol on the sharings and verifying that the product
is zero. The same polynomials fI and fI will be used for
both invocations of PermuteLayer to ensure that the same
permutation is used.

Once the permutation is completed, the receiving addresses
are publicly opened. Then the (permuted) transfer values
are added to the receiving addresses.

Increasing the Corruption Threshold: Although our PDC
scheme assumes signatures, the underlying protocols that
manipulate secret sharings make no computational assump-
tions. Hence the threshold is t < (1/3 − ϵ)n, which is near
optimal for information theoretic protocols. The threshold
can be raised to t < (1/2 − ϵ)n if some computational as-
sumptions are made. For instance, instead of using \stan-
dard" secret sharing, the modi(cid:12)ed PDC could use Pedersen’s
scheme [39], which uses commitments based on the discrete
logarithm assumption. Modifying the PDC sub-protocols to
use Pedersen commitments is fairly straightforward.
5. ACKNOWLEDGEMENTS

We thank the anonymous reviewers for their helpful com-
ments and our shepherd Abhishek Jain for his suggestions
on how to address them. We also thank Joshua Baron,
Jonathan Katz and Gene Tsudik for insightful discussions
about digital currency and MPC.
6. REFERENCES
[1] Litecoin, 2013. https://litecoin.org/.
[2] Primecoin: Cryptocurrency with prime number

proof-of-work, 2013. http:
//primecoin.org/static/primecoin-paper.pdf.

[4] Joshua Baron, Karim El Defrawy, Joshua Lampkins,
and Rafail Ostrovsky. How to withstand mobile virus
attacks, revisited. In Proceedings of the 2014 ACM
Symposium on Principles of Distributed Computing,
PODC ’14, pages 293{302, New York, NY, USA, 2014.
ACM.

[5] Elwyn R. Berlekamp. Algebraic Coding Theory.

Aegean Park Press, 1984.

[6] Ernest F. Brickell, Peter Gemmell, and David W.

Kravitz. Trustee-based tracing extensions to
anonymous cash and the making of anonymous
change. In SODA, pages 457{466, 1995.

[7] J. Camenisch, A. Lysyanskaya, and M. Meyerovich.
Endorsed e-cash. In Security and Privacy, 2007. SP
’07. IEEE Symposium on, pages 101{115, 2007.

[8] Jan Camenisch. Group signature schemes and

payment systems based on the discrete logarithm
problem, 1998.

[9] Jan Camenisch, Susan Hohenberger, and Anna

Lysyanskaya. Compact e-cash. In EUROCRYPT 2005,
pages 302{321. 2005.

[10] Jan Camenisch, Susan Hohenberger, and Anna

Lysyanskaya. Balancing accountability and privacy
using e-cash. In Security and Cryptography for
Networks, pages 141{155. 2006.

[11] Jan Camenisch, Ueli M. Maurer, and Markus Stadler.

Digital payment systems with passive
anonymity-revoking trustees. In ESORICS, pages
33{43, 1996.

[12] Jan Camenisch, Ueli M. Maurer, and Markus Stadler.

Digital payment systems with passive
anonymity-revoking trustees. Journal of Computer
Security, 5(1):69{90, 1997.

[13] Jan Camenisch, Jean-Marc Piveteau, and Markus
Stadler. An e(cid:14)cient fair payment system. In ACM
Conference on Computer and Communications
Security, pages 88{94, 1996.

[14] Jan Camenisch and Markus Stadler. E(cid:14)cient group

signature schemes for large groups. In Jr. Kaliski,
BurtonS., editor, Advances in Cryptology CRYPTO
’97, volume 1294 of Lecture Notes in Computer
Science, pages 410{424. Springer Berlin Heidelberg,
1997.

[15] R. Canetti. Universally composable signature,
certi(cid:12)cation, and authentication. In Computer
Security Foundations Workshop, 2004. Proceedings.
17th IEEE, pages 219{233, June 2004.

[16] Ran Canetti. Security and composition of multiparty

cryptographic protocols. Journal of Cryptology,
13(1):143{202, 2000.

[17] Ran Canetti. Universally composable security: A new

paradigm for cryptographic protocols. IACR
Cryptology ePrint Archive, 2000:67, 2000.

[18] David Chaum. Blind signatures for untraceable

payments. In CRYPTO, pages 199{203, 1982.

[19] David Chaum, Amos Fiat, and Moni Naor.

Untraceable electronic cash. In CRYPTO, pages
319{327, 1988.

[3] Giuseppe Ateniese, Antonio Faonio, Bernardo Magri,

[20] Ivan Damg(cid:23)ard, Matthias Fitzi, Eike Kiltz,

and Breno de Medeiros. Certi(cid:12)ed bitcoins. Cryptology
ePrint Archive, Report 2014/076, 2014.
http://eprint.iacr.org/.

Jesper Buus Nielsen, and Tomas Toft. Unconditionally
secure constant-rounds multi-party computation for

10equality, comparison, bits and exponentiation. In
TCC, pages 285{304, 2006.

[21] Ivan Damg(cid:23)ard and Jesper Buus Nielsen. Scalable and

unconditionally secure multiparty computation. In
CRYPTO, pages 572{590, 2007.

[22] Ivan Damg(cid:23)ard, Yuval Ishai, and Mikkel Kr(cid:28)igaard.

Perfectly secure multiparty computation and the
computational overhead of cryptography. In Henri
Gilbert, editor, Advances in Cryptology
EUROCRYPT 2010, volume 6110 of Lecture Notes in
Computer Science, pages 445{465. Springer Berlin
Heidelberg, 2010.

[23] Karim El Defrawy and Joshua Lampkins. Founding

digital currency on secure computation (full version of
this paper). use your favorite search engine to (cid:12)nd it.
[24] Peter Bogetoft et al. Secure multiparty computation
goes live. In Financial Cryptography, pages 325{343,
2009.

[25] Sarah Meiklejohn et al. A (cid:12)stful of bitcoins:

Characterizing payments among men with no names.
IMC, 2013.

[26] Ittay Eyal and Emin Gun Sirer. Majority is not

enough: Bitcoin mining is vulnerable. In Financial
Cryptography, 2014.

[27] Yair Frankel, Yiannis Tsiounis, and Moti Yung.

\indirect discourse proof" : Achieving e(cid:14)cient fair
o(cid:11)-line e-cash. In ASIACRYPT, pages 286{300, 1996.
[28] Matthew K. Franklin and Moti Yung. Communication
complexity of secure computation (extended abstract).
In STOC, pages 699{710, 1992.

[29] Juan A. Garay and Yoram Moses. Fully polynomial

byzantine agreement for n > processors in t + 1
rounds. SIAM J. Comput., 27(1):247{290, 1998.

[30] Amir Herzberg, Stanislaw Jarecki, Hugo Krawczyk,
and Moti Yung. Proactive secret sharing or: How to
cope with perpetual leakage. In CRYPTO, pages
339{352, 1995.

[31] Wen-Shenq Juang. A practical anonymous o(cid:11)-line

multi-authority payment scheme. Electronic Commerce
Research and Applications, 4(3):240{249, 2005.

[32] Dan Kaminsky. Some thoughts on bitcoin, 2011. http:

//www.slideshare.net/dakami/bitcoin-8776098.
[33] Jonathan Katz, Ueli Maurer, Bj(cid:127)orn Tackmann, and
Vassilis Zikas. Universally composable synchronous
computation. In TCC, pages 477{498, 2013.

[34] Anna Lysyanskaya and Zul(cid:12)kar Ramzan. Group blind

digital signatures: A scalable solution to electronic
cash. In Financial Cryptography, pages 184{197, 1998.

[35] Robert McMillan. $1.2m hack shows why you should

never store bitcoins on the internet, 2013. http://
www.wired.com/wiredenterprise/2013/11/inputs/.

[36] Ian Miers, Christina Garman, Matthew Green, and
Aviel D. Rubin. Zerocoin: Anonymous distributed
e-cash from bitcoin. In IEEE Symposium on Security
and Privacy, pages 397{411, 2013.

[37] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic

cash system, 2008. http://bitcoin.org/bitcoin.pdf.

[38] Rafail Ostrovsky and Moti Yung. How to withstand
mobile virus attacks (extended abstract). In PODC,
pages 51{59, 1991.

[39] Torben P. Pedersen. Non-interactive and

information-theoretic secure veri(cid:12)able secret sharing.
In CRYPTO, pages 129{140, 1991.

[40] Berry Schoenmakers. A simple publicly veri(cid:12)able

secret sharing scheme and its application to electronic.
In CRYPTO, pages 148{164, 1999.

[41] David Schultz. Mobile Proactive Secret Sharing. PhD

thesis, Massachusetts Institute of Technology, 2007.
[42] Adi Shamir. How to share a secret. Commun. ACM,

22(11):612{613, 1979.

[43] Markus Stadler, Jean-Marc Piveteau, and Jan

Camenisch. Fair blind signatures. In EUROCRYPT,
pages 209{219, 1995.

APPENDIX
A. CONVERT_SHARINGS SECURITY PROOF

We prove security of the protocol Convert Sharings in the
framework of Universal Composability (UC) [17]. A real
world protocol is said to be UC-secure if an environment, Z,
that provides inputs and receives outputs from the protocol
cannot distinguish whether it is interacting with the real (or
hybrid) protocol or an ideal one that uses an ideal functional-
ity performing the same task as the real world protocol. We
compare the ideal protocol with a hybrid protocol which re-
places calls to sub-protocols with calls to sub-functionalities.
The ideal functionality FCS for Convert Sharings is:

Description of FCS.

1.

Input Phase
1.1 Z instantiates each server Si with its input to
′
, K, n, t and its
the protocol, which is ℓ, ℓ
share of the degree d = ℓ + t − 1 polynomial
] × [K]. Z initializes
H (k)
the adversary A with auxiliary input z.
1.2 All servers send the inputs they received from
Z to FCS. If inputs are inconsistent, FCS out-
puts (abort) and aborts.

for each (a, k) ∈ [ℓ
′

a

2. Corruption Phase

a

b

′

and for each (b, k) ∈ [ℓ] × [K].

b

, K) to A.
(i) for each corrupt Si

A may iteratively request to corrupt servers by
sending messages (corrupt, Si) to FCS. For each
such corruption, FCS sends H (k)
a (i) to A for each
(a, k) ∈ [ℓ
] × [K] and sends (corrupt) to Si. After
each corruption, A may provide new input shares
for Si to FCS.
3. Output Phase
3.1 FCS sends (Shares?, ℓ, ℓ
′
3.2 A sends FCS shares V (k)
3.3 FCS interpolates from the shares of H (k)
] × [ℓ] × [K].

re-
ceived from the honest servers the points
a (−b) for each (a, b, k) ∈ [ℓ
H (k)
+ t − 1 polynomials
V (k)
uniformly at random, subject to the con-
b
straint that they agree with the shares received
from A and they satisfy V (k)
a (−b)
for each (a, b, k) ∈ [ℓ
′
(i) to each honest Si
for each (b, k) ∈ [ℓ] × [K]. FCS provides out-

3.5 FCS provides outputs V (k)

3.4 FCS chooses degree d
′

(−a) = H (k)

] × [ℓ] × [K].

b

′

′
= ℓ

11puts to the corrupt servers as speci(cid:12)ed by the
adversary.

Note that the functionality does not include a post-output
corruption phase or a post-execution corruption phase as
in [16]. The reason for eliminating post-output corruption
is that the adversary chooses its output, and hence learns
no new information in the output phase. Without loss, we
can assume that the adversary only corrupts after receiving
new information. (This follows the convention used in [22].)
Post-execution corruption is not needed when secure era-
sures are assumed, as stated in [16]. The reason is that mes-
sages sent and received during the protocol can be deleted
after the protocol is (cid:12)nished. Thus the adversary has no
information to learn from the protocol execution after the
protocol has (cid:12)nished.

i

a

and U (k)

The ideal world adversary (simulator) is given below. The
intuition behind it is as follows: The simulator begins by
emulating the sub-functionalities as if generating sharings
for (i, k) ∈ [n] × [K]. In
of polynomials H (K+1)
reality, the simulator simply provides to the hybrid-world
adversary the shares it requested, and whenever the adver-
sary requests to corrupt another party, the simulator chooses
random shares. The only di(cid:14)culty occurs in step 11. At this
point, the simulator has already provided the adversary with

every share of eHa and eUi. Thus the shares that the simula-
eHa is a sum of polynomials with H (K+1)

tor provides to the adversary upon corruption must match
with what has already been sent. The key point here is that
as a summand, and
only exists in the hybrid execution, not in FCS. So
H (K+1)
upon corruption, the simulator forwards the shares of H (k)
for k ∈ [K] received from FCS to the adversary, and then
chooses a share of H (K+1)
so that the sum matches with

the share of eHa that has already been sent. The process is
similar for the eUi.

a

a

a

a

Before describing the simulator, we need to describe the

except that only degree d (and no degree 2d) sharings will

sub-functionalities used. The functionality FShareB used in
the hybrid model will be essentially the same as the function-
ality FRobustShare from [22]. The functionalities FRandom and
FRandomB will be essentially the same as Fdouble from [22],
be created, and for FRandom the batch size is 1. Both FShareB
and FRandomB will be modi(cid:12)ed so that the batch size (ℓ or
′
ℓ
) is an input to the functionality.
The functionality FOpen receives from all players the shares
of the sharing(s) to be opened, interpolates the secret(s), and
then sends the secret(s) to each player and to the adversary.

′

′

the auxiliary input z that S received from Z.

Simulator S for Convert Sharings.
1. S internally runs A with the inputs (ℓ, ℓ
2. S, emulating FRandomB , sends (Shares?, ℓ
′

, K) and
, ℓ) to A
represents the number of sharings being
(where ℓ
generated and ℓ represents the batch size used for
those sharings).
3. A sends shares H (K+1)
(i) to S for each corrupt Si
and each a ∈ [ℓ
4. S, emulating FShareB , sends (Shares?, {1, . . . , n},
) to A (where {1, . . . , n} represents the
n(K + 1), ℓ
identities of the dealers, n(K + 1) represents the

].

a

′

′

′

j

i

K

j

j

∑

∑

(i) + U (K+1)

K

k=1 r(k)U (k)

a (i) + H (K+1)

a

to the constraint

′
of degree d

5. A sends shares U (k)

(i) for each corrupt Si.
polynomi-

using the polynomials already received from A.

repre-
number of sharings being generated, and ℓ
sents the batch size used for those sharings).
(i) to S for each corrupt Si and
each (j, k) ∈ [n]× [K + 1]. A also sends polynomials
to S for each corrupt Si and each
U (k)
k ∈ [K + 1].
6. S, emulating FRandom, sends (Shares?, K) to A
(where K represents the number of sharings being
generated).
7. A sends shares R(k)(i) to S for each corrupt Si and
each k ∈ [K].
8. Emulating FOpen, S receives (again) from A the
shares received in the previous step and sends uni-
formly random values {r(k)}k∈[K] to A.
9. A may iteratively request to corrupt servers. Each
(corrupt, Si) message that S receives from A is for-
warded to FCS, and shares H (k)
a (i) that S receives
10. S chooses degree d polynomials eHa that are ran-
from FCS are forwarded to A.
that eHa(i) =
∑
dom subject
als eUi that are random subject to the constraint that
k=1 r(k)H (k)
For each honest Sj, S chooses degree d
eUj(i) =
rupt Si and eUj(−a) = eHa(j) for each a ∈ [ℓ
each corrupt Si, de(cid:12)ne eUi =

(i) for each cor-
]. For
i +U (K+1)
11. Emulating the honest servers, S sends messages for
the honest servers as in step 7 of Convert Sharings,
with A emulating the (recipient) corrupt servers.
More speci(cid:12)cally, A iteratively selects each honest
server to send messages to dishonest servers in se-
quence, with S sending messages on behalf of the
honest servers according to the protocol speci(cid:12)ca-
tion of Convert Sharings, and and after each receipt
of messages from an honest server, A may choose
to iteratively corrupt servers. With each server cor-
ruption, the following steps are performed:
11.1 S forwards the corruption request from A to
FCS.
a (q) for (a, k) ∈
∑
] × [K] of
′
[ℓ
server Sq
corrupt
from FCS, S computes shares H (K+1)
(q) =
11.3 S chooses uniformly random polynomials U (k)
for k ∈ [K] that are consistent with the shares
already received from the adversary in step 5
∑
(−a) = H (k)
a (q) for each a ∈
and satisfy U (k)
[ℓ
k=1 r(k)U (k)
=
(−a) = H (K+1)
(q) for each a ∈ [ℓ
for k ∈ [K + 1] to A.

q − eUq.
(Note that by way eUq was de(cid:12)ned, this implies

a (q) − eHa(q).

11.4 S computes U (k+1)

11.5 S sends H (k)

a (q) for (a, k) ∈ [ℓ
′

11.2 Upon receiving shares H (k)

] × [K + 1] and

K

k=1 r(k)H (k)

K

k=1 r(k)U (k)

U (K+1)

(newly)

].)

U (k)

q

′

].

′

i

q

q

q

a

′

a

q

′

K

12. After all honest servers have sent their shares in the
previous step, the A sends the shares of the dis-
honest players to S according to the step 7 of Con-
vert Sharings.

1213. S internally executes Convert Sharings for each hon-
est player up to step 10 at which point S and A send
messages to each other according to the protocol
speci(cid:12)cation, with S emulating the honest servers
and A emulating the corrupt servers.
14. S de(cid:12)nes G, {z1, . . . , zn−2t}, and λb,m as in
∑
(i) =
, K) from FCS, S
(i) for each corrupt Si and
16. A provides an output for the environment, which S

step 12 of Convert Sharings and computes V (k)

replies with shares V (k)
for each (b, k) ∈ [ℓ] × [K].
forwards to Z.

15. Upon receiving (Shares?, ℓ, ℓ

zm (i) for each corrupt Si.

n−2t
m=1 λb,mU (k)

′

b

b

a , and the V (k)

Theorem 1. The protocol Convert Sharings UC-emulates
the ideal functionality FCS.
Proof. We need to show that for any polytime A, there
exists a polytime S such that no polytime Z can distin-
guish between interacting with A (in the execution of Con-
vert Sharings in the (FRandom,FRandomB ,FShareB ,FOpen)-hybrid
model) or interacting with S (in the ideal world protocol for
FCS).
Output of Honest Servers: We (cid:12)rst show that Z cannot
distinguish (except with negligible probability) between the
outputs of the honest servers in the hybrid versus the ideal
In the ideal execution, the honest servers will
execution.
output shares of V (k)
b which share the same values as the
input polynomials H (k)
will be uniformly
random subject to the constraint that they agree with the
shares provided by the adversary. Assuming the polynomi-
}i∈[n−2t] in step 12 of Convert Sharings are \correct"
als {U (k)
zm (−a) = H (k)
in that U (k)
b will hold the
same secrets as the H (k)
(as shown in the paragraph fol-
lowing the speci(cid:12)cation of Convert Sharings). Furthermore,
the shares of the corrupt servers are chosen by the simulator
to be the same as the shares in the hybrid execution. To
see that the V (k)
are uniformly random given the secrets
they hold and the shares of the corrupt players, note that
FShareB chooses the U (k)
for honest Si uniformly at random
given the secrets and corrupt shares. Since there are at least
|G| − t = (n − 2t) − t = n − 3t ≥ ℓ honest servers in G, the
uniform randomness then follows from the fact that inter-
polation with coe(cid:14)cients λb,m can be view as multiplication
by a hyper-invertible matrix (see the security proof for Ran-
domPairs in [22]).

a (zm), then the V (k)

It remains to show that the polynomials {Uzi

}i∈[n−2t] are

zi

a

b

b

i

\correct." We show that, except with negligible probability,
any dealer Si who dealt a U (k)
a (i)
for some a and k will be eliminated as corrupt in step 10 of
Convert Sharings. The random values r(k) opened in step 5
of Convert Sharings is a vector in ZK
p . For some (cid:12)xed i, let
V denote the subspace of ZK

(−a) ̸= H (k)

such that U (k)

p such that

i

i

∑

∑
for each a ∈ [ℓ
′
such that∑

K

i

p

Then the set of all possible vectors (r(1), . . . , r(K)) in ZK
(−a) ̸=
such the check in step 10 will pass is v +V . Now if U (k)
H (k)
a (i) for some a and k, then V will be a proper sub-
space of ZK
p . Then the probability that a random vector
(r(1), . . . , r(K)) will be in v +V is negligible.
Output of Adversary: The next step is to show that Z cannot
distinguish between the output of A in the hybrid versus
the ideal execution. Since the output of A is forwarded by
S to Z in the last step of simulation, it su(cid:14)ces to show
that A cannot distinguish between these two scenarios. We
therefore demonstrate that the messages sent from S to A
have the same distribution as those that would be sent in
the hybrid execution.
In step 8 of simulation, S sends uniformly random values,
which is what FOpen does in the hybrid execution. In step 9,
A corrupts servers, and S simply forwards their shares to
A, which is what A would see in the hybrid execution. We
deal with step 11 below. In step 13, S follows the protocol
speci(cid:12)cation to emulate the messages that would be sent in
the hybrid execution.
In step 11, S emulates honest servers sending shares of
a , and A may adaptively corrupt servers dur-
U (k)
a (q) for k ∈ [K] that are
ing this process. The shares H (k)
forwarded from FCS are the same as in the hybrid execution.
The H (K+1)
are uniformly random given the corrupt servers’
∑
S are uniformly random given the corrupt servers’ shares,
so is H (K+1)
in the ideal execution, since it is de(cid:12)ned by
a
k=1 r(k)H (k)
H (K+1)
K
=
for k ∈ [K + 1] are uniformly random given the cor-
the U (k)
rupt servers’ shares subject to U (k)
a (q) in both
the real and ideal worlds.

shares in the hybrid execution, and since the eHa chosen by
a − eHa. Using a similar argument,

(−a) = H (k)

and H (k)

a

a

q

q

i

B. PDC SECURITY PROOF SKETCH

Description of FPDC.

The parties that provide input to FPDC are the IVS,
V ,
the Ledger Servers, S1, . . . , Sn, and the users
U1, . . . , UJ , where J = poly(κ).

2.

Ledger Initialization:
1. Receive one copy of the balance ledger from each
honest Ledger Server. Each balance ledger entry is
of the form (ξ, ζ, ID, b, c), where ξ and ζ \represent"
the private and public keys (respectively), ID is the
identity associated with the address, b is the current
balance, and c is the transaction counter.
Initialize the transaction ledger to be empty. The
transaction ledger will be of the same format as in
the real-world protocol.
3. Receive from V a list L of identities. FPDC may
receive lists from V at any time during the execution
′
of the ideal process. Upon receiving another list L
from V , update L ← L ∪ L
′
. All lists received from
V are forwarded to A.
Initialize a set P := ∅, which will contain ordered
pairs of the form (ID, δ), where ID is an identity
and δ \represents" a signature on ID.

4.

k=1 r(k)U (k)

i

(−a) =

K

k=1 r(k)H (k)

a (i)

]. Let v = (v(1), . . . , v(K)) be some vector

∑

K

k=1 v(k)U (k)

i

(−a) + U (K+1)

(−a)
a (i) + H (K+1)

a

i

K

k=1 v(k)H (k)

=

(i).

5. Set the block number: BlockN um := 1.

13Identity Veri(cid:12)cation: The following occurs upon receipt
of a message of the form (verify_identity, ID) from
a user U .
If ID /∈ L, do nothing (skip the following steps).
1.
If (ID,·) /∈ P , send ID to A. The adversary returns
2.
δ, and FPDC updates P ← P ∪ {(ID, δ)}.
3. For (ID, δ) ∈ P , send (ID, δ) to U and V .
Interaction with Users: The following messages may
be received from users at any time during the ideal
execution. Messages will be deleted as in step 3 of
Ledger Server Loop. The subset I ⊂ [n] represents the
set of servers that are to receive their messages in the
current block, while the servers in I receive their mes-
sages in the next block.
1. Messages

form (init_addr, nonce,
V, ID, δ, I).
Store this message, and if there
is any corrupt Si such that i ∈ I, then send
(init_addr, nonce, V ) to A.

the

of

2. Messages of the form (tx, nonce, ξ1, ζ1, ζ2, j, v, I). If
there is no balance ledger entry with ξ1 as the pri-
vate key and ζ1 as the public key, or if there is no
balance ledger entry with ζ2 as the public key, then
delete this message. Otherwise, store this message,
and if there is any corrupt Si such that i ∈ I, then
send (tx, nonce, ζ1, ζ2, j) to A.

3. Messages

of

form (check_bal, nonce,
the
ξ, ζ, j1, j2, B1, B2, I).
If there is no balance ledger
entry with ξ as the private key and ζ as the public
key, then delete this message. Otherwise, store this
message, and if there is any corrupt Si such that
i ∈ I, then send (check_bal, nonce, ζ, j1, j2, B1, B2)
to A.

4. The adversary may send messages on behalf of the
corrupt users at any time. The messages may be of
any one of the above three forms, with the excep-
tion that ID, δ, and v (values that are secret-shared
in the real protocol) will be replaced with ⊥. (This
models the fact that A may deal inconsistent shar-
ings.) FPDC deletes or stores these messages accord-
ing the the same criteria used for messages from the
honest users.

sends messages

(check_bal, nonce,

to A of
(tx, nonce,

Processing Blocks: Upon receiving a message of the
form (update block, v) from all honest servers, if v =
BlockN um + 1, then the following steps are performed:
1. FPDC
the
form
ζ1, ζ2, j, i),
(init_addr, nonce, V, i),
ζ, j1, j2, B1, B2, i), which
or
simulates broadcasting those messages
the
honest servers. Messages received from users in
block BlockN um are broadcast for each honest
server with index in I, and messages received in
block BlockN um − 1 are broadcast for each honest
server with index in I.
2. The adversary may send messages to FPDC of the
same form as in the previous step, which simulates
broadcasting those messages for corrupt server Si.
3. For each broadcast message satisfying the conditions
of step 5 of Ledger Server Loop, FPDC performs the
corresponding action (i.e., adding an entry to the
balance ledger for an init_addr message, transfer-

for

4.

ring funds for a tx message, and returning informa-
tion to the user for a check_bal message). Before
doing so, for any message that involved a sharing
with shares set to ⊥ by A, FPDC asks A for a value
to replace this with (although A may still respond
with ⊥, which represents to a corrupt sharing). For
an init_addr message, FPDC chooses random ξ and
ζ to output as private and public keys for the user.
If a proactive refresh is to occur at the end of this
block, A may choose to decorrupt parties at this
step.
5. For each message from an honest user in block
BlockN um, notify A as in Interaction with Users
above if there is any corrupt Si such that i ∈ I.

6. Update BlockN um ← BlockN um + 1.
Corruption: The adversary may choose to corrupt par-
ties at any time during the ideal execution. Upon re-
ceiving (corrupt, Si) from A, FPDC sends (corrupt) to
Si and sends to A a copy of the balance and transac-
tion ledgers. In addition, FPDC sends A init_addr, tx,
and check_bal messages as in Interaction with Users
above for any message received from a user in the cur-
rent block with i ∈ I, and for any message received in
the previous block with i ∈ I.

We sketch below the simulator for the PDC scheme:
Ledger Initialization: To initialize the corrupt servers’
ledger entries, S provides to A balance ledger entries like
those in FPDC, except that randomly chosen values repre-
senting the corrupt servers’ shares are also included. All
lists L of identities received are forwarded to A.
Identity Veri(cid:12)cation: After receiving ID from FPDC, S will
interact with A emulating FSig as in [15]. This will result in
A choosing a signature, δ, which S sends to FPDC.
Interaction with Users: Upon receiving an init_addr, tx,
or check_bal message originating from an honest user, S re-
lays this message to A, but includes a randomly generated
share for each sharing. For each such message originating
from a corrupt player, S forwards a message of the appro-
priate format to FPDC.
Processing Blocks: Messages broadcast by honest servers
are forwarded from FPDC to A, and messages broadcast by
corrupt servers are forwarded from A to FPDC. For each
sub-functionality to invoke, S receives A’s shares. Based
on shares received thus far, S informs FPDC of the value to
be shared for each sharing that was initially shared with ⊥.
If the sub-functionality does not terminate, than the failure
type is forwarded from FPDC to A (i.e., a sharing was invalid,
a user was overdrawing an account, etc.).
Corruption: Upon corruption, S randomly generates a
new share for that server for each ledger entry and each
stored user message that has an associated sharing.

The indistinguishability of the view of the environment
can be argued as follows: The users who follow the proto-
col speci(cid:12)cation will generate uniformly random sharings,
and the shares provided to A by S are randomly chosen.
Since shares provided by A are replaced with ⊥ until enough
shares are received to determine the value being shared (or
whether the sharing is inconsistent), S can correctly pro-
vide input for FPDC, and hence the correct output will be
provided to the environment.

14