On the Feasibility of Large-Scale Infections  

of iOS Devices

Tielei Wang, Yeongjin Jang, Yizheng Chen, Simon Chung, Billy Lau,  

and Wenke Lee, Georgia Institute  of Technology

https://www.usenix.org/conference/usenixsecurity14/technical-sessions/presentation/wang_tielei

This paper is included in the Proceedings of the 23rd USENIX Security Symposium.August 20–22, 2014 • San Diego, CAISBN 978-1-931971-15-7Open access to the Proceedings of  the 23rd USENIX Security Symposium is sponsored by USENIXOn the Feasibility of Large-Scale Infections of iOS Devices

Tielei Wang, Yeongjin Jang, Yizheng Chen, Simon Chung, Billy Lau, and Wenke Lee

School of Computer Science, College of Computing, Georgia Institute of Technology

{tielei.wang, yeongjin.jang, yizheng.chen, pchung, billy, wenke}@cc.gatech.edu

Abstract

While Apple iOS has gained increasing attention from
attackers due to its rising popularity, very few large scale
infections of iOS devices have been discovered because
of iOS’ advanced security architecture.
In this paper,
we show that infecting a large number of iOS devices
through botnets is feasible. By exploiting design ﬂaws
and weaknesses in the iTunes syncing process, the de-
vice provisioning process, and in ﬁle storage, we demon-
strate that a compromised computer can be instructed to
install Apple-signed malicious apps on a connected iOS
device, replace existing apps with attacker-signed ma-
licious apps, and steal private data (e.g., Facebook and
Gmail app cookies) from an iOS device. By analyzing
DNS queries generated from more than half a million
anonymized IP addresses in known botnets, we measure
that on average, 23% of bot IP addresses demonstrate
iOS device existence and Windows iTunes purchases,
implying that 23% of bots will eventually have connec-
tions with iOS devices, thus making a large scale infec-
tion feasible.

1

Introduction

As one of the most popular mobile platforms, Apple
iOS has been successful in preventing the distribution of
malicious apps [23, 32]. Although botnets on Android
and jailbroken iOS devices have been discovered in the
wild [40, 42, 43, 45, 54], large-scale infections of non-
jailbroken iOS devices are considered extremely difﬁcult
for many reasons.

First, Apple has powerful revocation capabilities, in-
cluding removing any app from the App Store, remotely
disabling apps installed on iOS devices, and revoking any
developer certiﬁcate. This makes the removal of mali-
cious apps relatively straightforward once Apple notices
them.

Second, the mandatory code signing mechanism in
iOS ensures that only apps signed by Apple or certiﬁed

by Apple can be installed and run on iOS devices. This
signiﬁcantly reduces the number of distribution channels
of iOS apps, forcing attackers to have their apps signed
by a trusted authority.

Third, the Digital Rights Management (DRM) tech-
nology in iOS prevents users from sharing apps among
arbitrary iOS devices, which has a side effect of limit-
ing the distribution of malicious apps published on the
App Store. Although recent studies show that malicious
apps can easily bypass Apple’s app vetting process and
appear in the Apple App Store [26, 36, 51], lacking the
ability to self-propagate, these malicious apps can only
affect a limited number of iOS users who accidentally
(e.g., by chance or when tricked by social-engineering
tactics) download and run them. Speciﬁcally, to run an
app signed by Apple, an iOS device has to be authenti-
cated by the Apple ID that purchased the app. For exam-
ple, suppose we use an Apple IDA to download a copy of
a malicious app from the App Store and later we install
this copy on an iOS device that is bound to Apple IDB.
This copy cannot run on the iOS device that is bound
to Apple IDB because of the failure of DRM validation.
On iOS 6.0 or later, when launching this app, iOS will
pop up a window (Figure 1) to ask the user to re-input
an Apple ID and a password. If the user cannot input the
correct Apple ID (i.e., Apple IDA) and the corresponding
password, iOS refuses to run the app.

In this paper, we show that despite these advanced se-
curity techniques employed by iOS, infecting a large
number of non-jailbroken iOS devices through bot-
nets is feasible. Even though iOS devices are designed
for mobile use, they often need to be connected to per-
sonal computers via USB or Wi-Fi for many reasons,
such as backup, restore, syncing, upgrade, and charging.
We ﬁnd that the USB and Wi-Fi communication chan-
nels between iOS devices and computers are not well
protected. Consequently, a compromised computer (i.e.,
a bot) can be easily instructed to install malicious apps
onto its connected iOS devices and gain access to users’

USENIX Association  

23rd USENIX Security Symposium  79

1

app signed by attackers in possession of enterprise or in-
dividual developer licenses issued by Apple. This weak-
ness leads to many serious security threats. For example,
attackers can ﬁrst remove certain targeted apps (such as
banking apps) from iOS devices and replace them with
malicious apps that look and feel the same. As a result,
when a victim tries to run a targeted app, they actually
launch the malicious app, which can trick the user to re-
input usernames and passwords. We originally presented
this attack [31] in 2013 and Apple released a patch in iOS
7 that warns the user when connecting iOS devices to a
computer for the ﬁrst time. However, this patch does not
protect iOS devices from being stealthily provisioned by
a compromised computer that the user already trusts.

In addition to injecting apps into iOS devices, attack-
ers can also leverage compromised computers to obtain
credentials of iOS users. Speciﬁcally, since many iOS
developers presume that the iOS sandbox can effectively
prevent other apps from accessing ﬁles in their apps’
home directories, they store credentials in plaintext un-
der their apps’ home directories. For example, the Star-
bucks app was reported to save usernames and passwords
in plaintext. Starbucks thought the possibility of a secu-
rity exploit to steal the plaintext passwords was “very far
fetched” [8]. However, once an iOS device is connected
to a computer, all these ﬁles are accessible by the host
computer. Consequently, malware on the computer can
easily steal the plaintext credentials through a USB con-
nection. In our work, we found that the Facebook and
Gmail apps store users’ cookies in plaintext. By stealing
and reusing the cookies from connected iOS devices, at-
tackers can gain access to the victims’ accounts remotely.

While it is known that a host computer can partially
access the ﬁle system of a connected iOS device, we
point out that it leads to security problems, especially
when attackers control a large number of personal com-
puters. Considering that there are many apps dedicated
to iOS, this problem may allow attackers to gain creden-
tials that are not always available on PCs.

To quantitatively show that botnets pose a realistic
threat to iOS devices, we also conduct a large scale
measurement study to estimate how many compromised
computers (i.e., bots) could connect with iOS devices.
Intuitively, given the immense popularity of iOS devices
and compromised Windows machines, we presume that
many people are using iOS devices connected to com-
promised computers. However, to the best of our knowl-
edge, there exists no previous work that can provide large
scale measurement results.

By analyzing DNS queries generated from 473,506

Figure 1: User attempting to run an app downloaded by a
different Apple ID on his iOS device needs to ﬁrst enter
the correct Apple ID and password.
private data without their knowledge. In this paper, con-
nected iOS devices refer to those that are plugged into
a computer through USB cable or have Wi-Fi syncing
enabled. Note that if Wi-Fi syncing is enabled, the iOS
device will automatically sync with a paired computer
when they are on the same network.

The feasibility of a large scale infection is facili-
tated by two main problems that we have discovered
in our research. The ﬁrst is a previously unknown de-
sign ﬂaw in the iTunes syncing mechanism (including
both USB and Wi-Fi based syncing), which makes the
iTunes syncing process vulnerable to Man-in-the-Middle
(MitM) attacks. By exploiting this ﬂaw, attackers can
ﬁrst download an Apple-signed malicious app (e.g., a
Jekyll app [51]) using their Apple ID and then remotely
instruct a compromised computer to install the attacker’s
copy on a connected iOS device, completely bypassing
DRM checks. In other words, an attacker can have a ma-
licious app of his own choosing run on a user’s iOS de-
vice without the user ever seeing an authentication pop-
up window.

Coupled with botnet infrastructures, this exploit en-
ables large scale delivery of arbitrary Apple-signed apps.
This has two serious security implications. First, it chal-
lenges the common belief that the Apple App Store is the
sole distributor of iOS apps. Instead of relying on trick-
ing a user into downloading apps from the App Store,
attackers can now push copies of their app onto a vic-
tim’s device. Even if an app has been removed from the
App Store, attackers can still deliver it to iOS users. Sec-
ond, this expolit challenges the common belief that the
installation of iOS apps must be approved by the user.
Attackers can surreptitiously install any app they down-
loaded onto victim’s device.

The second security issue we discovered is that an
iOS device can be stealthily provisioned for development
through USB connections. This weakness allows a com-
promised computer to arbitrarily remove installed third-
party apps from connected iOS devices and install any

80  23rd USENIX Security Symposium 

USENIX Association

2

Infection Type
Install malicious apps signed by Apple
Install malicious apps signed by attackers
Steal private data (e.g., Facebook and Gmail apps’s cookies)

Root Cause
Man-in-the-Middle attacks against syncing
Stealthy provisioning of devices
Insecure storage of cookies

Connection Type
USB or Wi-Fi
USB
USB

Table 1: Infection Summary.

anonymized IP addresses1 that were involved in known
botnets on 10/12/2013 in 13 cities of two large ISPs in
the US, we identiﬁed 112,233 IP addresses that had App
Store purchase trafﬁc issued by iTunes on Windows, as
well as network trafﬁc generated by iOS devices. This
implies that the iOS users in the 112,233 home networks
were purchasing items in the App Store from compro-
mised Windows PCs on the same day. We make the fol-
lowing assumption: if iTunes is installed on a user’s per-
sonal computer and is also used to purchase some item
from the App Store, the user will eventually connect his
or her iOS device(s) to it either via USB or Wi-Fi. Based
on this assumption, we estimate that iOS devices in the
112,233 IP addresses could be infected via a connected
computer. In other words, 23% of bots in our measured
botnet could be used to infect iOS devices.

A broader implication of our study is that it may
raise concerns about the security of mobile two-factor-
authentication schemes [13].
In such schemes, a mo-
bile phone is used as a second factor of authentication
for transactions initiated on a potentially compromised
PC. A fundamental assumption made by such schemes
is that the “two factors” (i.e., the PC and the phone)
are very hard to be reliably and simultaneously compro-
mised (and linked to the same user) by an adversary. This
assumption is reasonable if the PC and the phone are ex-
posed to independent attack vectors. However, as shown
in this paper, since a large number of users would con-
nect mobile phones to their PCs, the PC itself becomes an
attack vector to the phone. As such, the aforementioned
assumption becomes dubious. An attacker who already
controls the PC can now use it as a stepping stone to in-
ject malware into the phone, and thus can control both
factors. As a result, the attacker can easily launch at-
tacks described in [21, 39] to defeat mobile two-factor-
authentication schemes2.

In summary, the main contributions of our work are:

(cid:127) We discover a design ﬂaw in the iTunes syncing
process, and present a Man-in-the-Middle attack
that enables attackers to run any app downloaded

by their Apple ID on iOS devices that are bound to
different Apple IDs, bypassing DRM protections.
Based on the MitM attack, we present a way to
deliver Apple-signed malicious apps such as Jekyll
apps to iOS users.

(cid:127) We point out

the security implications of the
stealthy provisioning process and insecure creden-
tial storage, and demonstrate realistic attacks, such
as replacing installed apps in the iOS device with
malicious apps and stealing authentication cookies
of the Facebook and Gmail apps.

(cid:127) We show that a large scale infection of iOS devices
is a realistic threat and we are the ﬁrst to show quan-
titative measurement results. By measuring iTunes
purchases and iOS network trafﬁc generated from
IP addresses involved in known botnets, we esti-
mate that on average, 23% of all bot population have
connections with iOS devices.

Table 1 summaries the attacks. We have made a full
disclosure to Apple and notiﬁed Facebook and Google
about the insecure storage of cookies in their apps. Ap-
ple acknowledged that, based on our report, they have
identiﬁed several areas of iOS and iTunes that can bene-
ﬁt from security hardening.

The rest of the paper is organized as follows. In Sec-
tion 2, we demonstrate installation of Apple-signed mali-
cious apps without violating DRM checks. In Section 3,
we demonstrate replacing targeted apps with attacker-
signed malicious apps.
In Section 4, we demonstrate
theft of private data (e.g., Facebook and Gmail apps’
cookies) from iOS devices.
In Section 5, we describe
our measurement techniques that indicate large scale in-
fection is feasible. Finally, we provide related work, dis-
cussion, and a conclusion.

2 Delivery of Apple-Signed Malicious Apps

1The original IP addresses were hashed into anonymized client IDs
in our dataset. We performed our measurement over ﬁve days of DNS
query data, and we used statistics from one day as an example here. We
use IP address and client ID interchangeably.

2The ultimate defeat of mobile two-factor-authentication schemes
will depend on what capabilities the injected mobile malware has. We
further discuss it in Section 6.

This section discusses how a compromised computer can
be instructed to install Apple-signed malicious apps on
iOS devices. We explore the iOS DRM technology and
iTunes syncing process in Section 2.1, present a Man-
in-the-Middle attack in Section 2.2, and discuss how to
bypass iOS DRM validations in Section 2.3.

USENIX Association  

23rd USENIX Security Symposium  81

3

iTunes'with'Apple'ID'A

4.'Generate'
afsync.rs
afsync.rs.sig

iOS'device'with'Apple'ID'B
2.'Generate'
/AirFair/sync/afsync.rq
/AirFair/sync/afsync.rq.sig

6.'Store'
/AirFair/sync/afsync.rs
/AirFair/sync/afsync.rs.sig

1.'Send'sync'request'(Keybag)
3.'Download'afsync.rq'and'afsync.rq.sig''
5.'Upload'afsync.rs'and'afsync.rs.sig
7.'Send'MetadataSyncFinish'request

iTunes'with'
Botmaster's'Apple'ID'A

3b.'Generate'
afsync.rs

3a.'afsync.rq'''
3c.'afsync.rs'''

Bot'client'
(victim's'computer)
1.'Send'sync'request'(Keybag)
3.'afsync.rq'and'afsync.rq.sig''

iOS'device'with'
Apple'ID'B
2.'Generate'
/AirFair/sync/afsync.rq
/AirFair/sync/afsync.rq.sig

4.'Generate'
afsync.rs.sig
5.'Upload'afsync.rs'and'afsync.rs.sig
7.'Send'MetadataSyncFinish'request

6.'Store'
/AirFair/sync/afsync.rs
/AirFair/sync/afsync.rs.sig

Figure 2: iTunes can sync apps to an iOS device with a
different Apple ID.

Figure 3: The Man-in-the-Middle against the syncing.

2.1 Fairplay DRM and iTunes Syncing
Apple utilizes a DRM (Digital Rights Management)
technology called Fairplay to prevent piracy of iOS apps.
All apps in the App Store are encrypted and signed by
Apple. To run an app downloaded from the App Store,
iOS will 1) verify an app’s code signature, 2) perform
DRM validation and decrypt the executable ﬁle, and 3)
run the decrypted code. As a result, a copy of an app
purchased by Apple IDA cannot run on other iOS devices
bound to other Apple IDs, because of the failure of DRM
validation in step 2.

Although Apple does not disclose any technical details
about the Fairplay DRM technology, we found a way to
bypass it based on the following key observations.

(cid:127) Observation 1: Different Apple IDs will receive
the same encrypted executable ﬁles for different
copies of the same app. After purchasing an app,
an iOS user will receive a ﬁle with the .ipa exten-
sion from the App Store. The ipa ﬁle is in com-
pressed zip format. We can retrieve the contents of
an app package by decompressing the ipa ﬁle. The
following shows the typical structure of an app di-
rectory (taking the Twitter app as an example).
/iTunesArtwork
/iTunesMetadata.plist
/Payload/Twitter.app/Twitter
. . .
/Payload/Twitter.app/SC_Info/Twitter.sinf
/Payload/Twitter.app/SC_Info/Twitter.supp
. . .
Although the whole ipa package is unique for each
Apple ID, we noticed that the encrypted executable
ﬁles inside these ipa ﬁles are the same. Different
copies of the same app purchased by different Ap-
ple IDs sharing same encrypted executable ﬁles im-
plies that the ﬁnal decryption of the executables

is irrelevant to Apple IDs3.

(cid:127) Observation 2: Apps purchased by different Ap-
ple IDs can run on the same iOS device under
certain circumstances. We found that iTunes can
sync apps in its app library to iOS devices through
USB or Wi-Fi connections, even if the iOS de-
vices are bound to different Apple IDs. Speciﬁcally,
when an iOS device with Apple IDB is connected to
iTunes with Apple IDA, iTunes can still sync apps
purchased by Apple IDA to the iOS device, and au-
thorize the device to run the apps. As a result, apps
purchased by both Apple IDA and Apple IDB can
run on the iOS device.

In particular, we reverse engineered the iTunes autho-
rization process, i.e., how iTunes authorizes an iOS de-
vice with a different Apple ID to run its apps. We brieﬂy
present the workﬂow here.

First, iTunes sends a Keybag sync request to the iOS
device (Step 1 in Figure 2). We refer the readers to [29]
for detailed use of “Keybags” in iOS. For example, a key-
bag named Escrow is used for iTunes syncing and allows
iTunes to back up and sync without requiring the user to
enter a passcode.

Next, the iOS device generates an authorization re-
quest ﬁle /AirFair/sync/afsync.rq and correspond-
ing signature ﬁle /AirFair/sync/afsync.rq.sig
(Step 2 in Figure 2). Upon retrieving these two ﬁles from
the iOS device (Step 3), iTunes generates an authoriza-
tion response ﬁle afsync.rs and corresponding signa-
ture ﬁle afsync.rs.sig (Step 4).

iTunes then uploads the authorization response and
signature ﬁles (afsync.rs and afsync.rs.sig) to the
iOS device (Step 5). The iOS device stores the two ﬁles

3We further explain this in Section A.1

82  23rd USENIX Security Symposium 

USENIX Association

4

in the directory /AirFair/sync/ and updates its inter-
nal state (Step 6).

Finally, iTunes sends a request to the iOS device to
ﬁnish the syncing process (Step 7). After that, all apps in
the iTunes app library can directly run on the iOS device
without showing the pop-up window similar to Figure 1,
even though iTunes and the iOS device are bound to dif-
ferent Apple IDs.

2.2 Remote Authorization
By reverse engineering the iTunes executables, we iden-
tiﬁed the functions in iTunes that are used to gener-
ate the afsync.rs and afsync.rs.sig (i.e., Step 4
in Figure 2). Based on these ﬁndings, we realized that
by launching a Man-in-the-Middle-style attack, iTunes
can remotely authorize an iOS device, without requiring
physical connections between iTunes and the iOS device.
Figure 3 shows the remote authorization process in
which iTunes is running on a remote computer (iTunes
with Botmaster’s Apple ID) and an iOS device is con-
nected to a local computer (i.e., the bot client) through a
USB cable or Wi-Fi connection. The local computer acts
as a middleman.

First, the local computer, as instructed by the bot-
master, sends a Keybag syncing request to a connected
iOS device (Step 1 in Figure 3). After receiving the re-
quest, the iOS device generates the authorization request
and signature ﬁle (Step 2), and transfers them to the lo-
cal computer (Step 3). However, unlike the traditional
iTunes authorization process, the local computer does
not directly produce the authorization response ﬁle. In-
stead, it sends the authorization request ﬁle afsync.rq
to a remote computer where iTunes is running (Step 3a).
Upon receiving afsync.rq, the remote computer can
force its local iTunes to handle the authorization request
ﬁle as if it were from a connected iOS device, generate
the authorization response ﬁle afsync.rs (Step 3b), and
then send afsync.rs back (Step 3c).

Next, the local computer further produces the signa-
ture ﬁle afsync.rs.sig by using local iTunes code
(Step 4). Note that the signature ﬁle is a keyed hash
value of the response ﬁle using the connection session
ID as the key. The signature ﬁle could also be generated
by the remote iTunes if the local computer transfers the
connection session ID to the remote iTunes in Step 3a.
Furthermore, the local computer uploads afsync.rs re-
ceived from the remote iTunes and afsync.rs.sig to
the connected iOS device (Step 5). Step 6 and Step 7 in
Figure 3 are the same as those in Figure 2.

The end result is that the iOS device connected to a lo-
cal computer obtains authorization to run apps purchased
by the iTunes instance running on a remote computer.

2.3 Delivery of Jekyll Apps
Background. Our previous work [51] demonstrated that
malicious third-party developers can easily publish ma-
licious apps on the App Store.
It also implemented a
proof-of-concept malicious app named Jekyll that can
carry out a number of malicious tasks on iOS devices,
such as posting tweets and dialing any number. Other
research also demonstrated malicious keylogger apps on
iOS 7.0.6 [55]. However, a key limitation of these apps
is that attackers have to passively wait for iOS users to
download the apps and thus affect only a limited number
of iOS users.

2.&Publish&them&on&App&Store

All&apps&are&signed&and&

encrypted&by&Apple

Jekyll&App

1.&Create&malicious&apps

3.&Download&malicious&apps&
using&attackers'&Apple&IDs&

4.&Deliver&the&AppleDsigned&malicious&apps&

to&iOS&users&through&botnets

Jekyll&App

Figure 4: Deliver Jekyll apps to iOS devices.

Delivery Process. Figure 4 illustrates the high level
workﬂow of the attack. First, attackers create Jekyll-like
malicious apps using methods proposed in [51] and pub-
lish them on the App Store (Step 1 & 2 in Figure 4).
Next, attackers download Jekyll-like apps from the App
Store using Apple IDs under their control (Step 3). Fi-
nally, attackers deliver the downloaded apps to compro-
mised computers and instruct them to install the down-
loaded apps to connected iOS devices.

Since Jekyll

[51] has been removed from the App
Store, we reused the copy of the app downloaded by our
testing accounts. By using the remote authorization tech-
nique we described in Section 2.2, we successfully made
our copy of Jekyll run on iOS devices bound to different
Apple IDs without triggering DRM violations. The at-
tack demonstrates that even if an app has been removed
from the App Store, attackers can still distribute their
own copies to iOS users. Although Apple has absolute
control of the App Store, attackers can leverage MitM to
build a covert distribution channel of iOS apps.

3 Delivery of Attacker-Signed Apps

In this section, we present how the USB interface can
be exploited to install arbitrary apps that are signed by
attackers. The iOS mandatory code signing mechanism
ensures that only apps signed by trusted authorities can

USENIX Association  

23rd USENIX Security Symposium  83

5

run on iOS devices. Apple allows developers to install
apps into iOS devices through a process called device
provisioning, which delegates code signing to iOS de-
velopers. This was originally intended for developers to
either test their apps on devices or for enterprises to do
in-house app distribution. Unfortunately, we found that
this process can be abused to install malicious apps into
iOS devices.

3.1 Provisioning Process
Preparation. A provisioning proﬁle is a digital certiﬁ-
cate that establishes a chain of trust. It describes a list
of iOS devices that are tied to an Apple ID, using the
Unique Device Identiﬁer (UDID) of each device. After
sending the UDID of an iOS device to Apple, a provi-
sioning proﬁle is produced for installation on the device.
Once installed, apps created and signed by the Apple
ID that created the provisioning proﬁle can be success-
fully executed in a provisioned iOS device. Although
a device’s UDID is considered sensitive information, it
is straightforward for compromised machines to obtain
the UDID of a connected iOS device because an iOS de-
vice exposes its UDID through the USB device descrip-
tor header ﬁeld.

Installing Provisioning Proﬁles. Conventionally, the
provisioning process is transparently done when one is
using Xcode (Apple’s IDE). However, we found that
the installation of provisioning proﬁles can also be done
by directly sending requests to a service running on
iOS devices called com.apple.misagent, launched via
the lockdownd service [33].
Speciﬁcally, by craft-
ing requests of the following key value pairs encapsu-
lated in plist format [1]: <MessageType, Install>,
<Profile, the provisioning proﬁle to be installed>, and
<ProfileType, Provisioning>, we can stealthily in-
stall a provisioning proﬁle in a USB-connected iOS de-
vice [33].

Installing and Removing Apps.

The removal
of an app is done by issuing an Uninstall com-
mand and app-id to a service on the device called
com.apple.mobile.installation proxy. The in-
stallation of an app is done by issuing an Install
command and app-id to the same service, with the
addition of the path to where the app package re-
sides on the computer [33]. Note that using the
com.apple.mobile.installation proxy service to
install or remove apps also works for non-provisioned
iOS devices.

3.2 Attack Examples
As we will present in Section 5.7, we discovered that
4,593 (4%) of 112,233 potential victims queried mobile
banking domains in a day (10/12/2013), implying that

these devices are likely to have mobile banking apps in-
stalled. We implemented a proof-of-concept program
that can check whether a plugged-in iOS device has
banking apps installed and replaces them with malicious
apps that look and feel the same, but trick the user to
re-input usernames and passwords.

4 Stealing Credentials

In this section, we demonstrate that in addition to inject-
ing apps into iOS devices, attackers can also leverage
bots to steal credentials of iOS users.

4.1 Background
Cookie as Credential. Due to the common architecture
of backend servers, the most frequently used credential
types in the iOS app model are HTTP cookies [17] and
OAuth Tokens [25, 27]. We focus on cookies, as they
generally provide a full set of privileges for a particular
app, whereas OAuth credentials are utilized to provide
limited permissions.

Many iOS apps (such as Facebook and Gmail) use
cookies as their authentication tokens. After ﬁrst login to
these apps, a cookie is generated by the server, transmit-
ted to the device, and stored locally. Later, this cookie
is presented to the server for accessing its contents via
APIs (mostly RESTful HTTP).

The locations of the stored cookies are determined by
the library that processes HTTP requests. The most com-
monly used library is called NSURLConnection [15],
which is provided by the default
iOS SDK. In ad-
dition, many third-party HTTP libraries [49, 50] are
built on top of NSURLConnection.
As a result,
these libraries store the cookies in the same ﬁxed lo-
cations as NSURLConnection. After analyzing the
NSURLConnection library, we found that all cookies are
stored inside an app’s home folder by default.

Due to sandbox-based isolation, accessing ﬁles inside
directories of other apps is prohibited in iOS. Since all
cookies are stored separately per app, unless attackers
can bypass the sandbox, a cookie can only be accessed
by the corresponding app itself. Thus, storing cookies in
each app directory is widely used by third-party develop-
ers and is considered to be hard to exploit [8].

4.2 Threat from the PC
This assumed difﬁculty of exploitation is incorrect
when USB-based attacks are considered in the threat
model. From a USB connection, a host computer can
connect to an iOS device not only through the iTunes
sync protocol, but also via the Apple File Connection
(AFC) protocol [46]. AFC is designed to access media

84  23rd USENIX Security Symposium 

USENIX Association

6

images taken from the camera, recorded
ﬁles (e.g.,
audio, or music ﬁles) through the USB cable. Further-
more, there exists a service maintained by lockdownd
called com.apple.mobile.house_arrest, which
provides
through
a computer
the AFC protocol.
has
contents of
/private/var/mobile/Applications/*.

As a result,
to the

to iOS app directories

full USB-based access

access

Attacks.

Credentials can be accessed via the
Cookie.binarycookies ﬁle within an app’s directory
using AFC. Both the httpOnly cookie that is protected
from JavaScript access and secure cookies that are only
transferred through HTTPS connections can be recov-
ered. Applying these cookies to the same apps in dif-
ferent devices allows attackers to log-in to the services
of their victims.

Real Examples. As a proof of concept, we imple-
mented a tool that can retrieve the cookies of Facebook
and Gmail apps from a USB-connected iOS device, and
transfer them to another computer.

By using these stolen cookies, we successfully logged
in as the victim via the web services for both Facebook
and Gmail. Although we only demonstrated the attacks
against Facebook and Gmail, we believe that our ﬁnding
affects a number of third-party apps that store cookies in
the way similar to the Facebook and Gmail apps.

5 Measurement

In this section, we describe the methodology and datasets
we use to determine a lower bound of the coexistence of
iOS devices, App Store purchases made from Windows
iTunes, and compromised Windows machines in home
networks, with a goal to quantitatively show that a large
number of users are likely to connect iOS devices to in-
fected personal computers.

5.1 Overview

SetiTunes

SetiOS

SetBot

SetMac

Figure 5: (Setbot − SetMac)∩ SetiOS ∩ SetiTunes is the esti-
mation of iOS devices that can be connected with bots.
Due to NAT, there are usually multiple machines (such
as Windows machines, mobile phones, and Mac ma-
chines) behind a single client ID (i.e., an anonymized IP
address). In our measurement, we used different ﬁnger-
prints to determine the client IDs (CIDs) that produce

``````````

Identiﬁed as

Truth

CID has Mac

CID has no Mac

CID has a Mac
CID has no Mac

True Positive
False Negative

False Positive
True Negative

Table 2: Deﬁnition of false positive and false negative.
network trafﬁc generated by iOS devices, App Store pur-
chases from Windows iTunes, and compromised Win-
dows machines.

First, we quantiﬁed the population of compromised
Windows machines (i.e., bots) using a labeled C&C do-
mains dataset (see Section 5.3). Since we only used C&C
domains from Windows malware families, we are con-
ﬁdent that all CIDs (Setbot in Figure 5) have Windows
machines. Next, within Setbot, we further measured how
many CIDs contain network trafﬁc generated from iOS
devices. Since there is an overlap of DNS queries from
Mac OS X and queries from iOS, we excluded CIDs
with Mac OS X trafﬁc (SetMac in Figure 5). We used
a set of iOS ﬁngerprint domain names to identify a lower
bound of CIDs containing iOS devices (SetiOS in Fig-
ure 5). Then, we estimated how many iOS devices in
SetiOS are likely to be connected to a Windows machine.
Since there is no unique DNS query generated when an
iOS device is connected to a Windows machine either via
USB or Wi-Fi, we assumed that if users have purchased
an item from the App Store using Windows iTunes, they
will eventaully connect iOS devices to a Windows ma-
chine. We estimated a lower bound of CIDs with Win-
dows iTunes (SetiTunes in Figure 5). Finally, the inter-
section of SetiOS and SetiTunes is our measurement result
(shaded area in Figure 5).

We use false positives and false negatives to evaluate
our methodology. They are deﬁned in Table 2, using
identiﬁcation of SetMac as an example. If a CID has a
Mac but we identify it as without a Mac, it is a false neg-
ative. On the other hand, if a CID does not have a Mac
but we identify it as with a Mac, it is a false positive. The
deﬁnition of false positive and false negative are similar
to identifying SetiOS and SetiTunes. Since we want to be
conservative about the size of SetiTunes ∩ SetiOS, we ac-
cept false positives for SetMac, false negatives for SetiOS
and false negatives for SetiTunes. However, we want to
have small or zero false negatives for SetMac as well as
false positives for SetiOS and SetiTunes.

5.2 Datasets
All datasets are provided by Damballa, Inc [3].

DNS Query Dataset. We obtained DNS trafﬁc from
two large ISPs in the US, collected in 13 cities for ﬁve
days4 in October 2013. A-type DNS queries from all
clients to the Recursive DNS Servers of the ISPs were

410/12/2013, 10/24/2013, 10/27/2013, 10/28/2013, 10/30/2013.

USENIX Association  

23rd USENIX Security Symposium  85

7

captured by a sensor in each city, and then de-duplicated
every hour to be stored. Each record in the dataset is a
tuple of sensor ID, hourly timestamp, anonymized CID,
query count, queried domain, and resolved IP address
of the domain. The CID is a hash of original client IP
address. The hash is performed to preserve client IP
anonymity, and at the same time to retain a one-to-one
mapping property. The query count denotes the num-
ber of times that client queried the particular domain and
resolved IP pair in the hour. On average, we observed
54 million client IDs, 62 million queries, and 12 billion
records daily from 13 sensors in total.

ISP Clients. Most CIDs in the two ISPs are home
networks. Only few are small businesses. Since 99.5%
of CIDs queried fewer than 1,000 distinct valid domains
daily, we identiﬁed those as representative of home net-
work users5.

DHCP Churn. Because of long DHCP lease times
(one week) and speciﬁc DHCP renewal policies (e.g., a
modem’s IP address will only be changed if some other
modem has acquired the IP address after lease expira-
tion) from the two large ISPs, the DHCP churn rate is
very low in the networks we measured. Consequently,
we consider a single CID as the same home in a given
day. This is different than that of a botnet’s perspective,
where the bots could reside in any network [48].

Passive DNS Database. We collected and built a pas-
sive DNS database for the same days, from the same lo-
cations as the DNS query dataset to provide visibility of
other types of DNS records. The database contains tu-
ples of date, sensor ID, queried domain, query type, re-
solved data, and query count. Since there are only A-type
records in the DNS query dataset, if there is a CNAME
chain [38] for the domain name we want to measure,
we use the passive DNS database to reconstruct the
CNAME chain to determine the mapping of the domain
we are interested in to the eventual returned A record.
For example, the CNAME chain for Apple’s iMessage
server static.ess.apple.com is shown in Table 3.
The ﬁnal A-type domain for static.ess.apple.com
is e2013.g.akamaiedge.net.
If we want to know
how many CIDs queried static.ess.apple.com in
a day, we ﬁrst examine the passive DNS database
that day to reconstruct all possible CNAME
for
chains to e2013.g.akamaiedge.net.
Next, we
make sure that only static.ess.apple.com resolved
into static.ess.apple.com.edgekey.net, and only
static.ess.apple.com.edgekey.net resolved into
e2013.g.akamaiedge.net.
Finally, we measure
e2013.g.akamaiedge.net in DNS query dataset.

HTTP Dataset. We utilized technology provided by
Damballa to collect HTTP headers related to iOS and

5We explain why we use 1,000 as the threshold in Section A.2

Windows iTunes, as well as those related to domain
names of our selection. If User Agent strings related to
iOS or Windows iTunes appeared in an HTTP header, or
if any selected domain name was in the “Host” ﬁeld of an
HTTP request, we collected the request and correspond-
ing response headers. The time frame for all HTTP head-
ers we obtained is from 10/18/2013 to 11/11/2013. Since
the HTTP data is not always available for all CIDs in our
DNS query dataset, we only used the HTTP dataset to
obtain ground truth for evaluating our approach.

Labeled C&C Domains We acquired all command
and control (C&C) domain names for botnets that
Damballa is tracking. The threat researchers in Damballa
labeled those C&C domains using various methods, in-
cluding static and dynamic analyses of malware, several
public blacklists, historical DNS information, etc. We
only picked malware families for Windows for the pur-
pose of this measurement, since we wanted to avoid Mac
OS X as much as possible.

static.ess.apple.com. 3600 IN CNAME
static.ess.apple.com.edgekey.net.
static.ess.apple.com.edgekey.net. 21600 IN CNAME
e2013.g.akamaiedge.net.
e2013.g.akamaiedge.net. 20 IN A 23.73.152.93

Table 3: CNAME chain for static.ess.apple.com.

5.3 Bot Population
First, we used labeled C&C domains to ﬁnd CIDs con-
taining infected Windows machines in the DNS query
dataset. If a CID queried any C&C domain in a day, we
consider it as having a bot at home for that day. During
the ﬁve days in October, we observed 442,399 to 473,506
infected CIDs daily, with an average of 459,326. In par-
ticular, there were 473,506 infected CIDs on 10/12/2013.
We use statistics from 10/12/2013 as an example below
to explain how we determine the population of iOS de-
vices and Windows iTunes.

5.4 Excluding Client IDs with Mac OS X
We utilized unique software update trafﬁc to ﬁngerprint
Mac OS X. Apple lists ﬁve domain names related to OS
X software update services [16]:

swscan.apple.com, swquery.apple.com, swdist.apple.com
swdownload.apple.com, swcdn.apple.com

Mac OS X is set to automatically check for security
updates daily since version 10.6 [14] and to check for
general software updates daily since version 10.8 [19].
We assume that if there is any Mac OS X within a
CID, there must be a query to at least one of the ﬁve
domains every day. According to [11], the percentage
of OS X versions later than or including 10.6 is 95%.
This assumption gives us a low false negative rate. To

86  23rd USENIX Security Symposium 

USENIX Association

8

evaluate the false positives of this approach, we veri-
ﬁed using the HTTP dataset (See Table 5). We were
able to collect HTTP headers for three of the ﬁve do-
main names. 3,530 headers for swdist.apple.com,
9,643 headers for swscan.apple.com, and 18,649
headers for swcdn.apple.com were observed. Among
115 unique (Source IP, User Agent string) pairs for
swdist.apple.com, 114 User Agent strings were from
Mac OS X, and one was from Mozilla, which gives
Similarly, nine out
us a
of 3,884 pairs of (Source IP, User Agent string) for
swscan.apple.com were false positives. We identiﬁed

false positive rate.

1
115

Weather App
Stocks App
Location
Service

apple-mobile.query.yahooapis.com

iphone-wu.apple.com

gs-loc.apple.com

iphone-wu.apple.com

Table 4: Domains for ﬁnding iOS devices.

6,966 (1.50%) of 473,506 infected CIDs with Mac OS
X on 10/12/2013. It is lower than the market share of
Mac OS X since we only looked for CIDs infected with
Windows malware. After excluding Mac OS X, we have
466,540 bot CIDs without Mac OS X, i.e., Setbot-SetMac.

iOS Device Population

5.5
We used unique domains from two default apps and one
service in iOS (the Weather app, Stocks app, and Loca-
tion Services) to get a lower bound of CIDs containing
iOS devices. We obtained these domains in Table 4 by
capturing and analyzing network trafﬁc when Weather,
Stock, and Location Services were used in a controlled
network environment. We also used the HTTP dataset for
evaluation. As Table 5 shows, within all (Source IP, User
Agent string) pairs that requested the three domains, all
User Agent strings were from either iOS or Mac OS X.
There were no User Agent strings from other operating
systems. Since we have already excluded CIDs with Mac
OS X trafﬁc in the previous step, domains in Table 4 can
be used to ﬁngerprint iOS without introducing any false
positives. However, if a user did not use Weather, Stocks,
or Location Services in the day, it is a false negative.

Of 466,540 CIDs without Mac OS X trafﬁc on
10/12/2013, 142,907 (SetiOS) queried any of the three
domains, indicating 30.63% of observed Windows bots
have iOS devices in the same home network.

5.6 Windows iTunes Population
After we identiﬁed infected CIDs containing iOS de-
vices, we further analyzed how many of these have
iTunes installed in infected Windows. The biggest chal-
lenge here is that there is no unique domain name
that can effectively ﬁngerprint Windows iTunes, because

Windows iTunes trafﬁc is similar to the trafﬁc generated
by the App Store for iOS.

Fortunately, we found that because of the Apple Push
Notiﬁcation Service [2], iOS devices need to constantly
query a certain domain name for push server conﬁgura-
tions. Based on this feature, we deﬁne iOS heartbeat
DNS queries as DNS queries that an iOS device always
makes as long as it is connected to the Internet.

To pinpoint Windows iTunes, our observation is that
if we observe App Store purchases but do not ﬁnd iOS
heartbeat DNS queries, then the purchases must originate
from iTunes. Next, we describe how we identify the iOS
heartbeat DNS queries and App Store purchase queries.

5.6.1 App Store Purchase
To ﬁngerprint App Store purchases, we experimented
with several App Store purchases in both Windows
iTunes and iOS. By analyzing PCAP traces of these pur-
chases, we discovered that domain names of the pattern
p*-buy.itunes.apple.com is related to a purchase,
where * denotes numbers. We used the HTTP dataset to
check this pattern (See Table 5). 487 HTTP headers were
collected from 10/26/2013 to 10/29/2013. From the 119
(Source IP, User Agent string) pairs, we conﬁrmed that
this pattern comes from the purchase of apps in either
iOS or iTunes.

iOS Heartbeat DNS Queries

5.6.2
To discover iOS heartbeat DNS queries, we ﬁrst col-
lected all domains in the “Host” ﬁeld of HTTP re-
quests containing iOS-related and Windows iTunes-
related User Agent strings from the HTTP dataset.
Next, we examined domains that received a large num-
ber of requests, and concluded that the domain name
init-p01st.push.apple.com is constantly queried
for Apple push server conﬁgurations and certiﬁcates
from iOS, but queried much less often by Windows
iTunes.

Apple does not disclose how often iOS devices query
their push server. To conﬁrm our observed queries were
iOS heartbeats, we utilized the following three methods.
1. HTTP Trafﬁc Analyses: 8,990 HTTP head-
ers were gathered for init-p01st.push.apple.com,
from 10/18/2013 to 10/31/2013. By inspecting the
distribution of “max-age” values of the Cache-Control
ﬁeld in the HTTP response headers, we were able to
know the intended cache policy for the push server cer-
tiﬁcate in the response. For iOS, the observed max-
age values were from 338s to 3,600s; for APSDae-
mon.exe (part of Windows iTunes), values ranged from
131,837s to 1,295,368s. Compared to Windows, iOS
caches the push server certiﬁcate for a shorter time, with
one hour maximum. Consequently, iOS devices must

USENIX Association  

23rd USENIX Security Symposium  87

9

Domain

Time Frame

iphone-wu.apple.com

swdist.apple.com
swscan.apple.com
swcdn.apple.com

10/24-11/04/2013
10/24-11/04/2013
10/19-11/11/2013
10/18-11/04/2013
apple-mobile.query.yahooapis.com 10/22-11/02/2013
10/22-11/04/2013
10/26-10/29/2013
10/18-10/31/2013

p*-buy.itunes.apple.com
init-p01st.push.apple.com

gs-loc.apple.com

HTTP headers

3,530
9,643
18,649
17,606
16,808
2,380
487
8,990

(Source IP, UA)

115
3,884
613
1,772
3,018
561
119
-

iOS
0
0
0

1,174
2,999
367
-
-

Mac Mozilla
114
3,875
140
598
19
182
-
-

1
9
473
0
0
0
-
-

Other

0
0
0
0
0
0

App Store

-

Table 5: Ground truth of ﬁngerprint domain names.

query init-p01st.push.apple.com when the cache
expires.

in

the

class

2. Reverse Engineering: We also reverse engineered
the push service daemon process apsd in iOS located at
/System/Library/PrivateFrameworks/
ApplePushService.framework/. We found that the
URL
http://init-p01st.push.apple.com/bag
is used to set up the push-server’s conﬁguration
path
APSEnvironmentProduction
through the method setConfigurationURL. Fur-
thermore,
called
PersistentConnection, we found that the maximum
length of time this connection can last is set to 1,800s
by
setMaximumKeepAliveInterval(1800.0).
This means iOS devices must re-send an HTTP re-
quest to get push server conﬁgurations at least every
1,800s. Moreover,
the ﬁnal A-type domain from
init-p01st.push.apple.com has a TTL of 20s. As a
result, every time the HTTP request is made, there must
be a DNS query for the A-type domain.

framework

another

private

in

3.

Idle iPod Touch Experiment: We set up
an iPod Touch to never auto-lock, connected it to a
WiFi hotspot, and left it idle for 35.5 hours. Dur-
ing this period,
there were 150 DNS queries to
init-p01st.push.apple.com in total. Average query
interval was 859s, with a maximum value of 1,398s and a
minimum value of 293s. The maximum query interval is
consistent with our 1,800s result via reverse engineering.
Our ﬁndings show that as long as an iOS de-
vice is connected to the Internet,
it constantly
queries init-p01st.push.apple.com for push ser-
vice conﬁgurations, with query intervals shorter than
an hour.
is determined by
both the HTTP Cache-Control value and an enforced
maximum interval value.
for
init-p01st.push.apple.com from iTunes is much
longer. The reason for this query interval difference may
be that iOS devices are more mobile than PCs. As an
iOS device moves, it might need a push server closer to
its current location, to ensure small push service delay.

Each query interval

The query interval

Given the unique ﬁngerprint for App Store pur-
chases and a unique iOS heartbeat query pattern,
we inferred a lower bound of Windows
iTunes

10

but

not

that queried
by estimating the number of CIDs
query
did
p*-buy.itunes.apple.com
init-p01st.push.apple.com in the hour before
and after the purchase query.
If the Windows iTunes
happened to query init-p01st.push.apple.com
within those two hours, or if the user did not pur-
chase anything in the iTunes App Store,
it would
be a false negative, since we cannot recognize Win-
dows iTunes even though it exists. However,
there
are no false positives.
Note that we cannot use
init-p01st.push.apple.com to estimate the number
of iOS devices for two reasons:
i) Windows iTunes
can query this domain; ii) the ﬁnal A-type domain of
init-p01st.push.apple.com can come from mul-
tiple original domain names6. Therefore, by removing
CIDs that queried init-p01st.push.apple.com in
the small time window, we exclude a larger set of CIDs
that purchased from within iOS, resulting in a lower
bound for Windows iTunes estimation.

On 10/12/2013,

from the 142,907 infected CIDs
with iOS devices, we further identiﬁed 112,233 CIDs
with Windows iTunes purchases on the same day, i.e.,
SetiTunes ∩ SetiOS. This indicates that 112,233 (23.70%)
of CIDs have both iOS devices and Windows iTunes, but
no Mac OS X within the home network.

5.7 Mobile Banking Trafﬁc
The iOS devices behind bot CIDs with Windows iTunes
are potential victims of our attacks. To estimate the per-
centage of those devices that may have banking apps
installed, we chose mobile domains from eight banks
(Citibank, Wells Fargo, PNC, Bank of America, Sun-
trust, Bank of the West, and U.S. Bank), and examined
how many of those iOS devices queried them. We dis-
covered that 4,593 (4%) of 112,233 potential victims
queried mobile banking domains on 10/12/2013. This
indicates that these devices are likely installed with mo-
bile banking apps that could be replaced with fake mo-
bile banking apps once they are infected, as discussed in
Section 3.

6This is the only ﬁngerprint domain name we used whose ﬁnal A-
type domain could be resolved from multiple different domain names.

88  23rd USENIX Security Symposium 

USENIX Association

5.8 Result Summary
We used the methodology described in this section to
measure the number of iOS devices that can be poten-
tially infected using the MitM attack described in Sec-
tion 2, with ﬁve days of DNS query data. The results
are summarized in Table 7. On average, we identiﬁed
459,326 bots daily. For 30% of bots, there exist iOS de-

Botnet

α
β
γ
δ
ε
ε
ζ
η
θ
ϑ

Size
287,055
69,895
49,138
16,236
13,732
5,024
4,554
4,377
4,231
4,067

Setbots ∩ SetiOS ∩ SetiTunes

75,714
12,517
10,216
3,232
2,662
1,182
944
929
834
806

Percentage

26.38%
17.91%
20.79%
19.91%
19.39%
23.53%
20.73%
21.22%
19.71%
19.82%

Table 6: Statistical analysis of the top 10 botnets with
highest number of infected CIDs on 10/12/2013.

vices used from the same CID; and for 23% of all bots,
there are both Windows iTunes installed and an iOS de-
vice used. Statistics for individual botnets as tracked by
Damballa are presented in Table 6. For example, if the
botmaster of botnet α bundled our attacks into their pay-
load, there would be 75,714 potential victims in 13 cities,
within the networks we monitor.
Setbots ∩ SetiOS
142,907 (30.63%)
134,838 (29.83%)
134,271 (30.35%)
138,793 (30.10%)
141,242 (30.21%)

112,233 (23.70%)
104,225 (23.06%)
104,075 (23.53%)
105,056 (22.78%)
102,795 (21.98%)

Setbots ∩ SetiOS ∩ SetiTunes

Date
10/12
10/24
10/27
10/28
10/30

Setbots
473,506
452,003
442,399
461,144
467,579

Table 7: Measurement results summary, October 2013.

6 Related Work

USB Attack Vector. The USB interface has been
demonstrated to be an attack vector for mobile de-
vices for some years [18, 31, 35, 52]. Z. Wang and
A. Stavrou [52] studied attacks that take advantage of
USB interface connectivity and presented three attack
examples on Android platforms that spread infections
from phone to phone, from phone to computer, and from
computer to phone. The work in [31, 35] further demon-
strated that these USB based attacks can take place
through USB charging stations or chargers. It is worth
noting that infecting connected mobile devices from the
PC has happened in the real world. Symantec has found
malware samples on Windows that can inject malicious
apps to USB-connected Android devices [6].

Our work is the ﬁrst to show measurement results that
indicate a large number of users are likely to connect iOS

devices to compromised computers, potentially leading
to a large scale infection of iOS devices. We hope that
our measurement results could drive Apple and other
mobile manufacturers to redesign the security model of
USB connections, and remind app developers to securely
store credentials. In addition, while most previous works
focus on Android, we present various attacks against
non-jailbroken iOS devices that can be launched via USB
or Wi-Fi connections.

Attacks Against iOS. In recent years, more attacks
against the iOS platform have been observed As one of
the most representative attacks, jailbreaking is the pro-
cess of obtaining root privilege and removing certain lim-
itations (such as code signing) on iOS devices by ex-
plooiting vulnerabilities in the kernel, the boot loader,
and even the hardware [37]. Since most jailbreaking
tools [22, 30] deliver the exploits through a USB con-
nection, attackers could also take advantage of these jail-
breaking tools to root USB-connected iOS devices. In
this case, attackers can easily inject malicious apps with
the ability to read and send SMS (e.g., [5]), which will
allow for more advanced attacks against SMS-based two
factor authentication schemes [21, 39].

Many researchers have shown that the App Store can-
not prevent publishing of malicious apps [26, 36, 51].
They also proposed defenses [20, 53] for jailbroken de-
vices. As previously mentioned, these malicious apps
could only affect a limited number of iOS users who
downloaded them. Our research describes the means to
deliver malicious apps to a signiﬁcant number of iOS de-
vices and could signiﬁcantly amplify the threat of iOS-
based malware.

Many works focus on reverse engineering iOS and
its protocols. Researchers analyzed the iMessage pro-
tocol and proposed Man-in-the-Middle attacks [44]. Re-
quiem [47] reverse engineered the Apple Fairplay DRM
protection algorithm for music, movies, and eBooks, and
can bypass Fairplay to decrypt protected media ﬁles.
However, Requiem does not support Apple Fairplay
DRM protection for apps in the App Store. The libimo-
biledevice project [33] enables a computer to commu-
nicate with USB-connected iOS devices without requir-
ing iTunes, such as syncing music and video to the de-
vice and managing SpringBoard icons and installed apps.
However, libimobiledevice does not contain the iTunes
authorization process (Section 2.1). In other words, li-
bimobiledevice can install an app purchased by Apple
IDA to an iOS device bound to Apple IDB, but the app
cannot successfully run due to the failure of DRM vali-
dations. In comparison, we analyzed the iTunes autho-
rization process, and found a way to bypass the DRM
validations. This can allow attackers to deliver malicious
apps downloaded by their Apple IDs to different iOS de-
vices.

USENIX Association  

23rd USENIX Security Symposium  89

11

Mobile OS Fingerprint. To ﬁngerprint mobile OSes
in a multi-device network environment, the User Agent
ﬁeld of the HTTP header, DHCP request header ﬁelds,
Organization Unique Identiﬁer (OUI, i.e., the ﬁrst 3-
bytes of a MAC address), or a combination of these were
commonly used [12, 24, 28, 34, 41]. Unfortunately, it is
not scalable to collect these data in ISP-level networks.
Furthermore, it is common for each client IP in a cellular
network to represent only one device. In ISP networks,
many client IPs represent a NAT endpoint. To cope with
the complexity caused by multiple devices per client IP
in ISP networks, we used unique domains from two de-
fault apps and one service within iOS to measure the
number of iOS devices. We also found a domain name
related to the push service with a unique query frequency
that allowed us to determine the presence or absence of
an iOS device for a given client IP.

7 Discussion

7.1 Accuracy of the Measurement
We emphasize that the goal of our measurement study
is to show that there is a large number of users who are
likely to connect their iOS devices to compromised com-
puters, which we argue may lead to a large scale infection
of iOS devices through botnets. There are many reasons
that may lead to underestimations in our measurement,
which implies that even more iOS devices could be in-
fected by the botnets that we monitor. For example, in
our measurement, we did not consider cellular trafﬁc and
the case that people often have multiple iOS devices in
their household.

Next, we discuss the potential reasons that may result
in overestimations and analyze why they are unlikely to
happen in our dataset.

Multiple Windows machines. The data we have only
allows us to determine what type of devices are behind an
IP address, but not how many of each. Thus, it is possi-
ble that there are multiple Windows machines behind an
IP. In the case that there are multiple Windows machines
and not all of them are infected, we may have an over-
estimated infection number since iOS devices could be
connected to only the uninfected computers. To reduce
this risk of overestimation, we excluded IPs that queried
more than 1,000 unique domains in a day because these
IPs are likely to be a gateway with many users. On the
other hand, we can expect that within a small environ-
ment, if one Windows machine in a NAT environment
is infected, it is likely that all Windows machines will
eventually be infected. This is because 1) most likely all
the Windows machines in the network are managed in a
similar manner, and have the same level of updates and

defenses, thus share the same vulnerabilities, and 2) it is
likely that there is some kind of communication or data
sharing (e.g., using the same Wi-Fi network or a USB
thumb drive) between the machines.

Mobility of iOS devices. Due to the mobility of
iOS devices, it is possible that the same iOS device ap-
pears in different “infected” IP addresses, which leads
to an overestimation of the number of potential iOS vic-
tims. However, we argue that this is extremely unlikely
in our dataset because the overestimation can only hap-
pen when the same iOS device is present behind differ-
ent NAT-networks in the same ISP, and the NATs have
infected computers that make purchases from Windows
iTunes in the same day.

7.2 Mitigation and Prevention
Since Apple has remote removal and revocation abilities,
they have complete mediation over what app can run on
an iOS device. However, due to a signiﬁcant number of
apps on the App Store and the lack of runtime monitors
on iOS devices, malicious apps are only detected when
the users perceive adverse effects of the malicious apps.
As a result, many iOS users may have already been af-
fected by such attacks before the manually-triggered re-
vocations and removal are applied. We have observed
many Android botnets [42, 43] even though Google also
has remote app removal ability [4]. In addition, this abil-
ity cannot prevent an attack that steals a user’s cookies
(as discussed in Section 4).

Since we only tested a few devices in the attack pre-
sented in Section 2, we cannot conﬁrm whether Apple is
able to impose a limit on the number of iOS devices that
can be authorized per Apple ID. However, since register-
ing an Apple ID only requires a valid email address, at-
tackers can easily prepare a number of Apple IDs and use
them to distribute malicious apps. Nonetheless, we still
suggest that Apple should monitor the anomalous Apple
IDs that deliver purchased apps to excessive number of
devices. In addition, we advocate that iOS should warn
the user when an app purchased by a different Apple ID
is to be installed.

The attack in Section 3 relies on iOS developer li-
censes. An individual iOS developer license can only
register up to 100 iOS devices, which prevents large scale
exploitation. However, Apple has the enterprise devel-
oper license program, which allows provisioning of an
arbitrary number of iOS devices. Although the appli-
cation for an Enterprise iOS Developer License is ar-
guably very difﬁcult because one would require a Dun
& Bradstreet (D-U-N-S) number, we have observed a lot
of real world cases of abusing enterprise licenses, such
as distributing pirated iOS apps [10], running GBA emu-
lators [9], and delivering jailbreak exploits [7]. It is also

90  23rd USENIX Security Symposium 

USENIX Association

12

possible for attackers to obtain such licenses through in-
fected machines under their control, rather than applying
for one. As result, we suggest that iOS should warn the
user when a provisioning proﬁle is installed or prompts
the user the ﬁrst time an app is run that is signed by an
unknown provisioning proﬁle.

To prevent

the malicious PC from stealing cook-
ies through the USB connection, third-party developers
should be aware that plaintext credentials could be easily
leaked through the USB interface and store the creden-
tials in a secure manner.

8 Conclusion

This paper discussed the feasibility of large scale infec-
tions of non-jailbroken iOS devices. We demonstrated
three kinds of attacks against iOS devices that can be
launched by a compromised computer: delivering Apple-
signed malicious apps, delivering third-party developer
signed malicious apps, and stealing private data from iOS
devices. Furthermore, by analyzing DNS queries gener-
ated from more than half a million IP addresses in known
botnets, we measured that on average, 23% of bots are
likely to have USB connections to iOS devices, poten-
tially leading to a large scale infection.

9 ACKNOWLEDGMENTS

We thank our anonymous reviewers and Manos Anton-
akakis for their invaluable feedback. We also thank the
various members of our operations staff who provided
proofreading of this paper. This material is based upon
work supported in part by the National Science Foun-
dation under Grants No. CNS-1017265, CNS-0831300,
and CNS-1149051, by the Ofﬁce of Naval Research un-
der Grant No. N000140911042, by the Department of
Homeland Security under contract No. N66001-12-C-
0133, and by the United States Air Force under Contract
No. FA8650-10-C-7025. Any opinions, ﬁndings, and
conclusions or recommendations expressed in this mate-
rial are those of the authors and do not necessarily reﬂect
the views of the National Science Foundation, the Ofﬁce
of Naval Research, the Department of Homeland Secu-
rity, or the United States Air Force.

References

[1] Apple

property

list.

https://developer.

apple.com/library/mac/documentation/cocoa/
conceptual/PropertyLists/AboutPropertyLists/
AboutPropertyLists.html.

[2] Apple push notiﬁcation service. http://en.wikipedia.org/

wiki/Apple_Push_Notification_Service.
[3] Damballa, inc. https://www.damballa.com/.

[4] Google

throws

android
http://googlemobile.blogspot.com/2011/03/
update-on-android-market-security.html.

switch

kill

on

phones.

[5] irealsms. http://irealsms.com/.
[6] New malware tries to infect android devices via usb ca-
http://www.symantec.com/security_response/

ble.
writeup.jsp?docid=2014-012109-2723-99.
[7] Pangu jailbreak for ios7.1.x. http://pangu.io/.
[8] Starbucks
vulnerable.

passwords

leaves

app

http:

//money.cnn.com/2014/01/15/technology/security/
starbucks-app-passwords/.

[9] Abusing enterprise distribution program to let users install gba
emulator, 2013. http://www.iphonehacks.com/2013/07/
apple-revokes-gba4ios-signing-certificate.html.

[10] Offering pirated ios apps without

the need to jailbreak,
2013. http://www.extremetech.com/mobile/153849-chinese-app-
store-offers -pirated-ios-apps-without-the-need-to-jailbreak.

[11] Operating

system

market

share,

2014.

http://www.netmarketshare.com/
operating-system-market-share.aspx?qprid=
10&qpcustomd=0&qpsp=2014&qpnp=1&qptimeframe=Y.

[12] M. Afanasyev, T. Chen, G. M. Voelker, and A. C. Snoeren. Anal-
ysis of a mixed-use urban wiﬁ network: when metropolitan be-
comes neapolitan.
In Proceedings of the 8th ACM SIGCOMM
conference on Internet measurement, IMC ’08, pages 85–98,
New York, NY, USA, 2008. ACM.

[13] F. Aloul, S. Zahidi, and W. El-Hajj. Two factor authentication
using mobile phones. In IEEE/ACS Computer Systems and Ap-
plications. 2009.

[14] Apple Inc. Mac OS X Snow Leopard and malware detection.

http://support.apple.com/kb/HT4651, June 2011.

[15] Apple Inc.

NSURLConnection Class Reference, Nov
https://developer.apple.com/library/

2013.
ios/documentation/cocoa/reference/foundation/
Classes/NSURLConnection_Class/Reference/
Reference.html.

[16] Apple Inc. Requirements for Software Update Service. http:

//support.apple.com/kb/ht3923, October 2013.
[17] A. Barth. HTTP State Management Mechanism.

tools.ietf.org/html/rfc6265, April 2011.

http://

[18] A. Bates, R. Leonard, H. Pruse, D. Lowd, and K. Butler. Lever-
aging usb to establish host identity using commodity devices. In
Network and Distributed System Security Symposium (NDSS’14),
2014.

[19] K. Bell.

Apple Increases Mountain Lion Security With
Daily Update Checks, Automatic Installs, More, June 2012.
http://www.cultofmac.com/175709/apple-increases-mountain-
lion-security-with-daily-update-checks-automatic-installs-more/.
[20] L. Davi, R. Dmitrienko, M. Egele, T. Fischer, T. Holz, R. Hund,
S. Nrnberger, and A. reza Sadeghi. Mocﬁ: A framework to mit-
igate control-ﬂow attacks on smartphones.
In Proceedings of
the Network and Distributed System Security Symposium (NDSS),
2012.

[21] A. Dmitrienko, C. Liebchen, C. Rossow, and A.-R. Sadeghi. On
the (in)security of mobile two-factor authentication. Technical
Report TUD-CS-2014-0029, CASED/TU Darmstadt, Mar. 2014.
[22] Evad3rs. Evasi0n jailbreaking tool. 2013. http://evasi0n.

com/.

[23] A. P. Felt, M. Finifter, E. Chin, S. Hanna, and D. Wagner. A
survey of mobile malware in the wild. In Proceedings of the 1st
ACM workshop on Security and privacy in smartphones and mo-
bile devices (SPSM), pages 3–14, 2011.

USENIX Association  

23rd USENIX Security Symposium  91

13

[24] A. Gember, A. Anand, and A. Akella. A comparative study of
handheld and non-handheld trafﬁc in campus wi-ﬁ networks. In
Proceedings of the 12th international conference on Passive and
active measurement, PAM’11, pages 173–183, Berlin, Heidel-
berg, 2011. Springer-Verlag.

[25] E. Hammer-Lahav. The OAuth 1.0 Protocol. http://tools.

ietf.org/html/rfc5849, April 2010.

[26] J. Han, S. M. Kywe, Q. Yan, F. Bao, R. H. Deng, D. Gao, Y. Li,
and J. Zhou. Launching generic attacks on ios with approved
third-party applications. In 11th International Conference on Ap-
plied Cryptography and Network Security (ACNS 2013). Banff,
Alberta, Canada, June 2013.

[27] D. Hardt. The OAuth 2.0 Authorization Framework. http://

tools.ietf.org/html/rfc6749, October 2012.

[28] L. Invernizzi, S. Miskovic, R. Torres, S. Saha, S.-J. Lee,
C. Kruegel, and G. Vigna. Nazca: Detecting Malware Distribu-
tion in Large-Scale Networks. In Proceedings of the ISOC Net-
work and Distributed System Security Symposium (NDSS ’14),
Feb 2014.

[29] iOS Security, May 2012. http://images.apple.com/ipad/

business/docs/iOS_Security_May12.pdf.

[30] Y. Jang, T. Wang, B. Lee, and B. Lau. Exploiting unpatched ios

vulnerabilities for fun and proﬁt. In Black Hat USA, 2014.

[31] B. Lau, Y. Jang, C. Song, T. Wang, P. H. Chung, and P. Royal.
Mactans: Injecting malware into ios devices via malicious charg-
ers. In Black Hat USA, 2013.

[32] C. Lever, M. Antonakakis, B. Reaves, P. Traynor, and W. Lee.
The core of the matter: Analyzing malicious trafﬁc in cellular
carriers. In Proceedings of The 20th Annual Network and Dis-
tributed System Security Symposium, 2013.

[33] Libimobiledevice. 2013. http://www.libimobiledevice.

org/.

[34] G. Maier, F. Schneider, and A. Feldmann. A ﬁrst look at mobile
hand-held device trafﬁc. In Proceedings of the 11th international
conference on Passive and active measurement, PAM’10, pages
161–170, Berlin, Heidelberg, 2010. Springer-Verlag.

[35] B. Markus, J. Mlodzianowski, and R. Rowley.

Juice jacking,
http://www.techhive.com/article/238499/

2011.
charging_stations_may_be_juice_jacking_data_
from_your_cellphone.html.

[36] C. Miller. Inside ios code signing. In Symposium on Security for

Asia Network (SyScan), Taipei, Nov 2011.

[37] C. Miller, D. Blazakis, D. DaiZovi, S. Esser, V. Iozzo, and R.-
iOS Hacker’s Handbook. Wiley, 1 edition, May

P. Weinmann.
2012.

[38] P. Mockapetris. Domain Names - Concepts and Facilities. http:

//www.ietf.org/rfc/rfc1034.txt, November 1987.

[39] C. Mulliner, R. Borgaonkar, P. Stewin, and J.-P. Seifert. Sms-
based one-time passwords: Attacks and defense. In Detection of
Intrusions and Malware, and Vulnerability Assessment. 2013.

[40] C. Mulliner and J.-P. Seifert. Rise of the iBots: 0wning a telco
network. In Proceedings of the 5th IEEE International Confer-
ence on Malicious and Unwanted Software (Malware), Nancy,
France, October 2010.

[41] I. Papapanagiotou, E. M. Nahum, and V. Pappas. Smartphones vs.
laptops: comparing web browsing behavior and the implications
for caching. In Proceedings of the 12th ACM SIGMETRICS/PER-
FORMANCE joint international conference on Measurement and
Modeling of Computer Systems, SIGMETRICS ’12, pages 423–
424, New York, NY, USA, 2012. ACM.

[42] V. Pidathala, H. Dharmdasani,
largest

and Z. Bu.
J. Zhai,
Misosms:
one of
advanced mobile bot-
nets.
http://www.fireeye.com/blog/technical/
botnet-activities-research/2013/12/misosms.html.
[43] H. Pieterse and M. Olivier. Android botnets on the rise: Trends
In Information Security for South Africa

the

and characteristics.
(ISSA), 2012.

[44] pod2g and gg. imessage privacy. In Hack In The Box Amsterdam,

2013.

[45] P. Porras, H. Sadi, and V. Yegneswaran. An analysis of the ikee.b
iphone botnet. In The Second International ICST Conference on
Security and Privacy in Mobile Information and Communication
Systems, 2010.

[46] M. RENARD, 2013. Hacking apple accessories to pown iDe-

vices.

[47] Requiem.

2013.
FairPlay#Requiem.

http://en.wikipedia.org/wiki/

[48] B. Stone-Gross, M. Cova, L. Cavallaro, B. Gilbert, M. Szyd-
lowski, R. Kemmerer, C. Kruegel, and G. Vigna. Your botnet is
my botnet: Analysis of a botnet takeover. In Proceedings of the
16th ACM Conference on Computer and Communications Secu-
rity, CCS ’09, 2009.

[49] The Restkit Project. RestKit, Nov 2013. http://restkit.

org/.

[50] M. Thompson. Afnetworking, Nov 2013. https://github.

com/AFNetworking/AFNetworking.

[51] T. Wang, K. Lu, L. Lu, S. Chung, and W. Lee. Jekyll on ios:
When benign apps become evil. In The 22nd USENIX Security
Symposium (SECURITY), 2013.

[52] Z. Wang and A. Stavrou. Exploiting smart-phone usb connectiv-
ity for fun and proﬁt. In Proceedings of the 26th Annual Com-
puter Security Applications Conference, ACSAC ’10, 2010.

[53] T. Werthmann, R. Hund, L. Davi, A.-R. Sadeghi, and T. Holz.
Psios: Bring your own privacy & security to ios devices.
In
8th ACM Symposium on Information, Computer and Communi-
cations Security (ASIACCS 2013), May 2013.

[54] C. Xiang, F. Binxing, Y. Lihua, L. Xiaoyi, and Z. Tianning. And-
bot: Towards advanced mobile botnets.
In Proceedings of the
4th USENIX Conference on Large-scale Exploits and Emergent
Threats, LEET’11, 2011.

[55] M. Zheng, H. Xue, and T. Wei. Background monitoring on non-
jailbroken ios 7 devices. http://www.fireeye.com/blog/
author/twei.

A Appendices

A.1 Fairplay
The code segments of iOS apps on the App Store are
encrypted with AES-128. Speciﬁcally, rather than us-
ing a single pair of key and IV (Initialization Vector) per
app, each 4K bytes (i.e., memory page size) of the code
segment of an app are encrypted with a unique pair of
key and IV. These keys and IVs are also encrypted and
stored in an supp ﬁle that is inside the SC_Info folder
within the app archive. Upon loading an encrypted app
into memory, iOS will derive the decryption keys and
IVs from the supp ﬁle, the sinf ﬁle that is also in-
side the SC_Info folder, and the sidb ﬁle that resides

92  23rd USENIX Security Symposium 

USENIX Association

14

under /private/var/mobile/Library/FairPlay/
iTunes_Control/iTunes/. A heavily obfuscated ker-
nel module FairPlayIOKit and a heavily obfuscated
user space daemon fairplayd are involved in this pro-
cess.

Furthermore,

this user space daemon fairplayd
is also involved in the generation of afsync.rq and
afsync.rq.sig mentioned in Section 2.2. After receiv-
ing the syncing request from a PC, the air trafﬁc con-
trol service atc running in iOS devices will communi-
cate with fairplayd through Mach messages to gener-
ate afsync.rq and afsync.rq.sig.

A.2 Measurement
Exclude small business networks. We plotted the cu-
mulative distribution for number of distinct valid do-
mains queried from all CIDs in a day in Figure 6. Some
CIDs queried a lot more than 2,000 distinct domains in a
day, e.g., 25,138,224. However, we only show in Fig-
ure 6 until 2,000 unique domains in the x-axis. The
CDF curve grows extremely slowly after 1,000 unique

domains, and 99.5% of CIDs queried fewer than 1,000
unique domains in a day. Therefore, we only use CIDs
that queried fewer than 1,000 distinct valid domains per
day in our experiment.

CDF for Unique Domains per Day

100

)

%
(
F
D
C

75

50

25

0

0
2000
Unique Domains Queried by CID per Day

1000

500

1500

Figure 6: Cumulative distribution for number of distinct
valid domains queried from all CIDs, on 10/12/2013.

USENIX Association  

23rd USENIX Security Symposium  93

15

