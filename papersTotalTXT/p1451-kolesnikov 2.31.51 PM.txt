Attribute-based Key Exchange with General Policies∗

Vladimir Kolesnikov

Hugo Krawczyk

IBM Research

hugo@ee.technion.ac.il

Yehuda Lindell
Bar-Ilan University

yehuda.lindell@biu.ac.il

Tal Rabin
IBM Research

talr@us.ibm.com

1.

INTRODUCTION

The increasing need and complexity of authentication in
the digital world, alongside ever growing privacy concerns,
has given rise to encryption and authentication mechanisms
that combine privacy aspects (anonymity, unlinkability, etc.)
with credentials that go well beyond asserting an identity
of a client but rather vouch for a full set of attributes (age,
rank, role, etc.). These mechanisms allow for authentication
and encryption that build on authorization policies com-
puted on the provided set of attributes. For example, in a
hospital setting, access to a patient’s records can be pro-
vided to the patient, her doctor, nurses while on duty, or to
the director of the hospital ward, and this can be formalized
as a policy.

The prime examples of these mechanisms are attribute-

based credentials (ABCs) [23, 17, 19, 20, 7, 3, 4] and attribute-
based encryption (ABE) [36, 30, 9, 38]. The former is mainly
directed towards identiﬁcation and access control based on
a set of attributes, and emphasizes privacy aspects such
as anonymity, unlinkability, and attribute privacy. While
ABCs generally assume an interactive setting between a
client and a server, ABE focuses on (non-interactive) encryp-
tion where authorization is enforced through an encryption
scheme that ties a ciphertext to a policy and a decryption
key that ensures that only clients that have attributes that
satisfy the policy can decrypt (note that we focus on the “ci-
phertext policy” setting of ABE [9]). Since ABE schemes are
non-interactive (and the party decrypting is completely pas-
sive), they have certain implicit privacy properties of ABC
solutions such as unlinkability and attribute privacy. An
essential requirement of the above primitives is that of col-
lusion resistance. This means that diﬀerent clients of the
system cannot combine their attributes in order to pass pol-
icy veriﬁcation that neither could have individually passed.
In many practical settings simply communicating a mes-
sage to a party or just establishing rights (such as validating
a function of attributes) is not enough. For example, authen-
tication to an online service is usually followed with further
communications that also need to be protected.
In other
words, the goal in these systems is the use of credentials to
bootstrap a key exchange protocol that provides the parties
with keys to protect a session.

In this paper we combine elements of ABE and ABCs to
build attribute-based key exchange (ABKE) where our focus
is on an interactive solution involving a client that holds
a certiﬁcate (issued by an authority CA) vouching for the
client’s attributes and a server that holds a policy com-

kolesnikov@research.bell-

Bell Labs
labs.com

†
Alex J. Malozemoff
amaloz@galois.com

Galois

ABSTRACT
Attribute-based methods provide authorization to parties
based on whether their set of attributes (e.g., age, organi-
zation, etc.) fulﬁlls a policy. In attribute-based encryption
(ABE), authorized parties can decrypt, and in attribute-
based credentials (ABCs), authorized parties can authen-
ticate themselves.
In this paper, we combine elements of
ABE and ABCs together with garbled circuits to construct
attribute-based key exchange (ABKE). Our focus is on an in-
teractive solution involving a client that holds a certiﬁcate
(issued by an authority) vouching for that client’s attributes
and a server that holds a policy computable on such a set of
attributes. The goal is for the server to establish a shared
key with the client but only if the client’s certiﬁed attributes
satisfy the policy. Our solution enjoys strong privacy guar-
antees for both the client and the server, including attribute
privacy and unlinkability of client sessions.

Our main contribution is a construction of ABKE for ar-
bitrary circuits with high (concrete) eﬃciency. Speciﬁcally,
we support general policies expressible as boolean circuits
computed on a set of attributes. Even for policies contain-
ing hundreds of thousands of gates the performance cost is
dominated by two pairing computations per policy input.
Put another way, for a similar cost to prior ABE/ABC solu-
tions, which can only support small formulas eﬃciently, we
can support vastly richer policies.

We implemented our solution and report on its perfor-
mance. For policies with 100,000 gates and 200 inputs over
a realistic network, the server and client spend 957 ms and
176 ms on computation, respectively. When using oﬄine
preprocessing and batch signature veriﬁcation, this drops to
only 243 ms and 97 ms.
∗
iacr.org/2016/518
†
Portion of work done while at University of Maryland and
Bell Labs.

The full version of this paper is available at https://eprint.

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’16, October 24-28, 2016, Vienna, Austria
c(cid:13) 2016 ACM. ISBN 978-1-4503-4139-4/16/10. . . $15.00
DOI: http://dx.doi.org/10.1145/2976749.2978359

1451putable on the set of attributes. The goal is for the server
to establish a shared key with the client if and only if the
client’s certiﬁed attributes satisfy the policy.1

Of course, the above goal is easy to achieve if the client
is willing to reveal its attributes to the server. The objec-
tive of our work is to enable the ABKE functionality while
keeping the attributes of the client private alongside ensur-
ing additional important properties. The main features of
our ABKE solution are summarized next.

General policies. We support any policy expressible as a
polynomial-size boolean circuit computed on a set of
attributes.

Attribute privacy. Client attributes are never disclosed. Of
course, the server learns whether the key exchange suc-
ceeded and thus learns that the client’s attributes ful-
ﬁll the policy used in the exchange. However, nothing
beyond this fact is revealed.

Unlinkability. Multiple communications with the same client
(with one or more servers) cannot be linked together.
Collusion resistance. It is not possible for an adversary given
keys associated with multiple clients with diﬀerent at-
tributes (certiﬁed by the CA) to succeed in an exchange
in which no single client with its associated attributes
fulﬁlls the policy. In particular, attributes from diﬀer-
ent clients cannot be mixed-and-matched.

1.1 Overview of Our Solutions
Our main contributions are a deﬁnition (cf. §4) and real-
ization (cf. §6) of attribute-based key exchange (ABKE) for
public (circuit-based) policies.

ABKE using garbled circuits. Our construction uses
garbled circuits in order to achieve ABKE. The use of gar-
bled circuits enables us to obtain a solution that both sup-
ports arbitrarily-complex policies (without requiring heavy
machinery like multilinear maps or fully homomorphic en-
cryption) and is concretely eﬃcient. In our approach, the
server generates a garbled circuit and sends it to the client.
The client then obtains the garbled values on the input wires
of the circuit, depending on its attributes. This is achieved
by encrypting the garbled values on the input wires using
a type of encryption that enables the client to decrypt only
those values associated with its attributes. We call this no-
tion attribute selective encryption (ASE) (cf. §5). The main
technical diﬃculty comes with ensuring that the client ob-
tains input labels corresponding to its credentials in a pri-
vate, unlinkable, and collusion-free manner. At a high level,
we construct such an encryption scheme using a rerandomiz-
able set of public keys and a rerandomizable signature bind-
ing the public keys together. The client then presents a set
of rerandomized keys (along with a signature on them), and
the server encrypts the garbled labels knowing that the client
can only decrypt the appropriate set. We introduce and uti-
lize the notion of extractable linearly homomorphic (ELH) sig-
natures (cf. §7) to construct two instantiations of ASE: one
based on identity-based encryption (cf. §8) and the other

1Note that we focus on the client-server setting where the
client authenticates to the server. Server authentication usu-
ally happens with regular public key certiﬁcates that identify
the server and can use standard tools such as TLS. Exten-
sions of our system to the mutual authentication setting are
possible but not treated here.

built directly from ELH signatures (cf. §9). The extractabil-
ity requirement ensures that a simulator can extract the
original message that was signed, even though the adversary
presents a randomized message. We prove this extractability
property using the knowledge-of-exponent (KEA) assump-
tion.

Our use of garbled circuits is a careful adaptation of the
zero-knowledge-using-garbled-circuits approach of Jawurek
et al. [34]. As shown in their work, we can use a single
garbled circuit while still achieving malicious security; this
is discussed in more detail in §6.
Concrete performance. At a cost similar to that of prior
ABE/ABC solutions, which only run eﬃciently on (small)
formulas, we can support vastly richer policies represented
by large circuits. Speciﬁcally, we instantiate our construc-
tion over bilinear groups requiring a number of pairings pro-
portional to the number of input attributes to the policy
circuit. Then a garbled circuit computation of the policy
circuit is performed with cost that is not noticeable for poli-
cies of even relatively large circuit size2.
To directly measure the performance of our scheme, we
implemented it and ran various experiments; see §10. For
example, in our implementation, the server and client com-
putation time for a 1,000-gate policy and 10 attributes is
67 ms and 11 ms, respectively; for a 100,000-gate policy
and 200 attributes the times are only 957 ms and 176 ms.
We also note that much of the computation can be moved
oﬄine and we can use batch signature veriﬁcation on the
server side. Again with a 100,000-gate policy and 200 at-
tributes, this optimized time is only around 243 ms for the
server, when assuming the server is batching ten messages
in its signature veriﬁcation, and 97 ms for the client.

Additional features. Our construction can be easily ex-
tended to provide additional useful features, as detailed be-
low.

• Credential expiration, by having attributes encode the
expiration date.
• Delegation of attributes. This follows directly from the
projectability property of our ASE deﬁnition (cf. §5).
• Multi-authority. This can be achieved generically by
having credentials from diﬀerent CAs encode, as a se-
quence of attributes, a unique certiﬁed serial number
which is veriﬁed to be the same during ABKE. A more
eﬃcient alternative is oﬀered by our ELH-based ASE
construction (cf. §9) by using a common value u in the
clients’ public keys in lieu of a unique serial number.
• Unlinkability with respect to CA. Our IBE-based con-
struction for ASE (cf. §8) provides information the-
oretic unlinkability, which implies unlinkability even
against a colluding server and CA. Such unlinkability
is also achieved by our ELH-based solution provided
that the public key components g and h are generated
jointly between the client and CA.

Future work. In this work we consider public policies only.
However, our techniques can be used to provide some no-
tion of private policies and we leave this for future work.
Likewise, our focus here has been on achieving practical eﬃ-
ciency, and we achieve this using the KEA assumption and
2For example, we can garble (resp., evaluate) an AND gate
in roughly 46 (resp., 28) cycles per gate using privacy-free
garbled circuits [25, 39].

1452the random-oracle model. The goal of achieving compara-
ble eﬃciency under standard assumptions only and without
a random oracle is important and we leave it for future work.

2. RELATED WORK

Our ABKE notion relates to ciphertext-policy attribute-
based encryption (CP-ABE) and attribute-based credentials
(ABCs). CP-ABE gives rise to a single-message key ex-
change (KE) solution in which a session key is encrypted
under ABE and hence is implicitly authenticated by clients
that can decrypt. Since the same key is distributed to any
client with a set of attributes satisfying the policy, multiple
clients may share the same key. This is the solution proposed
by Gorantla et al. [28], who provide a game-based deﬁni-
tion of attribute-based authenticated key exchange (under
the abbreviation AB-AKE) and note that such a scheme is
more in line with group key exchange than standard AKE.
ABE-based AKE requires several public-key operations
per gate of the policy formula. Recent solutions to ABE for
general circuits [26, 29], while suﬃcient to show feasibility,
are mainly of theoretical interest due to the use of heavy
underlying primitives. By using garbled circuits, our pro-
tocol costs are dramatically lower than either of the above
ABE-based solutions.

Since most key exchange settings allow for interaction (the
session that they protect is in itself typically interactive), our
work leverages interaction to improve policy expressiveness
as well as performance. In this sense we are closer to the
ABC setting, where clients own the credentials they use in
an interaction with a veriﬁer. Our work inherits many of the
challenges of ABCs, particularly in the area of client privacy,
with properties such as attribute-privacy and unlinkability
being central to our work. We note, however, two important
diﬀerences.

First and foremost, prior ABC protocols and systems fo-
cus on (but are not limited to) small formula-based poli-
cies [23, 17, 19, 20, 7, 3, 4, 1] due to the high cost of
needing several public-key operations per gate. Besides the
cost, diﬃculty of policy design and analysis of non-trivial
hand-generated small formulas is the reason that today’s de-
ployed systems mainly implement conjunction policies. In
this work, we dramatically increase the computation power
of the policy by enabling its implementation via garbled cir-
cuits. We believe that in addition to improving eﬃciency
of existing ABC use cases, our work enables a much larger
application scope for ABCs, due to the ability to run (large)
policies auto-generated from easy-to-understand high-level
code.

Secondly, the ABC literature focuses on veriﬁcation of
credentials and not on bootstrapping an authenticated ses-
sion. In general, the ability to verify client credentials (i.e.,
a yes/no result) is insuﬃcient for authenticating a session,
even if the communication is carried over a server-authenticated
channel (e.g., TLS). The relationship between credentials
and key exchange is explicitly studied by Camenisch et al. [18],
but their implementations do not cover rich policies, and do
not outperform ABCs.

ABCs provide several practical features which we regard
as future work, such as credential revocation and CA-veriﬁer
collusion. Other features, such as non-boolean and multi-
authority credentials can be easily and cheaply built within
our system (cf. §1.1).

In a concurrent and independent work, Chase et al. [22]

approach the problem of ABCs for non-boolean attributes by
relying on garbled circuits to represent policies and, as a con-
sequence, allow general circuit-based policies. The method
of delivery of wire labels to the prover (in our notation, the
client) is indeed the technical core of both of our approaches.
Chase et al. allow the prover to enter arbitrary inputs to the
garbled circuit, requiring a zero-knowledge proof that its
garbled circuit inputs are consistent with arithmetic com-
mitted values, which, in turn, are consistent with the cre-
dential vector on which there exists a valid CA signature.
This results in a number of exponentiations per boolean at-
tribute, even in cases where a small subset of them are used
in the policy. Chase et al. oﬀer an alternative algorithm to
reduce the number of public-key operations at the expense
of message authentication code computation inside the gar-
bled circuit, which introduces a signiﬁcant communication
overhead but may be a worthy trade-oﬀ for provers with
many attributes. This approach, too, scales with the to-
tal number of attributes. In contrast, in our approach the
client needs to only compute public-key operations per pol-
icy attribute (rather than over all the client’s attributes as is
required by Chase et al.), which may be signiﬁcantly faster
in many settings. However, our improved performance is a
trade-oﬀ for using stronger assumptions. Additionally, we
present the ﬁrst implementation of general circuit ABKE
(and hence ABCs), and report on its concrete performance.
Finally, the construction of [22] does not support delegation,
and it is not immediately clear how to enable it there.

Finally, Sakai et al. [37] very recently proposed attribute-
based signatures for circuits based on bilinear maps. In their
setting, only signers satisfying a certain policy on their at-
tributes could successfully sign a message. Their scheme
could be a basis for an ABC solution; however, they require
several public-key operations and about 1 Kb of data sent
per circuit gate; our garbled circuit-based solution is much
more eﬃcient (16 bytes and several symmetric key opera-
tions per circuit gate).

3. PRELIMINARIES
Let P1, . . . , P(cid:96) and S1, . . . , St be the set of clients and
servers, respectively, and let A = {a1, . . . , am} be the uni-
verse of all possible attributes. We associate an m-bit string
χi = χi[1]··· χi[m] ∈ {0, 1}m with each Pi such that χi[j] =
1 if and only if Pi has attribute aj. A policy is a (polynomial
sized) circuit C with m inputs and a single-bit output. We
say that Pi satisﬁes policy C if and only if C(χi) = 1.

Garbled circuits. One of our main building blocks is gar-
bled circuits. As the circuit description is public and only
one party has input, we can utilize privacy-free garbled cir-
cuits [25], which are more eﬃcient than standard garbled cir-
cuits. We use the garbled circuit notation of Bellare et al. [8],
with one function (veriﬁcation) introduced by Jawurek et
al. [34]. We only consider circuits with a single bit of out-
put, as this is all that is needed in our setting.
We deﬁne a veriﬁable garbling scheme by a tuple of func-
tions G = (Gb, Ev, Ve) with each function deﬁned as follows:
• Garbling algorithm Gb(1n, C): A randomized algo-
rithm which takes as input the security parameter and
a circuit C : {0, 1}m → {0, 1} and outputs a tuple
of strings (GC,{X 0
j }j∈[m],{Z 0, Z 1}), where GC is
the garbled circuit, the values {X 0
j }j∈[m] denote

j , X 1

j , X 1

1453the input-wire labels, and the values {Z 0, Z 1} denote
the output-wire labels.

• Evaluation algorithm Ev(GC,{Xj}j∈[m]): A determin-
istic algorithm which evaluates garbled circuit GC on
input-wire labels {Xj}j∈[m].

• Veriﬁcation algorithm Ve(C, GC,{X 0

j }j∈[m]): A
deterministic algorithm which takes as input a cir-
cuit C, garbled circuit GC, and input-wire labels {X 0
j ,
j }j∈[m], and outputs accept if GC is a valid garbling
X 1
of C and reject otherwise.

j , X 1

A veriﬁable garbling scheme must satisfy three security
properties: (1) correctness, (2) authenticity, and (3) ver-
iﬁability. The deﬁnitions for correctness and authenticity
are standard: correctness enforces that a correctly garbled
circuit, when evaluated, outputs the correct output of the
underlying circuit; authenticity enforces that the evaluator
can only learn the output label that corresponds to the value
of the function. Veriﬁability [34] allows one to check that
the garbled circuit indeed implements the speciﬁed plaintext
circuit C.

t-KEA assumption. We recall the t-KEA assumption
used in our implementation of extractable linearly homo-
morphic signature from §7. The assumption was formulated
in [11, 10]. See these papers and [32] for a good discussion
and further references related to this assumption and its re-
cent use. See also [5, 31] for a proof of security for t-KEA
in the generic (bilinear) group model. The formulation be-
low is simpliﬁed by not including an auxiliary input that, if
present, is the same for both algorithms E and E(cid:48)
. We will
use the plain acronym KEA when referring to the 1-KEA
assumption.

1 , . . . , gx
t

Definition 3.1. (t-KEA [11, 10]) Let G be a cyclic group
of prime order q. Consider algorithms that on input t ran-
dom elements g1, . . . , gt in G and t values gx
for
x ∈R Zq, output a pair (f, f(cid:48)
) in G2. Such an algorithm E is
said to be a t-KEA algorithm if with non-negligible probabil-
ity (over the choice of inputs to E and E’s random coins) E
outputs (f, f(cid:48)
= f x. We say that the t-KEA as-
sumption holds over G if for every eﬃcient t-KEA algorithm
E in G there exists another eﬃcient algorithm E(cid:48) for which
the following property holds except for a negligible probabil-
ity: Let g1, . . . , gt, gx
t be an input to E and ρ a vector
of random coins for E on which E outputs (f, f(cid:48)
= f x) then
on the same inputs (and random coins) E(cid:48) outputs a vector
1 ··· gxn
(f, f(cid:48)
n .

= f x, x1, . . . , xn) such that f = gx1

) such that f(cid:48)

1 , . . . , gx

Auxiliary functionalities. Our construction makes use of
two (standard) functionalities for commitments (Fcom) and
secure coin-tossing (Fcointoss).
Anonymous channels. Our protocol assumes that the
parties interact over anonymous channels. In practice, the
anonymity provided by the network used by the clients is
the level of anonymity that they achieve. For the purpose of
proving security, we assume a perfect anonymous channel.
In the simple-UC framework [21], which we use in this work,
all messages to and from functionalities have public headers
consisting of the type of operation, and the private content
itself; the public header is revealed to the adversary but not
the private content. However, the adversary is always given

the identity of the party sending the message to the func-
tionality and the identity of the party receiving the message
from the functionality. Thus, in order to model anonymous
channels, all parties must send and receive together. (This
actually makes sense since in principle, an adversary who
can view the entire network can break anonymity unless ev-
ery party interacts in each round. Nevertheless, here we use
this simply as a way to model the requirements.) The Fanon
functionality appears in Figure 3.1. In the functionality all
parties send a message to all other parties in each round.
Note that if a party has no message at all to send, or it
only needs to send to some parties, then it can simply use
an empty message. We stress again that in practice not all
parties need to interact in each round; this is merely for the
purpose of modeling.

4. SECURITY DEFINITION

All of our deﬁnitions and proofs are in the simple-UC
(SUC) model [21]. As was shown in the aforementioned
work [21], any protocol that is secure in the SUC framework
is also secure in the full UC framework.

Attribute-based key exchange. We present a function-
ality Fabke for attribute-based key exchange supporting at-
tribute privacy, unlinkability, and collusion resistance. The
functionality is initialized with a set of attribute vectors
{χi}, where χi corresponds to the attribute vector of client Pi.
The functionality begins by waiting for a message from a
server Sj that contains a circuit C representing Sj’s policy.
The functionality stores this information and broadcasts a
notiﬁcation to all parties P1, . . . , P(cid:96) that a policy is avail-
able. Upon receiving a response by one of the parties, say,
Pi, the functionality proceeds as follows. If C(χi) = 1, the
policy is satisﬁed and so the functionality forwards a random
key k to both Pi and Sj. If C(χi) = 0, then Fabke sends ⊥ to
both Pi and Sj. The full description of Fabke can be found
in Figure 4.1.

Attribute privacy is captured by the fact that Sj never
receives the attribute vector χi of client Pi. Collusion re-
sistance is handled by the fact that each party’s attribute
vector is ﬁxed upon functionality initialization and cannot
be changed. Thus, parties cannot use any attribute vector
that diﬀers from their initial ones. This implies that collu-
sions between parties to eﬀectively use a diﬀerent attribute
vector are impossible. Finally, unlinkability follows since the
functionality does not pass on the identity of the client Pi to
the server Sj at any time. We note that we do not provide
server anonymity in our deﬁnition, since it does not seem
to be required for the ABKE setting. Thus, the server’s
identity is revealed in the functionality deﬁnition.
We also introduce a functionality Fsetup for providing each
party with the keys used in our protocol construction; see
Figure 4.2.

5. ATTRIBUTE SELECTIVE ENCRYPTION
We introduce the notion of attribute selective encryption
(ASE). ASE is related to ABE in the sense that clients’ keys
and decryption capabilities are related to the attributes they
possess. In ASE a plaintext is comprised of a set of mes-
sages, and a client’s credentials determine which subset can
be decrypted. In more detail, each client has an m-bit vector
χ ∈ {0, 1}m representing a set of attributes: χ[j] is set to
1 if and only if the client possesses the jth attribute. The

1454Fanon works with clients P1, . . . , P(cid:96) as follows:

1. Upon receiving a message (send, sid, Pi, (mi
2. After Fanon receives a send message from every client P1, . . . , P(cid:96), Fanon sends (receive, sid, Pj , (m1

(cid:96))) from Pi, Fanon stores the message.

1, . . . , mi

j , . . . , m(cid:96)

j )) to client Pj

for j = 1, . . . , (cid:96).

The public header of each message is (send, sid, Pi) and (receive, sid, Pj ), respectively, for send and receive messages. The
private contents is the vector of messages.

Figure 3.1: Anonymous communications functionality Fanon.

Fabke runs with clients P1, . . . , P(cid:96) with attribute vectors χ1, . . . , χ(cid:96) ∈ {0, 1}m, and servers S1, . . . , St, and works as follows:
1. Upon receiving (policy, sid, C) from some Sj , where C is either a circuit C(cid:48) : {0, 1}m → {0, 1} or ⊥, send (policy, sid, Sj , C)

to all P1, . . . , P(cid:96). If C = ⊥ then halt, and otherwise store (policy, sid, Sj , C).

2. Upon receiving (exchange, sid, Sj ) from Sj and (exchange, sid, Sj , Pi) from Pi, if some message (policy, sid, Sj , C) is stored,

then:

• If C(χi) = 1 then choose k ∈R {0, 1}n and send (completed, sid, k) to Pi and Sj .
• If C(χi) = 0 then send (completed, sid, ⊥) to Pi and Sj .

3. Upon receiving (abort, sid) from Sim, clear any message (policy, sid, Sj , C) that is stored, send (abort, sid) to Pi and Sj ,

and halt.

The public header of each message is: (policy, sid, Sj , C), (exchange, sid, Sj ), and (completed, sid); all other content is private.
Figure 4.1: Attribute-based key exchange functionality Fabke with attribute privacy, unlinkability and collusion resistance.

client holds public and secret keys associated with χ. Any-

one can encrypt a set of 2m messages

(cid:18) x1,0

x1,1

(cid:19)

··· xm,0
··· xm,1

under the client’s public key, and ASE enforces an OT-like
property where the client can decrypt using its secret key
only one of each (xi,0, xi,1), depending on χ[j]. That is, the
client decrypts the messages x1,χ[1], . . . , xm,χ[m], and noth-
ing else. We stress that ASE, unlike ABE, encrypts under a
speciﬁc client’s public key, and only that client can decrypt.
Besides the basic semantic security notion of ASE, we con-
sider four additional properties: attribute privacy, collusion
resistance, unlinkability, and projectability. Each property
on its own is easy to achieve, yet the combination, espe-
cially that of collusion resistance and unlinkability, makes
the construction challenging.

Attribute privacy. This property requires that the public
key pkχ hides attribute vector χ. That is, publishing pkχ
does not reveal which attributes the client holds. The fol-
lowing trivial solution achieves attribute privacy: generate
a set of 2m public keys and deﬁne the secret key to consist
of only one of the secret keys in each pair.
Collusion resistance. A set P of clients with attribute
vectors X = {χi}Pi∈P and corresponding keypairs must not
be able to construct a keypair representing χ /∈ X (or χ
representing a subset of attributes not implied by X — cf.
projectability below). Collusion resistance can be achieved
by combining the trivial solution from above with a secure
signature scheme; i.e., by providing a signature on the set of
the client’s public keys. This prevents clients from mixing
and matching the individual keys in their public keys, giving
collusion resistance.

Unlinkability. Unlinkability is the inability to link between
diﬀerent uses of the same public key. Speciﬁcally, we require
that it be possible to randomize a public key using some
algorithm Unlink so that the pair (pkχ, Unlink(pkχ)) looks
like two independent public keys. Without the requirement

of collusion resistance, unlinkability is easy to achieve (e.g.,
by using ElGamal keys). However, as we are interested in
collusion resistance we thus need to enable the creation of
a signature on the randomized key. For this we need to
use homomorphic signatures. However, existing signature
schemes do not provide the capabilities that are needed for
our schemes. Thus, combining signatures with unlinkability
is not straightforward.

Projectability. We require that given a keypair associated
with a vector χ, one can generate a keypair that is associ-
ated with any orthogonal projection of χ onto some subset
S ⊆ [m]. We stress that the subset S is explicit in the pro-
jection (otherwise, the encrypting party cannot know what
the projection is, and this could be used to obtain unautho-
rized decryptions). As each public key needs to be certiﬁed,
this implies that the certiﬁcate for the new key also needs
to be derived from the certiﬁcate of pkχ.

Committing encryption. We require that ASE encryp-
tion is committing.
5.1 Formal Deﬁnition

Let n denote the security parameter and let m be the
length of the attribute vector. We assume for simplicity
that the client receives a public key on the entire attribute
vector.

Definition 5.1. An attribute selective encryption (ASE)
scheme with attribute privacy, collusion resistance, and un-
linkability is a tuple of probabilistic-polynomial time algo-
rithms (Setup, GenCert, Vrfy, Enc, Dec, Unlink, Project) as fol-
lows:

• Setup(1n, m) takes as input an attribute set size m,
and outputs a master veriﬁcation key and a master
secret key (mVK, mSK) along with public parameters
PP. All the following algorithms implicitly take PP as
input.

1455Upon initialization with length parameter m, Fsetup runs (PP, mVK, mSK) ← Setup(1n, m) and stores (mVK, mSK).

1. Upon receiving (generate, sid, χi) from player Pi, Fsetup checks if there exists a record (i, ·, ·, ·).

sends (result, sid, ⊥) to Pi. Otherwise, Fsetup runs (pk, sk) ← GenCert(mSK, χi),
(result, sid, mVK, pk, sk) to Pi.

If so, Fsetup
records (i, χi) and sends

The public header of each message is: (generate, sid) and (result, sid); all other content is private.

Figure 4.2: Setup functionality Fsetup.

• GenCert(mSK, χ) takes as input the master secret key
and attribute vector χ ∈ {0, 1}m, and outputs a certi-
ﬁed keypair (pkχ, skχ) associated with χ.
• Vrfy(mVK, pkχ) takes as input the master veriﬁcation
key and a public key pkχ, and outputs 1 if and only
if pkχ is a valid public key.
• Enc(pkχ, (cid:126)x) takes as input a public key pkχ, and a vec-
is a series of

(cid:18) x1,0

tor (cid:126)x, where (cid:126)x =

(cid:19)

··· xm,0
··· xm,1

x1,1

2m messages. The function outputs an encryption c.
For simplicity, we assume that each xi,b is of length n
(this suﬃces for our use).
• Dec(skχ, c) takes as input a secret key skχ and a ci-
phertext c, and outputs a set of m plaintexts based
on χ.
• Unlink(pkχ, skχ) takes as input a public key pkχ and its
associated private key skχ, and outputs a new keypair
(pk(cid:48)
• Project(pkχ, skχ, S) takes as input a public key pkχ, its
associated secret key skχ, and a set S ⊆ {0, 1}m which
deﬁnes χ(cid:48)
by specifying which attributes of χ are to be
preserved. Project outputs a keypair (pk(cid:48)
χ(cid:48) ) on
the projected attribute vector χ(cid:48)

χ) for the same χ.

χ(cid:48) , sk(cid:48)

χ, sk(cid:48)

.

We require the following properties on the algorithms:

• (Correctness) For every (PP, mVK, mSK) ← Setup(1n, m),

χ ∈ {0, 1}m, (pkχ, skχ) ← GenCert(mSK, χ), and (cid:126)x, it
holds that Dec (skχ, Enc(pkχ, (cid:126)x)) = (x1,χ1 , . . . , xm,χm ).
• For every (pkχ, skχ), the output of Unlink(pkχ, skχ) is
• For every (PP, mVK, mSK) ← Setup(1n, m), χ ∈ {0, 1}m,

distributed identically to the output of GenCert.
and (pkχ, skχ) ← GenCert(mSK, χ), it holds that Vrfy(mVK,
pkχ) = 1.

• The algorithm Enc is a committing encryption scheme.
Finally, we require the existence of the following two algo-
rithms, which are used in our security deﬁnitions:

• GenCert∗

(mSK) takes as input the master secret key
and outputs a certiﬁed keypair (pk, sk) associated with
both the 0 and 1 value of each attribute.
GenCert∗
of 2m plaintexts.

(sk, c) takes as input a secret key sk generated by
and a ciphertext c, and outputs the full set

• Dec∗

We call an ASE scheme projectable if:

• For every (PP, mVK, mSK) ← Setup(1n, m), χ ∈ {0, 1}m,
(pkχ, skχ) ← GenCert(mSK, χ), S ⊆ {0, 1}m, the out-
put of Project(pkχ, skχ, S) is distributed according to
GenCert(mSK, χ(cid:48)
• Correctness holds for every projected attribute vector.

derived according to S.

) for χ(cid:48)

Having deﬁned the syntax, we now deﬁne security. We
deﬁne this via experiments between a challenger C and an
adversary Adv for an ASE scheme π.

Collusion resistance. Our collusion resistance experiment
guarantees that players can only obtain decryptions autho-
rized by their attribute vectors. The adversary Adv is given
oracle access to GenCert in order to model Adv corrupting
multiple parties and learning their attribute vectors. Even-
tually, Adv sends a public key to C, who responds with a
random plaintext (cid:126)x encrypted under this public key. The
adversary Adv responds with a set of potential plaintext mes-
sages. If some subset of this set corresponds to an attribute
vector (or any of its projections) that were not queried by
Adv to GenCert, then Adv wins.

The reason we need to deﬁne collusion resistance in this
way is that when proving security of our ABKE scheme,
we extract the plaintext through the adversary’s calls to
the random oracle. Namely, the plaintext messages xi,b are
input into the random oracle by the adversary. However,
the adversary is not limited to just inputting the proper
messages to the random oracle, and thus we need to consider
the set of all queries to the random oracle, a subset of these
which may contain the extracted plaintext.

Note that it is easy for the challenger to check whether
such a subset exists as follows. It checks whether each mes-
sage in M is a valid plaintext message xi,b. Given this set of
valid plaintext messages, the challenger can extract an at-
tribute vector (based on the (i, b) values) and check whether
such an attribute vector is unauthorized as per the deﬁni-
tion.
Experiment Exptcollude

π,Adv (1n, m):

1. C computes (PP, mVK, mSK) ← Setup(1n, m) and sends
PP and mVK to Adv.
2. Adv, with oracle access to GenCert(mSK,·), outputs a
public key pk. Let X be the set of attribute vectors
Adv used as input to its oracle.
3. C chooses a random plaintext (cid:126)x, as speciﬁed by the
4. Adv outputs a set M of potential plaintext messages.
5. The output of the experiment is 1 (and Adv wins) if

ASE syntax, and sends Enc(pk, (cid:126)x) to Adv.

and only if the following conditions all hold:

(a) Vrfy(mVK, pk) = 1;
(b) There exists some subset M(cid:48) ⊆ M such that ei-

ther (1) the strings in M(cid:48)
for some attribute vector χ, or (2) there exist two
strings s, s(cid:48) ∈ M(cid:48)
= xi,1
for some i ∈ [m].
(c) χ /∈ X , and χ is not a projection of any vector
from X .

such that s = xi,0 and s(cid:48)

correspond to {xi,χ[i]}i∈[m]

Note that Adv does not have oracle access to GenCert after
Step 3. This models the fact that Fabke assumes a static
setup after which the clients and their attributes are ﬁxed.

Attribute privacy. We now consider an adversary who
aims to infer χ from pkχ. This follows a standard indistin-

1456guishability-based formulation. At a high level, the adver-
sary is trying to distinguish a public key generated for some
attribute vector χ with an “all-powerful” public key gener-
ated by GenCert∗
. Note that the inability to distinguish
these two settings implies the inability to distinguish be-
tween any two attribute vectors by a simple hybrid argu-
ment.
Experiment Exptatt-priv

(1n, m):

π,Adv

1. C computes (PP, mVK, mSK) ← Setup(1n, m) and sends
2. Adv, with oracle access to GenCert(mSK,·), sends at-
3. C chooses b ∈R {0, 1}, and proceeds as follows:

PP and mVK to Adv.
tribute vector χ ∈ {0, 1}m to C.

• If b = 0, compute (pk, sk) ← GenCert(mSK, χ)
• If b = 1, compute (pk, sk) ← GenCert∗

and send pk to Adv.

(mSK) and

send pk to Adv.
4. Adv outputs a bit b(cid:48)
5. The output of the experiment is 1 (and Adv wins) if

.

and only if b(cid:48)

= b.

Unlinkability. Finally, we deﬁne an experiment to formal-
ize the property of unlinkability. The deﬁnition is relatively
weak in that we only need to prevent an adversary from de-
termining whether a keypair has been run through Unlink
or not. However, this is suﬃcient for our purposes. In par-
ticular, unlinkability of keys used in our ABKE protocols
will hold due to the conjunction of the guarantees of both
attribute privacy and unlinkability.

Experiment Exptlink

π,Adv(1n, m):

1. C computes (PP, mVK, mSK) ← Setup(1n, m) and sends
2. Adv with oracle access to GenCert(mSK,·) eventually
3. C computes (pk0, sk0) ← GenCert(mSK, χ) and (pk1, sk1) ←

PP and mVK to Adv.
sends χ to C.
Unlink(pk0, sk0). C chooses b ∈R {0, 1} and sends
(pkb, skb) to Adv.

4. Adv outputs b(cid:48)
5. The output of the experiment is 1 (and Adv wins) if
and only if b(cid:48)

= b.

.

Note that we cannot simply set Unlink to the identity func-
tion as we need the output distribution of Unlink to be the
same as that of GenCert, as required in Deﬁnition 5.1.

Security deﬁnition. We are now ready to deﬁne security.

Definition 5.2. A (projectable) attribute selective en-
cryption scheme π with attribute privacy, collusion resis-
tance, and unlinkability is secure if for every probabilistic-
polynomial time adversary Adv there exists a negligible func-
tion µ such that for every n and every Y ∈ {att-priv, link}
it holds that

(cid:104)

(cid:104)

Pr

ExptY

π,Adv(1n, m) = 1

and

Pr

Exptcollude

π,Adv (1n, m) = 1

(cid:105) ≤ 1
(cid:105) ≤ µ(n).

2

+ µ(n)

ASE Instantiations. We present two schemes realizing
Deﬁnition 5.2 in §8 and §9.

6. ABKE FROM ASE

We now construct ABKE for public policies by integrating
ASE with garbled circuit-based zero-knowledge proofs [34]
and key agreement. Jawurek et al. [34] observed that for
zero-knowledge proofs, the veriﬁer-constructed circuit may
be opened to the prover post-evaluation since it has no pri-
vate data. Carefully arranging the prover’s and veriﬁer’s
commitments and openings, they ensure that neither can
cheat, and only a single garbled circuit needs to be garbled,
sent, and evaluated. Speciﬁcally, their protocol proceeds
by the server using a sender-committing oblivious transfer
(OT) to transfer the input-wire labels to the client. Given
the garbled circuit and input-wire labels, the client can eval-
uate the garbled circuit and commit the output-wire label
to the server. Now, the server can decommit to its inputs
of the OT, allowing the client to verify that the garbled cir-
cuit was constructed correctly. If so, the client can open the
commitment to its output and the server can verify that the
client indeed computed the correct output-wire label.
We adapt this protocol to realize Fabke by replacing sender-
committing OT with ASE. That is, instead of the parties
running the OT step in Jawurek et al.’s protocol, the client
sends its (randomized) ASE public key to the server, who
encrypts each input-wire label of the garbled circuit with
ASE, guaranteeing that the client is only able to decrypt
labels corresponding to its attribute vector. Next, the client
evaluates the garbled circuit and commits to the output-
wire label it computed. The server can then open all the
encrypted values, allowing the client to verify the circuit
was correctly garbled (before the client reveals anything). If
the circuit is correct, the client decommits the output-wire
label it computed, allowing the server to verify that indeed
the client satisﬁed the policy. The parties then run a secure
coin-tossing protocol to derive the shared key. See Figure 6.1
for the full protocol description.

Garbling scheme for ABKE. For us to successfully re-
duce to the collusion experiment in our ASE deﬁnition, we
need to extract the plaintext from a malicious client to feed
to the challenger in the experiment. This plaintext corre-
sponds to the input-wire labels of the garbled circuit. Thus,
we need some way to do this extraction. We do this by using
a random oracle: we can monitor the inputs to the random
oracle and use these as “potential” plaintexts which we can
feed to the challenger in the collusion experiment. Thus, we
construct a simple modiﬁed garbling scheme which allows us
to do this extraction.
ABKE garbling scheme GABKE = (GbABKE, EvABKE, VeABKE)
for a circuit C with m inputs.

GbABKE is deﬁned as follows.
1. Generate 2m random labels X b

i ∈R {0, 1}n, where X 0
i
i correspond to input wire i. The set of all
form the input-wire labels to be encrypted. Let

and X 1
X b
i := RO(i(cid:107)b(cid:107)X b
i
hb

i ), where RO is a random oracle.

2. Using any secure garbling scheme Gb, generate the gar-

bled circuit, including the 2m input-wire labels W b
i .

3. Append to the generated garbled circuit the follow-
for wire i, append

ing input-wire translation tables:

(cid:32)

(cid:33)

(W 0
i )
(W 1
i )

i

Ench0
Ench1
set {X b
Gb.

. Set the input-wire labels to be the
i } and the output-wire labels to be those set by

i

1457The protocol Πabke is between server S and client P with attribute vector χ. We assume a setup where each client Pi sends
(generate, sid, S, χi) for some set S ⊆ [m] and attribute vector χi to Fsetup, receiving (result, sid, mVK, pk, sk) in response. We
assume all messages are sent/received through the Fanon functionality; for simplicity we omit the use of this functionality in
the description below. Also for simplicity, we assume the evaluated policy C uses all m attributes (otherwise, a corresponding
Project operation can be applied to the party’s key).

1. S broadcasts policy circuit C to all parties. If C is not a valid policy then P outputs ⊥.
j }j∈[m], {Z0, Z1}) ← GbABKE(1n, C).
2. S runs (GC, {X 0
3. P computes (pk(cid:48), sk(cid:48)) ← Unlink(pk, sk) and sends pk(cid:48) to S.
4. S runs Vrfy(mVK, pk(cid:48)).

If the output is zero then S aborts; otherwise, S sets (cid:126)x = {X 0

j , X 1

Enc(pk(cid:48), (cid:126)x) and sends c and GC to P.

5. P computes (cid:126)m ← Dec(sk(cid:48), c), where (cid:126)m = (cid:98)X

if EvABKE fails.

0 , . . . , (cid:98)X

χ0
j

m and computes Z ← EvABKE(GC, {(cid:98)X

χm
j

χi
j

i }i∈[m]); P sets Z := ⊥

j , X 1

j }j∈[m], computes c ←

6. P sends (commit, sid, 1, Z) to Fcom, which sends (committed, sid, 1, |Z|) to S.
7. S sends the wire labels {X b

i } and the randomness r used in the encryption to P, who veriﬁes that the encryptions match
the wire labels and then computes VeABKE(C, GC, {X 0
i }i∈[m]). If either the wire labels did not match the encrypted
values or the output of VeABKE is reject then P outputs ⊥. Likewise, if C(χj ) = 0 then P outputs ⊥. Otherwise, P
sends (reveal, sid, 1) to Fcom, which sends (reveal, sid, 1, Z) to S.
8. S checks that Z = Z1; if not, it sends ⊥ to P and halts. Otherwise, the parties both send (toss, sid) to Fcointoss, receive

i , X 1

(tossed, sid, k), and output k.

Figure 6.1: Protocol Πabke realizing Fabke in the (Fcom, Fcointoss, Fanon)-hybrid model.

The EvABKE and VeABKE functions are deﬁned naturally
from Ev, Ve, and GbABKE.

Clearly, the scheme allows evaluation and veriﬁcation in
the same manner as the underlying garbling scheme once a
label per each wire is obtained. At the same time, any party
evaluating a garbled circuit must make a call to the random
oracle per input-wire label in order to learn the “real” un-
derlying label for the garbled circuit. Thus, the underlying
garbling scheme Gb cannot be decrypted without a random
oracle evaluation on an input-wire label of GbABKE, which is
exactly the property we need for the reduction to the collu-
sion experiment.

We prove the following in the full version [35].

Theorem 6.1. Assume that the encryption scheme used
in Πabke is a secure attribute selective encryption scheme.
Then Πabke securely computes Fabke in the (Fcom,Fcointoss,Fanon)-
hybrid model, in the random-oracle model.

7. ELH SIGNATURES

We introduce the notion of extractable linearly homomor-
phic (ELH) signatures and show an implementation using
the Boneh-Lynn-Shacham (BLS) [16] signature scheme. ELH
signatures play a central role in our ASE constructions de-
tailed in §8 and §9.

Definition 7.1. (Linearly homomorphic signatures) Let
Sig = (Sign, Vrfy) be a signature scheme over a space of
messages consisting of elements of a group G of prime or-
der q, with signatures also lying in this group. We say that
Sig is linearly homomorphic over G if for any two elements
g1, g2 ∈ G, it holds that Sign(g1g2) = Sign(g1)Sign(g2). The
scheme is called unforgeable if no probabilistic polynomial-
time algorithm given n pairs (gi, Sign(gi)) for random ele-
ments g1, . . . , gn ∈ G and an additional random indepen-
dent element g ∈ G, has non-negligible probability to output
Sign(g).

1 ··· gxn

Note that being linearly homomorphic implies that given
n signed elements g1, . . . , gn ∈ G, one can compute (without
the signing key) the signature of any linear combination (in
the exponent) of g1, . . . , gn; namely, for any x1, . . . , xn ∈ Zq
n ) = Sign(g1)x1 ··· Sign(gn)xn .
we have that Sign(gx1
We note that the requirement of the signatures lying in the
same group as the message space is not essential but it sim-
pliﬁes notation by using the same group operation for group
elements and signatures, and is a property of our implemen-
tation using BLS signatures. This notion can be seen as
a one-dimensional case of homomorphic signatures for lin-
ear spaces [14, 27, 15]. Also note that the unforgeability
property holds only with respect to random messages (i.e.,
random elements in the group).

We now deﬁne the property of extractability. It captures
the intuition behind linearly homomorphic signatures as al-
lowing limited malleability. That is, anyone can generate
signatures on a value g without possessing the signing key
as long as it knows a representation of g as a linear com-
bination (in the exponent) of previously signed elements.
Extractability formalizes this knowledge similarly to exist-
ing knowledge extractability notions. In spite of being intu-
itively appealing we are not aware of this form of homomor-
phic signatures being deﬁned in prior work.

Definition 7.2. (Extractable linearly homomorphic sig-
natures) Let G be a cyclic group of prime order q and Sig =
(Sign, Vrfy) a linearly homomorphic signature scheme over
G. Consider algorithms that on input t random elements
g1, . . . , gt in G and corresponding signatures Sign(g1), . . . ,
Sign(gt), output a pair (f, Sign(f )) for f ∈ G with non-
negligible probability (over the choice of gis and the algo-
rithm’s random coins). We say that Sig is an extractable
linearly homomorphic (ELH) signature scheme if for every
polynomial-time algorithm F as above there exists another
polynomial-time algorithm F (cid:48) for which the following prop-
erty holds, except for with negligible probability: Let {gi,
Sign(gi)}i∈[t] be an input to F on which F outputs (f, Sign(f )),
then on the same inputs (and internal random coins) F (cid:48) out-

1458puts a vector (f, Sign(f ), x1, . . . , xn) with xi ∈ Zq such that
f = gx1

1 ··· gxn
n .

Interestingly, extractability in linearly homomorphic sig-
natures implies unforgeability as shown next (the proofs ap-
pear in the full version [35]).

Lemma 7.3. Let Sig = (Sign, Vrfy) be an ELH signature
scheme over a group G where the discrete logarithm problem
is hard. Then Sig is unforgeable.

Lemma 7.4. Under the hardness of the discrete log over
group G, given g1, . . . gn, g ∈R G\{1}, it is infeasible to ﬁnd
x1, . . . , xn ∈ Zq such that g = gx1
1 ··· gxn
n . Similarly, ﬁnding
i=1gyi
two representations Πn
i = Πn
such that there exists
an i for which xi (cid:54)= yi is also infeasible.
7.1 Implementation of ELH Signatures

i=1gxi

i

We now demonstrate an implementation of an ELH sig-
nature scheme using the Boneh-Lynn-Shacham (BLS) [16]
signature scheme, which we ﬁrst recall.

Boneh-Lynn-Shacham (BLS) signature scheme. The
scheme assumes groups (G1, G2, GT ) of prime order q with
a bilinear pairing e : G1 × G2 → GT where the co-CDH
assumption holds (i.e., given g ∈ G1, h, hx ∈ G2, ﬁnding gx
is infeasible). The public/private keypair is (hx, x), where
x ∈R Zq, and h ∈R G2. A signature on message m is com-
puted as H(m)x where H is a hash function mapping mes-
sages to random elements in G1. Veriﬁcation of a signa-
ture σ on message m under public key y = hx is performed
by checking the following equality: e(σ, h) = e(H(m), y).
BLS∗ signature scheme. We deﬁne the BLS∗ scheme to
be the same as BLS but the message space is the group G1
itself and no hash function is applied to the messages (this
is suﬃcient for our application that only requires unforge-
ability on random group elements).

The following lemma shows that BLS∗

leads to an im-
plementation of ELH signatures under the t-KEA assump-
tion [11, 10]. The proof appears in the full version [35].

Lemma 7.5. Under the t-KEA assumption over group G1,
BLS∗ is an unforgeable extractable linearly homomorphic
signature scheme.

8. ASE USING IBE

We now construct an attribute selective encryption scheme
from identity based encryption (IBE) and extractable lin-
early homomorphic (ELH) signatures. The security of the
protocol is based on the security of the underlying IBE and
ELH signature schemes.
In addition, we require that the
master public key of the IBE scheme be from a group so
that it can be rerandomized and that the ELH signature
scheme works over the same group.

We note that ASE can be constructed from IBE in a
generic way if it satisﬁes these additional requirements. Both
the Boneh-Franklin [13] and Boneh-Boyen [12] IBE schemes
can be used and they yield diﬀerent eﬃciency and compu-
tational requirements from the parties. However, this pre-
sentation will not be generic but rather at points we will be
speciﬁc to the Boneh-Franklin IBE scheme.

We ﬁrst give a high level overview of how we use the IBE
scheme in our construction. Recall that in an IBE scheme a
central authority chooses a master secret key and publishes

the correlated master public key. The master public key
is used as part of the encryption key for all clients. Each
client has an identity which is known to all and in addition
each client receives a private secret key that is computed
using the master secret key and its identity. A message is
encrypted using the master public key and the identity of
the client for whom the message is intended. The client uses
its secret key to decrypt.

The ﬁrst switch that we make in our scheme is that the
“identities” are associated with the attributes. Thus, if a
client has an attribute then it receives the secret key relat-
ing to that attribute. However, that clearly is not suﬃcient
as collusions can take place. A client receiving the secret
key for attribute j1 can collude with another client who has
the secret key for j2, enabling them to decrypt an unautho-
rized set of messages. Thus, we introduce our second switch
which is that the center creates a “personalized” public mas-
ter key for each client (by choosing a diﬀerent master secret
key) and modiﬁes the secret keys of the client to relate to
the personalized public key. Now this additional change pre-
vents the clients from colluding as their secret keys relate to
diﬀerent master public keys. While this is the basic intu-
ition, there are additional details that need to be added to
satisfy all the requirements, which we describe below.

To present our scheme, we ﬁrst recall the general construc-
tion of IBE and deﬁne its terminology. An IBE scheme is
comprised of four parts: setup, key generation, encryption,
and decryption.

• SetupIBE(1n): Takes as input the security parameter.
We split the setup into two parts: Part 1 outputs the
public parameters PPIBE, and Part 2 outputs the mas-
ter public key mpkIBE and the master secret key mskIBE.
The public parameters are common to all key pairs,
and are implicitly given to all algorithms below.
• KeyGenIBE(mskIBE, ID): Takes as input the master se-
cret key and the identity ID of the client, and outputs
the client’s secret key skIBE.
• EncIBE(mpkIBE, m, ID): Takes as input the master pub-
lic key, the plaintext message m, and the identity of a
client, and outputs the ciphertext c.
• DecIBE(c, skIBE): Takes as input the ciphertext and the

client’s secret key and outputs the message.

Due to lack of space, we assume familiarity with the deﬁ-
nition of IBE. Here we informally state that encrypting with
IBE is a secure encryption.

We are now ready to present our construction. Our IBE-

ASE scheme is deﬁned as follows.

• Setup(1n, m):

1. Run Part 1 of SetupIBE, receiving PPIBE.
2. Choose 2m random strings, gj,0, gj,1, for j ∈ [m],
where gj,0 corresponds to not having attribute j,
and gj,1 corresponds to having the attribute. These
will be the “identities” of the system.

3. Run a key generation protocol for an ELH sig-
nature scheme, receiving and setting mVK to the
public veriﬁcation key and mSK to the secret sign-
ing key.
4. Output PP := (PPIBE,{gj,0, gj,1}j∈[m]), mVK, and

mSK.

• GenCert(mSK, χ):

14591. Run Part 2 of SetupIBE, creating mskIBE and mpkIBE.
Set pkχ := (mpkIBE, σ = Sign(mpkIBE)). In what
follows we sometimes abuse notation and refer to
pkχ only as the public key and sometimes as both
the public key and its signature.
2. For each attribute j ∈ [m], call KeyGenIBE on in-
put mskIBE and identity gj,χ[j]. This returns a
secret key skj.

3. Set the client’s secret key to skχ := (sk1, . . . , skm).

Note that now we can discard the master secret key
mskIBE. We use the signature to compensate for the
fact that mpkIBE is not one of the public parameters of
the system.
• Vrfy(mVK, pkχ): Output a bit attesting to the validity
• Enc(pkχ,{xj,0, xj,1}j∈[m]):

of the public key pkχ by checking the signature σ.

1. Verify that Vrfy(mVK, pkχ) = 1. If not then abort.
2. For j ∈ [m], compute cj,0 ← EncIBE(pkχ, xj,0, gj0)

and cj,1 ← EncIBE(pkχ, xj,1, gj1).

3. Output c := c1,0, c1,1, . . . , cm,0, cm,1.

• Dec(skχ, c): Output xj := DecIBE(cj,χ[j], skχ[j]) for all
• Unlink(pkχ, skχ): In our implementation using the Boneh-

j ∈ [m].

Franklin IBE scheme, the public key pkχ has the form
gz for some value z. We implement the unlink opera-
tion by raising pkχ to a random exponent s. All other
values are also raised to s, including the ELH signature
and every component of the secret key.
• Project(pkχ, skχ, S): The project function in the IBE
case is trivial; all that needs to be done is to remove
from the secret key the elements whose index is not in
the set S. The public key remains the same.
(mSK): Exactly as in GenCert, except now the
secret key sk contains secret keys skj,b for all j ∈ [m]
and b ∈ {0, 1}.
This can be trivially achieved in two manners: ﬁrst,
by giving additional secret keys exactly in the format
as given in GenCert or even simpler by just giving x to
the client.

• GenCert∗

(sk, c): Same as Dec, except here the full set of 2m
plaintexts are returned. This is completely straightfor-
ward, as the secret key now includes decryption keys
for all messages.

• Dec∗

The proof of the following theorem is presented in the full
version [35].

Theorem 8.1. The above scheme is a secure ASE scheme
when instantiated with the Boneh-Franklin IBE and an ELH
signature scheme. The ELH signature scheme needs to work
over the same group G, as deﬁned in Boneh-Franklin.

9. ASE USING ELH SIGNATURES
We present an instantiation of an attribute-selective en-
cryption (ASE) scheme (cf. §5) based on extractable linearly
homomorphic (ELH) signatures (cf. §7). The key generation
and certiﬁcation mechanism uses the homomorphic prop-
erty of the signatures while their extractability properties
are used to prove security.

The ELH-ASE scheme is deﬁned as follows.
• Setup(1n, m): Let Sig = (Sign, Vrfy) be an ELH sig-
nature scheme over a group G of order q. Setup uses

Sig to sign several elements in each client’s public key
(deﬁned below). Each element type (g, h, u) has a ded-
icated signature key and there is also a per-attribute
signature key to sign elements of the form uej. For
readability, we denote the above four types of signa-
tures by Signg, Signh, Signu and Signj for j ∈ [m].
The set of public veriﬁcation keys for the above sig-
natures form the master veriﬁcation key mVK and the
corresponding secret signing keys form the master se-
cret key mSK.
We refer to the party running the Setup function as
the CA.
• GenCert(mSK, χ): A public key pkχ associated with
an attribute vector χ = (χ1, . . . χm) is generated as
follows:

compute signatures Signg(g), Signh(h), and Signu(u).

1. Choose random elements g, h, u ∈ G \ {1} and
2. Choose r1, . . . , rm ∈R Z∗
if
χ[j] = 0 and ej = hrj if χ[j] = 1; compute signa-
tures Signj(uej) for j ∈ [m].

q and set ej = grj

Set the public key pkχ to (g, h, u,{ej}j∈[m], Signg(g),
Signh(h), Signu(u),{Signj(uej)}j∈[m]) and the secret key
skχ to {rj}j∈[m].
• Vrfy(mVK, pkχ): Check that g, h, u ∈ G \ {1} and use
• Enc(pkχ,{xj,0, xj,1}j∈[m]): For j ∈ [m], choose sj, tj ∈R

mVK to check all signatures.

Zq and set cj,0 :=(cid:0)gsj , esj

(cid:1) and cj,1 :=

htj , etj

· xj,0

(cid:16)

j · xj,1

j

The ciphertext is the sequence {(cj,0, cj,1)}j∈[m].
(Note: We assume for simplicity that the random val-
ues xj,b, that correspond to input wire labels X b
j in
protocol Πabke of Fig. 6.1 are random elements in G
(these values are later hashed into strings hb
j as part
of the garbling scheme GABKE).)
• Dec(skχ,{(cj,0, cj,1)}j∈[m]): For j ∈ [m], set (C1, C2)
• Unlink(pkχ, skχ): Choose a random value r ∈ Zq and

to the pair cj,χj and compute xj,χj := C2/C1

rj .

raise every element of pk to the power of r; output:
j}j∈[m], (Signg(g))r, (Signh(h))r,

χ := (gr, hr, ur,{er
(cid:48)

pk

(Signu(u))r,{(Signj(uej))r}j∈[m])

(cid:17)

.

• GenCert∗

χ := {r · rj}j∈[m].

and sk(cid:48)
• Project(pkχ, skχ, S): Output a new public key by omit-
ting any component ej for j /∈ S, and set the corre-
sponding secret key to {rj}j∈S.

(mSK): Generation of the pair (pkχ, skχ) is
the same as for GenCert except that h is set to gτ for
known τ ∈R Zq and ej is set to grj for all j ∈ [m] (as
in the case χ = 0m). The secret key sk is comprised of
the set {rj}j∈[m] and the value τ . This enables Dec∗
as follows.
(sk,{cj,0, cj,1}j∈[m]): For j ∈ [m], set (C1, C2)
rj . Then,
to the pair cj,0 and compute xj,0 := C2/C1
for j ∈ [m], set (C1, C2) to the pair cj,1 and compute
xj,1 := C2/C1

τ·rj .

• Dec∗

The proof of the following theorem is presented in the full
version [35].

Theorem 9.1. If Sig is an extractable linearly homomor-
phic signature scheme over a DDH group G then under the
DDH and KEA assumptions over G, the ELH-ASE scheme

1460has the properties of collusion resistance, attribute privacy,
unlinkability, projectability and committing encryption.

10. PERFORMANCE

As the bottleneck in terms of computation is the pairings
and exponentiations (versus garbling and evaluating the pol-
icy), we now give a concrete count of the number of pair-
ings and exponentiations required for each of the two ASE
schemes presented in §8 and §9.

• IBE-based scheme (§8). For concreteness we calculate

the cost using the Boneh-Franklin IBE scheme [13].

– The client computes two exponentiations to ran-
domize both its “master public key” and its asso-
ciated signature.

– The server computes two pairings to verify the
signature of the client’s “master public key”. To
encrypt 2m messages, the server computes 2m
pairings and 2m exponentiations.

– The client computes m pairings and exponentia-

tions to decrypt m messages.
• ELH signature-based scheme (§9).

– The client computes a total of 6 + 2m exponenti-
ations to randomize both the basis and its associ-
ated signature (6) and the public keys and their
associated signatures (2m). These operations can
all be done oﬄine.

– The server computes 3+m signature veriﬁcations,
which requires 6 + 2m pairings (this can be sped
up by batch veriﬁcation of signatures; see below).
To encrypt the 2m messages it computes 4m ex-
ponentiations.

– The client computes m exponentiations to de-

crypt m messages.

We note several important points regarding the perfor-
mance of the ELH signature-based scheme. First, the scheme
requires the client to only compute exponentiations as op-
posed to pairings. This could be meaningful in a setting
where the client is a small computing device. Second, the
server can batch multiple signature veriﬁcations from dif-
ferent clients. The CA’s signature keys for g, h, u and the
attributes are the same for all clients. Using techniques of
Ferrara et al. [24] for batching pairing-based signatures can
help us achieve better amortized run-times.

Implementation and results. We implemented the scheme
described in Figure 6.1 using the ELH signature-based ASE
scheme (cf. §9) utilizing all the optimizations mentioned
above. We instantiate the coin-tossing and commitment
functionalities using SHA-1, and use the privacy-free gar-
bling technique of Zahur et al. [39]. The code as well as
all the scripts for generating our experimental results are
available at https://github.com/amaloz/abke.

All experiments were conducted on an Intel Core i5-4210H
CPU running at 2.90 GHz, and we use the RELIC library [6]
for pairings, using the optimal ate pairing on the BN-P256
curve. On our benchmark machine, pairings take roughly
1.88 ms and exponentiations in G1 take roughly 160 µs
(76 µs when using preprocessing). All experiments were
run over localhost; however, to emulate a WAN environ-
ment we used the tc command in Linux to set the latency

Figure 10.1: Computation time of the server and client for
various numbers of attributes and sizes of the policy. The bottom
x-axis gives the number of gates in the policy, the top x-axis gives
the number of attributes, and the y-axis gives the computation
time in seconds.

Figure 10.2: Communication time of the server and client for
various numbers of attributes and sizes of the policy circuit. The
bottom x-axis gives the number of gates in the policy, the top
x-axis gives the number of attributes, the left y-axis gives the
computation time (in seconds), and the right y-axis gives the
number of bits sent (in Mb).

Figure 10.3: Optimized computation time (i.e., pushing the
cost of randomizing the public key and garbling the policy to an
oﬄine stage, along with batching of the key veriﬁcation) of the
server and client for various numbers of attributes and sizes of the
policy. The bottom x-axis gives the number of gates in the policy,
the top x-axis gives the number of attributes, and the y-axis gives
the computation time in seconds.

to 33 ms (the average latency in the United States [2]) and
the bandwidth to 200 Mbps. For each measurement, we ran
10 iterations of 10 runs, taking the mean of the medians
from each run.

Figures 10.1 and 10.2 show the results of our experiments.
We varied the number of attributes m between 10, 50, and
200, and varied the size of the policy (comprised of only AND
gates) between 1,000, 10,000, and 100,000. Figure 10.1 de-
picts the computation time of the server and client, whereas
Figure 10.2 depicts the communication time. We also list the
number of bits sent by the server and client in Figure 10.2.

103104105103104105103104105NumberofANDGates0.00.20.40.60.81.0ComputationTime(s)ServerTimeClientTime1050200NumberofAttributes103104105103104105103104105NumberofANDGates0.00.51.01.52.02.5CommunicationTime(s)ServerTimeClientTime1050200NumberofAttributes0102030405060DataSent(Mb)DataSent103104105103104105103104105NumberofANDGates0.000.050.100.150.200.25ComputationTime(s)ServerTimeClientTime1050200NumberofAttributes1461Step

S

S [opt]

P P [opt]

159 ms
82 ms

2 (Gb)
—
—
—
3 (Unlink)
—
— 78 ms
4 (Vrfy)
—
—
4 (Enc)
—
—
5 (Dec)
28 ms
— 28 ms
5 (Ev)
—
3 ms
3 ms
6 (commit)
— <1 ms <1 ms
7 (Enc)
42 ms
— 42 ms
7 (Ve)
—
8 ms
8 ms
8 (cointoss) <1 ms <1 ms <1 ms <1 ms

5 ms
—
857 ms
82 ms
—
—
—
—
—

Total

944 ms

241 ms

159 ms

81 ms

Table 10.1: Breakdown of server (S) and client (P) computation
times for the various steps of Πabke for a 100,000 gate policy with
200 attributes.
[opt] denotes the optimized computation time
(i.e., pushing computation to an oﬄine stage and batching veri-
ﬁcation). See Figure 6.1 for a description of each step. The total
cost is slightly less than that reported elsewhere due to rounding
errors and not accounting for initialize/cleanup steps.

As we can see, the computation time is fairly consistent for a
ﬁxed m, but grows as m increases. This validates our claim
that the pairings and exponentiations account for most of
the overhead as opposed to the garbling and evaluating of
the policy. The computation time varies from 67 ms for the
server and 11 ms for the client for a 1,000 gate policy with
10 attributes, to 957 ms for the server and 176 ms for the
client for a 100,000 gate policy with 200 attributes.

Looking at the case of a 100,000 gate policy with 200
attributes (see also Table 10.1), we see that most of the
overhead on the server side comes from verifying the pub-
lic key sent by the client (857 ms), due to the 2m pairings
needed. The next largest operation is encryption, which ac-
counts for 82 ms. Meanwhile, garbling the policy takes only
5 ms. Regarding the client, the costliest operation is check-
ing that the encryption sent by the server is correct, which
requires re-encrypting the m unopened wire-labels (42 ms),
followed by randomizing its public key (78 ms). Decryption
is relatively cheap, requiring 28 ms. Meanwhile, evaluating
the garbled circuit takes 3 ms, again demonstrating that the
garbled circuit is not the bottleneck (at least with regards
to computation).

Looking at the communication time (cf. Figure 10.2), we
see that as both the number of attributes and number of
gates grows so does the running time. We stress that this
growth impacts previous ABE formula-based solutions to
a much greater degree. Importantly, for all but extremely
large policies of millions of gates, communication will typi-
cally not be a bottleneck of our system. Most of the server’s
communication time is spent sending the garbled circuit,
whereas most of the client’s time is spent receiving the gar-
bled circuit and the ciphertext, this latter case due to the
client blocking while the server veriﬁes the (randomized)
public key. We note that our network bandwidth of 200 Mbps
is pessimistic, and running our protocol on Amazon EC2 or
other networks with 1 Gbps bandwidth will all but elimi-
nate the communication overhead of sending/receiving the
garbled circuit (e.g., when running over localhost, the com-
munication time is essentially the time spent blocking wait-
ing for the other party to complete some computation).

Note that with regards to computation, most of the ex-

Operation
BLS∗
BLS∗

sign
verify

BLS∗

batch verify

Cycles

522,767

12,316,919
22,635,625

Table 10.2: Benchmarking BLS∗ signing and veriﬁcation, along
with the batch veriﬁcation approach of Ferrara et al. [24] for ten
messages.

pensive operations (such as randomizing and verifying the
public key) can be either done oﬄine or batched. Thus,
we also calculated an optimized computation time; see Fig-
ure 10.3.
In these experiments, we ignore the cost of the
client randomizing its public key and the server garbling its
policy, as both of these can be done in an oﬄine stage. To
account for the batching optimization, we implemented and
benchmarked the batching techniques of Ferrara et al. [24],
see Table 10.2. We see a roughly 5.4× improvement when
batch verifying ten messages. Thus, in our experiments we
model a server operating over ten clients at a time by divid-
ing the public key veriﬁcation time by 5.4. We see upwards
of a 4.4× and 2× improvement in running time for the server
and client, respectively. This makes sense in light of the fact
that randomizing and verifying the public key are the two
most expensive operations.

A policy cost example.
In light of the above results,
we provide a rough calculation of the cost of a realistic
policy, where the client succeeds if its geolocation (xU , yU )
is within distance d of the server’s location (xS, yS). The
client’s geolocation credential may be issued with a certi-
ﬁed timestamp, which may simultaneously be checked by
a policy. Such a policy would require a circuit computing
(xU − xS)2 + (yU − yS)2<?d2 and a (much smaller) circuit
verifying that the timestamp is in an acceptable time in-
terval. Using a 64-bit input and the CBMC circuit com-
piler [33], we can compile this function as a circuit contain-
ing approximately 20,000 gates. Thus, as demonstrated by
our performance results, the cost of the corresponding gar-
bled circuit would be unnoticeable relative to the public key
operations required by the server and client.
In contrast,
an ABE-based solution would require converting the policy
circuit into a (very large) formula, and performing pairings
proportional to its size, which is not practical in most set-
tings.

Acknowledgments
This work was supported by the Oﬃce of Naval Research
(ONR) contract number N00014-14-C-0113. This work was
done in part while the authors were visiting the Simons Insti-
tute for the Theory of Computing, supported by the Simons
Foundation and by the DIMACS/Simons Collaboration in
Cryptography through NSF grant #CNS-1523467. Work of
Alex J. Malozemoﬀ conducted in part with Government sup-
port through the National Defense Science and Engineering
Graduate (NDSEG) Fellowship, 32 CFG 168a, awarded by
DoD, Air Force Oﬃce of Scientiﬁc Research.

11. REFERENCES
[1] ABC4Trust EU project. https://www.abc4trust.eu.
[2] Global IP network latency. http://ipnetwork.bgtmo.ip.

att.net/pws/network delay.html. Retrieved February
8, 2016.

1462[3] Identity mixer. http://idemix.wordpress.com.
[4] Microsoft U-Prove. http://www.microsoft.com/uprove.
[5] M. Abe and S. Fehr. Perfect NIZK with adaptive

soundness. In TCC, 2007.

[6] D. F. Aranha and C. P. L. Gouvˆea. RELIC is an

Eﬃcient LIbrary for Cryptography.
https://github.com/relic-toolkit/relic.

[7] M. Belenkiy, J. Camenisch, M. Chase, M. Kohlweiss,

A. Lysyanskaya, and H. Shacham. Randomizable
proofs and delegatable anonymous credentials. In
Crypto, 2009.

[8] M. Bellare, V. T. Hoang, and P. Rogaway.

Foundations of garbled circuits. In CCS, 2012.

[9] J. Bethencourt, A. Sahai, and B. Waters.

Ciphertext-policy attribute-based encryption. In S&P,
2007.

[10] N. Bitansky, R. Canetti, A. Chiesa, S. Goldwasser,

H. Lin, A. Rubinstein, and E. Tromer. The hunting of
the SNARK. Cryptology ePrint Archive, Report
2014/580, 2014.

[11] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer.

From extractable collision resistance to succinct
non-interactive arguments of knowledge, and back
again. In ITCS, 2012.

[12] D. Boneh and X. Boyen. Eﬃcient selective-ID secure
identity based encryption without random oracles. In
Eurocrypt, 2004.

[13] D. Boneh and M. K. Franklin. Identity-based

Pedersen. Practical short signature batch veriﬁcation.
In CT-RSA, 2009.

[25] T. K. Frederiksen, J. B. Nielsen, and C. Orlandi.
Privacy-free garbled circuits with applications to
eﬃcient zero-knowledge. In Eurocrypt, 2015.
[26] S. Garg, C. Gentry, S. Halevi, A. Sahai, and

B. Waters. Attribute-based encryption for circuits
from multilinear maps. In Crypto, 2013.

[27] R. Gennaro, J. Katz, H. Krawczyk, and T. Rabin.
Secure network coding over the integers. In PKC,
2010.

[28] M. C. Gorantla, C. Boyd, and J. M. Gonz´alez Nieto.

Attribute-based authenticated key exchange. In
ACISP, 2010.

[29] S. Gorbunov, V. Vaikuntanathan, and H. Wee.
Predicate encryption for circuits from LWE. In
Crypto, 2015.

[30] V. Goyal, O. Pandey, A. Sahai, and B. Waters.

Attribute-based encryption for ﬁne-grained access
control of encrypted data. In CCS, 2006.

[31] J. Groth. Short pairing-based non-interactive

zero-knowledge arguments. In Asiacrypt, 2010.

[32] D. Gupta and A. Sahai. On constant-round concurrent

zero-knowledge from a knowledge assumption. In
Indocrypt, 2014.

[33] A. Holzer, M. Franz, S. Katzenbeisser, and H. Veith.
Secure two-party computations in ANSI C. In CCS,
2012.

encryption from the Weil pairing. In Crypto, 2001.

[34] M. Jawurek, F. Kerschbaum, and C. Orlandi.

Zero-knowledge using garbled circuits: how to prove
non-algebraic statements eﬃciently. In CCS, 2013.

[35] V. Kolesnikov, H. Krawczyk, Y. Lindell,

A. Malozemoﬀ, and T. Rabin. Attribute-based key
exchange with general policies.
https://eprint.iacr.org/2016/518.

[36] A. Sahai and B. R. Waters. Fuzzy identity-based

encryption. In Eurocrypt, 2005.

[37] Y. Sakai, N. Attrapadung, and G. Hanaoka.

Attribute-based signatures for circuits from bilinear
map. In PKC, 2016.

[38] B. Waters. Ciphertext-policy attribute-based

encryption: An expressive, eﬃcient, and provably
secure realization. In PKC, 2011.

[39] S. Zahur, M. Rosulek, and D. Evans. Two halves make

a whole - reducing data transfer in garbled circuits
using half gates. In Eurocrypt, 2015.

[14] D. Boneh, D. Freeman, J. Katz, and B. Waters.
Signing a linear subspace: Signature schemes for
network coding. In PKC, 2009.

[15] D. Boneh and D. M. Freeman. Homomorphic

signatures for polynomial functions. In Eurocrypt,
2011.

[16] D. Boneh, B. Lynn, and H. Shacham. Short signatures

from the Weil pairing. Journal of Cryptology,
17(4):297–319, Sept. 2004.

[17] S. Brands. Rethinking Public Key Infrastructures and
Digital Certiﬁcates: Building in Privacy. MIT Press,
2000.

[18] J. Camenisch, N. Casati, T. Groß, and V. Shoup.

Credential authenticated identiﬁcation and key
exchange. In Crypto, 2010.

[19] J. Camenisch and A. Lysyanskaya. An eﬃcient system

for non-transferable anonymous credentials with
optional anonymity revocation. In Eurocrypt, 2001.

[20] J. Camenisch and A. Lysyanskaya. Signature schemes

and anonymous credentials from bilinear maps. In
Crypto, 2004.

[21] R. Canetti, A. Cohen, and Y. Lindell. A simpler

variant of universally composable security for standard
multiparty computation. In Crypto, 2015.

[22] M. Chase, C. Ganesh, and P. Mohassel. Eﬃcient

zero-knowledge proof of algebraic and non-algebraic
statements with applications to privacy preserving
credentials. In Crypto, 2016.

[23] D. Chaum. Untraceable electronic mail, return

addresses, and digital pseudonyms. Communications
of the ACM, 24(2):84–88, 1981.

[24] A. L. Ferrara, M. Green, S. Hohenberger, and M. Ø.

1463