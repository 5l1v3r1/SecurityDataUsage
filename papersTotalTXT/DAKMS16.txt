Step by Step Towards Creating a Safe Smart

Contract: Lessons and Insights from a

Cryptocurrency Lab

Kevin Delmolino1, Mitchell Arnett1, Ahmed Kosba1, Andrew Miller1,2, and

Elaine Shi2

del@terpmail.umd.edu, marnett@umd.edu, akosba@cs.umd.edu,

amiller@cs.umd.edu, elaine@cs.cornell.edu

1 Department of Computer Science
University of Maryland, College Park

2 Initiative for Cryptocurrencies and Contracts (IC3)

Department of Computer Science

Cornell University

Abstract. We document our experiences in teaching smart contract
programming to undergraduate students at the University of Maryland,
the ﬁrst pedagogical attempt of its kind. Since smart contracts deal di-
rectly with the movement of valuable currency units between contratual
parties, security of a contract program is of paramount importance.
Our lab exposed numerous common pitfalls in designing safe and se-
cure smart contracts. We document several typical classes of mistakes
students made, suggest ways to ﬁx/avoid them, and advocate best prac-
tices for programming smart contracts. Finally, our pedagogical eﬀorts
have also resulted in online open course materials for programming smart
contracts, which may be of independent interest to the community.

1

Introduction

Completely decentralized cryptocurrencies like Bitcoin [16] and other altcoins [5]
have captured the public’s attention and interest, and have been much more suc-
cessful than any prior incarnations of electronic cash. Many would call the rise
of these electronic currencies a technological revolution, and the “wave of the
future” [3]. Emerging altcoins such as Ethereum [21] and Counterparty [12] ex-
tend Bitcoin’s design by oﬀering a rich programming language for writing “smart
contracts.” Smart contracts are user-deﬁned programs that specify rules govern-
ing transactions, and that are enforced by a network of peers (assuming the
underlying cryptocurrency is secure). In comparison with traditional ﬁnancial
contracts, smart contracts carry the promise of low legal and transaction costs,
and can lower the bar of entry for users.

In Fall 2014, at the University of Maryland, we organized a new, hands-on
smart contract programming lab in our undergraduate-level security class – the
ﬁrst of its kind that has ever been attempted.

Smart contract programming: unique challenges and opportunities.
Although smart contract programming in many ways resembles traditional pro-
gramming, it raises important new security challenges. Contracts are “play-for-
keeps”, since virtual currencies have real value. If you load money into a buggy
smart contract, you will likely lose it. Further, smart contract programming
requires an “economic thinking” perspective that traditional programmers may
not have acquired. Contracts must be written to ensure fairness even when coun-
terparties may attempt to cheat in arbitrary ways that maximize their economic
gains.

As an outcome of our lab, we observed several classes of typical mistakes
students made. In contrast to traditional software development tasks where bugs
such as buﬀer overﬂows are often benign (except in rare or contrived scenarios),
in our lab, we observed several bugs and pitfalls that arise due to the unique
nature of smart contract programs and lead to clear and immediate exploits
(e.g., theft or loss of money).

Our lab experiences show that even for very simple smart contracts (e.g.,
a “Rock, Paper, Scissors” game), designing and implementing them correctly
was highly non-trivial. This suggests that extra precautions and scrutiny are
necessary when programming smart contracts.

In this paper, although we adopt Ethereum’s Serpent language, most of the
the insights we gain are not language-speciﬁc, but can be generalized to smart
contract programming under a broad model.

Open-source course and lab materials. Based on lessons and insights drawn
through this experimental lab, we have designed new, open course materials and
lab designs for smart contract programming [4]. We hope that these open-source
course materials and labs will aid both instructors who wish to teach smart
contract programming and students/developers who wish to teach themselves
smart contract programming.

Broader insights gained. Inspired by our experimental smart contract lab,
we argue why cryptocurrency and smart contracts will serve as a great pedagog-
ical platform for Cybersecurity education. We also draw from our experiences
why the “build, break, and amend your own program” approach is beneﬁcial
to instructing adversarial thinking and incentivizing a student-driven learning
atmosphere.

Roadmap. In the remainder of this paper, we will ﬁrst give more background
on cryptocurrency and smart contracts (Section 2). We will then detail experi-
ences with our lab (Section 3), the typical pitfalls we observed in smart contract
programming (Section 4), and the insights and lessons learned.

2 Background

In this section, we provide some background on cryptocurrencies and the pro-
gramming model of smart contracts.

Fig. 1. Schematic of a decentralized cryptocurrency system with smart con-
tracts. A smart contract’s state is stored on the public blockchain. A smart contract
program is executed by a network of miners who reach consensus on the outcome of
the execution, and update the contract’s state on the blockchain accordingly. Users can
send money or data to a contract; or receive money or data from a contract.

2.1 Background on Decentralized Cryptocurrencies

Smart contracts are built on top of an underlying cryptocurrency platform. A
cryptocurrency is a decentralized system for interacting with virtual money in
a shared global ledger. Users transfer money and interact with contracts by
publishing signed data called transactions to the cryptocurrency network. The
network consists of nodes (called miners) who propagate information, store data,
and update the data by applying transactions. A high-level schematic is shown
in Figure 1.

Although the ideas behind cryptocurrencies date back at least twenty-ﬁve
years (e.g., cryptographic e-cash [11]), a recent surge of interest in this technology
has been incited by the success of Bitcoin [16]. For a comprehensive survey on
Bitcoin and other cryptocurrencies, see [7, 9].

The main interface provided by the underlying cryptocurrency is an append-
only log called a blockchain, which imposes a partial or total ordering on trans-
actions submitted by users. The data in the blockchain is guaranteed to be valid
according to certain predeﬁned rules of the system (e.g., there are no double-
spends or invalid signatures). All of the data in the blockchain is public, and
every user can access a copy of it. No one can be prevented from submitting
transactions and getting them included in the blockchain (with at most some
small delay). There is global agreement among all nodes and users about the
contents of the blockchain, except for the most recent handful of blocks which
have not yet settled.

For simplicity, we also assume that the built-in currency has a stable mone-
tary value. Users therefore have an incentive to gain more of (and avoid losing)

ContractsMined BlockMinersBlock # iBlock # i+ 1Block # i+ 2TimeBlockchain……CodeStorageDataUsersMoneyunits of this currency. Anyone can acquire the virtual currency by purchasing or
trading for it using other ﬁat currencies (e.g., US dollars) or virtual currencies.
The currency is assumed to be fungible; one unit of Ether (the currency unit
of Ethereum) is exactly as valuable as any other, regardless of the currency’s
“history.”

The system keeps track of “ownership” of the currency by associating each
unit of currency to an “address”. A user address is a hash of a public key;
whoever knows the corresponding private key can spend the money associated to
that address. Users can create as many accounts as they want, and the accounts
need not be linked to their real identity.

2.2 Background on Smart Contracts

Need for general smart contracts. Bitcoin oﬀers a rudimentary scripting sys-
tem that is neither expressive nor user-friendly. A line of work in both academia
and industry has attempted to design various smart contract applications in a
way that retroﬁts Bitcoin’s scripting language [6, 8, 17, 18]. Due to fundamental
limits of the expressiveness of Bitcoin’s scripting language, retroﬁtting the lan-
guage is not only time consuming, but can also result in asymptotically more
costly implementations in terms of number of rounds or on-chain cost. In com-
parison, many of the same tasks would be easier to program and more eﬃcient,
if they were built atop a general purpose smart contract language (of which
Ethereum [21] is the ﬁrst incarnation).

Smart contract model. A contract is an instance of a computer program that
runs on the blockchain, i.e., executed by all consensus nodes. A smart contract
consists of program code, a storage ﬁle, and an account balance. Any user can
create a contract by posting a transaction to the blockchain. The program code
of a contract is ﬁxed when the contract is created, and cannot be changed.

As shown in Figure 1, a contract’s storage ﬁle is stored on the public blockchain.

A contract’s program logic is executed by the network of miners who reach con-
sensus on the outcome of the execution and update the blockchain accordingly.
The contract’s code is executed whenever it receives a message, either from a
user or from another contract. (A user can sends a message to a contract by
including the message data and the address of the contract in her transaction;
one contract can send a message to another using a special instruction in its
program code.) While executing its code, the contract may read from or write
to its storage ﬁle. A contract can also receive money into its account balance,
and send money to other contracts or users.

Conceptually, one can think of a contract as a special “trusted third party”
– however, this party is trusted only for correctness and availability but not for
privacy. In particular, a contract’s entire state is visible to the public.

Contract invocation. A contract’s code will be invoked whenever it receives a
message. A contract can deﬁne multiple entry points of execution – in Ethereum’s
Serpent language, each entry point is deﬁned as a function. A message contents

will specify the entry point at which the contract’s code will be invoked. There-
fore, messages act like function calls in ordinary programming languages. After
a contract ﬁnishes processing a message it receives, it can pass a return value
back to the sender.

Gas. Ethereum uses the concept of “gas” to discourage over-consumption of
resources (e.g., a contract program that causes miners to loop forever). The
user who creates a transaction must spend currency to purchase gas. During the
execution of a transaction, every program instruction consumes some amount
of gas. If the gas runs out before the transaction reaches an ordinary stopping
point, it is treated as an exception: the state is reverted as though the transaction
had no eﬀect, but the Ether used to purchase the gas is not refunded! When one
contract sends a message to another, the sender can oﬀer only a portion of its
available gas to the recipient. If the recipient runs out of gas, control returns to
the sender, who can use its remaining gas to handle the exception and tidy up.

Ethereum Speciﬁcs. Our lab employs Ethereum’s Serpent language to illus-
trate smart contract programming, although the lessons apply more generally
to other cryptocurrencies and smart contract systems as well. We only deﬁne as
much Ethereum-speciﬁc terminology as needed to understand our examples. In
particular, the built-in currency of Ethereum is called Ether, and an Ether can
be divided into smaller currency units such as “wei”.

2.3 A Taste of Smart Contract Design

In this section, we will give the reader a brief overview of smart contract design
by describing the Ethereum implementation of a simple, yet useful, motivating
example – the ﬁnancial swap instrument. This contract allows two parties, Alice
and Bob, to take opposing bets about the price of a stock at some future time.
Both parties initially deposit equal amounts of money (as units of Ether cur-
rency). After a deadline has passed, the current price of the stock is queried by
interacting with a designated stock price authority (which would itself be imple-
mented as a smart contract - we refer to this contract as StockPriceAuthority).
Depending on the price at that time, the entire combined deposit is awarded to
either Alice or Bob.

The contract’s storage allocates space for the following data on lines 1 and
2: 1) the public keys of Alice and Bob; and 2) the deadline and threshold of the
swap contract. The contract also deﬁnes a function determine outcome, which
any party may invoke. This example serves as motivation of the useful aspects
of smart contracts as ﬁnancial instruments. In our other examples, we will tend
to focus on gambling games. It also serves to illustrate several low level aspects
of Serpent programming.

3 A Recount of Our Smart Contract Programming Lab

In our undergraduate security class at the University of Maryland, students were
asked to develop smart contract applications of their choice atop Ethereum [21],

1

2

3

4

5

6

7

8

9

10

11

data Alice, Bob
data deadline, threshold

# Not shown: collect equal deposits from Alice and Bob
# We assume StockPriceAuthority is a trusted third party contract
(cid:44)→

that can give us the price of the stock

def determine_outcome():

if block.timestamp > deadline:

price = StockPriceAuthority.price()
if price > threshold: send(Alice, self.balance)
else: send(Bob, self.balance)

Fig. 2. This Serpent program implements a simple ﬁnancial “swap” instrument, il-
lustrating that smart contracts are a powerful and useful tool for programming with
money.

using its expressive Serpent [20] programming language for composing smart
contracts. Students were divided into groups of four. Due to the experimental
nature of the lab, the instructor assigned one of her Ph.D. students to closely
supervise each group, to ensure that students could obtain hands-on help. The
lab proceeded in two phases.

Creation phase. The ﬁrst phase is a creation phase where each group created
a smart contract application of their own choice. The students created a variety
of applications, including games (e.g., Rock-Paper-Scissors, Russian Roulette,
custom-designed games), escrow services, auctions (e.g., sealed auctions, silent
auctions), a parking meter service, and stock market applications. At the end of
the ﬁrst phase, each group made a short presentation of their contract application
in class. The instructor, TAs, and students jointly observed numerous issues with
the programs that students created (see Section 4 for a detailed discussion).

Amendment phase. Therefore, we extended the project to a second phase,
called an amendment phase. The goal of this phase was for students to critique
their programs, ﬁnd bugs, and amend their designs. The instructor and TAs
had in-person meetings with each project group to help them amend their smart
contracts. Students also formed pair groups to critique and help the other group.

4 Pitfalls of Smart Contract Programming

In this section, we will demonstrate some of the typical pitfalls we observed for
smart contract programming. For ease of exposition, we will use a simple “Rock,
Paper, Scissors” example to illustrate three classes of typical mistakes. Similar
mistakes were commonly observed in various other applications developed by
the students.

Quick overview of our running example. We will ﬁrst give a quick overview
of the structure of our buggy “Rock, Paper, Scissors” program before we go on to
diagnose the bugs. In this contract, two players will play a simple “Rock, Paper,
Scissors” for money. The contract program consists of two main functions:

– player input: The players register with the contract and deposit money to
play. Each player also provides input to the contract in the form of their
choice of rock, paper, or scissors.

– finalize: The contract decides a winner and sends the proceeds to the

winner.

As we show below, surprisingly, even for a very simple smart contract it is

diﬃcult to create it correctly!

4.1 Errors in Encoding State Machines

Programming smart contracts typically involves encoding complex state ma-
chines. Logical errors in encoding state machines were commonly observed. The
simplest type of logical error is a contract that leaks money in corner cases.

To illustrate this, let us look at our buggy “Rock, Paper, Scissors” exam-
ple. Figure 3 shows the player input function where players register with the
contract and deposit money to play. The contract would then store the players’
public keys, inputs, and coins deposited (Lines 14-17). This contract exhibits
several mistakes:

– If a third player attempts to join and sends money to the contract, that
money becomes inaccessible (Line 20). Neither the player nor anyone else
can ever recover it.

– Similarly, if a player sends an amount of money that is not exactly 1000 wei,

the contract also leaks the money.

Note that while a careful player can protect herself from the second problem
by never sending the incorrect amount, she cannot always protect herself from
the ﬁrst problem. In a decentralized cryptocurrency like Bitcoin or Ethereum,
multiple parties may be sending inputs to the contract simultaneously. In this
case, it is up to the miner who mines this block to decide how to order these
transactions.

To ﬁx these bugs, the contract should refund the money back to a player
unless the player is successfully registered in the game. This approach is taken
in our improved contract (Figure 4, Lines 17 and 20).

What is shown here is merely the simplest example of a logical error when
encoding the state machine. In our lab, students created contracts that are far
more sophisticated (e.g., stock market applications, various ﬂavors of auctions)
that required the design of much more complex state machines. Failure to encode
the correct state machine (e.g., omitting certain transitions, neglecting to check
the current state) was among the most commonly observed pitfalls.

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

# A two-player game with a 1000 wei prize

data player[2](address, choice)
data num_players
data reward
data check_winner[3][3] # a ternary matrix that captures the rules
(cid:44)→

of rock-paper-scissors game

def init():

num_players = 0
# code omitted: initialize check_winner according to game rules

def player_input(choice):

if num_players < 2 and msg.value == 1000:

reward += 1000
player[num_players].address = msg.sender
player[num_players].choice = choice
num_players = num_players + 1
return(0)

else: return(-1)

def finalize():

p0 = player[0].choice
p1 = player[1].choice
# If player 0 wins
if check_winner[p0][p1] == 0:

send(0,player[0].address, reward)
return(0)

# If player 1 wins
elif check_winner[p0][p1] == 1:

send(0,player[1].address, reward)
return(1)

# If no one wins
else:

send(0,player[0].address, reward/2)
send(0,player[1].address, reward/2)
return(2)

Fig. 3. Pitfalls in smart contract design. This buggy contract illustrates a few
pitfalls:
Pitfall 1 (Lines 19 and 20): If a third player attempts to join the contract, his money
eﬀectively vanishes into a blackhole.
Pitfall 2 (Line 16): Players send their inputs in plaintext to the contract. A malicious
player can wait to see his opponents choice before deciding on his own input.

4.2 Failing to Use Cryptography

Another mistake is more subtle: Players send their inputs in cleartext. Since
transactions are broadcast across the entire cryptocurrency network, a cheating
player may wait to see what his opponent chooses before providing his own input.
Players in a smart contract are typically anonymous, and can be reason-
ably expected to act selﬁshly to maximize their ﬁnancial gains, even if it means
deviating from the default or “honest” behavior.

Cryptography is often the ﬁrst line of defense against potentially malicious
parties. Here, the obvious remedy is to use cryptographic commitments. Both
players can commit to their inputs in one time epoch, and then in a later epoch
open the commitments and reveal their inputs. A standard commitment satisﬁes
two properties, binding and hiding. Binding ensures that a player cannot change
their input after committing to it. Hiding ensures that a party learns nothing
about the others input choice even after observing the commitment. In our ap-
plication, the commitment must also be non-malleable, i.e., a player should not
be able to maul a previous player’s commitment into a related value (e.g., one
that will allow her to win). In general, for secure composition of computation-
ally sound primitives, we would recommend the usage of universally composable
commitments [10]. In this paper, we will use a simple, hash-based commitment
that is secure under the random oracle model. To commit a message m, ﬁrst
pick a random nonce that is suﬃciently long, and then compute the commit-
ment H(m, nonce). The opening and veriﬁcation algorithms are obvious.

In Figure 4, we show a ﬁxed contract that properly uses commitments.
The previous player input function is broken up into two phases: in the new
player input function, each player provides a commitment; after both commit-
ments are received, the open function is used to reveal their committed inputs.

Opportunity to teach cryptography. As students realized and sought to ﬁx
bugs in their own programs, the opportunity arose to teach them cryptography
as a well-motivated solution to their immediate practical problems. The instructor
seized this opportunity; in the amendment phase of the project, students were
indeed able to apply cryptographic commitments to secure their smart contracts!

4.3 Misaligned Incentives

More subtle bugs remain, even for the improved contract in Figure 4.

For example, one party can wait for the other to open its commitment. Upon
seeing that he will lose, that party may elect to abort (i.e., not to send any further
messages) – thus denying payment to the other player as well. It may seem at
ﬁrst glance like the losing party should be indiﬀerent to revealing his committed
input or not (regardless, we would prefer to have a clear positive preference for
revealing it); however, the reality is slightly worse, since that party must incur
a gas cost to even submit a transaction that opens his commitment.

This generalizes to a broader question of how to ensure the incentive com-
patibility of a contract. Can any player proﬁt by deviating from the intended
behavior? Does the intended behavior have hidden costs?

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

data player[2](address, commit, choice, has_revealed)
data num_players
data reward
data check_winner[3][3]

def init():

num_players = 0
# code omitted: initialize check_winner according to game rules

def player_input(commitment):

if num_players < 2 and msg.value >= 1000:

reward += msg.value
player[num_players].address = msg.sender
player[num_players].commit = commitment
num_players = num_players + 1
if msg.value - 1000 > 0:

send(msg.sender, msg.value-1000)

return(0)

else:

send(msg.sender, msg.value)
return(-1)

def open(choice, nonce):

if not num_players == 2: return(-1)
# Determine which player is opening
if msg.sender == player[0].address:

player_num = 0

elif msg.sender == player[1].address:

player_num = 1
else: return(-1)
# Check the commitment is not yet opened
if sha3([msg.sender, choice, nonce], items=3) ==
(cid:44)→
(cid:44)→

player[player_num].commit and not
player[player_num].has_revealed:

# Store opened value in plaintext
player[player_num].choice = choice
player[player_num].has_revealed = 1
return(0)

else: return(-1)

44

45

46

47

48

49

50

51

52

53

54

55

56

57

58

59

60

61

62

def finalize():

#check to see if both players have revealed answer
if player[0].has_revealed and player[1].has_revealed:

p0 = player[0].choice
p1 = player[1].choice
#If player 0 wins
if check_winner[p0][p1] == 0:

send(player[0].address, reward)
return(0)

#If player 1 wins
elif check_winner[p0][p1] == 1:

send(player[1].address, reward)
return(1)

#If no one wins
else:

send(player[0].address, reward/2)
send(player[1].address, reward/2)
return(2)

else: return(-1)

Fig. 4. An improved but nonetheless buggy contract. This contract ﬁxes a
subset of the problems identiﬁed in the original (Figure 3). When an edge case oc-
curs, the contract refunds the players rather than leaking money (Lines 17 and 20).
A cryptographic commitment scheme is used to oﬀer privacy of users’ inputs before
they are revealed for the winner determination (Line 14 and 33-36). As mentioned in
Section 4.3, this improved contract is still not safe due to misaligned incentives.

In this speciﬁc example, we can remedy the problem by setting a deadline
before which the second player has to reveal, otherwise the player who revealed
ﬁrst will be able to get the reward. This will protect the ﬁrst player when the
second player aborts. The modiﬁcations needed to protect against that case are
shown in Figure 5. Furthermore, we can have both players include an additional
security deposit in the ﬁrst stage, which they forfeit unless they open their
commitments in a timely manner. This way, even the losing player has a stronger
motivation to open his bid, but this change is not included here for simplicity.

4.4 Ethereum-speciﬁc Mistakes

Several subtle details about Ethereum’s implementation make smart contract
programming prone to error.

Call-stack bug. Without going into too much detail, contracts must be writ-
ten “defensively” to avoid exceptions that can occur when multiple contracts
interact. One Ethereum contract can send a message to another contract, which
can in turn send a message to another. However, Ethereum limits the resulting
call-stack to a ﬁxed size of 1024. For example, if the callstack depth is already
at this limit when the send instruction on Line 59 of Figure 4 is reached, then

# Declare a timer variable in the beginning
data timer_start
#### < Code omitted. Same as Figure 4 lines (1-22) >

def open(choice, nonce):

#### < Code omitted. Same as Figure 4 lines (24-32)>
if sha3([msg.sender, choice, nonce], items=3) ==
(cid:44)→
(cid:44)→

player[player_num].commit and not
player[player_num].has_revealed:
player[player_num].choice = choice
player[player_num].has_revealed = 1
# Keep track of the first reveal time. The other player should
(cid:44)→
if not timer_start: timer_start = block.number
return(0)

reveal before 10 blocks are mined.

else: return(-1)

def finalize():

# Check timer: Wait 10 blocks for both players to open
if block.number - timer_start < 10: return(-2)
if player[0].has_revealed and player[1].has_revealed:

#### < Code omitted. Same as Figure 4 lines (47-61)>

# Check for abort: If p1 opens but not p2, send money to p1
elif player[0].has_revealed and not player[1].has_revealed:

send(player[0].address, reward)
return(0)

# If p2 opens but not p1, send money to p2
elif not player[0].has_revealed and player[1].has_revealed:

send(player[1].address, reward)
return(1)

else: return(-1)

Fig. 5. Modiﬁcations required to the contract of Figure 4 to protect against
an aborting player.

that instruction will be skipped and the player will not get paid. Furthermore,
a send instruction sends by default the maximum available gas to the recipient.
If the recipient of the send instruction on Line 59, for example, is a contract
with buggy code that raises an exception, then Line 60 is never executed and
the other player loses out. We stress that the same bug was later manifested
in Etherpot [2], a lottery application built atop Ethereum and released to the
public. In our online course materials [4] we oﬀer guidance on how to avoid this
call-stack bug in Ethereum.

Blockhash bug. Another Ethereum-speciﬁc quirk is that the block.prevhash
instruction supports only the 256 most recent blocks, presumably for eﬃciency

reasons. This limitation also aﬀected Etherpot [2] and potentially other contracts
that went into production. Miller proposed one potential ﬁx to this problem by
implementing a global “blockhash service” contract that allows other contracts
to retrieve block hashes beyond 256 blocks [1].

Incentive bugs. Ethereum’s underlying mining protocol can introduce subtle,
incentive-related bugs. Etherpot [2], again as an example, uses the hash of a block
in the blockchain (e.g., at height T ) as a random beacon value to pick the lottery
winner. However, by selectively withholding blocks, miners can bias this value,
gaining an unfair advantage in the lottery - the miner who ﬁrst ﬁnds a block at
height T can check whether this results in them winning the lottery – if not, they
can withhold the block until another block is found, gaining a “second chance”
to win. To combat this, Etherpot makes sure the prize value of each lottery is less
than the base block reward. Thus a miner who withholds a block must sacriﬁce
the block reward they would have earned. However, Ethereum implements a
protocol variation called GHOST [15, 19], which allows miners who temporarily
withhold blocks to still get a (discounted) reward for their block, even if the
block is revealed later. Thus Etherpot’s reward limit is set too loose.

4.5 Complete, Fixed Contract
Due to space constraints, we provide a complete, incentive compatible, and secure
contract for the “Rock, Paper, Scissors” game in our online course materials [4].

5 Conclusion
5.1 Open-Source Course and Lab Materials

Our smart contract programming lab was an audacious, original attempt at
instructing a technology of in-development nature. Ethereum and its Serpent
language have only recently emerged, and are rapidly undergoing changes. The
Serpent language is not well documented and development environment support
(e.g., debugging tools) is also rudimentary. Therefore, several students struggled
in installing the simulation environment and getting up to speed. To facilitate
future pedagogical endeavors on smart contract programming, we have released
open course materials on smart contract programming [4]. The course materials
comprise the following:
– A detailed language reference guide for Ethereum’s Serpent programming lan-

guage.

– A virtual machine image with a snapshot of pyethereum and serpent com-
piler installed, providing a simulator environment for experimentation. Since
the Ethereum’s Serpent language is constantly under development, our Ser-
pent language reference matches the snapshot installed in this VM.

– A tutorial that builds on our “Rock, Paper, Scissors” example, intended to
walk the student through the typical pitfalls in programming safe smart con-
tracts. The student is presented with the buggy version of the contract and
asked to ﬁx the bugs in a step-by-step, guided manner.

These materials are available at https://mc2-umd.github.io/ethereumlab/.

5.2 Cryptocurrency and Smart Contracts as a Cybersecurity

Pedagogical Platform

Our experiences also led us to conclude that cryptocurrency and smart con-
tracts are a great platform for cybersecurity pedagogy. First, cryptocurrency
and smart contracts, like other interesting emerging technologies, could easily
capture the students’ attention and imagination. Second, cybersecurity is a sci-
ence that is interdisciplinary in nature; and cryptocurrency is a platform that
captures multiple core cybersecurity notions, e.g., cryptography, programming
languages, and game theory. Third, cryptocurrency and smart contracts easily
motivate “adversarial thinking.” For example, in our lab, students had to ana-
lyze their own smart contracts and reason how other selﬁsh players can harm
honest participants and maximize their own ﬁnancial gains.

5.3 The “Build, Break, and Amend Your Own Programs”

Approach to Cybersecurity Education

Inspired by our smart contract programming lab, we also feel that the “Build,
break, and amend your own programs” approach is very helpful for cybersecurity
education. In our labs, students learned why security is diﬃcult and learned
adversarial thinking by analyzing and breaking their own programs. Students
initially failed to make proper use of cryptography in their smart contracts (see
Section 4). But then, by realizing why their smart contracts are not safe, they
become self-driven in learning cryptographic building blocks.

In future work, we plan to further extend these pedagogical ideas, such that
students can learn through hands-on, creative experiences, and learn adversarial
thinking through attacking and amending their own code.

5.4 Subsequent Pedagogical Eﬀorts and Research

Based on insights gained through our experiences, one of the co-authors of this
paper, Miller, gave a smart contract programming tutorial at 1st Cyberport
FinTech Programming Workshop. This lab has also inspired later research on
cryptocurrencies and smart contracts. Juels et al. [13] recently demonstrated
how smart contracts can be leveraged to facilitate criminal activities and create
incentive compatible underground eco-systems. They then discuss countermea-
sures and advocate the responsible deployment of technology. Their paper would
be the criminal counterpart of our “step by step” paper. Finally, Kosba et al.
propose a general formal model for the “blockchain model of computation” which
captures the formal abstraction of smart contract programming [14].

5.5 Acknowledgements

We thank the anonymous reviewers for insightful feedback. This work is funded in
part by NSF grants CNS-1314857, CNS-1453634, CNS-1518765, CNS-1514261,
a Packard Fellowship, a Sloan Fellowship, two Google Faculty Research Awards,
a VMWare Research Award, Maryland Procurement Oﬃce contract H98230-14-
C-0137, ARO grants W911NF11103, W911NF1410358, and W911NF09102.

References

1. Blockhash contract. https://github.com/amiller/ethereum-blockhashes.
2. Etherpot. https://etherpot.github.io/.
3. The rise and rise of bitcoin. Documentary, http://bitcoindoc.com/.
4. Smart contract programming open course materials. http://mc2-umd.github.io/

ethereumlab/.

5. Shaik Shakeel Ahamad, Madhusoodhnan Nair, and Biju Varghese. A survey on

crypto currencies. In Int. Conf. on Advances in Civil Engineering, 2013.

6. Marcin Andrychowicz, Stefan Dziembowski, Daniel Malinowski, and Lukasz
Mazurek. Secure Multiparty Computations on Bitcoin. In IEEE Symposium on
Security and Privacy, 2013.

7. Simon Barber, Xavier Boyen, Elaine Shi, and Ersin Uzun. Bitter to betterhow to
make bitcoin a better currency. In Financial cryptography and data security, pages
399–414. Springer, 2012.

8. Iddo Bentov and Ranjit Kumaresan. How to Use Bitcoin to Design Fair Protocols.

In CRYPTO, 2014.

9. Joseph Bonneau, Andrew Miller, Jeremy Clark, Arvind Narayanan, Joshua A.
Kroll, and Edward W. Felten. SoK: Research perspectives and challenges for bitcoin
and cryptocurrencies. In 2015 IEEE Symposium on Security and Privacy, SP 2015,
San Jose, CA, USA, May 17-21, 2015, pages 104–121, 2015.

10. R. Canetti. Universally composable security: A new paradigm for cryptographic
protocols. In IEEE symposium on Foundations of Computer Science (FOCS), 2001.
11. David Chaum, Amos Fiat, and Moni Naor. Untraceable electronic cash. In Proceed-
ings on Advances in cryptology, pages 319–327. Springer-Verlag New York, Inc.,
1990.

12. Adam Krellenstein Robby Dermody and Ouziel Slama. Counterparty announce-

ment. https://bitcointalk.org/index.php?topic=395761.0, January 2014.

13. Ari Juels, Ahmed Kosba, and Elaine Shi. Rings of gyges: Using smart contracts

for crime. Manuscript, 2015.

14. Ahmed Kosba, Andrew Miller, Charalampos Papamanthou, Elaine Shi, and Zikai
Wen. Hawk: The blockchain model of cryptography and privacy-preserving smart
contracts. https://eprint.iacr.org/2015/675.pdf.

15. Yoad Lewenberg, Yonatan Sompolinsky, and Aviv Zohar.

Inclusive block chain

protocols. In Financial Cryptography and Data Security (FC), 2015.

16. Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system. 2008.
17. Rafael Pass and abhi shelat. Micropayments for decentralized currencies. In Pro-
ceedings of the 22Nd ACM SIGSAC Conference on Computer and Communications
Security, CCS ’15, pages 207–218, 2015.

18. Tim Ruﬃng, Aniket Kate, and Dominique Schr¨oder. Liar, liar, coins on ﬁre!: Pe-
nalizing equivocation by loss of bitcoins. In Proceedings of the 22Nd ACM SIGSAC
Conference on Computer and Communications Security, CCS ’15, 2015.

19. Yonatan Sompolinsky and Aviv Zohar. Accelerating bitcoin’s transaction pro-
cessing. fast money grows on trees, not chains. IACR Cryptology ePrint Archive,
2013:881, 2013.

20. Ethereum Wiki. Serpent. https://github.com/ethereum/wiki/wiki/Serpent,

2015.

21. Gavin Wood. Ethereum: A secure decentralized transaction ledger.

http:

//gavwood.com/paper.pdf, 2014.

