Identifying and Analyzing High Impact

Routing Events with PathMiner

Giovanni Comarela

Boston University

Boston, USA

gcom@bu.edu

Mark Crovella
Boston University

Boston, USA

crovella@bu.edu

ABSTRACT

1.

INTRODUCTION

Understanding the dynamics of the interdomain routing system is
challenging. One reason is that a single routing or policy change
can have far reaching and complex effects. Connecting observed
behavior with its underlying causes is made even more difÔ¨Åcult by
the amount of noise in the BGP system. In this paper we address
these challenges by presenting PathMiner, a system to extract large
scale routing events from background noise and identify the AS or
link responsible for the event.

PathMiner is distinguished from previous work in its ability to
identify and analyze large-scale events that may re-occur many
times over long timescales. The central idea behind PathMiner is
that although a routing change at one AS may induce large-scale,
complex responses in other ASes, the correlation among those re-
sponses (in space and time) helps to isolate the relevant set of re-
sponses from background noise, and makes the cause much easier
to identify. Hence, PathMiner has two components: an algorithm
for mining large scale coordinated changes from routing tables, and
an algorithm for identifying the network element (AS or link) re-
sponsible for the set of coordinated changes.

We describe the implementation and validation of PathMiner.
We show that it is scalable, being able to extract signiÔ¨Åcant events
from multiple years of routing data at a daily granularity. Finally,
using PathMiner we study interdomain routing over past 9 years
and use it to characterize the presence of large scale routing events
and to identify the responsible network elements.

Categories and Subject Descriptors

C.2.3 [Network Operations]: Network monitoring; C.2.5 [Local
and Wide-Area Networks]: Internet ‚Äì BGP

General Terms

Measurement

Keywords

BGP, Interdomain Routing, Boolean Tensor Factorization

Permission to make digital or hard copies of part or all of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proÔ¨Åt or commercial advantage, and that copies bear this notice and the full citation
on the Ô¨Årst page. Copyrights for third-party components of this work must be honored.
For all other uses, contact the owner/author(s).
Copyright is held by the author/owner(s).
IMC‚Äô14, November 5‚Äì7, 2014, Vancouver, BC, Canada.
ACM 978-1-4503-3213-2/14/11.
http://dx.doi.org/10.1145/2663716.2663754

The state of the interdomain routing system ‚Äì that can be seen
as the set of next-hops chosen by each AS (Autonomous System)
toward each preÔ¨Åx ‚Äì is driven by constant change, both automated
(by the rules of BGP path selection) and human-mediated (by pol-
icy changes). Each routing change made by an individual AS is in
response to some discrete event, such as a link failure or addition,
a peer‚Äôs route announcement or withdrawal, or a policy change.
However the complexity of the resulting dynamics means that the
causal relationship between routing changes in different parts of the
system is notoriously difÔ¨Åcult to tease out.

In this paper we present PathMiner, a system for identifying
large-scale changes to the state of the routing system that are caused
by individual events, and for narrowing down network elements
(ASes or links) responsible for the set of changes. By ‚Äòlarge-scale‚Äô
we mean routing changes that involve many ASes and preÔ¨Åxes, and
may re-occur at multiple times.

The central idea behind PathMiner is that when a set of ASes
change their next-hop decisions to a set of preÔ¨Åxes in a coordinated
fashion, especially when those same changes are repeated at multi-
ple points in time, then it is very likely that the coordinated activity
is ultimately caused by actions taken by a single AS or link. This
is an application of Occam‚Äôs Razor: when a large set of ASes all
change their next-hop decisions for a large set of preÔ¨Åxes, it is un-
likely to be a coincidence. Rather, the simplest explanation is that
all the changes were ultimately triggered by the action of a sin-
gle ‚Äòactor‚Äô (AS or link). Furthermore, as the size of the AS set
and preÔ¨Åx set involved grows, causation by a single actor becomes
even more likely. Hence, PathMiner looks for signiÔ¨Åcant spatio-
temporal patterns in BGP routing, extracts them from background
noise, and identiÔ¨Åes the network element most likely to be respon-
sible for generating the pattern.

We start by formalizing the concept of high impact routing
events, and showing how to translate the discovery of such events
into the Boolean Tensor Factorization problem. The Ô¨Årst compo-
nent of PathMiner is a new algorithm for Boolean Tensor Factor-
ization that is well suited for the kind of data that is derived from
network routing changes.

The second component of PathMiner identiÔ¨Åes the single actor
that is responsible for each event. This second step crucially de-
pends on the fact that the Ô¨Årst step extracts a set of coordinated
routing changes. The key insight is that over the set of all paths
that participate in the routing changes, the network element having
highest precision and recall as a classiÔ¨Åer for changed paths is most
likely the single actor responsible for the event.

We validate PathMiner by manually inspecting the extracted
events and actors. For this we developed an automated tool for
graphical reconstruction of the event, which depicts the changes

421made to the subgraph that is induced by the set of ASes and preÔ¨Åxes
involved in the event. While manual inspection is time consuming
and imperfect, we know of no alternative, since existing systems
for root-cause analysis are not capable of working with historical
data, nor with sets of large-scale routing changes. Our validation
Ô¨Ånds that the actors identiÔ¨Åed for each event almost always agree
with manual analysis.

Using PathMiner we perform an initial analysis of the last 9 years
of interdomain routing data, sampled at a daily granularity. We
show that PathMiner is capable of extracting large events, some of
which involve over 100,000 coordinated routing changes. Taken to-
gether, these events constitute between 10% and 20% of all visible
routing changes over time in the datasets we analyzed. Individual
events can involve tens to hundreds of ASes and preÔ¨Åxes, and oc-
cur tens to hundreds of times in our data. For most of these events,
PathMiner is able to identify a single actor (or a small set of actors)
that is likely responsible for ultimately causing this coordinated ac-
tivity.

One of the main contributions of our work is to provide evidence
that large-scale events do exist and they also re-occur over long
periods of time. SpeciÔ¨Åcally, PathMiner exposes the existence of
regions of the AS-level Internet that have similar dynamics towards
sets of preÔ¨Åxes. To the best of our knowledge PathMiner is the
Ô¨Årst tool capable of exposing such facets of the Internet at a global
scale. From an engineering point of view, such information may be
valuable for network administrators, when making changes in their
systems, by providing historical view of events related to similar
actions.

A high-level view laying out the main stages in PathMiner is
shown in Figure 1. In the rest of this paper, we describe each of the
stages shown in the Ô¨Ågure. First, Section 2 uses an example to mo-
tivate the development of PathMiner. Section 3 presents a formal
deÔ¨Ånition for our problem. In Section 4 we present and describe
how to process raw BGP data (corresponding to the Ô¨Årst two stages
in Figure 1). In Sections 5 and 6 we describe and present results
of our event detection methodology (the next two stages in Figure
1). Section 7 describes our single actor identiÔ¨Åcation strategy (the
last stage of the Ô¨Ågure). Finally, we discuss related work in Sec-
tion 8 and present concluding remarks and future work directions
in Section 9.

2. AN EXAMPLE

Before diving into the details of PathMiner, it is helpful to ex-
amine a typical example to provide intuition and motivate our ap-
proach.

Figure 2 shows a small subgraph representing the dynamics of a
portion of the network with respect to routing towards two preÔ¨Åxes
(hosted at AS42381 and AS44173, and shown in gray at the bot-
tom). The Ô¨Ågure captures routing dynamics over two consecutive
days (April 30, 2013 and May 1, 2013).

This subgraph is a portion of an event extracted by PathMiner.
The ASes along the top row of the Ô¨Ågure and the preÔ¨Åxes at the
bottom of the Ô¨Ågure constitute the output of the Ô¨Årst step of Path-
Miner. From the Ô¨Årst to the second day, all of the ASes at the top
change their next-hops toward all of the preÔ¨Åxes at the bottom. In
fact, the full event is quite large, involving dozens of ASes that all
change their next-hops; we have extracted these ASes which show
behavior that is typical of all the others.

A directed edge in the graph denotes the fact that the Ô¨Årst AS
uses the second AS as its next-hop for (each of) the two preÔ¨Åxes.
Black (solid) edges refer to edges seen in both days, red (dashed)
edges refer to edges seen just in the Ô¨Årst day and green (dotted)
edges refer to those seen only in the second day. Inside each node,


'

0






 !"#

- !"#

$"%&

&%'"

%"(
)


 

*+,- ."
%%%

/,
"%

Figure 1: Stages of PathMiner.

the negative (positive) number shows the number of paths passing
through the node in the Ô¨Årst (second) day of the event (Note that
the path counts reÔ¨Çect the full event, which involves many ASes
not shown.)

Figure 2 shows that on April 30, most of the paths towards
preÔ¨Åxes 1 and 2 were passing through AS6939 (Hurricane Elec-
tric). In the next day however paths are more dispersed; some pass
through AS3549 (Global Crossing), some through AS3257, some
only through AS174 (Cogent), and some pass only through other
ASes, not in the Ô¨Ågure, which connect directly to AS29632.
In
other words, ASes are switching from AS6939 to other ways to
reach AS29632. We can conclude that either (a) AS6939 made
its routes to the subject preÔ¨Åxes unattractive or unavailable, or (b)
AS29632, as well the others mentioned above, took actions to make
their routes more attractive or available.

This is interesting as a single event, as it shows a large-scale re-
organization of the network with regard to two preÔ¨Åxes hosted by
different ASes. However, it becomes even more interesting when
we note that the same event (or its reverse) happened 28 times dur-
ing 2013. From these 28 days PathMiner identiÔ¨Åed AS6969 and
AS29632 as responsible by the event in 18 and 10 days respec-
tively.

To illustrate how PathMiner Ô¨Ånds such event, consider Figures
3(a) and 3(b). These plots show all points in time during 2013 (on
the x axis) where each AS (on the y axis) changes its next-hop
towards one preÔ¨Åx. We treat each plot as a binary matrix, in which
element (j, k) is 1 if the AS represented by row j changes it next-
hop towards the subject preÔ¨Åx between the days k and k + 1.1 It
is clear that each matrix consists of noise plus a strong signal; that
signal is extracted and shown in Figures 3(c) and 3(d). Because
Figures 3(c) and 3(d) are very similar, they together represent the
fact that a group of many ASes changed their next-hops towards
both preÔ¨Åxes synchronously, multiple times in 2013.

1A change is related to the observed next-hops at two instants of
data collection, the Ô¨Årst on day k, and the second on day k + 1.
Transient changes, between the two data collection points, are not
considered in this work. Details in Sections 3.2 and 4.

422AS8419 -2 +2

AS5385 -2 +2

AS3549 -10 +46

AS3257 -0 +16

AS6939 -220 +3

AS174 -16 +301

AS29632 -236 +312

AS42381 -118 +156

AS44173 -118 +156

Figure 2: Path changes summary in the network towards two
preÔ¨Åxes (hosted at gray nodes) from Apr-30-2013 to May-01-
2013.

This simple example shows the nature of the kinds of events
captured by PathMiner. It also illustrates the key challenges that
PathMiner must overcome: i) how can we extract signal from noise
(e.g., going from Figure 3(a) to 3(c))? ii) next, how can we Ô¨Ånd pre-
Ô¨Åxes with similar signal matrices (e.g., matching Figure 3(c) with
3(d))? and iii) once multi-AS/preÔ¨Åx/time events are extracted, how
can we identify the AS or link most likely to have triggered all of
the routing changes captured in the event (as shown in Figure 2)? In
the following sections we present the solutions taken by PathMiner
to these challenges.

3. NOTATION AND DEFINITIONS

In this section we present the mathematical notation/deÔ¨Ånitions
(Section 3.1) used throughout the paper and a formal deÔ¨Ånition of
the problem we aim at solving (Section 3.2).

3.1 Notation

In this paper scalars will be denoted by lower-case letters (a),
sets by upper-case letters (A), vectors by lower-case bold-face let-
ters (v), and matrices by upper-case bold-face letters (M). We
will also work extensively with 3-dimensional arrays, or tensors,1
which we denote by upper-case calligraphic letters (T ).

A tensor may be seen as a collection of slices (matrices), Ô¨Åbers
(vectors) or elements. More speciÔ¨Åcally, for the n-by-m-by-l ten-
sor X , we use Xi::, X:j: and X::k respectively to denote hori-
zontal, lateral and frontal slices. In the same way, x:jk, xi:k and
xij: denote column, row and tube Ô¨Åbers respectively. Finally, xijk
(and with same meaning xi,j,k, Xijk or Xi,j,k depending on con-
venience) denotes the element (i, j, k) of X . In all cases above,
i = 1, . . . , n, j = 1, . . . , m and k = 1, . . . , l.

Tensor Y is an induced tensor from X if there exist sets A =
{a1, . . . an‚Ä≤ }, B = {b1, . . . , bm‚Ä≤ } and C = {c1, . . . , cl‚Ä≤ } such
that yijk = xai,bj ,ck . In this case we say that sets A, B and C
induce Y in X and we write Y = X (A, B, C). The same meaning
holds if we use vectors instead of sets (with the provision that when
using vectors, the ordering of indices matters, which is not the case
when using sets).

Unless otherwise stated, operations over tensors are deÔ¨Åned anal-
ogously as operations over matrices. SpeciÔ¨Åcally, for a n-by-m-by-
l tensor X , we denote its size as (n, m, l), its volume as vol(X ) =

1The word tensor is in general used to refer to N -dimensional ar-
rays. In this paper we deal only with N = 3. More details about
tensors can be found at [8].

n √ó m √ó l, and its Frobenius norm as ||X || = qPi,j,k x2

ijk. We
will also frequently refer to the density of a tensor, which is the
fraction of its entries that are nonzero.
In the particular case of
binary tensors, this is den(X ) =

.

Pi,j,k xijk

vol(X )

3.2 Problem deÔ¨Ånition

Our starting point is the path-based nature of BGP (Border Gate-
way Protocol), in which ASes keep information about the preferred
paths to each reachable preÔ¨Åx [19]. From a perspective of ASes
and preÔ¨Åxes, at a given time t the global state of the system can be
deÔ¨Åned as: a set of ASes A, a set of preÔ¨Åxes P , and for each a ‚àà A
a set of AS-paths, each of which allows a to reach a preÔ¨Åx in P .
Another representation that we will also use is based on next-hops.
In this representation, the state of the system consists of a set of
tuples (a, b, p) where a ‚àà A uses b ‚àà A as the next-hop to reach
p ‚àà P . The next-hop representation of the system contains less
information than the preferred-paths representation, so they are not
equivalent, but each will be more convenient for certain parts of
PathMiner.

To formalize the next-hop representation, at a given time t let N
be a multivalued n-by-m matrix of next-hops in the network, where
Nij denotes the set of next-hops used by AS j to reach preÔ¨Åx i.
Observing N over a discrete set of l points in time yields a n-by-
m-by-l multivalued tensor N , where Nijk is the set of next-hops
used by AS j to reach preÔ¨Åx i at time k. Tensor N represents the
complete dynamics of the network over the set of measurements.

By comparing (frontal) slices of N , we can identify next-hop
changes in the network. This results in a binary tensor C, which is
the n-by-m-by-(l ‚àí 1) tensor of routing changes, deÔ¨Åned as:

Cijk =(1,

0,

if Ni,j,k 6= Ni,j,k+1,
otherwise.

(1)

Given these deÔ¨Ånitions, we can deÔ¨Åne a high impact event in the
global routing system as: sets I (of preÔ¨Åxes), J (of ASes) and K
(of points in time) such that the sub-tensor C(I, J, K) has large
volume and high density. Because C(I, J, K) has large volume,
it has potential for high impact ‚Äì many routing changes might be
involved. The fact that C(I, J, K) has high density means that it
is likely to be a singular event ‚Äì that is, most ASes are changing
their next-hops toward most preÔ¨Åxes at most timepoints, and as ar-
gued above, such unusually coordinated activity is likely due to the
actions of a single network element.

To make this deÔ¨Ånition concrete, we introduce the concept of a

(Œª, ŒΩ)-event:

DEFINITION 1. ((Œª, ŒΩ)-event) A binary tensor B is a (Œª, ŒΩ)-
event with regard to binary tensor X if there exist sets I, J and K
such that B = X (I, J, K); den(B) ‚â• Œª; and vol(B) ‚â• ŒΩ.

DeÔ¨Ånition 1 still is not enough to fully characterize the events
we are seeking. For instance, two distinct (Œª, ŒΩ)-events B and B‚Ä≤
may be such that B is a sub-tensor of B‚Ä≤ and hence, the former
can be viewed just as redundant information when compared with
the latter. Therefore, it is also necessary to put constraints on the
set of (Œª, ŒΩ)-events we want to Ô¨Ånd. Thus, the Ô¨Ånal description of
our problem, which we call Boolean Tensor (Œª, ŒΩ)-Factorization
(or (Œª, ŒΩ)-BTF) is:

PROBLEM 1. (Boolean Tensor (Œª, ŒΩ)-Factorization) Given a
binary tensor X , integers r and ŒΩ and a real Œª, the Boolean Ten-
sor (Œª, ŒΩ)-Factorization problem consists of Ô¨Ånding r triples of sets
(Ih, Jh, Kh), h = 1, . . . , r such that:

423s
e
S
A

20

40

60

80

100

120

140

160

180

200

s
e
S
A

20

40

60

80

100

120

140

160

180

200

s
e
S
A

20

40

60

80

100

120

140

160

180

200

s
e
S
A

20

40

60

80

100

120

140

160

180

200

50

100

150

200

250

300

350

Day

50

100

150

200

250

300

350

Day

50

100

150

200

250

300

350

Day

50

100

150

200

250

300

350

Day

(a) PreÔ¨Åx 1, all changes

(b) PreÔ¨Åx 2, all changes

(c) PreÔ¨Åx 1, signal

(d) PreÔ¨Åx 2, signal

Figure 3: Next-hop changes towards the two preÔ¨Åxes of Figure 2 during 2013. An observed next-hop change, by AS j, towards the
subject preÔ¨Åx at day k implies value 1 for the element (j, k).

i) X (Ih, Jh, Kh) is a (Œª, ŒΩ)-event in X , for h = 1, . . . , r; and

is minimized, where: X (h) is a binary

tensor with same size as X , and x(h)

ijk = 1 iff (i, j, k) ‚àà
h=1 X (h) is deÔ¨Åned as the elementwise

r

X ‚àí

_h=1

ii) (cid:12)(cid:12)(cid:12)(cid:12)(cid:12)
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)
X (h)(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)
(cid:12)(cid:12)(cid:12)(cid:12)(cid:12)
Ih √ó Jh √ó Kh; andWr

logical or of X (1), . . . , X (r).

The intuition behind the deÔ¨Ånition of Problem 1 is to Ô¨Ånd a
set of r binary tensors that best approximate X as blocks of 1‚Äôs.
Moreover, we are only interested in tensors related to (Œª, ŒΩ)-events.
h=1 X (h) is the best approximation for X that can
be obtained with a rank-r binary tensor, when each X (Ih, Jh, Kh)
is a (Œª, ŒΩ)-event.

More formally,Wr

Unfortunately, easy ways to solve Problem 1 exactly are not
known. Setting Œª = 0 and ŒΩ = 0, the problem is equivalent to
the Boolean Tensor Factorization problem studied in [9], which is
known to be NP-hard [18]. Therefore, the more general problem of
(Œª, ŒΩ)-BTF is also NP-hard.

In summary, this section sets out a deÔ¨Ånition that translates the
general notion of identifying high impact events in the global rout-
ing into a speciÔ¨Åc problem. Unfortunately this deÔ¨Ånition highlights
two difÔ¨Åculties: i) complete topologies of the global interdomain
routing system over time are not available; and ii) computing an
exact solution to Problem 1 is hard in general.
In the next sec-
tion we discuss the available data we used and how we address its
incompleteness, and then in Section 5 we describe our heuristic al-
gorithms for Ô¨Ånding solutions to Problem 1.

4. DATASET DESCRIPTION

In this section we present the dataset we used, how we processed
it, and its limitations. Our source of data consisted of BGP RIBs
(Routing Information Bases) made available by RIPE [2] and the
Route Views project [4].

We obtained data from 9 years, from the beginning of 2005 until
the end of 2013, at a daily timescale. For each day and repository
we obtained the RIB made available at 8am (or, if not available,
the closest one). We made the arbitrary choice of 8am in order
to have approximately 24 hours between routing information col-
lected for each day. From the RIBs we extracted all records of
the form route dumping date, preÔ¨Åx and AS-path (only data related
to IPv4 preÔ¨Åxes). We stored this data on a 12-node cluster in a
Hadoop Distributed File System (HDFS) and, for the most data in-
tensive computations, we used Hadoop [1] and Spark [3]. Table 1
presents a summary of our dataset.

As described in Section 3, our Ô¨Årst step is to obtain the next-hop
tensor N . To this end, for each entry of the form [date, preÔ¨Åx p, AS-
path], where AS-path is given by [AS1, . . . , ASq], we computed

Table 1: Dataset summary

Year
2005
2006
2007
2008
2009
2010
2011
2012
2013

PreÔ¨Åxes
286723
331421
400784
438730
506978
543868
626312
879730
850997

ASes
23157
26188
29382
32929
36336
39339
43151
46262
49502

Size (GB)

340
470
640
806
845
939
1154
1397
1745

the q ‚àí 1 4-tuples [date, p, ASi, ASi+1], for i = 1, . . . , q ‚àí 1.
Each 4-tuple means that at time date, in order to reach preÔ¨Åx p, the
source ASi uses as next-hop ASi+1.

Referring to Table 1, it is important to remark that we do not have
routing information from every source to every destination at every
point in time. In this context, missing data can arise mainly for
two reasons: (a) data collection issues and (b) visibility problems
(the RIPE and Route Views RIBs do not capture the complete AS-
topology of the Internet). Note as well that the datasets considered
are large ‚Äì for recent years, over 1TB each in size.

Fortunately, both of these problems (missing data, and dataset
size) can be signiÔ¨Åcantly lessened by carefully selecting a represen-
tative subset of the data. Accordingly, we selected our data subset
by greedily choosing ASes and preÔ¨Åxes with most of the next-hop
changes in the network. To that end, using big data tools, we com-
puted the tensor C (Cijk = 1 iff AS j changed next-hop towards
preÔ¨Åx i from day k to k + 1) for each of the nine datasets in full.
Next, we computed the total number of changes over the year for
each preÔ¨Åx i (as a destination), each AS j (as a source) and for each
pair (i, j). Figures 4(a) and 4(b) present the log-log complemen-
tary CDFs of the total number of changes for preÔ¨Åxes and ASes,
respectively. It can be seen that for ASes there is a distinct subset
of heavy-hitters that account for the majority of routing changes.

Going further, Figure 4(c) shows the cumulative number of
changes for a pair (i, j) for the year of 2011. That is, value at row
i and column j of the heat map represents the fraction of changes
corresponding to the i preÔ¨Åxes and j ASes with most changes in
the dataset. This Ô¨Ågure provides information about how to greed-
ily, with respect to the number of routing changes, obtain a sample
of ASes and preÔ¨Åxes. With regard to ASes it is possible to see
that including more than the top 200 ASes in the sample does not
increase signiÔ¨Åcantly the fraction of changes captured.

On the other hand, there are hundreds of thousands of preÔ¨Åxes
that experience signiÔ¨Åcant levels of routing changes. At the same
time, it is also important to recognize that there exist many sets of
preÔ¨Åxes for which routing information is essentially redundant. In

4240
10

‚àí1

10

‚àí2

10

‚àí3

10

‚àí4

10

F
D
C
C

10

‚àí5

 
0
10

 

0
10

 

2005
2006
2007
2008
2009
2010
2011
2012
2013

1
10

2
10

3
10

4
10

5
10

Changes per prefix

(a)

‚àí1

10

F
D
C
C

‚àí2

10

‚àí3

10

10

‚àí4

 
0
10

2005
2006
2007
2008
2009
2010
2011
2012
2013

2
10

4
10

6
10

8
10

Changes per AS

(b)

(c)

Figure 4: Distributions of the total number of next-hop changes: (a) per preÔ¨Åx; (b) per AS; and (c) per pair (AS, preÔ¨Åx), for 2011
only. In (c) value at (i, j) indicates the total number of next-hop changes from the Ô¨Årst j ASes towards Ô¨Årst i preÔ¨Åxes (ASes and
preÔ¨Åxes are sorted, in decreasing order, by their number of changes).

Table 2: Summary of the sampled routing changes tensors

Year Density (%) Missing (%)
2005
2006
2007
2008
2009
2010
2011
2012
2013

0.9
1.2
1.5
1.9
1.7
1.6
1.7
1.8
2.3

7.4
8.7
6.7
6.3
8.1
7.0
5.9
7.4
5.5

particular, in many cases preÔ¨Åxes originated by the same AS are
routed similarly [6]. For our problem, such sets of preÔ¨Åxes add no
additional information about coordinated routing changes.

Hence, in our data subset we chose the top 20000 preÔ¨Åxes in
terms of volume of changes, but only allowing at most one pre-
Ô¨Åx hosted in each AS.1 Since the 20000 preÔ¨Åxes come from 20000
distinct ASes, and there are only about 50000 ASes active in total,
we expect that this subset captures a large fraction of the distinct
and observable routing changes in our data. That is, the intuition
behind our sampling strategy was to obtain a set of preÔ¨Åxes respon-
sible for many changes, and at the same time avoiding the discovery
of blocks with many preÔ¨Åxes belonging to the same AS and hence
having identical routing changes.

Table 2 presents statistics about tensor C projected only over the
samples; each sample tensor is of size 20000-by-200-by-364. Note
that because the set of active ASes and preÔ¨Åxes has changed over
the 9 year timespan, the sampling procedure was done indepen-
dently for each year. Therefore, the sets of preÔ¨Åxes and ASes con-
sidered vary from year to year, in order to capture the maximum
amount of routing changes, and hence results in the remaining of
this work were computed independently for each sample.

Table 2 also shows the percent of missing data, i.e., missing next-
hop entries in the tensor N (projected over the samples). Since
these percentages were reasonably small, we handled missing data
as follows. Suppose that at some point in time k we have Nijk 6= ‚àÖ
for some i, j and Ni,j,k+1 = ‚àÖ. Because data at time k + 1 is
missing, we cannot know for certain whether: i) AS j cannot reach
preÔ¨Åx i at time k + 1 (which would imply that Cijk = 1), or ii)
AS j can reach i at time k + 1 but our data set does not contain
that information (which implies that Cijk can be either 0 or 1). In

1We considered the host of a preÔ¨Åx to be the AS advertising the
preÔ¨Åx for the Ô¨Årst time in each year.

light of this limitation we took a conservative approach and deÔ¨Åned
Cijk to be 0. Therefore, a 1 in the tensor C means that we deÔ¨Ånitely
observe a next-hop change in the data, but a 0 can either imply
that a change did not happen, or that we simply do not know what
happened. Choosing to set these entries to 0 also reÔ¨Çects that fact
that zeros comprise the vast majority of known values in our data.
Note that the amount of uncertainty in the routing changes ten-
sors (C) is thus bounded by the 5 to 10% of missing data. This has
implications in the next section for our event extraction. In particu-
lar, we should expect that even when a set of ASes all change their
next-hops for a set of preÔ¨Åxes, our data may only show a portion
(e.g., 90%) of those changes ‚Äì i.e., the observed density of a valid
event may be less than 100%.

Another aspect worth mentioning about the dataset is the pres-
ence of more than one next-hop from some ASes towards some
preÔ¨Åxes. In fact, that was the motivation for our deÔ¨Ånition of next-
hop change, given in Equation 1, where one can see that we com-
pare sets, instead of elements. Other possible approach would be
to use a Ô¨Åner granularity of the network, where the issue of more
than one next-hop never arises. For instance, such granularity could
be obtained by considering quasi-routers. Unfortunately, the use of
quasi-routers would introduce problems hard to be addressed in our
analyses. For example, which quasi-router observed at a day k cor-
responds to the quasi-routers observed at day k + 1?

In order to provide means to understand how much the issue of
more than one next-hop may affect our results, we computed the
fraction of cases in which |Nijk| > 1 or |Ni,j,k+1| > 1, during
the computation of Cijk, in our nine datasets (before sampling). In
all cases this fraction was below 8%. Furthermore, from the cases
where Cijk = 1 we have that the same fraction is below 30% (in
all datasets).

5. EXTRACTING EVENTS

As previously discussed, at a high level PathMiner consists of
two main steps: (1) Ô¨Ånding high-impact events, and (2) identifying
the most likely network element causing the event. In this section,
we describe our solution to step (1), which is an algorithm for Ô¨Ånd-
ing good solutions to the (Œª, ŒΩ)-BTF problem.

An attractive solution to the (Œª, ŒΩ)-BTF problem would be to
start from an existing algorithm for standard Binary Tensor Factor-
ization. Unfortunately, the large size (combined with the density)
of our binary tensors was too much for existing algorithms (e.g., in
[9]) to handle. As a result, we developed a scalable heuristic to Ô¨Ånd
(Œª, ŒΩ)-events in the routing changes tensor C.

4254
10

e
m
u
o
V

l

3
10

5
10

4
10

e
m
u
o
V

l

3
10

4
10

e
m
u
o
V

l

3
10

2
10

0.7

0.75

0.8

0.85

0.9

0.95

1

2
10

0.7

0.75

0.8

0.85

0.9

0.95

1

2
10

0.7

0.75

0.8

0.85

0.9

0.95

Density

(a)

Density

(b)

Density

(c)

Figure 5: Density versus Volume for 2D (Œª, ŒΩ)-events obtained from slices of tensor C, 2013 only. PreÔ¨Åx (horizontal) slices in (a), AS
(lateral) slices in (b) and time (frontal) slices in (c). Experiments performed using Algorithm 1 with Œª = 0.7, ŒΩ = 100 and «´ = 1%.

Our approach has two steps. First we look at individual slices
of C and extract (Œª, ŒΩ)-events within slices (Section 5.1). Then,
we aggregate similar slice events in order to form events that span
multiple slices (Section 5.2).

The algorithmic approach we adopt is well suited to the case
where signiÔ¨Åcant large, dense events exist in the data (as those pre-
sented in Figure 3). Thus it is well suited to the current problem,
while other algorithms (including [9]) may be more appropriate
when events are smaller and rarer. For the sake of brevity and due
to space limitations we present only a high level description of our
algorithms.1

5.1

2D Factorization

Let X be a slice of C. It can be a preÔ¨Åx (horizontal), AS (lateral)
or a time (frontal) slice. For example, X may be the preÔ¨Åx slice
shown in Figure 3(a). The goal of 2D Factorization is to extract
from X a set of large volume, high density patterns such as shown
in Figure 3(c). For simplicity of notation we assume from now on
that X is a preÔ¨Åx slice of C for preÔ¨Åx i. Description for AS and
time slices proceeds analogously.

To start, we deÔ¨Åne a rank-1 binary matrix: given binary vectors
a and b, a rank-1 binary matrix X is given by Xij = ai √ó bj . That
is, a rank-1 binary matrix is the outer product of two binary vectors
and can be thought of as a ‚Äòblock‚Äô of 1s (after reordering of rows
and columns).

The 2D Factorization step repeats the following as long as a sig-
niÔ¨Åcant fraction of 1s can be obtained from X: Find a good rank-1
binary approximation for X, denoted M. If the set of rows J (rep-
resenting ASes) and columns K (representing days) with non zero
elements of M induces a submatrix B with volume at least ŒΩ and
density at least Œª, then label the triple ({i}, J, K) as a (Œª, ŒΩ)-event.
Next, independently of volume and density of B, remove all ones
captured by the set of rows J and the set of columns K. This strat-
egy is described more precisely in Algorithm 1.

The key challenge is to obtain the rank-1 approximation M (Line
5). In fact, this is equivalent to the Frequent Itemset Mining prob-
lem, which currently has not a known easy way to be exactly
solved. Furthermore, the tensor C may have many thousands of
slices, so the algorithm we use must run quite quickly. Hence we
use the strategy of relaxing the discrete problem into a continuous
one, solving the continuous problem, and thresholding the result to
Ô¨Ånd an approximate discrete solution.

1Our implementation is publicly available and can be obtained at
http://cs-people.bu.edu/gcom/bgp/imc2014 or by
direct request to the authors.

Algorithm 1: 2D-FACTORIZATION

Data: n by m binary matrix X related to preÔ¨Åx i, Œª, ŒΩ and

convergence parameter «´

Z‚Ä≤ ‚Üê Z

1 F ‚Üê {}
2 Z ‚Üê X
3 repeat
4
5 M ‚Üê RANK-1-APPROXIMATION(X, Z, Œª, ŒΩ)
6
7
8
9
10

J ‚Üê {j : mjk = 1}
K ‚Üê {k : mjk = 1}
B ‚Üê X(J, K)
if den(B) ‚â• Œª and vol(B) ‚â• ŒΩ then

F ‚Üê F ‚à™ {({i}, J, K)}

zjk ‚Üê 0

for (j, k) ‚àà J √ó K do

11
12
13 until kZk = 0 or kZ‚àíZ‚Ä≤k2
14 return F

kZk2 < «´;

Our relaxation seeks a real-valued rank-1 approximation to Z
(which initially is a copy of X). For this we use Non-Negative
Matrix Factorization (NNMF) [5]. Using NNMF we Ô¨Ånd real non-
negative vectors w (n-by-1) and h (1-by-m) such that wh is a real
nonnegative rank-1 matrix approximating Z. We then threshold w
and h independently, obtaining the binary vectors w‚Ä≤ and h‚Ä≤, such
that M = w‚Ä≤h‚Ä≤ minimizes kX ‚àí Mk (see that the error is com-
puted considering the original matrix). We note that once w and h
are computed, computing M (by Ô¨Ånding the optimal thresholding)
can be performed in time O(mn).

For the results in this paper, we ran Algorithm 1 for each of the
9 datasets with Œª = 0.7, ŒΩ = 100 and «´ = 1%. We considered as
input three different sets of slices: preÔ¨Åx slices, AS slices and time
slices. Figure 5 summarize the results by presenting a scatterplot
of density versus volume for the year of 2013 (same general com-
ments apply for other datasets). While preÔ¨Åx slices give us events
with a wide range of density and volume, AS and time slices behave
differently. Basically, most of the AS and time events have low den-
sity or volume close to 104. The explanation is twofold: Ô¨Årst, AS
and time slices are harder to mine, since their size is signiÔ¨Åcantly
larger than the size of preÔ¨Åx slices; and second, many of the events
on AS and time slices consist of one AS changing its next-hop to-
wards all (or almost all) preÔ¨Åxes in the network. Hence, because
preÔ¨Åx slices offer the best quality results (in terms of density) and
reveal the most interesting structure in the data, we use only pre-

426Ô¨Åx slices to generate the (Œª, ŒΩ)-events used in the next stage of the
algorithm.

5.2

3D Factorization

The next step is to Ô¨Ånd 3 dimensional (Œª, ŒΩ)-events in the tensor
C. The input S, obtained using the method in the last section, is a
set of triples of the form ({i}, J, K), where i represents a preÔ¨Åx, J
a set of ASes and K a set of points in time. The basic idea is to Ô¨Ånd
triples having similar blocks (given by sets J and K) and to group
them to create 3D events.

We consider that there may be two ways of combining a pair of
blocks. First, they may be nearly identical ‚Äì that is, their intersec-
tion may be nearly as large as their union. In that case, we merge
them by constructing the block that contains them both. Second,
their intersection may be much smaller than their union, but still
sufÔ¨Åciently large in terms of absolute volume.
In that case, we
merge them by constructing the block that is their intersection.

To evaluate these two cases, we deÔ¨Åne two functions over pairs

of triples x = (I, J, K) and x‚Ä≤ = (I ‚Ä≤, J ‚Ä≤, K ‚Ä≤) as:

dB(x, x‚Ä≤) = 1 ‚àí

|J ‚à© J ‚Ä≤| √ó |K ‚à© K ‚Ä≤|
|J ‚à™ J ‚Ä≤| √ó |K ‚à™ K ‚Ä≤|

and

sB(x, x‚Ä≤) = |J ‚à© J ‚Ä≤| √ó |K ‚à© K ‚Ä≤|.

(2)

(3)

The distance function dB measures the volume of the intersec-
tion of two blocks divided by the volume of their union. If close to
zero, then J is similar to J ‚Ä≤ and K is similar to K ‚Ä≤. Hence, it is
natural to assume that (I ‚à™ I ‚Ä≤, J ‚à™ J ‚Ä≤, K ‚à™ K ‚Ä≤) is a larger event.
We extend this strategy to merge multiple triples in a single step as
follows: given a triple x, look for a set S‚Ä≤ (which contains x) such
that maxy,z‚ààS ‚Ä≤ dB(y, z) ‚â§ Œ≥, for some 0 ‚â§ Œ≥ ‚â§ 1. Once S‚Ä≤ is
found we combine all of its elements at once using the following
operator:

COMBINE-UNION(S‚Ä≤) =Ô£´
Ô£≠ [y‚ààS ‚Ä≤

y1, [y‚ààS ‚Ä≤

y2, [y‚ààS ‚Ä≤

y3Ô£∂
Ô£∏ ,

where y1, y2 and y3 represent, for triple y, the sets of preÔ¨Åxes,
ASes and points in time respectively.

The similarity function sB captures the case when the intersec-
tion of two blocks is large enough by itself to merit merging the
blocks. That is, it may be the case that triple x is not nearly the
same as any other triple in S, but there still exists x‚Ä≤ such that
sB(x, x‚Ä≤) is signiÔ¨Åcantly large (larger than some threshold Œ≤). In
this case, we may conclude that (I ‚à™ I ‚Ä≤, J ‚à© J ‚Ä≤, K ‚à© K ‚Ä≤) is an
event. In fact, the second part of the algorithm looks for elements
x‚Ä≤ ‚àà S such that sB(x, x‚Ä≤) ‚â• Œ≤ and then combines them using the
following operator:

COMBINE-INTER(x, x‚Ä≤) = (I ‚à™ I ‚Ä≤, J ‚à© J ‚Ä≤, K ‚à© K ‚Ä≤).

Alternating the test for maximum distance and minimum similar-
ity and using COMBINE-UNION and COMBINE-INTER operators
iteratively yields the discovery of new triples (possible representing
new (Œª, ŒΩ)-events) and is the core of our strategy to Ô¨Ånd 3 dimen-
sional blocks in C. The procedure is summarized in Algorithm 3
(presented in Appendix A).

One may note that Algorithm 3 does not check the density of
new formed 3D blocks. This is because extracting the relevant por-
tions of C for this check is so time consuming as to be prohibitively
expensive for our datasets. Of course this absence of veriÔ¨Åcation
may lead to triples that induce blocks with low density. A second
problem that may arise is that the extracted 3D blocks may still

show signiÔ¨Åcant overlap. In order to address these two issues we
added a Ô¨Ånal stage that discards blocks with low density and blocks
that do not add new information to the results because it overlaps
with many others. This process is described in Algorithm 2, which
greedily (by decreasing order of volume) selects only triples with
a minimum density and that captures signiÔ¨Åcant information not
contained in blocks previously selected. Results and parameters
set up related to the methodology presented in this section will be
discussed in Section 6.

Algorithm 2: EVENT-SELECTION

Data: Tensor C, S, set of triples of sets of the form (I, J, K)

and thresholds Œª and ŒΩ

1 L ‚Üê sort triples (I, J, K) ‚àà S in decreasing order of

volume (|I| √ó |J| √ó |K|)

2 S‚Ä≤ ‚Üê ‚àÖ
3 for i = 1 to |L| do
(I, J, K) ‚Üê Li
4
B ‚Üê C(I, J, K)
5
if vol(B) ‚â• ŒΩ and den(B) ‚â• Œª then
6
foreach (i, j, k) ‚àà I √ó J √ó K do
7
8

Cijk ‚Üê 0

9

S‚Ä≤ ‚Üê S‚Ä≤ ‚à™ {(I, J, K)}

10 return S‚Ä≤

6. CHARACTERIZING EVENTS

After the execution of the set of algorithms presented in the pre-
vious section, we have a collection of 3D events extracted from
from the routing changes tensor C, each one with large volume and
high density. In this section, we brieÔ¨Çy pause to characterize the
events found by PathMiner in the 9 years of routing data.

After experimentation we settled on the following parameters for
the algorithms presented in Section 5.2: Œª = 0.8, ŒΩ = 100, Œ≥ =
0.1 and Œ≤ = 100.1 Table 3 summarizes the overall performance
of PathMiner when using these parameter settings on our data. The
column ‚Äò# 1‚Äôs Retrieved‚Äô is the total number of routing changes that
were contained in events, and the ‚ÄòPercent‚Äô column is the fraction
of all routing changes in our data that were contained in events.

Table 3: Summary of (Œª, ŒΩ)-events

Dataset

#Events

#1‚Äôs Retrieved

Percent

2005
2006
2007
2008
2009
2010
2011
2012
2013

5255
6823
8252
7996
8602
9646
12042
13910
13992

1107109
1689299
2504558
2411041
2466807
2952688
3991264
4611049
5880885

8.2
9.5
11.1
8.3
9.7
12.6
16.3
17.8
17.7

The table shows that PathMiner is able to Ô¨Ånd many blocks, com-
prising a signiÔ¨Åcant fraction of the routing changes contained in the
datasets, ranging from 8.2% in 2005 up to 17.8% in 2012. Figures

1For instance, using Œ≤ = 200 and Œ≥ ‚àà {0.2, 0.05} did not change
the results signiÔ¨Åcantly in terms of percentage of retrieved next-hop
changes, average volume or average density. Tests performed with
2013 dataset.

4275
x 10

d
e
v
e
i
r
t
e
r
 
s
e
g
n
a
h
c
 
f
o
 
e
g
a
t
n
e
c
r
e
P

30

25

20

15

10

5

0

06

07

08

09

10

11

12

13

Year

(b)

06

07

08

09

10

11

12

13

Year

(a)

s
e
g
n
a
h
c
 
f
o
 
r
e
b
m
u
n
 
l
a
t
o
T

2

1.5

1

0.5

0

0
10

‚àí1

10

‚àí2

10

‚àí3

10

‚àí4

10

F
D
C
C

‚àí5

10

 
2
10

y
a
d
 
a
 
s
t
n
e
v
E

600

500

400

300

200

100

0

 

0
10

F
D
C
C

‚àí1

10

‚àí2

10

‚àí3

10

‚àí4

10

06

07

08

09

10

11

12

13

Year

(c)

 

2005
2006
2007
2008
2009
2010
2011
2012
2013

2
10

3
10

4
10

5
10

Volume x Density

(f)

 

0
10

F
D
C
C

‚àí1

10

2005

2006

2007

2008

2009

2010

2011

2012

2013

3
10

4
10

5
10

Volume

(d)

10

‚àí2

 

0.8

2005
2006
2007
2008
2009
2010
2011
2012
2013

0.85

0.95

1

0.9

Density

(e)

10

‚àí5

 
1
10

5
10

4
10

3
10

e
m
u
o
V

l

2
10

0
10

4
10

e
m
u
o
V

l

3
10

2
10

2
10

0
10

1
10

Number of Prefixes

(g)

4
10

e
m
u
o
V

l

3
10

2
10

2
10

0
10

1
10

Number of ASes

(h)

1
10

Number of days

2
10

(i)

Figure 6: Basic statistics about (Œª, ŒΩ)-events found by PathMiner (Œª = 0.8 and ŒΩ = 100). Time series of: (a) total number of next-hop
changes in each yearly sample; (b) percentage of these changes captured in events by PathMiner; (c) number of events found in each
day. Complementary CDFs of: volume of events ‚Äì volume is deÔ¨Åned as the product of the number of preÔ¨Åxes, ASes and days in a
event; (e) density of events ‚Äì density is the number of changes captured by an event over its volume; (f) product volume √ó density of
events. Event scatterplots (2013 only): (g) number of preÔ¨Åxes versus volume; (h) number of ASes versus volume; (i) number of days
versus volume.

6(a), 6(b) and 6(c) present the same statistics on a daily basis as
a time series over the 9 years of data. Note that the samples for
each year are distinct so trends should not be inferred across years.
From Figures 6(b) and 6(c) we can see that PathMiner performs
better in tensors with higher density and that overall, the shape of
the time series related to the fraction of changes and the number of
events a day is similar to the shape of the time series related to the
total number of changes (higher values in 2008 and in the last three
years, 2011, 2012 and 2013).

Next, we move to analyzing density and volume of events. As an
algorithmic constraint we have that each block has density higher
than 0.8 and volume greater than 100. But, in general, how large
and dense are the events? Figures 6(d), 6(e) and 6(f) present the
log-log complementary CDF for volume, density and their product,
respectively, for all 9 datasets. In general the distributions are long-
tailed, with many small events and a few very large events. In terms
of volume we can see that for 2005 more than 10% of all blocks
have volume greater than 500 and that this number goes up to 1000
in 2013.
In the tail of the curves we can see some huge events

with volume greater than 104. Similar comments can be made for
Figure 6(f). In terms of density, although 0.8 can be considered
a high threshold, there are many blocks that are much denser. For
instance, approximately 30% of all events (in all datasets) have den-
sity higher than 0.9 and 10% are higher than 0.95 in density.

We also explore the relationship between the volume of events
and the number of preÔ¨Åxes, ASes and days that the event con-
tains. Figures 6(g), 6(h) and 6(i) present the results for the year
of 2013 (results for other years follow the same trend). It can be
seen that the extracted events include large numbers of days and
ASes (obtained via the 2 dimensional factorization algorithm) and
that events with many preÔ¨Åxes are formed as a result of the 2D
event aggregation step.

Finally, Table 4 presents the 5 largest events, in terms of vol-
ume for each year. Columns 2 to 4 represent the number of pre-
Ô¨Åxes, ASes and days in each event (thus the volume of the event
can be obtained by their product). The table shows that PathMiner
was able to Ô¨Ånd events of remarkable scope, some of which in-
volve dozens of ASes, preÔ¨Åxes, and days. The largest events (in

4282007 and 2008) involve over 100,000 individual routing changes.
In this respect it is important to recall as well that each preÔ¨Åx in
our datasets is originated in a distinct AS, so the actual number of
routing changes per event in the full data is much larger because of
the similar routing behavior of co-originated preÔ¨Åxes.

Table 4: Description of top-5 events over 9 years

Dataset

#PreÔ¨Åxes

#ASes

#Days Density

2005

2006

2007

2008

2009

2010

2011

2012

2013

2
2
1
1
2
3
82
1
3
1

140
13
75
77
45
156
79
15
22
10
45
1
13
6
14
49
28
60
98
17
81
37
21
46
47
1
4
1
1
31
43
6
11
1
57

54
60
59
57
52
68
11
66
58
65
49
52
8
5
37
28
41
44
37
103
102
90
51
89
48
38
41
101
15
43
23
23
43
53
20
87
65
98
94
36
34
80
92
128
83

200
109
138
95
48
168
19
183
61
156
20
44
35
28
6
25
6
23
13
10
2
91
11
13
10
16
11
2
8
13
16
19
14
5
11
152
44
101
96
8
32
77
27
158

4

0.90
0.88
0.83
0.87
0.91
0.86
0.83
0.86
0.91
0.85
0.80
0.81
0.89
0.80
0.91
0.88
0.85
0.83
0.83
0.88
0.80
0.87
0.81
0.80
0.83
0.90
0.97
0.88
0.94
0.80
0.80
0.90
0.88
0.90
0.95
0.82
0.86
0.90
0.90
0.87
0.82
0.82
0.81
0.80
0.86

7. SINGLE ACTOR ANALYSIS

In this section we present the second component of PathMiner,
an algorithm to identify the network element that is most likely to
have caused a large event, given that the ASes, preÔ¨Åxes and days
involved in the event are known. We start by explaining our identi-
Ô¨Åcation methodology, and then we present results.

7.1 Algorithm

We start with some basic observations. Consider an action taken
by some network element a (say, an AS) that causes a path from
AS b towards preÔ¨Åx p to change. We observe that a is, in general,
either on the path from b to p before the change, or after [10]. For
example, if a link fails or comes up, or an AS announces a new

route and/or withdraws an existing route, these events can cause
changes to many paths, but the paths involved will all pass through
the link or AS either before or after the change.1

Thus, if we are interested in some event that happened on day k,
then we may want to compare the set of paths seen in the network
on day k with those seen on day k + 1. Counting paths in order
to identify (or narrow down) a root cause for a routing change has
been explored before, e.g. [16]. However, PathMiner differs from
such previous work in terms of goals (since it particularly focuses
on large events that may re-occur over time) and in methods (since
it carefully chooses the set of paths to analyze).

PathMiner takes advantage of the fact that starting from a collec-
tion of (Œª, ŒΩ)-events, found by its Ô¨Årst component, is an effective
way of isolating the set of paths to study, thus avoiding interference
of paths that are changing for unrelated reasons. SpeciÔ¨Åcally, when
analyzing an event that on day k has set of ASes J and set of pre-
Ô¨Åxes I, we consider only paths seen on days k and k + 1 passing
through ASes in J towards preÔ¨Åxes in I. If one of such path start
at an AS which is not in J and passes through a ‚àà J , then Path-
Miner takes such path in account, but it ignores the portion before
a. Accordingly, we deÔ¨Åne Pk to be the multiset of all paths that are
found starting at an element of J and ending at an element of I on
day k.

Considering the above observations we have that a good candi-
date for the single network element responsible for the entire set
of observed path changes has the following properties: on either
day k or day k + 1, (a) most of the changed paths pass through
the network element and (b) most the paths going through the net-
work element change. We call these rules single actor rules and the
network element so identiÔ¨Åed the single actor.

For concreteness, assume that network element e is the single
actor, and the changed paths go through e on day k but not on
day k + 1. Among all the paths being considered, deÔ¨Åne D =
Pk \ Pk+1 as the paths that disappeared; De as the paths in D
passing through e; and Pk,e as the paths in Pk that pass through e.
If e is the single actor, by the single actor rules one concludes that
e = |De|
rD
|Pk,e| should be close
to 1. In other words, rD
e captures the fraction of disappeared paths
passing through e (rule (a)) and pD
e captures the fraction of paths
passing through e that disappeared (rule (b)).

|D| should be close to 1, and pD

e = |De|

e and rD

For intuition, we note that pD

e correspond respectively
to the deÔ¨Ånitions of precision and recall for a particular classiÔ¨Åer.
This classiÔ¨Åer is the one that declares that a path will disappear if
the path passes through e on day k. In other words, maximizing pD
e
and rD
e with regard to e yields the network element that best classi-
Ô¨Åes the paths as changing versus unchanging. Following common
practice in machine learning, we combine precision and recall into
the F-score. In fact, in our case we use the F2 score deÔ¨Åned by
2 (e) = 5pD
F D
We can make analogous deÔ¨Ånitions covering the set of paths that
appear on day k + 1. In that case, we deÔ¨Åne A = Pk+1 \ Pk, and
Ae as the paths in A that pass through e. Hence, pA
|Pk+1,e| ,
and the same interpretation given

to place higher emphasis on the role of recall.

e = |Ae|

e rD
e
e +rD
e

4pD

2 (e) = 5pA
e = |Ae|
rA
4pA
above is valid here as well.

|A| , F A

e rA
e
e +rA
e

In practice one does not know a priori whether e will be found
using the single actor rules applied to disappeared paths on day
k, or appearing paths on day k + 1. To overcome this problem we

1The assumption that the cause of the event will be in the new or
old path is not always true [14]. However, PathMiner is built under
such assumption because it deals with large-scale events, where the
likelihood of observing paths passing through the cause increases.

429Table 5: Single actor analysis of Top-5 events of each year

76
38
38
57
30*
50
13
103
58
93
14
18
35
16*

6

16*

Most Frequent Actor Days
31050
23918
1299
8342
20485
23918
3257
33697
20485
33697
174
1273
4637
3257
7575
9121
25462
174
25462
3303
3216
15412
3216
8359
29049
30890
3491
21219
5588
13249
5588
3549
3491
12989
174
38312
29632
4755
56209
4651
7713
12880
8529
10029
21219

3
12
5
8
2*
62
7
10
5
14
11
2
8*
8
16
17
13
4*
10
142
37
96
91
8
28
52
19
116

Dataset

2005

2006

2007

2008

2009

2010

2011

2012

2013

deÔ¨Åne the candidate single actor to be the network element (or set of
elements) that maximizes ‚àÜF (e) = max{F D
2 (e)}. From
this analysis we exclude AS-links that are seen on days k and k + 1
and ASes which all incoming and outgoing AS-links are also seen
on days k and k + 1. This decision is justiÔ¨Åed by the fact that an
AS-link that has not been disrupted and an AS that, explicitly, has
not changed its local preference and/or export policies are unlikely
the element that triggers a large-scale event.

2 (e), F A

This algorithm is effective, but can some times return multiple
elements as candidate single actors for any given day k in an event.
However, one can bring one more observation to bear: the single
actor should be the same over all days k in the event. This offers an
additional opportunity to winnow the set of candidate single actors.
So the Ô¨Ånal step of the single actor analysis is: for events that re-
occur over a set of days K, repeat the single-day strategy for every
k ‚àà K. Then, deÔ¨Åne as the Ô¨Ånal single actor of the event the
element (or elements) that is observed in the candidate single actors
set in at least the majority of the days in K. If such element is
not found (no element is a candidate single actor in the majority
of days) the algorithm declares that it was not able to identify the
cause of the event.

7.2 Performance

PathMiner is able to identify the actors responsible for most of
the events presented in Table 4. Table 5 shows the ASes identi-
Ô¨Åed as the single actor for each event, and the number of days that
the element was classiÔ¨Åed as single actor (note that in the table we
present only the most frequent one and that other elements, present
in the majority of days, also have to be considered as possible ac-
tors). The boldface numbers indicate the cases where PathMiner
identiÔ¨Åed the same element(s) as cause(s) for a majority of days in
the event. It can be seen that PathMiner has more difÔ¨Åculty identi-
fying single actors for events spanning many days and/or involving
few ASes.

In order to validate the actors identiÔ¨Åed by PathMiner for events
in Table 4 we performed a visual inspection of each event as fol-
lows4: for each day of each event we looked at the network ele-
ment identiÔ¨Åed as actor, the graphical representation of the event,
and asked two questions. First, ‚Äúwould an action of that network
element (e.g. an AS changing its local preferences and/or its export
policies) explain the occurrence of the event?‚Äù Second, ‚ÄúDo the
actions of this network element provide the simplest explanation
among all elements involved in the event?‚Äù If the answers for those
question were afÔ¨Årmative in the majority of days of the event we
considered such event validated.

We also conducted analyses to understand how often PathMiner
is able to identify a single actor as cause of an event. Our Ô¨Årst
analysis is related to the maximum value of ‚àÜF (e) obtained for
each day in an event and for all events that PathMiner found in
the 9 datasets. The results, presented in Figure 7(a) by a CDF,
indicate that large values are the predominant case. For instance,
the Ô¨Ågure shows that the maximum ‚àÜF (e) is equal to 1 in 40% of
the cases and is greater than 0.8 in more than 80%. These numbers
suggest that in most of the days within events PathMiner is capable
of Ô¨Ånding a network element (or a set of) that, in fact, can explain
the massive amount of changes related to the event.

These results are promising, but note that they refer to individual
days within events. It is important to also ask how consistent the

4Graphical representations for these events and actor identiÔ¨Åca-
tion summary are available at http://cs-people.bu.edu/
gcom/bgp/imc2014. We also make available the same repre-
sentation and summary for another 500 randomly selected events
for the year of 2013.

4

* The actor found by PathMiner provides a
simple explanation for the event. However,
other elements providing a simple explana-
tion could be identiÔ¨Åed by visual inspec-
tion.

identiÔ¨Åcation is over the days of an event, and how often PathMiner
is able to Ô¨Ånd the same actor over the set of days of the event. To
answer those questions we identiÔ¨Åed for each event the element that
appears as cause of the event most frequently over the days of the
event and the fraction of days this single actor has been identiÔ¨Åed.
Figure 7(b) presents the results. It can be seen (with exception of
2005) that in more than 40% of the events a single network ele-
ment has been observed by PathMiner as an event cause over all
days of the event. Furthermore, we can see that in more than 90%
of the events there is a single actor that is present over the major-
ity of days. For the cases where majority has not been found we
refer to Figure 7(c) to show that in some of them the event con-
tains many days, which naturally increases the complexity of the
problem. However, there are many small (in terms of days) events
for which PathMiner was not able to identify a single actor. Initial

430F
D
C

1

0.8

0.6

0.4

0.2

0

 
0

2005
2006
2007
2008
2009
2010
2011
2012
2013

2005

2006

2007

2008

2009

2010

2011

2012

2013

0.2

0.4

0.6

0.8

1

Maximum F score

(a)

F
D
C

0.8

0.6

0.4

0.2

0

 
0

 

1

 

s
y
a
d
 
f
o
 
n
o
i
t
c
a
r
F

1

0.9

0.8

0.7

0.6

0.5

0.4

0.3

0.2

0.2

0.4

0.6

0.8

1

Fraction of days

(b)

50

100

150

200

Number of Days within the event

(c)

Figure 7: Summary of our methodology for Single Actor identiÔ¨Åcation: (a) CDF of ‚àÜF , computed over each day of each event; (b)
CDF of the fraction of days that the same AS (or AS-link) is reported as actor (has maximum ‚àÜF score) over all days of the event; (c)
scatterplot of the number of days within an event versus the fraction of days that the same AS (AS-link) is reported as actor ‚Äì same
variable as in (b).

investigation reveals that those events are related to a small number
of ASes, and as consequence to a small number of paths, which is
not an ideal situation to work with measures such as precision and
recall. We emphasize that further investigation is necessary in that
direction as future work.

As a Ô¨Ånal analysis, we list the ASes which, as actors had the
greatest impact on the network. We considered the year of 2013,
for all events that PathMiner was able to identify a single actor and
that involved at least 50 ASes (to avoid the problem of few paths
mentioned previously). Table 6 shows the top-20 ASes ranked in
three different ways: Ô¨Årst, by the number of events that the AS is
an actor; second, by the aggregate volume of all events that the AS
is an actor; and third, by the aggregate number of days of all events
that the AS is an actor. In all three cases, if more than one AS was
identiÔ¨Åed as actor, or if there was an AS-link, we counted each AS
involved individually. Therefore, events with more than one AS as
actor are counted more than once in Table 6.

Table 6: Three different rankings for the Top-20 Single Actors

Total volume Total days
AS9498
AS4755
AS6453
AS12880
AS6939
AS9002

#Events
AS174
AS9498
AS9002
AS3356
AS6939
AS3549
AS12389 AS174
AS3216
AS3549
AS20485 AS3216
AS6453
AS12389
AS31133 AS15412
AS20485
AS7018
AS3356
AS701
AS4755
AS3491
AS12880 AS55410
AS8167
AS10029
AS12989
AS6461
AS4651
AS209
AS197556
AS3491
AS8359
AS8167

AS9498
AS4755
AS6453
AS174
AS3549
AS3216
AS6939
AS3356
AS20485
AS15412
AS12389
AS9002
AS701
AS3491
AS18101
AS8167
AS12880
AS7018
AS18881
AS55410

First, it can be seen that the way we ranked the ASes change the
order in the three columns of the table, but there is a signiÔ¨Åcant

overlap between the top-20 of each rank, showing that, in general,
there are heavy-hitter actors that trigger many large, re-occurring
events. Second, in all three ranks, it is possible to identify some
large ASes, which peer other large ASes and are important parts of
the Internet core. For example, AS174 (Cogent), AS6939 (Hurri-
cane Electric), AS3549 (GBLX) and AS3356 (Level3) are in the
top-20 of each list. This suggests that some ASes in the core are
responsible for a large amount of the reorganization that happens
in the network. However, it is important to remember that our
strategy to sample ASes may have inÔ¨Çuence in this result, and ul-
timately that our original dataset does not cover the complete AS-
level topology of the Internet (which in fact motivated our sampling
strategy).

7.3 Case studies

In this section we present three case studies in order to show the
ability of PathMiner to identify actors of high impact events. Case
studies I and II were chosen to illustrate typical scenarios where
PathMiner is able to identify a network element (or set of elements)
whose actions would explain, in a simple way, the occurrence of
the event. We remark that many events share the same structure
(this can be seen in the online supplementary material). Case study
III, on the other hand, shows that PathMiner is not guaranteed to
always work. In that case, we discuss the reason and show that the
assumptions under which PathMiner was build are not satisÔ¨Åed.

In the representation of each case study, Figures 8, 9 and 10,
ASes in gray hosts a destination preÔ¨Åx. Red (dashed) edges are
those present only at day k, green (dotted) edges are present only
at day k + 1 and black (solid) edges are present in both days. Inside
each node we have: the AS identiÔ¨Åer; the number of paths passing
through the AS at day k, with a negative sign; and the number of
paths passing through the AS at day k + 1, with a positive sign.
Only paths passing through an AS in the event towards a preÔ¨Åx in
the event are counted.

7.3.1 Case study I

Our Ô¨Årst case study is related to the second event for the year of
2009 presented in Table 4. In this event we have 90 ASes changing
their next-hops towards one preÔ¨Åx over 91 days during the year.
Among those, we picked 2 pairs of consecutive days in order to
illustrate the nature of the event. Following the same convention
used in Section 2, Figures 8(a) and 8(b) picture the most impor-
tant part of the network for our needs. From Feb-08 to Feb-09
many ASes stopped using AS15412 as next-hop and started using

431AS6939 -2 +2

AS6539 -1 +1

AS1280 -1 +1

AS6939 -4 +4

AS1280 -1 +1

AS6539 -1 +1

AS3549 -37 +6

AS4637 -2 +280

AS4637 -294 +4

AS15412 -143 +0

AS18101 -143 +0

AS15412 -0 +142

AS18101 -0 +142

AS10029 -143 +280

AS10029 -294 +145

(a) Path changes between Feb-08-2009 and Feb-09-2009

(b) Path changes between Feb-10-2009 and Feb-11-2009

Figure 8: Representation of case study I.

AS4637 instead. Just from that observation it is possible to conjec-
ture that one of these two ASes was responsible for the changes,
and in fact, considering Feb-08 and Feb-09, both ASes have the
same ‚àÜF value. On the next day almost the reverse event hap-
pens, with ASes leaving AS4637 and starting to use AS15412 as
next-hop. But it can be seen that AS4637 still has a path towards
the preÔ¨Åx and it still is used by some ASes as next-hop. This fact
indicates that AS4637 is probably not the actor responsible for the
event.

It is also necessary to observe that AS15412 and AS18101 are
not seen in our dataset at Feb-09 and Feb-10 (no paths passing
through them). Hence we cannot say exactly if the cause is one
or the other or even a link leaving one of them, narrowing down the
set of candidates to AS15412, AS18101 and AS10029 (and links).
However, in other days of the event the same structure of the Ô¨Ågures
was observed, but there were paths passing through AS15412 and
AS18101. This indicates that in fact many paths left (preferred)
AS15412 as next-hop due its actions, not AS18101 or AS10029.

Following the majority rule, PathMiner selected AS15412 as sin-
gle actor of the event and therefore, it was able to capture the dis-
cussion presented above.

7.3.2 Case study II

In this case study we explore the second event for the year of
2012 shown in Table 4. The event involves 4 preÔ¨Åxes, 65 ASes, and
occurs on 44 days during the year. Figures 9(a) and 9(b) present
the simpliÔ¨Åed dynamics of the changes for 2 days, Jan-10-2012
and Jan-11-2012. This case study seems similar to the previous
one, since we can observe that over the time ASes are alternating
their next-hops (towards the four preÔ¨Åxes) between AS35320 and
AS29632. Simply looking at those Ô¨Ågures it is possible to narrow
down the cause to one of these two ASes (or the links between them
and AS42418). The question that arises is: why did PathMiner
chose AS29632? It turns out that for many of the 44 days of the
event, some of ASes leaving next-hop AS29632 started reaching
two of the four destinations by paths not passing through AS35320.
Therefore, either AS29632 or two other ASes (at the same time)
are the causes. PathMiner identiÔ¨Åes AS29632 as actor, capturing
the idea that the simplest explanation is the most likely one.

7.3.3 Case study III

Our last case study discusses an event for which PathMiner was
not able to identify a single network element responsible for the
whole event. The event is the one on the Ô¨Årst row of Table 4 for

the year of 2005. The event involves 2 preÔ¨Åxes, 54 ASes and it
happens on 200 days of the year. However PathMiner was not able
to Ô¨Ånd a single network element responsible for changes in at least
100 days. Why did that happen? A closer look at the event shows
us that the assumptions over which PathMiner is built are not valid.
In fact, this is a strange case. Figures 10(a) and 10(b) present two
typical subgraphs describing the changes over the days of the event.
First, we note that the structure of the graph is completely differ-
ent of our two previous case studies. The second, and key, fact is
that the event contains only two preÔ¨Åxes, but we can see three gray
nodes in the Ô¨Ågures (gray nodes are those hosting the preÔ¨Åxes of
the event). Denoting those two preÔ¨Åxes by preÔ¨Åx 1 and preÔ¨Åx 2,
through data examination it was possible to see that: i) at Jan-11
preÔ¨Åxes 1 and 2 were being hosted at AS23918 and AS29257 re-
spectively; ii) at Jan-12 preÔ¨Åx 1 was being hosted at AS29257 and
at AS31050 (which does not seem to be a normal situation) and
preÔ¨Åx 2 was being hosted at AS23918; and iii) at Jan-13 preÔ¨Åxes
are hosted as at Jan-11.

Over the 200 days of the event this alternating state was repeated.
In summary, it can be seen that is hard to Ô¨Ånd one network element
that can be responsible for these changes. More speciÔ¨Åcally, our
assumption of a single actor causing the event does not seem to be
valid here ‚Äì it appears that a set of coordinated changes is being
implemented through actions of multiple ASes.

8. RELATED WORK

There is a considerable amount of literature about BGP due to its
importance to the global Internet. In this section we discuss how
PathMiner differs from existing work.

BGP event detection: BGP event detection has been studied in
a variety of ways. Most work on event detection relies on BGP
update messages in order to analyze path changes. For example,
the authors in [20] proposed a methodology to identify high impact
BGP routing changes. However their scope is different from ours,
since in their context the term high impact is related to the impact
in the network trafÔ¨Åc leaving a speciÔ¨Åc ISP and not in terms of
changes propagating throughout the network.

In [17, 16] the authors propose a way to identify temporal event
boundaries in the stream of update messages and a visualization
tool that allows users to narrow down and infer root causes. Our
work, on the other hand, does not rely on inferring the state of the
routing system by using update messages (in fact this is a hard task,
since in most cases internal AS policies are unknown). Instead, we

432AS3356 -131 +0

AS8468 -4 +4

AS6939 -20 +16

AS13237 -4 +4

AS3356 -0 +133

AS8468 -4 +4

AS6939 -16 +20

AS13237 -4 +4

AS35320 -470 +0

AS29632 -6 +667

AS35320 -0 +462

AS29632 -667 +6

AS43418 -476 +667

AS43418 -667 +468

AS50723 -115 +153

AS39307 -116 +154

AS39322 -131 +186

AS50723 -153 +113

AS39307 -154 +114

AS39322 -186 +129

(a) Path changes between Jan-10-2012 and Jan-11-2012

(b) Path changes between Jan-11-2012 and Jan-12-2012

Figure 9: Representation of case study II.

AS1299 -3 +75

AS1239 -70 +18

AS6939 -31 +2

AS6939 -2 +29

AS1299 -75 +2

AS1239 -18 +74

AS286 -86 +85

AS4725 -0 +28

AS286 -85 +85

AS29257 -150 +8

AS1273 -5 +0

AS209 -1 +3

AS31050 -0 +157

AS31050 -157 +0

AS209 -3 +1

AS29257 -8 +153

AS1273 -0 +4

AS4694 -6 +0

AS2516 -7 +24

AS4725 -30 +0

AS2516 -24 +9

AS4694 -0 +5

AS17675 -42 +21

AS4716 -69 +94

AS4716 -94 +68

AS17675 -21 +41

AS23918 -111 +115

AS23918 -115 +109

(a) Path changes between Jan-11-2005 and Jan-12-2005

(b) Path changes between Jan-12-2005 and Jan-13-2005

Figure 10: Representation of case study III.

use real daily snapshots of the network to perform a large scale
event identiÔ¨Åcation.

The authors of [11] use tensor factorization techniques (real, not
boolean) to infer events in the stream of BGP updates. However,
since they use a path-based representation they are restricted to a
small set of monitors. Moreover, since they work with data ob-
tained at the granularity of minutes their strategy is not able to
identify large scale events involving hundreds of sources, possibly
months apart.

Finally, it is important to mention that working with BGP up-
dates demands extra processing in order to clean the data. In our
approach we use BGP RIBs, i.e., snapshots of the interdomain rout-
ing system , which avoids the complex process of update messages
cleaning and allows PathMiner to scale over long timescales.

Root cause analysis: the second component of PathMiner, de-
scribed in Section 7, consists of a technique to identify (or at least
narrow down) possible ASes (or links) triggering large scale events.
Although sounding related to root cause analysis, as in [14] and
[10], it is important to remark that our requirements and assump-
tions differ signiÔ¨Åcantly. On one hand, general root cause iden-
tiÔ¨Åcation systems are real time, work with BGP update messages
(sometimes with information coming from external sources) and
are interested at identifying causes of any path changes. On the
other hand, differently of PathMiner, those systems are not capa-
ble, of identifying large events and narrowing down causes using
just routing tables.

BGP path discovery: as mentioned in Section 8 our datasets
do not contain paths from every source to every destination and
even for those we have, the issue of missing data arises. Therefore,
we note that PathMiner could beneÔ¨Åt from techniques that allow it
to have better snapshots of the global interdomain routing system.
Among recent works on this direction are [15], [13] and [12].

Boolean Tensor Factorization: in this work we did not aim at a
general approach for solving instances of the BTF problem coming
from an abitrary application. In fact, among recent works trying to
solve the general BTF problem are [7] and [9]. The former is de-
signed to Ô¨Ånd blocks of closed relations (i.e., equivalent to blocks
with density 1), which is too strong a requirement for our appli-
cation. The latter would suit our needs, but although it does not
impose any formal requirement for volume and density, unfortu-
nately the available implementation did not scale for our datasets
due to the amount of data analyzed by PathMiner.

9. CONCLUSIONS AND FUTURE WORK

In this work we presented PathMiner, a system capable of identi-
fying and analyzing high impact events in the interdomain routing
system of the Internet. We started by giving a formal deÔ¨Ånition of
the problem and discussing how to prepare the data and how to deal
with missing data. In its Ô¨Årst phase PathMiner has the advantage
of working with a next-hop representation of the AS-level Internet,
which allows PathMiner to naturally combine paths obtained from
multiple sources.

In order to identify events we proposed a new heuristic to solve
the Boolean Tensor Factorization problem, since algorithms cur-
rently available in the literature were not scalable to our datasets.
Using datasets spanning 9 years of routing in the Internet we
showed that PathMiner is able to Ô¨Ånd many large and dense events.
Next, we addressed the challenge of discovering network ele-
ments (ASes or AS-links) that were likely the actors responsible
for the event occurrence. Our methodology, based on concepts bor-
rowed from classiÔ¨Åcation theory, was able to identify possible event
causes in most of the events we found. One key aspect of Path-
Miner is its ability to look at the same event re-occurring many
times, which helps the process eliminating event cause candidates.
Finally, we presented 3 case studies, for large events, exemplifying
all these aspects of PathMiner.

433To the best of our knowledge, PathMiner is the Ô¨Årst system ca-
pable of exploring the amount of information we analyzed, Ô¨Ånding
daily large routing events and recognizing that such events re-occur
many times during the period of one year, in some cases months
apart.

In future work we intend to address the need to better under-
stand cases where PathMiner is not capable of Ô¨Ånding a single ac-
tor responsible for an event (as exempliÔ¨Åed in our third case study).
Moreover, we are interested in the possibility of using PathMiner to
explore persistent routing changes, i.e., considering only changes
that were not quickly undone in the system. Such studies might
have the potential to expose interesting structural reorganization of
the AS-level Internet.

10. ACKNOWLEDGEMENTS

This material is based upon work supported by the National
Science Foundation under grant numbers CNS-0905565, CNS-
1018266, CNS-1012910, and CNS-1117039, and supported by the
Army Research OfÔ¨Åce under grant W911NF-11-1-0227. We are
grateful to the anonymous reviewers and to our shepherd, Alex
Snoeren, for their valuable comments. We also thank Evimaria
Terzi and Dora Erdos for the helpful discussions.

11. REFERENCES

[1] Hadoop. http://hadoop.apache.org.
[2] Ripe‚Äôs routing information service raw data project.

http://www.ripe.net/data-tools/stats/
ris/ris-raw-data.

[3] Spark. http://spark.apache.org.
[4] University of oregon route views project.

http://www.routeviews.org.

[5] Michael W. Berry, Murray Browne, Amy N. Langville,

V. Paul Pauca, and Robert J. Plemmons. Algorithms and
applications for approximate nonnegative matrix
factorization. Computational Statistics & Data Analysis,
52(1):155‚Äì173, September 2007.

[6] A. Broido and kc claffy. Analysis of RouteViews BGP data:

policy atoms. In NRDM, 2001.

[7] Lo√Øc Cerf, J√©r√©my Besson, C√©line Robardet, and

Jean-Fran√ßois Boulicaut. Closed Patterns Meet n-ary
Relations. ACM Trans. Knowl. Discov. Data, 3(1), 2009.

[8] Andrzej Cichocki, Rafal Zdunek, Anh Huy Phan, and

Shun-ichi Amari. Nonnegative Matrix and Tensor
Factorizations: Applications to Exploratory Multi-way Data
Analysis and Blind Source Separation. Wiley Publishing,
2009.

[9] D√≥ra Erd√∂s and Pauli Miettinen. Walk ‚Äôn‚Äô Merge: A Scalable
Algorithm for Boolean Tensor Factorization. In Proceedings
of the 13th International Conference on Data Mining, ICDM
‚Äô13, pages 1037‚Äì1042. IEEE, 2013.

[10] Anja Feldmann, Olaf Maennel, Z. Morley Mao, Arthur

Berger, and Bruce Maggs. Locating Internet Routing
Instabilities. In Proceedings of SIGCOMM Conference,
SIGCOMM ‚Äô04, pages 205‚Äì218. ACM, 2004.

[11] K. Glass, R. Colbaugh, and M. Planck. Automatically

identifying the sources of large Internet events. In
Intelligence and Security Informatics (ISI), 2010 IEEE
International Conference on, pages 108‚Äì113, 2010.

[12] Enrico Gregori, Alessandro Improta, Luciano Lenzini,

Internet Measurement Conference, IMC ‚Äô12, pages 253‚Äì264.
ACM, 2012.

[13] Yihua He, Georgos Siganos, Michalis Faloutsos, and

Srikanth Krishnamurthy. Lord of the Links: A Framework
for Discovering Missing Links in the Internet Topology.
IEEE/ACM Trans. Netw., 17(2):391‚Äì404, April 2009.

[14] Umar Javed, Italo Cunha, David Choffnes, Ethan

Katz-Bassett, Thomas Anderson, and Arvind Krishnamurthy.
PoiRoot: Investigating the Root Cause of Interdomain Path
Changes. In Proceedings of SIGCOMM Conference,
SIGCOMM ‚Äô13, pages 183‚Äì194. ACM, 2013.

[15] Akmal Khan, Taekyoung Kwon, Hyun-chul Kim, and
Yanghee Choi. AS-level Topology Collection Through
Looking Glass Servers. In Proceedings of the 2013 Internet
Measurement Conference, IMC ‚Äô13, pages 235‚Äì242. ACM,
2013.

[16] Mohit Lad, Dan Massey, and Lixia Zhang. Visualizing

Internet Routing Changes. IEEE Transactions on
Visualization and Computer Graphics, 12(6):1450‚Äì1460,
November 2006.

[17] Mohit Lad, Lixia Zhang, and Daniel Massey. Link-rank: A

Graphical Tool for Capturing BGP Routing Dynamics. In
Proceedings of the Network Operations and Management
Symposium, NOMS ‚Äô04, pages 627‚Äì640. IEEE, 2004.

[18] Pauli Miettinen. Boolean Tensor Factorizations. In

Proceedings of the 11th International Conference on Data
Mining, ICDM ‚Äô11, pages 447‚Äì456. IEEE, 2011.

[19] Y. Rekhter and T. Li. A Border Gateway Protocol (BGP-4).

RFC Editor, 1995.

[20] Jian Wu, Zhuoqing Morley Mao, Jennifer Rexford, and Jia

Wang. Finding a Needle in a Haystack: Pinpointing
SigniÔ¨Åcant BGP Routing Changes in an IP Network. In
Proceedings of the Symposium on Networked Systems
Design & Implementation, NSDI‚Äô05, pages 1‚Äì14. USENIX
Association, 2005.

Appendix A - 3D-FACTORIZATION Algorithm

Algorithm 3: 3D-FACTORIZATION

Data: S, set of triples of the form (I, J, K), and thresholds

Œ≥ and Œ≤

1 F ‚Üê ‚àÖ
2 while S 6= ‚àÖ do
3
4
5

s ‚Üê pick and do not remove an element of S
S‚Ä≤ ‚Üê {x : x ‚àà S and dB(x, s) ‚â§ Œ≥}
Ô¨Ånd maximal S‚Ä≤‚Ä≤ ‚äÜ S‚Ä≤ such that max
x,y‚ààS ‚Ä≤‚Ä≤

dB(x, y) ‚â§ Œ≥

6
7
8
9

10
11
12
13

14
15
16
17

if |S‚Ä≤‚Ä≤| > 1 then

y ‚Üê COMBINE-UNION(S‚Ä≤‚Ä≤)
S ‚Üê S\S‚Ä≤‚Ä≤
S ‚Üê S ‚à™ {y}

else

F ‚Üê F ‚à™ {s}
S ‚Üê S\{s}
S‚Ä≤ ‚Üê {x : x ‚àà S, sB(x, s) ‚â• Œ≤ and
COMBINE-INTER(s, x) 6= s}
if |S‚Ä≤| > 0 then

s‚Ä≤ ‚Üê arg maxx‚ààS ‚Ä≤ sB(s, x)
y ‚Üê COMBINE-INTER(s, s‚Ä≤)
S ‚Üê S ‚à™ {y}

Lorenzo Rossi, and Luca Sani. On the incompleteness of the
as-level graph: A novel methodology for bgp route collector
placement. In Proceedings of the 2012 ACM Conference on

18 return F

434