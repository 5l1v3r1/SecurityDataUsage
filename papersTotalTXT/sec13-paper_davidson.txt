FIE on Firmware: Finding Vulnerabilities in 
Embedded Systems using Symbolic Execution

Drew Davidson, Benjamin Moench, Somesh Jha, and Thomas Ristenpart,  

University of Wisconsin—Madison

Open access to the Proceedings of the 22nd USENIX Security Symposium is sponsored by USENIXThis paper is included in the Proceedings of the 22nd USENIX Security Symposium.August 14–16, 2013 • Washington, D.C., USAISBN 978-1-931971-03-4Finding Vulnerabilities in Embedded Systems using Symbolic Execution

FIE on Firmware:

Drew Davidson
Thomas Ristenpart
University of Wisconsin–Madison, {davidson,bsmoench,jha,rist}@cs.wisc.edu

Benjamin Moench

Somesh Jha

Abstract
Embedded systems increasingly use software-driven
low-power microprocessors for security-critical settings,
surfacing a need for tools that can audit the security of
the software (often called ﬁrmware) running on such de-
vices. Despite the fact that ﬁrmware programs are of-
ten written in C, existing source-code analysis tools do
not work well for this setting because of the speciﬁc ar-
chitectural features of low-power platforms. We there-
fore design and implement a new tool, called FIE, that
builds off the KLEE symbolic execution engine in order
to provide an extensible platform for detecting bugs in
ﬁrmware programs for the popular MSP430 family of
microcontrollers. FIE incorporates new techniques for
symbolic execution that enable it to verify security prop-
erties of the simple ﬁrmwares often found in practice.
We demonstrate FIE’s utility by applying it to a corpus
of 99 open-source ﬁrmware programs that altogether use
13 different models of the MSP430. We are able to ver-
ify memory safety for the majority of programs in this
corpus and elsewhere discover 21 bugs.
1
Embedded microprocessors are already ubiquitous, pro-
viding programmatic control over critical, increasingly
Internet-connected physical infrastructure in consumer
devices, automobiles, payment systems, and more. Typ-
ical low-power embedded systems combine a software-
driven microprocessor, together with peripherals such as
sensors, controllers, etc. The software on such devices is
referred to as ﬁrmware, and it is most often written in C.
The use of ﬁrmware exposes embedded systems to
the threat of software vulnerabilities, and researchers
have recently discovered exploitable vulnerabilities in
a wide variety of deployed embedded ﬁrmware pro-
grams [12, 18, 19, 21, 22, 24, 27]. These bugs were found
using a combination of customized fuzz testing and man-
ual reverse engineering, requiring large time investments
by those with rare expertise.

Introduction

To improve ﬁrmware security, one possible approach
would be to use the kinds of source-code analysis tools
that have been successful in more traditional desktop and
server settings (e.g., [2, 4, 8, 9, 11, 13, 17, 26, 28, 31, 36]).
These tools, however, prove insufﬁcient for analyzing
ﬁrmware:
the microcontrollers used in practice have a
wide range of architectures, the nuances of which frus-
trate tools designed with other architectures in mind
(most often x86). Firmware also exhibits characteris-
tics dissimilar to more traditional desktop and server pro-
grams, such as frequent interrupt-driven control ﬂow and
continuous interaction with peripherals. All this suggests
the need to develop new analysis tools for this setting.

We initiate work in this space by building a system,
called FIE, that uses symbolic execution to audit the se-
curity of ﬁrmware programs for the popular MSP430
family of 16-bit microcontrollers. We have used FIE
to analyze 99 open-source ﬁrmware programs written
in C and of varying code complexity. To do so, FIE
had to support 13 different versions of the MSP430
family of 16-bit RISC processors. Our analyses ulti-
mately found 20 distinct memory-safety bugs and one
peripheral-misuse bug.

We designed FIE to support analysis of all potential
execution paths of a ﬁrmware. This means that, modulo
standard but important caveats (see Section 6), FIE can
verify security properties hold for the relatively simple
ﬁrmware programs often seen in practice. For example,
we verify memory safety for 53 of the 99 ﬁrmware pro-
grams in our corpus.
Overview of approach: FIE is based on the KLEE sym-
bolic execution framework [10]. In addition to the en-
gineering efforts required to make KLEE work at all for
MSP430 ﬁrmware programs, we architected FIE to in-
clude various features that render it effective for this new
domain. First, we develop a modular way to specify the
memory layout of the targeted MSP430 variant, the way
in which special memory locations related to peripherals
should be handled, and when interrupt handlers should

USENIX Association  

22nd USENIX Security Symposium  463

be invoked. This all allows analysts to ﬂexibly detail pe-
ripheral behavior. We provide a default speciﬁcation that
models worst-case behavior of all peripherals and inter-
rupts. This default enables analysis without any knowl-
edge or access to (simulators of) individual microcon-
trollers or peripheral components, while ensuring con-
sideration of any possible deployment environment.

Small ﬁrmware programs appear to arise frequently
(our corpus has many that have less than 100 lines of
code) and for these we might hope to achieve complete
analyses, meaning all possible paths are checked. Even
with very small ﬁrmware programs, however, deep or
inﬁnite loops arise often and force the analysis to visit
already-analyzed states of the symbolic execution. We
therefore use a technique called state pruning [6], which
detects when a program state has been previously ana-
lyzed, and if so, removes it from further consideration.
Our realization of pruning keeps a history of all changes
made to memory at each program point, and while sim-
pler than prior approaches (see Section 7) it proves ef-
fective. We also introduce a new technique called mem-
ory smudging, which heuristically identiﬁes loop coun-
ters and replaces them with unconstrained symbolic vari-
ables. While smudging can introduce false positives, our
experiments show them to be rare. Together, pruning and
smudging signiﬁcantly improve code coverage and sup-
port the ability to analyze all possible paths of simpler
ﬁrmware programs.
Summary: This paper has the following contributions:
• We provide (to the best of our knowledge) the ﬁrst
open-source tool designed for automated security
analysis of ﬁrmware for the widely used MSP430 mi-
crocontrollers.
• We explore use of state pruning and memory smudg-
ing to enhance coverage of symbolic execution and to
attempt to verify the absence of classes of bugs. Ul-
timately, FIE is able to verify memory safety on 53
open-source ﬁrmware programs.
• FIE found 21 distinct bugs in the ﬁrmware corpus,
many of which appear to be exploitable memory-
safety violations.

To do these analyses at scale, we developed a system for
managing FIE-powered analyses on Amazon EC2 [1].
The source code for FIE, the ﬁrmware corpus, and the
EC2 virtual machine images and associated management
scripts will all be made publicly available from the ﬁrst
author’s website.1
Outline: The remainder of this paper is structured as
follows: In Section 2, we give background on embed-
ded systems and the MSP430 family, describe a corpus
of open-source ﬁrmware that we gathered, and explain

1http://pages.cs.wisc.edu/davidson/fie

some of the key challenges that must be overcome for
use of symbolic execution in our context. We then give
a high-level overview of how FIE works in Section 3,
and explain its mechanisms in greater detail in Section 4.
We evaluate FIE on the corpus of ﬁrmware examples and
discuss the vulnerabilities found in Section 5. Finally we
discuss limitations of FIE in Section 6, related work fur-
ther in Section 7 and conclude in Section 8.
2 Background and Analysis Targets
Our system, FIE, analyzes embedded ﬁrmware programs
for the MSP430 family of microcontrollers using sym-
bolic execution [2, 8–11, 13, 17, 28, 31, 36]. In this sec-
tion, we describe details of the MSP430 family, discuss
a representative corpus of ﬁrmware programs that we
gathered, review symbolic analysis, and explore the chal-
lenges faced in attempting to use existing tools for anal-
ysis of ﬁrmware programs.
2.1 MSP430 Microcontrollers
We chose Texas Instruments’ (TI’s) MSP430 family of
microcontrollers as our analysis target because of its
popularity. MSP430s already ﬁnd use in security crit-
ical applications such as credit-card point of sale sys-
tems, smoke detectors, motion detectors, seismic sen-
sors, and more [34]. We believe porting our approach to
other, similar low-power microprocessor families would
be straightforward.
Architecture and memory layouts: MSP430s use a
custom, but simple, RISC instruction set, and have a
von Neumann architecture (instructions and data share
the same address space) with at least 16-bit addressing.
MSP430s have a set of CPU registers, which are accessed
via special memory locations. There are over 500 differ-
ent MSP430 microcontroller products. One example is
the MSP430G2x53 series, which consists of 5 different
chips. These have from 1 kB to 16 kB of non-volatile
ﬂash memory and from 256 to 512 bytes of volatile ran-
dom access memory. The memory layouts for the differ-
ent models are distinct, meaning some physical addresses
are invalid on one variant while valid on another.
Hardware peripherals: MSP430 microcontrollers are
used in conjunction with both built-in and external hard-
ware peripherals. Built-in peripherals include ﬂash
memory,
interfaces and
the like, whereas external peripherals (USB hardware,
modems, sensors, etc.) must be connected to the micro-
controller via I/O pins. MSP430s have a limited number
of I/O pins, and so they are multiplexed amongst vari-
ous functions. Usually, one function is general purpose
I/O and the other is an internal function. For applications
that need to use many different functions of the device, a
given pin may be switched between its multiplexed du-
ties several times during execution. Accessing periph-

timers, power management

464  22nd USENIX Security Symposium 

USENIX Association

2

1
2
3
4
5
6

FCTL3 = FWKEY ;
FCTL1 = FWKEY + ERASE ;
* F_ptr = 0;
while ( FCTL3 & BUSY );
FCTL1 = FWKEY ;
FCTL3 = FWKEY + LOCK ;

Figure 1: Code excerpt that clears a ﬂash segment

erals works via memory-mapped I/O or special registers
(which are, in turn, accessed via special memory loca-
tions). We refer to all memory that serves internal or
external peripherals as special memory.

Peripherals often have intricate semantics. For exam-
ple, consider accessing ﬂash memory, which is a built-
in peripheral for nearly all MSP430 models. Figure 1
gives a code snippet taken from the USB drivers in our
corpus (see next section). This code clears a segment
of ﬂash memory using various special registers, which
is required before any writes to that segment can occur:
ﬂash control register 3 (FCTL3) must be set to the spe-
cial ﬂash write key (FWKEY) to unlock the memory and
allow writes to it, and ﬂash control register 1 (FCTL1)
must contain the FWKEY value masked with the particu-
lar value to indicate the type of write. Finally, after the
memory is erased, the ﬂash memory is re-locked by as-
signing the special value FWKEY + LOCK.
Firmware programming: Most MSP430 programs are
written in C, using one of three compilers recommended
by TI: IAR, CCS, and msp430-gcc. The ﬁrst two com-
pilers are commercial products packaged in IDEs, while
the third is a port of the gcc toolchain to the MSP430.
Each of these tools provides a number of extensions to
C. Unfortunately, the extensions do not agree on a single
syntax. As a result, many programs conditionally include
code based on the compiler that is being used. we chose
to base our tool on the msp430-gcc syntax as it is popu-
lar, open-source, and has straightforward extensions.

Embedded ﬁrmware usually operates by setting up
conﬁguration for the program and then spinning in an
inﬁnite loop while waiting for input from the environ-
ment. These event-driven programs use interrupt han-
dlers, busy waiting (e.g., line 4 in Figure 1), and the like
to drive computation in response to I/O from peripherals,
and so interrupt handlers often contain the bulk of the
program logic. A typical ﬁrmware will initialize several
registers specifying which interrupts to activate and then
go to sleep either by setting the chip to a low-power sleep
mode or by entering an explicit inﬁnite loop.
2.2 Firmware Corpus
As mentioned, MSP430s are used in a wide variety of
security-critical applications. The diversity of appli-
cations is reﬂected in the ﬁrmware programs found in

practice, ranging from simple programs for controlling
some external hardware peripheral on up to feature-rich
lightweight operating systems such as Contiki [35]. To
have a concrete set of analysis targets and as well edu-
cate our design of FIE, we have gathered a corpus of 99
open-source MSP430 ﬁrmware programs, which we now
discuss further.
Cardreader: The ﬁrst ﬁrmware in our corpus is
cardreader, a secure credit card reader designed for the
MSP430g2553 and written by one of the authors inde-
pendently of the development of FIE. This was motivated
by recent attacks against smartphone-based point-of-sale
MSP430 devices [20]. Our ﬁrmware assumes the pres-
ence of a magnetic credit card stripe reader attached to
port 1 (conﬁgured for general purpose I/O), and a UART
connection on port 2 (to transmit gathered credit card
data). The cardreader gets as input card data from the
stripe reader, loads a stored cryptographic key from ﬂash
memory, and applies AES encryption to the card data
before writing the result to the UART. cardreader is fully
functional, with 1,883 lines of C code as computed by
the cloc utility, and incorporates many of the MSP430
programming constructs that, as we will see, can thwart
traditional symbolic-execution-based analysis. We made
no efforts to tailor the code to be amenable to analysis
by FIE. We also performed extensive manual audit of
the code to verify the absence of memory or peripheral-
misuse errors.
USB drivers: We additionally use two USB driver
ﬁrmware programs, CDC Driver and HID Driver, taken
from the TI-supplied USB developers package. These
programs include a full USB code stack, and include
7,453 and 7,448 lines of C code, respectively. The partic-
ular programs we chose exercise the CDC (Communica-
tions Device Class) and HID (Human Interface Device)
USB classes, which represent different device types in
the USB speciﬁcation. The CDC-using ﬁrmware, for ex-
ample, takes string commands from an attached terminal
program on a host PC, uses these commands to toggle
the LED in various ways, and sends back an acknowledg-
ment string to the host device. The code that we tested
was written for the IAR compiler, but we manually wrote
Makeﬁles to compile the source code for our analysis.
Community projects and GitHub: In order to increase
the size of our corpus, we searched for open source
projects both on the TI MSP430 Community Projects
website [33] and GitHub. For the former, we manually
crawled the website, and downloaded all projects with
a Makeﬁle, of which we found 12 that compiled prop-
erly. For the latter, we used the GitHub API to automat-
ically download all projects that matched the keyword
“msp430”. There were 360 such projects. Of these, we
culled out those that either: did not include makeﬁles,

USENIX Association  

22nd USENIX Security Symposium  465

3

g2553
g2452
g2231
g2221
g2211
g2001
f5529
f5521
f5310
f2013
f2012
f1612
f149

0

10

20

30

40

LOC
1− 50
51− 100
101− 200
201− 500
501− 1000
1001− 2000
≥ 2001

#
36
13
28
9
7
2
4

Table 2: Number of ﬁrmware program in the corpus (left) tar-
geting the indicated MSP430 models and (right) having the
number of lines of C code in the given range.

were not written in C, or did not compile properly for
the MSP430 using their given makeﬁles (this includes
projects such as desktop utilities for connection to an
MSP430, and thus matched the keyword without being
applicable to FIE). After this culling we had 83 ﬁrmware
programs.
Contiki: Finally, we add to the corpus Contiki [35],
which provides an operating system for microcontrollers.
To use Contiki, one writes an application against it as
a library, which is then statically linked for a complete
ﬁrmware. Since we need an entrypoint to the library
for testing, we use a “hello world” example program in-
cluded with the Contiki distribution. The resulting C ﬁle
for the ﬁrmware has only 10 lines of code, but this links
against other, larger modules. There are over 200,000
lines of C code in the full Contiki source tree. We
note that Contiki supports many architectures, including
(amongst others) motes that support MSP430x, an ex-
tension of the MSP430 that supports 20-bit addresses.
FIE only supports basic 16-bit MSP430, and thus can-
not run on these motes. Fortunately, Contiki has sup-
port for a basic MSP430 backend: the esb, based on the
msp430f1612. We use this backend in our analysis.

The table in Figure 2 shows a break down of the num-
ber of ﬁrmware programs whose number of lines of code
(computed using cloc, including C and C/C++ header
ﬁles) falls in the indicated range. As can be seen, the
range of sizes of these ﬁrmware programs is large, but
most are 2,000 lines of C code or less. This is not sur-
prising given that MSP430s are often used to drive rela-
tively simple controllers or sensors: our ﬁrmware set in-
cludes the large number of small hobbyist projects found
on GitHub and the TI community projects webpage. A
breakdown of the architectures targeted by ﬁrmware pro-
grams in the corpus is shown in the graph in Figure 2.
(When a single ﬁrmware supports multiple target archi-
tectures, we restrict attention to one, picked arbitrarily.)
2.3 Symbolic Execution and Challenges
To date, ﬁnding vulnerabilities in embedded ﬁrmware
programs has relied upon specialized fuzzing and reverse
engineering [12, 18, 20–22, 24], which requires signiﬁ-

cant manual effort and knowledge of the ﬁrmware under
analysis. Almost all previous research on more general
software analysis tools (see Section 7) has not focused
on the setting of embedded microcontrollers, and so the
relatively unique features of our context (relatively small
ﬁrmware sizes, large diversity of architectures, and com-
plex environmental interactions) mean that traditional
approaches need to be revisited. We initiate such work,
focusing in particular on symbolic execution. We feel
it to be well-suited to ﬁrmware analysis, allowing ﬁne-
grained modeling of architectural nuances, ﬂexibility in
analysis approach, and typical limitations of symbolic
analysis (i.e., scalability) may not prove to be as much
of an issue for the small ﬁrmware programs seen in prac-
tice. We leave exploration of other approaches (e.g.,
static analysis, concolic execution, etc.) to future work.
Symbolic execution: In symbolic execution, variables
corresponding to inputs to a program are treated as sym-
bolic. This means one stores a representation of all of
the possible values that each symbolic variable may take
on. The program is then executed symbolically using an
execution engine. A symbolic state (just state from now
on) is a current program counter, other register contents,
stack frames, and memory contents. The latter three may
contain a mix of concrete values or symbolic variables
and the constraints over those variables. From an ini-
tial state, the engine executes the program one instruc-
tion at a time and updates the state appropriately, chang-
ing concrete values or possibly adding constraints upon
symbolic variables.

Should execution reach a control ﬂow decision such
as a branch, the executor uses a SAT solver to deter-
mine what are the possible next instructions. A new state
is generated for each possible next instruction, with ap-
propriate constraints for the outcome. For example, if a
variable x is assigned symbolic variable α (that is uncon-
strained), and a branch if (x < 5) is encountered, two
child states will be spawned: the ﬁrst executes inside the
if condition with the constraint α < 5, and the second
executes after the if condition with the constraint α ≥ 5.
Once multiple states are active, the engine decides dur-
ing each iteration which state to progress, based on some
state selection heuristic.
(Complete) analyses: Analysis is performed by inves-
tigating each state for violations of some speciﬁc prop-
erties. A common choice is memory-safety violations,
which can be checked by ensuring that all reads and
writes are to properly allocated memory ranges. Should
a state violate such a property, the execution halts and
outputs one of the paths that could lead to this state as
well as concrete values that drive the program’s execu-
tion along that path. The latter is facilitated by using the
SAT solver to provide a solution for the formulas describ-
ing constraints on the symbolic variables.

466  22nd USENIX Security Symposium 

USENIX Association

4

It is well known that symbolic execution can, in the-
ory, provide both sound and complete analyses of some
programs. A sound analysis does not emit any false pos-
itives — bug reports that are spurious. We refer to a
symbolic-execution-based analysis as being complete if
it covers all of the ﬁnitely many possible symbolic states.
Obviously complete analyses are intractable for many
programs. Past work on symbolic execution has there-
fore focused on achieving high code coverage, meaning
the number of executable lines of code in a program that
have been symbolically executed along any path. High-
coverage symbolic execution enables ﬁnding bugs along
the paths that are explored. One can also use the explored
paths to generate inputs for use in testing. In our setting
of resource-constrained, small ﬁrmware programs, there
is hope that in addition to high code coverage, we may
be able to sometimes achieve complete analyses as well.
Symbolic analysis (even when sound and complete)
has inherent limitations, stemming from the possibility
of bugs in the analysis engine or compilers used, source
code that depends on memory address values, use of in-
line assembly, etc. We discuss these limitations more in
Section 6.
Challenges: We use the symbolic execution system
KLEE [10] as the foundation for FIE. Our problem do-
main, however, necessitates rethinking several aspects of
KLEE’s design and use. In particular, we face the follow-
ing three key challenges:

Challenge 1 (architecture ambiguity): Firmware pro-
grams make a number of assumptions about the hard-
ware, including the overall layout of memory and loca-
tion of memory-mapped hardware controls. These as-
sumptions are not made explicit in a ﬁrmware’s source
code. For example, it is common for a program to store
persistent conﬁguration data at a hard-coded memory ad-
dress in ﬂash. An architecture-agnostic analysis, or one
tailored to x86 environments (as most prior tools are),
would view code using this feature as having read from
uninitialized memory. Making matters worse, the wide
diversity of architectures mean that we will need a way
to conﬁgure an analysis to the architectures of interest.

Challenge 2 (intensive I/O): Firmware programs are
highly interactive with the environment throughout the
lifecycle of the program and are designed to interact with
a huge diversity of peripherals. Handling external inputs
to a program is a well-studied issue in prior symbolic
execution contexts, for example KLEE implements func-
tions to determine for the symbolic executor the outcome
of (a subset of) common Linux operating system calls.
In our setting, the peripheral interface is via special reg-
isters and memory-mapped I/O and there exists a huge
diversity of potential peripheral behaviors. This makes
our setting closer to the one targeted by SymDrive, which
uses the S2E [14] symbolic execution system to analyze

x86 Linux kernel drivers without hardware [26]. Like
SymDrive, we need to support analysis without (simula-
tors of) peripherals and often without even knowing the
intended peripheral. When a peripheral and its behavior
are known, we should support the detection of (what we
call) peripheral misuse bugs, in which a ﬁrmware incor-
rectly implements the (sometimes complex) operations
involving some peripheral.

Challenge 3 (event-driven programming): The event-
driven model of programming used for ﬁrmware is prob-
lematic for symbolic execution because deep or inﬁnite
loops are frequent, and most program logic happens in,
or as a direct result of, interrupt handlers. S2E and
SymDrive both dealt with the frequent use of loops in
code, via path selection heuristics or loop elision. These
approaches do not allow complete analyses, which we
hope to sometimes achieve in our setting. We note that
since interrupts are so crucial to the operation of the
program, failure to follow possible control ﬂow paths
through interrupt handlers will result in very low cover-
age results. Furthermore, disregarding the circumstances
under which interrupts can occur may cause infeasible
paths to be explored in the analysis. At the same time,
the number of possible paths that can occur in the pro-
gram due to interrupts causes state space explosion as, in
the worst case, we must consider every instruction as a
potential branch.
3 Overview of FIE
Our main contribution is FIE, an extensible tool
symbolic-execution-based analysis of MSP430
for
It is based on KLEE [10], but with signiﬁ-
ﬁrmware.
cant modiﬁcations and embellishments to the frontend
and core engine as we will explain. In this initial work
we focus on analyzing memory safety of ﬁrmware pro-
grams, the lack of which has been exploited in many of
the recent security exploits against embedded systems.
We also report on detection of some peripheral misuse
bugs. Our analyses, by default, use a conservative threat
model in which all inputs from peripherals are untrusted.
In a departure from previous symbolic analysis sys-
tems, we target the ability to achieve complete analyses
for simple ﬁrmware programs. These appear to be com-
mon and complete analysis in this context is particularly
compelling since it means that (subject to various caveats
discussed in Section 6) one can verify security or correct-
ness properties of a ﬁrmware before deploying it. As far
as we are aware, symbolic execution has not before been
used for veriﬁcation, since in most settings it is not fea-
sible under current techniques.

This goal of completeness will guide our design in sev-
eral ways, as previous optimizations (such as path selec-
tion heuristics) do not support this goal. That said, we
will not always be able to provide veriﬁcation, and when

USENIX Association  

22nd USENIX Security Symposium  467

5

not, FIE will be useful in a more traditional role for bug-
ﬁnding and test case generation. Here its efﬁcacy will be
measured by its ability to provide high-percentage code
coverage.

In the remainder of this section, we walk through the

workﬂow of FIE, shown in Figure 3.
FIE frontend: The ﬁrst step to analyzing ﬁrmware is
compiling it to a form that can be symbolically exe-
cuted. The core of this process uses the CLANG com-
piler to LLVM bitcode. However, there are three neces-
sary features of this process that CLANG alone does not
provide: (1) deﬁnitions for compiler intrinsics that are
not expanded by CLANG; (2) deﬁnitions of standard li-
brary (stdlib) functions that would normally be included
at link time; and (3) deﬁnitions of hardware-deﬁned be-
havior. Handling (1) and (2) is straightforward: we pro-
vide a wrapper around CLANG which links pre-compiled
bitcode for functions in stdlib and for compiler intrinsics.
We took the deﬁnitions for the stdlib functions from the
msp430-gcc source code, and we manually wrote stubs
for the compiler intrinsics. As a convenience to the user,
the wrapper also embeds a token into the ﬁrmware byte-
code to specify which MSP430 variant the ﬁrmware is
compiled for, which simpliﬁes the FIE command line.
Providing deﬁnitions for hardware-deﬁned behavior is
more involved, since it is often unknown at compile time
— for instance, the ﬁrmware may interact with a variety
of peripheral devices to the chip with varying behaviors.
We address this at runtime using an analysis speciﬁca-
tion, which is describe in depth in Section 4.2.

The most predominant compiler in use for our corpus
is msp430-gcc, a version of gcc targeting the MSP430.
Fortunately the arguments to CLANG are largely compat-
ible with msp430-gcc, so we can drop in our CLANG
wrapper in place of msp430-gcc, and use many of the
original, unmodiﬁed Makeﬁles included in our corpus.
Core execution engine: Once ﬁrmware bitcode has been
generated, FIE itself can be run. To analyze the LLVM
ﬁrmware bytecode ﬁle input.bc, the user issues the
command

fie -mmodel=<mem> -imodel=<intr> input.bc
The memory spec is speciﬁed by mem, which supplies
the semantics of special memory such as attached de-
vices, ﬂash memory, etc. FIE comes with a set of de-
fault speciﬁcations which conservatively returns uncon-
strained symbolic values to any read from special mem-
ory and ignores writes. However, the user may wish to
choose a different speciﬁcation or write their own. We
discuss this process in depth in Section 4.2.

The interrupt spec intr informs the analysis of when
(and which) interrupts should be simulated to have ﬁred
at any given point in symbolic execution. Should an in-
terrupt be deemed to ﬁre, the state’s execution is pro-

firmware 
source 
code

Clang

Wrapper

firmware 
bytecode

Symbolic
Execution

Engine

intrinsic 
bytecode

stdlib 

bytecode

interrupt 

spec

memory 

spec

Figure 3: The FIE workﬂow and system components.

gressed to the appropriate interrupt handler function
within the ﬁrmware. The interrupt spec allows us to
ﬂexibly model different interrupt ﬁring behaviors. Our
default is to allow any enabled interrupt to ﬁre at every
program point. See Section 4.2.

We inherit as well

from KLEE various possible
command-line options, so the user can optionally specify
the wall-clock time to spend on the analysis, the search
heuristic to use, etc.

FIE runs a modiﬁed version of the KLEE symbolic exe-
cution engine (the executor) to perform the analysis over
the ﬁrmware bitcode. In particular, we use directly from
KLEE their existing state selection heuristics, their un-
derlying SAT solver framework, and much of their state
management code. Our major changes include porting
the entire execution engine to a 16-bit architecture, which
includes a new memory manager to ensure that all mem-
ory objects are allocate within a 16-bit value, and the use
of the memory spec and interrupt library to model exe-
cution when the engine interacts with special memory or
ﬁres an interrupt. We also implement two enhancements
to the symbolic execution engine, state pruning (Sec-
tion 4.3), ﬁrst introduced by RWset [6] and adapted to
our domain, and memory smudging (Section 4.4), which
is novel to this work. These can improve code coverage
and, for some programs, enable complete analyses.

FIE ﬁnishes when it completes an analysis by visiting
every possible state, hits the requested time limit, or ﬁnds
a memory-safety (or other) violation. In the latter case it
outputs a description of a path leading to the bug. We
call this a trace. The trace includes concrete examples of
inputs (i.e., from peripherals) that cause the ﬁrmware to
trigger the bug, and includes at what points in the exe-
cution interrupts ﬁred to cause a jump to a speciﬁc inter-
rupt handler. Currently, a trace is useful as a debugging
log, but eventually it could be used to directly drive an
MSP430 simulator to validate the potential bug.

We have additionally prepared an Amazon EC2 [1]
virtual machine image and control scripts to run analy-
ses on EC2. This made it easy to automate running FIE
on our large corpus of programs. We will publicly re-
lease an open-source version of FIE, associated scripts,
and the EC2 virtual machine image.

468  22nd USENIX Security Symposium 

USENIX Association

6

4 Details of FIE’s Architecture

4.1 Main Execution Loop

For the purposes of describing FIE, we deﬁne an exe-
cution state to be an immutable snapshot of the symbolic
execution at a given point in time. That means it includes
all values used to emulate LLVM bitcode, including a
program counter, stack frames, and global memory (used
for global variables, the heap, etc.). Any memory loca-
tion may have either a concrete value or a symbolic one,
the latter represented by a set of constraints.

In our abstraction, the main execution loop of FIE op-
erates by generating successor states from the current im-
mutable state. This allows us a history of past states,
which, looking ahead, will be useful for describing our
state pruning feature. This treatment differs from [10],
which instead described states as mutable objects trans-
formed by the symbolic execution.

Figure 4 gives high-level pseudocode for the main ex-
ecution loop. A set AS contains the active states to be
run; at the start it holds just one initial state. The loop
chooses a state from AS according to a state selection
heuristic R. For this we use the KLEE heuristic that seeks
to maximize coverage. Once a state has been selected,
new successor states may be immediately spawned ac-
cording to SpawnInterrupts. This function also outputs
a boolean shouldExec that can be set to false to force an
interrupt to ﬁre, otherwise the instruction at the current
state’s program counter is symbolically executed.

Should shouldExec be true, FIE symbolically executes
the next instruction of the current state. Here FIE in-
terposes on memory loads and stores that target mem-
ory addresses corresponding to special memory (e.g., pe-
ripherals). The addresses of special memory are pro-
vided by the memory spec as described in the next
section. Other operations are handled by Eval, which
works like KLEE’s evaluation mechanism, except with
a new special-memory-aware memory manager, support
for emulation of 16-bit ﬁrmware, and compiler intrinsics
used by msp430-gcc.

Each of SpecLoadEval, SpecStoreEval, and Eval must
check that security properties are satisﬁed. Should one
fail, a warning will be generated and the set of succes-
sors S output by the evaluation function will be empty.
This allows execution to continue, along other paths,
even after one path leads to an error.

The set of possible successor states SS is then taken
to be the union of those output by SpawnInterrupts and
one of the eval functions. In a normal symbolic execu-
tion engine, the full set SS would be added to AS. FIE
works a bit differently due to state pruning and memory
smudging as we explain in Sections 4.3 and 4.4.

Dequeue S from AS according to R
(shouldExec,Sint) ← SpawnInterrupts(S)
if shouldExec then

Let p be the program counter of S
Let I be the instruction pointed to by p
if I is a load to special memory then

else if I is a write to special memory then

S ← SpecLoadEval(I,S)
S ← SpecStoreEval(I,S)
S ← Eval(I,S)
PS p ← PS p ∪{S}
SS ← Sint ∪S
for all S(cid:26) ∈ SS do

1: AS = {Sinit}
2: while AS (cid:29)= ∅ do
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:

else

Let p(cid:26) be the program counter of S(cid:26)
if Prune(S(cid:26),PS p(cid:26) ) = false then

S(cid:26)(cid:26) ← MemorySmudge(S(cid:26),PS p(cid:26) )
AS ← AS ∪ S(cid:26)(cid:26)

Figure 4: Pseudocode of FIE’s main execution loop.

4.2 Modeling Chips and Peripherals
FIE must be aware of various aspects of the target ar-
chitecture, including what are valid memory addresses,
whether they correspond to special memory locations,
and how interrupt ﬁring should be simulated. With over
400 chips in the MSP430 family, hard-coding this infor-
Instead, FIE is conﬁg-
mation would be cumbersome.
ured at runtime to work for particular models of chips,
external peripherals, and interrupt ﬁring.
In this sec-
tion, we discuss the details of writing an analysis speci-
ﬁcation ﬁle, together with a memory spec and interrupt
spec. Combined these serve as a layer of abstraction be-
tween the symbolic execution engine and the actual tar-
get chip’s hardware details.
Analysis speciﬁcation: When FIE is run, the analyst in-
dicates the target architecture on the command line. In
turn FIE loads an associated analysis speciﬁcation ﬁle,
which is a plaintext ﬁle adhering to a simple format and
specifying how the analysis should be conﬁgured. An
example is shown in Figure 5.

Recall that each MSP430 chip has memory locations
that correspond to on-chip peripheral addresses. As
well there are other hardware speciﬁcs, e.g., the loca-
tion and length of non-volatile ﬂash memory segments.
These memory locations differ amongst chips. For exam-
ple, PORT 0 input resides at memory location 0x0020
on the MSP430G2221, but resolves to 0x200 on the
MSP430F5521. This information is generally not in-
cluded in ﬁrmware source-code. The speciﬁcation ﬁle
therefore includes information on the layout of memory
and what addresses correspond to special memory. In the
example, the ﬁle ﬁxes the total size of memory on line 1,

USENIX Association  

22nd USENIX Security Symposium  469

7

layout 0 x10000
range 0 x1080 0 x10bf flash
range 0 x10c0 0 x10ff flash
addr P1IN 0 x0020 1
addr P1OUT 0 x0021 1
addr P1DIR 0 x0022 1
addr P1IFG 0 x0023 1
i n t e r r u p t P O R T 2 _ I S R c h e c k _ P O R T 2

Figure 5: MSP430g2553 analysis speciﬁcation excerpt

speciﬁes ﬂash regions on lines 2 and 3, and sets the lo-
cations and sizes of several special memory addresses
on lines 4–7. The ﬁnal line indicates that the function
check PORT2 is used to determine when interrupts han-
dled by PORT2 ISR ﬁre.

For

this

is

any MSP430 chip that

supported by
layout ﬁle can be synthesized
msp430-gcc,
automatically from ﬁrmware source code (for ISRs) and
ﬁles included in the compiler. While we could therefore
have made speciﬁcations completely internal, we expose
the layout ﬁle explicitly to allow an analyst to modify
the hardware model if desired.

The chip layout speciﬁcation explicitly ﬁxes architec-
ture details that are implicit in ﬁrmware, but it does not
specify the actual behavior of these special features, such
as when to ﬁre interrupts and the behavior of special
memory. These are handled by the memory and inter-
rupt speciﬁcations.
Memory spec: The expected functionality of special
memory locations is not available in a ﬁrmware, and of-
ten not really ﬁxed until the device is deployed with at-
tached hardware peripherals. Thus, FIE uses a library of
functions that, together, form a model of special mem-
ory behavior. For each special memory location, the
memory spec contains a function n read and n write,
where n is the name of the special memory location (e.g.,
P1IN read and P1IN write). The SpecLoadEval and
SpecStoreEval functions determine which of the n read
and n write functions to invoke, based on the target ad-
dress.
(Note that the target address may be symbolic,
in which case FIE resolves the set of possible addresses,
and generates new successors for each possible resulting
behavior.)

Read and write functions are passed the entire sym-
bolic execution state, and output a (possibly empty) set
of states. This allows special memory reads and writes
to deﬁne behavior as an arbitrary computation over the
state. Security and domain experts can therefore modify
a memory spec to reﬁne models of peripheral behavior.
Although this modeling approach is ﬂexible and ex-
pressive, previous work has noted that such models can
be quite onerous to develop [14]. To eliminate this draw-
back, we provide a default memory spec which is auto-

matically generated from the analysis spec. For mem-
ory reads, the default memory spec returns a fresh, un-
constrained symbolic value. For example, reading from
P1IN always returns a new, unconstrained, symbolic, 8-
bit variable, while writing to P1OUT is a no-op. This de-
fault conservatively assumes that an attacker has full con-
trol over all peripherals and uninitialized memory. This
means that our analysis often overapproximates special
memory behavior, and in particular might lead to ﬁnding
vulnerabilities that cannot always be exploited when spe-
ciﬁc peripherals are used. This approach is in-line with
similar work on modeling symbolic hardware [26], and
as we will see in Section 5, empirically results in few
false positives.
Interrupt spec: Deciding which interrupt is enabled at
a given program point is nontrivial: the MSP430 design
documents specify a partial order of priorities over inter-
rupts, i.e., a higher priority interrupt cannot be preempted
by a lower priority one. Furthermore, some (but not all)
interrupts are only enabled when appropriate status reg-
ister ﬂags are set. Thus, determining the enabled set of
interrupts requires knowledge not only of the architec-
ture but also the current ﬁrmware state.

FIE handles this using an interrupt spec. It contains
a number of gate functions, one for each possible inter-
rupt that can occur on an MSP430. The SpawnInterrupts
function executes each gate function, passing each a
pointer to the entire execution state. The gate functions
return a ﬂag indicating that the interrupt: (1) cannot ﬁre
at the current instruction (usually indicating that the in-
terrupt is disabled at that program point); or (2) may oc-
cur at the current program point. For case (2), the gate-
way function additionally returns a successor state S(cid:31) that
is the same as the current state S except advanced to the
ﬁrst instruction of the associated interrupt handler.

SpawnInterrupts collects the returned values pro-
duced into a set of successor states Sint that includes
one successor for each gateway that returned may. As
well, SpawnInterrupts determines if it’s valid for execu-
tion to proceed without an interrupt. This reﬂects the fact
that when the ﬁrmware is in a sleep state the only valid
successor states are in Sint (i.e., the path must traverse
an interrupt handler). In this case, SpawnInterrupts re-
turns shouldExec set to false, correctly forgoing evalua-
tion of S. Otherwise it is set to true, and S is evaluated.

FIE uses, by default, an interrupt spec that explores
an over-approximation of all feasible paths: any inter-
rupt that is enabled at a particular program point may
ﬁre. Thus, an instruction for which n interrupts may ﬁre
will have at least |Sint| = n successor states, and possibly
multiple more in the case that the current state is evalu-
ated. In practice, even an attacker with physical access
to the chip is unlikely to be able to exercise all possible
ﬁring sequences. This means that FIE using the default

470  22nd USENIX Security Symposium 

USENIX Association

8

interrupt spec may yield false positives, but without fur-
ther information about possible adversaries treating all
possible ﬁring sequences is necessary for veriﬁcation.

The default interrupt spec can be used for all the
MSP430 variants: if the ﬁrmware does not handle a cer-
tain type of interrupt, that gate function is simply ig-
nored. However, swapping out interrupt libraries can still
be useful as a way to tune the analysis. For example, in
Section 5 we evaluate an interrupt spec that, instead of
ﬁring at every instruction, allows interrupts only to ﬁre
once per basic block. While this relaxed interrupt model
misses feasible paths, it improves performance.
4.3 State Pruning
In the course of analysis, the main execution loop will of-
ten generate a set SS including one or more states S(cid:31) that
will execute equivalently to another, already seen state ˆS.
We call such an S(cid:31) redundant. We denote states that lead
to equivalent execution by S(cid:31) ≈ ˆS and say S(cid:31) and ˆS are
equivalent.
Most prior symbolic execution frameworks, includ-
ing KLEE, simply add redundant states to the set of
active states, meaning they will potentially be sched-
uled for execution later. Consider Figure 4, but mod-
iﬁed so that lines 14–18 are replaced by a single line
AS ← AS ∪Sint ∪S. That is, all successors generated
via interrupt spawning or evaluation are simply added to
the set of active states. We refer to this variant as the
PLAIN operating mode of FIE.

Redundant states arise frequently in our setting, and
as we will show experimentally in Section 5, PLAIN is
slowed down considerably by them. One reason is that
interrupt ﬁrings can lead to two different paths leading to
the same state. Figure 6(a) shows an example interrupt
handler and code. At line 1, interrupts are enabled. By
the beginning of line 4, when running PLAIN there would
be 4 states resulting from the paths P1 = (cid:27)s2,s3,s4(cid:26), P2 =
(cid:27)s2,s7,s3,s4(cid:26), P3 = (cid:27)s2,s3,s7,s4(cid:26), P4 = (cid:27)s2,s7,s3,s7,s4(cid:26),
where si represents the statement at line i. The states S4
and S(cid:31)4 resulting from execution along paths P2 and P3 are
equivalent, since both increment a via the interrupt han-
dler once — even though they explore distinct program
paths all variables have the same value.

A second source of redundant states arises when sym-
bolic execution of loops generates redundant states. This
situation also causes the PLAIN mode of FIE to loop in-
ﬁnitely. Consider when running PLAIN from a state S3
on the looping line 3 in the code snippet shown in Fig-
ure 6(b). The main loop will call SpecLoadEval and
in turn invoke the memory spec function associated to
P1IN. An unconstrained symbolic variable will be gen-
erated and two successor states will be returned: S4 set
to line 4 (the branch condition assumed to fail) and S(cid:31)3
remaining on line 3 (the branch condition succeeded).

When S(cid:31)3 runs, it will again generate two new states, S(cid:31)4
and S(cid:31)(cid:31)3. Yet, S(cid:31)4 ≈A S4 and S(cid:31)3 ≈A S(cid:31)(cid:31)3. This will continue
endlessly, generating a large number of states and ulti-
mately ensuring that the analysis will never complete.

In KLEE and most prior systems redundant states were
dealt with indirectly, by way of state selection heuristics
R that favored new lines of code. We would like to sup-
port complete analyses, however, and so we go a differ-
ent route and instead build into FIE the ability to detect
and prune redundant states.

State pruning was used previously by RWset [6],
which detects if two states S(cid:31), ˆS are equivalent by check-
ing if the set of values taken by all live variables (plus ap-
propriate context such as the call path) of S(cid:31) match those
seen in ˆS, giving rise to a narrower notion of equivalence
that we denote by ˆS ≈L S(cid:31). Deciding ˆS ≈L S(cid:31) uses a live
variable analysis at each program point. We do not have
a live variable analysis that is sound in the presence of
interrupt paths, which are prevalent in our domain. We
expect that such an analysis would be costly and less ac-
curate when accounting for interrupts, and so we go a dif-
ferent route. FIE checks equivalence by investigating if
every variable, symbolic expression2, program counter,
and all other parts of the state are equal between ˆS and
S(cid:31), denoted ˆS ≈A S(cid:31). This embodies a trade-off between
simplicity of equivalence checking (i.e., we forgo static
analysis) and the ability to prune as aggressively as is
theoretically possible.

Lines 14–20 of Figure 4 realize state pruning. There a
function Prune checks each potential successor S(cid:31) ∈ SS
to see if it is equivalent to any of the previously generated
states in PS p(cid:31), namely those that have the same program
counter p(cid:31) as S(cid:31). To use the ≈A equivalence relation ef-
ﬁciently, we modify the way KLEE maintains states in
memory, storing for each visited program counter a set
of diffs of the memory contents of all states that have
been seen at that program counter. This also allows fast
comparisons to detect redundant states.
4.4 An Optimization: Memory Smudging
As we will see in the next section, FIE as described thus
far can already be used to perform complete analyses for
some simple ﬁrmware and achieves good code-coverage
for some more complex ﬁrmware. However, it is clear
that even small programs can force FIE to attempt to ex-
plore an intractable number of states. For example, con-
sider the code snippet in Figure 6(c). The empty for loop
on line 4 will force FIE to proceed down at least one
path of length at least MAX LONG instructions. Unlike the
loop example in Figure 6(b), state pruning cannot short-
circuit evaluation of this long path because the value of

2We only consider syntactic equality of constraints, and do not at-
tempt to decide if two different sets of constraints deﬁne the same set
of possible values.

USENIX Association  

22nd USENIX Security Symposium  471

9

eint ();
BCSCTL1 = C A L B C 1 _ 1 M H Z ;
DCOCTL = C A L D C O _ 1 M H Z ;

1 int main (){
2
3
4
5 }
6 ISR ( PORT1 ){
7
8 }

a += 1;

...
while ( P1IN & BIT2 );
if ( P1IN & BIT2 ){

1 uint8_t getByte (){
2
3
4
5
6
7
8 }

goto W a i t F o r S t a r t ;

}
...

...
long i = 0;
while ( i < M A X _ L O N G ) {

i ++;

1 int main (){
2
3
4
5
6
7
8 }

}
...

(a) Code with equivalent paths

(b) Code with an inﬁnite fork

(c) Code with a long loop

Figure 6: State pruning can detect and remove the redundant states produced in code samples (a) and (b). Memory smudging
replaces i in code sample (c) with a symbolic variable after t iterations (e.g., t = 100), enabling analysis to move beyond the loop
more quickly.

i is monotonically increasing and so states never repeat
along the path.

To speed analysis for such settings, while retaining
the ability to be complete, we use memory smudging.
It is represented by the function MemorySmudge on
line 19 of Figure 4. At analysis time, the analyst sup-
plies a modiﬁcation threshold t to FIE. Before adding a
(non-redundant) successor state S(cid:31) to AS, the function
MemorySmudge checks if any memory locations in S(cid:31)
have been modiﬁed t times. If so the location’s value is
replaced by a special value (cid:31). This wildcard value may
take any value allowed by the type and cannot be con-
strained. To implement this, FIE keeps a count of every
distinct value that an instance of a variable takes on at a
program point. The count is associated with the activa-
tion record of the variable. Thus, if a local variable is
smudged, it will again be concrete on the next call to that
function while global variables remain smudged.

Smudging allows the analysis to explore more of a
ﬁrmware at the cost of precision. To see this, con-
sider again Figure 6(c), and let the smudging threshold
be t = 100. On iteration 100, i takes on the value (cid:31).
Then, as the loop continues to iteration 101, the condi-
tion i < MAX LONG will cause the execution state to be
split into two states: a state SF that fails the loop condi-
tion and proceeds to line 7, and a state ST that executes
the body of the loop at line 5 again. By executing ST ,
code that would not be executed until MAX LONG itera-
tions of the loop can instead be executed after 100 it-
erations. This approach does lead to the addition of new
states (compared to execution without smudging), but we
have found that pruning typically eliminates states added
due to smudging. When FIE executes SF in the example
above, it will explore the (empty) body of the loop, and i
will be incremented. However, since i = (cid:31), the update to
i will be discarded. Now, SF is again at the head of the
loop, and execution state is identical to the previous iter-
ation: no variable besides i has been touched, and i = (cid:31) as
it did on the previous iteration. Thus, SF ends up pruned.
Memory smudging over-approximates a state and so
can be a source of false positives, i.e., (cid:31) contains values
that may never be realized along any path. For example,

a pointer modiﬁed t times and then dereferenced can re-
sult in a false positive. FIE reports in output warnings if
any involved values were smudged, making it easier for
analyst to detect such a false positive. As we see in the
next section, false positives due to smudging seem rare
in practice for reasonable values of t.
4.5
Implementation Details
The pseudocode presented in Figure 4 gives the high-
level logic of FIE but abstracts away many details for
simplicity. Our implementation includes a number of
important embellishments, which we can only brieﬂy de-
scribe here.
Memory sharing: Since FIE creates at least one new
state at nearly every instruction, it is important that the
creation and storage of states be as efﬁcient as possible.
Thus, we only store one complete state per calling con-
text for each PS. Additional states with the same calling
context are then compared to the existing state, and only
the incremental difference in that state are stored. We
also inherit memory optimizations from KLEE, the most
important of which is copy-on-write memory for states.
Pruning frequency: The PRUNE operation shown on
line 18 of Figure 4 can become expensive as the num-
ber of states at PS becomes large. Rather than perform-
ing this operation at each instruction, the default mode of
FIE prunes only at basic block boundaries. We preserve
the ability to conﬁgure FIE to prune at each instruction,
but have found that basic-block-level pruning improves
performance in all our tests.
5 Evaluation
To evaluate FIE, we used it to analyze the 99 ﬁrmware
programs in our corpus. We will investigate the overall
efﬁcacy in terms of code coverage, the ability to com-
plete analyses, the utility of pruning and smudging, and
the bugs FIE helped us ﬁnd.
Firmware size and coverage: We ﬁrst ﬁx some con-
ventions regarding how we measure the size of ﬁrmware
programs and analysis coverage. For our evaluations,
we measure ﬁrmware size by the number of executable
LLVM instructions, denoted by the acronym NEXI. We

472  22nd USENIX Security Symposium 

USENIX Association

10

(1) compiling the
compute a ﬁrmware’s NEXI by:
ﬁrmware into LLVM bitcode using CLANG; (2) running
the resulting bitcode through LLVM optimization passes
for global and local dead code elimination; and (3) tak-
ing the number of LLVM instructions in the resulting bit-
code as the NEXI. This count includes intrinsic functions
and library functions called by the ﬁrmware. We note
that some programs used external modules whose source
code was not included in their source tree; we did not
attempt to track down these libraries and FIE emits an
error should it execute an instruction calling an omitted
function. Likewise for inline assembly instructions not
supported by FIE. This did not signiﬁcantly affect our
evaluation, e.g., only two programs ever reached miss-
ing functions or inline assembly in the 50 minute runs
reported on below. Note that usually FIE continues run-
ning in such cases along other paths.

Code coverage is the fraction of LLVM instructions
executed in the course of the analysis divided by the
NEXI of the target ﬁrmware. Using NEXI as opposed
to C lines of code better aligns our complexity and cov-
erage metrics with the work done by FIE, and avoids any
ambiguity in terms of overcounting coverage of partially
executed blocks or lines of C code. The NEXI sizes are,
on average, 1.5 times larger than the number of lines of
C code computed in Section 2. NEXI was smaller than
cloc for 23 of the programs due to dead code elimination.
Experimental setup: All the analyses reported on be-
low used Amazon EC2 high-memory, double-extra-large
(m2.2xlarge) instances which have 36 GB of RAM and
13 virtual CPUs (each advertised to be the equivalent of
an 1.0–1.2 GHz 2007 Opteron or 2007 Xeon processor).
Unless speciﬁed otherwise, FIE was given 50 minutes of
runtime3, and each analysis was performed on a separate
EC2 instance. To facilitate this effort, we wrote a set of
scripts for launching, monitoring, and retrieving the re-
sults of FIE run via a custom EC2 VM image.
Coverage under different FIE modes: We started by
analyzing each ﬁrmware for 50 minutes for each of ﬁve
different modes supported by FIE, for a total of 495 ex-
ecutions. The resulting NEXI coverages are shown in
Table 7. We now explain the modes and discuss their
performance.

Baseline: The BASELINE mode reﬂects a bare mini-
mum port of KLEE to the MSP430 environment, in par-
ticular it has support for: 16-bit addressing; a custom
memory allocator that ensures that memory objects do
not collide with special memory locations and have ad-
dresses within the chip’s address range; and implementa-
tion of intrinsics supported by msp430-gcc. It does not,
however, have any knowledge of the semantics of, spe-

3Setting the time to a bit less than one hour halves the cost of run-

ning on EC2.

NEXI

%

Complete

100%

90–100%
80–90%
70–80%
60–70%
50–60%
40–50%
30–40%
20–30%
10–20%
0–10%
Total %
Avg. %
Median %

E
LIN
BASE

n/a
1
1
0
0
0
0
0
0
1
10
86
1.1
5.9
1.7

Z
Z
FU
n/a
43
10
7
5
4
4
8
0
8
5
5

26.1
74.5
96.9

AIN
PL
7
40
9
5
5
5
6
8
0
11
5
5

23.7
71.1
89.5

E
N
U
PR
35
34
15
10
6
5
5
9
2
4
3
6

29.5
74.4
88.7

E
G
D
U
M
S

52
46
15
6
4
5
3
5
3
5
3
4

32.3
79.4
98.1

Table 7: Number of ﬁrmware programs for which FIE achieves
coverage in the indicated range, for 50 minute runs of FIE in
each of ﬁve operating modes. “Complete” gives the number of
programs for which the mode was able to analyze all possible
symbolic states.

cial memory or interrupts, etc. For most ﬁrmware, the
BASELINE analysis performs very poorly, with a median
of 1.7% coverage. This is because BASELINE almost
always ends prematurely with a false positive since the
ﬁrmware appears (to the analysis) as if it were reading
from an uninitialized memory location. Manual inspec-
tion of the code of the two outliers (from GitHub) re-
vealed that they are not using any features of the MSP430
architecture. The poor coverage of BASELINE for the
other ﬁrmware programs attests to the importance of pro-
viding an architecture-aware analysis.

Fuzz: We next use FIE to realize a general-purpose
fuzzing tool for MSP430 ﬁrmware. This mode, unlike
BASELINE, takes advantage of knowledge of the mem-
ory layout, special registers, and interrupt handling se-
mantics. We implemented a special memory spec in
which any read to a peripheral results in a returned value
chosen uniformly in the appropriate range. (Twice read-
ing the same peripheral location leads to two indepen-
dent values.) Writes to peripherals are ignored. We
use the conservative interrupt spec, meaning that in the
FUZZ mode the analysis branches off new states to exe-
cute interrupt handlers as appropriate. In this mode, then,
FIE never generates symbolic variables, and so is able to
quickly evaluate on concrete values along many paths.
Fuzzing provides surprisingly good coverage for many
of the ﬁrmware programs, in fact beating symbolic exe-
cution modes in many cases. This is because fuzzing can
evaluate states more quickly, and for simple programs
this can lead to good coverage in a 50 minute test.

USENIX Association  

22nd USENIX Security Symposium  473

11

e
g
a
r
e
v
o
c

e
v
i
t
a
l
e
R

0.6

0.4

0.2

0

−0.2
−0.4
−0.6

1

25

50

75

99

1

25

50

75

99

Figure 8: Coverage of SMUDGE relative to FUZZ (top) and
SMUDGE relative to PLAIN (bottom) for the 50-minute tests.
Here SMUDGE outperforms FUZZ and PLAIN for 32% and 42%
of the programs, respectively.

Plain, Prune, and Smudge: We now turn to modes
that use FIE as a symbolic executor with the architecture-
aware analysis. To compare the efﬁcacy of the state prun-
ing and memory smudging techniques, we use three dif-
ferent modes: PLAIN (no pruning or smudging), PRUNE
(with pruning but not smudging), and SMUDGE (pruning
and smudging, with smudging threshold t = 100). All
three modes used the most conservative interrupt model.
Overall SMUDGE provides better coverage than all oth-
ers, including FUZZ. A comparison of relative perfor-
mance for each ﬁrmware appears in the charts of Fig-
ure 8. The x-axes is the ﬁrmware (ordered by y-values)
and the y-value is (Ns−Nf )/Ntot where Ns is, for the left
chart, the number of instructions covered by SMUDGE
for this ﬁrmware, Nf is the number covered by FUZZ,
and Ntot is the NEXI for the ﬁrmware. The right chart
is the same except comparing SMUDGE with PLAIN.
These graphs surface two facts. First, there exists a large
number of ﬁrmware programs for which the analyses do
equally well (where relative coverage is 0, most often be-
cause both analyses had 100% coverage), which is due to
the large number of very simple ﬁrmware from GitHub
and the TI website. Second, SMUDGE can do worse than
others on a few ﬁrmware programs, but improves per-
formance over FUZZ for 32% of the programs and over
PLAIN for 42% of the programs.
50-minute analysis outcomes:
In Table 9 we give a
breakdown of the emitted termination status for the anal-
yses. FIE can either stop because it runs out of mem-
ory (No mem), the requested amount of execution time
has been reached (Timeout), or because there exist no
more active states (Finished). Additionally, FIE will out-
put bug reports. As can be seen, pruning and smudging
help reduce memory usage and increase the number of
analyses that ﬁnish. Potential bugs were reported for 92
ﬁrmware programs by the BASELINE, all false positives.
Smudging introduced a false positive in one ﬁrmware,
since a pointer was smudged. (Smudging a pointer fre-
quently leads to a memory safety violation, because any
dereference of it will be viewed as an error.) FIE makes
it easy to determine if a warning is related to smudging

Mode
BASELINE
FUZZ
PLAIN
PRUNE
SMUDGE

Termination status

FPs

No mem Timeout

Finished

9
10
7
0
0

2
79
85
64
46

88
10
7
35
53

93
0
0
0
1

Table 9: Counts of each termination code seen in the 50-minute
runs. “No mem”: the analysis exhausted memory; “Timeout”:
analysis ran for the full 50 minutes; “Finished”: analysis com-
pleted early. The ﬁnal column is the number of ﬁrmware pro-
grams with erroneous bug reports.

by marking variables that were smudged as such in the
bug report. No true positives were found in these short
runs.

Recall that an explicit design goal for FIE was the abil-
ity to support complete analyses (all possible symbolic
states are checked). The PLAIN, PRUNE, and SMUDGE
modes do support this: an analysis is complete if the
termination status was Finished and no bugs were re-
ported. Modulo the limitations discussed in the next sec-
tion, this veriﬁes the absence of bugs. The ﬁrst row of Ta-
ble 7 shows the number of ﬁrmware programs for which
PLAIN, PRUNE, or SMUDGE were able to verify the ab-
sence of memory safety and (some kinds of) peripheral
misuse bugs, in these short 50 minute runs.
As can
be seen, our pruning and smudging mechanisms enable
a huge increase in the number of analyses that FIE can
complete: a 6x increase when we use pruning and an
additional factor of 1.48x improvement when we add in
smudging. In the end, the total number of ﬁrmware pro-
grams for which one of the analysis modes completed is
53. (One ﬁrmware was completed by PRUNE but had a
false positive under SMUDGE, and so it was not counted
in the SMUDGE column of Table 7.)

We note that these complete analyses revealed that 13
ﬁrmware programs have dead code missed by the static
optimization passes, which means for these our mea-
sured coverage is lower than it should be (e.g., for one
ﬁrmware we achieved a complete analysis but only 45%
coverage). For consistency, we do not correct the NEXI
values for these ﬁrmware programs.
Firmware complexity measures: The above shows that
FIE enables complete analyses for a majority of the
ﬁrmware programs in our corpus, yet the total amount of
code covered across the full corpus indicates that FIE was
not able to explore most of the larger ﬁrmware programs
given only 50 minutes. As can be seen in Figure 10, the
coverage is uniformly poor for ﬁrmware programs with
more than 4,000 executable instructions. More subtly,
there exist many much smaller programs for which cov-
erage is also poor (the vertical trend closer to the y-axis),
which could be due to complicated but short code con-

474  22nd USENIX Security Symposium 

USENIX Association

12

)

%

(

e
g
a
r
e
v
o
C

1

0.8

0.6

0.4

0.2

0

0

FUZZ
PLAIN
PRUNE
SMUDGE

Conservative
Basic block

e
g
a
r
e
v
o
C
%

1

0.8

0.6

0.4

0.2

0

1,000 2,000 3,000 4,000 5,000 6,000

NEXI

Figure 10: Coverage as a function of ﬁrmware size in the 50
minute tests.

Complexity

Criteria

# FWs

low

medium

high

≤ 100 NEXI
or < 2 loops
≤ 500 NEXI
and ≥ 2 loops
> 500 NEXI
and ≥ 2 loops

49

37

13

SMUDGE
coverage

Avg: 93.6%
Med: 100%
Avg: 79.5%
Med: 93.1%
Avg: 27.8%
Med: 24.8%

Table 11: Criteria for ﬁrmware complexity groups, the number
of ﬁrmware programs (# FWs) in each group, and SMUDGE’s
average and median coverage for each group.

structs or, perhaps, undiscovered dead code.

To focus subsequent experiments on the more chal-
lenging ﬁrmware programs, we partition the programs
into three complexity groups based on a simple static
analysis.
(Using static analysis avoids biasing the set
unnecessarily by the nature of FIE’s analysis.) The cri-
teria for partitioning our programs into low-, medium-,
and high-complexity groups is described in Table 11. To
determine the number of loops in a program, we use
LLVM’s built-in loop detection. We chose this partic-
ular partitioning for its simplicity, but admit there are
many other possibilities. We give the average and me-
dian performance of the 50-minute SMUDGE runs as bro-
ken down by each group. Of the 53 programs that FIE is
able to complete analysis for in 50 minutes, 38 are low
complexity and 14 are medium complexity. The average
NEXI for these completed programs is 84.4 and the aver-
age number of loops is 2.2; the most complex completed
program has a NEXI of 414 and 17 loops.
Effect of smudging threshold: We now measure the ef-
fect of the smudging threshold t on coverage and false
positive rates for the high complexity ﬁrmware pro-
grams. By decreasing t one might hope to achieve a
trade-off between coverage improvements (by breaking
out of loops even more quickly) and increased risk in
false positives. We run SMUDGE for 50-minutes for
each of t = 1,10,1000 for the 13 ﬁrmware programs and

Figure 12: Coverage when spawning interrupts every instruc-
tion (Conservative) versus once per basic block for the 13 high-
complexity ﬁrmware programs.

use as well the t = 100 results from the runs discussed
above. The average coverages were 23.3%, 25.2%,
25.5%, 25.6% for t = 1,10,100,1000, making the dif-
ferences too small to be signiﬁcant. The number of false
positives increased for small t; with t = 1 there were two
false positives, and none for the larger values of t. We
conclude that t = 100 strikes a reasonable balance, but
further performance improvements may not be easily ob-
tained by tweaking t.
Relaxing the interrupt model: Recall that we have so
far been using FIE with a very conservative interrupt
model in which all enabled interrupts ﬁre at every pro-
gram point. This can mean that most instructions, as
opposed to just branches, end up forking off multiple
new states. We therefore implement a relaxed interrupt
model in which every enabled interrupt ﬁres at the ﬁrst
instruction of each basic block, but not during subse-
quent instructions. This means analysis will miss pos-
sible paths (barring complete analyses) but could speed
up performance and thereby increase code coverage. In
Figure 12 we compare, for the high-complexity ﬁrmware
programs, the coverage obtained by SMUDGE with t =
100 using both the conservative interrupt model (Con-
servative) and the new model that only ﬁres at each basic
block (Basic block). The results are both from 50 minute
runs. Several of the ﬁrmware programs see drastic cover-
age improvements, the last bar on the right represents the
largest improvement at 232%. No false positives arose in
these basic block runs, however one program hit a code
construct4 currently not supported by FIE.
Finding vulnerabilities: FIE currently supports ﬁnding
two types of bugs: memory safety violations, such as
buffer overruns and out-of-bounds accesses to memory
objects like arrays, as well as peripheral-misuse errors in
which a ﬁrmware writes to a read-only memory location
or to locked ﬂash. It will be easy to increase scope to
further security properties in the future.

4A ﬁrmware used a custom variable argument function. We plan to

add support in the public release version.

USENIX Association  

22nd USENIX Security Symposium  475

13

Firmware
CDC Driver
HID Driver
controleasy

Types

NEXI
4,489 Memory safety
2,958 Memory safety
1,255
Flash misuse

# bugs

10
11
1

Table 13: Summary of vulnerabilities discovered by FIE. The
ﬁnal column is the number of distinct vulnerabilities in the
ﬁrmware.

We supplemented the above analyses with runs in
which we allowed SMUDGE to run up to 24 hours, with
t = 100 and using the conservative interrupt model, on
each of the 13 high-complexity programs. Table 13 gives
a breakdown of the 22 bugs found across all of the runs.
The bugs were spread across three ﬁrmware programs,
the two USB drivers supplied by TI and one community
ﬁrmware called Controleasy. Of the bugs, 21 were mem-
ory safety violations while one was a ﬂash misuse bug.
CDC Driver and HID Driver share some common source
ﬁles, one of the bugs spans both, while the others are
from disjoint source ﬁles. The memory safety bugs in
the two USB drivers include 18 vulnerabilities in which
a USB protocol value (received from off-chip) ends up
controlling an index into an array, allowing adversarial
reads or the ability to crash the ﬁrmware. One of the vul-
nerabilities, in HID Driver, allows an adversary over the
network to inject arbitrarily long strings due to an unpro-
tected strcat. This allows crashing the ﬁrmware, but
may also lead to a complete compromise by way of con-
trol ﬂow hijacking. The ﬁnal two memory safety bugs are
present in both programs but arise from the same source
ﬁle. The bug dereferences a value read from ﬂash, which
in our model is untrusted but unlikely to be exploitable
in most settings.

The TI community code project controleasy has a pe-
ripheral misuse bug in which a read-only I/O port can be
written to based on the value of another peripheral. Like
the attacker-controlled reads in the USB code, this bug
can be used by an attacker that can send data to PORT 1
to cause the ﬁrmware to crash.
6 Limitations
The evaluation in the last section evidenced FIE’s effec-
tiveness at both ﬁnding bugs as well as verifying their
absence. Of course, FIE does have some limitations.

The design of FIE arises from a philosophy that sound
and complete analysis are valuable and can be feasible
for the embedded ﬁrmware often found in practice. How-
ever, it is simple to show that there exist ﬁrmware for
which complete analyses are intractable, and likewise
soundness is only with respect to the symbolic execu-
tion framework (it is possible that reported bugs may not
arise in the ﬁrmware when run natively, as discussed be-
low). Indeed some of the ﬁrmware in our corpus (e.g.,
Contiki) appear to have, in particular, an intractably large

number of reachable states. Here FIE attempts to provide
as high as possible code coverage, but improving on the
results reported in the last section might require different
techniques than currently used. For example, a combina-
tion of loop elision [14, 26] and improved state selection
heuristics might be more effective than state pruning and
memory smudging. Future work might therefore explore
incorporation of other techniques into FIE.

Both when achieving complete analyses and when
not, there exist various sources of imprecision in anal-
ysis that may lead to false positives or false negatives.
In developing FIE we often encountered analysis errors
due to bugs in the analysis software or misconﬁgura-
tion (e.g., using the incorrect target architecture almost
always yields false positives). These problems were sub-
sequently ﬁxed, and while we are unaware of any out-
standing bugs in FIE and have manually veriﬁed all the
bugs reported in Section 5, it could be that some analysis
errors remain.

Imprecision can also arise due to discrepancies be-
tween the ﬁrmware as symbolically executed in FIE and
natively in deployment. In building FIE, we had to im-
plement extensions to C that are (sometimes implicitly)
deﬁned by msp430-gcc. We encountered inconsistencies
between msp430-gcc and FIE, which were subsequently
ﬁxed, but some may remain. These C extensions also
differ among the three MSP430 compilers, and so an-
alyzing ﬁrmware written to work for the IAR or CCS
compilers (e.g., the USB drivers in our corpus) may give
rise to analysis errors when using FIE. Even so FIE can
still be useful for ﬁnding vulnerabilities in such ﬁrmware
programs, as the bugs found in the USB drivers shows.

As a ﬁnal source of imprecision, our most conserva-
tive analysis models peripherals and interrupt ﬁring as
adversarially controlled. This means that FIE may ex-
plore states that do not arise in real executions, and errors
ﬂagged due to such states would constitute false posi-
tives. We feel that ﬁxing even such bugs should be en-
couraged, since it reduces the potential for latent vulner-
abilities. Moreover, it is unclear where to draw the line
in terms of adversarial access to a chip. That said, FIE
is easily customizable should such false positives prove
burdensome, or to receive the speed-ups of other envi-
ronmental models.

Finally, we note that currently FIE fails execution
paths that include inline assembly. While we added some
explicit handlers for several inline assembly instructions
(e.g., nop), this approach would struggle with complex
assembly code constructs. Future work might investigate
performing symbolic analysis starting with MSP430 as-
sembly, similarly to [7].

476  22nd USENIX Security Symposium 

USENIX Association

14

7 Related Work
FIE is based off of KLEE and, in turn, builds off the work
of KLEE’s predecessors such as EXE [11]. These prior
systems target generation of high-coverage test suites for
non-embedded programs (e.g., Linux CoreUtils). As we
saw in previous sections, using KLEE with a minimal
amount of porting provides poor coverage. The many
systems that extend KLEE [2,9,13,28,31,36] do not target
embedded systems, with the exception of KleeNet [28].
It targets wireless sensor nodes running Contiki [35], but
only on x86 platforms, and so does not work for our set-
ting of MSP430 ﬁrmware programs.

Concolic execution systems extend symbolic execu-
tion by concretizing values that cannot be handled by
the constraint solver efﬁciently (or cannot be handled by
the constraint solver at all) [14, 30]. Whole-system con-
colic execution tools like S2E [14] can execute external
functions natively by concretizing symbolic arguments,
and then providing the concrete value in the call. Their
model of concretization makes less sense in our setting,
where we have a ﬁrmware that speciﬁes all software on
the system and interacts only with hardware peripherals.
For the latter, we can support concretization in the sense
that a memory speciﬁcation can return concrete values,
change symbolic values to concrete, etc.

SymDrive [26] builds off S2E to test Linux and
FreeBSD kernel drivers without the need for the ac-
tual hardware, and treats many of the same problems as
FIE, including modeling hardware, dealing with polling
loops, etc. SymDrive uses static analysis to help guide
execution along states that reach deep paths and to avoid
loops. This improves code coverage, but does not enable
complete analyses. We leave incorporating such static
analysis techniques into FIE, in order to increase code
coverage in conjunction with state pruning and memory
smudging, for future work.

Pruning redundant states during an analysis has been
considered before in a variety of program analysis con-
texts [3, 5, 32]. Closest to our work is RWset [6], which
extended the EXE [11] symbolic execution engine to
track live variables and to discard a state should the val-
ues of all live variables have already been executed upon.
Our state pruning approach is simpler and does not re-
quire an auxiliary live variable analysis (which can be
challenging in the face of interrupt-driven code). The
trade-off for this simplicity is that FIE may prune less
aggressively than possible. On the other hand, FIE goes
further than RWset in limiting path explosion via mem-
ory smudging, which is effective even when, for exam-
ple, variables written within a loop are live.

There is a body of work on improving the performance
of symbolic execution by merging similar states [23,25].
State merging seeks to combine identical (or similar) ac-
tive states, whereas state pruning compares active states

to both active and prior states. Only the latter enables
complete analysis. Whether the two techniques are use-
ful in conjunction is an interesting open question.

Much effort has gone into improving the scalability
of symbolic execution [7, 15, 29]. One such example
is Cloud9, which speeds symbolic execution by paral-
lelizing the execution of multiple memory states across
a cluster of commodity hardware. We note that such
techniques are applicable to FIE, and future work may
involve adopting such techniques to improve the perfor-
mance of FIE for large ﬁrmware programs.

Finally, we are aware of two commercial tools of po-
tential relevance to FIE. The ﬁrst, Codenomicon [16], of-
fers a network protocol fuzzing tool for embedded med-
ical devices. It therefore targets protocol parsing logic,
which is a frequent source of vulnerabilities. FIE already
supports rudimentary fuzzing, and could perform net-
work protocol fuzzing (or a mixture of fuzzing and sym-
bolic execution) by implementing more detailed memory
specs. Second is Coverity [4], a static analysis tool that
targets a number of platforms, including the MSP430.
While we have access to Coverity, their software license
unfortunately prevents head-to-head comparisons in pub-
lished research.
8 Conclusion
In this paper, we presented the design and implementa-
tion of FIE, a tool for performing symbolic-execution-
based analysis of MSP430 ﬁrmware programs. It pro-
vides an extensible platform for ﬁnding security vulner-
abilities and other kinds of bugs, and has proven effec-
tive in analyzing a large corpus of open-source MSP430
ﬁrmware programs. To increase code coverage in a way
that supports veriﬁcation of security properties, we incor-
porate into FIE the techniques of state pruning and mem-
ory smudging. We used FIE to verify memory safety for
53 ﬁrmware programs and elsewhere found 21 distinct
vulnerabilities, some of which appear to be remotely ex-
ploitable. All this shows that FIE is particularly well-
suited to the small, simple ﬁrmware programs often used
for microcontrollers and proves useful for analysis of
more complex ﬁrmware programs as well.
Acknowledgements
We would like to thank Kevin Fu, Matt Renzelmann and
the anonymous reviewers for their extensive feedback on
earlier drafts of this paper. This work was supported,
in part, by DARPA and AFRL under contracts FA8650-
10-C-7088 and CNS-1064944. The views, opinions,
and/or ﬁndings contained herein are those of the authors
and should not be interpreted as representing the ofﬁcial
views or policies, either expressed or implied, of the De-
fense Advanced Research Projects Agency or the Depart-
ment of Defense.

USENIX Association  

22nd USENIX Security Symposium  477

15

References

[1] Amazon. Amazon elastic compute cloud.

http://aws.

amazon.com/ec2, 2013. Last accessed Jun 2013.

[2] T. Avgerinos, S. K. Cha, B. L. T. Hao, and D. Brumley. AEG:
Automatic exploit generation. In Network and Distributed System
Security Symposium (NDSS), 2011.

[3] T. Ball, V. Levin, and S. K. Rajamani. A decade of software
model checking with SLAM. Commun. ACM, 54(7):68–76, July
2011.

[4] A. Bessey, K. Block, B. Chelf, A. Chou, B. Fulton, S. Hallem,
C. Henri-Gros, A. Kamsky, S. McPeak, and D. Engler. A few
billion lines of code later: using static analysis to ﬁnd bugs in the
real world. Commun. ACM, 53(2):66–75, Feb. 2010.

[5] D. Beyer, T. A. Henzinger, R. Jhala, and R. Majumdar. The soft-
ware model checker Blast: Applications to software engineering.
Int. J. Softw. Tools Technol. Transf., 9(5):505–525, Oct. 2007.

[6] P. Boonstoppel, C. Cadar, and D. Engler. RWset: Attacking path
explosion in constraint-based test generation. In C. Ramakrish-
nan and J. Rehof, editors, Tools and Algorithms for the Construc-
tion and Analysis of Systems, volume 4963 of Lecture Notes in
Computer Science, pages 351–366. Springer Berlin Heidelberg,
2008.

[7] D. Brumley, C. Hartwig, M. G. Kang, Z. Liang, J. Newsome,
P. Poosankam, D. Song, and H. Yin. BitScope: Automatically
dissecting malicious binaries. Technical report, In CMU-CS-07-
133, 2007.

[8] D. Brumley, J. Newsome, D. Song, H. Wang, and S. Jha. To-
wards automatic generation of vulnerability-based signatures. In
Proceedings of the 2006 IEEE Symposium on Security and Pri-
vacy (SP), pages 2–16. IEEE Computer Society, 2006.

[9] S. Bucur, V. Ureche, C. Zamﬁr, and G. Candea. Parallel symbolic
execution for automated real-world software testing. In EuroSys,
pages 183–198, 2011.

[10] C. Cadar, D. Dunbar, and D. Engler. KLEE: unassisted and auto-
matic generation of high-coverage tests for complex systems pro-
grams. In Proceedings of the 8th USENIX conference on Operat-
ing systems design and implementation (OSDI), pages 209–224.
USENIX Association, 2008.

[11] C. Cadar, V. Ganesh, P. M. Pawlowski, D. L. Dill, and D. R.
Engler. EXE: automatically generating inputs of death. In ACM
Conference on Computer and Communications security, pages
322–335. ACM, 2006.

[12] S. Checkoway, D. McCoy, B. Kantor, D. Anderson, H. Shacham,
S. Savage, K. Koscher, A. Czeskis, F. Roesner, and T. Kohno.
Comprehensive experimental analyses of automotive attack sur-
faces. In Proceedings of USENIX Security, 2011.

[13] V. Chipounov and G. Candea. Reverse engineering of binary de-

vice drivers with RevNIC. In EuroSys, pages 167–180, 2010.

[14] V. Chipounov, V. Kuznetsov, and G. Candea. S2E: a platform for
in-vivo multi-path analysis of software systems. SIGPLAN Not.,
46(3):265–278, Mar. 2011.

[15] L. Ciortea, C. Zamﬁr, S. Bucur, V. Chipounov, and G. Candea.
Cloud9: a software testing service. SIGOPS Oper. Syst. Rev.,
43(4):5–10, Jan. 2010.

[16] Codenomicon.

Codenomicon defensics.

http://www.

codenomicon.com, 2013. Last accessed Jun 2013.

[17] M. Costa, M. Castro, L. Zhou, L. Zhang, and M. Peinado.
Bouncer: securing software by blocking bad input. In Symposium
on Operating System Principles (SOSP), pages 117–130, 2007.

[18] A. Cui, M. Costello, and S. J. Stolfo. When ﬁrmware modiﬁca-
tions attack: A case study of embedded exploitation. In Network
and Distributed System Security Symposium (NDSS), 2013.

[19] A. Cui and S. J. Stolfo. A quantitative analysis of the insecu-
rity of embedded network devices: results of a wide-area scan.
In Annual Computer Security Applications Conference (ACSAC),
pages 97–106. ACM, 2010.

[20] W. Frisby, B. Moench, B. Recht, and T. Ristenpart. Security

analysis of smartphone point-of-sale systems. In Proceedings of
the 6th USENIX conference on Offensive Technologies (WOOT),
pages 3–3, 2012.

[21] D. Halperin, T. Heydt-Benjamin, B. Ransford, S. Clark, B. De-
fend, W. Morgan, K. Fu, T. Kohno, and W. Maisel. Pacemakers
and implantable cardiac deﬁbrillators: Software radio attacks and
zero-power defenses. In IEEE Symposium on Security and Pri-
vacy (SP), pages 129–142, 2008.

[22] D. Halperin, T. Kohno, T. Heydt-Benjamin, K. Fu, and W. Maisel.
Security and privacy for implantable medical devices. Pervasive
Computing, IEEE, 7(1):30–39, 2008.

[23] T. Hansen, P. Schachte, and H. Søndergaard. State joining and
splitting for the symbolic execution of binaries. In Runtime Veriﬁ-
cation, 9th International Workshop, RV 2009, pages 76–92, 2009.
[24] K. Koscher, A. Czeskis, F. Roesner, S. Patel, T. Kohno, S. Check-
oway, D. McCoy, B. Kantor, D. Anderson, H. Shacham, et al.
Experimental security analysis of a modern automobile. In 2010
IEEE Symposium on Security and Privacy, pages 447–462. IEEE,
2010.

[25] V. Kuznetsov, J. Kinder, S. Bucur, and G. Candea. Efﬁcient state
merging in symbolic execution. In PLDI, pages 193–204, 2012.
[26] M. J. Renzelmann, A. Kadav, and M. M. Swift. Symdrive: testing
drivers without devices. In Proceedings of the 10th USENIX con-
ference on Operating Systems Design and Implementation, pages
279–292. USENIX Association, 2012.

[27] I. Rouf, R. Miller, H. Mustafa, T. Taylor, S. Oh, W. Xu,
M. Gruteser, W. Trappe, and I. Seskar. Security and privacy
vulnerabilities of in-car wireless networks: a tire pressure mon-
itoring system case study. In Proceedings of the 19th USENIX
conference on Security, 2010.

[28] R. Sasnauskas, O. Landsiedel, M. H. Alizai, C. Weise,
S. Kowalewski, and K. Wehrle. Kleenet: Discovering insidious
interaction bugs in wireless sensor networks before deployment.
In ACM/IEEE International Conference on Information Process-
ing in Sensor Networks (IPSN), Stockholm, Sweden, April 2010.
[29] P. Saxena, P. Poosankam, S. McCamant, and D. Song. Loop-
extended symbolic execution on binary programs.
In Inter-
national Symposium in Software Testing and Analysis (ISSTA),
pages 225–236, 2009.

[30] K. Sen, D. Marinov, and G. Agha. CUTE: A concolic unit test-
ing engine for C. In Proceedings of the 10th European software
engineering conference held jointly with 13th ACM SIGSOFT
international symposium on Foundations of software engineer-
ing, ESEC/FSE-13, pages 263–272, New York, NY, USA, 2005.
ACM.

[31] A. Slowinska, T. Stancescu, and H. Bos. Howard: A dynamic
excavator for reverse engineering data structures. In Network and
Distributed System Security Symposium (NDSS), 2011.

[32] U. Stern and D. L. Dill. Improved probabilistic veriﬁcation by
hash compaction. In In Advanced Research Working Conference
on Correct Hardware Design and Veriﬁcation Methods, pages
206–224. Springer-Verlag, 1995.

[33] Texas

Instruments.

projects website.
http://e2e.ti.com/group/microcontrollerprojects/
m/msp430microcontrollerprojects/default.aspx. Last
accessed Jun 2013.

Microcontroller

[34] Texas Instruments. MSP430 for security applications. http:

//www.ti.com/mcu/docs/mcuorphan.tsp?contentId=
33485&DCMP=MSP430&HQS=Other+OT+430security, January
2012.

[35] The Contiki Project. Contiki. http://www.contiki-os.org/.

Last accessed Jun 2013.

[36] C. Zamﬁr and G. Candea. Execution synthesis: a technique
for automated software debugging. In EuroSys, pages 321–334,
2010.

478  22nd USENIX Security Symposium 

USENIX Association

16

