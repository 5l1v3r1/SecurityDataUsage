Does Counting Still Count? Revisiting the Security of Counting based User

Authentication Protocols against Statistical Attacks∗

Hassan Jameel Asghar

Centre for Advanced Computing
Algorithms and Cryptography

Department of Computing, Faculty of Science

Macquarie University, Sydney, Australia

hassan.asghar@mq.edu.au

Shujun Li

Department of Computing

Faculty of Engineering and Physical Sciences
University of Surrey, Guildford, Surrey, UK

shujun.li@surrey.ac.uk

Ron Steinfeld

Clayton School of Information Technology

Faculty of Information Technology

Monash University, Clayton, Australia

Email: ron.steinfeld@monash.edu

Josef Pieprzyk

Centre for Advanced Computing
Algorithms and Cryptography

Department of Computing, Faculty of Science

Macquarie University, Sydney, Australia

josef.pieprzyk@mq.edu.au

Abstract

At NDSS 2012, Yan et al. analyzed the security of sev-
eral challenge-response type user authentication protocols
against passive observers, and proposed a generic count-
ing based statistical attack to recover the secret of some
counting based protocols given a number of observed au-
thentication sessions. Roughly speaking, the attack is based
on the fact that secret (pass) objects appear in challenges
with a different probability from non-secret (decoy) objects
when the responses are taken into account. Although they
mentioned that a protocol susceptible to this attack should
minimize this difference, they did not give details as to how
this can be achieved barring a few suggestions.

In this paper, we attempt to ﬁll this gap by generaliz-
ing the attack with a much more comprehensive theoretical
analysis. Our treatment is more quantitative which enables
us to describe a method to theoretically estimate a lower
bound on the number of sessions a protocol can be safely
used against the attack. Our results include 1) two proposed
ﬁxes to make counting protocols practically safe against the
attack at the cost of usability, 2) the observation that the at-
tack can be used on non-counting based protocols too as
long as challenge generation is contrived, 3) and two main
design principles for user authentication protocols which
can be considered as extensions of the principles from Yan
et al. This detailed theoretical treatment can be used as a
∗The full edition of this paper is available at http://eprint.

iacr.org/2012/659.

guideline during the design of counting based protocols to
determine their susceptibility to this attack. The Foxtail pro-
tocol, one of the protocols analyzed by Yan et al., is used as
a representative to illustrate our theoretical and experimen-
tal results.

1. Introduction

Every now and then we are informed via the media about
people’s credentials being stolen and misused through new
ways. As technology thrives to provide convenience to
users through ubiquitous access to their assets, attackers are
likewise adapting by developing new ways of impersonat-
ing the user. Prime examples of such methods include credit
card skimmers, hidden cameras over Automated Teller Ma-
chines (ATMs), shoulder-surﬁng, malicious computer ter-
minals in public spaces, and phishing attacks spooﬁng users
to disclose their credentials. By far the most prevalent
means of establishing a user’s identity is through password
or Personal Identiﬁcation Number (PIN). It is straightfor-
ward to see that this method of authentication is not secure
under the aforementioned threats, as the password or PIN
can be obtained by an attacker through a single observation.
Just recently, in the state of Louisiana in the United States,
25 cases of debit card skimmers have been reported which
have cost the victims each between 500 to 600 dollars [22].
These devices record users’ PINs which can then be used to
withdraw money through ATMs using a clone of the debit

card. The problem can be mitigated to some extent by using
more sophisticated methods of authentication, for instance,
biometric-based authentication or by using a trusted device.
However, these methods introduce vulnerabilities of their
own such as potential tampering with the biometric-sensing
equipment or the theft of the trusted device.

Generally speaking, in a user authentication system an
observer is an attacker who can observe and record one
or more login (authentication) sessions between the user
U (prover) and the server S (veriﬁer) in order to obtain
the user’s password P . The abstract entity, observer, can
be realized by a human via shoulder-surﬁng or by a ma-
chine such as a hidden camera, or a combination of both.
A successful attack enables the observer to impersonate the
user by deceiving the server into falsely believing that he
is the legitimate user. A stronger notion is that of an ac-
tive attacker who, in addition to having the capability of
performing an observer attack, can also maliciously manip-
ulate the communication between the user and the server to
gain further advantage in impersonating the user. One so-
lution to the observer problem is challenge-response type
authentication, which has the following general structure:

1: U sends his ID to S.
2: for i = 1 to r do
3:
4:

S sends the challenge Ci to U.
U sends the response Ri to S.

5: if the responses are correct for all the r rounds then S

accepts U else S rejects U.

Since S shares the password with U, it can verify each
response by comparing it with its own computation. The
challenge-response pairs {(Ci,Ri)}r
i=1 are communicated
in the open. The user responds by computing a publicly
known function f of the password and the challenge. The
function should be such that the password cannot be re-
vealed upon the observation of a sufﬁciently large number
of challenge-response pairs. The ﬁrst known effort to build
a challenge-response protocol secure under the threat of an
observer was made by Matsumoto and Imai [17] in 1991,
but a solution with both high security and acceptable us-
ability remains an open problem to date [14, 28].

Challenge-response protocols often follow the k-out-of-
n paradigm in which the password is a k-element subset of
a set of n objects. The objects forming the password con-
stitute the pass-objects whereas the remaining n− k objects
are the decoy objects. One type of challenge-response pro-
tocols is counting based protocols in which the user counts
the number of pass-objects present in a challenge and then
responds by computing a function f of the count. Normally,
the number of objects present in a challenge is less than
n and is called the window size. The appeal of counting
based protocols over others is their apparent usability ad-

vantage since the user has to merely recognize, count the
number of objects present in a challenge and do a simple
calculation based on the count.
In [28, § 4.4], Yan et al.
introduced a passive attack, called counting based statisti-
cal analysis, which reveals the password in counting based
protocols after the observation of far fewer sessions than
original claims. Brieﬂy, the attack involves observation of a
sufﬁciently large number of challenge-response pairs from a
protocol followed by an analysis of the difference in occur-
rence of δ-tuples of pass and decoy objects in the challenges
corresponding to different responses. Here δ is any number
between 1 and k inclusive [28]. Yan et al. did not give a
theoretical analysis as to why their attack works apart from
a demonstration of the attack on the Foxtail protocol for the
case δ = 2, i.e., by considering pairs of objects. The Foxtail
protocol was proposed in [14] as a counting based protocol
secure against observation.

OUR CONTRIBUTIONS. In this paper, we revisit the rea-
son why existing counting based protocols are not secure
against the attack from Yan et al. We point out that their
attack on Foxtail is actually based on a simpler attack that
analyzes individual objects instead of pairs. In [28], Yan et
al. stated that the simpler attack is not possible due to the
inclusion of a condition in Foxtail to ensure the number of
pass and decoy objects are the same in each challenge. This
implies that the attack is applicable to all counting based
protocols which include a similar condition. We put the
attack from Yan et al. into context by observing that in con-
trast with other statistical attacks, this attack merely ana-
lyzes the occurrence of tuples of pass and decoy objects
given challenge-response pairs. To this end, we call the
attack frequency analysis, to borrow a term from classical
cryptanalysis. We report a theoretical study on the reason
why frequency analysis works on protocols that have con-
trived challenges [28, §4.2]. We also show that the attack
is applicable to some non-counting based protocols. Where
possible, we give quantitative details of the general attack.
In addition, we demonstrate a method to theoretically esti-
mate a lower bound on the number of sessions required to
distinguish a pass-object tuple from its decoy counterpart.
This serves as a criterion to decide whether the protocol in
question is susceptible to frequency analysis in a practical
setting. We then discuss what is required to make a proto-
col practically safe from this attack, introducing two new
principles as a result. Based on the proposed new princi-
ples, we suggest two ﬁxes against the attack; one general to
all counting based protocols and the other speciﬁc to Fox-
tail. We show how these ﬁxes render the protocols practi-
cally safe from frequency analysis, although they do incur
extra usability costs. We demonstrate these amendments
using Foxtail as an example. To the best of our knowledge,
the resulting protocols are by far the most usable protocols
which remain practically secure against frequency analysis.

We invite the community to scrutinize the security of our
protocols and to investigate if there is a more usable and se-
cure (against frequency analysis and other attacks) counting
based protocol than our proposals.
ORGANIZATION. The rest of the paper is organized as fol-
lows. We discuss the related work in Section 2. Section 3
describes a general model of counting based protocols using
the Foxtail protocol as an example to concretize the attack
from Yan et al. A detailed theoretical explanation of why
their attack works is given in Section 4. We give a detailed
theoretical treatment of the generalized attack in Section 5,
and discuss the impact of different ways of generating chal-
lenges in counting based protocols in Section 6. Section
7 discusses the applications of the attack to non-counting
based protocols. We introduce two new principles and ﬁxes
against the attack in Section 8. Section 9 contains conclud-
ing remarks.

2. Related Work

In accordance with the theme of the paper, we shall re-
strict this brief review of literature to generic attacks and
design principles related to challenge-response type user au-
thentication protocols. Furthermore, since we consider pas-
sive adversaries only, we shall not discuss active attacks. As
mentioned before, the ﬁrst attempt at constructing a proto-
col secure against a powerful passive adversary dates back
to Matsumoto and Imai [17]. The protocol was shown to
be susceptible to a passive attack in [24], but the attack is
speciﬁc to the protocol. Li and Teng [15] proposed another
attack on the same protocol which can be categorized as an
intersection attack. Roughly speaking, an intersection at-
tack attempts to ﬁnd the password by checking if a set of
candidates for the password satisfy a speciﬁc criterion. As
more and more sessions are observed, the size of the candi-
date set diminishes as members failing the criterion are dis-
carded. A brute force attack can be considered as the most
computationally intensive intersection attack. Intersection
attack has also been demonstrated on Predicated-based Au-
thentication Service (PAS) [27] by Li et al. in [12]. In [16],
Matsumoto proposed protocols that are secure up until a
certain number of sessions after which Gaussian elimina-
tion can be used to ﬁnd the password. This algebraic at-
tack can ﬁnd the password by observing a number of ob-
served challenge-response pairs which is linear in the size
of the challenge. Subsequent protocols that have incorpo-
rated resilience against Gaussian elimination in their design
include Hopper and Blum (HB) [9], Foxtail [14], and As-
ghar, Pieprzyk and Wang (APW) [3] protocols. Another
algebraic attack was demonstrated on the virtual password
scheme [10, 11] by Li et al. in [13]. Satisﬁability (SAT)
solvers have been used by Golle and Wagner [8] to demon-
strate the insecurity of Weinshall’s Cognitive Authentica-

tion Scheme (CAS) [25]. SAT solvers can ﬁnd the secret
once the information from the challenge-response pairs can
be translated in the form of SAT clauses.

Hopper and Blum [9] introduced a meet-in-the-middle

attack of time complexity O((cid:0) n

k/2

(cid:1)) which is much more

efﬁcient than the brute force attack. They also showed that
it is not possible to circumvent this attack even by introduc-
ing noise, implying that the attack is also applicable to the
HB protocol introduced in the same paper which is based
on the NP-hard problem of learning parity with noise. Yan
et al. also showed that the introduction of noise does not
preclude brute-force attack [28, §4.4]. An improved meet-
in-the-middle attack was shown by Asghar et al. in [3] with

(cid:1)). In [4], it is shown that the

a time-complexity of O((cid:0)n/2

k/2

other protocol from [9], namely the sum of k mins protocol,
is based on a ﬁxed-parameter intractable problem, which
roughly means that the best possible worst-case algorithms
to ﬁnd the secret will take time nf (k) for some function f.
Coskun and Herley introduced a generic attack on proto-
cols which use a subset of the password to compute a re-
sponse in each round [7]. The attack has a far lower time-
complexity than the brute force attack if the subset of the
password used is small. The attack is based on the obser-
vation that candidates for the password which are different
from the password in a small number of objects can be eas-
ily distinguished from others since their responses are much
more similar to those computed using the password.

Li and Shum introduced several design principles to
overcome some of the vulnerabilities in the previous proto-
cols [14]. The principle relevant to security against passive
attacks suggests including uncertainty in the protocol; for
instance, by occasionally sending an intentionally wrong re-
sponse. Yan et al. speciﬁed several design principles in [28].
The ﬁrst of them recommends a large secret space, and it
even applies to protocols that have hidden responses such
as the Undercover protocol [20]. This vulnerability on Un-
dercover was also independently demonstrated by Perkovi´c
et al. with the same intersection attack [18]. Note that if the
challenges are ﬁxed instead of randomized, Undercover is
not vulnerable to this attack [18, §4.3.1]. The second princi-
ple suggests that the subset of password used for each round
of a challenge-response protocol should be large. The third
principle relates to the distribution of objects in a challenge
when a certain constraint on the number of secret-objects
present in a challenge is required, e.g., at least 3 secret ob-
jects be present in the challenge as in the case of the Convex
Hull Click (CHC) protocol [21, 26]. The principle suggests
that in such a construction, all objects should be present
in a challenge. The fourth principle is related to protocols
in which it is possible to construct a probabilistic decision
tree based on the challenge-response pairs. To avoid an at-
tack based on this, it should not be possible to distinguish
individual objects in a decision path consistent with the ob-

served challenge-response pair. According to the authors,
this attack is specially dangerous on protocols which have
any weight or orientation information associated with the
objects such as CAS [25]. The last principle states that the
protocols be designed such that they are resistant to count-
ing based statistical analysis, which is the focus of this pa-
per.

3. Counting based Protocols and Foxtail

Although the attack proposed by Yan et al. in [14] was
demonstrated on the Foxtail protocol1 only, it can in general
be applied to a class of protocols that are based on count-
ing pass-objects in a challenge. It is therefore essential to
present a general model of counting based protocols.

3.1. General Model of Counting based Protocols

Counting based protocols are multi-round challenge-
response protocols based on a pool (set) of n objects O =
{o1, . . . , on}. The password, challenges and responses are
deﬁned as follows:

– The password P is a k-element subset of O, where k <
n. We shall call an element of P , a pass-object. P can
be represented as the set {ρ1, ρ2, . . . , ρk}, where ρi are
the pass-objects.2 The set D = O − P is called the
decoy set, and all its elements are called decoy objects.
A decoy object shall be denoted by d. Notice that since
is O ﬁxed, D is also ﬁxed.

– Each challenge Ci is a ﬁnite sequence of objects from
a subset of O. A sequence is different from a set in
that each element can occur multiple times and the or-
der of the elements matters. The notation #Ci denotes
the length of the sequence. For any subset O(cid:48)
⊆ O,
let Ci(O(cid:48)) be the subsequence of Ci containing objects
from O(cid:48). Ci(O(cid:48)) is empty if no object from O(cid:48) is in Ci.
#Ci(O(cid:48)) denotes the length of this subsequence. From
these deﬁnitions, we see that for the password P ,

(cid:88)

ρ∈P

#Ci(P ) =

#Ci({ρ}).

Informally, #Ci(P ) is the sum of all occurrences of
pass-objects in the challenge Ci.

– The response is deﬁned as Ri = f (#Ci(P )), where
In the

f is a function, called the response function.

1Yan et al. call this protocol SecHCI, but SecHCI is actually used as an
umbrella term in [14] for protocols intended to be secure against observer
attacks. We therefore use the term Foxtail instead, which alludes to the
speciﬁc function described above.

2The reason for using ρ instead of p for pass-objects is that the latter

symbol is reserved for probabilities.

simplest case, Ri = #Ci(P ), thus making a response
only requires counting the occurrence of pass-objects
in the challenge. Another example of f is mod q for
any q ≥ 2.

3.2. Foxtail and the Attack from Yan et al.

Since Yan et al. used the Foxtail protocol to demonstrate
their attack, we describe the protocol here for reference. It
should be noted that the attack can be generalized for any
counting based protocol. The Foxtail protocol proposed
in [14] is a counting based protocol which implements the
challenge and the response function f as follows:

– A challenge Ci contains two half-challenges, each

composed of l objects.

– The ﬁrst half Ci,1 is generated following the so-
called Uni-rule (meaning uniform rule) such that
Ci,1 contains 0, 1, 2 or 3 pass-objects with equal
probability. This implies that the number of pass-
objects in the ﬁrst half challenge cannot be more
than 3.
– The second half Ci,2 is generated through the so-
called Rand-rule (meaning random rule) which
means that each element in Ci,2 is generated by
randomly picking an object from the object pool
O.

– The response function is as follows:

(cid:23)
(cid:22) #Ci(P ) mod 4
(cid:23)
(cid:22) (#Ci,1(P ) + #Ci,2(P )) mod 4

2

Ri = f (#Ci(P )) =

=

2

∈ {0, 1}.

The objects from the two half-challenges are randomly
shufﬂed in Ci so that the attacker does not know which ob-
ject belongs to which of the two half-challenges. To ensure
that the pass and decoy objects occur in the challenge with
the same probability, 3n = 2kl must hold [14]. A recom-
mended set of parameter values for Foxtail is (n, k, l) =
(140, 14, 15). This setting was believed to be able to offer
a balance between usability and security against all known
attacks [14]. The number of rounds r is 20 to make sure that
the probability of randomly guessing the response to a chal-
lenge is approximately one in a million. Unless otherwise
mentioned, r is understood to be 20.

In [28], Yan et al. pointed out that the above men-
tioned Foxtail protocol is not secure against a 2-dimensional
counting based attack which exploits the following observa-
tion about Foxtail with the recommended parameter values:

– In all challenges corresponding to a 0-response, there
are 0.599 more pairs among pass-objects on average.

– In all challenges corresponding to a 1-response, there
are 0.599 fewer pairs among pass-objects on average.

Based on this response-dependent imbalance, a score can
be maintained for each object pair in two tables, one for
each response. That is, for each challenge-response pair we
see if the object-pair is present or not. If it is present, we
increment the score by 1 in the table corresponding to the
response. The ﬁnal score is the difference in scores between
the 0-response and the 1-response. By observing a sufﬁcient
number of authentication sessions, it is possible to differen-
tiate pass-object pairs from decoy-object pairs because the
former tend to have higher scores. Yan et al. call this attack
2-dimensional counting attack and attributed its success to
the correlation between the password and the responses in
two-dimensional space.

In this paper, we shall refer to this type of attack
as response-dependent frequency analysis, abbreviated as
RDFA. The name alludes to the observation that this type
of attack essentially analyzes the difference in the fre-
quency of occurrence of objects in challenges. A response-
independent frequency analysis is also possible as noted
by Yan et al. [28].
In the Foxtail protocol, the condition
3n = 2kl is required to prevent precisely this attack. Again,
for brevity’s sake, we shall refer to this variant as RIFA.
More generally, we will refer to a RDFA (resp., RIFA)
involving δ-tuples of objects as δ-dimensional RDFA or
δD-RDFA (resp., δD-RIFA). The umbrella term, frequency
analysis, covers both RIFA and RDFA.

4. Revisiting the Attack from Yan et al. on Fox-

tail

While Yan et al. attributed the success of 2D-RDFA to
the correlation in 2-dimensional (2D) space, they did not
give a theoretical explanation as to why their attack works
other than demonstrating the attack with experimental re-
sults.
In this section we show that a simpler attack also
works in 1-dimensional (1D) space, leading to the ﬁnding
that the attack from Yan et al. is in fact a generalization of
the 1D attack to 2D space. In other words, we show that 1D-
RDFA is also possible on the Foxtail protocol, and it is the
theoretical basis of 2D-RDFA proposed by Yan et al. Note
that they mentioned that due to the condition 3n = 2kl,
1D frequency analysis is not possible on Foxtail [28, §4.4].
However, as we will show later this condition only pre-
cludes 1D-RIFA. Leaving general results aside for now, we
begin with the detailed description of 1D-RDFA and how it
works on Foxtail.

In the original security analysis of the Foxtail protocol
given in [14], the occurrence of different objects in the chal-
lenges are calculated without considering the responses.
However, since the passive observer can see the responses,

he can divide the challenges into two sets, each correspond-
ing to one response bit, and then analyze them separately.
To proceed with this idea, let us see what are the values
of c1 = #Ci,1(P ) and c2 = #Ci,2(P ) when the response is
known. We can see, for instance, that when Ri = 0, (c1, c2)
can take the values

(0, 0), (0, 1), (1, 0), (1, 3), (2, 2), (2, 3), (3, 1), (3, 2), . . . ,

and when Ri = 1, (c1, c2) can have the values
(0, 2), (0, 3), (1, 1), (1, 2), (2, 0), (2, 1), (3, 0), (3, 3), . . . .

Observing the above, we can see that the expected occur-
rence of any pass-object ρ could be different under the two
conditions.
In addition, the expected occurrence of any
pass-object could also be different from that of any decoy
object. To ﬁnd an explicit equation for the expected occur-
rence of any object, we need to deﬁne a few notations for
succinctness. Let p(cid:48)
c1 denote the probability of the event
#Ci,1(P ) = c1, and let pc2 denote the probability of the
event #Ci,2(P ) = c2. Further, denote the probability that
ρ appears when a half-challenge contains c pass-objects by
qc.3 Assume R ∈ {0, 1}. Given R and c1, deﬁne the sets

(cid:26)

(cid:12)(cid:12)(cid:12)(cid:12)c2 ∈ {0, . . . , min(k, l)} and
(cid:27)
(cid:22) (c1 + c2) mod 4

(cid:23)

FR(c1) =

c2

2

= R

.

(1)

Note that there can be a maximum of min(k, l) pass-objects
in the second half-challenge, therefore c2 is always less than
or equal to this number. On the other hand, the ﬁrst half-
challenge can have a maximum of 3 pass-objects. For com-
pactness, we shall use FR to denote FR(c1). The choice
of the symbol F for these sets alludes to the fact that it is
dependent on the response function f. Deﬁne

3(cid:88)

(cid:88)

c1=0

c2∈FR

˜pR =

p(cid:48)

c1

pc2 ,

(2)

which denotes the probability that the response is R.
Now, denote the expected occurrence of a pass-object in
a challenge corresponding to response R by ξρ(n, k, l,R)
or ξρ(R) for simplicity. Then
(cid:88)
p(cid:48)
c1
(cid:88)
3(cid:88)
˜pR

ξρ(R) =

3(cid:88)

(qc1 + qc2)

pc2

c1=0

c2∈FR

pc2(qc1 + qc2 ).

(3)

p(cid:48)

c1

=

1
˜pR

c1=0

c2∈FR

3Note that qc is the same for both half-challenges. For a ﬁxed c, there

is no distinction as to which pass-objects are chosen.

For the Foxtail protocol under study, the three probabilities
have the following values:

(2) If ξρ(0) > ξρ(1), then ξρ(0) ≥ ξd(1) > ξd(0) ≥ ξρ(1)

and the equalities hold if and only if n = 2k.

p(cid:48)

c1

=

1
4

, pc2 =

, qc =

c
k

.

(4)

(3) If ξρ(0) < ξρ(1), then ξρ(0) ≤ ξd(1) < ξd(0) ≤ ξρ(1)

and the equalities hold if and only if n = 2k.

n . So we have ξρ(0) = ξρ(0)+ξρ(1)

Proof. First consider Part (1). If ξρ(0) = ξρ(1) then Part (1)
of Theorem 1 readily gives ξd(0) = ξd(1), since otherwise
it implies n = k, which is not allowed. This implies that
ξρ(0) − ξρ(1) = ξd(0) − ξd(1) = 0. For the converse, note
that if ξρ(0)−ξρ(1) = ξd(0)−ξd(1) and ξρ(0)−ξρ(1) (cid:54)= 0,
then Part (1) of Theorem 1 gives n − k = −k ⇒ n = 0,
which is absurd. So, the only other possibility is if ξρ(0) −
ξρ(1) = 0. This readily implies ξρ(0) = ξρ(1).
Next, take Part (2). According to Part (1) of Theorem 1,
ξρ(0) > ξρ(1) implies ξd(0) < ξd(1). Furthermore, Part (2)
of the theorem says that if 3n = 2kl, then ξρ(0) + ξρ(1) =
ξd(0) + ξd(1) = 4l
+
ξρ(0)−ξρ(1)
, where the last equality
n +
holds since ξρ(0) − ξρ(1) is positive. Similarly we can get
. An analogous procedure shows
ξρ(1) = 2l
, which is true since ξd(0)−ξd(1)
ξd(0) = 2l
. Now,
is negative, and likewise ξd(1) = 2l
k . This
from Part (1) of Theorem 1,
2 . Now,
gives us |ξρ(0) − ξρ(1)| ≥ |ξd(0) − ξd(1)|, if k ≤ n
2 is not permissible, as this implies l < 3 when put
k > n
in 3n = 2kl, which violates the condition imposed by the
ﬁrst-half challenge (since it requires l ≥ 3). Therefore, this
gives us |ξρ(0)−ξρ(1)|
and the equality holds
if and only if n = 2k. This immediately leads to the result
we want to prove.

(cid:12)(cid:12)(cid:12) ξρ(0)−ξρ(1)

(cid:12)(cid:12)(cid:12) = n−k

|ξρ(0)−ξρ(1)|
|ξd(0)−ξd(1)|

|ξd(0)−ξd(1)|

|ξd(0)−ξd(1)|

|ξρ(0)−ξρ(1)|

n −
n −

ξd(0)−ξd(1)

= 2l

2

2

n +

2

2

2

≥

2

2

2

The proof of Part (3) is analogous to that of Part (2) with

the inequalities reversed.
Corollary 2. Let 3n = 2kl. If ξρ(0) − ξρ(1) = ξd(0) −
ξd(1), ξρ(0) = ξd(0) and ξρ(1) = ξd(1) then ξρ(0) =
n .
ξρ(1) = ξd(0) = ξd(1) = 2l

Proof. This follows immediately from Part (1) of Corollary
1 and Part (3) of Theorem 1.

Lemma 1. If 3n = 2kl and ξρ(0) = ξρ(1) = ξd(0) =
ξd(1) = 2l

n then p(0, m1) = p(2, m2), where

p(0, m1) = p0 + p4 + p8 + ··· + pm1,
p(2, m2) = p2 + p6 + p10 + ··· + pm2,

m1 = (cid:98)min(k, l)/4(cid:99), m2 = 2 + (cid:98)(min(k, l) − 2)/4(cid:99),4 and
the pi are as deﬁned in Eq. (4).

Proof. The proof is given in the full edition of this paper.

(cid:0) k

c2

(cid:1)

(cid:1)(cid:0)n−k
(cid:0)n
(cid:1)

l−c2

l

Similarly, we can derive the expected occurrence of a decoy
object d per challenge for both responses. Denote this by
ξd(R). We have

3(cid:88)

(cid:88)

c1=0

c2∈FR

ξd(R) =

1
˜pR

p(cid:48)

c1

pc2 (q(cid:48)

c1

+ q(cid:48)

c2

).

(5)

c = l−c

Here, q(cid:48)
n−k denotes the probability that d appears when
a half-challenge contains c pass-objects. From these equa-
tions, we see that it is possible to differentiate a pass-object
from a decoy object if any of the three inequalities holds:
1. ξρ(0) (cid:54)= ξd(0).
2. ξρ(1) (cid:54)= ξd(1).
3. ξρ(0) − ξρ(1) (cid:54)= ξd(0) − ξd(1).
For the recommended parameters of Foxtail, we es-
timated the values of ξρ(0), ξρ(1), ξd(0) and ξd(1) us-
ing Monte Carlo simulations. The results are as follows:
ξρ(0) ≈ 0.218548, ξρ(1) ≈ 0.210024, ξd(0) ≈ 0.213812,
ξd(1) ≈ 0.214759. One can see that the ﬁrst two inequali-
ties hold. It is obvious that the third inequality also holds:
ξρ(0) − ξρ(1) ≈ 0.008524 > ξd(0) − ξd(1) ≈ −0.000947.
Not only does ξρ(0) − ξρ(1) has a different sign from
ξd(0) − ξd(1), but also its amplitude is 9 times higher than
the latter. These results merely show that the inequalities
hold when the parameters are (n, k, l) = (140, 14, 15). It
still leaves open the possibility that there is a set of values
for which these inequalities do not hold. Unfortunately, in
the following, we show that this is not possible if 3n = 2kl.
Theorem 1. Let ξρ(R) and ξd(R) be as deﬁned in Eqs. (3)
and (5), then
(1) ξρ(0) − ξρ(1) = − n−k
(2) If 3n = 2kl, then ξρ(0) + ξρ(1) = ξd(0) + ξd(1) = 4l
n .
Proof. The rather tedious proof of this theorem is given in
the full edition of this paper.
Corollary 1. Let ξρ(R) and ξd(R) be as deﬁned in Eqs. (3)
and (5), then
(1) ξρ(0) = ξρ(1) if and only if ξρ(0) − ξρ(1) = ξd(0) −

k (ξd(0) − ξd(1)).

ξd(1).

Further if 3n = 2kl, then

4For instance, if k = 14 and l = 15, then m1 = 12 and m2 = 14.

We can show with the help of a computer simulation
(using inﬁnite precision) that none of the values of n, k
and l, where n ≤ 5000, meeting the condition 3n = 2kl,
satisfy p(0, m1) = p(2, m2). Beyond this value of n,
p(0, m1) (cid:54)= p(2, m2) still seems to hold, but due to time
constraints we did not try to verify this. Regardless of this
limitation, a value of n larger than 5000 seems impractical.
In fact, the usability threshold is arguably much lower than
5000. This is true since k needs to be small due to human
memory constraints. Let us say that the value of k is desired
to be no more than 30. Then we get l = 250 which means
a window size of 500. It remains an open problem to obtain
an analytical proof of the following conjecture for all values
of n.
Conjecture 1. If 3n = 2kl, then p(0, m1) (cid:54)= p(2, m2) for
all values of n ≤ 5000.
Proof. Computer assisted. See Appendix A for the algo-
rithm used to verify this conjecture.

The above conjecture tells us that for all practical values

of (n, k, l) the following always hold:
1. ξρ(0) − ξd(0) (cid:54)= 0,
2. ξρ(1) − ξd(1) (cid:54)= 0,
3. (ξρ(0) − ξρ(1)) − (ξd(0) − ξd(1)) (cid:54)= 0.
Any of the three inequalities above can be used for 1D-
RDFA. We shall refer to the left-hand terms in these in-
equalities as differentials. Moreover, since the last differ-
ential involves two response values instead of just one, we
should call it the two-response differential to distinguish it
from the one-response differentials. Among the three, the
two-response differential has the best differentiation capa-
bility. To see this, ﬁrst assume that ξρ(0) > ξρ(1). Then
(ξρ(0) − ξρ(1)) − (ξd(0) − ξd(1)) = (ξρ(0) − ξd(0)) +
(ξd(1) − ξρ(1)). Since the expressions ξρ(0) − ξd(0) and
ξd(1) − ξρ(1) are positive, according to Part (2) of Corol-
lary 1, it follows that (ξρ(0) − ξρ(1)) − (ξd(0) − ξd(1))
if
is greater than the ﬁrst two differentials. Similarly,
ξρ(0) < ξρ(1), we get (ξd(0)− ξd(1))− (ξρ(0)− ξρ(1)) =
(ξd(0) − ξρ(0)) + (ξρ(1) − ξd(1)). Once again the two ex-
pressions on the right are positive, leading to the desired
conclusion. Therefore, the two-response differential will
be used to explain how 1D-RDFA works. The attack is
based on counting the occurrence of all objects in a ﬁxed
number of observed authentication sessions and storing the
numbers corresponding to 0-responses and 1-responses sep-
arately. For each object we deﬁne the difference between its
occurrence in 0-response challenges and that in 1-response
challenges as its frequency difference. Then we rank all the
objects according to their frequency differences, and pick
the top k ranked objects as the recovered k pass-objects. We

have assumed here that ξρ(0)−ξρ(1) > ξd(0)−ξd(1). If the
reverse is true then the attack picks the bottom k ranked ob-
jects. Our simulated attacks showed that this 1D-RDFA can
recover around half of the pass-objects with around 1,000
observed authentication sessions and all pass-objects with
about 7,000 observed authentication sessions using the de-
fault parameter values (n, k, l) = (140, 14, 15). While the
number of authentication sessions is large, the attack does
show the theoretical insecurity of the Foxtail protocol for
long-term use without password renewal.

From the imbalance between the expected occurrence of
pass-objects and decoy objects in 1D space, one can eas-
ily extend the attack to 2D space by considering pairs of
objects. This is exactly what Yan et al. demonstrated in
their paper [28]. By checking object pairs, the chance of
decoy objects getting ranked higher than pass-objects be-
comes even lower compared with the 1D case, so the attack
allows recovering the password with a much smaller num-
ber of observed authentication sessions. Figure 1 shows the
results of a simulated 2D attack, which agrees well with the
results reported in [28].

Figure 1. The rate of successfully recovered
pass-objects w.r.t.
the number of observed
authentication sessions.

5. Generalized Frequency Analysis

So far we have discussed 1D and 2D-RDFA. This can
be generalized to any δ ∈ {1, . . . , k} in a straightforward
manner. We have also seen that the condition 3n = 2kl is
imposed on Foxtail to prevent 1D-RIFA. As it turns out, this
condition only precludes 1D-RIFA, and multi-dimensional
RIFA is still possible. To understand this, we extend the
notion of expected occurrences developed in the previous
section to include response-independence. Speciﬁcally, we
allow R to take on another value, symbolized by ∞, which

0100200300400500600700800900100000.10.20.30.40.50.60.70.80.91Number of observed authentication sessionsRate of successfully recovered pass−objectsindicates that the response is irrelevant. Then

F∞(c1) = ∪R FR(c1) = F0(c1) ∪ F1(c1)
= {c2 |c2 ∈ {0, . . . , min(k, l)}}
= {0, . . . , min(k, l)}.

Since F∞(c1) is independent of c1, it is natural to denote
this simply as F∞. Now for any δ ∈ {1, . . . , k} and for any
(cid:88)3
R ∈ {0, 1} ∪ ∞, we have
(cid:88)3

(cid:88)
(cid:88)

ξδ
ρ(R) =

pc2q(c1, c2),

c2∈FR

1
˜pR

and

(6)

p(cid:48)

c1

c1=0

p(cid:48)

c1

pc2 q(cid:48)(c1, c2).

(7)

ξδ
d(R) =

1
˜pR

c1=0

c2∈FR

If δ = 1, we shall often ignore the superscript to be con-
sistent with the notation used previously.
In the above,
q(c1, c2) is the probability that a pass-object δ-tuple occurs
in a challenge containing c1 and c2 pass-objects in the ﬁrst
and second-half challenges, respectively. q(cid:48)(c1, c2) is de-
ﬁned similarly for a decoy object δ-tuple.5
In the previ-
ous section, we showed explicit equations of q(c1, c2) and
q(cid:48)(c1, c2) for the case δ = 1 and R ∈ {0, 1}. The expres-
sions are the same for δ = 1 and R = ∞. Unfortunately,
for higher values of δ these probabilities are not easily ex-
pressible since a large number of cases has to be consid-
ered which increases with δ. However, we can still estimate
these quantities empirically using Monte Carlo simulations.
Thus, we shall be using experimental estimates when con-
sidering δ > 1.

ρ(∞)− ξ1

ρ(∞) − ξ2

ρ(∞) = ξδ

Now if 3n = 2kl, then ξ1

d(∞), which im-
ρ(∞) = ξ1
plies that 1D-RIFA will not be fruitful. But this does not
d(∞) for δ ≥ 2. For in-
necessarily imply ξδ
stance, the values (n, k, l) = (20, 5, 6), although artiﬁcially
d(∞) = 0. Yet,
small, satisfy 3n = 2kl implying ξ1
by simulating 100,000 Foxtail challenge-response pairs, we
d(∞) = 0.01256 which is signiﬁ-
ﬁnd that ξ2
cantly larger than 0. Thus, a 2D-RIFA is plausible.
In
100 trials, we were able to obtain the password in 386 ses-
sions on average with these parameters. By contrast 2D-
RDFA with two-response differential, i.e., using the differ-
ence (ξ2
d(1)), was able to ﬁnd
the secret in merely about 13 sessions. Although the per-
formance of 2D-RIFA is poorer, the results show that the
attack is possible nonetheless.

ρ(1)) − (ξ2

ρ(0) − ξ2

d(0) − ξ2

It is worthwhile to see if higher dimensional frequency
analysis reveals the password in fewer sessions. To this
end, we ran a Monte Carlo simulation with the values

5We do not consider tuples which are composed of both pass and decoy
objects for two reasons. First it makes the analysis increasingly complex.
d(R) holds for all δ, then the expected occurrences
Second, if ξδ
of the mixed δ-tuples also tend to be the same.

ρ(R) = ξδ

ρ(∞)−ξδ

ρ(R) and ξδ

(n, k, l) = (140, 14, 15), to estimate ξδ
d(R)
by randomly sampling 100,000 challenge-response pairs.
Based on these results, the three differentials mentioned in
the previous section together with the no-response differen-
tial ξδ
d(∞) are plotted in Figure 2, as δ ranges from
1 to k. As is evident, the differentials are non-negligible
uptil δ = 4, after which they approach 0. The ﬁgure sug-
gests that higher dimensional frequency analysis (beyond
δ = 4), in general, might not be practical in ﬁnding the
ρ(R) approaches 0
password since the difference ξδ
rapidly with increasing δ. This also makes intuitive sense;
as δ increases the expected occurrence of a δ-tuple also de-
creases (more objects need to be in a challenge at the same
time), this in turn increases the number of samples required
to distinguish between pass and decoy object δ-tuples. The
smaller the value of the differential, the larger the number
of challenge-response pairs required to reveal the password.
Together with Conjecture 1, this also shows that it is not
possible to ensure ξδ
d(R) holds for all δ and all R
in the Foxtail protocol.

ρ(R) = ξδ

ρ(R) − ξδ

Figure 2. The no-response, one-response and
two-response differentials as d ranges from 1
to k.

In practice, however, negligible values of the differ-
entials are sufﬁcient, as it will take a huge number of
challenge-response pairs to obtain the password. It is im-
portant, then, to ﬁnd a theoretical estimate of the number
of pairs required to distinguish between a pass and decoy
object δ-tuple with a given probability. Let us deﬁne an in-
dicator random variable I δ
ρ (i,R) which is 1 if a pass-object
d (i,R) is deﬁned likewise.
δ-tuple occurs in a challenge. I δ
To illustrate the estimation method, we consider 2D-RDFA
with two-response differential. The case for other variants
is similar. Two-response 2D-RDFA examines the following
probability:

(cid:104)(cid:88)m

Pr

ρ (i, 0) − I δ
(I δ

ρ (i, 1))

i=0

02468101214Dimensionδ−0.010−0.0050.0000.0050.0100.015ξδρ(∞)−ξδd(∞)ξδρ(0)−ξδd(0)ξδρ(1)−ξδd(1)(ξδρ(0)−ξδρ(1))−(ξδd(0)−ξδd(1))(cid:88)m

i=0

>

(cid:105)

d (i, 0) − I δ
(I δ

d (i, 1))

.

We have assumed that the frequency difference of the pass-
object δ-tuples is higher than that of decoy object δ-tuples.
If the opposite is true, the inequality can be duly reversed.
Also, it is implicitly assumed that there is an equal num-
ber of challenge-response pairs corresponding to 0 and 1-
responses at our disposal. This is reasonable since the re-
sponse is uniformly distributed. Thus, m is in fact half of
the total number of pairs observed. Let

I1 = I δ

ρ (i, 0), I2 = I δ

ρ (i, 1), I3 = I δ

d (i, 0) and I4 = I δ

d (i, 1).

Deﬁne

Z δ
ρ,d(i,R) = I1−I2−I3 +I4 = a1I1 +a2I2 +a3I4 +a4I4,
where a1 = 1, a2 = −1, a3 = −1 and a4 = 1. The ex-
pected value of Z δ

ρ,d(i,R) is

E[Z δ

ρ,d(i,R)] = a1E[I1] + a2E[I2] + a3E[I3] + a4E[I4]

d(0) + ξδ

d(1).

Its variance is

Var[Z δ

ρ,d(i,R)] =

= ξδ

ρ(0) − ξδ
4(cid:88)

ρ(1) − ξδ
4(cid:88)

jVar[Ij]+2
a2

j=1

j=1

k>j

(cid:88)

ajakCov[Ij, Ik],

where Cov(·,·) is the covariance. Denote E[Z δ
µZ and Var[Z δ
translates into

ρ,d(i,R)] by
Z. The aforesaid probability

(cid:105)

ρ,d(i,R)] by σ2
(cid:104)(cid:88)m
(cid:34)(cid:80)m
(cid:18)

Z δ
ρ,d(i,R) > 0

i=0 Z δ

(cid:19)

√mµZ

i=0

ρ,d(i,R) − mµZ
σZ√m

Pr

= Pr

≈ Φ

−

σz

,

(cid:35)

√mµZ

σz

> −

(cid:104)(cid:80)m

where Φ(·) is the cumulative distribution function of a stan-
dard normal random variable. The approximation follows
from the central limit theorem [19, §8.3, p. 434]. Now, say
≥ 0.6, then we can esti-
we let Pr
≥ 0.6,

mate the number of pairs required as Φ
which means

ρ,d(i,R) > 0

i=0 Z δ

mµZ
σz

(cid:16)

(cid:17)

(cid:105)

−

√

√mµZ

σz ≥ 0.25335 ⇒ m ≥

−

0.06419σ2
Z

µ2
Z

.

As discussed before, since m is half of the challenge-
response pairs observed, the total number of pairs required
is double this amount. Let us denote this by mlb, i.e.,
mlb = 2m, where lb stands for lower bound. Similarly,

Table 1. Number of pairs required such that
ρ,d(i,R) > 0] = 0.6, with n = 140, k = 14
Pr[Z δ
and l = 15.

δ

1

mlb = pairs
slb = sessions

µZ
σ2
Z

1095
55

0.00947
0.76527

2
136
7

3
489
24

0.01204
0.15345

0.00280
0.02987

4

5

14144
707

0.00022
0.00533

47742
2387

-0.00005
0.00093

we denote the number of sessions corresponding to mlb by
slb. With the values (n, k, l) = (140, 14, 15) we calculated
the number of samples required so that the probability of
distinguishing a pass-object δ-tuple from a decoy-object δ-
tuple is at least 0.6. The results are shown in Table 1. Be-
yond δ = 5 the numbers are negligible, and as such are
not shown in the table. We obtained these results with the
help of a Monte Carlo simulation, estimating the expected
value and variance of Z δ
ρ,d(i,R). While this leaves room for
slight errors, we can still notice a trend, namely as δ grows
beyond its ﬁrst few values, a very high number of samples
are required to distinguish between the two types of tuples.
Note that these results do not mean that the adversary
can obtain the entire password after these many samples, or
even obtain a single pass-object δ-tuple. This only serves
as a lower bound, which is a loose but safe. For instance,
it takes on average about 711 sessions to ﬁnd the whole
password using 2D-RIFA with these parameter values [28]
whereas the corresponding value of slb in Table 1 is only
7. But in practice, it might not be possible to ﬁnd the aver-
age number of sessions required to ﬁnd the password using
δ dimensional frequency analysis for each δ ≤ k through
simulations, since the computational burden increases con-
siderably. Under such circumstances, one can use mlb or
slb as a safe lower bound to limit the number of sessions a
protocol can be used with the same password. As a marker,
at least 2,000 authentication sessions is reasonable. An es-
timate of the number of challenge-response pairs required
to obtain the whole password remains an open problem. It
appears that no practical values of the parameters in Fox-
tail can ensure slb > 2000 for all δ. As an example, with
the parameters (n, k, l) = (160, 24, 10), for which a brute-
force attack has time complexity greater than 280 [14], two-
response 2D-RDFA was able to ﬁnd the password in a little
more than 1,200 sessions on average in 10 trials.

6. Is the Challenge Generation Method the

Culprit?

It is interesting to ponder whether the method of generat-
ing challenges in counting based protocols is the reason for
the disparity in the differentials. To analyze this we inves-

tigated three variants of Foxtail. The ﬁrst variant of Foxtail
does not contain a window, and we duly call this the no-
window Foxtail. A challenge in this variant is generated by
sampling each object uniformly at random, i.e., each object
is included in the challenge with probability 1/2. Another
way of looking at this is that now we have a variable length
window. The other two variants are derived from the way
the two half-challenges are generated in the original Foxtail.
We name these variants the Uni-rule and the Rand-rule Fox-
tail after the way the challenges are generated. Both these
variants have a ﬁxed window size of l. Note that there are no
half-challenges used for all these variants of Foxtail. Notice
that the combination of the two challenges in the original
Foxtail was there to circumvent a partially known password
attack, which is a much stronger notion of security not con-
sidered in this paper.

For comparison, the formulas for the differentials are
shown in Table 2. As an example, the derivation of the re-
sults for no-window Foxtail is shown in Appendix B. The
derivation for the other two is more involving and is given
in the full version of the paper. The parameter λ in Uni-rule
Foxtail is a ﬁxed positive integer ≤ k + 1. In the original
Foxtail, it was ﬁxed at 4 for the ﬁrst half-challenge. The
parameter ensures that the probability of a 0-response is the
same as the probability of a 1-response. As a result the
2 in case of Uni-rule Foxtail. This
quantities ˜p0 and ˜p1 are 1
is also true in case of the original Foxtail (The proof is in the
full edition of the paper). This is not the case with the no-
window and Rand-rule Foxtail. The resulting bias means
an increased success probability of random guess. How-
ever, for reasonably large values of protocol parameters the
difference in probabilities is too small for random guess to
have any advantage. On the other hand, these two variants
of Foxtail do not require any condition to ensure that the
no-response differential is 0 for δ = 1. In fact, in contrast
with the Uni-rule and original Foxtail, the no-response dif-
ferential is 0 for any value of δ. See Appendix B for the
proof of this result for the no-window Foxtail. The proof
for the Rand-rule Foxtail is much longer and is given in the
full edition of the paper.

On the other hand, the response based differentials are
not necessarily zero. An interesting observation is that the
differentials in no-window Foxtail are only dependent on k,
and not on n. Thus, it is possible to minimize the differ-
entials by increasing k alone. Due to the absence of half-
challenges, the expression for higher-dimensional differen-
tials is straightforward in all these variants of Foxtail. Fig-
ure 3 shows these differentials for the no-window Foxtail.
As the ﬁgure suggests, when n = 140 and k = 14 the
lower-dimensional differentials are non-negligible, but with
k = 25 they are very small. Note that the y-axis scale is
different in the two plots. Table 3 shows the number of ses-
sions required to distinguish a pass-object δ-tuple from its

decoy object counterpart (i.e., slb). As can be seen, slb is
quite large. This is not the case with k = 14. For instance,
with δ = 2, the two-response differential requires only 35
sessions to distinguish. Notice that the original Foxtail is
still not secure against frequency analysis with the compar-
ative value of k = 24 as mentioned before, with n = 160
and l = 10.

(a)

(b)

Figure 3. The differentials for no-window Fox-
tail with (a) n = 140 and k = 14, (b) n = 140
and k = 25.

We can conclude from this that the no-window Foxtail
is safe from frequency analysis with n = 140 and k = 25,
since it can be used for a sufﬁciently large number of ses-
sions. However, this is still not satisfactory for two main
reasons. First, although it can be used for a huge number of
sessions (at least 64,000), we would like to see if there is a
way to completely remove the threat of frequency analysis
no matter how many sessions are observed. Secondly, the
values of parameters for which the protocol is safe are ar-
guably not practical. The introduction of a window in the
original Foxtail ensures that the number of objects in a chal-
lenge are ﬁxed, i.e., 2l. This reduces the cognitive load on

02468101214Dimensionδ−0.020−0.015−0.010−0.0050.0000.0050.0100.0150.020ξδρ(∞)−ξδd(∞)ξδρ(0)−ξδd(0)ξδρ(1)−ξδd(1)(ξδρ(0)−ξδρ(1))−(ξδd(0)−ξδd(1))0510152025Dimensionδ−0.0010−0.00050.00000.00050.0010ξδρ(∞)−ξδd(∞)ξδρ(0)−ξδd(0)ξδρ(1)−ξδd(1)(ξδρ(0)−ξδρ(1))−(ξδd(0)−ξδd(1))Table 2. Comparison of differentials in the three variants of Foxtail.

(cid:9)

(cid:99) = R

2

No-window

(cid:8)c|(cid:98) c mod 4
(cid:1) 1
(cid:0)k
(cid:80)
(cid:18) (c
(cid:0)k
(cid:1) 1
(cid:80)
(cid:18) (c
(cid:1) 1
(cid:0)k

c∈FR

2k

2k

c

c

c∈FR

c

2k

(cid:19)
δ)
δ) − 1
(k

2δ

δ)
δ) − 1
(k

2δ

= 0

(cid:19)

1
˜pR

k(cid:80)

c=0

(cid:9)

(cid:99) = R
2
c)(n−k
(k
l−c )
(n
l )

Rand-rule

(cid:8)c|(cid:98) c mod 4
(cid:80)
(cid:18) (c
(cid:80)
(cid:18) (c
min{k,l}(cid:80)

c∈FR
c)(n−k
(k
l−c )
(n
l )
c∈FR
c)(n−k
(k
l−c )
(n
l )

1
˜pR

δ)
δ) −
(k

c=0

(cid:19)

(l−c
δ )
δ)
δ) −
(n−k
(k
δ )
(l−c
δ )
(n−k
δ )

(cid:19)

= 0

(cid:9)

(cid:99) = R

Uni-rule

2

(cid:8)c|(cid:98) c mod 4
(cid:80)
(cid:18) (c
(cid:80)
(cid:18) (c
min{k,l}(cid:80)

c∈FR

1
λ

c∈FR
δ)
δ) −
(k
δ)
δ) −
(k

1
λ

1
λ

c=0

(cid:19)
(cid:19)

(l−c
δ )
(n−k
δ )
(l−c
δ )
(n−k
δ )

FR

˜pR

ξδ
ρ(R) − ξδ
ξδ
ρ(∞) − ξδ

d(R)

d(∞)

Table 3. Number of pairs in no-window Foxtail
to ensure Pr[Z δ
ρ,d(i,R) > 0] = 0.6, with n = 140
and k = 25.
1

2

3

4

5

δ

0 only if λ = k + 1, n = 2l and k = l

inal Foxtail, although in practice this might require a large
number of sessions. One way to make the differentials neg-
ligible is to increase the values of n and k (see the equations
of the differentials), but this increases cognitive load.

mlb = pairs ∞ 6,461,048
slb = sessions ∞ 323,052
0.000122
0.750000

0
1.0

µZ
σ2
Z

1,675,087

83,754
0.000183
0.437500

1,292,210

64,610
0.000152
0.234375

2,670,567
133,528
0.000076
0.121093

7. Frequency Analysis on Non-counting based

Protocols

the user searching for his pass-objects if l is small. The ab-
sence of a window implies that a much larger number of ob-
jects can be present in each challenge and if k = 25, a much
larger number of pass-objects too, thus making it harder for
the user to locate his pass-objects. This can be solved by
making k smaller, say 10 to 14. But, as we have seen, this
value of k is not secure against frequency analysis.

As noted before, the no-window and Rand-rule Foxtail
are inherently resistant to RIFA, since the no-response dif-
ferentials are zero for all dimensions. Intuitively, this is due
to the fact that the challenges in both these variants do not
differentiate between pass and decoy objects. Both types
are drawn at random with the same probability. This is not
true in the case of Uni-rule Foxtail. There are two cases
depending on the value of λ. First, if λ < k + 1, then a
maximum of λ − 1 pass-objects are present in a challenge.
Thus, a λD-RIFA can be carried out since there is no pass-
object λ-tuple in the challenge. The second case is when
λ = k + 1. This results in the conditions n = 2l and l = k
which are necessary to ensure that the no-response differ-
entials are zero for all dimensions. Unfortunately, these re-
strictions deem the protocol impractical, since n needs to
be large enough to prevent brute-force attack which means
k, being half of n, is going to be large too. This implies
that in theory, it is not possible to completely eradicate the
threat of multi-dimensional RIFA in the Uni-rule and orig-

Yan et al. also showed that frequency analysis can be ap-
plied on non-counting based protocols that use some struc-
ture in the challenge [28, §4.2]. Consider for example, the
CHC protocol from [26]. In this protocol, the user responds
by clicking inside the convex hull of any three of the pass-
objects present in the challenge. The protocol ensures that
at least 3 objects are present in each challenge, so that a
convex hull can be formed. In [26], the window-size was
variable with an average value of l = 83. Yan et al. showed
that 2D-RIFA reveals the password after the observation of
18 challenge response pairs or less than 2 sessions, with
the parameter values (n, k, l) = (112, 5, 83). However, it
was shown in [1, 2] that the parameters should satisfy the
relation n = 2kl
k+3 to prevent 1D-RIFA. Under this rela-
tion, the aforementioned set of parameter values is not rec-
ommended. A comparable set of recommended values is
(n, k, l) = (115, 5, 92). But as we shall see, these set of
values still do not completely eradicate the threat of higher-
dimensional RIFA. In a manner analogous to the derivation
of expected occurrences for Foxtail, we see that for CHC

k(cid:88)

1

(cid:1)(cid:0)k
(cid:0)c
(cid:1) , and ξδ

δ

k(cid:88)

1

c=3

k − 2

(cid:0)l−c
(cid:1)
(cid:1) ,
(cid:0)n−k

δ

δ

ξδ
ρ(∞) =

c=3

k − 2

δ

d(∞) =

where we have assumed that the challenge is generated such
that 3, 4, . . . , k pass-objects are present with the same prob-
k−2. With the above set of
ability [1, 26]; hence the term 1
values the 2D no-response differential, i.e., ξ2
d(∞),

ρ(∞)−ξ2

is −0.00525. This corresponds to an mlb of 2153.6 On the
other hand, with (n, k, l) = (112, 5, 83), ξ2
d(∞) is
0.08998 giving an mlb of just over 7. Thus, if the aforemen-
tioned relation is satisﬁed by the parameter values, CHC is
relatively safe from 2D-RIFA in the sense that the attacker
has to observe a larger number of session. However, in the-
ory it is still susceptible to the attack.

ρ(∞)− ξ2

Another protocol with an apparent structure in its chal-
lenge is Undercover [20], which requires that at most one
pass-object be present in a challenge with l = 4 objects.
If the challenges are generated randomly, then this piece of
information can be used to ﬁnd the password in less than 10
sessions [18,28]. This can be explained with the help of the
ρ(∞) = 0 for all δ > 1. On the
differentials. We see that ξδ
other hand ξδ
d(∞) is non-zero for 1 < δ ≤ l. This implies
that the corresponding differentials are non-zero. Thus, δD-
RIFA for any δ > 1 can be carried out to ﬁnd the pass-
word. We have seen that the same problem can also arise in
the Uni-rule Foxtail discussed in the previous section, if a
value of λ < k + 1 is used. In such a case the protocol is
susceptible to λD-RIFA, which can be practical if λ is too
low.

Yan et al. [28] also remarked that the APW protocol [3]
does not succumb to frequency analysis. We can see why
APW is resistant to frequency analysis. APW is a non-
counting based protocol in which each object has a random
integer weight associated with it from 0 to 9. This is equiv-
alent to saying that each object is drawn at random with
probability 9/10, i.e., an object occurs in a challenge if its
weight is non-zero. The APW does not use a window, which
means that it is safe from RIFA since the differentials are all
zero which can be veriﬁed in a manner similar to the case
of no-window Foxtail. The protocol is also safe from RIFA
if it uses a window and the challenges are generated using
the Rand-rule method. However, if the protocol is to use
the Uni-rule method of generating the challenge, RIFA is
applicable.

Since the CHC and APW protocols are not based on
counting, RDFA does not straightforwardly apply to them.
On the other hand, from these examples, we see that RIFA
is applicable to non-counting based protocols as well, as
long as the challenge generation method distinguishes be-
tween pass and decoy objects. The severity of this vulnera-
bility can be empirically determined by ﬁnding the value of
slb. A very low value of slb means that the corresponding
set of parameter values are insecure. An important remark
is that resistance to frequency analysis does not imply that
the protocol is secure from all other attacks. For instance,
with (n, k, l) = (115, 5, 92), the CHC protocol is safe from
RIFA in terms of the number of observed sessions required,
yet a brute force attack can easily ﬁnd the password, since
the time-complexity is low (≈ 227).

6Variance is not shown.

8. Can Counting based Protocols be Com-
pletely Secure against Frequency Analysis?

The preceding discussion reveals that there are two prin-
ciples necessary to completely eradicate the threat of fre-
quency analysis on counting based protocols.

1. Each object in a challenge should be sampled indepen-
dently with the same probability regardless of its type.
This is to prevent RIFA.

2. The response should be independent of the number
of pass-objects present in a challenge. This prevents
RDFA. (This seems contradictory when applied to
counting based protocols, but see the discussion that
follows).

The ﬁrst principle does not mean that parameters be cho-
sen such that the probabilities are artiﬁcially made the same.
This is precisely what was done in the Foxtail protocol re-
sulting in the condition 3n = 2kl, which prevents 1D-RIFA
but not its higher dimensional variants. If, instead, each ob-
ject is sampled uniformly at random, as in the case of the
no-window or Rand-rule Foxtail, RIFA is unsuccessful for
all dimensions. This principle is not restricted to counting
based protocols. We have already seen how CHC, a non-
counting based protocol, is susceptible to RIFA. Yan et al.
proposed the same principle for protocols where there is a
structural requirement for the challenges. Such as, there
should be at least 3 pass-icons present in a challenge as in
the case of CHC. As it turns out, the principle is important
to avoid frequency analysis as well.

The second principle above seems to be related to count-
ing based protocols only. Notice that the responses in a
counting based protocol are dependent on the number of
pass-objects present in a challenge. Compare this to the
APW or the CHC protocol. There, the responses are in-
dependent of the number of pass-objects present. In APW,
the response is a random integer corresponding to an index
of an array of length n. In CHC, the response is a click,
whose location is not altered by the number of pass objects
present. Therefore both these protocols, and any protocol
whose reponse is not dependent on the number of pass ob-
jects present in a challenge is safe from RDFA. Thus, a ﬁx
needs to be found for counting based protocols to make the
response independent of the number of pass-objects present
in the challenge. A desirable property of such a ﬁx is that it
should be able to retain all the features of a counting based
protocol. Notice that these results can be generalized to any
|R| > 2. In such a case, one can still use pair-wise differ-
entials, or more generally, tuple-wise differentials.
Based on these two principles we ﬁrst show a ﬁx that can
be used for any counting based protocol. We illustrate the

ﬁx by once again using Foxtail as an example. The draw-
back of the ﬁx is that it increases the authentication time
almost twofolds. We further show a ﬁx speciﬁc to the Fox-
tail protocol that incurs a smaller time penalty. We also dis-
cuss how this ﬁx can be generalized to all counting based
protocols.

8.1. A Fix for Any Counting based Protocol

One of the reasons why RDFA works is that the true
challenges and responses are all observable to the attacker.
If we can design the protocol to deliver a partially hidden
challenge to the user, we may be able to make the true chal-
lenge and/or the true response only partly observable to the
attacker. For instance, the hidden challenge may be used to
skip one or more pass-objects in the challenge as if a differ-
ent challenge was shown to the user, or it could be used to
reverse the response so that the attacker is confused about
the true response. Taking the Foxtail protocol as an exam-
ple, if the hidden challenge can uniformly confuse the two
possible responses, RDFA will not work any more because
the expected occurrences will be the average of two kinds of
challenges, thus reducing it to the case where the response is
not considered at all. How to select a proper way of encod-
ing the hidden challenge and avoiding any information leak-
age about the hidden challenge will be the core of this idea.
The idea of hidden challenges was ﬁrst proposed in [20]
using an additional device accessible to the legitimate user
only.7 In this section, we describe a new framework of us-
ing soft hidden challenges with counting based protocols,
where soft hidden challenges are hidden challenges embed-
ded in the challenge without the need of getting any auxil-
iary hardware involved. The framework can be considered
a ﬁx for all counting based protocols against RDFA. We il-
lustrate this in the following using Foxtail as an example.

The ﬁrst change we introduce in the enhanced Foxtail
protocol is that we generate the challenge without consid-
ering the type of object, i.e., pass or decoy object. This
can be achieved either through a window-based design or a
non-window based design. In the ﬁrst case, the challenge
is generated using the Rand-rule, i.e., for the ﬁxed window-
size l, a total of l objects are drawn at random from the pool
of n objects, regardless of their type, for each challenge. In
the case of the no-window Foxtail, each object is present
in a challenge with probability 1/2. As we have seen, this
completely eradicates the threat of RIFA. To illustrate the
second change, we use the Rand-rule challenge generation
method.
In order to make the protocol safe from RDFA,
the response to the Foxtail function is ﬂipped according to
a random bit. We call this random bit, the ﬂip-bit. The
ﬂip-bit is not communicated in the open. We will discuss

7Note that the particular design in [20] has some security ﬂaws related

to its human-computer interface as pointed out in [18].

how this can be achieved in a moment. To see why this ﬁx
completely prevents RDFA, see Appendix C. The main idea
is that the ﬂip-bit ensures that the occurrence of the pass-
objects is independent of the response. In a similar way, we
can show that the response-based differentials are 0 if the
no-window Foxtail is used in conjunction with the ﬂip-bit.
We now return to the implementation of the ﬂip-bit. One
way to achieve this is to have two challenges per round.
In the ﬁrst challenge, the user counts the number of pass-
objects present and computes the Foxtail function as before.
Once the function is computed, a new challenge is shown
which has all n objects present. Each object in the challenge
has a random bit associated with it. The user locates a pre-
determined pass-object, retrieves the bit associated with it,
and sends the response as the mod 2 sum of the bit and the
result of the Foxtail function. Notice that the ﬂip-bit (sec-
ond) challenge is an instance of soft hidden challenges dis-
cussed before. Here, part of the challenge is hidden from the
observer in the sense that without knowing the response to
the Foxtail function, it is not possible to know which is the
ﬂip-bit apart from guessing the pass-object. Figure 4 shows
an example of the two types of challenges in the modiﬁed
Rand-rule Foxtail.

(a)

(b)

Figure 4. Modiﬁed Foxtail (a) With the ﬁrst
challenge (b) With the ﬂip-bit (second) chal-
lenge.

Unfortunately, this simple ﬁx has two drawbacks. First,
the attacker can randomly guess the pass-object correspond-
n, which is quite small
ing to the ﬂip-bit with probability 1
since a typical value of n is 140. If the attacker’s guess is
correct, RDFA can be applied by removing the ﬂip-bit from
n, which is ap-
the response. The probability of success is 1
proximately 0.0071 when n is 140. The success probability
of this random guess attack can be reduced by increasing
n, however, too large a value of n will incur usability costs.
Moreover, there is an even smarter attack which can still
work with a large value of n. The attacker can simply treat
each of the n bits in the second challenge as the ﬂip-bit, re-

0110101000101001move it from the response and apply RDFA. All bits other
than the ﬂip-bit will show no difference between pass and
decoy object occurrences, since they are independent of the
response. Thus, the frequency differences will be zero for
these bits. However, removal of the ﬂip-bit alone will make
the frequency difference reappear, and hence RDFA can be
straightforwardly applied.

(cid:1)), since the

k(cid:48)

aforementioned attack has complexity O((cid:0) n

A possible solution to the above-mentioned security vul-
nerabilities is to obtain the ﬂip-bit as the mod 2 sum of
bits corresponding to multiple pass-objects, which results
in a protocol that is computationally secure against RDFA.
More speciﬁcally, let k(cid:48)
≤ k be the number of pass-objects
selected in the setup phase to compute the ﬂip-bit. Then the
attacker has to go through all k(cid:48)-combinations of objects
in the second challenge. Thus increasing k(cid:48) increases the
time-complexity of the aforementioned version of RDFA,
and with k(cid:48) = k the complexity is the same as brute-force.
The drawback is the extra authentication time imposed by
the calculation of the ﬂip-bit, which increases with k(cid:48). This
ﬁx can be generalized to any function and any range of re-
sponse values. Generally speaking, the ﬂip-bit can be re-
placed by a random integer modulo |R| which is computed
as the mod |R| sum of k(cid:48)
≤ k pass-objects each carrying a
random weight from the set {0, 1, . . . ,|R| − 1} in the sec-
ond challenge. An analysis similar to the one above shows
that the differentials are all 0. In particular, this ﬁx can be
applied to the function #C(P ) mod q for any q ≥ 2, and
the resulting scheme will be computationally secure against
frequency analysis. Yan et al. identiﬁed this as an insecure
function against frequency analysis [28, §4.4], but by in-
troducing the ﬂip-bit ﬁx the protocol based on this function
can be made computationally secure against frequency anal-
ysis. Note that this does not mean that a protocol based on
the function #C(P ) mod q is free from any other attacks.
Gaussian elimination is one example.
There does not appear to be any ﬁx for the Uni-rule and
original Foxtail. The evidence in support of this has been
given in the previous sections where we considered the orig-
inal Foxtail and its variants. It also seems that there is no
ﬁx for these variants of Foxtail with practical values of pa-
rameters that can prevent frequency analysis for sufﬁciently
large slb (say 2000). However, it is possible to resist fre-
quency analysis for large values of slb by using a differ-
ent counting function. Yan et al. point out that the function
#C(P ) mod 2 is safe from frequency analysis [28, §4.4].
Our results show that the differentials are still non-zero with
the parameters (n, k, l) = (140, 14, 15) for this function.
The difference appears to be that the differentials are much
smaller in this case. The quantity slb is about 9000 for
δ = 1. Compare this with the case of the Foxtail func-
tion, which has slb = 55 for the same δ. Perhaps this led
Yan et al. to conclude that using this function will prevent

frequency analysis. However, this function itself is not suf-
ﬁcient, since it is vulnerable to an attack based on Gaussian
elimination after the observation of a small number of ses-
sions [14, 28].

8.2. A Fix for Foxtail

The ﬂip-bit solution doubles the authentication time,
since the user has to respond to twice the number of chal-
lenges per session as compared to the original Foxtail with
a reasonably large value of k(cid:48). We therefore present a bet-
ter ﬁx speciﬁcally for the Foxtail function, and discuss how
this can be applied to a wider range of counting functions.
In this version of Foxtail, the challenge consists of all n ob-
jects. Each object is assigned a random weight from the
set {0, 1, 2, 3}. The computation of the Foxtail function is
done as before, with the binary weights replaced by mod
4 weights. Accordingly, we call this variant of the proto-
col, the no-window Foxtail with 4-ary weights. First notice
that RIFA will not work on this protocol due to the same
reasons detailed in the binary weights case. The protocol
is also secure from any RDFA with dimension less than
or equal to k − 1. To see this, suppose k = 2, and con-
sider 1D-RDFA. The response is independent of the weight
of a single pass-object since it depends on the weight of
the other pass-object which in turn has a random weight
from {0, 1, 2, 3}. Thus, the response does not reveal any
bias in the differentials. Notice that this bias will be there
if we consider k = 1.
In this case, we do not have an-
other pass-object to randomize the response. For higher di-
mensional RDFA, we can consider a pass-object tuple to be
present if all its constituent objects have a non-zero weight.
Here again, if we consider k = 3 and 2D-RDFA, the re-
sponse randomizes over the individual occurrence of the
pass-object pairs. This is true since the response is depen-
dent on the weight of a third pass-object which is randomly
chosen from {0, 1, 2, 3}. Again, there will be bias in the
differentials if we consider k = 2. In general, for a ﬁxed k,
the only version of RDFA that will work is kD-RDFA. But
the complexity of such an attack is the same as brute force
attack.

We could also propose Rand-rule Foxtail with 4-ary
weights. However, this version is not secure against RDFA
in the above mentioned sense.
To see this, consider
Rand-rule Foxtail with 4-ary weights with the parameters
(n, k, l) = (140, 14, 20). Since l is small, with high prob-
ability the challenge does not contain more than 1 pass-
object. Thus, 1D-RDFA can be applied, since in most chal-
lenges a second pass-object is not present to randomize the
response. This probability, however, can be made increas-
ingly small by incrementing l. A suitable set of parameters
is (n, k, l) = (140, 14, 40), for which our previous criterion
of slb > 2000 applies for all δ ≥ 2. However, for δ = 1,

the value of slb is lower than this mark. Yet, through Monte
Carlo simulations, we were only able to ﬁnd the password
in more than 16, 000 sessions on average in 100 runs. Thus,
these parameter values are safe against RDFA for a sufﬁ-
ciently large number of sessions. In general, this ﬁx is not
straightforwardly applicable to all counting based protocols,
as it depends on the speciﬁc function. But a general rule
can be established that if a counting function uses a mod
q operation on the result of counting where q > 2, then
the objects should be assigned random weights from the set
{0, 1, . . . , q − 1}. Otherwise, the fact that the response is
not uniformly distributed can be used in RDFA to ﬁnd the
password.

8.3. Usability Analysis

Based on the quantitative framework introduced by Yan
et al. [28, §6], we can also estimate the usability of the ﬁxed
Foxtail protocols. Since the Rand-rule Foxtail with 4-ary
weights is the most usable one, we mainly focus on this
variant for the usability analysis. In each round, the protocol
requires recognizing k pass-objects, adding their weights, a
modulo operation and a small division. Let RT denote the
reaction time. Then

(cid:18)(cid:24) kl

(cid:25)

(cid:19)

(cid:24) l

(cid:25)

4

RT = (0.3694+0.0383k)

+

− 1

t0 +t0 +t1.

n

n (cid:101) − 1)t0.

The equation 0.3694 + 0.0383k is the reaction time for
recognition when k pass-objects constitute the positive set
[23, 28]. Since the window size is l, we have l
4 paral-
lel recognition channels, since each individual has up to
a limit of 4 parallel recognition channels [28]. t0 and t1
represent the reaction time of large addition8 and small di-
vision respectively. The values used here are t0 = 0.924
and t1 = 0.959 [6, 28]. Since kl
n pass-objects are present
in a challenge on average, the average number of additions
is (cid:100) kl
n (cid:101) − 1. Hence the average reaction time for adding
weights is ((cid:100) kl
Plugging in the values n = 140, k = 14, l = 40, t0 =
0.924 and t1 = 0.959 into the equation for RT, we see that
the reaction time amounts to about 13.71 seconds per round
or 274.22 seconds per session. In comparison, the reaction
time is 212.76 seconds per session for the original Foxtail
according to Table 1 in [28]. The time is about 3 seconds per
round more than the time required in the original Foxtail.
This is due to the fact that the simpler task of counting is
replaced with large additions. In the case of the enhanced
no-window Foxtail with 4-ary weights, the reaction time is
more than double. This is because the average number of
objects present in a challenge is 70 (when n is 140), which
is more than double the window size in the original Foxtail.

8Large addition is deﬁned as the operation in which the product of the

two operands is greater than 25 [6]

We acknowledge the lack of an actual user study to obtain
RT, but we did not ﬁnd it necessary since we do not claim
that the ﬁxed Foxtail protocols are practical (as is the case
with the protocols discussed by Yan et al. in [28]).

9. Conclusion

In this paper, we have given a detailed quantitative ex-
planation of a speciﬁc attack on user authentication pro-
tocols called frequency analysis, which was introduced by
Yan et al. in [28] where they named it counting based sta-
tistical analysis. They demonstrated the weakness of sev-
eral protocols including Foxtail from [14] using this attack.
We have extended their work by giving a more quantitative
analysis of the attack. We have shown that one variant of
the attack is applicable to any protocol that generates chal-
lenges with the knowledge of the pass and decoy objects,
even if the parameter values are chosen such that the two
types of objects occur with the same probability. We have
described a method to determine the number of sessions a
protocol can be safely used with the same password before
frequency analysis comes into play. We have also argued
that it is not necessary that a candidate function completely
eradicate the threat of frequency analysis.
In practice, if
frequency analysis requires a very high number of sessions,
it can be counted as a sufﬁcient defence. We have shown
a ﬁx that renders any counting based protocol practically
safe from frequency analysis. The resulting ﬁx, however,
incurs almost double the cost in reaction time. We have
also described another ﬁx speciﬁc to the Foxtail protocol,
which causes a lesser increase in reaction time, yet makes
the protocol practically secure from frequency analysis. As
future work, for usability analysis, it will be helpful to ex-
tend the framework from Yan et al. to include reaction times
for tasks speciﬁc to user authentication protocols, as op-
posed to those taken from studies that are carried out by
experimental psychologists under conditions different from
such protocols. We also plan to implement the Foxtail pro-
tocol for the purpose of a user study to compare the actual
reaction time against the one obtained from the framework
of Yan et al. Lastly, we also intend to undergo a theoret-
ical study on the security of Foxtail against other attacks,
especially algebraic attacks, in order to determine safe pa-
rameter values against all types of attacks.

Acknowledgements

Hassan Jameel Asghar was supported by 2012 Macquarie
University Safety Net (MUSN) Grant. The research of Ron
Steinfeld was supported by an Australian Research Fellow-
ship (ARF) from the Australian Research Council (ARC),
and ARC Discovery Grants DP0987734 and DP110100628.
Josef Pieprzyk was supported by ARC grant DP0987734.

References

[1] H. J. Asghar, S. Li, J. Pieprzyk, and H. Wang. Cryptanalysis
of the Convex Hull Click Human Identiﬁcation Protocol. In
ISC ’10, pages 24–30. Springer-Verlag, 2010.

[2] H. J. Asghar, S. Li, J. Pieprzyk, and H. Wang. Cryptanaly-
sis of the Convex Hull Click Human Identiﬁcation Protocol.
International Journal of Information Security, 2012, DOI:
10.1007/s10207-012-0161-x.

[3] H. J. Asghar, J. Pieprzyk, and H. Wang. A New Human
Identiﬁcation Protocol and Coppersmith’s Baby-Step Giant-
In ACNS ’10, pages 349–366. Springer-
Step Algorithm.
Verlag, 2010.

[4] H. J. Asghar, J. Pieprzyk, and H. Wang. On the Hardness
of the Sum of k Mins Problem. The Computer Journal,
54(10):1652–1660, Oct. 2011.

[5] R. A. Brualdi. Introductory Combinatorics. Pearson Educa-

tion, Inc., New Jersey, USA, 4th edition, 2004.

[6] J. I. D. Campbell and Q. Xue. Cognitive Arithmetic Across
Cultures. Journal of Experimental Psychology: General,
130(2):299–315, 2001.

[7] B. Coskun and C. Herley. Can “Something You Know” Be
Saved? In ISC ’08, pages 421–440. Springer-Verlag, 2008.
[8] P. Golle and D. Wagner. Cryptanalysis of a Cognitive Au-
thentication Scheme (Extended Abstract). In SP ’07, pages
66–70. IEEE Computer Society, 2007.

[9] N. J. Hopper and M. Blum. Secure Human Identiﬁca-
tion Protocols. In ASIACRYPT ’01, pages 52–66. Springer-
Verlag, 2001.

[10] M. Lei, Y. Xiao, S. V. Vrbsky, and C.-C. Li. Virtual Pass-
word using Random Linear Functions for On-line Services,
ATM Machines, and Pervasive Computing. Computer Com-
munications, 31(18):4367–4375, 2008.

[11] M. Lei, Y. Xiao, S. V. Vrbsky, C.-C. Li, and L. Liu. A Virtual
Password Scheme to Protect Passwords. In ICC ’08, pages
1536–1540. IEEE, 2008.

[12] S. Li, H. J. Asghar, J. Pieprzyk, A.-R. Sadeghi, R. Schmitz,
and H. Wang. On the Security of PAS (Predicate-based Au-
thentication Service). In ACSAC ’09, pages 209–218. IEEE
Computer Society, 2009.

[13] S. Li, S. A. Khayam, A.-R. Sadeghi, and R. Schmitz. Break-
ing Randomized Linear Generation Functions based Virtual
Password System. In ICC ’10. IEEE, 2010.

[14] S. Li and H.-Y. Shum. Secure Human-Computer Identiﬁca-
tion (Interface) Systems against Peeping Attacks: SecHCI.
IACR’s Cryptology ePrint Archive: Report 2005/268,
http://eprint.iacr.org/2005/268, 2005.

[15] X.-Y. Li and S.-H. Teng. Practical Human-Machine Identi-
ﬁcation over Insecure Channels. Journal of Combinatorial
Optimization, 3(4):347–361, 1999.

[16] T. Matsumoto. Human-Computer Cryptography: An At-

tempt. In CCS ’96, pages 68–75. ACM, 1996.

[17] T. Matsumoto and H. Imai. Human identiﬁcation through
In EUROCRYPT ’91, pages 409–421.

insecure channel.
Springer-Verlag, 1991.

[18] T. Perkovi´c, A. Mumtaz, Y. Javed, S. Li, S. A. Khayam, and
M. ˇCagalj. Breaking Undercover: Exploiting Design Flaws
In SOUPS ’11. ACM,
and Nonuniform Human Behavior.
2011.

[19] S. M. Ross. A First Course in Probability. Prentice Hall, 4

edition, 2002.

[20] H. Sasamoto, N. Christin, and E. Hayashi. Undercover: Au-
In CHI ’08,

thentication Usable in Front of Prying Eyes.
pages 183–192. ACM, 2008.

[21] L. Sobrado and J.-C. Birget. Graphical Passwords. The Rut-

gers Scholar, 4, 2002.

[22] T.-P. Staff. Debit card skimmers stealing money from ac-
counts, reports say. Times-Picayune, Greater New Orleans,
http://www.nola.com/crime/index.ssf/
2012/07/debit_card_skimmers_stealing_m.
html, 11 July 2012.

[23] S. Sternberg. Memory-scanning: Mental Processes Re-
vealed by Reaction-time Experiments. American Scientist,
57(4):421–457, 1969.

[24] C.-H. Wang, T. Hwang, and J.-J. Tsai. On the Matsumoto
and Imai’s Human Identiﬁcation Scheme. In EUROCRYPT
’95, pages 382–392. Springer-Verlag, 1995.

[25] D. Weinshall.

Cognitive Authentication Schemes Safe
Against Spyware. In SP ’06, pages 295–300. IEEE Com-
puter Society, 2006.

[26] S. Wiedenbeck, J. Waters, L. Sobrado, and J.-C. Birget. De-
sign and Evaluation of a Shoulder-Surﬁng Resistant Graph-
ical Password Scheme. In AVI ’06, pages 177–184. ACM,
2006.

[27] X. Bai and W. Gu and S. Chellappan and X. Wang and D.
Xuan and B. Ma. PAS: Predicate-Based Authentication Ser-
vices against Powerful Passive Adversaries. In ACSAC ’08,
pages 433–442. IEEE Computer Society, 2008.

[28] Q. Yan, J. Han, Y. Li, and R. H. Deng. On Limitations of
Designing Leakage-Resilient Password Systems: Attacks,
In NDSS ’12. Internet Society,
Principles and Usability.
2012.

A. Algorithm to Check if p(0, m1) = p(2, m2)

Due to the ﬁrst half-challenge in Foxtail, l has to be

greater than or equal to 3. This implies that

3n = 2kl ⇒ 3n ≥ 2k · 3 ⇒ k ≤

n
2

.

A further restriction on l, namely l ≤ n, is imposed by
the second-half challenge. The following algorithm ﬁnds if
p(0, m1) = p(2, m2) is true for any values of n, k and l in
(cid:0)n
accordance with these rules. Notice that the expressions of
pi in both p(0, m1) and p(0, m2) contain the denominator

(cid:1), which can be cancelled on both sides. The algorithm

l
does not compute this factor in the calculation of pi.
Check p(0, m1) ?= p(2, m2).
Input: A positive integer nmax.
Output: A set of values of the form (n, k, l) satisfying

p(0, m1) = p(2, m2).
1: initialize found ← ∅.
2: for n = 1 to nmax do
for k = 1 to (cid:98) n
3:

2(cid:99) do

4:

5:
6:
7:

8:
9:
10: output found

if 3n ≡ 0 mod 2k then
checks if 3n and 2k have an integer factor.

# This

l ← 3n/2k.
if l ≤ n then

compute all individual values of pi
for p(0, m1) and p(2, m2).
if p(0, m1) = p(2, m2) then

found ← found ∪ {(n, k, l)}.

Our simulations show that the condition is not met for all

values of nmax ≤ 5000.
B. Frequency Analysis of Foxtail with No Win-

dow

Since each pass-object appears in the challenge with
2, it follows that the probability that a challenge

probability 1
contains c pass-objects is binomially distributed. Hence

(cid:88)

(cid:18)k

(cid:19) 1

c∈FR

c

2k .

˜pR =

ρ(R) − ξδ

d(R), ﬁrst note that
To derive an expression for ξδ
the probability that a decoy object δ-tuple occurs in a chal-
lenge is independent of the number of pass-objects in the
challenge. This is true since each object is chosen indepen-
dently and uniformly at random. So the probability that a
decoy object δ-tuple occurs in a challenge is 1
2δ . On the
other hand, the probability that a pass-object δ-tuple occurs
in a challenge containing c pass-objects is given by

δ

where(cid:0)c

(cid:1) = 0 if c < δ. Combining these two observations,
(cid:33)

we obtain the following expression in a manner analogous
to that of Foxtail with window size 2l:

δ

(cid:1)(cid:0)k
(cid:0)c
(cid:1) ,

δ

δ

δ

c

2k

1
2δ

c∈FR

1
˜pR

(cid:18)k

(cid:88)

(cid:19) 1

(cid:32)(cid:0)c
(cid:1)(cid:0)k
(cid:1) −
(cid:33)
(cid:32)(cid:0)c
(cid:1)(cid:0)k
(cid:18)k
(cid:19) 1
(cid:88)
(cid:1) −
(cid:1)(cid:0)k
(cid:0)c
(cid:19) 1
(cid:18)k
(cid:19) 1
(cid:18)k
k(cid:88)
k(cid:88)
(cid:1) −
(cid:0)k
(cid:1)(cid:0)c
(cid:1)
(cid:19) 1
(cid:18)k
k(cid:88)
k(cid:88)
(cid:1)
(cid:0)k

c∈F∞

1
2δ

2k

2k

2k

c=0

c=0

1
2k −

1
2δ

c

c

c

c

δ

δ

δ

δ

δ

c

c=0

δ

c=0

1
2δ

2k .

ξδ
ρ(∞) − ξδ

d(∞) =

=

=

of the binomial distribution with parameters (k, 1

2k = 1, since it is the sum of probabilities
2 ). We get

c=0

c

Now from [5, §5.8, p. 155], we have

(cid:19)(cid:18)c

(cid:19)

(cid:18)k
(cid:1) 1

c

(cid:0)k

(cid:18)k

(cid:19)(cid:18)k − δ

(cid:19)

.

c − δ

=

δ

δ

Also(cid:80)k

δ

δ

=

c=0

c=0

c−δ

c − δ

d(∞) =

ρ(∞) − ξδ
ξδ

k(cid:88)
k(cid:88)
k(cid:88)

(cid:0)k
(cid:1)(cid:0)k−δ
(cid:1)
(cid:1)
(cid:0)k
(cid:19) 1
(cid:18)k − δ
(cid:19) 1
(cid:18)k − δ
The last step follows from the fact that(cid:0)k−δ
(cid:18)k − δ
(cid:19) 1
k−δ(cid:88)
(cid:19) 1
(cid:18)k − δ
k−δ(cid:88)

Let b = c − δ. Then

ρ(∞) − ξδ
ξδ

d(∞) =

c − δ

2k −

c−δ

b=0

c=δ

=

=

b

1
2δ

b

b=0

1
2k −

2k −

1
2δ

1
2δ

2k −

1
2δ .

(cid:1) = 0 if c < δ.

1
2δ

2k−δ −

1
2δ

=

1
2δ · 1 −

1
2δ = 0,

where the term in the next to last step is equal to 1 since it
is the sum of probabilities of the binomial distribution with
parameters (k − δ, 1
2 ).
C. Why the Flip-bit Fix Prevents RDFA?

To see why the ﬂip-bit ﬁx completely prevents RDFA,
b denote the

we ﬁrst calculate the probabilities ˜pR. Let p(cid:48)
probability that the ﬂip-bit is b. We have

(cid:88)
(cid:88)

c∈F1

c∈F1

pcp(cid:48)

1

pcp(cid:48)

0

pcp(cid:48)

0 +

pcp(cid:48)

1 +

(cid:88)
(cid:88)

c∈F0

=

c∈F0
= ˜p1,

where we have used the fact that p(cid:48)
1. Let q(c) and
q(cid:48)(c) denote the probabilities that a pass-object and a decoy
object δ-tuple is present in a challenge containing c objects,
respectively. Then

0 = p(cid:48)

(cid:1)(cid:0)k
(cid:0)c
(cid:1) , q(cid:48)

δ

δ

(cid:1)
(cid:0)l−c
(cid:0)n−k
(cid:1) .

δ

δ

qc =

c =

ξδ
ρ(R) − ξδ

d(R) =

.

˜p0 =

Now assume R = ∞. Then ˜p∞ = 1, since it is the sum of
the probabilities of both responses. We get

We have

ξδ
ρ(0) =

=

=

1
˜p0

1
˜p0

1
˜p1

c∈F0

(cid:32)(cid:88)
(cid:32)(cid:88)
(cid:32)(cid:88)

c∈F0

c∈F0

= ξδ

ρ(1).

pcp(cid:48)

0qc +

pcp(cid:48)

1qc +

pcp(cid:48)

1qc +

c∈F1

(cid:88)
(cid:88)
(cid:88)

c∈F1

c∈F1

(cid:33)
(cid:33)
(cid:33)

pcp(cid:48)

1qc

pcp(cid:48)

0qc

pcp(cid:48)

0qc

Let R denote the compliment of R. Then for both values of
R

ξδ
ρ(R) =

=

=

=



Rqc

δ

δ

c=0

l

c=0

pcqc

p(cid:48)
R

l−c

c

c∈JR

1
2

1
1
2

c∈JR

1
˜pR

1
˜pR

pcp(cid:48)

pcp(cid:48)

Rqc +

(cid:88)

(cid:1)(cid:0)k
(cid:0)c
(cid:1)

(cid:88)
k(cid:88)
(cid:0)k
(cid:1)(cid:0)n−k
(cid:1)
min{k,l}(cid:88)
(cid:1)
(cid:0)n
(cid:1)(cid:0)n−k
(cid:0)k
(cid:1)
(cid:1)(cid:0)k
(cid:0)c
min{k,l}(cid:88)
(cid:0)n
(cid:1)
(cid:1) ,
2 and p(cid:48)
(cid:1)(cid:0)n−k
(cid:1)
(cid:1)
(cid:0)l−c
(cid:0)n
(cid:1)
(cid:0)n−k
(cid:1) .
(cid:1) (cid:32)(cid:0)c
(cid:1)(cid:0)n−k
(cid:1)
(cid:1)(cid:0)k
(cid:0)n
(cid:1) −

min{k,l}(cid:88)
(cid:0)k

min{k,l}(cid:88)

(cid:0)k

l−c

c

l−c

c

l−c

c

c=0

l

δ

δ

δ

δ

δ

δ

(cid:1)(cid:33)
(cid:1)
(cid:0)l−c
(cid:0)n−k

δ

δ

.

where we have used the fact that ˜pR = 1
2. Similarly for the decoy objects we get ξδ
1
and

R = p(cid:48)
d(0) = ξδ

R =
d(1)

ξδ
d(R) =

l
Combining these two results, we get

c=0

ξδ
ρ(R) − ξδ

d(R) =

c=0

l

This is the same equation as that of the no-response differ-
ential in the case of the Rand-rule Foxtail as shown in Ta-
ble 2, which leads to the conclusion that ξδ
d(R) =
0, for all R and δ.

ρ(R) − ξδ

