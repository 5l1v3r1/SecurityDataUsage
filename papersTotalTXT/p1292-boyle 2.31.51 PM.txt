Function Secret Sharing: Improvements and Extensions

Elette Boyle

IDC Herzliya, Israel

elette.boyle@idc.ac.il

Niv Gilboa

Ben Gurion University, Israel

gilboan@bgu.ac.il

Yuval Ishai

Technion and UCLA

yuvali@cs.technion.ac.il

ABSTRACT
Function Secret Sharing (FSS), introduced by Boyle et al.
(Eurocrypt 2015), provides a way for additively secret-sharing
a function from a given function family F. More concretely,
an m-party FSS scheme splits a function f : {0, 1}n → G, for
some abelian group G, into functions f1, . . . , fm, described
by keys k1, . . . , km, such that f = f1 + . . . + fm and every
strict subset of the keys hides f . A Distributed Point Func-
tion (DPF) is a special case where F is the family of point
functions, namely functions fα,β that evaluate to β on the
input α and to 0 on all other inputs.

FSS schemes are useful for applications that involve pri-
vately reading from or writing to distributed databases while
minimizing the amount of communication. These include
diﬀerent ﬂavors of private information retrieval (PIR), as
well as a recent application of DPF for large-scale anony-
mous messaging.

We improve and extend previous results in several ways:
• Simpliﬁed FSS constructions. We introduce a ten-
soring operation for FSS which is used to obtain a con-
ceptually simpler derivation of previous constructions
and present our new constructions.

• Improved 2-party DPF. We reduce the key size of
the PRG-based DPF scheme of Boyle et al. roughly
by a factor of 4 and optimize its computational cost.
The optimized DPF signiﬁcantly improves the concrete
costs of 2-server PIR and related primitives.

• FSS for new function families. We present an ef-
ﬁcient PRG-based 2-party FSS scheme for the family
of decision trees, leaking only the topology of the tree
and the internal node labels. We apply this towards
FSS for multi-dimensional intervals. We also present
a general technique for extending FSS schemes by in-
creasing the number of parties.

1 , . . . , k∗

• Veriﬁable FSS. We present eﬃcient protocols for ver-
ifying that keys (k∗
m), obtained from a poten-
tially malicious user, are consistent with some f ∈ F.
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’16, October 24 - 28, 2016, Vienna, Austria
c(cid:13) 2016 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ISBN 978-1-4503-4139-4/16/10. . . $15.00
DOI: http://dx.doi.org/10.1145/2976749.2978429

Such a veriﬁcation may be critical for applications that
involve private writing or voting by many users.

Keywords: Function secret sharing, private information
retrieval, secure multiparty computation, homomorphic en-
cryption

1.

INTRODUCTION

In this work we continue the study of Function Secret
Sharing (FSS), a primitive that was recently introduced by
Boyle et al. [7] and motivated by applications that involve
private access to large distributed data.
Let F be a family of functions f : {0, 1}n → G, where G is
an abelian group. An m-party FSS scheme for F provides a
means for “additively secret-sharing” functions from F. Such
a scheme is deﬁned by a pair of algorithms (Gen, Eval). Given
a security parameter and a description of a function f ∈ F ,
the algorithm Gen outputs an m-tuple of keys (k1, . . . , km),
where each key ki deﬁnes the function fi(x) = Eval(i, ki, x).
The correctness requirement is that the functions fi add up
to f , where addition is in G; that is, for any input x ∈ {0, 1}n
we have that f (x) = f1(x) + . . . + fm(x). The security re-
quirement is that every strict subset of the keys computa-
tionally hides f . A naive FSS scheme can be obtained by
additively sharing the entire truth-table of f . The main
challenge is to obtain a much more eﬃcient solution, ideally
polynomial or even linear in the description size of f .

The simplest nontrivial special case of FSS is a Distributed
Point Function (DPF), introduced by Gilboa and Ishai [18].
A DPF is an FSS for the family of point functions, namely
functions fα,β : {0, 1}n → G for α ∈ {0, 1}n and β ∈ G,
where the point function fα,β evaluates to β on input α and
to 0 on all other inputs. Eﬃcient constructions of 2-party
DPF schemes from any pseudorandom generator (PRG),
or equivalently a one-way function (OWF), were presented
in [18, 7]. This was extended in [7] to more general func-
tion families, including the family of interval functions f[a,b]
that evaluate to 1 on all inputs x in the interval [a, b] and
to 0 on all other inputs. For m ≥ 3, the best known PRG-
the naive solution, with key size ≈ √
based DPF construction is only quadratically better than
N , where N = 2n [7].

We consider here the case m = 2 by default.

On the high end, polynomial-time FSS schemes for ar-
bitrary polynomial time functions are implied by indistin-
guishability obfuscation [7] and by variants of fully homo-
morphic encryption [7, 14]. In the present work we mainly
consider PRG-based FSS schemes, which have far better
concrete eﬃciency and are powerful enough for the appli-
cations we describe next.

1292FSS schemes are motivated by two types of applications:
ones that involve privately reading from a database held by
m servers, and ones that involve privately writing (or incre-
menting) an array which is secret-shared among m servers.
In both cases, FSS can be used to minimize the communi-
cation complexity. We illustrate two concrete application
scenarios below and refer the reader to Appendix A for a
more detailed exposition.

For a typical “reading” application, consider the problem
of 2-server Private Information Retrieval (PIR) [10, 8]. In
the basic ﬂavor of PIR, the two servers hold a database of
N strings (x1, . . . , xN ), and a client wishes to retrieve xα
without revealing α to either of the two servers. PIR in this
setting can be implemented by having the client distribute
the point function fα,1 : [N ] → Z2 between the servers.
Concretely, the client generates a pair of keys (k1, k2) which
deﬁne additive shares f1, f2 of fα,1, and sends each key to
a diﬀerent server. On input ki, server i sends back the sum
j=1 xjfi(j), where each xj is viewed as an element in Z(cid:96)
2.
The client can recover xα by taking the exclusive-or of the
two (cid:96)-bit strings it receives.

(cid:80)N

Still relying only on a standard DPF, this can be directly
generalized to private search by keywords (returning the
payload associated with a private (cid:96)-bit keyword), private
search on streaming data [27, 15, 7], and more. FSS for in-
terval functions can be used to privately search values in a
secret range. Realizing similar private search functionalities
using standard PIR protocols requires the use of suitable
data structures, which incur a signiﬁcant additional over-
head in round complexity, storage, and cost of updates [9].
In general, FSS for a function family F can be used to eﬃ-
ciently perform searches deﬁned by predicates from F.

For a typical “writing” application, consider the following
example from [7]. Suppose that we want to collect statis-
tics on web usage of mobile devices without compromising
the privacy of individual users, and while allowing fast col-
lection of real-time traﬃc data for individual web sites. A
DPF provides the following solution. An array of counters
is additively shared between 2 servers. A client who visits
URL α can now secret-share the point function f = fα,1
over a suﬃciently large group G = ZM and each server i
updates its shared entry of each URL αj by locally adding
fi(αj) to its current share of αj. Note that the set of URLs
αj used to index entries of the array does not need to in-
clude the actual URL α visited by the client, and in fact
it can include only a selected watchlist of URLs which is
unknown to the client. A diﬀerent “writing” application for
DPF was proposed in the context the Riposte system for
anonymous messaging [11]. In this system, messages from
diﬀerent clients are mixed by having each client privately
write the message to a random entry in a distributed array.
1.1 Our Contribution

Motivated by applications of FSS, we continue the study
of eﬃcient constructions that can be based on any PRG.
We improve and extend previous results from [7] in several
directions.

Simplified FSS constructions. We introduce a concep-
tually simple “tensoring” operation for FSS, which we use
both to rederive previous constructions and obtain some of
the new constructions we describe next.

Improved 2-party DPF. We reduce the key size of the

PRG-based DPF scheme of Boyle et al. roughly by a factor of
4 and optimize its computational cost. In an AES-based im-
plementation, the key size of a DPF is equivalent to roughly
a single AES key per input bit. We provide further opti-
mizations for the case of DPF with a single-bit output and
for reducing the computational cost of evaluating the DPF
of the entire domain (as needed, for instance, in the PIR ap-
plication described above). The optimized DPF can be used
to implement 2-server PIR protocols in which the communi-
cation overhead is extremely small (e.g., roughly 2.5K bits
are sent to each server for retrieving from a database with
225 records) and the computation cost on the server side is
typically dominated by the cost of computing the XOR of
half the data items. More concretely, the additional com-
putational cost of expanding the DPF key for an N -record
database consists of roughly N/64 AES operations. In the
case of private keyword search, retrieving the payload associ-
ated with an 80-bit keyword requires sending less than 10K
bits. See Table 1 for more details on the concrete eﬃciency
of our DPF construction and Appendix B for more details
on the PIR application and a comparison with alternative
approaches from the literature.
FSS for new function families. We present an eﬃcient
PRG-based 2-party FSS scheme for the family of decision
trees, leaking only the topology of the tree (i.e., the shape
of the graph) and the internal node labels (i.e., which input
variable labels each node). Our construction hides the la-
bels of edges and leaves. We apply this towards PRG-based
FSS for multi-dimensional intervals, e.g., capturing conjunc-
tion queries or search restricted to a geographical region.
We also present a general technique for extending the ex-
pressive power of FSS schemes by increasing the number of
parties. Concretely, we show how to obtain FSS schemes
for the family of all products of pairs of functions from two
given families that are realized by FSS. This can be applied
towards more eﬃcient solutions for multi-dimensional inter-
vals, though with a larger number of parties.
Verifiable FSS. In both types of applications of FSS dis-
cussed above, badly formed FSS keys can enable a malicious
client to gain an unfair advantage. The eﬀect of malicious
clients can be particularly devastating in the case of “writ-
ing” applications, where a single badly formed set of keys
can corrupt the entire data. We present eﬃcient protocols
for verifying that keys (k∗
m) are consistent with some
f ∈ F. Our techniques make black-box use of the under-
lying FSS scheme, and avoid the cost of general-purpose
secure computation techniques. Our veriﬁcation protocols
make a novel use of sublinear veriﬁcation techniques (in-
cluding special-purpose linear sketching schemes and linear
PCPs) and combine them with MPC protocols that exploit
correlated randomness from an untrusted client for better
eﬃciency. These techniques may be applicable beyond the
context of veriﬁable FSS.
Organization. Useful deﬁnitions appear in Section 2. Sev-
eral FSS constructions, including the tensor product gen-
eralization, optimized DPF and evaluating a DPF on the
entire domain are presented in Section 3. Deﬁnitions and
protocols for veriﬁable FSS are the focus of Section 4. The
appendix discusses applications of FSS and concrete perfor-
mance for one speciﬁc application – two-server PIR. Due to
lack of space, the proofs of claims in this work and additional
material are postponed to the full version of the paper.

1 , . . . , k∗

12932. PRELIMINARIES

We extend the deﬁnition of function secret sharing from [7]
by allowing a general speciﬁcation of the allowable leakage,
namely the partial information about the function that can
be revealed.
A function family is deﬁned by a pair F = (PF , EF ),
where PF ⊆ {0, 1}∗ is an inﬁnite collection of function de-
scriptions ˆf , and EF : PF×{0, 1}∗ → {0, 1}∗ is a polynomial-
time algorithm deﬁning the function described by ˆf . Con-
cretely, each ˆf ∈ PF describes a corresponding function
f : Df → Rf deﬁned by f (x) = EF ( ˆf , x). We assume
by default that Df = {0, 1}n for a positive integer n and al-
ways require Rf to be a ﬁnite Abelian group, denoted by G.
When there is no risk of confusion, we will sometimes write
f instead of ˆf and f ∈ F instead of ˆf ∈ PF . We assume
that ˆf includes an explicit description of both Df and Rf
as well as a size parameter Sf .

We let Leak( ˆf ) capture partial information about ˆf that
can be leaked. When Leak is omitted it is understood to
output Df and Rf . (This will be suﬃcient for most classes
considered in this work; for more general classes, one also
needs to leak the size Sf .)

As in [7], we consider by default an “additive” represen-
tation of the output (i.e., an output y is split into group
elements y1, . . . , ym that add up to y), rather than settle for
an arbitrary compact output representation. The additive
representation is critical for the applications we consider and
is achieved by our constructions.

Definition 2.1

(FSS: Syntax). An m-party function
secret sharing (FSS) scheme is a pair of algorithms (Gen, Eval)
with the following syntax:

• Gen(1λ, ˆf ) is a PPT key generation algorithm, which
on input 1λ (security parameter) and ˆf ∈ {0, 1}∗ (de-
scription of a function f ) outputs an m-tuple of keys
(k1, . . . , km). We assume that ˆf explicitly contains an
input length 1n, group description G, and size param-
eter S (see above).

• Eval(i, ki, x) is a polynomial-time evaluation algorithm,
which on input i ∈ [m] (party index), ki (key deﬁning
fi : {0, 1}n → G) and x ∈ {0, 1}n (input for fi) out-
puts a group element yi ∈ G (the value of fi(x), the
i-th share of f (x)).

When m is omitted, it is understood to be 2. When m = 2,
we sometimes index the parties by i ∈ {0, 1} rather than
i ∈ {1, 2}.

Definition 2.2

(FSS: Security). Let F = (PF , EF )
be a function family and Leak : {0, 1}∗ → {0, 1}∗ be a func-
tion specifying the allowable leakage. Let m (number of
parties) and t (secrecy threshold) be positive integers. An
m-party t-secure FSS for F with leakage Leak is a pair
(Gen, Eval) as in Deﬁnition 2.1, satisfying the following re-
quirements.

• Correctness: For all ˆf ∈ PF describing f : {0, 1}n →
G, and every x ∈ {0, 1}n, if (k1, . . . , km) ← Gen(1λ, ˆf )

i=1 Eval(i, ki, x) = f (x)(cid:3) = 1.

then Pr(cid:2)(cid:80)m

• Secrecy: For every set of corrupted parties S ⊂ [m] of
size t, there exists a PPT algorithm Sim (simulator),

such that for every sequence ˆf1, ˆf2, . . . of polynomial-
size function descriptions from PF , the outputs of the
following experiments Real and Ideal are computation-
ally indistinguishable:

– Real(1λ): (k1, . . . , km) ← Gen(1λ, ˆfλ);

Output (ki)i∈S.

– Ideal(1λ): Output Sim(1λ, Leak( ˆfλ)).

We will also use the natural concrete security variant of
(T, )-secure FSS. When Leak is omitted, it is understood
to be the function Leak( ˆf ) = (1n, G) where 1n and G are the
input length and group description contained in ˆf . When t
is omitted it is understood to be m − 1.

Definition 2.3

(Distributed Point Function). A
point function fα,β, for α ∈ {0, 1}n and β ∈ G, is deﬁned
to be the function f : {0, 1}n → G such that f (α) = β and
f (x) = 0 for x (cid:54)= α. A Distributed Point Function (DPF) is
an FSS for the family of all point functions, with the default
leakage (i.e., Leak( ˆf ) = (1n, G)).

3. NEW FSS CONSTRUCTIONS FROM ONE-

WAY FUNCTIONS

In this section, we present a collection of new FSS con-
structions whose security relies only on one-way functions.
At the core of our new results is a new procedure for com-
bining FSS schemes together via a “tensoring” operation, to
obtain FSS for a more expressive function class. A direct
iterative execution of this operation with two diﬀerent re-
cursion parameters reproduces both the DPF constructions
of Gilboa and Ishai [18] and the (seemingly quite diﬀerent)
tree-based DPF construction from [7].

Further exploring this operation, we make progress in two

directions:

Improved eﬃciency. We demonstrate new optimizations
for the case of DPFs, yielding concrete eﬃciency improve-
ments over the state-of-the-art constructions (for both DPFs
and FSS and for interval functions) [7], dropping the key size
of an n-bit DPF from 4n(λ + 1) down to just n(λ + 2) bits.
We also provide a new procedure for eﬃciently performing
a full domain DPF evaluation (i.e., evaluating on every ele-
ment of the input domain), a task which occurs frequently
within PIR-style applications.

Extended expressiveness. Then, by exploiting the gener-
alization of the procedure, we construct FSS for the class of
polynomial-sized decision trees. This enables applications
such as multi-dimensional interval queries.

We also demonstrate an orthogonal means of obtaining
increased FSS expressibility, achieving FSS for the product
of two supported function classes, in exchange for requiring
a larger number of parties m.
3.1 DPF Tensor Operation
Given the following three tools: (1) a DPF scheme FSS• =
(Gen•, Eval•) for the class of multi-bit point functions F•, (2)
an FSS scheme (GenF , EvalF ) for an arbitrary class of func-
tions F whose keys are pseudorandom (and support an ad-
ditive group structure), and (3) a pseudorandom generator,
we construct an FSS scheme for the tensor of the function
family F with the class of single-bit point functions: that is,
functions gα,f (x, y) which evaluate to f (y) on inputs (α, y),
and to 0 elsewhere.

1294Note that if F• supports n1-bit inputs and F supports
n2-bit inputs then the resulting function class F• ⊗ F takes
(n1 + n2)-bit inputs. The key size of the resulting FSS
(Gen⊗, Eval⊗) will correspond to size⊗(n1+n2, λ) = size•(n1, λ)+
2sizeF (n2, λ).

Remark 3.1. In the case when F is itself a class of (multi-
n1 ⊗ F•
bit) point functions F•, the result of this tensor F•
n2
will correspond directly to another class of (multi-bit) point
functions F•
n1+n2 with larger domain. Repeating this pro-
cess iteratively by doubling the input bit-length in each step
(n1 = n2) yields a construction isomorphic to that from [18],
with key size O(nlog2 3) bits. Alternatively, repeating this
process with n2 = 1 at each step yields the construction
from [7], with key size 4n(λ + 1) bits.

Intuitively, the transformation works as follows. We use
the DPF to generate keys for a function which outputs a ran-
dom seed concatenated with the bit 1 on the special input
α, and 0 everywhere else. This means (viewing the scheme
with “subtractive” reconstruction, for simplicity) that when
evaluating at x = α the parties reach independent random
output seeds s0, s1, and disagreeing bits t0 = 1− t1, whereas
everywhere else their outputs will agree. The sb’s can then
be used to generate long(er) masks (via a PRG) to hide in-
formation from the other party. In the tensor construction,
the masks are used to hide FSS keys from the second scheme:
the parties are both given both keys to the second FSS, but
with one masked by the PRG-output of s0 and the other
masked by the PRG-output of s1. These are the “correction
words.” The bit tb tells the party which of the correction
words to use. When t0 = t1 and s0 = s1, the parties will
perform identical actions, and their ﬁnal output will be the
same. For the special input α, they will exactly remove the
masks and evaluate using the revealed FSS keys. The pseu-
dorandomness of the F FSS keys means the parties cannot
identify which input is the special one.

Note that new keys have the form of one key from the
DPF and two elements in the key space of the second FSS:
that is, the resulting key size size⊗(n1 + n2, λ) is indeed
size•(n1, λ) + 2sizeF (n2, λ).

We defer a formal treatment of the tensor product opera-

tion to the full version.
3.2 Optimized DPF and PIR-like Applications
For input length n, security parameter λ, and 1-bit out-
puts, the best known DPF constructions [7] achieved key
size 4n(λ + 1) bits (the key size grows accordingly for larger
outputs). We now demonstrate an optimized DPF construc-
tion stemming from the tensor approach, which drops the
key size down to n(λ + 2) bits.

Theorem 3.2

(Optimized DPF). Assuming a pseudo-
random generator G : {0, 1}λ → {0, 1}2(λ+1), then the scheme
(Gen•, Eval•) in Figure 1 is a secure DPF for fα,β : {0, 1}n →
G with key size n(λ + 2) + log2 |G|.

We obtain savings in two diﬀerent ways. First, we modify
the generic tensor transformation (accordingly, the scheme
of [7]) so that instead of needing two correction words for
each level, we can suﬃce with one. The reason this is possi-
ble here is because the “second” FSS scheme in this instance
is a single-bit-input DPF, which is simply a secret shared
string of the truth table. For such FSS we do not need to

enforce full control over the unmasked key values that the
parties will compute in order to guarantee correct evalua-
tion, but rather only over the diﬀerence between the values.
This saves us one factor of 2.

Second, we are able to shrink the size of each correction
word by roughly a factor of 2 (explicitly, from 2(λ + 1) bits
to (λ + 2)). Recall that the goal of the correction word is
to shift a (pseudo-)random string (a1, a2) so that it agrees
with a second pseudo-random string (b1, b2) on one half i ∈
{0, 1}, and remains independent on the other half. Previous
constructions achieved this via shifting by a correction word
(c1, c2), where ci = ai⊕bi, and c1−i was a random oﬀset. We
observe that the introduced randomness in the latter shift is
unnecessary, and instead shift both halves by the same oﬀset.
Since a1−i and b1−i were (pseudo-)random and independent
to begin with, conditioned on ai, bi, this property will be
preserved with the shift ai ⊕ bi. This provides us with our
second saved factor of 2.

The pseudocode of our DPF construction is given in Fig-
ure 1. We provide a formal proof of security within the full
version.

3.2.1 Full Domain Evaluation
Some applications of DPF require running the Eval algo-
rithm on every element of the input domain. As an example,
consider two-server Private Information Retrieval (PIR) in
which two servers S0,S1 hold the same N = 2n group ele-
ments x0, . . . , xN−1 ∈ G, for some abelian group G, and a
user wishes to retrieve xα while hiding α.

PIR can be implemented using DPF as described in the
introduction. A straightforward implementation of this idea
requires each server to run Eval• N times independently,
once for each input xj. We show two improvements to this
na¨ıve approach of evaluating the whole input domain, lever-
aging the structure of our particular construction.

Consider a rooted binary tree whose leaves are the ele-
ments of the input domain and the path from the root to a
leaf reﬂects the binary representation of the element’s index.
In other words, the path moves from the current node to the
left child if the next bit in the representation is 0 and to the
right child if the next bit in the representation is 1. In our
construction Eval•(b, kb, x) traverses the path from the root
to a leaf x and the na¨ıve algorithm for full domain evaluation
traverses each of these paths resulting in time O(nN ). How-
ever, for every node in the tree there is a unique τ (i) value
computed by any execution of Eval• that traverses the node.
Since the τ values and the correction words are suﬃcient to
compute the result of Eval• on a single point computing full
domain evaluation can be carried out by computing the τ
values for each node in the tree which requires O(N ) time.
A second improvement is the early termination optimiza-
tion for small output groups. The correction word CW (n+1)
in Gen• is the output β masked by the expansion of two
seeds. If the representation of β is short then several output
values can be “packed” into CW (n+1). For any node V of
depth ν in the tree there are 2n−ν leaves in its sub-tree, or
2n−ν input elements with a shared preﬁx that ends at V . If
the size of CW (ν) is at least 2n−ν times the output length
then the main loop of both Gen• and Eval• can terminate
at level ν instead of at level n. In this case CW (ν) will be
a sequence of group elements masked by the two expanded
seeds. The sequence will have the output β in the location
speciﬁed by the last n− ν bits of α and the unit elements of

1295Input
Domain
{0, 1}n
{0, 1}16
{0, 1}25
{0, 1}40
{0, 1}80
{0, 1}160

Key length
≈ (n − log λ)λ

in bits

1-bit output
Eval• - #AES Gen• - #AES
operations
operations
2(n − log λ)
n − log λ

Key length

in bits

nλ + 2(n + λ + 1)

1417
2578
4513
9673
19993

9
18
33
73
153

18
36
66
146
306

2320
3481
5416
10576
20896

128-bit output

Eval• - #AES Gen• - #AES
operations
operations

n
16
25
40
80
160

2n
32
50
80
160
320

Table 1: Performance of the optimized DPF construction as in Figure 1.
In the case of single bit outputs we use the
additional early termination optimization, which is presented in Section 3.2.1. The precise analytic expression for the key
size is somewhat cumbersome, but is reﬂected in the exact key size for each concrete input domain. We implement the PRG
operation expanding s ∈ {0, 1}127 to 256 bits by computing AESs||0(0)||AESs||0(1).

Optimized Distributed Point Function (Gen•, Eval•)
Let G : {0, 1}λ → {0, 1}2(λ+1) a pseudorandom generator.
Let ConvertG : {0, 1}λ → G be a map converting a random
λ-bit string to a pseudorandom group element of G.
Gen•(1λ, α, β, G):
1: Let α = α1, . . . , αn ∈ {0, 1}n be the bit decomposition.
2: Sample random s(0)
3: Sample random t(0)
4: for i = 1 to n do
0 ||tR
5:

1 ← {0, 1}λ
0 ← {0, 1}λ and s(0)
1 ← t(0)
0 ← {0, 1} and take t(0)
1 ||tL
0 ← G(s(i−1)

0 ⊕ 1
1 ||tR

(cid:12)(cid:12)(cid:12)(cid:12) sR

(cid:12)(cid:12)(cid:12)(cid:12) sR

) and sL

1 ←

1

0

0 ⊕ tR

1 ⊕ αi

1 )(cid:3),

0 ) + Convert(s(n)

1

b

b

1

CW

1 ⊕ αi ⊕ 1 and tR

1(cid:2)β − Convert(s(n)

CW ← tR
CW||tR
· sCW for b = 0, 1
· tKeep
CW for b = 0, 1

0 ||tL
sL
0
G(s(i−1)
).
if αi = 0 then Keep ← L, Lose ← R
else Keep ← R, Lose ← L
end if
0 ⊕ sLose
sCW ← sLose
0 ⊕ tL
CW ← tL
tL
CW (i) ← sCW||tL
b ⊕ t(i−1)
b ← sKeep
s(i)
b ← tKeep
b ⊕ t(i−1)
t(i)

6:
7:
8:
9:
10:
11:
12:
13:
14: end for
15: CW (n+1) ← (−1)tn
with addition in G
||t(0)
16: Let kb = s(0)
b
17: return (k0, k1)
Eval•(b, kb, x):
1: Parse kb = s(0)||t(0)||CW (1)||···||CW (n+1)
2: for i = 1 to n do
3:
4:
5:
6:
7:
8:
9: end for

τ (i) ← G(s(i−1)) ⊕ (t(i−1) ·(cid:2)sCW||tL
Parse τ (i) = sL||tL (cid:12)(cid:12)(cid:12)(cid:12) sR||tR ∈ {0, 1}2(λ+1)

if xi = 0 then s(i) ← sL, t(i) ← tL
else s(i) ← sR and t(i) ← tR
end if

Parse CW (i) = sCW||tL

||CW (1)||···||CW (n+1)

CW||tR

CW

b

(cid:3))

CW||sCW||tR

CW

10: return (−1)b(cid:2)Convert(s(n)) + t(n) · CW (n+1)(cid:3) ∈ G

Figure 1: Pseudocode for optimized DPF construction for
fα,β : {0, 1}n → G, where || denotes string concatenation.
Subscripts 0 and 1 refer to party id. All s values are λ-bit
strings and t values are a single bit.

G in every other location. The two improvements described
above lead to the following theorem statement.

Theorem 3.3

(Full domain evaluation). Let λ be a
security parameter, G be an abelian group and (cid:96) = log |G|.
Let z = max{λ, (cid:96)} and let G be a PRG G : {0, 1}λ →
{0, 1}2z+1. There exists a full domain evaluation protocol for
(cid:96)(cid:99))(λ + 2)
fα,β : {0, 1}n → G with key size at most (n−(cid:98)log z
z(cid:101) PRG operations.
and at most (cid:100)2n (cid:96)
3.3 FSS for Decision Trees

We now describe how the tensoring approach can be uti-
lized to provide FSS for the broader class of decision trees.
A decision tree is deﬁned by a tree topology, variable labels
on each node v (which can take values in some node-speciﬁc
set Sv), value labels on each edge (in our case, correspond-
ing to some element in Sv), and output labels on each leaf
node.
In our construction, the key size is roughly λ·|V |, where V
is the set of nodes, and evaluation on a given input requires
|V | executions of a pseudorandom generator, and a compa-
rable number of additions. The FSS is guaranteed to hide
the secret edge value labels and leaf output labels (which
we refer to as “Decisions”), but (in order to achieve this ef-
ﬁciency) reveals the base tree topology and node variable
assignments (which we refer to as “Tree”).

As a simple illustrative example, consider a decision tree
representation of the OR function on n bits xi. The tree
topology includes a length-n chain of nodes (each labeled
by a unique input xi), with edges all labeled by 0, ending
in a terminal output node (labeled by 0). In addition, from
each internal node there is a second edge, labeled by 1, ter-
minating in a leaf labeled by 1. In this example, the leaked
information “Tree” consists of the structure of the tree and
the n node labels xi; the hidden information “Decisions” con-
sists of the choice of condition labels 0,1 on each edge, as
well as the 0,1 leaf output labels. In particular, the result-
ing FSS key cannot be distinguished from the analogous FSS
key for the AND function, which has an identical structure
but with the 0 and 1 roles reversed.

Note that FSS for decision trees could be attained di-
rectly from a linear combination of separate DPFs: for each
leaf node, simply include an additional corresponding DPF.
However, such an approach is wasteful; in particular, our
DPF constructions have the property that a DPF key con-
tains within it explicitly DPF keys for each of its preﬁxes.
Because of this, we can optimize the required key size and

1296computation, to leverage the “shared backbone” of paths
within the decision tree. Our construction instead directly
applies the tensoring approach to “append” each node onto
the backbone structure, one by one.

More speciﬁcally, our construction is recursive. The key
generation procedure Gen starts from the leaves.
In each
step, we obtain an FSS key for a given tree structure Γ
by sampling a key for a smaller tree Γ(cid:48) with all siblings
of one leaf node in Γ removed (say, children ua of a node
v). The output value we select for this newly formed leaf
v in the restricted decision tree program will be the same
structure s||1 ∈ {0, 1}λ+1 as in the tensor operation from
the previous section. And, in an analogous fashion, we will
construct a “correction word” associated with this node v,
which contains the target values for its children, but masked
by the PRG-output of the parties’ respective shares of s (i.e.,
G(sb)). The key thus consists of a correction word for every
node, which is an element of {0, 1}λ+1 for each internal node,
and is an element of the output group G for each leaf node.
Security of the scheme follows the same argument as in the
tensor.

The evaluation procedure Eval begins from the root node,
and calls a recursive function EvalNode. When executed on
a leaf, EvalNode outputs its correction word directly. When
executed on an internal node, EvalNode outputs the sum of
EvalNode on each of its children.

We refer the reader to the full version for formal deﬁni-

tions, constructions, and proof.

Constant-dimension intervals. A sample application of
our FSS construction for decision trees is for constant d-
dimensional interval queries: that is, functions f (x1, . . . , xd)
which evaluate to a selected nonzero value precisely when
ai ≤ xi ≤ bi for some secret interval ranges (ai, bi)i∈[d].
(See, e.g., [28] for supporting a similar functionality in the
context of searching on encrypted data.) For n-bit inputs
of length (cid:96) we achieve FSS for d-dimensional intervals with
key size and computation time O(nd). For small values of d,
such as d = 2 for supporting a conjunction of intervals, this
yields solutions with reasonably good concrete eﬃciency.

Corollary 3.4. For d ∈ N there exists FSS for the class
of d-dimensional intervals (ai, bi)i∈[d] with key size O(λ·nd).

The construction can be achieved as follows. First, we re-
duce from general d-dimensional intervals to the problem of
2d “special” intervals, whose left-boundary ai is equal to 0.
This can be done by means of a linear combination of spe-
cial intervals via inclusion-exclusion (and recalling that FSS
schemes combine linearly [7]).

To illustrate the construction of FSS for these special d-
dimensional intervals, consider the case of d = 1 and 2.
Observe that a 1-dimensional special interval for n-bit in-
puts can be expressed directly as a decision list; that is, a
decision tree with one long length-n path u1, . . . , un with
edges (ui, ui+1), and single terminal edges with appropriate
0/1 output labels departing from each node along the path.
(Namely, a generalization of the OR function construction
discussed earlier).

To extend to 2 dimensions, the 0/1 terminal edges from
nodes ui are each replaced by a length-n decision list (as
above), this time labeled by the corresponding bits of the
second input y. Departing from the primary path corre-
sponds to either falling outside the x-dimension interval (in

which case the ﬁnal leaf will be labeled 0) or within it, in
which case the leaf will be labeled based on the 1-dimensional
y interval. A similar approach can be taken to extend to
general d dimensions, for constant d.

We remark that revealing the topology and node labels
of the utilized d-dimension decision tree (as is the case in
our FSS for decision trees construction) does not adversely
aﬀect security, since this structure is identical across any
choice of secret interval boundaries. Rather, the only thing
that diﬀers in the construction is the choice of edge and leaf
node labels, which is precisely what is hidden by our FSS
construction.
3.4 A Product Operator for FSS

In this section we present a simple technique for increas-
ing the expressive power of FSS by increasing the number
of parties. We consider here function families F such that
for each f ∈ F the output range Rf is equipped with a
ring structure. For two functions f1, f2 with the same input
domain and output ring, we naturally deﬁne the product
f = f1 · f2 by f (x) = f1(x)f2(x).

Definition 3.5

(Product of function families). Let

F1,F2 be function families. Deﬁne
F1·F2 = {f1 · f2 : f1 ∈ F1, f2 ∈ F2, Df1 = Df2 , Rf1 = Rf2}

The product operator can be used for expressing function
classes that capture conjunctions. For instance, if the input
x is partitioned into (x1, x2) and F1,F2 are the classes of in-
terval functions applied to x1 and x2 respectively, the class
F1 · F2 is the class of all two-dimensional intervals. Com-
pared with the solution based on decision trees, we will get
better eﬃciency (linear in the bit-length of the input instead
of quadratic) at the cost of using a larger number of parties.
The following theorem captures the basic FSS product
operator. (Here we use (m, t)-FSS as an abbreviation for
an m-party t-secure FSS.) In the full version we describe an
alternative product operator that converts (m, m − 1)-FSS
schemes for classes Fi, 1 ≤ i ≤ m − 1, into an (m, 1)-FSS
i=1 Fi, where the key size for sharing
f1 · f2 ··· fd is m − 1 times the total key sizes required for
sharing fi.

(Gen, Eval) for F =(cid:81)m−1

Theorem 3.6. Let (Gen1, Eval1) be an (m1, t)-FSS for F1
and (Gen2, Eval2) be an (m2, t)-FSS for F2. Then there ex-
ists an (m1m2, t)-FSS (Gen, Eval) for F = F1 · F2 in which
the size of the key produced by Gen on f1 · f2 is the sum of
the key sizes of Gen1 on f1 and Gen2 on f2.

As a concrete instance, using a 3-party PRG-based DPF
construction from [7] (which achieves a quadratic improve-
ment over a naive solution), one can get a nontrivial PRG-
based (3, 1)-FSS that supports private searches involving a
conjunction of two keywords or ranges.

4. VERIFIABLE FSS: HANDLING MALICIOUS

CLIENTS

As discussed in the Introduction, FSS schemes are mo-
tivated by two types of applications: ones that involve pri-
vately reading from a database stored at two or more servers,
and ones that involve privately writing into a secret-shared
array. In both types of applications, badly formed FSS keys
can enable a malicious client to gain an unfair advantage.

1297Consider, for example, an application of DPF for main-
taining a secret data histogram, say for the purpose of web-
site traﬃc analytics. The histogram count of each bin x ∈
[N ] is additively secret-shared between two servers over a
large group G = Zp. A valid “increment α” query for a (hid-
den) bin α should correspond to secret shares of the point
function fα,1 that evaluates to 1 at α and 0 at all other
points. However, since each server sees only one share of
the function (to hide the identity of α), neither server on its
own has a way of verifying that the given shares really do
encode such a “proper” point function. A malicious client
may just as easily encode a function that increments item
α by 100, eﬀectively casting a “heavy” vote. Even worse,
it may encode a “garbage” function f∗ that increments ev-
ery bin by some random amount—eﬀectively erasing all the
prior existing counts. We seek eﬃcient procedures for the
servers to verify the validity of the function shared by the
client before it is being processed, by using a small amount
of server-to-server communication.

4.1 Modeling Veriﬁable FSS

We consider an FSS scheme where m the keys are gen-
erated by a potentially malicious client, but are processed
by semi-honest servers, to which we refer from here on as
parties. That is, the parties honestly follow the prescribed
protocol, but try to infer as much information as possible
about an honest client’s secret function f from their view.
We allow the parties to communicate over secure point-to-
point channels, but try to minimize the communication to
the extent possible. (Some form of communication between
the parties is clearly necessary for verifying the consistency
of the keys.) Finally, we make the simplifying assumption
that parties can generate a common source of randomness
which is unpredictable to the clients, and do not count this
randomness towards the communication.
In practice, this
common source of randomness can be realized by having
one of the parties pick a random PRF key and communicat-
ing it to all other parties. The same PRF key can be used
to verify many FSS instances, as long as it is independent
of the FSS keys.

We are interested in veriﬁcation protocols that minimize
communication between parties, do not involve the client
beyond the initial key distribution, and do not involve any
additional parties. This should be contrasted with a veriﬁ-
cation protocol from [11] that involves an additional party
and requires communication linear in the domain size.

Similarly to the veriﬁcation protocol from [11], we would
like our protocols to only make a black-box use of the un-
derlying FSS scheme (which in our case translates into a
black-box use of a PRG). The latter requirement is meant
to rule out protocols that involve a generic use of secure
computation for verifying that the keys form a valid output
of Gen. To the end of realizing such a black-box veriﬁcation,
we are willing to slightly relax the goal by settling for the va-
lidity of the keys with respect to a given set of inputs. That
is, the veriﬁcation protocol is given a subset D(cid:48) of the input
domain D as an additional input. The set D(cid:48) represents
the set of inputs on which the function f will actually be
evaluated, and hence may not be known to the client. The
distinction between D and D(cid:48) is motivated by applications
such as secure keyword search or range queries, where D(cid:48)
is typically a tiny subset of D. However, in other applica-
tions of FSS, including PIR and distributed histograms, it

is typically the case that D(cid:48) = D.

We allow the running time of the veriﬁcation protocol, but
not its communication complexity, to grow with the size of
D(cid:48). In fact, all veriﬁcation protocols we present invoke Eval
on every x ∈ D(cid:48). This is typically not an eﬃciency bottle-
neck, since these evaluations are anyway necessary for the
application. We expect our solutions to beat the concrete
eﬃciency of applying practical general-purpose MPC proto-
cols to the function deﬁned by Gen except, perhaps, when
D(cid:48) is very large.

The veriﬁcation protocol should have the following sound-
ness property: If the veriﬁcation protocol is successful, then
the parties are essentially convinced that the function f∗
eﬀectively shared by the client is consistent with some f ∈
F on the domain D(cid:48). Of course, the veriﬁcation protocol
should not reveal to the parties any information about the
function f∗ beyond its validity.

We formalize the above requirements below. For simplic-
ity we do not explicitly treat general leakage, since we will
present veriﬁcation protocols for FSS with standard leak-
age, namely where only the input domain Df and output
domain Rf are leaked. However, the deﬁnitions extend in a
straightforward way to the general case.

Definition 4.1

(Verifiable FSS). Let F be a class
of functions. An (m, t)-veriﬁable FSS (VFSS) for F is a
triplet of algorithms (Gen, Eval, Ver) such that (Gen, Eval) are
an FSS for F as in Deﬁnition 2.2, and there exists a negligi-
ble function negl for which the following additional require-
ments hold.

• Syntax of Ver: Ver is an m-party interactive proto-
col. In the beginning of the protocol, each party i has
a local input ki (presumably an output of Gen). In ad-
dition, all parties share the following common inputs:
a security parameter 1λ, an input domain D for (an
unknown) f ∈ F, output domain R for f , and a subset
D(cid:48) ⊆ D of relevant evaluation points. (An empty D(cid:48)
is interpreted as D(cid:48) = D.) We also assume that the
parties have access to a common source of randomness
picked independently of the inputs, and do not count
this randomness towards the communication complex-
ity. In the end of the protocol, each party outputs “Ac-
cept” or “Reject.”

• Completeness: If (k1, . . . , km) are valid outputs of
Gen(1λ, f ) for some f ∈ F with input domain D and
output domain R, then for all D(cid:48) ⊆ D, in the execution
of Ver on local inputs (k1, . . . , km) and common inputs
D, D(cid:48), R, all parties output “Accept” with probability 1.
• Soundness: Consider the following security experi-
ment deﬁned by a PPT adversary A running on in-
put 1λ:
1: A(1λ) outputs a description of FSS input domain
D, FSS output domain R, FSS keys (k∗
m),
and a set D(cid:48) ⊆ D (represented by an explicit list
of elements).
2: The protocol Ver is executed on local inputs (k∗
and common inputs 1λ, D, R, D(cid:48).
3: A wins if at least one party outputs “Accept” and
moreover there is no function f ∈ F with input do-
main D∗ and output domain R∗ for which f∗
1 (x) +
m(x) = f (x) for all x ∈ D(cid:48) (where f∗
. . . + f∗
i (x) :=
Eval(i, k∗
i , x)).

1 , . . . , k∗

1 , . . . , k∗
m)

1298The soundness requirement is that every PPT A can
only win the above game with negligible probability in λ.
• Secrecy: Following the (honest) execution of Ver on
keys (k1, . . . , km) generated by Gen(1λ, f ) (with an ar-
bitrary D(cid:48) ⊆ Df ), the joint view of any t parties should
not reveal anything about f except Df and Rf . This
is formalized as in the secrecy requirement of Deﬁni-
tion 2.2, except that the output of Real includes the
entire view of parties in S. When t is unspeciﬁed, it is
understood to be m − 1.

Selective failure attacks. While allowing D(cid:48) to be a
strict subset of D is useful, it may also give rise to secu-
rity vulnerabilities. First, the above soundness requirement
does not rule out a correlation between the set D(cid:48) of relevant
evaluation points and the event of rejecting.1 While selec-
tive failure attacks can often be problematic, we would like
to argue that they are not a major concern in the context
of natural applications of veriﬁable FSS. First, as discussed
earlier, veriﬁable FSS is most strongly motivated by “writ-
ing” scenarios, where we typically have D(cid:48) = D and the
client learns nothing from the event of rejection. Even if we
use D(cid:48) ⊂ D, in such scenarios the client does not need to
be directly informed that an error has been detected, and
his vote can be silently discarded. In any case, the price of
being caught cheating typically outweighs the advantage of
learning one bit of information about D(cid:48).
A second type of attack that may apply to the case where
D(cid:48) ⊂ D is when an invalid function shared by a malicious
client coincides with a valid function when restricted to D(cid:48).
For instance, in a veriﬁable DPF protocol, a malicious client
can share a function that has a nonzero output on many
points (say, simultaneously voting for many candidates) in
the hope that the function will have only one nonzero output
on the (unknown) subset D(cid:48). Both types of attacks are
irrelevant to the case D(cid:48) = D, and they can be mitigated by
incurring a penalty for being caught cheating.
4.2 Template for Veriﬁable FSS Protocols

We assume that the output domain G is of the form Z(cid:96)
p,
for a prime p and positive integer (cid:96), and view it as the ad-
ditive group of the (large) ﬁnite ﬁeld F
p(cid:96) . Our veriﬁcation
protocols typically achieve soundness error of O(1/|F|) by
communicating just a constant number of ﬁeld elements. To
verify FSS over a small group, such as G = Z2, one can
view G as a subgroup of the additive group of a suﬃciently
large ﬁeld, say F = F
2λ , and apply a veriﬁcation scheme for
an FSS over F. (This does not require any changes to Gen
or Eval, only to make Ver view each output of Eval as an
element of F.)
The high level idea of our veriﬁable protocols is the follow-
ing. Let N = |D(cid:48)|. Consider the function family F(cid:48) deﬁned
by restricting F to the evaluation points in D(cid:48). By locally
applying Eval on the inputs in D(cid:48), the parties obtain an ad-
ditive secret sharing of a (long) vector y ∈ FN consisting of
the values (f∗(x))x∈D(cid:48) . The parties need to verify that y
1In fact, such correlations are inherent to any solution that
only makes a black-box access of Eval, which includes all of
the eﬃcient solutions we present next. Indeed, there is no
way to eﬃciently distinguish between, say, a random point
function on λ-bit inputs and a function that has a nonzero
value on two random inputs.

is valid, namely it is consistent with F(cid:48), using only a small
amount of communication and without revealing informa-
tion about y. For instance, in the case of point functions
the vector y should satisfy the requirement that it has at
most one nonzero entry.

The veriﬁcation that y is well-formed is achieved via the
following combination of randomized linear sketching and
special-purpose MPC. The parties use their common source
of randomness to pick a linear function L : FN → Fd, where
d is a small constant. The function L (also referred to as a
“linear sketch”) is picked from a carefully chosen distribution
L that has the following properties:

1. Given z = L(y), one can decide (with negligible error
probability over the choice of L) whether y is valid,
namely it is consistent with F;

2. This decision procedure is “MPC friendly” in the sense
that there is a very eﬃcient MPC protocol ΠMPC for
verifying that a secret-shared vector z ∈ Fd is of the
right form.

Given a distribution L and an MPC protocol ΠMPC as above,
the protocol Ver proceeds as follows. Party i, holding a
(long) additive share yi of y, locally compresses yi into zi =
L(yi). Then the parties run ΠMPC for deciding whether to
accept y as being consistent with F(cid:48).

To further improve the eﬃciency of ΠMPC, we let the FSS
client distribute between the parties correlated randomness
that is consumed by ΠMPC. This correlated randomness can
be incorporated into the keys produced by Gen and does not
require additional interaction with the client. However, it
is critical that the soundness of the veriﬁcation hold even
if this correlated randomness is distributed by a malicious
client. Our solutions for this type of “client-assisted MPC”
problems can be useful beyond the context of veriﬁable FSS.
To fully instantiate the above template, we need to specify
the distribution L from which L is picked, the veriﬁcation
predicate V applied to z, and the MPC protocol ΠMPC for
(client-assisted) computation of V on the shares of z. See
Figure 2 for a formal description of a veriﬁcation protocol
following this template. In Section 4.3 we will instantiate
the sketching distribution L and in Section 4.4 we will in-
stantiate the MPC protocol ΠMPC.
4.3 Instantiating the Sketching Scheme (L,V)
In this section we propose several eﬃcient instantiations
of the sketching scheme (L,V) that apply to useful classes F
and support very eﬃcient MPC protocols for V. All instan-
tiations rely on the standard Schwartz-Zippel (SZ) lemma,
bounding the number of zeros of a low-degree polynomial.
Due to space constraints we defer proofs to the full version.
DPF fα,β with β ∈ {0, 1} and F of characteristic > 2.
This is the most useful case for applications that involve
voting or counting, where each client can increment a single
counter by 1 or “abstain” by using β = 0. Here we use Lsq
that picks random ﬁeld elements r1, . . . , rN and outputs the
matrix L ∈ F2×N deﬁned by L1,j = rj and L2,j = r2
j . That
is, each column of L contains a random ﬁeld element and
the square of this element. (In an actual implementation, L
can be generated using a short PRF key picked by one of
the parties and sent to all others.) The veriﬁcation predicate
Vsq, which will be realized by ΠMPC, checks that the sketch
z = (z1, z2) satisﬁes the condition Vsq(z1, z2) = z2
1 − z2 = 0.

1299FSS Veriﬁcation Template Ver(i, k∗
i )
Common inputs:

- Security parameter 1λ;
- Input length 1n, of FSS input domain D = {0, 1}n;
- FSS output group G ⊆ F, where F is a ﬁnite ﬁeld and
|F| ≥ 2λ;
// Here λ can be taken to be a statistical
security parameter.
- Subset D(cid:48) ⊆ D of size N . An empty D(cid:48) is interpreted
as D(cid:48) = D; // Running time is linear in N .

Given algorithms:

- FSS evaluation algorithm Eval;
- Matrix sampler L(F, N ), outputting a matrix L ∈
Fd×N (for some constant d ≥ 1);
- Veriﬁcation predicate V : Fd → Fd(cid:48)
- Client-assisted MPC protocol ΠMPC for V.

;

1: Picking matrix: Let L ← L(F, N ) using common ran-

domness;
// Same L is used by all parties; L can be reused as long
as it is independent of all k∗
i .
i , x))x∈D(cid:48) ; //yi ∈ FN

2: Applying Eval: yi ← (Eval(i, k∗
3: Local compression: Let zi ← L · yi; //zi ∈ Fd
4: Interactive veriﬁcation: Run ΠMPC on input zi using
i to evaluate V(z) and accept

correlated randomness in k∗
if and only if the output of ΠMPC is the all-0 vector.

Figure 2: Template for FSS veriﬁcation protocol for a given
(Gen, Eval).

Claim 4.2. Let F be a ﬁnite ﬁeld of characteristic p > 2.
If y ∈ FN is neither a unit vector nor the all-0 vector, then

Pr(cid:2)L ← Lsq(F, N ); (z1, z2) ← L · y : z2 = z2

(cid:3) ≤ 2/|F|.

1

DPF fα,β with β ∈ {0, 1} and general F. We can elim-
inate the restriction on F by using a sketch of d = 3 ﬁeld
elements: Lprod picks L ∈ F3×N as a random matrix whose
third row is the product of the ﬁrst two. That is, L1,j = rj,
L2,j = sj, and L3j = rjsj where the rj and sj are random
and independent ﬁeld elements. The veriﬁcation predicate
is Vprod(z1, z2, z3) = z1z2 − z3.

Claim 4.3. Let F be any ﬁnite ﬁeld. Suppose y ∈ FN is
neither a unit vector nor the all-0 vector. Then
Pr [L ← Lprod(F, N ); (z1, z2, z3) ← L · y : z3 = z1z2] ≤ 2/|F|.

DPF fα,β with β ∈ {1,−1} and general F. Our next
sketching procedure applies to general ﬁelds and, like the
ﬁrst procedure, only requires a sketch of d = 2 ﬁeld ele-
ments. An additional diﬀerence is that the set of possible
β values is {1,−1} instead of {0, 1}. In the case of ﬁelds of
characteristic 2, this is equivalent to requiring that β = 1.
Over other ﬁelds, one can either view the extra possibility
as a feature, e.g., for votes that involve “liking” or “disliking”
a candidate, or enforce the requirement that β = 1 as de-
scribed below. Here we use Linv that picks random nonzero
ﬁeld elements r1, . . . , rN and deﬁne L ∈ F2×N by L1,j = rj

−1
j

and L2,j = r
. That is, each column of L contains a ran-
dom ﬁeld element and its inverse. The veriﬁcation predicate
is Vinv(z1, z2) = z1z2 − 1 = 0. While generating L using Linv
is computationally more expensive than Lsq, its cost can be
amortized since the same L can be used to verify many DPF
keys.

Claim 4.4. Let F be any ﬁnite ﬁeld. If y ∈ FN is neither

a unit vector nor the negation of a unit vector, then
Pr [L ← Linv(F, N ); (z1, z2) ← L · y : z1z2 = 1] ≤ N/(|F|−1).

DPF fα,β with β = 1. The above sketching schemes allow β
to take two possible values. If we want to ensure that β = 1,
it suﬃces to additionally check that the sum of all entries
in y is equal to 1. Using our linear sketching framework,
this can be done in both cases by adding to L an additional
all-1 row and extending the veriﬁcation predicate V. For
instance, for d = 2, we extend V(z1, z2) into V(cid:48)(z1, z2, z3) =
(V(z1, z2), z3 − 1).
Note that the above two sketching schemes are only useful
when D(cid:48) = D. When D(cid:48) is a strict subset of D, the resulting
veriﬁable FSS would fail to be complete in the case α (cid:54)∈ D(cid:48),
because in this case y is the all-0 vector which is rejected by
the above sketching schemes.
DPF fα,β with unrestricted β ∈ F. The above sketch-
ing schemes natively support useful restrictions of β, namely
either β ∈ {0, 1}, β ∈ {1,−1}, or β = 1. However, in some
applications, such as “writing” applications in which a client
is free to overwrite the entire contents of a single entry of an
array, it is useful to support a DPF fα,β where β can be an
arbitrary ﬁeld element. To this end, we augment the general
template in Figure 2 by allowing the veriﬁcation predicate
V to be non-deterministic. That is, V may depend an addi-
tional input w ∈ F that is secret-shared by the client as part
of Gen. Given an honestly generated w, the veriﬁcation suc-
ceeds, and even a maliciously generated w cannot increase
the probability of accepting an invalid y.

To verify an arbitrary point function fα,β, we augment

the previous veriﬁcation predicates as follows:

• V(cid:48)

1 − z2w, where an honest client uses
sq(z1, z2, w) = z2
w = β.
prod(z1, z2, z3, w) = z1z2−z3w, where an honest client
uses w = β.
inv(z1, z2, w) = z1z2 − w, where an honest client uses
w = β2.

• V(cid:48)

• V(cid:48)

Completeness is easy to verify. To argue soundness, one can
modify the previous case analysis to show that for any y
with at least two nozero entries and for any ﬁxed w ∈ F,
the polynomial V(cid:48) still contains a monomial with a nonzero
coeﬃcient.

FSS for intervals.
In the full version, we present an
extension of the above techniques to the class of interval
functions f[a,b] that evaluate to 1 on all x ∈ [a, b] (where x
is interpreted as an integer in [0, 2n − 1]) and evaluates to 0
on all other inputs.
4.4 Instantiating the MPC Protocol ΠMPC

The previous sketching schemes reduce the veriﬁcation
that a long vector y is “well formed” (i.e., belongs to some

1300set B ⊆ FN deﬁned by F and D(cid:48)), to computing a simple,
low-degree predicate V on a short vector z given an additive
sharing z1, . . . , zm of z.
Given the simple nature of the predicates V we use, the
parties could compute V on their own. For instance, if there
is an honest majority of parties (t < m/2) they could use a
“BGW-style” protocol [4], or if there is no honest majority
they could use a “GMW-style” protocol [19] or an arith-
metic variant of this protocol [17, 23]. However, in the lat-
ter case, and in particular in the 2-party case, such protocols
make use of public-key cryptography and involve a consider-
able computation and communication overhead. While this
overhead can be amortized to some extent over multiple in-
stances (e.g., using OT extension techniques [2, 21]), we can
obtain better asymptotic and concrete eﬃciency by using
the help of correlated randomness provided by the client as
part of its key generation.

We present two diﬀerent MPC techniques that apply to
diﬀerent scenarios. The ﬁrst applies to the basic scenario
of verifying predicates V for the simple sketching schemes
described above. It relies on Beaver’s circuit randomization
technique [1] and its soundness exploits the fact that if y
is invalid, then the output of V is not only nonzero with
high probability but it also has a lot of entropy that can-
not be eliminated even if the client provides badly formed
correlated randomness. The second technique is based on
so-called linear PCPs and applies to a more specialized ver-
iﬁcation scenario in which such entropy is not present.
Using shared products. Originating from Beaver’s cir-
cuit randomization technique [1], a common technique for
speeding up MPC protocols is by employing correlated ran-
domness provided by a trusted dealer (or securely imple-
mented using input-independent preprocessing). In the case
of semi-honest parties, Beaver’s technique is very eﬃcient:
it requires the dealer to send 3 ﬁeld elements to each party
for each multiplication gate, and requires each party to com-
municate to all other parties just a single ﬁeld element for
every input or multiplication gate.

Naturally, when the dealer is malicious, the security guar-
antees of the protocol break down. (The goal of protecting
such protocols against a malicious dealer is orthogonal to
the goal of protecting them against malicious parties; see,
e.g., [5, 12] for eﬃcient solutions to the latter.) In [16] it was
observed that in natural protocols of this type, the eﬀect of
a malicious dealer corresponds precisely to an additive at-
tack on the circuit computed by the protocol, namely an
attack that can “blindly” add a ﬁeld element to every inter-
nal wire in the arithmetic circuit computed by the protocol.
To protect against this type of attacks, the solution proposed
in [16] is to protect the computation against additive attack
by using a special type of fault-tolerant circuit called “AMD
circuit.” While this approach can be used protect against a
malicious dealer with a constant overhead, this constant is
quite large and the resulting protocols are fairly complex.
Our main observation is that for the purposes of securely
verifying V, the additive attacks induced by badly formed
correlated randomness are harmless, because the soundness
of the sketching scheme holds even in the presence of such
attacks. As noted above, the high level reason for this is that
the attack cannot reduce the entropy of V(z) for a sketch z
computed from a badly formed y.
More concretely, the predicates V deﬁned above only re-
quire either one or two multiplications, where each multipli-

cation of additively shared secrets a and b is implemented
using Beaver’s technique as follows:

• Inputs: Additive shares [a] = ([a]1, . . . , [a]m) and [b] =

([b]1, . . . , [b]m) of secrets a, b ∈ F.

• Outputs: Additive shares [c] = ([c]1, . . . , [c]m) of c =

ab.

• Correlated randomness: Random additive shares
[a(cid:48)], [b(cid:48)] of random and independent secrets a(cid:48), b(cid:48) ∈ F,
and random additive shares [c(cid:48)] of c(cid:48) = a(cid:48)b(cid:48).
// This correlated randomness is included in the keys
output by Gen.

• Communication: Party i locally computes [∆a]i =
[a]i − [a(cid:48)]i and [∆b]i = [b]i − [b(cid:48)]i and sends [∆a]i and
[∆b]i to all other parties.

• Computing output: Party i computes ∆a =(cid:80)m
and ∆b = (cid:80)m

j=1[∆b]j, and outputs [c]i = ∆a∆b +

j=1[∆a]j

∆b[a]i + ∆a[b]i + [c(cid:48)]i.

To evaluate V on the shared sketch [z], we use the above
procedure for evaluating each multiplication, where addi-
tions are implemented non-interactively, and the output is
reconstructed by simply exchanging shares of the output.

We now brieﬂy analyze the security of the FSS veriﬁcation
protocol obtained by combining the above client-aided MPC
protocol with the sketching schemes proposed above. First,
since we assume the parties to be semi-honest, the secrecy
property follows from the semi-honest security of the MPC
protocol (i.e., the only information learned by the parites is
that V(z) = 0, which is always the case for an honest client).
Consider the case of correlated randomness generated by a
malicious client. Since all predicates V we consider include
only a single level of multiplications, the eﬀect of such bad
randomness is limited to adding some χ ∈ F to each output.
Indeed, since every possible choice of [a(cid:48)] and [b(cid:48)] is valid, an
inconsistency can always be viewed as an error in the choice
of c(cid:48), which is only added to the output. (If the computation
involves two multiplications followed by an addition, which
is needed for some of the predicates V we propose, the two
errors χ1 and χ2 are added.)
The crucial point is that the additive error χ introduced
by bad randomness is independent of the randomness of L.
Hence, it suﬃces to observe that the soundness of the sketch-
ing schemes (L,V) we propose holds also if the constant χ
is added to the output of V. This follows from the fact
that soundness is argued via the Schwartz-Zippel Lemma
applied to polynomials whose degree is greater than 1, for
which adding a constant does not change the degree.

Using linear PCPs for specially structured β. The
soundness of the above MPC protocol crucially depends on
the fact that the client cannot predict the inputs for the
protocol in case y is invalid. In the full version, we describe
a diﬀerent technique for the case where the inputs are fully
known to the client. Concretely, the technique is used to
make the client prove that the value β of a point function
fα,β has a special structure. A particularly useful instance
is where β is of the form (γ, γ2, . . . , γd) ∈ Fd for a ﬁnite ﬁeld
F. A β vector of this form can be used to decode a set of
messages that match the same search criterion in “reading”
applications or are written to the same bin in “writing” ap-
plications [15, 11]. The idea is to make the client help the
parties verify the validity of β by secret-sharing a suitable

1301proof between the parties. The proof can be viewed as a
special case of the so-called Hadamard-PCP that has been
previously used in the context of sublinear-communication
arguments for NP [22, 6], exploiting the simple algebraic
structure of the statement for better eﬃciency.
4.5 Putting the Pieces Together

We conclude by summarizing the type of FSS veriﬁcation
enabled by combining the above sketching schemes and MPC
protocols.

Theorem 4.5

(Verifiable FSS). For each function fam-

ily Fi speciﬁed below, the following holds. For every m-party
FSS scheme Π = (Gen, Eval) for Fi, there is an m-party ver-
iﬁable FSS scheme Π(cid:48) = (Gen(cid:48), Eval, Ver) for Fi such that
keys generated by Gen(cid:48) include keys of Gen and a constant
number of additional ﬁeld elements, and in Ver parties in-
voke Eval once on each x ∈ D(cid:48), perform O(|D(cid:48)|) additional
ﬁeld operations, and communicate a constant number of ﬁeld
elements with each other.

The function families Fi are:
• All point functions fα,β;
• All point functions fα,β with β ∈ {0, 1} (alternatively,

with β = 1 or β ∈ {1,−1} if D(cid:48) = D);

• All interval functions f[a,b] and their negations −f[a,b].
• All point functions fα,β for β of the special form (γ,
γ2, . . . , γd) ∈ Fd; here the keys produced by Gen include
O(d) additional ﬁeld elements.

Acknowledgements. Research done in part while visit-
ing the Simons Institute for the Theory of Computing, sup-
ported by the Simons Foundation and by the DIMACS /
Simons Collaboration in Cryptography through NSF grant
#CNS-1523467. Supported by ERC starting grant 259426.

The ﬁrst author additionally supported by ISF grant 1709/14

and ERC starting grant 307952. The second author addi-
tionally supported by ISF grant 1638/15, a grant by the
BGU Cyber Center, the Israeli Ministry Of Science and
Technology Cyber Program and by the European Union’s
Horizon 2020 ICT program (Mikelangelo project). The third
author was additionally supported by DARPA Brandeis pro-
gram under Contract N66001-15-C-4065, ISF grant 1709/14,
BSF grant 2012378, a DARPA/ARL SAFEWARE award,
NSF Frontier Award 1413955, NSF grants 1228984, 1136174,
1118096, and 1065276. This material is based upon work
supported by the Defense Advanced Research Projects Agency
through the ARL under Contract W911NF-15-C-0205. The
views expressed are those of the author and do not reﬂect
the oﬃcial policy or position of the Department of Defense,
the National Science Foundation, or the U.S. Government.

5. REFERENCES
[1] D. Beaver. Eﬃcient multiparty protocols using circuit
randomization. In CRYPTO ’91, pages 420–432, 1991.

[2] D. Beaver. Correlated pseudorandomness and the

complexity of private computations. In STOC 1996,
pages 479–488, 1996.

[3] A. Beimel, Y. Ishai, E. Kushilevitz, and I. Orlov.

Share conversion and private information retrieval. In
CCC 2012, pages 258–268, 2012.

[4] M. Ben-Or, S. Goldwasser, and A. Wigderson.
Completeness theorems for non-cryptographic
fault-tolerant distributed computation (extended
abstract). In STOC, pages 1–10, 1988.

[5] R. Bendlin, I. Damg˚ard, C. Orlandi, and S. Zakarias.

Semi-homomorphic encryption and multiparty
computation. In Eurocrypt 2011, pages 169–188, 2011.

[6] N. Bitansky, A. Chiesa, Y. Ishai, R. Ostrovsky, and
O. Paneth. Succinct non-interactive arguments via
linear interactive proofs. In TCC, pages 315–333, 2013.

[7] E. Boyle, N. Gilboa, and Y. Ishai. Function secret

sharing. In EUROCRYPT 2015, pages 337–367, 2015.

[8] B. Chor and N. Gilboa. Computationally private

information retrieval (extended abstract). In STOC
1997, pages 304–313, 1997.

[9] B. Chor, N. Gilboa, and M. Naor. Private information

retrieval by keywords. IACR Cryptology ePrint
Archive, 1998:3, 1998.

[10] B. Chor, O. Goldreich, E. Kushilevitz, and M. Sudan.
Private information retrieval. J. ACM, 45(6):965–981,
1998.

[11] H. Corrigan-Gibbs, D. Boneh, and D. Mazi`eres.

Riposte: An anonymous messaging system handling
millions of users. In IEEE Symposium on Security and
Privacy, pages 321–338, 2015.

[12] I. Damg˚ard, V. Pastro, N. P. Smart, and S. Zakarias.

Multiparty computation from somewhat homomorphic
encryption. In CRYPTO 2012, pages 643–662, 2012.

[13] G. Di Crescenzo, T. Malkin, and R. Ostrovsky. Single

database private information retrieval implies
oblivious transfer. In EUROCRYPT 2000, pages
122–138, 2000.

[14] Y. Dodis, S. Halevi, R. D. Rothblum, and D. Wichs.
Spooky encryption and its applications. In CRYPTO
2016, pages 93–122, 2016.

[15] M. Finiasz and K. Ramchandran. Private stream

search at the same communication cost as a regular
search: Role of LDPC codes. In ISIT 2012, pages
2556–2560, 2012.

[16] D. Genkin, Y. Ishai, M. Prabhakaran, A. Sahai, and
E. Tromer. Circuits resilient to additive attacks with
applications to secure computation. In STOC 2014,
pages 495–504, 2014.

[17] N. Gilboa. Two party RSA key generation. In

CRYPTO ’99, pages 116–129, 1999.

[18] N. Gilboa and Y. Ishai. Distributed point functions
and their applications. In Advances in Cryptology -
EUROCRYPT, pages 640–658, 2014.

[19] O. Goldreich, S. Micali, and A. Wigderson. How to

play any mental game or a completeness theorem for
protocols with honest majority. In STOC, pages
218–229, 1987.

[20] T. Gupta, N. Crooks, W. Mulhern, S. Setty, L. Alvisi,

and M. Walﬁsh. Scalable and private media
consumption with popcorn. In NSDI 2016, 2016.

[21] Y. Ishai, J. Kilian, K. Nissim, and E. Petrank.

Extending oblivious transfers eﬃciently. In CRYPTO
2003, pages 145–161, 2003.

[22] Y. Ishai, E. Kushilevitz, and R. Ostrovsky. Eﬃcient
arguments without short PCPs. In 22nd CCC, pages
278–291, 2007.

1302[23] Y. Ishai, M. Prabhakaran, and A. Sahai. Secure

arithmetic computation with no honest majority. In
TCC 2009, pages 294–314. Springer, 2009.

[24] E. Kushilevitz and R. Ostrovsky. Replication is NOT

needed: SINGLE database, computationally-private
information retrieval. In 38th FOCS, pages 364–373,
1997.

[25] C. A. Melchor, J. Barrier, L. Fousse, and M. Killijian.

XPIR : Private information retrieval for everyone.
PoPETs, 2016(2):155–174, 2016.

[26] R. Ostrovsky and V. Shoup. Private information

storage (extended abstract). In STOC 1997, pages
294–303, 1997.

[27] R. Ostrovsky and W. Skeith III. Private searching on

streaming data. In CRYPTO 2005, pages 223–240,
2005.

[28] E. Shi, J. Bethencourt, H. T. Chan, D. X. Song, and

A. Perrig. Multi-dimensional range query over
encrypted data. In 2007 IEEE Symposium on Security
and Privacy, pages 350–364, 2007.

APPENDIX
A. APPLICATIONS OF FSS

In this section we describe some representative applica-
tions of FSS beyond those described in the Introduction.
For simplicity we restrict attention to 2-party FSS.

Private keyword search. Suppose that each of two servers
holds a database of keywords with corresponding payloads
X = {(x1, p1), . . . , (xN , pN )} where xj ∈ {0, 1}n and pj ∈
{0, 1}m. We further assume that no payload pj is the all-0
string. The client would like to privately test whether some
secret keyword x is in the database, and obtain the corre-
sponding payload if it is. To this end, the client uses a DPF
to split the point function fx,1 : {0, 1}n → Z2 into f1, f2,
sending each key to the corresponding server. Server i sends
j=1 pjfi(xj), where each pj is viewed as an
element in Zm
2 be the answers received from
the two servers. The client lets p = a1 + a2, and outputs “no
match” if p = 0 or p otherwise.

back the sum(cid:80)N

2 . Let a1, a2 ∈ Zm

i returns (cid:80)N

Generalized keyword search. In the case of a general-
ized keyword search, where the search predicate f : {0, 1}n →
{0, 1} is taken from a class F, the client can count the num-
ber of entries j satisfying f (xj) = 1 by viewing the range of
f as the group G = ZN +1. Splitting f into f1 + f2, server
j=1 fi(xj), and the client can recover the ex-
act number of matches by adding the two answers in G. A
bounded number of matching payloads can be retrieved by
using sketching or coding techniques [27, 15].

Private updates. Consider the following application sce-
nario for a writing analogue of PIR [26]. A user owns N
ﬁles (x1, . . . , xN ) where xj ∈ {0, 1}m. For backup purposes,
the ﬁles are secret-shared between two cloud servers, namely
every xj is split into xj,1 and xj,2 such that xj,1 ⊕ xj,2 = xj.
The user would like to update ﬁle xα to a new version x(cid:48)
α
without revealing any information about the update (includ-
ing the identity α of the ﬁle that has been updated) to any
individual server. To this end, the client lets β = xj ⊕ x(cid:48)
and uses a DPF to split the point function fα,β : [N ] → Zm
2
into f1, f2, sending each key to the corresponding server.

j

Each server i updates its shares of the N ﬁles by letting
j,i ← xj,i ⊕ fi(j), for 1 ≤ j ≤ N .
x(cid:48)
B. CONCRETE EFFICIENCY OF PIR

Since the introduction of Private Information Retrieval
(PIR), there have been three diﬀerent models for PIR. The
ﬁrst, presented in the original PIR work of Chor et al. [10],
assumes that the database is replicated in k ≥ 2 non-colluding
servers and requires that the protocol be information theo-
retically secure. The second, proposed by Chor and Gilboa [8],
assumes two non-colluding servers but relaxes the security
requirement to hold against computationally bounded ad-
versaries. The third model, introduced in [24], assumes that
the database is held by a single server and security is again
computational.

In the application of DPF to PIR, as described in the In-
troduction, the query size is the DPF key, which is roughly
of size λ·(n−log λ) for a database of size N = 2n records (im-
proving over the previous best DPF-based solution from [7]
by roughly a factor of 4). Using Theorem 3.3, the DPF key
requires approximately N/64 AES operations. In addition
to this cost, each server should take the inner product of
a (pseudo-)random N -bit vector with the database, eﬀec-
tively amounting to computing the XOR of roughly half the
records in the database. The latter cost is common to all
multi-server PIR protocols that have 1-bit answers.2

Chor et al. [10] present a simple 2-server information-
theoretic PIR protocol with N -bit queries and 1-bit an-
swers.This protocol provides good concrete eﬃciency in ap-
plications that involve a small number of records (e.g., see
[20]). The optimized DPF protocol in this paper leads to
better communication complexity for databases that have
400 items or more.
Information-theoretic PIR protocols
with k ≥ 3 servers achieve better communication complex-
ity than two-server protocols. However, employing an addi-
tional server may be costly, and moreover, even the best pub-
lished schemes for practical parameters (e.g., the 3-server
protocol in [3] with communication complexity 14N 1/4) have
higher communication than our construction for large enough
databases, e.g. four billion items for [3]. In terms of com-
putation, all multi-server PIR protocols require each server
to expand a received key to a string of N elements and
then compute the inner product of the database with the ex-
panded key. In the two-server solution of [10] the expanded
string is explicitly sent to each server; other information-
theoretic PIR protocols require several ﬁeld or ring opera-
tions per database bit to perform this expansion. We note
that all of the alternative approaches do not natively gen-
eralize to more general types of searches, such as keyword
search or range queries, without a signiﬁcant overhead in-
troduced by the use of data structures.

Single-server PIR with sublinear communication is known
to imply public-key encryption [13]. Indeed all known single-
server PIR protocols require (additively homomorphic) public-
key encryption of the whole database to evaluate a PIR
query (cf. [25] and references therein). This is typically sev-
eral orders of magnitude slower than the solution we present.

2To simplify the exposition we restrict our attention to pro-
tocols that have 1-bit answers, since these seem to be the
most attractive from a concrete eﬃciency point of view.

1303