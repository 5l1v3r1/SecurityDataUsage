The Devil is in the Constants: Bypassing Defenses

in Browser JIT Engines

Michalis Athanasakis

Elias Athanasopoulos

FORTH, Greece

michath@ics.forth.gr

FORTH, Greece

elathan@ics.forth.gr

Michalis Polychronakis
Stony Brook University

mikepo@cs.stonybrook.edu

Georgios Portokalidis
Stevens Institute of Tech.

gportoka@stevens.edu

Sotiris Ioannidis
FORTH, Greece
sotiris@ics.forth.gr

Abstract—Return-oriented programming (ROP) has become
the dominant form of vulnerability exploitation in both user
and kernel space. Many defenses against ROP exploits exist,
which can signiﬁcantly raise the bar against attackers. Although
protecting existing code, such as applications and the kernel,
might be possible, taking countermeasures against dynamic code,
i.e., code that is generated only at run-time, is much harder.
Attackers have already started exploiting Just-in-Time (JIT)
engines, available in all modern browsers, to introduce their
(shell)code (either native code or re-usable gadgets) during JIT
compilation, and then taking advantage of it.

Recognizing this immediate threat, browser vendors started
employing defenses for hardening their JIT engines. In this paper,
we show that—no matter the employed defenses—JIT engines are
still exploitable using solely dynamically generated gadgets. We
demonstrate that dynamic ROP payload construction is possible
in two modern web browsers without using any of the available
gadgets contained in the browser binary or linked libraries. First,
we exploit an open source JIT engine (Mozilla Firefox) by feeding
it malicious JavaScript, which once processed generates all re-
quired gadgets for running any shellcode successfully. Second, we
exploit a proprietary JIT engine, the one in the 64-bit Microsoft
Internet Explorer, which employs many undocumented, specially
crafted defenses against JIT exploitation. We manage to bypass
all of them and create the required gadgets for running any
shellcode successfully. All defensive techniques are documented
in this paper to assist other researchers. Furthermore, besides
showing how to construct ROP gadgets on-the-ﬂy, we also show
how to discover them on-the-ﬂy, rendering current randomization
schemes ineffective. Finally, we perform an analysis of the most
important defense currently employed, namely constant blinding,
which shields all three-byte or larger immediate values in the
JIT buffer for hindering the construction of ROP gadgets.
Our analysis suggests that extending constant blinding to all
immediate values (i.e., shielding 1-byte and 2-byte constants)
dramatically decreases the JIT engine’s performance, introducing
up to 80% additional instructions.

I. INTRODUCTION

Web browsers are undoubtedly omnipresent. They are found
on PCs, smartphones, tablets, smart TVs, gaming consoles,
and elsewhere. Most Internet users probably use a browser

Permission to freely reproduce all or part of this paper for noncommercial
purposes is granted provided that copies bear this notice and the full citation
on the ﬁrst page. Reproduction for commercial purposes is strictly prohibited
without the prior written consent of the Internet Society, the ﬁrst-named author
(for reproduction of an entire paper only), and the author’s employer if the
paper was prepared within the scope of employment.
NDSS ’15, 8-11 February 2015, San Diego, CA, USA
Copyright 2015 Internet Society, ISBN 1-891562-38-X
http://dx.doi.org/10.14722/ndss.2015.23209

every day. Even users that prefer apps, instead of a general
purpose browser, unknowingly interact with browser compo-
nents frequently used by app developers [1]. Their popularity
is probably one of the reasons that they are such an attractive
target for attackers and security researchers alike [2]–[4].

A. Problem Statement

Attacks against browsers continue despite the fact

that
compromising binary software using buffer overﬂows and
control-hijacking attacks is much harder today. Modern op-
erating systems (OSs) include features like stack canaries [5],
non-executable pages [6], and address-space layout
ran-
domization (ASLR) [7], which severely hinder exploitation.
Even code-reuse techniques such as return-oriented program-
ming (ROP) [8] are not straightforward, since they require
information-leak bugs to reveal the randomized location of
code [9], [10] or legacy code and libraries that ASLR cannot
randomize.

Recent works on control-ﬂow integrity (CFI) [11], [12],
ﬁne-grained code randomization [13]–[15], and run-time be-
havioral monitoring [16], [17] promise to protect software
from ROP-like attacks, but unfortunately they have been
also shown to be vulnerable to niche attacks [9], [18], [19].
Other approaches that require application source code, such as
modular ﬁne-grained CFI [20] and G-Free [21], offer greater
guarantees again control-ﬂow hijacking attacks and ROP. So
far, there are no documented attacks against these defenses,
so, in principle, they could protect our precious browsers in
the future, even though one cannot make strong predictions.
Unfortunately, even defenses that may be effective for
conventional software are not always so for browsers. Modern
browsers dynamically generate code through just-in-time (JIT)
compilation to accelerate the execution of JavaScript (JS) code
at run time. Although defenses like the ones discussed above
can be efﬁcient in protecting existing code, code generation is
frequently not handled and it is outside their threat model.

Attacks exploiting the JIT engines of browsers are not new.
Figure 1 depicts the evolution of attacks and defenses against
them. Originally, code and data were not separated by the
code-generation engine, so both the generated native code
and the data it was operating on was placed on the same
executable memory pages. It was enough for the attacker to
place shellcode in a JavaScript array and then redirect the
program’s control-ﬂow to his shellcode in memory. Because

Apart

need

for

JavaScript program is compiled. The calling convention of
VirtualProtect in Windows is the following. The func-
tion takes 4 arguments using the %rcx, %rdx, %r8, and %r9
registers. Therefore, assuming we control the stack, we need
to introduce the gadgets shown in Listing 3. In Listing 3 we
include an additional gadget, which pops %rax. This gadget
is not needed for calling VirtualProtect but for breaking
a defense mechanism employed by Chakra as we will discuss
later.

from the

gadgets we

calling
VirtualProtect, we also need an additional gadget
for adjusting the stack. Usually, the vulnerability is related
to the heap, therefore we need to adjust the real stack to the
fake stack controlled by us, something that we commonly
call stack pivoting. We avoided discussing the stack-pivoting
gadget in Section IV, since in the case of Mozilla this gadget
can be constructed trivially. Constructing the stack-pivoting
in IE is usually based on exchanging a register the attacker
controls with %rsp, so that the stack pointer points to the
attacker’s fake stack. This exchange can be done using xchg,
which unfortunately is 2 bytes long, and with the additional
ret instruction becomes a 3-byte gadget. As we show later
in this section 3-byte gadgets cannot be constructed trivially
(see “Long gadgets” later in this section). For constructing
the stack-pivoting gadget we need an additional requirement:
having control over %al. The reason is discussed later in this
section.

encapsulated gadget.

Listing 2 shows a JavaScript program, which once executed,
generates the gadgets required to compromise Mozilla Firefox.
To do this, we ﬁrst declare seven variables (lines 1-3). Each
variable is carefully initialized to host a gadget. The initializa-
tion takes place inside a long loop to trigger the JIT engine.
In Figure 4 we show how we inﬂuence the JIT output by
assigning particular immediate values to JavaScript variables.
For example, assigning the value 12728721 to a variable will
introduce the following assembly code once compiled:

movl $0xc3c031 , 0 x6c8(%eax )

In hex this has the value of 0x06c8080c7c3c03100
which includes 0xc3c031, which is a gadget for zeroing
%eax:

xor %eax , %eax ;

r e t ;

In the same fashion we can construct all of the gadgets
contained in the ROP chain of Listing 1 and eventually call
mprotect for making the shellcode executable.
V. EXPLOITING INTERNET EXPLORER

1 pop %r8 ; r e t ;
2 pop %r9 ; r e t ;
3 pop %rcx ; r e t ;
4 pop %rdx ; r e t ;
5 pop %rax ; r e t ;

Listing 3. Required gadgets for calling VirtualProtect in Windows
(64-bit).

In this section we present how we exploit a vulnerable
Internet Explorer (IE) in Microsoft Windows (64-bit) without
using any of the available gadgets contained in the binary or
DLLs used by the browser.
A. Why Internet Explorer is different

Version 9 of IE has started employing a JavaScript JIT
engine called Chakra [34]. As IE is proprietary, little is known
about
its internals, and in particular how the JIT engine
works. There are several issues that make carrying out an
attack as the one presented in Section IV for IE signiﬁcantly
harder. First, lack of source code makes understanding how
the JIT engine is triggered, where the JIT buffer is located,
and other related detail important for exploiting the engine,
very difﬁcult. Second, Chakra employs a series of defenses
speciﬁcally introduced for preventing the generation of gadgets
in the JIT buffer. Third, we want to exploit the 64 bit version
of IE, which changes things in terms of calling conventions,
as fastcall is used, and the ﬁrst function arguments are passed
through registers and not through the stack. In the rest of the
section we describe how we overcome these difﬁculties.
B. Preparation

As before,

to exploit IE we must make the page that
holds the shellcode executable. This means that we need
to call VirtualProtect with the appropriate arguments,
and to accomplish this we must use the gadgets that will
be introduced in the JIT buffer, once a properly crafted

C. Exploit Design Considerations

Similarly to the approach we took in Section IV, we started
with a compute-heavy loop to trigger the JavaScript JIT
compiler and a series of variable initializations, to introduce
the desired gadgets in the JIT buffer once the loop is compiled.
However, IE is very different from Mozilla and such an
approach failed. IE’s JIT engine, Chakra, employs a number
of defenses which makes introducing gadgets in the JIT buffer
through immediate values in the JavaScript source impossible.
To make our attack work we had to reverse engineer Chakra’s
defenses. We will discuss some of these defenses here and
how we were able to circumvent them.

a) Constant Blinding: Any immediate value less than 2
bytes long is never emitted as is in the JIT buffer. Instead, it is
XORed with a random value and then XORed again when it is
actually used. For example, assume the following JavaScript
code:

var g a d g e t = 0 xc35841 ;

Once it is compiled, we would normally expect to see the
following code in the JIT buffer:

mov %rcx , 1000000 c35841h
mov qword ptr [ rax +48h ] , %rcx

This code essentially puts the (immediate) value 0xc35841
in %rcx, which we assume is the register that holds the value
of the JavaScript variable gadget. This reﬂects the example
we discussed in Figure 4, where an immediate value (in our

6

pop %r8
add byte [%rax ] , %a l

The important part is that Chakra has placed a conditional
jump which is followed if the overﬂow bit is set:

jo 000051 fd6c0037

Notice, that the addition following the pop instruction sets the
overﬂow bit and thus the ﬂow follows the conditional jump
which executes an access violation handler. To overcome this
we need to achieve two things:

• Make sure that the code between the partially emitted
gadget (the pop-part) does not alter the exploit’s logic
(i.e., does not modify any of the registers from Listing 3).
• Somehow unset the overﬂow bit before the conditional

jump.

In one special case, for constructing the stack-pivoting
gadget (which is a 3-byte gadget), it is sufﬁcient to control
%rax (speciﬁcally guarantee that its low part, %al, has a zero
value), and thus avoid raising the overﬂow ﬂag. This is why
we need to control %rax for exploiting IE, as we described
in the beginning of this section.

c) Code Diversiﬁcation: Chakra adds another diversiﬁ-
cation layer in the JIT buffer by emitting a random number of
nop instructions. These instructions perform no useful com-
putation, however they change the layout of the JIT buffer, and
therefore, all important gadgets have a different location every
time they are generated. This particular technique, inserting
random nop instructions, has been also used for diversifying
the Linux kernel layout [35]. Software diversiﬁcation [36] has
been a promising defense mechanism against exploitation, and
we have seen it applied with many different strategies [7], [13],
[14], as well as used for preventing the attacks we discuss in
this paper [24]. Unfortunately, recently we have seen at least
two sophisticated techniques [9], [10], that can bypass ﬁne-
grained randomization methods by exploiting information-leak
bugs. Our work here is about generating the gadgets in a
heavily defended environment, such as Chakra, and not on
techniques for discovering the process layout. Recall that with
the wide adoption of ASLR all exploits need at least one
information-leak bug for discovering the position of the needed
gadgets. The amount of information leakage depends of course
on the nature of the vulnerability.
D. Exploit Implementation
1 f u n c t i o n r8 ( addr ) {
2
3 }4
5 f u n c t i o n r9 ( addr ) {
6
7 }8
9 f u n c t i o n e m i t g a d g e t s ( ) {
10
11
12
13
14
15

r a x = 0 xc358 ;
r c x = 0 xc359 ;
rdx = 0 xc35a ;
r8 ( 0 ) ;
r9 ( 0 ) ;

return addr + 0 x5841 ;

for ( i = 0 ;

i < 0 xc35841 ;

return addr + 0 x5941 ;

i ++) {

}
return 0 ;

16
17
18 }
19
20 e m i t g a d g e t s ( ) ;

Listing 4. The JavaScript program which once compiled will produce the
needed gadgets in the JIT buffer of IE.

Now that we have presented the defenses employed by
Chakra, we will discuss how we introduce the needed gad-
gets in the JIT buffer for running the exploit. As already
mentioned we need to create four gadgets for loading %rcx,
%rdx, %r8, and %r9, with the correct values for calling
VirtualProtect (see Listing 3). Two of the four gadgets
(the ones for %rcx an %rdx) are only 2 bytes in length and
thus they can be created with the techniques we analyzed in
Section IV (see lines 12 and 13 in Listing 4). The challenging
part is to create the other two for loading %r8 and %r9, which
are longer than 2 bytes.

These gadgets are emitted in the JIT buffer using JavaScript
functions. Observe lines 1–7 in Listing 4. We implemented two
JavaScript functions, r8() and r9(), which simply return
a ﬁxed value added to their single argument input. These
functions, once compiled, produce the following code (for
example r9()):

000000 D71F8F0132

add %eax , 5941 h
jo
mov %rcx , 1000000000000 h
or %rax , %rcx
add %rsp , 30h
pop %rbx
pop %r s i
mov %rsp , %rbp
pop %rbp
r e t

Now, if execution starts from the address of the immediate
value (0x5941), a pop %r9 will be executed and control
ﬂow will eventually reach the ret instruction where the
(compiled) JavaScript function returns. The only problem is
the conditional jump for the overﬂow bit which will be set.
To overcome this we use an additional gadget which sets %rax
(line 11 in Listing 4). The complete JavaScript source for
introducing all needed gadgets in the JIT buffer is shown in
Listing 4 and the stack, along with the way the individual
gadgets are chained, is depicted in Figure 6.

VI. DISCOVERING THE GADGETS

In Sections IV and V we demonstrated how someone can
introduce ROP gadgets in the JIT buffer of Mozilla Firefox
and IE. However, for a successful attack, the adversary has
to locate the position of each gadget in order to form the
ROP chain, which will eventually compromise the vulnerable
program. In this section we investigate how this can be carried
out successfully. Notice, that we assume that a ﬁne-grained
randomization scheme has been enabled, like Librando [24]
or Chakra.
A. How Information Leaks Work

All randomization schemes have an Achilles’ heel: infor-
mation leaks. An attacker can read the contents of a part of

8

section in order to create a fully working exploit. The exploit
creates all needed ROP gadgets in the JIT buffer, it locates
them one by one using an information-leakage vulnerability,
it builds the ROP chain, which once executed it makes a page
hosting the shellcode executable, and, ﬁnally, compromises the
browser.
1 O = new O b j e c t ( ) ;
2 O.g1 = 0 xc358 ;
3 O.g2 = 0 xc359 ;
4 f u n c t i o n foo ( x ) { r e t u r n 0 x5841 ; }
5 O.func = foo ;

Listing 5. JavaScript code that generates a Object which memory layout is
described in Figure 7.

VII. DEFENSES

In this section we discuss defenses. We ﬁrst discuss existing
defenses and their applicability and later we propose new
countermeasures based on our experience from building the
attacks presented in this paper.

A. Existing Defenses

So far, there are two ways to defend against the attacks
we described: (i) preventing the construction of gadgets using
techniques such as constant blinding (see Section V), and (ii)
diversifying the JIT buffer so that the created gadgets cannot
be located. Both these strategies are used in IE’s JIT engine
(Chakra) and Librando [24]. We have serious concerns that
these strategies may not actually constrain sophisticated and
determined attackers.

As far as strategy (i) is concerned, we demonstrated its
weaknesses by realizing an actual attack on Chakra which
bypasses constant blinding by constructing gadgets in short
immediate values of 1 and 2 byte. One could argue that
by applying constant blinding in all immediate values, no
matter the size, could,
in theory, stop the attack. This is
correct, however, enforcing constant blinding in all immediate
values does not come for free. We perform our evaluation
using the SunSpider benchmarks suite. We log all the JIT
instructions that were actually executed in each test. We count
how many instructions involve an immediate value (of 1
or 2 bytes) and the respectively required CPU cycles. We
extract
this information from Intel’s manual, by matching
instructions and corresponding cycles. Essentially, there are
three families of instructions that may involve an immedi-
ate value, the distribution of which we depict in Figure 9.
Note that in all tests the instructions involving an immediate
value comprise a signiﬁcant percentage, ranging between 18–
52% of all executed instructions. Therefore applying constant
blinding to all immediate values is quite costly, introducing
an estimated overhead of 15% to 80%, as shown in Figure 8.
We assume that the JIT compiler emits (at least) two or six
more instructions for each instruction involving an immedi-
ate value, depending on whether the instruction has one or
two immediates. We match these additional instructions to
corresponding cycles and calculate the overhead as additional
cycles. Notice that this estimation is quite conservative, since

we do not account for additional code that will be executed for
preparing the blinding (i.e., calls to rand(), code analysis,
and so on).

Moreover, strategy (ii) is based on simply hiding the
gadgets. This strategy has been adopted by many proposals
for countering software exploitation. Unfortunately, all these
strategies can be defeated either through a memory disclosure
bug [29], or by forcing the vulnerable application to place
attacker data, that is the generated code by the JavaScript
JIT compiler in our case, in predictable locations. The latter
is comparable with heap spraying [30], where the attacker
allocates many copies of his data in an attempt to ensure that
one of the copies lands at a predictable memory address in
the vulnerable program’s heap. This might sound improbable
but recent work in this ﬁeld has shown that such memory
disclosure attacks are both powerful and realizable, and they
can bypass even highly dynamic randomization schemes [15].
In fact, in this paper we have demonstrated a similar technique
for leaking the location of the JIT buffer (see Section VI),
and discovering all constructed ROP gadgets, rendering all
randomization schemes ineffective.

One possible direction for mitigating ROP in general, and
is Control-Flow
thus the attacks presented in this paper,
Integrity (CFI). [37] This was initially a very promising
technique against code-reuse attacks, which quickly drove
to implementations [11], [12], [16], [17] that support legacy
code and impose negligible overhead. Unfortunately, there are
many concerns about the validity of these approaches [18],
[19],
therefore making the applicability
of CFI, especially the coarse-grained version, questionable.
Nevertheless, there are still efforts for applying ﬁne-grained
CFI in dynamic-code generation [20], which is essentially
very similar to JIT compilation, and possibly could be a
practical solution—as long as the overhead is reasonable—for
countering the attacks presented in this paper.

[31],

[32],

[38],

B. Proposed Defenses

Based on our experience while developing the attacks
presented here we propose two defense mechanisms. Both,
require code analysis. Realizing these techniques is beyond the
scope of this paper and we believe further research is needed
for implementing them. Both techniques introduce overhead
which may eventually nullify the gains from JIT compilation.
This is the reason why we believe that the attacks presented
in this paper cannot be easily addressed.

d) JIT Analysis: The most obvious defense mechanism
is to enhance the JIT compiler with the techniques proposed
by G-Free [21] for eliminating all gadgets. This has as a major
advantage that the produced code is safe and gadget-free,
however this does not come for free. The code has to be further
processed for eliminating the gadgets, and the produced native
code will experience overheads compared to the non gadget-
free code. Last but not least, it is unclear if it actually easy
to apply G-Free techniques in code that is generated partially
and on-the-ﬂy.

10

the vulnerable program in an unintended behavior [8], [25],
[26], [43], [44]. So far, the most practical defense mechanism
for defeating code-reuse attacks is ASLR [7], which simply
randomizes the process layout in the virtual space, so that
the attacker cannot locate the existing code. Researchers have
managed to bypass ASRL when the entropy is not enough or
using information leaks [45]–[48]. Following the practice of
ASLR, researchers developed more ﬁne-grained randomization
schemes [13], [14], but again they were defeated by sophisti-
cated exploitation techniques based on information leaks [9]
or on brute forcing crash-resistant processes [10].

It seems that the most promising direction for countering
code-reuse attacks is to eliminate the feasibility of code-reuse
itself. This can be done either by either re-writing the bi-
nary [11], [12] to respect its call-graph [37], either monitoring
at run-time [16], [17], or by re-compiling it for eliminating
all code-reuse paths (gadgets) [21]. Although attacks for such
systems have been demonstrated [18], [31], [32], we believe
that the bar for exploiting a binary has been signiﬁcantly raised
by the community and that attackers have to discover new
avenues for exploitation. One of this, is the one presented in
this paper: exploiting a program in an environment which is
gadget free.

In parallel with this work, Song et al [49] show that
JIT buffers can be exploited through code cache injection
techniques. This is possible if the JIT buffer is both writable
and executable or even temporarily writable at times. This
threat is more realistic if the generated code is multi-threaded,
because the switch between writable and executable leaves a
time window for exploitation. They propose a new dynamic
code generation architecture which utilizes a separate process
and shared memory to prevent such exploits.

IX. CONCLUSION

In this paper we introduced and demonstrated a method
to attack gadget-free binaries. We demonstrated our attack
on Mozilla Firefox and Microsoft Internet Explorer, two of
the most widely used applications. Our starting assumption
was that the binaries and shared libraries contain no gadgets
that can be exploited. Our attack manages to introduce useful
gadgets by utilizing the JIT engine present in both browsers,
but also present in other applications as well. Using the JIT
engine, we can create the required gadgets at run-time, inside
the JIT buffer.

Furthermore, we modiﬁed a technique based on already
published work [9] for discovering the gadgets at run-time by
leaking the address of the JIT buffer. Our attack is powerful in
the sense that it allows the execution of any shellcode, since it
can change the access permissions of the data page holding the
shellcode. Our techniques are able to exploit the JIT engine
of IE (Chakra), which incorporates a series of defense mecha-
nisms designed speciﬁcally to thwart such attacks. Finally, we
performed an extensive analysis and present details about the
undocumented defensive techniques of Chakra.

12

X. ACKNOWLEDGMENTS

We thank the anonymous reviewers for their valuable com-
ments. This work was supported in part by the FP7-PEOPLE-
2010-IOF project XHUNTER No. 273765 and by the US
Air Force through Contract AFRL-FA8650-10-C-7024. Any
opinions, ﬁndings, conclusions or recommendations expressed
herein are those of the authors, and do not necessarily reﬂect
those of the US Government, or the Air Force.

REFERENCES

[1] Google, “WebView,” Android Developers API Reference, https://

developer.android.com/reference/android/webkit/WebView.html.

[2] N. Joly, “Advanced exploitation of

Internet Explorer 10 / Win-
dows 8 overﬂow (Pwn2Own 2013),” VUPEN Vulnerability Research
Team (VRT) Blog, May 2013, http://www.vupen.com/blog/20130522.
Advanced Exploitation of IE10 Windows8 Pwn2Own 2013.php.

[3] A. Pelletier, “Advanced exploitation of Internet Explorer heap overﬂow
(Pwn2Own 2012 exploit),” VUPEN Vulnerability Research Team (VRT)
Blog,
July 2012, http://www.vupen.com/blog/20120710.Advanced
Exploitation of Internet Explorer HeapOv CVE-2012-1876.php.

[4] J. L. Obes and J. Schuh, “A tale of two pwnies,” The Chromium Blog,
May 2012, http://blog.chromium.org/2012/05/tale-of-two-pwnies-part-
1.html.

[5] C. Cowan, C. Pu, D. Maier, H. Hinton, J. Walpole, P. Bakke, S. Beattie,
A. Grier, P. Wagle, Q. Zhang et al., “Stackguard: Automatic adaptive
detection and prevention of buffer-overﬂow attacks,” in Proceedings of
the 7th USENIX Security Symposium, vol. 81, 1998, pp. 346–355.

[6] S. Andersen and V. Abella, “Changes to functionality in microsoft
windows xp service pack 2, part 3: Memory protection technologies,
Data Execution Prevention,” Microsoft TechNet Library, September
2004, http://technet.microsoft.com/en-us/library/bb457155.aspx.

[7] PaX Team, “Address Space Layout Randomization (ASLR),” 2003, http:

//pax.grsecurity.net/docs/aslr.txt.

[8] H. Shacham, “The geometry of innocent ﬂesh on the bone: Return-into-
libc without function calls (on the x86),” in Proceedings of the 14th
ACM conference on Computer and Communications security, October
2007, pp. 552–61.

[9] K. Z. Snow, L. Davi, A. Dmitrienko, C. Liebchen, F. Monrose, and A.-R.
Sadeghi, “Just-in-time code reuse: On the effectiveness of ﬁne-grained
address space layout randomization,” in Proceedings of the 34th IEEE
Symposium on Security and Privacy, May 2013.

[10] A. Bittau, A. Belay, A. Mashtizadeh, D. Mazieres, and D. Boneh,
the 35th IEEE Symposium on

“Hacking blind,” in Proceedings of
Security and Privacy, vol. 14, 2014.

[11] C. Zhang, T. Wei, Z. Chen, L. Duan, L. Szekeres, S. McCamant,
D. Song, and W. Zou, “Practical control ﬂow integrity and randomization
for binary executables,” in Proceedings of the 1013 Security and Privacy
Symposium, 2013, pp. 559–573.

[12] M. Zhang and R. Sekar, “Control ﬂow integrity for cots binaries,” in

22nd USENIX Security Symposium, 2013.

[13] V. Pappas, M. Polychronakis, and A. D. Keromytis, “Smashing the
gadgets: Hindering return-oriented programming using in-place code
randomization,” in Proceedings of the 2012 IEEE Symposium on Security
and Privacy, 2012, pp. 601–615.

[14] R. Wartell, V. Mohan, K. W. Hamlen, and Z. Lin, “Binary stirring:
Self-randomizing instruction addresses of legacy x86 binary code,” in
Proceedings of the 2012 ACM conference on Computer and communi-
cations security. ACM, 2012, pp. 157–168.

[15] A. K. Cristiano Giuffrida and A. S. Tanenbaum, “Enhanced operating
system security through efﬁcient and ﬁne-grained address space ran-
domization,” in Proceedings of the 21st USENIX Conference on Security
Symposium, 2012, pp. 40–55.

[16] V. Pappas, M. Polychronakis, and A. D. Keromytis, “Transparent ROP
exploit mitigation using indirect branch tracing,” in Proceedings of the
22nd USENIX Security Symposium, 2013, pp. 447–462.

[17] Y. Cheng, Z. Zhou, M. Yu, X. Ding, and R. H. Deng, “ROPecker:
A generic and practical approach for defending against ROP attacks,”
in Proceedings of the 2014 Network and Distributed System Security
(NDSS) Symposium, February 2014.

[18] E. G¨oktas¸, E. Athanasopoulos, H. Bos, and G. Portokalidis, “Out of
control: Overcoming control-ﬂow integrity,” in Proceedings of the 35th
IEEE Symposium on Security and Privacy, May 2014.

[19] E. G¨oktas¸, E. Athanasopoulos, M. Polychronakis, H. Bos, and G. Por-
tokalidis, “Size does matter: Why using gadget-chain length to prevent
code-reuse attacks is hard,” in 23rd USENIX Security Symposium, 2014.
[20] B. Niu and G. Tan, “Modular control-ﬂow integrity,” in Proceedings
[Online]. Available: http:

the 35th PLDI, 2014, pp. 577–587.

of
//doi.acm.org/10.1145/2594291.2594295

[21] K. Onarlioglu, L. Bilge, A. Lanzi, D. Balzarotti, and E. Kirda, “G-Free:
Defeating return-oriented programming through gadget-less binaries,”
in Proceedings of
the 26th Annual Computer Security Applications
Conference, 2010, pp. 49–58.

[22] D. Blazakis, “Interpreter exploitation,” in Proceedings of

the 4th
USENIX Conference on Offensive Technologies,
ser. WOOT’10.
Berkeley, CA, USA: USENIX Association, 2010, pp. 1–9. [Online].
Available: http://dl.acm.org/citation.cfm?id=1925004.1925011

[23] C. Rohlf and Y. Ivnitskiy, “Attacking clientside jit compilers,” Black Hat

USA, 2011.

[24] A. Homescu, S. Brunthaler, P. Larsen, and M. Franz, “Librando:
transparent code randomization for just-in-time compilers,” in ACM
Conference on Computer and Communications Security, A.-R. Sadeghi,
V. D. Gligor, and M. Yung, Eds. ACM, 2013, pp. 993–1004.

[25] S. Checkoway, L. Davi, A. Dmitrienko, A.-R. Sadeghi, H. Shacham,
and M. Winandy, “Return-oriented programming without returns,” in
Proceedings of the 17th ACM conference on Computer and Communi-
cations Security, October 2010, pp. 559–72.

[26] T. Bletsch, X. Jiang, V. W. Freeh, and Z. Liang, “Jump-oriented
programming: a new class of code-reuse attack,” in Proceedings of the
6th ASIACCS, March 2011, pp. 30–40.

[27] Microsoft, “The enhanced mitigation experience toolkit,” http://support.

microsoft.com/kb/2458544.

[28] A. Portnoy, “Bypassing all of

the things,” Exodus Intelligence,

https://www.exodusintel.com/ﬁles/Aaron Portnoy-Bypassing All Of
The Things.pdf.

[29] F. J. Serna, “CVE-2012-0769, the case of the perfect info leak,” http:

//zhodiac.hispahack.com/my-stuff/security/Flash ASLR bypass.pdf.

[30] DarkReading, “Heap spraying: Attackers’ latest weapon of choice,”
http://www.darkreading.com/security/vulnerabilities/showArticle.jhtml?
articleID=221901428, November 2009.

[31] Lucas Davi, Ahmad-Reza Sadeghi, Daniel Lehman, and Fabian Mon-
rose, “Stitching the gadgets: On the ineffectiveness of coarse-grained
control-ﬂow integrity protection,” in 23rd USENIX Security Symposium,
2014.

[32] Felix Schuster, Thomas Tendyck, Jannik Pewny, Andreas Maa, Martin
Steegmanns, Moritz Contag, and Thorsten Holz, “Evaluating the effec-
tiveness of current anti-rop defenses,” in Proceedings of the Internation
Conference on Research in Attacks, Intrusions, and Defenses (RAID),
2014.

[33] E. J. Schwartz, T. Avgerinos, and D. Brumley, “Q: Exploit hardening
made easy,” in Proceedings of the USENIX Security Symposium, 2011.
[34] Microsoft MSDN, “Advances in javascript performance in ie10 and
windows 8,” http://blogs.msdn.com/b/ie/archive/2012/06/13/advances-
in-javascript-performance-in-ie10-and-windows-8.aspx.

[35] V. P. Kemerlis, G. Portokalidis, and A. D. Keromytis, “kguard:
Lightweight kernel protection against
return-to-user attacks,” in
Proceedings of the 21st USENIX Conference on Security Symposium,
ser. Security’12. Berkeley, CA, USA: USENIX Association, 2012, pp.
39–39. [Online]. Available: http://dl.acm.org/citation.cfm?id=2362793.
2362832

[36] P. Larsen, A. Homescu, S. Brunthaler, and M. Franz, “Sok: Automated
software diversity,” in Proceedings of the 35th IEEE Symposium on
Security and Privacy, May 2014.

[37] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti, “Control-ﬂow
integrity,” in Proceedings of the 12th ACM conference on Computer
and Communications Security, 2005, pp. 340–353.

[38] Nicholas Carlini and David Wagner, “Rop is still dangerous: Breaking

modern defenses,” in 23rd USENIX Security Symposium, 2014.

[39] A. One, “Smashing the stack for fun and proﬁt,” Phrack magazine,

vol. 7, no. 49, p. 365, 1996.

[40] M. Frantzen and M. Shuey, “StackGhost: Hardware facilitated stack
protection,” in Proceedings of the 10th USENIX Security Symposium,
August 2001, pp. 55–66.

[41] P. Akritidis, C. Cadar, C. Raiciu, M. Costa, and M. Castro, “Preventing
memory error exploits with wit,” in IEEE Symposium on Security and
Privacy, 2008, pp. 263–277.

[42] A. Slowinska, T. Stancescu, and H. Bos, “Body armor for binaries:
preventing buffer overﬂows without recompilation,” in Proceedings of
USENIX Annual Technical Conference, Boston, MA, June 2012.

[43] M. Tran, M. Etheridge, T. Bletsch, X. Jiang, V. Freeh, and P. Ning, “On
the expressiveness of return-into-libc attacks,” in Proceedings of the 14th
international conference on Recent Advances in Intrusion Detection,
2011, pp. 121–141.

[44] E. Buchanan, R. Roemer, H. Shacham, and S. Savage, “When good in-
structions go bad: Generalizing return-oriented programming to RISC,”
in Proceedings of CCS 2008, P. Syverson and S. Jha, Eds. ACM Press,
Oct. 2008, pp. 27–38.

[45] H. Shacham, M. Page, B. Pfaff, E.-J. Goh, N. Modadugu, and D. Boneh,
“On the effectiveness of address-space randomization,” in Proceedings
of the 11th ACM conference on Computer and Communications Security,
2004, pp. 298–307.

[46] R. Strackx, Y. Younan, P. Philippaerts, F. Piessens, S. Lachmund, and
T. Walter, “Breaking the memory secrecy assumption,” in Proceedings
of the Second European Workshop on System Security, ser. EUROSEC
’09. New York, NY, USA: ACM, 2009, pp. 1–8. [Online]. Available:
http://dx.doi.org/10.1145/1519144.1519145

[47] R. Hund, C. Willems, and T. Holz, “Practical timing side channel attacks
against kernel space aslr,” in Security and Privacy (SP), 2013 IEEE
Symposium on.

IEEE, 2013, pp. 191–205.

[48] G. F. Roglia, L. Martignoni, R. Paleari, and D. Bruschi, “Surgically
returning to randomized lib (c),” in Computer Security Applications
Conference, 2009. ACSAC’09. Annual.

IEEE, 2009, pp. 60–69.

[49] C. Song, C. Zhang, T. Wang, W. Lee, and D. Melski, “Exploiting
and protecting dynamic code generation,” in Proceedings of the 2015
Network and Distributed System Security (NDSS) Symposium, February
2015.

13

