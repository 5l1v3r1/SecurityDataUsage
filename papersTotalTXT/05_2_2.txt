StackArmor: Comprehensive Protection from Stack-based

Memory Error Vulnerabilities for Binaries

Xi Chen∗ Asia Slowinska† Dennis Andriesse† Herbert Bos§ Cristiano Giuffrida§

Department of Computer Science

∗x.chen@vu.nl, †{asia,da.andriesse}@few.vu.nl, §{herbertb,giuffrida}@cs.vu.nl

VU University Amsterdam, The Netherlands

Abstract—StackArmor is a comprehensive protection tech-
nique for stack-based memory error vulnerabilities in binaries. It
relies on binary analysis and rewriting strategies to drastically re-
duce the uniquely high spatial and temporal memory predictabil-
ity of traditional call stack organizations. Unlike prior solutions,
StackArmor can protect against arbitrary stack-based attacks,
requires no access to the source code, and offers a policy-driven
protection strategy that allows end users to tune the security-
performance tradeoff according to their needs. We present an
implementation of StackArmor for x86 64 Linux and provide a
detailed experimental analysis of our prototype on popular server
programs and standard benchmarks (SPEC CPU2006). Our
results demonstrate that StackArmor offers better security than
prior binary- and source-level approaches, at the cost of only mod-
est performance and memory overhead even with full protection.

I.

INTRODUCTION

While common defenses like W⊕X, canaries, and traditional
ASLR prevent na¨ıve return address overﬂows and code injection
attacks, they have done little to eliminate stack-based attacks
altogether. Mainly, the complexity of the attacks has increased
as attackers resort to advanced techniques like Return-Oriented
Programming (ROP) [69]. Likewise, they exploit the stack’s
predictable layout to disclose useful information, stored in
current, previous, or reused stack frames [24]. We conclude that,
despite all efforts, the stack remains a hugely attractive target
for attackers, mainly because it is an exploit-friendly contiguous
mapping with spatial and temporal allocation locality that is
entirely predictable—obviating even the need for “feng shui”
strategies on the heap [74].

In this paper, we address the problem at

its root by
completely abandoning the idea of a linearly growing stack.
We statically rewrite binaries to isolate and fully randomize
the locations of stack frames and individual stack buffers,
countering both spatial attacks like overﬂows and temporal
attacks like stack-based use-after-frees.

While ours is an extreme solution that provides more
comprehensive protection than prior solutions, we are not the
ﬁrst to argue for better stack defenses. Existing approaches
include compiler extensions [10], [11], shadow stacks [18],
[26], [28], [44], [62], [65], [70], [80], Control-Flow Integrity

Permission to freely reproduce all or part of this paper for noncommercial
purposes is granted provided that copies bear this notice and the full citation
on the ﬁrst page. Reproduction for commercial purposes is strictly prohibited
without the prior written consent of the Internet Society, the ﬁrst-named author
(for reproduction of an entire paper only), and the author’s employer if the
paper was prepared within the scope of employment.
NDSS ’15, 8-11 February 2015, San Diego, CA, USA
Copyright 2015 Internet Society, ISBN 1-891562-38-X
http://dx.doi.org/10.14722/ndss.2015.23248

(CFI) [8], [34], [82], and binary rewriting to add buffer
protection [72], but they either rely on source code and leave
binaries at the mercy of attackers, or offer only very limited
protection. Speciﬁcally, there is currently no stack protection
technique for binaries that mitigates all of the following attack
vectors: (i) buffer overwrites and overreads within a stack frame,
(ii) buffer overwrites and overreads across stack frames, (iii)
stack-based use-after-frees, (iv) uninitialized reads (in reused
stack frames). As a result, stack attacks are still rampant.
Attackers use them both to divert the control ﬂow (and, e.g.,
start off a ROP chain) and for memory disclosures [24].

Information leakage and buffer overﬂow attacks, in particu-
lar, are greatly helped by the predictability of the stack layout.
Although the start is typically randomized, the stack itself
grows in an entirely predictable fashion, making the disclosure
of canaries, return addresses, or data pointers of previous stack
frames as simple as leaking uninitialized data or exploiting
buffer overreads. The same applies to exploits modifying data
in another stack frame. For example, randomization between
stack frames would have stopped recent high-proﬁle attacks on
Asterisk [38], Xen [39], Kerberos [36], and MS Ofﬁce [37].

Our focus on binaries is neither academic nor fundamental,
but important in practice: the adoption of advanced security
measures in popular compilers is slow. Compiler maintainers
are conservative and wont to reject options that incur signiﬁcant
overhead. The -fstack-protector-strong option in gcc is
a case in point: it had to be tailored to a very narrow threat
model for performance reasons. As most vendors simply use
common compilers like gcc, any measure not added to it for
performance reasons will not make it into their products. Unless
they apply the defenses at the binary level, users cannot decide
for themselves to sacriﬁce some performance for better security.
Contributions We introduce StackArmor, a novel stack
protection technique that shields binaries from all of the above
attacks. To provide comprehensive protection, StackArmor relies
on static analysis enabled by state-of-the-art binary analysis
tools—which provide the necessary program abstractions, such
as functions and their control-ﬂow graphs. Our static analysis
is also supported by information on the location and size of
stack objects, for example provided by debug symbols (similar
to prior binary-level protection techniques [44]) or dynamic
reverse engineering techniques [53], [71]. StackArmor can also
operate in complete absence of these, by gracefully reducing
its (intra-frame) protection guarantees. Using binary rewriting
to instrument call and return instructions, StackArmor provides
tailored protection based on application-speciﬁc performance
and security requirements. In full protection mode, StackArmor
relies on a combination of randomization, isolation, and secure

Fig. 3. A sample SP-unsafe function that violates all the three SP-safety rules
imposed by the BR analyzer.

variables, by conﬁrming that their pointers are never stored
or passed to callees, and (3) detects alloca invocations (and
possibly other unsafe idioms). The example function in Figure 3
violates all the three SP-safety rules and is classiﬁed as SP-
unsafe1. To read args[i], the function accesses the stack
through %rbp and %rax—violating (1). The second rule is
violated when the function computes the address of ret and
stores the resulting %rbp-derived pointer to %rsi. Finally,
the invocation of alloca causes a manipulation of the %rsp
register, which violates (3).

While seemingly very conservative, our analysis closely
matches the behavior of modern compilers, which typically
generate very simple (and efﬁcient) stack-accessing instructions
for functions that maintain no pointers into the stack. As shown
in Section V-C, on average, our analysis classiﬁed 80% of
functions across all the SPEC CPU2006 benchmarks as SP-
safe (geometric mean).

B. Deﬁnite Assignment Analyzer

To determine the functions (and objects) that require protec-
tion from uninitialized reads, the DA analyzer relies on static
analysis to conservatively identify all the DA-unsafe objects,
i.e., stack objects that cannot be proven as initialized before
they are ﬁrst read. Our strategy is inspired by similar source-
level analyses employed in safe languages to implement zero
initialization semantics [46]. An important challenge when oper-
ating at the binary level is that object boundaries are no longer
exposed in the code in any obvious way. Another challenge
is that aliasing problems may generally prevent the analyzer
from unambiguously mapping all the accesses to stack objects.
To address these challenges, the DA analyzer relies on
two key observations. First, the functions that require ad-
hoc uninitialized read protection are only those that have
been marked as SP-safe—since the others are protected using
randomization and isolation. All the SP-safe functions, in turn,
have no buffers, pointers into the stack, or stack-accessing
instructions that our simple data-ﬂow analysis cannot map
into a constant stack frame offset. As a consequence, these
variables are not initialized in other functions, which drastically
simpliﬁes our deﬁnite assignment analysis, essentially reducing
it to a basic intra-procedural data-ﬂow analysis [43]. Second,
once constant stack frame offsets are available for each load

1All the assembly snippets presented in the paper have been generated with

clang 3.3.

Fig. 4. A sample DA-unsafe function—on the CFG path marked with solid
arrows, the analyzer cannot prove that 12(%rsp) (containing the arg variable)
is initialized.

and store stack-accessing instruction, our analysis can simply
operate at the byte rather than at the object level.

To determine functions and stack variables that require
protection (and thus zero initialization),
the DA analyzer
proceeds as follows. For every function, it traverses its CFG
in depth-ﬁrst fashion and maintains a per-path tag map to
keep track of the bytes in the stack frame that have been
read or written to in the current path. For every path, a ﬁrst
write-before-read event causes the DA analyzer to mark the
target bytes as path-safe and a ﬁrst read-before-write event
causes the DA analyzer to mark the target bytes as path-unsafe.
If the traversal reaches an unresolved control transfer or a
function call, it marks all the bytes that are not marked at
all yet as path-unsafe. At the end, all the bytes in the stack
frame (and the function itself) that have been marked as path-
unsafe at least once are marked as DA-unsafe, thus requiring
uninitialized read protection. The example function in Figure 4
is DA-unsafe, since the analyzer cannot prove that on each
CFG path, the stack location 12(%rsp) (containing the arg
variable) is written before it is read.

C. Buffer Reference Analyzer

For each function, the BR analyzer determines which stack
buffers can be safely isolated in separate frames, i.e., while
making sure that all references to these buffers are detected and
relocated as well. The isolation serves as a protection against
intra-frame spatial memory corruption attacks.

To this end, the BR analyzer performs an intra-procedural
static analysis to unambiguously map all the instructions taking
stack addresses. StackArmor can safely isolate a buffer only
if it proves that none of its references are ever used to access
other memory regions. Even though the BR analyzer relies
on the available information on the location and size of all
the stack objects (as provided by debug symbols or dynamic
reverse engineering techniques [53], [71]), the mapping poses
signiﬁcant challenges. First, the stack (or frame) pointer is
subject to aliasing. Another difﬁculty is that unlike source-level

4

              function test_sp:                 pushq   %rbp          movq    %rsp, %rbp        subq    $32, %rsp        movl    %edi, -4(%rbp)        movq    %rsi, -16(%rbp)        movl    $67305985, -24(%rbp)        movslq  -4(%rbp), %rax        movsbl  -24(%rbp,%rax), %edi         movq    -16(%rbp), %rax        addq    $15, %rax        andq    $-16, %rax        leaq    -20(%rbp) %rsi                   movq    %rsp, %rdx        subq    %rax, %rdx        movq    %rdx, %rsp                        callq   helper_sp        movl    -20(%rbp), %eax        movq    %rbp, %rsp        popq    %rbp        retextern	void	helper_sp(int,	int	*,	void	*);int	test_sp(int	i,	unsigned	long	size){				int	ret;				char	args[]	=	{1,	2,	3,	4};				helpersp(								args[i],									&ret,									alloca(size));				return	ret;}      function testda:               .LBB1_0:         subq    $24, %rsp        movq    %rdi, 16(%rsp)        cmpq    $11, %rdi        jb      .LBB12       .LBB1_1          movl    $10 12(%rsp)        jmp     .LBB14       .LBB1_2:        cmpq    $2, 16(%rsp)        jb      .LBB14       .LBB1_3        movl    $1 12(%rsp)      .LBB1_4:        movl    12(%rsp), %edi             callq   helper_da        addq    $24, %rsp        retextern void helper_da(int);int test_da(unsigned long size){    int arg;    if (size > 10)        arg = 10;    else if (size > 1)        arg = 1;         helper_da(arg)}Control-ﬂow graph and the DA analyzer's results:0123412(%rsp) 16(%rsp) safesafesafesafesafeunsafeDA result:unsafesafesafenecessary to correctly copy caller-speciﬁed arguments—whose
number may change across call sites, due to variadic calls—into
the armored stack frame, it may also complicate stack manage-
ment when caller and callee cannot be statically paired with one
another. Indirect calls, for example, need to be conservatively
instrumented since their target may be SP-unsafe—albeit not
statically known. An instrumented indirect call with a SP-
safe callee, however, would cause execution to return from a
call site with the %rsp still pointing into the armored stack
frame. To address this problem, the rewriter instruments all the
instructions following a call site which contains indirect calls,
library calls, and other special idioms—e.g., setjmp—to restore
the original stack and allow the caller to resume execution
consistently. Our setjmp instrumentation also checks if control
returned from a longjmp invocation and garbage collects all
the deeper (and thus no longer needed) physical stack frames in
that case. The complementary situation—an uninstrumented call
site with an instrumented SP-unsafe callee—is also possible,
for example when dealing with uninstrumented libraries calling
program-speciﬁed callbacks. To detect (and simply ignore) this
situation, the return site instrumentation checks if the current
%rsp is lower than the new %rsp in the most recent saved
context. Our instrumentation strategy can efﬁciently handle
all the caller-callee combinations—i.e., instrumented caller
and callee, uninstrumented caller and callee, instrumented
caller and uninstrumented callee, and uninstrumented caller
and instrumented callee—in a conservative way, allowing
unrestricted use of shared libraries and arbitrary optimizations
driven by our static analyzers.

To protect against intra-frame spatial attacks, in turn, the
rewriter instruments all the SP-unsafe functions with buffers
reported by the BR analyzer. In particular, it ﬁrst instruments
the entry site (i.e., after the function prologue) to relocate each
buffer reported in a new stack frame provided by the allocator.
Second, it remaps all the stack-referencing instructions reported
by the BR analyzer to reference the corresponding buffers in
their own independent frames. Such frames are later garbage
collected when the main armored frame is deallocated.

To protect the remaining SP-safe functions against uninitial-
ized reads, ﬁnally, the rewriter instruments the necessary entry
sites to zero-initialize all the stack regions reported by the DA
analyzer. To implement efﬁcient zero initialization semantics,
the rewriter also coalesces multiple bzero writes into the same
memory word (8 bytes).

IV.

IMPLEMENTATION

We implemented StackArmor to instrument 64-bit ELF
binaries for the Linux x86 64 platform, but our prototype
is easily portable to other UNIX systems. As StackArmor is
built on top of PEBIL [52], it performs static instrumentation,
i.e., it inserts additional code and data into an executable, and
generates a new armored binary with permanent modiﬁcations.
We ﬁrst discuss the requirements for the disassembly process
imposed by StackArmor and then we present some details
of the instrumentation. We conclude with limitations of the
current implementation.

A. Binary Disassembly and Analysis

StackArmor’s static analyses require information about
instructions, basic blocks, CFGs, and functions present in a

binary. While we do not claim any contributions in the area
of binary disassembly and we use existing tools, we show that
StackArmor relies only on the correctness of disassembly and
not its completeness. It is designed to cope with incomplete
information—it gracefully reduces security guarantees without
breaking the binary. Finally, we discuss what other assumptions
StackArmor makes.

Incomplete disassembly. In principle, it is not feasible to
fully disassemble arbitrary stripped x86 binaries statically [73],
[78]. Due to indirect control ﬂows and interleaving code
and data, disassembly can be imprecise, so we get possibly
incomplete information on instructions, basic blocks, CFGs,
and functions. At the same time, binary disassembly is subject
to active research [12], [13], [83] and our experience with
standard tools that support both symbol and non-symbol based
CFG reconstruction (Dyninst [16]) shows that lack of symbols
is hardly a concern in practice if 100% accuracy is not strictly
required (on SPEC benchmarks we missed only 1/12357
functions and 7/325173 basic blocks and edges due to lack of
debug information).

Unresolved jumps: The ﬁrst consequence of incomplete
disassembly are unresolved jmp instructions, i.e., indirect jumps
whose targets remain unknown. All the static analyses behave
in a conservative way: the SP analyzer classiﬁes a function
with an unresolved jump as SP-unsafe, so the DA analyzer
does not even consider it and the BR analyzer labels all its
buffers as unknown. The rewriter, in turn, sets up a new and
isolated stack frame for this function. If the rewriter misses and
does not instrument a return instruction, StackArmor handles
this case with no trouble, as we discussed in Section III-E.

Unresolved calls: StackArmor also needs to deal with
unresolved indirect call instructions. Similarly to unresolved
jumps, the three static analyses report conservative results. An
unresolved call does not, however, inﬂuence the instrumenta-
tion of the caller function.

Missing functions: Since StackArmor is not aware of
functions missed due to incomplete disassembly, it simply does
not analyze or instrument them. As discussed in Section III-E,
the binary rewriter ascertains that the binary works well even
if an instrumented function calls an uninstrumented one, and
the other way round.

Summarizing, in the presence of incomplete disassembly,
StackArmor always errs on the safe side. If necessary, it just
excludes a function from analysis and protection, so it executes
as in the vanilla version of the binary.

Stack pointers and function prologue. The three StackAr-
mor’s static analyses (Sections III-A-III-C) consider ex-
plicit stack references, i.e., instruction operands of the form
rsp+offset or rbp-offset. While this deﬁnition of an
explicit stack reference assumes the special role of the rsp and
rbp registers, StackArmor’s actual implementation does not
rely on rbp containing the base pointer. If, due to optimizations,
rbp does not point to the beginning of the frame, nothing bad
happens—the analyses are limited to the references derived
from the rsp register. To detect and examine function prologues,
StackArmor follows the ABI for x86 64/Linux [55]. Observe
that rsp, however, is a sacred register, whose value is required
by the important push, pop, call, and ret instructions. Thus,
in practice, there is no reason why a program would ever use

7

rsp for anything else than the current stack position and we
can therefore safely rely on its usage.

Function arguments. As we said in Section III-E, before
a call instruction, the binary rewriter copies over all the
call arguments already pushed into the stack. It examines the
basic block containing the call instruction and checks how
many bytes to transfer. Our argument-copying strategy poses
very little restriction on the calling convention: (a) stack-based
argument passing is done in a single basic block, (b) arguments
are callee-owned. Even though it is possible to extend our
prototype to an even more general solution as proposed in [12],
[13], we are not aware of any calling convention violating (a)-
(b)2. Our implementation was correct in all the server programs
and standard benchmarks we tested.

B. Instrumentation

Our binary rewriter is implemented on top of PEBIL [52],
an efﬁcient binary instrumentation tool for Linux. PEBIL can
place hooks in arbitrary binary points to call a predetermined
handler enclosed in a shared library, with the instrumenta-
tion automatically saving and restoring registers to create a
consistent execution context.

For our purposes, we extended the original PEBIL tool in
three ways. First, we allowed only registers effectively used in
StackArmor’s handler—which does not rely on external library
calls on the instrumentation path—to be saved and restored at
each invocation to minimize context switching costs at function
entry/exit time. Second, we implemented support for handlers
enclosed in a static library—injected by our rewriter into the
binary—eliminating the costs associated with indirect PLT calls
on the instrumentation path. This change enabled StackArmor’s
stack frame allocator to be entirely implemented and compiled
into a static library with efﬁcient position-dependent code.
Finally, we allowed PEBIL to access Thread-Local Storage
(TLS), where our instrumentation stores references to per-thread
metadata and stack frames managed by our allocator. Our
current implementation completely allocates/deallocates per-
thread data structures at thread creation/destruction time by
default, but adopting more efﬁcient pooling strategies—not
necessary for our test programs—is straightforward.

One limitation of PEBIL is that it relies on debug symbols
to generate a list of functions present in a binary and their CFGs.
This is, however, not a limitation of StackArmor, but of the
tool we used for familiarity. As we discussed in Section IV-A,
StackArmor is designed to handle incomplete disassembly while
gracefully reducing its security guarantees, without breaking
the binary. At the same time, recent research shows how to
disassemble stripped binaries [13], [83], as well as locate
functions and resolve (at least some) indirect control ﬂows
with the aim of generating CFGs [12]. Thus, StackArmor’s
prototype could be ported to other binary rewriting frameworks,
such as Dyninst [16], which can operate even in the absence
of relocation and debug symbol information.

2The tail call optimization violates (b) but even that does not require copying
back callee-owned arguments given that the callee returns directly to the caller
of the caller.

C. Limitations
The main

the

current

of

limitation

StackArmor
implementation—inherited from PEBIL—is the inability to
support C++-style exceptions. This limitation—addressable
with additional effort—did not prevent our prototype from
running all the popular server applications and benchmarks
considered in our evaluation.

V. EVALUATION

We evaluated StackArmor on a workstation equipped with
an Intel i7-4770K CPU clocked at 3.90 GHz, a 256 KB per-core
cache, an 8 MB shared cache, and 8 GB of DDR3-1600 RAM.
We ran all our tests on an Ubuntu 12.10 installation running
Linux kernel 3.12 (x86 64).

For our evaluation, we selected lighttpd (v1.4.28)—a
popular web server—vsftpd (v1.1.0)—a popular FTP server—
the OpenSSH Daemon (v3.5)—a popular SSH server—and
exim (v4.69)—a popular email server. To benchmark lighttpd,
we relied on the Apache benchmark [1] conﬁgured to is-
sue 25,000 requests with 10 concurrent connections and 10
request/connection. To benchmark vsftpd, we relied on the
pyftpbench benchmark [3] conﬁgured to open 100 connections
and request 100 1 KB-sized ﬁles per connection. To benchmark
OpenSSH and exim, ﬁnally, we relied on the OpenSSH
test suite and a homegrown script repeatedly launching the
sendemail program [4], respectively. To stress our StackArmor
prototype in memory-intensive scenarios and better investigate
the performance-security tradeoffs, we also considered all the
C programs in the SPEC CPU2006 benchmarks. To guide our
BR analyzer, ﬁnally, we generated the necessary information
on the location and size of stack objects from debug symbols.
This allowed our BR analyzer to identify (and isolate) 90.7%
of the buffers on average across all our programs. We ran all
our experiments 11 times—while checking that the CPUs were
fully loaded throughout our tests—and reported the median.
Our evaluation answers 4 key questions: (i) Security: Is
StackArmor effective in protecting against both spatial and tem-
poral stack-based attacks? (ii) Performance: Does StackArmor
yield acceptable run-time overhead across all the conﬁgurations
supported? (iii) Memory usage: How much memory does
StackArmor require? Multithreading support: Does StackArmor
perform and scale well in multithreaded programs?

A. Security Against Spatial Attacks

To evaluate the security guarantees offered by StackArmor
against spatial attacks, we measured the attack surface
reduction induced by our protection techniques. Our deﬁnition
of attack surface quantiﬁes both the number of vulnerable
targets (i.e., stack-allocated objects) and the number of
offenders (e.g., stack-allocated buffers) in intra-frame and
inter-frame attack scenarios.

Intra-frame attack surface reduction. The intra-frame
attack surface Sintra(f ) of a given function f quantiﬁes the
extent to which the Nf objects—noncontrol and control data
including the return address—allocated in f’s stack frame are
exposed to buffer overﬂow/underﬂow attacks using any of
the Bf stack-allocated buffers in the same frame during the
execution. More formally:

8

TABLE I.

MEAN ATTACK SURFACE REDUCTION FOR ALL THE

FUNCTIONS WITH STACK-ALLOCATED BUFFERS.

Intra-frame

Inter-frame

Shadowing
(Source)
100.0%
96.1%
93.2%
100.0%
91.5%

StackArmor

100.0%
96.8%
94.4%
100.0%
95.95%

Shadowing
(Source)
99.0%
97.2%
94.0%
99.6%
94.6%

StackArmor

99.9%
99.9%
99.9%
99.9%
99.9%

lighttpd
exim
OpenSSH
vsftpd
SPECgm

Bf(cid:88)

Nf(cid:88)

i=1

j=1

Sintra(f ) =

canAttack(i, j) ? 1 : 0

When our BR analysis achieves full coverage, StackArmor’s
protection strategy reduces the original
intra-frame attack
surface Bf · Nf (induced by a traditional stack organization) to
0 (no buffer can predictably attack other intra-frame objects).
In general, however, the intra-frame attack surface reduction
is subject to the precision of our BR analysis. Table I shows
the mean intra-frame attack surface reduction across all the
functions with stack-allocated buffers, also comparing against
traditional shadow stack techniques in the ideal case—source-
level, with all the buffers remapped.

As shown in the table, StackArmor yields a high attack
surface reduction across all our test programs—94.4% worst-
case reduction for OpenSSH—even successfully isolating all the
stack-allocated buffers for lighttpd and vsftpd. Encouragingly,
the reduction is comparable and even higher than traditional
shadow stack techniques, which typically rely on source code
to implement a precise BR analysis strategy but also fail to
prevent individual per-frame buffers from attacking one another.
Inter-frame attack surface reduction. To provide a prac-
tical deﬁnition of inter-frame attack surface, we consider the
extent to which an attacker can overﬂow into the stack frame of
all the possible callers of every given function f—an attacker
could potentially overﬂow into any active stack frame, but the
spatial predictability guarantees are progressively reduced as
we move higher in the call stack and consider all the possible
caller-callee combinations. A hypothetical attacker that reliably
predicts the caller g of the currently executing function f can
potentially rely on all the buffers in f to overﬂow into any of
the objects in the stack frame of g—an attack model completely
defeated by StackArmor’s protection strategy. In a more generic
attack model, in turn, the inter-frame attack surface Sinter(f )
of a given function f is subject to the probability pk of the
stack frame of the caller k—i.e., a function in the set of the
Cf callers of f—being active on the call stack before that of
f. More formally:

(cid:20)

Cf(cid:88)

i=k

Sinter(f ) =

Bf(cid:88)

Nk(cid:88)

i=1

j=1

pk ·

(cid:21)

canAttack(i, j) ? 1 : 0

for a traditional stack organization and pk = 1/Rmax for
StackArmor, with the swap size Rmax set to 1, 024 in our
experiments. To accurately identify the set of Cf callers for
every given f, we performed static callgraph analysis of
our test programs using the LLVM compiler framework [50].
Our implementation relies on data structure analysis [51], an
efﬁcient context-sensitive and ﬁeld-sensitive points-to analysis
to conservatively analyze function pointers used in indirect calls.
Table I reports our ﬁndings, comparing the mean inter-frame
attack surface reduction across all the functions with stack-
allocated buffers induced by StackArmor against the reduction
induced by traditional (source-level) shadow stack techniques.
As the table shows, StackArmor yields a very high inter-
frame attack surface reduction across all our test programs—
99.9% in all the cases—and consistently higher than traditional
source-level shadow stack techniques. The higher reduction re-
ported compared to our intra-frame analysis highlights the effec-
tiveness of StackArmor in greatly increasing the randomization
entropy in probabilistic attack models. Even when compared
to prior source-level stack randomization strategies [18], [47]
that introduce random gaps between objects, StackArmor yields
much stronger randomization guarantees, given that logically
contiguous objects (and frames) are guaranteed to be physically
nonadjacent in memory by construction.

B. Security Against Temporal Attacks

To evaluate the security guarantees offered by StackArmor
against temporal attacks, we analyzed the unpredictability of
stack frame reuse. To this end, we measured the effectiveness
of StackArmor in generating a seemingly random sequence
of physical stack frame addresses at runtime. For each of the
benchmarked programs, we evaluated the randomness of such
sequence observed under four conﬁgurations: (1) Baseline, (2)
StackArmor with Rmax = 0, (3) ASLR, and (4) StackArmor with
Rmax = FSL = 1, 024. Our ASLR implementation dynamically
generates random inter-frame gaps g ∈ [0; 40 KB] using
the rdrand instruction. This strategy already yields higher
entropy than modern ASLR techniques [18], [33], which allow
deterministic [18] or periodic [33] stack frame reuse in loops,
or use statically generated random inter-frame gaps [33].

To measure randomness of a sequence of stack frames,
we conducted a nonparametric hypothesis test for random-
ness (Bartels’ rank test [14]), where we assumed as a null
hypothesis that
the sequence is generated randomly. For
the ﬁrst two conﬁgurations, p-values are consistently lower
than 1.9e − 7, while always lower than 9.3e − 3 for ASLR.
Summarizing, in the ﬁrst three conﬁgurations, we can reject
the null hypothesis at the signiﬁcance level α = 0.01, which
conﬁrms highly predictable stack frame reuse. In contrast,
StackArmor’s default conﬁguration (Rmax = FSL) reported
high p-values ∈ [0.37; 0.90], meaning that we cannot reject the
null hypothesis. This result conﬁrms the randomness of the
sequence generated by StackArmor, yielding truly unpredictable
stack frame reuse and strong protection against temporal attacks.

C. Performance

To concretely compute Sinter(f ) and its reduction induced
by StackArmor for our test programs, we assume pk to be
a uniform distribution (for simplicity), that is, pk = 1/Cf

StackArmor’s protection strategy introduces run-time per-
formance overhead due to the costs associated with random
stack frame allocation—for the logical stack frames and

9

Functions (#)

SP-unsafe
(Source)

SP-unsafe

(StackArmor)

DA-unsafe

397
18
846
1
73
335
118
41
27
101
5
57
54

409
22
972
4
77
337
121
42
31
105
8
59
66

1,227
48
3,499
17
91
1,351
324
73
56
391
14
218
172

Total

1,885
112
5,630
33
244
2,690
548
153
127
599
29
380
332

SP-unsafe
(Source)
0.21x
0.16x
0.15x
0.03x
0.30x
0.12x
0.22x
0.27x
0.21x
0.17x
0.17x
0.15x
0.16x

perlbench
bzip2
gcc
mcf
milc
gobmk
hmmer
sjeng
libquantum
h264ref
lbm
sphinx3
SPECgm

Functions (Ratio)

SP-unsafe

(StackArmor)

0.22x
0.20x
0.17x
0.12x
0.32x
0.13x
0.22x
0.27x
0.24x
0.18x
0.28x
0.16x
0.20x

0.65x
0.42x
0.62x
0.52x
0.37x
0.50x
0.59x
0.48x
0.44x
0.65x
0.48x
0.57x
0.52x

394
4
48
80
9
5
1
2
1
4
30
4
9

TABLE III.

StackArmor-REPORTED STATISTICS FOR THE SPEC CPU2006 BENCHMARKS.

Stack

DA-unsafe Max depth Max frame

(KB)
8.7
10.2
54.2
82.8
80.5
5.5
2.8
1.1
2.0
2.7
26.3
21.4
10.4

Compared to prior stack-based solutions, our reported
overheads are generally higher than source-level stack ran-
domization strategies [18], [33]—which, however, offer poorer
entropy and isolation guarantees—and comparable to traditional
shadow stack strategies [18], [20], [26], [28], [44], [62],
[70], [77], [80]—which, however, offer a narrower protection
model. In the latter case, a direct benchmark comparison is
plausible with the SPEC (INT2000) results reported in [70],
which evaluate the impact of a binary translation-based return
address shadowing strategy. The latter yields 17% overhead
(geometric mean), comparable to our SPEC overhead for
Basic, which, in turn, also includes inter-frame protection. The
small performance difference shows the effectiveness of our
stack protection analysis in eliminating the need for pervasive
stack instrumentation. Overall, we believe StackArmor provides
realistic performance for real-world programs, supporting a
much more comprehensive strategy than prior solutions in the
default conﬁguration, while allowing users to tune the security-
performance tradeoff according to their needs.

D. Memory Usage

StackArmor’s stack frame allocation strategy translates to
higher virtual and physical memory usage. Since virtual memory
is a plentiful resource in modern (x86 64) systems, we focus
our analysis on the latter. For this purpose, Figure 9 depicts
the resident set size (RSS) increase for varying values of
the maximum swap size Rmax during the execution of our
benchmarks. To thoroughly evaluate the impact of Rmax, we
conﬁgured StackArmor with the default number of maximum
stack frames and no soft limit (i.e., F = FSL = 16, 384),
allowing arbitrary values of Rmax during the execution.

The Rmax = 0 conﬁguration reﬂects StackArmor’s behavior
when in-place frame map randomization is disabled. In this
scenario, the RSS increase is only caused by internal fragmen-
tation, since stack frames are allocated at page granularity (0.2-
0.5 MB increase across our server programs). When in-place
frame map randomization is enabled, in turn, our allocation
strategy progressively reduces stack frame reuse, resulting in
RSS linearly increasing with Rmax. For very large values
of Rmax (e.g., Rmax = 10, 000), the allocator unrestrictedly
draws new stack frames from a large random pool of 10, 000
frames—initially all nonresident in memory—yielding very

low frame reuse and thus very high RSS increase (0.7-
118.5 MB across our server programs). The differences reported
across programs acknowledge variations in the distributions
of functions with stack-allocated buffers instrumented by
StackArmor. For example, a program continuously calling a
function f with many in-frame buffers may rapidly circle
through all the StackArmor’s physical stack frames, resulting
in all the F frames being resident in memory. This was nearly
the case for some long-running SPEC benchmarks, leading to
a consistent worst-case RSS increase for SPEC (1.6-195.1 MB
geometric mean).

Note, that while StackArmor’s protection strategy exposes
an evident randomization entropy-RSS tradeoff—controlled
by Rmax—which generally results in higher RSS than prior
stack-based solutions, our default conﬁguration Rmax = 1, 024—
which already provides reasonably high entropy, as earlier ex-
periments demonstrated—results in a worst-case RSS increase
for SPEC of only 22 MB (geometric mean).

E. Multithreading Support

To evaluate StackArmor’s ability to perform and scale well
in multithreaded programs, we selected 3 additional server
programs which rely on worker threads to process client
requests: Apache httpd (v2.2.23, mpm worker module)—a
popular web server—MySQL (v5.1.65)—a popular database
server—and Memcached (v1.4.20)—a popular memory caching
server. To evaluate Apache httpd, we relied on the Apache
benchmark [1] conﬁgured to issue 25,000 requests with T
concurrent connections and 10 request/connection. To evaluate
MySQL, we relied on the Sysbench OLTP benchmark [5]
conﬁgured to issue 10,000 transactions using a read-write
workload and T concurrent connections. To evaluate Mem-
cached, we relied on the memslap benchmark [2] conﬁgured
to issue 1,000,000 operations with a T concurrency level. We
conﬁgured each server program with T worker threads to match
the concurrency level induced by the corresponding benchmarks
and evaluated StackArmor’s performance and memory usage
impact for increasing values of T = [1; 100].

To evaluate the performance impact, we measured the
StackArmor-induced benchmark run time normalized against the
baseline, using our default conﬁguration at full protection (intra-
frame+inter-frame protection and zero initialization enabled).

11

addition, BinArmor [72] is tailored to buffer overﬂows and,
unlike StackArmor, cannot address temporal attacks.

Protection from temporal attacks. Prior temporal attack
protection systems focus on both use-after-free and uninitial-
ized read vulnerabilities. Systems in the former category are
generally targeted towards heap-based vulnerabilities, with
techniques ranging from garbage collection [19], [63] to secure
allocation [9], [15], [42], [54], [59] and dynamic memory
checking [21], [22], [57], [68]. The ﬁrst two classes are
not directly applicable to the stack, although StackArmor
does borrow ideas from prior secure heap allocator designs.
Similar to many secure allocators [15], [54], [59], StackArmor
enforces a fully randomized allocation strategy, with a sparse
page layout [59] and a single object per page(s) [54] to
enforce probabilistic memory safety. Unlike type-safe allocation
strategies [9], [42], in turn, StackArmor does not allow type-
safe memory reuse because doing so is more expensive and
makes uninitialized stack reads more predictable. Compared
to prior designs, however, StackArmor’s allocator is much
simpler (frames are preallocated) and more efﬁcient (the
self-managing frame map eliminates expensive bookkeeping
and lookups), thanks to the inherently bounded and dynamic
nature of the stack. Dynamic memory checking tools [21],
[22], [57], [68], in turn, can generally operate on the stack,
offer pseudo-deterministic detection guarantees, and also often
detect uninitialized reads [21], [57], [79]. Unlike StackArmor,
however,
they typically incur very high overhead. Other
more lightweight uninitialized read detection techniques exist,
but they generally sacriﬁce precision for performance [15],
[47]. While StackArmor can only protect (and not detect)
against uninitialized reads, it thwarts arbitrary attacks using a
combination of probabilistic (randomization) and deterministic
(zero initialization) strategies. The latter, in turn, is directly
comparable to secure deallocation [27], which zeroes out
memory blocks at deallocation time. Even though this approach
can also protect against nonreuse-based temporal violations,
it is very expensive on the stack [27]. StackArmor exploits
the allocation context to reduce the number of initializations
(and thus the overhead) using deﬁnite assignment analysis—
implemented at the binary level in contrast to prior source-level
strategies [35], [41], [42], [46], [48].

VII. CONCLUSION

Nearly two decades after the ﬁrst stack smashing attack,
performance concerns still induce modern compilers to ship
with weak stack protection mechanisms, ultimately resulting
in binaries being left at the mercy of the attackers. This paper
presented StackArmor, a more comprehensive stack protection
technique which offers a practical solution to this problem.
Unlike prior systems, StackArmor can efﬁciently protect against
arbitrary spatial and temporal stack-based attacks, operates
entirely at the binary level, and supports policy-driven defenses
to allow end users to tune the performance-security tradeoff.
To fulﬁll its goals, StackArmor abandons the traditional stack
organization and relies on a combination of randomization,
isolation, and zero initialization—efﬁciently balanced using
static analysis—to create the illusion that stack objects are
drawn from a fully randomized space. Our experimental results
conﬁrm that StackArmor is practical, efﬁcient, and provides
more comprehensive protection than all the prior binary- and
source-level solutions.

ACKNOWLEDGMENT

The authors would like to thank the anonymous reviewers
for their comments. This work has been supported by the
Rosetta project funded by ERC (ERC Starting Grant #258108)
and by the Re-Cover project funded by NWO.

REFERENCES

[1]
[2]
[3]
[4]
[5]
[6]

[7]

“Apache benchmark,” http://httpd.apache.org/docs/2.0/programs/ab.html.
“memslap,” http://docs.libmemcached.org/bin/memslap.html.
“pyftpdlib,” https://code.google.com/p/pyftpdlib.
“SendEmail,” http://caspian.dotconf.net/menu/Software/SendEmail.
“SysBench,” http://sysbench.sourceforge.net.
“ASLR: Leopard versus Vista,” http://blog.laconicsecurity.com/2008/01/
aslr-leopard-versus-vista.html, 2008.
“Switching from ”-fstack-protector” to ”-fstack-protector-strong” in
Fedora 20,” http://fedorahosted.org/fesco/ticket/1128, 2013.

[8] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti, “Control-ﬂow integrity
principles, implementations, and applications,” ACM Trans. on Inf. and
System Security, vol. 13, no. 1, 2009.

[9] P. Akritidis, “Cling: A memory allocator to mitigate dangling pointers,”

in Proc. of the 19th USENIX Security Symp., 2010.

[10] P. Akritidis, C. Cadar, C. Raiciu, M. Costa, and M. Castro, “Preventing
memory error exploits with WIT,” in Proc. of the IEEE Symp. on Security
and Privacy, 2008.

[11] P. Akritidis, M. Costa, M. Castro, and S. Hand, “Baggy bounds checking:
An efﬁcient and backwards-compatible defense against out-of-bounds
errors,” in Proc. of the 18th USENIX Security Symp., 2009.

[12] K. Anand, M. Smithson, A. Kotha, K. Elwazeer, and R. Barua,
“Decompilation to compiler high IR in a binary rewriter,” University of
Maryland, Tech. Rep., 2010.

[13] K. Anand, M. Smithson, K. Elwazeer, A. Kotha, J. Gruen, N. Giles, and
R. Barua, “A compiler-level intermediate representation based binary
analysis and rewriting system,” in Proc. of the 8th ACM European
Conference on Computer Systems, ser. EuroSys’13, 2013.

[14] R. Bartels, “The rank version of von Neumann’s ratio test for random-

ness,” J. Am. Statist. Assoc., vol. 77, no. 377, 1982.

[15] E. D. Berger and B. G. Zorn, “DieHard: Probabilistic memory safety for
unsafe languages,” in Proc. of the ACM SIGPLAN Conf. on Programming
Language Design and Implementation, 2006.

[16] A. R. Bernat and B. P. Miller, “Anywhere , Any-Time Binary Instru-
mentation,” in Proc. of the 10th ACM SIGPLAN-SIGSOFT Workshop
on Program Analysis for Software Tools, ser. PASTE’11, 2011.

[17] S. Bhatkar, D. C. DuVarney, and R. Sekar, “Address obfuscation: An
efﬁcient approach to combat a board range of memory error exploits,”
in Proc. of the 12th USENIX Security Symp., 2003.

[18] S. Bhatkar, R. Sekar, and D. C. DuVarney, “Efﬁcient techniques for
comprehensive protection from memory error exploits,” in Proc. of the
14th USENIX Security Symp., 2005.

[19] H.-J. Boehm, “Bounding space usage of conservative garbage collectors,”
in Proc. of the 29th ACM SIGPLAN-SIGACT Symp. on Principles of
Programming Languages, 2002.

[20] P. Broadwell, M. Harren, and N. Sastry, “Scrash: A system for generating
secure crash information,” in Proc. of the 12th USENIX Security Symp.,
2003.

[21] D. Bruening and Q. Zhao, “Practical memory checking with Dr. Memory,”
in Proc. of the Ninth Int’l Symp. on Code Generation and Optimization,
2011.
J. Caballero, G. Grieco, M. Marron, and A. Nappa, “Undangle:
Early detection of dangling pointers in use-after-free and double-free
vulnerabilities,” in Proc. of the 2012 Int’l Symp. on Software Testing
and Analysis, 2012.

[22]

[23] M. Castro, M. Costa, and T. Harris, “Securing software by enforcing
data-ﬂow integrity,” in Proceedings of the 7th USENIX Symposium on
Operating Systems Design and Implementation, ser. OSDI ’06, 2006.

13

[24] H. Chen, Y. Mao, X. Wang, D. Zhou, N. Zeldovich, and M. F.
Kaashoek, “Linux kernel vulnerabilities: State-of-the-art defenses and
open problems,” in Proc. of the Second Asia-Paciﬁc Workshop on Systems,
2011.

[25] Y. Cheng, Z. Zhou, M. Yu, X. Ding, and R. H. Deng, “Ropecker: A
generic and practical approach for defending against ROP attacks,” in
Proc. of the 21th Annual Network and Distributed System Security Symp.,
2014.

[26] T.-C. Chiueh and F.-H. Hsu, “RAD: A compile-time solution to buffer
overﬂow attacks,” in Proc. of the 21st Int’l Conf. on Distributed
Computing Systems, 2001.
J. Chow, B. Pfaff, T. Garﬁnkel, and M. Rosenblum, “Shredding your
garbage: Reducing data lifetime through secure deallocation,” in Proc.
of the 14th USENIX Security Symp., 2005.

[27]

[28] M. L. Corliss, E. C. Lewis, and A. Roth, “Using DISE to protect
return addresses from attack,” in Proc. of the Workshop on Architectural
Support for Security and Anti-Virus, 2004.

[29] M. Costa, J. Crowcroft, M. Castro, A. Rowstron, L. Zhou, L. Zhang,
and P. Barham, “Vigilante: End-to-end containment of internet worms,”
in Proc. of the 20th ACM Symp. on Oper. Systems Prin., 2005.

[30] M. Cova, V. Felmetsger, G. Banks, and G. Vigna, “Static detection of
vulnerabilities in x86 executables,” in Computer Security Applications
Conference, 2006. ACSAC’06. 22nd Annual.

IEEE, 2006.

[31] C. Cowan, C. Pu, D. Maier, H. Hintony, J. Walpole, P. Bakke, S. Beattle,
A. Grier, P. Wagle, and Q. Zhang, “StackGuard: Automatic adaptive
detection and prevention of buffer-overﬂow attacks,” in Proc. of the
Seventh USENIX Security Symp., 1998.

[32] B. Cox, D. Evans, A. Filipi, J. Rowanhill, W. Hu, J. Davidson, J. Knight,
A. Nguyen-Tuong, and J. Hiser, “N-variant systems: A secretless
framework for security through diversity,” in Proc. of the 15th USENIX
Security Symp., 2006.

[34]

[33] A. K. Cristiano Giuffrida and A. S. Tanenbaum, “Enhanced operat-
ing system security through efﬁcient and ﬁne-grained address space
randomization,” in Proc. of the 21st USENIX Security Symp., 2012.
J. Criswell, N. Dautenhahn, and V. Adve, “KCoFI: Complete control-
ﬂow integrity for commodity operating system kernels,” in Proc. of the
35th IEEE Symp. on Security and Privacy, 2014.
J. Criswell, A. Lenharth, D. Dhurjati, and V. Adve, “Secure virtual
architecture: A safe execution environment for commodity operating
systems,” in Proc. of the 21st ACM Symp. on Oper. Systems Prin., 2007.
[36] CVE-2008-0063, “Kerberos stack-based information leak,” http://web.

[35]

nvd.nist.gov/view/vuln/detail?vulnId=CVE-2008-0063, 2008.

[37] CVE-2010-0262, “Microsoft ofﬁce arbitrary code execution vulnerability
due to uninitialized stack variable,” http://web.nvd.nist.gov/view/vuln/
detail?vulnId=CVE-2010-0262, 2010.

[38] CVE-2012-5976, “Asterisk stack-based buffer overﬂow,” http://web.nvd.

nist.gov/view/vuln/detail?vulnId=CVE-2012-5976, 2013.

[39] CVE-2013-4368, “Xen stack-based information leak,” http://web.nvd.

nist.gov/view/vuln/detail?vulnId=CVE-2013-4368, 2013.

[40] D. Dhurjati and V. Adve, “Backwards-compatible array bounds checking
for C with very low overhead,” in Proc. of the 28th Int’l Conf. on Software
Eng., 2006.

[41] D. Dhurjati, S. Kowshik, and V. Adve, “SAFECode: Enforcing alias
analysis for weakly typed languages,” in Proc. of the ACM SIGPLAN
Conf. on Programming Language Design and Implementation, 2006.

[42] D. Dhurjati, S. Kowshik, V. Adve, and C. Lattner, “Memory safety
without runtime checks or garbage collection,” in Proc. of the ACM
SIGPLAN Conf. on Languages, Compilers, and Tools for Embedded
Systems, 2003.

[43] D. Dhurjati, S. Kowshik, V. Adve, and C. Lattner, “Memory safety
without garbage collection for embedded applications,” ACM Trans.
Embed. Comput. Syst., 2005.

[44] U. Erlingsson, M. Abadi, M. Vrable, M. Budiu, and G. C. Necula, “XFI:
Software guards for system address spaces,” in Proc. of the Seventh
Symp. on Operating Systems Design and Implementation, 2006.

[45] H. Etoh and K. Yoda, “ProPolice - Improved stack smashing attack

detection,” IPSJ SIGNotes Computer Security, vol. 14, 2001.

[46] N. G. Fruja, “The correctness of the deﬁnite assignment analysis in C#,”

in Proc. of the Second Int’l Workshop on .NET Technologies, 2004.

14

[47] C. Giuffrida, L. Cavallaro, and A. S. Tanenbaum, “Practical automated
vulnerability monitoring using program state invariants,” in Proc. of the
Int’l Conf. on Dependable Systems and Networks, 2013.

[48] T. Jim, J. G. Morrisett, D. Grossman, M. W. Hicks, J. Cheney, and
Y. Wang, “Cyclone: A safe dialect of C,” in Proc. of the USENIX Annual
Technical Conf., 2002.

[49] Y. Joey, “Merge stack alignment branch,” https://gcc.gnu.org/ml/gcc-

patches/2008-04/msg00349.html, 2008.

[50] C. Lattner and V. Adve, “LLVM: A compilation framework for lifelong
program analysis & transformation,” in Proc. of the Third Int’l Symp.
on Code Generation and Optimization, 2004.

[51] C. Lattner, A. Lenharth, and V. Adve, “Making context-sensitive points-
to analysis with heap cloning practical for the real world,” in Proc.
of the ACM SIGPLAN Conf. on Programming Language Design and
Implementation, 2007.

[52] M. Laurenzano, M. M. Tikir, L. Carrington, and A. Snavely, “PEBIL:
Efﬁcient static binary instrumentation for Linux,” in Proc. of the Int’l
Symp. on Performance Analysis of Systems and Software, 2010.

[53] Z. Lin, X. Zhang, and D. Xu, “Automatic reverse engineering of data
structures from binary execution,” in Proc. of the 17th Annual Network
and Distributed System Security Symposium, ser. NDSS’10, 2010.

[54] V. B. Lvin, G. Novark, E. D. Berger, and B. G. Zorn, “Archipelago:
Trading address space for reliability and security,” in Proc. of the 13th
Int’l Conf. on Architectural Support for Programming Languages and
Operating Systems, 2008.

[55] M. Matz, J. Hubi, A. Jaeger, and M. Mitchell, “System V Application
Binary Interface. AMD64 Architecture Processor Supplement.” 2013.
[56] G. C. Necula, S. McPeak, and W. Weimer, “CCured: Type-safe
retroﬁtting of legacy code,” in Proc. of the 29th ACM SIGPLAN-SIGACT
Symp. on Principles of Programming Languages, 2002.

[57] N. Nethercote and J. Seward, “Valgrind: A framework for heavyweight
dynamic binary instrumentation,” in Proc. of the Third Int’l ACM
SIGPLAN Conf. on Virtual Execution Environments, 2007.
J. Newsome and D. Song, “Dynamic taint analysis: Automatic detection,
analysis, and signature generation of exploit attacks on commodity
software,” in Proc. of the Network and Distributed Systems Security
Symposium, ser. NDSS’05, 2005.

[58]

[59] G. Novark and E. D. Berger, “DieHarder: Securing the heap,” in Proc.

of the 17th ACM Conf. on Computer and Commun. Security, 2010.

[60] V. Pappas, M. Polychronakis, and A. D. Keromytis, “Transparent ROP
exploit mitigation using indirect branch tracing,” in Proc. of the 22nd
USENIX Security Symp., 2013.

[61] G. Portokalidis and A. D. Keromytis, “Fast and practical instruction-set
randomization for commodity systems,” in Proc. of the 26th Annual
Computer Security Applications Conf., 2010.

[62] M. Prasad and T. cker Chiueh, “A binary rewriting defense against
stack-based buffer overﬂow attacks,” in Proc. of the USENIX Annual
Technical Conf., 2003.
J. Rafkind, A. Wick, J. Regehr, and M. Flatt, “Precise garbage collection
for C,” in Proc. of the Eighth Int’l Symp. on Memory management,
2009.

[63]

[64] C. Rosier, “Support

for dynamic stack realignment + VLAs
for x86,” http://lists.cs.uiuc.edu/pipermail/llvm-commits/Week-of-Mon-
20120702/146062.html, 2014.

[65] B. G. Roth and E. H. Spafford, “Implicit buffer overﬂow protection using
memory segregation,” in Proc. of the Sixth Int’l Conf. on Availability,
Reliability and Security, 2011.

[66] B. Salamat, A. Gal, T. Jackson, K. Manivannan, G. Wagner, and M. Franz,
“Multi-variant program execution: Using multi-core systems to defuse
buffer-overﬂow vulnerabilities,” in Proc. of the Int’l Conf. on Complex,
Intelligent and Software Intensive Systems, 2008.

[67] B. Salamat, T. Jackson, A. Gal, and M. Franz, “Orchestra: Intrusion
detection using parallel execution and monitoring of program variants
in user-space,” in Proc. of the Fourth European Conf. on Computer
Systems, 2009.

[68] K. Serebryany, D. Bruening, A. Potapenko, and D. Vyukov, “Address-
Sanitizer: A fast address sanity checker,” in Proc. of the USENIX Annual
Technical Conf., 2012.

[69] H. Shacham, “The geometry of innocent ﬂesh on the bone: Return-into-
libc without function calls (on the x86),” in Proc. of the 14th ACM Conf.
on Computer and Communications Security, 2007.

[70] S. Sinnadurai, Q. Zhao, and W.-F. Wong, “Transparent runtime shadow
stack: Protection against malicious return address modiﬁcations,” Uni-
versity of Singapore, Tech. Rep., 2004.

[71] A. Slowinska, T. Stancescu, and H. Bos, “Howard: A dynamic excavator
for reverse engineering data structures,” in Proc. of the Network and
Distributed System Symp., 2011.

[72] A. Slowinska, T. Stancescu, and H. Bos, “Body Armor for binaries:
Preventing buffer overﬂows without recompilation,” in Proc. of USENIX
Annual Technical Conf., 2012.

[73] M. Smithson, K. Anand, and A. Kotha, “Binary rewriting without
relocation information,” University of Maryland, Tech. Rep. November,
2010.

[74] A. Sotirov, “Heap feng shui in JavaScript,” in Black Hat Europe, 2007.
[75] B. D. Sutter, B. D. Bus, and K. D. Bosschere, “On the static analysis

of indirect control transfers in binaries,” ser. PDPTA’00, 2000.

[76] P. Team, “Overall description of the PaX project,” http://pax.grsecurity.

net/docs/pax.txt, 2008.

[77] Vendicator, “Stack Shield: A ”stack smashing” technique protection tool

[77] Vendicator, “Stack Shield: A ”stack smashing” technique protection tool

for Linux,” http://www.angelﬁre.com/sk/stackshield/info.html, 2001.

[78] R. Wartell, Y. Zhou, and K. Hamlen, “Differentiating code from data in
x86 binaries,” in Proc. of the 2011 European Conference on Machine
Learning and Knowledge Discovery in Databases, ser. ECML PKDD’11,
2011.

[79] D. Ye, Y. Sui, and J. Xue, “Accelerating dynamic detection of uses of
undeﬁned values with static value-ﬂow analysis,” in Proc. of the 11th
Int’l Symp. on Code Generation and Optimization, 2014.

[80] Y. Younan, D. Pozza, F. Piessens, and W. Joosen, “Extended protection
against stack smashing attacks without performance loss,” in Proc. of
the 22nd Annual Computer Security Applications Conf., 2006.

[81] Y. Younan, P. Philippaerts, L. Cavallaro, R. Sekar, F. Piessens, and
W. Joosen, “PAriCheck: An efﬁcient pointer arithmetic checker for C
programs,” in Proc. of the Fifth ACM Symp. on Inf., Computer and
Commun. Security, 2010.

[82] C. Zhang, T. Wei, Z. Chen, L. Duan, L. Szekeres, S. McCamant, D. Song,
and W. Zou, “Practical control ﬂow integrity and randomization for
binary executables,” in Proc. of the 34th IEEE Symp. on Security and
Privacy, 2013.

[83] M. Zhang and R. Sekar, “Control ﬂow integrity for COTS binaries,” in

Proc. of the 22nd USENIX Security Symposium, 2013.

15

