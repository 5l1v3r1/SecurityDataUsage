Predictability of Android OpenSSL’s Pseudo Random

Number Generator

The Attached Institute of ETRI

The Attached Institute of ETRI

Soo Hyeon Kim

(cid:3)

P.O. Box 1 Yuseong
Daejeon, South Korea

hyuni76@ensec.re.kr

Daewan Han

P.O. Box 1 Yuseong
Daejeon, South Korea
dwh@ensec.re.kr

Dong Hoon Lee
Graduate School of
Information Security

Korea University, South Korea
donghlee@korea.ac.kr

ABSTRACT
OpenSSL is the most widely used library for SSL/TLS on the
Android platform. The security of OpenSSL depends greatly
on the unpredictability of its Pseudo Random Number Gen-
erator (PRNG). In this paper, we reveal the vulnerability of
the OpenSSL PRNG on the Android. We ﬁrst analyze the
architecture of the OpenSSL speciﬁc to Android, and the
overall operation process of the PRNG from initialization
until the session key is generated. Owing to the nature of
Android, the Dalvik Virtual Machine in Zygote initializes
the states of OpenSSL PRNG early upon booting, and SSL
applications copy the PRNG states of Zygote when they
start. Therefore, the applications that use OpenSSL gen-
erate random data from the same initial states, which is a
potential problem that may seriously aﬀect the security of
Android applications. Next, we investigate the possibility
of recovering the initial states of the OpenSSL PRNG. To
do so, we should predict the nine external entropy sources
of the PRNG. However, we show that these sources can be
obtained in practice if the device is ﬁxed. For example, the
complexity of the attack was O(232+t) in our smartphone,
where t is the bit complexity for estimating the system boot
time. In our experiments, we were able to restore the PRNG
states in 74 out of 100 cases. Assuming that we knew the
boot time, i.e., t = 0, the average time required to restore
was 35 min on a PC with four cores (eight threads). Finally,
we show that it is possible to recover the PreMasterSecret
of the ﬁrst SSL session with O(258) computations using the
restored PRNG states, if the application is implemented by
utilizing org.webkit package and a key exchange scheme is
RSA. It shows that the vulnerability of OpenSSL PRNG can
be a real threat to the security of Android.

Categories and Subject Descriptors
C.2.0 [Computer-Communication Networks]: General—
Security and protection; C.2.2 [Computer-Communication
(cid:3)

This author is in the process of Korea University doctorate.

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS’13, November 4–8, 2013, Berlin, Germany.
Copyright 2013 ACM 978-1-4503-2477-9/13/11 ...$15.00.
http://dx.doi.org/10.1145/2508859.2516706.

Networks]: Network Protocols—Applications; E.3 [Data]:
Data Encryption—Standards
Keywords
SSL/TLS; OpenSSL; Android; Pseudo Random Number Gen-
erator; Entropy
1.

INTRODUCTION

With the great evolution of wireless Internet, smartphones
and tablets have become popular communication devices.
While various mobile operating systems are currently avail-
able, as of the second quarter of 2013, Android has domi-
nated 79.3% of the smartphone market [5]. Because many
Android applications transfer sensitive data over the Inter-
net, their security is important which is an issue that has
attracted signiﬁcant attention.

SSL/TLS is one of the most important and well-known
cryptographic protocols for secure communication. It is used
by a variety of applications such as Web browsers, e-mail,
and mobile commerce. The security of SSL depends greatly
on the unpredictability of the Pseudo Random Number Gen-
erator (PRNG), because its outputs are used for generating
session keys. Several SSL applications have been weakened
owing to the lack of entropy of the PRNG [8, 17]. Therefore,
it is important to investigate the security of PRNG in An-
droid embedded devices. SSL is typically implemented us-
ing open libraries. In particular, OpenSSL [6] is widely used
for Android. Our study therefore focuses on the OpenSSL
PRNG on Android.

First, we studied the Android OpenSSL architecture and
tracked the overall operation process of its PRNG from ini-
tialization up to the generation of session key. This study
was conducted based on an analysis of the source codes,
and an experiment using an Android test board. As a re-
sult, we found that the OpenSSL PRNG is initialized by the
Zygote process upon the system boot, and that each appli-
cation initializes its own OpenSSL PRNG state by copying
the last state of Zygote. In other words, every SSL appli-
cation generates random data from the same initial state.
If an attacker can recover the state of the OpenSSL PRNG
from any application, he can predict the important values,
such as the encryption keys of the other applications.

Second, we intensively examined the entropy of external
sources injected into the OpenSSL PRNG in order to es-
timate the complexity of recovering the initial states. The
unpredictability of the OpenSSL PRNG is highly dependent
on the data read from the Android kernel PRNG (/dev/
urandom) at the system boot. However, we found that the

659Android kernel PRNG cannot be supplied with suﬃcient ex-
ternal entropy until /dev/urandom is input into the OpenSSL
PRNG. This vulnerability is regarded as the Android version
of the boot-time entropy hole of the Linux PRNG [17]. We
can therefore predict /dev/urandom upon booting without
much complexity. The other sources can be predicted from
ClientHello packets and the system information of the de-
vice. Roughly speaking, we claim that the initial states of
an Android OpenSSL PRNG can be recovered practically.
The exact attack complexity and strategy are described in
Section 4.

To verify our discovery, we conducted experiments on An-
droid smartphones following our attack strategy. We used
two phones of the same model: one as a target and the other
as a simulator. We acquired the information of the target
phone needed for the attack in advance based on the anal-
ysis of the simulator phone. We then recovered the initial
states of the target phone from the pre-acquired information
and a ClientHello packet. The details of this method and
its results are described in Section 5.

Finally, we analyzed that the vulnerability of the OpenSSL
PRNG can aﬀect the practical security of the Android de-
vice. When a PRNG generates random data for the PreMas-
terSecret (PMS), it uses the uninitialized memory values for
another external entropy sources. In Section 6, we describe
how these memory values can be predicted, and how the PMS
can be obtained from SSL packets.

In summary, the contributions of this paper are as follows.
(cid:15) We discovered that the OpenSSL PRNG of all Android
applications generate random data from the same ini-
tial states and that these states can be restored in prac-
tice. For example, the complexity was O(232+t) in our
phone, where t is the bit complexity for estimating the
boot time of the phone. This vulnerability is caused
by the Dalvik feature of the Android architecture, the
boot-time entropy hole of the kernel PRNG, and the
insuﬃcient external entropy of the OpenSSL PRNG.

(cid:15) We conﬁrmed our discovery experimentally using smart-
phones. We were able to restore the initial OpenSSL
PRNG states of applications in 74 out of 100 cases.
Assuming that we knew the boot time, that is t = 0,
the average time to restore the state was 35 min on a
single PC with four cores (eight threads).

(cid:15) We showed that it is possible to recover the PMS of the
ﬁrst SSL session with the restored OpenSSL PRNG
states and O(258) computations, if SSL is implemented
using the org.webkit package and the key exchange
scheme is RSA. The representative application aﬀected
is the default Web browser.

Since the vulnerability we discovered is derived from the
original structure of Android and the OpenSSL PRNG, it
aﬀects every Android application using OpenSSL. Further
studies on methods for allocating memory addresses such
as Address Space Layout Randomization (ASLR) may re-
duce the complexity or extend the aﬀected applications in
PMS recovery attacks. We therefore recommend that ade-
quate countermeasures should be adopted immediately, and
suggest some possible candidates in Section 7.

From this point, we refer to the Android kernel PRNG
that originated from Linux PRNG as LPRNG, and the An-
droid OpenSSL PRNG as APRNG.

Figure 1: The SSL Handshake protocol

2. BACKGROUND
2.1 SSL/TLS

SSL/TLS is composed of two protocols: a handshake pro-
tocol and a record protocol. The handshake protocol nego-
tiates security parameters, and authenticates the server and
the client. The record protocol provides the compression
and encryption of the application data. Herein, we brieﬂy
introduce the handshake protocol for further understanding
of this paper. The steps involved in the protocol are shown
in Figure 1.

1. The client sends a ClientHello message containing the
following attributes: a list of supported ciphersuites, a
session ID, and a 28-byte random nonce.

2. The server responds with a ServerHello message that
includes a chosen ciphersuite and a nonce. Then, the
server sends its identiﬁcation in the form of a certiﬁ-
cate list. Depending on the negotiated ciphersuite, a
ServerKeyExchange message may also be sent, which
contains the information to generate a PMS. Finally,
the server sends a ServerHelloDone message that in-
dicates the end of the negotiations.

3. The client uses a certiﬁcate to authenticate the server.
If it secceeds, the client generates the PMS and sends
a ClientKeyExchange message that contains the data
needed by the server to calculate the PMS. Next, it
sends a ChangeCipherSpec message in order to inform
the server that future messages will be encrypted us-
ing the negotiated session key. Finally,
it sends a
Finished message containing the MAC of all previ-
ously exchanged messages in the handshake protocol.

4. In response, the server sends a ChangeCipherSpec mes-
sage and its Finished message. Then, the Handshake
protocol is ﬁnished and a secure communication chan-
nel is established.

660Figure 2: The structure of LPRNG

2.2 LPRNG

LPRNG is commonly used for generating random data
needed in many secure services for a Linux kernel and ap-
plications. We brieﬂy introduce the structure of the latest
version of LPRNG according to [19].

It comprises three entropy pools: input_pool, blocking_
pool, and nonblocking_pool. Figure 2 shows the over-
all structure of LPRNG. Each entropy pool has its own
entropy_counter, which is decremented when its output
is extracted from the pool, and incremented when new en-
tropy is added. External entropy sources are mixed only in
input_pool, which transfers its entropy to blocking_pool
and nonblocking_pool. The external entropy is designed
to be supplied from system interrupts, the disk I/O, and
user inputs such as a keyboard or mouse, but some of them
may not used depending on the platform. LPRNG pro-
vides /dev/random and /dev/urandom, which are device in-
terfaces for reading random data. /dev/random reads from
blocking_pool, and returns random bytes only when suﬃ-
cient entropy has been collected. /dev/urandom reads from
nonblocking_pool, and returns random bytes regardless of
the amount of entropy generated.
2.3 Related Work

Ever since its introduction decades ago, many researchers
have been scrutinizing the security of SSL/TLS. As a result,
various weaknesses of the protocol have been revealed and
ﬁxed [10, 12, 13, 14, 18, 20, 21, 22]. Herein, we introduce a
few results that are most closely related to our research.

In 2008, Bello [8] observed that the PRNG of Debian
OpenSSL was predictable owing to an implementation bug.
Yilek et al.
[25] reported on the aftermath of this vulner-
ability. They predicted that the eﬀect of the vulnerabil-
ity on clients was limited because most of the popular Web
browsers at the time did not use OpenSSL. Nowadays, mo-
bile devices are becoming major tools for the Internet, and
OpenSSL is mostly used on these devices. Thus, if any vul-
nerability exists in OpenSSL, the clients will be aﬀected to
the same extent as the servers. Our discovery described in
this paper is an example of such vulnerability.

Figure 3: The architecture of Android OpenSSL

Heninger et al.

[17] analyzed the vulnerability of weak
public key pairs in network devices. They performed large-
scale scans of TLS certiﬁcates and SSH host keys. After
analyzing the scanned data, they discovered that there were
many vulnerable RSA and DSA keys of network devices, and
one of the reasons for this vulnerability was due to insuﬃ-
cient entropy of the LPRNG upon system booting. In our
study, we show that this problem also applies to Android.
Combined with the Zygote forking structure, this can be
more serious for Android than for other embedded devices.
As mobile devices have become widely used, the studies on
the use of SSL/TLS in Android have increased. Georgiev et
al. [16] demonstrated that in many Android apps SSL/TLS
implementations were insecure against MITM attacks. Fahl
et al.
[15] also reported that many applications contained
the SSL/TLS code that was potentially vulnerable to MITM
attacks. These vulnerabilities of Android SSL were due to
implementation errors and developers’ misunderstandings of
the requirements for SSL security. In contrast, our discovery
is related to the structural limitations of LRPNG and the
Android architecture.

Ristenpart and Yilek [23] revealed that Virtual Machine
(VM) resets could lead to randomness reuse and allow an at-
tacker to compromise TLS sessions or expose a DSA signing
key of server. They also suggested a general framework for
hedging cryptographic operations against this type of ran-
domness failure, and experimentally conformed that their
framework can be applied to the OpenSSL library. The vul-
nerability of APRNG, which will be described in this paper,
partly stems from the Dalvik Virtual Machine (DalvikVM)
cloning architecture of Android. Our discovery is therefore
another good example of the practical insecurities that arise
owing to the reuses of VM states.

3. ANALYSIS OF ANDROID OPENSSL

In this section, we describe how the Android OpenSSL is
implemented and how the APRNG is operated to generate
the ClientHello nonce using the SDK class library.
3.1 Architecture of Android OpenSSL

SSL is implemented in the form of an open source li-
brary. The typical libraries include OpenSSL, GnuTLS,
NSS, and so on. We focus on OpenSSL, because it is used by
most Android applications. The Android OpenSSL provides

661Figure 4: The process of RAND add() and RAND byte()

libcrypto.so for the cryptographic functions and libssl.
so for SSL communications in the form of a system shared
library.

Android is based on a customized Linux kernel with a
Java program interface. Because system services and native
or user applications run as Linux processes, each applica-
tion is assigned to a unique PID. Since Android applications
are based on Java programming, every application must run
in its own instance of the DalvikVM. However, it takes a
long time to initialize and operate the DalvikVM whenever
a new application is launched. Therefore, Android uses a
VM known as Zygote, which is the parent process of most
Android applications.

Upon startup of Android, the Linux kernel starts the Zy-
gote process by reading init.rc. It initializes a DalvikVM
that pre-loads and pre-initializes the core library classes in-
cluding the OpenSSL shared library. While the native func-
tion of DalvikVM sets SSL_ConText(SSL_CTX) for SSLSOCKET,
the internal APRNG states are initialized and updated. When-
ever Android applications that use OpenSSL are executed,
their DalvikVMs copy and load the APRNG states of Zygote
to their own APRNG states, as shown in Figure 3.
3.2 APRNG Operation Process

OpenSSL provides the user interfaces so that applications
can select one of many random engines to generate random
bytes. Android applications use the SSLeay random method.
The APIs for the use of APRNG are as follows.

(cid:15) RAND_poll(): initializes the PRNG states with the en-

tropy sources.

(cid:15) RAND_add(void *buf, int n, double entropy): mixes

n bytes of buf into PRNG states.

(cid:15) RAND_byte(void *buf, int n): generates n bytes of

random data and puts into buf.

3.2.1 Initialization of the States
While an Android device is booting, Zygote creates a SSL_
CTX for SSL communication.
In the process of the SSL_
CTX setting, Zygote executes RAND_poll() to initialize the
APRNG states. RAND_poll() adds four entropy sources to
the APRNG states by calling RAND_add(). These entropy
sources will be described in detail in the next section.

3.2.2 Update of the States
The internal APRNG states comprise two entropy pools:
20 bytes of md_state and 1023 bytes of PRNG_state. The
states are updated by using RAND_add() and RAND_byte().
PRNG has an unsigned integer array md_count, and md_
count[0] is incremented by 1 whenever the RAND_byte()
function is called. In addition, md_count[1] represents the
total number of message blocks input to SHA-1 when the
RAND_add() function is executed. The size of an input block
for SHA-1 is 10 bytes.

In the RAND_add(), the data of buf are input into the
APRNG states for updating. In the RAND_byte(), the exist-
ing (uninitialized) values of buf are input to SHA-1 as an ex-
ternal entropy source. The buf will contain newly generated
random values after the execution of RAND_byte() is ﬁn-
ished. The three internal variables md_state, PRNG_state,
and md_count are also injected into SHA-1. The PRNG_state
is updated by the output of SHA-1, which is xored with
the previous PRNG_state. After ﬁnishing the update of the
PRNG_state, the last hash output generated is xored with
the previous md_state.

3.2.3 Extracting Random Bytes
RAND_byte() is used to extract random bytes.

In this
function, the application PID and three internal variables are
mixed in SHA-1. The APRNG uses the bottom 10 bytes
of the output of SHA-1 as random bytes. PRNG_state is
updated by xoring the top 10 bytes of the hash output into
the previous PRNG_state.

The operating processes of RAND_add() and RAND_byte()

are depicted in Figure 4.
3.3 Generating ClientHello Nonce

Android applications use class interfaces to establish SSL
connections. These classes are in the middle of the interface
between the Java application and the OpenSSL library. Rep-
resentative classes are the org.webkit and javax.net.ssl
packages. The org.webkit package provides the libchromium_
net.so library to establish an SSL connection using webkit
socket. The javax.net.ssl package uses Java Secure Socket
Extension (JSSE) and provides native functions so that ap-
plications can communicate using SSL.

As mentioned before, Android applications generate a Clien-

tHello nonce from the states initialized by Zygote. The

662Figure 5: The procedure of generating ClientHello nonce in org.webkit package

generation process of this can be classiﬁed into two types
depending on these packages. In this subsection, we explain
in detail the case of org.webkit, and brieﬂy describe the
case of javax.net.ssl.
3.3.1 Generation of Random Values in /dev/urandom
As shown in Figure 5, Zygote reads the random values
from /dev/urandom for initialization of the APRNG states.
The user interface functions to read from /dev/urandom are
get_random_bytes() and urandom_read(). The default size
of an output block of LPRNG is 10 bytes. If the number of
requested bytes is not a multiple of 10 bytes, the last block is
truncated. If the entropy_counter of input_pool does not
exceed the minimum needed (threshold), /dev/urandom out-
puts without mixing the output of input_pool. The thresh-
old of entropy_counter is 192 bits in Android kernel 3.0.15.
Upon Android startup, all bytes of the LPRNG states
are set to zero. In these states, the Linux kernel extracts 4
bytes of random data three times from /dev/urandom for the
network setting, such as initializing inet6 and computing
genid for the ipv4 address. The Linux Kernel then adds
ktime and utsname to the nonblocking_pool as external
entropy sources. The ktime is nano-second after the system
boots, and utsname indicates name and information about
current kernel.

While the initial process of the kernel starts the services
registered in init.rc, the kernel and some of the applica-
tions extract random data from /dev/urandom for various
purposes. For example, the kernel uses 6 bytes for assign-
ing an Ethernet IP address, and 16 bytes whenever it loads
the ELF format. Some Android processes request 4 bytes
for stack_chk_guard, and applications using SQLite extract
256 bytes for initializing the states of their own PRNG. We
note in advance that stack_chk_guard is importantly used
in recovering the PMS of some SSL packets, as described in
Section 6.

Because Zygote is also registered in init.rc, it is initial-
ized upon system boot, and 32 random bytes from /dev/
urandom are injected into APRNG during this process.

3.3.2 Operation of Zygote APRNG
While DalvikVM of Zygote creates SSL_CTXs, four entropy
sources, i.e., Time, PID, UID, and /dev/urandom, are injected
into the states during LPRNG initialization executed by
RAND_poll(). The one read from /dev/urandom is 32 bytes,
and the others are 4 bytes.

The APRNG executes RAND_byte() to generate 16 bytes
of random data for setting the ticket key [7], which is used
to resume a SSL session without requiring session-speciﬁc
states at the server. The ticket key consists of three compo-
nents, i.e., the key name, hmac key and AES key. Because
DalvikVM of Zygote creates two SSL_CTXs for transferring
and receiving, APRNG calls RAND_byte() six times in total.
In RAND_byte(), APRNG uses the existing value of the out-
put buﬀer as a small source of entropy. However, the value
in the operation of Zygote is initialized to zero.

3.3.3 Operation of Application APRNG
When an application starts, it loads the initialized OpenSSL.

To establish a session, it creates a new SSL_CTX by calling
SSL_CTX_new(), which also calls RAND_byte() three times
to set the ticket key. At this point, the application’s PID
and the output buﬀer value, which is initialized to zero, are
mixed into the APRNG states. When OpenSSL performs
the SSL handshake by invoking SSL_connect(), APRNG
also adds the Time into the states. Next, the ClientHello
nonce is generated and transferred to a server.

If the application uses the javax.net.ssl package for
SSL, it has a little diﬀerence in the number of times to
run RAND_bytes() for SSL_CTX and external input injected
into the states. The APRNG generates 16 bytes of ran-
dom values for SSL_CTX_new() six times and then adds the
ﬁle information regarding /dev/urandom, 1024 bytes from
/dev/urandom, and Time to its internal states before gener-
ating the ClientHello nonce.

4. PREDICTABILITY OF APRNG

The randomness of the APRNG depends on the unpre-
dictability of the external entropy sources. The sources in-
put into the APRNG are shown in the gray boxes in Figure
5. Among these, /dev/urandom is the most important in

663Table 1: Example of utsname

sysname
nodename
release
version

machine

domainname

Linux
(none)
3.0.15

#1 SMP PREEMPT

Fri Feb 8 16:54:28 KST 2013

armv7l
(none)

pool is less than the threshold (192 bit) at 83%. In these
cases, /dev/urandom requested from the APRNG are gener-
ated using only two external sources: utsname and ktime.

Our experiment is highly limited, but we expect that this
phenomenon will generally occur in Android. It was previ-
ously reported for other Linux platforms [17]. In addition
to the above experiment on a test board, we also conducted
another experiment on smartphones (Section 5), which con-
vince us that our assertion will be true in practice.
4.2 Complexity of the Entropy Sources

Herein, we analyze the complexity of the entropy sources,
which are fed into the state of APRNG until the ClientHello
nonce is generated. The following elements should be checked:

(cid:15) LPRNG: utsname, ktime, CBN
(cid:15) Zygote APRNG: UID, PID, Time, Buffer
(cid:15) Application APRNG: PID, Time, Buffer

ktime

utsname

4.2.1
The utsname comprises six elements that contain informa-
tion on the system and kernel. The sysname, nodename, and
domainname have ﬁxed values. The machine and release
indicate the version of the chip and kernel, respectively, and
version is the time when the kernel was compiled. Thus,
they do not have many types of such elements, which will be
same, if the devices are released by a manufacturer during
the same period. Therefore, if an attacker ﬁxes the target
for an attack, he can see the device’s utsname in advance. As
an example, the utsname of our board is provided in Table 1.
4.2.2
The ktime is the time in nano-seconds when LPRNG calls
random_initialize(). This function is usually executed
within 2 seconds after a system boot. The complexity of
ktime can therefore be roughly estimated as 31 bits. How-
ever, if we ﬁx a device, we can reduce it to 25 (cid:24) 28 bits by
more minutely analyzing the execution time of the function.
For example, based on the analysis which we will present
in Section 5, we can estimate the complexity of ktime as 26
bits in our phone.
4.2.3 CBN
We deﬁne the CBN (Computed Block Number) as the
total number of random blocks (10 bytes) computed in /dev/
urandom from the system boot to the start of the Zygote
initialization. The CBN depends on the device model, OS
version, and communication provider. It varies between 100
and 250. For example, in our experiment, it was 137 on the
board and 210 on the phone. However, we observed that the
CBNs of diﬀerent devices are equal if the above properties of
the devices are the same.

Figure 6:
launch

Input pool entropy counter at Zygote

terms of its size and complexity. LPRNG depends on exter-
nal sources for randomness: utsname, ktime, and various de-
vice events, which are transferred by input_pool. However,
an Android device has no user inputs such as a mouse or a
keyboard, and has a few interrupts until Zygote is launched
at the system boot. It is therefore possible that input_pool
cannot transfer its entropy to /dev/urandom because of its
low entropy_counter at boot time. If this actually occurs,
and the complexities of the other entropy sources are low, we
can predict the internal states of APRNG. In this section, we
verify that these two hypotheses are true and demonstrate
their eﬀects on the vulnerability of the APRNG.

In the analysis, we conducted various experiments on an

Android test board with the following conﬁgurations:

(cid:15) Chip set: Exynos 4210
(cid:15) CPU: Dual-core ARM Cortex-A9
(cid:15) Memory: 1G Bytes
(cid:15) OS: Android ICS 4.0.4 (kernel 3.0.15)

We used adb tool [2] and trace32 [9] to analyze the internal
information of the board and applications.
4.1 Boot-time Entropy Hole of LPRNG

LPRNG is designed to be supplied with external entropy
when system events such as a disk I/O operation, user input,
and IRQ occur by calling the following functions: add_disk_
randomness(), add_input_randomness(), and add_interrupt_
randomness(). However, we found that add_interrupt_
randomness() is not used in an Android device, which was
already reported for other Linux platforms [11, 24]. The
add_input_randomness() is rarely used, and is not used
at boot time in an Android device. Thus, only disk I/O
events are entropy sources for LPRNG before the Zygote
launch. These events do not occur deterministically and are
dependent on the devices, OS versions, and communication
providers. We therefore need to conduct an experiment to
determine how much entropy is fed into LPRNG from the
disk events.

We measured the entropy_counter of input_pool when
Zygote initialized OpenSSL. Figure 6 shows the frequency
versus entropy_counter of input_pool for 100 test cases.
The ﬁgure shows that the entropy_counter of the input_

6644.2.4 UID and PID
The size of the UID is 4 bytes in the source code, but is
set to 0 in Android. The PID is assigned sequentially ac-
cording to the order that the application is running. The
PID has 15 bits of complexity in the source code. However,
Android’s initial processes and the manufacturer’s built-in
applications are executed in the order speciﬁed. Thus, the
Zygote PID is less than 3000 and is nearly ﬁxed in the the
same model devices. The PIDs of built-in applications, such
as Web browsers, e-mail, and YouTube, do not signiﬁcantly
change. For example, the PID of the Web browser on our
phone is on 2900(cid:24)2950. We can therefore estimate the com-
plexity of the Zygote PID on our phone as 0, and that of the
application PID as 6.
4.2.5 Time
The Time refers to gmt_unix_time, the unit of which is in
seconds. Since the application’s Time is almost equal to the
time shown in the ClientHello packet, we can predict it
exactly. The Zygote module is launched upon system boot,
and thus the Zygote Time can be approximated as the sys-
tem boot time. Phones are usually rebooted more than once
per week for battery changes or other reasons. Therefore,
we estimate the complexity of the Zygote Time of a general
phone as 20 bits. However, an attacker may obtain the ap-
proximate boot time of a targeted device through various
methods. Possible situations and scenarios are described in
the next subsection.

4.2.6 Buffer
The Buffer is the existing value of the RAM where the
output of RAND_byte() will be stored. Its complexity there-
fore depends on how the buﬀer is deﬁned and initialized in
the function that calls RAND_byte(). The buﬀer used to gen-
erate the ClientHello nonce is initialized to all zeros, and
we can therefore regard it as a ﬁxed constant. However, this
is not true for other cases such as PMS generation.
4.3 Vulnerability and Attack Strategy

So far, we have investigated the complexity of entropy
sources for APRNG until the ClientHello nonce is gener-
ated for org.webkit based applications. Table 2 shows a
summary of our analysis. In the second and third columns,
we describe the bit complexity of the entropy sources in gen-
eral devices and a ﬁxed device, respectively. The bit com-
plexities of our phone are given in the last column, where
t is the bit complexity for estimating the boot time. As
a conclusion, if we ﬁx a device and acquire its information
beforehand, they can be restored exactly except for ktime,
application’s PID, and Zygote Time.

The complexity of three unpredictable elements will be
diﬀerent according to chip speed, OS version, application,
and system boot time. We can expect their sum to 50 (cid:24) 55
bits on a ﬁxed device. However, Zygote Time is close to
If we can ﬁnd this value through 2t
a system boot time.
trials, the states of APRNG can be recovered with O(235+t)
computations. If t is 0, it can be accomplished in a few hours
using a single PC, as demonstrated in the next section. We
cannot say that it is impossible even if in the worst case
where t is 20. It is well known that a brute force attack on
DES with a key size of 56 bits can be accomplished within
a day [4]. Therefore, we can state at a minimum that the
APRNGs of applications based org.webkit are vulnerable.

Table 2: Entropy of APRNG (bit)

entropy
sources
utsname

ktime

CBN
UID

Zygote PID
Zygote Time

Application PID
Application Time

Buffer
Total

general
devices

43
31
8
0
12
20
15
0
0

129

a ﬁxed
device
25 (cid:24) 28

0

0
0
0
20
5 (cid:24) 7
0
0

50 (cid:24) 55

our

phone

0
26
0
0
0
t
6
0
0

32 + t

However, the problem does not end here. As we explained in
Section 3, every SSL application starts with the same initial
states of APRNG, which are updated by Zygote. Thus, if
an attacker can restore the APRNG states of any speciﬁc
application, he can obtain the states of all applications even
those that are implemented by other packages and will run
after the attack.

Now, we present a strategy for attacking APRNG of a
device. An attacker ﬁxes a target and obtains its information
by conducting experiments on another device of the same
model and OS version as the target.

If possible, the attacker obtains the time when the device
was last booted up. It will reduce the attack time. Possible
situations and scenarios can be considered are as follows: A
man engaged in air travel is more likely to reboot his phone
when arriving. There are many companies and organizations
where the visitors need to leave their phone at a help desk
according to the security policy. If the phone is not turned
oﬀ, a staﬀ member at the desk who wants to attack the
phone can reboot it. In these cases, the attacker can guess
the boot time of the phone.

Then, he collects ClientHello nonce packets of an org.
webkit application such as the Web browser generated on
the target. Finally, he computes a ClientHello nonce with
unknown external sources as variables. By exhaustively
searching for the variables within the ranges according to
the the preacquired information, he compares the output
with the real ClientHello nonce captured in the packet. If
he ﬁnds variables with which two values are matched, he can
restore the APRNG’s initial states of all applications.

This result shows that the APRNG is vulnerable from a
cryptographic perspective at least. More practical implica-
tions of this problem will be discussed in Section 6.

5. EXPERIMENT ON A PHONE

In this section, we present the results of experiments on
restoring the initial state of APRNG in a smartphone using
the attack strategy described in the previous section. We
used two phones of the same model, one as a target and the
other as a simulator, to obtain the information needed for
an attack on the target.
5.1 Pre-acquisition of the Device Information
To obtain the information needed for our attack, we used
the kernel log of the simulator phone by modifying the source

665Figure 7: A captured SSL packet on the experiment

Table 3: Searching Range of Variables in the Attack

variable
utsname

ktime

CBN

Zygote PID
Zygote Time

Application PID
Application Time

searching range

same to that of Section 5.1
780(cid:24)830 ms, 1230(cid:24)1240 ms

210
1845

0x511b7cce(cid:24)0x511b7ccf

2900(cid:24)2950

0x511b7dfa

Figure 8: ktimes on the experiment

Table 4: Values found on the experiment

variable

ktime (ns)
Zygote Time

Application PID

MD state

of SSL CTX

value

790212920
0x511b7cce
2939
c4 82 04 51 c6 e7 9a fe 3e 4a
85 f7 b6 e5 4f f7 67 17 b7 e9

code. We rebooted the phone 100 times and checked the
variables.

The OS version used was Android 4.0.4 Ice Cream Sand-
wich. The utsname was same as that presented in Section
4.2, except the release is ‘3.0.15-1042229’ and the version
is ‘#3 SMP PREEMPT Fri Aug 17 20:49:17 KST 2012’. We
could know the Zygote PID through the Android adb shell
command, which was 1845. We could also see that, in most
cases, the initialization of the LPRNG occurred at 770(cid:24)830
or 1298(cid:24)1230 ms after the system boot. This is the reason
that we estimated the entropy of ktime as 26 bits in Section
4.2. Finally, we found that CBN was 210 for most cases.
5.2 Restoring the APRNG States

We rebooted the target phone and used the boot time to
predict the Zygote Time, that is, we set t to 1. We then
activated HTTPS using a Web browser a few minutes af-
ter system started. At the same time, we captured the
ClientHello nonce of the SSL packets using Wireshark. We
set the application Time equal to the packet time.

We constructed an SW program to execute the attack
procedure described in Section 4.3. The variables are ﬁxed
or searched for within the range shown in Table 3, which are
set by the acquired information. We executed this program
on a PC conﬁgured with a Intel Core 3.60 GHz i7 CPU
with four cores. Since it can be operated with eight threads,
we parallelized the program by dividing the search range of
ktime into eight parts.

As a result, we succeeded in ﬁnding unﬁxed variables. The
captured ClientHello packet is shown in Figure 7, and the
found values and restored MD_state are given in Table 4. We
repeated the experiments 100 times on the same phone, and
successfully found the unknowns 74 times. Figure 8 shows
the distribution of ktimes of these cases.

6. EFFECT OF THE VULNERABILITY

As the main contribution of this paper, we showed that the
initial state of APRNG can be restored practically with high
probability. Then, how is the security of Android OpenSSL
aﬀected by this vulnerability? We analyze this subject in
this section.

The main interest is whether the problem of APRNG
poses a threat to the conﬁdentiality of OpenSSL, such as a
session key recovery. The session key is generated from the
PMS and other known variables. As mentioned in Section 3.3,
APRNG states cannot be restored in javax.net.ssl appli-
cations for extra unpredictable inputs, and thus the their
PMSs cannot be recovered at this time. We therefore focus
on org.webkit applications.

6.1 PMS Restoration

The generation of a PMS varies depending on the key ex-
change scheme of the negotiated ciphersuite. The 46 random
bytes of PMS are generated directly by APRNG of client in
RSA scheme. In the (EC)DH scheme, PMS is computed us-
ing the client’s randomly generated private key and server’s
public key.
It is notable that the random data related to
the PMS are generated immediately after the ClientHello
nonce is generated. Another Time value is added into the
APRNG states, but it can be predicted because it is almost
same as the time of the ClientHello packet. We can know
the states of the APRNG after outputting the ClientHello
nonce, and thus the remaining problem for recovering the
PMS is to estimate the existing value of the output buﬀer.

The buﬀer is deﬁned as a local variable in the RSA and as
a dynamic variable in the EC(DH). It seems diﬃcult to ﬁnd
the pattern of a dynamic variable. However, it is possible to
track the values of a local variable, because such variables

666Table 5: Comparison of buﬀer memory values

example

Memory value

case I

0063
00000000 6bdae5f2 0000000a 4e900379
403382cc 6bdae5f2 0000000a 4e900379
006257a0 6bdae5f2 0000000a
00ed
00000000 869f1107 0000000a 4e9da379
403492cc 869f1107 0000000a 4e9da379
00529fc0 869f1107 0000000a
WORD-1
WORD-2 WORD-3 WORD-4 WORD-5
Pattern WORD-6 WORD-3 WORD-4 WORD-5

case II

WORD-7 WORD-3 WORD-4

are stored in the stack memory. We therefore analyzed the
case of the RSA key exchange scheme.

Table 5 shows two examples of buﬀer values we should
examine. These values are not totally random and have a
certain pattern, which is abstracted in the last row of the
table.

To the results of tracking the memory, we found that the
46 bytes of the buﬀer are written while SSL_get_server_
certificate() function is executed. The use of each word
is as follows, where locking_callback() is a function used
to read the public key contained in the certiﬁcate.

(cid:15) WORD-1:

the address of a parameter of SSL_get_

server_certificate().

(cid:15) WORD-2: the result when verify_mode of SSL is SSL_

VERIFY_NONE, which is always 0x00000000.

(cid:15) WORD-3: the value of stack_chk_guard which is re-

quired by locking_callback().

(cid:15) WORD-4: the value of a variable used in locking_

callback(), which is always 0x0000000a.

(cid:15) WORD-5: the starting address of locking_callback().
(cid:15) WORD-6: the address of a ﬁle in which X509_pubkey_

get() is stored when the lock is set.

(cid:15) WORD-7:

the address of memory where sign algo-
rithm are stored when the X509_Certificate_type()
is executed.

WORD-2 and WORD-4 are ﬁxed values. The other words

vary at each time, but are not totally random as follows:

(cid:15) WORD-1: the upper 7 bits are always 0.
(cid:15) WORD-5: the upper 9 and lower 12 bits are ﬁxed.
(cid:15) WORD-6: the upper 12 and lower 12 bits are ﬁxed.
(cid:15) WORD-7: the upper 7 and lower 3 bits are ﬁxed.

We can therefore estimate all of the variables, except for
WORD-3, with O(250) complexity. WORD-3 (stack_chk_
guard) is fully random data. However, it is read from /dev/
urandom before the random data of /dev/urandom is input
into Zygote APRNG. It can therefore be predicted from
ktime and utsname found when we restore the APRNG

states. The CBN is less than 250, and we can therefore predict
WORD-3 at most O(28) trials. The maximum complexity
of restoring the PMS is thus O(258).

Note that the above complexity is not bitwise. To deter-
mine whether we estimated the unknowns exactly, we need
to calculate a session key from the unknowns and decrypt
the SSL packets. This requires dozens of hash computa-
tions and negotiated cipher operations such as RC4 or AES,
which cannot be executed even 250 times a year on a single
PC. However, this may be accomplished practically if the at-
tacker belongs to a well-funded enterprise or organizations.
Finally, we remark the possibility of improving the at-
tack. The randomness of WORD-1, 5, 6, and 7 is due to the
address ASLR provided beginning with Android 4.0 [1, 3].
If we can predict the ASLR operation more accurately on
general devices, the PMS recovery attack may be improved.
However, such a study is beyond the scope of this paper and
will be the subject of future work.
6.2 Effect of Decrypting the First Session

Suppose that we obtain the ﬁrst session of HTTPS re-
quests from the recovered session key. The decrypted HTTPS
request includes the request-line, the resource identiﬁed by
the request, the HTTP header, and message bodies. Among
them, the most important part is the HTTP header includ-
ing a cookie. A cookie has information regarding the login
and preferences when a user visits a Web site. If a user will
visit the same site in the future, the data stored in the cookie
can be used as an authentication token of the user.

An attackers can thereby impersonate a user request by
stealing a full set of cookies from the recovered ﬁrst session
[14]. Then, other important information may be stolen, and
other exploit attacks can be made based on this attack.

7. COUNTERMEASURE

The vulnerability of the APRNG described in this pa-
per stems from the following independent causes: an appli-
cation’s direct use of SSL CTX forked by Zygote, and the
boot-time entropy hole of LPRNG, and the insuﬃcient ex-
ternal entropy of APRNG.

The ﬁrst is due to the fundamental operating structure of
Android, which is related to Zygote forking, and therefore
supplementing it will not be easy, and appears to be outside
the scope of the information security community.

A well-known countermeasure for correcting the boot-time
entropy hole of LPRNG is saving the status at shutdown,
and writing it back to the pools at startup. This is rec-
ommended in general Linux systems, and can be achieved
using a script activated during system startups and shut-
downs. However, this countermeasure appears to be absent
in Android. If possible, this method can be a simple and
powerful countermeasure.

Adding more entropy sources to APRNG before gener-
ating ClinetHello nonce is another method to defeat our
attack. Besides resistance to our attack, there is impor-
tant reason to should consider this countermeasure. Since
Zygote forking structure is hard to change in Android, the
phenomenon that OpenSSL applications start with the same
initial PRNG states cannot be easily remedied. However,
this is much undesirable in the point of security. Therefore,
Scattering the PRNG states randomly in each application’s
startup is needed. It is recommendable that Additional un-

667predictable entropy sources are mixed when each application
starts.

8. CONCLUSION

In this paper, we revealed the vulnerability of the Android
OpenSSL PRNG. After we investigated the operating pro-
cess of Android OpenSSL, its concrete implementation, and
the entropy sources of its PRNG, we claimed and veriﬁed
that the initial states of APRNG can be recovered practi-
cally. We also showed that our discovery can be a real threat
to Android by showing that the PMSs of some SSL sessions
can be recovered practically.

To the best of our knowledge, most previously revealed
Android SSL vulnerabilities are problems of individual ap-
plications, and can therefore be easily corrected at the ap-
plication level from careful use and implementation. In con-
trast, the problem we identiﬁed is due to the structural limits
of the Android architecture and LPRNG, and therefore af-
fects every Android application that use OpenSSL. Further
studies on the memory allocation and each device charac-
teristic may reduce the complexity or extend the aﬀected
applications during practical attacks. We recommend that
adequate countermeasures should be immediately adopted.
The security of Android is becoming increasingly impor-
tant owing the widespread use of mobile devices. Our study
serves as a reminder that more studies and supplements are
needed to ensure the security of Android.

9. ACKNOWLEDGEMENTS

We would like to thank Peter Gutmann and the anony-
mous reviewers for their helpful comments and suggestions
for enhancing the quality of this paper. Dong Hoon Lee is
supported by Next-Generation Information Computing De-
velopment Program through the National Research Founda-
tion of Korea (NRF) funded by the Ministry of Science, ICT
& Future Planning (2010-0020726).

10. REFERENCES
[1] Address space layout randomization.

http://en.wikipedia.org/wiki/Address_space_
layout_randomization.

[2] Android debug bridge.

http://developer.android.com/tools/.

[3] Android Security Overview. http:

//source.android.com/devices/tech/security/.

[4] Break DES in less than a single day.

http://www.sciengines.com/company/
news-a-events/74-des-in-1-day.html.

[5] IDC - Press Release. http://www.idc.com/getdoc.

jsp?containerId=prUS24257413.

[6] OpenSSL. http://www.openssl.org/.
[7] RFC 4507: Transport Layer Security (TLS) Session

Resumption without Server-Side State.

[8] The Debian Project. Openssl-Predictable Random

Number Generator, DSA-1571-1. Available from
http://www.debian.org/security/2008/dsa-1571.

[9] Trace32. http://www.lauterbach.com/.
[10] N. J. Alfardan and K. G. Paterson,

Plaintext-Recovery Attacks Against Datagram TLS.
In Network and Distrubited System Security
Symposium (NDSS 2012), 2012.

[11] T. Biege. Analysis of a Strong Pseudo Random

Number Generator by anatomizing Linux’ Random
Number Device. Tech. rep., PhoneFactor, Inc., Nov.
2006.

[12] D. Brumley and D. Boneh. Remote Timing Attacks

Are Practical. In Proceedings of the 12th conference on
USENIX Security Symposium - Volume 12 (Berkeley,
CA, USA, 2003), USENIX Association, 2003.

[13] B. Canvel, A. Hiltgen, S. Vaudenay, and M.

Vuagnoux. Password Interception in a SSL/TLS
Channel. In Proceedings of Advances in Cryptology -
CRYPTO 2003 , Springer-Verlag, pp. 583–599, 2003.
[14] T. Duong and J. Rizzo. Here Come the Xor Ninjas.

Tech. rep., May 2011.

[15] S. Fahl, M. Harbach, T. Muders, L. Baumg¨artner, B.
Freisleben, and M. Smith. Why Eve and Mallory Love
Android: An Analysis of Android SSL (In)Security. In
Proceedings of the 2012 ACM conference on Computer
and communications security, pp. 50–61, 2012.

[16] M. Georgiev, S. Iyengar, S. Jana, R. Anubhai, D.

Boneh, and V. Shmatikov. The Most Dangerous Code
in the World: Validating SSL Certiﬁcates in
Non-browser Software. In Proceedings of the 2012
ACM conference on Computer and communications
security, pp. 38–49, 2012.

[17] N. Heninger, Z. Durumeric, E. Wustrow, and J. A.
Halderman. Mining Your Ps and Qs: Detection of
Widespread Weak Keys in Network Devices. In
Proceedings of the 21st USENIX Security Symposium,
pp. 205–220, 2012.

[18] V. Klima, O. Pokorny, and T. Rosa. Attacking

RSA-Based Sessions in SSL/TLS. In Proceedings of
Cryptographic Hardware and Embedded Systems
(CHES) 2003 , Springer, pp. 426–440, 2003.

[19] P. Lacharme. The Linux Pseudorandom Number

Generator Revisited. IACR ePrint Arcive 2012/251.
Available from http://eprint.iacr.org/2012/251.

[20] M. Marlinspike. More Tricks for Defeating SSL in

Practice. In Black Hat USA, 2009.

[21] C. Meyer and J. Schwenk. Lessons Learned from

Previous SSL/TLS Attacks: A Brief Chronology of
Attacks and Weakness. IACR ePrint Arcive 2013/049.
Available from http://eprint.iacr.org/2013/049.

[22] M. Ray and S. Dispensa. Renegotiating TLS.

Technical Report, PhoneFactor, Inc., Nov. 2009.

[23] T. Ristenpart and S. Yilek. When Good Randomness
Goes Bad: Virtual Machine Reset Vulnerabilities and
Hedging Deployed Cryptography. In Proceedings of the
Network and Distributed System Security Symposium
(NDSS) 2010 . Internet Society, 2010.

[24] T. Vuillemin, F. Goichon, C. Lauradoux, and G.

Salagnac. Entropy Transfers in the Linux Random
Number Generator. Research Report 8060, INRIA,
Sept. 2012.

[25] S. Yilek, E. Rescorla, H. Shacham, B. Enright, and S.
Savage. When Private Keys Are Public: Results From
the 2008 Debian OpenSSL Vulnerability. In
Proceedings of IMC 2009 , pp. 15–27, 2009.

668