2012 IEEE Symposium on Security and Privacy

Rozzle: De-Cloaking Internet Malware

Clemens Kolbitsch

Benjamin Livshits and Benjamin Zorn

Lastline, Inc.

Microsoft Research

Christian Seifert

Microsoft Corporation

Abstract—JavaScript-based malware attacks have in-
creased in recent years and currently represent a
signiﬁcant threat to the use of desktop computers,
smartphones, and tablets. While static and runtime
methods for malware detection have been proposed
in the literature, both on the client side, for just-in-
time in-browser detection, as well as oﬄine, crawler-
based malware discovery, these approaches encounter
the same fundamental limitation. Web-based malware
tends to be environment-speciﬁc, targeting a particular
browser, often attacking speciﬁc versions of installed
plugins. This targeting occurs because the malware
exploits vulnerabilities in speciﬁc plugins and fails
otherwise. As a result, a fundamental limitation for
detecting a piece of malware is that malware is triggered
infrequently, only showing itself when the right environ-
ment is present. We observe that, using ﬁngerprinting
techniques that capture and exploit unique properties
of browser conﬁgurations, almost all existing malware
can be made virtually impossible for malware scanners
to detect.

This paper proposes Rozzle, a JavaScript multi-
execution virtual machine, as a way to explore multi-
ple execution paths within a single execution so that
environment-speciﬁc malware will reveal itself. Using
large-scale experiments, we show that Rozzle increases
the detection rate for oﬄine runtime detection by
almost seven times. In addition, Rozzle triples the
eﬀectiveness of online runtime detection. We show
that Rozzle incurs virtually no runtime overhead and
allows us to replace multiple VMs running diﬀerent
browser conﬁgurations with a single Rozzle-enabled
browser, reducing the hardware requirements, network
bandwidth, and power consumption.

Index Terms—malware; cloaking; JavaScript

I. Introduction

In recent years, we have seen mass-scale exploitation
of memory-based vulnerabilities migrate towards drive-by
attacks delivered through the browser. With millions of
infected URLs on the Internet, JavaScript malware now
constitutes a major threat. A recent 2011 report from
Sophos Labs indicates that the number of malware pieces
analyzed by Sophos Labs every day in 2010, about 95,000
samples, nearly doubled from 2009 [31].

While static and runtime methods for malware detection
have been proposed in the research literature [11, 12, 26],
both on the client side, for just-in-time in-browser detec-
tion, as well as oﬄine, crawler-based malware discovery,
these approaches encounter the same fundamental limita-
tion. Web-based malware tends to be environment-speciﬁc,
targeting a particular browser, often with speciﬁc versions

of installed plugins. This targeting happens because the
exploits will often only work on speciﬁc plugins and fail
otherwise. As a result, a fundamental limitation for detect-
ing a piece of malware is that malware is only triggered
occasionally, given the right environment; an excerpted
example of such malware is shown in Figure 1.

While this behavior has been observed previously in
the context of x86 malware [22, 23, 37], the traditional
approach to improving path coverage involves symbolic ex-
ecution, a powerful multi-path exploration technique that
is often associated with non-trivial performance penal-
ties [7, 8, 16, 27]. As such, oﬀ-the-shelf symbolic execution
is not a feasible strategy. In a brute-force attempt to
increase detection rates, oﬄine detectors often deploy and
utilize a variety of browser conﬁgurations side-by-side.
While potentially eﬀective, it is often unclear how many
environment conﬁgurations are necessary to reveal all
possible malware that might be lurking within a particular
web site. Conversely, many sites will be explored using
diﬀerent conﬁgurations despite the fact that their behavior
is not environment-speciﬁc. As a result, this approach
requires signiﬁcantly more hardware, power , and network
bandwidth.

This paper proposes Rozzle, a JavaScript multi-
execution virtual machine, as a way to explore multi-
ple execution paths within a single execution so that
itself. Rozzle
environment-speciﬁc malware will reveal
implements a single-pass multi-execution approach that

E5Jrh = new A c t i v e X O b j e c t ( " AcroPDF . PDF " );

E5Jrh = new A c t i v e X O b j e c t ( " PDF . PdfCtrl " );

lv = E5Jrh . G e t V e r s i o n s (). split ( " ," )[4].

split ( " = " )[1]. replace (/\./ g , " " );

try {

} catch ( e ) { }

if ( lv < 900 && lv != 813)

1 try {
2
3 } catch ( e ) { }
4 if (! E5Jrh )
5
6
7
8 if ( E5Jrh ) {
9
10
11
12
13
14 }
15 try {
16
17
18
19
20 } catch ( e ) { }
21 if ( E5Jrh && E5Jrh [2] < 124)
22
23

var E5Jrh = 0;
E5Jrh = ( new A c t i v e X O b j e c t (

d o c u m e n t . wr ite ( ’ < embed src =".../ validate . php ? s = PTq ..."

width =100 height =100 type =" a p p l i c a t i o n / pdf " > </ embed > ’)

" S h o c k w a v e F l a s h . S h o c k w a v e F l a s h .9 " ))
. G e t V a r i a b l e ( " $ " + " version " ). split ( " ," )

document . write ( ’ < object c la s si d =" clsid : d27cdb6e - ae ..."

width =100 height =100 align = middle > < param name =" movie "... ’ );

Fig. 1: Typical JavaScript exploit found in the wild that
demonstrates environment matching.

© 2012, Clemens Kolbitsch. Under license to IEEE.
DOI 10.1109/SP.2012.48

443

is able to detect considerably more malware without any
noticeable overhead on most sites. The goal of our work is
to increase the eﬀectiveness of a dynamic crawler searching
for malware so as to imitate multiple browser and envi-
ronment conﬁgurations without dramatically reducing the
throughput.

A. Contributions

This paper makes the following contributions:
• Insight. We observe that typical JavaScript malware
tends to be fragile; in other words, it is designed to
execute in a particular environment, as opposed to
benign JavaScript, which will run in an environment-
independent fashion. In Section II, we experimentally
demonstrate that the fragility metric correlates highly
with maliciousness.

• Low-overhead multi-execution. We describe Roz-
zle, a system that ampliﬁes other static and dynamic
malware detectors. Rozzle implements lightweight
multi-execution for JavaScript, a low-overhead spe-
cialized execution technique that explores multiple
malware execution paths in order to make malware
reveal itself to both static and runtime analysis.

• Detection eﬀectiveness. Using 65,855 JavaScript
malware samples, 2.5% of which trigger a runtime
malware detector, we show that Rozzle increases
the eﬀectiveness of the runtime detector by almost
a factor of seven. We also show that Rozzle increases
the detection capability of static and dynamic mal-
ware detection tools used in a dynamic web crawler,
increasing runtime detections over three-fold and stat-
ically ﬁnding 5.6% more malicious URLs. Further-
more, in our experience, Rozzle does not introduce
any new false positives.

• Runtime overhead. Using a collection of 500 repre-
sentative benign web sites, we show that the median
CPU overhead is 0% and the 80th percentile is 1.1%.
The median memory overhead is 0.6% and the 80th
percentile is 1.4%. The average overhead is slightly
higher, because of a few outliers: the CPU overhead
averages 10% and the memory overhead of using
Rozzle is 3% on average.

• New attack directions. We outline attack strategies
that are not detectable with the current generation of
static and runtime malware detection tools and use
these attacks as a motivation and a quality bar for
Rozzle’s design.

B. Paper Organization

The rest of the paper is organized as follows. Section II
gives some background information on JavaScript exploits
and their detection. Section III gives an intuitive overview
of Rozzle. Section IV describes the implementation of our
analysis. Section V describes our experimental evaluation.
Section VI outlines approaches to creating more powerful

f l a s h _ p l u g i n = " 0 " , v i d e o _ p l u g i n = " 00 " ;

v i d e o _ p l u g i n = " 01 "

q u i c k t i m e _ p l u g i n = " 0 "+ q u i c k t i m e _ p l u g i n ;

p l u g i n _ n a m e . in d e x O f ( " S h o c k w a v e F l a s h " ) != -1)

f l a s h _ p l u g i n = ge t _ v e r ( n a v i g a t o r . p l u g i n s [ i ]. description ,4);

else if ( wi n d o w . n a v i g a t o r . j a v a E n a b l e d && j a v a _ p l u g i n == 0 &&

p l u g i n _ n a m e . i n d e x O f ( " Java " ) != -1)

j a v a _ p l u g i n = ge t _ v e r ( n a v i g a t o r . p l ugins [ i ]. description ,4);

}

else if ( p l u g i n _ n a m e . i n d e x O f ( " 7 " ) != -1)

a d o b e _ p l u g i n = " 07 " ;

else

}
if ( a d o b e _ p l u g i n == " 00 " &&

a d o b e _ p l u g i n = " 05 " ;

else
if ( p l u g i n _ n a m e . in d e x O f ( " 6 " ) != -1)

a d o b e _ p l u g i n = " 06 " ;

a d o b e _ p l u g i n = " 01 " ;

} else {
if ( f l a s h _ p l u g i n == " 0 " &&

p l u g i n _ n a m e . in d e x O f ( " Adobe Acrobat " ) != -1) {

p l u g i n _ n a m e = n a v i g a t o r . p l u g i n s [ i ]. d e s c r i p t i o n ;
if ( p l u g i n _ n a m e . in d e x O f ( " 5 " ) != -1)

var helper = parseInt ( p l u g i n _ n a m e . re p l a c e (/\ D /g , " " ));
if ( helper > 0) q u i c k t i m e _ p l u g i n = helper . toString (16);

var p l u g i n _ n a m e = n a v i g a t o r . pl u g i n s [ i ]. name ;
if ( q u i c k t i m e _ p l u g i n == 0 &&

p l u g i n _ n a m e . in d e x O f ( " Q u i c k T i m e " ) != 1) {

1 var q u i c k t i m e _ p l u g i n = " 0 " , a d o b e _ p l u g i n = " 00 " ,
2
3
4 f u n c t i o n g e t _ v e r s i o n (s , m a x _ o f f s e t ) { ... }
5
6 for ( var i = 0; i < n a v i g a t o r . p l u g i n s . l e n g t h ; i ++) {
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33 }
34
35 if ( n a v i g a t o r . m i m e T y p e s [ " video /x - ms - wmv " ]. e n a b l e d P l u g i n )
36
37
38 while ( q u i c k t i m e _ p l u g i n . length < 8)
39
40 while ( f l a s h _ p l u g i n . l e n g t h < 8)
41
42 while ( j a v a _ p l u g i n . length < 8)
43
44
45 var f i n g e r p r i n t = " Q "+ q u i c k t i m e _ p l u g i n + " 9 "+ v i d e o _ p l u g i n +
46
47
48 var s y s t e m _ l a n g u a g e ;
49 if (!( s y s t e m _ l a n g u a g e = n a v i g a t o r . s y s t e m L a n g u a g e ))
50
if (!( s y s t e m _ l a n g u a g e = n a v i g a t o r . u s e r L a n g u a g e ))
51
52
53 if ( s y s t e m _ l a n g u a g e ) {
54
55
56
57
58
59
60
61
62
63 }
64
65 // send out a r e q u e s t that de p e n d s on g e n e r a t e d f i n g e r p r i n t
66 f e t c h _ e x p l o i t ( f i n g e r p r i n t );

var l = s y s t e m _ l a n g u a g e . c h a r C o d e A t ( i ). t o S t r i n g (16);
if ( l < 2) l a n g u a g e += " 0 ";
l a n g u a g e += l ;

s y s t e m _ l a n g u a g e = s y s t e m _ la n g u a g e . s u b s t r (0 ,10);
var l a n g u a g e = " ";
for ( var i = 0; i < s y s t e m _ l a n g u a g e . length ; i ++) {

}
while ( l a n g u a g e . le n g t h < 20) l a n g u a g e += " 00 " ;
f i n g e r p r i n t += " L " + l a n g u a g e

if (!( s y s t e m _ l a n g u a g e = n a v i g a t o r . b r o w s e r L a n g u a g e ))

s y s t e m _ l a n g u a g e = n a v i g a t o r . l a n g u a g e ;

" 8 "+ a d o b e _ p l u g i n + " F "+ f l a s h _ p l u g i n + " J "+ j a v a _ p l u g i n ;

f l a s h _ p l u g i n = " 0 "+ f l a s h _ p l u g i n ;

j a v a _ p l u g i n = " 0 "+ j a v a _ p l u g i n ;

Fig. 2: Sophisticated environment ﬁngerprinting.

attacks that use cloaking to hide from the current gen-
eration of malware detection tools. Section VII discusses
the limitations of Rozzle and illustrates real instances
of cloaking, discussed in more detail
in a companion
technical report [20]. Section VIII discusses related work,
and, ﬁnally, Section IX concludes.

II. Background

In the last several years, we have seen web-based mal-
ware experience a tremendous rise in popularity. Much
of this is due to the fact that JavaScript, a type-safe
language, can be used as a means of mounting drive-by
attacks against web browsers. A prominent example of

444

such attacks is heap spraying [29, 33], where many copies
of the same shellcode are copied all over the browser
heap before a jump to the heap is triggered through a
vulnerability in the browser. This exploitation technique
showcases the expressive power of a scripting language,
since copying of the shellcode is typically accomplished
with a single for loop.

Previous work on runtime heap spraying detection [26]
and static malware detection [12] suggests that there are
millions of malicious sites containing heap spraying as
well as other kinds of JavaScript-based malware, such
as scareware. Previous reports point out the prevalence
of JavaScript malware cloaking [3, 10, 36]. Our experience
indicates that various forms of cloaking, environment
matching, or ﬁngerprinting are virtually omnipresent in
today’s JavaScript malware. In fact, as we discovered,
the degree to which a particular piece of code depends
on the environment in which it runs — code fragility —
is an excellent indicator of maliciousness; most benign
code is environment-independent, whereas most malicious
code contains at least some form of cloaking, environment
matching, or ﬁngerprinting.

A. JavaScript Malware: An Example of Real-Life Malware
To give the reader a better understanding of speciﬁc
problems that our work addresses, we present an example
of browser ﬁngerprinting code found in the wild. A cleaned
up version of this example, shown in Figure 2, employs
precise ﬁngerprinting to deliver only selected exploits that
are most likely to successfully attack the client browser.
Lines 1–33 compile the portion of the ﬁngerprint that
records the presence of the Adobe Acrobat, Quicktime,
and Java plugins. Lines 35–36 record the presence of
the Windows Media Player. Lines 45–46 construct the
ﬁngerprint string variable and lines 48–63 augment it with
the browser language. Finally, line 66 issues a request to a
malware hosting site to fetch the malware that corresponds
to the computed ﬁngerprint.

B. Current Practices: Matching, Cloaking, Fingerprinting
Based on our experience with speciﬁc malware samples
such as the example above, we distinguish between three
categories of techniques commonly used in today’s mal-
ware: environment matching, ﬁngerprinting, and cloaking.
Environment matching: Figure 1 shows a typical exam-
ple of environment matching, found in most of the malware
we ﬁnd in the wild. In this case, the script determines
the capabilities of the browser and selectively alters the
content of the page, such as showing a movie.
Fingerprinting: Browser ﬁngerprinting is a technique in
which a variety of environment variables are evaluated to
assess the capabilities of the browser. In contrast to envi-
ronment matching, browser ﬁngerprinting is more compre-
hensive and detailed in its assessment. Privacy advocates
show that browser ﬁngerprinting can be used to track users
across sessions without the help of cookies as browsers

carry unique information that results in unique ﬁnger-
prints [14, 24]. Malware writers also use ﬁngerprinting, as
illustrated in Figure 2, to deliver malware customized for
a particular browser conﬁguration or, perhaps, even in the
case of targeted attacks, for a particular user.
Cloaking: Cloaking is a technique to show diﬀerent con-
tent depending on conditions reﬂecting who is visiting the
site. Oﬄine malware scanning is used routinely to compile
black lists of malicious URLs [25, 26]. In this scenario,
cloaking can be successfully used by malware writers to
avoid being detected when the malware-detecting crawler
visits a particular site. Cloaking occurs with server-side
and client-side variants. Server-side cloaking works by
treating certain categories of HTTP headers or IP ad-
dresses, such as those coming from security vendors, dif-
ferently. Client-side cloaking implements cloaking using
JavaScript that detects crawlers by indentifying client-side
characteristics that are unique to them. For example, a
common crawler optimization is to avoid loading images
to save bandwidth. We have observed malware that checks
if images have been successfully loaded before executing its
attack.

C. Code Fragility Experiment

Our

experience with malware

that
environment-dependent
In
this section, we measure the prevalence of environment
sensitive JavaScript code.

indicates

code

is often malicious.

Using a simple ad hoc static analysis tool designed
to process JavaScript abstract syntax trees (ASTs), we
experimentally analyze the frequency with which both
benign and malicious sites get access to environment-
speciﬁc data that could be used to identify the browser,
browser version, installed plugins, the operating system,
or even the CPU architecture. We conclude that, indeed,
code fragility is an excellent measure of maliciousness.
Fragility detection tool: To evaluate our hypothe-
sis, we constructed a simple static analysis tool for de-
termining what conditionals (ifs) in JavaScript code
are environment-dependent. The tool works by statically
tainting values [34] that are dependent on the navigator
object and its ﬁelds as well as values that come from
ActiveXObject calls. Taint is conservatively propagated
through unary and binary string operations such as trim
and string concatenation, as well as assignments.
Experimental results: We start with a set of 38.9 mil-
lion JavaScript code snippets, representing all JavaScript
presented for execution, from 2.8 million unique URLs.
The set contains 2,373 JavaScript ﬁles that were ﬂagged by
Zozzle [12], a static malicious JavaScript detector, and 194
ﬁles ﬂagged by a simple static classiﬁer-based detector
trained only to detect code fragility. These 194 ﬁles are
a strict subset of the 2,373 ﬁles detected by Zozzle. A
summary of this data is presented in Figure 3.

The ﬁgure shows the number and fraction of ﬁles that
have particular characteristics. The three main columns,

445

Documents
Reference
Branch

ActiveXObject
navigator
navigator.plugins
navigator.mimeTypes
navigator.javaEnabled
navigator.userAgent
navigator.language
navigator.platform
navigator.appVersion
window
document
document.location
ScriptEngine

All

Malicious

Static fragility

38,930,392
2,993,848
466,228
440,508
151,788
129,326
63,086
55,526
45,928
40,723
27,408
9,075
3,107
1,182
391
110

100.00%
7.69%
1.20%
1.13%
0.39%
0.33%
0.16%
0.14%
0.12%
0.10%
0.07%
0.02%
0.01%
0.00%
0.00%
0.00%

2,373
2,123
2,123
2,100
1,462
1,444
1,444
1,091
372
0
0
0
0
0
0
0

100.00%
89.46%
89.46%
88.50%
61.61%
60.85%
60.85%
45.98%
15.68%
0.00%
0.00%
0.00%
0.00%
0.00%
0.00%
0.00%

194
194
194
194
147
147
147
119
28
0
0
0
0
0
0
0

100.00%
100.00%
100.00%
100.00%
75.77%
75.77%
75.77%
61.34%
14.43%
0.00%
0.00%
0.00%
0.00%
0.00%
0.00%
0.00%

Fig. 3: Measuring code fragility: Environment usage statistics across diﬀerent categories of code.

“All”, “Malicious” and “Static fragility”, show the fractions
of the total with respect to the diﬀerent subsets. The
“All” column represents all ﬁles, “Malicious” represents
the subset ﬂagged as malicious by Zozzle, and “Static
fragility” represents the subset ﬂagged by a special static
detector, similar to Zozzle, that we trained explicitly just
to detect JavaScript that has control dependences on its
environment. The “Reference” row shows those ﬁles where
the navigator object or plugins are explicitly referenced.
The “Branch” row shows those ﬁles where conditional ex-
pressions are based on the values of the navigator object
or the presence or versions of plugins. The remaining
rows break out the branches into the number of uses of
speciﬁc ﬁelds of navigator and other environment-related
variables. We highlight our observations below:

• Only

7.7% of

all

JavaScript

reference
environment-speciﬁc values. This number
is an
estimate of the fraction of ﬁles that would require
multi-execution
potential malicious
behavior.

expose

ﬁles

to

• In 1.2% of all ﬁles, there is a branch on a symbolic
value. Because branches require explicit action during
multi-execution, these ﬁles will incur an additional
cost in Rozzle.

• We observe that 98.8% of malicious ﬁles (as ﬂagged
by the Zozzle classiﬁer) reference the JavaScript
environment, 89.5% get a reference to something we
would treat as symbolic (XML-RPC ActiveX objects,
as well as document and window objects account for
the remaining 9.3% which we do not consider to leak
sensitive information). The same 89.5% of malicious
ﬁles will branch on these conditions.

• The static fragility detector triggered on fewer ﬁles
than Zozzle, but the ﬁles detected were a complete
subset of the malicious ﬁles detected by Zozzle, indi-
cating that ﬁles with signiﬁcant dependences on the
environment are almost always malicious.

This analysis provides experimental support for our intu-

Avoidance
technique

Envir. testing
Fingerprinting

Cloaking (client)
Cloaking (server)

Works against
Static
Dyn.

Rozzle improves
Dyn.

Static

yes
yes

yes
yes

no
yes

yes
yes

yes
yes

yes
no

yes
yes

yes
no

Fig. 4: How avoidance strategies (Section II-B) work against
dynamic and static malware detection techniques and how
Rozzle improves existing detection techniques.

itive understanding: exploits are environment-dependent.

III. Overview

Section III-A covers existing techniques and outlines
their shortcomings. Section III-B describes the basics of
Rozzle. Finally, Section III-C provides a detailed example
of multi-execution.

A. Challenges and Existing Techniques

While static analysis is a powerful technique that al-
lows one to explore all program paths, a particular issue
that plagues static analysis in the context of malicious
JavaScript is that we are unable to observe all code. Run-
time evaluation has been advocated in this context [12, 17],
but runtime execution suﬀers from the issue of low path
coverage. A speciﬁc example is JavaScript malware that is
triggered only when the user hovers over a particular UI
element. This malware would generally not be exposed in
the context of oﬄine detection. A number of approaches
to improve runtime path coverage exist, as detailed in the
rest of this subsection.
Large-scale distributed setup: Machine clusters run-
ning diﬀerent environment conﬁgurations are traditionally
used for oﬄine malware scanning, detection, and analysis.
There are a number fundamental problems with this ap-
proach, however.

• Scalability and ineﬃcient use of resources.
While it is feasible to deploy a number of machines

446

e
c
a
r
t
 
l

a
i
t
i
n

I

e
c
a
r
t
 
t
c
a
r
t
s
b
A

JavaScript 
runtime with 

Rozzle

outputi(e)

e
c
a
r
t
 
d
e
z
i
t
e
r
c
n
o
C

                                                output policy L                                               output policy L

outputj(e)

outputi(L(e, i, π ))

outputj(L(e, i, π ))

Fig. 5: Rozzle architecture as a series of trace rewriting steps.

using diﬀerent operating systems as well as browser
manufacturers or versions, there are a number of
other factors that need to be considered. For example,
the availability of certain add-ons (such as Adobe
Flash or the Java runtime) can have a great im-
pact on how a browser renders or interacts with a
remote server. The combinatorial growth of possible
plugin version/browser/browser version combinations
dictates the use of only the most popular environment
conﬁgurations. In practice, this approach linearly ex-
pands the requirements on scanning hardware, net-
work bandwidth, and power.

• Overkill. The ability to detect malicious pages that
selectively target a particular type of browser requires
re-scanning the same page. As shown in the previous
section, only a very small fraction of sites found today
make use of environment ﬁngerprinting. Thus, deploy-
ing large clusters of computers re-scanning the same
page and getting the same result is highly unproﬁtable
and constitutes a waste of resources.

• Server load. Since multiple re-scans of the site are
necessitated by this approach, load on analyzed web
servers is increased. Note that we cannot cache server
responses, as they might be user agent-speciﬁc. This
may lead to the server refusing to accept connections
from our oﬄine scanner.

• Incomplete attack surface. Any pre-deﬁned
browser setup can only handle a known set of browsers
and plugins. Thus, there is no guarantee that this
setup will detect vulnerabilities in less popular plugins
that could be used in targeted attacks against a small
group of victims using known browser conﬁgurations.

Traditional symbolic execution: More recently, re-
searchers have tried applying techniques of symbolic ex-
ecution [5, 7, 8, 16] to the task of exposing malware [5, 23].
This approach, while increasing the coverage, suﬀers from
scalability challenges and is, in many ways, unnecessarily
precise. Indeed, with a very precise runtime or static
detector, malicious behavior is so uncommon that the issue
of feasible paths is a relatively small concern.

if ( n a v i g a t o r . u s e r A g e n t == " safari " ) {

s h e l l c o d e = u n e s c a p e ( " 1... " );

} else {

s h e l l c o d e = u n e s c a p e ( " A ... " );

}

Fig. 6: Simple example of the use of symbolic values.

B. Rozzle Architecture and Overview

Rozzle is an enhancement or ampliﬁcation technology,
designed to improve the eﬃcacy of both static and runtime
malware detection. Figure 4 summarizes how existing
malware detection techniques are aﬀected by avoidance
strategies in Section II-B and how Rozzle improves exist-
ing detection techniques. Rozzle is eﬀective at improving
both static and runtime detection. However, Rozzle is
helpless at avoiding server-side cloaking.

Multi-execution explained: The key idea behind Roz-
zle is to execute both possibilities whenever it encounters
control ﬂow branching that is dependent on the envi-
ronment. For example, in the case of the if statement
shown in Figure 6, Rozzle will execute both branches, one
after another. Some readers might wonder if this creates a
dependency on the order in which Rozzle will execute the
then and the else branch. A key insight is that in this
case we need to perform weak updates. In other words,
the second assignment to variable shellcode does not
override, but adds to the ﬁrst value. This is like using gated
SSA form [32] in optimizing compilers, except in the case
of Rozzle, SSA construction happens at runtime.

Rozzle architecture: Figure 5 provides an overview of
the Rozzle architecture. Rozzle augments the semantics
of a regular JavaScript interpreter by introducing addi-
tional statements in the execution that correspond to
multiple symbolically executed paths, transforming the
initial trace on the left hand side of the ﬁgure, into the
abstract trace in the middle. The abstract trace simulta-
neously captures the values of symbolic variables that are
dependent on diﬀerent program paths, but these abstract
values must be made concrete when their values are used,
for example, in network communications or with the DOM.

447

At such output statements, symbolic values are made
concrete according to an output policy L, which is a
function of the expression, e, the kind of output being
done, i, and the environment, π.

C. Detailed Example of Multi-Execution

To build-up the reader’s intuition, we now show a
more involved example of how Rozzle transforms execu-
tion. Figure 7 provides an illustrative example of multi-
execution in action on a simpliﬁed code excerpt extracted
from the ﬁngerprinting routine in Figure 2. Figure 7(a)
shows the original program. On line 9, we output the
computed value qt plugin. Figure 7(b) shows the eval-
uation function computed by Rozzle to symbolically rep-
resent the computed result of qt plugin. Note that the
evaluation function is parameterized with the navigator
object, whose plugins array is used in the function code.
Conditionals in the evaluation function correspond to
conditional statements in the original program. While this
is outside the scope of this paper, note that evaluation
functions may be analyzed entirely statically using one of
the proposed approaches in the literature [4] to determine
all potential outputs, to determine which inputs may lead
to a particular output. Finally, Figure 7(c) shows the
symbolic value the way it is represented by Rozzle. Once
again, the symbolic evaluation tree directly matches the
structure of the evaluation function in Figure 7(b), with
leaves contributing the potential values of the output,
which are either the result of evaluating

p a r s e I n t ( name . re p l a c e (/\ D /g , " " )). t o S t r i n g (16)

var helper = parseInt ( name . replace (/\ D /g , " " ));
if ( helper > 0){

1 var q t _ p l u g i n = " 0 ";
2 var name = n a v i g a t o r . p l u g i n s [0]. name ;
3 if ( q t _ p l u g i n == 0 && name . i n d e x O f ( " Q u i c k T i m e " ) != -1) {
4
5
6
7
8 }
9 o u t p u t ( q t _ p l u g i n );

q t _ p l u g i n = h e l p e r . t o S t r i n g (16)

}

(a) Original program.

var name = n a v i g a t o r . p l u g i n s [0]. name ;
return ( " 0 " == 0 && name . indexOf ( " Q u i c k T i m e " ) != -1) ?

1 f u n c t i o n ( n a v i g a t o r ) {
2
3
4
5
6
7
8 }

" 0 " :

" 0 ";

p a r s e I n t ( name . r e p l a c e (/\ D /g , " " )) ?

p a r s e I n t ( name . r e p l a c e (/\ D /g , " " )). t o S t r i n g (16) :

(b) Evaluation function.

condExpr

?

boolExpr

!=

condExpr

?

“0”

numExpr

indexOf

-1

numExpr

stringExpr

name

stringExpr

“QuickTime”

stringExpr

numExpr

parseInt

stringExpr

toString

stringExpr

“0”

or "0".

stringExpr

replace

numExpr

parseInt(…)

16

numExpr

IV. Techniques

stringExpr

This section focuses on the details of multi-execution,
covering both the fundamental principles and the de-
tails of Rozzle implementation on top of the Chakra
JavaScript engine in Internet Explorer 9. This section
is organized as follows: Section IV-A describes how we
construct and manipulate symbolic values. Section IV-B
elaborates challenges faced with a na¨ıve implementation
of multi-execution. Section IV-D discusses “concretizing”
symbolic values on-demand. Section IV-E discusses the
details of multi-execution in Rozzle. Finally, Section IV-F
talks about our implementation built on top of IE 9.

A. Symbolic Values

Like traditional approaches

to symbolic execution
(e.g., [16, 18], our analysis treats speciﬁc values during
execution as symbolic. Unlike traditional approaches to
symbolic execution, however, that emphasize represent-
ing only sound and feasible executions, as the cost of
performance overhead, our analysis allows unsound and
infeasible executions with the beneﬁt of increased perfor-
mance. In Rozzle, path exploration is achieved through
executing multiple branches in the course of a single
modiﬁed execution, using symbolic heap values to reﬂect

name

/\\D/g

""

stringExpr

stringExpr

(c) Symbolic value for output represented as a parse tree in the
grammar shown in Figure 8. Concrete values (leaf nodes) are shown
in black. The triangle represents a subtree rooted at a parseInt node,
identical to the subtree to the left of the triangle.

Fig. 7: Example of multi-execution.

multiple program outcomes. For example, the merge of two
versions of shellcode in

Figure 6 gives rise to a symbolic value that is created

at runtime after the if/else construct:

shellcode3 = navigator.userAgent=="safari" ?

shellcode1,shellcode2

Note the merge of the weak updates in the conditional
due to the dependency on the userAgent string. In
general, objects that provide environment-speciﬁc data
come in a variety of diﬀerent basic as well as complex
object types, such as strings (e.g., userAgent), integers
(ScriptEngineVersion), and objects (supported mime-

448

Expressions
symExpr

::= numExpr | stringExpr | boolExpr

| memberCall | f uncCall | (cid:2)
| condExpr | concretize(symExpr)

condExpr
binaryExpr

::= boolCond ? symExpr : symExpr
::= symExpr binaryOp symExpr

f uncCall
memberCall
paramExpr

::= f unc ( paramExpr )
::= symExpr . f unc ( paramExpr )
::= symExpr | symExpr , paramExpr

Booleans

boolCond

boolExpr

Numerics

numExpr

::= boolExpr | ¬boolExpr
| symExpr ∨ symExpr
| symExpr ∧ symExpr
| symExpr boolOp symExpr
| isSymbolic(symExpr)

::= true | false

::= numericF unc(symExpr) | 1 | 2 | . . .

| numExpr binaryOp numExpr
| − numExpr
| parseInt(stringExpr)
| indexOf(stringExpr, stringExpr)
| abs(numExpr)
| min(numExpr, numExpr)
| . . .

String expressions

stringExpr

::= stringF unc(symExpr) | "" | . . .

| encodeURI(stringExpr)
| decodeURI(stringExpr)
| substr(stringExpr)
| concat(stringExpr, stringExpr)
| replace(stringExpr, stringExpr)
| replace(/stringExpr/, stringExpr)
| toString(numExpr)
| toString(numExpr, numExpr)
| . . .

Operators

binaryOp
boolOp

::= + | − | ∗ | / | % | << | >>
::= = |
(cid:5)= | < | <= | > | >=

Fig. 8: BNF for symbolic expressions used in Rozzle. The
start symbol is symExpr.

types) or ActiveXObjects. Dynamically-typed languages
are especially well-suited to having symbolic heap values,
so the approach we outline here is equally appropriate
for JavaScript, Python, Ruby, or Perl. When representing
symbolic values at runtime, within the JavaScript heap, we
introduce a new JavaScript object type, symbolicWrapper
that contains the information that it is wrapping (e.g., a
userAgent string) as well as the current concrete type.
Initially, each symbolic wrapper has the runtime type
of the wrapped object (e.g., string when wrapping a
navigator.userAgent string value).

symbolic: All

Marking values as
environment-
speciﬁc values start out as symbolic in Rozzle. For
example, navigator.userAgent is treated symbolically,
whereas the string "0" is not. This is quite similar to
runtime tainting. In Rozzle, taint originates with the

ﬁelds of the navigator object. Additionally, we mark
functions ActiveXObject,
as symbolic the results of
ScriptEngineMajorVersion,
ScriptEngine,
ScriptEngineMinorVersion,
and
ScriptEngineBuildVersion in the engine.

B. Challenges

While the basic idea of maintaining symbolic values
on the heap is straightforward, any implementation must
address some fundamental challenges, including the follow-
ing:

• Looping on a symbolic value: When looping on a
symbolic value, how many iterations do we need to
perform?

• Writing symbolic values to the DOM: Symbolic
values represent multiple concrete ones, so which of
the concrete values do we write out to the DOM?

• Output operations on symbolic values: What if
a symbolic value is used to compute the URL that
the program is reading data from? How do we make
these network requests concrete? Do we consider all
of them?

• Limiting the size of symbolic values within the
heap: When representing the symbolic heap na¨ıvely,
there is a very real possibility of running out of
memory, because of the extra context provided by the
symbolic values.

• Introducing errors: Rozzle may introduce new
errors in correct code. One key reason is that Rozzle
may expose diﬀerences in browser implementations,
executing paths that would otherwise be infeasible.

C. Symbolic Values: Manipulation and Representation

Figure 8 summarizes a grammar that captures symbolic
values that may be created by Rozzle at runtime. We
provide this in the form of a BNF grammar where symExpr
is the start symbol; symbolic value trees that are created
at runtime can be seen as parse trees for expressions
in this grammar. Grammar elements such as condExpr ,
numericExpr , or stringExpr give rise to intermediate tree
nodes, as shown in Figure 7(c). Elements memberCall and
funcCall are slightly more complicated. Whenever there is
a call to a property of the object (i.e., a member function),
we need to check if the current concrete type supports this
method. If so, the output is a symbolic object representing
the result of calling the function on the given object. This
produces an AST of symbolic objects where each node in
the tree contains a function and sub-ASTs for each call
parameter.

Depth limiting: When creating new symbolic values, we
are careful to limit the depth of resulting symbolic trees.
One of the common reasons this comes up is because of
symbolic values updated in a non-symbolic loop, which
leads to the creation of unbounded nested trees. Our
solution is to collapse the entire tree the moment its depth

449

exceeds a ﬁxed threshold and represent is as a special
symbolic value (cid:3).

stmt

::= var = symExpr | var.f ield = symExpr

| if (symExpr) then stmt else stmt
| while (symExpr) stmt
| symExpr = symExpr(symExpr, . . . , symExpr)
| output (symExpr)

Fig. 9: Statements in our program representation.

using this method and ignore the rest. We leave the gen-
eration of multiple concrete values and their prioritization
for future work.

E. Details of Multi-Execution

Figure 10 shows pseudo code for our multi-execution
engine. The inputs of the algorithms are program P , which
is a collection of statements stmt 1, . . . , stmt n, browser
proﬁle π, an output policy L, and a side-eﬀect hash map
mod .

The proﬁle contains speciﬁc details of the environment
such as the userAgent string, the plugins array and the
data accessible from it, the major and minor version of the
JavaScript engine, etc. The output policy L deﬁnes how to
concretize a particular value e at output statement i given
proﬁle π, and themod
hash map. Many policies exist,
including concretizing e with respect to π, sequentially
outputting all concrete values in e, etc.

Function isSymbolic is a runtime check that returns
whether the value passed in should be treated symboli-
cally. The algorithm in Figure 10 consists of an interpreter
loop that handles the cases of an if conditional, a loop, etc.
in turn.
Branching on symbolic values: When code branches on
a symbolic value, we need to make a decision which branch
to take. Because our goal is to detect possible malicious
behavior down any path, despite potential unsoundness,
Rozzle executes both cases. We do this by maintaining a
symbolic stack of conditions that must be fulﬁlled to reach
the current point in the execution. Considering Figure 11,
the if/else block would have an active symbolic value of
fingerprint.indexOf(IE) >= 0 and any variable assign-
ment within this block will need to respect this condition.
Thus, when we assign to either a variable or a heap object
of the form object.f ield outside this block, it will be made
into a conditional symbolic value. Before executing the
else branch, the active element on the symbolic-condition
stack is inverted. Assignments to variables are merged
when one sees that it is a reference to a variable that
is already conditional on a symbolic. This means, after
executing the above block, variable isIE would hold

isIE = ( x . indexOf ( " IE " ) >= 0) ? true : false ;

Note that this form of multi-execution when both branches
are followed is only performed with the conditional
is
symbolic, which in practice happens quite rarely for benign
programs. As mentioned before, in Rozzle, we execute
branches that are dependent on symbolic variables se-
quentially, one after another. To support weak updates

Symbolic value compression: A challenge that we have
to address when dealing with large JavaScript programs
that have a lot of tainted branches is to keep the size
of symbolic value trees small. Our approach to reducing
the memory footprint of Rozzle involves using a canonical
representation for data structures used to represent sym-
bolic values, in a manner similar to decision diagrams [6],
etc. This way, symbolic values will share some of the
subtrees, as illustrated with the triangle in Figure 7. In
Rozzle, somewhat akin to [16], we keep a pool of allocated
symbolic values and, whenever creating a new conditional
value, consult the list to see if the sub-components of
the conditional are already found in the pool. Compar-
isons against existing pool elements are very fast and are
currently done via a depth-ﬁrst explicit comparison; an
alternative involves using hashing and a lookup table for
the same purpose.

D. Resolution of Symbolic Values

While the use of symbolic values in Rozzle allows us
to explore more code paths than can be observed through
a single concrete execution based on one particular en-
vironment, there exist cases where we need to obtain
concrete values in the JavaScript engine from symbolic
values constructed by Rozzle. Typically this happens,
when an object is passed from the JavaScript engine
to another browser subsystem (e.g., during modiﬁcations
of the DOM, when browsing to a new URL containing
symbolic path elements, requesting new content from the
web, etc.) Figure 7(c) shows a graphical representation
of a variable in symbolic memory. When Rozzle requires
concrete values (e.g., when passing a symbolic variable
outside the JavaScript engine), it traverses the tree in
memory and generates code as seen in Figure 7.

Value concretization is required when the program in-
teracts with various IO subsystems within the browser
such as the DOM, sending data on the network or open-
ing an new URL. The exact concretization approach is
an implementation choice, governed by a concretization
policy L, as shown in Figure 5. Accurate value concretiza-
tion is not necessary to achieve signiﬁcant experimental
success with Rozzle. Speciﬁcally, many malicious exploits
of the environment-matching variety are exposed to either
a static or dynamic malware detector if the code that
introduces them is executed in any event. However, sophis-
ticated attacks using enviornment ﬁngerprinting as shown
in Figure 2 do require systematic concretization.

We represent proﬁles as collections of independent parts
(e.g., user agents, ActiveX objects, etc.) and at each
output apply the set of parts to the symbolic expression,
selecting parts (e.g, “IE6”) using brute-force search for
values that are consistent with the constraints in the path
expression. We take the ﬁrst consistent output that results

450

MultiExecute(P = {stmt 1, . . .stmt n}, π, L,Γ =default(globalObject ))

case if (e) then Tt else Tf

if isSymbolic(e) then

Γt = []
Γt.prototype = Γ
MultiExecute(Tt, π, L,mod t)
Γf = []
Γf .prototype = Γ
MultiExecute(Tf , π, L,mod f )
Γ =Range (Γt) ∩ Range(Γf )
for all v in Γ do
Γ[vt] = Γt[v]
Γ[vf ] = Γf [v]
Γ[v] =φ (e, vt, vf )

Γ[v] =φ (e, v, vt)

end for
for all v in (Range(modt ) \ Γ) do
end for
for all v in (Range(modf ) \ Γ) do
end for

v = φ(¬e, v, vf )

if e then

Tt

else

else

Tf
end if

end if
end case

1: for i=1 . . . n do
switch stmt i :
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22:
23:
24:
25:
26:
27:
28:
29:
30:
31:
32:
33:
34:
35:
36:
37:
38:
39:
40:
41:
42:
43:
44:
45:
46:
47:
48:
49:
50:
51:
52:
53:
54:
55:
56:
57:
58:
59:
60:
61: end for

end if
lend :
end case
case v = e
Γ[v] =e
end case

end if

else

else

case v1 = v2

Γ[v1] = Γ[v2]
end case

case output(e)

L(e, i, π, Γ)()
end case
end switch

case while(e) do T

lhead :
if isSymbolic(e) then
(cid:2)
= []
Γ
(cid:2).prototype = Γ
Γ
MultiExecute(T, π, L, Γ
) do
for all v in Range(Γ
[v], Γ[v])

(cid:2)
Γ[v] =φ (e, Γ

(cid:2)

(cid:2)

)

end for
goto lend

if e then

T
goto lhead

goto lend

1 var x = f i n g e r p r i n t ;
2 var isIE ;
3 if ( x . indexOf ( " IE " ) >= 0) {
4
5 } else {
6
7 }

isIE = false ;

isIE = true ;

Fig. 11: Symbolic execution: a simple if.

stack with the new condition. When leaving the symbolic
branch (i.e., after executing the last branch conditioned
under the symbolic predicate), the symbolic condition is
popped from the stack. Within a symbolic branch, weak
updates are used for both variable assignments and heap
object stores. For this, the current path condition (i.e., the
conjunction of all elements of the path predicate stack) is
used to build the tree of symbolic memory as described
above. The pseudo code for handling conditionals is shown
in lines 3–30 of Figure 10.
Looping on symbolic values: Handling symbolic loops
presents probably the most complex case for Rozzle to
address. To simplify our discussion, we assume that we
are dealing with a while-loop with a conditionale and
body B. The pseudo code for handling loops is shown in
lines 31–60 of Figure 10. The intuitive idea is to rewrite
the trace corresponding to the loop into an augmented
trace which, at every loop iteration checks to see if the
loop conditional e is symbolic. Note that e may become
symbolic after several iterations. If that happens, we will
proceed to treat loop updates as weak updates using mask
mod and to terminate the execution of the loop after one
(symbolic) iteration. If the conditional e is not symbolic,
we will proceed to execute as usual, until either the loop
terminates on line 39 or the loop conditional becomes
symbolic.

F. Prototype Implementation in Chakra

Our implementation of Rozzle is based on Chakra, the
Internet Explorer 9 JavaScript execution engine. Chakra
supports a wide range of non-standardized JavaScript
methods and objects. This is important because using IE,
we can more successfully pretend to be a diﬀerent browser
and have more methods available to call than in other
settings, leading to fewer errors introduced by Rozzle. An-
other reason for choosing Chakra is its performance [21].
When Rozzle needs to resolve symbolic variables into
concrete values, we use the JavaScript engine: symbolic
memory is represented as a new JavaScript type and
operated on at runtime by the engine. Symbolic memory
can be directly translated into code that, given a set of
environments, produces possible concrete values, as illus-
trated in Figure 7. Below, we describe the modiﬁcations
implemented to support multi-execution in Chakra:
Symbolic memory: To represent symbolic variables in-
side the framework, we introduce a new JavaScript run-
time type symbolicWrapper. Variables of this type sup-
port all operators typically supported by other runtime

Fig. 10: Algorithm for multi-execution which takes program
P , proﬁle π, and output policy L as inputs. The last parameter
Γ is an optional in-out hash map that represents the side eﬀects
of calling MultiExecute; the default value for Γ is globalObject
that is typically the same as the window object in JavaScript.

on such code paths, we proceed as follows: Whenever a
branch is encountered and Rozzle ﬁnds that the condition
is symbolic, the condition is pushed onto a stack used to
keep track of path predicates. When executing the else-
statement of a symbolic branch, the condition on the top of
stack is inverted and used as condition for the new branch.
The else block is handled by combining the element on

451

new A c t i v e X O b j e c t ( " pdf " );
hasPDF = true ;

1 var hasPDF ;
2 try {
3
4
5 } catch ( exc ) {
6
7 }

hasPDF = false ;

Fig. 12: Symbolic execution: try/catch.

types in the language (e.g., assignments, additions, etc.),
however, they cannot be instantiated by user-provided
code directly. Any attempts of allocating such an instance
results in a runtime exception. All functions that return
values that can be used to ﬁngerprint the runtime envi-
ronment (i.e., the browser version) are modiﬁed to return
symbolic variables. Likewise, global or DOM objects (e.g.,
navigator.userAgent) produce symbolic values. Similar
to other languages that support dynamic types, JavaScript
allows us to check the type of a variable at runtime. In our
scenario, this allows an attacker aware of Rozzle to detect
and avoid execution inside our system. Although such code
would be very indicative of malicious behavior if detected,
we tackle this problem as follows: if the type of a variable of
type symbolic is queried or compared to another type using
the typeof keyword, Rozzle resolves the type that most
closely resembles the given variable (e.g., for a symbolic
variable holding the navigator.userAgent, the system
returns a string).
Function calls: Symbolic values may be passed into both
the JavaScript language and the DOM API functions
exposed by the JavaScript engine. Example of this include
concat and indexOf functions on strings. To handle such
interactions, we need to modify natively implemented
functions in Chakra to ﬁrst check if any of the parameters
is symbolic and to return a properly constructed new
symbolic value if that is the case. While this might sound
like a considerable amount of manual work, fortunately, as
most parts of the API are written in C, we only need to
insert a single macro into the prologue of each function.
Virtual branching and try/catch blocks: Exceptions
are common mechanism used by attackers to test the ca-
pabilities of the environment in which their code executes.
As a result, we need to handle this speciﬁc idiom in our
runtime. Consider the following commonly found example
shown in Figure 12. We handle this by introducing “virtual
if-blocks” after the allocation of symbolic values. We do
this by pushing a special condition onto the condition
stack after the allocation of an object that might not exist,
treating the try block as the virtual then and the catch
block as the virtual else. After theif-block, we execute
the catch block and invert the active condition (just like
in the else case). This would lead to a symbolic expression
such as

hasPDF = ( h a s _ a c t i v e X _ s u p p o r t _ p d f ) ? true : false ;

where has activeX support pdf is a special variable that
parameterizes the environment.

Local focus: Weak updates can lead to an unnecessary
loss of precision. To understand why, consider the following
loop:

for ( i =0; i <5000; i ++){

1 if ( n a v i g a t o r . u s e r A g e n t . i n d e x O f ( " safari " ) > 0){
2
3
4
5
6
7
8 }

// ignore the undef because path
// p r e d i c a t e m a t c h e s the symbolic value p r e d i c a t e
// i = i s _ s a f a r i ? 0 : undef ;
me m o r y [ i ] = nop + nop + s h e l l c o d e ;

}

Na¨ıvely, Rozzle would treat assignments to variable i
symbolically, because the loop increment is considered
to be an assignment that is control dependent on the
outcome of the if. However, for the special case of the
path predicate matching the predicate of the conditional
symbolic value, the other alternative, undef, is projected
away, and Rozzle in this case will treat loop variable i
non-symbolically. This change to the default strategy is ac-
tually quite important because treating this loop symboli-
cally means that we are not executing the loop 5,000 times
(see the discussion of looping above) and are therefore not
going to be ﬂagged at runtime by Nozzle for attempting
a heap spray attack. This form of special-casing is akin to
the notion of focus used to obtain locally precise treatment
in static analysis [15].

V. Evaluation

In this section, we evaluate the cost and beneﬁt of Roz-
zle by comparing an unmodiﬁed browser (base) against a
browser with Rozzle.

A. Improved Oﬄine Detection Rates with Rozzle

To understand if Rozzle is able to extract new run-
time behavior in real malicious scripts, we selected a set
of 65,855 web-based malware samples found in the wild
using the Zozzle static malware detector in combination
with a high-interaction client honeypot on a large cluster
of machines.

Setup: In this experiment, we take special care to mini-
mize the degree to which external inﬂuences could aﬀect
the outcome, such as site availability or modiﬁcations of
the exploits. For this, we extracted the JavaScript context
ﬂagged by Zozzle and hosted the ﬁle on a server on our
network, thus the name oﬄine experiments. We placed
the ﬁles on a local disk and visited each ﬁle as a local
URL using the high-interaction client honeypot twice, once
using its default conﬁguration using an Internet Explorer 9
proﬁle (base run) and a second time using the Rozzle-
extended version. As the client honeypot renders and
executes the page content, it scans any JavaScript contexts
found using Zozzle and also uses Nozzle to detect any
suspicious behavior during the execution of the scripts.

Results: Figure 13 shows the detection rates using the
dynamic detector, Nozzle, during the visits of our high-
interaction client honeypot. We do not include static
detection by Zozzle, as all scripts have previously been
detected by the latter. The ﬁgure shows an overview of

452

Shared

New Detections

Errors

+595% runtime detections 

10,381 

-2,000

0

2,000

4,000

6,000

8,000

10,000

12,000

Fig. 13: Oﬄine malicious-only detection: improvements.

the detection results: Nozzle triggered in 1, 662 cases
total in the base run while the second run using Rozzle
ﬂagged 11, 559 URLs (595% more detections). In 1178
cases (71%) the URL was ﬂagged in both runs, leaving 484
URLs (29%) where Rozzle introduced an error into the
script’s execution before it was ﬂagged. These results
provide valuable information to improve our prototype
implementation in the future, as discussed Section VII-A.
In contrast to the 484 introduced errors, we see that
Rozzle is able to expose new malicious dynamic activity
in 10, 381 cases. We conclude that Rozzle is successful in
increasing path coverage using multi-path execution and
that environment-sensitive malware is a real problem that
Rozzle is able to expose.

B. Improved Online Detection Rates with Rozzle

In this experiment, we collect and visit URLs hosted on
the Internet. This allows us to test if Rozzle is able to
extract previously unseen content that might be detected
using either of the detectors. Early on in the evaluation,
we found that this is not an easy task as malware hosting
servers are quite unreliable. As others have noted [38],
we encountered many malicious URLs where attacks were
served only once to a given IP address/ subnet or only once
within a given time period (e.g., using a cookie-check).
This creates the problem that depending on which conﬁgu-
ration is used ﬁrst(base versus Rozzle), that conﬁguration
may see more malware simply because the site fails to
serve the malware a second time. To make our estimates
of Rozzle’s eﬀectiveness conservative, we visit each URL
with the base conﬁguration ﬁrst. Thus, if the exploit is not
served during the second Rozzle run, we might mistake
this as an error introduced by Rozzle, but not as a new
detection. Further, we manually veriﬁed a large fraction of
the analysis results where we see a diﬀerence in the two
runs, excluding those that are caused by a clear diﬀerence
in the content served by the server.
Setup: We obtained a large set of suspicious URLs from
static analysis of web crawler content. Because our exper-
imental resources were limited, we applied blacklist-based
ﬁltering to increase the likelihood of visiting URLs hosting
malware. Each URL was checked against a list of hosts
known to serve malicious content as well as using Google’s
SafeBrowsing API. For 57, 132 URLs (approximately 0.1%
of the initial list), at least one of the checks succeeded and

24

50

174

(203% increase)

225

2,510

156

(a) Nozzle improvement rates.

(b) Zozzle improvement rates.

Fig. 14: Online general URL detection: improvement rates.

Base

Added by Nozzle

Added by Zozzle

Added by both

s
n
o
i
t
c
e
t
e
D
w
e
N

 

0

100

2,758 

76 

142 

14 

600
2,600                   2,700                  3,000                 3,100                  3,200               3,300 

300

200

400

500

Fig. 15: Online general URL detection: new detections with
Rozzle.

we visited the URL with our two experimental conﬁgura-
tions. We enabled both Zozzle and Nozzle detection in
our browsers for both conﬁgurations.
Results: Nozzle and Zozzle improvement rates for these
experiments are summarized in Figure 14(a). The dynamic
detector, Nozzle, ﬂagged 74 malicious URLs with the
base conﬁguration and 224 using the Rozzle conﬁguration.
Similar to the results obtained during the oﬄine evalua-
tion, 24 (32.4%) of the base detections were not detected
with the Rozzle conﬁguration, but Rozzle enabled many
more (174) new Nozzle detections. For the static detector,
Zozzle, the results are somewhat diﬀerent. In the base
conﬁguration, 2, 735 URLs were ﬂagged as malicious while
using Rozzle only detected 2, 660 malicious URLs. A total
of 2, 510 URLs were detected in both runs, with 225 errors
and 156 new Zozzle detections in the second run.

To better understand the diﬀerences in detections
caused by Rozzle, we manually veriﬁed a subset of URLs
constituting 1, 540/1, 557 Zozzle and 31/120 Nozzle de-
tections in the base and second (Rozzle) runs, respec-
tively. Our goal was to understand 1) how often Rozzle’s
failure to detect was cause by Rozzle, as opposed to other
factors (false negatives), and 2) whether the additional
Rozzle detections were actually malicious sites and not
false positives.

In investigating false negatives, for Nozzle, 2/9 missed
detections were caused by the server not serving an exploit
during the second run, and are not the fault of Rozzle. In
the other 7 cases, handling of symbolic variables caused
errors during script execution. For Zozzle, 60 detections

453

were missing in the Rozzle-enabled run. In 44 cases, the
exploit was not served during the second analysis run
and, as above, the failure to detect is not the fault of
Rozzle. In 5 cases, our system caused an error during
JavaScript execution, stopping the exploit from being
unpacked or being downloaded and resulting in a missing
Zozzle detection. In the remaining 11 cases, the script
caused an error at runtime. Although it is not clear
whether Rozzle has any impact on these code snippets,
we conservatively assume that the errors are caused by
the multi-path execution.

In investigating false positives, we scrutinized the addi-
tional malicious URLs detected using Rozzle, and deter-
mined that they were actually malicious. We also cross-
checked to determine if there was overlap between the
Rozzle-enabled Nozzle detections and detections found
by the base conﬁguration, to see if Rozzle had uncov-
ered any previously undetected malware. We also did the
converse check, looking for new Rozzle-enabled Zozzle
detections the had previously not been detected by the
base conﬁguration.

We found that in 90 cases, Rozzle triggered a Noz-
zle dynamic malware detection whereas in the base run
neither the static nor the dynamic detector detected the
malicious script. Likewise, in 156 cases the Zozzle static
detector ﬂagged the URL as malicious although it had
not been detected by either system without Rozzle. Of
these new detections, 14 were detected by both Nozzle
and Zozzle when Rozzle was used. Figure 15 summarizes
these results graphically.

C. Performance Overhead of Rozzle

Setup: To measure the the CPU and memory overhead of
Rozzle, we visit a set of 500 randomly selected URLs from
the list selected for the online evaluation described above.
We chose this set of URLs as it is a representative sample
of URLs that an oﬄine malware crawler would be expected
to scan. To gather performance data, we added callbacks
in the JavaScript framework before and after a context
is executed. While we only measure the time within the
JavaScript runtime, other factors contribute to the overall
performance, and the relative overall impact on the end-
to-end throughput is signiﬁcantly less than shown here.

To measure Rozzle’s memory impact, we added call-
backs to the JavaScript allocator and garbage collector
to be notiﬁed about allocation/de-allocation events. In
measuring memory and CPU overhead, we analyzed each
URL three times sequentially and we report the mini-
mum of the three runs (the distribution of averages was
similar to the distribution of minimums). Unfortunately,
simply repeating analysis runs does not always provide
reproducible numbers. We noticed that script execution
times varied widely, often due to diﬀerent contents being
loaded per visit (such as advertisements) or special cookie
initialization code upon the ﬁrst visit. To compensate
for this, we visited each URL one additional time for

 

 

 

X
<
d
a
e
h
r
e
v
O
h
t
i

 

w
 
s
L
R
U

 
f
o
%

 

 

 

 

X
<
d
a
e
h
r
e
v
O
h
t
i

 

w
 
s
L
R
U

 
f
o
%

 

1
0.9
0.8
0.7
0.6
0.5
0.4
0.3
0.2
0.1
0

7
0

.

4
4
8
0

.

8
8
9
0

.

2
3
1
1

.

6
7
2
1

.

2
4
1

.

4
6
5
1

.

8
0
7
1

.

2
5
8
1

.

6
9
9
1

.

4
1
2

.

4
8
2
2

.

8
2
4
2

.

2
7
5
2

.

6
1
7
2

.

6
8
2

.

4
0
0
3

.

8
4
1
3

.

2
9
2
3

.

6
3
4
3

.

8
5
3

.

Overhead Relative to Unmodified 

(a) Rozzle Memory overhead.

100%
90%
80%
70%
60%
50%
40%
30%
20%
10%
0%

7
0

.

2
6
8
0

.

4
2
0
1

.

6
8
1
1

.

8
4
3
1

.

1
5
1

.

2
7
6
1

.

4
3
8
1

.

6
9
9
1

.

8
5
1
2

.

2
3
2

.

2
8
4
2

.

4
4
6
2

.

6
0
8
2

.

8
6
9
2

.

3
1
3

.

2
9
2
3

.

4
5
4
3

.

6
1
6
3

.

Overhead Relative to Unmodified 

4
2
7
3

.

8
6
8
3

.

2
1
0
4

.

6
5
1
4

.

3
4

.

8
7
7
3

.

4
9
3

.

2
0
1
4

.

4
6
2
4

.

(b) Rozzle CPU overhead.

Fig. 16: Distributions of relative memory and CPU JavaScript
engine overhead. Larger numbers imply more memory and
slower execution time.

script setup purposes and discarded this run from any
calculation. Additionally, we counted the number of script
contexts, number of function invocations, as well as unique
functions called per URL. Whenever the Rozzle-enabled
run showed fewer script contexts or many fewer function
invocations or called functions, we discarded the URL
from analysis, assuming the site contained nondeterminis-
tic script inclusions or Rozzle caused execution to abort
prematurely (and would thus skew results).

Results: Figures 16(a) and Figure 16(b) shows Rozzle’s
impact on memory and CPU, respectively. The ﬁgures
show the cumulative distributions of observed overheads
on the Y-axis, with the measured relative overhead plotted
on the X-axis. Thus, for example, we see that over 90% of
the URLs we measured had no memory overhead relative
to the unmodiﬁed runtime. X-axis numbers greater than
1 indicate slower execution and more memory. The ﬁgures
both show that for the vast majority of web sites, Rozzle
has no performance or memory impact, which matches
our earlier measurements indicating that few web sites
make references to the environment or execute condi-
tionally based on environment values. From these distri-
butions, the median CPU overhead is 0% and the 80th
percentile is 1.1%. The median memory overhead is 0.6%

454

" \ x6D "+ " \ x73 \ x69 \ x65 " + " \ x20 \ x36 ") > 0)

d ocument . write ( " < iframe src = x6 . htm > </ iframe > " );

" \ x6D "+ " \ x73 "+ " \ x69 " + " \ x65 " + " \ x20 "+ " \ x37 " ) > 0)

d ocument . write ( " < iframe src = x7 . htm > </ iframe > " );

" Sh " + " ockw " + " av " + " e "+ " Fl " + [ . . . ] ) ;

var a ;
var aa = new A c t i v e X O b j e c t (

1 if ( n a v i g a t o r . u s e r A g e n t . t o L o w e r C a s e (). i n d e x O f (
2
3
4 if ( n a v i g a t o r . u s e r A g e n t . t o L o w e r C a s e (). i n d e x O f (
5
6
7 try {
8
9
10
11 } catch ( a ) { } finally {
12
13
14 }
15 try {
16
17
18
19 } catch ( c ) { } finally {
20
21
22
23
24 }

aacc = " < iframe src = of . htm > </ iframe > " ;
s e t T i m e o u t ( " d o c u m e n t . write ( aacc ) " , 3500);

var c ;
var f = new A c t i v e X O b j e c t (

" O " + " \ x57 \ x43 " + " \ x31 \ x30 \ x2E \ x53 " + [ . . . ] ) ;

if ( a != " [ object Error ] " )

d o c u m e n t . wr ite ( " < iframe src = svfl9 . htm > </ iframe > " );

if ( c != " [ object Error ] " ) {

}

Fig. 17: Real-life malware roulette.

and the 80th percentile is 1.4%. The average overhead is
slightly higher: the average CPU overhead is 10% and
the average memory overhead is 3%. Since the JavaScript
runtime is only a fraction of the total CPU and memory
overhead in a modern browser, we consider these overheads
to be acceptable for oﬄine malware scanning and also even
potentially usable for in-browser scanning as well.

VI. Attack scenario

In the course of our research, we have observed that the
majority of exploits detected in the wild are na¨ıve about
detection avoidance. We have, however, seen examples
of real malware that are diﬃcult to detect without the
techniques presented here. One such example is shown
in Figure 17. A key observation here is that malware is
injected after ﬁngerprinting the browser.

In this section and in our companion technical re-
port [20], we outline an attack strategy designed to avoid
detection. The crux of this approach revolves around only
revealing a small piece of JavaScript at a time, in order to
avoid static detection and using server-side page redirects
to avoid runtime detection.

The key idea is to re-write the original malware into
a series of redirects to hide from traditional client-side
honeypots: In each state, a small script extracts the nec-
essary information (e.g., the browser version) and submits
it to the remote server. In turn, the attacker redirects the
browser depending on the submitted data: If the extracted
information does not fulﬁll any path constraints leading
to a possible exploit state, the browser is redirected to
a benign site to avoid raising suspicion. Otherwise, the
attacker redirects to a server under her control to proceed
in the roulette. Eventually, a server delivers the actual
exploit to the requesting browser. We used our high-
interaction honeypot described in Section V to test this
assumption: As expected, without Rozzle, the client was
redirected to the benign site after a few checks (states).
With the Rozzle-enhanced version, however, the crawler is

able to detect environment-sensitive parts of the URL and,
using individual proﬁles, enumerate diﬀerent sub-pages to
visit. Thus, we were able to navigate through the redirects
and ﬂag the servers as malicious.

VII. Discussion

In this section we discuss limitations of Rozzle, includ-
ing ways that attackers can avoid it, as well as considering
malware trends that are likely to impact other forms of
static and dynamic detection.

A. Limitations

As with any detection tool, we need to consider ways
that a determined attacker can avoid being detected by
systems using Rozzle. Avoidance approaches fall
into
three categories: hiding the decision making from the
client, detecting that Rozzle is being used and/or thwart-
ing it, and avoiding the detection techniques that Rozzle
enhances. We consider each in turn.
Server-side cloaking: Rozzle can thwart client-side
cloaking attempts but it is not eﬀective against server-
side techniques such as IP black-listing, etc. In particular,
a determined attacker can construct a ﬁngerprint of the
client-side environment and send it to the server, which
in the response would direct the client in various ways
depending on the conﬁguration. Such behavior is itself
quite suspicious (the server is unlikely to need to know all
the details of the client conﬁguration) and could perhaps
be detected as potentially malicious.

A common technique to avoid crawler-based malware
detection is to trigger the malware execution only when
a user interaction occurs, or when a timer ﬁres. This
approach can make Rozzle less eﬀective and represents
a general problem for dynamic crawlers. A simple, brute-
force approach to mitigate this form of hiding is to set
all timer intervals to zero in the crawler and execute all
handlers preemptively.

Breaking existing code: It is not not entirely surprising
that in certain circumstances Rozzle may lead to runtime
errors because we execute infeasible paths. In particular,
this often occurs when the program checks the user agent
and then instantiates an object speciﬁc to that browser.
While it is possible to provide mock-ups (or emulation) for
this missing functionality, and we do that in a limited set
of cases, our emulation is not exhaustive.

Similarly, aggressive execution of otherwise infeasible
paths may lead to an explosion of both the memory size
because of the growth of symbolic values in the heap, as
well as the time required to multi-execute the program,
if suﬃciently many nested conditionals are present. In
practice the measurements in Section V show that these
factors rarely impact performance,
in part due to the
symbolic value compression mentioned in Section IV-B.
Identifying that Rozzle is enabled: It is diﬃcult to
hide the fact that Rozzle is used within the browser,

455

because of functional diﬀerences in execution as well as
timing diﬀerences, etc. As a result, client code that detects
the presence of Rozzle can avoid delivering the payload
in that case. Another approach would be to construct a
denial-of service attack against Rozzle-enabled browsers:
knowing the algorithm that Rozzle uses, an attacker could
construct a program that caused Rozzle to run out of
memory, time, or other resources.

B. Emergence of Better Malware Cloaking

While our results show that our current static malware
detector is quite eﬀective without Rozzle enhancement,
we have also observed numerous cases of real malware
that are resistant to static detection. Figure 17 shows a
real-life example of malware that injects iframe-based
payloads based on ﬁngerprinting results computed on
the client. While we hypothesized the existence of such
malware, ﬁnding this malware in the wild validates our
belief that such approaches need to be defended against.
This example is one of the signiﬁcant number of new
runtime detections found with the help of Rozzle, as
described in Section V. On lines 3 and 6, exploit code
for IE 6 and 7 is included, respectively. Line 14 includes
Flash-speciﬁc code. Finally, line lines 23 and 24 include
code speciﬁc to ActiveX object OWC10.Spreadsheet. Our
companion technical report [20] provides a number of other
such examples found in practice.

VIII. Related Work

A. Symbolic Execution

Symbolic execution was introduced by King [18] and
is used in research areas such as program testing and
bug detection. Some notable eﬀorts include [5, 8, 16, 23].
Path exploration approaches include enumerating program
traces [16] or cloning the program environment (by fork-
ing a new process [8]). In contrast, Rozzle maintains the
symbolic state of the program entirely in the runtime
engine’s memory.

Most importantly, potentially costly and unpredictable
path feasibility testing is no longer employed by Rozzle
because is willing to consider potentially infeasible paths.
We branch on environment-sensitive values instead of
program inputs. Additionally, consider that JavaScript
code frequently communicates with third-party servers
that will detect and prevent repeated requests from the
same machine. Symbolic path exploration in Rozzle is
performed in a single run; as a result, Rozzle will minimize
this communication instead of going through it repeatedly,
as part of path exploration. These design choices,
in
combination generally make Rozzle very lightweight.

Austin et al. introduce faceted values, a form of multi-
execution, to simultaneously simulate multiple security
levels during JavaScript code execution [1]. While the
technique has elements in common with Rozzle, the appli-
cation of multi-execution is diﬀerent (they are interested in
reasoning about information ﬂow security) and the values

being propagated are diﬀerent. Wilhelm et al. propose forc-
ing branches in the program for rootkit identiﬁcation [35].

B. JavaScript Analysis

the

growing

of

With

popularity

browser-based
JavaScript applications, JavaScript analysis has recently
gained much attention.Cova et al. describe JSAND [11]
for analyzing and classifying web content based on
static and dynamic features. Their system provides a
framework to emulate JavaScript code and determine
characteristics that are typically found in malicious code.
Ratanaworabhan et al. describe Nozzle, a dynamic
system that uses a global heap health metric to detect
heap-spraying, a common technique used in modern
browser exploits [26]. In [12], the authors present a mostly
static analysis engine called Zozzle. This system uses
a naive bayes classiﬁer to ﬁnding instances of known,
malicious JavaScript.

These systems’ goals are orthogonal to those presented
in this paper. Combining them with Rozzle can improve
detection results and we extended two of these systems
(Nozzle and Zozzle) to evaluate our system (see Sec-
tion V). Similarly, JSAND could beneﬁt from our system,
as its dynamic features are currently limited to a single-
proﬁle execution.

A system closely related to Rozzle is Kudzu [27]. In
their paper, Saxena et al. present a symbolic execution
framework for JavaScript that can be used to explore all
paths inside a script body. Similar to Flax [28], the goal
of Kudzu is to detect client-side code inclusion vulnerabil-
ities. For this, the tool builds symbolic representations of
all variables in the code and, when it encounters a branch
instruction, solves these symbolic formulas. Additionally,
they explore GUI-triggered code paths (“event space”)
by invoking a random sequence of event handlers. The
approach used by Kudzu does not scale to our application
scenario, however. As mentioned above, Rozzle cannot
rely on constantly resolving all dynamic formulas due to
the strict analysis performance requirements.

C. Environment Fingerprinting

Malicious code frequently uses ﬁngerprinting to gather
information on a target host. This information is then
used to accommodate to diﬀerences in the execution envi-
ronment, to launch exploits speciﬁc to the host, or deter
execution inside an analysis system.

Fingerprints can be extracted from a variety of sources.
For instance, attackers use information from the network
layer [19, 30] to identify software components running on
a remote target. This information greatly reduces the
attack vectors and improves chances of a successful exploit.
Another data source is the underlying CPU architecture.
In [9], the authors present a system for building binaries
that identify the CPU using semantic diﬀerences of indi-
vidual opcodes. This way, programs are able to execute dif-
ferent behavior depending on the execution environment.

456

Balzarotti et al. present a system [2], whose aim is to detect
programs showing CPU-dependent behavior intended to
evade analysis inside malware sandboxes.

In [13, 14], the author describe Panopticlick, a system
for identifying the uniqueness of a particular browser
conﬁguration. The author argues that the ﬁngerprint of
most conﬁgurations are unique and might be used to track
individual users browsing the web. Mowery et al. [24]
extend this idea and identify browser version, OS, as well
as the underlying CPU model using timing information.

IX. Conclusions

JavaScript-based malware attacks have increased in re-
cent years and currently represent a signiﬁcant threat to
the use of desktop computers, smartphones, and tablets. In
this paper, we show that Web-based malware tends to be
environment-speciﬁc, targeting a particular browser, often
with speciﬁc versions of installed plugins. As a result, a
fundamental limitation for detecting a piece of malware
is that malware is only triggered occasionally, given the
right environment. We observe that using current ﬁnger-
printing techniques, any piece of existing malware may be
made virtually undetectable with the current generation
of malware scanners.

This paper proposes a JavaScript multi-execution tech-
nique to explore multiple execution paths in parallel as
a way to make environment-speciﬁc malware reveal it-
self. We experimentally demonstrate that, when used for
static online detection, Rozzle ﬁnds an additional 5.6% of
malicious URLs, indicating that currently malware does
not yet use sophisticated cloaking techniques to hide itself
from our detector. Rozzle increases the detection rate for
oﬄine runtime detection by almost seven times. Finally,
Rozzle triples the eﬀectiveness of online runtime detection
with minimal overhead. Rozzle oﬀers signiﬁcant practical
improvements in hardware requirements, network band-
width, and power consumption. Furthermore, in our expe-
rience, Rozzle does not introduce any new false positives.

Acknowledgments

We appreciate the cooperation and eﬀorts of David
Felstead and Paul Rebriy of the Bing malware team in
the course of this research. We also appreciate the helpful
feedback from the anonymous reviewers.

References

[1] T. H. Austin and C. Flanagan. Multiple facets for dynamic informa-

tion ﬂow. In POPL’12, Jan. 2012.

[2] D. Balzarotti, M. Cova, C. Karlberger, C. Kruegel, E. Kirda, and
G. Vigna. Eﬃcient Detection of Split Personalities in Malware.
In Proceedings of the Network and Distributed System Security
Symposium, February 2010.

[3] K. Bhargrava, D. Brewer, and K. Li. A study of URL redirection

indicating spam. In Proc. Conf. on Email and Anti-Spam, 2009.

[4] N. Bjorner, P. Hooimeijer, B. Livshits, D. Molnar, and M. Veanes.
Symbolic ﬁnite state transducers: Algorithms and applications.
Technical Report MSR-TR-2011-85, Microsoft Research, July 2011.
[5] D. Brumley, C. Hartwig, Z. Liang, J. Newsome, D. Song, and H. Yin.
Automatically identifying trigger-based behavior in malware. Tech-
nical report, Carnegie Mellon University, 2007.

[6] R. E. Bryant. Symbolic boolean manipulation with ordered binary

decision diagrams. ACM Comp. Surveys, 24(3), Sept. 1992.

457

[7] C. Cadar, D. Dunbar, and D. R. Engler. Klee: Unassisted and
automatic generation of high-coverage tests for complex systems
programs. In OSDI, 2008.

[8] C. Cadar, V. Ganesh, P. M. Pawlowski, D. L. Dill, and D. R. Engler.
In Computer and

Exe: automatically generating inputs of death.
Communications Security, 2006.

[9] S. K. Cha, B. Pak, D. Brumley, and R. J. Lipton. Platform-
independent programs. In Proceedings of the Conference on Com-
puter and Communications Security, Oct. 2010.

[10] K. Chellapilla and A. Maykov. A taxonomy of JavaScript redirection

spam. In AIRWeb, 2007.

[11] M. Cova, C. Kruegel, and G. Vigna. Detection and analysis of drive-
by-download attacks and malicious JavaScript code. In Proceedings
of the International World Wide Web Conference, April 2010.

[12] C. Curtsinger, B. Livshits, B. Zorn, and C. Seifert. Zozzle: Low-
overhead mostly static JavaScript malware detection. In Proceedings
of the Usenix Security Symposium, Aug. 2011.

[13] P. Eckersley. How unique is your web browser? In Privacy Enhanc-

ing Technologies, 2010.

[14] P. Eckersley. Panopticlick. http://panopticlick.eff.org/, 2011.
[15] M. Fahndrich and R. DeLine. Adoption and focus: practical linear

types for imperative programming. In PLDI ’02.

[16] P. Godefroid, M. Y. Levin, and D. A. Molnar. Automated whitebox
fuzz testing. In Network and Distributed System Security Sympo-
sium, 2008.

[17] S. Kaplan, B. Livshits, B. Zorn, C. Seifert, and C. Curtsinger. “nofus:
Automatically detecting” + string.fromcharcode(32) + “obfuscated
”.tolowercase() + “javascript code”. Technical Report MSR-TR-
2011-57, Microsoft Research, May 2011.

[18] J. C. King. Symbolic execution and program testing. Commun.

ACM, 19, July 1976.

[19] T. Kohno, A. Broido, and K. C. Claﬀy. Remote physical device
ﬁngerprinting. In Proceedings of the IEEE Symposium on Security
and Privacy, 2005.

[21] Microsoft Corp.

[20] C. Kolbitsch, B. Livshits, B. Zorn, and C. Seifert. Rozzle: Decloaking
Internet malware. Technical report, Microsoft Research, Sept. 2011.
The new JavaScript engine in Internet
http://blogs.msdn.com/b/ie/archive/2010/03/18/

Explorer 9.
the-new-javascript-engine-in-internet-explorer-9.aspx, 2010.

[22] P. Milani Comparetti, G. Salvaneschi, C. Kolbitsch, E. Kirda,
Identifying dormant functionality in
In Proceedings of the IEEE Symposium on

C. Kruegel, and S. Zanero.
malware programs.
Security and Privacy, 2010.

[23] A. Moser, C. Kruegel, and E. Kirda. Exploring multiple execution
paths for malware analysis. In Proc. of the IEEE Symposium on
Security and Privacy. IEEE Computer Society, 2007.

[24] K. Mowery, D. Bogenreif, S. Yilek, and H. Shacham. Fingerprinting
information in JavaScript implementations. In Proceedings of Web
2.0 Security and Privacy 2011, May 2011.

[25] N. Provos, D. McNamee, P. Mavrommatis, K. Wang, and
N. Modadugu. The ghost in the browser: Analysis of web-based
malware. 2007.

[26] P. Ratanaworabhan, B. Livshits, and B. Zorn. Nozzle: A defense
against heap-spraying code injection attacks. In Proceedings of the
Usenix Security Symposium, Aug. 2009.

[27] P. Saxena, D. Akhawe, S. Hanna, F. Mao, S. McCamant, and
D. Song. A symbolic execution framework for JavaScript. Tech-
nical Report UCB/EECS-2010-26, EECS Department, University of
California, Berkeley, Mar 2010.

[28] P. Saxena, S. Hanna, P. Poosankam, and D. Song. Flax: Systematic
discovery of client-side validation vulnerabilities in rich web appli-
cations. In Network and Distributed System Security Symposium.
[29] SkyLined. Internet Explorer IFRAME src&name parameter BoF re-
mote compromise. http://skypher.com/wiki/index.php?title=Www.
edup.tudelft.nl/~bjwever/advisory/_iframe.html.php, 2004.

[30] M. Smart, G. R. Malan, and F. Jahanian. Defeating TCP/IP stack

ﬁngerprinting. In Proc. of the Usenix Security Symposium, 2000.

[31] Sophos Labs. Security threat report 2011, 2011.
[32] P. Tu and D. Padua. Gated SSA-based demand-driven symbolic
analysis for parallelizing compilers. In Proceedings of the Interna-
tional Conference on Supercomputing, 1995.

[33] R. van den Heetkamp. Heap spraying. http://www.0x000000.com/

index.php?i=412&bin=110011100, Aug. 2007.

[34] L. Wall. Perl security.

http://search.cpan.org/dist/perl/pod/

perlsec.pod.

[35] J. Wilhelm and T. Chiueh. A forced sampled execution approach
In Recent Advances in Intrusion

to kernel rootkit identiﬁcation.
Detection. 2007.

[36] B. Wu and B. D. Davison. Detecting semantic cloaking on the web. In
Proceedings of the International Conference on World Wide Web,
2006.

[38] K. Zeeuwen, M. Ripeanu, and K. Beznosov.

[37] C. Xuan, J. Copeland, and R. Beya. Toward revealing kernel
malware behavior in virtual execution environments. In RAID, 2009.
Improving malicious
URL re-evaluation scheduling through an empirical study of malware
download centers. 2011.

