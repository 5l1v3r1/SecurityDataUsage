Coupon Collector’s Problem

for Fault Analysis against AES

— High Tolerance for Noisy Fault Injections

Yu Sasaki1, Yang Li2, Hikaru Sakamoto2 and Kazuo Sakiyama2

1 NTT Secure Platform Laboratories

sasaki.yu@lab.ntt.co.jp

2 The University of Electro-Communications

{liyang,sakiyama}@uec.ac.jp

Abstract. In this paper, we propose a new technique for Square Dif-
ferential Fault Analysis (DFA) against AES that can recover a secret
key even with a large number of noisy fault injections, while the previ-
ous approaches of the Square DFA cannot work with noise. This makes
the attack more realistic because assuming the 100% accuracy of obtain-
ing intended fault injections is usually impossible. Our success lies in
the discovery of a new mechanism of identifying the right key guess by
exploiting the coupon collector’s problem and its variant. Our attack pa-
rameterizes the number of noisy fault injections. If the number of noisy
faults is set to 0, the analysis becomes exactly the same as the previous
Square DFAs. Then, our attack can work even with a large number of
noisy faults. Thus our work can be viewed as a generalization of the pre-
vious Square DFAs with respect to the number of tolerable noisy fault
injections.

Keywords: AES, Fault analysis, DFA, Noisy fault model, SQUARE
DFA, Coupon collector’s problem

1 Introduction

Fault analysis is one of the major approaches of the side-channel analysis. In
particular, Diﬀerential Fault Analysis (DFA) has been applied to very wide range
of ciphers. The suitable fault injection rounds for DFA (DFA round) are almost
uniquely determined depending on the structure of the target cipher. These
DFA rounds are the ﬁrst place to be protected for the DFA countermeasures. A
common approach is to take redundancy in hardware cost or time to trade the
ability of detecting faulty calculations [1–3]. When the faults are injected before
the DFA rounds, the complexity of the key recovery process usually becomes
impractical in a straightforward DFA application.

For the AES-128 encryption [9], many DFA results [4–8] imply that the DFA
rounds are 8 and 9. Even after the countermeasure is proposed so that rounds
8 and 9 are protected, researchers have proposed practical DFA variants based

Table 1. Comparison of Square DFA.

Approach α #Tolerable noise Time #Fault Injections
[10]
[12]

255
43

Ours

256
44
256
128
64

0
0

1610

49
13

236.68
234.14
244.54
241.15
239.94

59712
5664
2464

on the fault injected at round 7 such as Square DFA [10], impossible DFA [10,
11], and Meet-in-the-Middle (MitM) DFA [11].

The Square DFA exploits a property of the AES algorithm, i.e., if the
attacker collects 256 ciphertexts where one byte at the beginning of round 7
takes all 256 distinct values and other bytes are ﬁxed to a constant, in a few
rounds after, all bytes take exactly 256 distinct values with probability 1. The
illustration of the property is available in Fig. 1. Then, the attacker guesses the
last round key and performs a partial inverse computations for 256 ciphertexts.
The correctness of the key guess is veriﬁed by checking whether or not 256
distinct values are observed. The attack requires to obtain 255 distinct fault
values on a target byte with exactly 255 fault injections. Hence, the attack
cannot accept the noise, and [10] assumed the bit-fault model.

Kim improved the Square DFA based on the observation that 256 distinct
values are not necessary to recover the key [12]. The attacker collects only α dis-
tinct values at the beginning of round 7, and thus the number of fault injections
is reduced and the attack model is relaxed to the random-byte fault model. The
attack requires to obtain α−1 distinct fault values on a target byte with exactly
α − 1 fault injections. Hence, the attack cannot accept the noise.

In practice, fault injections cannot assure the 100% accuracy of the intended
fault injections. As a result, it is necessary to introduce the noisy fault model.,
where random faulty ciphertexts corresponding to unintended fault injections
are mixed in the data to be analyzed for recovering a key.

Our Contributions. We propose a new technique for the Square DFA, which
can recover the key even with a large number of noisy fault injections.

Assume that an attacker can inject an intended fault every two trials. First
of all, the attacker obtains one ciphertext without injecting the fault. In order to
collect α − 1 intended faulty ciphertexts, the same number of noisy ciphertexts
are obtained, and the total number of data to be analyzed is n = 2(α − 1) + 1.
Our attack still can ﬁnd the key with such a high probability of obtaining noise
at a small additional cost. See Table 1 for the comparison with previous work.
Our attack collects α distinct values at the beginning of round 7. However,
the attacker also obtains n − α unintended ciphertexts due to the noise, and
she does not know which are intended ones. For the right key guess, at least
α distinct values appear after the partial decryption. If the probability of this

event is small enough, the key space is reduced. The probability of this event is
estimated by solving the coupon collector’s problem and its variant, Let β be
the size of each cell of the cipher (β = 256 for AES). The probability that a key
guess is regarded as a right key candidate, i.e., α distinct values appear in one
byte after the partial decryption is equivalent to the probability where at least
α out of β coupons are collected with n coupon drawing events.

2 Related Work

2.1 Speciﬁcation of AES
AES-128 [9] is a 128-bit block cipher using a 128-bit key. It consists of 10 rounds.
Subkeys ski for round i are generated from the original secret key K. At ﬁrst,
subkey sk0 is XORed to the plaintext. Then a round function AK◦M C◦SR◦SB
is iteratively applied, where SB is an S-box transformation, SR is a byte shift,
M C is a multiplication by an MDS matrix, and AK is a subkey XOR. Note
that M C is omitted for the last round. We denote the initial state in round x by
#xI. Then, states immediately after each operation in round x are denoted by
#xSB, #xSR, #xM C, and #xAK. Obviously, #xAK is identical with #(x + 1)I.
We denote 4-byte positions in column j of state #S by #S[Col(j)].

2.2 Square DFA on AES
Phan and Yen showed that the key is recovered with the fault injected at the
beginning of round 7 [10]. The attack uses the idea of the Square attack, which
was ﬁrstly proposed by Daemen et al. for the Square cipher.

The attack collects 256 distinct values on a single byte at the beginning of
round 7. The attacker ﬁrstly obtains a ciphertext. While the same plaintext is
encrypted 255 times. she injects a fault on a target byte. The fault model by
Phan and Yen [10] is summarized as follows.

Fault model 1 (bit-fault and deterministic-fault)

– An attacker can inject the fault in any intended bit position, and

moreover, several target bits can be ﬂipped simultaneously.

– The fault injection to the target bits always succeeds.

All in all, the attacker can obtain 255 distinct fault values with 255 injections
without obtaining any noisy data. 256 distinct values for a single byte at #7I
result in 256 distinct values for all bytes at #9AK(cid:48) as shown in Fig. 1. Note that
the order of the linear operations are exchanged in rounds 9 and 10.
After 256 ciphertexts following the data structure of Fig. 1 are obtained, the
attacker recovers the converted last round key sk(cid:48)
10 = SR−1(sk10).
The key recovery phase is described in Fig. 2. At ﬁrst, the inverse of SR is
applied to all ciphertexts. Then, the attacker guesses sk(cid:48)
10 column by column.
Let us focus our attention on column 0, which is colored in Fig. 2. 232 value
of sk(cid:48)
10[Col(0)] are exhaustively guessed. For each guess, the attacker decrypts
α = 256 converted ciphertexts (C(cid:48)
255) up to #9AK(cid:48)[Col(0)]. Then, the
right key can be identiﬁed based on the following mechanism.

10, where sk(cid:48)

0, . . . , C(cid:48)

Fig. 1. Fault injection at #7I . The key is a ﬁxed value but the notation c is omitted.

Fig. 2. The structure of the key recovery phase.

Key Recovery Mechanism 1: For the right guess, 256 distinct values
appear for each byte of #9AK(cid:48)[Col(0)]. This is unlikely to occur for wrong
guesses. In fact, the probability of this event for a wrong guess is

(1)

(cid:179)255(cid:89)

i=0

(cid:180)4 ≈ 0.

(256 − i)

256

Finally, the right key value is recovered with 255 fault injections and about
232 · 256 · 1/10 ≈ 236.68 AES computations.

2.3 Improved Square DFA with a Small Number of Fault Injections
Kim proposed an improved Square DFA on AES [12]. The entire attack struc-
ture again follows Fig. 1. Suppose that the attacker obtains α distinct values

SBSRMC#8I#8SB#8SR#8MCsk8Round 8ααααααααααααααααSBSRMC#7I#7SB#7SR#7MCsk7Round 7αcccccccccccccccαccccccαccαccαccSBSR#10I#10SB#10AK’sk10Ciphertext (Ci): αdistinct valuesαRound 10: no propertySB#9I#9SBRound 9ααααααααααααααααSR#9SRsk9#9AK’MCMC -1sk9’ααααααααααααααααααααααααααααααααααααααααααααααααSR -1sk10’αcccccccccccccccαcccccccccccccccαcccαcccαcccαcccαcccαcccαcccαcccαcccαcccαcccαccc: constantcSB#10I#10SBC’i= SR-1(Ci)sk10’ = SR-1(sk10)ααααααααααααααααMC#9AK’at the target single byte at #7I, where 1 ≤ α ≤ 256. The only diﬀerence from
the original Square DFA [10] is the value of α. Phan and Yen only considered
α = 256 while Kim regarded it as a variable ranging from 1 to 256. Due to the
same reason as [10], each byte at #9AK(cid:48) takes α distinct values.

Fault model 2 (random byte-fault and deterministic fault)
– An attacker can inject α− 1 distinct fault values in an intended byte
position. Fault value is uncontrollable and is uniformly distributed.

– The fault injection to the target byte always succeeds.

For a ﬁxed α, the right key can be identiﬁed based on the following mechanism.

Key Recovery Mechanism 2: For the right guess, α distinct values
appear for each byte of #9AK(cid:48)[Col(0)]. If this event is unlikely to occur
for wrong guesses, the right key can be identiﬁed. The probability of this

event for a wrong guess is (cid:179)α−1(cid:89)

(cid:180)4

(256 − i)

256

i=0

.

(2)

Kim showed that when α = 44, Eq. (2) is smaller than 2−32 and thus the right
key is recovered. Finally, the right key value is recovered with 43 fault injections
and about 232 · 44 · 1/10 ≈ 234.14 AES computations.

3 Square DFA Based on Coupon Collector’s Problem

We generalize the previous Square DFA to accept the noise. Our attack has two
parameters. 1) how many distinct values can be obtained at #7I, α, and 2) how
many ciphertexts are obtained before α intended ciphertexts are collected, n.
Note that n is the sum of the numbers of intended and unintended ciphertexts.
If we set the number of noisy fault to 0 (n = α), the analysis becomes the same
as [12]. If we further set α = 256, the analysis becomes the same as [10]. Hence,
we call our approach generalized Square DFA. For the further generalization,
we also parameterize the size of each cell by β, e.g. β = 256 for AES.

3.1 Overview

The parameters of the attacker’s abilities α and n basically depend on the en-
vironment e.g., how much cost can be spent for the attack. We assume that the
attacker’s ability is independently measured before the analysis is started.

Fault model 3 (random byte-fault and probabilistic-fault)
– An attacker can inject at most α − 1 distinct fault values in an in-
tended byte position, The fault value is uncontrollable and is uni-
formly distributed.
with a probability of (α − 1)/(n − 1).

– The intended fault injection can be obtained only probabilistically,

The attack ﬁrstly obtains 1 ciphertext without the fault injection. While the
same plaintext is encrypted n − 1 times, the attacker injects the fault n − 1
times and obtains the corresponding n − 1 ciphertexts. α − 1 intended faulted
ciphertexts are included in the n − 1 faulted ciphertexts, but which ciphertexts
are intended ones is unknown. After collecting such 1 + (n − 1) = n ciphertexts,
we recover the last round key sk(cid:48)

10 column by column.

Key Recovery Mechanism 3: For the right guess, at least α distinct
values appear for each byte of #9AK(cid:48)[Col(0)]. If this event is unlikely to
occur for wrong guesses, the right key can be identiﬁed.

Therefore, for each guess of sk(cid:48)
10[Col(0)], if less than α distinct values are ob-
served in at least one byte of #9AK(cid:48)[Col(0)], we know the guess is wrong, and
thus the key space is reduced. Let P (α, β, n) be the probability that, for each key
guess, at least α distinct values appear for one byte of #9AK(cid:48)[Col(0)]. The key
10[Col(0)] is reduced from β4 to β4 × P (α, β, n)4 after the analysis.
space of sk(cid:48)
For simplicity, let us discuss the case where α = β, which implies that all
values are collected at #7I. For AES, α = β = 256. In this case, P (α, β, n) is
equivalent to the success probability of the coupon collector’s problem.

There are β coupons. With 1 coupon-drawing event, 1 coupon which is
uniformly distributed from β coupons is obtained. The success probability
of the coupon collector’s problem for parameters (β, n) is the one that all
β coupons are completed with n coupon-drawing events.

For α < β, P (α, β, n) is equivalent to a variant of the coupon collector’s problem
where at least α kinds out of β kinds of coupons are collected with n coupon-
drawing events. In the next section, we will evaluate the value of P (α, β, n).

3.2 Probability Evaluation of P (α, β, n)

Proposition 1 Let Q(α, n) be the number of permutations of n coupons includ-
ing all of the α diﬀerent coupons completely (1 ≤ α ≤ n). Then

(cid:181)

α(cid:88)

k=1

(cid:182)

(cid:181)

(cid:182)

α
k

Q(α, n) =

(−1)α−k

kn

.

(3)

(cid:161)α
(cid:162)

Proof. As Q(j, n)
covers all the possible ways to collect j diﬀerent coupons
chosen from α coupons (j ≤ α) using n random coupon-drawing trials, its sum-
mation for j = 1, 2, . . . , α, where α = 0, 1, . . . , n, always becomes αn as

j

(cid:181)

α(cid:88)

k=1

Q(k, n)

(cid:181)

α
k

(cid:182)(cid:182)
(cid:80)n
k=1(−1)n−k

= αn,

(cid:161)n

(cid:162)

k

(cid:80)n

(cid:161)n
(cid:162)

k=1

k

For an =

bk, we have bn =

Eq. (4), consider αn as an and Q(k, n) as bk, we can derive Eq. (3).

ak. Therefore for
(cid:117)(cid:116)

(4)

Proposition 2 Let P (α, β, n) be the probability that one collects at least α out
of β coupons through n trials, where 2 ≤ α ≤ β. Then

P (α, β, n) =

Q(α − 1, i − 1)

,

(5)

(cid:181)

(cid:182)(cid:181)

(cid:182) n(cid:88)

β
α

α
1

i=α

βi

(cid:181)

(cid:182)(cid:181)

(cid:182)

(cid:162)(cid:161)β−α+1

(cid:162)

(cid:161) β

α−1

1

=

Proof. We have the probability that one collects α coupons out of β exactly at
the i-th trial, i.e., α − 1 coupons are collected through the i − 1 trials, as

Q(α − 1, i − 1)
βi

Q(α − 1, i − 1)

βi

.

α
1

β
α

As the probability of P (α, β, n) equals the summation of the above probabilities
(cid:117)(cid:116)
for i = α, α + 1, . . . , n, Eq. (5) is derived.

4 Details of the Generalized Square DFA on AES-128

The parameters (α, n) should be measured depending of the attacker’s ability.
The parameter β is ﬁxed to 256. In this section, we explain the attack with
the parameter (α, β, n) = (256, 256, 1553), where P (α, β, n) = 1/2 according to
Eq. (5). Note that (α, n) = (256, 1553) is just an example for the case study.

The attack consists of the data collecting phase and the key recovery phase.

The procedure of the data collecting phase is as follows.

1. Obtain a ciphertext C0 without injecting the fault, and store it in a table.
2. While the same plaintext is encrypted, try to inject a fault in a target single
byte at #7I. If the obtained ciphertext does not overlap with already stored
ones in a table, add this ciphertext into a table. Otherwise, discard it.

3. Repeat Step 2 until n ciphertexts C0, . . . , Cn−1 are obtained.

For one plaintext, a set of n ciphertexts is constructing. For (α, n) = (256, 1553),
we collect 8 sets of n ciphertexts by using 8 diﬀerent plaintexts.

The input to the key recovery phase is 1553 ciphertexts C0, . . . , C1552, where

256 values are collected in the target single byte at #7I. Then, do as follows.
1. Compute C(cid:48)
2. For each column (j = 0, 1, 2, 3), exhaustively guess the value for sk(cid:48)

i ← SR−1(Ci) for 0 ≤ i ≤ 1552.

10[Col(j)]

and compute #9AK(cid:48)[Col(j)].
#9AK(cid:48)[Col(j)], discard the guessed sk(cid:48)

3. If only less than 256 distinct values are observed in at least one byte of

4. Repeat steps 1 to 3 by 8 times with changing the ciphertext set.

10[Col(j)] from the key candidates.

The attack cost is evaluated as follows. The number of the faulty ciphertexts is
8 · 1553 = 12424. In the key recovery phase, Step 1 costs 8 · 1553 inverse SR
computations, which essentially does not cost anything. Step 2 costs 8· 1553· 232
one round computations, which is (8· 1553· 232)/10 ≈ 242.28 AES computations.
The memory requirement is 232 AES state to count the remaining key space.

The time complexity can be optimized. Once a key candidate is identiﬁed to
be a wrong key, it does not have to be examined again. Therefore, the complexity
is 1553 · (232 + 228 + 224 + ··· + 24)/10 ≈ 239.37 AES computations.

If not only for the ciphertext, but also the plaintext is available for the
attacker, she can combine the brute force attack. Hence, step 4 can be stopped
when the key space is reduced to a suﬃciently small size, rather than 1.

5 Concluding Remarks

In this paper, we presented the new fault analysis called generalized Square
DFA, which was an extension of the previous Square DFA with respect to the
noisy fault injections. The probability that a key candidate is judged as a correct
key is estimated with a coupon collector’s problem and its variant.

References

1. Fischer, W.: Aspects of the development of secure and fault-resistant hardware.

In: FDTC. (2008) 18–22

2. Guilley, S., Sauvage, L., Danger, J.L., Selmane, N.: Fault injection resilience. In:

FDTC. (2010) 51–65

3. Satoh, A., Sugawara, T., Homma, N., Aoki, T.: High-Performance Concurrent
In Oswald, E., Rohatgi, P., eds.:

Error Detection Scheme for AES Hardware.
CHES 2008. Volume 5154 of LNCS., Springer (2008) 100–112

4. Bl¨omer, J., Seifert, J.P.: Fault Based Cryptanalysis of the Advanced Encryption
Standard (AES). In Wright, R.N., ed.: FC 2003. Volume 2742 of LNCS., Springer
(2003) 162–181

5. Dusart, P., Letourneux, G., Vivolo, O.: Diﬀerential Fault Analysis on A.E.S. In
Zhou, J., Yung, M., Han, Y., eds.: ACNS 2003. Volume 2846 of LNCS., Springer
(2003)

6. Giraud, C.: DFA on AES.

In Dobbertin, H., Rijmen, V., Sowa, A., eds.: AES

Conference 2004. Volume 3373 of LNCS., Springer (2004) 27–41

7. Moradi, A., Shalmani, M.T.M., Salmasizadeh, M.: A Generalized Method of Dif-
ferential Fault Attack Against AES Cryptosystem. In Goubin, L., Matsui, M., eds.:
CHES 2006. Volume 4249 of LNCS., Springer (2006) 91–100

8. Piret, G., Quisquater, J.J.: A Diﬀerential Fault Attack Technique against SPN
Structures, with Application to the AES and KHAZAD. In Walter, C.D., C¸ etin
Kaya Ko¸c, Paar, C., eds.: CHES 2003. Volume 2779 of LNCS., Springer (2003)
77–88

9. Daemen, J., Rijmen, V.: AES Proposal: Rijndael. (1998)

10. Phan, R.C.W., Yen, S.M.: Amplifying Side-Channel Attacks with Techniques from
Block Cipher Cryptanalysis. In Domingo-Ferrer, J., Posegga, J., Schreckling, D.,
eds.: CARDIS 2006. Volume 3928 of LNCS., Springer (2006) 135–150

11. Derbez, P., Fouque, P.A., Leresteux, D.: Meet-in-the-Middle and Impossible Dif-
In Preneel, B., Takagi, T., eds.: CHES 2011.

ferential Fault Analysis on AES.
Volume 6917 of LNCS., Springer (2011) 274–291

12. Kim, C.H.: Eﬃcient methods for exploiting faults induced at AES middle rounds.

Cryptology ePrint Archive, Report 2011/349 (2011)

