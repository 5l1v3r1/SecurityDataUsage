Information-Flow Analysis of

Android Applications in DroidSafe

Michael I. Gordon∗, Deokhwan Kim∗, Jeff Perkins∗, Limei Gilham†, Nguyen Nguyen‡, and Martin Rinard∗

∗Massachusetts Institute of Technology

mgordon@mit.edu, dkim@csail.mit.edu, jhp@csail.mit.edu, rinard@csail.mit.edu

†Kestrel Institute
gilham@kestrel.edu
‡UWIN Software, LLC
nguyen@uwinsoftware.com

Abstract—We present DroidSafe, a static information ﬂow
analysis tool that reports potential leaks of sensitive information
in Android applications. DroidSafe combines a comprehensive,
accurate, and precise model of the Android runtime with static
analysis design decisions that enable the DroidSafe analyses to
scale to analyze this model. This combination is enabled by
accurate analysis stubs, a technique that enables the effective
analysis of code whose complete semantics lies outside the scope
of Java, and by a combination of analyses that together can
statically resolve communication targets identiﬁed by dynamically
constructed values such as strings and class designators.

Our experimental results demonstrate that 1) DroidSafe
achieves unprecedented precision and accuracy for Android
information ﬂow analysis (as measured on a standard previously
published set of benchmark applications) and 2) DroidSafe detects
all malicious information ﬂow leaks inserted into 24 real-world
Android applications by three independent, hostile Red-Team
organizations. The previous state-of-the art analysis, in contrast,
detects less than 10% of these malicious ﬂows.

I.

INTRODUCTION

Sensitive information leaks, as implemented by malicious
or misused code (such as advertising libraries) in Android
applications, constitute one of the most prominent security
threats to the Android ecosystem [1, 2]. Android currently
supports a coarse-grain information security model in which
users grant applications the right to access sensitive informa-
tion [3]. This model has been less than successful at eliminat-
ing information leaks [1], in part because many applications
need to legitimately access sensitive information, but only for
a speciﬁc limited purpose — for example, an application may
legitimately need to access location information, but only with
the right to send the information to authorized mapping servers.
Motivated by this problem, researchers have developed a
variety of systems that are designed to analyze or explore the
information ﬂows in Android applications. Dynamic analysis

frameworks execute instrumented versions of Android appli-
cations and observe behaviors [4–6]. Potential downsides of
this approach include missed information ﬂows that are not
exercised during testing and, in some cases, the ability of
the malicious application to detect the testing and modify its
behavior to avoid exercising the malicious ﬂow [4]. They also
suffer from denial-of-service attacks if malware is activated
during application execution and the application is killed or
functionality is disabled.

Static analysis frameworks attempt to analyze the appli-
cation before it executes to discover all potential sensitive
ﬂows [7–13]. Standard issues that complicate the construction
of such systems are the challenges of 1) scaling to large
applications and 2) maintaining precision in the analysis such
that it does not report too many ﬂows that do not actually
exist in the application. One particularly prominent issue with
developing static analyses for Android applications is the size,
richness, and complexity of the Android API and runtime,
which typically comprises multiple millions of lines of code
implemented in multiple programming languages. Because
sensitive ﬂows are often generated by complex interactions
between the Android application, API, and runtime, any static
analysis must work with an accurate model of this runtime to
produce acceptably accurate results.

Accuracy is critical for a static analysis seeking to cal-
culate security properties of an application; any inaccuracies
in the execution model provide a motivated attacker with the
opportunity to insert malicious ﬂows that will not be captured
by an analysis. Also, imprecision in a model could lead to
results that are unusable due to too many false positives;
another target for a motivated attacker. To the best of our
knowledge, the difﬁculty of obtaining an acceptably accurate
and precise Android model has signiﬁcantly limited the ability
of previous systems to successfully detect the full range of
malicious information ﬂows in Android applications.

Permission to freely reproduce all or part of this paper for noncommercial
purposes is granted provided that copies bear this notice and the full citation
on the ﬁrst page. Reproduction for commercial purposes is strictly prohibited
without the prior written consent of the Internet Society, the ﬁrst-named author
(for reproduction of an entire paper only), and the author’s employer if the
paper was prepared within the scope of employment.
NDSS ’15, 8-11 February 2015, San Diego, CA, USA
Copyright 2015 Internet Society, ISBN 1-891562-38-X
http://dx.doi.org/10.14722/ndss.2015.23089

DroidSafe

We present a new system, DroidSafe, for accurately and
precisely analyzing sensitive explicit
information ﬂows in
large, real-world Android applications. DroidSafe tracks in-
formation ﬂows from sources (Android API calls that inject
sensitive information) to sinks (Android API calls that may
leak information). We evaluate DroidSafe on 24 complete real-

world Android applications that, as part of the DARPA Auto-
mated Program Analysis for Cybersecurity (APAC) program,
have been augmented with malicious information ﬂow leaks
by three hostile Red Team organizations. The goal of these
organizations was to develop information leaks that would
either evade detection by static analysis tools or overwhelm
static analysis tools into producing unacceptable results (by, for
example, manipulating the tool into reporting an overwhelming
number of false positive ﬂows). DroidSafe accurately detects
all of the 69 malicious ﬂows in these applications (while
reporting a manageable total number of ﬂows). A current state-
of-the-art Android information-ﬂow analysis system, Flow-
Droid [8] + IccTA [14], in contrast, detects only 6 of the 69
malicious ﬂows, and has a larger ratio of total ﬂows reported
to true malicious ﬂows reported.

Additionally, we evaluate DroidSafe on DROIDBENCH, a
suite of 94 Android information-ﬂow benchmarks from the
developers of FlowDroid and IccTA, and report the highest
accuracy (most actual ﬂows reported) and highest precision
(fewest false positive ﬂows reported) for this benchmark
suite to date, 94.3% and 87.6% respectively. DroidSafe fails
to report only the implicit ﬂows in DROIDBENCH. Finally,
we evaluate DroidSafe on a suite of 40 Android explicit
information-ﬂow benchmarks developed by us to add coverage
to DROIDBENCH; DroidSafe achieves 100% accuracy and
precision for the suite, compared to FlowDroid + IccTA’s
34.9% accuracy and 79.0% precision.

One advantage of working with applications that contain
known inserted malicious ﬂows is the ability to characterize
the accuracy of our analysis (i.e., measure how many malicious
ﬂows DroidSafe was able to detect). As these results illustrate,
DroidSafe implements an analysis of unprecedented accuracy
and precision. To the best of our knowledge, DroidSafe pro-
vides the ﬁrst usable information-ﬂow analysis for Android
applications [7–14].

The Android Model and Analysis Co-design

Given the extensive and complex interactions between the
Android execution environment and Android applications, an
accurate and precise information-ﬂow analysis for Android ap-
plications requires a comprehensive and accurate model of the
Android environment. To obtain such a model, we started with
the Android Open Source Project (AOSP) [15] implementation,
which contains a Java implementation of much of the Android
environment. The goal was to maximize accuracy and precision
by directly analyzing as comprehensive a model of Android as
feasible.

As we worked with AOSP, it quickly became apparent
that
the size and complexity of the Android environment
made it necessary to develop the model and the analysis
together as an integrated whole, with the design decisions in
the model and the analysis working together synergistically to
enable an effective solution to the Android static information-
ﬂow analysis problem. The result is the ﬁrst accurate and
precise model of the Android environment and the ﬁrst analysis
capable of analyzing such a model.
Accurate Analysis Stubs: While the AOSP provides an
accurate and precise model for much of Android, it is missing
critical parts of the Android runtime. And for good reason —

it is currently not practical to implement much of the Android
runtime in Java. We therefore developed a novel technique,
accurate analysis stubs, to enable the effective analysis of code
whose full semantics lies outside the scope of AOSP. Each stub
is written in Java and only incompletely models the runtime
behavior of the modeled code. But the semantics of the stub
is complete for the abstractions that the analysis deploys (in
this case points-to and information-ﬂow analyses). Examples
of semantics missing in the AOSP and added via accurate
analysis stubs include native methods; event callback initiation
with accurate context; component life-cycle events; and hidden
state maintained by the Android runtime and accessible to the
application only via the Android API.

Accurate analysis stubs simplify the development of the
analysis — they eliminate any need to develop a library of
method summaries written in a different speciﬁcation lan-
guage [16, 17], any need to conservatively hard code policies
within the analysis that attempt to compensate for the missing
semantics [8], or any need to analyze code written in multiple
languages. They also simplify the development of the model
— they enable the developers of the model to work ﬂexibly
and efﬁciently within the familiar implementation language.
And they support the use of sophisticated language features
such as inheritance, polymorphic code reuse, exceptions, and
threads, all of which promote effective engineering of stubs
that accurately and precisely model key aspects of the Android
environment.

In addition to code, accurate analysis stubs also support the
use of Java objects to model otherwise hidden state maintained
by the Android runtime. Examples of such state include
Android Activity saved state,
the global Application
object, Intent, Parcel, shared preferences, and the ﬁle
system. Accurate analysis stubs enable DroidSafe to be the
ﬁrst analysis to accurately model these key Android features.
The AOSP implementation overlaid with our accurate anal-
ysis stubs represents our model of the Android API and run-
time. We call this model the Android Device Implementation
(ADI). Each application is analyzed in the context of the ADI,
approximately 1.3 MLOC. For the information-ﬂow analysis,
we manually identiﬁed and classiﬁed 4,051 sensitive source
methods and 2,116 sensitive sink methods in the Android API.
Scalable, Precise Points-To Analysis: Both our Android
model and Android applications heavily use sophisticated
language features (such as inheritance and polymorphic code
reuse) that are known to signiﬁcantly complicate static pro-
gram analyses. To preserve acceptable precision, DroidSafe
therefore deploys a modern global object-sensitive points-
to analysis speciﬁcally designed to analyze code that uses
such features [18]. DroidSafe further enhances scalability by
identifying classes that are not relevant to the information ﬂow
and eliminating object sensitivity for instances of these classes.
This Android-speciﬁc optimization enables our global points-
to analysis to achieve a context depth greater than what was
achieved in prior work [18, 19], delivering a precise analysis
appropriately tailored for solving Android information-ﬂow
problems.
Flow-Insensitive Analyses: DroidSafe employs a ﬂow-
insensitive information-ﬂow analysis. Many interactions be-
tween Android applications and the Android environment

2

are mediated by asynchronous callbacks. Because our Droid-
Safe implementation uses ﬂow-insensitive points-to and
information-ﬂow analyses, it accurately considers all possible
runtime event orderings that asynchronous callbacks can trig-
ger. Developers of ﬂow sensitive analyses, in contrast, have had
difﬁculty obtaining a model that correctly exposes all of these
event orderings to a ﬂow sensitive analysis (see Section VIII).
Because the analysis does not consider all event orderings, it
may miss sensitive ﬂows.

Critically, ﬂow insensitivity also enables the analysis to
scale to analyze an accurate and precise Android model and
therefore to accurately and precisely track information ﬂows
through the Android environment. Scalability issues restrict
ﬂow-sensitive analyses to signiﬁcantly less accurate and pre-
cise Android models characterized by imprecise conservative
ﬂow summaries and/or blanket policies for Android API meth-
ods [8, 9, 11]. Our results show that the ability to analyze an
accurate and precise model more than makes up for any loss
of precision caused by ﬂow insensitivity (see Section VIII).
Static Communication Target Resolution: Information ﬂows
in Android apps may involve inter-component (between ap-
plication components) and inter-application (between separate
installed apps) communication; communication targets are
identiﬁed by dynamically constructed values (such as String,
Uri, and class designators) packaged in an Intent object.

To precisely analyze such ﬂows, DroidSafe combines 1) ac-
curate analysis stubs, 2) a internal representation of all deﬁned
IntentFilter registrations, 3) an analysis of operations that
construct strings; this analysis delivers regular expressions that
accurately summarize the strings that the application will con-
struct when it runs, 4) a novel points-to analysis that precisely
tracks Strings, and 5) algorithms that rewrite the DroidSafe
intermediate representation to directly invoke resolved targets.
Because DroidSafe works with a comprehensive model of
the Android environment, it supports precise resolution of
communication targets whose identiﬁcation (typically via an
Intent) involves signiﬁcant interactions with the Android
API.

These techniques enable DroidSafe to precisely analyze
calls that start Activity components; start, stop, and bind
Service components; invoke RPC calls on Service com-
ponents; send and receive Service messages; broadcast
messages to BroadcastReceiver components; and per-
form operations on ContentProvider components (shared
databases). For Intent-based resolution, DroidSafe incorpo-
rates IntentFilter registrations deﬁned both in the Android
manifest and those deﬁned programmatically in app code. We
are aware of no other analysis that can provide comparable
or even usable levels of accuracy or precision for all of these
critical Android communication mechanisms.

techniques that enable DroidSafe to deliver an analysis of
unprecedented scalability, accuracy, and robustness, 3) a set
of new mechanisms that enable these techniques to work
together to provide a comprehensive, accurate, and precise
information-ﬂow analysis for Android applications, and 4)
signiﬁcant engineering effort that delivers a comprehensive
model of the Android runtime. Speciﬁc contributions include:
• Accurate Analysis Stubs: A novel technique that enables
the rapid and accurate development of semantics miss-
ing from a source code base. Each stub is written in
the language of the implementation of the API model,
simplifying analysis. Stubs augment the implementation
with semantics possibly incomplete for the full runtime
behavior, but complete for the analysis abstractions.
• Android Device Implementation: A comprehensive and
precise model of the Android API and runtime system
implemented in Java that accurately captures the semantics
of life-cycle events, callback context, external resources,
and inter-component communication. The core of the ADI
includes 550 manually-veriﬁed Android API classes which
cover over 98% of API calls in deployed Android applica-
tions. The ADI currently models Android 4.4.3, because
updating the model for Android updates is not overly
burdensome. Independent analysis tools can readily employ
this model.
• Static Analysis Design Decisions: Our analysis occupies
a new design point for information-ﬂow analysis of An-
droid: deep object sensitivity and ﬂow insensitivity. Flow
insensistivity enables DroidSafe to accurately consider all
possible event orderings. It also enables DroidSafe to scale
to analyze an accurate and precise model of the Android
environment, which is critical for the overall success of
DroidSafe. Any loss of precision due to ﬂow-insensitivity
is more than compensated for by the analysis’s ability to
scale to analyze our accurate and precise Android model.
• Static Communication Target Resolution: A comprehen-
sive and precise model of inter-component communication
resolution in Android that links data ﬂows between sender
and target. DroidSafe includes a global Intent and Uri
value resolution analysis, IntentFilter reasoning, and
coverage of all common forms of communication. To our
knowledge it is the most complete such model to date.
• Experimental Evaluation: An evaluation demonstrating
that 1) DroidSafe achieves unprecedented precision and
accuracy for the information-ﬂow analysis of Android and
2) DroidSafe can detect malicious sensitive information
leaks inserted by sophisticated, independent hostile orga-
nizations, where a current state-of-the-art information-ﬂow
analysis largely fails.
• Full Implementation: A full open-source implementation

of DroidSafe and our ADI available upon request.

Contributions

II. BACKGROUND AND PROBLEM

This paper identiﬁes and implements, for the ﬁrst time, an
effective point in the overall Android information-ﬂow design
space. Our overarching contribution is the identiﬁcation of this
design point and the resulting DroidSafe implementation. We
attribute the ability of DroidSafe to operate at this design point
to: 1) the identiﬁcation of a set of techniques that work well
together, 2) new implementations of known program analysis

Android applications are implemented in Java on top
of the Android API. The implementation of an application
speciﬁes handlers for the dynamic events that may occur during
the execution of the application. Thus, Android applications
are dynamic and event-driven by nature. Applications have
multiple entry points, and interact heavily with the Android
API via utility and resource access classes. The package for

3

an Android application represents an incomplete program; the
source package alone is not appropriate for analysis without
an accompanying model of the Android API and runtime
semantics to exercise all possible semantics in the application.
The Android API version 4.4.3 includes over 3,500 classes
visible to an application developer. Analyzing the complete
source code for the API is exceedingly difﬁcult because it
is implemented over multiple languages and some of the
implementation is device-speciﬁc. Thus, static analysis frame-
works rely on modeling the Android API semantics. Manually
producing summaries for all of the application-visible methods
of the Android API is daunting task that is potentially error
prone. For a high-precision analysis, it is also exceedingly dif-
ﬁcult to model all semantics of the implementation regarding
memory allocation, data ﬂows, and aliasing. A blanket policy
for generating ﬂows for all API methods would risk being too
imprecise and inaccurate.

A. Event Dispatch and Ordering

An accurate model of the event dispatch and ordering must
represent all valid event orderings so that a static analysis can
accurately capture possible runtime behavior. Otherwise, an
attacker can hide ﬂows in semantics not covered by the model.
Android applications are composed of multiple components,
each implementing one of four classes: Activity, Service,
BroadcastReceiver, and ContentProvider. Each of these
components has its own life-cycle deﬁned with events for
which a callback implementation can be provided. For exam-
ple, Figure 1(a) provides an example of a single Activity that
deﬁnes two life-cycle events. These events have the potential
to run in many orders, and they are not called directly in
application code. There exists a leak of sensitive information
in one possible ordering,
if onCreate is dispatched after
onStop. This is possible if the activity is placed in the
background by user interaction, and not reclaimed by the
system before it is reactivated by the user.

In addition to life-cycle state orderings, components can
have different launching modes that specify whether a single
object should handle all activations or if a separate object is
spawned for each activation. Thus memory could be shared
across separate activations of a component.

B. Callback Context

An Android application deﬁnes callback handler methods
that are called for dynamically-dispatched runtime events.
Many event handler methods include arguments passed by the
runtime to the application for processing. These arguments
are generated by the runtime and could include data from
the application (including tainted data), depending on the
execution sequence prior to the event. We call the arguments
to a callback handler its callback context. Figure 1(b) gives
example of a ﬂow through callback context. This example
employs an Activity’s ability to save state when it is paused,
and restore that state when resumed. An accurate model must
represent these possible ﬂow connections (of which there are
possibly thousands). Policies such as injecting taint for all
callback handler arguments or connecting callback argument
ﬂows conservatively risk generating an overwhelming number
of false positives (see Section VIII).

C. Inter-component Communication (ICC)

The Android framework relies heavily on inter-component
communication (ICC) to allow individual components to be
independent and to better manage resources. Components ini-
tiate and connect to other components via android.content
.Intent objects (which can themselves contain a payload).
The resolution of Intent destination is complex [20]. An
Intent can specify a class explicitly, or implicitly allow the
Android system to select a destination based on a Uri and
string ﬁelds. Components register for implicit Intent delivery
programmatically or via their application’s XML manifest.
Service components additionally allow one to send and receive
messages and perform remote procedure calls.

An accurate model of Android must represent the possible
ﬂows via ICC mechanisms. Figure 1(c) gives an example of
three components that communicate via Intent objects and
Service messages. In the example, there is a ﬂow through
ICC from ICCSource through ICCService to ICCSink. In
addition to representing the communication, a model must
consider all possible orderings of component activations.

A blanket conservative policy to deliver Intent objects
and messages to all possible targets may not be acceptable
because applications are typically constructed of many compo-
nents. However, statically calculating the destination of each
Intent requires resolution of Intent values such as Uri
strings and action strings, and reasoning about components’
implicit IntentFilter registration.

III. THREAT MODEL AND LIMITATIONS

In our scenario the application developer (or re-packager) is
malicious. This attacker seeks to exﬁltrate sensitive data from
a mobile device to her servers or to an area on the device that
is unprotected so that a colluding application can perform the
exﬁltration.

Our deﬁnition of sensitive data includes unique device ID,
sensor data (location, acceleration, etc.), ﬁle data, image data
and meta-data, email and SMS messages, passwords, network
trafﬁc, and screen-shots. All of these data items are retrieved
or stored via the Android API; we deﬁne sources of sensitive
data as ﬂows initiated from calls to Android API methods that
we have identiﬁed (see Section IV).

The attacking developer intentionally routes sensitive data
to a destination (on or off the device) that is not authorized
by the user. We deﬁne sinks as Android API calls that may
exﬁltrate data beyond the application boundaries. Sinks include
network, NFC, ﬁle system, email or SMS message, or directly
to a colluding application via ICC or RPC. All of these
sinks are guarded by the Android API. Sinks are identiﬁed
as described in Section IV.

DroidSafe protects against explicit sensitive information
exﬁltration by tracking sensitive source to sink ﬂows present in
the application. DroidSafe analyzes an applications before it is
placed on an app store or before device install. Not every ﬂow
reported by DroidSafe is malicious; maliciousness depends on
the intent of the developer and the security policies of the user
or organization. Thus, the user or a trusted entity reviews the
information ﬂows for malicious leaks.

4

A. Limitations

We assume the device has not been rooted, and dynamic
code loading is not present in the application. We do not aspire
to detect leaks of sensitive data via side channels or implicit
ﬂows [21]. Our trusted computing base on a device is the Linux
kernel and libraries, the Android framework, and the Dalvik
VM.

DroidSafe’s reporting is deﬁned by the source and sink
calls identiﬁed in the Android API. An attacker could exﬁltrate
API-injected information that is not considered sensitive by
DroidSafe, or via a call that is not considered a sink; and it
would not be reported.

Our analysis does not have a fully sound handling of
Java native methods, dynamic class loading, and reﬂection.
However, we compensate for these idioms with aggressive
best-effort policies and analyses. Our analysis has a blanket
ﬂow policy for native methods of an Android application, but
an application could inject a sensitive ﬂow in a native method,
and DroidSafe would not report it. We attempt to aggressively
resolve reﬂection targets in a fashion similar to [22] and [23],
but if a reﬂected invoke cannot be resolved, we inject a special
REFLECTION taint on the method’s arguments and return
value (injected by DroidSafe). Thus we could miss a ﬂow
injected in an unresolved reﬂected call.

Finally, we intend the DroidSafe ADI to accurately reﬂect
the runtime semantics of Android with respect to the infor-
mation ﬂow and points-to information. While we believe we
largely cover the semantics, given the size of the Android
runtime and API we acknowledge that there may be some
methods whose semantics the current ADI does not fully
reﬂect. Different versions exist of Android, and we analyze
an application in the context of Android 4.4.3.

IV. DROIDSAFE’S ANDROID DEVICE IMPLEMENTATION
To our knowledge, our model of Android represents the
most complete, accurate, and precise Android execution model
suitable for static analysis. We accurately and precisely model
complexities such as callback context, life-cycle events, data
ﬂows, heap object instantiations, native methods, and aliasing.
Our Android model is expressed in a single language, standard
Java, matching the source language of Android applications,
and is appropriate for many existing analysis techniques.
One could think of our Android model as a software imple-
mentation of an Android device; along with the application
and harness. Thus we call our model the Android Device
Implementation (ADI).

The ADI is a simpliﬁed (thus easier to analyze) model of
the actual Android system that, with respect to our analysis,
represents a best-effort over approximation of the possible
behaviors of the real system. The combination of an applica-
tion, our ADI core, our harness, the semantic transformations
for ICC (see Section VI), and resources (unique for each
application), creates a closed application for analysis of an
Android application.

A. ADI Core

We seeded our ADI with the Java implementation of the
Android API available from the Android Open Source Project

(AOSP) [15], version 4.0.3, along with additional open-source
libraries upon which the AOSP implementation depends. This
created a code base with no missing dependencies that could
be compiled. This code base was approximately 1.3 MLOC,
however it was missing substantial portions of the semantics
of the Android API and runtime such as native methods, event
ﬁrings, callback initiation, and component life-cycle events.
Furthermore, many commonly used classes included Java
implementations that present difﬁculties for a static analysis.
We therefore developed a novel technique, accurate anal-
ysis stubs, to enable the effective analysis of code whose full
semantics lies outside the scope of AOSP. Each stub is written
in Java and only incompletely models the runtime behavior of
the modeled code. But the semantics of the stub is complete for
the abstractions that the analysis deploys (in this case points-to
and information-ﬂow analyses).

We added accurate analysis stubs for 3,176 native methods
to model the data ﬂow, object instantiation and aliasing of the
missing native code. This was accomplished through a com-
bination of automated and manual means, though all methods
were reviewed manually. We developed concrete implementa-
tions of 45 classes for which concrete implementations are left
to closed-source, commercial libraries.

We simpliﬁed the implementation of 117 classes in the Java
standard library and Android library to increase precision and
decrease analysis time. Examples include container classes,
component classes, I/O classes, primitive wrapper classes,
strings, and threading classes. We attempted to faithfully
maintain the semantics of the original code with respect to
its contract with an Android application and a ﬂow-insensitive
analysis. The base AOSP plus our additions and modiﬁcations
enable our ADI to accurately and precisely track ﬂows through
the API.

B. Event and Callback Dispatch

We created a runtime implementation hooked into the API
implementation that models component creation, shared and
saved state, life-cycle event ﬁring and argument context, and
callback event ﬁring and argument context.

For callback handlers, we implement the callback regis-
tration method to invoke the application’s callback handler
method with the appropriate arguments. For example, Android
deﬁnes the ability for a component to register to be notiﬁed
if a database has changed, and handle this change in a given
method in a new thread. The application will deﬁne a callback
handler object, and register this to be notiﬁed of database
changes. The ADI implements this registration method via
a stub that creates the thread directly, and calls the callback
method on the registered database. Since our analysis is ﬂow
insensitive and our harness is wrapped in a loop (see below),
DroidSafe considers all event orderings even though the stub
API method invokes the callback handler method directly from
the callback registration method (with the appropriate context).
For arguments to callback handlers that are generated by
the runtime system, our model creates a new object and passes
it to the registered callback handler in the app. For example,
to model a key press, our runtime system will create a new
object to represent the key press, and call the callback handler
with this object on each component.

6

We developed a separate package for implementing compo-
nent creation and life-cycle event modeling. This package con-
tains stubs for registration methods for each Android compo-
nent type: Activity, Service, BroadcastReceiver, and
ContentProvider. The harness (discussed below) instanti-
ates each application component and passes the component
object to the appropriate registration method. The registration
methods model shared preferences, saved state, global con-
text classes, and device conﬁguration. This context is passed
accurately to the life-cycle events of components.

Since our runtime system makes explicit calls to all life-
cycle events of each component, a ﬂow-insensitive analysis
can capture the ﬂow between the two life-cycle events in the
component in Figure 1(a). Also, since we accurately model
saved state through the API and back into a callback handler,
our model enables an analysis to report the ﬂow in Figure 1(b).

C. Identifying and Classifying Sources and Sinks

We manually identiﬁed 4,051 sensitive source methods and
2,116 sensitive sink methods in the Android API. We also
classiﬁed each source and sink with a high-level classiﬁcation
(e.g., location, device ID, ﬁle, network, and database) so that
analysis results can be grouped for veriﬁcation or consumption
by a human. For example, a ﬂow reported by the tool might
be: “Location data can ﬂow to the network.”

Initially, we tested SuSi, a tool that automatically identi-
ﬁes sink and source methods in the Android API [24]. The
automatically identiﬁed sources and sinks were incomplete.
We compared our identiﬁcations of sources and sinks with the
results of SuSi.1 and found that SuSi is missing hundreds of
important sources. For example, SuSi did not identify 53%
of source calls as “sensitive sources” and 32% of sink calls
as “sinks” for the malicious ﬂows in the APAC malicious
applications (see Section VIII). These missing sources and
sinks indicate the challenge of automatic identiﬁcation.

D. ADI Coverage and Keeping Current with Android Updates
The core of our model includes 550 commonly-used An-
droid API implementation classes. We manually reviewed,
added accurate analysis stubs, and veriﬁed these 550 classes.
For veriﬁcation, we manually conﬁrmed that the class im-
plementation is not missing semantics for data ﬂow, object
instantiation, and aliasing; and that event callbacks deﬁned
in the classes are called explicitly by our model (with the
proper context). For classes not
in our core set, we still
maintain high accuracy because we analyze the actual Java
implementation (with accurate analysis stubs), however we
may experience a higher level of imprecision for these classes
if their implementation is complex.

To measure the coverage of the ADI, we acquired a list of
Android API method call frequencies accumulated over 95,910
Android applications downloaded from the Google Play Store.
This list reports the number of invoke expressions to each
Android API method over all the applications. Calls to the
core 550 veriﬁed classes account for 98.1% of the total calls
over these applications.

1We used the source and sink lists for Android 4.2 in the SuSi public
repository under the directory SourceSinkLists/Android 4.2/
SourcesSinks.

We initially seeded the ADI with the AOSP version 4.0.3,
and veriﬁed the core based on this version. We have since
upgraded our model to Android 4.4.3. This process included
reviewing changes to classes in our core 550 classes between
these versions; and accounting for and verifying any changes in
the ADI. This process required one person-week of work, for
an experienced Java and Android developer. For the update, the
rest of the ADI classes were copied over from AOSP 4.4.3, and
accurate analysis stubs were created for native methods. This
process required another person-week. We expect the update
process for our ADI to continue to be relatively fast since
there are few changes to the core of Android between version
updates; historically new implementation has been contained
in new packages.

E. Harness

Each analyzed application must be hooked into the ADI
via a harness. In its ﬁrst pass, DroidSafe generates this harness
method automatically. DroidSafe scans the application source
code for all classes that subclass one of Android’s four com-
ponent types. It instantiates objects in the harness for all such
classes found. We cannot rely solely on the Android manifest
for the complete list of components, since the manifest is
required to list only components that are exported and available
to other applications. We represent each component with a
single heap object
to account for the complexities of the
Android component memory model (see Section II-A). In our
harness, each instantiated component object is passed to the
appropriate runtime method to exercise all of its life-cycle
events. The harness method is wrapped in a loop; the loop
is present to capture all possible orderings for callbacks that
are called in the harness.

Though details are beyond the scope of this paper, the
harness also includes instantiation of GUI objects deﬁned
in XML resources (including programmatically setting their
attributes, and registering event handlers, such as onClick), and
the incorporation of String values deﬁned in XML resources.

V. OBJECT-SENSITIVE POINTS-TO ANALYSIS

Points-to analysis (PTA) is a foundational static program
analysis that computes a static abstraction of all the heap
locations that a pointer (reference) variable may point to during
program execution. In addition to the points-to relation, points-
to analysis also constructs a call graph as modern languages re-
quire points-to results to calculate targets for dynamic dispatch
and functional lambda calculations. Our goal was to employ
much of the AOSP Android API implementation without mod-
iﬁcation, and achieve precise results for our client analyses.
However, as with many static analyses there is a trade-off
between scalability and precision; appropriate control-ﬂow and
data-ﬂow abstractions must be chosen to avoid intractability
and to calculate acceptably precise results.

Let us consider the difﬁculties of analyzing complex Java
code with precision. Figure 2 lists simpliﬁed ADI source code
for two commonly used classes in the Android API: android
.os.Bundle and java.util.HashMap. Bundle allocates a
HashMap. The example also provides relevant code for two
Android activities that each create a Bundle and store values
to their Bundle; Activity1 puts non-sensitive data in its

7

Fig. 2. Example source code for our ADI and two Activity objects illustrating the challenges of points-to and information ﬂow analysis.

Bundle while Activity2 puts sensitive data in its Bundle.
Consider the difﬁculty presented to an analysis given this code.
To precisely separate the two Bundle objects created ( N(cid:13) and
S(cid:13)), a PTA must separate multiple levels of allocations started
at each Bundle allocation (Bundle allocates a HashMap, H(cid:13),
which allocates an array to store entries, T(cid:13)). In other words,
an analysis must be able separate analysis facts between the
array of entries created in the two HashMaps objects of the
two Bundle objects in this code. Otherwise, sensitive data put
in one Bundle is conﬂated with data that can be retrieved from
the other Bundle, decreasing precision.

Our PTA algorithm is based on a whole-program, ﬂow-
insensitive, subset-based foundation [25] for Java on which
we have added context sensitivity. Context sensitivity is a
general approach where a PTA is able to separate analysis
facts for a method m that arise at multiple call sites of m.
There are multiple choices for context, and the DroidSafe
PTA implements object sensitivity. Accumulating evidence
demonstrates that object sensitivity is the best choice for
object-oriented languages [18, 26–28].

Object sensitivity is notoriously difﬁcult to understand and
implement [18]. Here we give the reader an intuitive descrip-
tion of object sensitivity and its scalability challenges. For a
rigorous description of object sensitivity see [18] (note that our
PTA implements a 3Full+2Heap analysis modiﬁed as described
below). An object-sensitive analysis uses object allocation sites
(new expressions in Java) as context elements. In our analysis,
a heap object, o, is represented by the allocation site of o, plus
the allocation site of the object that allocated o, and so on,
to a parameterized depth, k. For a given method, our analysis
is able to separate facts depending on the heap object of the
receiver on which the method is called.

Considering again the example in Figure 2, our analysis is
able to separate analysis facts calculated for the array table of

two HashMap objects allocated from the two Bundle objects.
When the Bundle objects are created on line 3 and line
4 of Activity1 and Activity2, respectively, a series of
allocations is performed via constructors. The object-sensitive
heap abstraction will have two separate elements representing
the two table arrays, with context being their allocation
history:

(cid:104) T(cid:13) ← H(cid:13) ← N(cid:13)(cid:105)
(cid:104) T(cid:13) ← H(cid:13) ← S(cid:13)(cid:105)

Where a ← b denotes “a allocated in b”.

The new expression on line 3 of Activity1 creates a
heap object (cid:104) S(cid:13)(cid:105), and the cascading allocations from the
constructors of Bundle and HashMap create (cid:104) H(cid:13) ← S(cid:13)(cid:105) and
(cid:104) T(cid:13) ← H(cid:13) ← S(cid:13)(cid:105), respectively.

When the Bundle.put(...) method of Activity2 is
called (line 5), the method context (receiver) for the call is
(cid:104) S(cid:13)(cid:105), this triggers a call to HashMap.put(...) (line 7 of
HashMap) with context (cid:104) H(cid:13) ← S(cid:13)(cid:105). In this context, the points-
to set result for the reference to the ﬁeld table on line 7 of
HashMap is the array object (cid:104) T(cid:13) ← H(cid:13) ← S(cid:13)(cid:105). Any elements
placed in this array via the assignment of line 7 will only be
reﬂected in this array heap object.

Thus, for the example, our PTA is able to separate analysis
facts between the two Bundle objects in the two Activities via
deep object-sensitivity. For this example, the analysis requires
a heap context depth of 3 (to distinguish (cid:104) T(cid:13) ← H(cid:13) ← N(cid:13)(cid:105)
from (cid:104) T(cid:13) ← H(cid:13) ← S(cid:13)(cid:105)).

Object sensitivity has powerful precision but scalability
presents a challenge. Our example requires a depth of 3, and
other commonly used classes require deeper depths, e.g., in
the AOSP implementation, Intent allocates a Bundle (that
allocates a HashMap...) requiring a depth of 4 to disambiguate

8

package android.os;public class Bundle ... {  private Map<String,Object> mMap = new HashMap<String,Object>();      public void put(String k, Object v) {    mMap.put(k,v);  }  public Object get(String k) {    return mMap.get(k);  }}package java.util;public class HashMap<K,V>... {  private Entry[] table = new Entry[size];  public void put(K key, V value) {    ...    table[index] = new Entry<K,V>(key, value);   }  public V get(Object key) {    ...    e = table[indexFor(hash, table.length)];    ...    return e;  }}public class Activity2 extends Activity {  ...  double sensitive = location.getLatitude(); //source  Bundle bundle2 = new Bundle();   bundle2.put("data", sensitive);  ...  sink(bundle2);  //flow of sensitive -> sink}public class Activity1 extends Activity {  ...  Bundle bundle1 = new Bundle();   bundle1.put("data", <notSensitive>);  ...  sink(bundle1);  //not a sensitive flow}Android Device Implementation (ADI) Android Application Source Code 1234567891011121312345678910111213141516123456712345678NSHTEthe items placed in the Bundle of two Intent objects. We
tested other whole-program object-sensitive frameworks, but
found they could not scale to the required context depth [29]
or did not maintain program information required for our
client [18].

analysis analyzes m without context, conﬂating the analysis
results of all calls to m on objects of c. For information-ﬂow
analysis, this relaxation means that, in m, if a sensitive taint
ﬂows to a ﬁeld f of an object of a class c, the taint will
(imprecisely) ﬂow to f for all heap objects of class c.

To solve this scalability challenge, our points-to analysis
implementation operates on the pointer assignment graph
(PAG) representation of the program [30], an explicit represen-
tation of the program. In the past, while explicit implementa-
tions provided the fastest running times, they would typically
exhaust main memory for large programs [29, 31]. However,
today, with the large and increasing size of available main
memory, we found that an explicit implementation can now
scale to large programs.

Furthermore, our implementation is ﬂexible and parameter-
ized. This ﬂexibility enables us to implement a series of client
analysis-speciﬁc and Android-speciﬁc optimizations of our
object-sensitive points to analysis. Without our optimizations 3
of the 24 APAC applications (see Section VIII) could not ﬁnish
analysis in DroidSafe given a limit of 64GB of heap memory.
With optimizations, all applications now run in under 34GB of
heap memory. The optimizations provide a savings of 5.1x in
total analysis time. We highlight the important optimizations
here.

A. Selectively Applying Context

Typically, a points-to analysis keeps the same base context
depth for all allocated objects. Initially, we tried this policy, at
a depth of 3, for the applications in our APAC suite. However,
our analysis would fail on 3 of our APAC applications because
it exhausted 64GB of allocated heap memory. Instead we
implement a targeted approach: we add context for an abstract
heap location at the minimum depth that is required to achieve
precision for one of our client analyses. The depth of context
on abstract heap objects varies from 0 to 4. The context depth
is calculated based on the following.

By analyzing a suite of 211 Android applications for which
we had source, we learned which API classes from our ADI
could be analyzed content-insensitively without signiﬁcant loss
of precision for clients of the PTA. We performed our points-to
analysis on our suite, and determined API classes that could
never reach (via a series of local or ﬁeld references) a String
value our Intent resolution analysis was tracking, and could
never reach a value that was tainted with sensitive information
ﬂow (across all Android applications in our suite).

This set, S, contains 1489 Android API classes. Most of
these classes are Android GUI objects and libraries through
which sensitive data should never ﬂow. For all c ∈ S, our
clients analyses will calculate the same results regardless of
whether an object of c in the heap abstraction of our PTA has
context or not (for the 211 Android applications analyzed).
This set represents 26% of the total classes of our ADI. We
extrapolate that context-insensitivity analyzing the classes of
S in our will give us an acceptable loss of precision across all
Android applications.

Conversely with a maximum context depth of 3, our points-
to analysis is unable to disambiguate many important analysis
facts. For example, we could not disambiguate the Bundle
between separate Intent objects (as discussed above). To
address this issue, we automatically increase the context depth
to 4 for all heap objects of Array type. In the example of
Figure 2, this means that the array object allocated at line
3 of HashMap has a depth of 4, giving it enough context to
disambiguate the Intent object that allocated the Bundle that
allocated the HashMap that allocated the array. This general
strategy works across containers in the Java and Android API
packages.

IMPROVING THE PRECISION OF ICC MODELING

VI.
Inter-component communication (ICC) is common in An-
droid applications and must be modeled both accurately and
precisely. However, the AOSP implementation of ICC-related
classes is incomplete (relying on native methods for target
resolution and payload delivery). To achieve precision, we
implement our own model of ICC via accurate analysis stubs,
aggressively resolve dynamic program values, and transform
application code to increase precision.

Intent objects describe ICC destinations. Values involved
in the resolution include both java.lang.String and java
.lang.Class objects. We resolve these values statically to
guide precision-enhancing transformations. Our ADI provides
us with an accurate and precise model for resolution analysis
of values involved in Intent resolution.

Strings are an essential base value type of many of the
Intent ﬁelds. To resolve string values given the myriad opera-
tions performed on strings, we employ the JSA String Analyzer
(JSA) [32]. JSA is a ﬂow-sensitive and context-insensitive
static analysis that includes a model of common operations
on Java’s String type. For a given String reference, the
analysis computes a multi-level automaton representing all
possible string values. As a ﬁrst pass, we run JSA (on only the
application source) to resolve values for string references that
are arguments to Android API calls. We convert each resolved
automaton to a regular expression that represents the possible
values of the string value.

After JSA is run, we replace resolved string values in the
application code with constants representing their computed
regular expression, and perform a pass of our points-to analysis
such that these values can be propagated globally. We run our
points-to analysis and store the results of this analysis for
all string references in the program, such that later we can
query the resolved regular expressions representing values for
all string references in application code.

A. Resolving Explicit Intent Destinations

We modiﬁed our PTA to never attach context to an alloca-
tion of or a method call on an object of a class in S. This means
that for a method m called on c ∈ S, the information-ﬂow

Explicit Intent objects are initiated with the destination
component’s fully-qualiﬁed class name or class constant ob-
ject. Before the PTA is run, each class constant passed to a

9

Source Method
Context: void send*Broadcast(Intent, ...) [6 variants]
Activity: void startActivit*(Intent, ...) [6 variants]
Context: void bindService(Intent, Connection)
Context: void startService(Intent)
ContentResolver: insert, query, delete, update

Target Method Call Injected

BroadcastReceiver: void onReceive(Intent)
Activity: void setIntent(Intent)
Service: void droidSafeOnBind(Intent, Connection)
Service: void onStartCommant(Intent, ...)
ContentProvider: insert, query, delete, update

Fig. 3. DroidSafe’s ICC source to target methods transformations.

method of Intent is converted into a component name string
constant representing the class. To determine the destinations
of an Intent object in our abstract heap, we query the points-
to information for the ﬁelds of component name. If all of the
strings objects in the points-to set are constants, we consider
the Intent object resolved.

B. Resolving Implicit Intent Destinations

Implicit Intent objects are Intent objects for which
a component name is not speciﬁed;
in our analysis these
are Intent objects for which the component name ﬁeld
is null. Implicit Intent objects do not directly reference
a destination but instead leave it to the Android system to
deliver them to the appropriate destination(s). A component
registers as a destination of implicit Intent objects by declar-
ing IntentFilter elements in the manifest or program-
matically installing IntentFilter objects on components.
IntentFilter registrations specify string constants that the
component will accept for the action, category, data type,
and uniform resource identiﬁer (Uri) ﬁelds of a dispatched
Intent. We parse the Android manifest, and keep a map
of implicit Intent registrations,
i.e., for each component
the implicit Intent ﬁeld values it accepts. We also sup-
port updating this map with programmatic registrations for
BroadcastReceiver objects, by modeling IntentFilter.
An implicit Intent object in our abstract heap is resolved
if our PTA concludes that the points-to set for one of the action,
category, data type, or Uri ﬁelds reference only constants (or
is empty).

For a resolved implicit Intent, i, we build i’s list of in-
app targets by comparing to each component’s intent ﬁlter. For
component c, we test the action, category, data type, and Uri
ﬁelds in sequence. For each ﬁeld, if i’s ﬁeld is unresolved,
then the test passes. If the ﬁeld of i is resolved, then if any
of its string constants are in the set of strings accepts by c’s
intent ﬁeld for the ﬁeld, then it is a match. All ﬁelds of i have
to pass the test against the respective ﬁelds of c’s intent ﬁlter
for i to be able to target c.

There is additional complexity for programmatic intent
ﬁlters, as DroidSafe may not be able to resolve all ﬁelds of an
intent ﬁlter to constants. An intent ﬁlter ﬁeld that cannot be
resolved matches the respective ﬁeld for all Intents.

C. Transforming ICC calls to Improve Precision

ICC initiation calls are methods that pass an Intent to
Android’s runtime system to perform inter-component com-
munication or binding. Our strategy for improving precision
for ICC is to transform ICC initiation calls into appropriate
method calls at the destination(s), thus linking the data ﬂows
between source and destination.

Figure 3 presents a list of the most common ICC initiation
calls, and the linkage calls that are inserted by DroidSafe to
improve precision and accuracy. For example, for an invoke of
startActivity(Intent), we transform this call into calls
of the destination activities’ setIntent(Intent), linking
the source and targets. Thus when a target Activity calls
getIntent(), all Intent objects that could possibly be sent
to the Activity are calculated by our PTA (we update the PTA
result after all ICC transformations are completed).

For ICC initiation calls on resolved Intent objects, we
link the ICC initiation call to only the destination compo-
nents that are speciﬁed by the Intent. This is achieved
by calling the appropriate linkage method on the heap ob-
ject allocated in our harness for the destination component.
For unresolved Intent objects, we insert linkage calls to
all components of
the appropriate type. For example, a
startActivity(Intent) call with an unresolved Intent
is delivered to all Activity components.

D. Android Services

Android Service components require additional sophistica-
tion because in addition to Intent-mediating communication,
messaging and RPCs can be performed. We illustrate our
Service transformations via the examples in Figure 1(c). In this
example, the Activity ICCSource binds and sends a messages
to the Service ICCService. The important steps performed by
DroidSafe to resolve this ﬂow are as follows:
1) Our manifest parser maps the Intent action string “ICC-

ServiceAction” to ICCService.

2) DroidSafe resolves the Intent object on line 15 as an
Implicit Intent with action string “ICCServiceAction”.
Consulting the implicit IntentFilter registration map,
we see the Intent’s destination is ICCService.

3) The call

to bindService(...) on line 16 is trans-
formed to a linkage call to the harness object representing
ICCService. This linkage call is a new method we deﬁne
in our ADI for Service, droidSafeOnBind(Intent,
ServiceConnection). The linkage method performs the
following (some details omitted):
a) Invoke

receiver’s)
onBind(Intent) method to retrieve the Binder
object. The ADI model for android.os.Messenger
.getBinder() creates a Binder that references the
Messenger object which created it.

ICCService’s

(the

b) Invoke

onServiceConnected(ComponentName,
Binder) on the passed ServiceConnection object,
passing
from
ICCService’s onBind() method.

the android.os.Binder returned

With the linkage methods called, the Binder object used
to create the Messenger in ICCSource line 7 is con-

10

nected to the IncomingHandler of line 8 of ICCService.
The method android.os.Messenger.send(Message) has
a stub to call
the handleMessage(Message) method of
its Handler object. Thus, the call mService.send(msg)
on line 23 of ICCSource will deliver
the message to
the handleMessage(Message) method of ICCService’s
Messenger object.

This is just one example of binding and message communi-
cation in Android that we support. The DroidSafe ICC model
supports precision increasing transformations for common
forms of ICC, and handles uncommon cases conservatively.

INFORMATION-FLOW ANALYSIS

VII.
information-ﬂow analysis

Our

computes

over-
approximation of all
the memory states that occur during
the execution of a program. The analysis is designed as a
forward data-ﬂow analysis. For each type of statement, we
deﬁne a transfer function in terms of how it changes the state
of memory.

an

We divide memory into four separate areas that store local
variables, instance ﬁelds, static ﬁelds, and arrays, reﬂecting the
semantics of the Java programming language:

Memory = Local × Instance × Static × Array
Local = Ctx × Var → InfoVal
Instance = Loc × Field → InfoVal
Static = Class × Field → InfoVal
Array = Loc → InfoVal

Ctx, Loc = AllocSitek

Each of the memory areas is modeled as a function
whose codomain consists of a set of information values. An
information value is a tuple of the type of information and the
source code location where the information was ﬁrst injected.
Our analysis can identify not only the kind of information
being exﬁltrated but the code location of the source.

In the local variable area, Local, each method’s local vari-
ables are parameterized by their calling contexts (i.e. the heap
location of a receiver object), so the precision of the analysis
does not decrease when a method is called in various contexts.
In other words, our information-ﬂow analysis analyzes local
variables in a ﬂow-insensitive and object-sensitive fashion.

The instance ﬁeld area, Instance, is a function that takes
as its arguments an abstract heap location and an instance
ﬁeld. The return value is information values that ﬂow into
the instance ﬁeld of objects at the heap location. Note that an
abstract heap location consists of a series of allocation sites
(see Section V). This area corresponds to what is colloquially
called “context-sensitive (or object-sensitive) heap” or “heap
cloning” in the literature [18]. Each static ﬁeld of each class
has an entry in the static ﬁeld area, Static. Unlike the memory
area for instance ﬁelds, the static ﬁeld area is not parameterized
by heap locations because, in Java, all objects of each class
share the static ﬁelds of the class.

The analysis collects all information values that are as-
signed to the elements of an array and stores the result at
a single heap location of the array area, Array. That is, we
analyze arrays in an array-index-insensitive fashion.

11

An information value is

injected into an appropri-
ate memory area when a source API method is invoked
from application code. More speciﬁcally, for the statement
r = o.source(a) where r is of primitive type, the analysis
puts an information value into an entry in the local variable
area that corresponds to the r variable in the current calling
context; the stored information value consists of the statement’s
location and the type of information associated with the
source method. If r is a reference, the information value
is stored in the special taint ﬁeld of an instance that r refers
to in the current calling context.

For each o.sink(a, ...) statement that invokes a sink
method, DroidSafe reports the information values for accessed
memory addresses in the sink. For each argument (and the
receiver o), DroidSafe reports all the information values that
are attached to memory addresses (and their taint ﬁeld) read
during the execution of the body of the sink method (among
memory addresses reachable from the argument).

In Figure 2, the analysis injects an information value into
the sensitive variable when Location.getLatitude(),
a source API method, is invoked (line 3 of Activity2).
The information value consists of the line number and the
type of information (for this case, a user’s location). For the
invocation of Bundle.put() method (line 5 of Activity2),
the transfer functions of the statements in the body of Bundle
.put() convey the information value from the sensitive
variable to the value ﬁeld of an Entry object whose heap
location is (cid:104) E(cid:13) ← H(cid:13) ← S(cid:13)(cid:105). At the call to a sink API
method (line 7 of Activity2), the analysis reports 1) a user’s
location information is reachable from the bundle2 argument,
2) the information was generated ﬁrst at line 3, and 3) whether
the body of the sink method actually uses the information by
reading the Entry.value ﬁeld. On the other hand, for the call
to a sink API method in Activity1 (line 6 of Activity1),
the analysis correctly reports that a user’s location information
is not reachable from the bundle1 argument. That is, even
though the Entity objects in Activity1 and Activity2
are both created at the same program location E(cid:13), the analysis
properly distinguishes information ﬂows into them because
each of them has its own heap location ((cid:104) E(cid:13) ← H(cid:13) ← N(cid:13)(cid:105)
and (cid:104) E(cid:13) ← H(cid:13) ← S(cid:13)(cid:105), respectively).

VIII. EVALUATION

This section presents experimental results that characterize
the effectiveness of DroidSafe’s information-ﬂow analysis. Our
results indicate:

1) DroidSafe achieves both higher precision and accuracy than
FlowDroid [8] + IccTA [14] a current state-of-the-art An-
droid information-ﬂow analysis. [8] and [14] demonstrate
that FlowDroid + IccTA achieve both higher precision and
accuracy than commercially available tools such as IBM’s
AppScan Source [33] (which was speciﬁcally designed to
analyze Android apps) and HP’s FortifySCA [34].

2) DroidSafe successfully reports all malicious leaks of sen-
sitive information in a suite of malicious Android applica-
tions developed by independent, motivated, and sophisti-
cated attackers from three hostile Red Team organizations.
3) DroidSafe successfully scales to analyze large Android

applications analyzed in the context of our ADI.

there

are

Across

the APAC applications,

131
ContentProvider operations. Of
the operations, 66.4%
use Uri objects that DroidSafe resolves. Of the resolved
operations, 35.6% target a components of the application, and
each resolved operation targets 1.0 components. Epicc does
not resolve Uri values, and consequently FlowDroid does not
link ﬂows through ContentProvider operations.

IX. RELATED WORK

Object-Sensitive Points-To Analysis: For robustness and ﬂex-
ibility, typical whole-program object-sensitive analysis imple-
mentations reduce program facts into representations appropri-
ate for general solvers; examples include logic relations [18],
constraints [31], and binary decision diagrams [29, 38]. Our
implementation differs from these systems in that it operates
directly on the pointer assignment graph (PAG) representation
of the program [30], an explicit representation of the program.
Previous work has demonstrated that direct implementations
of points-to analysis problems, when they ﬁt in memory, are
typically faster than general solvers [29, 31]. Today main
memory sizes are large enough to accommodate our direct im-
plementation of a context sensitive analysis of large programs.
Tuning context-sensitivity of an analysis for precision
and scalability has also received much work. Hybrid context
sensitivity treats virtual and static method calls differently, and
in addition to object sensitivity, attempts to emulate call-site
sensitivity for static calls [39]. Our analysis implements hybrid
context sensitivity by cloning static method calls for calls to
application methods, and certain API factory methods. Type
sensitivity is a form of object sensitivity that merges contexts
based on types [18]. We tried type sensitivity for our client, but
it did not provide adequate precision. An introspective analysis
drops context sensitivity from program elements that could
blow-up the analysis [19], without regard for precision of the
client. In client-driven approaches [40], a client analysis asks
for more precision from the points-to analysis when needed.
In contrast, our technique pre-calculates the set of classes
(and thus allocations and methods calls) for which precision
is historically not helpful for our problem.
Information-Flow Security Analysis: DroidSafe follows a
long history of information-ﬂow analysis (sometimes called
taint analysis) systems for security. Livshits and Lam [41]
present an approach for taint analysis of Java EE applications
that is demand-driven, uses call-site context sensitivity, and
shallow object sensitivity via inlining. TAJ [42] focuses on
Java web application and employs a program slicing technique
combined with a selective object-sensitive analysis. F4F [16] is
a taint analysis for Java applications built on web frameworks
that uses a speciﬁcation language to describe the semantics of
the underlying framework.

Focusing on information-ﬂow analysis for Android, Flow-
Droid [8] is a sophisticated, open-source static information
ﬂow analysis for Android applications. FlowDroid’s analysis
is ﬂow-sensitive, and thus, is more precise than DroidSafe,
however the FlowDroid model of Android is not nearly as
complete as DroidSafe’s. FlowDroid attempts to compensate
with inaccurate blanket ﬂow policies on unmodeled API
methods. From testing, we discovered that FlowDroid does
not accurately model all possible combinations of life-cycle

15

or callback events, demonstrating the difﬁculty of modeling
Android execution in a ﬂow-sensitive system. FlowDroid’s
analysis is on-demand and ﬂow-sensitive as opposed to Droid-
Safe. However, each instantiation of the analysis is expensive;
in preliminary experiments running FlowDroid with our ADI,
the analysis completed only 7 of 24 applications given a 2
hour timeout for each application.

Epicc [36] is a tool that resolves Intent destinations in
an application. Epicc developed a model of commonly-used
classes and methods involved in the Android Intent imple-
mentation. Their analysis is on-demand and ﬂow-sensitive. The
DroidSafe system includes a more comprehensive model of
classes and mechanisms used in inter-component and inter-
application communication (for example Uri and Service
messages). DroidSafe’s resolution can also reason about values
created in and passed through API methods.

IccTA [14] combines FlowDroid with Epicc and seeks to
identify sensitive inter-component and inter-application infor-
mation ﬂows. DidFail [43] also combines FlowDroid and Epicc
to discover sensitive ﬂows across applications. Though not
discussed here, DroidSafe includes an analysis to capture inter-
application ﬂows via a database of previously resolved Intent
values and reachable source ﬂows. This database is consulted
and appropriate ﬂows are injected before information analysis.
There are other many other examples of static information
ﬂow analyses for Android. CHEX [7] detects information
ﬂow vulnerabilities between components. ScanDal [9] is a
static analysis implemented as an abstract interpretation of
Dalvik bytecode. CHEX and ScanDal employ analysis with
k = 1 call-site context sensitivity. SCanDroid [11] resolves
data ﬂows between components using a limited model of
Android, and conservative ﬂow policies for API methods.
LeakMiner [12] tracks ﬂows with a context-insensitive anal-
ysis. AndroidLeaks [13] combines both context-sensitive and
context insensitive analyses, but models ﬂows through API
methods with a blanket policy that reduces precision. Droid-
Safe includes a more precise analysis and has a more accurate
and precise model of the Android API than these other tools.
Dynamic testing and monitoring approaches engender dif-
ferent tradeoffs compared to static analysis. Examples include
the sophisticated dynamic taint-tracking tool TaintDroid [5],
and Tripp and Rubin [44] who describe an approach for
classifying information leakages by considering values that
ﬂow through sources and sinks. They do not have issues with
reﬂection and dynamic class loading. But, if employed for
triage, they require adequate test coverage. If used for dynamic
monitoring they are susceptible to denial-of-service attacks if
malware is activated during execution and the application is
killed or functionality is disabled. This might be unacceptable
for mission-critical applications. Similar to static analysis, they
require user-mediated judgment for reported sensitive ﬂows.
DroidSafe’s list of sources and sinks was compiled man-
ually. SuSi [24] employs supervised machine learning to au-
tomatically designate source and sink methods in the Android
API. Merlin [45] is a probabilistic approach that employs a
potentially incomplete list of sources, sinks, and sanitizers
to calculate a more comprehensive list. Merlin automatically
infers an information ﬂow speciﬁcation for an application
from its propagation graph using probabilistic inference rules.

While SuSi’s list proved incomplete for the APAC applications,
Merlin’s technique is complementary to ours and a possible
next step for helping the results of DroidSafe.

X. CONCLUSION

Malicious leaks of sensitive information pose a signiﬁcant
threat to the security of Android applications. Static analysis
techniques offer one way to detect and eliminate such ﬂows.
The complexity of modern application frameworks, however,
can pose a major challenge to the ability of static analyses to
deliver acceptably accurate and precise analysis results.

Our experience developing DroidSafe shows that 1) there
is no substitute for an accurate and precise model of the
application environment, and 2) using the model to drive the
design decisions behind the analysis and supporting techniques
(such as accurate analysis stubs) is one effective but (in-
evitably) labor-intensive way to obtain an acceptably precise
and accurate analysis. As long as there are complex application
frameworks, we anticipate that making an appropriate set of
design decisions (such as the use of a scalable ﬂow insensitive
analysis) to successfully navigate the trade-off space that the
application framework implicitly presents will be a necessary
prerequisite for obtaining acceptable accuracy and precision.
Our results indicate that the ﬁnal DroidSafe system, with
its combination of a comprehensive model of the Android
runtime and an effective set of analyses and techniques tailored
for that model, takes a signiﬁcant step towards the ﬁnal goal
of an information ﬂow analysis that can eliminate malicious
information leaks in Android applications.

ACKNOWLEDGMENT

We would like to thank our shepherd, Ben Livshits, and
our anonymous reviewers for their insightful comments. This
material is based on research sponsored by DARPA under
agreement number FA8750-12-X-0110. The U.S. Government
is authorized to reproduce and distribute reprints for Gov-
ernmental purposes notwithstanding any copyright notation
thereon.

REFERENCES

[1] A. P. Felt et al., “A survey of mobile malware in the wild,” Security,

vol. 55, p. 3, 2011.

[2] M. C. Grace, W. Zhou, X. Jiang, and A.-R. Sadeghi, “Unsafe exposure

analysis of mobile in-app advertisements,” in WISEC, 2012.

[3] A. P. Felt et al., “Android Permissions Demystiﬁed,” CCS, 2011.
[4] N. J. Percoco and S. Schulte, “Adventures in Bouncerland,” 2012.
[5] W. Enck, P. Gilbert, B. Chun, and L. Cox, “TaintDroid: an information
ﬂow tracking system for real-time privacy monitoring on smartphones,”
in OSDI, 2010.

[6] A. Reina, A. Fattori, and L. Cavallaro, “A System Call-Centric Anal-
ysis and Stimulation Technique to Automatically Reconstruct Android
Malware Behaviors,” in EuroSec, 2013.

[7] L. Lu et al., “CHEX: Statically Vetting Android Apps for Component

Hijacking Vulnerabilities,” in CCS, 2012.

[8] S. Arzt et al., “FlowDroid: Precise Context, Flow, Field, Object-sensitive
and Lifecycle-aware Taint Analysis for Android Apps,” in PLDI, 2014.
[9] J. Kim, Y. Yoon, K. Yi, and J. Shin, “Scandal: Static Analyzer for

Detecting Privacy Leaks in Android Applications,” in MoST, 2012.

[10] E. Chin, A. Felt, K. Greenwood, and D. Wagner, “Analyzing inter-

application communication in Android,” in MobiSys, 2011.

[11] A. P. Fuchs, A. Chaudhuri, and J. S. Foster, “ScanDroid: Automated

Security Certiﬁcation of Android Applications,” Tech. Rep., 2010.

16

[12] Z. Yang and M. Yang, “Leakminer: Detect

information leakage on

android with static taint analysis,” in WCSE, 2012, p. 104.

[13] C. Gibler, J. Crussell, J. Erickson, and H. Chen, “AndroidLeaks: auto-
matically detecting potential privacy leaks in android applications on a
large scale,” Trust and Trustworthy Computing, 2012.

[14] L. Li et al., “I know what leaked in your pocket: uncovering privacy

leaks on Android Apps with Static Taint Analysis,” CoRR, 2014.

[15] Google, “Android Open Source Project.” [Online]. Available: https:

//source.android.com/

[16] M. Sridharan et al., “F4F:

taint analysis of framework-based web

applications,” in OOPSLA, 2011.

[17] K. Z. Chen et al., “Contextual Policy Enforcement in Android Applica-

tions with Permission Event Graphs,” in NDSS, 2013.

[18] Y. Smaragdakis, M. Bravenboer, and O. Lhoták, “Pick Your Contexts

Well: Understanding Object-Sensitivity,” in POPL, 2011.

[19] Y. Smaragdakis, G. Kastrinis, and G. Balatsouras, “Introspective analy-

sis: context-sensitivity, across the board,” in PLDI, 2014.

[20] Google, “Intent and Intent Filters.” [Online]. Available: http://developer.

android.com/guide/components/intents-ﬁlters.html

[21] D. King, B. Hicks, M. Hicks, and T. Jaeger, “Implicit ﬂows: Can’t live

with ’Em, can’t live without ’Em,” in ICISS, 2008.

[22] Y. Smaragdakis, G. Kastrinis, G. Balatsouras, and M. Bravenboer, “More

Sound Static Handling of Java Reﬂection,” Tech. Rep., 2014.

[23] B. Livshits, J. Whaley, and M. S. Lam, “Reﬂection Analysis for Java,”

in APLAS, 2005.

[24] S. Rasthofer, S. Arzt, and E. Bodden, “A machine-learning approach for

classifying and categorizing android sources and sinks,” NDSS, 2014.

[25] L. O. Andersen, “Program Analysis and Specialization for the C Pro-

gramming Language,” Ph.D. dissertation, U. of Copenhagen, 1994.

[26] M. Bravenboer and Y. Smaragdakis, “Strictly declarative speciﬁcation of

sophisticated points-to analyses,” in OOPSLA.

[27] O. Lhotak, “Program analysis using binary decision diagrams,” Ph.D.

dissertation, McGill University, Montreal, 2006.

[28] M. Sridharan et al., Aliasing in Object-Oriented Programming. Springer

Berlin Heidelberg, 2000.

[29] M. Berndl et al., “Points-to analysis using BDDs,” PLDI, 2003.
[30] O. Lhotak, “SPARK: A Flexible Points-To Analysis Framework for

Java,” Ph.D. dissertation, McGill University, Montreal, 2002.

[31] J. Kodumal and A. Aiken, “Banshee: A scalable constraint-based analysis

toolkit,” in SAS, 2005.

[32] A. S. Christensen, A. Mø ller, and M. I. Schwartzbach, “Precise Analysis

of String Expressions Static Analysis,” in SAS, 2003.

[33] IBM, “IBM Security AppScan.” [Online]. Available: http://www-03.

ibm.com/software/products/de/appscan

[34] HP, “Enterprise Security Intelligence.” [Online]. Available: http:

//www8.hp.com/us/en/software-solutions/enterprise-security.html

[35] R. Vallée-Rai, E. Gagnon, and L. Hendren, “Optimizing Java bytecode

using the Soot framework: Is it feasible?” CC, 2000.

[36] D. Octeau et al., “Effective inter-component communication mapping in
android with epicc: An essential step towards holistic security analysis,”
in Usenix Security, Washington D.C., USA, 2013.

[37] A. Jordan, A. Gladd, and A. Abramov, “Android Malware Survey,”

Raytheon BBN Technologies, Tech. Rep. April, 2012.

[38] P. Liang and M. Naik, “Scaling abstraction reﬁnement via pruning,” ACM

SIGPLAN Notices, vol. 47, no. 6, p. 590, 2012.

[39] G. Kastrinis and Y. Smaragdakis, “Hybrid Context-Sensitivity for Points-

To Analysis,” in PLDI, 2013.

[40] S. Guyer and C. Lin, “Client-driven pointer analysis,” SAS, 2003.
[41] V. B. Livshits and M. S. Lam, “Finding Security Vulnerabilities in Java

Applications with Static Analysis,” in USENIX Security, 2005.

[42] O. Tripp et al., “TAJ: Effective Taint Analysis of Web Applications,” in

PLDI, 2009.

[43] W. Klieber et al., “Android taint ﬂow analysis for app sets,” in SOAP,

2014.

[44] O. Tripp and J. Rubin, “A Bayesian Approach to Privacy Enforcement

in Smartphones,” in USENIX Security, 2013.

[45] B. Livshits, A. V. Nori, S. K. Rajamani, and A. Banerjee, “Merlin:
Speciﬁcation Inference for Explicit Information Flow Problems,” in
PLDI, 2009.

