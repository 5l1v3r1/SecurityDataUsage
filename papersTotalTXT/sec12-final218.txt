I Forgot Your Password: Randomness Attacks Against PHP Applications∗

Dept. of Informatics & Telecom.,

Dept. of Informatics & Telecom.,

Aggelos Kiayias

University of Athens,
aggelos@di.uoa.gr

& Computer Science and Engineering,
University of Connecticut, Storrs, USA.

PHP for example lacks a built-in cryptographically se-
cure PRNG in its core and until recently, version 5.3, it
tottaly lacked a cryptographically secure randomness
generation function.

This left PHP programmers with two options: They
will either implement their own PRNG from scratch
or they will employ whatever functions are offered by
the API in a “homebrew” and ad-hoc fashion. In ad-
dition, backwards compatibility and other issues (cf.
section 2), often push the developers away even from
the newly added randomness functions, making their
use very limited. As we will demonstrate and heavily
exploit in this work, this approach does not produce
secure web applications.

Observe that using a low entropy source or a crypto-
graphically weak PRNG to produce randomness does
not necessarily imply that an attack is feasible against
a system. Indeed, so far there have been a very limited
number of published attacks based on the insecure us-
age of PRNG functions in PHP, while popular exploit
databases1 contain nearly zero exploits for such vul-
nerabilities (and this may partially explain the delay in
the PHP community adopting secure randomness gen-
eration functions). Showing that such attacks are in
fact very practical is the objective of our work.

In this paper we develop generic techniques and al-
gorithms to exploit randomness vulnerabilities in PHP
applications. We describe implementation issues that
allow one to either predict or completely recover the
initial seed of the PRNGs used in most web applica-
tions. We also give algorithms for recovering the in-
ternal state of the PRNGs used by the PHP system, in-
cluding the Mersenne twister generator and the glibc
LFSR based generator, even when their output is trun-
cated. These algorithms could be used in order to
attack hardened PHP installations even when strong
seeding is employed, as it is done by the Suhosin ex-
tension for PHP and they may be of independent inter-
est.

We also conducted an extensive audit of several pop-
ular PHP applications. We focused on the security
of password reset implementations. Using our attack

George Argyros

University of Athens,

argyros.george@gmail.com

Abstract

We provide a number of practical techniques and
algorithms for exploiting randomness vulnerabilities
in PHP applications.We focus on the predictability of
password reset tokens and demonstrate how an attacker
can take over user accounts in a web application via
predicting or algorithmically derandomizing the PHP
core randomness generators. While our techniques are
designed for the PHP language, the principles behind
our techniques and our algorithms are independent of
PHP and can readily apply to any system that utilizes
weak randomness generators or low entropy sources.
Our results include: algorithms that reduce the entropy
of time variables, identifying and exploiting vulnera-
bilities of the PHP system that enable the recovery or
reconstruction of PRNG seeds, an experimental analy-
sis of the H˚astad-Shamir framework for breaking trun-
cated linear variables, an optimized online Gaussian
solver for large sparse linear systems, and an algorithm
for recovering the state of the Mersenne twister gen-
erator from any level of truncation. We demonstrate
the gravity of our attacks via a number of case studies.
Speciﬁcally, we show that a number of current widely
used web applications can be broken using our tech-
niques including Mediawiki, Joomla, Gallery, osCom-
merce and others.

1

Introduction

Modern web applications employ a number of ways
for generating randomness, a feature which is critical
for their security. From session identiﬁers and pass-
word reset tokens, to random ﬁlenames and password
salts, almost every web application is relying on the
unpredictability of these values for ensuring secure op-
eration. However, usually programmers fail to under-
stand the importance of using cryptographically secure
pseudorandom number generators (PRNG) something
that opens the potential for attacks. Even worse, the
same trend holds for whole programming languages;

∗Research partly supported by ERC Project CODAMODA.

1e.g. http://www.exploit-db.com

1

framework we were able to mount attacks that take
over arbitrary user accounts with practical complex-
ity. A number of widely used PHP applications are
affected (see Figure 7), while we believe that the im-
pact is even larger in less known applications.

Our results suggest that randomness attacks should
be considered practical for PHP applications and ex-
isting systems should be audited for these vulnerabili-
ties. Weak randomness is a grave vulnerability in any
secure system as it was also recently demonstrated in
the widely publicized discovery of common primes in
RSA public-keys by Lenstra et al.
[14]. We ﬁnally
stress that our techniques apply in any setting beyond
PHP, whenever the same PRNG functions are used and
the attack vector relies on predicting a system deﬁned
random object.

This is only an extended abstract, a full version can

be found in [1].

1.1 Attack model
In Figure 1 we present our general attack template. An
attacker is trying to predict the password reset token in
order to gain another user’s privileges (say an admin-
istrator’s). Each time the attacker makes a request to
the web server, his request is handled by a web appli-
cation instance, usually represented by a speciﬁc op-
erating system process, which contains some process
speciﬁc state. The web application uses a number of
application objects with values depending on its in-
ternal state, with some of these objects leaking to the
attacker through the web server responses. Examples
of such objects are session identiﬁers and outputs of
PRNG functions. Although our focus is in password
reset functions, the principles that we use and the tech-
niques that we develop can be readily applied in other
contexts when the application relies on the generation
of random values for security applications. Examples
of such applications are CAPTCHA’s and the produc-
tion of random ﬁlenames.

Attack complexity. Since we present explicit practi-
cal attacks, we deﬁne next the complexity under which
an attack should be consider practical. There are two
measure of complexity of interest. The ﬁrst is the time
complexity and the second is the query or communi-
cation complexity. For some of our attacks the main
compuational operation is the calculation of an MD5
hash. With current GPU technologies an attacker can
perform up to 230 MD5 calculations per second with
a $250 GPU, while with an additional $500 can reach
up to 232 calculations [9]. These ﬁgures suggest that
attacks that require up to 240 MD5 calculations can
be easilty mounted. In terms of communication com-
plexity, most of our attacks have a query complexity
of a few thousand requests at most, while some have
as little as a few tens of requests. Our most commu-
nication intensive attacks (section 5) require less than

35K(≈ 215) requests. Sample benchmarks that we per-
formed in various applications and server installations
show that on average one can perform up to 222 re-
quests in the course of a day.

2 PHP System

We will now describe functionalities of the PHP sys-
tem that are relevant to our attacks. We ﬁrst describe
the different modes in which PHP might be running,
and then we will do a description of the randomness
generation functions in PHP. We focus our analysis in
the Apache web server, the most popular web server at
the time of this writing, however our attacks are easily
ported to any webserver that meets the conﬁguration
requirements that we describe for each attack.

2.1 Proccess management
There are different ways in which a PHP script is ex-
ecuted. These ways affect its internal states, and thus
the state of its PRNGs. We will focus on the case when
PHP is running as an Apache module, which is the de-
fault installation in most Linux distributions and is also
very popular in Windows installations.

mod php: Under this installation the Apache web
server is responsible for the process management.
When the server is started a number of child proccesses
are created and each time the number of occupied pro-
cesses passes a certain threshold a new process is cre-
ated. Conversely, if the idle proccesses are too many,
some processes are killed. One can specify a maxi-
mum number of requests for each process although this
is not enabled by default. Under this setting each PHP
script runs in the context of one of the child processes,
so its state is preserved under multiple connections un-
less the process is killed by the web server process
manager. The conﬁguration is similar in the case the
web server uses threads instead of processes.

Keep-Alive requests. The HTTP protocol offers a
request header, called Keep-Alive. When this header
is set in an HTTP request, the web server is instructed
to keep the connection alive after the request is served.
Under mod php installations this means that any sub-
sequent request will be handled from the same process.
This is a very important fact, that we will use in our
attacks. However in order to avoid having a process
hang from one connection for inﬁnite time, most web
servers specify an upper bound on the number of con-
sequent keep-alive requests. The default value for this
bound in the Apache web server is 100.

2.2 Randomness Generation
In order to satisfy the need for generating randomness
in a web application, PHP offers a number of different

2

Figure 1: Attack template.

randomness functions. We brieﬂy describe each func-
tion below.

the
php combined lcg()/lcg value():
php combined lcg() function is used internally
by the PHP system, while lcg value() is its
public interface. This function is used in order to
create sessions, as well as in the uniqid function
described below to add extra entropy. It uses two
linear congruential generators (LCGs) which it
combines in order to get better quality numbers.
The output of this function is 64 bits.
This
uniqid(prefix, extra entropy):
function returns a string concatenation of the
seconds and microseconds of the server time con-
verted in hexadecimal. When given an additional
argument it will preﬁx the output string with the
preﬁx given. If the second argument is set to true,
the function will sufﬁx the output string with an
output from the php combined lcg() function.
This makes the total output to have length up to
15 bytes without the preﬁx.
microtime(),
time():
function
microtime() returns a string concatenation
of the current microseconds divided by 106 with
the seconds obtained from the server clock. The
time() function returns the number of seconds
since Unix Epoch.
mt srand(seed)/mt rand(min, max):
mt rand is
the Mersenne
Twister (MT) generator [15] in the PHP system.
In order to be compatible with the 31 bit output of
rand(), the LSB of the MT function is discarded.
The function takes two optional arguments which
map the 31 bit number to the [min, max] range.
The mt srand() function is used to seed the MT
generator with the 32 bit value seed; if no seed
is provided then the seed is provided by the PHP
system.
srand(seed)/rand(min, max): rand is the in-
terface function of the PHP system to the rand()
function provided by libc.
In unix, rand() ad-

the interface for

The

ditive feedback generator (resembling a Linear
Feedback Shift Register (LFSR)), while in Win-
dows it is an LCG. The numbers generated by
rand() are in the range [0,231−1] but like before
the two optional arguments give the ability to map
the random number to the range [min, max]. Like
before the srand() function seeds the generator
similarly to the mt srand() function.
openssl random pseudo bytes(length,
strong): This function is the only function
available in order to obtain cryptographically
secure random bytes. It was introduced in version
5.3 of PHP and its availability depends on the
availability of the openssl library in the system.
In addition, until version 5.3.4 of PHP this
function had performance problems [2] running
The strong
in Windows operating systems.
parameter,
is set
to true if the
function returned cryptographically strong bytes
and false otherwise. For these reasons, and
for backward compatibility, its use is still very
limited in PHP applications.

if provided,

In addition the application can utilize an operating sys-
tem PRNG (such as /dev/urandom). However, this
does not produce portable code since /dev/urandom
is unavailable in Windows OS.

3 The entropy of time measurements

Although ill-advised (e.g., [5]) many web applica-
tions use time measurements as an entropy source.
In PHP, time is accessed through the time() and
microtime() functions. Consider the following prob-
lem. At some point a script executing a request made
by the attacker makes a time measurement and use the
results to, say, generate a password reset token. The
attacker’s goal it to predict the output of the measure-
ment made by the PHP script. The time() function
has no entropy at all from an attacker point of view,
since the server reveals its time in the HTTP response
header as dictated by the HTTP protocol. On the other

3

hand, microtime ranges from 0 to 106 giving a max-
imum entropy of about 20 bits. We develop two dis-
tinct attacks to reduce the entropy of microtime()
that have different advantages and mostly target two
different scenarios. The ﬁrst one, Adversial Time Syn-
chronization, aims to predict the output of a speciﬁc
time measurement when there is no access to other
such measurements. The second, Request Twins, ex-
ploits the fact that the script may enable the attacker to
generate a correlated leak to the target measurement.

Adversarial Time Synchronization (ATS). As we
mentioned above, in each HTTP response the web
server includes a header containing the full date of the
server including hour, minutes and seconds. The basic
observation is that although we get no leak regarding
the microseconds from the HTTP date header we know
that when a second changes the microseconds are ze-
roed. We use this observation to narrow down their
value.

The algorithm proceeds as follows: We connect to
the web server and issue pairs of HTTP requests R1
and R2 in corresponding times T 1 and T 2 until a pair
is found in which the date HTTP header of the cor-
responding responses is different. At that point we
know that between the processing of the two HTTP
requests the microseconds of the server were zeroed.
We proceed to approximate the time of this event S in
localtime, denoted by the timestamp D, by calculating
the average RTT of the two requests and offsetting the
middle point between T 2 and T 1 by this value divided
by two.

In the Apache web server the date HTTP header is
set after processing the request of the user. If the at-
tacker requests a non existent ﬁle, then the point the
header is set is approximatelly the point that a valid
request will start executing the PHP script.
It fol-
lows that if the attacker uses ATS with HTTP requests
to not existent ﬁles then he will synchronize approx-
imately with the beggining of the script’s execution.
Given a steady network where each request takes RT T
2
time to reach the target server, our algorithm devia-
tion depends only on the rate that the attacker can send
HTTP requests.
In practice, we ﬁnd that the algo-
rithm’s main source of error is the network distance
between the attacker’s system and the server cf. Fig-
ure 3. The above implementation we described is a
proof-of-concept and various optimizations can be ap-
plied to improve its accuracy.

Request Twins. Consider the following setting: an
application uses microtime() to generate a password
token for any user of the system. The attacker has ac-
cess to a user account of the application and tries to
take over the account of another user. This allows the
attacker to obtain password reset tokens for his account
and thus outputs of the microtime() function. The
key observation is that if the attacker performs in rapid

succession two password reset requests, one for his ac-
count and one for the target user’s account, then these
requests will be processed by the application with a
very small time difference and thus the conditional en-
tropy of the target user’s password reset token given
the attacker’s token will be small. Thus, the attacker
can generate a token for an account he owns and in
fast succession a token for the target account. Then
the microtime() used for generating the token of his
account can be used to approximate the microtime()
output that was used for the token of the target account.

Experiments. We conducted a series of experiments
for both our algorithms using the following setup. We
created a PHP “time” script that prints out the current
seconds and microseconds of the server. To evaluate
the ATS algorithm we ﬁrst performed synchronization
between a client and the server and afterwards we sent
a request to the time script and tried to predict the value
it would return. To evaluate the Request Twins algo-
rithm we submitted two requests to the time script in
fast succession and measured the difference between
the output of the two responses.

In Figure 3 we show the time difference between
the server’s time and our client’s calculation for four
servers with different CPU’s and RTT parameters. Our
experiments suggest that both algorithms signiﬁcantly
reduce the entropy of microseconds (up to an average
of 11 bits with ATS and 14 bits with Request Twins)
having different advantages each. Speciﬁcally, the
ATS algorithm seems to be affected by large RTT val-
ues while it is less affected by differences in the CPU
speed. The situation is reversed for Request Twins
where the algorithm is immune to changes in the RTT
however, it is less effective in old systems with low
processing speed.

4

Seed Attacks

In this section we describe attacks that allow either the
recovery or the reconstruction of the seeds used for the
PHP system’s PRNGs. This allows the attacker to pre-
dict all future iterations of these functions and hence
reduces the entropy of functions rand(),mt rand(),
lcg value() as well as the extra entropy argument
of uniqid() to zero bits. We exploit two properties
of the seeds used in these functions. The ﬁrst one is
the reusage of entropy sources between different seeds.
This enables us to reconstruct a seed without any ac-
cess to outputs of the respective PRNG. The second is
the small entropy of certain seeds that allows one to
recover its value by bruteforce.

We present three distinct attacks. The ﬁrst attack al-
lows one to recover the seed of the internal LCG seed
used by the PHP system using a session identiﬁer. Us-
ing that seed our second attack reconstructs the seed of
rand() and mt rand() functions from the elements
of the LCG seed without any access to outputs of these

4

Conﬁguration

CPU(GHz) RTT(ms) min
1× 3.2
0
4× 2.3
5
1× 0.3
53
2× 2.6
73

1.1
8.2
9
135

ATS
max
4300
76693
39266
140886

avg
410
4135
2724
83573

Req. Twins

min
0
565
1420

2

max
1485
1669
23022
1890

avg
47
1153
4849
299

Figure 2: ATS.

Figure 3: Effectiveness of our time entropy lowering techniques against four servers
of different computational power and RTT. Time measurements are in microseconds.

functions. Finally, we exploit the fact that the seed
used in these functions is small enough for someone
with access to the output of these functions to recover
its value by bruteforce.

Generating fresh processes. Our attacks on this sec-
tion rely on the ability of the attacker to connect to a
process with a newly initialized state. We describe a
generic technique against mod php in order to achieve
a connection to a fresh process. Recall that in mod php
when the number of occupied processes passes a cer-
tain threshold new processes are created to handle the
new connections. This gives the attacker a way to force
the creation of fresh processes: The attacker creates a
large number of connections to the target server with
the keep-alive HTTP header set. Having occupied a
large number of processes the web server will create
a number of new processes to handle subsequent re-
quests. The attacker, keeping the previous connections
open, makes a new one which, given that the attacker
created enough connections, will be handled by a fresh
process.

4.1 Recovering the LCG seed from Ses-

sion ID’s

In this section we present a technique to recover the
php combined lcg() seed using a PHP session iden-
tiﬁer. In PHP, when a new session is created using the
respective PHP function (session start()), a pseu-
dorandom string is returned to the user in a cookie, in
order to identify that particular session. That string is
generated using a conjuction of user speciﬁc and pro-
cess speciﬁc information, and then is hashed using a
hash function which is by default MD5, however there
is an option to use other hash functions such as SHA-1.
The values contained in the hash are:

Client IP address (32 bits).
A time measurement: Unix epoch and microsec-
onds (32 + 20 bits).
A value generated by php combined lcg() (64
bits).

Notice now that in the context of our attack model
the attacker controls each request thus he knows ex-

actly most of the values. Speciﬁcally, the client IP ad-
dress is the attacker’s IP address and the Unix Epoch
can be determined through the date HTTP header. In
addition, if php combined lcg() is not initialized at
the time the session is created, as it happens when a
fresh process is spawned, then it is seeded. The state
of the php combined lcg() is two registers s1, s2 of
size 32 bits each, which are initialized as follows. Let
T1 and T2 be two subsequent time measurements. Then
we have that
s1 = T1.sec⊕ (T1.usec (cid:28) 11) and s2 = pid⊕ (T2.usec (cid:28) 11)

where pid denotes the current process id, or if threads
are used the current thread id 2.

Process id’s have a range of 215 values in Linux
systems In Windows systems the process id’s (resp.
threads) are also at most 215 unless there are more
than 215 active processes (resp. threads) in the system
which is a very unlikely occurence.

Observe now that the session calculation involves
three time measurements T0, T1 and T2. Given that
these three measurements are conducted succesivelly
it is advantageous to estimate their entropy by examin-
ing the random variables T0,∆1 = T1−T0,∆2 = T2−T1.
We conducted experiments in different systems to es-
timate the range of values for ∆1 and ∆2. Our exper-
iments suggest that ∆1 ∈ [1,4] while ∆2 ∈ [0,3]. We
also found a positive linear correlation in the values of
the two pairs. This enables a cutdown of the possible
valid pairs. These results suggest that the additionally
entropy introduced by the two ∆ variables is at most 5
bits.

To summarize, the total remaining entropy of the
session identiﬁer hash is the sum of the microseconds
entropy from T0 (≈ 20 bits) the two ∆ variables (≈
5 bits) and the process identiﬁer(15 bits). These give
a total of 40 bits which is tractable cf. section 1.1.
Furthermore the following improvements can be made:
(1) Using the ATS algorithm the microseconds entropy
can be reduced as much as 11 bits on average. (2) The
attacker can make several connections to fresh pro-
cesses instead of one, in rapid succession, obtaining

2In PHP versions before 5.3.2 the seed used only one time mea-

surement which made it even weaker.

5

session identiﬁers from each of the processes. Because
the requests were made in a small time interval the
preimages of the hashes obtained belong into the same
search space, thus improving the probability of invert-
ing one of the preimages proportionally to the number
of session identiﬁers identiﬁers obtained. Our experi-
ments with the request twins technique suggest that at
least 4 session identiﬁers can be obtained from within
the same search space thus offering a reduction of at
least two bits. Adding these improvements reduces the
search time up to 227 MD5 computations.

4.2 Reconstructing the PRNG Seed from

Session ID’s

In this section we exploit the fact that the PHP system
reuses entropy sources between different generators, in
order to reconstruct the PRNG seed used by rand()
and mt rand() functions from a PHP session identi-
ﬁer. In order to predict the seed we only need to ﬁnd
a preimage for the session id, using the methods de-
scribed in the previous section. One advantage of this
attack is that it requires no outputs from the affected
functions.

When a new process is created the internal state of
the functions rand() and mt rand() is uninitialized.
Thus, when these functions are called for the ﬁrst time
within the script a seed is constructed as follows:
seed = (epoch× pid)⊕ (106× php combined lcg())

where epoch denotes the seconds since epoch and pid
denotes the process id of the process handling the re-
quest. It it easy to notice, that an attacker with access to
a session id preimage has all the information needed in
order to calculate the seed used to initialize the PRNGs
since:

is

known

seed

from the

epoch is obtained through the HTTP Date header.
pid
of
the
php combined lcg() obtained
the
through
preimage of the session id from section 4.1.
php combined lcg() is also known, since the at-
tacker has access to its seed, he can easily predict
the next iteration after the initial value.

In summary the technique of this section allows the re-
construction of the seed of the mt rand() and rand()
functions given access to a PHP session id of a fresh
process. The time complexity of the attack is the
same as the one described in section 4.1 while the
query complexity is one request, given that the attacker
spawned a fresh process (which itself requires only a
handful of requests).

4.3 Recovering the Seed from Applica-

tion leaks

In contrast to the technique presented in the previous
section, the attack presented here recovers the seed of

6

the PRNG functions rand() and mt rand() when the
attacker has access to the output of these functions. We
exploit the fact that the seed used by the PHP system is
only 32 bits. Thus, an attacker who connects to a fresh
process and obtains a number of outputs from these
functions can bruteforce the 32 bit seed that produces
the same output.

We emphasize that this attack works even if the out-
puts are truncated or passed through transformations
like hash functions. The requirements of the attack is
that the attacker can deﬁne a function from the set of
all seeds to a sufﬁciently large range and can obtain a
sample of this function evaluated on the seed that the
attacker tries to recover. Additionally for the attack to
work this function should behave as a random map.

Consider the following example. The attacker has
access to a user account of an application which gen-
erates a password reset token as 6 symbols where each
symbol is deﬁned as g(mt rand()) where g is a ta-
ble lookup function for a table with 60 entries contain-
ing alphanumeric characters. The attacker deﬁnes the
function f to be the concatenation of two password re-
set tokens generated just after the PRNG is initialized.
The attacker samples the function by connecting to a
fresh process and resetting his password two times.
Since the table of function g contains 60 entries, the
attacker obtains 6 bits per token symbol, giving a total
range to the function f of 72 bits.

The time complexity of the attack is 232 calculations
of f however, we can reduce the online complexity
of the attack using a time-space tradeoff. In this case
the online complexity of the attack can be as little as
216. The query complexity of the attack depends on
the number of requests needed to obtain a sample of
f . In the example given above the query complexity is
two requests.

5

State recovery attacks

One can argue that randomness attacks can be easily
thwarted by increasing the entropy of the seeding for
the PRNG functions used by the PHP system. For ex-
ample, the suhosin PHP hardening extension replaces
the rand() function with a Mersene Twister generator
with separate state from mt rand() and offers a larger
seed for both generators getting entropy from the oper-
ating system3.

We show that this is not the case. We exploit the
algebraic structure of the PRNGs used in order to re-
cover their internal state after a sufﬁcient number of
past outputs (leaks) have been observed by the attacker.
Any such attack has to overcome two challenges. First,
web applications usually need only a small range of

3The suhosin patch installed in some Unix operating systems
by default does not include the randomness patches, rather than it
mainly offers protection from memory corruption attacks. The full
extension is usually installed separately from the PHP packages.

lowing range for possible values for n:

(cid:98) (l − a)· M
b− a + 1

(cid:99) ≤ n ≤ (cid:98) (l − a + 1)· M
b− a + 1

(cid:99)− 1

Therefore, given a bucket number l we are able to
ﬁnd an upper and lower bound for the original number
denoted respectively by Ll and Ul. In order to recover
a part of the original number n one can simply ﬁnd the
number of most signiﬁcant bits of Ll and Ul that are
equal and observe that these bits would be the same
also in the number n. Therefore, given a bucket l we
can compare the MSBs of both numbers and set the
MSBs of n to the largest sequence of common most
signiﬁcant bits of Ll,Ul.

Notice that in some cases even the most signiﬁ-
cant bit of the two numbers are different, thus we
are be unable to infer any bit of the original number
n with absolute certainty. For example, in Figure 4
given that a number falls in bucket 3 we have that
920350134≤ n≤ 1227133512. Because 920350134 <
230 and 1227133512 > 230 we are unable to infer any
bit of the original number n.

Another important observation is that this speciﬁc
truncation algorithm allows the recovery of a fragment
of the MSBs of the original number. Therefore, in the
following sections we will assume that the truncation
occurs in the MSBs and we will describe our algo-
rithms based on MSB truncated numbers. However, all
algorithms described work for any kind of truncation.

5.2 Process distinguisher
As we mentioned in section 2.1, if one wants to receive
a number of leaks from the same PHP process one can
use keep-alive requests. However, there is an upper
bound that limits the number of such requests (by de-
fault 100). Therefore, if the attacker needs to observe
more outputs beyond the keep-alive limit the connec-
tion will drop and when the attacker connects back to
the server he may be served from a different process
with a different internal state. Therefore, in order to
apply state recovery attacks (which typically require
more than 100 requests), we must be able to submit
all the necessary requests to the same process. In this
section, we will describe a generic technique that ﬁnds
the same process over and over using the PHP session
leaks described in section 4.1.

While we cannot avoid disconnecting from a pro-
cess after we have submitted the maximum number of
keep-alive requests, we can start reconnecting back to
the server until we hit the process we were connected
before and continue to submit requests. The problem
in applying this approach is that it is not apparent to
distinguish whether the process we are currently con-
nected to is the one that was serving us in the previ-
ous connection. To distinguish between different pro-
cesses, we can use the preimage from a session iden-
tiﬁer. Recall that the session id contains a value from

Figure 4: Mapping a random number n ∈ [M] to 7
buckets and the respective bits of n that are revealed
given each bucket.

random numbers, for example to sample a random en-
try from an array. To achieve that, the PHP system
maps the output of the PRNG to the given range, an
action that may break the linearity of the generators.
Second, in order to collect the necessary leaks the at-
tacker may need to reconnect to the same process many
times to collect the leaks from the same generator in-
stance. Since, there could be many PHP processes run-
ning in the system, this poses another challenge for the
attacker.

In this section we present state recovery algo-
rithms for the truncated PRNG functions rand() and
mt rand(). The algorithm for the latter function
is novel, while regarding the former we implement
and evaluate the H˚astad-Shamir cryptanalytic frame-
work [8] for truncated linearly related variables. We
begin by discussing the way truncation takes place in
the PHP system. Afterwards, we tackle the problem of
reconnecting into the same server process. Finally we
present the two algorithms against the generators.

5.1 Truncating PRNG sequences in the

PHP system

As mentioned in section 2.2 the rand() and
mt rand() functions can map their output to a user
deﬁned range. This has the effect of truncating the
functions’ output. Here we discuss the process of trun-
cating the output and its implications for the attacker.
Let n ∈ [M] = {0, . . . ,M − 1} be a random number
generated by rand() or mt rand(), where M = 231
in the PHP system. In order to map that number in the
range [a,b] where a < b the PHP system maps n to a
number l ∈ [a,b] in the following way:
n· (b− a + 1)

l = a +

M

We can view the process above as a mapping from
the set of numbers in the range [M] to b− a + 1 “buck-
ets.” Our goal is to recover as many bits as possible
of the original number n. Observe that given l it is
possible to recover immediately up to (cid:98)log(b− a + 1)(cid:99)
most signiﬁcant bits (MSB) of the original number n
as follows:

Given that n belongs to bucket l we obtain the fol-

7

the php combined lcg() function, which in turn uses
process speciﬁc state variables. Thus, if the session
is produced from the same process as before then the
php combined lcg() will contain the next state from
the one it was before. This gives us a way to ﬁnd the
correct process among all the server processes running
in the server. In summary the algorithm will proceed
as follows:

1. The attacker obtains a session identiﬁer and a
preimage for that id using the techniques dis-
cussed in section 4.1.

2. The attacker submits the necessary requests to ob-
tain leaks from the PRNG, using the keep-alive
HTTP header until the maximum number of re-
quests is reached.

3. The attacker initiates connections to the server re-
questing session identiﬁers. He attempts to ob-
tain a preimage for every session identiﬁer using
the next value of the php combined lcg() from
the one used before or, if the server has high traf-
ﬁc, the next few iterations. If a preimage is ob-
tained the attacker repeats step 2, until all neces-
sary leaks are obtained.

Notice that obtaining a preimage after disconnect-
ing requires to bruteforce a maximum number of 20
bits (the microseconds), and thus testing for the cor-
rect session id is an efﬁcient procedure. Even if the
application is not using PHP sessions, or if a preimage
cannot be obtained, there are other, application spe-
ciﬁc, techniques in order to ﬁnd the correct process.

A generic technique for Windows.
In the case of
Windows systems the attacker can employ another
technique to collect the necessary leaks from the same
process in case the server has low trafﬁc.
In unix
servers with apache preforked server + mod php all
idle processes are in a queue waiting to handle an in-
coming client. The ﬁrst process in the queue handles
a client and then the process goes to the back of the
queue. Thus, if an attacker wants to reconnect to the
same process without using some process distinguisher
he will need to know exactly the number of processes
in the system and if there are any intermediate requests
by other clients while the attacker tries to reconnect to
the same process. However, in Windows prethreaded
server with mod php things are slightly better for an
attacker. Threads are in a priority queue and when a
thread in the ﬁrst place of the queue handles a request
from a client it returns again in that ﬁrst place and han-
dles the ﬁrst subsequent incoming request. Thus, an
attacker which manages to connect to that ﬁrst thread
of the server, can rapidly close and reopen the connec-
tions thus leaving a very small window in which that
thread could be occupied by another client. Of course,
in high trafﬁc servers the attacker would have a difﬁ-
culty connecting in a time when the server is idle in

the ﬁrst place. Nevertheless, techniques exist [16] to
remotely determine the trafﬁc of a server and thus al-
low the attacker to ﬁnd an appropriate time window
within which he will attempt this attack.

Based on the above, in the following sections we
will assume that the attacker is able to collect the nec-
essary number of leaks from the targeted function.

State recovery for mt rand()

5.3
The mt rand() function uses the Mersenne Twister
generator in order to produce its output. In this section
we give a description of the Mersenne Twister genera-
tor and present an algorithm that allows the recovery of
the internal state of the generator even when the output
is truncated. Our algorithm also works in the presence
of non consecutive outputs as in the case resulting from
the buckets truncation algorithm of the PHP system (cf.
section 5.1).

Mersenne Twister. Mersenne Twister, and speciﬁ-
cally the widely used MT19937 variant, is a linear
PRNG with a 624 32-bit word state. The MT algo-
rithm is based on the following recursion: for all k,
xk+n = xk+m⊕((xk∧0x80000000)|(xk+1∧0x7fffffff))A
where n = 624 and m = 397. The logical AND oper-
ation with 0x80000000 discards all but the most sig-
niﬁcant bit of xk while the logical AND with 0x7fffffff
discards only the MSB of xk+1. A is a 32 × 32 ma-
trix for which multiplication by a vector x is deﬁned as
follows:

(cid:26) (x (cid:29) 1)

xA =

(x (cid:29) 1)⊕ a

if x31 = 0
if x31 = 1

Here a = (a0,a1, ...,a31) = 0x9908B0DF is a constant
32-bit vector (note that we use x31 to denote the LSB
of a vector x). The output of this recurrence is ﬁnally
multiplied by a 32× 32 non singular matrix T , called
the tempering matrix, in order to produce the ﬁnal out-
put z = xT .

State recovery. Since the tempering matrix T is non
singular, given 624 outputs of the MT generator one
can easily compute the original state by multiplying
the output z with the inverse matrix T−1 thus obtain-
ing the state variable used as xi = ziT−1. After recov-
ering 624 state variables one can predict all future it-
erations. However, when the output of the generator is
truncated, predicting future iterations is not as straight-
forward as before because it is not possible to locally
recover all needed bits of the state variables given the
truncated output.

The key observation in recovering the internal state
is that due to the fact that the generator is in GF(2) the
truncation does not introduce non linearity even though
there are missing bits from the respective equations.

8

Thus, we can express the output of the generator as a
set of linear equations in GF(2) which, when solved,
yield the initial state that produced the observed se-
quence. From the basic recurrence of MT we can de-
rive the following equations for each individual bit:
Lemma 5.1. Let x0,x1, . . . be an MT sequence and j >
0. Then the following equations hold for any k ≥ 0:

1. x0

jn+k = x0
2. x1
jn+k = x1
a1)

( j−1)n+k+m ⊕ (x31
( j−1)n+k+m ⊕ x0

( j−1)n+k+1 ∧ a0)
( j−1)n+k ⊕ (x31

( j−1)n+k+1 ∧

3. ∀i,2 ≤ i ≤ 31 : xi

xi−1
( j−1)n+k+1 ⊕ (x31

( j−1)n+k+1 ∧ ai)

jn+k = xi

( j−1)n+k+m ⊕

Proof. The equations follow directly from the basic re-
currence.

In addition since the tempering matrix is only a lin-
ear transformation of the bits of the state variable xi,
we can similarly express each bit of the ﬁnal output of
MT as a linear equation of the bits of the respective
state variable.

To recover the initial state of MT, we generate all
equations over the state bit variables x0,x1, . . . ,x19936.
To map any position in the MT sequence in an equation
over this set of variables, we apply the equations of the
lemma above recursively until all variables in the right
hand side have index below 19937.

Depending on the positions observed in the MT se-
quence the resulting linear system will be different.
The question that remains is whether that system is
solvable. Regarding the case of the 31-bit truncation,
i.e. only the MSB of the output word is revealed, we
can use known properties of the generator in order to
easily prove the following:

Lemma 5.2. Suppose we obtain the MSB of 19937
consecutive words from the MT generator. Then the
resulting linear system is uniquely solvable.

Proof. It is known that the MT sequence is 19937-
distributed to 1-bit accuracy4. The linear system is
uniquely solvable iff the rows are linearly independent.
Suppose that a set k ≤ 19937 of rows are lineary de-
pendent. Then the last row of the set k obtained is
computable from the other members of the k-set some-
thing that contradicts the order of equidistribution of
MT.

The above result is optimal in the sense that this is
the minimum number of observed outputs needed for
the system to become fully determined.
In the case
we obtain non consecutive outputs due to truncation

4Suppose that a sequence is k-distributed to u-bit accuracy. Then
knowledge of the u most signiﬁcant bits of l words does not allow
one to make any prediction for the u bits of the next word when l < k.
This is the cryptographic interpretation of the “order of equidistribu-
tion” whose exact deﬁnition can be found in [15].

9

or application behavior, linear dependencies may arise
between the resulting equations and therefore we may
need a larger number of observed outputs.

Because we cannot know in advance when the sys-
tem will become solvable or the equations that will be
included, we employ an online version of Gaussian
elimination in order to form and solve the resulting
system. In this way, the attacker can begin collecting
leaks and gradually feed them to our Gaussian solver
until he is notiﬁed that a sufﬁcient number of indepen-
dent equations have been collected. Note that regular
Gaussian elimination uses both elementary row and el-
ementary column operations. However, because we do
not have in advance the entire linear system we cannot
use elementary column operations. Instead we make
Gaussian elimination using only elementary row oper-
ations and utilize a bookkeeping system to enter equa-
tions in their place as they are produced by the leaks
supplied to the solver. Our solver employs a sparse
vector representation and is capable of solving overde-
termined sparse systems of tens of thousands of equa-
tions in a few minutes.

We ran a sequence of experiments to determine the
solvability of the system when a different number of
bits is truncated from the output. In addition we ran
experiments when the outputs of the MT generator is
passed through the PHP truncation algorithm, with dif-
ferent user deﬁned ranges. All experiments were con-
ducted in a 4× 2.3 GHz machine with 4 GB of RAM.
In Figure 5 we present the number of equations
needed when the PHP truncation algorithm is used.
In the x-axis we have the logarithm of the number
of buckets. We also show the standard deviation ap-
pearing as vertical bars. It can be seen that the num-
ber of equations needed is much higher than the the-
oretical lower bound of 19937 and ﬂuctuates between
27000 and 33000. Neverthless, the number of leaks re-
quired is decreasing linearly to the number of buckets
we have. The reason is that although we have more lin-
early dependend equations, the total number of equa-
tions we obtain due to the larger number of buckets is
bigger.

Implementation error in the PHP system. The
PHP system up to current version, 5.3.10, has an error
in the implementation of the Mersenne Twister gen-
erator (we discovered this during the testing of our
solver). Speciﬁcally the following basic recurrence is
effectively used in the PHP system due to a program-
ming error:

xk+n = xk+m ⊕ ((xk ∧ 0x80000000)|(xk+1 ∧ 0x7ffffffe)|(xk ∧ 0x1))A
As a result the PHP system uses a different generator
which, as it turns out, has slightly more linear depen-
dencies than the MT generator. This means that prob-
ably the randomness properties of the PHP generator
are poorer compared to the original MT generator.

Figure 5: Solving MT; y-axis:number of equations; x-axis: number of buckets (logarithm). Standard deviation
shown as vertical bars.

State recovery for rand()

5.4
We turn now to the problem of recovering the state
of rand() given a sequence of leaks from this gen-
erator. While mt rand() is implemented within the
PHP source code and thus is unchanged across differ-
ent enviroments, the rand() function uses the respec-
tive function deﬁned from the standard library of the
operating system. This results in different implemen-
tations across different operating systems. There are
mainly two different implementations of rand() one
from the glibc and one from the Windows library.

Windows rand(). The rand() function deﬁned in
Windows is a Linear Congruential Generator (LCG).
An LCG is deﬁned by a recurrence of the form

Xn+1 = (aXn + c) mod m

Although LCGs are fast and require a small memory
footprint there are many problems which make them
insufﬁcient for many uses, including of course cryp-
tographic purposes. The parameters used by the Win-
dows LCG are a = 214013,c = 2531011,m = 232. In
addition, the output is truncated by default and only
the top 15 bits are returned.
If PHP is running in a
threaded server in Windows then the parameters of the
LCG used are a = 1103515245,c = 12345,m = 215.

Glibc rand().
In the past, glibc also used an LCG for
the rand() function. Subsequently an LFSR-like “ad-
ditive feedback” design was adopted. The generator
has a state of 31 words (of 32 bits each), over which it
is deﬁned by the following recurrence:

ri = (ri−3 + ri−31) mod 232

In addition the LSB of each word is discarded and the
output returned to the user is oi = ri (cid:29) 1. An interest-
ing note is that the man page of rand() states that rand

is a non-linear generator. Nevertheless, the non linear-
ity introduced by the truncation of the LSB is negligi-
ble and one can easily recover the initial values given
enough outputs of the generator.

State recovery. Notice that if the generators used
have a small state such as the Windows LCGs then
state recovery is easy, by applying the attack from sec-
tion 4 to bruteforce the entire state of the generator.
However, on the Glibc generator, which has a state of
992 bits, these attacks are infeasible assuming that the
state is random. Although LCGs and the Glibc gener-
ators are different, they both fall into the same crypt-
analytic framework introduced by H˚astad and Shamir
in 1985 for recovering values of truncated linear vari-
ables. This framework allows one to uniquely solve
an underdeﬁned system of linear equations when the
values of the variables are partially known. In this sec-
tion we will discuss our experiences with applying this
technique in the two aforementioned generators: The
LCG and the additive-feedback generator of glibc. We
will brieﬂy describe the algorithm for recovering the
truncated variables in order to discuss our experiments
and results. The interested reader can ﬁnd more infor-
mation about the algorithm in the original paper [8].

Suppose we are given a system with l linear equa-
tions on k variables modulo m denoted by x1,x2, . . . ,xk,

1x1 + a1
a1
1x1 + a2
a2

2x2 +··· + a1
2x2 +··· + a2

kxk = 0 mod m

kxk = 0 mod m

. . .
2x2 +··· + al

al
1x1 + al

kxk = 0 mod m

where l < k and each variable xi is partially known.
We want to solve the system uniquely by utilizing the
partial information of the k variables xi.

We use the coefﬁcients of the l equations to create a
set of l vectors, where each vector is of the form vi =

10

(a1, . . . ,ak). In addition we add to this set the k vectors
m· ei,0 < i ≤ k. The cryptanalytic framework exploits
properties of the lattice L that is deﬁned as the linear
span of these vectors. Observe that the dimension of L
is k and in addition for every vector v ∈ L we have that
∑k
i=1 vixi = 0 mod m.
Given the above the attack works as follows: ﬁrst a
lattice is deﬁned using the recurrence that deﬁnes the
linear generator; then, a lattice basis reduction algo-
rithm is employed to create a set of linearly indepen-
dent equations modulo m with small coefﬁcients; ﬁ-
nally, using the partially known values for each vari-
able, we convert this set of equations to equations over
the integers which can be solved uniquely. Speciﬁ-
cally, we use the LLL [13] algorithm in order to obtain
a reduced basis B for the lattice L. Now because B =
{w j} is a basis, the vectors of B are linearly indepen-
dent. The key observation is that the lattice deﬁnition
implies that w j·x = w j·(xunknown +xknown) = d j·m for
some unknown d j. Now as long as xunknown·w j < m/2
(this is the critical condition for solvability) we can
solve for d j and hence recover k equations for xunknown
which will uniquely determine it.

The original paper provided a relation between the
size of xknown and the number of leaks required from
the generator so that the upper bound of m/2 is ensured
given the level of basis reduction achieved by LLL. In
the case of LCGs the paper demanded the modulo m to
be squarefree. However, as shown above, in the gen-
erators used it holds that m = 232 and thus their argu-
ments do not apply. In addition, the lattice of the addi-
tive generator of glibc is different than the one gener-
ated by an LCG and thus needs a different analysis.

We conducted a thorough experimental analysis of
the framework focusing on the two types of generators
above. In each case we tested the maximum possible
value of xknown to see if the m/2 bound holds for the
reduced LLL basis.
In the following paragraphs we
will brieﬂy discuss the results of these experiments for
these types of generators.

In Figure 6 we show the relationship between the
number of leaks required for recovering the state with
the lattice-attack and the number of leaks that are trun-
cated for four LCGs:
the Windows LCG, the glibc
LCG (which are both 32 bits), the Visual Basic LCG
(which is 24 bits) and an LCG used in the MMIX of
Knuth (which is 64 bits). It is seen that the number
of leaks required is very small but increases sharply as
more bits are truncated. In all cases the attack stops
being useful once the number of truncated bits leaves
none but the logw− 1 most signiﬁcant bits where w is
the size of the LCG state. The logarithm barrier seems
to be uniformly present and hints that the MSB’s of
a truncated LCG sequence may be hard to predict (at
least using the techniques considered here). A similar
logarithmic barrier was also found in the experimental
analysis that was conducted by Contini and Shparlin-
ski [3] when they were investigating Stern’s attack [17]

against truncated LCG’s with secret parameters.

Applying the attack in the glibc additive feedback
generator we found that the LLL algorithm became a
bottleneck in the algorithm running time; due to its
large state the algorithm required a large number of
leaks to recover even small truncation levels there-
fore increasing the lattice dimension that was given
to the LLL algorithm. Our testing system (a 3.2GHz
cpu with 2GB memory) ran out of memory when 7
bits were truncated. The version of LLL we em-
ployed (SageMath 4.8) has time complexity O(k5)
where k is the dimension of the lattice (which repre-
sents roughly the number of leaks). The best time-
complexity known is O(k3 logk) derived from [12];
this may enable much higher truncation levels to be re-
covered for the glibc generator, however we were not
able to test this experimentally as no implementation
of this algorithm is publicly available.

We conclude that truncated LCG type of generators
can be broken (in the sense of entirely recovering their
internal state) for all but extremely high levels of trun-
cation (e.g.
in the case of 32-bit state LCG’s mod-
ulo 232 when they are truncated to 16 buckets or less).
For additive feedback type of generators, such as the
one in glibc, the situation is similar, however higher
recursion depths require more leaks (with a linear re-
lationship) that in turn affect the lattice dimension re-
sulting in longer running times. Comparing the results
between the LCGs and the additive feedback genera-
tors one may ﬁnd some justiﬁcation for the adoption
of the latter in recent versions of glibc : it appears that
- at least as far as lattice-based attacks are concerned -
it is harder to predict truncated glibc sequences (com-
pared to say, Windows LCG’s) due to the higher run-
ning times of LLL reduction (note though that this does
not mean that these are cryptographically secure).

6 Experimental results and Case studies

In order to evaluate the impact of our attacks on real
applications we conducted an audit to the password
reset function implementations of popular PHP appli-
cations. Figure 7 shows the results from our audit.
In each case succesfully exploiting the application re-
sulted in takeover of arbitrary user accounts5 and in
some cases, when the administrator interface was af-
fected, of the entire application. In addition to iden-
tiﬁying these vulnerabilities we wrote sample exploits
for some types of attack we presented, each on one af-
fected application.

5The only exception to that is the HotCRP application where
passwords were stored in cleartext thus there was no password reset
functionality. However, in this case we were able to spoof registra-
tions for arbitrary email accounts.

11

Figure 6: Solving LCGs with LLL; y-axis:number of leaks; x-axis: number of bits truncated.

Application
mediawiki
Open eClass

taskfreak
zen-cart

4.2
4.2
4.2
ATS
osCommerce 2.x ATS
4.2
osCommerce 3.x
ATSc
RTc

elgg

Gallery

Attack
4.3
4.3
4.3
RT
RT
4.3
4.2
4.1c

5.3
5.4
5.3

5.4
4.3
4.2c

•
•
•
•
•
•
•
•

Application

Attack

Joomla
MyBB
IpBoard
phorum
HotCRP
gazelle
tikiWiki

SMF

4.3
ATSc
ATSc
4.2
4.2
4.3
4.2
ATSc

5.3c
4.2c
5.3
5.3

5.4

4.1c
4.1c
4.3
4.3
5.3
4.3
4.3c

•
◦
•
•
•
•
•
◦

Figure 7: Summary of audit results. The c superscript denotes that the attack need to be used in combination with
other attacks with the same superscript. The • denotes a full attack while ◦ denotes a weakness for which the
practical exploitation is either unveriﬁed or requires very speciﬁc conﬁgurations. The number denotes the section
in which the applied attack is described in the paper.

6.1 Selected Audit Results
Many applications we audited where trivially vulnera-
ble to our attacks since they used the affected PRNG
functions in a straightforward manner, thus making it
pretty easy for an attacker to apply our techniques and
exploit them. However some applications attempted
to defend against randomness attacks by creating cus-
tom token generators. We will describe some attacks
that resulted from using our framework against custom
generators.

Gallery. PHP Gallery is a very popular web based
photo album organizer. In order for a user to reset his
password he has to click to a link, which contains the
security token. The function that generates the token is
the following:

namely a time measurement from uniqid(), an out-
put from the MT generator and an output from the
php combined lcg() through the extra argument in
the uniqid() function.
In addition the output is
passed through the MD5 hash function so its infeasi-
ble to recover the initial values given the output of this
function. Since we do not have access to the output
of the function, the state reconstruction attack seems
an appropriate choice for attacking this token gener-
ation algorithm. Indeed, the Gallery application uses
PHP sessions thus an attacker can use them to predict
the php combined lcg() and mt rand() outputs. In
addition by utilizing the request twins technique from
section 3 the attacker can further reduce the search
space he has to cover to a few thousand requests.

function hash($entropy="") {

return md5($entropy . uniqid(mt_rand(), true));

}

The token is generated using three entropy sources,

Joomla.
Joomla is one of the most popular CMS ap-
plications, and it also have a long history of weak-
nesses in its generation of password reset tokens [4,
11]. Until recently, the code for the random token gen-
eration was the following:

12

function genRandomPassword( $length=8 ) {

$salt = abc...xyzABC...XYZ0123456789 ;
$len = strlen ( $salt );
$makepass = ‘‘’’;

- $stat = @stat ( FILE ) ;
- if (empty($stat) || !isarray($stat))
-
- mt_srand(crc32(microtime().implode(|,$stat)));

$stat=array(phpuname());

for($i=0;$i<$length;$i++){

$makepass .= $salt[mt_rand(0,$len1)];

}
return $makepass;

}

this

In addition the output of

function is
hashed using MD5 along a secret, 16 bytes, key
(config.secret) which is created at
installation
using the function above. The config.secret value
was also used to create a “remember me” cookie in the
following way:

cookie = md5(config.secret+’JLOGIN REMEMBER’)

Since the second part of the string is constant
and the conﬁg.secret is generated through the gen-
RandomPassword function which has only 232 possi-
ble values for each length, one could bruteforce all
possible values and recover config.secret. All
that was left was the prediction of the output of the
genRandomPassword() function in order to predict
the security token used to reset a password. One then
observes that although the contents of the $stat vari-
able in the genRandomPassword() function are suf-
ﬁciently random, the fact that crc is used to convert
this value to a 4 byte seed allows one to predict the
seed generated and thus the token. This attack was
reported in 2010 in [11] and a year after, Joomla re-
leased a patch for this vulnerability which removed the
custom seeding (dashed lines) from the token gener-
ation function. The idea was that because the gener-
ator is rolling constantly without reseeding one will
be unable to recover the config.secret and thus the
generator will be secure due to its secret state. Un-
fortunately, this may not be the case. If at the instal-
lation time the process handling the installation script
is fresh, a fact quite probable if we consider dedicated
servers that do not run other PHP applications, then
the search space of the config.secret will be again
232 and thus an attacker can use the same technique
as before to recover it. After the config.secret is
recovered, exploitation of the password reset imple-
mentation is straightforward using our seed recovery
attack from section 4.3. A similar attack also holds
when mod cgi is used for script execution as each re-
quest will be handled by a fresh process again reducing
the search space for config.secret in 232 values.

However, the low entropy of the config.secret
key is not the only problem of this implementation.
Even if the key had enough entropy to be totally unpre-
dictable, the generator would still be vulnerable. No-
tice that in case the genRandomPassword() is called

13

with a newly initialized MT generator then there at
most 232 possible tokens, independently of the entropy
of config.secret. This gives an interesting attack
vector: We generate two tokens from a fresh process
sequentially for a user account that we control. Then
we start to connect to a fresh process and request a to-
ken for our account.
If the token matches the token
generated before then we can submit a second request
for the target user’s account which, since the ﬁrst to-
ken matched the token we own, will match the second
token that we requested before (recall that the tokens
are not bound to users). Observe that if we gener-
ate only one pair of tokens this attack is expected to
succeed after 232 requests, assuming that the seed is
random. Nevertheless, we can request more than one
pair of tokens thus increasing our success probability.
Speciﬁcally, if we have n pairs of tokens then at the
second phase the attack is expected to succeed after
232/n requests. Therefore, if we denote by r(n) the ex-
pected requests that the attack needs to hit a “good”
token given n initial token pairs, then we have that
r(n) = 2n + 232/n. Our goal is to minimize the func-
tion r(n); this function obtains a positive minimum at
n = 231/2, for which we have that r(231/2) ≈ 185000.
A simple bruteforcing framework that we wrote was
able to achieve around 2500 requests per minute, a rate
at which an attacker can compromise the application
in a little more than one hour. To be fair, we have to
add the requests that are required to spawn new pro-
cesses but even if we go as far as to double the needed
requests (and this is grossly overestimating) we still
have a higly practical attack.

Gazelle. Gazelle is a torrent
tracker application,
which includes a frontend for building torrent shar-
ing communities. It’s been under active development
for the last couple of years and its gaining increasing
popularity. The interesting characteristic of the appli-
cation’s password reset implementation is that it uses
two generators of the PHP system (namely rand() and
mt rand(). The code that generates a token is this:

function make_secret($Length = 32) {

$Secret = ’’;
$Chars=’abcdefghijklmnopqrstuvwxyz0123456789’;
for($i=0; $i<$Length; $i++) {

Rand = mt_rand(0, strlen($Chars)-1);
$Secret .= substr($Chars, $Rand, 1);

}
return str_shuffle($Secret);

}

The

a

code generates

random string using
mt rand() and then shufﬂes the string using the
str shuffle() function which internally uses the
rand() function. If we try to apply directly the seed
recovery attack, i.e. try to ask a question of the form
“which seed produces this token” then we will run
into problems because we have to take into account
two seeds, and a total search space of 64 bits which

is infeasible. The normal action would be to follow
the same path as we did in the Gallery application
where we had a similar problem and utilize the seed
reconstruction attack which does not require an output
of the PRNGs. However, the Gazelle application uses
custom sessions (which are generated using the same
function), and thus we cannot apply that attack either.
The solution lies into slightly moﬁying the seed recov-
ery attack. Instead of asking the question “which seed
produces this mt rand() sequence”, which is shufﬂed
and thus affected by the second PRNG, we instead ask
which seed produces the unsorted set which contains
the characters of our string. This set is not affected by
the shufﬂing and thus we can effectively bruteforce
the mt rand() seed independently. After recovering
the mt rand() seed we know the initial sequence that
was produced and we can subsequently recover the
seed of rand() using the same attack.

6.2 Attacks Implementation
In addition to auditing the applications, we imple-
mented a number of our attacks targeting selected ap-
plications.
In particular, we implemented a seed re-
covery attack against Mediawiki, a state reconstruction
attack against the Phorum application and the request
twins technique against Zen-cart. In the following sec-
tions we will brieﬂy describe each vulnerability and
the results of our attacks implementation.
Mediawiki. Mediawiki is a very popular wiki appli-
cation used, among others, by Wikipedia. Mediawiki
uses mt rand() in order to generate a new password
when the user requests a password reset. In order to
predict the generated password we use the seed recov-
ery attack of section 4.3. The function f that we sam-
ple is the one used to generate a CSRF token which is
the following:

function generateToken( $salt = ’’ ) {

$token = dechex(mt_rand()).dechex(mt_rand());
return

md5( $token . $salt );

}

Our function f given a seed s ﬁrst seeds the
mt rand() generator and then uses that generator to
produce a token as the function above. To fully eval-
uate the practicality of the attack we implemented the
attack online, without any time-space tradeoff. Our im-
plementation was able to cover around 1300000 seed
evaluations of f per second in a dual-core laptop with
two 2.3 GHz processors. This allowed us to cover the
full 232 range in about 70 minutes. Of course, using
a time-space tradeoff the search time could be further
reduced to a few minutes.
Zen cart. Zen-Cart is a popular eCommerce applica-
tion. At the time of this writing, a sample database
which shops enter volunterily numbers about 2500 ac-
tive e-shops 6.
In order to reset a user’s password

6www.zen-cart.com/index.php?main_page=showcase

14

zen-cart ﬁrst seeds the mt rand() generator with the
microtime() function and then uses the mt rand()
function to produce a new password for the user. Thus,
there at most 106 possible passwords which could be
produced. Our exploit used the request twins tech-
nique to reset both our password and the target user’s
password. Afterwards, we bruteforced the generated
password for our account to recover the microtime()
value that produced it. This takes at most a few sec-
onds on any modern laptop. Then, our exploit brute-
forces the passwords generated by microtime() val-
ues close to the one that generated our own new pass-
word. We ran our exploit in a network with RTT
around 9 ms, and Zen-Cart was installed in a 4× 2.3
GHz server. The average difference of the two pass-
words was about 3600 microseconds, and the exploit
needed at most two times that requests since we don’t
know which password was produced ﬁrst. With the
rate of 2500 requests per minute that our implementa-
tion achieves, the attack is completed in a few minutes.
Phorum. Phorum is a classic bulletin board applica-
tion. It was used, among others, by the eStream com-
petition as an online discussion platform. In order for
a user to reset his password the following function is
used:

function phorum_gen_password($charpart=4, $numpart=3)
{

$vowels = ... //[char array];
$cons = ... //[char array];
$num_vowels = count($vowels);
$num_cons = count($cons);
$password="";

for($i = 0; $i < $charpart; $i++){
$password .= $cons[mt_rand(0, $num_cons - 1)]

. $vowels[mt_rand(0, $num_vowels - 1)];

}
$password = substr($password, 0, $charpart);
if($numpart){

$max=(int)str_pad("", $numpart, "9");
$min=(int)str_pad("1", $numpart, "0");
$num=(string)mt_rand($min, $max);

}
return strtolower($password.$num);

}

What makes this function interesting in the context
of state recovery is that at if called with no arguments
(as it is in the application), at least four mt rand()
leaks are discarded in each call. We implemented
the attack having the application installed in a Win-
dows server with the Apache web server and we used
our generic technique for Windows in order to recon-
nect to the same process. On average, the attack re-
quired around 1100 requests and 11 reconnections of
our client. The running time was about 30 minutes, and
the main source of overhead was the system solving.
This fact is mainly explained from the small number
of buckets and the lost leaks of each iteration. Nev-
erthless, the attack remained highly practical, as we

were able to compormise any user account (including
the administrator) within half an hour.

7 Defending against the Attacks

We believe that a major shortcoming of the PHP core
is that it does not provide a native cryptographically
secure PRNG and token generator.
In fact, a pseu-
dorandom function (PRF) would be the most suitable
cryptographic primitive for generating random tokens
based on program deﬁned labels; PRF’s can be con-
structed by PRNG’s [7]. We feel that this is a short-
coming since developers tend to prefer functions from
the core as they are compatible with every different
enviroment PHP is running in. A possible solution
would be to introduce a secure PRNG in the PHP
core (as a new function). We proposed this solu-
tion to the PHP development team which informed us
that the development overhead would be too big for
supporting such a function and the solution of using
openssl random pseudo bytes() (which requires
OpenSSL) is their recommendation.

On the other hand, administrators can take a num-
ber of precautions to defend against randomness at-
tacks using current PHP versions. The Suhosin ex-
tension provides a secure seed in the mt rand() and
rand() functions. The seed exploits the fact that the
Mersenne Twister has a large state and ﬁlls that state
using a hash function. Because rand() may have a
small state and is dependent from the operating sys-
tem, the Suhosin extension replaces rand() with a
Mersenne twister generator with a different state from
mt rand(). The hashed values of the seed used are
a concatenation of predictable values such as process
identiﬁers and timestamps, along with, potentially, un-
predictable ones such as memory addresses of vari-
ables and input from /dev/urandom. Because the
addresses in any modern operating system are ran-
domized through ASLR, as a security precaution, us-
ing them as a seed should provide enough additional
entropy to make the two seed attacks (sections 4.2,
4.3) infeasible (assuming ASLR addresses are un-
predictable).
In addition, the suhosin extension ig-
nores the calls to the seeding functions mt srand(),
srand() in order to defend against weak seeding from
the application. Although this may introduce a state re-
covery vulnerability, in the majority of our case stud-
ies, custom seeding was pretty weak and this mea-
sure (of securely seeding once and ignoring applica-
tion based reseeding) increases security. We strongly
believe that securely seeding the generators, when pos-
sible, is a very useful exploit mitigation for the attacks
we presented. Although state recovery attacks would
still be possible, these attacks are more complex than
the seed attacks which require a handful of requests
and commodity hardware to compromise the applica-
tions. Furthermore, creating a secure seed from such
sources has a negligible performance overhead. There-

fore, such measures should be employed by the PHP
system as safeguards for applications that misuse the
PHP core PRNGs.

Our session preimage attack (section 4.1) can be
mitigated by utilizing an option (disabled by default)
of PHP to add extra entropy, from a ﬁle, in the ses-
sion identiﬁer. By specifying /dev/urandom as the
entropy ﬁle, a user can increase the entropy of a
session arbitrarily thus making it infeasible for an
attacker to obtain a preimage.
In Windows, be-
cause /dev/urandom is not available this option
gathers entropy using the same algorithm as in the
openssl random pseudo bytes() function.
The
PHP developement team informed us that the above
option will be enabled by default in the upcoming ver-
sion, PHP 5.4.

The above workarounds, if employed, will kill our
seed attacks and the generic process distinguisher we
devised. However, state recovery attacks would still be
possible either through some application speciﬁc leak,
or using the generic technique described for Windows
operating systems (section 5.2). In addition, we ﬁnd
the possibility of the existence of other process distin-
guishers very probable; after all, the process identiﬁer
is not considered a cryptographic secret and could be
leaked either through the application or the web server
or even the operating system itself. Therefore, we feel
that even using these workarounds, one should con-
sider state recovery attacks practical.

With the present state of the PHP system, developers
should avoid using directly the PRNGs of the PHP core
for security purposes. Any application that requires
a security token should employ a custom generator,
that will either use the functions from the PHP exten-
sions such as the openssl random pseudo bytes(),
if available, or it will use other entropy sources. We
give an example of one such function in [1].

8 Related Work

The ﬁrst randomness attack in PHP that we are aware
of appeared in a blog post by Stefan Esser [5, 6], where
he described basic system properties such as keep-
alive connection handling by web server processes,
and described how misusing mt srand() could re-
sult in security vulnerabilities that he demonstrated in
some popular applications. Shortly after, the same
author released an update of the Suhosin extension
which included the randomness features for strong
seeding mentioned above. Our preimage attack on
PHP sessions was insipired by an attack introduced by
Samy Kamkar [10], in which he described some cases
where an adversary would be able to guess a PHP ses-
sion. However these attacks assumed a side-channel
of server information. Finally Gregor Kopf [11] de-
scribed, along other attacks, the vulnerability in the
password reset implementation of Joomla. This work
describes some type of seed recovery attacks but only

15

for the case that a fresh seeding occurs within the PHP
script executed.

9 Conclusions

We ﬁnd the fact that the most popular programming
language in a domain that has a clear need for cryp-
tographically strong randomness does not have such a
generator within its core system to be a security hazard.
Still, even if such a generator existed in the language,
the misuse of other functions would not disappear im-
mediately as API misusage is a very common security
problem in modern systems. Therefore, we believe
that research in the practical exploitation of such in-
secure functions should be continued and extended to
other environments even if they do offer better secu-
rity features in their API than PHP. In this paper we
explored the case of PHP installed in the Apache web
server along with mod php. We also showed the ap-
plicability of some of our attacks in cgi mode where
each request is handled by a new process. However,
the case of fast cgi needs further investigation as its
behavior depends highly on its conﬁguration. In addi-
tion, it would be interesting to check other languages
and web servers, such as PHP on an IIS web server, or
Python and Ruby on Rails web applications in Apache.
A problem that is also of theoretical interest is the
development of faster algorithms for recovering trun-
cated linear variables and ﬁnding an explanation for
the logarithmic barrier we encountered when experi-
menting with the H˚astad-Shamir framework. To con-
clude, despite the fact that linear generators are cryp-
tographically insecure, the fact that developers misuse
them for security critical features makes the analysis
of their practical security within a certain application
context an interesting research question which we be-
lieve needs further attention and awareness.

References

[1] George Argyros and Aggelos Kiayias.

I forgot
your password: randomness attacks against php
applications.
http://crypto.di.uoa.gr/
CRYPTO.SEC/Randomness_Attacks.html,
2012.

[2] Unknown

Author.
openssl random pseudo bytes()
painfully
slow.
https:
//bugs.php.net/bug.php?id=51636, 2010.

PHP Bug

51636,

#

[3] Scott Contini and Igor Shparlinski. On stern’s
attack against secret
truncated linear congru-
ential generators.
In Colin Boyd and Juan
Manuel Gonz´alez Nieto, editors, ACISP, vol-
ume 3574 of Lecture Notes in Computer Science,
pages 52–60. Springer, 2005.

16

[4] Stefan Esser. Joomla weak random password re-
set token vulnerability. SektionEins GmbH, Se-
curity Advisory 2008/09/11, 2008.

[5] Stefan Esser. Lesser known security problems in

php applications. In Zend Conference, 2008.

[6] Stefan

Esser.

random

numbers.

so
www.suspekt.org/2008/08/17/mt_
srand-and-not-so-random-numbers/,
2008.

mt srand

not
and
http://

[7] Oded Goldreich, Shaﬁ Goldwasser, and Silvio
Micali. How to construct random functions. J.
ACM, 33(4):792–807, 1986.

[8] Johan H˚astad and Adi Shamir. The cryptographic
security of truncated linearly related variables. In
Robert Sedgewick, editor, STOC, pages 356–362.
ACM, 1985.

[9] Robert ”Hackajar” Imhoff-Dousharm.

Eco-
nomics of password cracking in the gpu era. In
DEFCON 19, 2011.

[10] Samy Kamkar. phpwn: Attacking sessions and
In Blackhat

pseudo-random numbers in php.
USA, Las Vegas, NV 2010, 2010.

[11] Gregor Kopf. Non-obvious bugs by example.
In 27th Chaos Communication Congress CCC,
2010.

[12] Henrik Koy and Claus-Peter Schnorr. Segment
lll-reduction of lattice bases.
In Joseph H. Sil-
verman, editor, CaLC, volume 2146 of Lec-
ture Notes in Computer Science, pages 67–80.
Springer, 2001.

[13] A.K. Lenstra, H.W.jun. Lenstra, and L´aszlo
Lov´asz. Factoring polynomials with rational co-
efﬁcients. Math. Ann., 261:515–534, 1982.

[14] Arjen K. Lenstra, James P. Hughes, Maxime
Augier, Joppe W. Bos, Thorsten Kleinjung, and
Christophe Wachter.
Ron was wrong, whit
IACR Cryptology ePrint Archive,
is right.
2012:064, 2012.

[15] Makoto Matsumoto and Takuji Nishimura.
Mersenne twister: A 623-dimensionally equidis-
tributed uniform pseudo-random number genera-
tor. ACM Trans. Model. Comput. Simul., 8(1):3–
30, 1998.

[16] HD Moore and Valsmith. Tactical exploitation.

In DEFCON 15, 2007.

[17] Jacques Stern. Secret linear congruential gener-
ators are not cryptographically secure. In FOCS,
pages 421–426. IEEE Computer Society, 1987.

