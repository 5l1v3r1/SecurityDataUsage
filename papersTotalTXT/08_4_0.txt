Knock Yourself Out:

Secure Authentication with Short Re-Usable

Passwords

Benjamin G¨uldenring, Volker Roth and Lars Ries

Computer Science

Freie Universit¨at Berlin

Germany

Abstract—We present Knock Yourself Out (KYO), a pass-
word generator that enables secure authentication against a
computationally unbounded adversary. Master passwords can
be surprisingly short and may be re-used for multiple service
accounts even in the event of client compromises and multiple
server compromises. At the same time, KYO is transparent to
service operators and backwards-compatible. Master passwords
are fully client-manageable while secrets shared with service
operators can be kept constant. Likewise, secrets can be changed
without having to change one’s passwords. KYO does not rely on
collision-resistant hash functions and can be implemented with
fast non-cryptographic hash functions. We detail the design of
KYO and we analyze its security mathematically in a random
hash function model. In our empirical evaluation we ﬁnd that
KYO remains secure even if small sets of hash functions are
used instead, in other words, KYO requires minimal storage and
is highly practical.

I.

INTRODUCTION

Authenticating oneself to another party over a computer
network is a fundamental security goal, and passwords are
a pervasive mechanism to accomplish that goal. Passwords
steadfastly resist being outmoded by other authentication
technologies even though they are associated with bad security
and bad usability. Common wisdom says that users must choose
long passwords randomly for best security. Furthermore, users
must not re-use passwords across different services or else
one breach of a service may leak passwords that adversaries
use to breach additional accounts. This is a realistic threat as
the public press can testify. However, users cannot remember
reliably many different secure passwords because of a variety of
cognitive limitations and hence they tend to engage in insecure
password practices. For example Florenˆcio et al. [9] found
that the average password is used at 4 sites. Bonneau and
Preibusch [5] pointed out that after apparent improvements in
password quality between the 70’s and 90’s, the web appears
to have altered that trend again for worse.

Permission to freely reproduce all or part of this paper for noncommercial
purposes is granted provided that copies bear this notice and the full citation
on the ﬁrst page. Reproduction for commercial purposes is strictly prohibited
without the prior written consent of the Internet Society, the ﬁrst-named author
(for reproduction of an entire paper only), and the author’s employer if the
paper was prepared within the scope of employment.
NDSS ’15, 8-11 February 2015, San Diego, CA, USA
Copyright 2015 Internet Society, ISBN 1-891562-38-X
http://dx.doi.org/10.14722/ndss.2015.23261

In our paper, we propose means to signiﬁcantly enhance the
security and usability of password security mechanisms against
security breaches. Speciﬁcally, we address the following two
risks associated with password mechanisms simultaneously.

1) An adversary obtains a copy of a user’s personal password
database and uses the information to log into that user’s
accounts. We call this a client breach.

2) An adversary obtains a copy of a server’s password
database and uses the information to log into accounts on
other servers. We call this a server breach.

As this is done in related work (see section VII), we assume that
the integrity of clients and servers has not been compromised,
for example, by installing a key logger that intercepts entry of a
master password. We do not address the risk that an adversary
obtains a copy of a server’s password database and uses the
information to log into accounts on that same server. Instead,
we discuss in Section VII how related work attempts to mitigate
this risk under varying assumptions and how they blend with
our proposals.

Existing work has addressed client breaches and server
breaches largely in isolation, sometimes using similar mech-
anisms. For example, decoy passwords have been proposed
as a means to trigger false login detection at servers in the
case of client [4] and server [14] breaches. Although, no work
we are aware of has addressed the case that passwords are
shared among accounts and multiple password databases are
breached. For example, intersecting two databases with decoy
passwords quickly reveals all shared passwords and ﬁlters
out decoys with high probability. This yields passwords that
adversaries can potentially use to log onto ﬁrst-party servers
(breached) and third-party servers (not breached). Furthermore,
the protection mechanisms proposed thus far have notable
costs associated with them, for example, increased memory
requirements [4], [14], [7], increased interactions and login
latency [16], delayed veriﬁcation [6] and varying amounts of
required server changes [14], [16], [6]. Even key stretching [15]
consumes energy that largely goes to waste, which is a best
practice most password mechanism rely on in order to counter
ofﬂine attacks. Lastly, none of these proposals introduce more
user-friendly password choices.

In this paper, we propose Knock Yourself Out (KYO), a
novel client-side password generator mechanism that mitigates
the risks of simultaneous breaches of clients and multiple
servers. The master password can be as short as four characters,

and 10 characters if security against the breach of the password
client and three servers is desired. Passwords can be re-used,
that is, a client need only remember one master password.
At the same time, KYO is fully client-manageable, that is,
server-speciﬁc secrets can be changed without changing the
master password, and the master password can be changed
without affecting server secrets. KYO incurs no additional costs
over na¨ıve state of the art password mechanisms and it can
be instantiated with fast non-cryptographic hash functions and
without key stretching. We prove KYO secure in an information-
theoretic setting, that is, in a random hash function model
against unbounded adversaries. KYO is backwards-compatible
with existing server implementations. In order to achieve its best
security and usability product, KYO requires that servers are
conﬁgured to lock accounts upon the ﬁrst false login attempt.
KYO veriﬁes passwords locally and prevents false logins.

In what follows, we further detail our assumptions and threat
model, followed by an overview over KYO’s design, properties
and features. Subsequently, we evaluate KYO mathematically
in a random hash function model and we brieﬂy point out
the impact of moving from a random hash function to smaller
sets of functions. In our subsequent empirical exploration, we
ﬁnd that even small sets of functions exhibit the necessary
and sufﬁcient properties we require. Based on our theoretical
analysis, we estimate the salient properties of KYO, for example,
the relationships between password length and the number
of client and server breaches against which passwords shall
be secure. We discuss obvious and less obvious application
areas for KYO, compare KYO to related work and end with
conclusions and an outlook of what kind of future work we
deem most exciting.

II. ASSUMPTIONS AND THREAT MODEL

For ease of description we assume throughout the paper
that Alice communicates with Bob, Carol and David. One may
think of Alice as a user with a client computer, and of Bob,
Carol and Dave as servers. Alice shares a secret with Bob, and
another one with Carol, and another one with David. KYO
allows Alice to generate all of her shared secrets based on a
single password, if she so desires. For the sake of generality,
we consider the scenario that Alice wishes to use one password
for Bob and a different one for Carol and David. More formally,
let ρ1, ρ2 be Alice’s passwords, let γ1 . . . , γ3 be the secrets
that Alice shares with the other parties and let σA→B be a seed
Alice uses to generate the secret she shares with Bob. Let F
be the generator function, then:

γ1 = FσA→B (ρ1)

γ2 = FσA→C (ρ2)
γ3 = FσA→D (ρ2)

This will be our running example. Alice authenticates herself
to Bob by presenting γ1 to Bob in a fashion that assures that
the presentation is fresh and that γ1 is not revealed to outside
parties. In practice, Alice may connect to Bob using a TLS
connection, Bob authenticates itself to Alice based on a valid
X.509v3 certiﬁcate, and Alice transmits her shared secret to
Bob in order to authenticate herself to Bob. All parties store
their seeds and corresponding identities.

A. Power of the adversary

The adversary may compromise any number of the parties,
for example, Alice, Bob and Carol. We assume that none of the
compromised parties store their passwords, and that they do not
enter their passwords following a compromise. This means that,
for example, the adversary learns all secrets Bob shares with
Alice, and all seeds Alice stores, but not the password of Alice.
Furthermore, we assume that the adversary is computationally
unbounded, that is, he can compute as much as he likes.

The risks we outlined encompass a wide variety of actual
risks to which Alice may expose herself. For example: Alice
looses her laptop, someone seizes or steals her laptop, or
someone compromises one or multiple services that Alice uses
and steals any available secret information on the users of the
service.

B. Security and safety objectives

We say that an adversary succeeds if he authenticates
himself as Alice to an uncompromised party. Depending on
which parties the adversary compromises and how many of
them, we seek to make statements of the form the success
probability of
the adversary is , where  is a concrete
probability based on some choice of security parameters. We
will call the probability  insecurity and accordingly 1 − 
security.

In an analoguous fashion, we wish to make statements
about the safety of password entry. Jumping slightly ahead,
KYO veriﬁes correct password entry locally. Therefore, one
might assume that Alice, the user, has an inﬁnite number of
tries and, consequently, Bob will never lock out Alice because
Alice only submits correct secrets to him. However, if Alice
has an inﬁnite number of tries then an adversary who breaches
the client can brute-force the mechanism ofﬂine. Since we
wish to provide security against client breaches, we cannot
allow this to happen. For this reason, KYO takes a different
approach and as a consequence there exists a probability δ with
which KYO accepts a false password as correct. In this case,
KYO will produce a wrong secret and Bob will lock Alice out.
Hence, security determines an upper bound on safety. In our
mathematical analysis, we show how to control  and δ. In our
writing, we refer to δ as insafety and to 1 − δ as safety.

C. Baseline security

Eventually, we must choose concrete parameters and these
parameters determine the actual security and safety of KYO and
the necessary lengths of passwords. We want our passwords
to be as short as possible without sacriﬁcing security and
safety. Hence the question arises what are acceptable levels of
security and safety. Towards guidance we look at the security
of ATM machines. It is probably safe to assume that the risk
of unauthorized access to one’s bank account is an acceptable
baseline. We further assume that the adversary is in possession
of a banking card and hence the remaining security lies in
the PIN. ATMs typically limit the number of invalid PIN
entries to two so that a user has three attempts to enter the
correct PIN. Conservatively, we assume that the PIN number is
chosen uniformly at random from the set {0, . . . , 9}4 and hence
there are N = 104 equally likely PINs. The failure probability

2

of guessing a particular PIN in n tries is then given by the
hypergeometric distribution

(cid:19)(cid:18)N − 1
(cid:18)1
(cid:19)

(cid:18)N

(cid:19)−1

·

,

0

n

n

which simpliﬁes to 1 − n · 10−4. Thus for three allowed PIN
entries the insecurity of this scheme is 3 · 10−4. Since ATM
machines are in widespread use, we believe 3 · 10−4 to be
a reasonable baseline for insecurity. Likewise, it is probably
fair to argue that, most of the time, a security breach in this
scenario is a more serious event than a lockout. From this we
conclude that the security bound is suitable as a bound for
safety as well.

D. Residual risks and attacks

We have mentioned before that KYO performs best if servers
lock an account immediately if the client provides a false secret.
This poses a denial of service risk. Actually, this risk exists
in any password system that tolerates only a low constant
number of false logins. A second risk is that an adversary
succeeds simply by ﬁxing a random password and by trying
this password on a large number of user accounts. If a server
has a large number of users then with a good probability, the
adversary will breach some accounts. Again, this is a risk that
applies to password systems in general. Although, the risk
is somewhat higher in the case of KYO because KYO uses
short secrets in addition to short passwords. Short secrets have
other security beneﬁts, as we discuss in following sections.
Fortunately, there is a general solution that mitigates the two
risks we just mentioned. Randomizing users’ identities forces
the adversary to guess matching user identities and passwords.
Hence, we can augment n bits of password entropy with an
arbitrary entropy m from user identities for a total of n + m
bits. Florenˆcio et al. [10] discuss this approach nicely in a paper
of theirs and therefore we assume henceforth that the problem
is solved adequately. We discuss another similar solution in
Section VI to make KYO backwards compatible with existing
systems.

III. DESIGN

A contemporary password check fulﬁls two goals. First, it
veriﬁes that Alice entered her password correctly, and second,
it veriﬁes that the entered password is authentic. The former
is a safety check (that the password was entered correctly) and
the latter is a security check (it matches the one associated with
the user account). If the server veriﬁes both safety and security,
this distinction seems artiﬁcial since the response is typically
the same in both cases (for example, a prompt to re-enter
one’s password). It does not make sense to distinguish between
them. In the case of our password generator schemes there is
a distinction, however, because Alice checks her password ρ1
locally for correctness, and Bob stops accepting communication
from Alice immediately if Alice presents anything but γA→B
as her secret. In order to prevent this from happening when
she enters a wrong password, Alice uses an error detecting
code in order to check passwords for correctness locally. This
code will however detect only a fraction of all possible false
password entries.

Towards an understanding of the principles that underpin
our KYO password generator, consider a function Fσ that

3

safety

110

101

111

000

100

011

passwords

48D3
0E97
AA98
187F
...

s
e
c
u
r
i
t
y

σ

F
001

010

Fig. 1. Example password partition among eight subsets. As the number of
subsets increases, the list of colliding passwords becomes smaller.

partitions the set of all hexadecimal passwords of length four
into eight evenly sized subsets as indicated in Figure 1. For
example, Fσ maps the password (48D3)16 to the subset (001)2.
We use the output of F as the error correction information and
store it locally on a computer. Assume that Fσ maps passwords
randomly to each subset. It follows that the probability that
any password is in subset (001)2 is 1/8. The safety of F is
therefore the probability that a password other than (48D3)16
is not in that same subset, which is 1− 1/8 = 0.875. Assuming
that passwords are chosen uniformly at random, each subset
contains (164/23) = 8192 equally likely passwords. Therefore,
the security of F against an attacker with knowledge of F
and the subset (001)2 is 1 − 1/8192 ≈ 0.9999, even if the
adversary is unbounded.

There is a small catch, though. If Alice enters her password
incorrectly multiple times and her entries are pair-wise different
then safety decreases because the remaining number of incorrect
passwords not mapped to (001)2 decreases compared to the
number of incorrect passwords mapped to (001)2. This effect
compounds over multiple authentication sessions unless Alice
always makes the same errors. Therefore, KYO chooses a new
seed σ each time Alice enters her password correctly. This
renders authentication sessions independent of each other and
improves safety. In what follows, we explore these ideas further.
Particularly, we will use two instances of the sketched function
F , one for checking safety and another one to generate secrets.

A. KYO families

We require functions with certain properties for KYO. In this
section, we deﬁne these requirements. We begin by introducing
necessary terminology. Towards this end, let S = {0, 1}s, P =
{0, 1}n, L = {0, 1}(cid:96) with s ≥ n > (cid:96) be sets and let (Fσ)σ∈S
be a family of hash functions with

Fσ : P → L,

γ = Fσ(ρ).

We call ρ ∈ P password and σ ∈ S seed. We call γ ∈ L
(shared) secret if it is used for authentication purposes, or
digest if it is used for error detection. If there is no need for a
distinction between these two cases then we use the term digest
for both. Note that since we require that n > (cid:96), Fσ will be a
lossy function, that is, non-injective. Unless noted otherwise,
whenever we say that some element is chosen randomly from
some set, we mean that it is chosen uniformly at random from
that set and independent from any other values that might be
chosen from the same set at the same time.

pw pw-info
1
(σ1, γ1)
2
(σ2, γ2)

entry
Bob
Carol
Dave

pw seed
1
2
2

σA→B
σA→C
σA→D

Password table PW

Address book T

Fig. 2. Contents of Alice’s address book and password table for a shared
password ρ2 for Carol and Dave, and a separate password ρ1 for Bob.

Requirement 1 (Password selection). Given arbitrary pass-
words ρ1, . . . , ρN ∈ P , seeds σ1, . . . , σN ∈ S and digests
γ1, . . . , γN ∈ L with Fσi(ρi) = γi, there exists a password
ρ ∈ P with Fσi(ρ) (cid:54)= γi for all i = 1, . . . , N.
Requirement 2 (Seed selection 1). Given arbitrary passwords
ρ, ρ1, . . . , ρN ∈ P , there exists a seed σ ∈ S with Fσ(ρ) (cid:54)=
Fσ(ρi) for all i = 1, . . . , N.
Requirement 3 (Seed selection 2). Given an arbitrary pass-
word ρ ∈ P and a shared secret γ ∈ L, there exists a seed
σ ∈ S with Fσ(ρ) = γ.

We also require that there exist algorithms that compute
passwords and seeds according to these requirements. We do
not require that these algorithms are efﬁcient in a complexity-
theoretic sense but instead that running them is feasible for
practical choices of parameters. In Section IV-A, we show that
random sampling computes passwords and seeds with high
probability.

B. Data structures

The KYO password generator manages and generates secrets
based on a password table PW and an address book table T,
see Figure 2 for illustration. The password table keeps error
detection information on passwords, that is, a seed and digest
for each password. The address book contains records that
name the recipient (for example, a server), the index of the
associated password record in the password table, and a seed
speciﬁc to that recipient and the associated password. In what
follows, we describe how KYO implements common operations
such as verifying passwords, computing secrets, adding and
removing accounts, adding and changing passwords, et cetera.

C. Password creation and veriﬁcation

In order to create a new password entry in PW, Alice
ﬁrst selects a random password ρ ∈ P . If the password table
PW is still empty, she then selects a random seed σ ∈ S,
calculates γ := Fσ(ρ) and stores (σ1, γ1) := (σ, γ) in PW.
If PW is not empty then Alice selects a random ρ ∈ P that
meets requirement 1 and a random seed σ ∈ S that meets
requirement 2. Next, she calculates γ := Fσ(ρ) and stores
(σi, γi) := (σ, γ) with a fresh index i in PW. This ensures
that table PW satisﬁes the following constraint with a high
probability:
Constraint 1 (Confused passwords). Let ρi be Alice’s pass-
words. Table PW satisﬁes the confused passwords constraint
iff for all i and j:

Fσi(ρj) = γi ⇒ j = i.

Scheme 1 KYO secret derivation

procedure AUTH(Password ρ, Recipient R)

r := T[R].pw
(σcheck, γcheck) := PW[r].pw-info
σ := T[R].seed

if Fσcheck (ρ) = γcheck then

σ(cid:48) ←R S
PW[r].pw-info := (σ(cid:48), γ(cid:48))

(cid:46) fulﬁlling requirement 2

else

return Fσ(ρ)
return ⊥

(cid:46) shared secret derivation

(cid:46) report error and restart

In order to verify if a password ρ is the correct password
for entry i, Alice retrieves the entry (σi, γi) from PW and
tests whether Fσi (ρ) = γi. If so, we say that ρ veriﬁes under
(σi, γi). Constraint 1 ensures that each password veriﬁes under
only one entry (σi, γi) in PW, thus providing password safety.

D. Adding recipients and shared secret derivation

In order to add a recipient, say Bob, to the address book
T, Alice selects a random seed σ ∈ S and chooses a password
index i from PW. Alice then enters her password ρ. If ρ veriﬁes
under (σi, γi) then Alice stores the entry (cid:104)Bob, i, σ(cid:105) in T. She
ﬁnally transmits the shared secret γ := Fσ(ρ) to Bob who
will store it locally in order to verify Alice with it in the
future. Figure 2 shows Alice’s tables PW and T for our running
example of one password for Bob and a shared one for Carol
and Dave.

In order to derive a shared secret for recipient R, Alice
enters a password ρ and runs Algorithm AUTH(ρ, R) in
Scheme 1. Upon entering ρ, the algorithm tests if ρ veriﬁes
for recipient R. If the test fails then the algorithm fails and
Alice is assumed to have entered a wrong password. If the test
succeeds then the algorithms updates the corresponding entry
in PW and outputs a shared secret. As we show in Section IV,
the update of the entry in PW is important for the scheme’s
safety.

E. Changing passwords and shared secrets

Alice might want to change a secret she shares with Bob
without changing her password. This is not possible with
contemporary password generators but it is straightfoward in
KYO. Alice selects a new random seed σ ∈ S, calculates the
shared secret and informs the recipient of it’s new value.

Changing one’s password while keeping all shared secrets
the same is more involved. Let σi, γi with i ∈ I be the seeds
and shared secrets that are protected by password ρ (the seed
is taken from table T), that is, it holds that
∀i ∈ I : Fσi(ρ) = γi.

Alice chooses a new random password ρ(cid:48) ∈ P that satisﬁes
i ∈ S that
Constraint 1. Subsequently, she must ﬁnd seeds σ(cid:48)
fulﬁll the equation before. Requirement 3 states that it is
possible to ﬁnd such seed values. Once found, Alice replaces
the entry in PW with (σ(cid:48), Fσ(cid:48)(ρ(cid:48))) with a fresh selected seed
σ(cid:48) ∈ S and updates the entries of T with the found seeds σ(cid:48)
i.

4

In our evaluation in Section IV we show that it is not only
possible to ﬁnd these seeds σ(cid:48)
i but also that doing so does not
compromise security. We will call this scenario selected seeds,
because a seed is “selected” to ﬁt an independently chosen
password and shared secret.

F. Managing password sharing

Alice may use the same technique to transparently manage
groups, that is, the recipients for whom she uses the same
password, say ρ. In order to include someone in that group
with whom she shares secret γ, all she needs to do is ﬁnd an
additional σ so that Fσ(ρ) = γ.

In order to exclude someone from a group, she simply
chooses a new random password ρ(cid:48) that satisﬁes constraint 1
and ﬁnds a seed σ that satisﬁes Fσ(ρ(cid:48)) = γ. As before,
Requirements 1 and 3 ensure that this is possible.

G. Synchronizing shared secrets

In what we have seen so far, Bob stores the secret γ he
shares with Alice locally in order to be able to verify if a
client is indeed Alice. Instead of storing the secret explicitly,
Bob can protect γ using F in the same way Alice protects
her secrets. In order to do so he selects a random veriﬁcation
password ρv ∈ P and ﬁnds a veriﬁcation seed σv ∈ S so that
Fσv (ρv) = γ. Once found, he stores σv in a separate column
in his own address book T. The necessary Algorithm AUTHv
for this is basically the same as AUTH in Scheme 1, with the
symbols of seeds and digests substituted in the obvious manner.
Bob runs AUTHv(ρv, R) and accepts if the output is the same
as the shared secret he received from Alice.

If Bob had a password beforehand that he uses to authen-
ticate himself to Alice then Bob can keep his password and
synchronize the secret he shared with Alice with the secret
that Alice shared with him. Essentially, both Alice and Bob
choose passwords and seeds that map to the same secret. In this
fashion, Bob des not have to store two seeds for two secrets
both shared with Alice. Since passwords and shared secrets are
chosen randomly and independently of each other, this scenario
is essentially the same as the selected seeds scenario and
Requirement 3 ensures that it is possible to ﬁnd the necessary
seed values.

It is worth noting that if all participants used synchronized
secrets then an adversary would not be able to impersonate
anyone even if he had access to all KYO tables of everyone, as
we show in our evaluation. The downside is that synchronized
secrets link the security of the authentication of Bob and Alice.
This means that if an adversary ever learns the secret that Alice
uses to authenticate herself to Bob (for example, by breaking
into their communication channel) then the adversary cannot
only authenticate himself as Alice to Bob but also vice versa.

H. Summary of properties

By what we have described so far, it should be clear that
Alice is free to manage groups of users for whom she can
choose same or different passwords as a means of protecting
shared secrets. Furthermore, Alice is free to change passwords
and secrets as she pleases. Moreover, all communicating parties
can synchronize their seeds so that they can choose individual

passwords to manage mutually shared secrets for authentication
purposes. The use of shared secrets is not limited to online
communication, though. Since KYO does not require a feedback
channel, communicating parties may use their shared secrets
for other purposes as well, for example, for the purpose of
authenticating electronic mail. It is important to note, though,
that the shared secret is short by design and, hence, the
authentication scheme must be designed carefully to account
for this property.

IV. EVALUATION

In this section we analyze KYO mathematically based on
the assumption that F is a random hash function. This implies
that |S| = |L||P|. We update our deﬁnition of KYO families
from Section III-A accordingly as follows:
Deﬁnition 1 (KYO family). Let F be the set of all functions
mapping P to L and let S be an index set enumerating them.
Then (Fσ)σ∈S is called a KYO(n, s, (cid:96))-Family.

The deﬁnition implies that Fσ is selected randomly from
F given a random seed σ. For growing P and L, the length of
a seed quickly exceeds what is feasibly processed and stored
on a computer. In practice, we will therefore work with index
sets that are much smaller. This is unproblematic as long as
the number of recipients per password is small compared to 2s.
This is because the distribution over random samples of the
indexes has the same mathematical expectation as F . Therefore,
we just need “enough” indexes so that F meets the requirements
we introduced in Section III-A. The analysis and the proofs
are simpler in the case of a random hash function, though. We
have proven corresponding lemmas and theorems for random
index subsets as well but presenting them here while meeting
the page limit would render the presentation unreadable.

In what follows, we show that KYO families meet the
requirements we put forward in Section III-A. For ease of
reading we only state the results in this section and give the
proofs in Appendix A. Subsequently, we analyze the safety of
KYO families followed by an analysis of the security of KYO
families.

A. KYO generator properties

For a given ρ ∈ {0, 1}n and σ,∈ {0, 1}s, we denote the

set of passwords that map to γ under σ with

σ (γ) := {ρ(cid:48) ∈ P | Fσ(ρ(cid:48)) = γ} .
F −1

We now show that a KYO family meets Requirements 1
and 2 and 3 with high probability. The following lemmas state
that random sampling is sufﬁcient to achieve safety with high
probability.
Lemma 1 (Password creation). If the password table PW
already contains N passwords, the number of random tries to
ﬁnd the (N + 1)-th password is geometrically distributed with
average value (1 − N · 2−(cid:96))−1.
Lemma 2 (Seed selection 1). For N − 1 given passwords, a
randomly chosen seed σ meets Requirement 2 with probability
(1 − 2−(cid:96))N−1.

5

that KYO does not allow unsuccessful authentication attempts,
that is, an attacker has only one try to predict the target secret.
If Alice re-uses the target password for N − 1 other recipients
then an adversary may try to authenticate to each of them to
learn information about the target password. In order to simplify
this part of our analysis we assume that an adversary is then
given the secrets of those N − 1 recipients. From here on, we
assume that K contains the following types of information:

• The contents of Alice’s address book,
• a set of passwords,
• a set of shared secrets other than the target, and
• whether any shared secrets are selected.

In practice, K might include information from sources outside
of our model as well, for example, partial information on the
target password derived from smudges on the touch screen
of a smartphone [2]. We consider these side-channels out of
our scope. For the purpose of our analysis, the items above
are a complete characterization of the types of information
an adversary can have. Hence, by taking into account all
combinations of these items, we get an exhaustive view on an
adversary’s success probability.

We begin by reasoning that the adversary must know a
user’s address book to glean information on a target secret.
Assume he does not. Then he may know at most all secrets
other than the target secret and he may know all passwords. The
secrets yield information on their corresponding passwords but
passwords only yield information on other passwords through
digests in the password table. Therefore, the best the adversary
can hope is to learn the target password, which we just assumed
he already knows. Since F comprises all functions from P to
L, there exist equally many seeds σ for any pair of ρ and γ so
that Fσ(ρ) = γ. This follows from a simple labeling argument.
Hence, given the target password but not the target seed, all
secrets are equally likely, which completes our argument.

In what follows, we assume that the adversary has obtained
information from the address book table and the password table.
We are left with two types of information transfers to analyze:

1) The ﬁrst transfer is from secrets to passwords through the

contents of the password table.

2) The second transfer is from passwords to secrets through

the contents of the address book table.

Remember that the goal of the adversary is to glean information
on the target secret based on at most a ﬁxed number of other
leaked secrets and information in the user’s password table and
address book table.

We begin with the second type of transfer. Our analytical
goal is to measure the probability distribution over secrets given
partial knowledge about a password. Note that the information
whether the target seed is selected (as opposed to having been
chosen entirely at random) does not help here since the number
of seeds to choose from are the same for every password
and digest combination. Therefore, we ignore selected seeds
for now. The following deﬁnition models the secret guessing
experiment accordingly.
Deﬁnition 4 (Guessing secrets experiment).
The secrets guessing experiment is deﬁned by the probability

space (Ω,P(Ω), Pr), with

Ω := {(ρ, σ) ∈ P × S}.

In order to work with this deﬁnition we deﬁne the random
variables R that gives the target password, Σ that gives the
target seed and Γ the target secret. In detail, for given ρ, σ or
γ:

• R = ρ denotes all events (ρ, σ) with σ ∈ S,
• Σ = σ denotes all events (ρ, σ) with ρ ∈ P , and
• Γ = γ denotes all events (ρ, σ) ∈ Ω with Fσ(ρ) = γ.
As we will see in the next section, if an adversary learns
secrets and seeds he will learn a candidate set C of passwords
that are all equally likely. The next lemma gives the guessing
probability with knowledge of C.
Lemma 5 (Guessing secrets). Let C be a set of equally likely
candidate passwords and let c = |C|. We deﬁne M = Fσ(C).
Then the probability

Pr[Γ = γ | Σ = σ ∧ ρ ∈ C]
is binomial distributed with the average value

(cid:0)2(cid:96) · (1 − (1 − 2−(cid:96))c)(cid:1)−1

for every γ ∈ M.

We discuss the ﬁrst type of information transfer next, that
is, how an adversary may gain knowledge of a set of candidate
passwords C. Speciﬁcally, we investigate what happens if the
adversary learns the contents of Alice’s address book and her
shared secrets. We obtain results about the size of the password
candidate set C and that all passwords within C are equally
likely. These results and the results from Lemma 5 together
yield the overall guessing probability.

Recall that in the selected seeds scenario, Alice ﬁxes a
password ρ and a secret γi and then chooses a seed σi so
that Fσi(ρ) = γi. Let Si(ρ) denote the set from which Alice
chooses the seed σi. If Alice does not ﬁx a secret γi then let
Si(ρ) denote the set of all seeds, that is, Si(ρ) = S. Next, we
model the probability distribution over passwords if seeds and
secrets are learned.
Deﬁnition 5 (Guessing passwords experiment).
The password guessing experiment is deﬁned by the probability
space (Ω,P(Ω), Pr), with

Ω = {(ρ, σ1, . . . , σN ) | ρ ∈ P, σi ∈ Si(ρ)},

| P | · N(cid:89)

1

i=1

1

| Si(ρ) | ,

a digest γi is given
else.

and

where

Pr[(ρ, σ1, . . . , σN )] :=

(cid:26){σ | Fσ(ρ) = γi}

Si(ρ) :=

S

In addition to the random variables we have deﬁned before
(R, Σ and Γ) we need random variables Σi and Γi. Variable
Σi describes the seed for the i-th pair and variable Γi describes

7

permissible then Alice may protect herself against denial of
service attacks in the following way. In addition to her secret
γ, Alice shares a randomly generated token τ. She stores τ
in plain text in her address book and sends τ, γ to Bob. Bob
only veriﬁes whether Alice’s password is correct if the received
token τ matches the one he has stored for Alice. It is easy to
see that an adversary succeeds in locking out Alice only if he
guesses the value τ, the probability of which is negligible in
τ. Note that in this case, τ is related to safety and not security.
Hence, Alice only looses denial of service protection (safety)
if her Address book is disclosed.

Alice may use a similar approach to achieve backwards
compatibility with servers that are oblivious to KYO, that
is, servers that
lock users out only after multiple failed
authentication attempts (instead of one failed attempt). As
before, Alice generates and stores a token τ in her address book
and sends τ||γ for authentication. Note that τ is now related to
security and Alice sacriﬁces KYO’s protection against address
book loss in exchange for achieving backwards compatibility.
However, KYO’s protection against server-side disclosures
remains intact.

Besides the obvious uses of KYO, we originally designed it
to help solve a problem that arises in whistleblowing systems.
Consider a whistleblower Alice who established contact with
a journalist Bob and wishes to send e-mail to the journalist
using an anonymous re-mailer. In order to authenticate herself
to Bob, Alice encrypts a shared secret along with the message.
A typing error would stall her account with Bob and hence it
is desirable to check locally that the secret is the correct one.
An incorrect secret would then be a giveaway that Alice is in
danger. However, it might be desastrous for the whistleblower
if the adversary found the secret on her computer because
he could use the secret to conﬁrm that she indeed is the
whistleblower. With KYO, she can keep her secret on her
computer protected with a 4 character password even if the
adversary is computationally unbounded.

VII. RELATED WORK

KYO families are an exploration of ideas similar to those of
collisionful hash functions [3] or collision rich hashing proposed
previously to secure ﬁle checksums against manipulation [19]
or to protect key exchange protocols against man-in-the-middle
attacks using weak passwords [1]. KYO can be understood as
an extension of collisionful hashing to password sharing and
password management.

A. Server-side mechanisms

Cappos proposed PolyPassHash [6], which is a mechanism
meant
to mitigate password database leaks from servers.
The mechanism keeps users’ salted and hashed passwords
xor’ed with a per-user share. Without knowledge of a share,
adversaries cannot brute-force the associated password. Shares
are computed using a (k, n)-threshold scheme. The general idea
is that once k users have provided their passwords, k shares
can be recovered and all other shares can be computed. From
this moment on, logins can be veriﬁed. In order to allow some
level of password veriﬁcation before the threshold is reached,
Cappos suggests that each database entry leak some bits of the
salted and hashed passwords.

This bears some resemblance to how KYO uses digests.
However, whereas digests are a safety mechanism in KYO,
they are a security mechanism in PolyPassHash. In KYO, a
random digest collision results in a fail-safe lockout whereas
it leads to a security breach in the case of PolyPassHash.
Furthermore, adversaries can use the leaked bits to conﬁrm
suspected password re-use, for example, if they have obtained
other login credentials of some users in the PolyPassHash
database. This in turn allows one to recover shares. KYO, on
the other hand, is designed speciﬁcally to mitigate the risks of
multiple related database leaks (and client leaks).

It is worth noting that PolyPassHash can be broken by
bribing at most k users into revealing their passwords after a
database leak. This poses no subjective risk to users because
they can change their passwords to new ones before revealing
their old ones. An even easiest and cheaper attack is to open
k accounts at the service before downloading the password
database. This means that k passwords are known and all shares
can be recovered easily. In the KYO case, password database
leaks provide no information on users’ passwords unless clients
are breached as well, because the seeds are only on clients.

HoneyWords [14] is another mechanism to mitigate pass-
word database leaks. The server keeps k − 1 decoy passwords
along with each correct one, in random order. When a user
logs in, the server queries a trusted honey checker service
with the user id and obtains the index of the correct password,
which is used to verify the user’s input. If an adversary obtains
the bassword database then he has a 1/k chance to choose
the right password. If he chooses a decoy then the server
locks the associated account. Obviously, the decoys must be
chosen so that they are not easily distinguished from the real
password. However, adversaries may attempt to exclude decoys
by submitting them to other services posing as the same user.
If the attempt is successful then the user has very likely re-used
her password. If the attempt is unsuccessful then the password
might have been a decoy and the adversary tries another one.
SAuth [16] also uses decoys to mitigate password database
leaks of a service. Decoys are valid alternative passwords,
though. Their purpose is not to protect the breached service
but to mitigate attacks on other services in cases of password
re-use. If two databases are leaked then, again, password re-
use is insecure. As in other decoy uses, the challenge is to
generate decoys in a fashion that makes them indistinguishable
from user-provided passwords. SAuth also requires that users
authenticate themselves not only with a valid password but
also that they log into a vouching service with the password
of the vouching service. Both services must be speciﬁed
beforehand and assurances must be provided that both accounts
belong to the same individual. A downside is that users are
inconvenienced compared to the status quo because SAuth
incurs additional interaction and login delays.

Mechanisms that employ decoys typically require O(k · n)
memory where n is the number of passwords and k − 1 the
number of decoys. For large databases, this incurs considerable
overhead. If memory is plentiful then passwords can be pro-
tected against off-line attacks in a bounded retrieval model [7].
The underlying assumption is that the password database is
too large to be leaked in its entirety. KYO, on the other hand,
requires O(n) memory, the size of a contemporary password
database.

11

B. Client-side mechanisms

Many password managers, for example, those proposed by
Ross et al. [23], [13] and Haldermann et al. [23], [13], apply
collision resistant hash functions to various combinations of
a user password, user name, site name and a random nonce.
A usual assumption is that the hash function is slow enough
so that an exhaustive search for the password is infeasible.
However, this type of protection requires that passwords are
long enough to withstand exhaustive search and that the hash
function is regularly updated to reﬂect advances in algorithms
and processor speed. KYO, on the other hand, is designed
to be resistant against computationally unbounded adversaries.
Assume, for comparison, that calculating a secret takes 1 second
on commodity hardware on a single CPU core and further
assume that KYO is conﬁgured to use 25 bit long random
passwords. Since exhaustive searches are trivially parallelized,
an eight-core CPU would take at most 48 days to ﬁnd the
password. KYO, on the other hand, remains secure.

Several works propose means to harden password managers
against risks such as a client breach. Perhaps the most prominent
work is Kamouﬂage due to Bojinov et al. [4]. The authors
pointed out that most password manager implementations could
be brute-forced. They improved upon the password manager
concept by introducing decoy databases so that an adversary
cannot decide which database holds the correct password for a
given service and needs to guess randomly. Failure to guess
correctly would eventually cause the attacked account being
locked, for example, based on a three-strikes rule. The beneﬁts
come at a cost, though. Bojinov et al. recommend 105 databases
per user as a working conﬁguration. Furthermore, the way in
which databases are populated is quite involved because, again,
decoys must be generated so that the adversary cannot easily
tell them apart from real passwords.

iMobileSitter [12] is a password manager for smartphones.
It accepts any master password that is input and, if the master
password is false, decrypts its secrets erroneously but plausibly-
looking. For example, a four digit PIN is always decrypted into
a (different) four digit PIN. In order to hint at incorrect master
passwords, it displays an iconic image along with retrieved
secrets and expects that the user recognizes that a wrong image
is displayed along with a falsely decrypted secret. By virtue of
being a password manager rather than a password generator,
iMobileSitter is susceptible to known-plaintext or plausible
plaintext attacks on the master password. In particular if the
secrets have hidden structure, for example, secret strings in
l33t sp34k, this can be leveraged in a brute-force attack on
the master password. This also means that iMobileSitter is not
robust against server breaches, which yield known plaintexts.
Additional approaches to hardening secret key encryption
use bits of information of a users’s personal life in order to
encrypt the secret key [8], they use multiple low entropy pass-
words in order to generate a high entropy password [11] or they
leverage secure personal devices for password recovery [20].
there is password-corrective
hashing [21]. In this approach hash functions map similar
passwords to the same output, for example, passwords that
differ with respect to character transpositions and substitutions.
In contrast to our work, password-corrective hashing does not
take password sharing into account. Furthermore, a variety of

On the input error side,

factors may inﬂuence the input errors users make, for example,
the keyboard layout and the input method [24]. In particular,
soft keyboards on mobile phones were shown to yield different
input error rates. We believe it likely that different layouts also
have an inﬂuence on the types of errors. Password corrective
hashing would have to account for all conceivable inﬂuences,
particularly if passwords are meant to be shared among different
devices.

C. Related work summary

In summary, while it may appear that KYO uses elements
that have been published prior, none of the cited works and no
existing password management solution of which we are aware
offers the combination of beneﬁts that KYO offers while KYO
suffers from none of the limits and downsides that existing
approaches have. Some properties of KYO make it quite unique
and an interesting subject for further study. In particular, KYO
demonstrates that surprisingly short passwords can offer a high
level of security against unbounded attackers while protecting
against client and multiple server breaches. Second, KYO
demonstrates that fast non-cryptographic hash functions have
compelling security applications, particularly hash functions
for which pre-images can be enumerated efﬁciently.

VIII. CONCLUSION AND FUTURE WORK

We have presented KYO, our client-side password generator.
KYO is easy to implement, efﬁcient to operate and provides a
unique set of beneﬁts that set it apart from the related work
of which we are aware. KYO offers short passwords, security
against unbounded adversaries and against client and multiple
server breaches while being backwards-compatible and ﬂexible
at the same time. The feature that we ﬁnd most compelling
is KYO’s use of non-cryptographic hash functions. KYO does
not rely on collision-resistance and rather beneﬁts from hash
functions that enable efﬁcient enumeration and intersection
of pre-image sets. We analyzed KYO mathematically and
empirically in order to provide evidence of its security, safety
and performance. However, its empirical analysis could be
pushed to larger security parameters if more beneﬁcial hash
functions can be identiﬁed. This might also enable a user to test
for her choices of passwords what the concrete security is that
they provide, rather than relying on average case guarantees,
as is common in many areas of cryptography.

ACKNOWLEDGMENTS

The ﬁrst author and the third author were supported by the

CONFINE [22] project while doing this research.

REFERENCES

[1] ANDERSON, R., AND LOMAS, T. Fortifying key negotiation schemes
with poorly chosen passwords. Electronics Letters 30, 13 (Jun 1994),
1040–1041.

[2] AVIV, A. J., GIBSON, K., MOSSOP, E., BLAZE, M., AND SMITH,
J. M. Smudge attacks on smartphone touch screens. In Proc. USENIX
Workshop on Offensive Technologies (2010), pp. 1–7.

[3] BERSON, T. A., LOMAS, M., AND GONG, L. Secure, keyed and
collisionful hash functions. Tech. Rep. SRI-CSL-94-08, Stanford
Research Institute (Menlo Park, CA US), 1994.

[4] BOJINOV, H., BURSZTEIN, E., BOYEN, X., AND BONEH, D. Kamou-
ﬂage: Loss-resistant password management. In Proc. of ESORICS’10
(2010).

12

[5] BONNEAU, J., AND PREIBUSCH, S. The password thicket: technical
and market failures in human authentication on the web. In Proc. WEIS
(2010).

[25] WEGMAN, M. N., AND CARTER, J. New hash functions and their use
in authentication and set equality. Journal of Computer and System
Sciences 22, 3 (1981), 265 – 279.

[6] CAPPOS, J. Polypasshash: Protecting passwords in the event of a

password ﬁle disclosure.

[7] DI CRESCENZO, G., LIPTON, R., AND WALFISH, S. Perfectly secure
In Proc. Third
password protocols in the bounded retrieval model.
Conference on Theory of Cryptography (2006), vol. 3876 of LNCS,
Springer-Verlag, pp. 225–244.

[8] ELLISON, C., HALL, C., MILBERT, R., AND SCHNEIER, B. Protecting
secret keys with personal entropy. Future Gener. Comput. Syst. 16, 4
(Feb. 2000), 311–318.

[9] FLORENCIO, D., AND HERLEY, C. A large-scale study of web password
habits. In Proceedings of the 16th International Conference on World
Wide Web (New York, NY, USA, 2007), WWW ’07, ACM, pp. 657–666.
[10] FLOR ˆENCIO, D., HERLEY, C., AND COSKUN, B. Do strong web
passwords accomplish anything? In Proceedings of the 2Nd USENIX
Workshop on Hot Topics in Security (Berkeley, CA, USA, 2007),
HOTSEC’07, USENIX Association, pp. 10:1–10:6.

[11] FRYKHOLM, N., AND JUELS, A. Error-tolerant password recovery.
In Proceedings of the 8th ACM Conference on Computer and Com-
munications Security (New York, NY, USA, 2001), CCS ’01, ACM,
pp. 1–9.

[12] GMBH, M.

imobilesitter —mobilesitter for iphone.

http://www.
mobilesitter.de/downloads/mobilesitter-kes-special-mobile-security.pdf.
[13] HALDERMAN, J. A., WATERS, B., AND FELTEN, E. W. A convenient
method for securely managing passwords. In Proceedings of the 14th
International Conference on World Wide Web (New York, NY, USA,
2005), WWW ’05, ACM, pp. 471–479.
JUELS, A., AND RIVEST, R. L. Honeywords: Making password-cracking
detectable. In Proceedings of the 2013 ACM SIGSAC Conference on
Computer &#38; Communications Security (New York, NY, USA, 2013),
CCS ’13, ACM, pp. 145–160.

[14]

[15] KALISKI, B. PKCS #5: Password-Based Cryptography Speciﬁcation

Version 2.0. RFC 2898 (Informational), September 2000.

[16] KONTAXIS, G., ATHANASOPOULOS, E., PORTOKALIDIS, G., AND
KEROMYTIS, A. D. Sauth: Protecting user accounts from password
database leaks. In Proc. CCS (2013), pp. 187–198.

[17] L’ECUYER, P. Tables of linear congruential generators of different sizes
and good lattice structure. Math. Comput. 68, 225 (Jan. 1999), 249–260.
[18] LEHMER, D. H. Mathematical methods in large-scale computing units.
In Proceedings 2nd Symposium on Large-Scale Digital Computing
Machinery (Cambridge, MA, 1951), Harvard University Press, pp. 141–
146.

[19] LOMAS, M., AND CHRISTIANSON, B. Remote booting in a hostile
world: to whom am i speaking? [computer security]. Computer 28, 1
(Jan 1995), 50–54.

[20] MANNAN, M., BARRERA, D., BROWN, C. D., LIE, D., AND VAN
OORSCHOT, P. C. Mercury: Recovering forgotten passwords using
personal devices. In Proceedings of the 15th International Conference
on Financial Cryptography and Data Security (Berlin, Heidelberg, 2012),
FC’11, Springer-Verlag, pp. 315–330.

[21] MEHLER, A., AND SKIENA, S. Improving usability through password-
corrective hashing. In Proceedings of the 13th International Conference
on String Processing and Information Retrieval (Berlin, Heidelberg,
2006), SPIRE’06, Springer-Verlag, pp. 193–204.

[22] CONFINE. Community networks testbed for the future internet. http:

//conﬁne-project.eu/, June 2013.

[23] ROSS, B., JACKSON, C., MIYAKE, N., BONEH, D., AND MITCHELL,
J. C. Stronger password authentication using browser extensions. In
Proceedings of the 14th Conference on USENIX Security Symposium -
Volume 14 (Berkeley, CA, USA, 2005), SSYM’05, USENIX Association,
pp. 2–2.

[24] SCHAUB, F., DEYHLE, R., AND WEBER, M. Password entry usability
and shoulder surﬁng susceptibility on different smartphone platforms.
In Proceedings of the 11th International Conference on Mobile and
Ubiquitous Multimedia (New York, NY, USA, 2012), MUM ’12, ACM,
pp. 13:1–13:10.

We now get for the number of passwords that map to γi

p :=

(2(cid:96))2n−1
(2(cid:96))2n = 2−(cid:96).
(cid:18)N

(cid:19)

APPENDIX

Before we start we recapitulate a well-known lemma that

we use throughout our proofs.
Lemma A1 (Number of functions). Let X1, X2 be non-empty
and disjoint sets and Y1, Y2 non-empty sets. Set X := ∪iXi,
Y := ∪iYi, and

F := {f : X → Y | ∧i ∀x ∈ Xi : f (x) ∈ Yi}.

Then it is | F |=| Y1 ||X1| · | Y2 ||X2|.

KYO properties:

Lemma A2. Let σ be a seed and γ a digest. Then the size of
F −1
σ (γ) is binomial distributed with average value 2n−(cid:96).

Proof: For a password ρ, what is the probability that it
is mapped to γ? There are in total (2(cid:96))2n−1 functions that do
map a given ρ to a given γ. So the probability to select such
a function is

Pr[| F −1

σ (γ) |= x] =

px(1 − p)N−x.

x

σ (γ) is binomial distributed with expected value 2n ·

So F −1
2−N·(cid:96) = 2n−(cid:96).
Lemma 1 (Password creation). If the password table PW
already contains N passwords, the number of random tries
to ﬁnd the (N + 1)-th password is geometric distributed with
average value (1 − N · 2−(cid:96))−1.

Proof: Given (σ1, γ1), . . . , (σN , γN ), what is the size of
(γi) | has
(γi)? We know from Lemma A2 that | F −1
σi

∪iF −1
average value 2−(cid:96). So we get on average

σi

| ∪N

i=1F −1

σi

(γi) |= N · 2n−(cid:96).

So the probability to successfully pick a suiting password at
random is

p := 1 − N · 2n−(cid:96)

2n

= 1 − N · 2−(cid:96).

The number of random tries to ﬁnd one password is then
given by the geometric distribution with probability p, and its
expected value is 1/p.
Lemma A3. Given a password ρ and secret γ, the number
of random tries to ﬁnd a seed σ that satisﬁes Fσi(ρ) = γ is
geometric distributed with average value 2(cid:96).

Proof: The probability to pick such a function in one try
is 2−(cid:96). Let X be a random variable that denotes the number
of tries until one is found. Then X is geometric distributed:

Pr[X ≤ x] = 1 −(cid:0)1 − 1/2(cid:96)(cid:1)x

.

The expected value of X is 2−(cid:96), so one must test 2(cid:96) different
seeds on average to ﬁnd one such seed.

13

Lemma 2 (Seed selection 1). For given N − 1 passwords, a
randomly chosen seed σ fulﬁls requirement 2 with probability
(1 − 2−(cid:96))N−1.

Proof: We count the number of functions that do not map
the passwords ρ1, . . . , ρN−1 to an arbitrary but ﬁxed digest.
From lemma A1 follows that there are

(2(cid:96) − 1)N−1 · (2(cid:96))2n−(N−1)

of them. Since there are (2(cid:96))2n functions in total, we get the
probability that a randomly chosen function fulﬁls requirement 2

(2(cid:96) − 1)N−1 · (2(cid:96))−(N−1) =

(2(cid:96) − 1)N−1
(2(cid:96))N−1

= (1 − 2−(cid:96))N−1.

Lemma 3 (Seed selection). Given a password ρ and shared
secrets γ1, . . . , γN , the number of random tries to ﬁnd seeds
σ1, . . . , σN that satisfy Fσi(ρ) = γi is geometric distributed
with average value N · 2(cid:96).

Proof: Follows by N repetitions from Lemma A3 .

Safety:

Lemma 4 (Safety). Let N be the number of pairwise distinct
wrongly entered passwords and let N be small compared to
2s. Then the safety of the KYO scheme is binomial distributed
with average value

1 − (1 − 2−(cid:96))N .

Proof: Let γ be the stored digest. There are (2(cid:96) − 1)

N ·
(2(cid:96))2n−N functions that do not map the passwords ρi to the
digest γ. We now ﬁnd, that

i=1Fσ(ρi) = ρ} =
i=1Fσ(ρi) (cid:54)= ρ}

Pr[{σ ∈ Ω : ∨N
=1 − Pr[{σ | ∧N
=1 − | {σ | ∀ρ ∈ {ρ1, . . . , ρN} : Fσ(ρ) (cid:54)= ρ} |
| S |
=1 − (2(cid:96) − 1)
N · (2(cid:96))2n−N
(2(cid:96))2n
=1 − (1 − 2−(cid:96))N .

= 1 − (2(cid:96) − 1)N · 2−(cid:96)N

If N is small compared to 2s, we can approximate this
experiment by drawing from an urn with replacement. The
probability is then binomial distributed with the average value
above.

Security:

Lemma 5 (Guessing secrets). Let C be a set of equally likely
candidate passwords and c := |C|. We deﬁne M := Fσ(C).
Then the probability

Pr[Γ = γ | Σ = σ ∧ ρ ∈ C]
is binomial distributed with the average value

(cid:0)2(cid:96) · (1 − (1 − 2−(cid:96))c)(cid:1)−1

for every γ ∈ M.

14

p :=

= 2−N·l

(cid:19)N

(cid:18) (2(cid:96))2n−1
(cid:19)
(cid:18)N

(2(cid:96))2n

m

Proof: In this proof, we consider F to be a random function.
Note that this does not contradict our deﬁnition of KYO families,
but instead provides an easier proof. We model this situation
by drawing balls from an urn with 2(cid:96) different colored balls
for c times.

For each secret γ, the probability that it is mapped onto by
at least one password in C is 1− (1− 2−(cid:96))c. So the size of M
is binomial distributed with average value 2(cid:96) · (1− (1− 2−(cid:96))c).
Let X denote a random variable that gives the number of
passwords that map to a given digest. Since F is a random
function, X too will be binomial distributed with average value
c · 2−(cid:96). So on average, each digest γ ∈ M will be equally
likely with probability 1/c.
Lemma 6. The size of M is binomial distributed with average
value

2n−N·(cid:96).

Proof: For a password ρ, what is the probability that it is
mapped to γi? There are in total (2(cid:96))2n−1 functions that do
map a given ρ to a given γi. If the σi are selected uniformly
at random and independent from each other, we get

as the probability that such a function was selected each time.
We get for the number of passwords M that map to γi

Pr[M = m] =

pm(1 − p)N−m,

i.e., M is binomial distributed and it’s expected value is

2n · 2−N·(cid:96) = 2n−N·(cid:96).

(1)

Theorem 1 (Guessing passwords). It is

Pr[R = ρ | ∧N

i=1(Σi = σi ∧ Γi = γi] =

(cid:40) 1|M|

0

ρ ∈ M
else.

with the size of M being binomial distributed with average
value 2n−N l.

Proof: For any ρi ∈ M, we get using Bayes’ theorem

=

i=1(Σi = σi ∧ Γi = γi] =
i=1(Σi = σi ∧ Γi = γi) | R = ρi] · Pr[R = ρ]

Pr[R = ρ | ∧N
Pr[∧N

(cid:80)
ρj∈M Pr[∧N
which simpliﬁes to
(cid:80)
Pr[Σi = σi ∧ Γi = γi | R = ρi]
ρj∈M Pr[Σi = σi ∧ Γi = γi | R = ρj]

i=1(Σi = σi ∧ Γi = γi) | R = ρj] · Pr[R = ρj],

=

1
| M | ,

(2)

since all passwords are initially equally likely and the terms

Pr[Σi = σi ∧ Γi = γi | R = ρi]

are all equal, given that (Fσ)σ∈S covers all functions mapping
P to L. The result follows now from Lemma 6.

