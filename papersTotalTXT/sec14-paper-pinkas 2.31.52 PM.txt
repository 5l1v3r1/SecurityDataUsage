Faster Private Set Intersection Based  

on OT Extension

Benny Pinkas, Bar-Ilan University; Thomas Schneider and Michael Zohner,  

Technische Universität Darmstadt

https://www.usenix.org/conference/usenixsecurity14/technical-sessions/presentation/pinkas

This paper is included in the Proceedings of the 23rd USENIX Security Symposium.August 20–22, 2014 • San Diego, CAISBN 978-1-931971-15-7Open access to the Proceedings of  the 23rd USENIX Security Symposium is sponsored by USENIXFaster Private Set Intersection based on OT Extension

Benny Pinkas

Thomas Schneider

Michael Zohner

Bar-Ilan University, Israel

TU Darmstadt, Germany

TU Darmstadt, Germany

Abstract

Private set intersection (PSI) allows two parties to com-
pute the intersection of their sets without revealing any
information about items that are not in the intersection.
It is one of the best studied applications of secure com-
putation and many PSI protocols have been proposed.
However, the variety of existing PSI protocols makes it
difﬁcult to identify the solution that performs best in a re-
spective scenario, especially since they were not all im-
plemented and compared in the same setting.

In this work, we give an overview on existing PSI pro-
tocols that are secure against semi-honest adversaries.
We take advantage of the most recent efﬁciency improve-
ments in OT extension to propose signiﬁcant optimiza-
tions to previous PSI protocols and to suggest a new PSI
protocol whose runtime is superior to that of existing pro-
tocols. We compare the performance of the protocols
both theoretically and experimentally, by implementing
all protocols on the same platform, and give recommen-
dations on which protocol to use in a particular setting.

1

Introduction

Private set intersection (PSI) allows two parties P1 and P2
holding sets X and Y , respectively, to identify the inter-
section X ∩ Y without revealing any information about
elements that are not in the intersection. The basic PSI
functionality can be used in applications where two par-
ties want to perform JOIN operations over database ta-
bles that they must keep private, e.g., private lists of
preferences, properties, or personal records of clients or
patients. PSI is used for privacy-preserving computa-
tion of functionalities such as relationship path discov-
ery in social networks [37], botnet detection [40], test-
ing of fully-sequenced human genomes [3], proximity
testing [43], or cheater detection in online games [10].
Another use case is measurement of the performance
of web ad campaigns, by comparing purchases by users
who were shown a speciﬁc ad to purchases of users who
were not shown the ad. This is essentially a variant of
PSI where the input of the web advertising party is the
identities of the users who were shown the ad, and the

input of the merchant, or of an agency that operates on
its behalf, is the identities of the buyers. It was published
that Facebook and Datalogix, a consumer data collection
company, perform this type of measurements.1 (The ar-
ticle indicates that they seem to be using the insecure
hash-based solution described in §1.1, but instead they
can use a properly secure PSI protocol while still being
reasonably efﬁcient.)

PSI has been a very active research ﬁeld, and there
have been many suggestions for PSI protocols. The large
number of proposed protocols makes it non-trivial to
perform comprehensive cross-evaluations. This is fur-
ther complicated by the fact that many protocol designs
have not been implemented and evaluated, were analyzed
under different assumptions and observations, and were
often optimized w.r.t. overall runtime while neglecting
other relevant factors such as communication.

In this paper, we give an overview on existing efﬁ-
cient PSI protocols, optimize the recently proposed PSI
protocols of [27] and [17], based on garbled circuits and
Bloom ﬁlters, respectively, and describe a new PSI pro-
tocol based on recent results in the area of efﬁcient OT
extensions [1, 35]. We compare both the theoretical and
empirical performance of all protocols on the same plat-
form and conclude with remarks on the protocols and
their suitability for different scenarios.

1.1 Classiﬁcation of PSI Protocols
A naive solution When confronted with the PSI prob-
lem, most novices come up with a solution where both
parties apply a cryptographic hash function to their in-
puts and then compare the resulting hashes. Although
this protocol is very efﬁcient, it is insecure if the input
domain is not large or does not have high entropy, since
one party could easily run a brute force attack that applies
the hash function to all items that are likely to be in the
input set and compare the results to the received hashes.
(When inputs to PSI have a high entropy, a protocol that
compares hashes of the inputs can be used [41].)

1https://www.eff.org/deeplinks/2012/09/deep-dive-facebook-and-datalogix-

whats-actually-getting-shared-and-how-you-can-opt

USENIX Association  

23rd USENIX Security Symposium  797

PSI is one of the best studied problems in secure
computation. Since its introduction, several techniques
have been used to realize PSI protocols. While the
ﬁrst PSI protocols were special-purpose solutions based
on public-key primitives, other solutions were based on
circuit-based generic techniques of secure computation,
that are mostly based on symmetric cryptography. A
recent development are PSI protocols that are based on
oblivious transfer (OT) alone, and combine the efﬁciency
of symmetric cryptographic primitives with special pur-
pose optimizations. Finally, we describe PSI protocols
that utilize a third party to achieve even better efﬁciency.

Public-Key-Based PSI A PSI protocol based on the
Difﬁe-Hellmann (DH) key agreement scheme was pre-
sented in [29] (related ideas were presented earlier
in [36]). This protocol is based on the commutative prop-
erties of the DH function and was used for private prefer-
ence matching, which allows two parties to verify if their
preferences match to some degree.

Freedman et al. [21] introduced PSI protocols se-
cure against semi-honest and malicious adversaries in the
standard model (rather than in the random oracle model
assumed in the DH-based protocol). This protocol was
based on polynomial interpolation, and was extended
in [19], which presents protocols with simulation-based
security against malicious adversaries, and evaluates the
practical efﬁciency of the proposed hashing schemes. We
discuss the proposed hashing schemes in §6. A similar
approach that uses oblivious pseudo-random functions to
perform PSI was presented in [20]. A protocol that uses
polynomial interpolation and differentiation for ﬁnding
intersections between multi-sets was presented in [34].

Another PSI protocol that uses public-key cryptogra-
phy (more speciﬁcally, blind-RSA operations) and scales
linearly in the number of elements was presented in [14]
and efﬁciently implemented and benchmarked in [15].

A PSI protocol based on additively homomorphic en-
cryption was described in [11], but is excluded from this
evaluation since it scales quadratically in the number of
elements and is hence slower than related solutions.

Circuit-Based PSI Generic secure computation proto-
cols have been subject to huge efﬁciency improvements
in the last decade. They allow the secure evaluation of
arbitrary functions, expressed as Arithmetic or Boolean
circuits. Several Boolean circuits for PSI were proposed
in [27] and evaluated using the Yao’s garbled circuits
framework of [28]. The authors showed that their Java
implementation scales very well with increasing secu-
rity parameter and outperforms the blind-RSA protocol

of [14] for larger security parameter.2 We reﬂect on and
present new optimizations for circuit-based PSI in §3.

OT-Based PSI A recent PSI protocol of [17] uses
Bloom ﬁlters [9] and OT extension [30] to obtain very
efﬁcient PSI protocols with security against semi-honest
and malicious adversaries. We describe this protocol and
our optimization using random OT extension [1] in §4.

Third Party-Based PSI Several PSI protocols have
been proposed that utilize additional parties, e.g., [4].
In [25], a trusted hardware token is used to evaluate an
oblivious pseudo-random function. This approach was
extended to multiple untrusted hardware tokens in [18].
Several efﬁcient server-aided protocol for PSI were pre-
sented and benchmarked in [32]. For their PSI protocol
with a semi-honest server, the authors report a runtime
of 1.7 s for server-aided PSI on one million elements us-
ing 20 threads between cloud instances in the US east
- and west coast and 10 MB of communicated data. In
comparison, our fastest PSI protocol without a server re-
quires 4.9 s for 218 elements using four threads and sends
78 MB (cf. Tab. 1 and Tab. 8). Note that this comparison
is sketchy and is only meant to demonstrate that using
a third party can increase performance. In our work we
focus on PSI protocols without a third party.

1.2 Our Contributions
We describe in detail the PSI protocols based on generic
secure computation and on Bloom ﬁlters, and suggest
how to improve their performance using carefully ana-
lyzed features of OT extension. We then introduce a new
OT-based PSI protocol, and perform a detailed experi-
mental comparison of all the PSI protocols that we de-
scribed. In the following, we detail our contributions.

Optimizations of Existing Protocols We improve the
circuit- and Bloom-ﬁlter-based PSI protocols using re-
cent optimizations for OT extension [1].
In particular,
in §3 we evaluate the circuit-based solution of [27] on a
secure evaluation of the GMW protocol, and utilize fea-
tures of random OT (cf. §2.2) to optimize the perfor-
mance of multiplexer gates (which form about two thirds
of the circuit). In §4.3 we redesign the Bloom ﬁlter-based
protocol of [17] to beneﬁt from using random OT and to
support multi-core environments.

2Subsequent work of [15] claimed that the blind-RSA protocol
of [14] runs faster than the circuit-based protocol of [27] even for larger
security parameter. Their implementation is in C++ instead of Java.

798  23rd USENIX Security Symposium 

USENIX Association

A Novel OT-Based PSI Protocol We present a new
PSI protocol that is directly based on OT (§5) and di-
rectly beneﬁts from recent improvements in efﬁcient OT
extensions [1, 35]. The basic version of the protocol can
efﬁciently compare one element with many elements,
but for PSI on n elements it requires O(n2 logn) com-
munication.
In §6 we use carefully analyzed hashing
techniques in order to achieve O(nlogn) communication.
The resulting protocol has very low computation com-
plexity since it mostly requires symmetric key operations
and has even less communication than some public-key-
based PSI protocols.

A Detailed Comparison of PSI Protocols We imple-
ment the most promising candidate PSI protocols us-
ing state-of-the-art cryptographic techniques and com-
pare their performance on the same platform. As far as
we know, this is the ﬁrst time that such a wide compar-
ison has been made, since previous comparisons were
either theoretical, compared implementations on differ-
ent platforms or programming languages, or used imple-
mentations without state-of-the-art optimizations. Our
implementations and experiments are described in detail
in §7. Certain experimental results were unexpected. We
give a partial summary of our results in Tab. 1: the values
in parenthesis give the overhead of the original protocols
and highlight the gains achieved by our optimizations.

PSI Protocol

Runtime (s)
Comm. (MB)

DH
ECC
[29]
416
24

Circuit [27]

optimized GMW §3.2
(original GMW [1])

762 (1,304)

14,040 (23,400)

Bloom Filter
optimized §4.3
(original [17])

68 (154)

740 (1,393)

OT
§5+§6

14
78

Table 1: Runtime and transferred data for private set in-
tersection protocols on sets with 218 32-bit elements and
128-bit security with a single thread over Gigabit LAN.

We highlight here the conclusions of our results:

• The Difﬁe-Hellman-based protocol [29], which was
the ﬁrst PSI protocol, is actually the most efﬁcient
communication (when implemented using
w.r.t.
elliptic-curve crypto). Therefore it is suitable for
settings with distant parties which have strong com-
putation capabilities but limited connectivity.

• Generic circuit-based protocols [27] are less efﬁ-
cient than the newer, OT-based constructions, but
they are more ﬂexible and can easily be adapted for
computing variants of the set intersection function-
ality (e.g., computing whether the size of the inter-
section exceeds some threshold). Our experiments
also support the claim of [27] that circuit-based PSI
protocols are faster than the blind-RSA-based PSI

protocol of [14] for larger security parameters and
given sufﬁcient bandwidth.

• While for larger security parameter previously pro-
posed circuit- and OT-based protocols can be faster
than the public-key-based protocols on a Gigabit
LAN, the DH-based protocol of [29] outperforms
all of them in an Internet network setting. Our new
OT-based protocol (§5+§6) is the only protocol that
maintains its performance advantage in this setting
and even outperforms public-key-based PSI proto-
cols for a mobile network setting.

2 Preliminaries

We give our notation and security deﬁnitions in §2.1 and
review recent relevant work on oblivious transfer in §2.2.

2.1 Notation and Security Deﬁnitions

We denote the parties as P1 and P2, and their respective
input sets as X and Y with |X| = n1 and |Y| = n2. When
the two input sets are of equal size, we use n = n1 = n2.
We refer to elements from X as x and elements from Y
as y and each element has bit-length σ (we detail the
relation between n and σ in the full version [47]).

We refer to a correlation resistant one-way function

We write b[i] for the i-th element of a list b, denote the
bitwise-AND between two bit strings a and b of equal
length as a∧ b and the bitwise-XOR as a⊕ b.
as CRF, and to a pseudo-random generator as PRG.
We write(cid:31)N

transfers on (cid:31)-bit strings, and write OTm

(cid:31) for m parallel 1-out-of-N oblivious

1(cid:30)-OTm

(cid:31) for(cid:31)2

1(cid:30)-OTm

(cid:31) .

Security parameters We denote the symmetric secu-
rity parameter as κ, the asymmetric security parameter
as ρ, the statistical security parameter as λ , and use the
recommended key sizes of the NIST guideline [45], sum-
marized in Tab. 2. We denote the bit size of elliptic curve
points with ϕ, i.e., ϕ = 284 for Koblitz curve K-283
when using point compression.

Security
80-bit
128-bit

SYM (κ)

FFC and IFC (ρ)

80
128

1,024
3,072

ECC (ϕ)
K-163
K-283

Hash
SHA-1
SHA-256

Table 2: NIST recommended key sizes for symmetric
cryptography (SYM), ﬁnite ﬁeld cryptography (FFC),
integer factorization cryptography (IFC), elliptic curve
cryptography (ECC) and hash functions.

USENIX Association  

23rd USENIX Security Symposium  799

Adversary deﬁnition The secure computation litera-
ture considers two types of adversaries with different
strengths: A semi-honest adversary tries to learn as much
information as possible from a given protocol execution
but is not able to deviate from the protocol steps. The
semi-honest adversary model is appropriate for scenarios
where software attestation is enforced or where an un-
trusted third party is able obtain the transcript of the pro-
tocol after its execution, either by stealing it or by legally
enforcing its disclosure. The stronger, malicious adver-
sary extends the semi-honest adversary by being able to
deviate arbitrarily from the protocol steps.

Most protocols for private set intersection, as well
as this work, focus on solutions that are secure against
semi-honest adversaries. PSI protocols for the mali-
cious setting exist, but they are considerably less ef-
ﬁcient than protocols for the semi-honest setting (see,
e.g., [13, 16, 19, 21, 26, 31]).

The random oracle model As most previous works on
efﬁcient PSI, we use the random oracle model to achieve
more efﬁcient implementations [8]. We provide details
and argue about the use of random oracles in the full ver-
sion [47].

2.2 Oblivious Transfer
Oblivious transfer (OT) is a major building block for
secure computation. When executing m invocations of
1-out-of-2 OT on (cid:31)-bit strings (denoted (cid:31)2
(cid:31) ), the
sender S holds m message pairs (xi
0,xi
1 ∈
{0,1}(cid:31), while the receiver R holds an m-bit choice vector
b. At the end of the protocol, R receives xi
b[i] but learns
nothing about xi
1−b[i], and S learns nothing about b. Many
OT protocols have been proposed, most notably (for the
semi-honest model) the Naor-Pinkas OT [42], which uses
public-key operations and has amortized complexity of
3m public-key operations when performing m OTs.

1(cid:30)-OTm

0,xi

1) with xi

OT extension [6, 30] reduces the number of expen-
(cid:31) to that of only OTκ
sive public-key operations for OTm
κ,
and computes the rest of the protocol using more efﬁcient
symmetric cryptographic operations which are orders of
magnitude faster. The security parameter κ is essentially
independent of the number of OTs m, and can be as small
as 80 or 128. Thereby, the computational complexity for
performing OT is reduced to such an extent, that the net-
work bandwidth becomes the main bottleneck [1].

Recently, the efﬁciency of OT extension protocols has
gained a lot of attention. In [35], an efﬁcient 1-out-of-
N OT extension protocol was shown, that has sub-linear
communication in κ for short messages. Another proto-
col improvement is outlined in [1, 35], which decreases
the communication from R to S by half. Additionally,

0,xi

several works [1,44] improve the efﬁciency of OT by us-
ing an OT variant, called random OT. In random OT,
(xi
1) are chosen uniformly and randomly within the
OT and are output to S, thereby removing the ﬁnal mes-
sage from S to R. Random OT is useful for many appli-
cations, and we show how it can reduce the overhead of
PSI. We elaborate on these OT extension protocols in the
full version [47].

3 Circuit-Based PSI

Unlike special purpose private set intersection protocols,
the protocols that we describe in this section are based
on a generic secure computation protocol that can be
used for computing arbitrary functionalities. State-of-
the-art for computing the PSI functionality is the sort-
compare-shufﬂe (SCS) circuit of [27], which has size
full version [47]for details.) We dis-
O(nlogn) (cf.
cuss these protocols by reﬂecting on the generic secure
computation protocol of Goldreich-Micali-Wigderson
(GMW) [23] (§3.1) and outlining major optimizations for
evaluating the SCS circuit for PSI using GMW (§3.2).
The usage of generic protocols holds the advantage
that the functionality of the protocol can easily be ex-
tended, without having to change the protocol or the
security of the resulting protocol. For example, it is
straightforward to change the protocol to compute the
size of the intersection, or a function that outputs 1 iff
the intersection is greater than some threshold, or com-
pute a summation of values (e.g., revenues) associated
with the items that are in the intersection. Computing
these variants using other PSI protocols is non-trivial.

3.1 The GMW Protocol
We focus on the GMW protocol [23] for generic secure
computation, which was implemented in the semi-honest
model for multiple parties in [12], optimized for two par-
ties in [49], and extended to the malicious model in [44].
The GMW protocol represents the function to be
computed as a Boolean circuit and uses an XOR-based
secret-sharing and OT to evaluate the circuit. A cir-
cuit with input bit u from P1 and v from P2 is evaluated
as follows. First, P1 and P2 secret-share their input bit
u = u1 ⊕ u2 and v = v1 ⊕ v2 and Pi obtains the shares
labeled with i. The parties then evaluate the Boolean cir-
cuit gate-by-gate, as detailed next. To evaluate an XOR
gate with input wires u and v and output wire w, P1 lo-
cally computes w1 = u1 ⊕ v1 while P2 locally computes
w2 = u2 ⊕ v2.

Evaluating AND gates using multiplication triples
An AND gate with input wire u and v and output wire w

800  23rd USENIX Security Symposium 

USENIX Association

requires an interaction between both parties using a mul-
tiplication triple [5]. A multiplication triple is a set
of shares α1,α2,β1,β2,γ1,γ2 ∈ {0,1} with (α1 ⊕ α2) ∧
(β1⊕β2) = γ1⊕γ2. Given a multiplication triple, to eval-
uate an AND gate implementing u AND v, the parties
compute di = αi ⊕ ui and ei = βi ⊕ vi, exchange di,ei, re-
construct d = d1 ⊕ d2 and e = e1 ⊕ e2, and compute the
shares of the gate output wire as w1 = (d∧e)⊕(d∧β1)⊕
(e∧ α1)⊕ γ1 and w2 = (d ∧ β2)⊕ (e∧ α2)⊕ γ2. These
are all extremely efﬁcient operations and therefore the
efﬁciency of the evaluation depends on the efﬁciency of
generating multiplication triples.

0,xi

1) and sets βi = xi

As described in [1], multiplication triples can be gen-
erated using two random OTs on one-bit strings as fol-
lows: both parties choose αi ∈R {0,1} and run two ran-
dom OTs, where in the ﬁrst OT P1 acts as sender and P2
as receiver with choice bit α2, and in the second OT P2
acts as sender and P1 as receiver with choice bit α1. From
each OT, the sender obtains (xi
0 ⊕ xi
1
and the receiver obtains xi
αi. To compute valid γ0,γ1
values for the triple, note that (α1 ⊕ α2) ∧ (β1 ⊕ β2) =
(α1 ∧ β1)⊕ (α1 ∧ β2)⊕ (α2 ∧ β1)⊕ (α2 ∧ β2) =γ 0 ⊕ γ1.
Pi locally computes αi ∧ βi. Values α1 ∧ β2 and α2 ∧ β1
are computed using the output of the random OT as
α1 ⊕x2
α1∧β2 = x2
0. Finally, P1 sets
γ1 = (α1∧β1)⊕x1
a1 and P2 sets γ2 = (α2∧β2)⊕x2
0⊕
x1
α2. These computations can be done in a preprocessing
step before the input is known, are independent of cir-
cuit’s structure, and highly parallelizable.

0 and α2∧β1 = x1
0⊕x2

α2 ⊕x1

3.2 Optimized Circuit-Based PSI
We describe in this section an optimization which greatly
reduces the overhead of circuit based PSI for GMW (as
is detailed in Tab. 5 in §7, the reduction in the runtime
for inputs of size 218 is about 40%). The optimization is
based on a protocol proposed in [39].

Approximately 2/3 of the AND gates in the SCS cir-
full version [47] for
cuit are due to multiplexers (cf.
In each multiplexer operation with σ-bit in-
details).
puts x and y and a choice bit s, we compute z[ j] =
s∧ (x[ j]⊕ y[ j])⊕ x[ j] for each 1 ≤ j ≤ σ using σ AND
gates in total. The evaluation of this multiplexer circuit
in the GMW protocol requires random OT2σ
1 , namely 2σ
random OTs of single-bit inputs. We observe that the
same wire s is input to multiple AND gates which allows
for the following optimization.

Consider an input wire u that is the input to multiple
AND gates of the form w[1] = (u AND v[1]), . . . ,w[σ ] =
(u AND v[σ ]). Similar to the evaluation of a single AND
gate described in §3.1, these gates can be evaluated using
a multiplication triple generalized to vectors, which we
call a vector multiplication triple.

A vector multiplication triple has the following form:

α1,α2 ∈ {0,1}; β1,β2,γ1,γ2 ∈ {0,1}σ , where Pi holds
the shares labeled with i that satisfy the condition (α1 ⊕
α2) ∧ (β1[ j] ⊕ β2[ j]) = γ1[ j] ⊕ γ2[ j]. To evaluate the
AND gates, both parties compute di = αi ⊕ ui and
ei[ j] =β i[ j] ⊕ vi[ j], exchange di,ei[ j], set d = d1 ⊕ d2,
e[ j] =e 1[ j]⊕ e2[ j], and wi[ j] = (d ∧ e[ j])⊕ (d ∧ βi[ j])⊕
(e[ j] ∧ αi) ⊕ γi[ j]. The vector multiplication triple can
be pre-computed analogously to the regular multiplica-
tion triples described in §3.1, but using random OT2
σ ,
namely only two random OTs applied to σ-bit strings:
The parties each choose α1,α2 ∈R {0,1} and perform
a random OT1
σ with P1 acting as sender and P2 acting
as receiver with choice bit α2, and a second random
OT1
σ with P2 acting as sender and P1 acting as receiver
with choice bit α1. From these random OTs, Pi obtains
βi ∈ {0,1}σ = xi
1 and, analogously to the regular
multiplication triple generation, a valid γi ∈ {0,1}σ .

0 ⊕ xi

Efﬁciency Overall, evaluating σ AND gates with a
vector multiplication triple requires to send 2σ + 2 bits
(instead of 4σ bits with σ regular multiplication triples).
Generating a vector multiplication triple requires 2 ran-
dom OTs on σ-bit strings (instead of 2σ random OTs
with σ regular multiplication triples); as the communi-
cation of random OT is independent of the input length,
this improves communication by factor σ.

In the SCS circuit we have 2nlog2 n +n +1 multiplex-
ers, each of which can be evaluated using a single vector
multiplication triple. This reduces the number of random
OTs from 2σ (2nlog2 n + n + 1) to 2(2nlog2 n + n + 1).

Further applications of vector multiplication triples
As a side note, we comment that our vector multipli-
cation triples can be used in every circuit where wires
are used as input in two or more AND gates. As such,
another beneﬁcial application is multiplication. When
computing a multiplication between two σ-bit numbers
x and y using the school method multiplication cir-
cuit [49], each bit xi is multiplied with every bit of y:
∀1≤i≤σ∀1≤ j≤σ (xi ∧ y j). Here, using vector multiplica-
tion triples allows to reduce the total number of random
OTs by a factor two, from 4σ 2 − 2σ OTs to 2σ 2.

4 Bloom Filter-Based PSI

The recent PSI protocol of [17] uses Bloom Filters (BF)
and OT to compute set intersection. We summarize
Bloom ﬁlters in §4.1 and the PSI protocol of [17] in §4.2.
We then present a redesigned optimized version of the
protocol in §4.3. This optimization reduces the runtime
for inputs of size 218 by 55%− 60% (cf. §7, Tab. 5).

USENIX Association  

23rd USENIX Security Symposium  801

m

p(cid:31) lnm−k ln p

4.1 The Bloom Filter
A BF that represents a set of n elements consists of an
m-bit string F and k independent uniform hash functions
h1, ...,hk with hi : {0,1}∗ (cid:28)→ [1,m], for 1 ≤ i ≤ k.
Ini-
tially, all bits in F are set to zero. An element x is in-
serted into the BF by setting F[hi(x)] = 1 for all i. To
query if the BF contains an item y, one checks all bits
F[hi(y)]. If there is at least one j such that BF[h j(y)] = 0,
then y is not in the BF. If, on the other hand, all bits
BF[hi(y)] are set to one, then y is in the BF except for
a false positive probability ε. An upper bound on ε
can be computed as ε = pk(1 +O( k
)), where
p = 1− (1− 1
m )kn. The authors of [17] propose to choose
the number of hash functions as k = 1/ε and the size of
the BF as m = kn/ln2 ≈ 1.44kn. In their experiments,
they set ε = 2−κ, resulting in k = κ and a ﬁlter of size
m ≈ 1.44κn.
4.2 Garbled Bloom Filter-Based PSI
For BF-based PSI, one cannot simply compute the bit-
wise AND of the BFs that represent each set, as this leaks
information (see [17] for details).
Instead, the authors
of [17] introduced a variant of the BF, called Garbled
Bloom Filter (GBF). Like a BF, a GBF G uses κ hash
functions h1, ...,hκ, but instead of single bits, it holds
shares of length (cid:28) at each position G[i], for 1 ≤ i ≤ m.
These shares are chosen uniformly at random, subject to
the constraint that for every element x contained in the
ﬁlter G it holds that(cid:30)κ
To represent a set X using a GBF G, all positions
of G are initially marked as unoccupied. Each element
x ∈ X is then inserted as follows. First, the insertion
algorithm tries to ﬁnd a hash function t ∈ [1...κ] such
that G[ht (x)] is unoccupied (the probability of not ﬁnd-
ing such a function is equal to the probability of a false
positive in the BF, which is negligible due to the choice
of parameters). All other unoccupied positions G[h j(x)]
are set to random (cid:28)-bit shares. Finally, G[ht (x)] is set

j=1 G[h j(x)] = x.

to G[ht (x)] = x ⊕(cid:29)(cid:30)κ
j=1, j(cid:21)=t G[h j(x)](cid:28) to obtain a valid
sharing of x. We emphasize that because existing shares
need to be re-used, the generation of the GBF cannot be
fully parallelized. (We describe below in §4.3 how the
protocol can be modiﬁed to enable a parallel execution.)
In the semi-honest secure PSI protocol of [17], P1 gen-
erates a m-bit GBF GX from its set X and P2 generates
a m-bit BF FY from its set Y . P1 and P2 then perform
OTm
(cid:28) , where for the i-th OT P1 acts as a sender with input
(0,GX [i]) and P2 acts as a receiver with choice bit FY [i].
Thereby, P2 obtains an intersection GBF G(X∧Y ), for
which G(X∧Y )[i] = 0 if FY [i] = 0 and G(X∧Y )[i] = GX [i] if
FY [i] = 1. P2 can check whether an element y is in the in-
tersection by checking whether(cid:30)k
?
= y.

i=1 G(X∧Y )[hi(y)]

(Note that P2 cannot perform this check for any value
which is not in its input set, since the probability that
it learns all GBF locations associated with that value is
equal to the probability of a false positive, which is neg-
ligible due to the choice of parameters.) The bit-length
of the shares in the GBF can be set to (cid:28) = λ .

4.3 Random GBF-Based PSI
We introduce an optimization of the GBF-based PSI pro-
tocol of [17], which we call the random Garbled Bloom
Filter protocol. The core idea is to have parties collabo-
ratively generate a random GBF. This is in contrast to the
original protocol where the GBF had to be of a speciﬁc
structure (i.e., have the XOR of the entries of x ∈ X be
x). The modiﬁed protocol can be based on random OT
extension (in fact, on a version of the protocol which is
even more efﬁcient than the original random OT exten-
sion). For each position in the ﬁlter, each party learns a
random value if the corresponding bit in its BF is 1. P1
then sends to P2 the XOR of the GBF values correspond-
ing to each of its inputs, and P2 compares these values to
the XOR of the GBF values of its own inputs.

We denote the primitive that enables this solution
an oblivious pseudo-random generator (OPRG), which
takes as inputs bits b1,b2 from each party, respectively,
generates a random string s, and outputs to Pt s if bt = 1
and nothing otherwise, for t ∈ {0,1}. Additionally, we
require that the parties remain oblivious to whether the
other party obtained s. A protocol for computing this
functionality is obtained by modifying the existing ran-
dom OT extension protocol of [1] as follows.

Recall that in random OT extension, S has no input in
0,xi
the i-th OT and outputs two values (xi
1), while R in-
puts a choice bit vector b and outputs xi
b[i]. Computation
of each of these values involves one evaluation of a hash
function H (cf. §2.2; the detailed random OT extension
protocol is summarized in the full version [47]). The new
functionality is obtained by having S ignore the xi
0 output
that it receives, and ignore also the xi
1 output if b1 = 0.
Similarly, R ignores its output if b2 = 0. The random OT
extension protocol thus becomes more efﬁcient, since the
parties can ignore parts of the computation.

Our resulting Bloom ﬁlter-based protocol works as
follows. First, P1 and P2 each generate a BF, FX and FY
respectively. They evaluate the OPRG with P1 being
the sender and P2 being the receiver, using the bits of
FX and FY as inputs, to obtain random GBFs GX and
GY with entries in {0,1}(cid:28). For each element x j in its
set X, P1 then computes mP1[ j] =(cid:30)κ
i=1 GX [hi(x j)], with
1 ≤ j ≤ n1. Finally, P1 sends all mP1 values in random
order to P2, which identiﬁes whether an element y in its
set is in the intersection by checking whether a j exists
such that mP1[ j] =(cid:30)κ

i=1 GY [hi(y)].

802  23rd USENIX Security Symposium 

USENIX Association

Correctness For each item in the intersection, P2 gets
from P1 the same XOR value that it computed from its
own GBF, and therefore identiﬁes that the item is in
the intersection. For any item which is not in the in-
tersection, it holds with overwhelming probability that
the XOR value computed by P2 is independent of the n1
values received from P1. The probability of a false posi-
tive identiﬁcation for that value is therefore n1 · 2−(cid:31). The
probability of a false positive identiﬁcation for any of the
values is n1n2 · 2−(cid:31). To achieve correctness with proba-
bility 1-2−λ , we therefore set (cid:31) = λ + log2 n1 + log2 n2.

Security The security of each party can be easily
proved using a simulation argument. P2’s security is ob-
vious, since the only information that P1 learns are the
random outputs of the random OT protocol, which are
independent of P2’s input and can be easily simulated
by P1. P1’s security is apparent from observing that the
information that P2 receives from P1 is composed of

• The XOR values that P2 computed for each item in

the intersection.

• The XOR values that P1 computed for its n1 −|X ∩
Y| items that are not in the intersection. These val-
ues are independent of P2’s BF unless one of these
items is a false-positive identiﬁcation in the ﬁlter,
which happens with negligible probability ε.

Optimization

Party

# Bits Sent

# calls to H

Original GBF-based PSI [17]

Random GBF-based PSI (§4.3)

P1
P2
P1
P2

2mλ
2mκ
n1(cid:31)
mκ

2m
m

m/2
m/2

Table 3: Communication and computation complexities
for Bloom-ﬁlter-based PSI of [17] and our optimiza-
(λ : statistical security parameter, κ: symmetric
tion.
security parameter, ni: number of elements of party Pi,
m ≈ 1.44κ max(n1,n2), (cid:31) = λ + log2 n1 + log2 n2).

5 Private Set Intersection via OT

We propose a new private set intersection protocol that
is based on the most efﬁcient OT extension techniques,
in particular the random OT functionality [1, 44] and the
efﬁcient 1-out-of-N OT of [35]. This PSI protocol scales
very efﬁciently with an increasing set size.

We ﬁrst describe the protocol for a private equality test
(PEQT) between two elements x and y (§5.1) and then
describe how to efﬁciently extend it for comparing y to
a set X = {x1, ...,xn} (§5.2). The resulting protocol can
then be simply extended to perform PSI between sets X
and Y by applying the parallel comparison protocol for
each element y ∈ Y (§5.3). The overhead of the protocol
can be greatly improved using hashing (§6).

Therefore, the information received from P1 can be easily
simulated by P2 given its legitimate output, i.e., X ∩Y .
Efﬁciency As shown in Tab. 3, our resulting random
GBF-based PSI protocol has less computation and com-
munication complexity than the original GBF protocol
in [17]. In terms of communication, in our new protocol,
P1 has to send the n1(cid:31)-bit vector mP1 and P2 has to send
mκ bits in the random OTs. (This is compared to 2mλ
bits and 2mκ bits sent in the original protocol. Later in
our experiments in §7 we show that the communication
is reduced by a factor between 1.9 and 3, cf. Tab. 6.)
is
The computation complexity of our protocol
HW(FX ) hash function evaluations for P1 and HW(FY )
hash function evaluations for P2, where HW(·) denotes
the Hamming weight. When the number of hash func-
tions k and the size of the BF m are chosen optimally, we
can approximate the average Hamming weight in a BF
using the probability that a single bit is set to 1, which is
1− (1− ( 1
A main advantage of our protocol is that it allows to
parallelize all operations: BFs can be generated in paral-
lel (bits in the BF are changed only from 0 to 1) and, most
importantly, the random GBF can also be constructed in
parallel, in contrast to the original GBF-based protocol.

2. Thus, HW(F) ≈ m
2 .

m ))kn ≈ 1

0,si
i=1 si

1(cid:30) OTσ

i=1 si

x = y iff mP1 = mP2.

The basic private equality test can be improved by us-

5.1 The Basic PEQT Protocol
In the most basic private equality test (PEQT) protocol,
P1 and P2 check whether their σ-bit elements x and y are
(cid:31) , where P2 uses
the bits of y as its choice vector. From each random OT,
P1 obtains two uniformly distributed and random (cid:31)-bit
1), and P2 obtains si
strings (si
y[i]. P1 then computes
x[i] (the XOR of the strings corresponding
to the binary representation of x) and sends it to P2. P2
y[i] and decides that

equal by engaging in random (cid:31)2
mP1 =(cid:29)σ
compares this value to mP2 =(cid:29)σ
ing a base-N representation of the inputs and a(cid:31)N
size N, and then engaging in random(cid:31)N
1(cid:30)-OTt
For this, P2 cuts its σ-bit element y into t blocks y[i]
of bitlength η each: y = y[1]|| . . .||y[t]; similarly, P1 in-
terprets x = x[1]|| . . .||x [t]. In the i-th random(cid:31)N
1(cid:30)-OT, P2
inputs y[i] as choice bits and P1 obtains N random and
uniformly distributed (cid:31)-bit strings (si
N−1); P2 ob-
tains si
x[i] to P2 who compares
it to mP2 =(cid:29)t
y[i] and decides that x = y iff mP1 = mP2.

in the protocol. Speciﬁcally, let N = 2η. P1 and P2 check
whether their σ-bit elements x and y are equal by repre-
senting them using t = σ /η letters from an alphabet of

y[i]. P1 sends mP1 =(cid:29)t

i=1 si

i=1 si

1(cid:30) OT

(cid:31).

0, ...,si

USENIX Association  

23rd USENIX Security Symposium  803

i=1 si

Correctness

If x = y then the choices that both parties
make for their sums are equal, i.e., mP1 =(cid:31)t
x[i] =
(cid:31)t
i=1 si
y[i] = mP2, and P2 successfully identiﬁes equality.
If x (cid:31)= y then the probability that mP1 = mP2 is 2−(cid:31). To
see that this is true, assume w.l.o.g. that the inputs dif-
fer in their last sub-string, i.e., x[t] (cid:31)= y[t]. Equality only
holds if the last element received by P2, namely st
y[t], is
equal to(cid:31)t
y[t] is inde-
pendent of the other values, and therefore this equality
happens with probability 2−(cid:31) and thus we can set (cid:31) to be
equal to the statistical security parameter λ .

x[i] ⊕(cid:31)t−1

y[i]. The value of st

i=1 si

i=1 si

Security P2’s security is obvious, since the only infor-
mation that P1 learns are the random values chosen in the
random OT, which are independent of P2’s input.

As for P1’s security, note that P2’s view in the protocol

1(cid:29)-OT protocols,

consists of its t outputs in the random(cid:30)N

and of the value mP1 sent by P1. If x = y then mP1 is equal
to the XOR of the ﬁrst t values. Otherwise, all t + 1 val-
ues are uniformly distributed. In both cases, the view of
P2 can be easily simulated given the output of the pro-
tocol (i.e., knowledge whether x = y). The protocol is
therefore secure according to the common security deﬁ-
nitions of secure computation [22].

Efﬁciency Since in the i-th random OT P1 needs only
the output si
x[i], it sufﬁces to evaluate one hash function

sion protocol3 of [1] and (cid:31) = λ , the parties perform ran-
dom OTσ
λ , send σκ + λ bits, and do σ hash function
evaluations each. In comparison, when using the random

per random OT. When using the random(cid:30)2
1(cid:29)-OT exten-
(cid:30)N
1(cid:29)-OT extension protocol of [35], the parties perform

only σ /η OTs and send 2κ bits per OT; in total, they
have to send 2σκ/η + λ bits and do σ /η hash function
evaluations each. In the full version [47] we provide an
analysis which shows that setting η = 8 results in opti-
mal performance for our PSI protocols.

5.2 Private Set Inclusion Protocol
In a private set inclusion protocol, P1 and P2 check
whether y equals any of the values in X = {x1, ...,xn1}.
The set inclusion protocol is similar to the basic PEQT
protocol, but in order to perform multiple comparisons
in parallel, the OTs are computed over longer strings,
essentially transferring (in parallel) a random string for
each element in the set X.

n1(cid:31),
where P2 uses the bits of y as choice bits. Each received

In more detail, both parties run a random(cid:30)N

1(cid:29)-OTt

3Note that for σ < κ we can perform σ base-OTs instead of using
OT extension. However, here we analyze the costs when using OT
extension for simplicity and consistency reasons.

0, ...,si

string is of length n1(cid:31) bits. That is, in the i-th random OT,
N−1) ∈ {0,1}n1(cid:31),
P1 obtains N random strings (si
and P2 obtains one random string si
y[i]. The strings are
parsed as a list of n1 sub-strings of length (cid:31) bits each.
We refer to the j-th sub-string in these lists as si
w[ j], for
1 ≤ j ≤ n1 and 0 ≤ w < N. Using these sub-strings, P1
and P2 can then compute the XOR of the strings corre-
sponding to their respective inputs, compare the results
and decide on equality, as was described in the basic
PEQT protocol in §5.1.
In more detail, P1 computes
mP1[ j] =(cid:31)t
x j[i][ j] and sends the n1(cid:31)-bit string mP1 to
P2. P2 decides whether y matches any of the elements in
X by computing mP2 =(cid:31)t
y[i] and checking whether
Correctness and security follow from the properties of
the protocol of §5.1. However, now we require that the
value mP2 and all the n1 values mP1[ j] are distinct, which
happens with probability n12−(cid:31). Thus, to achieve cor-
rectness with probability 1-2−λ , we must increase the
bit-length of the OTs to (cid:31) = λ + log2 n1. Also, note
that P2 learns the position j at which the match is found,
which can be avoided by randomly permuting the inputs.

a j exists with mP1[ j] = mP2.

i=1 si

i=1 si

Efﬁciency The set inclusion protocol that compares y
to many values has the same number of random OTs
as the basic comparison protocol comparing y to a sin-
gle value, but it requires the transferred strings to be of
length n1(λ +log2(n1)) bits instead of λ bits. Note, how-
ever, that since we use random OTs there is no need to
send these strings in the OT protocol. Instead, all strings
corresponding to the same value of the same input bit can
be generated from a single seed using a pseudo-random
generator. Therefore, the amount of data transferred in
the OTs is the same as for the single comparison PEQT
protocol.

The only additional data that is sent is the n1(λ +
log2 n1)-bit string mP1, which P1 sends to P2. Hence,
the total amount of communication is 2σκ/η + n1(λ +
log2 n1) bits.

In addition, the PRG which is used to generate the out-
put string from the OT must be evaluated multiple times
to generate the n1(λ + log2 n1) bits. Therefore, the set
inclusion protocol, which compares y to n1 elements, is
less efﬁcient than a single run of the PEQT protocol,
but is deﬁnitely more efﬁcient than n1 invocations of the
PEQT protocol.

5.3 The OT-Based PSI Protocol
To obtain the ﬁnal PSI protocol that computes X ∩Y , P2
simply invokes the private set inclusion protocol of §5.2
for each y ∈ Y . Correctness and security follow from the
properties of the private set inclusion protocol.

804  23rd USENIX Security Symposium 

USENIX Association

Efﬁciency Overall,
to compute the intersection be-
tween sets X and Y of σ-bit elements, the protocol re-

1(cid:30)-OTs of n1(λ + log2 n1) bit-
1(cid:30)-OT of [35],

quires n2σ /η random (cid:31)N
strings and additionally n1n2(λ + log2 n1) bits to be sent.
Using the random (cid:31)N
the total amount
of communication is 2n2σκ/η + n1n2(λ + log2 n1) bits.
For large n1 and n2, this amount of communication grows
too large for an efﬁcient solution. In order to cope with
large sets, one can use a hashing scheme, as shown in §6.

6 Hashing Schemes and PSI

Several private set intersection protocols are based on
running many invocations of pairwise private equality
tests (PEQT). These protocols include [11, 21, 27] or our
set inclusion protocol in §5. A straightforward imple-
mentation of these protocols requires n2 invocations of
PEQT for sets of size n, and therefore does not scale well.
In [19, 21] it was proposed to use hashing schemes to re-
duce the number of comparisons that have to be com-
puted. The idea is to have each party use a publicly
known random hashing scheme to map its input elements
to a set of bins. If an input element is in the intersection,
both parties map it to the same bin. Therefore, the pro-
tocol can check for intersections only between items that
were mapped to the same bin by both parties.

Naively, if n items are mapped to n bins then the av-
erage number of items in a bin is O(1), checking for an
intersection in a bin takes O(1) work, and the total over-
head is O(n). However, privacy requires that the par-
ties hide from each other how many of their inputs were
mapped to each bin.4 As a result, we must calculate in
advance the number of items that will be mapped to the
most populated bin (w.h.p.), and then set all bins to be of
that size. (This can be done by storing dummy items in
bins which are not fully occupied.) This change hides the
bin sizes but also increases the overhead of the protocol,
since the number of comparisons per bin now depends
on the size of the most populated bin rather than on the
actual number of items in the bin. However, while the
parties need to pretend externally that all their items are
real, they do not need to apply all their internal compu-
tations to their dummy items (since they know that these
items are not in the intersection). A careful implementa-
tion of this observation, which takes into account timing
attacks, can further optimize the computation complexity
of the underlying protocols.

The work of [19, 21] gave asymptotic values for the
bin sizes that are used with this technique, and of the

4Otherwise, and since the hash function is public, some information
is leaked about the input. For example, if no items of P1 were mapped
to the ﬁrst bin by the hash function h, then P2 learns that P1 has no
inputs in the set h−1(1), which covers about 1/n of the input range.

resulting overhead. They left the task of setting ap-
propriate parameters for the hashing schemes to future
work. We revisit the hashing schemes that were outlined
in [19,21], namely, simple hashing, balanced allocations,
and Cuckoo hashing (§6.1). We evaluate the performance
when using hashing schemes for PSI (§6.2), and describe
an analysis of the involved parameters (§6.3). We con-
clude that Cuckoo hashing yields the best performance
(for parameters which we ﬁnd to be most reasonable).

6.1 Hashing Schemes
Simple Hashing
In the simplest hashing scheme the
hash table consists of b bins B1...Bb. Hashing is done
by mapping each input element e to a bin Bh(e) using a
hash function h : {0,1}σ (cid:27)→ [1,b] that was chosen uni-
formly at random and independently of the input ele-
ments. An element is always added to the bin to which it
is mapped, regardless of whether other elements are al-
ready stored in that bin. Estimating the maximum num-
ber of elements that are mapped to any bin, denoted
maxb, is a non-trivial problem and has been subject to ex-
tensive research [24, 38, 48]. When hashing m elements
to b = m bins, [24] showed that maxb = lnm
lnlnm (1 + o(1))
w.h.p. In this case, there is a difference between the ex-
pected and the maximum number of elements mapped
to a bin, which are 1 and O( lnm
lnlnm ), respectively. When
decreasing the number of bins to a value b satisfying
c·blnb = m for some constant c, it was shown in [48] that
maxb = (dc − 1 + α)lnb, where dc is the largest solution
to f (x) = 1 + x(lnc − lnx + 1) − c = 0, and α is a pa-
rameter for adjusting the conservativeness of the approx-
imation, and should be set to be slightly larger than 1. In
this case the expected and maximum number of elements
mapped to a bin are of the same order O(lnb) ≈ O(lnm).
This is preferable for our purposes, since even though
privacy requires that we set each bin to be as large as the
most populated bin, this size is of the same order as the
expected size of a bin when no privacy is needed.

Balanced Allocations The balanced allocations hash-
ing scheme [2] uses two uniformly random hash func-
tions h1,h2 : {0,1}σ (cid:27)→ [1,m]. An element e is mapped
by checking which of the two bins Bh1(e) and Bh2(e) is
less occupied, and mapping the element to that bin. A
lookup for an element q is then performed by checking
both bins, Bh1(q) and Bh2(q), and comparing the elements
in these bins to q. The advantage of this scheme, shown
in [2], is that when hashing m elements into b = m bins,
maxb is only lnlnm
ln2 (1 + o(1)), i.e., exponentially smaller
than in simple hashing.

USENIX Association  

23rd USENIX Security Symposium  805

Cuckoo Hashing Similar to balanced allocations hash-
ing, Cuckoo hashing [46] uses two hash functions h1,h2 :
{0,1}σ (cid:29)→ [1,b] to map m elements to b = 2(1 + ε)m
bins. The scheme avoids collisions by relocating el-
ements when a collision is found using the following
procedure: An element e is inserted into a bin Bh1(e).
Any prior contents o of Bh1(e) are evicted to a new bin
Bhi(o), using hi to determine the new bin location, where
hi(o) (cid:27)= h1(e) for i ∈ {1,2}. The procedure is repeated
until no more evictions are necessary, or until a thresh-
old number of relocations been performed. In the latter
case, the last element is put in a special stash s. It was
shown that for a stash of size s ≤ lnm, insertion of m el-
ements fails with probability m−s [33]. A lookup in this
scheme is very efﬁcient as it only compares e to the two
items in Bh1(e) and Bh2(e) and to the s items in the stash.
In exchange for the improved lookup overhead, the size
of the hash table is increased to about 2m bins.

6.2 Evaluation of Hashing-Based PSI
We evaluate the asymptotic overhead of applying the OT-
based PSI protocol that was introduced in §5.3 while us-
ing any of the hashing scheme that we described. Also
note that P1 can save communication since instead of
sending all masks for each bin (including masks for both
dummy and real values), it can send only the masks of
its real values (in permuted order, so that P2 does not
know which value was in each bin). P2 can then simply
check every mask received from P1 against every com-
puted mask. However, in this case the bit-length (cid:30) of the
masks has to be increased to (cid:30)(cid:22) = λ + log2 n1 + log2 n2,
since P2 has to perform a total of n1n2 comparisons and
the overall error probability must be at most 2−λ . In the
following, we address the mask length for checking one
item against a set of n1 items as (cid:30)1 = λ + log2 n1 and
the mask length for checking a set of n2 items against n1
items as (cid:30)2 = λ + log2 n1 + log2 n2.

PSI based on simple hashing A protocol based on
simple hashing allocates the n inputs of P2 to b bins,
such that n = O(blnb) and b is approximately O(n/lnn).
Each bin is padded with dummy items to contain the
maximum number of items that is expected in a bin,
which is O(lnb) = O(lnn). For each bin, the parties
need to compute the intersection between sets of O(lnn)
items. Each item can be represented using O(lnlnn)
bits.5 The protocol requires O(lnnlnlnn) random OTs
for each bin. The total number of OTs is therefore
O(nlnlnn). The length of the values transferred in the
OTs (the masks) is (cid:30)2 lnn bits.

5This holds since the items in a bin can be hashed to a shorter rep-
resentation, as long as no collisions occurs. The length of the hashed
value should be about λ + log((lnn)2) =O(lnln n).

PSI based on balanced allocations A major problem
occurs when using balanced allocations hashing for PSI:
every item can be mapped to one of two bins, and there-
fore it is unclear with which of P1’s bin should P2 com-
pare its own input elements e. Furthermore, the protocol
must hide from each party the choice of bins made by the
other party to store e, since that choice depends on other
input elements and might reveal information about them.
The solution to this is to use balanced allocations by P2
alone, whereas P1 maps each of its input elements to two
bins using simple hashing with both hash functions h1
and h2. When using b = n bins, P2 has O(lnlnn) items
in each bin, whereas P1 has O(lnn/lnlnn) items in every
bin (actually, it has twice as many items as with simple
hashing, since it maps each item twice). The items can
be represented using strings of O(lnlnn) bits. The pro-
tocol continues as before. P2 learns the output, but since
P1 does not use balanced allocations, P1 does not learn
P2’s choices in that hashing scheme. The number of OTs
is linear in the number of items stored by P2 multiplied
by the representation length, e.g., O(n· (lnlnn)2) OTs on
(cid:30)2 lnn/lnlnn bit strings. This overhead is larger than that
of the simple hashing-based scheme.

PSI based on Cuckoo hashing Designing PSI based
on Cuckoo hashing encounters the same privacy problem
as when using balanced allocations hashing, and there-
fore the same solution is used. P2 uses Cuckoo hashing
whereas P1 maps each of its elements using simple hash-
ing with each of the two hash functions. P2 maps a sin-
gle item to each of the 2n bins, whereas P1’s bins contain
O(lnn) items. In addition, P2 has a stash of s ≤ lnn el-
ements. Each of these elements must be compared with
each of P1’s n elements. An item in a bin can again be
represented using O(lnlnn) bits, whereas an item in the
stash can be represented using O(lnn) bits. Furthermore,
when checking items in the stash, we check one item
against n1, allowing us to reduce the bit-size of the masks
in the OTs to (cid:30)1 instead of (cid:30)2. The protocol therefore per-
forms O(nlnlnn) OTs on inputs of length O((cid:30)2 lnlnn)
bits (for the items in the bins), and in addition O((lnn)2)
OTs of inputs of length O((cid:30)1 lnn) bits (for the items in
the stash, which are each compared to all items of P1’s
input). Overall, the protocol has the same asymptotic
overhead as the protocol that uses simple hashing.

6.3 Maximum Bin Size and Overhead
When using hashing schemes for private set intersection,
the number of bins b and the corresponding maximum
bin size maxb must be set to values that balance efﬁciency
and security. If maxb is chosen too small, the probability
of a party failing to perform the mapping, denoted Pfail,
increases. As a result, the output might be inaccurate

806  23rd USENIX Security Symposium 

USENIX Association

Parameter

Total # OTs

No hashing
Simple Hashing
Balanced Alloc.
Cuckoo Hashing

nt

3.7nt

2.9nt(lnlnn)
(2(1 + ε)n + s)t

Comm. [bits]

P1 to P2

n2(cid:31)1
n(cid:31)2
2n(cid:31)2

sn(cid:31)1 + 2n(cid:31)2

Comm. [MB]
total, n = 218

458,880 / 458,784

476 / 121
1,298 / 595
319 / 89

Table 4: Number of OTs and communication for the
different hashing-based protocols. The total communi-
cation given in the last column is calculated for (cid:31)1 =
λ + log2 n, (cid:31)2 = λ + 2log2 n, κ = 128, λ = 40, ε = 0.2,
s = 4. The ﬁrst value in this column is for t = σ = 32

(cid:31)2
1(cid:30)-OTs per element and the second value is for t = 32/8
1(cid:30)-OTs, N = 28. It is composed of the total number of
(cid:31)N

OTs in the 2nd column times the communication per OT
plus the communication from P1 to P2 in the 3rd column.

(since not all items can be mapped to bins), or one of the
parties needs to request a new hash function (a request
that leaks information about the input set of that party).
On the other hand, the number of performed comparisons
increases with b and maxb. An asymptotic analysis of the
maximum bin size was presented in [19, 21], but leaves
the exact choice of b and maxb and the resulting Pfail to
further work. In the following, we analyze the complex-
ity of the hashing schemes when used in combination
with our set inclusion protocol, described in §5. To com-
pare the performance of the hashing schemes on a uniﬁed
base, we depict in Tab. 4 the overall communication, di-
vided into the number of OTs (where we run t OTs per
element) and the number of bits sent from P1 to P2.

In the full version [47]we detail the analysis of setting
the optimal parameters for usage of the different hashing
schemes in our PSI protocol, and of the resulting number
of OTs and communication overhead. The results are
depicted in Tab. 4 and show that Cuckoo hashing has the
lowest communication.
In addition, this scheme has a
stronger guarantee on the upper bound of Pfail, since we
achieve rehash probability of n−s. We therefore use this
scheme in our implementation and experiments.

A note on approximations When using a hashing
scheme with ﬁxed bin sizes it is possible that the number
of items mapped to a certain bin, say by P1, is larger than
the capacity of the bin. (This event happens with prob-
ability Pfail.) In such a case it is possible for P1 to ask
to use a new hash function. This request reveals some
information about P1’s input. Another option is for P1
to ignore the missed item, and therefore essentially com-
pute an approximation to the intersection. This choice,
too, might reveal information about P1’s input, albeit in
a more subtle way through multiple invocations of the
functionality. Similarly, in the Bloom ﬁlter-based proto-

col, the occurrence of a false positive might leak infor-
mation. The best solution to this issue is to make sure
that the probability of these events happening is negligi-
ble, so that it is almost certain that these events will not
occur in practice. This is the approach that we take in
our comparisons. (Another approach would be to allow
the computation of an approximation of the original in-
tersection function, while analyzing the privacy leakage
effects of this computation, and deciding whether to tol-
erate them. The result might be a more liberal choice of
parameters which will result in a more efﬁcient imple-
mentation of the original protocol.)

7 Experimental Evaluation

In the following we experimentally evaluate the PSI pro-
tocols described before. We describe our benchmarking
environment in §7.1 and then detail the comparison be-
tween the protocols in §7.2. Tab. 5 compares the single-
threaded runtimes of all protocols over Gigabit LAN,
Tab. 6 compares the communication complexities, and
Tab. 7 compares the single-threaded runtimes on differ-
ent networks. In the tables we highlight the protocol with
lowest runtime and communication for each type.

7.1 Benchmarking Environment
We ran our experiments on two Intel Core2Quad desk-
top PCs (without AES-NI extension) with 4 GB RAM,
connected via Gigabit LAN. In each experiment, P1 and
P2 held the same number of input elements n and were
not allowed to perform any pre-computation. We set
n as in [17], i.e., n ∈ {210,212,214,216,218}, but omit-
ted n = 220, since many implementations exceeded the
available main memory. We use σ = 32 as the bit
length of the elements.6 We use a statistical security
parameter λ = 40 and a symmetric security parameter
κ ∈ {80,128} (other security parameters are chosen ac-
cording to Tab. 2). For our set-inclusion protocol we set
η = 8, i.e., use 1-out-of-28 OT extensions.

In our tables, the asymptotic performance is given for
the party with the majority of the workload, and are
divided to public-key operations (asym) and symmetric
cryptographic operations (sym).

Implementations The implementation of the blind-
RSA-based [14] and garbled Bloom-Filter [17] proto-
cols were taken from the authors, but we used a hash-
table to compute the last step in the blind-RSA proto-
col that ﬁnds the intersection (the original implemen-

6For protocols whose complexity depends on σ, elements from
full ver-

a large domain can be hashed to short representations; cf.
sion [47] for details.

USENIX Association  

23rd USENIX Security Symposium  807

tation used pairwise comparisons with quadratic run-
time overhead). We implemented a state-of-the-art Yao’s
garbled circuits protocol (using garbled-row-reduction,
point-and-permute, free-XOR, and pipelining, cf [28])
by building on the C++ implementation of [12] and using
the ﬁxed-key garbling scheme of [7]7. For Yao’s garbled
circuits protocol, we evaluated a size-optimized version
of the sort-compare-shufﬂe circuit (comparison circuits
of size and depth σ) while for GMW we evaluated a
depth-optimized version (comparison circuits of size 3σ
and depth log2 σ) for σ-bit input values [49].

We implemented FFC (ﬁnite ﬁeld cryptography) and
IFC (integer factorization cryptography) using the GMP
library (v. 5.1.2), ECC using the Miracl library (v. 5.6.1),
symmetric cryptographic primitives using OpenSSL (v.
1.0.1e), and used the OT extension implementation of [1]
which requires about 3 symmetric cryptographic opera-
tions per OT for the asymptotic performance analysis.

We argue that we provide a fair comparison, since all
protocols are implemented in the same programming lan-
guage (C/C++), run on the same hardware, and use the
same underlying libraries for cryptographic operations.
For each protocol we measured the time from starting
the program until the client outputs the intersecting ele-
ments. All runtimes are averaged over 10 executions.

7.2 Performance Comparison
We divide the performance comparison into three cate-
gories, depending on whether the protocol is based on
public-key operations, circuits, or OT. Afterwards, we
provide experiments for different networks and give a
comparison between the best protocols in each category.

Public-Key-Based PSI For the public-key-based PSI
protocols, we observe that the DH-based protocol of [29]
outperforms the RSA-based protocol of [14] when using
ﬁnite ﬁeld cryptography (FFC). Similarly to [1], we also
obtain the somewhat surprising result that for 80-bit se-
curity elliptic curve cryptography (ECC) using the Mir-
acl library is slower than FFC using the GMP library. For
larger security parameters, however, ECC becomes more
efﬁcient and outperforms FFC by a factor of 3 for 128-bit
security for the DH-based protocol. (The reason for this
phenomenon might be better implementation optimiza-
tions in the GMP library.) The advantage of the ECC-
based protocol is its communication complexity, which is
lowest among all PSI protocols, cf. Tab. 6. We note that
a major advantage of these protocols is their simplicity,
which makes them comparably easy to implement.

7The security of the ﬁxed-key garbling scheme is somewhat contro-

versial but we included it for performance reasons.

Circuit-Based PSI Here we tested Yao- and GMW-
based implementations, as well as an implementation of
our optimized vector multiplication-triple-based GMW
protocol (§3.2). Following is a summary of the results:
• Both the computation complexity and the communi-
cation complexity of the circuit-based PSI protocols
are the highest among all protocols that we tested.
• The basic GMW protocol has the highest overall

runtime and communication complexity.

• Our vector multiplication triple optimization re-
duces the runtime and communication of GMW
For security parameter
by approximately 40%.
κ = 80, this implementation is slightly faster than
Yao’s protocol, but it is slightly slower for κ =
128. Communication-wise, the vector multiplica-
tion triple GMW is more efﬁcient than Yao’s proto-
col.

• The runtime of Yao’s protocol hardly increases with
the security parameter, since we use AES-128 for
both versions. Note, however, that our implemen-
tation of Yao’s protocol exceeded the main memory
when processing 218 elements.

• Our Yao implementation does not use the AES-NI
hardware support. Using AES-NI is likely to im-
prove the runtime of the Yao implementation.

We give a more detailed performance comparison for
GMW and Yao’s protocol in the full version [47].

OT-Based PSI The random garbled Bloom ﬁlter pro-
tocol of §4.3 improves the original garbled Bloom ﬁlter
protocol of [17] by more than a factor of two in runtime
and by factor of 2-3 in communication.

We also implemented our protocol of §5, where we
used Cuckoo hashing with parameters ε = 0.2 and s = 4,
cf. §6. This protocol had the best runtime, and was about
5 times faster than the random garbled Bloom ﬁlter pro-
tocol for κ = 128. In terms of communication, our set
inclusion protocol uses less than 20% of the communi-
cation of the random garbled Bloom ﬁlter protocol for
κ = 80 and less than 10% communication for κ = 128.
The main difference between the set inclusion protocol
and the random garbled Bloom ﬁlter protocol is the de-
pendency of the performance on the symmetric security
parameter κ. In the random garbled Bloom ﬁlter proto-
col, the number of OTs is independent of the bit-length σ
but scales linearly with κ. On the other hand, the number
of OTs for the set inclusion protocol is independent of κ
but linear in σ. As a result, the runtime of the Bloom
ﬁlter protocol (but not of the set inclusion protocol) is
greatly affected when κ is increased.

808  23rd USENIX Security Symposium 

USENIX Association

Type

Symm. Security Parameter κ
Set Size n

Public-Key

Circuit [27]

OT

DH-based FFC [29]
DH-based ECC [29]
RSA-based [14]

Yao [7,28]
GMW [1]
Vector-MT GMW §3.2
Garbled Bloom Filter [17]
Random Garbled Bloom Filter §4.3
Set Inclusion §5 + Hashing §6

210

0.4
0.7
0.5

1.2
1.9
1.2

0.3
0.15
0.13

212

1.6
2.8
2.0

5.7
8.6
5.1

0.9
0.5
0.2

80-bit
214

6.2
11.0
7.9

27.7
35.2
21.2

3.9
2.0
0.8

216

24.7
44.1
31.3

128.2
161.9
100.3

16.1
8.1
3.3

218

98.8
177.5
124.9

-

806.5
462.7

71.9
34.3
13.5

210

4.8
1.6
7.7

1.6
2.6
1.9

0.6
0.27
0.26

212

19.1
6.5
31.0

6.3
12.8
7.8

2.0
1.0
0.3

128-bit
214

76.5
26.1
124.3

28.4
58.9
36.5

8.5
4.1
0.9

216

306.0
104.2
497.2

129.1
276.4
168.9

37.1
16.7
3.7

218

1,224.1
416.2
1,982.1

-

1,304.2
762.4

154.4
67.6
13.8

Asymptotic

2n asym
2n asym
2n asym

12nσ log2 n sym
30nσ log2 n sym
18nσ log2 n sym

4.32nκ sym
3.6nκ sym
0.75nσ sym

Table 5: Runtimes in seconds for PSI protocols with one thread over Gigabit LAN (σ = 32: bit size of set elements,
asym: public-key operations, sym: symmetric cryptographic operations).

Type

Symm. Security Parameter κ
Set Size n

Public-Key

Circuit [27]

OT

DH-based FFC [29]
DH-based ECC [29]
RSA-based [14]

Yao [7, 28]
GMW [1]
Vector-MT GMW §3.2
Garbled Bloom Filter [17]
Random GBF §4.3
Set Inclusion §5 + Hashing §6

210

0.4
0.1
0.3

28.1
31.3
18.8

3.4
1.1
0.2

212

1.5
0.2
1.1

135.0
150.0
90.0

13.5
4.5
0.8

80-bit

214

6.0
1.0
4.3

630.0
700.0
420.0

54.0
18.1
3.3

216

24.0
3.8
17.3

2,880.0
3,200.0
1,920.0

216.0
72.6
13.4

218

96.0
15.0
69.0

12,960.0
14,400.0
8,640.0

864.0
290.4
54.3

210

1.1
0.1
0.8

45.0
50.0
30.0

7.6
2.9
0.3

212

4.5
0.4
3.1

216.0
240.0
144.0

30.2
11.6
1.2

128-bit
214

18.0
1.5
12.5

1,008.0
1,120.0
672.0

121.0
46.2
4.8

216

72.0
6.0
50.0

4,608.0
5,120.0
3,072.0

483.8
184.9
19.4

218

288.0
24.0
200.0

20,736.0
23,040.0
13,824.0

1,935.4
739.7
78.3

Asymptotic

3nρ
3nϕ

2nρ + 2nκ
9nκσ log2 n
10nκσ log2 n
6nκσ log2 n
2.88nκ(κ + λ )

1.44nκ2 + n(λ + 2log2 n)
0.5nκσ + 6n(λ + 2log2 n)

Table 6: Communication complexity in MB for PSI protocols. (σ = 32: bit size of set elements, security parameters
κ,λ ,ρ,ϕ as deﬁned in §2.1). Numbers are computed from the asymptotic complexity given in the last column.

Experiments for Different Networks For each pro-
tocol
type (public-key-based, circuit-based, and OT-
based), we benchmark the best performing PSI protocol
in different network scenarios: Gigabit LAN, 802.11g
WiFi, intra-country WAN, inter-country WAN, and mo-
bile Internet (HSDPA) and depict our results in Tab. 7.
We characterize each network scenario by its bandwidth
and latency. By latency we mean one-way latency, i.e.,
the time from source to sink, and we used the same band-
width for up- and downlink. We simulated these network
types using the Linux command tc and ran the protocols
on n = 216 elements for κ = 128 and with one thread.

The only protocol that is nearly unaffected by the
change in network environment and for which the net-
work has not become the bottleneck is the DH-based
ECC protocol. In this protocol computation is the bottle-
neck which can be improved by using multiple threads.
For the other protocols we observe how the main bot-
tleneck transitions from computation to communication:
For Yao’s protocol this transition happens very early,
already when changing from Gigabit LAN to WiFi (fac-
tor 6 in runtime).8 Our vector-MT GMW protocol and
our random garbled Bloom ﬁlter protocol suffer less
drastically from the decreased bandwidth (factor 2.3 in
runtime). However, from the WiFi connection on, the

8The performance advantage of using ﬁxed-key AES garbling in-

stead of SHA-1/SHA-256 already diminished in the WiFi setting.

performance of all three protocol decreases approxi-
mately linear in the bandwidth. Note that, although our
vector-MT GMW protocol has only 66% of the commu-
nication complexity of Yao’s protocol, it is more than two
times faster in slower networks. This can be explained by
the direction of the communication. In Yao’s protocol,
the large garbled circuit is sent in one direction, whereas
the communication in GMW can be evenly distributed in
both directions s.t. it uses both up- and downlink.

For our set inclusion protocol, the network satura-
tion happens when using intra-country WAN. From this
point on, the performance also decreases linearly with
the bandwidth. Still, this protocol is the fastest of all
protocols in all network settings.

Experiments with Multiple Threads Tab. 8 shows the
runtimes with four threads. Of special interest is the
last column, which shows the ratio between the runtimes
with four threads and a single thread for n = 218 elements
and security parameter κ = 128. The DH-based protocol,
which is very simple and easily parallelizable, achieves
almost the optimal speedup of 4x as computation is the
performance bottleneck. The GMW protocol achieves
only a speedup of about 2x, possibly due to the gate-by-
gate evaluation of the circuit resulting in multiple rounds
of communication as the bottleneck. The OT-based pro-
tocols achieve a very good speedup of about 3x.

USENIX Association  

23rd USENIX Security Symposium  809

Network
(Bandwidth (Mbit/s) / Latency (ms))

Gigabit LAN
(1,000 / 0.2)

Type

Public-Key

Circuit [27]

OT

DH-based ECC [29]
Yao [7, 28]
Vector-MT GMW §3.2
Random Garbled Bloom Filter §4.3
Set Inclusion §5 + Hashing §6

802.11g WiFi

Intra-country WAN

Inter-country WAN

(54 / 0.2)

104.8
779.5

(25 / 10)

107.6
1,735.5

(10 / 50)

111.8
4,631.8

HSDPA
(3.6 / 500)

115.9

11,658.6

104.2
129.1

168.9 (11.3)

370.5 (18.1)

770.4 (27.5)

1,936.5 (67.2)

5,310.9 (170.2)

16.6
3.7

37.2
5.0

70.8
8.8

164.9
22.8

445.0
77.5

Table 7: Runtimes in seconds for PSI protocols with one thread in different network scenarios for n = 216 elements,
σ = 32: bit size of elements, and κ = 128-bit security (cf. Tab. 2); online time for Vector-MT GMW in ().

Type

Public-Key
Circuit [27]

OT

Symm. Security Parameter κ
Set Size n
DH-based FFC [29]
Vector-MT GMW §3.2
Random Garbled Bloom Filter §4.3
Set Inclusion §5 + Hashing §6

210
0.1
0.8
0.08
0.04

212
0.5
3.6
0.2
0.16

80-bit
214
1.8
15.9
0.8
0.4

216
6.7
71.3
3.2
1.2

218
26.9
288.1
13.1
4.7

210
1.3
1.1
0.14
0.04

212
5.2
5.6
0.5
0.2

128-bit
214
20.8
23.4
1.7
0.5

216
80.1
96.1
6.4
1.4

218
320.1
400.9
25.9
4.9

Speedup

3.82x
1.90x
2.61x
2.81x

Table 8: Runtimes in seconds for PSI protocols with four threads and σ = 32; speedup for n = 218 and κ = 128.

Comparison From the results we observe that OT-
based protocols have the lowest runtime on a fast net-
work. The public-key-based protocols require costly
public-key operations, which scale very poorly with in-
creasing security parameter, but need less communica-
tion than the OT- or circuit-based protocols. The circuit-
based protocols have a smaller runtime than the public-
key-based protocols using FFC or RSA for κ = 128, but
by far the highest communication complexity.

Our set inclusion protocol achieves both the most ef-
ﬁcient runtime and a very low communication overhead.
Compared to the second fastest protocol, namely our op-
timized random garbled Bloom-ﬁlter protocol, the set in-
clusion protocol is at least 5 times faster and uses 10
times less communication (for 128 bit security). More-
over, this protocol has the second best communication
overhead, requiring only 3 times the communication of
the DH-ECC-based protocol of [29], but running faster
in all network environments that we tested.

We stress that the choice of the preferable PSI protocol

depends on the application scenario. For instance,

• If communication is the bottleneck and computation
is vast, then the DH-based PSI protocol using ECC
is the most favorable. That protocol is also the sim-
plest protocol to implement.

• The circuit-based protocols are unique in that they
are based on generic secure computation techniques
and can therefore be easily modiﬁed to compute
more complex variants of PSI.

• While our set inclusion protocol performs very efﬁ-
ciently for σ = 32, it would require twice the run-
time for σ = 64, while the random garbled Bloom
ﬁlter protocol would have approximately the same
runtime (which would still be greater).

Acknowledgements We thank the anonymous review-
ers of USENIX Security 2014 for their helpful comments
on our paper. This work was supported by the European
Union’s 7th Framework Program (FP7/2007-2013) under
grant agreement n. 609611 (PRACTICE), by the German
Federal Ministry of Education and Research (BMBF)
within EC SPRIDE, by the Hessian LOEWE excellence
initiative within CASED, and by a grant from the Israel
Ministry of Science and Technology (grant 3-9094).

References

[1] G. Asharov, Y. Lindell, T. Schneider,

and
M. Zohner. More efﬁcient oblivious transfer
and extensions for faster secure computation.
In
Computer and Communications Security (CCS’13),
pages 535–548. ACM, 2013.

[2] Y. Azar, A. Z. Broder, A. R. Karlin, and E. Upfal.
Balanced allocations. SIAM Journal of Computing,
29(1):180–200, 1999.

[3] P. Baldi, R. Baronio, E. De Cristofaro, P. Gasti, and
G. Tsudik. Countering GATTACA: efﬁcient and se-
cure testing of fully-sequenced human genomes. In
Computer and Communications Security (CCS’11),
pages 691–702. ACM, 2011.

[4] R. W. Baldwin and W. C. Gramlich. Crypto-
In

graphic protocol for trustable matchmaking.
IEEE S&P’85, pages 92–100. IEEE, 1985.

[5] D. Beaver. Efﬁcient multiparty protocols using cir-
cuit randomization.
In Advances in Cryptology –
CRYPTO’91, volume 576 of LNCS, pages 420–432.
Springer, 1991.

810  23rd USENIX Security Symposium 

USENIX Association

[6] D. Beaver. Correlated pseudorandomness and the
complexity of private computations. In Symposium
on Theory of Computing (STOC’96), pages 479–
488. ACM, 1996.

[17] C. Dong, L. Chen, and Z. Wen. When private set
intersection meets big data: An efﬁcient and scal-
able protocol.
In Computer and Communications
Security (CCS’13), pages 789–800. ACM, 2013.

[7] M. Bellare, V. Hoang, S. Keelveedhi, and P. Ro-
gaway. Efﬁcient garbling from a ﬁxed-key block-
cipher.
In IEEE S&P’13, pages 478–492. IEEE,
2013.

[8] M. Bellare and P. Rogaway. Random oracles are
practical: A paradigm for designing efﬁcient pro-
tocols. In Computer and Communications Security
(CCS’93), pages 62–73. ACM, 1993.

[9] B. H. Bloom. Space/time trade-offs in hash cod-
ing with allowable errors. Communications of the
ACM, 13(7):422–426, 1970.

[10] E. Bursztein, M. Hamburg, J. Lagarenne, and
D. Boneh. OpenConﬂict: Preventing real time map
hacks in online games.
In IEEE S&P’11, pages
506–520. IEEE, 2011.

[11] H. Carter, C. Amrutkar, I. Dacosta, and P. Traynor.
For your phone only: Custom protocols for efﬁ-
cient secure function evaluation on mobile devices.
Journal of Security and Communication Networks
(SCN), 2013.

[12] S. G. Choi, K.-W. Hwang, J. Katz, T. Malkin, and
D. Rubenstein. Secure multi-party computation of
Boolean circuits with applications to privacy in on-
line marketplaces.
In Cryptographers’ Track at
the RSA Conference (CT-RSA’12), volume 7178 of
LNCS, pages 416–432. Springer, 2012.

[13] E. De Cristofaro, J. Kim, and G. Tsudik. Linear-
complexity private set intersection protocols secure
in malicious model.
In Advances in Cryptology
– ASIACRYPT’10, volume 6477 of LNCS, pages
213–231. Springer, 2010.

[14] E. De Cristofaro and G. Tsudik. Practical private set
intersection protocols with linear complexity. In Fi-
nancial Cryptography and Data Security (FC’10),
volume 6052 of LNCS, pages 143–159. Springer,
2010.

[15] E. De Cristofaro and G. Tsudik.

Experiment-
In Trust
ing with fast private set intersection.
and Trustworthy Computing (TRUST’12), volume
7344, pages 55–73. LNCS, 2012.

[16] D. Dachman-Soled, T. Malkin, M. Raykova, and
M. Yung. Efﬁcient robust private set intersec-
tion. In Applied Cryptography and Network Secu-
rity (ACNS’09), volume 5536 of LNCS, pages 125–
142. Springer, 2009.

[18] M. Fischlin, B. Pinkas, A.-R. Sadeghi, T. Schnei-
der, and I. Visconti. Secure set intersection with un-
trusted hardware tokens. In Cryptographers’ Track
at the RSA Conference (CT-RSA’11), volume 6558
of LNCS, pages 1–16. Springer, 2011.

[19] M. J. Freedman, C. Hazay, K. Nissim, and
set-intersection with
In Journal of Cryptol-

B. Pinkas.
Efﬁcient
simulation-based security.
ogy, 2013. To appear.

[20] M. J. Freedman, Y. Ishai, B. Pinkas, and O. Rein-
gold. Keyword search and oblivious pseudorandom
functions. In Theory of Cryptography Conference
(TCC’05), volume 3378 of LNCS, pages 303–324.
Springer, 2005.

[21] M. J. Freedman, K. Nissim, and B. Pinkas. Efﬁcient
private matching and set intersection. In Advances
in Cryptology – EUROCRYPT’04, volume 3027 of
LNCS, pages 1–19. Springer, 2004.

[22] O. Goldreich. Foundations of Cryptography, vol-
ume 2: Basic Applications. Cambridge University
Press, 2004.

[23] O. Goldreich, S. Micali, and A. Wigderson. How to
play any mental game or a completeness theorem
for protocols with honest majority. In Symposium
on Theory of Computing (STOC’87), pages 218–
229. ACM, 1987.

[24] G. H. Gonnet. Expected length of the longest probe
sequence in hash code searching. Journal of the
ACM, 28(2):289–304, 1981.

[25] C. Hazay and Y. Lindell. Constructions of truly
practical secure protocols using standardsmart-
cards. In Computer and Communications Security
(CCS’08), pages 491–500. ACM, 2008.

[26] C. Hazay and K. Nissim. Efﬁcient set operations
in the presence of malicious adversaries. In Pub-
lic Key Cryptography (PKC’10), volume 6056 of
LNCS, pages 312–331. Springer, 2010.

[27] Y. Huang, D. Evans, and J. Katz. Private set in-
tersection: Are garbled circuits better than custom
protocols? In Network and Distributed System Se-
curity (NDSS’12). The Internet Society, 2012.

USENIX Association  

23rd USENIX Security Symposium  811

[28] Y. Huang, D. Evans, J. Katz, and L. Malka. Faster
secure two-party computation using garbled cir-
cuits. In USENIX Security Symposium, pages 539–
554. USENIX, 2011.

[29] B. A. Huberman, M. Franklin, and T. Hogg. En-
hancing privacy and trust in electronic communi-
ties. In ACM Conference on Electronic Commerce
(EC’99), pages 78–86. ACM, 1999.

[30] Y. Ishai, J. Kilian, K. Nissim, and E. Petrank.
Extending oblivious transfers efﬁciently.
In Ad-
vances in Cryptology – CRYPTO’03, volume 2729
of LNCS, pages 145–161. Springer, 2003.

[31] S. Jarecki and X. Liu. Efﬁcient oblivious pseudo-
random function with applications to adaptive OT
and secure computation of set intersection. In The-
ory of Cryptography Conference (TCC’09), volume
5444 of LNCS, pages 577–594. Springer, 2009.

[32] S. Kamara, P. Mohassel, M. Raykova,

and
S. Sadeghian. Scaling private set intersection to
billion-element sets.
In Financial Cryptography
and Data Security (FC’14), LNCS. Springer, 2014.

[33] A. Kirsch, M. Mitzenmacher, and U. Wieder. More
robust hashing: Cuckoo hashing with a stash. SIAM
J. Comput., 39(4):1543–1561, 2009.

[34] L. Kissner and D. Song. Privacy-preserving set op-
erations. In Advances in Cryptology – CRYPTO’05,
volume 3621 of LNCS, pages 241–257. Springer,
2005.

[35] V. Kolesnikov and R. Kumaresan. Improved OT ex-
tension for transferring short secrets. In Advances
in Cryptology – CRYPTO’13 (2), volume 8043 of
LNCS, pages 54–70. Springer, 2013.

[36] C. Meadows.

A more efﬁcient cryptographic
matchmaking protocol for use in the absence of
a continuously available third party.
In IEEE
S&P’86, pages 134–137. IEEE, 1986.

[37] G. Mezzour, A. Perrig, V. D. Gligor, and P. Pa-
padimitratos. Privacy-preserving relationship path
discovery in social networks.
In Cryptology and
Network Security (CANS’09), volume 5888 of
LNCS, pages 189–208. Springer, 2009.

[38] M. D. Mitzenmacher. The power of two choices
in randomized load balancing. IEEE Transactions
on Parallel and Distributed Systems, 12(10):1094–
1104, 2001.

[39] P. Mohassel and S. S. Sadeghian. How to hide
circuits in MPC an efﬁcient framework for private

In Advances in Cryptology
function evaluation.
– EUROCRYPT’13, volume 7881 of LNCS, pages
557–574. Springer, 2013.

[40] S. Nagaraja, P. Mittal, C.-Y. Hong, M. Caesar, and
N. Borisov. BotGrep: Finding P2P bots with struc-
tured graph analysis. In USENIX Security Sympo-
sium, pages 95–110. USENIX, 2010.

[41] M. Nagy, E. De Cristofaro, A. Dmitrienko,
N. Asokan, and A.-R. Sadeghi.
Do I know
you? – efﬁcient and privacy-preserving common
friend-ﬁnder protocols and applications. In Annual
Computer Security Applications Conference (AC-
SAC’13), pages 159–168. ACM, 2013.

[42] M. Naor and B. Pinkas. Efﬁcient oblivious transfer
protocols. In SIAM Symposium On Discrete Algo-
rithms (SODA’01), pages 448–457. Society for In-
dustrial and Applied Mathematics (SIAM), 2001.

[43] A. Narayanan, N. Thiagarajan, M. Lakhani,
M. Hamburg, and D. Boneh. Location privacy via
private proximity testing.
In Network and Dis-
tributed System Security (NDSS’11). The Internet
Society, 2011.

[44] J. B. Nielsen, P. S. Nordholt, C. Orlandi, and S. S.
Burra. A new approach to practical active-secure
two-party computation. In Advances in Cryptology
– CRYPTO’12, volume 7417 of LNCS, pages 681–
700. Springer, 2012.

[45] NIST. NIST Special Publication 800-57, Recom-
mendation for Key Management Part 1: General
(Rev. 3). Technical report, National Institute of
Standards and Technology (NIST), 2012.

[46] R. Pagh and F. F. Rodler. Cuckoo hashing. In Euro-
pean Symposium on Algorithms (ESA’01), volume
2161 of LNCS, pages 121–133. Springer, 2001.

[47] B. Pinkas, T. Schneider, and M. Zohner. Faster
private set intersection based on OT extension.
Cryptology ePrint Archive, Report 2014/447, 2014.
http://eprint.iacr.org/2014/447.

[48] M. Raab and A. Steger. ”balls into bins” - a simple
and tight analysis. In Randomization and Approx-
imation Techniques in Computer Science (RAN-
DOM’98), volume 1518 of LNCS, pages 159–170.
Springer, 1998.

[49] T. Schneider and M. Zohner. GMW vs. Yao? Efﬁ-
cient secure two-party computation with low depth
circuits. In Financial Cryptography and Data Se-
curity (FC’13), volume 7859 of LNCS, pages 275–
292. Springer, 2013.

812  23rd USENIX Security Symposium 

USENIX Association

