ARPKI: Attack Resilient Public-Key Infrastructure

David Basin

Inst. of Information Security
Dept. of Computer Science

ETH Zurich, Switzerland
basin@inf.ethz.ch

Cas Cremers

Dept. of Computer Science

University of Oxford, UK

cas.cremers@cs.ox.ac.uk

Tiffany Hyun-Jin Kim
Carnegie Mellon University

Pittsburgh, USA

hyunjin@cmu.edu

Adrian Perrig

Inst. of Information Security
Dept. of Computer Science
adrian.perrig@inf.ethz.ch

ETH Zurich, Switzerland

Ralf Sasse

Inst. of Information Security
Dept. of Computer Science
ETH Zurich, Switzerland
ralf.sasse@inf.ethz.ch

Pawel Szalachowski
Inst. of Information Security
Dept. of Computer Science

ETH Zurich, Switzerland

psz@inf.ethz.ch

ABSTRACT
We present ARPKI, a public-key infrastructure that ensures
that certiﬁcate-related operations, such as certiﬁcate issuance,
update, revocation, and validation, are transparent and ac-
countable. ARPKI is the ﬁrst such infrastructure that sys-
tematically takes into account requirements identiﬁed by
previous research. Moreover, ARPKI is co-designed with a
formal model, and we verify its core security property using
the Tamarin prover. We present a proof-of-concept imple-
mentation providing all features required for deployment.
ARPKI eﬃciently handles the certiﬁcation process with low
overhead and without incurring additional latency to TLS.
ARPKI oﬀers extremely strong security guarantees, where

compromising n− 1 trusted signing and verifying entities is

insuﬃcient to launch an impersonation attack. Moreover, it
deters misbehavior as all its operations are publicly visible.

Categories and Subject Descriptors
K.6.5 [MANAGEMENT OF COMPUTING AND IN-
FORMATION SYSTEMS]: Security and Protection—
Authentication; C.2.0 [COMPUTER-COMMUNICATION
NETWORKS]: General—Security and protection

General Terms
Security

Keywords
Public-Key Infrastructure; TLS; certiﬁcate validation; public
log servers; formal validation; attack resilience

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’14, November 3–7, 2014, Scottsdale, Arizona, USA.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-2957-6/14/11 ...$15.00.
http://dx.doi.org/10.1145/2660267.2660298 .

1.

INTRODUCTION

In the current trust model of TLS PKI, a single compro-
mised (or malicious) Certiﬁcation Authority (CA) can issue a
certiﬁcate for any domain [9,21,23,26]. Moreover, such bogus
certiﬁcates can go unnoticed over long periods of time. This
glaring vulnerability is widely recognized.

In response, the research community has proposed diﬀer-
ent approaches to mitigate this problem. Recent proposals
include Certiﬁcate Transparency (CT) [18], which adds ac-
countability by using log servers to make compromises visi-
ble, and the Accountable Key Infrastructure (AKI) [15] that
prevents attacks by using checks-and-balances to prevent a
compromised CA from impersonating domains. Although
such proposals provide good starting points and building
blocks, they require many interacting features to be viable
and thus are inherently highly complex. History has shown
that humans will miss cases when considering the security
of such complex systems. Moreover, they must satisfy eﬃ-
ciency requirements and ﬁt with existing business models,
as well as oﬀer improved security. Finally, even advanced
proposals such as CT and AKI are still incomplete and have
been designed in an ad-hoc fashion, without a formal proof
of correctness. We will discuss limitations of the existing
state-of-the-art further in Section 2.

We now need to take the next step and get assurance
of both completeness of features as well as correctness of
the security claims, which can only be achieved by using a
principled approach.

security against a strong adversary capable of compromis-

Contributions. We present ARPKI, the ﬁrst co-designed
model, veriﬁcation, and implementation that provides ac-
countability and security for public-key infrastructures. In
contrast to other PKI proposals, ARPKI oﬀers:

● substantially stronger security guarantees, by providing
ing n− 1 entities at any time, where n≥ 3 is a system
● formal machine-checked veriﬁcation of its core security
● a complete proof-of-concept implementation that provides

parameter that can be set depending on the desired level
of security;

property using the Tamarin prover; and

all the features required for deployment and demonstrates
its eﬃcient operation.

382The full implementation, formal model and security proper-
ties, and the analysis tools are available [1].

Organization. In Section 2 we review the state-of-the-art
in PKI and in Section 3 we motivate properties that all PKI
architectures should have. We introduce ARPKI in detail in
Section 4 and describe its modeling and formal analysis in
Section 5. We present its implementation and evaluation in
Section 6 before we draw conclusions in Section 7.

2. PKI BACKGROUND

A variety of proposals have been made to address the
security issues in X.509 PKIs and to reduce trust in the
CAs. As illustrated in Figure 1, existing approaches can
be classiﬁed as being client-centric, CA-centric, or domain-
centric. We ﬁrst look at these diﬀerent approaches from a
high level and then focus on AKI, which is closest to our
work.
2.1 Alternative Approaches

Client-centric approaches. Proposals in this class em-
power clients to select dedicated entities to evaluate a cer-
tiﬁcates’ correctness before accepting it. Policy engine [5]
supports clients in deﬁning local policies (e.g., cryptographic
requirements, consistency of certiﬁcates based on an observed
history, etc.) for trust decisions. This proposal is at an early
stage and may rely on other proposals.

There are several proposals to create public repositories of
domain certiﬁcates and enable clients to select repositories
to compare the received key (of a domain) with the version
stored in the repositories. Perspectives [29] and Conver-
gence [2] fall in this category.

Although servers need no modiﬁcations, client-centric ap-
proaches require additional connections to query the reposi-
tories. This increases latency when establishing an HTTPS
connection.

CA-centric approaches. X.509 PKI includes standards
for Certiﬁcate Revocation Lists (CRL) [13] that are issued by
CAs to prevent clients from establishing a TLS connection
with domains with revoked certiﬁcates. Unfortunately, clients
must be able to access the current CRLs. To resolve this
online validation requirement, the Online Certiﬁcate Status
Protocol (OCSP) [22] allows clients to check domains’ certiﬁ-
cate status by querying CAs’ OCSP servers. However, OCSP
has security, privacy, and performance concerns. Another
approach is Short-lived certiﬁcates (SLC) [28] with which
domains acquire certiﬁcates with short validity lifetimes and
update them daily. SLC provides similar security beneﬁts
to OCSP while eliminating the need for online validation.
The major drawback with CA-centric approaches is their
heavy reliance on browser vendors to detect and blacklist
certiﬁcates issued by compromised CAs.

Domain-centric approaches. Three approaches allow
domain owners to actively control and protect their public
keys despite CAs’ potential vulnerabilities. They are based
on (1) pinning, (2) DNSSEC, or (3) log servers.

Pinning-based approaches, such as Public Key Pinning
(PKP) [3,4] and Trust Assertions for Certiﬁcate Keys
(TACK) [19], allow a domain to declare which keys are
valid for that domain such that clients “pin” the keys. How-
ever, these approaches have security vulnerabilities, such as
providing no protection on the ﬁrst visit to domains.

Figure 1: Classiﬁcation of PKI proposals.

The DNSSEC-based proposal called DNS-based Authenti-
cation of Named Entities (DANE) [12] enables domain owners
to assert certiﬁcate-speciﬁc ﬁelds on DNSSEC entries, such as
a list of acceptable CAs for issuing their domain’s certiﬁcates,
speciﬁc acceptable certiﬁcates, or speciﬁc trust anchors to
validate certiﬁcates. However, the security of DANE heavily
relies on the security of DNS operators, which historically is
not one of their concerns.

Log server-based approaches allow domain owners to record
their certiﬁcates to public log servers, creating accountability
for the CAs’ actions. For example, Sovereign Keys (SK) [10]
require domain owners to generate a sovereign key pair to
sign their TLS public key and to log the sovereign key pair
to read- and append-only timeline servers. Unfortunately
SK requires clients to query servers, increasing latency and
sacriﬁcing privacy.

Certiﬁcate Transparency (CT) [18] proposes that each
domain owner registers the CA-issued certiﬁcate to append-
only log servers with a Merkle hash tree structure. The
servers return a non-repudiable audit proof to the domain
such that the domain can provide its certiﬁcate along with the
audit proof to clients for a TLS connection setup. However,
as CT’s goal is only to make used certiﬁcates visible, it is still
vulnerable to attacks when an adversary compromises a CA
to create and register the fraudulent certiﬁcates, and CT does
not prevent clients from accepting these certiﬁcates. Because
CT itself is not designed to address certiﬁcate revocation, a
supplementary system called Revocation Transparency was
proposed [17]. Also Certiﬁcate Issuance and Revocation
Transparency (CIRT) [24] proposes eﬃcient revocation for
CT, but it requires a client to create a new identity once its
key is lost.

PoliCert [27] extends the Accountable Key Infrastructure
(discussed below) by giving the domain a way to describe
its own certiﬁcates and properties of TLS connections. It
also includes a revocation system and a new certiﬁcate val-
idation model. However, in this approach (as well as in
previously mentioned ones), the mechanisms for detecting
and disseminating log misbehavior are unspeciﬁed.

2.2 Accountable Key Infrastructure

We review the Accountable Key Infrastructure (AKI) [15]
in more detail for two reasons. First, ARPKI is inspired
by AKI’s design and employs some of its concepts. Second,
ARPKI addresses several shortcomings that we identiﬁed in
AKI.

AKI proposes to protect domains and clients from vulnera-
bilities caused by single points of failure, such as a CA’s root
key compromise [9,21,23,26]. Through checks-and-balances
among independent entities, AKI successfully distributes
trust over multiple parties and detects misbehaving entities
while eﬃciently handling certiﬁcate operations.

The AKI operates with the following three entities:

PKICA-centricClient-centricDomain-centricSLCOCSPPolicy engineRepositoriesPerspectivesConvergencePinningDNSSECLog serverPKPTACKDANESKCT/CIRTAKICRL3831. A Certiﬁcation Authority, called Certiﬁcation Agency
in [15], authenticates domains and issues X.509 certiﬁcates.
2. To make CA-issued certiﬁcates publicly visible, an In-
tegrity Log Server (ILS) maintains an Integrity Tree
that logs certiﬁcates. Each ILS updates its Integrity Tree
at a given interval, called ILS_UP.

3. Along with CAs, validators monitor ILS operations and
detect misbehavior, such as the sudden (dis)appearance of
certiﬁcates.

With these entities, the owner of a domain A.com deﬁnes
X.509 certiﬁcate extension ﬁelds, including:

● CA_LIST: List of trusted CAs to sign the certiﬁcate;
● ILS_LIST: List of trusted ILSes to register the certiﬁcate;
● ILS_TIMEOUT: Timeout of an ILS’s registration conﬁrma-
● CA_MIN: Minimum number of CA signatures needed to

tion;

initially register and update a certiﬁcate to ILSes.

The domain owner then contacts at least CA_MIN trusted CAs
to acquire certiﬁcates, the combination of which becomes
an AKICert. After receiving a conﬁrmation (i.e., signature)
from a trusted ILS that promises to add this AKICert to its
log and another conﬁrmation from at least one validator that
veriﬁes the correct operation of the trusted CAs and ILSes,
A.com uses the two conﬁrmations along with the AKICert to
establish TLS connections with clients.

Integrity Trees. Figure 2 illustrates the Integrity Tree
maintained by ILSes. Integrity Trees ensure that the ILS
cannot make false claims about any certiﬁcate it has or has
not stored. It is implemented as a Merkle hash tree, whose
leaves are lexicographically sorted by the domains’ names
and each parent node is computed as the hash of its two child
nodes. Every leaf stores the AKICert corresponding to the
given domain. After each ILS_UP period, the ILS updates the
tree by (1) adding new entries, (2) replacing updated entries,
and (3) deleting revoked and expired entries. Moreover, the
ILS computes the new root hash for the current version of
the tree.

This structure enables the ILS to create eﬃcient proofs
about its own content, including presence and absence proofs.
To prove that AKICert exists for A.com, the ILS provides
h1, AKICertA.com, h10, and h14. To prove that E.com does
not have any registered AKICerts, the ILS provides the
presence proofs for the immediate neighbors D.com and F.com:
h9, AKICertD.com, AKICertF.com, and h14. Along with presence
and absence proofs, the ILS provides the current signed root
hash rooti accompanied by the timestamp i (i.e., the last
time the tree was updated).

AKI weaknesses.
AKI leaves several questions unan-
swered. First, AKI’s setup suggests that validators can be
non-proﬁt organizations whose only incentive is to check
the correctness of ILS operations. However, AKI’s design
implies that if validators are not continuously online or have

rooti

h13

h14

h9

h10

h11

h12

h1

rooti−1

h2

h3

h4

h5

h6

h7

h8

A.com

D.com

F.com

K.com

P.com

S.com

Z.com

Figure 2: Integrity Tree in i-th ILS_UP period.

low bandwidth, then delays will occur during the certiﬁcate
registration and validation processes, contradicting AKI’s
claimed eﬃciency.

Second, parts of AKI’s design are not speciﬁed in suﬃcient
detail for a realistic implementation.
In particular, it is
unclear how ILSes interact during the AKICert registration
and update processes, how validators monitor the ILSes, and
how entities handle malicious events.

Third, AKI’s security properties have not been proven in
detail, and additional validation would help gain assurance
in AKI’s security claims.
In particular, with no mature
implementation available, certain edge cases are likely to
have been missed which may impact the security claims.
For instance, without synchronizing ILSes, an adversary can
register malicious AKICerts. To attribute misbehavior, all
ILSes and CAs must include the triggering messages (which
are signed by the sender) for any action they perform. If the
triggering requests are omitted, the ILSes and CAs will not be
able to prove their correct operation to others when needed.
In addition, the validators must consider both the updated
entries in the Integrity Tree of the ILSes and the original
request leading to the update (including its timestamp) to
monitor ILSes’ update handling.

Finally, AKI fails to prevent clients from accepting a com-
promised AKICert when an adversary successfully compro-
mises two out of three signing entities because CAs are not
actively involved in monitoring ILS or validator misbehav-
ior. Consequently, if an adversary compromises an ILS and
a validator, the compromised AKIcert stays valid until it
expires, even if the domain updates its key and acquires new
certiﬁcates from trusted CAs.

3. DESIRED PROPERTIES

In this section we state the adversary model and main

security properties that all PKIs should ideally provide.
3.1 Adversary Model

Ideally, PKIs achieve security with respect to the strongest
possible adversary (threat) model. Since PKIs operate over
a possibly untrusted network, the adversary, in the worst
case, can control the network. That is, we assume that the
adversary can eavesdrop, modify, and insert messages at will.
We also assume that the adversary can compromise some
entities, eﬀectively obtaining their long-term secrets. How-
ever, for a PKI to satisfy any nontrivial security property,
the adversary must not be able to compromise all entities.
We therefore assume that the adversary can compromise the
long-term secrets of some, but not all, parties.
3.2 Security Properties

In general PKIs should provide security, availability, and
be eﬃcient when clients authenticate domains, and these
properties should hold even under the threat model described
above.

Core security property. We ﬁrst highlight the core
security property that any PKI must satisfy, which prevents
impersonation attacks.

● Connection integrity. If a client establishes a connec-

tion based on a certiﬁcate, the client must be communicat-
ing with the legitimate owner of the associated domain.

384Other security properties. Besides the core property,
PKIs should also satisfy the following security properties.

● Legitimate initial certiﬁcate registration. The in-

frastructure should register a domain’s certiﬁcate only if
the certiﬁcate satisﬁes the requirements speciﬁed by the
infrastructure’s policy. For example, CA-centric infras-
tructures allow the use of a certiﬁcate as long as it is
signed by a non-revoked CA in the client browser’s root
CA list. As a second example, domain-centric infrastruc-
tures accept an initial certiﬁcate that is signed by (a set
of) designated entities that the domain owner explicitly
states to be trustworthy.

● Legitimate certiﬁcate updates. The infrastructure
● Visibility of attacks. If an adversary successfully launches

should update a domain’s certiﬁcate only if the new certiﬁ-
cate satisﬁes the requirements speciﬁed in the previously
registered certiﬁcate.

an attack against the infrastructure by compromising enti-
ties, the attack should become publicly visible for detec-
tion.

Figure 3: Basic communication ﬂow of ARPKI.
Solid numbered lines represent the message ﬂows
to register an ARCert, and dotted arrows represent
optional ﬂows. 10 and 11 represent a TLS connection
after registration is complete.

3.3 Performance Properties
PKIs should have the following performance properties.

● Low overhead. The infrastructure should not substan-
● Minimal additional latency over TLS. The infrastruc-

tially increase the TLS handshake message size and should
have negligible impact on processing time.

ture should induce minimal (ideally zero) additional round
trip latencies, possibly due to extra network requests, to
the TLS handshake.

4. ARPKI: ATTACK RESILIENT PKI

We now present ARPKI, the end result of our co-design of
model, veriﬁcation, and implementation. We return to the
modeling, veriﬁcation and co-design aspects in Section 5 and
present the implementation in more detail in Section 6.

ARPKI achieves strong security guarantees using three
entities for the certiﬁcate operation: two CAs and an ILS.
In particular, ARPKI’s CAs conduct active on-line conﬁrma-
tions with validator-like capabilities. Consequently, ARPKI

prevents compromise attacks such that even when n− 1
of n= 3, but we explain its extension to arbitrarily many

trusted entities are compromised, the security guarantees
still hold. The description in this section is for the case

trusted entities in Section 4.5.

Before we go into the details, let us ﬁrst give a high-
level summary of the actors and their responsibilities in this
scheme: a domain registers an ARPKI certiﬁcate (ARCert)
for itself with the ARPKI infrastructure, and can afterwards
use the resulting ARCert to securely serve webpages to clients.
The CAs check the identity of the domain owner on regis-
tration and then sign and give guarantees for the presented
certiﬁcate. Throughout the lifetime of the ARCert, the CAs
are responsible for checking the logs for this ARCert and
assuring the correct operation of other entities involved in
creating the ARCert. To check the ILSes behavior, the CAs
download all accepted requests from the ILSes and compare
them to the published integrity trees. The ILSes keep a log
of all ARCerts registered with them, in a publicly veriﬁable
way, and provide proofs of existence for ARCerts that are
then used by CAs and domains. The set of ILSes synchro-
nizes with each other in a secure and accountable manner.

Optionally there can be additional validators, that execute
checks similar to those made by CAs, but without issuing
ARCerts themselves.

that entity E signed message M by{M}K−1

We illustrate the process in Figures 3 and 4. We denote

, and H(⋅) stands

E

for a cryptographic hash function. All signatures include
timestamps and unique tags such that they cannot be mis-
taken for one another.

4.1 Initial ARCert Registration Process

ARCert generation. ARPKI supports trust agility, mean-
ing that the domain owners can select their roots of trust
and modify their trust decisions using extension parameters.
A domain owner creates an ARPKI certiﬁcate (ARCert) by
combining multiple standard certiﬁcates from trusted CAs.
Note that in this step each CA checks the identity of the
domain owner to authenticate domains correctly. We now
consider the owner of domain A registering her domain.

ARCert registration request (Steps 1–2).
In ARPKI,
three designated entities are actively involved in monitoring
each other’s operations. The core idea behind a Registra-
tion Request (RegReq) message is to let the domain
owner explicitly designate the trusted entities, namely two
CAs and one ILS (CA1, CA2, and ILS1 in Figure 3).

ARPKI requires the domain owner to contact just one CA
(CA1). The main responsibilities of CA1 are to validate the
correctness of the other two entities’ operations and act as a
messenger between the domain owner and ILS1 and CA2.

The domain owner also designates ILS1 to ensure that
ARCertA is synchronized among all ILSes. CA2 mainly
takes the validator’s role and ensures that ILS1 as well as
other ILSes operate accordingly, e.g., add ARCertA to their
Integrity Trees as promised.

ILS synchronization (Steps 3–6).
Ideally the same
ARCertA should be publicly visible among all ILSes. How-
ever, synchronizing all ILSes may be ineﬃcient, incurring
signiﬁcant time delay, and unrealistic. Instead, in ARPKI
ILS1 takes responsibility on behalf of the domain owner to
synchronize ARCertA among at least a quorum of all existing

Client (C)Validators (optional)ILSes12789561011ILS134CA2CA1TLSDomain (A)385ARCert Generation

A

ARCert Registration Request

: Set X.509 extensions
: Contact trusted CAs, get authenticated
: Combine multiple certiﬁcates into ARCertA

: RegReq={ARCertA, CA1 , ILS1 , CA2}K−1
: Ensure CA1∈ ARCertA’s CA_LIST

: Verify signatures in RegReq

A

: Add ARCertA into a pending request list

1. A→ CA1
CA1→ ILS1 : RegReq

2. CA1

: Ensure ILS1, CA1, and CA2 are diﬀerent entities
: Ensure no ARCert was registered for A’s domain

: Verify signatures in RegReq
: Ensure no ARCert was registered for A’s domain

: Collect SynResp from at least a quorum of ILSes

: Collect SynAck from at least a quorum of ILSes

ILS Synchronization

3. ILS1

: Ensure ILS1∈ ARCertA’s ILS_LIST

: Verify signatures in RegReq

ILSn

ILSn

ILS1

ILS1

5. ILS1

7. ILS1

4. ILSn

Registration Conﬁrmation

ILS1→ CA2 : RegResp=

ILS1→ ILSn: SynReq={RegReq}K−1
ILSn→ ILS1: SynResp={H(RegReq)}K−1
ILS1→ ILSn: SynCommit={H(RegReq)}K−1
6. ILSn→ ILS1: SynAck={H(RegReq)}K−1
: Accept={H(ARCertA)}K−1
{Accept, RegReq, List(SynAck)}K−1
: Ensure CA2∈ ARCertA’s CA_LIST
CA2→ CA1 : RegConf=
, List(SynAck)}K−1
{{Accept}K−1
CA1→ A : {{Accept}K−1
}K−1
10. C→ A
11. A→ C

: ARCertA,{{Accept}K−1

: Verify signatures in RegResp

: TLS connection request

}K−1

TLS Connection

8. CA2

9. CA1

ILS1

CA2

CA1

CA2

CA2

CA2

CA1

ILS1

: Ensure ILS1, CA1, and CA2 are diﬀerent entities

: Verify signatures in RegConf
: Ensure ILS1, CA1, and CA2 are diﬀerent entities
: Remove ARCertA from the pending request list

A

: Ensure ILS1, CA1, and CA2 are diﬀerent entities

Figure 4: Message ﬂows for the initial ARCert reg-
istration process in Figure 3.

ILSes.1 This ensures that only one ARCertA is registered
for the domain A, and the majority of the world maintains
a consistent certiﬁcate entry for the domain A in order to
prevent impersonation attacks.

Registration conﬁrmation (Steps 7–9). When the
majority of ILSes agree to add ARCertA to their public
Integrity Trees, ILS1 schedules domain A’s ARCert to appear
in its Integrity Tree during its next update (i.e., at the end of
the current ILS_UP time interval), which is stated and signed
in an Acceptance Confirmation (Accept) message. ILS1
then sends to CA2 a Registration Response (RegResp)
message, which serves as a proof to CA2 that ILS1 (and a
quorum of ILSes) indeed accepted domain A’s RegReq.
1The required quorum is one ILS more than 50% of all ILSes
to allow detection, and n ILSes more than 50% of all ILSes
to prevent inconsistent states. Here the security parameter

n= 3 is used, but generalized to arbitrary n in Section 4.5.

A

Proof Generation

ILS Conﬁrmation Request

: CCReq={A, CA1 , ILS1 , CA2}K−1

1. A→ CA1
2. CA1→ ILS1 : CCReq
7. ILS1→ CA2 : Proof={List(HashVal)}K−1
8. CA2→ CA1 : {{Root}K−1
}K−1
}K−1
9. CA1→ A : {{{Root}K−1
}K−1
10. C→ A
: ARCert,{{{Root}K−1
11. A→ C
}K−1

: TLS connection request

TLS Connection

, Proof

, Proof

ILS1

ILS1

ILS1

CA2

CA1

CA2

ILS1

CA2

,{Root}K−1

ILS1

}K−1

CA1

, Proof

Figure 5: Message ﬂows for obtaining ARCert’s log
proof. Upon receiving any signed message, all en-
tities verify the signatures (we omit these steps, fo-
cusing on the message ﬂows).

CA2 now takes the validator’s role to monitor and ensure
that ILS1 indeed made the majority of ILSes agree to accept
ARCertA for their next update time. CA1 also takes the
validator’s role to monitor that CA2 correctly monitors ILS1.
4.2 Clients Visiting a Domain using ARCert

TLS connection (Steps 10–11). The domain A now has
a conﬁrmation message (Accept) that is signed by three
trusted entities, and upon receiving Accept along with
ARCertA, clients can ensure that they are establishing a
TLS connection with domain A.

Clients can validate an ARCert against an Accept message
by verifying that the conﬁrmation (1) is authentic, meaning
the conﬁrmation is signed by trusted entities in ILS_LIST and
CA_LIST, (2) has not expired, and (3) is correct. Browsers
also perform the standard validation [7,11] of every X.509
certiﬁcate in ARCert. When validation succeeds, clients
accept the TLS connection to the domain A. The browser
can store the root (conﬁrmed by three trusted parties) for
optional checks later.
4.3 Conﬁrmation Renewal and Validation

Before ILS1’s RegResp expires (before ILS_TIMEOUT) or
after ILS1 updates its tree (i.e., at the start of every ILS_UP
interval), the domain owner must obtain a new proof that
its ARCert is indeed logged at the ILSes. We illustrate the
renewal process in Figure 5.

ILS conﬁrmation request (Steps 1–2). The domain
owner previously deﬁned the trust entities in her ARCertA.
Unless any one of the same entities is compromised, the
domain owner renews the ILS proof by contacting them.

Proof generation (Steps 7–9). At each ILS1 update,
CA1 and CA2 download all requests accepted by ILS1 (during
the last ILS_UP period), process it to maintain the local copy
of the tree, and monitor that the root hash of each CA’s local
copy matches what ILS1 publishes. If all the steps succeed,
the domain owner receives the ILS proof that is validated by
both CAs, as well as the root hash that is signed by all three
entities, making themselves accountable for their actions.

Instead of the Accept
TLS connection (Steps 10–11).
message, the domain owner now provides the Proof message

386Update ARCert Generation

A

: Set extensions for new key, contact trusted CAs
: Combine multiple certiﬁcates into an ARCertA

′
′, CA1 , ILS1 , CA2}K−1

A

ILS Synchronization

ILS ARCert Request

Update Conﬁrmation

: UpdateReq={ARCertA
1. A→ CA1
2. CA1→ ILS1 : UpdateReq
3. ILS1→ ILSn: SynReq={UpdateReq}K−1
4. ILSn→ ILS1: SynResp={H(UpdateReq)}K−1
′), T}K−1
: Accept={H(ARCertA
ILS1→ CA2 : UpdateResp=
{Accept, UpdateReq, List(SynAck)}K−1
8. CA2→ CA1 : UpdateConf=
{Accept
, List(SynResp)}K−1
K−1
9. CA1→ A : {{Accept}K−1
}K−1
10. C→ A
11. A→ C

′,{{Accept}K−1

: TLS connection request
: ARCertA

}K−1

TLS Connection

CA2

CA2

7. ILS1

ILS1

ILSn

ILS1

CA2

CA1

CA2

CA1

ILS1

Figure 6: Message ﬂows for updating domain A’s
ARCert.

together with the Integrity Tree root (signed by all three
entities) to TLS connection requests.

Clients can validate an ARCert against a conﬁrmation, be
it an Accept message or a Proof message with signed root,
by following the steps outlined in Section 4.2. For example,
the correctness validation of a Proof takes the form of the
browser re-computing the root of the Integrity Tree, using
the intermediate hash values as speciﬁed in the Proof and
comparing with the signed root.
4.4 Certiﬁcate Management

ARPKI supports certiﬁcate update, revocation, and re-
covery from loss or compromise of private key. Figure 6
illustrates how ARPKI supports certiﬁcate update.

Update ARCert generation. For a proper update, the
domain owner must satisfy the trust requirements that were
deﬁned in the previously registered ARCertA in ILS1. For
example, the domain owner’s new ARCertA
must be signed
by CA_MIN number of CAs in CA_LIST as speciﬁed in the old
ARCertA. Furthermore, the three designated entities for
updating the certiﬁcate must be in CA_LIST and ILS_LIST
of both the old ARCertA and the new ARCertA
; otherwise,
the update process is delayed by cool-oﬀ periods.

′

′

ILS request and synchronization (Steps 1–4).
To
update the ARCert, ILS1 proceeds with the update only if
an old ARCertA exists for the domain A.

ILS1 conﬁrms the
Update conﬁrmation (Steps 7–9).
replacement of ARCertA with ARCertA
only when at least
a quorum of all existing ILSes agree. This ensures that the
world continues to have a consistent view on domain A’s
ARCert.

′

The mutual checks in Steps 2, 7, and 8 in Figures 4–6 are
needed for misbehavior detection of CA1, CA2, and ILS1 dur-
ing the initial ARCert registration and subsequent ARCert

updates. Thus, an attack requires all three of them to be
compromised, since a single non-compromised entity detects
and blocks the attack.
4.5 Security Considerations

We have described the process for n = 3 above, which

prevents attacks based on the compromise of at most two
parties. To get stronger security guarantees, the process
can be extended for larger n: instead of the message sent
directly from CA2 to CA1 in Step 8 in Figure 3, additional
CAs inbetween CA2 and CA1 receive, check, sign, and send
the message to the next CA in line. Subsequently, the system
as a whole provides better security guarantees as it tolerates

n− 1 compromised parties. The downside is that n entities

must be involved in registration, conﬁrmation, and update,
and this may cause ineﬃciency in the client connection later
on.

Note that if an adversary can compromise n entities (CAs
or ILSes) in the overall system, the following attack is possible:
Given two disjoint sets of CAs, where one set is honest and
the other is compromised, if a domain successfully registered
a certiﬁcate for itself using the honest CAs, we would like
to guarantee that no bogus certiﬁcate can be registered for
that domain by the adversary. But, if all the ILSes are
compromised and willing to keep two separate logs, then
the adversary can register an ARCert for the domain using
the disjoint set of compromised CAs and ARPKI would not
prevent this attack. However, this attack is highly likely to
be detected quickly, and all the dishonest ILSes and CAs can
be held accountable.
4.6 Novelty of ARPKI

As mentioned earlier, the AKI design inspired ARPKI.
However, ARPKI introduces the following novel design as-
pects:

1. ARPKI introduces an entirely new role for the CAs, sup-
porting active on-line conﬁrmations with validator-like
capabilities. This changes the dynamics of the entire sys-
tem in terms of cost tradeoﬀs, possible resources, and
incentives.

2. ARPKI oﬀers diﬀerent message ﬂows to protect against
the weakness in AKI that we identiﬁed, such as the attack
based on two compromised parties. This also leads to a
simpler infrastructure from the domain’s perspective as
CA1 is the interface to the ARPKI infrastructure.

3. ARPKI supports a secure and accountable synchronization

sub-protocol for ILSes.

4. ARPKI’s CAs (working as validators) automatically down-
load requests accepted by the ILS to detect subtle mis-
behaviour. This frees the domain from having to contact
validators to verify the conﬁrmation.

5. Initial registration is simpliﬁed compared to AKI.

5. MODEL AND ANALYSIS

To establish high assurance guarantees, we formally an-
alyze ARPKI’s core security property using the Tamarin
Prover [20,25]. We chose Tamarin because it is a state-of-
the-art protocol analysis and veriﬁcation tool that supports
unbounded veriﬁcation, mutable global state, induction, and
loops.

In Tamarin, protocols are modeled using multiset rewrit-
ing rules and properties are speciﬁed using a fragment of

387ﬁrst-order logic that supports quantiﬁcation over timepoints.
Tamarin is capable of automatic veriﬁcation in many cases,
and it also supports interactive veriﬁcation by manual traver-
sal of the proof tree. If the tool terminates without ﬁnding a
proof, it returns a counter-example. Counter-examples are
given as so-called dependency graphs, which are partially or-
dered sets of rule instances that represent a set of executions
that violate the property. Counter-examples can be used to
reﬁne the model, and give feedback to the implementer and
designer.
5.1 Tamarin Background

Tamarin follows the Dolev-Yao model, where the adver-
sary can see and block all messages, as well as see the content
and manipulate messages (or their parts) that are not cryp-
tographically protected. The execution of a security protocol
in the presence of an adversary is modeled in Tamarin using
labelled multiset rewriting rules, as described below.

States. A state models a snapshot of a protocol’s execution:
the protocol participants’ local states, information about
fresh values, the adversary’s knowledge, and the messages
on the network. States are formalized as a ﬁnite multiset
of terms called facts. There is a special fact symbol Fr

with a ﬁxed semantics, where Fr(n) models that n is freshly

generated. The semantics of all other fact symbols is given
by the multiset rewriting rules.

Rules. Labeled multiset rewriting rules model the possible
actions of protocol participants and the adversary, who con-
trols and may modify messages on the network. Rules are
triples written as l -[ a ]-> r, where l, a, r are all ﬁnite
sequences of facts. We call l the premises, r the conclusions,
and a the actions.

We employ various modeling conventions. For example,
the protocol participants send messages using the Out fact,
which the adversary adds to its knowledge K fact, and then
can send to the protocol participants using the In fact. The
adversary can also combine knowledge, using any operator,

for example, given K(x) and K(y) and a binary operator f ,
the adversary deduces K(f(x, y)).
σ such that σ(l)∈ s, then the rule can be triggered, resulting
′ =(sࢨ σ(l))∪ σ(r). Each time a rule is
triggered, σ(a) is appended to the trace, which acts like a

Labeled multiset rewriting. For a given state s, for each
rule of the form l -[ a ]-> r, if there exists a substitution

in a new state s

log.

An execution is an alternating sequence of states and
multiset rewriting rules, where the initial state is empty,
and a state is followed by its successor state using the rule
in-between them. The trace of the execution is then the list
of the actions of the rules used in the sequence. Actions
are ordered sequentially and timestamped by the timepoint
when they occur. Properties are deﬁned in a fragment of
ﬁrst order logic and can refer to the actions in the trace and
their order. For more details, see [20,25].

If a counterexample to the speciﬁed property is found,
Tamarin’s GUI shows this as a graph of instantiated rules
and their connections. The graph includes the modeled rules
as well as the built-in adversary rules. Edges denote the
connections between facts produced by the right hand side
of rules and consumed by the left hand side of rules.

5.2 Tamarin Extensions

The size and complexity of ARPKI substantially surpassed
all protocols previously modeled with Tamarin. This re-
quired several improvements to the Tamarin tool chain.

First, protocols can now be speciﬁed using macros for
terms, which are used for repeating or large terms. These
macros, which may be nested, are expanded using the C
preprocessor. This change increased modeler productivity
and model maintainability. On the output side, we added
functionality to Tamarin’s GUI that allows a compact rep-
resentation of the huge output graphs that result from the
ARPKI model. This makes it easier to understand attacks
found by the tool. Finally, we introduced additional means
for the user to guide the proof search by annotating rules
with a measure of their relevance for the proof. These an-
notations can help Tamarin ﬁnd a proof in cases where its
default heuristics fail.
5.3 Modeling ARPKI

We modeled the communication ﬂow of ARPKI for the
initial ARCert generation and registration according to Fig-
ures 3 and 4.

Abstractions used. We employed several abstractions
during modeling. We used lists instead of Merkle hash trees
to store the registered certiﬁcates. As we do not give the
adversary the ability to tamper with these lists, and all
protocol participants only access them in the designated way,
this encodes the assumption that the hash tree cannot be
tampered with. However, the adversary can create such lists
(representing hash trees) himself by compromising parties
and using their long-term private keys to sign the lists. We
model signatures using a signing operator sign with a private
key as one of the parameters.
Model excerpt. The full Tamarin model for ARPKI is
available [1] and contains 23 rules taking around 1000 lines,
and is roughly 35000 characters before macro expansion, and
54000 characters after macro expansion. Even though in
principle our model allows arbitrarily many CAs and ILSes,
for the analysis we restrict ourselves to the minimal case of
two CAs and one ILS.

We present a simpliﬁed fragment of the rules to explain
the model’s key elements. The two rules below model the
execution of a domain that wants to register an ARCert for
its use, where it requests two CAs to sign oﬀ on the new
public key before it combines them. The state fact Domain-
CombineARCertA connects the two rules, so that the second
rule can only be triggered if the ﬁrst rule was previously
triggered and messages of the expected form are available.

rule A_Create_AR_Cert:

let ILSlist = $ILSk

pkA = pk(~ltkA) in

[ !Ltk($A, ~ltkA), F_CERT($A,pkA) ]

--[ OnlyOne(’A_Create_AR_Cert’)

, AskedForARCert($A,~ltkA) ]->
[ DomainCombineARCertA($A, CertA, $CA1, $CA2)
, Out(<$A, $CA1, SIGNREQ>), Out(<$A, $CA2, SIGNREQ>)]

In the above rule, we model the ILS list as a single public
name of an arbitrary ILS called ILSk. The $ preﬁx denotes
that ILSk is of type ‘public name’ and the ~ preﬁx denotes
terms of type ‘fresh’, i.e., freshly generated terms. Addi-
tional annotation of the type of each entity and timestamps
have been omitted here and throughout this section. Fact

388symbols with the ! preﬁx are never consumed and can be
used repeatedly.

To model asymmetric keys, we use fresh (unique) terms
as long-term private keys (here: ~ltkA) and use an abstract
one-way function pk that yields the corresponding public
key.

veriﬁcation. The action OnlyOne ensures that each domain
can only be registered once at the ILS. The state fact ILS-
toAdd stores the list of new ARCerts that must be added.
The message MSG1 that is sent out is a macro that expands to
contain the relevant parts of the registration request RegReq
and is signed by the ILS.

rule A_Receive_SignedCerts:

rule ILS_Reg_ILS:

let contactCA = $CA1 in
[ DomainCombineARCertA($A, CertA, $CA1, $CA2) ,

In(<$CA1, $A, SIGCert1>) , In(<$CA2, $A, SIGCert2>)]

[ In(< $CA1, $ILSk, RegReq >) , !Ltk($ILSk, ~ltkK)
, !Ltk($CA1, ~ltkCAx1) , !Ltk($CA2, ~ltkCAx2)
, ILStoAdd(~ltkK, $ILSk, AddList) ]

--[ NotEq(~ltkCAx1, ~ltkCAx2)

, ReceivedCASignedARCert($A,~ltkA) ]->
[ DomainHasARCertA($A, contactCA, ARCertA) ]

--[ OnlyOne(< ’RegisterDomain’, $A >) ]->

[ Out(< $ILSk, $CA2, MSG1 >)
, ILStoAdd(~ltkK, $ILSk, AddList + ARCertA) ]

We use the action NotEq(x,y) to specify that the rule can
only be triggered for two diﬀerent CAs. This concludes the
ARCert generation as described at the top of Figure 4.

We next describe the remaining message ﬂows for the
domain registering the new ARCert and the creation of the
registration conﬁrmation by CA1, CA2, and ILS, ignoring
the ILS synchronization as that is not part of our model.
In Figure 4 these message ﬂows are given by Steps 1–2 and
Steps 7–9. Each such step is a message exchange between
two parties, the sender and receiver. In the following step the
previous receiver becomes the sender of the next message. As
each rule is written from the point of view of one participant,
we simply combine the receiving of one message and the
sending of the next message into a single rule.

First, rule ILS_REG_A1 models sending the message from
Step 1. Note that the presence of private keys does not mean
that the participant actually knows the long-term private
keys of CA1 or CA2, but rather that it can check that the
correct signatures are used for those. The OnlyOne action
guarantees that for each ARCert, represented by its key
~ltkA, this registration will only be started once by an honest
participant. The state fact DomainHasARCertA connects this
rule with the previous one (initial generation) and the ﬁnal
rule which receives the fully signed ARCert. Note that the
message being sent, represented as RegReq, hides much of
the complexity of generating and checking the content of
messages.

rule ILS_Reg_A1:

let ILSlist = $ILSk in
[ DomainHasARCertA($A, $CA1, ARCertA)
, !Ltk($A, ~ltkA), !Ltk($CA1, ~ltkCAx1)
, !Ltk($CA2, ~ltkCAx2) ]

--[ OnlyOne(< ’ILS_Reg_A1’ , ~ltkA >) ]->

[ Out(< $A, $CA1, RegReq >),

DomainHasARCertA($A, $CA1, ARCertA) ]

The rule ILS_REG_CA1_FORWARD models receiving the mes-
sage from Step 1 and sending the message of Step 2. Note
that CA1 matches the contact CA in the ARCert. CA1 keeps
state of the received message in ContactCAStateILSReg and
does additional checks later.

rule ILS_Reg_CA1_Forward:

[ In(< $A, $CA1, RegReq >) ] --[ ]->
[ Out(< $CA1, $ILSk, RegReq >)
, ContactCAStateILSReg($A, $CA1, RegReq) ]

Next, rule ILS_REG_ILS receives the message from Step 2
and sends the message of Step 7 as an ILS. The two CAs are
bound inside the message that is received and the private
keys of CA1 and CA2 are again exclusively used for signature

The rule ILS_REG_CA2 receives the message of Step 7 and
sends the message of Step 8. Again, the private keys of ILS
and CA1 are used only for signature veriﬁcation. CA2 here
must take responsibility to only allow the registration of a
domain once. The message MSG1 is as described previously,
and MOK1 is an extension that is signed by CA2.

rule ILS_Reg_CA2:

[ In(< K, $CA2, MSG1 >), !Ltk($CA2, ~ltkCAx2)
, !Ltk($ILSk, ~ltkK), !Ltk($CA1, ~ltkCAx1) ]

--[ OnlyOne(< ’RegisterDomainSecondCA’, $A >) ]->

[ Out(< $CA2, $CA1, MOK1 >) ]

The rule ILS_REG_CA1 receives the message of Step 8 and
sends the message for Step 9. Again, the private keys of
ILS and CA2 are used only for signature veriﬁcation. Here,
CA1 ensures that the domain is only registered once. The
message sent out, MOK2, again extends MOK1 with a signature,
and is the proof of registration that will be used later by the
domain.

rule ILS_Reg_CA1:

[ In(< $CA2, $CA1, MOK1 >), !Ltk($CA1, ~ltkCAx1)
, !Ltk($ILSk, ~ltkK), !Ltk($CA2, ~ltkCAx2)
, ContactCAStateILSReg($A, $CA1, RegReq) ]
--[ OnlyOne(< ’RegisterDomainFirstCA’, $A >)

, AcceptedARCert($A, ~ltkA) ]->
[ Out(< $CA1, $A, MOK2 >) ]

Finally, the rule ILS_REG_A2 receives the MOK2 message
of Step 9, i.e., as the registering domain. Here, the private
keys of both CAs and the ILS are used just for signature
veriﬁcation. The domain also checks that the two CAs and
the ILS are distinct entities using NotEq.

rule ILS_Reg_A2:

[ DomainHasARCertA($A, $CA1, ARCertA)
, !Ltk($CA1, ~ltkCAx1), !Ltk($CA2, ~ltkCAx2)
, !Ltk($ILSk, ~ltkK), In(< $CA1, $A, MOK2 >) ]
--[ HasARCertNoLog($A, ~ltkA, ARCertANotVerified)

, NotEq(~ltkCAx1, ~ltkCAx2) , NotEq(~ltkCAx1, ~ltkK)
, NotEq(~ltkCAx2, ~ltkK)
, ReceivedARCert($A, ~ltkA) ]->
[ Out( ARCertANotVerified )
, StoredARCertA($A, ARCertA, ARCertANotVerified) ]

The state fact StoredARCertA is used to store the ARCert
that will subsequently be used by the domain for all connec-
tion requests.
5.4 Adversary Model

By default, Tamarin’s adversary model assumes that the
adversary has full network control. All messages sent using
Out(m) facts in the right hand side of rules are added to

389lemma main_prop:

"( All cid a b reason oldkey key #i1 #i2 #i3 #i4 .

( GEN_LTK(a,oldkey,’trusted’) @i1
& AskedForARCert(a,oldkey) @i2
& ReceivedARCert(a,oldkey) @i3

// ’Honest’ agent
// domain has asked for a ARCert with this exact key
// domain has confirmation that its ARCert with this
//

exact key has been processed.

& ConnectionAccepted(cid,b,a,reason,key) @i4 // browser accepted connection, based on private key

//

’key’ in for domain a.

& i3 < i4)
==>
( (not (Ex #j. K(key) @j)) )

) "

// adversary cannot know that private key

Figure 7: Main security property proven

the adversary’s knowledge, and any message that can be
constructed from this knowledge can be used to trigger an
In(m) fact in the left hand side of a rule. Thus, the adversary
can eavesdrop, modify, and insert messages.

Additionally we assume that the adversary can compromise
ILSes and CAs. For the main security property, we assume
that the adversary has compromised at most two such entities.
It is clear that for any design, if the adversary can compromise
all involved entities (here: two CAs, one ILS) that the browser
trusts, he can convince the browser that a certiﬁcate is good.
We model this by adding rules that enable the adversary to
register public keys that are later designated as a CA or an
ILS. A compromised ILS will then sign any integrity tree
represented as a list as usual.

5.5 Analysis Guarantees

Proof goal. Whenever (i) a domain A has been registered
initially by an honest party with an ARCert; and (ii) a
browser later accepts a connection to domain A with some
ARCert (which may have been updated and hence diﬀer from
the original ARCert), then the adversary does not know the
private key for that ARCert.

We require that the adversary does not know the private
key for the ARCert to model that the browser communicates
with the right domain, because for a bogus certiﬁcate the
adversary would know the private key. The part (i) makes
explicit the assumption that until a domain has had an
ARCert issued using ARPKI, anyone can register that domain
themselves, including the adversary, as long as they can fool
(or have compromised) two CAs.

We analyze this proof goal twice: once for at most two
compromised entities, and once for three or more compro-
mised entities. The formula that encodes this property in
Tamarin is shown in Figure 7 and takes the form of an
implication. The formula starts with a quantiﬁcation over
variables (cid, a, b, . . .): for all values of those variables there
should be a GEN_LTK(...) action in the trace at position i1
(#i1 denotes a variable i1 of type ‘timepoint’). In our model,
this action can only be produced by a particular rule that
generates initially trusted keys. If a domain A has initially
received an ARPKI certiﬁcate using a non-compromised pri-
vate key, and the browser accepted a connection for that
domain for any key pair (uniquely determined by the private
key key), then the implication holds if the adversary does

not know the private key key (encoded by K(key)).

This is precisely the connection integrity property from
Section 3. As we will show next, it holds for ARPKI whenever
up to two entities are compromised, and can be broken only
with three or more compromised entities.

Analysis. Using Tamarin, we ﬁnd the expected attack
for the case of three or more compromised CAs and ILSes.
An adversary that, for example, controls two CAs as well as
one ILS can create an ARCert for any domain. But, when
at most two entities are compromised, Tamarin veriﬁes the
lemma. This guarantees that no attack with less than three
compromised parties is possible.

We ran our experiments on a PC with an Intel Xeon CPU
(2.60GHz) with 16 cores and 32 GB of RAM with Ubuntu
14.04 64bit as the operating system. The proof runtime with
at most two compromised entities was 78 minutes, and the
runtime for ﬁnding the attack with three or more compro-
mised entities was 52 minutes. We had to develop extensions
and provided hints to Tamarin as indicated in Section 5.2.
We estimate the overall veriﬁcation eﬀort at several person
months.
5.6 Co-design

We developed our formal speciﬁcation of ARPKI in tandem
with its implementation, working from a single evolving
design document. As a result, the speciﬁcation and the
implementation are tightly linked, signiﬁcantly reducing the
possibility of modeling errors.

Tamarin played a critical role during the development in
helping us make all details of the protocol design precise and
in uncovering missing details. During development, we found
a number of attacks on early designs, even when limited
to two compromised parties. For example, in one case, we
discovered that checks done on the browser side, to protect
against a party signing more than once, were missing during
certiﬁcate creation, where the domain owner did not perform
these checks. The missing checks were then added to the
model, the speciﬁcation document, and the implementation.
Once the formal model had stabilized, further issues found
in failed proof attempts were quickly communicated and
ﬁxed on all sides.

6.

IMPLEMENTATION

In this section we describe our proof-of-concept implemen-
tation of ARPKI and assess its performance. Our proto-
type provides all the features required for deployment. In
particular, we implemented the following parts: (a) the
communication ﬂows and processing logic for the message
exchanges presented in Section 4, (b) the ILS process with
the fully implemented Integrity Tree, and the capability to
publish the information required for its consistency checks,
(c) the validator process, which monitors the ILSes and pub-
lishes misbehaviors, (d) the CA process that includes the
validator’s role with the additional ability to produce on-line
conﬁrmations, (e) the client process, i.e., a browser extended

390with support for full ARCert validation, (f ) the protocol for
accountable synchronization, and (g) the domain tool, which
can register, update, revoke, recover, and conﬁrm ARCerts.
6.1 Implementation Choices

We implement the ARCert certiﬁcates using a concate-
nation of standard X.509 certiﬁcates, where we used X.509
extensions [8] to introduce ARPKI-related ﬁelds such as
CA_LIST, ILS_LIST, ILS_TIMEOUT, and CA_MIN.

The implementation of all processes is written in C++.
We use OpenSSL (version 1.0.1) APIs for all cryptographic
operations, and use the JavaScript Object Notation (JSON)
and Base64 encoding for request and response messages. We
implement the Integrity Tree using SHA-512 as the hash
function, and use RSA-2048 as the signature algorithm.

Entities are implemented in a modular manner, where
every module provides its own API. The communications
module, which receives and serves requests, is implemented
using a multi-threaded work queue with TCP sockets. The
Integrity Tree is implemented as a separate database module,
while the publishing module is realized by a local HTTP
server. The ILS publishes all accepted requests and the root
hash at each update time. This module also allows every
entity to publish detected misbehaviors.

We implement the ARPKI TLS server by extending the
Nginx HTTP server (version 1.5.7). We conﬁgure the TLS
server to periodically interact with ARPKI’s infrastructure
to provide fresh conﬁrmations to the browser. After at most
every ILS_TIMEOUT (expected to be a few hours), the server
sends a request CCReq and receives fresh conﬁrmations, i.e.,
either Proof or Accept. The received conﬁrmations are
validated and saved for future HTTPS connections.

We implement the client by extending the Chromium
web browser and we deploy our system without signiﬁcant
changes to the server code and TLS protocol. During the
client-server connection, the server’s ARCert is sent within
the handshake’s Server Certiﬁcate message while conﬁrma-
tions are provided to the browser using the existing Online
Certiﬁcate Status Protocol Stapling extension. This architec-
ture includes the ARCert validation process from Section 4,
so the browser veriﬁes the ARCert and the signatures of the
received conﬁrmation. The browser additionally veriﬁes the
consistency of the ARCert and the conﬁrmation.
6.2 Performance Evaluation

We analyzed the performance of our prototype imple-
mentation in a real-world scenario. We set up a testbed
that included all entities: the ILS, CAs, validators, ARPKI-
supporting server, and browser. We ran our tests on a PC
with an Intel i5-3470 (3.20GHz) CPU and 16GB of RAM
with Ubuntu 12.04 64bit as the operating system. On this
machine we ran three virtual machines, acting as CA1, CA2,
and ILS1, respectively.

First we investigated how long it takes for the infras-
tructure to process three requests initiated by the domain:
RegReq, UpdateReq, and CCReq. Note that these ac-
tions are infrequently performed by our infrastructure for any
given domain. RegReq is sent once, while UpdateReq is,
in general, envisioned to be sent annually. The most common
request is CCReq, which is sent roughly every ILS_TIMEOUT.
Measurements are given as the average over 1000 test runs,
and the results are presented in Table 1. The total processing
time is calculated from the time that the domain sends the

Table 1: Total processing time (in milliseconds) re-
quired for the given request by the given entity.

Request
RegReq

UpdateReq

CCReq

CA1 CA2
9.28
9.31
9.33
9.49
5.12
5.64

ILS1 Total
32.15
13.56
31.80
12.98
7.06
17.82

Table 2: Detailed processing time (in milliseconds)
by the given entity.

Request

RegReq

CA1 UpdateReq

CCReq
RegReq

CA2 UpdateReq

CCReq
RegReq

ILS1 UpdateReq

CCReq

RSA ARCert Hash Misc.
1.61
1.71
2.51
1.37
1.44
1.28
1.72
1.90
1.24

5.80
5.90
2.39
5.97
5.72
2.40
10.09
9.32
5.68

1.72
1.69
-
1.70
1.93
-
1.38
1.40
-

0.18
0.19
0.22
0.24
0.24
0.25
0.37
0.36
0.15

request to the time that CA1 sends the response (which went
through all required entities), without considering network
latency. In other words, we measure the total processing
time spent by the entities involved.

We provide a further breakdown of the processing time
in Table 2. For each entity, we distinguish four kinds of
processing time. RSA denotes the time spent on signature
veriﬁcation and creation, required for creating and process-
ing protocol messages. ARCert denotes the time spent
on the veriﬁcation and parameter validation of the X.509
certiﬁcates. Hash denotes the time required to compute
hashes. Misc. encompasses message processing (Base64 and
JSON encoding/decoding and parsing), database lookup,
and input/output operations. For the CCReq, no ARCert
validation needs to be done, which we denote by a hyphen
in the table.

For the validation by the browser, we distinguish two
phases: standard validation and ARPKI validation. During
the standard validation phase, the browser validates every
X.509 certiﬁcate within ARCert, using the standard browser
validation procedure. This includes checking whether the
certiﬁcate is issued for a correct domain, has been signed
correctly, has expired, etc. The validation phase of ARPKI
additionally checks that (a) certiﬁcates within ARCert are
signed by CAs that are trusted by the domain, (b) proofs
have been produced for the correct ARCert and that the
proof validates with the correct root, and (c) the proof and
the root are signed by the correct entities (i.e., they are
distinct and trusted by the domain). We used an ARCert
that consisted of three standard X.509 certiﬁcates. The
entire validation took 2.25ms on average (the median was
2.20ms); the standard validation took 0.70ms on average
(median 0.67ms), and the ARPKI validation took on average
1.55ms (median 1.53ms).

The most time-consuming operations in our system in-
volve signature creation and veriﬁcation. This computational
overhead can be reduced by using state-of-the-art digital
signature schemes [6,14]. However, such improvements may

391not be backward-compatible with software that uses older
cryptographic libraries.

In our design, the CAs are required to perform veriﬁcation
in addition to their normal operations. Even though our
prototype is not yet optimized, our tests indicate that a CA
on a single low-end machine can serve about 100 ARCert’s
registrations/updates and 200 conﬁrmations per second. The
bandwidth required for this is 10Mbit/s.

In terms of client-server communication, the biggest trans-
mission overhead is introduced by using the ARCert, since it
is implemented by concatenating standard X.509 certiﬁcates.
Instead of sending one standard certiﬁcate, as is currently
done, a domain sends the concatenation of standard certiﬁ-
cates, each signed by a diﬀerent CA. Note that the size of this
overhead is not ﬁxed: the domain can adjust the trade-oﬀ
between processing/transmission overhead and the authenti-
cation of its own public key by combining the desired number
of standard certiﬁcates into an ARCert. It is important that
the latency introduced by the ARPKI infrastructure does not
inﬂuence the client-server connection. The conﬁrmations are
obtained periodically and stored by the server for a selected
amount of time. At each connection, the server provides
these conﬁrmations to the browser along with its ARCert.
Our solution does not introduce any extra network requests
for client-server connections. However, due to the size of
ARCert and conﬁrmations, small latency may be introduced
by the transport layer protocol [16]. Note that our solution
does not introduce any additional computational overhead
for the server during regular HTTPS connections.

Overall, our analysis of the prototype implementation
indicates that it is feasible to deploy ARPKI with reasonable
overhead.

7. CONCLUSIONS

We have presented ARPKI, a new public-key infrastruc-
ture that oﬀers very strong security guarantees. In particular,
it oﬀers resilience against impersonation attacks that involve

n− 1 compromised entities. Moreover, if all entities involved

in an ARCert are compromised, in which case domain imper-
sonation cannot be prevented, the validators may still obtain
the evidence of the compromise, and can take compensating
actions out of band. If such evidence cannot be obtained (an
adversary uses compromised keys to produce an ARCert and
its conﬁrmation, without logging this malicious ARCert),
then only an attacked client can make that attack detectable
by contacting validators out of band. Even though attack re-
silience cannot be achieved in this case, complete compromise
situations are at least visible. We have also implemented our
proposal. Our evaluation of the complete proof-of-concept
implementation provides strong evidence of the feasibility of
deploying ARPKI with reasonable overhead.

Throughout the design and implementation of ARPKI, we
used formal analysis to validate our design modiﬁcations.
This co-design of the formal model and the implementation
enabled us to detect numerous pitfalls early on.
It also
enabled us to make implementation choices that simpliﬁed
the construction of proofs later, such as including unique tags
in all messages. As a result, our formal model is much closer
to the implementation than a typical after-the-fact analysis
of a given implementation, thereby reducing the possibility
of modeling errors.

Finally, ARPKI introduces a new model of public-key in-
frastructure and certiﬁcate validation. Future work therefore

includes developing procedures for managing CA certiﬁcates,
elaborating the CAs’ policies and business models, improving
the representation of ARCert, and developing incremental
deployment strategies.

Acknowledgments
This work was supported by CyLab at Carnegie Mellon
University, NSF under award CNS-1040801, and a gift from
Google. We thank Emilia Kasper for her feedback during
the initial stage of this work. We thank Lorenzo Baesso and
Lin Chen for their programming assistance.

8. REFERENCES
[1] ARPKI: Full implementation, formal model, and

security properties.
http://www.netsec.ethz.ch/research/arpki.

[2] Convergence. http://convergence.io/.
[3] Public Key Pinning. http://www.imperialviolet.

org/2011/05/04/pinning.html, May 2011.

[4] Public Key Pinning Extension for HTTP.

http://tools.ietf.org/html/draft-ietf-websec-
key-pinning-01, December 2011.

[5] Mart´ın Abadi, Andrew Birrell, Ilya Mironov, Ted

Wobber, and Yinglian Xie. Global authentication in an
untrustworthy world. In Petros Maniatis, editor,
HotOS. USENIX Association, 2013.

[6] Daniel J Bernstein, Niels Duif, Tanja Lange, Peter

Schwabe, and Bo-Yin Yang. High-speed high-security
signatures. Journal of Cryptographic Engineering,
2(2):77–89, 2012.

[7] Robert Biddle, Paul C van Oorschot, Andrew S Patrick,

Jennifer Sobey, and Tara Whalen. Browser interfaces
and extended validation SSL certiﬁcates: an empirical
study. In Proceedings of the 2009 ACM workshop on
Cloud computing security, pages 19–30. ACM, 2009.

[8] D. Cooper, S. Santesson, S. Farrell, S. Boeyen,

R. Housley, and W. Polk. Internet X.509 Public Key
Infrastructure Certiﬁcate and Certiﬁcate Revocation
List (CRL) Proﬁle. RFC 5280 (Proposed Standard),
May 2008.

[9] Paul Ducklin. The TURKTRUST SSL certiﬁcate ﬁasco

- what really happened, and what happens next?
http://nakedsecurity.sophos.com/2013/01/08/the-
turktrust-ssl-certificate-fiasco-what-
happened-and-what-happens-next/, January 2013.

[10] Peter Eckersley. Sovereign Key Cryptography for

Internet Domains.
https://git.eff.org/?p=sovereign-keys.git;a=
blob;f=sovereign-key-design.txt;hb=HEAD.

[11] Martin Georgiev, Subodh Iyengar, Suman Jana,

Rishita Anubhai, Dan Boneh, and Vitaly Shmatikov.
The most dangerous code in the world: validating SSL
certiﬁcates in non-browser software. In Proceedings of
the 2012 ACM conference on Computer and
communications security, pages 38–49. ACM, 2012.
[12] Paul Hoﬀman and Jakob Schlyter. The DNS-based

Authentication of Named Entities (DANE) Transport
Layer Security (TLS) Protocol: TLSA.
http://tools.ietf.org/html/rfc6698, August 2012.
IETF RFC 6698.

392[13] R. Housley, W. Polk, W. Ford, and D. Solo. Internet

X.509 Public Key Infrastructure: Certiﬁcate and
Certiﬁcate Revocation List (CRL) Proﬁle. Technical
Report RFC 3280, Internet Engineering Task Force,
April 2002.

[14] Emilia Kasper. Fast elliptic curve cryptography in

OpenSSL. In Financial Cryptography and Data
Security, volume 7126 of LNCS, pages 27–39. Springer,
2012.

[15] Tiﬀany Hyun-Jin Kim, Lin-Shung Huang, Adrian

Perrig, Collin Jackson, and Virgil Gligor. Accountable
Key Infrastructure (AKI): A Proposal for a Public-Key
Validation Infrastructure. In Daniel Schwabe, Virg´ılio
A. F. Almeida, Hartmut Glaser, Ricardo A.
Baeza-Yates, and Sue B. Moon, editors, Proceedings of
the International World Wide Web Conference
(WWW), May 2013.

[16] Adam Langley. Overclocking SSL.

https://www.imperialviolet.org/2010/06/25/
overclocking-ssl.html, June 2010.

[17] Ben Laurie and Emilia Kasper. Revocation

Transparency. http://sump2.links.org/files/
RevocationTransparency.pdf.

[18] Ben Laurie, Adam Langley, and Emilia Kasper.

Certiﬁcate Transparency.
http://tools.ietf.org/pdf/rfc6962.pdf, June 2013.
IETF RFC 6962.

[19] Moxie Marlinspike and Trevor Perrin. Trust Assertions

for Certiﬁcate Keys. http://tack.io/draft.html,
May 2012.

[20] Simon Meier, Benedikt Schmidt, Cas Cremers, and

David Basin. The TAMARIN Prover for the Symbolic
Analysis of Security Protocols. In Computer Aided
Veriﬁcation, 25th International Conference, CAV 2013,
Princeton, USA, Proc., volume 8044 of LNCS, pages
696–701. Springer, 2013.

[21] Joseph Menn. Key internet operator VeriSign hit by

hackers.

http://www.reuters.com/article/2012/02/02/us-
hacking-verisign-idUSTRE8110Z820120202, January
2012.

[22] M. Myers, R. Ankney, A. Malpani, S. Galperin, and
C. Adams. X.509 Internet Public Key Infrastructure
Online Certiﬁcate Status Protocol - OCSP. Internet
Request for Comments 2560, June 1999.

[23] Paul Roberts. Phony SSL certiﬁcates issued for Google,

Yahoo, Skype, others.
http://threatpost.com/phony-ssl-certificates-
issued-google-yahoo-skype-others-032311/,
March 2011.

[24] Mark D. Ryan. Enhanced certiﬁcate transparency and

end-to-end encrypted mail. In Proceedings of NDSS.
The Internet Society, 2014.

[25] Benedikt Schmidt, Simon Meier, Cas Cremers, and
David Basin. Automated analysis of Diﬃe-Hellman
protocols and advanced security properties. In
Computer Security Foundations Symposium (CSF),
pages 78–94. IEEE, 2012.

[26] Toby Sterling. Second ﬁrm warns of concern after

Dutch hack. http://news.yahoo.com/second-firm-
warns-concern-dutch-hack-215940770.html,
September 2011.

[27] Pawel Szalachowski, Stephanos Matsumoto, and Adrian

Perrig. PoliCert: Secure and Flexible TLS Certiﬁcate
Management. In Proceedings of the ACM Conference
on Computer and Communications Security (CCS).
ACM, November 2014.

[28] Emin Topalovic, Brennan Saeta, Lin-Shung Huang,

Collin Jackson, and Dan Boneh. Towards Short-Lived
Certiﬁcates. In Web 2.0 Security and Privacy, May
2012.

[29] Dan Wendlandt, David G. Andersen, and Adrian Perrig.
Perspectives: Improving SSH-style Host Authentication
with Multi-Path Probing. In Proceedings of USENIX
Annual Technical Conference, June 2008.

393