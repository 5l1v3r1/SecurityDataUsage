Multi-Ciphersuite Security

of the Secure Shell (SSH) Protocol

Florian Bergsma
Horst Görtz Institute

Ruhr-Universität Bochum

Bochum, Germany

ﬂorian.bergsma@rub.de

Benjamin Dowling

Electrical Engineering and

Computer Science

Queensland University of

Technology

Brisbane, Australia

b1.dowling@qut.edu.au

Florian Kohlar

Horst Görtz Institute

Ruhr-Universität Bochum

Bochum, Germany

ﬂorian.kohlar@rub.de

Jörg Schwenk
Horst Görtz Institute

Ruhr-Universität Bochum

Bochum, Germany

joerg.schwenk@rub.de

Douglas Stebila

Electrical Engineering and

Computer Science

Mathematical Sciences
Queensland University of

Technology

Brisbane, Australia

stebila@qut.edu.au

ABSTRACT
The Secure Shell (SSH) protocol is widely used to provide
secure remote access to servers, making it among the most
important security protocols on the Internet. We show that
the signed-Diﬃe–Hellman SSH ciphersuites of the SSH proto-
col are secure: each is a secure authenticated and conﬁdential
channel establishment (ACCE) protocol, the same security
deﬁnition now used to describe the security of Transport
Layer Security (TLS) ciphersuites.

While the ACCE deﬁnition suﬃces to describe the security
of individual ciphersuites, it does not cover the case where
parties use the same long-term key with many diﬀerent ci-
phersuites:
it is common in practice for the server to use
the same signing key with both ﬁnite ﬁeld and elliptic curve
Diﬃe–Hellman, for example. While TLS is vulnerable to
attack in this case, we show that SSH is secure even when
the same signing key is used across multiple ciphersuites.
We introduce a new generic multi-ciphersuite composition
framework to achieve this result in a black-box way.

Categories and Subject Descriptors
C.2.0 [Computer–Communication Networks]: General
—security and protection

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’14, November 3–7, 2014, Scottsdale, Arizona, USA.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-2957-6/14/11 ...$15.00.
http://dx.doi.org/10.1145/2660267.2660286.

Keywords
Secure Shell (SSH); key agility; cross-protocol security; multi-
ciphersuite; authenticated and conﬁdential channel establish-
ment

1.

INTRODUCTION

Communication on the Internet is protected by a variety
of cryptographic protocols: while the Transport Layer Se-
curity (TLS) protocol (also known as the Secure Sockets
Layer (SSL) protocol) secures web communication, as well
as e-mail transfer and many other network protocols, the
Secure Shell (SSH) protocol1 provides secure remote login
and rudimentary virtual private network (VPN) access. It
is of paramount importance to have strong cryptographic
assurances of these protocols.

These and other real-world protocols tend to be far more
complex than protocols typically studied in the academic
literature. These protocols include both key exchange and
secure channel communication, support negotiation of many
combinations of cryptographic algorithms and a variety of
authentication modes, and have additional functionality such
as renegotiation and error reporting. All of these can aﬀect
the practical and theoretical security of the protocol.

At a high level, the parties run a cryptographic protocol
to establish a secure channel, then communicate arbitrary
application data over that channel. More precisely, execution
begins with a channel establishment phase, in which parties
negotiate which set of cryptographic parameters they intend
to use, establish a shared session key, use long-term keys
for entity authentication (either server-only or mutual), and
send key conﬁrmation messages. This is followed by the com-
munication of application data over a secure channel which
provides conﬁdentiality and integrity using the session key
from the channel establishment phase. The secure channel
is called the binary packet protocol in SSH. A complicat-
ing factor for SSH (as well as TLS) is that some portions
1In this paper, we refer exclusively to SSHv2 [39, 37, 40].

369Initiator

Responder

KEXINIT: nonce, ciphersuites

KEXREPLY: nonce, ciphersuites

KEXDH INIT: gx

KEXDH REPLY: gy, pkresp, sig

accept server
authentication

AUTHREQUEST: Enc(pkinit or pw or none)

AUTHOK

†: Enc(pkinit)
†: Enc(pkinit, sig)

AUTHREQUEST

e
s
a
h
p

e
k
a
h
s
d
n
a
h

accept client
authentication

AUTHSUCCESS

Enc(application data)

l
e
n
n
a
h
c

t
x
e
t
n
i
a
l
p

l
e
n
n
a
h
c

c
n
e
-
h
t
u
a

n
o
i
t
a
i
t
o
g
e
n

)
e
t
i
u
s
r
e
h
p
i
c
(

l
o
c
o
t
o
r
p
-
b
u
s

application
data phase

Figure 1: Overview of SSH protocol ﬂow.

† denotes messages omitted for server-only/password auth.

of the channel establishment phase take place in plaintext,
and other portions are sent over the secure channel. The
overlap between the channel establishment phase and the
secure channel can cause complications in the analysis of
these protocols.

thenticated encryption using the session key;

authenticated encryption using the session key;

For precision, we will use the following terminology:
• plaintext channel : communication that is not sent via
• auth-enc channel : communication that is sent via au-
• handshake phase: communication of protocol messages
to perform entity authentication and establish a secure
channel, consisting of a negotiation phase and a sub-
protocol (or ciphersuite) phase;2
• application data phase: communication of application

data using the auth-enc channel.

Figure 1 shows a simpliﬁed version of the SSH protocol with
mutual authentication; details appear in Section 4.

Provable security of real-world protocols. Standard
authenticated key exchange (AKE) models [7, 13, 27] are
not appropriate for modelling protocols such as SSH and
TLS for several reasons. First, the auth-enc channel for
secure application data communication is quite important
but is not included in AKE deﬁnitions. Moreover, even the
handshake phase cannot be analyzed as an AKE protocol:
AKE security requires indistinguishability of session keys,
but in both SSH and TLS, in the handshake phase, a key
conﬁrmation message is sent over the auth-enc channel which
allows an attacker to distinguish a random session key from
the real one. Some work has shown that truncated forms of
the SSH [36] and TLS [22, 29] handshakes are secure AKE
protocols, but this does not necessarily imply security of the
entire protocol.

2We note that ciphersuite happens to be a TLS-centric term.
SSH does not deﬁne a single ciphersuite, instead separately
negotiating key exchange, encryption, and MAC algorithms.
For consistency, in the case of SSH we refer to a single
combination of these algorithms as a ciphersuite.

It has also been observed that standard notions of authen-
ticated encryption are not quite appropriate for the auth-enc
channels in SSH or TLS either. The security property that
the auth-enc channel in SSH aims to meet is buﬀered stateful
authenticated encryption [6, 1, 30], which includes conﬁden-
tiality and integrity of ciphertexts and protection against
reordering, along with details associated with byte-wise pro-
cessing of received data.

Analysis of TLS proceeded in a similarly separate manner,
until, in 2012, the ﬁrst security proof of a full, unmodiﬁed
TLS ciphersuite appeared. Jager et al. [20] showed that (mu-
tually authenticated) signed-Diﬃe–Hellman TLS ciphersuites
were secure authenticated and conﬁdential channel establish-
ment (ACCE) protocols under reasonable assumptions on the
cryptographic building blocks. ACCE essentially combines
AKE and authenticated encryption notions to obtain a single
notion in which parties establish a channel that provides
conﬁdentiality and integrity of ciphertexts. Subsequently,
ciphersuites based on RSA key transport and static Diﬃe–
Hellman, with mutual and server-only authentication, have
been shown ACCE secure by both Kohlar et al. [24] and
Krawczyk et al. [26]. The ACCE notion was extended by
Giesen et al. [17] to cover renegotiation, in which parties
can establish a new ciphersuite or change authentication
credentials in an existing connection. Alternative approaches
for proving the full security of TLS include a composability
approach [11] and formal veriﬁcation of security properties
of an implementation [9], but ACCE seems the dominant
approach at present, and thus our choice for analyzing SSH.
Multi-protocol security. As noted above, both SSH
and TLS support the negotiation of diﬀerent combinations of
cryptographic algorithms—ciphersuites—for both the hand-
shake phase and the auth-enc channel. SSH’s possible nego-
tiated algorithms are noted in Section 4, and TLS supports
more than 300 diﬀerent combinations of algorithms. A note
on terminology: we will talk about SSH or TLS as a single
“protocol” consisting of diﬀerent “ciphersuites”; hence we are
interested in “multi-ciphersuite” security.

The previous works on ACCE security of TLS all focus on
ciphersuites running in isolation: in a cryptographic sense,
each ciphersuite is a diﬀerent “protocol”. Most ciphersuites
of TLS have been proven secure, but only in a world where
they have no interaction with other ciphersuites. In practice,
servers and clients often share a single long-term key across
multiple ciphersuites: For example, in SSH, the server may
have a single 2048-bit RSA signing key that it uses with vari-
ous key exchange and authenticated encryption mechanisms.
As ﬁrst identiﬁed by Kelsey et al. [23], re-use or sharing
of keys across multiple primitives or protocols can poten-
tially be insecure; this is variously called a chosen protocol
attack, cross-protocol attack, or multi-protocol attack. Very
early work on SSL by Wagner and Schneier [35] identiﬁed a
theoretical cross-ciphersuite attack on TLS: in ciphersuites
with signed key exchange, the data structure that is signed
(ServerKeyExchange) does not contain an identiﬁer of its
type, so it is theoretically possible that a data structure
signed for one key exchange method could be interpreted as
valid in another key exchange method. While Wagner and
Schneier were not able to translate this into a concrete attack,
Mavrogiannopoulos et al. [28] were able to make use of this
observation to interpret a set of ECDH parameters as valid
DH parameters. Cross-protocols attacks have been studied
in a variety of contexts for protocols in the literature [2, 34,

37015] and in practice [21]; notably, Cremers [15] studied 30
AKE protocols from the literature and found cross-protocol
attacks on 23 of them. In these lines of work, attacks arose
from a common fundamental principle: messages signed or
decrypted using long-term keys did not have suﬃciently dif-
ferent structure to prevent misuse in other protocols.

There have been several works considering the joint secu-
rity of protocols with shared or re-used keys, sometimes called
key agility.3 In their original paper on chosen protocol at-
tacks, Kelsey et al. [23] state ﬁve design principles that aim to
render chosen protocol attacks impossible; Canetti et al. [14]
similarly discuss requirements for security in multi-protocol
environments. Thayer-Fabrega et al. [33] proposed the use
of strand spaces, a type of formal logic for protocol execu-
tion, to identify under which conditions a protocol could be
composed with other protocols (re-using the same long-term
public key) without compromising security; enhancements
to this approach have followed [18, 5]. Datta et al. [16] and
Andova et al. [4] both give an alternative protocol composi-
tion logic. A common characteristic to these approaches is
deﬁning some form of independence of protocols, and then
using a composition theorem where protocols that are secure
in isolation and which are independent remain secure when
used together, even with re-used long-term keys. Bharga-
van et al. [10] analyze TLS in a multi-ciphersuite setting,
constructing a generic protocol where some—but not all—
algorithms can be combined while sharing long-term keys.

Contributions. Our main contribution is a provable
security analysis of the SSH protocol. In particular, we show
the various signed-Diﬃe–Hellman ciphersuites of SSH are
ACCE secure in isolation, under reasonable assumptions
on the underlying cryptographic primitive. We also show,
using a newly created framework for analyzing the security
of multi-ciphersuite protocols, that SSH is secure even when
these ciphersuites share the same long-term key. Our multi-
ciphersuite ACCE framework can be applied to analyze the
security of other ACCE protocols.

1. Provable security of signed-Diﬃe–Hellman SSH cipher-
suites in isolation. We provide the ﬁrst proof that SSH
is ACCE-secure.
In particular, we show that the signed-
Diﬃe–Hellman ciphersuites in SSH are ACCE-secure, under
reasonable assumptions on the cryptographic primitives used.
(Although RSA-key-transport-based ciphersuites have been
standardized for SSH [19], OpenSSH, the most prominent
implementation of SSH, does not support them as of this writ-
ing4, so we omit them.) We give results for both server-only
and mutually authenticated variants.

For mutual authentication, we only provide a formal treat-
ment of client authentication using public keys. While SSH
does support client authentication using passwords [37, §8],
this is a non-cryptographic form of password authentication:
after establishing a server-to-client auth-enc channel, the
client simply sends her username and password directly over
the auth-enc channel. Thus, having analyzed the server-only
variant, there is no value in further analyzing the case of
password authentication. Note as well that SSH allows mul-
tiple connections to be multiplexed in a single encrypted

3Contrast this with the universal composability (UC) frame-
work [12], where secure AKE protocols [13] can be composed
with other protocols but long-term keys are in general not
re-used across functionalities.
4http://www.openbsd.org/cgi-bin/cvsweb/src/usr.bin/
ssh/kex.h?rev=1.64

tunnel [38], but from a cryptographic perspective this is all
just application data.

2. Framework for analyzing multi-ciphersuite protocols.
We begin by adapting Jager et al.’s authenticated and con-
ﬁdential channel establishment (ACCE) deﬁnition [20]: we
deﬁne a multi-ciphersuite ACCE protocol: a short negoti-
ation phase is used to agree on one of several ciphersuites,
which is then used in the subsequent handshake phase and
auth-enc channel. We next deﬁne what it means for a multi-
ciphersuite ACCE protocol to be secure: it should be hard to
break authentication or channel security in any ciphersuite.
We then develop in Section 6 a generic approach for proving
multi-ciphersuite security from single ciphersuite security. It
will not be possible to prove in general that, if individual
ciphersuites are ACCE-secure in isolation, then the collection
is multi-ciphersuite-secure even when long-term keys are
re-used across ciphersuites: the aforementioned attack by
Mavrogiannopoulos et al. [28] on the signed-DH and signed-
ECDH ciphersuites in TLS serves as a counterexample to
such a theorem, so we need some additional alteration to the
standard ACCE deﬁnition.

Moreover, when long-term keys are shared, there are chal-
lenges in the standard simulation approach to proof. For
example, consider the case of two diﬀerent ciphersuites that
use the same long-term keys for authentication. A standard
simulation approach to proving multi-ciphersuite security
would be to assume one ciphersuite is secure in isolation,
then simulate the other ciphersuite. However, if long-term
keys are shared between the two ciphersuites, then it is in
general not possible to simulate the long-term private key op-
erations in the second, simulated ciphersuite, because those
keys are internal to the ﬁrst ciphersuite.

These are the main problems our technical approach must

solve. We achieve a composition theorem as follows:

1. Deﬁne a variant of ACCE in which the adversary has
access to an auxiliary oracle that does operations using
the long-term secret key, as long as queries to that
oracle do not violate a certain condition.
2. Suppose for each ciphersuite SPi there exists an auxil-
iary algorithm Auxi(sk,·) and condition Φi such that:
(a) SPi is secure even if an adversary makes queries
to Auxi(sk,·), provided the queries do not violate
Φi (i.e., in the sense of item 1 above); and

(b) if SPj shares long-term keys with SPi, then SPj
can be simulated using Auxi without violating Φi.
3. Then the collection of ciphersuites is secure, even when

long-term keys are re-used across ciphersuites.

Item 1 can be viewed as “opening up” the ACCE deﬁnition a
little bit, providing access to the secret key to do operations
that “don’t aﬀect security”. With carefully chosen auxiliary
algorithms and conditions, items 2(a) and 2(b) work together
to bypass the aforementioned challenge in proving a compo-
sition theorem using a simulation argument. Our approach
seems to provide substantial compositional power without
making proofs much harder in practice.

Our multi-ciphersuite ACCE approach contrasts with the
key agility methodology of Bhargavan et al. [10] for ana-
lyzing TLS. As noted above, TLS is not multi-ciphersuite
secure in general due to the cross-ciphersuite attack [28], so
Bhargavan et al. develop a more “ﬁne-grained” approach
to key agility in TLS: they explicitly model TLS as a pro-
tocol with multiple signature, KEM, and PRF algorithms,

371and then prove the joint security of key-agile TLS under
reasonable assumptions on the individual building blocks.
Our approach is more “coarse-grained”: we can compose sev-
eral whole ACCE-secure ciphersuites in a nearly black-box
manner, and the ciphersuites to be composed need not be
as “cleanly” related to each other as in Bhargavan et al.. In
fact, one could conceivably prove that key re-use in entirely
unrelated protocols (e.g., the same signing key in SSH and
(a revised form of) TLS) is secure using our framework.

3. Multi-ciphersuite security of SSH. Our composition
framework can be readily applied to signed-Diﬃe–Hellman
ciphersuites in SSH, yielding multi-ciphersuite security even
when long-term signing keys are re-used across ciphersuites.
To do so, we describe how to instantiate the auxiliary oracle
Auxi and predicate Φi in a way that maintains security in
condition 2(a) above, yet still allows cross-protocol simulation
as per condition 2(b) above. The composition theorem then
immediately yields multi-ciphersuite security.

2. PRELIMINARIES

In this section, we deﬁne notation used in the paper and

review the cryptographic assumptions used in the proofs.
Notation. Diﬀerent typefaces are used to represent dif-
ferent types of objects: Algorithms (also A and B); Queries;
Protocols; variables; security-notions; constants; vector no-
tation (cid:126)x is used for ordered lists. We use ∅ to denote the
empty string, and [n] = [1, n] = {1, . . . , n} ⊂ N for the set
If A is a set, then a $← A
of integers between 1 and n.
denotes that a is drawn uniformly at random from A. If A is
a probabilistic algorithm, then x $← A(y) denotes the output
x of A when run on input y and randomly chosen coins.
Standard security notions. We deﬁne in the standard
way (omitted for space) the advantages of an algorithm A in
solving the decisional Diﬃe–Hellman (DDH) problem in a
g,q(A)), ﬁnding
group of prime order q generated by g (Advddh
H(A)) [31],
collisions in an unkeyed hash function H (Advcr
breaking existential unforgeability of a signature scheme SIG
(A)), and distinguish-
under chosen message attack (Adveuf-cma
F (A))
ing a pseudorandom function F from random (Advprf
[26, full version, p. 43–45].

SIG

Buﬀered stateful authenticated encryption. Pater-
son et al. [30] introduced buﬀered stateful authenticated en-
cryption (BSAE) for appropriately modeling the security of
the SSH auth-enc channel. The main diﬀerence of BSAE to
previous deﬁnitions for authenticated encryption schemes is
that the decryption oracle buﬀers partial ciphertexts until
a complete ciphertext block is received, before answering a
decryption query. A full deﬁnition of BSAE and the security
game can be found in the full version [8].

3. MULTI-CIPHERSUITE ACCE

In the original ACCE formulation, an ACCE protocol is
deﬁned implicitly by however the experiment responds to
the Send queries.
In the multi-ciphersuite setting, there
are many diﬀerent ciphersuite algorithms to consider, so we
begin by more formally deﬁning a multi-ciphersuite protocol
in several portions. There will be a negotiation protocol,
which is common to all ciphersuites, and which is typically
used to negotiate which ciphersuite is used. Each party then
proceeds with the negotiated one of several sub-protocols, each
of which represents a diﬀerent ciphersuite. Each execution of

the protocol is called a session and will maintain and update
a collection of per-session variables.

Definition 1

(Per-session variables). Let π denote

the following collection of per-session variables:

• ρ ∈ {init, resp}: The party’s role in this session.
• c ∈ {1, . . . , nSP,⊥}: The identiﬁer of the sub-protocol
chosen for this session, or ⊥.
• pid ∈ {1, . . . , nP ,⊥}: The identiﬁer of the alleged peer
of this session, or ⊥ for an unauthenticated peer.
• α ∈ {in-progress, reject, accept}: The status.
• k: A session key, or ⊥. Note that k consists of two
sub-keys: bi-directional authenticated encryption keys
ke and kd (which themselves may consist of encryption
and MAC sub-keys).

• sid: A session identiﬁer deﬁned by the protocol.
• ste, std: State for the stateful authenticated encryption
• Any additional state speciﬁc to the protocol.
• Any additional state speciﬁc to the security experiment.

and decryption algorithms.

We can now deﬁne an ACCE protocol. It will be convenient
to explicitly name the diﬀerent algorithms that are executed
at diﬀerent times in the protocol.

Definition 2

(ACCE protocol). An ACCE proto-
col is a tuple of algorithms. The key generation algorithm
KeyGen() $→ (sk, pk) outputs a long-term secret key / pub-
lic key pair. The handshake algorithms AlgI(cid:96) and AlgR(cid:96),
(cid:96) = 1, . . . , take as input (sk, pk) and an incoming message
m, update per-session variables π, and output an outgo-
ing message m(cid:48). The handshake algorithms eventually set
the variables for the peer identiﬁer π.pid, the session status
π.α, the session key π.k, and the session identiﬁer π.sid.
There are also stateful authenticated encryption and de-
$→ (C, π.ste) and
cryption algorithms Enc(π.ke, m, π.ste)
Dec(π.kd, C, π.std) → (m(cid:48), π.std). All algorithms are as-
sumed to take as implicit input any global protocol parameters,
including the list of all trusted peer public keys.

Having deﬁned a single ACCE protocol, we now turn to

the multi-ciphersuite setting.

Definition 3

(Multi-ciphersuite protocol).

A multi-ciphersuite ACCE protocol NP(cid:107) (cid:126)SP is the protocol
obtained by ﬁrst running a negotiation protocol NP, which
outputs per-session variables π and a ciphersuite choice c,
then running subprotocol SPc ∈ (cid:126)SP. A negotiation proto-
col NP is a tuple of algorithms, denoted either NP.AlgI(cid:96) or
NP.AlgR(cid:96) for initiator or responder algorithms, respectively,
for (cid:96) = 1, . . . . All algorithms take as input an incoming
message m, update per-session variables π, and output an
outgoing message m(cid:48). The ﬁrst algorithms for both the initia-
tor and responder also take as input a vector (cid:126)sp of ciphersuite
preferences that the party should use in this session. The ﬁ-
nal negotiation algorithm for both parties sets the ciphersuite
choice variable π.c. Each sub-protocol SPc is a tuple of algo-
rithms corresponding to an ACCE protocol as in Deﬁnition 2,
namely SPc.KeyGen, SPc.AlgI(cid:96), SPc.AlgR(cid:96), SPc.Enc, SPc.Dec.
Note that the execution of the negotiation protocol and the
chosen subprotocol may be slightly interleaved, in that the
responder may send the last negotiation message and the ﬁrst
sub-protocol message together.

3723.1 Execution environment

The security experiment for a multi-ciphersuite ACCE
protocol is similar to that of individual ACCE protocols [20],
except that parties initially establish multiple long-term keys,
the adversary can activate parties with an ordered list of sub-
protocols, and the encryption/decryption is buﬀered stateful
authenticated encryption, rather than a stateful length-hiding
authenticated encryption. Let NP(cid:107) (cid:126)SP be a multi-ciphersuite
ACCE protocol, with | (cid:126)SP| = nSP.

Parties and long-term key generation. The execution
environment consists of nP parties, P1, . . . , PnP , each of
whom is a potential protocol participant. At the beginning
of the experiment, the variable δi,{c,d} is set to 1 or 0 and
represents whether party Pi re-uses the same long-term key
for SPc and SPd; note that δi,{c,d} must be 0 if SPc.KeyGen (cid:54)=
SPd.KeyGen, namely if there exists at least one input on
which the two algorithms diﬀer (for the same randomness).
Observe that δi,{c,d} is symmetric in c and d. Each party Pi
generates long-term private key / public key pairs (ski,c, pki,c)
for each sub-protocol SPc using SPc.KeyGen(), but, for all
d > c such that δi,{c,d} = 1, sets (ski,d, pki,d) = (ski,c, pki,c).
We say that there is no key re-use if all δi,{c,d} = 0.

Sessions. Each party can execute multiple sessions of the
protocol, either concurrently or subsequently. We will denote
i , where s ∈
the sth session of a protocol at party Pi by πs
{1, . . . , nS}. We overload the notation so that πs
i also denotes
the per-session variables π for this session. Each session
within a party has read access to the party’s long-term keys.
The per-session variables πj
i .(c, pid, α, k, sid) are initialized
to (⊥,⊥, in-progress,⊥,⊥). For the purposes of deﬁning
ciphertext indistinguishability and integrity, each session
i .b $←
upon initialization chooses a uniform random bit πs
{0, 1}. Each session also maintains additional variables for
stateful encryption/decryption as required in Figure 2.

Adversary interaction. The adversary controls all com-
it directs parties to initiate
munications between parties:
sessions, delivers messages to parties, and can reorder, alter,
delete, and create messages. The adversary can also compro-
mise certain long-term and per-session values of parties. The
adversary interacts with parties using the following queries.
The ﬁrst query models normal, unencrypted communica-

tion of parties during session establishment.

• Send(i, s, m) $→ m(cid:48): The adversary sends message m to
session πs
i . Party Pi processes message m according to
the protocol speciﬁcation and its per-session state πs
i ,
updates its per-session state, and optionally outputs
an outgoing message m(cid:48).
There is a distinguished initialization message which
allows the adversary to activate the session with certain
information. In particular, the initialization message
consists of: the role ρ the party is meant to play in this
session; the ordered list (cid:126)sp of sub-protocols the party
should use in this session; and optionally the identity
pid of the intended partner of this session.
This query may return error symbol ⊥ if the session
has entered state α = accept and no more protocol
messages are transmitted over the unencrypted channel.
The next two queries model adversarial compromise of

long-term and per-session secrets.

• Reveal(i, s) → k: Returns session key πs
• Corrupt(i, c) → sk: Returns party Pi’s long-term secret
key ski,c for sub-protocol c. Note the adversary does not

i .k.

e) $← SPc.Enc(ke, m0, st0
e)
e) $← SPc.Enc(ke, m1, st1
e)

Encrypt(i, s, m0, m1):
1. u ← u + 1
2. (C(0), st0
3. (C(1), st1
4. if C(0) = ⊥ or C(1) = ⊥ then
return ⊥
5.
6. C[u] ← C(b)
7. return C(b)

Decrypt(i, s, C):
1. (j, t) ← πs
i .pid, v ← v + 1
2. (m, std) ← SPc.Dec(kd, C, std)
3. if m = ⊥p then return ⊥
4. if b = 0 then return ⊥
j .u or C (cid:54)= πt
5. if v > πt
phase ← 1

6.
7. if phase = 1 then return m
8. return ⊥

then

j .C[v]

Figure 2: Encrypt and Decrypt queries in the multi-
ciphersuite ACCE security experiment.
Note that b, c, C[], kd, ke, std, ste, u, v denote the values stored in
the per-session variables πs
party identiﬁer j, once πs
unique matching session πt
j known to the challenger. The Decrypt
query accounts for buﬀering in the third line; this is the diﬀerence
from ACCE’s original stateful length-hiding deﬁnition [20, 26].

i has accepted every session πs

i .pid only contains the

i . Although πs

i has a

take control of the corrupted party, but can impersonate
Pi in later sessions of sub-protocol c.

The ﬁnal two queries model communication over the en-
crypted channel. The adversary can cause plaintexts to be
encrypted as outgoing ciphertexts, and can cause ciphertexts
to be delivered and decrypted as incoming plaintexts.

If πs

• Encrypt(i, s, m0, m1) $→ C: This query takes as input
i .k = ⊥, the query
two messages m0 and m1.
returns ⊥. Otherwise, it proceeds as in Figure 2, de-
pending on the random bit πs
i at the
beginning of the game and the state variables of πs
i .
• Decrypt(i, s, C) → m or ⊥: This query takes as input
i .k = ⊥, the query returns ⊥.
a ciphertext C.
Otherwise, it proceeds as in Figure 2. Note in particular
that decryption can be buﬀered, meaning a decryption
state may be maintained containing unprocessed bytes
of a partial ciphertext.

i .b sampled by πs

If πs

Together, these two oracles model the BSAE notion, which
simultaneously captures (i) indistinguishability under cho-
sen ciphertext attack, (ii) integrity of ciphertexts, and (iii)
buﬀered in-order delivery of ciphertexts. The hidden bit πs
i .b
is leaked to the adversary if any of these goals is violated.
3.2 Security deﬁnitions

Security of ACCE protocols is deﬁned by requiring that (i)
the protocol is a secure authentication protocol, and (ii) the
encrypted channel provides authenticated and conﬁdential
communication in the sense of buﬀered stateful authenti-
cated encryption. In the multi-ciphersuite setting, security
is further augmented by requiring that the parties agree on
the sub-protocol used.
Multi-ciphersuite ACCE security experiment. The
security experiment is played between an adversary A and
a challenger who implements all parties according to the
multi-ciphersuite ACCE execution environment. The adver-
sary sets the values of the long-term key re-use variables
δi,{c,d}. After the challenger initializes long-term keys based
on δi,{c,d}, the adversary receives the long-term public keys
of all parties, then interacts with the challenger using Send,
Reveal, Corrupt, Encrypt, and Decrypt queries. Finally, the
adversary outputs a triple (i, s, b(cid:48)) and terminates. We begin
by deﬁning when sessions match.

Definition 4

sion πt
• πs

j matches πs
i .ρ (cid:54)= πt
j.ρ;

(Matching sessions). We say that ses-
i if

373• πs
• πs

j.c; and

i .c = πt
i .sid preﬁx-matches πt

sent the last message in πs
of πs
then πs

i .sid, or (ii) if πt
j.sid.

i .sid = πt

j.sid, meaning that (i) if πs
i
j.sid is a preﬁx
i .sid,

j sent the last message in πs

i .sid, then πt

Note that for SSH, session IDs consist of a single value and
i .sid =
j.sid. Thus the “matching” relation is symmetric and thus

thus not only preﬁx-match, but must be identical: πs
πt
easier to handle.

Next we give mutual and server-only authentication def-
initions, based on the existence of matching sessions. For
server-only authentication, we are only concerned about
clients accepting without a matching server session.

Definition 5

We say that πs

(Authentication). Let πs

i accepts maliciously for sub-protocol c∗ if

i be a session.

• πs
• πs
• πs

i .α = accept;
i .c = c∗; and
i .pid = j (cid:54)= ⊥, where no Corrupt(j, c∗) query was
issued before πs
i accepted, nor Corrupt(j, d) for any d
such that δj,{c∗,d} = 1,

but there is no unique session πt

j which matches πs
i .

NP(cid:107) (cid:126)SP,c∗

Deﬁne Advmcs-acce-auth

(A) as the probability that, when A
terminates in the multi-ciphersuite ACCE experiment for
NP(cid:107) (cid:126)SP, there exists a session that has accepted maliciously
for sub-protocol c∗.
(A) as the probability that, when
NP(cid:107) (cid:126)SP,c∗
A terminates in the multi-ciphersuite ACCE experiment for
NP(cid:107) (cid:126)SP, there exists an initiator session (i.e., with πs
i .ρ =
init) that has accepted maliciously for sub-protocol c∗.

Deﬁne Advmcs-acce-so-auth

Channel security is deﬁned by the ability to break conﬁden-
tiality or integrity of the channel. Formally, this is deﬁned
as the ability of the adversary to guess the bit b used in the
Encrypt and Decrypt queries of an uncompromised session.
“Uncompromised” means that the adversary did not reveal
the session key at either the session or any matching session,
and that that adversary did not corrupt the long-term keys
of either party in the session. We give variants for mutually
and server-only authenticated channels.

Definition 6

(Channel security).

Suppose A outputs (i, s, b(cid:48)) in the multi-ciphersuite ACCE
experiment. We say that A answers the encryption challenge
correctly for subprotocol c∗ if

i .α = accept;
i .c = c∗;

• πs
• πs
• no Corrupt(i, c∗) query was ever issued, nor Corrupt(i, d)
• no Corrupt(j, c∗) query was ever issued for any j such
i , nor Corrupt(j, d) for any d such

for any d such that δi,{c∗,d} = 1;

j matches πs

that πt
that δj,{c∗,d} = 1;

• no Reveal(i, s) query was issued;
• no Reveal(j, t) query was issued for any πt
πs
i ; and
• πs
i .b = b(cid:48).
Deﬁne Advmcs-acce-aenc

NP(cid:107) (cid:126)SP,c∗

(A) as |p − 1/2|, where p is the prob-
ability that A answers the encryption challenge correctly for
subprotocol c∗.
(A) as |p − 1/2|, where p is the
probability that A answers the encryption challenge correctly

Deﬁne Advmcs-acce-so-aenc

NP(cid:107) (cid:126)SP,c∗

j that matches

for subprotocol c∗ and either πs
and there exists a session that matches πs
i .

i .ρ = init or both πs

i .ρ = resp

Definition 7

(Multi-ciphersuite-ACCE-secure).
A multi-ciphersuite protocol NP(cid:107) (cid:126)SP is (cid:126)-multi-ciphersuite-
ACCE-secure against an adversary A if, for all c∗, we have
(A) ≤ c∗ .
that Advmcs-acce-auth
We deﬁne an analogous notion for server-only authentication.

(A) ≤ c∗ and Advmcs-acce-aenc

NP(cid:107) (cid:126)SP,c∗

NP(cid:107) (cid:126)SP,c∗

When nSP = 1, the multi-ciphersuite ACCE protocol and
security deﬁnitions are equivalent to the original ACCE
deﬁnitions (albeit with slightly diﬀerent notation), except
for the change to buﬀered stateful authenticated encryption.
4. THE SSH PROTOCOL

In this section, we describe the SSH protocol using signed

Diﬃe–Hellman.

There are several cryptographic components that may
be negotiated in SSH, and the collective choice of these
components constitutes a ciphersuite. A party’s preferences
are represented as a vector (cid:126)sp, and the initiator and responder
preferences (cid:126)spC , (cid:126)spS are inputs to the negotiation function
neg( (cid:126)spC , (cid:126)spS) → c speciﬁed by the standard [40, §7.1] which
selects the ﬁrst element in (cid:126)spC that is also in (cid:126)spS.

Each ciphersuite SSHc can use diﬀerent cryptographic com-
ponents. The signature scheme SIGc for server and client
authentication may be either RSA, DSA, ECDSA [32], or
Ed25519. The key exchange method is Diﬃe–Hellman over
either a ﬁnite ﬁeld or elliptic curve cyclic group Gc of prime
order qc generated by gc. The hash function Hc can be either
SHA-1 or SHA-256. The buﬀered stateful encryption scheme
StEc can be composed of a variety of encryption and MAC
algorithms, including TripleDES in CBC mode or AES in
CBC or CTR mode and HMAC with MD5, SHA-1, SHA-256,
or SHA-512; or ChaCha20 with Poly1305.

During the negotiation phase, KEXINIT and KEXREPLY ex-
change nonces and negotiate the ciphersuite. During the
key-exchange portion of the sub-protocol phase, KEXDH INIT
and KEXDH REPLY exchange key-material, generate session
keys and authenticate the responder to the initiator via the
negotiated digital certiﬁcates and ciphersuites. During the
authentication portion of the sub-protocol phase, the respon-
der veriﬁes if the chosen authentication mode is authorised
for the given initiator, and authenticates the initiator via
passwords, public-keys or no client authentication at all.

The basic outline of the SSH protocol is given in Figure 1
in the introduction; the detailed message ﬂow and processing
for the signed-Diﬃe–Hellman handshake phase with server-
only or mutual public key authentication can be found in
Figure 3. For details on the authenticated encryption we
refer to the standard [40] and Albrecht et al. [1].
4.1 The SSH PRF

The PRFc function described in Figure 4 is used in the SSH
protocol to compute two values: H, which will be used as
the session ID (this value is later signed in the KEXDH REPLY
and AUTHREPLY messages); and k1(cid:107)k2(cid:107)k3(cid:107)k4(cid:107)k5(cid:107)k6 (which
are later used as encryption keys, IVs, and authentication
keys). PRFc computes these values using the hash function
Hc negotiated by the ciphersuite. While PRFc is superﬁ-
cially similar to HMAC, it varies suﬃciently that it merits
independent analysis.

We cannot prove security for SSH from the assumption
in SSH the

that Hc is a collision-resistant hash function:

374$← {0, 1}µ=128

Negotiation
1. init → resp: KEXINIT
1. rC
2. send KEXINIT ← (rC , (cid:126)spC )
3. π.ρ ← init
4. π.α ← in-progress
2. resp → init: KEXREPLY
$← {0, 1}µ
1. rS
2. send KEXREPLY ← (rS , (cid:126)spS )
3. π.ρ ← resp
4. π.α ← in-progress
5. π.c ← neg( (cid:126)spC , (cid:126)spS )
3. init
1. π.c ← neg( (cid:126)spC , (cid:126)spS )

Signed-Diﬃe–Hellman
sub-protocol, server-only
authentication mode
7. init → resp: AUTHREQUEST
1. send AUTHREQUEST ← username

(cid:107)service(cid:107)none
8. resp → init:
AUTHSUCCESS or AUTHFAILURE

1. if none authentication is authorised for

username for service then

π.α ← accept; send AUTHSUCCESS
π.α ← reject; send AUTHFAILURE

2.
3. else
4.

11. init
1. if AUTHFAILURE then
2.
3. else if AUTHSUCCESS then
4.

π.α ← reject and terminate
π.α ← accept

π.c

6. init → resp: NEWKEYS
1. K ← f x
2. (π.sid, π.k) ← PRFπ.c(K,

Signed-Diﬃe–Hellman sub-protocol (common to all authentication modes)
4. init → resp: KEXDH INIT
1. x $← Zqπ.c
2. e ← gx
3. send KEXDH INIT ← e
5. resp → init: KEXDH REPLY and NEWKEYS
1. y $← Zqπ.c
2. f ← gy
3. K ← ey
4. (π.sid, π.k) ← PRFπ.c(K,
5. σS ← SIGπ.c.Sign(skS,π.c, π.sid)
6. send KEXDH REPLY ← (f, pkS,π.c, σS )
7. send NEWKEYS

3. if SIGπ.c.Vfy(pkS,π.c, σS , π.sid) = 0 then
4.
5. π.pid ← S, where PS has public key pkS,π.c
6. send NEWKEYS

VC(cid:107)VS(cid:107)KEXINIT(cid:107)KEXREPLY(cid:107)pkS,π.c(cid:107)e(cid:107)f )

Note VC and VS are client and server version
strings.

VC(cid:107)VS(cid:107)KEXINIT(cid:107)KEXREPLY(cid:107)pkS,π.c(cid:107)e(cid:107)f )

π.α ← reject and terminate

π.c

Signed-Diﬃe–Hellman sub-protocol, mutual authentication mode
7. init → resp: AUTHREQUEST
1. send AUTHREQUEST ← username(cid:107)service
(cid:107)public-key(cid:107)0(cid:107)alg(cid:107)pkC,π.c (where alg is
the name of the public key algorithm (RSA,
DSA, ECDSA) and pkC,π.c is the client’s
public key for this ciphersuite)

10. resp → init: AUTHSUCCESS or AUTHFAILURE
1. A(cid:48) ← username(cid:107)service(cid:107)public-key
2. if A(cid:48) (cid:54)= A then
π.α ← reject
3.
4. if SIGπ.c.Vfy(pkC,π.c, σC , π.sid, A) = 0

(cid:107)1(cid:107)alg(cid:107)pkC,π.c

8. resp → init: AUTHOK or AUTHFAILURE
1. if username is not allowed access to service

by public-key authentication then

π.α ← reject and terminate
send AUTHOK ← alg(cid:107)pkC,π.c

2.
3. if π.α = in-progress then
4.
5. if π.α = reject then
6.

send AUTHFAILURE and terminate

9. init → resp: AUTHREQUEST
1. A ← username(cid:107)service(cid:107)public-key
2. σC ← SIGπ.c.Sign(skC,π.c, π.sid, A)
3. send AUTHREQUEST ← A(cid:107)σC

(cid:107)1(cid:107)alg(cid:107)pkC,π.c

then

π.α ← reject
π.α ← accept

5.
6. if π.α = in-progress then
7.
8. if π.α = accept then
9.
10. else if π.α = reject then
11.

send AUTHSUCCESS

send AUTHFAILURE and terminate

11. init
1. if AUTHFAILURE then
2.
3. else if AUTHSUCCESS then
4.

π.α ← reject and terminate
π.α ← accept

Figure 3: SSH handshake phase protocol: negotiation protocol and signed-Diﬃe–Hellman sub-protocol

PRFc(K, x):
1. H ← Hc(x(cid:107)K)
2. label ← [A, B, C, D, E, F ]
3. for i ∈ {1, . . . , 6} do
4.
5. return (H, k1(cid:107)k2(cid:107)k3(cid:107)k4(cid:107)k5(cid:107)k6)

ki ← Hc(K(cid:107)H(cid:107)labeli(cid:107)H)

Figure 4: Computation of PRFc using Hc.

hash value H to be signed by both parties not only contains
a transcript of the most important exchanged messages, but
also the secret Diﬃe-Hellman key K computed by both
parties. If Hc leaks information about K, the protocol cannot
be proven secure. Therefore we need the assumption that
PRFc is a secure PRF, which is how our security proof of
SSH proceeds in the rest of this section.

Under the assumption that Hc is a random function, it is

straightforward to see that PRFc is a secure PRF.

Analysis of PRFc under weaker, standard-model assump-
tions on Hc is more challenging. One way of analyzing
key derivation functions is Krawczyk’s extract-then-expand
paradigm [25].
In this paradigm, ﬁrst a pseudorandom
key K ← H(SKM ) is extracted from the secret key ma-
terial (such as the Diﬃe–Hellman shared secret) SKM us-
ing a hash function H, then application keying material
KM ← F (K,“1”(cid:107)info)(cid:107)F (K,“2”(cid:107)info)(cid:107) . . . is expanded from
the pseudorandom key K using a PRF F . Although PRFc

does seemingly have an extract phase (line 1) and then an
expand phase (line 4), the extract-then-expand paradigm
does not directly apply because the pseudorandom key (H,
in the case of PRFc) is subsequently used in another area
of the SSH protocol: H is signed by the signature scheme
and the signature is transmitted over the channel. Thus H
and the signature on H must not leak anything about the
Diﬃe–Hellman shared secret.

It may be possible to adapt extract-then-expand to analyze
the SSH PRF, but we leave that as future work. Our main
security proof of SSH is entirely standard model, so any
future work improving the analysis of PRFc from random
oracle model to standard model immediately yields a full
standard model proof of SSH.

5. ACCE SECURITY OF SSH

In this section, we analyze the security of single signed-DH
SSH ciphersuites, in isolation. We ﬁrst note a few challenges
we faced in the proofs, then show authentication and channel
security in the server-only and mutual authentication modes.
5.1 Challenges with security proofs for SSH

ACCE. As noted in the Introduction, challenges are often
encountered when trying to analyze real-world protocols.
The ﬁrst problem that arises when analyzing SSH is the
fact that the messages needed for client authentication are

375sent encrypted, allowing the adversary to trivially win key
indistinguishability in a standard authenticated key exchange
security experiment; this is resolved by switching to ACCE.
Session IDs vs. matching conversations. A secure
authentication protocol can, loosely speaking, be deﬁned
as a protocol where the success probabilities of active and
passive adversaries are equal, up to a negligible diﬀerence.
There are two main possible formalizations of this concept:
session IDs and matching conversations. We initially tried to
base our proof that SSH is a secure authentication protocol
on the classical notion of matching conversations (when the
two parties have the same transcript of communication), in
order to make our result comparable to previous work. How-
ever, SSH itself makes this impossible, because of a special
option to negotiate keys more quickly: the SSH client may
choose to start an abbreviated handshake, by guessing which
cryptographic parameters the server would accept, sending
messages KEXINIT and KEXDH INIT simultaneously. The SSH
server however may refuse this option, and in this case, the
KEXDH INIT message is discarded, and replaced by a new
(cid:48) to the server. In such a scenario, an ad-
message KEXDH INIT
versary may simply change the original value of KEXDH INIT
arbitrarily, thus breaking the matching conversations condi-
tion, and nevertheless make both sessions accept. Instead,
the SSH speciﬁcation itself suggests the use of a protocol-
speciﬁc session ID, a hash value H over the initial handshake
messages. This hash value is then used to generate and verify
the signatures both on client and server side.

PRF-ODH. Readers may wonder why we do not need the
PRF-Oracle-Diﬃe–Hellman (PFR-ODH) assumption used
in the analysis of signed-DH in TLS [20, 26].
In TLS, a
hypothetical adversary who can solve the CDH problem can
make a client oracle accept maliciously by intercepting all
messages after ServerKeyExchange, and then faking a valid
ServerFinished message. At the same time, this adversary
can refuse to cooperate in breaking DDH by testing if the
DDH challenge was embedded in the current session. All this
may not happen in SSH: here, acceptance directly depends
on signature veriﬁcation.

5.2 Server-only-authentication mode

In this section we drop subscripts for ciphersuites: SSH
denotes a single ciphersuite of the signed-Diﬃe–Hellman SSH
protocol described in Section 4, with signature scheme SIG,
Diﬃe–Hellman group of prime order q generated by g, and
hash function H, and the BSAE scheme StE.

The following theorem shows that, if the hash function
H is collision-resistant, the signature scheme SIG is euf-cma-
secure, the DDH problem for (g, q) is hard, the PRF is a
secure PRF, and the symmetric encryption is a secure BSAE
scheme, then the (single ciphersuite) signed-Diﬃe–Hellman
SSH protocol is a secure server-only ACCE protocol.

Theorem 1

(SSH is server-only-ACCE-secure).

Let µ be the length of the nonces in KEXINIT and KEXREPLY
(µ = 128), nP the number of participating parties and nS the
maximum number of sessions per party. The algorithms B1,
. . . , B5 given in the proof of the theorem are such that, for
all algorithms A, Advacce-so-auth
1 ) +
(A)+
nP Adveuf-cma
5 )) and BA
nP nS(Advddh
1 ,
5 have approximately the same running time as A.
. . . , BA

2µ + Advcr
(A) ≤ Advacce-so-auth
StE (BA

2 ) and Advacce-so-aenc
PRF(BA
3 ) + Advprf

(A) ≤ (nP nS )2

(BA
g,q(BA

4 ) + Advbsae

H(BA

SSH

SIG

SSH

SSH

In order to prove the theorem, we ﬁrst obtain a bound
on the server-only authentication advantage, then on the
channel security advantage.

SSH

Proof of Advacce-so-auth

(A) bound. The essence of the
proof is the observation that acceptance of a client session is
the result of a successful signature veriﬁcation. To be able
to use this fact, we have to make sure that all session IDs
are diﬀerent (by aborting if a nonce is chosen twice or if a
collision occurs in the hash computation of the session ID).
δ be the event that occurs when a client session
accepts maliciously in Game δ in the sense of Deﬁnition 5.
Game 0. The game equals the ACCE security experi-
(A) =

ment described in Section 3.2. Thus, Advacce-so-auth
Pr(break(0)

Let break(0)

SSH

0 ).

1

.

2µ

Game 1. In this game we add an abort rule for non-unique
nonces ri. Speciﬁcally the challenger collects a list L of all
cookies ri sampled by the challenger during the simulation.
If one cookie appears twice, we abort the simulation. Thus
Pr(break(0)

0 ) ≤ Pr(break(0)

1 ) + (nP nS )2

Game 3.

H(BA
1 ).

1 ) ≤ Pr(break(0)

Game 2. In this game we exclude hash collisions. Note
that in this game we can compute all session keys and session
identiﬁers honestly, and we maintain a list Coll, where all the
input/output pairs of all executions of the hash function H are
recorded. We abort if at any time a pair (in, H(in)) is added
to Coll such that there already exists an entry (in(cid:48), H(in(cid:48))) in
Coll with H(in) = H(in(cid:48)) but in (cid:54)= in(cid:48). Now we construct BA
as follows: B1 simulates the SSH protocol and interacts with
A. Whenever A wins the acce-so-auth game, B1 inspects the
recorded simulation to see if a hash collision occured. If it
did, B1 outputs this collision. Since B1 ﬁnds a collision, we
have that Pr(break(0)
2 ) + Advcr
In this game we exclude signature forgeries.
We abort the simulation if some session πs∗
i∗ accepts after it
receives a signature which was never output of a session with
a matching session identiﬁer. Note that we have excluded
nonce and hash collisions, so from now on all values to be
signed are diﬀerent. Thus any abort event is related to a
signature forgery.
2 which simulates
the SSH protocol as in Game 1. B2 interacts with A. B2
receives a public key pk from an euf-cma signature challenger
for SIG, guesses which public key pkj∗ the session will use
to verify the signature (which costs us a factor nP in the
reduction) and sets pkj∗ = pk. Since the signing key has
to be uncorrupted it is no problem for the reduction that
the secret signing key is unknown. If B2 needs to sign a
message on behalf of party Pj∗ , it makes a signing query
i∗ maliciously
to the euf-cma challenger.
accepts in the sense of deﬁnition 5 in Game 3, we know
from the discussion above that the maliciously accepting
session has veriﬁed a signature σ(cid:48) over a session ID H where
there is no session πt
j∗ with the same session ID, thus this
signature was not generated with a call to the signature
challenger. Thus B2 has found (H, σ(cid:48)) as a signature forgery,
so Pr(break(0)

Technically, we construct an algorithm BA

If the session πs∗

2 ) ≤ Pr(break(0)

3 ) + nP Adveuf-cma

(BA
2 ).

SIG

Final analysis. Now all signatures are computed by
legitimate parties only, and are all computed for diﬀerent
session IDs. Thus there is no way for a session to accept
maliciously, and we have Pr(break(0)

3 ) = 0.

376Proof of Advacce-so-aenc

be the
event that occurs when A answers the encryption challenge
correctly in Game δ in the sense of Deﬁnition 6.

(A) bound. Let break(1)

SSH

δ

Game 0. This game equals the ACCE security experiment

described in Section 3.2.

SSH

1

i∗ and πt∗

0 ) ≤ Pr(break(1)

Game 1. This game is identical to Game 3 of the previous
proof and we abort if some session accepts maliciously. With
the previous sequence of games we ensured unique nonces,
excluded hash collisions and signature forgeries. Thus, in this
game any session that accepts non-maliciously in the sense of
Deﬁnition 5 has a unique uncorrupted partner session. From
the previous proof, we have Pr(break(1)
1 ) +
(A). From now on, we always have a matching
Advacce-so-auth
session for the session πs∗
i∗ where the adversary tries to guess
the random bit: for server sessions through Deﬁnition 5, and
for client sessions through this game.
Game 2. In this game, we guess the session for which
the adversary outputs the bit b(cid:48). We guess two indices
(i∗, s∗) ∈ [nP ] × [nS] and abort if the adversary outputs
(i, s, b(cid:48)) with (i∗, s∗) (cid:54)= (i, s). This happens with probability
. We then exploit that no client session maliciously
nP nS
accepts due to Game 1, so we have that there exists a unique
partner session πt∗
j∗ which can be easily determined by the
1 ) ≤ nP nS · Pr(break(1)
simulator. Thus we have: Pr(break(1)
2 ).
Game 3. In this game we replace the value K = gxy
computed by πs∗
j∗ with a random value K∗. Since
we have excluded maliciously accepting sessions, and since
πs∗
i∗ fulﬁlls all conditions from Deﬁnition 6, the adversary
cannot inﬂuence these values. Any adversary A that can
distinguish this game from the previous game can directly be
used to construct an adversary BA
3 that can break the DDH
assumption: let (g, gu, gv, gw) be the DDH challenge. We set
gx := gu and gy := gv, and K∗ := gw. If w = uv, then we
have K∗ = K, and we are in Game 2, otherwise we are in
2 ) ≤ Pr(break(1)
Game 3. Thus Pr(break(1)
Game 4. In this game we replace the values H, k1, ..., k6
computed by πs∗
i∗ and πt∗
j∗ as PRF(K∗, sid) with random
6 . Any adversary A that can distinguish
values H∗, k∗
1 , ..., k∗
this game from the previous game can directly be used to
construct an adversary BA
4 that can break the PRF assump-
tion: let S = H||k1||...||k6 be the output of PRF, and let
S∗ = H∗||k∗
6 be a random string of the same length.
For S we are in Game 3, and for S∗ in Game 4. Thus
Pr(break(1)

Final analysis. We now have that the keys k∗

6 are
information-theoretically independent from the key exchange
messages. Thus any adversary A that can guess (i∗, s∗, b(cid:48))
correctly can directly be used to construct an adversary BA
5
that breaks the BSAE scheme. Technically we exploit the
fact that all keys for the encryption scheme are independent
from the handshake and embed a BSAE challenger. Now
we simply have to forward A’s output to the challenger and
thus we have Pr(break(1)

3 ) ≤ Pr(break(1)

4 ) ≤ Advbsae

StE (BA
5 ).

3 ) + Advddh

4 ) + Advprf

PRF(BA
4 ).

1||...||k∗

g,q(BA
3 ).

1 , ..., k∗

Remark 1. Forward secrecy. The ACCE deﬁnition of
Jager et al. [20] can be extended to include forward secrecy,
meaning that the adversary in the channel security deﬁnition
is allowed to corrupt the long-term key of the owner of the
target session or its peer after the target session has accepted.
We have omitted forward secrecy from this paper for sim-
plicity, but Deﬁnition 6 can be easily extended to cover the
case of forward secrecy, and the proof of the channel security
bound can be readily adapted using the techniques in [20].

Remark 2. Mutual authentication mode. In a similar man-
ner, it can be shown that the (single ciphersuite) signed-
Diﬃe–Hellman SSH protocol has secure mutual authentica-
tion when the client uses public key authentication if the
building blocks of SSH are secure, and thus is a secure ACCE
protocol with mutual authentication.

6. COMPOSITION THEOREM FOR

MULTI-CIPHERSUITE SECURITY

As noted in the Introduction, if two ciphersuites with the
same long-term key generation algorithm have been proven in-
dividually secure (i.e., if SP1.KeyGen = SP2.KeyGen, NP(cid:107)SP1
is ACCE-secure, and NP(cid:107)SP2 is ACCE-secure), it does not
necessarily follow that they are collectively secure when par-
ties use the same long-term secret key in both ciphersuites.
We still hope however to be able to prove some security
properties of individual ciphersuites separately and then
compose them together using some generic theorem, rather
than having to directly prove security of the whole multi-
ciphersuite combination all at once. Some intuition for our
composition framework follows.

Suppose a user supports two ACCE-secure ciphersuites
(the “apple” ciphersuite and the “orange” ciphersuite) with
authentication in both cases provided by use of the same digi-
tal signature scheme, and that in each ciphersuite, the signed
data clearly and unambiguously identiﬁes the ciphersuite (for
example, starting with the word “apple” or the word “orange”,
respectively). As well, suppose that during authentication in
each ciphersuite, the receiver veriﬁes that the signed data is
for the ciphersuite in question (it really does start with the
word “apple” or the word “orange”, respectively).

Intuitively, then, obtaining signatures from one ciphersuite
should not help in breaking the second ciphersuite, even if
they are both signed using the same long-term keys.

We are now able to consider the security of the two cipher-
suites together. Since “apple” signatures will not aﬀect the
security of the “orange” ciphersuite, and “orange” signatures
will not aﬀect the security of the “apple” ciphersuite, the two
ciphersuites remain secure even if they share long-term keys.
A theorem for the security of the two ciphersuites together
should say: if both the “apple” and “orange” ciphersuites are
being used and users are possibly sharing long-term keys
between them, and the adversary breaks some session in
the “apple” ciphersuite, then the “apple” ciphersuite was not
secure even in isolation; and similarly for “orange”.

To prove security, our simulator will be given a challenger
for the “apple” ciphersuite and must simulate the others. The
simulation can simulate ciphersuites that use keys not shared
with “apple” because it can choose those keys itself. Only
ciphersuites that share keys with “apple” are tricky; in this
case, the simulator asks the “apple” challenger to sign an
“orange” message, which should not aﬀect the security of the
“apple” ciphersuite but allows the simulator to simulate the
“orange” ciphersuite. We have to introduce a few small tech-
nical conditions to ensure that the simulation goes through,
but this is the main idea.
6.1 Single ciphersuite security with auxiliary

oracle

We begin by “opening up” the ACCE security deﬁnition
a little bit, to consider security of a single ciphersuite in
isolation, but with additional access to secret key operations.

377As shown in Deﬁnition 8, we extend the ACCE security
experiment to allow the adversary access to an auxiliary
oracle that runs a speciﬁed private key operation Aux(sk,·)
(in the case of signed-DH SSH, a signing oracle that signs
arbitrary messages). If the adversary breaks the original
ACCE security goals without asking a query x to Aux that
violates the constraint or predicate Φ, then the adversary
wins. For example, if we are studying the “orange” ciphersuite,
then the predicate Φ(x) would test if x starts with the word
“orange”. As long as the adversary’s signing queries did not
start with the word “orange”, they should not help him win
the security experiment.

P,Aux,Φ

Definition 8

Deﬁne Advacce-auth-aux

(ACCE-secure w/auxiliary oracle).
Let P be an ACCE protocol. Let Aux : (sk, x) (cid:55)→ y be an
algorithm. Augment the ACCE experiment giving the adver-
sary access to an additional oracle Aux(i, x) which outputs
Aux(ski, x). Let Φ(x) be a predicate on a value x.
(A) as the probability that, when A
terminates in the above augmented ACCE experiment for P
with auxiliary oracle, there exists a session that has accepted
maliciously, with the additional constraint that, for all x such
that A queried Aux(πs
(A) as |p − 1/2|, where p
is the probability that A answers the encryption challenge
correctly in the above augmented ACCE experiment for P
with auxiliary oracle, again with the additional constraint
that, for all x such that A queried Aux(πs
i .pid, x), Φ(x) = 0.
We deﬁne analogous notions for server-only authentication.

Similarly, deﬁne Advacce-aenc-aux

i .pid, x), Φ(x) = 0.

P,Aux,Φ

6.2 Multi-ciphersuite composition

Once we have that each ciphersuite is individually secure,
we want to use a composition theorem to show that their
multi-ciphersuite combination is secure, even if long-term
keys are shared across ciphersuites. For ciphersuites that
do not re-use long-term keys, security of the combination
is trivial. For ciphersuites that do re-use long-term keys,
reducing the security of the combination to the security
of the individual ciphersuites requires that we be able to
simulate the other ciphersuites. We can do so using the
above auxiliary signing oracle, as long as we do not violate
the predicate. For example, we need to be able to simulate
the “apple” ciphersuite using the “orange” signing oracle,
without asking queries that start with the word “orange”.
This simulatability condition is modelled in Deﬁnitions 9
and 10. Our composition theorem (Theorem 2) is then
shown using such a simulation argument.

Definition 9

(Simulatable). We say a sub-protocol
SP is simulatable using auxiliary algorithm Aux and helper
algorithms {HI(cid:96), HR(cid:96)} if, for all (cid:96), HIAux(sk,·)
(pk, π, m) =
SP.AlgI(cid:96)(sk, pk, π, m) and HRAux(sk,·)
(pk, π, m) = SP.AlgR(cid:96)
(sk, pk, π, m).

(cid:96)

(cid:96)

Definition 10

(Freshly simulatable). We say that
auxiliary algorithm Aux and helper algorithms {HI(cid:96), HR(cid:96)}
provide a fresh simulation of SP under condition Φ if Deﬁni-
tion 9 is satisﬁed and, for all A ∈ {HI(cid:96), HR(cid:96)}, there exist no
inputs to A that cause A to make a call Aux(·, x) such that
Φ(x) = 1.

Theorem 2

(Multi-ciphersuite composition).

Let NP(cid:107) (cid:126)SP be a multi-ciphersuite ACCE protocol. Let (cid:126)Aux
be a vector of auxiliary algorithms and let (cid:126)Φ be a vector of
conditions. Suppose that:

(cid:96)

, HRd,c

1. for all c, d ∈ [nSP], d (cid:54)= c, there exist helper algorithms
(cid:96) } such that Auxc and these helper algo-
{HId,c
rithms provide a fresh simulation of SPd under Φc; and
2. after observing the messages output by the negotiation
protocol, one can eﬃciently reconstruct the complete
per-session variables updated by those algorithms.
Then the algorithm B explicitly given in the proof of the
theorem is such that, for all algorithms A and for all c,
NP(cid:107)SPc,Auxc,Φc (BA) even under
Advmcs-acce-auth
key re-use across ciphersuites. Moreover, BA has at most
approximately the same running time as A.
NP(cid:107)SPc,Auxc,Φc (BA)

(A) ≤ nSPAdvacce-aenc-aux
for all c, even under key re-use across ciphersuites.

(A) ≤ nSPAdvacce-auth-aux

Similarly, Advmcs-acce-aenc

NP(cid:107) (cid:126)SP,c

NP(cid:107) (cid:126)SP,c

Moreover, analogous versions of the theorem apply for

server-only authentication.

Proof. We will specify an algorithm B that uses A.
Whenever A breaks authentication or channel security for
ciphersuite c∗ in the multi-ciphersuite ACCE experiment for
multi-ciphersuite ACCE protocol NP(cid:107) (cid:126)SP, the algorithm BA
will, with probability 1/| (cid:126)SP|, break authentication or channel
security in the ACCE with auxiliary oracle experiment for
the ACCE protocol NP(cid:107)SPc∗ .
Let A be an adversary in the multi-ciphersuite ACCE
experiment. Recall that A starts the experiment by setting
key re-use variables δi,{c,d}, which is 1 if party Pi is to re-use
long-term keys between SPc and SPd, namely if SPc.KeyGen =
SPd.KeyGen and party Pi is to set ski,c = ski,d; δi,{c,d} = 0
otherwise.
Algorithm B simulates an multi-ciphersuite ACCE experi-
ment for NP(cid:107) (cid:126)SP as follows. First, B chooses ˆc $← {1, . . . , nSP}.
B interacts with a challenger for the ACCE experiment for
NP(cid:107)SPˆc with auxiliary oracle Auxˆc.
B obtains the parties’ public keys for sub-protocol c from
the NP(cid:107)SPˆc experiment. For each party Pi and each sub-
protocol d, if δi,{c,d} = 1 then B sets party Pi’s public key
for sub-protocol d equal to its public key in sub-protocol c,
otherwise it generates a fresh key pair using SPd.KeyGen. B
gives all of these public keys to A.
B now runs A. A can make any Send, Corrupt, Reveal,
Encrypt, or Decrypt queries speciﬁed in the multi-ciphersuite
ACCE experiment. B needs to answer all of these. The basic
idea of B’s simulation is as follows.
B will start oﬀ every session by relaying it down to the
challenger for the ACCE-security of NP(cid:107)SPˆc with auxiliary
oracle. If a session ends up negotiating sub-protocol c, then
B continues relaying all queries for that session to the NP(cid:107)SPˆc
challenger.
If a session ends up negotiating a sub-protocol d other
than ˆc, B needs to simulate it. It can do so as follows. By
pre-condition 2 of the theorem, it can reconstruct the per-
session variables used by the negotiation protocol in the
challenger, so it can construct its own per-session variables
from the output of the negotiation protocol. If the query is
directed towards a party Pi such that Pi is using the same
key for sub-protocols ˆc and d (i.e., if δi,{c,d} = 1), then B
simulates the session for party Pi using the helper algorithms
{HId,ˆc
(cid:96) } for SPd using the auxiliary oracle Aux of the
challenger; by pre-condition 1 of the theorem, this provides
a correct simulation of NP(cid:107)SPd. If δi,{ˆc,d} = 0, then B can
simulate the session for party Pi itself since it generated Pi’s
secret key for this sub-protocol.

, HRd,ˆc

(cid:96)

378For parties and sessions where B relayed the complete
session to the challenger, B also relays the Corrupt, Reveal,
Encrypt, and Decrypt queries to the challenger; otherwise B
answers them itself.
B’s simulation of the multi-ciphersuite ACCE experiment
for NP(cid:107) (cid:126)SP to A is perfect.
Suppose A breaks authentication in NP(cid:107) (cid:126)SP. In particular,
there exists in the multi-ciphersuite ACCE experiment some
c∗ ∈ [nSP] and some session πs
i that has accepted maliciously
for sub-protocol c∗ with peer identiﬁer j, but there is no
unique session πt
j (in the multi-ciphersuite ACCE experiment)
with which πs
i has a matching session. With probability
1/nSP, ˆc = c∗. In this case, there correspondingly exists in
the ACCE-aux challenger a session πs
i that has accepted with
peer identiﬁer j but there is no unique session πt
j (in the
ACCE-aux challenger) with which πs
i has had a matching
session. Note in particular that B has not violated the
condition Φc∗ for NP(cid:107)SPc∗ because SPd is freshly simulatable
under Φc∗ due to pre-condition 1 of the theorem. Thus B
has caused a session in the ACCE-aux challenger to accept
maliciously, and thus has broken authentication in NP(cid:107)SPc∗ .
Hence, Advmcs-acce-auth

(A) ≤ nSPAdvacce-auth-aux

NP(cid:107)SPc∗ ,Auxc∗ ,Φc∗ (BA).

NP(cid:107) (cid:126)SP,c∗

Similarly, if A breaks channel security of NP(cid:107) (cid:126)SP by answer-
ing the encryption challenge correctly, then with probability
1/nSP B can answer its encryption challenge correctly and
break the channel security of NP(cid:107)SPc∗ . Note that B has not
made any prohibited queries in the channel security deﬁni-
tion: Reveal queries that would have made the ACCE chal-
lenger unfresh also would have made the multi-ciphersuite
ACCE experiment unfresh; and similarly to the authentica-
tion case above, B has not violated the condition Φc∗ . Hence,
Advmcs-acce-aenc

(A) ≤ nSPAdvacce-aenc-aux

NP(cid:107)SPc∗ ,Auxc∗ ,Φc∗ (BA).

NP(cid:107) (cid:126)SP,c∗

This yields the result. Note the same reasoning yields the

results for server-only authentication.

7. SSH IS MULTI-CIPHERSUITE SECURE
In order to use the composition theorem to show that
signed-Diﬃe–Hellman SSH ciphersuites are multi-ciphersuite
secure, even with re-use of long-term keys across ciphersuites,
we need to deﬁne the auxiliary algorithm Aux and the condi-
tion Φ, show that the preconditions of Theorem 2 are satisﬁed,
and show that individual ciphersuites are ACCE-secure with
Aux.

Let SSHc denote a ciphersuite of SSH, using signature
scheme SIGc. Recall from Section 4 that both the initia-
tor and responder use the long-term signing key as follows.
First, they compute the session ID as a hash of a session
identiﬁcation string and the shared secret:
π.sid ← Hc(VC(cid:107)VS(cid:107)KEXINIT(cid:107)KEXREPLY(cid:107)pkd(cid:107)e(cid:107)f(cid:107)K) . (1)
Finally, they compute a signature σ ← SIGc.Sign(sk, π.sid).
(If Sign is a hash-then-sign scheme, this means that the ses-
sion identiﬁcation string is hashed twice.) Recall further that
KEXINIT and KEXREPLY contain the initiator and responder’s
respective preference-ordered list of ciphersuites. (These are
actually separate lists for key exchange, compression, signa-
ture, MAC, and symmetric encryption algorithms, but from
these we can infer a ciphersuite.)

We deﬁne the auxiliary algorithm Auxc(sk, x) as com-
puting SIGc.Sign(sk, Hc(x)). For a ciphersuite c, we deﬁne
Φc(x) = 1 if, when x is parsed as in (1) and the ordered
ciphersuite preferences (cid:126)spC and (cid:126)spS are parsed from KEXINIT

and KEXREPLY, c = neg( (cid:126)spC , (cid:126)spS); in other words, if c is the
ciphersuite that is mutually most preferred by the initiator
and responder.
7.1 Preconditions of composition theorem

It is straightforward to show that signed-DH SSH cipher-
suites satisfy precondition 1 (freshly simulatable under the
condition) and precondition 2 (reconstruction of per-session
variables after negotiation) of Theorem 2. We sketch an
argument of this; the formal version is omitted due to space.
Consider two diﬀerent signed-DH SSH ciphersuites SSHc
and SSHd. Precondition 1 can be seen by constructing helper
algorithms {HI(cid:96), HR(cid:96)} that, with access to the above auxil-
iary algorithm Auxc for SSHc deﬁned above, perfectly simu-
late the signed-DH ciphersuite and showing that these helper
algorithms provide a fresh simulation of SSHd under the above
condition Φc. These helper algorithms are exactly the al-
gorithms described in Section 4, except that constructions
of signatures by hashing the session string and then using
the signature scheme’s Signc algorithm are replaced with
calls to the auxiliary oracle Aux which implements the above
algorithm Auxc. Moreover, these helper algorithms for SSHd
do not violate condition Φc for SSHc because Φc for SSHc only
outputs 1 if the input Vc(cid:107)Vs(cid:107)KEXINIT(cid:107)KEXREPLY(cid:107)pkd(cid:107)e(cid:107)f(cid:107)K
to Auxc is such that neg( (cid:126)spC , (cid:126)spS) = c. However, the helper
algorithms will only make queries where the ﬁrst mutual
ciphersuite is d (cid:54)= c. Thus, the helper algorithms for SSHd
provide a fresh simulation of SSHd using auxiliary algorithm
Auxc under condition Φc.

Precondition 2 requires that there exists an eﬃcient algo-
rithm that, after observing the messages output by the ne-
gotiation protocol, can reconstruct the complete per-session
variables at that point in time. Notice in the description of
SSH in Section 4 that the negotiation stage does not con-
struct or use any secret values—at the end of negotiation, all
variables in π are based either on the Send initialization val-
ues from A or the contents of the plaintext messages KEXINIT
or KEXREPLY.
7.2 Security of SSH with auxiliary oracle

Theorem 3

(SSH is secure w/aux. oracle).

Let SSHc be a signed-DH SSH ciphersuite with signature
scheme SIGc, hash function Hc; deﬁne Auxc and Φc as
above. Let µ be the length of the nonces in KEXINIT and
KEXREPLY (µ = 128), nP the number of participating parties
and nS the maximum number of sessions per party. The al-
gorithms B1, . . . ,B5 given in the proof of the lemma, are such
SSHc,Auxc,Φc (A) ≤ (nP nS )2
that, for all algorithms A, Advacce-so-auth-aux
2µ +
SSHc,Auxc,Φc (A) ≤
Hc (BA
1 ) + nP Adveuf-cma
2 ), and Advacce-so-aenc-aux
Advcr
(BA
gc,qc (BA
SSHc,Auxc,Φc (A) + nP nS
3 ) + Advprf
Advddh
Advacce-so-auth-aux
4 )
StEc (BA
1 , . . . ,BA
+Advbsae
5 have approximately the
same running time as A.

5 )(cid:1), and BA

(BA

(cid:16)

PRFc

SIGc

We obtain a bound on the server-only authentication advan-
tage; the bound on channel security proof proceeds identically
to the bound on Advacce-so-aenc

(A) in Section 5.2.

SSH

Proof of Advacce-so-auth-aux

SSHc,Auxc,Φc (A) bound. Games 0, 1, and

(A).

2 proceed exactly as in the bound on Advacce-so-auth

SSH

Game 0. The game equals the multi-ciphersuite ACCE

security experiment described in Section 3.2.

379Game 1. In this game we proceed identically to Game 1
(A), adding an abort rule for

in the bound on Advacce-so-auth
non-unique nonces, and get the same result.

SSH

Game 2. In the next two games we will exclude adver-
sarial modiﬁcations of all messages (KEXINIT to KEXDH INIT)
by using a successful adversary to either output a hash colli-
sion (in this game) or a signature forgery (next game). In
this game we proceed exactly as Game 2 in the bound on
(A), adding an abort rule for hash collisions,
Advacce-so-auth
and get the same result.

SSH

SSH

Game 3. In this game we ensure an adversary cannot use
signature forgery to make some session accept maliciously. If
the session πs∗
i∗ maliciously accepts in the sense of Deﬁnition 5,
we know from the discussion in the proof for the bound on
(A) that A has modiﬁed at least one of the key
Advacce-so-auth
exchange messages and computed a valid signature σ(cid:48) over
the hash of the correspondingly modiﬁed session string. In
order to do this, either A has computed a valid signature
itself, or A has utilised the auxiliary signing algorithm (for
the negotiated ciphersuite c) Auxc to compute a hash and
signature on the modiﬁed session string. In order for the
ACCE-with-auxiliary-oracle experiment to remain fresh, for
all x that A queries to Auxc, we must have that Φc(x) = 0;
in particular, when x is parsed as a session string as given in
equation (1), the negotiated ciphersuite neg( (cid:126)spC , (cid:126)spS) (cid:54)= c.
But all sessions that accept have negotiated ciphersuite equal
to c, and thus no query to the auxiliary oracle helps make
any session accept maliciously. We now embed a euf-cma
signature challenger, receive a public key pk, guess the public-
key pkj∗ the oracle will use for signature veriﬁcation, (again
costing our reduction by a factor of nP ) and replace pk with
pkj∗. We know any maliciously accepting oracle has veriﬁed
a signature σ(cid:48) over a session string where there exists no
other oracle πt∗
j∗ with the same session string. Thus σ(cid:48) was
generated by the adversary, and we can forward (sid(cid:48),σ(cid:48)) as
a signature forgery to the euf-cma signature challenger, and
we get: Pr(break(0)) ≤ Pr(break(0)

3 ) + nP Adveuf-cma

(BA
2 ).

SIGc

Final analysis. After Game 3, all of the server’s relevant
key-exchange messages are authenticated via the signature
σS, and since Game 3 aborts when a session accepts mali-
ciously, consequently we have Pr(break(0)

3 ) = 0.

7.3 Final result: Multi-ciphersuite SSH

Combining Theorem 3 from the previous subsection with
the composition theorem (Theorem 2) immediately yields
that the SSH protocol is multi-ciphersuite secure, even with
key re-use across ciphersuites.

Corollary 1

(SSH is multi-ciphersuite secure).
Let (cid:126)SSH be the multi-ciphersuite SSH protocol with each of the
nSP ciphersuites SSHc being a signed-Diﬃe–Hellman cipher-
suite as in Section 4. The algorithms B1, . . . , B5 inferred
from the proof are such that, for all algorithms A:

Advmcs-acce-so-auth

(cid:126)SSH,c

(A) ≤ nSP

(cid:18) (nP nS)2

2µ

(cid:17)
Hc (BA
+ Advcr
1 )
(BA
2 )

SIGc

,

+ nP Adveuf-cma

·(cid:16)

Advmcs-acce-so-aenc
gc,qq (BA

(cid:126)SSH,c
Advddh

(A) ≤ Advmcs-acce-so-auth
3 ) + Advprf

(BA

(cid:126)SSH,c

PRFc

(A) + nSPnP nS

4 ) + Advbsae

StEc (BA
5 )

,

(cid:17)

1 , . . . , BA

and BA
5 have approximately the same running time
as A. Moreover, analogous versions of the theorem apply for
mutual authentication.
8. DISCUSSION

Although we encountered some challenges in proving the
ACCE-security of SSH, overall SSH seemed somewhat eas-
ier to prove secure compared with the proofs of signed-DH
ciphersuites in TLS [20]. As in both cases, mutual authenti-
cation comes from digital signatures, but in SSH the object
that is signed is the (hash of the) session identiﬁer which is
a signiﬁcant portion of the transcript, whereas in TLS only
the ephemeral keys are signed. This means the security guar-
antees from verifying the signature in SSH more readily lead
to the proof of entity authentication for the whole session.
Another nice consequence of how SSH uses signatures is
that it enabled us to readily prove multi-ciphersuite secu-
rity. Even though long-term signing keys may be used by
multiple ciphersuites, in every case the object that is signed
uniquely identiﬁes the ciphersuite it is intended to be used
for. This reinforces the importance of the long-held cryp-
tographic wisdom of ‘signing what you mean to sign’. Our
multi-ciphersuite composition framework precisely captures
Anderson and Needham’s [3] principle 3 on protocol design:
“Be careful when signing or decrypting data that you never
let yourself be used as an oracle by your opponent.”

It is instructive to examine the TLS cross-ciphersuite at-
tack in the context of our multi-ciphersuite framework: the
full version of this paper [8] describes the attack of Mavro-
giannopoulos et al. [28] in more detail and the conditions of
our composition theorem that TLS does not satisfy. Mavro-
giannopoulos et al. suggested including the ciphersuite and
handshake transcripts in what is signed in TLS as a coun-
termeasure.
If future versions of TLS do indeed do this,
for example moving the server signature to just before the
server’s Finished message and including the complete tran-
script, then it should be straightforward to adapt existing se-
curity analyses of TLS. Moreover, such an adaptation should
easily have a proof of single-ciphersuite security even with
an auxiliary signing oracle, at which point our composition
theorem can readily be applied to yield multi-ciphersuite se-
curity. With discussions for a new version of TLS beginning
on the IETF’s mailing list, we hope that TLS 1.3 will indeed
incorporate this suggestion.
Acknowledgements
The authors gratefully acknowledge helpful discussions with
Tibor Jager. The research leading to these results has re-
ceived funding from the European Community (FP7/2007-
2013) under grant agreement number ICT-2007-216646—
European Network of Excellence in Cryptology II (ECRYPT
II), the Australian Technology Network–German Academic
Exchange Service (ATN-DAAD) Joint Research Co-operation
Scheme, and the Australian Research Council (ARC) Dis-
covery Project scheme under grant DP130104304.
9. REFERENCES
[1] M. R. Albrecht, K. G. Paterson, and G. J. Watson. Plaintext
recovery attacks against SSH. In 2009 IEEE Symposium on
Security and Privacy, pages 16–26. IEEE Computer Society
Press, May 2009.

[2] J. Alves-Foss. Multi-protocol attacks and the public key

infrastructure. In Proc. 21st National Information Systems
Security Conference, pages 566–576, October 1998.

380[3] R. J. Anderson and R. M. Needham. Robustness principles

for public key protocols. In D. Coppersmith, editor,
CRYPTO’95, volume 963 of LNCS, pages 236–247. Springer,
Aug. 1995.

[4] S. Andova, C. Cremers, K. Gjøsteen, S. Mauw, S. F.

Mjølsnes, and S. Radomirovi´c. A framework for
compositional veriﬁcation of security protocols. Information
and Computation, 206:425–459, 2008.

[5] G. Bela and I. Ignat. Verifying the independence of security
protocols. In Proc. 2007 IEEE International Conference on
Intelligent Computer Communication and Processing, pages
155–162. IEEE, 2007.

[6] M. Bellare, T. Kohno, and C. Namprempre. Breaking and

provably repairing the SSH authenticated encryption scheme:
A case study of the encode-then-encrypt-and-MAC
paradigm. ACM Transactions on Information and System
Security, 7(2):206–241, May 2004. Extended abstract
published in ACM CCS 2002.

[7] M. Bellare and P. Rogaway. Entity authentication and key
distribution. In D. R. Stinson, editor, CRYPTO’93, volume
773 of LNCS, pages 232–249. Springer, Aug. 1993.

[8] F. Bergsma, B. Dowling, F. Kohlar, J. Schwenk, and

D. Stebila. Multi-ciphersuite security of the Secure Shell
(SSH) protocol (full version). Cryptology ePrint Archive,
Report 2013/813, 2014. http://eprint.iacr.org/.

[9] K. Bhargavan, C. Fournet, M. Kohlweiss, A. Pironti, and

P.-Y. Strub. Implementing TLS with veriﬁed cryptographic
security. In 2013 IEEE Symposium on Security and Privacy,
pages 445–459. IEEE Computer Society Press, May 2013.

[10] K. Bhargavan, C. Fournet, M. Kohlweiss, A. Pironti, P.-Y.
Strub, and S. Zanella-B´eguelin. Proving the TLS handshake
secure (as it is). In J. A. Garay and R. Gennaro, editors,
CRYPTO 2014, volume 8617 of LNCS, pages 235–255.
Springer, 2014.

[11] C. Brzuska, M. Fischlin, N. P. Smart, B. Warinschi, and

S. C. Williams. Less is more: Relaxed yet composable
security notions for key exchange. International Journal of
Information Security, 12(4):267–297, August 2013.

[12] R. Canetti. Universally composable security: A new

paradigm for cryptographic protocols. In 42nd FOCS, pages
136–145. IEEE Computer Society Press, Oct. 2001.

[13] R. Canetti and H. Krawczyk. Analysis of key-exchange
protocols and their use for building secure channels. In
B. Pﬁtzmann, editor, EUROCRYPT 2001, volume 2045 of
LNCS, pages 453–474. Springer, May 2001.

[14] R. Canetti, C. Meadows, and P. Syverson. Environmental

requirements for authentication protocols. In M. Okada,
B. C. Pierce, A. Scedrov, H. Tokuda, and A. Yonezawa,
editors, Proc. Mext-NSF-JSPS Internaional Symposium on
Software Security (ISSS) – Theories and Systems, Part 9,
volume 2609 of LNCS, pages 339–355. Springer, 2002.

[15] C. J. F. Cremers. Feasibility of multi-protocol attacks. In

Proc. 1st International Conference on Availability,
Reliability, and Security (ARES) 2006, pages 287–294.
IEEE, 2006.

[16] A. Datta, A. Derek, J. C. Mitchell, and D. Pavlovic. Secure

protocol composition. Electronic Notes in Theoretical
Computer Science, 83(15), 2004.

[17] F. Giesen, F. Kohlar, and D. Stebila. On the security of TLS
renegotiation. In A.-R. Sadeghi, V. D. Gligor, and M. Yung,
editors, ACM CCS 13, pages 387–398. ACM Press, Nov.
2013.

[18] J. D. Guttman and F. J. Thayer Fabrega. Protocol

independence through disjoint encryption. In Proceedings
13th IEEE Computer Security Foundations Workshop
(CSFW-13), pages 24–34. IEEE, 2000.

[19] B. Harris. RSA Key Exchange for the Secure Shell (SSH)

Transport Layer Protocol. RFC 4432 (Proposed Standard),
Mar. 2006.

[20] T. Jager, F. Kohlar, S. Sch¨age, and J. Schwenk. On the

security of TLS-DHE in the standard model. In

R. Safavi-Naini and R. Canetti, editors, CRYPTO 2012,
volume 7417 of LNCS, pages 273–293. Springer, Aug. 2012.

[21] T. Jager, K. G. Paterson, and J. Somorovsky. One bad

apple: Backwards compatibility attacks on state-of-the-art
cryptography. In Proc. Internet Society Network and
Distributed System Security Symposium (NDSS) 2013, 2013.

[22] J. Jonsson and B. S. Kaliski Jr. On the security of RSA
encryption in TLS. In M. Yung, editor, CRYPTO 2002,
volume 2442 of LNCS, pages 127–142. Springer, Aug. 2002.
[23] J. Kelsey, B. Schneier, and D. Wagner. Protocol interactions

and the chosen protocol attack. In B. Christianson,
B. Crispo, M. Lomas, and M. Roe, editors, Proc. 5th
International Workshop on Security Protocols, volume 1361
of LNCS, pages 91–104. Springer, 1997.

[24] F. Kohlar, S. Sch¨age, and J. Schwenk. On the security of

TLS-DH and TLS-RSA in the standard model. Cryptology
ePrint Archive, Report 2013/367, 2013.
http://eprint.iacr.org/2013/367.

[25] H. Krawczyk. Cryptographic extraction and key derivation:

The HKDF scheme. In T. Rabin, editor, CRYPTO 2010,
volume 6223 of LNCS, pages 631–648. Springer, Aug. 2010.
[26] H. Krawczyk, K. G. Paterson, and H. Wee. On the security

of the TLS protocol: A systematic analysis. In R. Canetti
and J. A. Garay, editors, CRYPTO 2013, Part I, volume
8042 of LNCS, pages 429–448. Springer, Aug. 2013.

[27] B. A. LaMacchia, K. Lauter, and A. Mityagin. Stronger

security of authenticated key exchange. In W. Susilo, J. K.
Liu, and Y. Mu, editors, ProvSec 2007, volume 4784 of
LNCS, pages 1–16. Springer, Nov. 2007.

[28] N. Mavrogiannopoulos, F. Vercauteren, V. Velichkov, and

B. Preneel. A cross-protocol attack on the TLS protocol. In
T. Yu, G. Danezis, and V. D. Gligor, editors, ACM CCS 12,
pages 62–72. ACM Press, Oct. 2012.

[29] P. Morrissey, N. P. Smart, and B. Warinschi. A modular

security analysis of the TLS handshake protocol. In
J. Pieprzyk, editor, ASIACRYPT 2008, volume 5350 of
LNCS, pages 55–73. Springer, Dec. 2008.

[30] K. G. Paterson and G. J. Watson. Plaintext-dependent

decryption: A formal security treatment of SSH-CTR. In
H. Gilbert, editor, EUROCRYPT 2010, volume 6110 of
LNCS, pages 345–361. Springer, May 2010.

[31] P. Rogaway. Formalizing human ignorance. In P. Q. Nguyen,

editor, Progress in Cryptology - VIETCRYPT 06, volume
4341 of LNCS, pages 211–228. Springer, Sept. 2006.

[32] D. Stebila and J. Green. Elliptic Curve Algorithm

Integration in the Secure Shell Transport Layer. RFC 5656
(Proposed Standard), Dec. 2009.

[33] F. J. Thayer Fabrega, J. Herzog, and J. D. Guttman. Mixed
strand spaces. In Proceedings 12th IEEE Computer Security
Foundations Workshop (CSFW-12), pages 72–82, 1999.
[34] W.-G. Tzeng and C.-M. Hu. Inter-protocol interleaving

attacks on some authentication and key distribution
protocols. Information Processing Letters, 69(6):297–302,
March 1999.

[35] D. Wagner and B. Schneier. Analysis of the SSL 3.0 protocol.
In Proc. 2nd USENIX Workshop on Electronic Commerce,
1996.

[36] S. C. Williams. Analysis of the SSH key exchange protocol.

Cryptology ePrint Archive, Report 2011/276, 2011.
http://eprint.iacr.org/2011/276.

[37] T. Ylonen and C. Lonvick. The Secure Shell (SSH)

Authentication Protocol. RFC 4252 (Proposed Standard),
Jan. 2006.

[38] T. Ylonen and C. Lonvick. The Secure Shell (SSH)

Connection Protocol. RFC 4254 (Proposed Standard), Jan.
2006.

[39] T. Ylonen and C. Lonvick. The Secure Shell (SSH) Protocol

Architecture. RFC 4251 (Proposed Standard), Jan. 2006.

[40] T. Ylonen and C. Lonvick. The Secure Shell (SSH)

Transport Layer Protocol. RFC 4253 (Proposed Standard),
Jan. 2006. Updated by RFC 6668.

381