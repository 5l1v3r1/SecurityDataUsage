Password Managers: Attacks and Defenses
David Silver, Suman Jana, and Dan Boneh, Stanford University; Eric Chen and  

Collin Jackson, Carnegie Mellon University

https://www.usenix.org/conference/usenixsecurity14/technical-sessions/presentation/silver

This paper is included in the Proceedings of the 23rd USENIX Security Symposium.August 20–22, 2014 • San Diego, CAISBN 978-1-931971-15-7Open access to the Proceedings of  the 23rd USENIX Security Symposium is sponsored by USENIXPassword Managers: Attacks and Defenses

David Silver

Suman Jana Dan Boneh

Stanford University

Eric Chen Collin Jackson
Carnegie Mellon University

Abstract

We study the security of popular password managers and
their policies on automatically ﬁlling in Web passwords.
We examine browser built-in password managers, mo-
bile password managers, and 3rd party managers. We
observe signiﬁcant differences in autoﬁll policies among
password managers. Several autoﬁll policies can lead
to disastrous consequences where a remote network at-
tacker can extract multiple passwords from the user’s
password manager without any interaction with the user.
We experiment with these attacks and with techniques to
enhance the security of password managers. We show
that our enhancements can be adopted by existing man-
agers.

1

Introduction

With the proliferation of Web services, ordinary users
are setting up authentication credentials with a large
number of sites. As a result, users who want to setup
different passwords at different sites are driven to use a
password manager. Many password managers are avail-
able: some are provided by browser vendors as part of
the browser, some are provided by third parties, and
many are network based where passwords are backed up
to the cloud and synced across the user’s devices (such
as Apple’s iCloud Keychain). Given the sensitivity of
the data they manage, it is natural to study their security.
All the password managers (PMs) we examined do not
expect users to manually enter managed passwords on lo-
gin pages. Instead they automatically ﬁll-in the username
and password ﬁelds when the user visits a login page.
Third party password managers use browser extensions
to support autoﬁll.

In this paper we study the autoﬁll policies of ten pop-
ular password managers across four platforms and show
that all are too loose in their autoﬁll policies: they autoﬁll
the user’s password in situations where they should not
thereby exposing the user’s password to potential attack-
ers. The results can be disastrous: an attacker can extract
many passwords from the user’s password manager with-
out the user’s knowledge or consent as soon as the user
connects to a rogue WiFi network such as a rogue router
at a coffee shop. Cloud-based password syncing further
exacerbates the problem because the attacker can poten-
tially extract user passwords that were never used on the

device being attacked.
Our results. We study the security of password man-
agers and propose ways to improve their security.

• We begin with a survey of how ten popular pass-
word managers decide when to autoﬁll passwords.
Different password managers employ very differ-
ent autoﬁll policies, exposing their users to different
risks.

• Next, we show that many corner cases in aut-
oﬁll policies can lead to signiﬁcant attacks that en-
able remote password extraction without the user’s
knowledge, simply by having the user connect to a
rogue router at a coffee shop.

• We believe that password managers can help
strengthen credential security rather than harm it.
In Section 5 we propose ways to strengthen pass-
word managers so that users who use them are more
secure than users who type in passwords manually.
We implemented the modiﬁcations in the Chrome
browser and report on their effectiveness.

We conclude with a discussion of related work on pass-
word managers.
An example. We give many examples of password ex-
traction in the paper, but as a warm-up we present one
example here. Consider web sites that serve a login page
over HTTP, but submit the user’s password over HTTPS
(a setup intended to prevent an eavesdropper from read-
ing the password but actually leaves the site vulnerable).
As we show in Section 4, about 17% of the Alexa Top
500 websites use this setup. Suppose a user, Alice, uses
a password manager to save her passwords for these sites
At some point later, Alice connects to a rogue WiFi
router at a coffee shop. Her browser is directed to a land-
ing page that asks her to agree to the terms of service,
as is common in free WiFi hotspots. Unbeknownst to
Alice, the landing page (as shown in Figure 1) contains
multiple invisible iFrames pointing to the login pages of
the websites for which Alice has saved passwords. When
the browser loads these iFrames, the rogue router injects
JavaScript into each page and extracts the passwords aut-
oﬁlled by the password manager.

USENIX Association  

23rd USENIX Security Symposium  449

450  23rd USENIX Security Symposium 

USENIX Association

Thissimpleattack,withoutanyinteractionwiththeuser,canautomaticallyextractpasswordsfromthepass-wordmanageratarateofabouttenpasswordspersec-ond.Sixofthetenpasswordmanagersweexaminedwerevulnerabletothisattack.Fromtheuser’spointofview,shesimplyvisitedthelandingpageofafreeWiFihotspot.Thereisnovisualindicationthatpasswordex-tractionistakingplace.Figure1:AsamplelandingpageofarogueWiFihotspotcontaininginvisibleiFramestothetargetsites.NotethattheiFramesareactuallyinvisibletotheuserandshownhereonlyforclarity.2Passwordmanagers:asurveyWebeginwithadetailedsurveyoftheautoﬁllpoliciesimplementedinwidelydeployedpasswordmanagers.Thepasswordmanagerswesurveyinclude:•DesktopBrowserPMs:GoogleChrome34,Mi-crosoftInternetExplorer11,MozillaFirefox29,andAppleSafari7.•3rdPartyPMs:1Password[1],LastPass[5],Keeper[7],NortonIdentitySafe[6],andKeeP-ass[4].AllofthesebesidesKeePassprovidebrowserextensionsthatsupportpasswordﬁeldaut-oﬁll.•iOSPMs:MobileSafari’spasswordmanagersyncswiththedesktopversionofSafarithroughApple’siCloudKeychainsynchronizationservice.SincemobileSafaridoesnotsupportextensions,3rdPartyPMsareseparateapplicationswiththeirownbuilt-inwebbrowser.InadditiontoMobileSafari,wesurveypasswordmanagersinGoogleChrome,1Password,andLastPassTab.•AndroidPMs:thedefaultAndroidbrowserandChrome.Allthesepasswordmanagersofferan“autoﬁll”func-tionality,whereinthepasswordmanagerautomaticallypopulatestheusernameandpasswordﬁeldswithintheuser’swebbrowser.Wedivideautoﬁllstrategiesintotwobroadcategories:•Automaticautoﬁll:populateusernameandpass-wordﬁeldsassoonastheloginpageisloadedwithoutrequiringanyuserinteraction.PasswordmanagersthatsupportautomaticautoﬁllincludeChrome(allplatforms),Firefox,Safari,LastPass,NortonIdentitySafe,andLastPassTab.•Manualautoﬁll:requiresomeuserinteractionbe-foreautoﬁlling.Typesofinteractionincludeclick-ingonortypingintotheusernameﬁeld,pressingakeyboardshortcut,orpressingabuttoninthebrowser.Passwordmanagersthatalwaysrequiremanualinteractioninclude1Password,Keeper,andKeePass.InternetExplorer11usesahybridapproach:itautomat-icallyautoﬁllspasswordsonpagesloadedoverHTTPS,butrequiresuserinteractiononpagesloadedoverHTTP.WeshowinSection4thateventhisconservativebehav-iorstillenablessomeattacks.Somepasswordmanagersrequiremanualinteractionforautoﬁllinspeciﬁcsituations:•ChromerequiresmanualinteractionifthepasswordﬁeldisinaniFrame.•ChromecanreadpasswordsstoredinMacOSX’ssystem-widekeychain,butwillnotautomaticallyautoﬁllthemuntiltheyhavebeenmanuallyselectedbytheuseratleastonce.•TheﬁrsttimeSafariorChromeonMacOSXac-cessapasswordinthesystemkeychain,asystemdialogrequestspermissionfromtheuser.Iftheuserchooses“AlwaysAllow”,thisdialogwillnotbeshownagainandthepasswordwillautomaticallyautoﬁllinthefuture.ThisdialogdoesnotappearifthepasswordwassynchronizedfromanotherdeviceusingiCloudKeychain.•LastPassandNortonIdentitySafeprovidenon-defaultconﬁgurationoptionstodisableautomaticautoﬁll.Inthispaperweonlydiscussthedefaultconﬁgurationsforthesepasswordmanagers.Platform
Mac OS X

10.9.3

Safari ext.
Safari ext.
Safari ext.
Windows
8.1 Pro
IE addon
iOS 7.1.1

Password manager
Chrome 34.0.1847.137
Firefox 29.0.1
Safari 7.0.3
1Password 4.4
LastPass 3.1.21
Keeper 7.5.26
IE 11.0.9600.16531
KeePass 2.24
IdentitySafe 2014.7.0.43 Auto
Auto
Mobile Safari
Manual
1Password 4.5.1
Auto
LastPass Tab 2.0.7
Auto
Chrome 34.0.1847.18
Android 4.3 Chrome 34.0.1847.114
Auto
Auto

Android Browser

Same
protocol
and action
Auto
Auto
Auto
Manual
Auto
Manual
Auto/Man
Manual

Different
protocol
No Fill
No Fill
No Fill
Manual
Manual
Manual
No Fill
Manual
Auto
No Fill
Manual
Manual
No Fill
No Fill
No Fill

Different
form action
on load
Manual
None
Auto
Manual
Warning
Manual
Auto/Man
Manual
Auto
Auto
Manual
Auto
No Fill
No Fill
Auto

Different
form action
on submit
Auto
Auto
Auto
Manual
Auto
Manual
Auto/Man
Manual
Auto
Auto
Manual
Auto
Auto
Auto
Auto

auto-
Broken
complete
HTTPS
= “oﬀ”
No Fill
Auto
Auto
No Fill
Auto
Auto
Manual
Manual
Auto
Auto
Manual
Manual
Auto/Man Manual
Manual
Manual
Auto
Auto
Auto
No Fill
Manual
Manual
Auto
Auto
Auto
No Fill
Auto
No Fill
Auto
No Fill

Table 1: Password Manager autoﬁll behavior (automatic autoﬁll, manual autoﬁll, or no ﬁll), depending on the protocol
(http/https), autocomplete attribute, form action used on the current page relative to the protocol, and form action used
when the password was saved. Manual autoﬁlling refers to autoﬁlling a password after some user interaction, such as
a click or tap on one of the form ﬁelds. No ﬁll means that no autoﬁlling of passwords takes place. The second to last
column refers to autoﬁll behavior when the password ﬁeld’s autocomplete attribute is set to “off”. The last column
refers to autoﬁll behavior for a login page loaded over a bad HTTPS connection.

2.1 Autoﬁll policies

Next, we ask what happens when the PM is presented
with a login page that is slightly different from the login
page at the time the password was saved. Should the PM
apply autoﬁll or not? Different PMs behave differently
and we survey the different policies we found. Table 1
summarizes some of our ﬁndings.
The domain and path. All password managers we
tested allow passwords to be autoﬁlled on any page
within the same domain as the page from which the pass-
word was originally saved. For example, a password
originally saved on https://www.example.com/aaa.
php would be ﬁlled on https://www.example.com/
bbb.php. This allows autoﬁll to function on sites that
display the login form on multiple pages, such as in a
page header visible on all pages. It also allows autoﬁll
after a site redesign that moves the login form.

This feature means that an attacker can attack the
password manager (as in Section 4) on the least-secure
page within the domain.
It also means that two sites
hosted on the same domain (ie, example.edu/~jdoe
and example.edu/~jsmith) are treated as a single site
by the password manager.
Protocol: HTTP vs. HTTPS. Suppose the password
was saved on a login page loaded over one protocol (say,

HTTPS), but the current login page is loaded over a
different protocol (say, HTTP)? All other elements of
the URL are the same, including the domain and path.
Should the password manager autoﬁll the password on
the current login page?

Chrome, Safari, Firefox, and Internet Explorer all
refuse to autoﬁll if the protocol on the current login page
is different from the protocol at the time the password
was saved. However, 1Password, Keeper, and LastPass
all allow autoﬁll after user interaction in this case. Note
that LastPass normally uses automatic autoﬁll, so this
downgrade to manual autoﬁll on a different protocol was
implemented as a conscious security measure. Norton
IdentitySafe does not pay attention to the protocol. It au-
tomatically autoﬁlls a password saved under HTTPS on
a page served by HTTP. As we show later on, any form
of autoﬁlling, manual or not, is dangerous on a protocol
change.
Modiﬁed form action. A form’s action attribute spec-
iﬁes where the form’s contents will be sent to upon sub-
mission.

<form action="example.com" method="post">

One way an attacker can steal a user’s password is to
change the action on the login form to a URL under the

USENIX Association  

23rd USENIX Security Symposium  451

attacker’s control. Therefore, one would expect pass-
word managers to not autoﬁll a login form if the form’s
action differs from the action when the password was
ﬁrst saved.

We consider two different cases. First, suppose that
at the time the login page is loaded the form’s action
ﬁeld points to a different URL than when the pass-
word was ﬁrst saved. Safari, Norton IdentitySafe and
IE (on HTTPS pages) nevertheless automatically autoﬁll
the password ﬁeld. Desktop Chrome and IE (on HTTP
pages) autoﬁll after some manual interaction with the
user. LastPass asks for user conﬁrmation before ﬁlling
a form whose action points to a different origin than the
current page.

Second, suppose that at the time the login page is
loaded the form’s action ﬁeld points to the correct URL.
However, JavaScript on the page modiﬁes the form ac-
tion ﬁeld so that when the form is submitted the data is
sent to a different URL. All of the password managers
we tested allow an autoﬁlled form to be submitted in this
case even though the password is being sent to the wrong
location. We discuss the implications of this in Section 4
and discuss mitigations in Section 5.

Password managers without automatic autoﬁll require
user interaction before ﬁlling the form, but none give
any indication to the user that the form’s action does not
match the action when the credentials were ﬁrst saved.
Since a form’s action is normally not visible to the user,
there is no way for the user to be sure that the form was
submitting to the place the user intended.

The effects of the action attribute on autoﬁll behavior

is captured in the third and fourth columns of Table 1.
Autocomplete attribute A website can use the auto-
complete attribute to suggest that autocompletion be dis-
abled for a form input [3]:

<input autocomplete="off" ... >

We ﬁnd that Firefox, Mobile Safari, the default An-
droid Browser, and the iOS version of Chrome respect
the autocomplete attribute when it is applied to a pass-
word input. If a password ﬁeld has its autocomplete at-
tribute set to “off”, these password managers will neither
ﬁll it nor offer to save new passwords entered into it. All
of the other password managers we tested ﬁll the pass-
word anyway, ignoring the value of the autocomplete at-
tribute. LastPass ignores the attribute by default, but pro-
vides an option to respect it.

Once the password manager contains a password for a
site, the autocomplete attribute does not affect its vulner-
ability to the attacks presented in this paper. As described

in Section 4, in our setting, the attacker controls the net-
work and can modify the login form to turn the password
input’s autocomplete attribute on even if the victim web-
site turns it off.

In supporting browsers, the autocomplete attribute can
be used to prevent the password from being saved at all.
This trivially defends against our attacks, as they require
a saved password. However, it is not a suitable defense in
general due to usability concerns. A password manager
that doesn’t save or ﬁll passwords will not be popular
amongst users.
Broken HTTPS behavior. Suppose the password was
saved on a login page loaded over a valid HTTPS con-
nection, but when visiting this login page at a later time
the resulting HTTPS session is broken, say due to a bad
certiﬁcate. The user may choose to ignore the certiﬁcate
warning and visit the login page regardless. Should the
password manager automatically autoﬁll passwords in
this case? The desktop and Android versions of Chrome
refuse to autoﬁll passwords in this situation. IE down-
grades from automatic to manual autoﬁll. All other pass-
word managers we tested autoﬁll passwords as normal
when the user clicks through HTTPS warnings. As we
will see, this can lead to signiﬁcant attacks.
Modiﬁed password ﬁeld name. All autoﬁlling pass-
word managers, except for LastPass, autoﬁll passwords
even when the password element on the login page has a
name that differs from the name present when the pass-
word was ﬁrst saved. Autoﬁlling in such situations can
lead to “self-exﬁltration” attacks, as discussed in Sec-
tion 5.2.1. LastPass requires manual interaction before
autoﬁlling a password in a ﬁeld whose name is different
from when the password was saved.
2.2 Additional PM Features

Several password managers have the following secu-

rity features worth mentioning:
iFrame autoﬁll. Norton IdentitySafe, Mobile Safari
and LastPass Tab do not autoﬁll a form in an iFrame that
is not same-origin to its parent page. Desktop Chrome re-
quires manual interaction to autoﬁll a form in an iFrame
regardless of origin. Chrome for iOS and the Android
browser will never autoﬁll an iFrame. Firefox, Safari,
and Chrome for Android automatically autoﬁll forms in
iFrames regardless of origin.

Safari and Mobile Safari will only autoﬁll a single lo-
gin form per top-level page load. If a page, combined
with all of its iFrames, has more than one login form,
only the ﬁrst will be autoﬁlled.

We discuss the impact of these policies on security in

Section 4.

452  23rd USENIX Security Symposium 

USENIX Association

Visibility. Norton IdentitySafe does not automatically
autoﬁll a form that is invisible because its CSS display
attribute is set to “none” (either directly or inherited from
a parent). However, it will automatically autoﬁll a form
with an opacity of 0. Therefore, this defense does not
enhance security.
Autoﬁll method. KeePass is unique amongst desktop
password managers in that it does not integrate directly
with the browser. Instead, it can “autotype” a sequence
of keystrokes into whatever text ﬁeld is active. For most
login forms, this means it will type the username, the
Tab key, the password, then the Enter key to populate
and submit the form.
Autoﬁll and Submit.
1Password, LastPass, Norton
IdentitySafe, and KeePass provide variants of “autoﬁll
and submit” functionality, in which the password man-
agers not only autoﬁlls a login form but also automati-
cally submits it. This frees the user from interacting with
the submit button of a login form and thus makes autoﬁll
more convenient for the user.

3 Threat Model

In the next section we present a number of attacks
against password managers that extract passwords from
all the managers we examined. First, we deﬁne the at-
tackers capabilities and goals. We only consider active
man-in-the-middle network attackers i.e. we assume that
the adversary can interpose and modify arbitrary network
trafﬁc originating from or destined to the user’s machine.
However, unlike standard man-in-the-middle attacks, we
do not require the user to log into any target websites in
the presence of the attacker. Instead, the setup consists
of two phases:

First, the user logs in to a number of sites and the at-
tacker cannot observe or interfere with these logins. The
user’s password manager records the passwords used for
these logins. For password managers that support sync-
ing of stored passwords across multiple machines (e.g.,
Apple’s iCloud KeyChain), users may even carry out this
step on an altogether different device from the eventual
victim device.

At a later time the user connects to a malicious net-
work controlled by the attacker, such as a rogue WiFi
router in a coffee shop. The attacker can inject, block,
and modify packets and its goal is to extract the pass-
words stored in the user’s password manager without any
action from the user.

We call this type of attacker the evil coffee shop at-
tacker. These attacks require only temporary control of a
network router and are much easier and thus more likely

to happen in practice. We show that even such weak
man in the middle attackers can leverage design ﬂaws in
password managers to remotely extract stored passwords
without the user logging into any website.

The attacker has no software (malware) installed on
the user’s machine. We only assume the presence of
a password manager acting in the context of a web
browser.

4 Remote extraction of passwords from

password managers

We show that an evil coffee shop attacker can extract
passwords stored in the user’s password manager.
In
many of our attacks the user need not interact with the
victim web site and is unaware that password extraction
is taking place. We discuss defenses in Section 5.
4.1 Sweep attacks

Sweep attacks take advantage of automatic password
autoﬁll to steal the credentials for multiple sites at once
without the user visiting any of the victim sites. For
password managers backed by a syncing service (such
as Apple’s iCloud Keychain) the attacker can extract site
passwords even if the user never visited the site on that
device. These attacks work in password managers that
support automatic autoﬁll, highlighting the fundamental
danger of this feature.

Sweep attacks consist of three steps. First, the attacker
makes the user’s browser visit an arbitrary vulnerable
webpage at the target site without the user’s knowledge.
Next, by tampering with network trafﬁc the attacker in-
jects JavaScript code into the vulnerable webpage as it is
fetched over the network using one of the methods de-
scribed in Section 4.2. Finally, the JavaScript code exﬁl-
trates passwords to the attacker using the techniques in
Section 4.3.

In the sweep attacks we implemented, the user con-
nects to a WiFi hotspot controlled by the attacker. When
the user launches the browser, the browser is redirected
to a standard hotspot landing page asking for user con-
sent to standard terms of use. This is common behavior
for public hotspots. Unbeknownst to the user, however,
the landing page contains invisible elements that imple-
ment the attack.
iFrame sweep attack. Here the innocuous hotspot
landing page contains invisible iFrames pointing to the
arbitrary pages at multiple target sites. When the browser
loads these iFrames, the attacker uses his control of the
router to inject a login form and JavaScript into each
iFrame using the methods described in Section 4.2. As
we will see, injecting a login form and JavaScript is not

USENIX Association  

23rd USENIX Security Symposium  453

difﬁcult and can be done in several different ways. All
that is needed is some vulnerable page on the target site.
It is especially easy for sites that serve their login page
over HTTP (but submit passwords over HTTPS), which
is a common setup discussed in the next section.

As each iFrame loads, the password manager will au-
tomatically populate the corresponding password ﬁeld
with the user’s password. The injected JavaScript in each
iFrame can then steal and exﬁltrate these credentials.

Our experiments show that this method can extract
passwords, unbeknownst to the user, at a rate of about ten
passwords per second. To prevent the user from clicking
through the landing page before the attacks are done, the
landing page includes a JavaScript animated progress bar
that forces the user to wait until the attacks complete.

We also ﬁnd that the password extraction process can
be made more efﬁcient by arranging the iFrames in a
hierarchical structure instead of adding one iFrame to
the top-level page for each target website. Adding all
the iFrames to the top-level page would create large in-
creases in both the amount of trafﬁc on the network and
the amount of memory used by the victim’s browser. Hi-
erarchical arrangement of the iFrames can avoid such is-
sues. The top-level iFrame contains most of the code
for the attack and dynamically spawns child frames and
navigates them to the target pages. This technique al-
lows the iFrames to load asynchronously and thus en-
sures that network and memory usage remain reasonable
for the duration of the attack.

Chrome (all platforms) is the only automatic autoﬁll
password manager that is not vulnerable to the iFrame-
based attack, because they never automatically autoﬁll
passwords in iFrames. All the other automatic autoﬁll
password managers are vulnerable to this attack. Even
though the autoﬁll policies of Norton IdentitySafe, Sa-
fari, Mobile Safari, and LastPass Tab described in Sec-
tion 2.2 restrict the number of passwords that can be
stolen in a single sweep to 1, they remain vulnerable.
Window sweep attack. A variant of the sweep attack
uses windows instead of invisible iFrames. If the attacker
can trick users into disabling their popup blocker (e.g.,
by requiring a window to open before the user can gain
access to the WiFi network), the landing page can open
each of the victim pages in a separate window. This is
more noticeable than the iFrame-based approach, but the
JavaScript injected into each victim page can disguise
these windows to minimize the chances of detection.
Techniques for disguising the windows include minimiz-
ing their size, moving them to the edge of the screen,
hiding the pages’ contents so that they appear to the user
as blank windows, and closing them as soon as the pass-

word has been stolen.

Nearly all automatic autoﬁll password managers, in-
cluding desktop Chrome, are vulnerable to the window-
based attack. Only LastPass Tab is not vulnerable, as it
does not support popup windows at all. Hence, although
iFrames make the sweep attack easier, they are not re-
quired.
Redirect sweep attack. A redirect sweep attack en-
ables password extraction without any iFrames or sepa-
rate windows. In our implementation, once the user con-
nects to a network controlled by the attacker and requests
an arbitrary page (say, a.com), the network attacker re-
sponds with an HTTP redirect to some vulnerable page
on the target site (say, b.com). The user’s browser re-
ceives the redirect and issues a request for the page at
b.com. The attacker allows the page to load, but injects a
login form and JavaScript into the page, as described in
Section 4.2. The injected JavaScript disguises the page
(for example, by hiding its body) so that the user does
not see that b.com is being visited.

When the user’s browser loads the page from b.com,
the vulnerable password manager will automatically aut-
oﬁll the login form with the credentials for b.com, which
the injected JavaScript can then exﬁltrate. Once done,
the injected JavaScript redirects the user’s browser to the
next victim site, (say c.com) and exﬁltrates the user’s
password at c.com in the same way. When sufﬁciently
many passwords have been exﬁltrated the attacker redi-
rects the user’s browser to the original page requested by
the user (a.com).

This attack leaves small indications that password ex-
traction took place. While the attack is underway the
user’s address bar will display the address of the attacked
site, and the attacked site will remain in the user’s his-
tory. However, as long as the body of the page itself is
disguised, most users will not notice these small visual
clues.

All of the automatic autoﬁll password managers we

tested were vulnerable to this attack.
Summary. Table 2 describes which password man-
agers are vulnerable to these sweep attacks.
Attack ampliﬁcation via password sync. Most pass-
word managers offer services that synchronize users’
passwords between different devices. These password
synchronization services can potentially result in pass-
word extraction from devices without them ever having
visited the victim site.

Suppose the user’s password manager syncs between
their desktop and tablet, and will automatically autoﬁll
a password synced from another device without user in-

454  23rd USENIX Security Symposium 

USENIX Association

Platform
Mac OS X 10.9.3

Safari ext.
Safari ext.
Safari ext.
Windows 8.1 Pro

IE addon
iOS 7.1.1

Android 4.3

Password Manager
Chrome 34.0.1847.137
Firefox 29.0.1
Safari 7.0.3
1Password 4.4
LastPass 3.1.21
Keeper 7.5.26
Internet Explorer 11.0.9600.16531
KeePass 2.24
Norton IdentitySafe 2014.7.0.43
Mobile Safari
1Password 4.5.1
LastPass Tab 2.0.7
Chrome 34.0.1847.18
Chrome 34.0.1847.114
Android Browser

iFrame sweep Window sweep Redirect sweep

+

Single

+

+
+
+

+

+
+
+

+

HTTPS

HTTPS

HTTPS

SO

Single, SO

SO

+
+

+
+
+

+
+

+
+
+
+

Table 2: Vulnerability to sweep attacks. + indicates vulnerability without restriction. HTTPS indicates vulnerability
only on pages served over HTTPS. Single indicates a single site is vulnerable per top-level page load. SO indicates
vulnerability when the page containing the iFrame is same-origin with the target page in the iFrame.

teraction. Suppose further that the site c.com is vulner-
able to network attacks and thus to the attacks described
above. The user is careful and only ever visits c.com on
their desktop, which never leaves the user’s safe home
network. However, when the user connects their tablet to
the attacker’s WiFi network at a coffee shop, the attacker
can launch a sweep attack on the user’s tablet and extract
the user’s password for c.com even though the user has
never visited c.com on their tablet.

We tested Apple’s iCloud Keychain, Google Chrome
Sync, Firefox Sync, and LastPass Tab, and found all of
them to be vulnerable to this attack. In general, any pass-
word manager that automatically autoﬁlls a password
synced from another device will be vulnerable to this
type of attack ampliﬁcation. Therefore, the security of
any password manager is only as strong as the security
of the weakest password manager it syncs with.
4.2

Injection Techniques

Sweep attacks rely on the attacker’s ability to modify a
page on the victim site by tampering with network trafﬁc.
The attacks are simplest when the vulnerable page is the
login page itself. However, any page that is same-origin
with login page is sufﬁcient, as all password managers
associate saved passwords with domains and ignore the
login page’s path. The attacker can inject a login form
into any page in the origin of the actual login page and
launch a password extraction attack against that page.
We list a few viable injections techniques.
HTTP login page. Consider a web site that serves its
login page over HTTP, but submits the login form over

HTTPS. While this setup protects the user’s password
from eavesdropping when the form is submitted, a cof-
fee shop attacker can easily inject the required JavaScript
into the login form at the router and mount all the sweep
attacks discussed in the previous section.

Clearly serving a login form over HTTP is bad practice
because it exposes the site to SSLstrip attacks [33]. How-
ever extracting passwords via SSLstrip requires users to
actively enter their passwords while connected to the at-
tacker’s network and visiting the victim page.
In con-
trast, the sweep attacks in the previous section extract
passwords without any user interaction.

To test the prevalence of this setup — a login page
loaded over HTTP, but login form submitted over HTTPS
— we surveyed Alexa Top 500 sites (as of October
2013) by manually visiting them and examining their
login procedures. Of the 500 sites surveyed, 408 had
login forms.
71 of these 408 sites, or 17.40%, use
HTTP for loading the login page, but HTTPS for sub-
mitting it. Some well known names are on this list of 71
sites, including ask.com, godaddy.com, reddit.com,
huffingtonpost.com, and att.com.

Additionally, 123 (or 30.15%) of the sites used HTTP
both for loading the login page and for submitting it. This
setup is trivially vulnerable to eavesdropping, but a vul-
nerable password manager increases this vulnerability by
removing the need for a human to enter their password.
For the purposes of our attacks, these sites can be thought
of as an especially vulnerable subclass of sites with a lo-
gin form served over HTTP.

USENIX Association  

23rd USENIX Security Symposium  455

Passwords for all these vulnerable websites can be eas-
ily extracted from an autoﬁlling password manager using
the sweep attacks in the previous section. One could ar-
gue that all these sites need to be redesigned to load and
submit the login page over HTTPS. However, until that is
done there is a need to strengthen password managers to
prevent these attacks. We discuss defenses in Section 5.
Embedded devices I. Many embedded devices serve
their login pages over HTTP by default because the chan-
nel is assumed to be protected by a WiFi encryption
protocol such as WPA2. Indeed, Gourdin et al. report
that the majority of the embedded web interfaces still
use HTTP [26]. Similarly, internal servers in a corpo-
rate network may also serve web login pages over HTTP
because access to these servers can only be done over a
Virtual Private Network (VPN).

Sweep attacks are very effective against these devices:
the password manager autoﬁlls the password even when
the underlying network connection is insecure. By in-
jecting JavaScript into the HTTP login page as above, a
coffee shop attacker can extract passwords for embedded
devices and corporate servers that the user has previously
interacted with.
Embedded Devices II. Some home routers serve their
login pages over HTTPS, but use are self-signed certiﬁ-
cates. An attacker can purchase a valid certiﬁcate for
the same common name as the router’s [38] or generate
its own self signed certiﬁcate. When the user’s machine
connects to the attacker’s network, the attacker can spoof
the user’s home router by presenting a valid certiﬁcate for
the router’s web site. This allows the attacker to mount
the sweep attack and extract the user’s home router pass-
word.
Broken HTTPS. Consider a public site whose login
page is served over HTTPS. In Section 2 we noted that
many password managers that autoﬁll passwords auto-
matically do so even when the login page is loaded over
a broken HTTPS connection, say due to a bad certiﬁcate.
This can be exploited in our redirect sweep attack: when
the browser is redirected to the victim site, the attacker
serves the modiﬁed login page using a self signed cert
for that site. This modiﬁed login page contains a login
form and the JavaScript needed to exﬁltrate the user’s
password once it is autoﬁlled by the password manager.
These self signed certs will generate HTTPS warning
in the browser, but if the redirect sweep attack happens as
part of the process of logging on to the hotspot, the user is
motivated to click through the resulting HTTPS warning
messages. As a result the attacker can extract user pass-
words from the password manager, even for sites where

the login page is served over HTTPS.

Indeed, several prior works have found that users often
tend to click through HTTPS warnings [43, 8]. The user
may decide to click through the warning and visit the site
anyway, but not enter any sensitive information. Never-
theless, the user’s password manager autoﬁlls the pass-
word resulting in password extraction by the attacker, re-
gardless of the user’s caution. All of the password man-
agers we tested ﬁll passwords even when the user has
clicked through an SSL warning, with the exception of
the desktop and Android versions of Chrome.
Active Mixed Content. Any HTTPS webpage con-
taining active content (e.g., scripts) that is fetched over
HTTP is also a potential vector. If rendering active mixed
content is enabled in the user’s browser, any HTTPS page
containing active mixed content is vulnerable to injec-
tion. Chrome, Firefox, and IE block active mixed content
by default but provide a user option to enable it. Safari,
Mobile Safari, and the Android stock browser allow ac-
tive mixed content to be fetched and executed without
any warnings. Several types of active mixed content, es-
pecially those processed by browser plugins, are harder
to block. For example, embedding a Shockwave Flash
(SWF) ﬁle over HTTP if not blocked correctly can be
used by a network attacker to inject arbitrary scripts [30].
XSS Injection. A cross-site scripting vulnerability in
a page allows the attacker to inject JavaScript to modify
the page as needed [24]. XSS vulnerabilities are listed
as one of the most common web vulnerabilities in 2013
internet security threat report by Symantec [20]. If an
XSS vulnerability is present on any page of the victim
site, the sweep attacks will work even if the site’s login
page is served over HTTPS. For example, the attacker
simply includes an iFrame or a redirect on the malicious
hotspot landing page that links to the XSS page. The link
uses the XSS vulnerability to inject the required login
form and JavaScript into the page.

Furthermore, an XSS vulnerability allows for a weaker
threat model than our coffee shop attacker. An ordinary
web attacker can trick the user into visiting his site, then
launch the attack through the XSS vulnerability. This
style of attack requires no access to the user’s network
and has been suggested previously by RSnake [37] and
Saltzman et al. [40].
Leftover Passwords. The user’s password manager
may contain leftover passwords from older, less secure
versions of a site. An attacker could spoof the old site to
steal the leftover password. Unless the user is proactive
about removing older passwords, updating the security
of the site does not protect the domain from this type of

456  23rd USENIX Security Symposium 

USENIX Association

attack. For example, if a user’s password manager con-
tained a password for Facebook from before its switch
to HTTPS, an attacker could spoof an HTTP Facebook
login page to steal the password.
4.3 Password Exﬁltration

In the previous section we referred to JavaScript that
exﬁltrates the user’s password once it is autoﬁlled by the
password manager. Once the password manager has aut-
oﬁlled the login form, the attacker must be able to access
the ﬁlled-in credentials and send them to a server under
its control. We brieﬂy describe two methods for accom-
plishing this.
4.3.1 Method #1: Stealth

Using stealth exﬁltration, the attacker waits until the
login form is populated with the user’s credentials auto-
matically by a password manager, then steals the pass-
word by loading an attacker controlled page in an invis-
ible iFrame and passing the credentials as parameters.
The following simple JavaScript does just that and works
with all password managers we tested:

function testPassword() {

var password =

document.forms[0].password.value;

if(password != "") {

var temp = document.createElement("div");
temp.innerHTML +=

"<iFrame src=\""+ attacker_addr +
"?password=" + password +
"\" style=\"display:none;\" />";

document.body.appendChild(temp);
clearInterval(interval);

}}
interval = setInterval(testPassword, 50);

4.3.2 Method #2: Action

An HTML form’s “action” is the URL to which the
form’s data will be submitted. The attacker can mod-
ify a login form’s action attribute so that it submits to an
attacker-controlled site, thereby leaking the user’s cre-
dentials to the attacker. If the attacker redirects the user’s
browser back to the real action, the user will not notice
the change.

Automatic autoﬁll password managers populate pass-
word forms when the page ﬁrst loads. The attacker can
then use injected JavaScript to change the action, sub-
mit the form and steal the password. If the login page
is loaded in an iFrame or if it is rendered invisible, the
users will not even realize that a login form was submit-
ted. The following simple code does just that:

changer = function() {

document.forms[0].action = attacker_addr;
document.forms[0].submit();

}

setTimeout(changer, 1000);

In section 2.1 we showed that password managers that
automatically autoﬁll passwords do so on page load and
show no warning to the user when the submitted form ac-
tion differs from the action when the password was ﬁrst
saved. Thus, all password managers with automatic aut-
oﬁll are vulnerable to this exﬁltration method.
4.4 Attacks that need user interaction

All of the attacks described thus far take advantage
of automatic autoﬁll password managers to work when
the user does not interact with the login form. How-
ever, the exﬁltration techniques we described work re-
gardless of how the login form was ﬁlled. If the user’s
password manager requires user input to ﬁll passwords
and an attacker can trick the user to interact with the lo-
gin form without them realizing it, the same exﬁltration
techniques can be used to steal the password as soon as
the password form is ﬁlled.

We created a simple “clickjacking” attack [29, 39, 31].
The attacker presents the user with a benign form seem-
ingly unrelated to the target site. Overlaying the benign
form is an invisible iFrame pointing to the target site’s
login page. The iFrame is positioned such that when a
user interacts with the benign form, they actually inter-
act with the invisible iFrame — in this case, when the
user thinks they are ﬁlling a form on a benign site, they
are actually ﬁlling the password in the target site. Once
ﬁlled, any of the exﬁltration techniques described previ-
ously can be used to steal the password. This attack steals
a password for one site at a time, but could be repeated
to steal passwords for multiple sites.

We conﬁrmed this attack works against both Chrome
and Internet Explorer 11, as both required manual inter-
action before ﬁlling in at least some situations.
5 Strengthening password managers

In this section we present two complementary solu-
tions to the attacks presented earlier. Before describing
the details of our solutions, we ﬁrst describe why some
of the obvious solutions do not work. For example, as all
our attacks require JavaScript injection, a potential so-
lution is to prevent password managers from autoﬁlling
passwords on a page that is vulnerable to JavaScript in-
jection. This solution is hard to implement in practice
as some JavaScript injection vectors (e.g., XSS bugs)
are extremely hard for the browser to detect. Another
possible solution is to completely block autoﬁll inside
iFrames. However, this solution does not prevent the
window or redirect sweep attacks described in Section 4.

USENIX Association  

23rd USENIX Security Symposium  457

Moreover, blocking autoﬁll inside iFrames will inconve-
nience users of benign websites that include login forms
inside iFrames.
5.1 Forcing user interaction

Our ultimate goal is to ensure that using a password
manager results in better security than when users man-
ually enter passwords in a password ﬁeld. This is cer-
tainly not the case with password managers today, as the
attacks of the previous section demonstrate. We begin
with the simplest defense that makes password managers
no worse than manual user entry.

Our most powerful attacks exploit the automatic aut-
oﬁll of the password ﬁeld. An obvious defense is to al-
ways require some user interaction before autoﬁlling a
form. This will prevent sweep attacks where multiple
passwords are extracted without any user interaction. In-
teraction can come in the form of a keyboard shortcut,
clicking a button, selecting an entry from a menu, or typ-
ing into the username ﬁeld. Regardless of the type of
interaction, it must be protected against clickjacking at-
tacks as described in Section 4.4. The user interaction
should occur through trusted browser UI that JavaScript
cannot interact with, preventing malicious JavaScript
from spooﬁng user interaction and triggering an autoﬁll.
Furthermore, the password manager should show the
domain name being autoﬁlled before the ﬁlling occurs,
so that users know which site is being autoﬁlled. This
reduces the chances of the user ﬁlling a form without
meaning to. For example, if a login page for one site
contains an invisible iFrame pointing to the login page
of another site, the user must explicitly choose which do-
main they want ﬁlled.

In some settings, such as broken HTTPS, the password

manager should simply refuse to autoﬁll passwords.
Implementation. Always forcing user interaction was
easy to prototype in Chrome1 because Chrome al-
ready requires user input
in certain situations, such
as when the action on the current page is different
from the action when the password was saved. Since
the UI implementation already existed we simply had
to always trigger it. We did so by hardcoding the
wait_for_username variable to true in the construc-
tor of the PasswordFormFillData object. Note that
this does not protect against the clickjacking attacks de-
scribed in Section 4.4 but can be extended to do so.
Minimizing user inconvenience. As always forcing
user interaction before autoﬁlling may cause inconve-
nience to the user, password managers could provide
a “autoﬁll-and-submit” functionality that once triggered

1Chromium build 231333

by user interaction will autoﬁll the login form and sub-
mit it. We found that variants of autoﬁll-and-submit are
already supported by 1Password, LastPass, Norton Iden-
titySafe, and KeePass.

With this feature, the user’s total interaction will re-
main similar to the current manual autoﬁll password
managers. Instead of interacting with the submit button
after the password managers autoﬁll the login form, the
user will interact with the password manager to trigger
autoﬁll-and-submit. As long as the conditions stated ear-
lier in this section are satisﬁed, the use of such a feature
will be as secure as manually entering a password.
5.2 Secure Filling

Our main defense, called secure ﬁlling, is intended to
make the use of password managers more secure than
typing in passwords manually. Simply requiring user
interaction is not sufﬁcient.
Indeed, if a login page
is loaded over HTTP but submitted over HTTPS, no
browser or password manager implementation provides
security once the login form has been ﬁlled with the
user’s password: JavaScript can read the password di-
rectly from the form or change the form’s action so that
it submits to a password stealing page hosted by the at-
tacker.

The goal of secure ﬁlling is that even if an attacker in-
jects malicious JavaScript into the login page, passwords
autoﬁlled by the password manager will remain secure so
long as the form is submitted over HTTPS. This defense
is somewhat akin to HttpOnly cookies [10], but applied
to autoﬁlled passwords: they can be submitted to the web
server, but cannot be accessed by JavaScript. We discuss
compatibility issues at the end of the section.

Our proposed defense works as follows:

1. Along with the username and password, the pass-
word manager stores the action present in the login
form when the username and password were ﬁrst
saved.

2. When a login form is autoﬁlled by the password
manager, the password ﬁeld becomes unreadable
by JavaScript. We say that the autoﬁll is now “in
progress”.

3. If the username or password ﬁelds are modiﬁed
(by the user or by JavaScript) while an autoﬁll is
in progress, the autoﬁll aborts. The password is
cleared from the password ﬁeld, and password ﬁeld
becomes readable by JavaScript once more.

4. Once a form with an autoﬁll in progress is submit-
ted, and after all JavaScript code that is going to be

458  23rd USENIX Security Symposium 

USENIX Association

run has run, the browser checks that the form’s ac-
tion matches the domain of the action it has stored.
If the domains do not match, the password ﬁeld is
erased and the form submission fails. If the domains
do match, the form is allowed to submit as normal.

Making the password ﬁeld unreadable by JavaScript
prevents stealth exﬁltration, as the malicious JavaScript
is unable to read the password ﬁeld and thus unable to
steal the password. Checking the action before allow-
ing the form to submit ensures that the action has not
been changed to point to a potentially malicious site.
The password is guaranteed to only be ﬁlled into a form
that submits to the same place as when the password was
originally saved. For this to work, it is essential that the
check be performed after JavaScript’s (and thus the at-
tacker’s) last opportunity to modify the form’s action.

In the case where the form’s action does not match
what is stored, it may be desirable to give the user the
option to submit the form (and password) anyway. How-
ever, the browser should allow the user to make an ed-
ucated decision by showing the user both the new and
original actions and explaining how their password may
be leaked. This will weaken security, as the user may
chose to submit the form when they should not, but it
would improve compatibility when sites undergo a re-
design and the login page changes.
Implementation. We
proto-
type of
this defense
by modify-
In the
ing the PasswordAutofillAgent class.
FillUserNameAndPassword method, we ﬁll
the
password ﬁeld with a dummy value (a sequence of
unprintable characters), then store the real password and
the form’s action in a PasswordInfo object associated
with the form. In the WillSendSubmitEvent method,
we check if the dummy value is still present in the pass-
word ﬁeld; if it is, and if the form’s action matches the
action we had stored, we replace the dummy value with
the real password and allow the form to submit. While
our implementation is only a prototype, it shows that
implementing this defense is reasonably straightforward,
at least in Chrome.

implemented
in Chrome2

a

Although browsers vendors will need to implement
this functionality in their own password managers, they
may consider providing a mechanism for external pass-
word manager extensions to implement the same func-
tionality. An API could allow the password manager ex-
tension to ﬁll a form and designate it as autoﬁlled, as well
as designate the expected action on the form. The behav-
ior would then be the same as with the internal password

2Chromium build 231333

manager: the password ﬁeld would become unreadable
by JavaScript, and the browser checks that the action has
not changed before submitting the form.
5.2.1 Limitations of secure ﬁlling

The secure ﬁlling approach will cause compatibility
issues with existing sites whose login process relies on
the ability to read the password ﬁeld using JavaScript.
AJAX-based login. Some sites submit
their login
forms using AJAX instead of standard form submission.
When the login form’s submit button is pressed, these
sites use JavaScript to read the form ﬁelds, then construct
and submit an XMLHttpRequest object. This approach
is not compatible with our solution, as JavaScript would
not be able to read the ﬁlled password ﬁeld and there-
fore be unable to construct the XMLHttpRequest. Fur-
thermore, this does not use the form’s action ﬁeld, and
therefore the password manager cannot detect when the
password is being submitted to a different site than when
it was ﬁrst saved.

To study the impact our proposal would have on ex-
isting popular sites, we looked for the use of AJAX for
login on the Alexa Top 50 sites, as of October 26, 2013.
10 of the these 50 sites used AJAX to submit logins. 8
of 10 sites were based in China, with only one Chinese
site on the list not using AJAX. The remaining two sites
were based in Russia and the U.S., with other sites from
both countries using ordinary form submission. This
suggests the use of AJAX to submit passwords is popu-
lar in China but not common elsewhere in the world, and
overall AJAX is used by a signiﬁcant minority of popular
sites.

We propose two workarounds that will allow our solu-
tion to work with AJAX. First, sites could place the login
form in an iFrame instead of using XMLHttpRequest.
The iFrame would submit using standard form submis-
sion. Using this approach, there is no need for JavaScript
to read the form ﬁelds and the form’s action behaves nor-
mally. Therefore, it is fully compatible with our secure
ﬁlling recommendation, but still allows the user to login
asynchronously.

Second, for sites that must use XMLHttpRequest, the
browser could provide an additional API that allows
JavaScript to submit the password without being able to
read it. The existing XMLHttpRequest API uses a send()
method to send data. We propose an additional method,
sendPassword(). The sendPassword() method accepts a
form as a parameter, and sends the contents of the form’s
password ﬁelds without ever making them readable to
other JavaScript. To prevent an attacker from exﬁltrating
a password using AJAX, the password manager should
check that whenever a ﬁlled password is sent using send-

USENIX Association  

23rd USENIX Security Symposium  459

Password(), the destination URL matches the destination
URL from the ﬁrst time the ﬁlled password was sent.

Although these workarounds will require modiﬁca-
tions to a few existing sites, the security beneﬁts are well
worth the effort. The only downside for sites that do not
make the required modiﬁcations is that their users will
not be able to use some password managers.
Preventing self exﬁltration attacks. Chen et al. [17]
point out that in some cases an attacker can extract data
using what they call “self-exﬁltration.” In our setting this
translates to the following potential attack: if any page on
the victim site supports a public discussion forum, an at-
tacker can cause the secure ﬁlling mechanism to submit
the password to the forum page and have the password
posted publicly. The attacker can later visit the public fo-
rum and retrieve the posted passwords. Since the attacker
is changing the login form’s action to another page in the
same domain our secure ﬁlling mechanism will allow the
password to be sent. In this discussion, the public forum
can be replaced by any public form-posted data on the
victim site

For this attack to work, the name of the password ﬁeld
on the login page must be the same as the name of the text
ﬁeld on the public forum page. An attacker can easily
accomplish this by sending to the browser a login page
with the desired name.

Fortunately, it is straight forward to defend against
this issue: our secure ﬁlling mechanism should only ﬁll
a password ﬁeld whose name matches the name of the
ﬁeld when the password was saved. Furthermore, dy-
namically changing the name attribute using JavaScript
should cause a ﬁll to abort. This defense prevents the
attacker from submitting the password using any ﬁeld
with a namename other than the one chosen by the site
itself for the login page. This prevents the self exﬁltra-
tion attack, except for the extremely unlikely event where
a public forum page on the victim site has a text ﬁeld
whose name happens to be identical to the password ﬁeld
name on the login page.
User registration pages. An additional limitation of
our secure ﬁlling proposal is that it cannot improve the
security of manually entered passwords. HTML does
not provide a way to distinguish between password ﬁelds
on user registration pages and password ﬁelds in login
forms. Registration pages frequently use JavaScript to
evaluate passwords before submission — for example,
to check password strength or to verify two passwords
match. Therefore, JavaScript on registration pages must
have access to the password.

There are two solutions to this problem. One option

is to forbid JavaScript from reading any password ﬁeld,
and require that registration pages use regular text ﬁelds
programmatically made to behave like password ﬁelds.
On every key stroke JavaScript on the page replaces the
character with an asterisk, as in a password ﬁeld. To the
user the text ﬁeld will behave as a password ﬁeld, yet
JavaScript on the registration page will be able to access
the password.

Alternatively, HTML can be slightly extended to sup-
port two types of password ﬁelds, one for login and one
for registration. For login, the Password ﬁeld allows no
JavaScript access to its contents as needed for secure ﬁll.
The PasswordRegistration ﬁeld used for registration al-
lows JavaScript access to its contents but is never aut-
oﬁlled with a saved password (separate password man-
ager features such as a password generator can continue
to work).
5.3 Server-side defenses

How can a site defend itself without support from
password managers? As the attacks rely on decisions
made client-side by the user’s password manager, a com-
plete server-side defense is not possible. However, a few
existing best-practices can be used to greatly reduce the
attack area:

1. Use HTTPS on both the login page and page it sub-
mits to. Ideally, use HTTPS everywhere on the site
and enable HSTS (HTTP Strict Transport Security)
to prevent pages from ever loading under HTTP.

2. Use CSP (Content Security Policy) to prevent the
execution of inline scripts, making the injection of
JavaScript directly into the login page ineffective.

3. Host the login page in a different subdomain that
the rest of the site (i.e., login.site.com instead of
site.com). This limits the number of pages consid-
ered same-origin with the login page, reducing the
attack surface.

None of these defenses are unique to the attacks we
described, but are best-practices that will make our at-
tacks more difﬁcult. Even with these defenses, attacks
are still possible — attacks that take advantage of broken
HTTPS, for example, will still be feasible. Therefore,
it remains important that password managers implement
the ﬁxes we described to fully defend against the attacks.
6 Related work

There have been several prior works about ﬁnding vul-
nerabilities in existing password managers as well as
building stronger password authentication systems. We
summarize them below.

460  23rd USENIX Security Symposium 

USENIX Association

Vulnerabilities in password managers: Belekno et
al. [11] and Gasti et al. [25] surveyed several password
managers and found that most of them save passwords
to device storage in an insecure manner. However, these
attacks have a very different threat model than the at-
tacks described in this paper. They require the attacker
to have physical access to a user’s device. By contrast,
for our attacks we only consider network attackers which
is a weaker threat model than the ones requiring physical
access.

Besides autoﬁlling of passwords, several password
managers also support autoﬁlling of forms with informa-
tion like name, phone no etc. Prior works [21, 35, 27]
have shown that an attacker can steal autoﬁlled informa-
tion by using specially crafted forms. This is a different
class of attack than the attacks on login forms as unlike
login passwords, information ﬁlled into these forms is
not tied to any particular origin. However, for complete-
ness, we summarize our ﬁndings about attacks against
autoﬁlling of regular forms in Appendix A.

Some existing works [23, 2] have demonstrated how
an attacker can use injected JavaScript to steal user’s
stored passwords in a password manager for login pages
that are either vulnerable to XSS attacks or are fetched
over HTTP. However, unlike our attacks, these attacks
require that users willingly visit the vulnerable website at
the presence of the attacker. Reverse Cross-Site Request
(RCSR) [13] vulnerabilities perform phishing attacks by
leveraging the fact that several password managers will
ﬁll in passwords to login forms even if the form’s ac-
tion differs from the action when the password was ﬁrst
saved. These attacks require that the user clicks the sub-
mit button. By contrast, our attacks are completely auto-
mated and transparent to the user.

The most closely related works to the attacks we
present in this paper are by RSnake [37] and Saltzman
et al. [40]. RSnake [37] speculated that an attacker can
exploit form autoﬁlling tools that ﬁlls forms without any
user input in sites vulnerable to XSS attacks to extract the
autoﬁllable information without users’ notice. The basic
idea is to inject JavaScript using the XSS attack and exﬁl-
trate the autoﬁlled information. Saltzman et al. [40] sug-
gested that active network attackers can inject iFrames
to login forms of websites vulnerable to script injec-
tion either through XSS attacks or through pages loaded
over HTTP, make the password managers ﬁll those login
forms, and steal those passwords without users noticing
anything wrong. However, none of these works tested the
attacks. We performed a comprehensive study of vulner-
abilities and presented several new and different attack
vectors (mixed content, broken SSL, embedded device

admin pages etc.) and attack techniques (such as the redi-
rect attack).

Using XSS attacks for stealing autoﬁlled passwords
has also been explored by Stock et al. [42]. They sug-
gested that the password managers can prevent such at-
tacks by using a placeholder dummy password for aut-
oﬁlling and replacing it with the original one just before
submitting the login form to the remote server. In this
work, unlike Stock at al., we explore several different
vectors for stealing autoﬁlled passwords besides XSS at-
tacks. We also investigate several different third-party
password managers together with the builtin password
managers that were analyzed by Stock et al.

Blanchou et al. [12] describe several weaknesses of
password manager browser extensions and implement
a phishing attack that demonstrates the danger of auto-
matic autoﬁll. They do not examine any built-in browser
password managers or consider how passwords from
multiple sites could be stolen in one attack. They sug-
gest that password managers prevent the cross-domain
submission of passwords (what we called action exﬁltra-
tion in this paper), but do not consider stealth exﬁltration.
Fahl et al. [22] demonstrate attacks against Android
password managers. However, their attacks were speciﬁc
to the Android operating system, and most relied upon a
malicious Android app, not a network attacker.

Li et al. [32] survey a variety of vulnerabilities speciﬁc
to third-party web-based password managers and a web
attacker, then discuss mitigation strategies. They do not
discuss browser or native code password managers, nor
a network attacker.

Both the Chromium and Firefox bug databases have
bugs ﬁled to prevent autoﬁlling of login information in-
side an iFrame [18, 16]. However, preventing autoﬁlling
of passwords inside iFrames will not prevent the window
sweep or the redirect attacks described in Section 4. At
the time of this writing, only the Chromium bug has been
ﬁxed.

Another Chromium bug [19] seeks to only autoﬁll
forms after the user interacts with the login page, but not
necessarily the login form. This is not yet implemented,
however, increasing the scope of interaction to the entire
page will make it easier for the attackers to launch click-
jacking attacks. In contrast, autoﬁlling only after explicit
user interaction with the login form as suggested in Sec-
tion 5 is robust against such attacks.

A Firefox bug [14] discusses man-in-the-middle at-
tacks against the password manager similar to our redi-
rect attack. Another bug [15] suggests that ﬁlled pass-
words should not be readable by JavaScript. Their ap-
proach is similar to our secure ﬁlling, but remains vulner-

USENIX Association  

23rd USENIX Security Symposium  461

able to exﬁltration using the action attribute. Although
both bugs are several years old, neither has been acted
upon.

Password manager features: Aris [9] discusses the
autocomplete attribute and why setting autocomplete=off
results in poor security in addition to a bad user experi-
ence.

Secure password authentication systems: Another
related line of research investigated designing secure
password authentication systems that can choose strong
domain-speciﬁc passwords with minimal user interven-
tion [36, 28]. The main motivation behind these works
is to minimize the damage caused by users mistakenly
revealing their passwords through phishing websites or
social engineering These solutions also protect against
an attacker leveraging reused passwords that were stolen
from a low security website on a high security website.
None of these works focus on autoﬁlling of passwords
and thus do not help in preventing against the attacks we
presented in this paper.

There are also several research works that built pass-
word authentication systems that supported autoﬁll-
ing [45, 44]. However, their primary goal was to prevent
phishing attacks. In this paper, we focus on existing pass-
word managers and thus do not evaluate how vulnerable
these systems are against our attacks.

Sandler et al. proposed the ‘password booth’, a new
secure browser-controlled mechanism to let users se-
curely enter passwords that are not unaccessible from
JavaScript running as part of the host page’s origin [41].
Their solution is similar to our secure ﬁlling defense, but
does not take password managers into account. Secure
ﬁlling takes advantage of password managers to provide
guarantees the password booth cannot, namely that an
autoﬁlled password is submitted to the same origin it was
saved from. Furthermore, their proposal requires a dra-
matic UI change for all users, whereas ours requires only
a very minimal UI change from automatic to manual aut-
oﬁll. They suggest that a dramatic change is a feature
because it makes security more visible to the user, yet
at the same time a dramatic change will reduce adoption
from browser developers unwilling to upset their users
with change. Ultimately, our two ideas are compatible
as the password booth could be extended to work with
password managers as we describe in this paper.

An early unpublished version of this paper, containing
only a subset of the results, appears as a technical report
in [34].

7 Conclusions

In this paper we surveyed a wide variety of password
managers and found that they follow very different and
inconsistent autoﬁll policies. We showed how an evil
coffee shop attacker can leverage these policies to steal
the user’s stored passwords without any user interaction.
We also demonstrated that password managers can pre-
vent these attacks by simply following two steps - never
autoﬁlling under certain conditions like in the presence
of HTTPS certiﬁcate validation errors and requiring user
interaction through some form of trusted browser UI, that
untrusted JavaScript cannot affect, before autoﬁlling any
passwords. Finally, we presented secure ﬁlling, a defense
that makes autoﬁlling password managers more secure
than manually entering a password under certain circum-
stances (e.g., a login page fetched over HTTP but submit-
ted over HTTPS). We hope that this work will improve
the security of password managers and encourage devel-
opers to adopt our enhancements.

We disclosed our results to the password manager ven-
dors, prompting several changes to autoﬁll policies. Due
to our ﬁndings, LastPass will no longer automatically
autoﬁll password ﬁelds in iFrames, and 1Password will
no longer offer to ﬁll passwords from HTTPS pages on
HTTP pages.
Acknowledgments
This work was supported by NSF, the DARPA SAFER
program, and a Google PhD Fellowship to Suman Jana.
Any opinions, ﬁndings and conclusions or recommenda-
tions expressed in this material are those of the author(s)
and do not necessarily reﬂect the views of NSF, DARPA,
or Google.
References
[1] 1password - agilebits.

https://agilebits.com/

onepassword.

[2] Abusing password managers with xss.

http:

//labs.neohapsis.com/2012/04/25/abusing-
password-managers-with-xss/.

[3] The autocomplete attribute.

http://www.w3.org/

TR/2011/WD-html5-20110525/common-input-
element-attributes.html#the-autocomplete-
attribute.

[4] Keepass password safe. http://keypass.info.
[5] Lastpass — the last password you have to remember.

https://lastpass.com.

[6] Norton identity safe: Password manager & online identity

security. https://identitysafe.norton.com.

[7] Secure password manager - keeper password & data

vault1password. https://keepersecurity.com.

462  23rd USENIX Security Symposium 

USENIX Association

[8] D. Akhawe and A. P. Felt. Alice in warningland: A large-
scale ﬁeld study of browser security warning effective-
ness. In USENIX Security Symposium, 2013.

[9] Aris.

The war against autocomplete=off, 2013.

http://blog.0xbadc0de.be/archives/124.

[10] A. Barth. Http state management mechanism. RFC 2965,

2011.

[11] A. Belenko and D. Sklyarov. secure password managers
and military-grade encryption on smartphones: Oh, re-
ally? Blackhat Europe, 2012.

[12] M. Blanchou and P. Youn.
passwords

Password man-
agers:
2013.
https://isecpartners.github.io/whitepapers/passwords/2013/
11/05/Browser-Extension-Password-Managers.html.

everywhere,

Exposing

[13] Bugzilla@Mozilla.

Bug 360493 - (cve-2006-6077)
cross-site forms + password manager = security fail-
ure.
https://bugzilla.mozilla.org/show_bug.
cgi?id=360493.

[14] Bugzilla@Mozilla. Bug 534541 - passwords from login
manager can be intercepted by mitm attacker (e.g. evil
wiﬁ hotspot or dns poisoning). https://bugzilla.
mozilla.org/show_bug.cgi?id=534541.

[15] Bugzilla@Mozilla.

Bug 653132 - auto-ﬁlled pass-
word ﬁelds should not have their values available to
javascript). https://bugzilla.mozilla.org/show_
bug.cgi?id=653132.

[16] Bugzilla@Mozilla. Bug 786276 - don’t autoﬁll pass-
words in frames that are not same-origin with top-level
page. https://bugzilla.mozilla.org/show_bug.
cgi?id=786276.

[17] E. Y. Chen, S. Gorbaty, A. Singhal, and C. Jackson. Self-
exﬁltration: The dangers of browser-enforced informa-
tion ﬂow control. In W2SP, 2012.
163072:
in saved passwords

only ﬁll
https://code.google.com/p/chromium/issues/
detail?id=163072.

Chrome
after user

[18] Chromium.

should
action.

Issue

[19] Chromium.

Issue 257156: Don’t autoﬁll passwords on
page load for iframed content. https://code.google.
com/p/chromium/issues/detail?id=257156.

[20] S. Corp. 2013 internet security threat report, volume
http://www.symantec.com/content/en/us/

18.
enterprise/other_resources/b-istr_main_
report_v18_2012_21291018.en-us.pdf.

[21] J. de Valk. Why you should not use autocomplete.

https://yoast.com/autocomplete-security/.

[22] S. Fahl, M. Harbach, M. Oltrogge, T. Muders, and
M. Smith. Hey, you, get off of my clipboard.
In Fi-
nancial Cryptography and Data Security, pages 144–161.
Springer, 2013.

[23] M. Felker.

Password management concerns with ie
and ﬁrefox, part one, 2010. http://www.symantec.
com/connect/articles/password-management-
concerns-ie-and-firefox-part-one.

[24] S. Fogie, J. Grossman, R. Hansen, A. Rager, and P. D.
Petkov. Xss exploits: Cross site scripting attacks and de-
fense. Syngress, 2(3), 2007.

[25] P. Gasti and K. B. Rasmussen. On the security of pass-

word manager database formats. In ESORICS. 2012.

[26] B. Gourdin, C. Soman, H. Bojinov, and E. Bursztein. To-
ward secure embedded web interfaces. In USENIX Secu-
rity Symposium, 2011.

[27] J. Grossman.

I know who your name, where
http:

and live (safari v4 & v5).

you work,
//jeremiahgrossman.blogspot.com/2010/07/i-
know-who-your-name-where-you-work-and.html.
[28] J. A. Halderman, B. Waters, and E. W. Felten. A conve-
nient method for securely managing passwords. In WWW,
2005.

[29] R. Hansen. Clickjacking.

http://ha.ckers.org/

blog/20080915/clickjacking/.

[30] J. Hodges, C. Jackson, and A. Barth. Http strict trans-
port security (hsts). http://www.hjp.at/doc/rfc/
rfc6797.html.

[31] L.-S. Huang, A. Moshchuk, H. J. Wang, S. Schechter,
and C. Jackson. Clickjacking: attacks and defenses. In
USENIX Security Symposium, 2012.

[32] Z. Li, W. He, D. Akhawe, and D. Song. The emperor’s
new password manager: Security analysis of web-based
password managers.
In 23rd USENIX Security Sympo-
sium (USENIX Security 14), Aug. 2014.

[33] M. Marlinspike. New tricks for defeating ssl in practice.

In Blackhat DC, 2009.

[34] R. Gonzalez, E. Chen, and C. Jackson. Automated
password extraction attack on modern password man-
agers. Unpublished, Sep. 2013. arxiv.org/pdf/1309.
1416v1.pdf.

[35] R. M. Rodriguez.

How to take advantage of
sensitive informa-
http://blog.elevenpaths.com/2013/10/

chrome autoﬁll
tion.
how-to-take-advantage-of-chrome.html.

feature to get

[36] B. Ross, C. Jackson, N. Miyake, D. Boneh, and
J. Mitchell.
Stronger password authentication using
browser extensions. In Usenix Security Symposium, 2005.
[37] RSnake. Stealing user information via automatic form
http://ha.ckers.org/blog/20060821/

ﬁlling.
stealing-user-information-via-automatic-
form-filling.

[38] RunSSL.

intranet

Ssl certiﬁcate for private internal
local

address or
//runssl.com/members/knowledgebase/9/SSL-
Certificate-For-Private-Internal-IP-
Address-or-Local-Intranet-Server-Name.html.

server name.

ip
http:

USENIX Association  

23rd USENIX Security Symposium  463

[39] G. Rydstedt, E. Bursztein, D. Boneh, and C. Jackson.
Busting frame busting: a study of clickjacking vulnera-
bilities at popular sites. In W2SP, 2010.

[40] R. Saltzman and A. Sharabani. Active man in the middle

attacks. OWASP AU, 2009.

[41] D. Sandler and D. S. Wallach. input type=password must

die. W2SP, pages 102–113, 2008.

[42] B. Stock and M. Johns. Protecting Users Against XSS-

based Password Manager Abuse. In AsiaCCS, 2014.

[43] J. Sunshine, S. Egelman, H. Almuhimedi, N. Atri, and
L. F. Cranor. Crying wolf: An empirical study of ssl warn-
ing effectiveness. In USENIX Security Symposium, 2009.
[44] M. Wu, R. C. Miller, and G. Little. Web wallet: pre-
venting phishing attacks by revealing user intentions. In
SOUPS, 2006.

[45] K.-P. Yee and K. Sitaker. Passpet: convenient password
management and phishing protection. In SOUPS, 2006.

A Autoﬁlling of forms

Several password managers (Chrome, Safari, LastPass
and 1Password) that we studied in this paper also sup-
ported autoﬁlling forms with different pieces of informa-
tion like name, email address, phone no, credit card no,
expiry date etc. Even though this is not directly related
to autoﬁlling of passwords we summarize our ﬁndings in
this section for completeness.

Unlike login information, autoﬁll

information for
forms is not tied to any origin. Therefore, forms from
any domain can be autoﬁlled with the same information.
To make autoﬁlling secure all the password managers
we studied required user interaction to start autoﬁlling of
forms. However, several prior works have noticed that a
malicious attacker can create specially crafted forms that
only have certain innocuous ﬁelds visible (e.g. name)
while other more sensitive ﬁelds (e.g. phone number) in-
visible to the user and once the user triggers autoﬁlling,
both the invisible and visible ﬁelds get ﬁlled and thus be-
come accessible by the attacker [21, 35].

We found that while all the autoﬁlling password man-
agers we studied are to some extent vulnerable to this
attack, the type of sensitive information that can be ex-
tracted depends on the nature of user interaction required

to trigger autoﬁll. Unlike the rest of the paper in this sec-
tion we consider web attackers only as the autoﬁll infor-
mation is not tied by any origin.

• Chrome & Safari: Both Chrome and Safari sepa-
rate the autoﬁllable information into two categories
- personal information (e.g., name, email address,
phone no., physical address) and credit card infor-
mation (e.g., credit card no, expiry date). To trigger
autoﬁll for each category the user needs to click a
ﬁeld in each category and select an entry from the
available ones. Thus, even if an attacker makes a
user click a visible ﬁeld in the personal information
category none of the hidden credit card ﬁelds will
get autoﬁlled. This makes stealing credit informa-
tion much harder in these password managers with-
out the users noticing it.

• LastPass: Unlike Chrome and Safari, for triggering
autoﬁlling, LastPass only requires that user click a
button shown on top of the page. Once this but-
ton is clicked all ﬁelds in the form (both hidden and
visible) gets ﬁlled. This makes it very easy for an
attacker to create a crafted form showing only ﬁelds
like name and email address while stealing addi-
tional information, such as credit cards, or a Social
Security Number, through hidden ﬁelds.

• 1Password: Unlike LastPass, 1Password requires
that the users click different buttons depending on
what information they want to ﬁll. Thus, it is not
possible to steal credit card information from 1Pass-
word by making all credit cards hidden. However,
if a legitimate page that a user wants to ﬁll credit
card information into also contains an iFrame with
hidden credit card ﬁelds from a third-party domain
(e.g., advertisement), 1Password will ﬁll the credit
card information inside the iFrame as well as in the
main page with a single click and no notiﬁcation to
the user.

464  23rd USENIX Security Symposium 

USENIX Association

