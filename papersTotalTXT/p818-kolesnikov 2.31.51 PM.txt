Efﬁcient Batched Oblivious PRF

with Applications to Private Set Intersection

Vladimir Kolesnikov

Bell Labs

Ranjit Kumaresan

MIT

Murray Hill, New Jersey

kolesnikov@research.bell-

Cambridge, Massachusetts

vranjit@gmail.com

labs.com

Mike Rosulek

Oregon State University

Corvallis, Oregon
rosulekm@eecs.
oregonstate.edu

Ni Trieu

Oregon State University

Corvallis, Oregon
trieun@eecs.

oregonstate.edu

ABSTRACT
We describe a lightweight protocol for oblivious evaluation of
a pseudorandom function (OPRF) in the presence of semi-
honest adversaries.
In an OPRF protocol a receiver has
an input r; the sender gets output s and the receiver gets
output F (s, r), where F is a pseudorandom function and s
is a random seed. Our protocol uses a novel adaptation of 1-
out-of-2 OT-extension protocols, and is particularly eﬃcient
when used to generate a large batch of OPRF instances.
The cost to realize m OPRF instances is roughly the cost
to realize 3.5m instances of standard 1-out-of-2 OTs (using
state-of-the-art OT extension).

We explore in detail our protocol’s application to semi-
honest secure private set intersection (PSI). The fastest state-
of-the-art PSI protocol (Pinkas et al., Usenix 2015) is based
on eﬃcient OT extension. We observe that our OPRF can
be used to remove their PSI protocol’s dependence on the
bit-length of the parties’ items. We implemented both PSI
protocol variants and found ours to be 3.1–3.6× faster than
Pinkas et al. for PSI of 128-bit strings and suﬃciently large
sets. Concretely, ours requires only 3.8 seconds to securely
compute the intersection of 220-size sets, regardless of the
bit length of the items. For very large sets, our protocol is
only 4.3× slower than the insecure na¨ıve hashing approach
for PSI.

1.

INTRODUCTION

This work involves OT, OPRF and PSI constructions. We

start by reviewing the three primitives.

Oblivious Transfer.

Oblivious Transfer (OT) has been a central primitive in

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’16, October 24-28, 2016, Vienna, Austria
c(cid:13) 2016 ACM. ISBN 978-1-4503-4139-4/16/10. . . $15.00
DOI: http://dx.doi.org/10.1145/2976749.2978381

the area of secure computation. Indeed, the original proto-
cols of Yao [30] and GMW [7, 8] both use OT in a critical
manner. In fact, OT is both necessary and suﬃcient for se-
cure computation [15]. Until early 2000’s, the area of generic
secure computation was often seen mainly as a feasibility
exercise, and improving OT performance was not a priority
research direction. This changed when Yao’s Garbled Cir-
cuit (GC) was ﬁrst implemented [20] and a surprisingly fast
OT protocol (which we will call IKNP) was devised by Ishai
et al. [12].

The IKNP OT extension protocol [12] is truly a gem; it
allows 1-out-of-2 OT execution at the cost of computing and
sending only a few hash values (but a security parameter of
public key primitives evaluations were needed to bootstrap
the system). IKNP was immediately noticed and since then
universally used in implementations of the Yao and GMW
protocols. It took a few years to realize that OT extension’s
use goes far beyond these fundamental applications. Many
aspects of secure computation were strengthened and sped
up by using OT extension. For example, Nielsen et al. [24]
propose an approach to malicious two-party secure compu-
tation, which relates outputs and inputs of OTs in a larger
construction. They critically rely on the low cost of batched
OTs. Another example is the application of information-
theoretic Gate Evaluation Secret Sharing (GESS) [16] to the
computational setting [17]. The idea of [17] is to stem the
high cost in secret sizes of the GESS scheme by evaluating
the circuit by shallow slices, and using OT extension to ef-
ﬁciently “glue” them together. Particularly relevant for our
work, eﬃcient OTs were recognized by Pinkas et al. [28] as
an eﬀective building block for private set intersection, which
we discuss in more detail later.

The IKNP OT extension, despite its wide and heavy use,
received very few updates. In the semi-honest model it is
still state-of-the-art. Robustness was added by Nielsen [23],
and in the malicious setting it was improved only very re-
cently [2, 14]. Improvement for short secret sizes, motivated
by the GMW use case, was proposed by Kolesnikov and Ku-
maresan [18]. We use ideas from their protocol, and refer
to it as the KK protocol. Under the hood, KK [18] noticed
that one core aspect of IKNP data representation can be ab-
stractly seen as a repetition error-correcting code, and their
improvement stems from using a better code. As a result,

818instead of 1-out of-2 OT, a 1-out of-n OT became possible
at nearly the same cost, for n up to approximately 256.

Oblivious PRFs.

An oblivious pseudorandom function (OPRF) [6] is a pro-
tocol in which a sender learns (or chooses) a random PRF
seed s while the receiver learns F (s, r), the result of the PRF
on a single input r chosen by the receiver. While the gen-
eral deﬁnition of an OPRF allows the receiver to evaluate
the PRF on several inputs, in this paper we consider only
the case where the receiver can evaluate the PRF on a single
input.

The central primitive of this work, an eﬃcient OPRF pro-
tocol, can be viewed as a variant of Oblivious Transfer (OT)
of random values. We build it by modifying the core of
OT extension protocols [12, 18], and its internals are much
closer to OT than to prior works on OPRF. Therefore, our
presentation is OT-centric, with the results stated in OPRF
terminology.

OT of random messages shares many properties with OPRF.
In OT of random messages, the sender learns random m0, m1
while the receiver learns mr for a choice bit r ∈ {0, 1}.
One can think of the function F ((m0, m1), r) = mr as a
pseudorandom function with input domain {0, 1}. Similarly,
one can interpret 1-out-of-n OT of random messages as an
OPRF with input domain {1, . . . , n}.

In this work, we propose a novel extension to the IKNP
and KK protocols. At almost the same cost as 1-out-of-2
IKNP and KK OTs, we are able to achieve an 1-out-of-n
OT of random messages for arbitrarily large n. This can be
viewed as an OPRF with unbounded input domain {0, 1}∗.
That is, the receiver has an input r ∈ {0, 1}∗ and learns the
value R(r), while the sender obtains the ability to evaluate
R(r(cid:48)) for any string r(cid:48), where R is a pseudorandom function.
We call our main protocol batched, related-key OPRF
(BaRK-OPRF) since it achieves a large number of OPRF
instances, with keys that are related (in a way we describe
later). This is a new primitive, which nevertheless suﬃces
for the application to private set intersection that we con-
sider.

Application to Private Set Intersection (PSI).

Private set intersection (PSI) refers to the setting where
two parties each hold sets of items and wish to learn noth-
ing more than the intersection of these sets. Today, PSI is a
truly practical primitive, with extremely fast cryptograph-
ically secure implementations [27]. Incredibly, these imple-
mentations are only a relatively small factor slower than
than the na¨ıve and insecure method of exchanging hashed
values. Among the problems of secure computation, PSI is
probably the one most strongly motivated by practice. In-
deed, already today companies such as Facebook routinely
share and mine shared information [25, 31]. In 2012, (at least
some of) this sharing was performed with insecure naive
hashing. Today, companies are able and willing to tolerate
a reasonable performance penalty, with the goal of achiev-
ing stronger security [31]. We believe that the ubiquity and
the scale of private data sharing, and PSI in particular, will
continue to grow as big data becomes bigger and privacy
becomes a more recognized issue. We refer reader to [27, 28]
for additional discussion and motivation of PSI.

In our work, we signiﬁcantly improve state-of-the-art PSI
protocol of [27] by replacing one of its components with

BaRK-OPRF. This change results in a factor 2.3–3.6× perfor-
mance improvement for PSI of moderate-length strings (64
or 128 bits) and reasonably large sets. We substantiate our
algorithmic results with implementation and detailed evalu-
ation. Our largest improvement is for the case of larger sets
(224 items each) of long strings (128 bits), which requires
only one minute in our protocol but 214 seconds using [27].
1.1 Related work

Oblivious transfer.

Our BaRK-OPRF protocol can be seen as an OPRF proto-
col as well as a variant of oblivious transfer in the paradigm
of IKNP [12]. As mentioned in Section 1, given its critical
importance in secure computation, the IKNP OT extension
has a surprisingly short list of follow up improvements, ex-
tensions and generalizations.

Most relevant prior work for us is the KK protocol [18],
which views the IKNP OT from a new angle and presents a
framework generalizing IKNP. More speciﬁcally, under the
hood, players in the IKNP protocol encode Receiver’s se-
lection bit b as a repetition string of k copies of b. KK
generalized this and allowed the use of an error-correcting
code (ECC) with large distance as the selection bit encod-
ing. For a code consisting of n codewords, this allowed to
do 1-out of-n OT with consuming a single row of the OT ex-
tension matrix. In this work, we take the coding-theoretic
perspective to the extreme. We observe that we never need
to decode codewords, and by using (pseudo-)random codes
we are able to achieve what amounts to a 1-out-of-poly OT
by consuming a single row of the OT matrix, which for the
same security guarantee is only about 3.5× longer than in
the original IKNP protocol.

Our work is strictly in the semi-honest security model.
Other work on OT extension extends the IKNP protocol to
the malicious model [2, 14] and the PVC (publicly veriﬁable
covert) model [19].

Oblivious PRF.

Oblivious pseudorandom functions were introduced by
In general, the
Freedman, Ishai, Pinkas, & Reingold [6].
most eﬃcient prior protocols for OPRF require expensive
public-key operations because they are based on algebraic
PRFs. For example, an OPRF of [6] is based on the Naor-
Reingold PRF [22] and therefore requires exponentiations.
Furthermore, it requires a number of OTs proportional to
the bit-length of the PRF input. The protocol of [3] con-
structs an OPRF from unique blind signature schemes. The
protocol of [13] obliviously evaluates a variant of the Dodis-
Yampolskiy PRF [4] and hence requires exponentiations (as
well as other algebraic encryption components to facilitate
the OPRF protocol).

Private set intersection.

Oblivious PRFs have many applications, but in this paper
we explore in depth the application to private set intersec-
tion (PSI). We consider only the semi-honest security model.
Our PSI protocol is most closely related to that of Pinkas
et al. [27], which is itself an optimized variant of a previous
protocol of [28]. We describe this protocol in great detail in
Section 5.

We refer the reader to [28] for an overview of the many
diﬀerent protocol paradigms for PSI. As we have mentioned,

819the OT-based protocols have proven to be the fastest in prac-
tice. We do, however, point out that the OT-based proto-
cols do not have the lowest communication cost. In settings
where computation is not a factor, but communication is at a
premium, the best protocols are those in the Diﬃe-Hellman
paradigm introduced in [11]. In the semi-honest version of
these protocols, each party sends only 2n group elements,
where n is the number of items in each set. However, these
protocols require a number of exponentiations proportional
to the number of items, making their performance slow in
practice. Concretely, [27] found Diﬃe-Hellman-based proto-
cols to be over 200× slower than the OT-based ones.

While we closely follow the paradigm of [28], we abstract
parts of their protocol in the language of oblivious PRFs
(OPRF). The connection between OPRF and PSI was al-
ready pointed out in [6]. However, the most straightforward
way of using OPRF to achieve PSI requires an OPRF pro-
tocol in which the receiver can evaluate the PRF on many
inputs, whereas our OPRF allows only a single evaluation
point for the receiver. OPRFs have been used for PSI else-
where, generally in the malicious adversarial model [13, 10,
9].

Other applications of OPRF.

Just like a standard OPRF, our BaRK-OPRF variant im-
mediately and eﬃciently implies the keyword search func-
tionality of [6] (also called “string-select OT (SOT)” in [17]).
Keyword search allows the receiver R to select the received
In SOT the sender S has a mapping
secret via a string.
of keywords to secret values. R receives the secret corre-
sponding to the keyword string it selected.
In [17], SOT
for k-bit selection strings is built by executing k 1-out of-2
OTs, and this technique is also essentially what is used in
the PSI protocol of [28]. Using BaRK-OPRF, we can achieve
keyword search by consuming only a single row of the OT
extension matrix.

Oblivious PRFs can be used for secure pattern match-
ing [10, 5], where one party holds a long text T and the
other party holds a short pattern string p. The parties learn
the location of all occurrences of p within T .
2. TECHNICAL OVERVIEW OF OUR RE-

SULTS

We start with the OT-extension paradigm of Ishai, Kilian,
Nissim & Petrank (IKNP) [12]. The goal of OT extension is
to use a small number k of “base-OTs,” plus only symmetric-
key operations, to achieve m (cid:29) k “eﬀective OTs.” Here, k is
chosen depending on the computational security parameter
κ; in the following we show to what value k should be set.
Below we describe an OT extension that achieves m 1-out-
of-2 OTs of random strings, in the presence of semi-honest
adversaries.

We follow the notation of [18] as it explicates the coding-
theoretic framework for OT extension. Suppose the receiver
has choice bits r ∈ {0, 1}m. He chooses two m × k matrices
(m rows, k columns), T and U . Let tj, uj ∈ {0, 1}k denote
the j-th row of T and U , respectively. The matrices are
chosen at random, so that:

(cid:40)

tj ⊕ uj = rj · 1k def=

1k
0k

if rj = 1
if rj = 0

The sender chooses a random string s ∈ {0, 1}k. The

parties engage in k instances of 1-out-of-2 string-OT, with
their roles reversed, to transfer to sender S the columns of
either T or U , depending on the sender’s bit si in the string s
it chose. In the i-th OT, the receiver gives inputs ti and ui,
where these refer to the i-th column of T and U , respectively.
The sender uses si as its choice bit and receives output qi ∈
{ti, ui}. Note that these are OTs of strings of length m (cid:29) k
— the length of OT messages is easily extended. This can
be done, e.g., by encrypting and sending the two m-bit long
strings, and using OT on short strings to send the right
decryption key.

Now let Q denote the matrix obtained by the sender,
whose columns are qi. Let qj denote the jth row. The
key observation is that

(cid:40)

qj = tj ⊕ [rj · s] =

tj
tj ⊕ s

if rj = 0
if rj = 1

(1)

Let H be a random oracle (RO). We have that the sender can
compute two random strings H(qj) and H(qj ⊕ s), of which
the receiver can compute only one, via H(tj). Note that tj
equals either qj or qj ⊕ s, depending on the receiver’s choice
bit rj. Note that the receiver has no information about s, so
intuitively he can learn only one of the two random strings
H(qj), H(qj ⊕ s). Hence, each of the m rows of the matrix
can be used to produce a single 1-out-of-2 OT.

As pointed out by [12], it is suﬃcient to assume that H
is a correlation-robust hash function, a weaker assumption
than RO. A special assumption is required because the same
s is used for every resulting OT instance. See Section 3 for
deﬁnition of correlation-robustness.

Coding interpretation.
In IKNP, the receiver prepares secret shares of T and U
such that each row of T ⊕ U is either all zeros or all ones.
Kolesnikov & Kumaresan [18] interpret this aspect of IKNP
as a repetition code and suggest to use other codes instead.
Consider how we might use the IKNP OT extension pro-
tocol to realize 1-out-of-2(cid:96) OT. Well, instead of a choice bit
ri for the receiver, ri will now be an (cid:96)-bit string. Let C be
a linear error correcting code of dimension (cid:96) and codeword
length k. The receiver will prepare matrices T and U so that
tj ⊕ uj = C(rj).

Now, generalizing Equation 1 the sender receives

qj = tj ⊕ [C(rj) · s]

(2)
where “·” now denotes bitwise-AND of two strings of length
k. (Note that when C is a repetition code, this is exactly
Equation 1.)
For each value r(cid:48) ∈ {0, 1}(cid:96), the sender associates the secret
value H(qj ⊕ [C(r(cid:48)) · s]), which it can compute for all r(cid:48) ∈
{0, 1}(cid:96). At the same time, the receiver can compute one of
these values, namely, H(tj). Rearranging Equation 2, we
have:

H(tj) = H(qj ⊕ [C(rj) · s])

Hence, the value that the receiver can learn is the secret
value that the sender associates with the receiver’s choice
string r(cid:48) = rj.
At this point, OT of random strings is completed. For OT
of chosen strings, the sender will use each H(qi ⊕ [C(r) · s])
as a key to encrypt the r’th OT message. The receiver will
be able to decrypt only one of these encryptions, namely one
corresponding to its choice string rj.

820To argue that the receiver learns only one string, suppose
the receiver has choice bits rj but tries to learn also the
secret H(qj ⊕ [C(˜r) · s]) corresponding to a diﬀerent choice
˜r. We observe:

(3)

qj ⊕ [C(˜r) · s] = tj ⊕ [C(rj) · s] ⊕ [C(˜r) · s]

= tj ⊕ [(C(rj) ⊕ C(˜r)) · s]

Importantly, everything in this expression is known to the
receiver except for s. Now suppose the minimum distance
of C is κ (the security parameter). Then C(rj) ⊕ C(˜r) has
Hamming weight at least κ. Intuitively, the adversary would
have to guess at least κ bits of the secret s in order to violate
security. The protocol is secure in the RO model, and can
also be proven under the weaker assumption of correlation
robustness, following [12, 18].

Finally, we remark that the width k of the OT extension
matrix is equal to the length of codewords in C. The param-
eter k determines the number of base OTs and the overall
cost of the protocol.

Pseudorandom codes.

The main technical observation we make in this work is
pointing out that the code C need not have many of the
properties of error-correcting codes. In particular,

• We make no use of decoding, thus our code does not

need to be eﬃciently decodable.

• We require only that for all possibilities r, r(cid:48), the value
C(r) ⊕ C(r(cid:48)) has Hamming weight at least equal to
the computational security parameter κ.
In fact, it
is suﬃcient even if the Hamming distance guarantee
is only probabilistic — i.e., it holds with overwhelm-
ing probability over choice of C (we discuss subtleties
below).

For ease of exposition, imagine letting C be a random ora-
cle with suitably long output. (Later we will show that C can
be instantiated from a pseudorandom function in a straight-
forward way.)
Intuitively, when C is suﬃciently long, it
should be hard to ﬁnd a “near-collision.” That is, it should
be hard to ﬁnd values r and r(cid:48) such that C(r) ⊕ C(r(cid:48)) has
low (less than a computational security parameter κ) Ham-
ming weight. Later in Table 2 we compute the parameters
more precisely, but for now we simply point out that a ran-
dom function with output length k = 4κ suﬃces to make
near-collisions negligible in our applications.

We refer to such a function C (or family of functions,
in our standard-model
instantiation) as a pseudoran-
dom code (PRC), since its coding-theoretic properties —
namely, minimum distance — hold in a cryptographic sense.
By relaxing the requirement on C from an error-correcting
code to a pseudorandom code, we remove the a-priori bound
on the size of the receiver’s choice string!
In essence, the
receiver can use any string as its choice string; the sender
can associate a secret value H(qj ⊕ [C(r(cid:48))· s]) for any string
r(cid:48). As discussed above, the receiver is only able to compute
H(tj) = H(qj ⊕ [C(r) · s]) — the secret corresponding to
its choice string r. The property of the PRC is that, with
overwhelming probability, all other values of qj ⊕ [C(˜r) · s]
(that a polytime player may ever ask) diﬀer from tj in a way
that would require the receiver to guess at least κ bits of s.

Interpretation as an oblivious PRF variant.

As discussed in Section 1, we can view the functionality
achieved by this protocol as a kind of oblivious PRF. Intu-
itively, r (cid:55)→ H(q ⊕ [C(r) · s]) is a function that the sender
can evaluate on any input, whose outputs are pseudoran-
dom, and which the receiver can evaluate only on its chosen
input r.

In Section 3 we give a formal deﬁnition of the functionality

that we achieve. The main subtleties of the deﬁnition are:

1. the fact that the receiver learns slightly more than
the output of this “PRF” — in particular, the receiver
learns t = q ⊕ [C(r) · s] rather than H(t);

2. the fact that the protocol realizes many instances of
this “PRF” but with related keys — s and C are shared
among all instances.

We prove our construction secure assuming C is a pseudo-
random code and that H satisﬁes a natural generalization
of the “correlation robust” assumption from [12].

Summary & cost.

With our new variant of the IKNP protocol, we can obtain
m OPRF instances eﬃciently, using only k base OTs plus
symmetric-key operations. Compared to IKNP-paradigm
OT extension for 1-out-of-2 OTs, the main diﬀerences in
cost are:

• Cost associated with the increased width of the OT
extension matrices. In our case, the matrix has width
k rather than κ — concretely 3κ < k < 4κ in our
applications. Note that the parameter k controls the
number of base OTs required.1

• Computational costs associated with the pseudoran-
dom code C. While in IKNP C is a repetition code,
and in [18] C is a short Walsh-Hadamard code, in our
protocol C is cryptographic. However, we are able to
instantiate C using a PRF. In practice, we use AES as
the PRF, and the associated hardware acceleration for
AES in modern processors makes the cost of comput-
ing C minimal.

Application to private set intersection.

Private set intersection (PSI) refers to a computation in
which Alice has a set A of items, Bob has a set B of items,
and the two learn only A ∩ B and nothing more.

We show how BaRK-OPRF can be used to signiﬁcantly re-
duce the cost of semi-honest-secure PSI. The current fastest
protocol for the task is that of Pinkas et al. [27]. The pro-
tocol relies heavily on eﬃcient OT extension (for standard
1-out-of-2 OTs).

Looking closely at the PSI protocol of [27], we see that
they use a number of OTs that is proportional to N (cid:96), where
N is the number of items in the parties’ sets and (cid:96) is the
length (in bits) of those items. We can replace their use
of 1-out-of-2 OTs with a suitable use of BaRK-OPRF and

1In our instantiation, we actually use IKNP to extend κ
base OTs to k OTs, and then use those k OTs as base OTs
for BaRK-OPRF instances. Hence, the number of public-key
OT operations is unchanged. Still, the total communication
cost remains proportional to km in our protocol rather than
κm.

821remove the dependence on (cid:96). Our protocol uses a number
of BaRK-OPRF instances that is proportional only to N .

We implemented our BaRK-OPRF-based PSI protocol and
compared its performance to that of [27]. For PSI on strings
of length (cid:96) ∈ {64, 128} and suﬃciently large sets, our proto-
col is 2.3–3.6 times faster. This is a signiﬁcant achievement
in the already very polished PSI state of the art!

3. TECHNICAL PRELIMINARIES

We write (cid:107)x(cid:107)H to denote the hamming weight of a binary
string x. Our computational security parameter is κ and
statistical security parameter is σ.
3.1 Correlation Robustness

The OT extension protocol of IKNP [12] is proven secure
under a so-called correlation robustness assumption on the
underlying hash function. Our protocol makes use of the
following generalization of this notion:

Definition 1. Let H be a hash function with input length
n. Then H is d-Hamming correlation robust if, for any
strings z1, . . . , zm ∈ {0, 1}∗, a1, . . . , am, b1, . . . , bm ∈ {0, 1}n
with (cid:107)bi(cid:107)H ≥ d, the following distribution, induced by ran-
dom sampling of s ← {0, 1}n, is pseudorandom:

H(z1(cid:107)a1 ⊕ [b1 · s]), . . . , H(zm(cid:107)am ⊕ [bm · s])

As in the overview, “·” denotes bitwise-AND.

The deﬁnition generalizes previous ones in the following

way:

• If d = n, then the only legal choice of bi is 1n, and
H(zi(cid:107)ai ⊕ [bi · s]) simpliﬁes to H(zi(cid:107)ai ⊕ s). Restrict-
ing the deﬁnition in this way, and taking zi = i corre-
sponds to the IKNP notion of correlation robustness.
• If the bi values are required to be elements of a linear
error correcting code C, then the resulting deﬁnition
is one under which the construction of [18] is secure
(for simplicity they prove security in the random oracle
model).

3.2 Pseudorandom Codes

We now formalize the notion of a pseudorandom code,

motivated in Section 2.

Definition 2. Let C be a family of functions. We say
that C is a (d, ) pseudorandom code (PRC) if for all
strings x (cid:54)= x(cid:48),

(cid:104)(cid:107)C(x) ⊕ C(x

Pr
C←C

(cid:105) ≤ 2

−

(cid:48)

)(cid:107)H < d

That is, a (d, )-PRC guarantees that the hamming dis-
tance of two codewords is less or equal to d with probability
at most 2−.

The reader may ﬁnd it convenient to think of C as a ran-
dom oracle. However, it suﬃces for C to be a pseudorandom
function instantiated with random seed:

Lemma 1. Suppose F : {0, 1}κ × {0, 1}∗ → {0, 1}n is a
pseudorandom function. Deﬁne C = {F (s,·) | s ∈ {0, 1}κ}.
Then C is a (d, )-pseudorandom-code where:

probability 2−n(cid:80)d−1

Proof. Consider the following game. An adversary has
It queries its oracle O on x
strings x and x(cid:48) hard-coded.
and x(cid:48) and outputs 1 if O(x) and O(x(cid:48)) are within Hamming
distance d.
When O is instantiated as a random function, a simple
counting argument shows that the adversary outputs 1 with
When O is instantiated as a PRF F with random seed,
the probability must be within ν(κ) of the above probability,
where ν is negligible. The adversary’s output probability in
this instantiation is exactly the probability speciﬁed in the
PRC security deﬁnition, so the lemma follows.

(cid:0)n
(cid:1).

i=0

i

Note that in our typical usage of PRCs, the choice of C
(in this case, the seed to the PRF) is a public value. But
in both the security deﬁnition for PRC and in this analysis,
the values x and x(cid:48) are ﬁxed before the PRF key is chosen.
Whether or not F (s, x) and F (s, x(cid:48)) are within Hamming
distance d is not aﬀected by making the PRF seed pub-
lic.
3.3 Our Oblivious PRF Variant

As outlined in Section 2, our main construction is a variant
of OT-extension which associates a pseudorandom output
R(x) for every possible input r ∈ {0, 1}∗. The sender can
compute R(r) for any r, while the receiver learns R(x) for
only a single value r. This functionality is reminiscent of an
oblivious PRF (OPRF) [6]. In this section we describe
how our construction can be interpreted as a variant OPRF
functionality.

In an OPRF functionality for a PRF F , the receiver pro-
vides an input2 r; the functionality chooses a random seed
s, gives s to the sender and F (s, r) to the receiver.

In our protocol, the sender knows qj and s. We can con-

sider these values as keys to a PRF:

F ((qj, s), r) = H(j(cid:107)qj ⊕ [C(r) · s])

Intuitively, the sender can evaluate this PRF at any point,
while the receiver can evaluate it on only one. However, we
point out some subtleties:

• In our protocol, the receiver learns tj = qj ⊕ [C(r∗)· s]
for his chosen input r∗, which is more information than
the “PRF output” H(j(cid:107)tj). However, even knowing tj,
the other outputs of the “PRF” still look random. This
common feature of an OPRF protocol leaking slightly
more than the PRF output is called relaxed OPRF in
[6].

• In our protocol, we realize many “OPRF” instances
with related keys. In particular, all instances have the
same component s (and C).

We encapsulate these properties in the following deﬁni-

tions.
3.3.1 Our PRF variant
We refer to F as a relaxed PRF if there is another func-

tion (cid:101)F , such that F (k, r) can be eﬃciently computed given
just (cid:101)F (k, r). We then deﬁne the relevant notion of secu-
function (cid:101)F rather than just F .

rity with respect to an adversary who can query the relaxed

d−1(cid:88)

(cid:32)

(cid:33)

n
i

− = 2
2

−n

and ν is a negligible function.

i=0

+ ν(κ).

2More general OPRF variants allow the receiver to learn the
PRF output on many inputs — here it suﬃces to limit the
receiver to one input.

822Definition 3. Let F be a relaxed PRF with output length
v, for which we can write the seed as a pair (k∗, k). Then F
has m-related-key-PRF (m-RK-PRF) security if the
advantage of any PPT adversary in the following game is
negligible:

1. The adversary chooses strings x1, . . . , xn and m pairs

(j1, y1), . . . , (jm, ym), where yi (cid:54)= xji .

2. Challenger chooses random values appropriate for
PRF seeds k∗, k1, . . . , kn and tosses a coin b ← {0, 1}.

(a) If b = 0, the challenger outputs {(cid:101)F ((k∗, kj), xj)}j
and {F ((k∗, kji ), yi)}i.
{0, 1}v and outputs {(cid:101)F ((k∗, kj), xj)}j and {zi}i,

(b) If b = 1 the challenger chooses z1, . . . , zm ←

3. The adversary outputs a bit b(cid:48). The advantage of the
♦

adversary is Pr[b = b(cid:48)] − 1/2.

Intuitively, the PRF is instantiated with n related keys
(sharing the same k∗ value). The adversary learns the re-
laxed output of the PRF on one chosen input for each key.
Then any m additional PRF outputs (corresponding to any
seed) are indistinguishable from random by the adversary.
Lemma 2. Let C be a (d, +log2 m)-PRC, where 1/2 is a
negligible function, Let H be a d-Hamming correlation robust
hash function. Deﬁne the following relaxed PRF, for C ∈ C:

(cid:16)
(cid:16)

F

(cid:101)F

((C, s), (q, j)), r

((C, s), (q, j)), r

(cid:17)
(cid:17)

= H(j(cid:107)q ⊕ [C(r) · s])
= (j, C, q ⊕ [C(r) · s])

Then F has m-RK-PRF security.

Proof. In the m-RK-PRF game with this PRF, we can

rewrite the adversary’s view as in Section 2 as:

(C,{tj}j,{H(ji(cid:107)tji ⊕ [(C(xji ) ⊕ C(yi)) · s])}i)

There are m terms of the form C(xji ) ⊕ C(yi) for xji
(cid:54)=
yi. Each of these terms has Hamming weight at least d
with probability at least 1 − 2−−log2 m over the choice of
C. By a union bound, all m terms have Hamming weight
at least d with probability 1 − 2−. Conditioning on this
(overwhelmingly likely) event, we can apply the d-Hamming
correlation robust property of H to see that the H-outputs
are indistinguishable from random.

3.3.2 Our BaRK-OPRF functionality
In Figure 1 we formally describe the variant OPRF func-
tionality we achieve. It generates m instances of the PRF
with related keys, and allows the receiver to learn the (re-
laxed) output on one input per key.

4. MAIN CONSTRUCTION

We present our main construction, which is a semi-honest
secure protocol for the functionality in Figure 1, instantiated
with the relaxed PRF deﬁned in Lemma 2.

The functionality is parameterized by a relaxed PRF F ,
a number m of instances, and two parties: a sender and
receiver.

On input (r1, . . . , rm) from the receiver,

• Choose random components for seeds to the PRF:

k∗, k1, . . . , km and give these to the sender.

• Give (cid:101)F ((k∗, k1), r1), . . . ,(cid:101)F ((k∗, km), rm) to the re-

ceiver.

Figure 1: Batched, related-key OPRF (BaRK-OPRF)
ideal functionality.

We use the notation OTk

4.1 Notation
m to denote k instances of 1-out-
of-2 string-OT where the strings are m bits long. Let S de-
note the sender, and let R denote the receiver. In OTk
m, the
sender’s input is {(xj,0, xj,1)}j∈[k], i.e., m pairs of strings,
each of length m, and the receiver holds input {rj}j∈[k],
where each rj is a choice bit. Note that if S provides input
m, and if R provides input {rj}j∈[k]
{(xj,0, xj,1)}j∈[k] to OTk
m, then R receives back {xj,rj}j∈[k], while S receives
to OTk
nothing.

Following the convention in IKNP, we denote vectors in
bold, and matrices in capitals. For a matrix A, we let aj
denote the j-th row of A, and ai denote the i-th column of A.
If a = a1(cid:107)···(cid:107)ap and b = b1(cid:107)···(cid:107)bp are two vectors, then
we deﬁne ⊕ and · operations as follows. We use the notation
a⊕ b to denote the vector (a1⊕ b1)(cid:107)···(cid:107)(ap⊕ bp). Similarly,
the notation a · b denotes the vector (a1 · b1)(cid:107)···(cid:107)(ap · bp).
Finally, suppose c ∈ {0, 1}, then c · a denotes the vector
(c · a1)(cid:107)···(cid:107)(c · ap).

We note that to simplify notation via indexing, in the
following we will refer to the OT matrices as T0 and T1,
rather than as T and U , as we did when presenting high-
level overview of our work.
4.2 The BaRK-OPRF construction

Our BaRK-OPRF protocol is presented in Figure 2.

It
closely follows the high-level overview. Recall that we are
considering a PRF whose seed is of the form ((C, s), (j, qj))
and whose relaxed output is of the form t0,j = qj⊕(C(rj)·s).
Theorem 3. The BaRK-OPRF protocol in Figure 2 se-
curely realizes the functionality of Figure 1, instantiated with
the relaxed PRF deﬁned in Lemma 2, in the presence of
semi-honest adversaries, where κ is the computational secu-
rity parameter.

Proof. When using the abstraction of our OPRF func-

tionality, the proof is elementary.
Simulating S. The simulator receives output from the
OPRF ideal functionality consisting of related PRF seeds: a
common (C, s) and a qj for each j ∈ [m]. Let Q be a matrix
whose rows are the qj. Let qi denote the ith column of Q.
The simulator simulates an execution of the protocol in
which S chooses C in step 0, chooses s in step 1, and receives
output {qi}i∈[k] as OT output in step 3.
Simulating R. The simulator has input (r1, . . . , rm) and
receives output from the OPRF ideal functionality consist-
ing of a relaxed PRF output (j, C, tj) for each j ∈ [m].

823Input of R: m selection strings r = (r1, . . . , rm), ri ∈
{0, 1}∗.
Parameters:

• A (κ, )-PRC family C with output length k = k(κ).
• A κ-Hamming correlation-robust H :
[m] ×
• An ideal OTk

{0, 1}k → {0, 1}v.

m primitive.

Protocol:

0. S chooses a random C ← C and sends it to R.
1. S chooses s ← {0, 1}k at random. Let si denote

the i-th bit of s.

2. R forms m× k matrices T0, T1 in the following way:
• For j ∈ [m], choose t0,j ← {0, 1}k and set

t1,j = C(rj) ⊕ t0,j.
0, ti

Let ti
respectively.

1 denote the i-th column of matrices T0, T1

3. S and R interact with OTk

m in the following way:

• S acts as receiver with input {si}i∈[k].
• R acts as sender with input {ti
• S receives output {qi}i∈[k].

0, ti

1}i∈[k].

S forms m × k matrix Q such that the i-th column
of Q is the vector qi. (Note qi = ti
si .) Let qj denote
the j-th row of Q. Note, qj = ((t0,j ⊕t1,j)·s)⊕t0,j.
Simplifying, qj = t0,j ⊕ (C(rj) · s).

4. For

j

∈ [m], S outputs

the PRF seed

((C, s), (j, qj)).

5. For j ∈ [m], R outputs relaxed PRF output

(C, j, t0,j).

Figure 2: The BaRK-OPRF protocol

The simulator simulates an execution of the protocol in
which R receives C in step 0 and samples t0,j = tj in step
2.

In both cases it is straightforward to check that the sim-

ulation is perfect.

5.

IMPROVING PRIVATE SET INTERSEC-
TION

The main application of BaRK-OPRF is to improve the
performance of semi-honest-secure private set intersec-
tion (PSI). Pinkas et al. [28] give a thorough summary of
many diﬀerent paradigms for PSI in this model.

For our purposes, we summarize only the most eﬃcient
PSI protocol, which is the OT-based paradigm of [28] in-
cluding the optimizations suggested in follow up work [27].
Hereafter we refer to their protocol as the “PSSZ” protocol.
5.1 The OPRF Implicit in PSSZ

The main building block of PSSZ, private equality test,
can be viewed as a relaxed OPRF based on random OTs

(i.e., oblivious transfers of random messages), which can be
obtained eﬃciently from OT extension. The protocol is as
follows, where Bob has input r, with (cid:96) = |r|.

• The parties perform (cid:96) 1-out-of-2 OTs of random mes-
sages, with Alice as receiver. Bob acts as receiver and
uses the bits of r as his choice bits.
In the ith OT,
Alice learns random strings mi,0 and mi,1, while Bob
learns mi,r[i].

• Deﬁne the mapping F (x) = H(cid:0)(cid:76)

(cid:1), where H is

i mi,x[i]

a random oracle. One can then view F as a PRF whose
keys are the mi,b values (known to Alice). Bob learns
the output of F on r only. More precisely, he learns
relaxed output {mi,r[i]}i, for which all other outputs
of F are pseudorandom.

In this description, we have treated r as a string of bits,
and therefore use 1-out-of-2 (random) OTs. However, when
using the OT extension protocol of [18], the cost of a 1-out-
of-2 random OT is essentially the same as a 1-out-of-256
random OT. Hence, PSSZ interpret r as strings of characters
over {0, 1}8. The protocol uses one instance of 1-out-of-256
ROT for each byte (not bit) of r.

Regardless of whether one uses 1-out-of-2 or 1-out-of-256
OT, this OPRF protocol has cost that scales with length
of the input r, whereas ours has cost independent of the
input length. Our main improvement to PSSZ consists of
replacing their OPRF with ours. The rest of the protocol is
largely unchanged.
5.2 PSI from OPRF

We now describe how the PSSZ paradigm achieves PSI us-
ing an OPRF. This part of the overall PSI protocol is nearly
identical between our implementation and that of [27] (we
include an additional small optimization). For concreteness,
we describe the parameters used in PSSZ when the parties
have roughly the same number n of items.

The protocol relies on Cuckoo hashing [26] with 3 hash
functions, which we brieﬂy review now. To assign n items
into b bins using Cuckoo hashing, ﬁrst choose random func-
tions h1, h2, h3 : {0, 1}∗ → [b] and initialize empty bins
B[1, . . . , b]. To hash an item x, ﬁrst check to see whether
any of the bins B[h1(x)], B[h2(x)], B[h3(x)] are empty. If so,
then place x in one of the empty bins and terminate. Other-
wise, choose a random i ∈ {1, 2, 3}, evict the item currently
in B[hi(x)], replacing it with x, and then recursively try to
insert the evicted item. If this process does not terminate
after a certain number of iterations, then the ﬁnal evicted
element is placed in a special bin called the stash.

PSSZ use Cuckoo hashing for PSI in the following way.
First, the parties choose 3 random hash functions h1, h2, h3
suitable for 3-way Cuckoo hashing. Suppose Alice has a set
X of inputs and Bob has a set Y , where |X| = |Y | = n. Bob
maps his items into 1.2n bins using Cuckoo hashing and a
stash of size s. At this point Bob has at most one item per
bin and at most s items in his stash — he pads his input
with dummy items so that each bin contains exactly 1 item
and the stash contains exactly s items.

The parties then run 1.2n+s instances of an OPRF, where
Bob plays the role of receiver and uses each of his 1.2n + s
items as OPRF input. Let F (ki,·) denote the PRF evaluated
in the ith OPRF instance.
If Bob has mapped item y to
bin i via cuckoo hashing, then Bob learns F (ki, y); if Bob

824has mapped y to position j in the stash, then Bob learns
F (k1.2n+j, y).
On the other hand, Alice can compute F (ki,·) for any i.

So she computes sets of candidate PRF outputs:
H = {F (khi(x), x) | x ∈ X and i ∈ {1, 2, 3}}
S = {F (k1.2n+j, x) | x ∈ X and j ∈ {1, . . . , s}}

She randomly permutes elements of H and elements of S
and sends them to Bob. Bob can identify the intersection
of X and Y as follows.
If Bob has an item y mapped to
the stash, he checks whether the associated OPRF output is
present in S. If Bob has an item y not mapped to the stash,
he checks whether its associated OPRF output is in H.
Intuitively, the protocol is secure against a semi-honest
Bob by the PRF property. For an item x ∈ X \ Y , the
corresponding PRF outputs F (ki, y) are pseudorandom. It
is easy to see that security holds even if Bob learns relaxed
PRF outputs and the PRF achieves RK-PRF security, Def-
inition 3 (i.e., Alice’s PRF outputs are pseudorandom to
an adversary who learns relaxed PRF outputs). Similarly,
if the PRF outputs are pseudorandom even under related
keys, then it is safe for the OPRF protocol to instantiate
the PRF instances with related keys.
The protocol is correct as long as the PRF does not in-
troduce any further collisions (i.e., F (ki, x) = F (ki(cid:48) , x(cid:48)) for
x (cid:54)= x(cid:48)). Below we discuss the parameters required to pre-
vent such collisions.

An Optimization.

In the protocol summary above, Bob must search for each
of his OPRF outputs, either in the set H or the set S. Fur-
thermore, |H| = 3n and |S| = sn. Even when using a
reasonable data structure for these comparisons, they have
a non-trivial eﬀect on the protocol’s running time. We now
describe an optimization that reduces this cost (by approx-
imately 10% in our implementation). The full protocol is
described in Figure 3.
Our modiﬁcation works as follows. First, Bob keeps track
of a hash index z ∈ {1, 2, 3} for each item y ∈ Y that is not
mapped to the stash. For example, if Bob’s Cuckoo hashing
maps y to bin #h2(y), then Bob associates z = 2 with y.
If for example y is mapped to bin by two hash functions
#h1(y) = #h2(y) then Bob may choose either z = 1 or
z = 2 arbitrarily.
Then in the ﬁrst 1.2n OPRF instances, Bob uses input
y(cid:107)z. For the OPRF instances associated with the stash, he
does not need to append the index z. Summarizing, if Bob
has mapped item to position j in the stash, then Bob learns
F (k1.2n+j, y). If he has not mapped y to the stash, then he
learns F (khz (x), y(cid:107)z) for exactly one z.

Then Alice computes the following sets:

Hi = {F (khi(x), x(cid:107)i) | x ∈ X}, for i ∈ {1, 2, 3}
Sj = {F (k1.2n+j, x) | x ∈ X}, for j ∈ {1, . . . , s}

She randomly permutes the contents of each Hi and each Sj
and sends them to Bob. For each item y of Bob, if y is not
mapped to the stash then Bob can whether F (khz (y), y(cid:107)z) ∈
Hz, for the associated hash-index z. If his Cuckoo hashing
maps item y to position j in the stash, he can check whether
F (k1.2n+j, y) ∈ Sj.

The reason for appending the hash-index z to the PRF in-
put is as follows. Suppose h1(x) = h2(x) = i, which is indeed

can happen with noticeable probability, since the output
range of h1, h2 is small ([1.2n]). Without appending z, both
H1 and H2 would contain the identical value F (ki, x). This
would leak the fact that a collision h1(x) = h2(x) occurred.
Such an event is input-dependent so cannot be simulated.3
With our optimization: (1) All of the calls to the PRF
made by Alice (to compute the Hi’s and Sj’s) invoke the
PRF on distinct key-input pairs. This ensures that the con-
tents of these sets can be easily simulated; (2) Bob searches
for each of his PRF outputs within only one set (either an
Hi or an Sj) of n items. Contrast this with the approach
described previously, where Bob must ﬁnd each OPRF out-
put in either a set of size 3n or sn (depending on whether
the item is in the stash or not).

Recall that the protocol is correct as long as there are no
spurious collisions among PRF outputs. Since there are at
most n2 opportunities for a spurious collision (Bob searches
each time for a PRF output in a set of n items), we can
limit the overall probability of a spurious collision to 2−σ by
using PRF outputs of length σ + log2(n2).

Parameters: Alice has input X; Bob has input Y , with
|X| = |Y | = n. s is an upper bound on the stash size for
Cuckoo hashing.

1. Bob speciﬁes random hash functions h1, h2, h3 :

{0, 1}∗ → [1.2n] and tells them to Alice.

2. Bob assigns his items Y into 1.2n bins using Cuckoo
hashing. Let Bob keep track of z(y) for each y so
that: if z(y) = ⊥ then y is in the stash; otherwise
y is in bin hz(y)(y). Arrange the items in the stash
in an arbitrary order.
Bob selects OPRF inputs as follows: for i ∈ [1.2n],
if bin #i is empty, then set ri to a dummy value;
otherwise if y is in bin #i then set ri = y(cid:107)z(y). For
i ∈ [s], if position i in the stash is y, then set ri = y;
otherwise set ri to a dummy value.

3. The parties invoke 1.2n + s OPRF instances, with
Bob the receiver with inputs (r1, . . . , r1.2n+s). Alice
receives (k1, . . . , k1.2n+s) and Bob receives F (ki, ri)
for all i.

4. Alice computes:

Hi = {F (khi(x), x(cid:107)i) | x ∈ X}, for i ∈ {1, 2, 3}
Sj = {F (k1.2n+j, x) | x ∈ X}, for j ∈ {1, . . . , s}
and sends a permutation of each set to Bob.

5. Bob initializes an empty set O and does the follow-
ing for y ∈ Y : If z(y) = ⊥ and y is at position j in
the stash and F (k1.2n+j, y) ∈ Sj, then Bob adds y
to O. If z(y) (cid:54)= ⊥ and F (khz(y)(y), y(cid:107)z(y)) ∈ Hz(y)
then Bob adds y to O.

6. Bob sends O to Alice and both parties output O.

Figure 3: Our optimization to the PSSZ PSI proto-
col, written in terms of an OPRF functionality.

3The protocol and implementation of PSSZ do not account
for such collisions among the Cuckoo hash functions. Dupli-
cate values will appear in H in such an event.

8255.3 Comparing OPRF Subprotocols

When comparing our protocol to that of PSSZ, the ma-
jor diﬀerence is the choice of OPRF subprotocols. Later in
Section 6 we give an empirical comparison of the protocols.
For now, we derive an analytical comparison of the costs of
the two OPRF subprotocols, to give a better sense of our
improvement.

We focus on the communication cost associated with the
OT primitives. Communication cost is an objective metric,
and it often reﬂects the bottleneck in practice (especially
in these protocols where essentially all of the cryptographic
computations are precomputed). Although the computation
costs of our protocols are diﬀerent (e.g., ours requires com-
puting the pseudorandom code, which is a cryptographic
operation), communication cost is nonetheless a good proxy
for computation costs in OT extension protocols. The data
that is communicated in these protocols is a large matrix
that must be transposed, and this transposition is the pri-
mary contributor to the computational cost.

The main beneﬁt of our protocol is that its cost does not
scale with the size of the items being compared. Each in-
stance of OPRF consumes just one row of the OT extension
matrix. The width of this OT extension matrix is exactly
the length of the pseudorandom code (PRC). In Section 6.1
we describe how to compute an appropriate length of PRC.
For the range of parameters we consider, this parameter is
424–448 bits. Hence the OT-cost of one instance of our
OPRF protocol is 424–448 bits. The speciﬁc numbers are in
Table 1.

The PSSZ OPRF protocol uses several instances of 1-out-
of-256 ROT. With security parameter 128, the cost of such
a random OT is 256 bits using the OT extension of [18].
The main optimization of [27] allows for the OPRF sub-
protocols to be performed on items of length (cid:96)∗ = (cid:96) − log n
(n is the number of items in the overall PSI protocol) rather
than length (cid:96). Let (cid:96)∗ denote this eﬀective item length.
Then (cid:96)∗/8 instances of 1-out-of-256 ROT are needed for one
OPRF instance. The total OT-cost of their OPRF protocol
is therefore 256(cid:96)∗/8 = 32(cid:96)∗ bits.
Hence, we see that our protocol has lower communication
cost whenever (cid:96)∗ > 448/32 = 14. Among the diﬀerent pa-
rameter settings reported in [27], the only conﬁguration with
(cid:96)∗ < 14 is for PSI of n ≥ 220 items of length 32 bits. For all
other conﬁgurations, our PSI protocol has lower communi-
cation cost, with the savings increasing as the items become
longer. See Table 1.

Remark on pre-hashing long PSI inputs.

Our improvements to PSI are most signiﬁcant for PSI of
long items. Yet, if the parties have items which are very
long strings (say, thousands of bits), they can agree on a
random hash function, hash their items locally, and perform
PSI on the shorter hashes instead. The reader may rightfully
wonder whether this idea make our improvements irrelevant!
For this approach (hash-then-PSI) to work, we must en-
sure that the hashing introduces no collisions among the
parties’ items. If the parties have n items each, and we wish
to limit the probability of a collision to 2−σ, then we must
choose a hash function whose length is σ + 2 log n. When
using the optimizations of [27], the eﬀective item length can
be reduced from σ + 2 log n to σ + log n bits.

We see that pre-hashing the items cannot reduce their
eﬀective length below σ bits, where σ is a statistical security

n
28
28
28
212
212
212
216
216
216
220
220
220
224
224
224

(cid:96)
32
64
128
32
64
128
32
64
128
32
64
128
32
64
128

(cid:96)∗
24
56
120
20
52
116
16
48
112
12
44
108

8
40
104

OT cost

PSSZ our BaRK-OPRF
768
1792
3840
640
1664
3712
576
1536
3584
384
1408
3456
256
1280
3328

424
424
424
432
432
432
440
440
440
448
448
448
448
448
448

ratio
0.54
0.24
0.11
0.68
0.26
0.12
0.76
0.29
0.12
1.17
0.32
0.13
1.75
0.35
0.13

Table 1: Comparing the OT-cost of PSSZ-paradigm
OPRF subprotocol and ours, for various parameters.
The entries in the table refer to the contribution (in
bits) to the size of the OT-extension matrices. (cid:96) is
the item length (in bits), n is the total number of
items in the parties’ sets, and (cid:96)∗ is the eﬀective item
length when using the optimizations of [27].

parameter. Standard practice suggests σ ≥ 40, and yet our
protocol outperforms [27] whenever the eﬀective item length
is at least 14 bits. Hence hash-then-PSI does not allow one
to bypass our improvement to [27].

On a similar note, in our experimental results we report
performance of the protocols only for PSI inputs up to 128
bits long. For statistical security parameter σ = 40, as long
as the parties have at most 234 (17 billion) items, they can
use hash-then-PSI with a 128-bit hash.
6.

IMPLEMENTATION &
PERFORMANCE

We implemented our PSI protocol and report on its per-
formance in comparison with the state-of-the-art PSI pro-
tocol of [27]. Our complete implementation is available on
GitHub: https://github.com/osu-crypto/BaRK-OPRF.

In our implementation we used parameter settings consis-
tent with PSSZ or stricter, and ran their and our code on
our system so as to obtain meaningful comparisons. As do
PSSZ, we use matrix transposition code from [1] and several
other optimizations.
6.1 Choosing Suitable Parameters

In this section we discuss concrete parameters used in our
implementation. We use a computational security parame-
ter of κ = 128 and a statistical security parameter of σ = 40.

The other parameters are:

s: the maximum size of the stash for Cuckoo hashing,
when hashing n items into 1.2n using 3 hash functions.

k: length of the pseudorandom code (and hence the width
of the OT extension matrix) in the BaRK-OPRF pro-
tocol.

v: output length of the PRF realized by the BaRK-OPRF

protocol.

826n
28
212
216
220
224

s
12
6
4
3
2

k
424
432
440
448
448

v
56
64
72
80
88

Table 2: Parameters used in our implementation. n
is the size of the parties’ input sets; s is the maxi-
mum stash size for Cuckoo hashing; k is the width
of the pseudorandom code (in bits); v is the length
of OPRF output (in bits).

A summary of our concrete parameter choices is given in
Table 2. Below we describe how these parameters were de-
rived.

Hashing parameters.

Bob uses Cuckoo hashing with 3 hash functions to assign
his n items into 1.2n bins (and a stash). For the appropriate
choice of the stash size s, we use the numbers given in [27],
which limit the probability of hashing failure to 2−40.

Size of pseudorandom code.

Our BaRK-OPRF protocol requires a pseudorandom code
achieving minimum distance κ = 128. In our protocol, Alice
evaluates the PRF on (3 + s)n values.
In order to argue
that these values can be collectively pseudorandom, so we
require the underlying PRF to have m-RK-PRF security
(Deﬁnition 3) for m = (3 + s)n.

From Lemma 2, this means we must choose a pseudoran-
dom code with parameters (d = κ,  = σ + log m). Using
Lemma 1, we calculate the minimum length of such a pseu-
dorandom code; the results are column k in Table 2. We
round up to the nearest multiple of 8 so that protocol mes-
sages will always be whole bytes.

Length of OPRF outputs.

The length of OPRF output controls the probability of
a spurious collision in the PSI protocol. In Section 5.2 we
argued that output length of σ + log2(n2) is suﬃcient to
bound the probability of any spurious collision to 2−σ.

Using σ = 40, we compute the appropriate length in col-
umn v of Table 2. We round up to the nearest multiple of 8
so that protocol messages will always be whole bytes.
6.2 Environment settings

All of our experiments were implemented on a server with
Intel(R) Xeon(R) CPU E5-2699 v3 2.30GHz CPU and 256
GB RAM. We run both clients on the same machine, but
simulate a LAN and WAN connection using the Linux tc
command. In the WAN setting, the average network band-
width and the average (round-trip) latency are set to be 50
MB/s and 96 ms, respectively. In the LAN setting, the net-
work has 0.2ms latency. All of our experiments use a single
thread for each party.
6.3 Implementation Details
In our BaRK-OPRF protocol, the oﬄine phase is con-
ducted to obtain an OT extension matrix of size (1.2n+s)×k
by using the IKNP OT extension. Speciﬁcally, ﬁrst we

use the Naor-Pinkas construction [21] to get 128 base-OTs,
which are then extended to a k × 128 matrix by utilizing
the pseudorandom generator. The transpose of this matrix
yields the k base OTs for the BaRK-OPRF extension proto-
col. We extend to 1.2n + s OPRF instances.

We hash all inputs of both client and server at the begin-
ning of the online phase. Following Lemma 1, we use a PRF
with suitably long output as our pseudorandom code. More
concretely, the parties agree on an AES-128 key sk, which
is independent of their inputs, and then extend the output
of AES via:
C(x) = AESsk(1(cid:107)x)(cid:107)AESsk(2(cid:107)x)(cid:107)AESsk(3(cid:107)x)(cid:107)AESsk(4(cid:107)x)

to obtain the desired k random output bits. Furthermore,
to reduce the waiting time at the server side, the client will
constantly send a new packet encompassing multiple code
words to the server. Based on trail-and-error approach, the
packet size of 212 × k bits is selected to minimize the waiting
time. In Table 4, we report the running time of our proto-
col for both oﬄine and online phases in diﬀerent settings.
For instance, in LAN environment, the online phase of our
BaRK-OPRF protocol takes about 3.2s for n = 220.

To illustrate the eﬃcacy of the BaRK-OPRF-PSI approach,
we compared it with a na¨ıve hashing protocol and the
PSSZ protocol. The na¨ıve hashing protocol is a widely-
used insecure protocol [27] where both parties use the same
cryptographic hash function to hash their elements, then
one of the parties permutes their hash value and sends the
result to the other party, who will compute the intersection
by computing the match of the hash values. In the following,
we conducted several performance tests with the input sets
of equal size n and for inputs of length 32, 64, and 128 bits.
Note that the running time of our PSI protocol does not
depend on the bit length of the input. It can be explained
as follows. First, the upper bound of the length of the input
is 128 bits. Second, the hash function will call a block of
128 bits to encrypt the input data, thus our protocol has
the same computation cost for all bit length of the input. In
addition, the communication cost of our BaRK-OPRF pro-
tocol depends only on the length of the pseudorandom code
k and the length v of the OPRF outputs, which are inde-
pendent of the bit length (cid:96). Similarly, the na¨ıve hashing
protocol does not depend on (cid:96). This was conﬁrmed by our
simulation results for diﬀerent bit lengths (e.g. 32 bits, 64
bits, and 128 bits). Table 3 presents the running time of the
na¨ıve hashing protocol, PSSZ, and our PSI protocol in both
LAN and WAN environment.

As we can see in the tables, our protocol outperforms
PSSZ in almost all the case studies, especially for the long
bit length of input (cid:96) and large values of the input size n. For
example, we consider the results in the LAN setting. For the
input size of 220, our approach can improve 2.8 times and
3.6 times the performance of PSSZ for the bit lengths of 64
bits and 128 bits, respectively. For the input size of 224, the
corresponding improvements are 2.3 times and 3.6 times. It
is worth mentioning that it takes about 1 minute to compute
the intersection for the sets of size n = 224. Similar obser-
vations can be inferred from Table 3 for the WAN setting.
At the same time, for smaller bit lengths, the PSSZ pro-
tocol can be faster than our PSI protocol. This is the case,
for example, when the bit length is 32 bits and n = 224
in LAN setting. Since the two protocols are very similar,
diﬀering only in the choice of OPRF subprotocol, it would

827Setting

Protocol

(insecure) na¨ıve hashing

LAN

PSSZ

BaRK-OPRF-PSI

(insecure) na¨ıve hashing

WAN

PSSZ

BaRK-OPRF-PSI

Bit length (cid:96)
{32, 64, 128}

32
64
128

{32, 64, 128}
{32, 64, 128}

32
64
128

{32, 64, 128}

28
1
306
306
307
192
97
609
624
624
556

212
6
380
442
443
211
101
701
742
746
585

75
770
1,236
1,352
387
180
1,425
2,142
2,198
1,259

set size n
216

220
759
4,438
10,501
13,814
3,780
1,422
8,222
18,398
23,546
7,455

224
13,529
42,221
137,383
213,597
58,567
22,990
81,234
248,919
381,913
106,828

Table 3: Running time in ms for PSI protocols with n elements per party

LAN

Setting Phase
Oﬄine
Online
Oﬄine
Online

WAN

28
171
21
291
265

212
171
40
313
272

set size n
216
216
171
316
943

220
601
3,179
758
6,697

224
7,615
50,952
7,482
99,346

Table 4: Running time of our BaRK-OPRF protocol in ms in oﬄine and online phases

Protocol

na¨ıve hashing

Bit length (cid:96)
{32, 64, 128}

PSSZ

BaRK-OPRF-PSI

32
64
128

{32, 64, 128}

28
0.01
0.06
0.09
0.10
0.04

212
0.03
0.77
1.37
1.52
0.53

set size n
216
0.56
9.18
18.78
23.58
8.06

220
10.00
142.80
296.40
411.60
127.20

224
176.00
1,574.40
4,032.00
6,489.60
1,955.20

Asymptotic [bit]

nv

2κ(1.2n + s)(cid:100) min(v(cid:48),(cid:96))−log(n)

8

(cid:101) + (3 + s)nv(cid:48)

k(1.2n + s) + (3 + s)nv

Table 5: Communication in MB for PSI protocols with n elements per party. Parameters k, s, and v refer to
those in Table 2 / Section 6.1. PSSZ requires slightly long OPRF outputs: v(cid:48) = σ + log(3n2). Communication
costs for PSSZ and for our protocol ignore the ﬁxed cost of base OTs for OT extension.

be relatively straightforward to implement a hybrid that al-
ways chooses the best OPRF subprotocol based on n and
(cid:96) according to Table 1. However, in order to clarify the
strengths/weaknesses of the two protocols, we report the
performance for our approach even when it is worse.
Similar to the running time result, our communication
cost is 2.9–3.3× faster than Pinkas et al. for PSI of 128-
bit strings and suﬃciently large sets. Concretely, for the
input size of 220, our protocol can improve 3.2 times the
performance of PSSZ for the bit lengths 128 bits. Table 5
presents the communication (in MB) of the na¨ıve hashing
protocol, PSSZ, and our BaRK-OPRF-PSI protocol.

Acknowledgments
We thank Peter Rindal for contributing libraries and helpful
suggestions to our protocol implementation. We also thank
Michael Zohner for answering our many questions about the
implementation of [27]. Finally, we thank the anonymous
CCS reviewers for their helpful feedback.

The ﬁrst author is supported by the Oﬃce of Naval Re-
search (ONR) contract number N00014-14-C-0113. The sec-
ond author is supported by NSF Grants CNS-1350619 and
CNS-1414119, in part by the Defense Advanced Research
Projects Agency (DARPA) and the U.S. Army Research Of-

ﬁce under contracts W911NF-15-C-0226, and an MIT Trans-
lational Fellowship. The third and fourth authors are sup-
ported by NSF award 1149647 and a Google research award.
This work was initiated while the ﬁrst three authors were
visiting the Simons Institute for the Theory of Comput-
ing, supported by the Simons Foundation and by the DI-
MACS/Simons Collaboration in Cryptography through NSF
grant #CNS-1523467.

7. REFERENCES
[1] Asharov, G., Lindell, Y., Schneider, T., and Zohner,

M. More eﬃcient oblivious transfer and extensions for faster
secure computation. In Sadeghi et al. [29], pp. 535–548.

[2] Asharov, G., Lindell, Y., Schneider, T., and Zohner,

M. More eﬃcient oblivious transfer extensions with security
for malicious adversaries. In EUROCRYPT 2015, Part I
(Soﬁa, Bulgaria, Apr. 26–30, 2015), E. Oswald and
M. Fischlin, Eds., vol. 9056 of LNCS, Springer, Heidelberg,
Germany, pp. 673–701.

[3] Camenisch, J., Neven, G., and shelat, a. Simulatable

adaptive oblivious transfer. In EUROCRYPT 2007
(Barcelona, Spain, May 20–24, 2007), M. Naor, Ed.,
vol. 4515 of LNCS, Springer, Heidelberg, Germany,
pp. 573–590.

[4] Dodis, Y., and Yampolskiy, A. A veriﬁable random

function with short proofs and keys. In PKC 2005 (Les
Diablerets, Switzerland, Jan. 23–26, 2005), S. Vaudenay,

828Proceedings of the 13th Conference on USENIX Security
Symposium - Volume 13 (Berkeley, CA, USA, 2004),
SSYM’04, USENIX Association, pp. 20–20.

[21] Naor, M., and Pinkas, B. Eﬃcient oblivious transfer

protocols. In Proceedings of the Twelfth Annual
ACM-SIAM Symposium on Discrete Algorithms
(Philadelphia, PA, USA, 2001), SODA ’01, Society for
Industrial and Applied Mathematics, pp. 448–457.

[22] Naor, M., and Reingold, O. Number-theoretic

constructions of eﬃcient pseudo-random functions. Journal
of the ACM 51, 2 (2004), 231–262.

[23] Nielsen, J. B. Extending oblivious transfers eﬃciently -
how to get robustness almost for free. Cryptology ePrint
Archive, Report 2007/215, 2007. ia.cr/2007/215.

[24] Nielsen, J. B., Nordholt, P. S., Orlandi, C., and

Burra, S. S. A new approach to practical active-secure
two-party computation. In CRYPTO 2012 (Santa Barbara,
CA, USA, Aug. 19–23, 2012), R. Safavi-Naini and
R. Canetti, Eds., vol. 7417 of LNCS, Springer, Heidelberg,
Germany, pp. 681–700.

[25] Opsahl, K. The disconcerting details: How Facebook
teams up with data brokers to show you targeted ads.
https://www.eﬀ.org/deeplinks/2013/04/disconcerting-
details-how-facebook-teams-data-brokers-show-you-
targeted-ads, 2013. [Online; accessed
23-May-2016].

[26] Pagh, R., and Rodler, F. F. Cuckoo hashing. J.

Algorithms 51, 2 (2004), 122–144.

[27] Pinkas, B., Schneider, T., Segev, G., and Zohner, M.
Phasing: Private set intersection using permutation-based
hashing. In 24th USENIX Security Symposium, USENIX
Security 15 (2015), J. Jung and T. Holz, Eds., USENIX
Association, pp. 515–530.

[28] Pinkas, B., Schneider, T., and Zohner, M. Faster

private set intersection based on OT extension. In 23rd
USENIX Security Symposium, USENIX Security 14
(2014), K. Fu and J. Jung, Eds., USENIX Association,
pp. 797–812.

[29] Sadeghi, A.-R., Gligor, V. D., and Yung, M., Eds. ACM

CCS 13 (Berlin, Germany, Nov. 4–8, 2013), ACM Press.

[30] Yao, A. C.-C. How to generate and exchange secrets

(extended abstract). In 27th FOCS (Toronto, Ontario,
Canada, Oct. 27–29, 1986), IEEE Computer Society Press,
pp. 162–167.

[31] Yung, M. From mental poker to core business: Why and

how to deploy secure computation protocols?
https://www.sigsac.org/ccs/CCS2015/pro keynote.html,
2015. ACM CCS 2015 Keynote Talk.

Ed., vol. 3386 of LNCS, Springer, Heidelberg, Germany,
pp. 416–431.

[5] Faust, S., Hazay, C., and Venturi, D. Outsourced

pattern matching. In ICALP 2013, Part II (Riga, Latvia,
July 8–12, 2013), F. V. Fomin, R. Freivalds, M. Z.
Kwiatkowska, and D. Peleg, Eds., vol. 7966 of LNCS,
Springer, Heidelberg, Germany, pp. 545–556.

[6] Freedman, M. J., Ishai, Y., Pinkas, B., and Reingold,
O. Keyword search and oblivious pseudorandom functions.
In TCC 2005 (Cambridge, MA, USA, Feb. 10–12, 2005),
J. Kilian, Ed., vol. 3378 of LNCS, Springer, Heidelberg,
Germany, pp. 303–324.

[7] Goldreich, O. Foundations of Cryptography, Volume 2:

Basic Applications. Cambridge University Press, The
address, 2004.

[8] Goldreich, O., Micali, S., and Wigderson, A. How to

play any mental game or A completeness theorem for
protocols with honest majority. In 19th ACM STOC (New
York City
”
Ed., ACM Press, pp. 218–229.

New York, USA, May 25–27, 1987), A. Aho,

[9] Hazay, C. Oblivious polynomial evaluation and secure

set-intersection from algebraic PRFs. In TCC 2015, Part II
(Warsaw, Poland, Mar. 23–25, 2015), Y. Dodis and J. B.
Nielsen, Eds., vol. 9015 of LNCS, Springer, Heidelberg,
Germany, pp. 90–120.

[10] Hazay, C., and Lindell, Y. Eﬃcient protocols for set
intersection and pattern matching with security against
malicious and covert adversaries. Journal of Cryptology 23,
3 (July 2010), 422–456.

[11] Huberman, B. A., Franklin, M. K., and Hogg, T.

Enhancing privacy and trust in electronic communities. In
EC (1999), pp. 78–86.

[12] Ishai, Y., Kilian, J., Nissim, K., and Petrank, E.

Extending oblivious transfers eﬃciently. In CRYPTO 2003
(Santa Barbara, CA, USA, Aug. 17–21, 2003), D. Boneh,
Ed., vol. 2729 of LNCS, Springer, Heidelberg, Germany,
pp. 145–161.

[13] Jarecki, S., and Liu, X. Eﬃcient oblivious pseudorandom

function with applications to adaptive OT and secure
computation of set intersection. In TCC 2009 (Mar. 15–17,
2009), O. Reingold, Ed., vol. 5444 of LNCS, Springer,
Heidelberg, Germany, pp. 577–594.

[14] Keller, M., Orsini, E., and Scholl, P. Actively secure
OT extension with optimal overhead. In CRYPTO 2015,
Part I (Santa Barbara, CA, USA, Aug. 16–20, 2015),
R. Gennaro and M. J. B. Robshaw, Eds., vol. 9215 of
LNCS, Springer, Heidelberg, Germany, pp. 724–741.

[15] Kilian, J. Founding cryptography on oblivious transfer. In
20th ACM STOC (Chicago, Illinois, USA, May 2–4, 1988),
ACM Press, pp. 20–31.

[16] Kolesnikov, V. Gate evaluation secret sharing and secure

one-round two-party computation. In ASIACRYPT 2005
(Chennai, India, Dec. 4–8, 2005), B. K. Roy, Ed., vol. 3788
of LNCS, Springer, Heidelberg, Germany, pp. 136–155.
[17] Kolesnikov, V., and Kumaresan, R. Improved secure
two-party computation via information-theoretic garbled
circuits. In SCN 12 (Amalﬁ, Italy, Sept. 5–7, 2012),
I. Visconti and R. D. Prisco, Eds., vol. 7485 of LNCS,
Springer, Heidelberg, Germany, pp. 205–221.

[18] Kolesnikov, V., and Kumaresan, R. Improved OT

extension for transferring short secrets. In CRYPTO 2013,
Part II (Santa Barbara, CA, USA, Aug. 18–22, 2013),
R. Canetti and J. A. Garay, Eds., vol. 8043 of LNCS,
Springer, Heidelberg, Germany, pp. 54–70.

[19] Kolesnikov, V., and Malozemoff, A. J. Public

veriﬁability in the covert model (almost) for free. In
ASIACRYPT 2015, Part II (Auckland, New Zealand,
Nov. 30 – Dec. 3, 2015), T. Iwata and J. H. Cheon, Eds.,
vol. 9453 of LNCS, Springer, Heidelberg, Germany,
pp. 210–235.

[20] Malkhi, D., Nisan, N., Pinkas, B., and Sella, Y.
Fairplay—a secure two-party computation system. In

829