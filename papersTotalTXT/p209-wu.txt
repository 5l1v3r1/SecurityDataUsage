Efﬁcient Large Flow Detection over Arbitrary Windows: An

Algorithm Exact Outside An Ambiguity Region

Hao Wu

University of Illinois at
Urbana-Champaign

Hsu-Chun Hsiao

Carnegie Mellon University
National Taiwan University

Yih-Chun Hu

University of Illinois at
Urbana-Champaign

ABSTRACT
Many networking and security applications can beneﬁt from
exact detection of large ﬂows over arbitrary windows (i.e.
any possible time window). Existing large ﬂow detectors
that only check the average throughput over certain time
period cannot detect bursty ﬂows and are therefore easily
fooled by attackers. However, no scalable approaches pro-
vide exact classiﬁcation in one pass. To address this chal-
lenge, we consider a new model of exactness outside an ambi-
guity region, which is deﬁned to be a range of bandwidths be-
low a high-bandwidth threshold and above a low-bandwidth
threshold. Given this new model, we propose a deterministic
algorithm, EARDet, that detects all large ﬂows (including
bursty ﬂows) and avoids false accusation against any small
ﬂows, regardless of the input traﬃc distribution. EARDet
monitors ﬂows over arbitrary time windows and is built on a
frequent items ﬁnding algorithm based on average frequency.
Despite its strong properties, EARDet has low storage over-
head regardless of input traﬃc and is surprisingly scalable
because it focuses on accurate classiﬁcation of large ﬂows
and small ﬂows only. Our evaluations conﬁrm that existing
approaches suﬀer from high error rates (e.g., misclassifying
1% of small ﬂows as large ﬂows) in the presence of large ﬂows
and bursty ﬂows, whereas EARDet can accurately detect
both at gigabit line rate using a small amount of memory
that ﬁts into on-chip SRAM.

Categories and Subject Descriptors
C.2.3 [Computer-Communication Networks]: Net-
work Operations—Network monitoring; C.2.0 [Computer-
Communication Networks]: General—Security and pro-
tection

Keywords
Large Flow Detection; Flow Classiﬁcation; Ambiguity
Region; Arbitrary Windows

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
IMC’14, November 5–7, 2014, Vancouver, BC, Canada.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-3213-2/14/11 ...$15.00.
http://dx.doi.org/10.1145/2663716.2663724.

1.

INTRODUCTION

Being able to identify large ﬂows1 over any possible time
window (referred to as the arbitrary window model ) is of
great importance for a wide variety of networking and se-
curity applications such as traﬃc engineering, accounting,
anomaly detection, and Denial-of-Service (DoS) defense.
The arbitrary window model monitors time windows on
all time-scales, starting at each instant in time and end-
ing at the current time, and can thus detect bursty ﬂows
and outperform models that are based on ﬁxed-length win-
dows. Given the high traﬃc volumes in today’s Internet, no
scalable approaches provide exact classiﬁcation in one pass.
Thus, we consider a novel model of exactness outside a
small ambiguity region, which contains ﬂows that use band-
width between two conﬁgurable thresholds. Our model clas-
siﬁes ﬂows as either large, medium, or small. A ﬂow is de-
ﬁned to be a large ﬂow if there exists a time window in
which the bandwidth of the ﬂow exceeds the high-bandwidth
threshold. A small ﬂow is deﬁned to be a ﬂow whose vol-
ume is consistently lower than a low-bandwidth threshold
function over all arbitrary window. The rest are deﬁned as
medium ﬂows, or the ﬂows in the ambiguity region. Ex-
actness outside an ambiguity region guarantees perfect de-
tection of large ﬂows (including bursty ﬂows) and no false
accusation against any small ﬂows. This model is reason-
able because it limits the damage caused by large ﬂows and
allows existing techniques to handle the medium ﬂows sta-
tistically. Prior work [17] [16] adopts a similar concept, yet
they can only provide probabilistic bounds outside a re-
gion. The ambiguity region between the high-bandwidth
and low-bandwidth thresholds allows us to trade the level of
exactness for scalability, so that we can maintain state small
enough to ﬁt into limited on-chip memory for link-speed up-
date.

The new models of exactness and arbitrary window beneﬁt

many applications. For example:

• Detecting various DoS ﬂows: Denial-of-Service (DoS)
attacks use a combination of large attack ﬂows and
bursty attack ﬂows. Flows that are only bursty are
hard to catch due to their low average traﬃc band-
width. However, using the arbitrary window model, a
detector can instantly detect DoS attempts that use
bursty ﬂows [25].

• Bandwidth guarantees: To enforce bandwidth allo-
cation, schemes such as IntServ make impractical
1Large ﬂows are ﬂows that consume more than a threshold
amount of bandwidth. They are also called elephant ﬂows
in the literature.

209assumptions that either every router keeps per-ﬂow
state [33] or ﬁrst-hop routers are trusted to regulate
traﬃc on a per-ﬂow basis [36] on behalf of intermediate
routers [34]. Although a scalable and robust approach
was proposed [28], it causes collateral damage due to
the detection delay. Moreover, it cannot catch bursty
ﬂows. Our eﬃcient detector built upon these two new
models can help enforce bandwidth limits on ﬂows be-
cause it enables fast detection with no false accusation
on the legitimate small ﬂows and no missed detection
on large ﬂows including bursty ﬂows.

To the best of our knowledge, none of the existing algo-
rithms provide exactness outside an ambiguity region under
the arbitrary window model. Prior algorithms monitoring
average throughput (e.g., algorithms based on ﬁxed win-
dow and sliding window models) cannot detect bursty at-
tacks. For example, in a large-ﬂow detection system that
resets state and starts a new measurement interval periodi-
cally [17], a large bursty ﬂow can bypass detection by staying
lower than the threshold of throughput across this whole in-
terval, or even by deliberately spreading its burst across two
consecutive intervals. Although randomization of measure-
ment intervals can mitigate the problem of a burst spread
across a measurement interval, randomized algorithms may
be unable to provide strong deterministic guarantees.

In addition to lacking exactness and the arbitrary window
model, the storage overhead of existing algorithms may grow
unboundedly with the size of the input traﬃc in the presence
of malicious inputs. For example, an adversary can perturb
his traﬃc patterns (e.g., by varying the size and timing of
packets) so as to cause algorithmic complexity attacks [11]
because many algorithms bound their storage and compu-
tational overhead by assuming that the ﬂow sizes follow a
certain distribution, such as Zipﬁan.

To identify large ﬂows over arbitrary windows with low
storage overhead, we explore deterministic algorithms with
a new model of exactness considering a small ambiguity
region. We propose EARDet (Exact-Outside-Ambiguity-
Region Detector), a simple, eﬃcient, and no-per-ﬂow-state
large-ﬂow detector which is exact outside an ambiguity re-
gion regardless of the input traﬃc distribution. Built on
the Misra-Gries algorithm (a two-pass frequent items ﬁnd-
ing algorithm based on average frequency) [31], EARDet is
a one-pass streaming algorithm with simple operations:
it
only keeps a small array of counters which are increased or
decreased as each new packet arrives. A ﬂow is identiﬁed as
a large ﬂow if its associated counter exceeds a threshold.

Surprisingly, despite EARDet’s strong guarantees, we
show in our analysis that EARDet requires extremely small
amounts of memory that ﬁt into on-chip SRAM for line-
speed packet processing. We discuss implementation details
to further demonstrate EARDet’s eﬃciency. EARDet is
highly scalable because it focuses on the accurate classiﬁca-
tion of large and small ﬂows; unlike prior approaches, it does
not aim to estimate ﬂow volumes or identify the medium
ﬂows. In addition to our theoretical analysis, we also evalu-
ate EARDet using extensive simulations based on real traf-
ﬁc traces. We demonstrate that existing approaches suﬀer
from high error rates under DoS attacks, whereas EARDet
can eﬀectively detect large ﬂows in the face of both ﬂooding
and burst DoS attacks [22, 25].

Our main contributions are as follows.

• We propose a deterministic streaming algorithm that
is exact outside an ambiguity region regardless of the
input traﬃc. Two novel settings distinguish EARDet
from previous work:
it monitors ﬂows over arbitrary
windows, and it supports exact detection outside an
ambiguity region.

• We rigorously prove the two guarantees—catching all
large ﬂows and preventing false accusation on any
small ﬂows—without making assumptions about the
ﬂow size distribution.

• Our numerical analysis shows that EARDet can oper-
ate at 40 Gbps high-speed links using only hundreds of
bytes of on-chip SRAM, which is substantially smaller
than the memory consumption in many existing sys-
tems. We also provide guidelines on how to conﬁgure
EARDet to satisfy application-speciﬁc requirements.

• We compare EARDet with two closely related pro-
posals [16, 17] via comparative analysis and extensive
simulations based on real and synthetic traﬃc traces.
The results conﬁrm that these two are vulnerable to
attack ﬂows that manipulate the input traﬃc, while
EARDet consistently catches all large ﬂows without
misclassifying small ﬂows.

2. PROBLEM DEFINITION

Our goal is to design an eﬃcient arbitrary-window-based
algorithm which is exact outside an ambiguity region.
In
this section, we present the system model, formulate the
large ﬂow problem over arbitrary windows, and summarize
our design goals.

2.1 System Model

Flow identiﬁers.
Generally, packets are classiﬁed into
ﬂows based on the ﬂow identiﬁers (or ﬂow IDs) derived from
the packet header ﬁelds.2 Because our approach to large-
ﬂow detection is generic, we make no assumption on the
deﬁnition of ﬂow IDs. As in prior traﬃc monitoring work,
we assume ﬂow IDs are unforgeable, which is achievable by
ingress ﬁltering [19] and source authentication [4, 24, 27, 32].

Packet streams.
Let X be the packet space. We con-
sider a packet stream X = hx1, · · · , xki coming through a
link of capacity ρ, where xi ∈ X ∀i = 1 · · · k. Packets in
X are processed in sequence by a detection algorithm for
identifying large ﬂows. The algorithm can only make one
pass over the packet stream due to the high link capacity
and limited memory.

For a packet x, we denote by time(x) the time at which
the detection algorithm observes the packet, by size(x) the
size of the packet, and by ﬁd(x) the ﬂow ID of the packet.
The traﬃc volume of a ﬂow f during a time window [t1, t2) is
deﬁned as vol(f, t1, t2) , Px∈X ,ﬁd(x)=f,t1≤time(x)<t2
A traﬃc synopsis is a data structure that
Synopses.
summarizes ﬂows and can be used to answer queries regard-
ing certain ﬂow statistics. When a new packet x arrives,
the algorithm updates its traﬃc synopsis based on x’s ﬂow

size(x).

2While the ﬂow deﬁnitions vary depending on the applica-
tions, in most applications a ﬂow consists of packets that
share one or more header ﬁelds, such as the source IP, des-
tination IP, source port, destination port, and the protocol
number.

21040 Gbps link congested
by 50-Byte packets

A

B

C

D

B

0

10

20

30

40

t=50 (ns)

Landmark window model
(Landmark at 0)

Sliding window model
(window size=30ns)

Arbitrary window model

Examine flows in [0, t) → flow B evades detection

Examine flows in [t-30, t) →  flow B evades detection

Examine flows in [s, t) for all t > s ≥ 0 →  
flow B is a large flow over [10, 50) and can be detected

Figure 1: In this example, a ﬂow is large if it sends
more than 40M bps · w + 500kb for any time window of
size w. Although ﬂow B violates the limit over the
time window [10, 50), it can only be caught in the
arbitrary window model.

ID, size, and arrival time. Formally, a large-ﬂow detection
algorithm supports three operations over a synopsis S:

• Init(params) → S0. The initialization operation takes
as inputs the large-ﬂow deﬁnitions and desired detec-
tion accuracy, etc.

• Update(Si−1, xi) → Si. The update operation out-
puts an updated synopsis Si by incorporating the
new packet xi into the previous synopsis Si−1. For
convenience, we denote Update(Si, hxi+1, · · · , xi+ji) =
Update(Si+1, hxi+2, · · · , xi+ji) = Si+j.

• Detect(Si, xi) → b ∈ {0, 1}. The detection operation
evaluates Si to determine if xi belongs to a large ﬂow.

Prior approaches to large-ﬂow
Time window models.
detection can be classiﬁed into three main categories based
on the type of time window they monitor:
landmark win-
dow [10, 14, 17, 18, 23, 29–31], sliding window [5, 21, 26], and
arbitrary window [16].

In the landmark window model, each time window starts
at the closest landmark in the past (e.g., a landmark is
placed every ﬁve seconds) and ends at the current time. In
the sliding window model, recent traﬃc is considered more
important than old traﬃc, so the time window begins at
some recent time in the past. The window slides as new
packets arrive, such that the measurement incorporates the
new packets and excludes the oldest packets. Finally, the ar-
bitrary window model monitors every time window ending
at the current time. It is more diﬃcult to evade detection in
this model than in others, as illustrated in Figure 1. Note
that while the arbitrary window model covers every possi-
ble window, ﬂows can still evade detection if the detection
algorithm is inaccurate.

Detection Algorithm

Report

xi+2

xi+1

xi

Incoming Packet Stream

Report

Limited
Memory

Figure 2: A general framework for a large-ﬂow-
detection algorithm. The detection algorithm pro-
cesses incoming ﬂows and keeps limited state in
memory. Results may be reported to a remote
server for further analysis.

THℓ(t) = γℓt + βℓ, where γh > γℓ > 0 and βh > βℓ > 0.3 Al-
though selecting appropriate parameters largely depends on
the targeted application, we provide guidelines for selecting
these parameters in Section 4.

Exact-outside-ambiguity-region large-ﬂow problem.
As exact solutions are ineﬃcient, we consider a relaxed no-
tion of exactness:

Definition 1. Given a packet stream, the exact-outside-
ambiguity-region large-ﬂow problem returns a set of ﬂows F
such that (1) F contains every large ﬂow, and (2) F does
not contain any small ﬂow.

Because the number of large ﬂows can increase indeﬁnitely
over time, F may become too large to ﬁt into the limited
on-chip memory. Hence, such an algorithm often reports to
a remote server with mass storage that keeps a complete
copy of F , as illustrated in Figure 2. The algorithm must
therefore operate correctly even without a complete copy of
F .

A positive is when a ﬂow is added to F , and a negative
is when a ﬂow is not added to F . Hence, a False Positive
of small ﬂow (FPs) occurs when the detection algorithm
wrongly adds a small ﬂow, and a False Negative of large
ﬂow (FNℓ) occurs when it fails to include a large ﬂow.

The exact-outside-ambiguity-region large-ﬂow problem is
reasonable for two reasons: (1) It conﬁnes the damage by
large ﬂows and allows existing techniques (e.g., Sample and
Hold [17]) to handle the medium ﬂows statistically. (2) Prior
work [17] [16] also involves a region similar to our ambiguity
region, but they only provide probabilistic bounds outside
the region.

2.3 Design Goals

2.2 Large-Flow Problem Over Arbitrary

Our main goals are as follows:

Windows

Small, medium, and large ﬂows.
A ﬂow f is a large
ﬂow if there exists a time window [t1, t2) over which its vol-
ume vol(f, t1, t2) exceeds a high-bandwidth threshold func-
tion THh(t2 − t1). A ﬂow is a small ﬂow if its volume
vol(f, t1, t2) is lower than a low-bandwidth threshold func-
tion THℓ(t2 − t1) over all possible time windows [t1, t2). The
rest are deﬁned as medium ﬂows, i.e. ﬂows in an ambiguity
region.

In this paper we deﬁne the two threshold functions in the
form of leaky bucket descriptors: THh(t) = γht + βh and

Exactness outside an ambiguity region.
To achieve
exactness outside an ambiguity region in traﬃc monitoring,
we desire a deterministic monitor algorithm which identi-
ﬁes every large ﬂow including bursty ﬂow (i.e., no FNℓ)and
3Instead of using leaky bucket descriptors, prior work in the
landmark window model often deﬁnes the high-bandwidth
threshold to be a fraction of the link bandwidth, e.g.,
γh = 0.01 and βh = 0. However, it is infeasible to adopt
this fraction-based deﬁnition when it comes to the arbitrary
window model because every ﬂow will violate the threshold
over a suﬃciently small time window (e.g., a window con-
taining only one packet).

211protects every small ﬂow (i.e., no FPs) with no assump-
tion on the input traﬃc or attack pattern. Hence, the high-
bandwidth and low-bandwidth thresholds are also called the
no-FNℓ and no-FPs thresholds in this paper, respectively.

Scalability.
Although using per-ﬂow leaky buckets en-
ables exact and instantaneous detection of large ﬂows, keep-
ing per-ﬂow state is impractical due to the large number
of ﬂows in the Internet. Hence, the algorithm should re-
quire few per-packet operations and maintain small router
state that ﬁts in fast yet scarce storage devices (e.g., on-chip
SRAM or even registers) regardless of input traﬃc or attack
pattern, such that the detection algorithm can operate at
line rate.

Fast detection.
Fast detection of large ﬂows minimizes
collateral damage. Hence, for a large ﬂow violating the high-
bandwidth threshold over [t1, t2), the algorithm should de-
tect the ﬂow no later than t2 + tprocess, where tprocess is the
time it takes to process a packet.

3. ALGORITHM

In this section, we ﬁrst investigate and prove the no-
FPs and no-FNℓ relationships between landmark and arbi-
trary window models because they are useful for construct-
ing large-ﬂow algorithms over arbitrary windows. Based on
these relationships, we present EARDet, a streaming algo-
rithm that eﬃciently addresses the large-ﬂow problem over
arbitrary windows (as deﬁned in Deﬁnition 1) with exactness
outside an ambiguity region. Finally, we discuss the imple-
mentation and optimization techniques in detail, and numer-
ically demonstrate that EARDet can operate at high-speed
links while using only hundreds bytes of on-chip SRAM.

It is important to investigate the relationships between
landmark and arbitrary window models because they enable
us to draw on the rich experience of research on the large-
ﬂow problem over landmark windows [10,14,17,18,23,29–31]
for designing arbitrary-window algorithms. Particularly, we
are interested in knowing whether and to what extent we
can leverage existing landmark-window algorithms to build
arbitrary-window ones. The technical contributions of this
paper include proving two theorems that shed light toward
a systematic approach applying existing landmark-window
algorithms to arbitrary-window algorithms.

EARDet leverages the Misra-Gries (MG) algorithm [31],
which ﬁnds all frequent items in a data stream in one pass
but may falsely include non-frequent items. The MG algo-
rithm works over landmark windows in the sense that the
landmark is at the beginning of the data stream. The re-
search challenges here include (1) how to preserve MG’s
no-FNℓ property (over landmark windows) when porting
it to the arbitrary window model, and (2) how to achieve
the no-FPs property when processing packets in one pass.
EARDet modiﬁes the MG algorithm in several novel ways
to eﬀectively address the above challenges.
Interestingly,
despite these simple modiﬁcations, we prove that EARDet
achieves both no-FPs and no-FNℓ properties over arbitrary
windows, thereby providing strong guarantees regardless of
input traﬃc.

3.1 Relationships Between Landmark and

Arbitrary Windows

Here is a straightforward yet ineﬃcient solution to the
exact-outside-ambiguity-region large-ﬂow problem over arbi-

trary windows: the algorithm divides the problem into mul-
tiple sub-problems that each can be handled by a landmark-
window algorithm, L. More concretely, let Li be a copy
of L that monitors a time window starting from packet xi
and ending at the current time. For every newly arrived
packet xi, the algorithm initiates Li, and adds xi to the
new as well as all previous copies, L1, L2, · · · , Li. Then the
algorithm combines the answers returned by L1, L2, · · · , Li.
This straightforward solution is correct, but requires space
linear in the length of the traﬃc stream, which is pro-
hibitively expensive.

To make it more eﬃcient, the key idea is to eliminate
redundant copies of L. To show why this is possible, we
formally state two relationships between landmark windows
and arbitrary windows.

No-FPs relationship. We observe that only one copy
of L is needed to achieve the no-FPs property over arbitrary
window. Speciﬁcally, Theorem 2 states that if an algorithm
ensures (L1) no FPs in the landmark window model, then
it also ensures (A1) no FPs in the arbitrary window model.

Theorem 2. If an algorithm satisﬁes
• L1: For all t, it never reports a ﬂow whose volume is

below γ′

ℓt + β′

ℓ over time interval [0, t).

then it must also satisfy

• A1:

It never reports a ﬂow whose volume is below
γℓ(t2 −t1)+βℓ over time interval [t1, t2) for all t2 > t1.

when γ′

ℓ = γℓ and β′

ℓ = βℓ.

Proof sketch: L1 implies A1 because if a ﬂow sends less
than γℓ(t2 −t1)+βℓ for all intervals [t1, t2), it must also send
less than γ′
ℓ = γℓ and
β′
ℓ = βℓ. (cid:4)

ℓ for all intervals [0, t) when γ′

ℓt + β′

No-FNℓ relationship. The no-FNℓ relationship is more
challenging to prove. We observe that only one copy of L is
needed to achieve the no-FNℓ property if L’s traﬃc synopsis
is “similar” to the initial state throughout the execution of
the algorithm, as checking such a synopsis is roughly equiv-
alent to checking all of L1, L2, · · · , Li. In other words, we
can keep only one synopsis which somehow approximates
the synopsis in each sub-problem.

Formally, we deﬁne a distance metric dis(S, S′) quantify-

ing the similarity between two synopses:

dis(S, S′) ,

min

X,S ′=Update(S,X)

tspan(X)

where the time span of a packet sequence is deﬁned as
tspan(X) = maxx∈X time(x) − minx∈X time(x). S is deﬁned
as a snapshot of the algorithm’s internal state and thus does
not depend on time. The distance between two snapshots is
the shortest time it takes to convert one to the other given
a link capacity.

Theorem 3 states if an algorithm ensures (L2) no FNℓ
in the landmark window model and (L3) its synopsis is
bounded, it also ensures (A2) no FNℓ in the arbitrary win-
dow model.

Theorem 3. If an algorithm satisﬁes
• L2: For all t, it reports all ﬂows whose volume exceed

γ′
ht + β′

h over time interval [0, t).

• L3: Throughout the execution of L, dis(S0, Si) ≤
∆, where ∆ is a small constant and Si =
Update(S0, hx1, · · · , xii).

212then it must also satisfy

• A2:

It always reports a ﬂow whose volume exceeds
γh(t2 − t1) + βh over time interval [t1, t2) for some
t2 > t1.

when γh(t2 − t1) + βh ≥ γ′

h(t2 − t1 + ∆) + β′
h.

Proof sketch: Let L be an algorithm satisfying L2 and L3.
Let f be a ﬂow that sends more than γh(t2 − t1) + βh over
some time interval [t1, t2), and t2 is the smallest among all
possible values if the ﬂow f violates the spec multiple times.
To prove this No-FNℓ relationship, in the following we show
that L can catch any f when γh = γ′
h + γh∆,
thus satisfying A2 as well.

h and βh ≥ β′

For convenience, we denote by X b

a the incoming packet
stream between time interval [a, b). Since L satisﬁes L3 (i.e.,
the synopsis state of L is always bounded), dis(S0, St1 ) ≤ ∆
where St1 is its synopsis state at t1.

Based on the deﬁnition of the distance function, there
exists a packet sequence X ′ with a time span less than ∆ and
Update(S0, X ′) = St1 . In other words, from the algorithm’s
perspective, Update(S0, X t2
t1 ),4 i.e.,
the two packet sequences produce identical synopses. As a
result, if the algorithm L can detect f in X ′kX t2
t1 then it
can also detect f in X t2
0 because the output of the detection
function, Detect, solely depends on the synopsis.

0 ) = Update(S0, X ′kX t2

Moreover, by construction, f sends more than γh(t2 −
t1) + βh in the new sequence X ′kX t2
t1 , whose time span is
t2 − t1 + ∆. Therefore, L can detect f in the new sequence
because γh(t2 − t1) + βh ≥ γ′
h holds when
γh = γ′
h + γh∆. Hence, L can also detect f in
the original stream, X t2

h(t2 − t1 + ∆) + β′

h and βh ≥ β′

0 . (cid:4)

ℓ, β′

We note that L1 and A2 contradict each other for any
parameter selection: for any γ′
ℓ, γh, and βh, consider an
interval [t1, t2) satisfying t1 = t2 − ǫ and t2 > βh−β ′
ℓ+γhǫ+1
.
γ ′
ℓ
Then a ﬂow sending γh(t2 − t1) + βh + 1 over [t1, t2) will
violate the high bandwidth threshold over [t1, t2) but comply
with γ′
ℓ over [0, t2). That is, no algorithm can satisfy
(A2, L2, L3) and (A1, L1) at the same time.

ℓt2 + β′

The above two theorems can be viewed as guidelines for
designing new arbitrary-window algorithms based on exist-
ing landmark-window algorithms.

3.2 Algorithm Construction

Several existing landmark-window approaches [10, 14, 17,
23, 29–31] satisfy L2 when β′
h is set to zero. Among these
approaches, we observe that the MG algorithm [31] can be
made to satisfy L2 in a general setting (i.e., β′
h can be
non-zero) as well as L3 with slight modiﬁcations. As a re-
sult, we choose to leverage the MG algorithm for designing
EARDet.

We prove in the next section that EARDet’s design en-
sures L2 and L3, and therefore achieves the no-FNℓ prop-
erty (i.e., catching every large ﬂow) based on Theorem 3.
We also prove that EARDet achieves the no-FPs property
(i.e., protecting every small ﬂow), whereas the MG algo-
rithm requires a second pass to remove false positives in the
landmark window model.

Background of the MG algorithm. We brieﬂy review
the MG algorithm, which inspires our design. The MG algo-
rithm ﬁnds the exact set of frequent items (deﬁned as items
4k denotes concatenating two packet sequences into one se-
quence.

packet x

Is x blacklisted?

No

Counter update
for virtual !ows

Counter update

for x

Blacklist

Blacklist
Update

Yes

counter > 
threshold?

Figure 3: EARDet’s decision diagram.

that appear in a stream of m items for more than m
n+1 times)
in two passes with only n counters. This algorithm gener-
alizes the Majority algorithm [6, 20], which focuses on the
case when n = 2. The same generalization was rediscovered
by Demaine et al. [14] and Karp et al. [23].

The MG algorithm assumes an associative array of coun-
ters indexed by items. Counters are initialized to zeros. We
say that an item is stored if its counter is above zero. For
each incoming item e, the MG algorithm works as follows:
(1) If e is stored (i.e., ctr[e] > 0), increase ctr[e] by 1; (2) Else
if the number of non-zero counters is less than n, ctr[e] = 1;
and (3) Otherwise, decrease all non-zero counters by 1.

Since there are at most n non-zero counters kept at any
time, the storage overhead is O(n). This can be easily ex-
tended to items with positive weights. After the ﬁrst pass,
the MG algorithm guarantees that every frequent item is as-
sociated with a non-zero count, and a second pass is required
to remove falsely included infrequent items.

The correctness of this algorithm can be shown intuitively
as follows: Suppose an item e appears more than m
n+1 times,
but is not stored at the end. The total count would have
been reduced by more than m
n+1 · (n + 1) = m counts during
the execution, which is impossible since it is more than the
total number of items.

EARDet Overview.
Figure 3 illustrates EARDet’s de-
cision diagram for each incoming packet. At a high level,
EARDet works similarly to the MG algorithm except three
crucial distinctions:

• Blacklist: EARDet keeps a local blacklist L that
stores recently identiﬁed large ﬂows. Counters are up-
dated only if the ﬂow ID of the packet is not black-
listed. The main purpose of keeping the blacklist is
to avoid increasing a ﬂow’s counter when the counter
value has already exceeded a counter threshold, βT H .
Additionally, we can avoid spending unnecessary re-
sources on accounting blacklisted ﬂows. We bound the
blacklist’s size in Section 3.3.

• Counter threshold: A ﬂow is added to the blacklist
if its associated counter value exceeds a threshold βT H .
Setting a counter threshold together with blacklisting
ensures that counter values are always conﬁned, i.e.,
≤ βT H + α, where α is the maximum packet size.

• Virtual traﬃc:

In contrast to the frequent-item
problem, the large-ﬂow problem has to take the idle
time between two consecutive packets into account so
as to accurately detect large ﬂows with respect to the
link capacity. EARDet handles this by virtually ﬁll-
ing the unused bandwidth with virtual traﬃc. Virtual
traﬃc consists of multiple virtual ﬂows, each of which
is crafted purposely to comply with the low-bandwidth
threshold, thus avoiding unnecessary alarms.

Algorithm description.
Algorithm 1 describes how
EARDet works. As the MG algorithm, EARDet keeps

213βTH + α
βTH

8

b

5

a

g
2

8

b

5

a

2
g

b
3

11

b

5

a

2
g

e
2

9

b

3
a

virtual
traffic

6

6

b

Blacklist: 

Blacklist: 

Blacklist: b

Blacklist: b

Blacklist: b

Figure 4: Example of EARDet’s counter update.

n counters, each initialized to zero. Counters are stored in
an associative array indexed by ﬂow IDs, and the number of
non-zero counters never exceeds n. EARDet counters are
increased and decreased by the size of the packets, since a
packet of size w can be viewed as w uni-sized items. We
denote by C the set of non-zero counters. We discuss how
to implement EARDet eﬃciently in Section 3.3.

Algorithm 1 EARDet
1: Initialization (S ← Init(n), Line 8-9)
2: for each packet x in the stream do
3:
4:
5:
6:
7:

Add f to blacklist (L ← L ∪ {f})

if x’s FID f is not blacklisted (f /∈ L) then

Update counters for virtual traﬃc (Line 18-22)
Update counters for x (S ← Update(S, x), Line 10-17)
if detect violation (Detect(S, x) == 1, Line 21-22) then

8: Initialization, Init(n)
9: initialize all counters to zeros, L ← ∅, C ← ∅
10: Update counters for packet x, Update(S, x)
11: if x’s FID f is kept (f ∈ C) then
12:
13: else if less than n counters are kept (|C| < n) then
14:
15: else
16:
17:

Update f ’s counter by the packet size w (cf ← cf + w)
Set f ’s counter to w (cf ← w, C ← C ∪ {f})
Decrease all counters by d = min{w, minj∈C cj}
Set cf to w − d, and ∀j remove j from C if cj = 0

18: Update counters for virtual traﬃc between xi and

xi−1

19: Compute the virtual traﬃc size, v (v = ρtidle − size(xi−1),
20: For each unit u in the virtual traﬃc, update counters as if u

and tidle = time(xi) − time(xi−1))
belongs to a new ﬂow (e.g., unit is 1 byte)

21: Detect violation, Detect(S, x)
22: Return whether x’s ﬂow counter exceeds threshold (cf >

βT H )

Figure 4 gives an example showing how to update counters
when n = 3, βT H = 10, and α = 3, where α is the maximum
packet size. First, since there is an empty counter, ﬂow g is
added and its counter value becomes 2, the size of the new
packet. Then, since ﬂow b is stored already, its counter is
increased by 3. The new value of ctr[b] exceeds βT H , and
thus ﬂow b is blacklisted. The next ﬂow, e, is not stored yet
and there is no empty counter, so all counters are decreased
by the packet size. Finally, the virtual traﬃc is divided into
single-unit packets with new ﬂow IDs, resulting in the ﬁnal
state.5

Despite EARDet’s simple operations, work remains to
prove the no-FPs and no-FNℓ properties and to devise prac-
tical parameters. We answer these in Section 4.

5Conceptually, the counter values are updated as follows:
[3, 9, 0] → [3, 9, 1] → [2, 8, 0] → [2, 8, 1] → [1, 7, 0] →
[1, 7, 1] → [0, 6, 0]. Section 3.3 discusses techniques to ac-
celerate this process.

3.3 Data Structure and Optimization

While EARDet requires very little memory state, its pro-
cessing delay may be high in a naive implementation where
EARDet accesses every counter for each decrement opera-
tion (i.e., Line 16 in Algorithm 1). We now present several
optimization techniques to reduce the number of memory
accesses and the processing time.

Reducing number of memory accesses. We minimize
the number of memory accesses per packet via the following
technique. First, we keep counters in a data structure that
allows insertion, deletion, and ﬁnding the minimum in loga-
rithmic time. Data structures such as balanced search trees
and heaps can satisfy our requirements. Moreover, counter
values are not absolute but relative to a ﬂoating ground,
cground. Hence, the decrement operation, which requires
decreasing all counters previously, can now be achieved by
elevating the ﬂoating ground. The detection function be-
comes cf − cground > βBF .

The increment operation on Line 12 takes O(1) time using
an associative array. Adding a value to an empty counter as
described on Line 14 takes O(log n) time because we have to
insert the counter to the data structure. To prevent counter
overﬂow, EARDet periodically resets the ﬂoating ground
to zero and deducts all counters accordingly.

Eﬃcient counter update for virtual traﬃc. Virtual
traﬃc ensures accurate accounting of unused bandwidth, but
eﬃcient implementation is needed to handle virtual traﬃc
at line speed. We now discuss how to eﬃciently update
EARDet’s counters for virtual traﬃc. Particularly, we aim
to divide virtual traﬃc into multiple virtual ﬂows in a way
to minimize the time to process such virtual ﬂows. The only
constraint is that each virtual ﬂow should comply with the
low-bandwidth threshold to avoid triggering false alarms.

As Line 20 of Algorithm 1 shows, for each unit u of
the virtual traﬃc, EARDet updates its counters (i.e.,
Update(S, u)) as if the traﬃc unit belongs to a new ﬂow.
We can minimize the number of updates by maximizing the
unit size. To avoid false detection, the maximum size per
unit is βT H bytes. As βT H must be larger than the minimum
packet size (i.e., 40 bytes) for practical use, the overhead of
using βT H -byte virtual ﬂows is bounded by the worst-case
scenario where the link is congested by minimum-sized pack-
ets.

We can further optimize this task based on the following
observation: Once all counters become empty, they should
stay empty until the next real packet comes. Furthermore,
since the maximum counter value is βBF + α, counters will
all be empty if the size of the virtual ﬂow ≥ (βBF + α) · n.
(A tighter condition is if the virtual traﬃc size ≥ (maxj cj) ∗
n − Pj cj, but this requires keeping track of the sum of all
counters.)
In other words, EARDet can simply reset all
counters to zeros and avoid any update if the virtual traﬃc
size exceeds a certain threshold.

Counter implementation.
For eﬃciency, counters are
implemented as integers (e.g., in bytes) rather than non-
integer numbers. While packet sizes are always multiples of
bytes, the size of virtual traﬃc may be non-integer, which
introduces biases on EARDet’s guarantees. For example,
given a 800Mbps link and a nanosecond time precision at
the router, the size of a 1-ns virtual traﬃc is 0.1 bytes.

2141, v′

a v′

We bound such biases with a slightly modiﬁed algorithm
that adjusts virtual traﬃc. Let us denote by {v1, v2, · · · } the
sizes of a sequence of virtual traﬃc and by {v′
2, · · · } the
adjusted sizes. We maintain an extra ﬁeld called “carryover”,
co, which keeps the amount of uncounted virtual traﬃc. co
is initialized to zero, and we ensure that −0.5 ≤ co < 0.5 for
all time. Virtual ﬂows are adjusted such that v′
i ← [vi + coi]
and coi+1 ← coi + vi − v′
i where coi is the value of co before
proceeding vi. By construction, v′
is are all integers, and for
any a, b, |Pb
In other
words, the adjusted virtual traﬃc diﬀers from the original
one by at most 1 unit for any time interval. Consequently,
the modiﬁed algorithm guarantees to catch ﬂows violating
THh(t) = γht + (βh + 1) and guarantees not to catch any
ﬂow conforming to THℓ(t) = γℓt + (βh − 1).

i| = |cob+1 − coa| ≤ 1.

a vi − Pb

Bounding the blacklist.
EARDet keeps in memory
not only counters but also a local blacklist storing recently
detected large ﬂows.

We propose a simple mechanism to bound |L| and thus
prevent algorithmic complexity attacks to overﬂow the
blacklist as follows. Since the blacklist’s main purpose is to
avoid increasing a ﬂow’s counter when the counter value has
already exceeded a counter threshold, once a counter value
has dropped below the threshold, the ﬂow can be removed
from the blacklist. In this way, the size of L will always be
bounded by n because only ﬂows that are currently stored
can be blacklisted.

The key observation here is that ﬂows that are not cur-
rently stored can be removed from the blacklist because such
removal will not aﬀect EARDet’s no-FNℓ and no-FPs guar-
antees, as in EARDet whether a ﬂow will be caught or not
does not depend on other ﬂows’ behavior. The detector can
periodically report the current blacklist to a remote admin-
istrator, such that the administrator keeps a complete list
of detected large ﬂows, while the detector maintains a small
blacklist that helps avoid increasing a ﬂow’s counter when
the counter value has already exceeded βT H . The only trade-
oﬀ of this mechanism is that EARDet may spend unneces-
sary resources on accounting ﬂows that have been identiﬁed
as large ﬂows.

Parallelizing EARDet. A common way to reduce pro-
cessing time is parallelization. EARDet can be parallelized
at both the algorithm and instruction levels. At the al-
gorithm level, we can randomly distribute the ﬂows (thus
the workload) among multiple copies of EARDet. At the
instruction level, we can access and update multiple coun-
ters in parallel using multi-port SRAM when the operations
are order insensitive. We note that special-purpose SRAMs
(i.e., multi-port SRAMs) can support multiple read/write
simultaneously [38].

3.4 Storage and Computational Complexity

Given the above optimization techniques, we analyze

EARDet’s storage and computational overhead.

To operate at line rate on OC-768 (40 Gbps) high-speed
links, a typical 3.2 GHz processor has to process 40 million
medium-sized (1000 bits) packets per second, which means
the per-packet processing time should be at most 32 ns or
76 CPU cycles. In this analysis, we consider the following
memory model for commodity routers: CPU has 32 KB L1
cache, 256 KB L2 cache, 20 MB L3 cache, and gigabytes
main DRAM memory. Accessing L1, L2, and L3 caches

takes 4, 12, and 30 CPU cycles, respectively; accessing the
main memory is as slow as 300 cycles.

Storage complexity.
EARDet keeps an extremely
small traﬃc synopsis, a blacklist of detected ﬂows, and stor-
age of ﬂow ID keys (i.e. unique keys consist of IP address
and port number) for ﬂow identiﬁer. The synopsis consists
of n counters and a constant number of additional variables
for optimization such as the ﬂoating ground.
In IPv4, a
ﬂow ID key is 48 bits, and for IPv6, it is 144 bits. By imple-
menting the tree map using a red-black tree [8], each counter
needs store only one ﬂow ID key. In most applications the
synopsis and ﬂow ID keys will be small enough to ﬁt en-
tirely in the router’s L1 cache. For instance, in IPv4, using
100 32-bit counters and 100 48-bit key variables requires
only 960 bytes; even in IPv6, the same case requires only
2200 bytes, which can ﬁt in the L1 cache. (Guided by our
analysis in Appendix A, we use 100 counters as a represen-
tative example.) If the number of counters is much larger
than 100 in some conﬁguration, we can also use L2 cache
with some performance cost. In practice, a special-purpose
device with more fast memory can also be installed for large
ﬂow detection. Moreover, we can ﬂexibly tune the counter
size to further reduce the memory requirement at the cost of
a wider ambiguity region between the no-FPs and no-FNℓ
thresholds.

For

complexity.

Computational
each packet,
EARDet looks up and updates one or more counters, and
adjusts the internal data structure (e.g., a heap) of counters.
In EARDet, locating and updating a counter requires an
average of O(1) memory access in a hash-map-based asso-
ciative memory. Adjusting the data structure of n counters
requires O(log n) memory accesses.

Since EARDet’s state is small enough to ﬁt into the L1
cache as we discussed, the per-packet processing time can
be as low as tens of nanoseconds, which is suitable for pro-
cessing packets at 40Gbps high-speed links. Even when all
of EARDet’s data is in the L2 cache, EARDet can still
process packets at line speed on 13Gbps.

4. ANALYSIS

In this section, we prove the no-FPs and no-FNℓ proper-
ties. Furthermore, we analyze the incubation period of large
ﬂows, discuss EARDet’s tradeoﬀs, and present practical
guidelines for EARDet conﬁguration. Finally, we compare
EARDet with closely related proposals [16, 17] to demon-
strate that it outperforms prior work in terms of both eﬃ-
ciency and detection accuracy.

We consider a network link with a capacity of ρ, and a
EARDet detector with n counters. The counter thresh-
old is βT H . Once the value of a counter exceeds βT H , the
associated ﬂow will be judged as a large ﬂow and cut oﬀ
immediately. Hence, the maximum value of each counter is
βT H + α, where α is the maximum packet size. Table 1 sum-
marizes the notations used in this section. We will discuss
the relationship among parameters and how to set them in
the Section 4.6.

4.1 Large-Flow False-Negative Analysis

Theorem 4. No-FNℓ property. EARDet detects ev-
ery ﬂow violating the high-bandwidth threshold T Hh(t) =

215Table 1: Table of Notations.

Network management parameters:

ρ , Rate of link capacity
α , Maximum packet size

tupincb , Upper bound of tincb for any large ﬂows

T Hℓ , Low-bandwidth threshold
T Hh , High-bandwidth threshold
γℓ, βℓ , Rate and burst for low-bandwidth threshold

γh , Rate for high-bandwidth threshold

Tunable parameters:

n , Number of counters in EARDet

βT H , Threshold of counters(> βℓ)

Parameters that depend on tunable parameters:

βh , Burst for high-bandwidth threshold
β∆ , βT H − βℓ

Other notation:
R(t1, t2) , Average ﬂow rate in [t1, t2)

tincb , Incubation period of large ﬂows

RN F N , No-FNℓ rate
RN F P , No-FPs rate

γht+βh over a time window of length t, when γh ≥ RN F N =
ρ
n+1 and βh ≥ α + 2βT H .

ρ

Proof sketch:
Firstly, we prove that EARDet satisﬁes
L3 in Theorem 3. According to Algorithm 1, the maximum
value of each counter ci is βT H + α, and there are at most n
non-zero counters at any time. Also, given any valid synopsis
S = {ci} we can construct a packet stream X consisting of
ci bytes for ﬂow i and no space between packets, and by
construction S = Update(S0, X). Combining the above two
arguments and the deﬁnition of the distance function, we
conclude that dis(S0, S) ≤ size(X )
. That is,
setting ∆ = (βT H +α)n
satisﬁes L3.

≤ (βT H +α)n

ρ

ρ

h + β′

n+1 and β′

h = RN F N = ρ

Next we prove that EARDet satisﬁes L2 in Theorem 3
as well when setting γ′
h = βT H .
We prove by contradiction and assume there were a ﬂow f
violating γ′
h in the landmark window model at time t
but not being detected (i.e., cf < βT H ). This assumption
implies that more than γ′
h − βT H amount of ﬂow f
would have been canceled out6 during the decrement step,
or equivalently, more than (γ′
h − βT H ) · (n + 1) =
γ′
ht · (n + 1) = ρt amount of traﬃc would have been canceled
out. This statement, however, contradicts the setting where
the maximum traﬃc for t units of time is ρt. Thus, f cannot
escape from EARDet, and L2 is satisﬁed by EARDet.

ht + β′

ht + β′

(βT H +α)n

h = ρ
= βT H + n

Based on Theorem 3, we conclude that EARDet satis-
ﬁes A2 when γh = γ′
h + γh∆ =
βT H + ρ
In partic-
n+1
ular, EARDet catches every ﬂow violating the threshold
T Hh(t) = γht + βh when γh ≥ RN F N and βh ≥ α + 2βT H .
That is, EARDet catches all large ﬂows in the arbitrary
window model. (cid:4)

n+1 and βh ≥ β′
n+1 (βT H + α).

ρ

4.2 Small-Flow False-Positive Analysis

As discussed in Section 3.1, no algorithm can satisfy A2 in
Theorem 3 and L1 in Theorem 2 at the same time. Hence,
rather than applying Theorem 2, we have to take a diﬀerent
approach in proving the no-FPs property.

6A packet byte is canceled out if it does not contribute to
the corresponding counter.

To analyze EARDet’s no-FPs property, we consider how
EARDet increases and decreases its counter values. Firstly,
let us examine all cases based on the types of incoming ﬂows.
We say a ﬂow is old if it is stored in the counters currently;
otherwise the ﬂow is new.

1. When the incoming ﬂows are virtual ﬂows and there
are l empty counters, in a time window t, the decre-
ρ
ment is
l+1 t on all counters, and the increment is 0.
(l = 0, 1, 2, 3, ..., n)

2. When the incoming ﬂows are new real ﬂows and there
is no empty counter, in a time window t, the decrement
is ρt on all counters and the increment is 0 (which is
the same as the ﬁrst case when l = 0).

3. When the incoming ﬂows are old real ﬂows, or new
real ﬂows and there are some empty counters, in time
interval t, the decrement is 0 and the increment is ρ t
on one counter.

Thus, in the ﬁrst and second cases, when there are l empty
counters in the detector, the decrement is always ρ
l+1 t in the
interval of t; and in the third case, the increment is always
ρ t on one counter in the interval of t. Finally, the increment
and decrement cannot happen at the same time.

Lemma 5. For any small ﬂow f that complies with the
low-bandwidth threshold (i.e., T Hℓ(t) = γℓ t + βℓ), once the
ﬂow f is associated to a counter at t1, this counter will be
always lower than βT H after time t1 + tβℓ , if the counter
is occupied by the same ﬂow as the ﬂow f , where tβℓ =
(n−1)α+(n+1)βℓ
[1−(n+1)γℓ/ρ]ρ .

Due to space limitations, the detailed proofs are in our

technical report [37].

Theorem 6. No-FPs property.

EARDet will not
catch any ﬂow complying with the low-bandwidth thresh-
old T Hℓ(t) = γt + βℓ for all time windows of length t,
when 0 < βℓ < βT H , γℓ < RN F P , where RN F P =

(n−1)α+(n+1)βℓ+(n+1)β∆

β∆

· ρ.

Proof sketch: According to Lemma 5, to avoid catching
a small ﬂow f , the counter should be smaller than βT H be-
fore tβℓ . Hence, we choose a γℓ to achieve γℓ tβℓ + βℓ < βT H .
Then, (n−1)α+(n+1)βℓ

,

[1−(n+1)γℓ/ρ]ρ < βT H −βℓ
β∆

γℓ

⇔ γℓ <

(n − 1)α + (n + 1)βℓ + (n + 1)β∆ · ρ

The theorem is proved. (cid:4)
Interestingly, Theorem 6 shows that γℓ approaches

(1)

ρ
n+1 as

β∆ increases, but cannot go beyond ρ

n+1 .

4.3 Relationship between Low-Bandwidth

and High-Bandwidth Thresholds

Before the discussion, let us deﬁne two concepts:

Rate Gap: The ratio between γh and γℓ (i.e. γh/γℓ);
Burst Gap: The ratio between βh and βℓ (i.e. βh/βℓ).

Based on Theorems 4 and 6, the minimum rate gap is:

(γh/γℓ)min = RN F N
RN F P

= (n−1)α+(n+1)(βℓ+β∆)

Given β∆ = βT H − βℓ and n + 1

β∆(n+1)
.
= n

.
= n − 1, we get

(γh/γℓ)min

.
= 1 +

2α/β + 2

βh/βℓ − (α/βℓ + 2)

(2)

216Thus, the minimum possible rate gap (γh/γℓ)min is mainly
inﬂuenced by the burst gap βh/βℓ. Equation (2) tells us a)
βh/βℓ cannot be lower than α/βℓ + 2. b) EARDet only
needs a low βh/βℓ to achieve small enough (γh/γℓ)min. For
example, to achieve (γh/γℓ)min = 10, we only need βh/βℓ =
2.53. c) (γh/γℓ)min cannot be lower than 1.
(γh/γℓ)min
approaches to 1 as βh/βℓ grows.

4.4 Incubation Period of Large Flows

To deﬁne the incubation period, we ﬁrst consider a large
ﬂow that violates the high-bandwidth threshold over [t1, t2),
and the packet at ta triggers the detection. Because of
EARDet’s no-FNℓ property, ta ≤ t2. The incubation pe-
riod is deﬁned as ta − t1, representing the time duration for
which the large ﬂow remains under the radar. We bound
the incubation period as follows.

Theorem 7. For the ﬂow f which violates T Hh(t) over
some time window [t1, t2), if its average rate R(t1, ta) is
larger than Ratk in time interval of [t1, ta) (Ratk is a con-
stant rate larger than RN F N = ρ
n+1 ), then f ’s incubation
period is bounded by

tincb <

α + 2βT H
Ratk − ρ

n+1

.

(3)

Proof sketch:
Because R(t1, ta) > Ratk, intuitively the
tincb of ﬂow with average rate of R(t1, ta) must be shorter
than the t′
incb.
Assume a ﬂow f ′ with rate Ratk will violate T Hh(t) over

incb of ﬂow with rate of Ratk. That is, tincb < t′

time window [t′

1, t′

2), then

Ratk(t′

2 − t′
⇒ tincb < t′

(t′
2 − t′
1 ≤ t′

a − t′

1) =

ρ

n + 1

incb = t′

1) + α + 2βT H

2 − t′

1 =

α + 2βT H
Ratk − ρ

n+1

(4)

Thus, the theorem is proved. (cid:4)
From Theorem 7, the bound of the incubation period de-
creases as Ratk increases. In other words, if Ratk is ﬁxed, the
bound of the incubation period decreases with increasing n,
which implies we can reduce the upper bound by adding ex-
tra counters. To guarantee detection of ﬂows whose rate is
over Ratk (Ratk > ρ
n+1 ), the minimum number of counters
− 1, and the upper bound on the incubation period
is
can be lowered signiﬁcantly by adding a few counters. The
details will be discussed in Section 4.6.

Ratk

ρ

4.5 Tradeoff Analysis

We discuss three tradeoﬀs in EARDet: (1) memory con-
sumption (i.e., the number of counters) vs. the rate gap, (2)
the rate gap and burst gap, and (3) the rate gap and the
upper bound on the incubation time.

First, since the rate gap can be expressed as γh/γℓ >
RN F N /γℓ = ρ/γℓ
n+1 , we can see that the rate gap decreases
with increasing n. Second, Equation (2) shows that the min-
imum rate gap γh/γℓ is mainly inﬂuenced by βh/βℓ, namely
the burst gap, and the minimum rate gap decreases as the
burst gap increases. Finally, Theorem 7 shows that a large
burst gap results in a long incubation period. Hence, a small
rate gap results in a big burst gap, and a high incubation
period.

4.6 How To Engineer The Detector

To engineer our detector, we ﬁrst identify parameters
that are often known or given in a priori. Usually, users
want a detector for a speciﬁc link capacity, ρ, to protect
small ﬂows which comply with the low-bandwidth threshold:
T Hℓ(t) = γℓ t + βℓ, and to detect attack ﬂows that violate
the high-bandwidth threshold: T Hh(t) = γht + βh. How-
ever, as discussed in Section 4.5, there is a tradeoﬀ between
the rate gap and burst gap, so their requirements cannot be
both fulﬁlled. Thus, we choose to satisfy the rate require-
ment of γh, and then set βh according to γh because it is
more important to limit the ﬂow rate than the burst size.
Furthermore, since we want to minimize the incubation pe-
riod of large ﬂows, there is an upper bound of the incubation
period, tupincb.

We set βh = α + 2βT H and γh > ρ

n+1 to guarantee no
FNℓ according to Theorem 4. Since βT H = βℓ + β∆, we only
need to decide the number of counters n and β∆. Hence, the
problem can be simpliﬁed as follows. Given ρ, γℓ, βℓ, γh,
α, and tupincb, we aim to calculate n and β∆ such that the
parameters satisfy the constraints in Theorems 4, 6 and 7.
The detailed solution and analysis are in Appendix A. The
detailed analysis shows that the tunable parameters depend
on only the thresholds and are independent of the input
traﬃc.

5. EVALUATION

To evaluate EARDet, we compare EARDet with two
closely related proposals, which we refer to as FMF [17] and
AMF [16]. Both of our theoretical comparison and trace-
based simulations demonstrate that EARDet performs bet-
ter than prior work in terms of both exactness7 outside an
ambiguity region and eﬃciency. The simulation results us-
ing real and synthetic traﬃc traces are consistent with the
analysis in the theoretical evaluation.

5.1 Theoretical Comparison

Multistage ﬁlters.
Fixed-window-based Multistage Fil-
ters (FMF) identify large ﬂows in a ﬁxed measurement in-
terval. A FMF consists of parallel stages, each of which
is an array of counters initialized to zeros at the beginning
of a measurement interval. Each stage is assigned a hash
function that maps a packet’s ﬂow identiﬁer to a counter in
the stage. For each incoming packet, its ﬂow identiﬁer is
hashed to one counter in each hash stage, and the counter
value increments by the size of the packet. A ﬂow is consid-
ered a large ﬂow if all of its corresponding counters exceed
a pre-speciﬁed threshold.

Arbitrary-window-based Multistage Filters (AMF) identify
large ﬂows over arbitrary windows. To work in the arbitrary
window model, AMF replaces each counter in FMF with a
leaky bucket of a bucket size u and a drain rate r. A ﬂow
is considered a large ﬂow if the corresponding leaky buckets
are all violated.

Performance Comparison.
Table 2 presents a numer-
ical comparison of EARDet, FMF and AMF, where the
high-bandwidth rate is 1% of the link capacity, and the low-
bandwidth rate is 0.1% of link capacity. The results of FMF
and AMF are derived based on the authors’ original analysis

7The comparison in this section uses our deﬁnition of exact-
ness.

217Table 2: A numerical example given the require-
ments in Section 4.6. γh is 1% of the link capacity,
and γℓ is 0.1% of link capacity.

FPs rate

0

no guarantee / ≤ 0.04∗
no guarantee / ≤ 0.04

FNℓ rate

0
0∗
0

Scheme
EARDet

FMF
AMF

# of counters

101

101/1000
101/2000

∗FMF’s results are derived in the landmark window model, and
thus FMF’s FPs and FNℓ rates may be higher in the arbitrary

window model.

Table 3: Summary of comparison of three schemes.

Scheme
EARDet

FMF
AMF

FPs
no
yes
yes

FNℓ Memory
no
yes
no

low
high
high

Input Traﬃc
independent
dependent
dependent

that assumes a speciﬁc number of active ﬂows for the input
traﬃc.

EARDet outperforms the other two approaches in sev-
eral aspects: 1) EARDet guarantees no false detection of
small ﬂows, whereas it is unclear how FMF and AMF can
achieve this property. Even with ten times or more extra
storage, FMF and AMF still have error rates as high as
0.04. 2) Both EARDet and AMF can detect all large ﬂows.
However, FMF has FNℓ on bursty ﬂows. 3) EARDet re-
quires much less memory compared with multistage ﬁlters.
4) EARDet’s performance is independent of the input traf-
ﬁc, because the error rate is always zero. On the contrary, to
keep the same false positive rate, multistage ﬁlters require
more stages as the number of active ﬂows increases. Table 3
summarizes the comparison, which suggests that EARDet
is exact outside an ambiguity region and more eﬃcient than
prior works.

Although EARDet presents several advantages compared
with multistage ﬁlters, EARDet cannot estimate the size of
a detected ﬂow, which multistage ﬁlters achieve.

5.2 Experiment Settings

Datasets.
Table 4 summarizes the characteristics of
the two datasets used in the experiments. The Federico
II dataset contains traces collected at the TCP port 80 of
a 200 Mbps link [3, 12, 13]. The CAIDA dataset contains
anonymized passive traﬃc traces from CAIDA’s equinix-
sanjose monitors on 10 Gbps backbone links [2]. For each
dataset, we use the ﬁrst 30 seconds for the experiments.
We deﬁne ﬂows based on the source and destination IP ad-
dresses.

Dataset

Federico II

CAIDA

Table 4: Dataset Information.
of

link

Link ca-
pacity
200M bps
10Gbps

Avg
rate
1.85M B/s
279.65M B/s 2517099

#
ﬂows
2911

Avg ﬂow
size
19.9KB
3.3KB

and compare EARDet with FMF and AMF in the face of
common attacks.

In particular, we generate attack ﬂows using two simple
strategies—ﬂooding attacks and Shrew DoS attacks [22,25]—
and then mix real traces with artiﬁcially generated attack
ﬂows to simulate an attack environment. In a ﬂooding at-
tack, the adversary sends high-rate ﬂows with a speciﬁed
rate γlarge (e.g. γh). Each high-rate ﬂow is generated as fol-
lows. We randomly choose a 1-second time slot within the
30-second stream as the ﬁrst second of the ﬂow. Starting
from that second, we randomly generate γlarge/packetSize
packets in each 1-second interval to make the ﬂow size in
each interval equal to that speciﬁed rate.
In this experi-
ment, we set the packet size to 1518 bytes, the maximum
packet size. In a Shrew attack, the attacker sends periodic
bursts in an attempt to cut oﬀ TCP traﬃc by exploiting
TCP’s congestion control mechanism. To generate a bursty
ﬂow with a period T , burst duration L, and bursty ﬂow rate
γburst, we randomly choose a time point from [0, 29) sec-
ond as the start time, and then randomly generate γburst · L
packets in each L-length burst that occurs every T seconds.
We then evaluate (1) how many malicious large ﬂows can
evade detection, and (2) how many small benign ﬂows are
falsely caught because of these coexisting attack ﬂows.

We conﬁgure EARDet based on the guidelines in Section
4.6, such that it can detect large ﬂows violating T Hh(t) =
γh t + βh, where γh = 0.01ρ, and βh = 2βT H + α. βT H will
be calculated according to our technical report [37]. We also
consider small ﬂows that comply with T Hℓ(t) = γℓ t + βℓ,
where βℓ = 6072 bytes and γℓ = 0.01ρ. Also, we require
tupincb to be smaller than 1 second. Table 5 summarizes
the value of each parameter used in our experiments. In a
“non-congested link” setting, a ﬁxed number of attack ﬂows
are mixed with the real trace. We also consider a “congested
link” setting, where we ﬁll the link with attack ﬂows, for the
small dataset (i.e., the Federico II dataset) only. We leave
it as future work to scale our attack ﬂow generation tool to
work for larger datasets.

To conﬁgure the two multistage ﬁlters (FMF and AMF),
we set FMF’s window size to 1 second, number of stages
d = 2, number of counters in each stage b = 250, thresh-
old of FMF T = γh · 1 second, threshold of AMF u = βh,
and drain rate r = γh. We are also interested in the perfor-
mance of FMF and AMF when their memory is as small as
EARDet’s. Hence, we run additional experiments in which
the number of counters in each stage is 55. The details of
these values are shown in the Table 6.

For each experiment environment, we design two sets of
experiments to test the performance of these three ﬁlters
in the presence of ﬂooding attacks and Shrew attacks. We
repeat each experiment for 10 times and present the aver-
age. In the case of ﬂooding attacks, we randomly generate
k1 attack ﬂows for each attack rate. In the case of Shrew
attacks, we randomly generate k2 bursty ﬂows with 1.2 ∗ γh
burst rate and 1-second period for each burst duration L.
We set k1 = k2 = 50 for the non-congested link setting, and
set the k1 and k2 as large as possible to congest the link in
the congested-link setting.

Attack scenarios.
As stated in the theoretical analysis
in Section 5.1, EARDet is exact outside an ambiguity region
and eﬃcient comparing to prior algorithms. The theoretical
analysis focuses on the worst-case behaviors. To investigate
how EARDet performs in reality, we conduct experiments

Table 6: Multistage Filter Parameters.

Dataset

Federico II

CAIDA

b ∗ d

55 ∗ 2, 250 ∗ 2
55 ∗ 2, 250 ∗ 2

T

u

r

250KB
250KB/s
12.5M B 15.4KB 12.5M B/s

15.5KB

218Dataset

Federico II

CAIDA

γh

βh

γℓ

βℓ

ρ

α

link status

250KB/s
12.5M B/s

15.5KB
25KB/s
15.4KB 1.25M B/s

6072B
25M B/s
6072B 1.25GB/s

1518B congested/non-congested
1518B

non-congested

n
βT H
6991B 107
6925B 100

tupincb
0.8370s
0.1242s

Table 5: Parameters of Experiment Environment.

Detection Probability Under Large Rate Flow Attack

Detection Probability Under Shrew Attack

 

 

y
t
i
l
i

b
a
b
o
r
P

  1

0.9

0.8

0.7

0.6

0.5

0.4

0.3

0.2

0.1

  0

 

0.5

1

1.5

y
t
i
l
i

b
a
b
o
r
P

  1

0.9

0.8

0.7

0.6

0.5

0.4

0.3

0.2

0.1

EARDet in congested link

FMF in congested link

AMF in congested link

EARDet in non−congested link

FMF in non−congested link

AMF in non−congested link
γ

atk

γ

EARDet in congested link

FMF in congested link

AMF in congested link

EARDet in non−congested link

FMF in non−congested link

AMF in non−congested link
TH
h

2

3
Attack Flow Rate (Byte/s)

2.5

3.5

4

4.5
5
x 10

  0

 

100

200

300

400
Duration of Burst (ms)

500

600

700

800

900

1000

(a) Flooding DoS Attack

(b) Shrew DoS Attack

Figure 5: Detection Probability in Experiment with 55*2 counters in Multistage Filter.

Evaluation metrics. We consider three evaluation met-
rics: detection probability, false positive probability on small
ﬂows, and incubation period. Detection probability is the
probability to successfully detect a generated attack ﬂow.
False positive probability on small ﬂows is the probability
to wrongly catch a small ﬂow when the link is attacked by
attack ﬂows of a certain rate. Incubation period represents
the time needed to catch a generated attack ﬂow since it is
generated.

5.3 Experimental Comparison

Since the results for the two datasets are similar, we omit

CAIDA’s results due to space constraints.

Figure 5(a) and 5(b) shows the detection probability in
the face of diﬀerent types of attack ﬂows. We focus on the
scenario of using 55 ∗ 2 counters in FMF and AMF, as the
results of 250 ∗ 2 counters are similar. In Figure 5(b), the
T Hh line indicates whether a bursty ﬂow exceeds the high-
bandwidth threshold. The results show that EARDet de-
tects attack ﬂows with a 100% detection probability, which
conﬁrms Theorem 4. On the contrary, Figure 5(b) shows
that FMF cannot catch most of the Shrew ﬂows. Moreover,
EARDet can catch most of the attack ﬂows in the ambigu-
ity region (between T Hℓ(t) and T Hh(t)).

Figure 6(a) to Figure 6(h) show the results of FPs rates.
While EARDet has zero FPs in any case as expected, Fig-
ure 6(a) to Figure 6(d) shows that both FMF and AMF
have high FPs rates in both attack scenarios when using
very limited memory as EARDet. That is, the attacker
can successfully incriminate benign small ﬂows. Worst yet,
when the link is congested by attack ﬂows, the FPs rate can
be as high as 4% for FMF and 1% for AMF under ﬂooding
attacks, and for FMF, the FPs rate is also extremely high
under Shrew attacks. An interesting observation is that, in
Figure 6(a), both FMF and AMF have a higher FPs rate
when the link is congested by malicious small ﬂows. As Fig-
ure 6(e) to 6(h) show, using more counters in FMF and AMF

can reduce, but not eliminate, the FPs rates. The results of
the CAIDA dataset exhibit similar trends.

Also, in our experiments, EARDet always produces sim-
ilar results no matter whether the link is congested. In con-
trast, the results of AMF and FMF are much diﬀerent be-
tween the congested-link version and non-congested-link ver-
sion. This supports the conclusion in Section 5.1 that AMF
and FMF rely on the number of active ﬂows but EARDet
does not. This advantage makes EARDet stable in any
networking environment.

)
c
e
s
(
 

d
o
i
r
e
P
n
o

 

i
t

a
b
u
c
n

I

1

0.8

0.6

0.4

0.2

0

 
2

Incubation Period

 

Ave t

incb

Max t

incb

t
upincb

γ

h

2.5

3

3.5

4

Attack Flow Rate (Byte/s)

4.5
5
x 10

Figure 7: Incubation Period.

Figure 7 describes the maximum and average incubation
period of high-rate ﬂows with diﬀerent rates in ﬂooding at-
tacks. We can ﬁnd that the maximum incubation period for
ﬂows whose rate is over γh is always below the theoretical
upper bound for the incubation period, tupincb, which sup-
ports Theorem 7. Moreover, the average incubation period
is much lower than the theoretical upper bound, which shows
EARDet’s incubation period is much shorter in practice.

6. RELATED WORK

Section 2.1 classiﬁes prior work on detecting large ﬂows
and its closely related problem of ﬁnding frequent items
based on the types of monitoring windows. Cormode and
Hadjieleftheriou [9] present a thorough survey and compari-
son of algorithms for ﬁnding frequent items. This section re-
views prior approaches based on the techniques used. Most

219False Positive Of Legitimate Flow Under Large Rate Flow Attack

False Positive Of Legitimate Flow Under Shrew Attack

False Positive Of Legitimate Flow Under Large Rate Flow Attack

y
t
i
l
i

b
a
b
o
r
P

0.06

0.05

0.04

0.03

0.02

0.01

   0

 

 

0.2

EARDet
FMF
AMF
γ

atk

γ

y
t
i
l
i

b
a
b
o
r
P

0.1

  0

 

1

2

3

Attack Flow Rate (Byte/s)

4

5
x 10

 

EARDet
FMF
AMF
TH
h

0.004

0.003

0.002

0.001

y
t
i
l
i

b
a
b
o
r
P

    0

 

200

400

600

800

1000

Duration of Burst (ms)

 

EARDet

FMF

AMF
γ

atk

γ

1

2

3

Attack Flow Rate (Byte/s)

4

5
x 10

(a) 55*2 counters - Congested Link

(b) 55*2 counters - Congested
Link

(c) 55*2 counters - Non-congested
Link

False Positive Of Legitimate Flow Under Large Rate Flow Attack

False Positive Of Legitimate Flow Under Shrew Attack

 

EARDet
FMF
AMF
TH
h

 

0.002

EARDet
FMF
AMF
γ

atk

γ

y
t
i
l
i

b
a
b
o
r
P

0.001

y
t
i
l
i

b
a
b
o
r
P

0.005

0.004

0.003

0.002

0.001

    0

 

False Positive Of Legitimate Flow Under Shrew Attack

 

EARDet

FMF

AMF
TH
h

200

400

600

800

1000

Duration of Burst (ms)

y
t
i
l
i

b
a
b
o
r
P

0.0012

0.0011

 0.001

0.0009

0.0008

0.0007

0.0006

0.0005

0.0004

0.0003

0.0002

0.0001

     0

 

1

2

3

Attack Flow Rate (Byte/s)

4

5
x 10

    0

 

200

400

600

800

1000

Duration of Burst (ms)

(d) 55*2 counters - Non-congested
Link

(e) 250*2 counters
Link

- Congested

(f) 250*2 counters - Congested
Link

False Positive Of Legitimate Flow Under Large Rate Flow Attack

False Positive Of Legitimate Flow Under Shrew Attack

0.0004

0.0003

0.0002

0.0001

y
t
i
l
i

b
a
b
o
r
P

     0

 

EARDet

FMF

AMF
γ

atk

γ

 

 

0.0002

y
t
i
l
i

b
a
b
o
r
P

0.0001

EARDet

FMF

AMF
TH
h

1

2

3

Attack Flow Rate (Byte/s)

4

5
x 10

     0

 

200

400

600

800

1000

Duration of Burst (ms)

(g) 250*2 counters - Non-congested
Link

(h) 250*2
congested Link

counters

- Non-

Figure 6: False Positive on Small Flows.

of the prior work does not consider the arbitrary window
model.

Counter-based techniques.
Counter-based techniques
maintain a small number of counters, each of which asso-
ciated with a ﬂow or an item. Manku and Motwani [29]
present another well-known counter-based technique called
Lossy Counting. For each stored item, Lossy Counting main-
tains and updates the upper bound and lower bound on the
count of the item. The algorithm stores every new item
and periodically removes items whose upper bound is less
than the threshold. Similar to the MG algorithm discussed
in Section 3.2, the Space Saving algorithm [30] proposed by
Metwally et al. maintains k (item, counter) pairs and in-
creases the corresponding counter of each incoming item.
If the new item e is not stored currently, the stored item
with the lowest count is replaced by the new item, and the
counter increases accordingly.

Multistage ﬁlters identify
Sketch-based techniques.
large ﬂows over ﬁxed time windows [17] and over arbitrary
windows [16]. Fang et al.
[18] propose a similar mul-
tistage algorithm but their algorithm requires more than

one pass over the input stream. Cormode and Muthukr-
ishnan [10] present a novel data structure called count-min
sketch, which summarizes an input stream and can answer
several queries including ﬁnding frequent items. As pointed
out in their paper, despite the fact that the construction
is similar to that of multistage ﬁlters, count-min sketches
can ﬂexibly support negative weights and require only pair-
wise independence hash functions rather than fully indepen-
dent ones.
In general, sketches can support a richer set
of queries with a higher memory overhead compared with
counter-based techniques.

Sampling-based techniques.
Sampled NetFlow [1]
maintains a generic traﬃc summary of sampled packets.
With a sampling rate 1/r, the frequency estimate is derived
by multiplying the count by r. To improve the accuracy
of the estimates, both Sticky sampling [29] and Sample and
Hold [17] examine every incoming item and increase the cor-
responding count if the item is being monitored. If the new
item is not being monitored, it is sampled and added to the
monitoring list with a certain probability. Sampling-based
techniques in general cannot achieve high accuracy due to

220the lack of per-packet information. Duﬃeld [15] studies how
to perform fair sampling in traﬃc ﬂow measurements.

Calders et al.

[7] deﬁne a new frequency measure as the
maximum frequency over all possible windows ending at the
current time. Although their core idea is the same as the
arbitrary window model, their algorithm focuses on accu-
rately estimating the frequency based on the new frequency
measure, whereas we seek to accurately identify large ﬂows.

7. CONCLUSION

EARDet is a deterministic streaming algorithm that ro-
bustly catches all large ﬂows and protects all small ﬂows
regardless of the traﬃc distribution. The core ideas diﬀeren-
tiating EARDet from prior work are that it monitors ﬂows
over arbitrary windows and provides exactness outside an
ambiguity region. We believe that EARDet can aid emerg-
ing applications such as detecting DoS attacks by bursty
ﬂows [25] and enforcing QoS-based SLA compliance [35],
which require robust monitoring for high assurance. One
future direction is to explore the design space of large-ﬂow
algorithms in the arbitrary window model by applying the
no-FP and no-FN theorems to existing landmark-window-
based algorithms. Another interesting future work is to for-
mally examine the robustness of EARDet and prior algo-
rithms against malicious inputs.

8. ACKNOWLEDGMENTS

We gratefully thank our shepherd Darryl Veitch and the
anonymous reviewers for their valuable feedback. This re-
search was supported in part by NSF under grants CNS-
0953600, CNS-1248080, and CNS-1040801.

9. REFERENCES
[1] Random Sampled NetFlow. http://www.cisco.com/en/US/

docs/ios/12_0s/feature/guide/nfstatsa.html.

[2] The CAIDA UCSD Anonymized Internet Traces 2012 -

1220. http://www.caida.org/data/passive/passive_2012_
dataset.xml.

[3] Traces 1 of TCP port 80 traﬃc traces from Federico II.

http://traffic.comics.unina.it/Traces/ttraces.php.

[4] D. G. Andersen, H. Balakrishnan, N. Feamster,

T. Koponen, D. Moon, and S. Shenker. Accountable
Internet Protocol (AIP). In Proceedings of ACM
SIGCOMM, 2008.

[5] A. Arasu and G. S. Manku. Approximate Counts and

Quantiles over Sliding Windows. In Proceedings of ACM
PODS, 2004.

[6] B. Boyer and J. Moore. A Fast Majority Vote Algorithm.
Technical report, ICSCA-CMP-32, Institute for Computer
Science, University of Texas, 1981.

[7] T. Calders, N. Dexters, and B. Goethals. Mining Frequent

Items in a Stream Using Flexible Windows. Intelligent
Data Analysis, 12(3):293–304, 2008.

[8] T. H. Cormen, C. E. Leiserson, R. L. Rivest, and C. Stein.

Introduction to Algorithms, chapter 13: Red-Black Trees.
MIT Press and McGraw-Hill, 2001.

[9] G. Cormode and M. Hadjieleftheriou. Finding Frequent

Items in Data Streams. Proc. VLDB Endow.,
1(2):1530–1541, 2008.

[10] G. Cormode and S. Muthukrishnan. An Improved Data

Stream Summary: The Count-Min Sketch and its
Applications. Journal of Algorithms, 55(1):58–75, 2005.

[11] S. A. Crosby and D. S. Wallach. Denial of Service via

Algorithmic Complexity Attacks. In Proceedings of
USENIX Security, 2003.

[12] A. Dainotti, A. Pescap`e, P. Salvo Rossi, F. Palmieri, and
G. Ventre. Internet Traﬃc Modeling by means of Hidden
Markov Models. Computer Networks (Elsevier),
52:2645–2662, 2008.

[13] A. Dainotti, A. Pescap`e, and G. Ventre. A Cascade

Architecture for DoS attacks Detection based on the
Wavelet Transform. Journal of Computer Security,
17(6/2009):945–968, 2009.

[14] E. D. Demaine, A. L´opez-Ortiz, and J. I. Munro. Frequency
Estimation of Internet Packet Streams with Limited Space.
In Proceedings of ESA, 2002.

[15] N. Duﬃeld. Fair Sampling Across Network Flow

Measurements. In Proceedings of ACM SIGMETRICS,
2012.

[16] C. Estan. Internet Traﬃc Measurement: What’s Going on

in my Network? PhD thesis, 2003.

[17] C. Estan and G. Varghese. New Directions in Traﬃc

Measurement and Accounting: Focusing on the Elephants,
Ignoring the Mice. ACM Transactions on Computer
Systems (TOCS), 21(3):270–313, 2003.

[18] M. Fang and N. Shivakumar. Computing Iceberg Queries

Eﬃciently. In Proceedings of VLDB, 1999.

[19] P. Ferguson and D. Senie. Network Ingress Filtering:
Defeating Denial of Service Attacks which employ IP
Source Address Spooﬁng. RFC 2827 (Best Current
Practice), May 2000. Updated by RFC 3704.

[20] M. Fischer and S. Salzberg. Finding a Majority Among N
Votes: Solution to Problem 81-5. Journal of Algorithms -
JAL, 3(4):362–380, 1982.

[21] L. Golab, D. DeHaan, E. D. Demaine, A. L´opez-Ortiz, and
J. I. Munro. Identifying Frequent Items in Sliding Windows
over On-Line Packet Streams. In Proceedings of ACM IMC,
2003.

[22] M. Guirguis, A. Bestavros, and I. Matta. Exploiting the

Transients of Adaptation for RoQ Attacks on Internet
Resources. In Proceedings of IEEE ICNP, 2004.

[23] R. M. Karp, S. Shenker, and C. H. Papadimitriou. A

Simple Algorithm for Finding Frequent Elements in
Streams and Bags. ACM Transactions on Database
Systems, 28(1):51–55, 2003.

[24] T. Kim, C. Basescu, L. Jia, S. B. Lee, Y.-C. Hu, and

A. Perrig. Lightweight Source Authentication and Path
Validation. In Proceedings of ACM SIGCOMM, 2014.

[25] A. Kuzmanovic and E. Knightly. Low-Rate TCP-Targeted

Denial of Service Attacks and Counter Strategies.
IEEE/ACM Transactions on Networking, 14(4):683–696,
2006.

[26] L. Lee and H. Ting. A Simpler and More Eﬃcient

Deterministic Scheme for Finding Frequent Items over
Sliding Windows. In Proceedings of ACM PODS, 2006.

[27] X. Liu, A. Li, X. Yang, and D. Wetherall. Passport: Secure

and Adoptable Source Authentication. In Proceedings of
USENIX/ACM NSDI, 2008.

[28] S. Machiraju, M. Seshadri, and I. Stoica. A Scalable and

Robust Solution for Bandwidth Allocation. In Proceedings
of IEEE International Workshop on Quality of Service,
volume 00, 2002.

[29] G. Manku and R. Motwani. Approximate Frequency

Counts over Data Streams. In Proceedings of VLDB, 2002.

[30] A. Metwally, D. Agrawal, and A. El Abbadi. Eﬃcient
Computation of Frequent and Top-k Elements in Data
Streams. In Proceedings of ICDT, 2005.

[31] J. Misra and D. Gries. Finding Repeated Elements. Science

of Computer Programming, 2(2):143–152, 1982.

[32] J. Naous, M. Walﬁsh, A. Nicolosi, D. Mazieres, M. Miller,

and A. Seehra. Verifying and Enforcing Network Paths
with ICING. In Proceedings of ACM CoNext, 2011.

[33] S. Shenker, C. Partridge, and R. Guerin. Speciﬁcation of

Guaranteed Quality of Service. RFC 2212 (Proposed
Standard), Sept. 1997.

221[34] I. Stoica, S. Shenker, and H. Zhang. Core-Stateless Fair
Queueing: A Scalable Architecture to Approximate Fair
Bandwidth Allocations in High-Speed Networks.
IEEE/ACM Transactions on Networking, 11(1):33–46, Feb.
2003.

[35] D. M. Turner, V. Prevelakis, and A. D. Keromytis. A
Market-Based Bandwidth Charging Framework. ACM
Transactions on Internet Technology, 10(1):1–30, 2010.

[36] J. Turner. New Directions in Communications (Or Which

Way to the Information Age?). IEEE Communications
Magazine, 24:8–15, 1986.

[37] H. Wu, H.-C. Hsiao, and Y.-C. Yu. Eﬃcient Large Flow
Detection over Arbitrary Windows: An Algorithm Exact
Outside An Ambiguity Region. Technical report,
CMU-CyLab-14-006, CyLab, Carnegie Mellon University,
2014.

[38] M. Yu, L. Jose, and R. Miao. Software Deﬁned Traﬃc

Measurement with OpenSketch. In Proceedings of USENIX
NSDI, 2013.

APPENDIX

A. ENGINEERING THE DETECTOR: SO-

LUTION AND ANALYSIS

We give a detailed solution and analysis to the problem
deﬁned in Section 4.6. The problem can be expressed by the
inequality set (5):

that the inequality sets (5) and (7) are not totally equal, so
there may be additional solutions outside this space.

5
x 10

∆β−n Solution Space

 

∆β Lower Bound Curve

∆β Upper Bound Curve

4.5

4

3.5

3

2.5

2

1.5

1

0.5

β
∆

 

0
100

200

300

400

500

600

700

800

900

1000

number of counters (n)

Figure 8: Curve of
the lower bound of βℓ.
(γℓ = 100, 000 byte/s γh = 1, 000, 000 byte/s, ρ =
100, 000, 000 byte/s, α = 1518 bytes, βℓ = 6072 bytes,
tupincb = 1 second.)

According to the inequality set (7), the lower bound of β∆
. We can see β∆ min increases with n, as

is β∆ min = γℓ(α+βℓ)
n+1 −γℓ
Figure 8 shows. Since we can reduce memory consumption
and the burst gap by using a smaller n and β∆, we choose

ρ

n+1

< tupincb

α + 2βT H
γh − ρ
α(n − 1) + (n + 1)βℓ + (n + 1)β∆ · ρ > γℓ

β∆

ρ

n + 1

< γh




⇐




2(α + βT H )
n+1 ≤ tupincb
γh − ρ
β∆
α + βℓ + β∆ ·

ρ

n + 1 ≥ γℓ

ρ

< γh

n + 1
tupincb(γh − ρ
n+1 ) − 2(α + βℓ)
2

γℓ(α + βℓ)
n+1 − γℓ

ρ

⇔

n >

β∆ ≤

β∆ ≥
ρ
γh − 1



n+1 − γℓ ≤
ρ
γh − 1

ρ

γℓ(α + βℓ)

n >

⇒




tupincb(γh − ρ
n+1 ) − 2(α + βℓ)
2

We can assert that there must exist a solution pair of (n, β∆)
which fulﬁlls the inequality set (7), if and only if there is a
n satisfying nmin ≤ n ≤ nmax, where

nmin = ⌈ρ/

M + pM 2 − 4γhγℓ

2

nmax = ⌊ρ/

M − pM 2 − 4γhγℓ

2

⌉ − 1

⌋ − 1

M = γh + γℓ −

2(α + βℓ)
tupincb ≥ 0




Figure 8 illustrates the solution space. In this ﬁgure, the
(n, β∆) solution pairs are in the space between the two lines
of the lower bound curve and the upper bound curve. Note

(5)

(6)

(7)

(8)

n = nmin = ⌈ρ/

M + pM 2 − 4γhγℓ

2

βT H = βℓ + β∆ min = βℓ +

⌉ − 1
γℓ(α + βℓ)
nmin+1 − γℓ

ρ

(10)




as our ﬁnal answer to the design problem.

We give a numerical example showing how to conﬁgure
EARDet based on the result above. Suppose the adminis-
trator of the detector chooses γℓ = 100KB/s, γh = 1M B/s,
ρ = 100M B/s, α = 1518 bytes, βℓ = 6072 bytes, tupincb =
1 second. Then using Equation (10), we choose n = 101 and
β∆ = 863 bytes. With these two parameters, the incubation
period is 0.7848 seconds which is smaller than tupincb = 1
second, and the no false positive rate is 100450 byte/s which
is larger than γℓ = 100000. The ratio between no false
ρ
n+1 and low-bandwidth threshold rate γℓ is
negative rate
ρ
n+1 /γℓ = 9.80. The results show that to achieve quick re-
action to large ﬂows and a small rate gap, the detector only
needs a small number of extra counters compared with the
− 1 = 99)
minimum number of required counters (i.e.
and a low burst gap.

ρ
γh

We obtain this particular solution by choosing the mini-
mum n and minimum β∆. We can also solve the inequality
set (5) for diﬀerent requirements, such as minimizing the
rate gap between ρ

· ρ.

β∆

α(n−1)+(n+1)β+(n+1)β∆

n+1 and

However, the inequality set (7) may be unsolvable for some
ρ, γℓ, βℓ, γh, α, tupincb. To make it solvable, we need to make
sure M 2 − 8γhγℓ and M are not negative in the inequality
set (9). Namely,

(9)

γh + γℓ −

2(α + βℓ)
tupincb ≥ p4γhγℓ

(11)

(12)

⇐ tupincb ≥

2(α + βℓ)

γh + γℓ − 2√γhγℓ

Moreover, according to Section 4.3, γh > γℓ is necessary

to make the inequality set (7) solvable.

222