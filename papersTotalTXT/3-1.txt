Practical Fully Simulatable Oblivious Transfer

with Sublinear Communication

Bingsheng Zhang1, Helger Lipmaa2, Cong Wang3, and Kui Ren1

1 State University of New York at Buﬀalo, United States

2 University of Tartu, Estonia

3 City University of Hong Kong, China

Abstract During an adaptive k-out-of-N oblivious transfer (OT), a
sender has N private documents, and a receiver wants to adaptively
fetch k documents from them such that the sender learns nothing about
the receiver’s selection and the receiver learns nothing more than those
chosen documents. Many fully simulatable and universally composable
adaptive OT schemes have been proposed, but those schemes typically
require O(N ) communication in the initialization phase, which yields
O(N ) overall communication. On the other hand, in some applications,
the receiver just needs to fetch a small number of documents, so the
initialization cost dominates in the entire protocol, especially for 1-out-
of-N OT. We propose the ﬁrst fully simulatable adaptive OT with sub-
linear communication under the DDH assumption in the plain model.
Our scheme has O(N 1/2) communication in both the initialization phase
and each transfer phase. It achieves better (amortized) overall commu-
nication complexity compared to existing schemes when k = O(N 1/2).
Keywords. Adaptive oblivious transfer, fully simulatable security, sub-
linear communication, zero knowledge batch argument.

1

Introduction

Data outsourcing and online shopping have become during the recent years. To
address the related information security and privacy concerns, many crypto-
graphic protocols have been studied to accomplish tasks with minimal informa-
tion disclosure. Consider the case that an online store sells digital goods, such as
movies, books, music, etc. The buyer wants to purchase some of them without
revealing his/her choices. Here, we assume that there is a uniform price for those
goods in the same category, e.g. movies. 1 Oblivious transfer (OT) is a handy
primitive, which has found its usage in many security applications with this kind
of privacy requirements as in the aforementioned case.

OT family mainly consists of 1-out-of-2 OT, denoted as OT2

OT, denoted as OTN
adaptive queries (also known as adaptive k-out-of-N OT), denoted as OTN

1 , k-out-of-N OT, denoted as OTN

1, 1-out-of-N
k and k-out-of-N OT with
k×1.

1 It is also possible to protect the buyer’s privacy even if all the goods are paid at

unique prices. This problem is addressed by priced OT, see [33] for details.

OT2
1 is widely used in secure multi-party/two-party computation, for example, it
serves as an important building block of Yao’s garbled circuit [34] in two-party
secure function evaluation (SFE). Based on earlier work of Lipmaa [26], Ishai
and Paskin [18] showed how to privately evaluate a branching program with
OT2
1 also has rich applications in ﬁnancial cryptography, for instance, one
can use OTN

1 to construct simultaneous contract signing schemes [29].

1. OTN

k×1 as well as its special case, OTN

We focus on OTN
1 when k = 1. During an
OTN
k×1 protocol, a sender has N private documents, and a receiver can adaptively
fetch k documents from them such that the sender learns nothing about the
receiver’s selection and the receiver learns nothing more than those k documents.
The notion of OTN
k×1 was ﬁrst introduced by Naor and Pinkas [30] who also gave
several applications, including oblivious search. In an oblivious search protocol,
the server owns a sorted database that the client wants to search. Given the
element that the client is searching for, they invoke an OTN
k×1 protocol using
binary search, where k = log N . After the protocol execution, the client can
determine whether the element is in the database while the server only has
revealed limited database information (log N elements).

There is always a trade-oﬀ between security and eﬃciency. Due to bandwidth
limitation, most applications employ OT schemes with so-called half-simulation
security, where the sender’s and receiver’s security are handled separately. Such
OTN
1 can achieve logarithmic communication [10] or sublinear computation [27]
and OTN
k can achieve optimal rate [1]. The receiver’s security is deﬁned as indis-
tinguishability of the sender’s view of the protocol when the receiver’s choices
are diﬀerent. The sender’s security follows the real-world/ideal-world paradigm
and guarantees that for any malicious receiver in the real world there is a receiver
in an ideal world where OT is implemented by a trusted party. However, this
security deﬁnition is vulnerable to the selective failure attack [30]. Namely, the
sender is able to cause protocol failure based on some property of the receiver’s
selection. Based on an arbitrary semisimulatable OT protocol, Laur and Lipmaa
proposed a consistent OT protocol [24] of virtually the same complexity that
allows to detect selective failures, but still does not obtain ideal security.
On the other hand, all existing fully simulatable and universally composable
adaptive OT schemes typically require O(N ) communication in the initialization
phase. The huge initialization cost is not acceptable in many applications, espe-
cially when the receiver is only required to fetch a small number of documents.
For example, in 1-out-of-N OT the initialization cost dominates the entire pro-
tocol, so the overall communication cost becomes O(N ). Can we make OT more
communication-eﬃcient without sacriﬁcing its security level? In this paper, we
try to answer this question by investigating a practical fully simulatable OTN
k×1
scheme with sublinear communication.

Our Contribution and Related Work. In theory, one can transform any se-
cure OT protocol in semi-honest model to an OT protocol that is secure against
malicious adversaries by plug-in zero-knowledge (ZK) proofs/arguments. To
achieve sublinear communication, we may use probabilistically checkable proofs

Scheme

Init Cost Transfer Cost

Prot. 3.1 [31] O(N )
O(N )
O(N )
O(N )
O(N )
O(N )
O(N )
O(N )
O(N )
O(N )

O(N 1/2)
O(1)
O(1)
O(N )
O(1)
O(1)
O(1)
O(1)
O(1)
O(1)
this work O(N 1/2) O(N 1/2)

[5]
[13]
[20]
[19]
[33]
[21]
[14]
[22]
[35]

Assumption

Security
Full Sim
q-Power DDH + q-Strong DH Full Sim

DDH

DLIN + q-Hidden LRSW

Dec. n-th Residuosity/DDH
Dec. Residuosity + q-DDHI

UC

Full Sim
Full Sim

DLIN + q-Hidden SDH + q-TDH UC

DDH

3-DDH + DLIN

DDH/DLIN/DCR/QR/LWE
DDH/Dec. n-th Residuosity

DDH

Full Sim
Full Sim
Full Sim
Full Sim
Full Sim

Table1. Comparison of OTN

k×1 schemes. The trivial factor log N is ignored.

(PCP), e.g., [4] or a sublinear ZK argument [17,28]. The problem with such
approaches is that the OT protocol has to be reduced to some NP-complete
√
language, which is neither eﬃcient nor practical. In this paper, we propose the
k×1 scheme with O(
ﬁrst fully simulatable OTN
N ) communication in both the
√
initialization phase and each transfer phase based on the standard DDH as-
sumption. When k = O(
k×1 scheme has better amortized overall
communication complexity compared to existing schemes. In order to achieve
sublinear communication complexity, we constructed a few eﬃcient batch ZK
arguments, such as masked multi-exponentiation batch argument (c.f. Sect. 4.3,
below). We use Lim’s multi-exponentiation algorithm in our implementation,
and a benchmark is given at the end of this paper.

N ), our OTN

We now give a survey on recent fully simulatable and universally composable
OTN
k×1 schemes. As shown by Canetti and Fischlin [6], an OT cannot be realized
in UC security without additional trusted setup assumptions. All the UC-secure
OTN
k×1 schemes mentioned here are in common reference string (CRS) model,
i.e. Fcrs-hybrid model. Whereas many fully simulatable OTN
k×1 schemes in this
survey, as well as our construction, are realized in the plain model. Table 1 lists
several existing OTN
k×1 schemes, together with our proposed scheme for com-
parison. In 2007, Camenisch, Neven and shelat [5] proposed OTN
k×1 under the
q-strong Diﬃe-Hellman and q-power decisional Diﬃe-Hellman assumptions in
bilinear groups. They used signatures as a key ingredient in their scheme. Later,
Green and Hohenberger [12] showed an OTN
k×1 in random oracle model under de-
cisional bilinear Diﬃe-Hellman assumption. In their scheme, the sender encrypts
message mi by identity-based encryption under identity i. The receiver executes a
blind key extraction protocol such that he/her can obliviously obtain the secret
key of any identity. In 2008, Green and Hohenberger [13] introduced another
OT that achieves UC security in the Fcrs-hybrid model, using a Groth-Sahai
non-interactive ZK (NIZK) proof for pairing product equations. The scheme is
based on the decisional linear and q-Hidden LRSW assumptions. Jarecki and

Liu [19] simpliﬁed the Camenisch et al. construction to a fully simulatable OT
under the composite decisional residuosity and q-decisional Diﬃe-Hellman Inver-
sion assumptions. Rial, Kohlweiss and Preneel [33] presented an adaptive priced
OT that achieves UC security using “assisted decryption”. In 2009, Kurosawa
and Nojima [20] gave adaptive OT constructions based on Paillier and ElGa-
mal encryption schemes. Later, Kurosawa, Nojima and Phong [21] improved the
scheme [20] by increasing the complexity of initialization phase. In 2011, Green
and Hohenberger [14] proposed another fully simulatable OT under decisional 3-
party Diﬃe-Hellman assumption. Recently, Kurosawa et al. [22] and Zhang [35]
generalized the scheme in [21] to various schemes with diﬀerent assumptions.

We emphasize that Prot. 3.1 in [31] is essentially diﬀerent from our scheme.
In [31], the sender ﬁrst ‘commits’ the documents to the receiver in the initializa-
tion phase. This step takes O(N ) communication, because each “commitment”
serves as an encryption and the receiver should be able to extract (or decrypt)
the committed document from it later. Therefore, it is not possible to directly
plug a succinct commitment scheme in the Naor-Pinkas scheme.

2 Preliminaries
Let [n] := {1, . . . , n}. By a, we denote a vector a = (a1, . . . , an)T . When S is a
set, a ←$ S means that a is uniformly and randomly chosen from S. Let λ be
c≈ B, we mean that A and B are computationally
the security parameter. By A
indistinguishable. We abbreviate probabilistic polynomial-time as p.p.t. and let
poly(·) be a polynomially-bounded function.

Elliptic Curves Over Fp. The implementation of our scheme is based on
elliptic curve groups for eﬃciency. Let σ := (p, a, b, g, q, ζ) be the elliptic curve
domain parameters over Fp, consisting of a prime p specifying the ﬁnite ﬁeld Fp,
two elements a, b ∈ Fp specifying an elliptic curve E(Fp) deﬁned by E : y2 ≡
x3 + ax + b (mod p), a base point g = (xg, yg) on E(Fp), a prime q which is the
order of g, and an integer ζ which is the cofactor ζ = #E(Fp)/q. We denote the
cyclic group generated by g by G, and it is assumed that the DDH assumption
holds over G, that is for all p.p.t. adversary A:

(cid:12)(cid:12)(cid:12)(cid:12)Pr

AdvDDHG

(A) =

(cid:20) x, y ←$ Zq; b ←$ {0, 1} ; h0 = gxy;

h1 ←$ G : A(g, gx, gy, hb) = b

(cid:21)

(cid:12)(cid:12)(cid:12)(cid:12) ≤ (λ) ,

− 1
2

where (·) is a negligible function.

Security Deﬁnition (Fully Simulation Security). We use the same se-
curity deﬁnition as in [30,5,14]. Let (SI , RI , ST , RT ) be an OTN
k×1 protocol.
Let S∗, R∗ be private states. During the initialization phase, the sender sets
S0 ← SI (m1, . . . , mN ), and the receiver sets R0 ← RI (). During the (cid:96)-th
transfer phase, (cid:96) ∈ [k], the sender sets S(cid:96) ← ST (S(cid:96)−1), and the receiver sets
) ← RT (R(cid:96)−1, i(cid:96)), where i(cid:96) ∈ [N ] is the index of the message to be
(R(cid:96), m∗

σ(cid:96)

σ(cid:96)

σ(cid:96)

= mσ(cid:96) if retrieval succeeds, m∗

= ⊥ if fails. The security of an
received. m∗
OTN
k×1 scheme is deﬁned in the real-world/ideal-world paradigm with static cor-
ruption, i.e. the adversary A can only choose to corrupt either the sender or the
receiver at the beginning of the experiment.
Real experiment. In experiment RealˆS, ˆR(N, k, m1, . . . , mN ,I), a presumably
cheating sender ˆS is given messages (m1, . . . , mN ) as input and interacts with
a presumably cheating receiver ˆR(I), where I is a selection algorithm that
on input messages {mit}(cid:96)−1
t=1 outputs the index i(cid:96) of the next message to be
queried. In the initialization phase, ˆS and ˆR output the initial states S0 and
R0. In the (cid:96)-th transfer phase, for (cid:96) ∈ [k], the sender runs S(cid:96) ← ˆS(S(cid:96)−1), and
) ← ˆR(R(cid:96)−1). After the k-th transfer, the output of
the receiver runs (R(cid:96), m∗
the experiment RealˆS, ˆR is the tuple (Sk, Rk).

i(cid:96)

We deﬁne

the honest

the one

sender algorithm S as

runs
SI (m1, . . . , mN ) in the initialization phase, runs ST () during each transfer
phase, and returns Sk = ∅ as its ﬁnal output. The honest receiver algorithm
R runs RI () in the initialization phase, runs RT (R(cid:96)−1, i(cid:96)) during the (cid:96)-th trans-
fer phase, where the index i(cid:96) is generated by I, and returns Rk = (mi1, . . . , mik )
as its ﬁnal output.
Ideal experiment. In experiment IdealˆS(cid:48), ˆR(cid:48)(N, k, m1, . . . , mN ,I), the presum-
ably cheating sender ˆS(cid:48) and the presumably cheating receiver ˆR(cid:48) communicate
with the ideal functionality F N×1
OT . In the initialization phase, ˆS(cid:48)(m1, . . . , mN )
N to F N×1
OT . In the (cid:96)-th transfer phase, (cid:96) ∈ [k], ˆR(cid:48)(I)
sends messages m∗
(cid:96) . F N×1
sends to F N×1
then sends a tag ‘Received’ to ˆS(cid:48), and ˆS(cid:48)
replies a bit b(cid:96) ∈ {0, 1} to F N×1
to ˆR(cid:48);
OT . If b(cid:96) = 1 and i∗
otherwise, it sends ⊥ to ˆR(cid:48). After the k-th transfer, the output of the experiment
IdealˆS(cid:48), ˆR(cid:48) is the tuple (Sk, Rk).
We deﬁne the honest sender algorithm S(cid:48)(m1, . . . , mN ) as the one that sends
m1, . . . , mN to F N×1
in the initialization phase, and sends b(cid:96) = 1 during each
transfer phase, and returns Sk = ∅ as its ﬁnal output. The honest receiver
R(cid:48) submits the indices i(cid:96) that generated by I to F N×1
OT , and returns Rk =
(mi1, . . . , mik ) as its ﬁnal output.

1, . . . , m∗
an index i∗

(cid:96) ∈ [N ], F N×1

OT

sends m∗
i∗

OT

OT

that

(cid:96)

OT

Sender Security. An OTN
k×1 is sender-secure if for every real-world p.p.t. receiver
ˆR, there exists an ideal-world p.p.t. receiver ˆR(cid:48), s.t. for every N = poly(λ),
k ∈ [N ], (m1, . . . , mN ), selection algorithm I, and p.p.t. distinguisher D,
c≈ IdealS(cid:48), ˆR(cid:48)(N, k, m1, . . . , mN ,I) .

RealS, ˆR(N, k, m1, . . . , mN ,I)

Receiver Security. An OTN
k×1 is receiver-secure if for every real-world p.p.t.
sender ˆS, there exists an ideal-world p.p.t. sender ˆS(cid:48), s.t. for every N = poly(λ),

k ∈ [N ], (m1, . . . , mN ), selection algorithm I, and p.p.t. distinguisher D,
c≈ IdealˆS(cid:48),R(cid:48)(N, k, m1, . . . , mN ,I) .

RealˆS,R(N, k, m1, . . . , mN ,I)

Deﬁnition 1. OTN
secure.

k×1 is fully simulatable iﬀ it is both sender- and receiver-

Special Honest Veriﬁer Zero-knowledge Argument. Let R be a polyno-
mial time decidable binary relation, we say w is a witness for a statement x if
(x, w) ∈ R. We deﬁne the language L := {x | ∃w : (x, w) ∈ R} as the set of all
statements x that have a witness w for the relation R. Let a prover P and a
veriﬁer V be two p.p.t. interactive algorithms. Denote τ ← (cid:104)P(x, w),V(x)(cid:105) as
the public transcript produced by P and V. After the protocol, V accepts iﬀ
Φ(x, τ ) = 1, where Φ is a predicate function.
Deﬁnition 2. We say (P,V) is a perfectly complete argument for a relation R
if for all non-uniform p.p.t. interactive adversaries A it satisﬁes
– Perfect completeness: Pr[(x, w) ← A; τ ← (cid:104)P(x, w),V(x)(cid:105) : (x, w) ∈ R ∨
– Computational soundness: Pr[x ← A; τ ← (cid:104)A,V(x)(cid:105) : x /∈ L∧ Φ(x, τ ) = 1] ≈

Φ(x, τ ) = 1] = 1;

0.
Denote V(x; r) as the veriﬁer V on input x, given r as the randomness. An
argument (P,V) is public coin if the veriﬁer V picks his challenges randomly and
independently of the messages sent by the prover P.
Deﬁnition 3. A public coin argument (P,V) is called a perfect special honest
veriﬁer zero-knowledge (SHVZK) argument for a relation R if there exists a
p.p.t. simulator S such that for all non-uniform polynomial time adversaries A
we have

Pr[(x, w, r) ← A;τ ← (cid:104)P(x, w),V(x; r)(cid:105) : (x, w) ∈ R ∧ A(τ ) = 1]

= Pr[(x, w, r) ← A; τ ← S(x; r) : (x, w) ∈ R ∧ A(τ ) = 1] .

We deﬁne the SHVZK argument of knowledge similiarly to the deﬁnition
of [15,16,2]; namely, given an adversary that produces an acceptable argument
with probability p, there exists a witness-extended emulator that produces a
similar argument with probability p and outputs a witness. The standard deﬁni-
tion of “proofs of knowledge (PoK)” by Bellare and Goldreich [3] does not work
for “arguments of knowledge (AoK)”. See [8] for more discussion of this issue
and an alternative deﬁnition of knowledge soundness.
Deﬁnition 4. A public coin argument (P,V) has a witness extended emulator
if for all p.p.t. P∗ there exists an expected polynomial time emulator X = X P∗
such that for all non-uniform polynomial time adversaries A,

 (x, ψ) ← A;

Pr

τ ← (cid:104)P∗(x, ψ),V(x)(cid:105) :
A(τ ) = 1

 = Pr

 (x, ψ) ← A;

(τ, w) ← X (cid:104)P∗(x,ψ),V(x)(cid:105)(x, ψ) :
A(τ ) = 1 ∧ (Φ(x, τ ) = 0 ∨ (x, w) ∈ R)

 .

Here, X has access to a transcript oracle (cid:104)P∗(x, ψ),V(x)(cid:105) that can be rewound
to a particular round and run again with the veriﬁer using fresh randomness. Let
ψ be the state of P∗, including the randomness. Whenever P∗ is able to make a
convincing argument with state ψ, the emulator X can extract a witness w.

3 Building Blocks

Additively Homomorphic Public-key Cryptosystem. The lifted ElGamal
public-key cryptosystem consists of the following 4 p.p.t. algorithms:

– Gengk(1λ): inputs a security parameter λ, and outputs σ := (p, a, b, g, q, ζ).
– Genpkc(σ): picks sk ←$ Z∗
– Encpk(m; r): outputs e := (e1, e2) = (gr, gmhr).
– Decsk(e): outputs DLg(e2 · e−sk

), where DLg(x) is the discrete logarithm of
x. (Note that since DLg(·) is not eﬃcient, the message space should be a
small set, say {0, 1}ξ, for ξ ≤ 30.)

q, sets pk := h = gsk, and outputs (pk, sk).

1

It is well known that lifted ElGamal encryption scheme is IND-CPA se-
cure under the DDH assumption. It is additively homomorphic: Encpk(m1; r1) ·
Encpk(m2; r2) = Encpk(m1 + m2; r1 + r2).

Additively Homomorphic Succinct Vector Commitment. In our proto-
col, we use a generalized version of the Pedersen commitment scheme [32]. The
generalized Pedersen commitment scheme consists of the following 4 algorithms:

– Comck(m; r): outputs a commitment c := f r(cid:81)n

– Gengk(1λ): inputs security parameter λ, and outputs σ := (p, a, b, g, q, ζ).
– Genped(σ): outputs distinct generators ck := (g1, . . . , gn, f ).
for m ∈ Zn

q and

r ∈ Zq.

– Openck(c): outputs m ∈ Zn

. Open also
receives some private information that was created during the commitment.

i

i=1 gmi

q , r ∈ Zq such that c = f r(cid:81)n

i=1 gmi

i

The generalized Pedersen commitment is perfect hiding and computationally
binding if the discrete logarithm problem is hard in G. It is additively homo-
morphic: Comck(m1; r1) · Comck(m2; r2) = Comck(m1 + m2; r1 + r2).

In the plain model, if Alice wants to commit N elements to Bob, the best
√
communication complexity with generalized Pedersen commitment scheme is
O(
N commitment keys ck, and
Alice commits and sends to Bob

N ). Namely, Bob ﬁrst sends to Alice n :=

N commitments.

√

√

4 Fully Simulatable OTN

k×1 With Square-root

Communication

We now propose a fully simulatable OTN
k×1 protocol with a square-root overall
communication complexity. The basic idea comes from the classic KO private

Common input: σ := (p, a, b, g, q, ζ) ← Gengk(1λ).
Sender’s input: M := {mi.j}i,j∈[n] = {mj}j∈[n], where mj = (m1,j, . . . , mn,j)T .
Receiver’s output: i(cid:96) := mx(cid:96),y(cid:96) for the (cid:96)-th transfer phase, where x(cid:96), y(cid:96) ∈ [n].

Initialization Phase:

1. R computes (pk, sk) ← Genpkc(σ) and ck ← Genped(σ) , and sends pk, ck to S.
2. S picks r ←$ Zn
i=1, where r := (r1, . . . , rn)T .

q and sends {ci := Comck(mi; ri)}n

The (cid:96)-th Transfer Phase:

i=1 and ev := {e(i)

1. R sets two unit vectors u, v ∈ {0, 1}n according to (x(cid:96), y(cid:96)), i.e., ux(cid:96) = 1,
q , and sends eu :=
v )}n
i=1 to S, where
u , . . . , t(n)
u )T and tv :=

vy(cid:96) = 1 and the rest are 0’s. He picks tu, tv ←$ Zn
{e(i)
:= Encpk(vi; t(i)
u := (u1, . . . , un)T , v := (v1, . . . , vn)T , tu := (t(1)
(t(1)

v )T .
2. R proves to S that eu, ev encrypt unit vectors by unit vector PoK (c.f. Sect. 4.1).
3. S picks ts ←$ Zn
a ),
wi = Encpk(ai; t(i)

u )mj,i , and z = Encpk(0; tz)(cid:81)n

q , tz ←$ Zq. S sets for i ∈ [n], c(i)

s )(cid:81)n

q , a, ta ←$ Zn
j=1(e(j)

a = Comck(ai; t(i)

j=1(e(j)

v )aj .

v , . . . , t(n)

:= Encpk(ui; t(i)

u

u )}n

v

4. S sends ca, w, z to R.
5. S proves to R that

– w, eu, c, ca are consistent by masked multi-exp batch AoK (c.f. Sect. 4.3);
– eu, z, ca are consistent by multi-exp AoK (c.f. Sect. 4.2, below).
x(cid:96),1· (gay(cid:96) )−1).
−sk

and then returns mi(cid:96) as DLg(wx(cid:96),2· w

6. R computes gay(cid:96) = z2· z

−sk
1

Figure1. Fully Simulatable OTN

k×1 With Square-root Communication

information retrieval (PIR) scheme [23]. Intuitively, when not concerned about
privacy, the receiver sends two n-dimensional unit-vectors u, v to the sender,
N . The sender computes and sends m∗ = u· M · vT to the receiver,
where n =

√

where M = {mi,j}i,j∈[n] is the sender’s database.

Both the ElGamal encryption scheme and the generalized Pedersen commit-
ment scheme are based on elliptic curves, so the membership of a group element is
eﬃciently decidable. Hence, during our protocol, if the message consists of group
elements/generators, the parties always ﬁrst check their group membership. We
will not mention this step in the protocol description explicitly.

We give the protocol description in Fig. 1. Our OTN

k×1 scheme consists of
the initialization phase and the transfer phase. If the prover is honest, then wi

encrypts ai +(cid:80) mj,iuj = ai + mx(cid:96),i and z encrypts(cid:80) ajvj = ay(cid:96), and thus the

veriﬁer can retrieve mx(cid:96),y(cid:96) as claimed.We show how to construct the SHVZK
proofs/arguments in the following sections. All the SHVZK proofs/arguments
should be compiled to general ones via a standard transformation by using com-
mitments and a public coin ﬂipping protocol, e.g. [9]. To keep the exposition
simple, we will not explicitly mention the transformation in the protocol.

4.1 SHVZK Unit Vector Proof

Now we show how to construct the SHVZK Unit Vector Proof that is used in
our OTN
k×1 scheme. In a Unit Vector Proof, given an encrypted vector e :=
(e1, . . . , en)T = (Encpk(b1; r1), . . . , Encpk(bn; rn))T ∈ (G× G)n, the prover wants
to convince the veriﬁer that b := (b1, . . . , bn)T ∈ Zn
q is a unit vector, i.e., there
is exactly one i ∈ [n] such that bi = 1 and ∀j (cid:54)= i : bj = 0. Considering the
lifted ElGamal encryption, we have ei := (ei,1, ei,2) = (gri, gbihri). As depicted
in Fig. 2, we give a ZK proof of knowledge (PoK) of b, r ∈ Zn
q such that for
i=1 bi = 1, where r := (r1, . . . , rn)T .
The proof uses ∨,∧ compositions [?] of the basic Σ protocol to prove that ei
encrypts 0 or 1, based on DDH tuple proof technique [7].

i ∈ [n], ei = Encpk(bi; ri), bi ∈ {0, 1} and(cid:80)n

let ¯bi

Common input: Group information σ and the public key pk := h.
Prover’s private input: b ∈ {0, 1}n and r ∈ Zn
q .
Statement: {(ei,1, ei,2) := (gri , gbi hri )}n
1. Since bi ∈ {0, 1},
si, ρi,¯bi , zi,¯bi ←$ Zq and computes a(bi)
i,2 = hzi,¯bi · (ei,2 · g−¯bi )
a(¯bi)
and sends {(a(0)

:= 1 − bi. For i ∈ [n], the prover picks random
and
−ρi,¯bi . He picks random s ←$ Zq, sets A1 = gs, A2 = hs,
i,1 , a(1)

i=1 and (A1, A2) to the veriﬁer.

i=1 ei,2.
−ρi,¯bi

i=1 ei,1, E2 :=(cid:81)n

i=1. Let E1 :=(cid:81)n

2. The veriﬁer picks random challenge ρ ←$ Z∗
3. For i ∈ [n], the prover sets ρi,bi = ρ − ρi,¯bi and zi,bi = riρi,bi + si. He computes
i=1 ri + s, and sends {ρi,0, zi,0, zi,1}n

Z = ρ ·(cid:80)n

q and sends ρ to the prover.

i=0 and Z to the veriﬁer.

i,2 = hsi , a(¯bi)

i,1 = gzi,¯bi e

i,1 = gsi , a(bi)

i,1 , a(0)

i,2 ), (a(1)

i,2 )}n

i,1

1 A1 = gZ ∧ (E2/g)ρA2 = hZ . For i ∈ [n], the veriﬁer

Veriﬁcation:
1. The veriﬁer checks Eρ

computes ρi,1 = ρ − ρi,0 and checks

eρi,0
i,1 a(0)

i,1 = gzi,0 ∧ eρi,0

i,2 a(0)

i,2 = hzi,0 ∧ eρi,1

i,1 a(1)

i,1 = gzi,1 ∧ (ei,2/g)ρi,1 a(1)

i,1 = hzi,1 .

Figure2. Public Coin SHVZK Unit Vector Proof

Theorem 1. The protocol depicted in Fig. 2 is a 3-move public coin perfect
special honest veriﬁer zero-knowledge proof of knowledge of b and r such that

ei = Encpk(bi; ri) ∧ bi ∈ {0, 1} ∧(cid:80)n

i=1 bi = 1.

Proof. For perfect completeness, if bi ∈ {0, 1}, it is easy to verify that all the
equations hold. For soundness, we have to construct an extractor X that runs on
(cid:104)P∗,V(cid:105) to get a transcript. It rewinds the protocol to the challenge phase and
runs it with fresh challenges until it has 2 acceptable proofs. Assuming the prover
P has probability of p(λ) of making an acceptable proof, so the extractor X will
take an average of 2/p(λ) rewinds, which is polynomial running time. Thus, there
is overwhelming probability that we have transcripts with 2 diﬀerent challenges
ρ(1), ρ(2). From those transcripts, the extractor can extract the knowledge b
and r. Namely, for each i ∈ [n], we have at least one diﬀerent pair between

i,x, ρ(2)

i,1 , ρ(2)
i,x − ρ(2)

i,0 ) and (ρ(1)
i,x )/(ρ(1)

i,1 ). Assume ρ(1)
(ρ(1)
i,0 , ρ(2)
i,x are diﬀerent, we can compute ri =
i,x − z(2)
i,x). Subsequently, X can extract bi by checking ei. Hence,
(z(1)
we have constructed an extractor X that outputs b and r.
For perfect zero-knowledge, we construct a simulator S that on challenge ρ
outputs simulated proof that is indistinguishable from a real proof with challenge
ρ. On challenge ρ, for i ∈ [n], S randomly picks ρi,0, zi,0, zi,1, Z ←$ Zq and com-
putes ρi,1 = ρ − ρi,0, A1 = gZE
i,2 =
i,2 = hzi,1 (ei,2/g)−ρi,1 . S outputs
, a(1)
hzi,0e

−ρ
1 , A2 = hZ(E2/g)−ρ, a(0)

i,1 = gzi,0e

i,1 = gzi,1e

−ρi,0
i,2

−ρi,1
i,1

−ρi,0
i,1

, a(0)

, a(1)

i,1 , a(0)

i,2 ), (a(1)

i,1 , a(1)

i,2 )}n

i=1, (A1, A2), ρ,{ρi,0, zi,0, zi,1}n

i=0

(cid:16){(a(0)

τ∗ :=

(cid:17)

.

Note that simulated zi,0, zi,1, Z have the same distribution as in the real
proof, because si, s are uniformly random. It is easy to see that ρ0 and
ρ1 have identical distribution of them in a real proof. Finally, we argue
that {(a(0)
i=1, (A1, A2) are uniquely determined for ﬁxed
ρ0, ρ0, zi,0, zi,1, Z. Therefore, we have shown that the distribution of simulated
(cid:117)(cid:116)
τ∗ is identical to τ in a real proof.

i,2 ), (a(1)

i,2 )}n

i,1 , a(0)

i,1 , a(1)

4.2 Multi-exponentiation Argument

q and t ∈ Zq such that v = Encpk(0; t)(cid:81)n

In Fig. 3, we give an argument of knowledge of m := (m1, . . . , mn)T , r :=
(r1, . . . , rn)T ∈ Zn
and ci =
Comck(mi; ri), for i ∈ [n].

j=1 emj

j

q and t ∈ Zq.

q , t(cid:48) ←$ Zq and sends v(cid:48) := Encpk(0; t(cid:48))(cid:81)n

Common input: Group information σ and pk, ck.
Statement: e ∈ (G × G)n, v ∈ (G × G) and c ∈ Gn.
Prover’s private input: m, r ∈ Zn
1. The prover picks x, y ←$ Zn
2. The veriﬁer picks a random challenge ρ ←$ Z∗
3. The prover sends w := ρ · m + x, ˆt = ρ · t + t(cid:48) and z := ρ · r + y to the veriﬁer.
Veriﬁcation:
1. The veriﬁer checks cρ

i ui = Comck(wi; zi) ∧ vρv(cid:48) = Encpk(0; ˆt)(cid:81)n

ui := Comck(xi; yi) to the veriﬁer.

q and sends ρ to the prover.

i=1 exi
i ,

i=1 ewi

.

i

Figure3. Public Coin SHVZK Multi-exponentiation Argument

v = Encpk(0; t)(cid:81)n

Theorem 2. The protocol depicted in Fig. 3 is a 3-move public coin perfect
special honest veriﬁer zero-knowledge argument of knowledge of m, r, t such that

j=1 emj

j ∧ ci = Comck(mi; ri).

Proof. For perfect completeness, it is easy verify that all the equations hold.
Now we prove soundness and show that the protocol is an argument of knowl-
edge (AoK). Since ρ ∈ Z∗
q is randomly chosen, by Schwartz-Zippel lemma, the

prover has negligible probability of convincing the veriﬁer unless all ρ related
terms match on each side of the equality. Now we construct the witness-extended
emulator X runs (cid:104)P∗,V(cid:105) to get a transcript. If the prover P has probability p(λ)
of making an acceptable argument, the black-box witness-extended emulator X
also has success probability p(λ) to produce an accepting argument. It rewinds
the protocol to the challenge phase and runs it with fresh challenges until it has
2 acceptable arguments. Since the prover P has probability p(λ) of making an
accepting argument in the ﬁrst place, the emulator X will take an average of
2/p(λ) rewinds, which is polynomial running time. Again, there is overwhelming
probability that we have transcripts with 2 diﬀerent challenges ρ(1), ρ(2). After
obtaining w(η) = ρ(η) · m + x, ˆt(η) = ρ(η) · t + t(cid:48), z(η) = ρ(η) · r + y for η ∈ {1, 2},
X computes m = (w(1) − w(2))/(ρ(1) − ρ(2)), t = (ˆt(1) − ˆt(2))/(ρ(1) − ρ(2)) and
r = (z(1) − z(2))/(ρ(1) − ρ(2)). Hence, we have extracted a valid witness m, r, t
for the statement.
For perfect zero-knowledge, we have to construct a simulator S on challenge
ρ outputs the simulated argument that is indistinguishable from a real argument
with challenge ρ. On challenge ρ, the simulator S randomly picks w, z ←$ Zn
q and
−ρ
· v−ρ and ui = Comck(wi; zi)· c
.
S outputs τ∗ := (v(cid:48), u, ρ, w, ˆt, z). Since x, y, t are uniformly random in a real
i
argument, the distribution of simulated w, ˆt, z is identical to the distribution
of them in a real argument. Furthermore, v(cid:48), u are uniquely determined for
ﬁxed ρ, w, ˆt, z; therefore, simulated τ∗ has the same distribution as τ in a real
(cid:117)(cid:116)
argument.

ˆt ←$ Zq. S computes v(cid:48) = Encpk(0; ˆt)(cid:81)n

i=1 ewi

i

4.3 Masked Multi-exponentiation Batch Argument

In this section, we propose the masked multi-exponentiation batch argument.
Given two vectors of ciphertexts e := (e1, . . . , en)T ∈ (G × G)n, v :=
(v1, . . . , v(cid:96))T ∈ (G×G)(cid:96) and two vectors of commitments c := (c1, . . . , c(cid:96))T ∈ G(cid:96)
and u := (u1, . . . , u(cid:96))T ∈ G(cid:96), as depicted in Fig. 4, we will give an argument of
knowledge of M := {mj,i}n,(cid:96)

q such that for i ∈ [(cid:96)],

, r, s, t, d ∈ Z(cid:96)

j,i=1 ∈ Zn×(cid:96)

q

vi = Encpk(si; ti)

emj,i
j

,

ui = Comck(si; di)

and ci = Comck(mi; ri) .

vi = Encpk(si; ti)

emj,i
j

,

ui = Comck(si; di)

and ci = Comck(mi; ri)

j=1

where mi
(t1, . . . , t(cid:96))T and d := (d1, . . . , d(cid:96))T .

:= (m1,i, . . . , mn,i)T , r := (r1, . . . , r(cid:96))T , s := (s1, . . . , s(cid:96))T , t :=

Theorem 3. The protocol depicted in Fig. 4 is a 3-move public coin perfect
special honest veriﬁer zero-knowledge argument of knowledge of M , r, s, t, d such
that for i ∈ [(cid:96)],

n(cid:89)

n(cid:89)

j=1

Common input: Group information σ and pk, ck.
Statement: e ∈ (G × G)n, v ∈ (G × G)(cid:96) and c, u ∈ G(cid:96).
and r, s, t, d ∈ Z(cid:96)
Prover’s private input: M ∈ Zn×(cid:96)
q.
1. The prover picks x ←$ Zn
q , s0, t0, r0, d0 ←$ Zq and sends v0

:=
i , cx := Comck(x; r0) and u0 := Comck(s0; d0) to the ver-

Encpk(s0; t0)(cid:81)n

i=1 exi

q

iﬁer.

2. The veriﬁer randomly picks a challenge ρ ←$ Z∗
3. Set ρ := (ρ, ρ2, . . . , ρ(cid:96))T . The prover sends w := M · ρ + x, t(cid:48) = tT · ρ + t0,
s(cid:48) = sT · ρ + s0, d(cid:48) = dT · ρ + d0 and r(cid:48) := rT · ρ + r0 to the veriﬁer, where
w := (w1, . . . , wn)T .

q and sends ρ to the prover.

Veriﬁcation:

1. The veriﬁer checks

u0

(cid:48)
uρi
i = Comck(s

(cid:48)

)∧cx

; d

(cid:96)(cid:89)

i=1

(cid:96)(cid:89)

i=1

cρi
i = Comck(w; r

(cid:48)

)∧v0

(cid:96)(cid:89)

i=1

(cid:48)
vρi
i = Encpk(s

(cid:48)

)

; t

n(cid:89)

i=1

ewi
i

.

Figure4. Public Coin SHVZK Masked Multi-exponentiation Batch Argument

Proof. For perfect completeness, it is easy to verify that all the equations hold.
Now we prove soundness and show that the protocol is an argument of knowl-
edge (AoK), by showing that it has a witness-extended emulator. Since ρ ∈ Z∗
q
is randomly chosen, by Schwartz-Zippel lemma, the prover has negligible proba-
bility of convincing the veriﬁer unless all ρi related terms match on each side of
the equality for all i ∈ [(cid:96)]. The witness-extended emulator X runs (cid:104)P∗,V(cid:105) to get
a transcript. If the prover P has probability p(λ) of making an acceptable argu-
ment, the black-box witness-extended emulator X also has success probability
p(λ) to produce an accepting argument. It rewinds the protocol to the challenge
phase and runs it with fresh challenges until it has (cid:96) + 1 acceptable arguments.
Since the prover P has probability p(λ) of making an accepting argument in
the ﬁrst place, the emulator X will take an average of (cid:96)+1
p(λ) rewinds, which takes
poly(λ) running time. Again, there is overwhelming probability that we have
transcripts with (cid:96) + 1 diﬀerent challenges. The (cid:96) + 1 diﬀerent challenges give us
a ((cid:96) + 1) × ((cid:96) + 1) transposed Vandermonde matrix



1
ρ(1)
...

V =

1
ρ(2)
...

1

···
··· ρ((cid:96)+1)
. . .

...

(ρ(1))(cid:96) (ρ(2))(cid:96) ··· (ρ((cid:96)+1))(cid:96)

 .

Note that V is invertible because ρ(1), . . . , ρ((cid:96)+1) are diﬀerent, and X computes
V −1. Let Mx be the n × ((cid:96) + 1) matrix that is the column x concatenated
at the left side of M and denote W as the matrix that consists of columns
(w(1), . . . , w((cid:96)+1)). We have W = Mx · V , and X can compute Mx = W ·

v0 = (Encpk(s(cid:48); t(cid:48))(cid:81)n

q and r(cid:48), s(cid:48), t(cid:48), d(cid:48) ←$ Zq. S computes u0 = Comck(s(cid:48); d(cid:48))/((cid:81)(cid:96)
i ) and cx = Comck(w; r(cid:48))/((cid:81)(cid:96)

V −1. Similarly, X can extract r, s, t, d; hence, X has extracted a valid witness
M , r, s, t, d for the statement.
For perfect zero-knowledge, we have to construct a simulator S on chal-
lenge ρ outputs the simulated argument that is indistinguishable from a real
argument with challenge ρ. On challenge ρ, the simulator S randomly picks
w ←$ Zn
i=1 uρi
i ),
i ). S
outputs τ∗ := (u0, v0, cx, ρ, w, r(cid:48), s(cid:48), t(cid:48), d(cid:48)). Since x, r0, s0, t0, d0 are uniformly
random in a real argument, the distribution of simulated w, r(cid:48), s(cid:48), t(cid:48), d(cid:48) is iden-
tical to the distribution of them in a real argument. Furthermore, u0, v0, cx are
uniquely determined for ﬁxed ρ, w, r(cid:48), s(cid:48), t(cid:48), d(cid:48), therefore, simulated τ∗ is identical
(cid:117)(cid:116)
to the distribution of τ in a real argument.

i=1 cρi

i )/((cid:81)(cid:96)

i=1 ewi

i=1 vρi

4.4 Security Analysis of Our OTN

k×1 Scheme

In this section, we examine the security of our OTN
k×1 scheme in Fig. 1. Since wi in
step 3 of the transfer phase is masked by ai, it does not reveal information about
M ; therefore, the receiver can only decrypt one document in each transfer phase.
In our security proof of fully simulation, we don’t consider the initialization
phase and transfer phase as separated experiments. One may add argument of
knowledge of the openings of commitment c [15] in the initialization phase in
order to exact the sender’s input M in the initialization phase. Note that it is
the receiver’s responsibility to choose correct commitment key ck to achieve the
binding property. Since, the order of G is q, the sender only needs to check
group membership of ck to guarantee that his commitments will not reveal
anything information about the messages even if the receiver is cheating. Its
formal security proof is given in App. A.

4.5 Implementation and Eﬃciency

√
In terms of communicational eﬃciency, it is clear that the proposed OTN
k×1
scheme (shown in Fig. 1) costs O(
N ) in both the initialization phase and each
transfer phase. Let k = 1, as far as we know, our proposed OTN
1 is the ﬁrst
fully simulatable OTN
N ) communication complexity. The
k×1 scheme is O(N ) in both initial-
1
computation complexity of our proposed OTN
ization phase and each transfer phase. As mentioned before, since the scheme
uses lifted ElGamal encryption, the message space should be small enough to
compute discrete logarithm, e.g., mi ∈ {0, 1}ξ, where ξ ≤ 30.

√
that achieves O(

In practical implementation, the actual complexity of our protocol is smaller.
Since the protocol only uses multi-exponentiation operations in both homomor-
phic operations and commitments. We employ Lim’s multi-exponentiation algo-
rithm to reduce the actual computation. In [25], Lim showed how to compute
a product of n exponentiations using only O( n
log n ) multiplications. We imple-
k×1 scheme on elliptic curve group over Fp. The per-
mented the proposed OTN
formance benchmark is tested with the 192-bit elliptic curve domain parameters

Initialization phase

Each transfer phase

DB size S’s r.t. (s) R’s r.t. (s) Comm.
1 × 104
0.06
2.5×105 0.29
1 × 106
0.59
2.5×107 2.92
1 × 108
5.83

(byte)
4065
20165
40290
201290
402540

0.045
0.565
1.975
43.555
171.24

S’s r.t. (s) R’s r.t. (s) Comm.

0.98
4.9
9.7
48.61
96.94

1.16
7.24
17.68
223.25
786.77

(byte)
44320
220320
440320
2200320
4400320

Table2. Performance Benchmark. (r.t. stands for running time. Messages are chosen
from {0, 1}10, and the network delay is not considered.)

recommended by NIST p192, where p = 2192 − 264 − 1, which gives about 96-
bit security level. In order to save communication bandwidth, we also used the
standard point compression technique: a point on E(Fp) is represented by its x
coordinate together with the least signiﬁcant bit of its y coordinate. The code
is implemented in C++, using Multi-precision Integer and Rational Arithmetic
C/C++ Library (MIRACL) crypto SDK. All the tests are performed on a linux
desktop with an Intel Core i5-2400 CPU running at 3.10 GHz. Table 2 depicts
the sender’s and receiver’s running time (in seconds) as well as the communica-
tion complexity (in bytes) in both initialization phase and each transfer phase.
We can see our scheme is very eﬃcient even with relatively large database size.

5 Conclusions

√
In this paper, we proposed an eﬃcient OTN
k×1 scheme in the plain model. It
achieves fully simulatable security with O(
N ) communication in both the ini-
tialization phase and each transfer phase. Ideally, the scheme is dedicated to
1-out-of-N oblivious transfer, whereas it also achieves better (amortized) com-
munication, comparing with existing schemes when k = O(N 1/2), which covers
majority OT usage cases. We also implemented and highly optimized the pro-
posed scheme, and its perform benchmark shows very impressive results. When k
is very large, say O(N ), we recommend the user to adopt ORAM based two-party
computation schemes, e.g. [11], so the cost of each transfer is minimum after the
setup phase. We would like to further reduce the communication complexity of
fully simulatable OTN

1 in our future research.

Acknowledgements. The second author was supported by Estonian Research
Council, the Tiger University Program of the Estonian Information Technology
Foundation, and European Union through the European Regional Development
Fund. The last author was supported in part by US National Science Foundation
under grants CNS-1262277 and CNS-1116939.

References

1. Multi-query Computationally-Private Information Retrieval with Constant Com-

munication Rate. In: PKC (2010)

2. Bayer, S., Groth, J.: Eﬃcient Zero-knowledge Argument for Correctness of a Shuf-

ﬂe. In: EUROCRYPT (2012)

3. Bellare, M., Goldreich, O.: On Deﬁning Proofs of Knowledge. In: CRYPTO (1993)
4. Ben-Sasson, E., Goldreich, O., Harsha, P., Sudan, M., Vadhan, S.P.: Short PCPs

Veriﬁable in Polylogarithmic Time. In: CCC (2005)

5. Camenisch, J., Neven, G., Shelat, A.: Simulatable Adaptive Oblivious Transfer. In:

EUROCRYPT (2007)

6. Canetti, R., Fischlin, M.: Universally Composable Commitments. In: CRYPTO

(2001)

7. Chaum, D.: Zero-Knowledge Undeniable Signatures (extended abstract). In: EU-

ROCRYPT (1990)

8. Damg˚ard, I., Fujisaki, E.: A Statistically Hiding Integer Commitment Scheme

Based on Groups with Hidden Order. In: ASIACRYPT (2002)

9. Damg˚ard, I., Goldreich, O., Okamoto, T., Wigderson, A.: Honest Veriﬁer vs Dis-

honest Veriﬁer in Public Cain Zero-Knowledge Proofs. In: CRYPTO (1995)

10. Gentry, C., Ramzan, Z.: Single-Database Private Information Retrieval with Con-

stant Communication Rate. In: ICALP (2005)

11. Gordon, S.D., Katz, J., Kolesnikov, V., Krell, F., Malkin, T., Raykova, M., Vahlis,
Y.: Secure Two-party Computation in Sublinear (amortized) Time. In: CCS (2012)
12. Green, M., Hohenberger, S.: Blind Identity-Based Encryption and Simulatable

Oblivious Transfer. In: ASIACRYPT (2007)

13. Green, M., Hohenberger, S.: Universally Composable Adaptive Oblivious Transfer.

In: ASIACRYPT (2008)

14. Green, M., Hohenberger, S.: Practical Adaptive Oblivious Transfer from Simple

Assumptions. In: TCC (2011)

15. Groth, J.: Linear Algebra with Sub-linear Zero-Knowledge Arguments.

In:

CRYPTO (2009)

16. Groth, J.: A Veriﬁable Secret Shuﬄe of Homomorphic Encryptions. Journal of

Cryptology 23, 546–579 (2010)

17. Groth, J.: Short Pairing-Based Non-interactive Zero-Knowledge Arguments. In:

ASIACRYPT (2010)

18. Ishai, Y., Paskin, A.: Evaluating Branching Programs on Encrypted Data. In: TCC

(2007)

19. Jarecki, S., Liu, X.: Eﬃcient Oblivious Pseudorandom Function with Applications

to Adaptive OT and Secure Computation of Set Intersection. In: TCC (2009)

20. Kurosawa, K., Nojima, R.: Simple Adaptive Oblivious Transfer without Random

Oracle. In: ASIACRYPT (2009)

21. Kurosawa, K., Nojima, R., Phong, L.T.: Eﬃciency-improved fully simulatable

adaptive OT under the DDH assumption. In: SCN (2010)

22. Kurosawa, K., Nojima, R., Phong, L.T.: Generic Fully Simulatable Adaptive Obliv-

ious Transfer. In: ACNS (2011)

23. Kushilevitz, E., Ostrovsky, R.: Replication is NOT Needed: Single Database,

Computationally-Private Information Retrieval. In: FOCS (1997)

24. Laur, S., Lipmaa, H.: On the Feasibility of Consistent Computations. In: PKC

(2010)

25. Lim, C.H.: Eﬃcient Multi-exponentiation

and Application

Veriﬁcation
http://dasan.sejong.ac.kr/ chlim/pub/multiexp.ps

Signatures

Digital

of

(2000),

online

Tech.

to Batch
Report:

26. Lipmaa, H.: An Oblivious Transfer Protocol with Log-Squared Communication.

In: ISC (2005)

27. Lipmaa, H.: First CPIR Protocol with Data-Dependent Computation. In: ICISC

(2009)

28. Lipmaa, H.: Progression-Free Sets and Sublinear Pairing-Based Non-Interactive

Zero-Knowledge Arguments. In: TCC (2012)

29. Liskova, L., Stanek, M.: Eﬃcient Simultaneous Contract Signing. In: SEC (2004)
30. Naor, M., Pinkas, B.: Oblivious Transfer with Adaptive Queries. In: CRYPTO

(1999)

31. Naor, M., Pinkas, B.: Computationally Secure Oblivious Transfer. Journal of Cryp-

tology 18, 1–35 (2005), http://dx.doi.org/10.1007/s00145-004-0102-6

32. Pedersen, T.: Non-Interactive and Information-Theoretic Secure Veriﬁable Secret

Sharing. In: CRYPTO (1991)

33. Rial, A., Kohlweiss, M., Preneel, B.: Universally Composable Adaptive Priced

Oblivious Transfer. In: Pairing (2009)

34. Yao, A.: Protocols for Secure Computations (Extended Abstract). In: FOCS (1982)
35. Zhang, B.: Simulatable Adaptive Oblivious Transfer with Statistical Receiver’s

Privacy. In: ProvSec (2011)

A Security proof of our OTN

k×1 scheme

k×1 scheme (as shown in Fig. 1) is secure against

Theorem 4. The proposed OTN
the sender corruption under the DDH assumption.
Proof. We show that for every real-world cheating p.p.t. sender ˆS there exists
an ideal-world cheating p.p.t. sender ˆS(cid:48) such that for every distinguisher D:
c≈ IdealˆS(cid:48),R(cid:48)(N, k, m1, . . . , mN ,I)

RealˆS,R(N, k, m1, . . . , mN ,I)

Considering a sequence of games G0, . . . , G4, where Game G0 = RealˆS,R and
Game G4 = IdealˆS(cid:48),R(cid:48). We deﬁne

(cid:12)(cid:12)(cid:12)Pr[D(X) = 1 : X $← IdealˆS(cid:48),R(cid:48)] − Pr[D(X) = 1 : X $← RealˆS,R]

Adv[D] =

(cid:12)(cid:12)(cid:12)

.

Game G0: The real-world experiment RealˆS,R. By deﬁnition, Pr[D(X) = 1 :
X $← G0] = P r[D(X) = 1 : X $← RealˆS,R].
Game G1: Game G1 is the same as Game G0 except the following. In the ﬁrst
transfer phase, the receiver uses the witness-extended emulator of the masked
multi-exponentiation batch AoK to extract M∗, r∗ that is committed in c. If
extraction fails, then the protocol aborts. The failure probability is negligible.
Furthermore, if the server can open the commitments to a diﬀerent set M(cid:48), r(cid:48)
from what is extracted, then we have broken the blinding property of generalized
Pedersen Commitment; namely, the discrete logarithm assumption does not hold,
neither does the DDH assumption. Assume the DDH problem is hard over G,
we have Pr[D(X) = 1 : X $← G1] ≈ Pr[D(X) = 1 : X $← G0].

Game G2: Game G2 is the same as Game G1 except the following. In the ini-
tialization phase, the receiver randomly picks pk such that he does not know
the discrete logarithm of pk. In the (cid:96)-th transfer phase, the receiver skips all the
according M∗ that is extracted in Game
decryption steps, and returns m∗
G1. Since all the zero-knowledge arguments and proofs are sound, we have
Pr[D(X) = 1 : X $← G2] ≈ Pr[D(X) = 1 : X $← G1].

i(cid:96)

Game G3: Game G3 is the same as Game G2 except the following. In the (cid:96)-th
transfer phase, the receiver picks two random unit vectors u, v, regardless i(cid:96).
Since ElGamal encryption is IND-CPA secure under the DDH assumption, we
have Pr[D(X) = 1 : X $← G3] ≈ Pr[D(X) = 1 : X $← G2].

Game G4: The ideal-world experiment IdealˆS(cid:48),R(cid:48) in which an ideal-world sender
ˆS(cid:48) uses the real-world sender ˆS as a black-box as follows.
1. After receiving (m1, . . . , mN ), ˆS(cid:48) forwards them to ˆS.
2. ˆS(cid:48) acts as the receiver and plays Game G3 with ˆS.
3. In the ﬁrst transfer phase, ˆS(cid:48) sends (m∗

N ) that is extracted in Game
4. In the (cid:96)-th transfer phase, if ˆS behaved in an acceptable way, then ˆS(cid:48) sends

OT (for the initialization phase). 2

1, . . . , m∗

OT . Otherwise, ˆS(cid:48) sends b(cid:96) = 0 to F n×1
OT .

G1 to F n×1
b(cid:96) = 1 to F n×1

To sum up, it is easy to see that

(cid:12)(cid:12)(cid:12)Pr[D(X) = 1 : X $← G4] − Pr[D(X) = 1 : X $← G0]

(cid:12)(cid:12)(cid:12) ≤ (λ) ,

Adv(D) =

where (·) is a negligible function.

(cid:117)(cid:116)

Theorem 5. The proposed OTN
secure against the receiver corruption.

k×1 scheme (as shown in Fig. 1) is statistically

Proof. We show that for every real-world cheating p.p.t. receiver ˆR there exists
an ideal-world cheating p.p.t. receiver ˆR(cid:48) such that for every distinguisher D:

RealS, ˆR(N, k, m1, . . . , mN ,I)

c≈ IdealS(cid:48), ˆR(cid:48)(N, k, m1, . . . , mN ,I)

Again, we consider a series of hybrid games G0, . . . , G4, where Game G0 =
RealS, ˆR and Game G4 = IdealS(cid:48), ˆR(cid:48). We deﬁne

(cid:12)(cid:12)(cid:12)Pr[D(X) = 1 : X $← IdealS(cid:48), ˆR(cid:48)] − Pr[D(X) = 1 : X $← RealS, ˆR]

Adv[D] =

(cid:12)(cid:12)(cid:12)

.

Game G0: The real-world experiment RealS, ˆR. By deﬁnition, Pr[D(X) = 1 :
X $← G0] = Pr[D(X) = 1 : X $← RealS, ˆR].
2 Remark: the experiments do not separate initialization phase and transfer phase.

Game G1: Game G1 is the same as Game G0 except the following. In the (cid:96)-th
transfer phase, the sender uses the knowledge extractor of unit vector PoK to
extract the plaintext and randomizers of each ciphertext, i.e., those two unit
vectors u∗, v∗. Subsequently, we know the index i∗
(cid:96) . If extraction fails, then the
protocol aborts. Since the failure probability is negligible, Pr[D(X) = 1 : X $←
G1] ≈ Pr[D(X) = 1 : X $← G0].

Game G2: Game G2 is the same as Game G1 except the following. In each
transfer phase, the sender uses the simulator of the masked multi-exponentiation
batch AoK to prove that w is computed correctly without using M . If simulation
fails, then the protocol aborts. Since the failure probability is negligible, we have
Pr[D(X) = 1 : X $← G2] ≈ Pr[D(X) = 1 : X $← G1].

Game G3: Game G3 is the same as Game G2 except the following. In the
initialization phase, the sender randomly picks α ←$ Zn
q and sets ci = gαi as
fail commitments. Since the distribution of c is unchanged, Pr[D(X) = 1 : X $←
G3] = Pr[D(X) = 1 : X $← G2].

Game G4: The ideal-world experiment IdealS(cid:48), ˆR(cid:48)in which an ideal-world re-
ceiver ˆR(cid:48) uses the real-world receiver ˆR as a black-box as follows.
1. ˆR(cid:48) acts as the sender and plays Game G3 with ˆR.
2. In the (cid:96)-th transfer phase, ˆR(cid:48) sends i∗

from F n×1

OT . ˆR(cid:48) prepares M(cid:48) such that m(cid:48)
i∗

(cid:96) that is extracted in Game G1 to
and

= mi∗

(cid:96)

(cid:96)

3. Compute w according to M(cid:48) and complete the rest of the protocol as de-

F n×1
OT and fetches mi∗
∀j (cid:54)= i∗

(cid:96) : m(cid:48)

j = 0.

(cid:96)

scribed in Game G3.

To sum up, it is easy to see that

(cid:12)(cid:12)(cid:12)Pr[D(X) = 1 : X $← G4] − Pr[D(X) = 1 : X $← G0]

(cid:12)(cid:12)(cid:12) ≤ (λ) ,

Adv(D) =

where (·) is a negligible function.

(cid:117)(cid:116)

Theorem 6. The proposed OTN
latable secure under the DDH assumption.

k×1 scheme (as shown in Fig. 1) is fully simu-

Proof. By Deﬁnition 1, the proposed OTN
cure due to both Theorem. 4 and Theorem. 5.

k×1 framework is fully simulatable se-

