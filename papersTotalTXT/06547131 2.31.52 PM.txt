2013 IEEE Symposium on Security and Privacy

Lucky Thirteen: Breaking the TLS and DTLS Record Protocols

Nadhem J. AlFardan and Kenneth G. Paterson

Information Security Group,

Royal Holloway, University of London

Email: {nadhem.alfardan.2009, kenny.paterson}@rhul.ac.uk

Egham, Surrey TW20 0EX, UK

Abstract—The Transport Layer Security (TLS) protocol
aims to provide conﬁdentiality and integrity of data in transit
across untrusted networks. TLS has become the de facto secure
protocol of choice for Internet and mobile applications. DTLS
is a variant of TLS that is growing in importance. In this
paper, we present distinguishing and plaintext recovery attacks
against TLS and DTLS. The attacks are based on a delicate
timing analysis of decryption processing in the two protocols.
We include experimental results demonstrating the feasibility of
the attacks in realistic network environments for several differ-
ent implementations of TLS and DTLS, including the leading
OpenSSL implementations. We provide countermeasures for
the attacks. Finally, we discuss the wider implications of our
attacks for the cryptographic design used by TLS and DTLS.
Keywords-TLS, DTLS, CBC-mode encryption, timing attack,

plaintext recovery

I. INTRODUCTION

TLS is arguably the most widely-used secure communica-
tions protocol on the Internet today. Starting life as SSL, the
protocol was adopted by the IETF and speciﬁed as TLS 1.0
[7]. It has since evolved through TLS 1.1 [8] to the current
version TLS 1.2 [9]. Various other RFCs deﬁne additional
TLS cryptographic algorithms and extensions. TLS is now
used for securing a wide variety of application-level trafﬁc
and has become a serious rival to IPsec for general VPN
usage. It is widely supported in client and server software
and in cryptographic libraries for embedded systems, mobile
devices, and web application frameworks.

The DTLS protocol is a close relative of TLS, developed
from TLS by making minimal changes so as to allow it
to operate over UDP instead of TCP [16]. This makes
DTLS suitable for use where the costs of TCP connection
establishment and TCP retransmissions are not warranted,
for example, in voice and gaming applications. DTLS exists
in two versions, DTLS 1.0 [20], which roughly matches TLS
1.1 and DTLS 1.2 [21], which aligns with TLS 1.2.

Both TLS and DTLS are actually protocol suites, rather
than single protocols. The main component of (D)TLS that
concerns us here is the Record Protocol, which uses sym-
metric key cryptography (block ciphers, stream ciphers and
MAC algorithms) in combination with sequence numbers

The second author’s research was supported by an EPSRC Leadership

Fellowship, EP/H005455/1.

1081-6011/13 $26.00 © 2013 IEEE
DOI 10.1109/SP.2013.42

526

to build a secure channel for transporting application-layer
data. Other major components are the (D)TLS Handshake
Protocol, which is responsible for authentication, session
key establishment and ciphersuite negotiation, and the TLS
Alert Protocol, which carries error messages and manage-
ment trafﬁc. Setting aside dedicated authenticated encryption
algorithms (which are yet to see widespread support in TLS
or DTLS implementations), the (D)TLS Record Protocol
uses a MAC-Encode-Encrypt (MEE) construction. Here, the
plaintext data to be transported is ﬁrst passed through a
MAC algorithm (along with certain header bytes) to create
a MAC tag. The supported MAC algorithms are all HMAC-
based, with MD5, SHA-1 and SHA-256 being the allowed
hash algorithms in TLS 1.2 [9]. Then an encoding step
takes place. For the RC4 stream cipher, this just involves
concatenation of the plaintext and the MAC tag, while
for CBC-mode encryption (the other possible option), the
plaintext, MAC tag, and some encryption padding of a
speciﬁed format are concatenated. In the encryption step,
the encoded plaintext is encrypted with the selected cipher.
In the case where CBC-mode is selected, the block cipher
is DES, 3DES or AES (with DES being deprecated in TLS
1.2). Following [18], we refer to this MEE construction as
MEE-TLS-CBC. We provide greater detail on its operation
in the (D)TLS Record Protocol in Section II.

The widespread use of TLS (and the increasing use
of DTLS) makes the continued study of the security of
these protocols of great importance. Indeed, the evolution
of the TLS Record Protocol has largely been driven by
cryptographic attacks that have been discovered against it,
including those in [25], [5], [17], [3], [4], [10], [18], [1].

Of particular interest lately have been attacks based on the
use of chained initialisation vectors (IVs) for CBC-mode
in SSL and TLS 1.0, in particular, the so-called BEAST
attack [10] which has its roots in [23], [17], [3], [4]. This
attack achieved full plaintext recovery against TLS, but
only in scenarios where an attacker can gain access to a
chosen plaintext capability, perhaps by inducing the user to
ﬁrst download malicious javascript code into his browser.
Despite this strong requirement, the BEAST attack attracted
signiﬁcant industry and media attention in 2011. Amongst
the possible countermeasures are upgrading to TLS 1.1 or
1.2, the inclusion of a dummy zero-length message prior to

each real TLS message, or the abandonment of CBC-mode
encryption in favour of RC4 or an authenticated encryption
algorithm.

The other major line of attacks against the TLS Record
Protocol comprises [25], [5], [17], [18], [1] and relates
to how the padding that is required in MEE-TLS-CBC is
handled during decryption. The problems here all stem from
the fact that the padding is added after the MAC has been
computed and so forms unauthenticated data in the encoded
plaintext. Taken altogether, the attacks in [25], [5], [17], [18],
[1] show that handling padding arising during decryption
processing is a delicate and complex issue for MEE-TLS-
CBC.

It is the case that all these attacks on CBC-mode in
TLS could be avoided by adopting RC4 or a dedicated
authenticated encryption mode, or perhaps by redesigning
(D)TLS to use only an Encrypt-then-MAC construction.
However, RC4 is not an option for DTLS, and not NIST-
recommended for TLS [6]; meanwhile authenticated encryp-
tion modes are only available in TLS 1.2, which is not
yet widely supported.1 Redesigning (D)TLS would require
even more radical changes than adopting TLS 1.2. So it
would be fanciful to “wish away” MEE-TLS-CBC, and all
the complexity that this entails: this is an option that is
ﬁrmly embedded in the TLS and DTLS RFCs, in widespread
use, and will remain so for the foreseeable future. On the
other hand, we might hope that after more than a decade of
intensive study, we would have arrived at a point where we
understand how to implement MEE-TLS-CBC securely. In
this paper, we show that this is not the case.

A. Our Results

We present a family of attacks that apply to CBC-mode
in all TLS and DTLS implementations that are compliant
with TLS 1.1 or 1.2, or with DTLS 1.0 or 1.2. They also
apply to implementations of SSL 3.0 and TLS 1.0 that
incorporate padding oracle attack countermeasures (imple-
mentations that do not are of course already vulnerable to
known attacks).

The attacks come in various distinguishing, partial plain-
text recovery, and full plaintext recovery ﬂavours. For the
plaintext recovery attacks, no chosen-plaintext capability is
needed, in contrast to the BEAST attacks: the attacks can be
mounted by a standard man-in-the-middle (MITM) attacker
who sees only ciphertext and can inject ciphertexts of his
own composition into the network. The details of which
speciﬁc attacks are possible depends on the exact size of
MAC tags output by the MAC algorithm negotiated by the
Handshake Protocol, and also on the fact that the exactly 13
bytes of header data are incorporated in the MAC calculation
(hence our title).

1SSL Pulse (https://www.trustworthyinternet.org/ssl-pulse/) reported that
only 11.4% of 200,000 websites surveyed support TLS 1.2 in January 2013;
most major browsers currently do not support TLS 1.2.

527

The applicability of the attacks is also implementation-
dependent, because of the manner in which different imple-
mentations interpret the RFCs. We have investigated several
different open-source implementations of TLS and DTLS,
and found all of them to be vulnerable to our new attacks
or variants of them (or even old attacks in one case).

We have implemented a selection of the attacks in an
experimental setting. As with earlier attacks, completely
breaking TLS is challenging because the attacks create
“broken” TLS records and so consume many TLS sessions.
Nevertheless, our basic attack can extract full plaintext
for the current OpenSSL implementation of TLS assuming
the attacker is located, say, in the same LAN segment as
the targeted TLS client or server, using roughly 223 TLS
sessions to reliably recover a block of plaintext in a multi-
session attack scenario like that considered in [5]. Such a
scenario is applicable when, for example, an application pro-
tocol performs automatic TLS reconnection and password
retransmission. Given its complexity, this basic attack would
seem to present only a theoretical threat. However, variants
of it are much more effective:

• The distinguishing attacks against TLS are quite prac-
tical for OpenSSL, requiring just a handful of sessions
in order to reliably tell apart the encryptions of chosen
messages.

• Breaking DTLS implementations is fully practical even
for a remote attacker, since we can exploit the fact that
DTLS errors are non-fatal to mount the attacks in a
single session, and reuse the ampliﬁcation techniques
from [1] to boost the delicate timing signals on which
our attacks depend.

• We also have more efﬁcient partial plaintext recov-
ery attacks on TLS and DTLS. For example, against
OpenSSL TLS, an attacker who knows one byte of a
block in either of the last two byte positions can reliably
recover each of the remaining bytes in that block using
216 sessions.

• The complexity of all our attacks can be reduced using
language models and sequential statistical techniques
as in [5], [10]. As a simple example, if the plaintext
is base64 encoded, as is the case for HTTP basic
access authentication and cookies, then the number of
TLS sessions needed to recover a block reduces from
roughly 223 to 219.

• In the web setting, our techniques can be combined
with those used in the BEAST attack [10]: client-
side malware running in the browser can be used to
initiate all the needed TLS sessions, with an HTTP
cookie being automatically injected by the browser in
a predictable location in the plaintext stream in each
session. The malware can also control the location of
the cookie such that there is only one unknown byte in
the target block at each stage of the attack. The attacker

then combines the “one known byte” variant of our
attack and the base64 optimisation above (assuming the
sensitive part of the cookie is base64 encoded). Putting
all of these improvements together, we estimate that
HTTP cookies can be recovered using 213 sessions per
byte of cookie (with all the sessions being automatically
generated). Note that the malware does not need the
ability to inject chosen plaintext into an existing TLS
session for this attack.

B. How the Attacks Work

Our new attacks exploit the fact that, when badly for-
matted padding is encountered during decryption, a MAC
check must still be performed on some data to prevent the
known timing attacks. But what data should be used for
that calculation? The TLS 1.1 and 1.2 RFCs recommend
checking the MAC as if there was a zero-length pad. As
noted in those RFCs:

This leaves a small timing channel, since MAC
performance depends to some extent on the size
of the data fragment, but it is not believed to be
large enough to be exploitable, due to the large
block size of existing MACs and the small size of
the timing signal.

We conﬁrm that there are indeed small timing differences,
but, contrary to what is written in the RFCs, they can be
exploited. In short, provided there is a fortuitous alignment
of various factors such as the size of MAC tags, the block
cipher’s block size, and the number of header bytes, then
there will be a time difference in the time that it takes to
process TLS records having good and bad padding, and this
difference will show up in the time at which error messages
appear on the network. This timing side-channel can then be
“wrangled” into revealing plaintext data via careful statistical
analysis of multiple timing samples.

C. Disclosure

Given the large number of affected implementations, we
ﬁrst notiﬁed the IETF TLS Working Group chairs,
the
IETF Security Area directors and the IRTF Crypto Forum
Research Group (CFRG) chairs of our attacks in November
2012. We then began the process of contacting individual
vendors. Patches to address our attacks have been issued by
OpenSSL, NSS, GnuTLS, PolarSSL, CyaSSL, MatrixSSL,
Opera, F5, BouncyCastle and Oracle. For further details, see
the full version [2].

D. Further Details on Related Work

Padding oracle attacks began with Vaudenay [25], who
showed that the presence of a padding oracle, that is, an
oracle telling an attacker whether the padding was correctly
formatted or not, could be leveraged to build a decryption
capability. Canvel et al. [5] showed that such an oracle could
be obtained for the then-current version of OpenSSL by

exploiting a timing difference in TLS decryption processing.
In essence, in OpenSSL, if the padding was incorrectly
formatted, then no MAC check was performed, while if
the padding was correct, then the MAC check was done.
In turn, this meant faster production of an error message in
the “invalid padding” case than in the “valid padding” case.
Thus the padding oracle was revealed through a timing side-
channel. A complication for full plaintext recovery is that
in TLS, the corresponding error messages are fatal, leading
to the termination of the TLS session. To overcome this,
Canvel et al. considered the multi-session setting, wherein
it is assumed that the same plaintext is transmitted in the
same position in the ciphertext in many sessions. Moeller
[17] subsequently pointed out that not doing padding format
checks is not an option, since this enables even simpler
attacks. The correct solution, as advocated in TLS 1.1 and
TLS 1.2, is to check the padding format carefully, report a
single error message for padding and MAC failures, and
to make the record processing time essentially the same
whether or not the padding is correct. Most recently, in
[1], we showed that the OpenSSL implementation of DTLS
did not adopt the known attack countermeasures. We also
introduced novel timing ampliﬁcation techniques to build
full plaintext recovery attacks against this implementation
of DTLS, even though DTLS has no explicit error messages
to time.

Theoretical support for the MEE construction used in
(D)TLS can be found in [12], [14], [18]. In particular,
Paterson et al. [18] gave the ﬁrst positive security results
for a fully accurate model MEE-TLS-CBC that includes
all the details of the CBC-mode encoding step (which in-
corporates padding), proving that MEE-TLS-CBC provides
Length Hiding Authenticated-Encryption security, provided
that
its MAC and CBC-mode block cipher components
satisfy natural security properties, that the MAC tags are
long enough, and that it is implemented so that decryption
does not reveal the cause of any failures. Our attacks exploit
the fact that current implementations of (D)TLS fail to meet
this last assumption. So our attacks do not contradict the
results of [18], but instead relativize their applicability to
practice.

In independent work, Pironti et al. [19] identify effectively
the same timing channel in TLS that we exploit. However
they dismiss it as being “too small to be measured over
the network” and instead focus on using it
to recover
information about message lengths. The recent CRIME
attack exploits the optional use of compression in TLS in
combination with a chosen plaintext capability to mount a
plaintext recovery attack.

II. THE (D)TLS RECORD PROTOCOL

We focus on the cryptographic operation of the TLS
and DTLS Record Protocols in the case of CBC-mode

528

SQN 

HDR 

Payload 

MAC 

transmitted over the wire then has the form:

HDR||C

Payload 

MAC tag 

Padding 

Encrypt 

Ciphertext 

Figure 1. D(TLS) encryption process

encryption. The core encryption process is illustrated in
Figure 1 and explained in more detail below.

Data to be protected by TLS or DTLS is received from the
application and may be fragmented and compressed before
further processing. An individual record R (viewed as a byte
sequence of length at least zero) is then processed as follows.
The sender maintains an 8-byte sequence number SQN which
is incremented for each record sent2, and forms a 5-byte ﬁeld
HDR consisting of a 2-byte version ﬁeld, a 1-byte type ﬁeld,
and a 2-byte length ﬁeld. It then calculates a MAC over
the bytes SQN||HDR||R; let T denote the resulting MAC
tag. Note that exactly 13 bytes of data are prepended to the
record R here before the MAC is computed. The size of
the MAC tag is 16 bytes (HMAC-MD5), 20 bytes (HMAC-
SHA-1), or 32 bytes (HMAC-SHA-256). We let t denote
this size in bytes.
The record is then encoded to create the plaintext P
by setting P = R||T||pad. Here pad is a sequence of
padding bytes chosen such that the length of P in bytes
is a multiple of b, where b is the block-size of the selected
block cipher (so b = 8 for 3DES and b = 16 for AES). In
all versions of TLS and DTLS, the padding must consist of
p + 1 copies of some byte value p, where 0 ≤ p ≤ 255.
In particular, at least one byte of padding must always be
added. So examples of valid byte sequences for pad are:
“0x00”, “0x01||0x01” and “0x02||0x02||0x02”. The padding
may extend over multiple blocks, and receivers must support
the removal of such extended padding.

In the encryption step, the encoded record P is encrypted
using CBC-mode of the selected block cipher. TLS 1.1 and
1.2 and both versions of DTLS mandate an explicit IV,
which should be randomly generated. TLS 1.0 and SSL use
a chained IV; our attacks work for either option. Thus, the
ciphertext blocks are computed as:

Cj = EKe

(Pj ⊕ Cj−1)

where Pi are the blocks of P , C0 is the IV, and Ke is the
key for the block cipher E. For TLS (and SSL), the data

2In fact, in DTLS, this 8-byte ﬁeld is composed from a 16-bit epoch
number and a 48-bit sequence number. We will abuse terminology and
refer throughout to the 8-byte ﬁeld as being the sequence number for both
TLS and DTLS.

529

where C is the concatenation of the ciphertext blocks Ci
(including or excluding the IV depending on the particular
SSL or TLS version). Note that the sequence number is
not transmitted as part of the message. In DTLS, the data
transmitted over the wire is the same as in TLS, except that
SQN is included as part of the record header and the CBC-
mode IV is always explicit.

Simplistically, the decryption process reverses this se-
quence of steps: ﬁrst the ciphertext is decrypted block by
block to recover the plaintext blocks:

Pj = DKe

(Cj) ⊕ Cj−1,

where D denotes the decryption algorithm of the block
cipher. Then the padding is removed, and ﬁnally, the MAC
is checked, using the header information (and,
in TLS,
a version of the sequence number that is maintained at
the receiver). Finally, in DTLS, the sequence number is
optionally checked for replays.

In reality, much more sophisticated processing than this is
needed. The receiver should check that the ciphertext size is
a multiple of the block size and is large enough to contain
at least a zero-length record, a MAC tag of the required
size, and at least one byte of padding. After decryption, the
receiver should check that the format of the padding is one
of the possible patterns when removing it, otherwise attacks
are possible [17] (SSL allows a loose padding format, while
no speciﬁc padding checks are enforced during decryption in
TLS 1.0, so both are potentially vulnerable to the attacks in
[17]). Typically this is done by examining the last byte of the
plaintext, treating it as a padding length byte padlen, and
using this to dictate how many additional bytes of padding
should be removed. But care is needed here, since blindly
removing bytes could result in an underﬂow condition: there
needs to be sufﬁcient bytes in the plaintext to remove a total
of padlen+1 bytes and leave enough bytes for at least
zero-length record and a MAC tag.

If all this succeeds, then the MAC can be recomputed
and compared to the MAC tag in the plaintext. If the
padding fails to be correctly formatted, then implementations
should continue to perform a MAC check anyway, to avoid
providing a timing side-channel of the type exploited in [5].
But since the padding format is incorrect in this case, it’s
not immediately clear where the padding ends and the MAC
tag is located: in effect, the plaintext is now unparseable.
The solution recommended in TLS 1.1 and 1.2 (and by
extension, also in DTLS 1.0 and 1.2) is to assume zero-
length padding, interpret the last t bytes of the plaintext as
a MAC tag, interpret the remainder as the record R and run
MAC veriﬁcation on SQN||HDR||R. This has been adopted
in OpenSSL and elsewhere; GnuTLS on the other hand
removes padlen + 1 bytes from the end of the plaintext,

takes the next t bytes as the MAC, interprets what is left as
R and then runs MAC veriﬁcation on SQN||HDR||R.

For TLS, any error arising during decryption should be
treated as fatal, meaning an encrypted error message is sent
to the sender and the session terminated with all keys and
other cryptographic material being disposed of. For DTLS,
such errors may be rated non-fatal and the session would
proceed to process the next ciphertext.

It should now be apparent that implementing the basic
decryption processing of TLS and DTLS requires some
care in implementation, with there being signiﬁcant room
for coding errors and inadequate parsing. Moreover, this
should all be implemented in such a way that the processing
time does not leak anything about the plaintext (including
the padding bytes). As we shall see, this has proved to
be a challenge for implementers: no implementation we
examined gets it completely correct, and the advice from
TLS 1.1 and 1.2 that one should extract and check the
MAC tag as if the padding were of zero-length leaves an
exploitable timing side-channel.

A. Details of HMAC

As mentioned above, TLS and DTLS exclusively use the
HMAC algorithm [13], with HMAC-MD5, HMAC-SHA-
1, and HMAC-SHA-256 being supported in TLS 1.2.3 To
compute the MAC tag T for a message M with key Ka,
HMAC applies the speciﬁed hash algorithm H twice, in an
iterated fashion:

T = H((Ka ⊕ opad)||H((Ka ⊕ ipad)||M )).

Here opad and ipad are speciﬁc 64-byte values, and the
key Ka is zero-padded to bring it up to 64 bytes before the
XOR operations are performed. For all the hash functions
H used in TLS, the application of H itself uses an encoding
step called Merkle-Damg˚ard strengthening. Here, an 8-byte
length ﬁeld followed by padding of a speciﬁed byte format
are appended to the message M to be hashed. The padding
is at least 1 byte in length and aligns the data on a 64-
byte boundary. The relevant hash functions also have an
iterated structure, processing messages in chunks of 64 bytes
(512 bits) using a compression function, with the output
of each compression step being chained into the next step.
The compression function in turn involves a complex round
structure, with many basic arithmetic operations on data
being involved in each round.

In combination, these features mean that HMAC imple-
mentations for MD5, SHA-1 and SHA-256 have a distinctive
timing proﬁle. Messages M of length up to 55 bytes can
be encoded into a single 64-byte block, meaning that the
ﬁrst, inner hash operation in HMAC is done in 2 com-
pression function evaluations, with 2 more being required

3TLS ciphersuites using HMAC with SHA-384 are speciﬁed in RFC 5289
(ECC cipher suites for SHA256/SHA384) and RFC 5487 (Pre-Shared Keys
SHA384/AES) but we do not consider this algorithm further here.

530

for the outer hash operation, for a total of 4 compression
function evaluations. Messages M containing from 56 up to
64 + 55 = 119 bytes can be encoded in two 64-byte blocks,
meaning that the inner hash is done in 3 compression func-
tion evaluations, with 2 more being required for the outer
operation, for a total of 5. In general, an extra compression
function evaluation is needed for each additional 64 bytes
of message data, with the exact number needed being given
64 (cid:5) + 4, where (cid:2) is the message length
by the formula (cid:4) (cid:2)−55
in bytes. A single compression function evaluation takes
typically around 500 to 1000 hardware cycles (depending on
the hash function and details of the implementation), giving
a time in the sub-μs range for modern processors.

Recall that in TLS the MAC is computed on plaintext
after removing padding. Hence, one might expect the total
running time for decryption processing to reveal some infor-
mation about the size of the depadded plaintext, perhaps up
to a resolution of 64 bytes in view of the above discussion.
Our distinguishing attack exploits this, but we will show that
much more is possible.

III. A DISTINGUISHING ATTACK

In this section we describe a simple distinguishing attack
against the MEE-TLS-CBC construction as used in TLS.
This is a warm-up to our plaintext recovery attacks, but
we note that even a distinguishing attack against such an
important protocol would usually be regarded as a signiﬁcant
weakness.

Recall that in a distinguishing attack, the attacker gets
to choose pairs of messages (M0, M1). One of these is
encrypted, Md, say, and the resulting ciphertext is given
to the attacker. The attacker’s task is to decide the value of
the bit d. To prevent the attacker from winning trivially, we
require that M0 and M1 have the same length.

We focus on the case where b = 16, i.e. the block cipher
is AES. A variant of the attack works for b = 8. Suppose the
MAC algorithm is HMAC-H where H is either MD5, SHA-
1 or SHA-256. Let M0 consist of 32 arbitrary bytes followed
by 256 copies of 0xFF. Let M1 consist of 287 arbitrary bytes
followed by 0x00. Note that both messages have 288 bytes,
and hence ﬁt exactly into 18 plaintext blocks. Our attacker
submits the pair (M0, M1) for encryption and receives a
MEE-TLS-CBC ciphertext HDR||C. Now C consists of a
CBC-mode encryption of an encoded version of Md, where
the encoding step adds a MAC tag T and some padding
pad. Because the end of Md aligns with a block boundary,
the additional bytes T||pad are encrypted in separate blocks
from Md. The attacker now forms a new ciphertext HDR||C(cid:2)
in which C(cid:2) keeps the same 16-byte IV as C (if explicit IVs
are being used), but truncates the non-IV part of C to 288
bytes. This has the effect of removing those blocks of C
that contain T||pad.
Now the attacker submits HDR||C(cid:2) for decryption. If
the record underlying C was M0, then the plaintext P (cid:2)

corresponding to C(cid:2) appears to end with the valid 256-
byte padding pattern 0xFF . . . 0xFF. In this case, all of these
bytes are removed, and the remaining 32 bytes of plaintext
are interpreted as a short message and a MAC tag. For
example, if H is SHA-1, then we have a 12-byte message
and a 20-byte MAC tag. The MAC veriﬁcation fails (with
overwhelming probability), and an error message is returned
to the attacker. If the underlying record was M1, then P (cid:2)
appears to end with the valid 1-byte padding pattern 0x00.
In this case, a single byte is removed, and the remaining
287 bytes of plaintext are interpreted as a long message and
a MAC tag. Again, the MAC veriﬁcation fails and an error
message is returned to the attacker.

Notice that when d = 0, so C encrypts M0, a short
message consisting of 13 bytes of header plus at most 16
bytes of message (when the hash algorithm is MD5) is
passed through the MAC algorithm. To calculate the MAC
requires 4 evaluations of H’s compression function. On the
other hand, when d = 1, C encrypts M1, and a long message
consisting of 13 bytes of header plus at least 255 bytes of
message is passed through the MAC algorithm. Then to
calculate the MAC requires at least 8 evaluations of H’s
compression function, at least 4 more than for the d = 0
case. Hence, we expect the time it takes to produce the
error message on decryption failure to be somewhat larger
if d = 1 than when d = 0, on the order of a couple of μs
for a modern processor. This timing difference then allows,
in theory, a distinguishing attack on the MEE-TLS-CBC
construction used in TLS.

A. Practical Considerations

In describing the attack, we have ignored the time taken
to remove padding. This is different for the two messages
being processed, and the difference is opposite to that for
MAC checking in that padding removal for M0 takes longer
than for M1. Similarly, we have ignored any other timing
differences that might arise during other processing steps. In
practice, as we will see in Section V, these differences turn
out to be smaller than the MAC timing difference.

The attack exploits the requirement from the (D)TLS
RFCs that
implementations be able to properly decrypt
records having variable length padding, but does not require
implementations to actually send records containing such
padding. A variant attack is possible in case only minimum-
length padding is supported, but involves a smaller timing
signal.

In TLS, the error messages are sent over the network,
and so can easily be detected by the attacker. However,
these messages are subject to network jitter, and this may
be large enough to swamp the timing difference arising
from the 4 extra compression function evaluations. On the
other hand,
the timing signal may be quite large when
the cryptographic processing is performed in a constrained
environment, e.g. on an 8-bit or 16-bit processor, or even on

a smartphone. Furthermore, the jitter may be signiﬁcantly
reduced when the adversary runs as a separate process
on the machine performing TLS decryption. This may be
possible in virtualised environments, e.g. in a cloud scenario
as explored in [22]. The attack also destroys the TLS session,
since in TLS such errors are fatal. The attack can be iterated
across L sessions, with Md being encrypted in each session,
and statistical processing used to extract the timing signal.
In DTLS, there are no error messages, but the techniques
of [1] can be applied to solve this problem. There, the
authors send a packet containing a ciphertext C closely fol-
lowed by a DTLS message, with the latter always provoking
a response message. Any timing difference arising from the
decryption of C then shows up as a difference in the arrival
time of the response messages. The signal ampliﬁcation
techniques from [1] can also be used to boost the timing
difference – here, the idea is to send multiple packets all
containing C in quick succession, to create a cumulative
timing difference (since each time C is processed, it will be
processed in the same way).

In the attack as described, we have used 288 byte mes-
sages. This ensured that
there were sufﬁcient bytes left
after the removal of padding to leave room for a message
(possibly of zero length) and a MAC tag. This ensures
that C(cid:2) passes any sanity checks that might be applied
during decryption. However, these sanity checks might be
exploitable in variants of our basic attack. For example,
an implementation that ﬁnds it does not have enough bytes
left to contain a MAC after depadding may choose to skip
MAC veriﬁcation altogether, leading to an increased timing
difference.

Note that the attack would still work as described if the
truncated MACs specifed for TLS in [11] were used, since
the full HMAC-H computation is still performed but only
certain bytes of the computed tag are compared to bytes of
the plaintext.

We report on the successful implementation of this attack

in Section V.

IV. PLAINTEXT RECOVERY ATTACKS

A. General Approach

As we have seen in the previous section, the processing
time for a (D)TLS record (and therefore the appearance
time of error messages) will depend on the amount of
padding that the receiver interprets the encoded plaintext as
containing. However, by placing a target ciphertext block at
the end of the encrypted record, an attacker can arrange that
the plaintext block corresponding to this block is interpreted
as padding, and hence make the processing time depend on
plaintext bytes. But, it seems that large amounts of valid
padding are needed to create a signiﬁcant timing difference,
and this is difﬁcult to arrange in a plaintext recovery attack.
We show that
this barrier to plaintext recovery can be
overcome under certain circumstances.

531

Let C∗ be any ciphertext block whose corresponding
plaintext P ∗ the attacker wishes to recover. Let C(cid:2) denote
the ciphertext block preceding C∗. Note that C(cid:2) may be the
IV or the last block of the preceding ciphertext if C∗ is the
ﬁrst block of a ciphertext. We have:

P ∗ = DKe

(C∗) ⊕ C(cid:2).

For any block B of plaintext or ciphertext, we write
B = [B0B1 . . . Bb−1], where Bi denote the bytes of B.
In particular, we have P ∗ = [P ∗

1 . . . P ∗

0 P ∗

b−1].

As usual, we assume that the attacker is capable of eaves-
dropping on the (D)TLS-protected communications and of
injecting messages of his choice into the network. For TLS,
or DTLS with sequence number checking disabled, we do
not need the ability to prevent messages from reaching their
destination. Nor do we require a chosen-plaintext capability.
B. Full Plaintext Recovery

For simplicity of presentation, in what follows, we assume
the CBC-mode IVs are explicit (as in TLS 1.1, 1.2 and
DTLS 1.0, 1.2). We also assume that b = 16 (so our
block cipher is AES). It is easy to construct variants of
our attacks for implicit IVs and for b = 8. We begin by
considering only TLS, with details for DTLS to follow.
We also assume that the TLS implementation follows the
advice in the TLS 1.1 and 1.2 RFCs about checking the
MAC as if there was a zero-length pad when the padding is
incorrectly formatted. We will examine the security of other
implementation options in Section VI. Most importantly,
and for reasons that will become clear, we assume for the
moment that t = 20 (so that the MAC algorithm is HMAC-
SHA-1). We consider t = 16 and t = 32 (HMAC-MD5 and
HMAC-SHA-256) shortly.

Let Δ be a block of 16 bytes and consider the decryption

of a ciphertext Catt(Δ) of the form

Catt(Δ) = HDR||C0||C1||C2||C(cid:2) ⊕ Δ||C∗

in which there are 4 non-IV ciphertext blocks, the penulti-
mate block C(cid:2) ⊕ Δ is an XOR-masked version of C(cid:2) and
the last block is C∗. The corresponding 64-byte plaintext is
P = P1||P2||P3||P4 in which

P4 = DKe(C∗) ⊕ (C(cid:2) ⊕ Δ)

= P ∗ ⊕ Δ.

Notice that P4 is closely related to the unknown, target
plaintext block P ∗. We consider 3 distinct cases, which
between them cover all possibilities for what can happen
during decryption of Catt(Δ):

1) P4 ends with a 0x00 byte: in this case, a single byte of
padding is removed, the next 20 bytes are interpreted
as a MAC tag T , and the remaining 64 − 21 = 43
bytes of plaintext are taken as the record R. MAC
veriﬁcation is then performed on a 13 + 43 = 56-byte
message SQN||HDR||R.

532

2) P4 ends with a valid padding pattern of length at
least 2 bytes: in this case, at least 2 bytes of padding
are removed, and the next 20 bytes are interpreted as
a MAC tag T . This leaves a record R of length at
most 42 bytes, meaning that MAC veriﬁcation is then
performed on a message of length at most 55 bytes.
3) P4 ends with any other byte pattern: in this case, the
byte pattern does not correspond to valid padding.
Following the prescription in the TLS 1.1 and 1.2
RFCs, the plaintext is treated as if it contains no bytes
of padding, so the last 20 bytes are interpreted as a
MAC tag T , and the remaining 44 bytes of plaintext
are taken as the record R. MAC veriﬁcation is then
performed on a 57-byte message.

the MAC veriﬁcation will

In all cases, the MAC veriﬁcation will fail (with over-
whelming probability) and an error message produced. No-
tice that, in accordance with the discussion in Section II-A,
in Cases 1 and 3,
involve 5
evaluations of the compression function for SHA-1, while
Case 2 only requires 4 evaluations. Therefore, we can hope
to distinguish Case 2 from Cases 1 and 3 by timing the
appearance of the error message on the network. Here
the timing difference is that needed for a single SHA-
1 compression function evaluation (compared to 4 such
evaluations in our distinguishing attack). Notice that the
size of the header, 13 bytes, in conjunction with the MAC
tag size, 20 bytes, are critical in generating this distinctive
timing behaviour.

In Case 2, assuming that the plaintext has no special
structure, the most likely padding pattern to arise is the
one of length 2, namely 0x01||0x01, with all longer padding
patterns being roughly 256 times less likely. Thus, if the
attacker selects a mask Δ in such a way that he detects
Case 2 after submitting Catt(Δ) for decryption, then he can
infer that P4 ends with 0x01||0x01, and, using the equation
P4 = P ∗ ⊕ Δ, can now recover the last 2 bytes of P ∗.
(In fact, by repeating the attack with a mask Δ(cid:2) that is
modiﬁed from Δ in the third-to-last byte, the attacker can
easily separate the case of a length 2 padding pattern from
all longer patterns.)
The question remains: how does the attacker trigger Case
2, so that he can extract the last 2 bytes of P ∗? Recall that
the attacker has the freedom to select Δ. By injecting a
sequence of ciphertexts Catt(Δ) with values of Δ that vary
over all possible values in the last 2 bytes Δ14, Δ15, then
(in the worst case) after 216 trials, the attacker will surely
select a value for Δ such that Catt(Δ) triggers Case 2.
Once the last 2 bytes of P ∗ have been extracted, the
attacker can more efﬁciently recover the remaining bytes
of P ∗, working from right to left. This phase is essentially
identical to Vaudenay’s original padding oracle attack [25].
For example, to extract the third-to-last byte, the attacker
can use his new knowledge of the last two bytes of P ∗ to
now set Δ14, Δ15 so that P4 ends with 0x02||0x02. Then he

generates candidates Catt(Δ) as before, but modifying Δ13
only. After at most 28 trials, he will produce a ciphertext
which falls into case 2 again, which reveals he has managed
to set a value 0x02 in the third-to-last byte of P4 = P ∗⊕ Δ.
From this, he can recover P ∗
13. Recovery of each subsequent
byte in P ∗ requires at most 28 trials, giving a total of 14· 28
trials to complete the extraction of P ∗.

1) Practical considerations: In practice, for TLS, there
are two severe complications. Firstly, the TLS session is
destroyed as soon as the attacker submits his very ﬁrst attack
ciphertext. Secondly, the timing difference between the cases
is very small, and so likely to be hidden by network jitter
and other sources of timing difference.

The ﬁrst problem can be overcome for TLS by mounting
a multi-session attack, wherein we suppose that the same
plaintext is repeated in the same position over many sessions
(as in [5], for example). We have used masks Δ in such a
way that no further modiﬁcation to the attack is needed to
cater for this setting – of course blocks C(cid:2) and C∗ change
for each session.

The second problem can be overcome in the same multi-
session setting by iterating the attack many times for each
Δ value and then performing statistical processing of the
recorded times to estimate which value of Δ is most likely
to correspond to Case 2. In practice, we have found that a
basic percentile test (and even averaging) works well – see
Section V for further details. Assuming that L trials are used
for each Δ value, the attack as described consumes roughly
L · 216 sessions, with one ciphertext Catt(Δ) being tried in
each session.

2) More efﬁcient variants: The attack complexity can be
signiﬁcantly reduced by assuming that the language from
which plaintexts are drawn can be modelled using a ﬁnite-
length Markov chain. This is a fair assumption for natural
languages, as well as application-layer protocol messages
such as HTML, XML etc. This model can be used to
drive the selection of candidate plaintext bytes in order of
decreasing likelihood, and from this, determine the bytes of
Δ needed to test whether a guess for the plaintext bytes leads
to valid padding or not. Similar techniques were used in [5],
[10] in combination with sequential statistical techniques to
reduce the complexity of recovering low-entropy plaintexts.
Note that this approach does not work well if TLS’s optional
compression is used. Another possibility is that the plaintext
bytes are drawn from a reduced space of possibilities. For
example, in HTTP basic access authentication, the username
and password are Base64 encoded, meaning that each byte
of plaintext has only 64 possible values. Similar restrictions
often apply to the sensitive parts of HTTP cookies.
In a related attack scenario, if the attacker already knows
one of the last two bytes of P ∗, he can recover the other
byte with much lower complexity than our analysis so far
would suggest. This is then a plaintext recovery attack with
partially-known-plaintext. For example, suppose the attacker

knows the value of the byte P ∗
14. Then he sets the starting
14 ⊕ 0x01, so that when
value of Δ such that Δ14 = P ∗
Catt(Δ) is decrypted, the second-to-last byte of P4 already
equals 0x01. Then he iterates over the 28 possible values
for Δ15, eventually ﬁnding one such that P4 has its last two
bytes equal to 0x01||0x01, triggering Case 2. He can then
proceed to recover the rest of P ∗ with the same complexity
as before. Overall, this attack, which recovers 15 bytes of
plaintext with 1-out-of-2 of the last bytes of the target block
known, consumes only 15L · 28 sessions, where L is the
number of trials used for each Δ value in each byte position.
This can be further reduced by combining the two variants.
For example, for base64 encoded plaintext, only 15L · 26
sessions are needed to decrypt a block.

3) Combining Lucky 13 with the BEAST: A signiﬁcant
limitation of our attacks as described so far is their consump-
tion of many TLS sessions. This limitation can be overcome
by combining our attacks with techniques from the BEAST
attack [10] to target TLS-protected HTTP cookies.

Speciﬁcally, in the context of a web browser communicat-
ing with a web server over TLS, the user can be induced into
downloading malware into his browser from a rogue website.
This malware, perhaps implemented in Javascript, can then
initiate all
the TLS sessions need for our attack, with
the browser automatically appending the targetted HTTP
cookie to the browser’s initial HTTP request. Furthermore,
by adjusting the length of that initial HTTP request, the
malware can ensure that there is only one unknown byte of
HTTP cookie plaintext in each target ciphertext block. This
allows our remote attacker to carry out the variant attack
described immediately above. Assuming the targeted part of
the cookie is base64 encoded, the attack consumes L · 26
sessions per byte of HTTP cookie. As we will discuss in
more detail in Section V, we found that setting L = 27
yields reliable plaintext recovery in our experimental set-
up, giving us an attack that recovers HTTP cookies using
roughly 213 sessions per unknown byte of cookie.

C. Plaintext Recovery for Other MAC Algorithms

A critical feature of our attack above is the relationship
between the size of the header included in the MAC calcu-
lation (ﬁxed at h = 13 bytes), the MAC tag size t, and the
block size b. For example, if TLS happened to be designed
such that h = 12, then, with t = 20 and b = 16, a similar
case analysis as before shows that our ciphertext Catt(Δ)
would have the property of having faster MAC veriﬁcation
if P4 also ends with the single byte 0x00 (the valid padding
pattern of length 1). This would allow an improved 28 attack
against TLS with CBC-mode and HMAC-SHA-1. In some
sense, 13 is lucky, but 12 would have been luckier!

Similarly, we have (less efﬁcient) variants of our attacks
for HMAC-MD5 and HMAC-SHA-256, where the tag sizes
t are 16 and 32 bytes, respectively. In fact, because here
t is a multiple of b, the analysis is largely the same in

533

both cases, and we consider only HMAC-MD5 in detail.
This time Catt(Δ) is such that we fall into Case 2 (valid
padding with a message of size at most 55 bytes, giving
fast MAC veriﬁcation) only if P4 = P ∗ ⊕ Δ ends with
a valid padding of length 6 or more. With no additional
information on P ∗ the attacker would need (worst case) 248
attempts to construct the correct Δ so as to trigger this case;
detecting that he had done so would be more difﬁcult in
view of the large number of candidate Δ values. This is
not an attractive attack, especially in view of the practical
considerations for TLS mentioned above. On the other hand,
we do have attractive partially-known-plaintext attacks for
HMAC-MD5 and HMAC-SHA-256. For example, if any 5
out of the last 6 bytes of P ∗ are known, we can recover the
remaining 11 bytes using 11L · 28 sessions. The attack can
also be made more efﬁcient if the plaintext has low entropy,
by trying candidates for the last 6 bytes of P ∗ in order
of decreasing probability and then recovering the remaining
bytes of P ∗ once the right 6-byte candidate is found. This
would be an good option for password recovery, for example.
A similar analysis can be carried out for truncated MAC
algorithms, as per [11]. For example, for an 80-bit (10-byte)
MAC tag, if any 11 out of the last 12 bytes of P ∗ are known,
we can recover the remaining 5 bytes using 5L· 28 sessions.
Finally, we note that the “Lucky 13 + BEAST” attacks

work equally well, no matter what the MAC tag size is.

D. Applying the Attacks to DTLS

So far we have focussed on TLS. The changes needed to
handle DTLS are the same as for our distinguishing attack
in Section III: we can use the techniques of [1] to amplify
the timing differences and to emulate TLS’s error messages.
The ampliﬁcation capability reduces the attack complexity
dramatically: essentially, we can accurately test each Δ value
using just a few packet trains instead of requiring L trials.
There is one further critical difference that we wish to
emphasise: as already noted, DTLS does not treat errors
arising during decryption as being fatal. This means that the
entire attack against DTLS can be carried out in a single
session, that is, without requiring the same plaintext to be
repeated in the same position in the plaintext across multiple
sessions, and without waiting for the Handshake Protocol to
rerun for each session.

These differences brings our attack well within the bounds
of practicality for DTLS. This is particularly so if DTLS’s
optional checking of sequence numbers is disabled. Even if
this is not the case, the attacks are quite feasible in practice,
provided enough DTLS messages are available, or if the
upper layer protocol being protected by DTLS produces
replies to sent messages in a consistent manner. These issues
are discussed at greater length in [1] and the next section,
where we report on the successful implementation of our
attacks for the OpenSSL implementation of TLS and DTLS.

V. EXPERIMENTAL RESULTS FOR OPENSSL

A. Experimental Setup

We ran version 1.0.1 of OpenSSL on the client and the
server. In our laboratory set-up, a client, the attacker and the
targeted server are all connected to the same VLAN on a
100Mbps Ethernet switch. The targeted server was running
on a single core processor machine operating at 1.87 GHz
with 1 GByte of RAM, while the attacker was running on
a dual core processor machine operating at 3.4 GHz, with 2
GByte of RAM.

To simulate the (D)TLS client, we made use of
s_client, a generic tool that is available as part of the
OpenSSL distribution package. We modiﬁed s_client’s
source code to satisfy our testing requirements. We also
developed a basic Python script that calls s_client when
needed. Our attack code is written in C and is capable of
capturing, manipulating and injecting packets of choice into
the network.

In the case of TLS, the attacker captures the “targeted”
packet, manipulates it and then sends the crafted version to
the targeted server causing the TLS session to terminate.
This crafted packet forces the client and the targeted server
to lose TCP synchronization, causing delay in the TCP
connection shutdown. To speed up the TCP connection tear
down, the attacker sends spoofed RST packets to the client
and the targeted system upon detecting the TLS encrypted
alert message, forcing both systems to independently destroy
the underlying TCP structure associated with the terminated
TLS session.

All the timing values presented in the paper are based
on hardware cycles, which are speciﬁc to processor speed.
For example, 187 hardware cycles on our targeted server
operating at speed of 1.87 GHz translate to an absolute
timing of 100 ns. To count the hardware cycles, we made
use of an existing C library licensed under GNU GPL v34.

B. Statistical Analysis

The network timings we collect

in each experiment
are from skewed distribution(s) with long tails and many
outliers. However, we found that using basic statistical
techniques (medians and, more generally, percentiles) was
sufﬁcient to analyse our data.

C. Distinguishing Attack for OpenSSL TLS

Figure 2 shows the experimental distribution of timing
values for the TLS distinguishing attack described in Sec-
tion III. The ﬁgure indicates that, with enough samples, it
should be possible to distinguish encryptions of message M0
(consisting of 32 arbitrary bytes followed by 256 copies of
0xFF) from encryptions of message M1 (consisting of 287
arbitrary bytes followed by 0x00).

4code.google.com/p/fau-timer

534

0.00006

0.00005

0.00004

0.00003

0.00002

0.00001

y
t
i
l
i
b
a
b
o
r
P

0

1.50 (cid:2)106 1.51 (cid:2)106 1.52 (cid:2)106 1.53 (cid:2)106 1.54 (cid:2)106 1.55 (cid:2)106 1.56 (cid:2)106 1.57 (cid:2)106

Hardware Cycles Calculated by Attacker

s
e
l
c
y
C

e
r
a
w
d
r
a
H


r
e
v
r
e
S

n
o

d
e
t
a
l
u
c
l
a
C


14 000

13 800

13 600

13 400

13 200

13 000

12 800

12 600

0

(cid:3)
15

(cid:4) 0xFE

50

100

(cid:2)15

150

200

250

Figure 2. Distribution of timing values (outliers removed) for distinguish-
ing attack on OpenSSL TLS, showing faster processing time in the case of
M0 (in red) compared to M1 (in blue).

Figure 3. OpenSSL TLS median server timings (in hardware cycles) when
P ∗
14 = 0x01 and P ∗
15 = 0xFF. As expected, Δ15 = 0xFE leads to faster
processing time.

Success Probability

L
1
2
4
8
16
32
64
128

0.756
0.769
0.858
0.914
0.951
0.983
0.992

1
Table I

s
e
l
c
y
C

e
r
a
w
d
r
a
H


y
r
a
s
r
e
v
d
A

y
b

d
e
t
a
l
u
c
l
a
C


1.292 (cid:2)106

1.291 (cid:2)106

1.290 (cid:2)106

1.289 (cid:2)106

1.288 (cid:2)106

1.287 (cid:2)106

(cid:3)
15

(cid:4) 0xFE

1.286 (cid:2)106

0

50

100
(cid:2)15

150

200

250

OPENSSL TLS DISTINGUISHING ATTACK SUCCESS PROBABILITIES.

We used a simple threshold test to build a concrete attack:
we calculate a threshold value T based on proﬁling, gather
L timing samples, ﬁlter outliers, calculate the median of the
remaining timing samples, and then output 1 if the median
value is greater than T and 0 if it is less. Table I shows the
success probabilities for this concrete distinguishing attack;
it is evident that the attack is reliable even if only a moderate
number of samples are available. The attack already has a
signiﬁcant advantage over guessing when L = 1, i.e. when
only one sample is available.

D. Plaintext Recovery Attacks for OpenSSL TLS

15 can be recovered when P ∗

1) Partial plaintext recovery: Section IV describes an
attack where byte P ∗
14 is known.
14 ⊕ Δ14 to equal 0x01,
This involves setting Δ14 to force P ∗
and then trying all possible values of Δ15, identifying which
15⊕Δ15 to also equal 0x01. Figure 3 shows the
one forces P ∗
median server-side decryption time as a function of Δ15 for
the particular values of P ∗
14 = 0x01 (so Δ14 = 0x00) and
P ∗
15 = 0xFF. A clear reduction in processing time can be
seen for the expected value of Δ15, namely Δ15 = 0xFE.
Also notable is the stability in the processing time for other
byte values. These server-side times indicate that an attack
based on timing error message on the network has some
prospect of success. Figure 4 shows the corresponding distri-
bution of median network timings in our experimental setup.
Clearly, the data is noisier, but the “dip” at Δ15 = 0xFE is

Figure 4. OpenSSL TLS median network timings in terms of hardware
cycles when P ∗
15 = 0xFF. As expected Δ15 = 0xFE
leads to faster processing time.

14 = 0x01 and P ∗

clearly distinguishable.

Figure 5 shows success probabilities for the attack. Each
data-point in the ﬁgure is based on at least 64 experiments.
Each curve in the ﬁgure represents a different number of
total sessions consumed in the attack (corresponding to
different values for L, the number of trials for each Δ value).
The x-axis represents the percentile used in our statistical
test: if the percentile value is p, then we take as the correct
value for Δ15 the one for which the p-th percentile value
of the timing distribution (measured over L samples) is
minimised. It is evident that a range of percentiles work well,
including the median. As expected, the success probability
of the attack increases as L increases. We already reach
a success probability of 1 when L = 28, where the total
number of sessions needed is 216. Similarly, we have a
success probability of 0.93 when L = 27, where the total
number of sessions is 215.

Given these results, we anticipate that the attack would
extend easily to recovering 15 unknown bytes from a block,
given one of the last two bytes. We have not implemented
this variant.

2) Full plaintext recovery: The next step would be to
perform the full plaintext recovery attack from Section IV.
In this case, the attacker would need a total of L · 216 trials

535

Figure 5.
success probabilities for recovering P ∗

OpenSSL TLS partial plaintext recovery: percentile-based

15 assuming P ∗

14 known.

Figure 6.
success probabilities for recovering P ∗

15 with P ∗

OpenSSL DTLS partial plaintext recovery: percentile-based

14 known, n = 10.

(cid:3)

(cid:2)

(cid:3) (cid:3) (cid:3) (cid:3) (cid:3) (cid:3) (cid:3) (cid:3) (cid:3) (cid:3) (cid:3)
(cid:2) (cid:2) (cid:2) (cid:2) (cid:2) (cid:2) (cid:2) (cid:2) (cid:2)
(cid:2)

(cid:4)(cid:4)(cid:4) (cid:4) (cid:4) (cid:4) (cid:4) (cid:4) (cid:4) (cid:4) (cid:4) (cid:4) (cid:4) (cid:4) (cid:4)
(cid:5)(cid:5)(cid:5)(cid:5) (cid:5) (cid:5) (cid:5) (cid:5) (cid:5) (cid:5) (cid:5) (cid:5) (cid:5) (cid:5) (cid:5) (cid:5) (cid:5)
(cid:4)
(cid:3)
(cid:4)
(cid:3)
(cid:2)
(cid:3)
(cid:2)

(cid:2)

(cid:5)

20

40

60

80

Percentiles

(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)
(cid:2) (cid:2) (cid:2) (cid:2) (cid:2) (cid:2) (cid:2) (cid:2) (cid:2) (cid:2) (cid:2) (cid:2) (cid:2) (cid:2) (cid:2)
(cid:3) (cid:3) (cid:3) (cid:3) (cid:3) (cid:3) (cid:3) (cid:3) (cid:3) (cid:3) (cid:3) (cid:3) (cid:3) (cid:3) (cid:3) (cid:3) (cid:3) (cid:3) (cid:3)
(cid:2)
(cid:3)
(cid:2) (cid:2)

(cid:2)

1.0

0.8

0.6

0.4

0.2

0.0

s
e
i
t
i
l
i
b
a
b
o
r
P

s
s
e
c
c
u
S

(cid:3)
(cid:3)

(cid:5)

(cid:2)

(cid:4)
(cid:4)

(cid:2)
(cid:2)

(cid:3)
(cid:5)(cid:5)
(cid:4)(cid:4)
(cid:3)(cid:3)(cid:3)
(cid:2)(cid:2)(cid:2)(cid:2)
0

(cid:3)

(cid:4)

(cid:3)

(cid:4)

(cid:3)

(cid:2)

1.0

0.8

0.6

0.4

0.2

s
e
i
t
i
l
i
b
a
b
o
r
P

s
s
e
c
c
u
S

(cid:5)
(cid:4)
(cid:3)
(cid:2)

(cid:5)
(cid:4)
(cid:2)
(cid:3)

(cid:2) 211 Trials L(cid:2)23
(cid:3) 212 Trials L(cid:2)24
(cid:4) 213 Trials L(cid:2)25
(cid:5) 214 Trials L(cid:2)26

(cid:2)
(cid:3)
(cid:5)
(cid:4)

(cid:2)

(cid:3)
(cid:4)
(cid:5)

100

(cid:4)
(cid:3)
(cid:4)
(cid:2) (cid:2)
(cid:3)

(cid:4)
(cid:3)
(cid:2)

(cid:4)
(cid:2)
(cid:3) (cid:3)
(cid:2)
(cid:4)

(cid:2) 219 Trials L(cid:2)23
(cid:3) 220 Trials L(cid:2)24
(cid:4) 221 Trials L(cid:2)25

(cid:2)
(cid:3)

(cid:4)

(cid:2) (cid:2)(cid:2)
(cid:4)
(cid:3)
(cid:4)(cid:4)
(cid:3)(cid:3)
100

1.0

0.8

0.6

0.4

0.2

0.0

s
e
i
t
i
l
i
b
a
b
o
r
P

s
s
e
c
c
u
S

(cid:6) (cid:6) (cid:6) (cid:6) (cid:6) (cid:6) (cid:6) (cid:6)
(cid:7) (cid:7) (cid:7) (cid:7) (cid:7) (cid:7) (cid:7) (cid:7) (cid:7)
(cid:6)

(cid:5) (cid:5) (cid:5) (cid:5) (cid:5)

(cid:4) (cid:4) (cid:4) (cid:4) (cid:4)

(cid:7)

(cid:6)

(cid:5)

(cid:7)

(cid:5)

(cid:4)

(cid:5)

(cid:4)

(cid:5)

(cid:4)

(cid:5)

(cid:4)

(cid:7)
(cid:6)

(cid:5)

(cid:4)

(cid:7)

(cid:6)

(cid:5)

(cid:4)

(cid:7)
(cid:6)
(cid:5)
(cid:3)
(cid:4)
(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7) (cid:7)
(cid:6)(cid:6)(cid:6)(cid:6)(cid:6)(cid:6)(cid:6)(cid:6) (cid:6)
(cid:5)(cid:5)(cid:5)(cid:5)(cid:5)(cid:5)(cid:5)(cid:5) (cid:5)
(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4) (cid:4)
(cid:3)(cid:3)(cid:3)(cid:3) (cid:3)(cid:3)(cid:3) (cid:3) (cid:3) (cid:3)
(cid:2)(cid:2)(cid:2)(cid:2) (cid:2)(cid:2)(cid:2) (cid:2) (cid:2) (cid:2) (cid:2)
(cid:7)
0
20

(cid:3)

(cid:3)
(cid:2) (cid:2)
40

(cid:3) (cid:3) (cid:3) (cid:3) (cid:3) (cid:3)

(cid:4)
(cid:2) (cid:2) (cid:2) (cid:2) (cid:2) (cid:2) (cid:2) (cid:2)

(cid:3)

(cid:3)

(cid:3)

(cid:2)

60

80

Percentiles

(cid:6)
(cid:5)
(cid:4)
(cid:3)
(cid:4)
(cid:6)
(cid:2) (cid:2) (cid:2)
(cid:5)
(cid:3)
(cid:3)
(cid:7) (cid:7)
(cid:4)
(cid:6)
(cid:5)
100

(cid:2) 212 Trials L(cid:2)24
(cid:3) 213 Trials L(cid:2)25
(cid:4) 214 Trials L(cid:2)26
(cid:5) 215 Trials L(cid:2)27
(cid:6) 216 Trials L(cid:2)28
(cid:7) 217 Trials L(cid:2)29

to discover which mask value triggers Case 2. In the case
of TLS, this takes a considerable amount of time due to the
underlying TCP and TLS connection set-up and tear-down
times. For example, with L = 27 we estimate that the 223
sessions would take around 64 hours in our setup. However,
once the last two bytes of a block have been successfully
recovered, then the remaining bytes in that block can be
recovered in a much shorter time. We have not implemented
the full plaintext recovery attack for TLS. Our results below
for DTLS strongly indicate that the full attack would work
for TLS with L = 27, albeit slowly.

E. Plaintext Recovery Attacks for OpenSSL DTLS

As explained in Section IV-D, we can use the timing
and ampliﬁcation techniques from [1] in combination with
the previously described attacks to attack DTLS. Now the
attacker sends a number (n) of crafted packets, followed by
a DTLS Heartbeat request and waits for the corresponding
Heartbeat reply. This process is repeated L times for each
mask value. The attacker selects n and L in order to trade-
off the attack success probability and the total number of
packets injected. We have found experimentally that n = 10
is a good choice for achieving stable timing values. On the
other hand, n = 1 is indicative of what might be expected
to happen with TLS but without enduring the overhead of
TCP and TLS connection setups (note that the noise levels
for DTLS are generally somewhat higher since we depend
on an application-layer error message rather than a native
TLS error message). Higher values of n could be used if
the attacker is remote from the server.
Figure 6 shows the percentile-based success probabilities
for recovering P ∗
15 assuming that P ∗
14 is known, for n =
10. It can be seen that the attack is very effective, reliably
recovering the unknown plaintext byte with only 211 trials
(L = 23). Even for 28 trials (L = 1), the success probability
is 0.266.

We also conducted a 2-byte recovery attack against
OpenSSL DTLS; this attack is effectively the ﬁrst step of
the full plaintext recovery attack described in Section IV.
Figure 7 shows the success probabilities for recovering P ∗
14
and P ∗
15 when n = 10. Again, the attack is very effective,

536

0.0

(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)
(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)
(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)
0

20

40

60

80

Percentiles

Figure 7.
probabilities for recovering P ∗

14 and P ∗

OpenSSL DTLS 2-byte recovery: percentile-based success

15, n = 10.

recovering both bytes with success probability 0.93 for 219
trials (L = 23). The quality of these results is evidence that
the attack should extend easily to a full plaintext recovery
attack. Figure 8 shows our results for n = 1, which we
recall serves as an experimental model for TLS. We see that
2-byte recovery is reliable given 223 trials (L = 27); we
already reach more than 80% success rate using 222 trials.

F. More Challenging Network Environments

We have not conducted experiments where the attacker
is not situated in the same LAN as the server. Given
the small
timing differences involved, we would expect
the attacks to fail when the attacker is remote, i.e. more
than a couple of hops away from the server, or that very
large numbers of sessions would be needed to get reliable
results. Nevertheless, there are realistic scenarios where the

1.0

0.8

0.6

0.4

0.2

0.0

s
e
i
t
i
l
i
b
a
b
o
r
P

s
s
e
c
c
u
S

(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)(cid:7)

(cid:5)(cid:5)(cid:5)(cid:5)(cid:5)(cid:5)(cid:5)(cid:5)(cid:5)(cid:5)(cid:5)(cid:5)(cid:5)(cid:5)(cid:5)(cid:5)(cid:5)(cid:5)
(cid:6)(cid:6)(cid:6)(cid:6)(cid:6)(cid:6)(cid:6)(cid:6)(cid:6)(cid:6)(cid:6)(cid:6)(cid:6)(cid:6)(cid:6)(cid:6)(cid:6)(cid:6)(cid:6)(cid:6)(cid:6)(cid:6)(cid:6)(cid:6)(cid:6)(cid:6)(cid:6)(cid:6)
(cid:5)(cid:5)
(cid:6)
(cid:7)
(cid:5)(cid:5)

(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)
(cid:4)

(cid:4)(cid:4)

(cid:5)

(cid:5)

(cid:7)(cid:7)

(cid:4)
(cid:4)
(cid:4)
(cid:4)
(cid:4)
(cid:4)
(cid:4)

(cid:6)

(cid:3) (cid:3)

(cid:3)

(cid:3)

(cid:3)

(cid:3)(cid:3)(cid:3)
(cid:2) (cid:2) (cid:2) (cid:2) (cid:2)

(cid:2) (cid:2)

(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)(cid:3)
(cid:4)(cid:4)(cid:4)(cid:4)
(cid:5)(cid:5)(cid:5)(cid:5)
(cid:6)(cid:6)
(cid:7)(cid:7)
(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)(cid:2)
0

20

(cid:4)(cid:4)
(cid:4)

(cid:4)(cid:4)

(cid:3) (cid:3) (cid:3)

(cid:3) (cid:3) (cid:3)

(cid:3)

(cid:5)

(cid:6)

(cid:5)

(cid:5)(cid:5)

(cid:4)(cid:4)
(cid:4)
(cid:4)(cid:4)
(cid:4)

(cid:7)
(cid:6)

(cid:3)

(cid:3) (cid:3) (cid:3)

(cid:7)
(cid:5)
(cid:4)
(cid:4)(cid:4)
(cid:5)
(cid:2) (cid:2) (cid:2) (cid:2) (cid:2) (cid:2) (cid:2) (cid:2) (cid:2) (cid:2) (cid:2) (cid:2) (cid:2) (cid:2) (cid:2) (cid:2) (cid:2) (cid:2) (cid:2) (cid:2) (cid:2) (cid:2)(cid:2)
(cid:3) (cid:3) (cid:3)
(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)(cid:4)
(cid:3) (cid:3) (cid:3) (cid:3) (cid:3) (cid:3) (cid:3)(cid:3)
(cid:6)(cid:6)(cid:6)(cid:6)
(cid:5)(cid:5)(cid:5)(cid:5)
(cid:7)(cid:7)(cid:7)(cid:7)
80
100

(cid:3) (cid:3)

(cid:6)
(cid:5)

(cid:6)
(cid:7)
(cid:5)

40

60

(cid:2) 220 Trials L(cid:2)24
(cid:3) 221 Trials L(cid:2)25
(cid:4) 222 Trials L(cid:2)26
(cid:5) 223 Trials L(cid:2)27
(cid:6) 224 Trials L(cid:2)28
(cid:7) 225 Trials L(cid:2)29

Percentiles

Figure 8.
probabilities for recovering P ∗

14 and P ∗

15, n = 1.

OpenSSL DTLS 2-byte recovery: percentile-based success

proximity requirement can be met, for example when a
hostile network service provider attacks its customers, or
in cloud computing environments. For DTLS, the timing
signals can be ampliﬁed, effectively by an arbitrary amount,
and so we would expect to be able to mount the attacks
remotely.

VI. OTHER IMPLEMENTATIONS OF TLS

1) GnuTLS: The GnuTLS5 implementation of MEE-
TLS-CBC deals with bad padding in a different way to that
recommended in the RFCs: instead of assuming zero-length
padding, it uses the last byte of plaintext to determine how
many plaintext bytes to remove (whether or not those bytes
are correctly formatted padding). Since this approach is a
natural alternative to the RFCs’ advice for handling bad
padding we analyse it here; for full details of the analysis,
see the full version [2].

Firstly, we point out that GnuTLS-style processing is just
as vulnerable to distinguishing attacks as RFC-compliant
processing. Indeed, the attack described in Section III will
work just as before6. We next present an attack that recovers
the rightmost byte of plaintext
in any target block for
GnuTLS-style padding processing. Let C∗ denoting the
target ciphertext block, C(cid:2) denote the previous ciphertext
block and Δ denote a mask block of 16 bytes. We consider
the decryption of a ciphertext Catt(Δ) of the form:

Catt(Δ) = HDR||C0||C1||C2|| . . .||C18||C(cid:2) ⊕ Δ||C∗

in which there are 20 non-IV ciphertext blocks, the penul-
timate block is an XOR-masked version of C(cid:2) and the last
block is C∗, the target ciphertext block. The corresponding
320-byte plaintext is P = P1||P2|| . . .||P19||P20 in which

(C∗) ⊕ (C(cid:2) ⊕ Δ)

P20 = DKe

= P ∗ ⊕ Δ.

Now we need consider only two distinct cases, which

between them cover all possibilities:

1) P20 ends with a 0x00 byte: in this case, a single byte of
padding is removed, the next 20 bytes are interpreted
as a MAC tag T , and the remaining 320 − 21 = 299
bytes of plaintext are taken as the record R. MAC
veriﬁcation is then performed on a 13 + 299 = 312-
byte message SQN||HDR||R.

2) P20 ends with any other byte value: in this case, at
least two bytes of “padding” are removed, the next
20 bytes are interpreted as a MAC tag T , and the
remaining bytes of plaintext are taken as the record
R. Because the starting message length, at 320 bytes,
is long enough to allow for the removal of 256 bytes
of padding and a 20-byte MAC whilst still leaving

5www.gnu.org/software/gnutls/
6In fact, since the attack only involves plaintexts which are correctly

padded, it will work for any correct decryption algorithm.

537

a non-null record, no length sanity tests will fail.
MAC veriﬁcation is then performed on a message
SQN||HDR||R that contains at most 311 bytes.

In both cases, the MAC veriﬁcation will fail (with over-
whelming probability) and an error message produced. No-
tice that, in accordance with the discussion in Section II-A,
in Case 1, the MAC veriﬁcation will involve 9 evaluations of
the compression function for SHA-1, while Case 2 requires
at most 8 evaluations. Therefore, we can hope to distinguish
the two cases by careful timing, as previously.

Now the single-byte plaintext recovery attack is straight-
forward:
the attacker injects a sequence of ciphertexts
Catt(Δ) with values of Δ that vary over all possible values
then (in the worst case) after 28
in the last byte Δ15,
trials, the attacker will surely select a value for Δ such that
Catt(Δ) triggers Case 1. When this is detected, he knows
that P20 ends with a 0x00 byte and can infer the value of the
last byte of P ∗ via the blockwise equation P20 = P ∗ ⊕ Δ.
For further improvements to this attack and analysis for

HMAC-MD5 and HMAC-SHA-256, see [2]

We note that we have not found attacks for GnuTLS-style
processing that can extract more than the last byte of the
target block. This is not surprising in view of the fact that
the decryption time for GnuTLS-style processing depends
only on the last byte of plaintext.

We worked with version 3.0.21 of GnuTLS to implement
the above attacks. We found that
the network timings
for error messages were much noisier than for OpenSSL.
We also identiﬁed some coding errors in GnuTLS which
hampered our attack. Nevertheless, we were still able to
reliably recover up to 4 bits of the last byte of each block.
For details, see the full version [2]. Whilst extracting less
plaintext than our OpenSSL attack, far fewer TLS sessions
were required for GnuTLS. This indicates that
ignoring
the recommendations of the RFCs can have severe security
consequences.

2) NSS: Network Security Services (NSS)7 is an open-
source set of libraries implementing, amongst other things,
TLS. It is widely used, including in Mozilla client prod-
ucts and Google Chrome. The NSS code8 takes the same
approach as in GnuTLS, potentially rendering the code
vulnerable to an attack recovering a single byte of plaintext
per block.

3) PolarSSL: We also examined the PolarSSL9 imple-
mentation of TLS. The code10 behaves in much the same
way as OpenSSL, setting a variable padlen to 0 if the
padding check fails, and then verifying the MAC on a
record stripped of padlen bytes. This would render it

7http://www.mozilla.org/projects/security/pki/nss
8We worked with version 3.13.6 available at https://ftp.mozilla.org/pub/

mozilla.org/security/nss/releases/NSS 3 13 6 RTM/src/.

9polarssl.org/
10We worked with version 1.1.4 available at polarssl.org/trac/browser/

trunk/library/ssl tls.c.

vulnerable to the attacks described in Section IV. However,
in its default conﬁguration, PolarSSL does not send any TLS
alert messages when decryption errors are encountered. This
protects PolarSSL against our attack but also means that it
is not RFC-compliant in this aspect.

4) yaSSL: The yaSSL11 embedded SSL library, CyaSSL,
is targetted at embedded and real-time operating system
environments. It appears to have rather few known vulner-
abilities, with only 5 being reported in the CVE database12
since 2005. The CyaSSL code13 does not perform proper
padding checks, but instead just examines the last byte of
plaintext and uses this to determine how many bytes to
remove. This approach renders the code vulnerable to the
old attack from [17] which recovers one byte of plaintext
per block. This was the only implementation that we found
that still contains this basic ﬂaw.

5) Java: We have examined the BouncyCastle14 and

OpenJDK15 Java implementations of TLS.

The BouncyCastle code does careful sanity checking of
the padding length (as indicated by the last byte of plaintext)
but treats the padding as having length 1 if the padding
format, when checked, is found to be incorrect (a variable
paddingsize is set to 0, but then the plaintext size is
reduced by an amount paddingsize+minLength where
minLength is set to be 1 larger than the MAC tag size).
This deviates slightly from the recommendation of the RFCs
to treat the padding as having length zero, but still allows
our attacks in Sections III and IV to be applied (for Case 3
of the main plaintext recovery attack in Section IV, MAC
veriﬁcation ends up being performed on a 56-byte message,
but this will still involve 5 evaluations of the compression
function for SHA-1).

The OpenJDK code appears follow the recommendation
of the RFCs in treating the padding as having zero length if
the padding format, when checked, is found to be incorrect.
This is because this case is trapped by exception handling,
during which the variable deﬁning the plaintext length is not
changed. This potentially renders it vulnerable to our attacks
in Sections III and IV.

VII. COUNTERMEASURES

A. Add Random Time Delays

A natural reaction to timing-based attacks is to add
random time delays to the decryption process to frustrate
statistical analysis. In fact, this countermeasure is surpris-
ingly ineffective, as we demonstrate in the full version [2].

11yassl.com/yaSSL/Home.html
12www.cvedetails.com/vulnerability-list/vendor id-3485/Yassl.html
13We worked with version 2.3.0 available at yassl.com/yaSSL/Source/

output/src/internal.c.html.

14www.bouncycastle.org/viewcvs/viewcvs.cgi/java/crypto/src/org/

bouncycastle/crypto/tls/TlsBlockCipher.java?view=markup

15hg.openjdk.java.net/jdk7/l10n/jdk/ﬁle/3598d6eb087c/src/share/classes/
sun/security/ssl/SSLSocketImpl.java and hg.openjdk.java.net/jdk7/2d/jdk/
ﬁle/85fe3cd9d6f9/src/share/classes/sun/security/ssl/CipherBox.java

538

B. Use RC4

The simplest countermeasure for TLS is to switch to using
the RC4 stream cipher in place of CBC-mode encryption.
However, this is not an option for DTLS. When a stream
cipher is used in TLS, no padding is required. Consequently
none of the attacks in this paper will work. RC4 is widely
supported in implementations of TLS, the same countermea-
sure is effective against the BEAST attack, and has been
fairly widely adopted in response to BEAST. The use of a
stream cipher in a MEE construction is well-supported by
theory [12]. But the ﬁrst bytes of keystream output by the
RC4 generator have certain small biases, and TLS does not
discard these before starting encryption. For this reason, we
do not recommend using RC4.

C. Use Authenticated Encryption

Another possibility is to switch from MEE-TLS-CBC to
using a dedicated authenticated encryption algorithm, such
as AES-GCM or AES-CCM which were standardised for use
in TLS in RFCs 5288 [24] and 6655 [15], respectively. In
theory, this should obviate all attacks based on weaknesses
in the MEE construction. However, we cannot rule out
implementation errors, and we are not aware of any detailed
analysis of implementations of these algorithms in (D)TLS
for potential side-channels. A further issue is that authenti-
cated encryption was only added in TLS 1.2, and this version
of TLS is not yet widely supported in implementations.

D. Careful implementation of MEE-TLS-CBC decryption

Our ﬁnal option is to implement MEE-TLS-CBC decryp-

tion more carefully.

The key requirement

is to ensure uniform processing
time for all MEE-TLS-CBC ciphertexts of a given size.
That is, the total processing time should depend only on
the ciphertext size, and not on any characteristics of the
underlying plaintext (including padding). The basic principle
to be followed in achieving this is quite simple: since
the major timing differences arise from MAC processing,
implementations should make sure the same amount of MAC
processing is carried out no matter what the underlying
plaintext
indicates the message length to be. However,
this simple principle is complicated by the need to also
perform careful sanity checking on the underlying plaintext
whilst avoiding the introduction of yet more timing side-
channels, and to make sure appropriate amounts of MAC
processing are performed even when these checks fail. A
further complication arises because the number of bytes to
be examined in the padding check depends on the last byte of
the last plaintext block, and so, even if the MAC processing
is made uniform, the running time of the padding check may
still leak a small amount of information about the plaintext.
With these remarks in mind, we now proceed to give a
detailed prescription of how to achieve constant-time pro-
cessing of MEE-TLS-CBC ciphertexts, incorporating suit-

2) Decrypt

able sanity checking. In what follows, we let plen denote
the length (in bytes) of the plaintext P obtained immediately
after CBC-mode decryption of the ciphertext, padlen
denote the last byte of that plaintext interpreted as an integer
between 0 and 255, and t denote the length of the MAC tags
(in bytes). Also, let HDR, SQN denote the (D)TLS record
header and the expected value of the sequence number for
this record. Our recommended procedure is then as follows:
1) First sanity check the ciphertext: check that its length
in bytes is a multiple of the block-size b and is at least
max{b, t + 1} (for chained IVs) or b + max{b, t + 1}
(for explicit IVs). If these conditions are not met, then
return fatal error.
to obtain plaintext P ; now
the ciphertext
plen will be a multiple of b and at least max{b, t+1}.
3) If t + padlen + 1 > plen, then the plaintext is not
long enough to contain the padding (as indicated by
the last byte of plaintext) plus a MAC tag. In this case,
run a loop as if there were 256 bytes of padding, with
a dummy check in each iteration. Then let P (cid:2) denote
the ﬁrst plen − t bytes of P , compute a MAC on
SQN||HDR||P (cid:2) and do a constant-time comparison of
the computed MAC with the last t bytes of P . Return
fatal error.
4) Otherwise (when t + padlen + 1 ≤ plen), check
the last padlen + 1 bytes of P to ensure they are all
equal (to the last byte of P ), ensuring that the loop
does check all the bytes (and does not stop as soon as
the ﬁrst mismatch is detected). If this fails, then run
a loop as if there were 256 − padlen − 1 bytes of
padding, with a dummy check in each iteration, and
then do a MAC check as in the previous step. Return
fatal error.
5) Otherwise (the padding is now correctly formatted)
run a loop as if there were 256−padlen−1 bytes of
padding, doing a dummy check in each iteration. Then
let P (cid:2) denote the ﬁrst plen−padlen−1−t bytes of
P , and let T denote the next t bytes of P (the remain-
der of P is valid padding). Run the MAC computation
on SQN||HDR||P (cid:2) to obtain a MAC tag T (cid:2). Then set
L1 = 13+plen−t, L2 = 13+plen−padlen−1−t,
(cid:5) MAC
and perform an additional (cid:4) L1−55
compression function evaluations (on dummy data).
Finally, do a constant-time comparison of T and T (cid:2).
If these are equal, then return P (cid:2). Otherwise, return
fatal error.

(cid:5) − (cid:4) L2−55

64

64

When implementing the above procedure, it would be
tempting to omit seemingly unnecessary computations that
are performed, for example when t + padlen + 1 > plen.
However, these are needed to prevent other timing side-
channels like those reported in [1] for the GnuTLS imple-
mentation of DTLS. Notice also that the dummy computa-
tions performed in the last step are compression function

539

0.00006

0.00005

0.00004

0.00003

0.00002

0.00001

y
t
i
l
i
b
a
b
o
r
P

0

1.54 (cid:2)106 1.55 (cid:2)106 1.56 (cid:2)106 1.57 (cid:2)106 1.58 (cid:2)106 1.59 (cid:2)106 1.60 (cid:2)106 1.61 (cid:2)106

Hardware Cycles Calculated by Attacker

Figure 9. Distribution of timing values (outliers removed) for distinguish-
ing attack on OpenSSL TLS, using our decryption procedure.

evaluations and not full MAC computations. These give a
MAC computation time that is the same irrespective of how
much padding is removed (and equal to that carried out in
earlier steps).

We have implemented the above procedure by modi-
fying OpenSSL version 1.0.1, the same version used for
our attacks. We then ran our distinguishing attack from
Section III against the modiﬁed code. Each packet in the
attack passes the padding check, but fails MAC veriﬁcation,
causing the server to close the TLS session and send an
encrypted alert message. Figure 9 shows the distribution of
timing values (in hardware cycles) after implementing our
procedure. This ﬁgure should be compared with Figure 2:
visual inspection alone shows that the timing difference is
substantially reduced. In fact, the separation between the
medians of the two distributions is reduced from about
8500 to about 1100 hardware cycles (from around 2.5μs
to 0.32μs). In turn, this small separation means that 128
sessions are needed to achieve a distinguishing success
probability of 0.68, whereas, prior to our modiﬁcations,
just 1 session was enough to give a success probability of
0.756. For the plaintext recovery attack, the adversary will
have access to timing differences roughly one quarter of
this, i.e. roughly 80ns on our hardware. Notice also that
the two distributions are reversed compared to Figure 2, i.e.
processing 0xFF packets now takes longer, on average, than
for 0x00 packets. We believe that this is caused by overhead
introduced by a SHA1_Update function call that occurs
for 0xFF packets but not 0x00 packets.

To achieve further reductions in timing difference would
require a more sophisticated “constant time” programming
approach. The OpenSSL patch in versions 1.0.1d, 1.0.0k
and 0.9.8y addressing the attacks in this paper provides an
example of how to do this. The complexity of the OpenSSL
patch is notable, with around 500 lines of new ‘C’ code
being required. For further discussion and explanation, see
www.imperialviolet.org/2013/02/04/luckythirteen.html.

VIII. DISCUSSION

We have demonstrated a variety of attacks against im-
plementations of (D)TLS. We reiterate that the attacks are
ciphertext-only, and so can be carried out by the standard
MITM attacker, without a chosen-plaintext capability. The
attacks that are possible depend crucially on low-level imple-
mentation details, as well as factors such as the relationship
between the MAC tag size t and the block size b. All
implementations we examined were vulnerable to one or
more attacks. It is an interesting open question as to whether
similar timing attacks could be developed against the TLS
encryption operation using a variant of the CRIME attack.
For TLS, we need a multi-session attack, with, in some
cases, many sessions. This limits the practicality of the
attacks, but note that they be further improved using standard
techniques such as language models and sequential estima-
tion. They can also be enhanced in a BEAST-style attack
to enable efﬁcient recovery of HTTP cookies. The timing
differences we must detect are close to or below the levels
of jitter one typically ﬁnds in real networks. In particular,
our attacker needs to be positioned relatively close (in terms
of network hops) to the machine being attacked. Still, the
attacks should be considered as a realistic threat to TLS,
and we have described a range of suitable countermeasures.
The attacks are much more serious for DTLS, because
of this protocol’s tolerance of errors and because of the
availability of timing ampliﬁcation techniques from [1]. Very
careful implementation of the MEE-TLS-CBC decryption
algorithm is needed to thwart these ampliﬁcation techniques.
In view of this, we highly recommend the use of a suitable
authenticated encryption algorithm in preference to CBC-
mode for DTLS.

ACKNOWLEDGEMENTS

We thank Xuelei Fan, David McGrew, Adam Langley,
Brad Wetmore and the anonymous reviewers for useful
feedback. We also thank Eric Rescorla for pointing out
that our attacks can be enhanced in the web setting using
BEAST-like techniques.

REFERENCES

[1] N. AlFardan and K. G. Paterson. Plaintext-recovery attacks

against Datagram TLS. In NDSS, 2012.

[2] N. AlFardan and K. G. Paterson. Lucky thirteen: Breaking
the TLS and DTLS record protocols. Full version of this
paper, available from www.isg.rhul.ac.uk/tls, 2013.

[3] G. V. Bard. The vulnerability of SSL to chosen plaintext

attack. IACR Cryptology ePrint Archive, 2004:111, 2004.

[4] G. V. Bard. A challenging but feasible blockwise-adaptive
chosen-plaintext attack on SSL. In SECRYPT, pages 99–109,
2006.

[5] B. Canvel, A. P. Hiltgen, S. Vaudenay, and M. Vuagnoux.
Password Interception in a SSL/TLS Channel. In D. Boneh,
editor, CRYPTO, volume 2729 of LNCS, pages 583–599.
Springer, 2003. ISBN 3-540-40674-3.

540

Guidelines for

[6] C. M. Chernick, C. Edington III, M. J. Fanto, and R. Rosen-
the Selection and Use of Trans-
thal.
port Layer Security (TLS) Implementations.
In NIST Spe-
cial Publication 800-52, June 2005, National Institute of
Standards and Technology. Available at http://csrc.nist.gov/
publications/nistpubs/800-52/SP-800-52.pdf , 2005.

[7] T. Dierks and C. Allen. The TLS Protocol Version 1.0. RFC

2246, Internet Engineering Task Force, 1999.

[8] T. Dierks and E. Rescorla. The Transport Layer Security
(TLS) Protocol Version 1.1. RFC 4346, Internet Engineering
Task Force, 2006.

[9] T. Dierks and E. Rescorla. The Transport Layer Security
(TLS) Protocol Version 1.2. RFC 5246, Internet Engineering
Task Force, 2008.
[10] T. Duong and J. Rizzo. Here come the ⊕ Ninjas. Unpublished

manuscript, 2011.

[11] D. Eastlake 3rd. Transport Layer Security (TLS) Extensions:

Extension Deﬁnitions. RFC 6066, 2011.

[12] H. Krawczyk. The order of encryption and authentication
for protecting communications (or: How secure is SSL?). In
CRYPTO, pages 310–331, 2001.

[13] H. Krawczyk, M. Bellare, and R. Canetti. HMAC: Keyed-
Hashing for Message Authentication. RFC 2104 (Informa-
tional), 1997.

[14] U. Maurer and B. Tackmann.

On the soundness of
formalizing the malleability of
authenticate-then-encrypt:
symmetric encryption. In ACM CCS, pages 505–515, 2010.
[15] D. McGrew and D. Bailey. AES-CCM Cipher Suites for
Transport Layer Security (TLS). RFC 6655 (Proposed Stan-
dard), 2012.

[16] N. Modadugu and E. Rescorla. The Design and Implemen-

tation of Datagram TLS. In NDSS, 2004.

[17] B. Moeller.

Security of CBC ciphersuites in SSL/TLS:
Problems and countermeasures, 2004. http://www.openssl.
org/∼bodo/tls-cbc.txt.

[18] K. G. Paterson, T. Ristenpart, and T. Shrimpton. Tag size
does matter: Attacks and proofs for the TLS record protocol.
In ASIACRYPT, pages 372–389, 2011.

[19] A. Pironti, P.-Y. Strub, and K. Bhargavan. Identifying website
users by TLS trafﬁc analysis: New attacks and effective
countermeasures. Technical Report 8067, INRIA, September
2012.

[20] E. Rescorla and N. Modadugu. Datagram Transport Layer
Security. RFC 4347, Internet Engineering Task Force, 2006.
[21] E. Rescorla and N. Modadugu. Datagram Transport Layer
Security Version 1.2. RFC 6347, Internet Engineering Task
Force, 2012.

[22] T. Ristenpart, E. Tromer, H. Shacham, and S. Savage. Hey,
you, get off of my cloud: exploring information leakage in
third-party compute clouds.
In E. Al-Shaer, S. Jha, and
A. D. Keromytis, editors, ACM Conference on Computer and
Communications Security, pages 199–212. ACM, 2009.

[23] P. Rogaway.

Problems with proposed IP cryptography.
Unpublished manuscript, 1995. http://www.cs.ucdavis.edu/
∼rogaway/papers/draft-rogaway-ipsec-comments-00.txt.

[24] J. Salowey, A. Choudhury, and D. McGrew. AES Galois
Counter Mode (GCM) Cipher Suites for TLS. RFC 5288
(Proposed Standard), 2008.

[25] S. Vaudenay. Security Flaws Induced by CBC Padding -
In EUROCRYPT,

Applications to SSL, IPSEC, WTLS ...
pages 534–546, 2002.

