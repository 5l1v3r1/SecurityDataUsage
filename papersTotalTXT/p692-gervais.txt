Tampering with the Delivery of Blocks and Transactions

in Bitcoin

Arthur Gervais

ETH Zurich, Switzerland
agervais@inf.ethz.ch

Ghassan O. Karame
NEC Laboratories, Europe

ghassan.karame@neclab.eu

Hubert Ritzdorf

ETH Zurich, Switzerland
rihubert@inf.ethz.ch

Srdjan ˇCapkun

ETH Zurich, Switzerland
capkuns@inf.ethz.ch

ABSTRACT
Given the increasing adoption of Bitcoin, the number of
transactions and the block sizes within the system are only
expected to increase. To sustain its correct operation in
spite of its ever-increasing use, Bitcoin implements a number
of necessary optimizations and scalability measures. These
measures limit the amount of information broadcast in the
system to the minimum necessary.

In this paper, we show that current scalability measures
adopted by Bitcoin come at odds with the security of the
system. More speciﬁcally, we show that an adversary can
exploit these measures in order to eﬀectively delay the prop-
agation of transactions and blocks to speciﬁc nodes for a con-
siderable amount of time—without causing a network par-
titioning in the system. Notice that this attack alters the
information received by Bitcoin nodes, and modiﬁes their
views of the ledger state. Namely, we show that this allows
the adversary to considerably increase its mining advantage
in the network, and to double-spend transactions in spite of
the current countermeasures adopted by Bitcoin. Based on
our results, we propose a number of countermeasures in or-
der to enhance the security of Bitcoin without deteriorating
its scalability.

Categories and Subject Descriptors
C.2.0 [Computer-Communication Networks]: General
– Security and protection.

Keywords
Bitcoin; Preventing object delivery; Countermeasures.

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS’15, October 12–16, 2015, Denver, Colorado, USA.
c(cid:13) 2015 ACM. ISBN 978-1-4503-3832-5/15/10 ...$15.00.
DOI: http://dx.doi.org/10.1145/2810103.2813655.

1.

INTRODUCTION

Bitcoin has received more adoption and popularity than
any other digital currency proposed to date. Currently, Bit-
coin holds the largest market share amongst all existing digi-
tal currencies, with a market cap exceeding 3 billion USD [5].
There are also numerous businesses [1], exchange platforms,
and banks [14] that are currently built around the Bitcoin
ecosystem.

Transaction security is ensured in Bitcoin by means of
blocks which instantiate a hash-based Proof of Work (PoW)
mechanism; Bitcoin’s PoW requires 10 minutes on average
to be solved and 6 consecutive blocks are recommended to
conﬁrm any single transaction in the system. This suggests
that transactions will be conﬁrmed in the system after al-
most one hour—provided that the majority (>50%) of the
computing power in the network is honest.

Given the growing investments in Bitcoin, and the increas-
ing adoption by users, the security, scalability, and reliability
of Bitcoin has received considerable attention in the litera-
ture. Recently, several studies have challenged the security
assumptions adopted by Bitcoin [13, 19, 20]. For instance,
Eyal and Sirer [15] showed that selﬁsh miners that com-
mand more than 33% of the total computing power of the
network can acquire a considerable mining advantage in the
network. Additionally, Karame et al. [20] showed that the
measures adopted in Bitcoin to handle fast payments are
not enough to deter double-spending attacks, and proposed
a countermeasure which is currently integrated in Bitcoin.
Recently, Heilman et al. showed how to attack the Bitcoin
mining protocol by monopolizing the connections of nodes
in the system.

Given that the Bitcoin overlay network is densely con-
nected, most of these studies assume that all transactions
and blocks (and their order of execution) advertised in the
system will be almost immediately available to the majority
of Bitcoin nodes soon after their release into the network.
Recently, a number studies brieﬂy hinted on the possibil-
ity of delaying blocks [3] and transactions [2, 22] for a short
amount of time (e.g., for 2 minutes).

In this paper, we extend these observations and we show
analytically and experimentally that an adversary can deny
the delivery of blocks and transactions to victim Bitcoin
nodes for a considerable amount of time. By doing so, this
attack enables the adversary to alter the information re-
ceived by Bitcoin nodes, and to modify their views of the
ledger state. This is achieved by exploiting Bitcoin band-

692width optimization techniques and the measures that are in
place to tolerate network delays and congestion. The mini-
mal requirement for this attack to succeed in practice is sim-
ply that the attacker can establish at least one connection
to the victim. An even more powerful attack resulting in al-
most indeﬁnite delays at the victim node only requires that
the attacker can ﬁll the victim’s remaining open connection
slots—without necessarily causing any network partitioning
in the Bitcoin network.

Our results therefore motivate the need for a careful de-
sign of the scalability mechanisms adopted in Bitcoin. While
existing mechanisms limit the amount of propagated infor-
mation in the system to the minimum necessary, we show
that these techniques come at odds with security and reduce
the ability of the network to e.g., detect double-spending
attacks, resolve, or prevent blockchain forks. For instance,
our ﬁndings suggest that the 33% bound outlined by Eyal
and Sirer [15] might be even further reduced. Namely, if a
considerable fraction of miners does not rely on alternative
relay networks to receive network updates [4], then malicious
miners can temporarily prevent the propagation of recently
mined blocks in the network, in order to further increase
their advantage—while commanding less than 33% of the
total computing power in the network. In this respect, we
propose a modiﬁcation of the block request process in Bit-
coin to deter this misbehavior.

Our ﬁndings additionally uncover new vulnerabilities in
the Bitcoin network’s ability to handle fast payments. Fast
payments refer to payments where the time between the ex-
change of currency and goods is short (in the order of a
minute).
In light of the vulnerabilities discovered in [20],
Bitcoin incorporated a new countermeasure which consists
of relaying the ﬁrst double-spent transaction in order to en-
hance the security of fast payments [7]. In this respect, we
show analytically and experimentally that an adversary can
leverage our ﬁndings to circumvent this countermeasure and
double-spend fast payments without bearing any risk of los-
ing her money. We also show that payments which were only
conﬁrmed by few blocks might be reverted by the adversary.
Based on our ﬁndings, we explore a number of solutions to
deter this misbehavior and we estimate a lower-bound on
the waiting time required to ensure the security of fast pay-
ments.

More speciﬁcally, our contributions in this paper can be

summarized as follows:

• We analytically and experimentally conﬁrm that a resou-

rce-constrained adversary can abuse existing scalabil-
ity measures adopted in Bitcoin clients in order to deny
information about newly generated blocks and trans-
actions to Bitcoin nodes for at least 20 minutes. We
then extend this basic attack and show how an adver-
sary can continuously deny the delivery of such infor-
mation.

• We validate our analysis by means of implementation
using a handful of hosts located around the globe. Our
results demonstrate the feasibility and easy realization
of our attacks in current Bitcoin client implementa-
tions.

• We show that our results allow the adversary to con-
siderably increase its mining advantage in the net-
work, double-spend transactions in spite of the current
countermeasures adopted by Bitcoin, and easily mount
Denial-of-Service attacks.

• We propose a number of mitigations for hardening the
security of the network against such a misbehavior
without deteriorating the scalability of Bitcoin. Namely,
we propose a modiﬁcation of the block request man-
agement system in Bitcoin in order to detect any mis-
behavior in the delivery of blocks. Additionally, we
leverage our ﬁndings to estimate the minimum amount
of waiting time required to ensure, with considerable
probability, the security of fast payments in Bitcoin.

The remainder of the paper is organized as follows. In Sec-
tion 2, we overview Bitcoin and summarize the measures de-
ployed in the system to minimize the amount of propagated
information. In Section 3, we show how an adversary can
eﬀectively delay information propagation in the network. In
Section 4, we extend our analysis and discuss possible tech-
niques to continuously prevent the delivery of Bitcoin blocks.
In Section 5, we discuss the impact of our ﬁndings on the
security of Bitcoin, and we outline possible countermeasures
in Section 6. In Section 7, we overview related work in the
area, and we conclude the paper in Section 8.

2. SCALABILITY MEASURES IN BITCOIN
In this section, we overview Bitcoin, and summarize the

main scalability measures integrated in the system.

Background.

Bitcoin is a loosely-connected P2P network, where nodes
can join and leave the network at any moment. Bitcoin
nodes are connected to the overlay network over TCP/IP.
Initially, peers bootstrap to the network by requesting peer
address information from Domain Name System (DNS) seeds
which provide a list of current Bitcoin node IP addresses.
Newly connected nodes advertise peer IP addresses via Bit-
coin addr messages. Notice that a default full Bitcoin client
establishes a maximum of 125 TCP connections, of which
up to 8 are outgoing TCP connections.

Bitcoin transactions transfer coins (BTCs) among peers;
these peers are referenced in each transaction by means of
virtual pseudonyms—referred to as Bitcoin addresses. Each
address maps to a unique public/private key pair; these keys
are used to transfer the ownership of BTCs among addresses.
A Bitcoin transaction is formed by digitally signing a hash of
the previous transaction where this coin was last spent along
with the public key of the future owner and incorporating
this signature in the coin. Transactions take as input the
reference to an output of another transaction which spends
the same coins, and outputs the list of addresses which can
collect the transferred coins. A transaction output can only
be redeemed once, after which the output is no longer avail-
able to other transactions. Once ready, the transaction is
signed by the user and broadcast in the P2P network. Any
peer can verify the authenticity of a BTC by checking the
chain of signatures.

The diﬀerence between the input and output amounts of
a transaction is collected in the form of fees by Bitcoin min-
ers. Miners are peers, which participate in the generation
of Bitcoin blocks. These blocks are generated by solving a
hash-based proof-of-work (PoW) scheme; miners must ﬁnd
a nonce value that, when hashed with additional ﬁelds (e.g.,
the Merkle hash of all valid transactions, the hash of the pre-
vious block), the result is below a given target value. If such
a nonce is found, miners then include it in a new block thus
allowing any entity to verify the PoW. Since each block links

693to the previously generated block, the Bitcoin blockchain
grows upon the generation of a new block in the network.
A Bitcoin block is mined on average every 10 minutes and
currently awards 25 BTCs to the generating miner. It was
shown in [20] that Bitcoin block generation follows a shifted
geometric distribution with parameter 0.19. This also sug-
gests that there is considerable variability in the generation
times; for example, one of the longest block generation time
so far lasted almost 99 minutes (this corresponds to block
152,218).

During normal operations, miners typically work on ex-
tending the longest blockchain in the network. Due to the
underlying PoW scheme, however, diﬀerent miners can po-
tentially ﬁnd diﬀerent blocks nearly at the same time—in
which case a fork in the blockchain occurs. Forks are inher-
ently resolved by the Bitcoin system; the longest blockchain
which is backed by the majority of the computing power in
the network will eventually prevail.

Scalability Measures.

Currently, almost 1 transaction per second (tps) [1] is ex-
ecuted in Bitcoin; this results in an average block size of al-
most 400 KB1. In an experiment that we conducted, we mea-
sured the amount of traﬃc observed by a full Bitcoin node2;
our results show that Bitcoin nodes in- and outbound traﬃc
heavily depends on the number of connections of the node.
For instance, a node with about 70 connections witnesses
on average 8.5 GB daily traﬃc3, while a node with about
25 connections witnesses on average 3 GB traﬃc within 24
hours4. Given the increasing adoption of Bitcoin, the num-
ber of transactions, and the block sizes are only expected to
increase. For example, if Bitcoin were to handle 1% of the
transactional volume of Visa5, then Bitcoin needs to scale to
accommodate almost 500 tps—requiring considerably larger
blocks to be broadcasted in the network.

Motivated by these factors, the current Bitcoin protocol
implements various bandwidth optimizations, and measures
in order to sustain its scalability and correct operation in
spite of ever-increasing use. In what follows, we detail the
existing measures taken by Bitcoin developers.

Measure 1. Bitcoin combats the broadcasting of ill-formed

blocks and transactions by maintaining an internal reputa-
tion management system.

Whenever a node receives objects (e.g., blocks, transac-
tions), it checks their correctness before forwarding them
to other peers in the network. First, objects are validated
based on their respective syntax and sizes, e.g., oversized ob-
jects are discarded. If this veriﬁcation passes, the contents
of the objects are subsequently validated. For transactions,
this includes verifying the signature, the input and output
coins used in the transaction; similarly, the PoW included in
block headers is veriﬁed with respect to the current network
diﬃculty.

1The maximum block size is currently limited to 1 MB which
corresponds to less than 7 transactions per second.
2Our measurements were conducted over a period of 18 days,
during which our node had on average 70 active connections.
3Measured over 20 days.
4Measured over 2 days.
5Currently, the Visa network is designed to handle peak
volumes of 47,000 tps [9].

Node A

Node V

Node A

Node V

new block arrival

new transaction arrival

inv

s

g e t h e a d e r
a
t
g e t d a
headers
block

inv

a

t

g e t d a

transaction

Block transmission

Transaction transmission

Figure 1: Summary of the request management sys-
tem in Bitcoin.

To prevent any abuse of the Bitcoin overlay network (e.g.
Denial of Service attacks), a receiving node locally assigns
a penalty to peers who broadcast ill-formed objects. Once
a node has reached 100 penalty points, the receiving node
disconnects from the misbehaving node for 24 hours. For
example, if a node broadcasts invalid alerts, then it will be
given 10 penalty points. Nodes which attempt more serious
misbehavior, such as inserting invalid transaction signatures,
are immediately assigned 100 points, and therefore directly
banned. Penalties also apply to ill-formed control messages
such as inv (inventory) or addr commands. Notice that
locally assigned penalties are not transmitted to other peers.

Measure 2. Bitcoin uses an advertisement-based request
management system to minimize the information spread in
the network.

To minimize information spread in the network, messages
are propagated in the Bitcoin network with the help of an
advertisement-based request management system. Namely,
if node A receives information about a new Bitcoin object
(e.g., a transaction or a block) from another node, A will
advertise this object to its other connections (e.g. node V)
by sending them an inv message; these messages are much
smaller in size than the actual objects, because they only
contain the hash and the type of object which is advertised.
Only if node V has not previously received the object adver-
tised by the inv message, V will request the object from A
with a getdata request. Following the Bitcoin protocol, node
A will subsequently respond with a Bitcoin object, e.g., the
contents of a transaction or a block.

By doing so, inventory messages limit the amount of data
broadcast in the network. Notice that in case the object
advertised corresponds to a block, neighbor V ﬁrst requests
the block header before the actual block data. Here, when
a block header is advertised via a headers message, the re-
ceiving node internally stores the highest block known by the
sending peer. The receiving node also validates any received
header, by verifying its corresponding PoW. Transactions,
on the other hand, are requested directly using a transac-
tion inv message. This process is summarized in Figure 1.
To minimize bandwidth consumption, Bitcoin nodes re-
quest a given object only from a single peer, typically the
ﬁrst peer which ﬁrst advertises the object.
In an experi-
ment that we conducted, we measured the traﬃc (cf. Fig-
ure 2) witnessed by a default Bitcoin client over a period

694140

120

100

80

60

40

20

r
u
o
h
r
e
p
s
e
t
y
b
a
g
e
M

0

1

inv

tx

block

3

5

7

9

11 13 15 17 19 21 23

Hours of trafﬁc capture

)
s
(

l

a
v
e
i
r
t
e
r

k
c
o
b

l

r
o
f

e
m
T

i

160

140

120

100

80

60

40

20

0

1400

1200

1000

800

600

400

200

0

256 Kbit/s
downstream

500 Mbit/s
downstream

Figure 2: Hourly traﬃc distribution of a Bitcoin
node, up and downstream, over 24 hours, w.r.t. to
diﬀerent Bitcoin messages. Here, ‘tx’ denotes trans-
actions.

Figure 3: Block transmission times with respect to
the connection speed. Here, we evaluate the time
to download 400 consecutive Bitcoin blocks on a
500 Mbps and 256 Kbps connection.

of 24 hours6. We observe that, indeed, the transmission of
blocks consumes a signiﬁcant part of the bandwidth of our
client. Requesting the same object from multiple peers en-
tails downloading the same data several times, and therefore
can only increase the bandwidth consumption of the system.

node, 0.5% of the generated blocks exceeded the 20 minute
timeout adopted by current clients. This shows that the
current timeouts adopted in Bitcoin when sending/receiving
blocks are indeed necessary for the correct delivery of blocks
in the network.

Measure 3. Bitcoin relies on static timeouts in order to
prevent blocking while tolerating network outages, conges-
tion, and slow connections.

Given that Bitcoin runs atop an overlay network, com-
munication latency and reliability pose a major challenge to
the correct operation of the system. Currently, Bitcoin re-
lies on timeouts in order to tolerate network delays—while
preventing blocking. Blocking can occur e.g., when a node
stops responding during communication.

For example, in Bitcoin version 0.10, the Bitcoin develop-

ers introduced a block timeout download of 20 minutes7.

Similarly, for transactions, the Bitcoin developers intro-
duced a 2-minute timeout. Notice that the choice of the
timeout is a non-trivial task and depends on a number of
parameters such as bandwidth, object size, latency, process-
ing power, and the Bitcoin version of each node. On the one
hand, overly long timeouts might deteriorate the quality of
service of the whole network and can be abused to conduct
e.g., double-spending attacks [8]. On the other hand, short
timeouts might hinder eﬀective communication under vary-
ing network conditions, or when communicating with slow
peers.

In an experiment that we conducted, we measured the
block transmission times in Bitcoin with respect to the nodes’
bandwidths. Our results (cf. Figure 3) show that block re-
trieval times signiﬁcantly vary depending on the connection
of the node. For instance, fast nodes with 500 Mbps down-
stream take an average of 1.55 seconds to download a block,
while slow nodes equipped with a 256 Kbps connection take
an average of 71.70 seconds to download blocks. It is inter-
esting to note that, during our measurements on the slow

6During our measurements, the client was connected to ap-
proximately 30 neighbors.
7Available from https://github.com/bitcoin/bitcoin/
pull/5608

Measure 4. Bitcoin clients keep track of the order of
the received transaction advertisements. If a request for a
given transaction is not delivered, the next peer in the list is
queried.

When a transaction T is advertised via an inv message
to a given node, the latter keeps track of the order of an-
nouncements with a ﬁrst-in ﬁrst-out (FIFO) buﬀer. Each
time a peer advertises T , the peer is inserted in the buﬀer.
Transaction T is only requested from one peer at a time. For
each entry in the buﬀer, Bitcoin clients maintain a 2-minute
timeout, after which, the next entry in the buﬀer is queried
for T .

3. DELAYING INFORMATION DELIVERY
In this section, we show how an adversary can exploit
the scalability measures of Bitcoin’s request management in
order to delay the delivery of message advertisements.

For the purpose of our analysis, we assume that the ad-
versary A is a full Bitcoin node, and has access to the entire
blockchain. Here, the objective of A is to deny the delivery
of an object O for a short period of time from a speciﬁc node
denoted by V. In Section 4, we extend this analysis and show
how an adversary can arbitrarily prolong the prevention of
message delivery.

3.1 Necessary Requirements

We start by outlining the necessary conditions which need
to be satisﬁed for A to successfully prevent the delivery of
object information from a given Bitcoin node V.

Requirement 1: A must be the ﬁrst peer to send a mes-
sage advertisement of object O to V.
If V requests
an object O from a node which is not under the con-
trol of A, then little can be done by A to prevent
the node from sending O to V. However, if A is able

695to ﬁrst advertise O via an inv message to V, then V
will temporarily abstain from requesting O from any
other node in the network. As explained earlier, Bit-
coin nodes only request the same data element from a
single peer in order to minimize bandwidth consump-
tion (cf. Measure 2). In order to be the ﬁrst to ad-
vertise an object O to V, A needs to be an immediate
neighbor of V in the Bitcoin overlay network (i.e., there
is a direct TCP connection between A and V).

Requirement 2: V should wait suﬃciently long after a get-
data message before requesting the data from another
peer [22]. The longer V waits for A to send O, the
more damaging is the misbehavior of A (cf. Section 5).
As mentioned earlier, current Bitcoin implementations
inﬂict a timeout of 20 minutes on V for blocks, and 2
minutes for transactions; after the timeout, V can re-
quest O from another node (cf. Measure 3).

In what follows, we show how these requirements can be
satisﬁed.

Satisfying Requirement 1.

As mentioned earlier, Bitcoin nodes verify the correct-
ness of every received object before they re-broadcast it in
the network. Notice that this process requires considerable
time; for example, when receiving transactions, nodes verify
the transactions’ signatures, and check that the input coins
have not been spent previously. Similarly, for blocks, nodes
check the correctness of the PoW in relation with the cur-
rent diﬃculty in the network, and verify the correctness of
every transaction that is conﬁrmed in the block.

This oﬀers a clear advantage for an adversary in order
to satisfy Requirement 1.
Indeed, an adversary can sim-
ply forward a given object of choice O immediately after it
receives it—without verifying its correctness. Since all re-
maining nodes in the system will have to perform a series of
veriﬁcation steps to verify O, the adversary is likely to be
the ﬁrst node to advertise O to its neighbors. As explained
in Measure 2, this ensures that A’s neighbors will not re-
quest the object from any other node in the network until
the timeout expires. Notice, that if A is interested in deny-
ing the delivery of O to a speciﬁc node V, then the adversary
can advertise O solely to V. Here, in the case where O is
created by A (e.g., O is a transaction), A can satisfy Re-
quirement 1 by ﬁrst advertising O to V, before broadcasting
it in the network.

We stress here that A should be directly connected to
V. This is a reasonable assumption, since most full Bitcoin
nodes do not exhaust their maximum 125 connections; in
typical cases, nodes are therefore likely to accept connection
request originating from A. Notice that if V does not accept
incoming connections (e.g., is located behind a NAT or ﬁre-
wall), Requirement 1 can also be satisﬁed if V connects to A
(i.e., by requesting an outbound connection). Alternatively,
A can try to compromise a neighbor of V.

Satisfying Requirement 2.

To optimize bandwidth, recall that objects are only re-
quested from one peer at a time (cf. Measure 2). This
means that if A is the ﬁrst node to advertise O to V, V will
simply wait for A to send O and will not request the same
object from any other peer. During this period, A simply
has to respond to the active ping messages of V. Notice that

Adversary

inv

Proxy

inv

inv

Victim

Victim

inv

inv

i n v

Bitcoin network

Figure 4: Satisfying Requirement 1. The adversary
can use a simple relay proxy to forward inv mes-
sages without validating the correctness of the cor-
responding object.

if A does not actively respond to ping messages from V in
this period, then V disconnects eventually before the object
transmission timeout.

For blocks, the default timeout for V is set to 20 minutes;
transactions, however, have a waiting timeout of 2 minutes.
Given Measure 4, it is easy for A to increase the timeout
for transactions simply by sending x back to back inv mes-
sages for the same transaction. By doing so, A eﬀectively
increases the timeout speciﬁc to the advertised transaction
by 2x minutes. We validate this analysis experimentally in
Section 3.2.

3.2 Experimental Validation

In what follows, we empirically assess the probability that
A succeeds in relaying ﬁrst an inv message of an object O
to a given node V (cf. Requirement 1). For this purpose,
we implement a proxy which relays speciﬁc inv messages
directly before passing them to the Bitcoin software. Based
on this proxy, we evaluate how likely A can be the ﬁrst node
to advertise an inv message to V.

Our experimental setup is sketched in Figure 4. Here, we
assume that A is located in Europe and operates an Intel
i7 CPU (3.40GHz) with 32 GB RAM and a 500/400 Mbps
Internet connection. In our setup, A connects to V through
a direct TCP connection.

To remove any bias that might occur from a given net-
work topology, we consider 10 diﬀerent nodes emulating V
geographically dispersed around the globe. We also vary
the connectivity of A and V during our measurements (i.e.,
between 40 and 800 TCP connections to diﬀerent full Bit-
coin nodes for A and between 40 and 200 for V). Because
only full Bitcoin nodes forward blocks and transactions, only
connections to full Bitcoin nodes are relevant for this exper-
iment. We, therefore, modify the Bitcoin client, such that
only connections to full Bitcoin clients are established and
such that the maximum connection limit is kept constantly.
N , that A satisﬁes
Requirement 1 as follows. We relay N advertisements for
objects to V, and we compute the number of getdata and
getheaders replies r originating from V received within the
subsequent 30 seconds; recall that these messages provide
suﬃcient evidence that A is the ﬁrst relayer of an object to
V, and as such V will not request this object from elsewhere.

We measure the probability Pr = r

Denying the Delivery of Blocks.

We start by investigating the success probability of A in
denying the delivery of blocks. Here, for diﬀerent combina-
tions of the number of connections of A and V (cf. Table 1),

696we forward N = 100 blocks generated after block height
350,000 and compute Pr.

Recall that to prevent the delivery of a block object O, A
needs to directly relay the inv corresponding to O, without
validating it. By doing so, A is faster in relaying the inv mes-
sage than any other node in the system. To better assess the
advantage of A in this case, we measured the time required
to validate 100 blocks (from block height 353,000 onwards).
Our results show that a single block requires on average 174
milliseconds to validate on an Amazon EC2 dual-core in-
stance; notice that most of the overhead is spent in verifying
the correctness of the transactions. In addition to the net-
work latency for retrieving a Bitcoin block (cf. Measure 3),
this gives 174 milliseconds advantage on average for A to
succeed in denying the delivery of a block object.

In Table 1, we measure Pr with respect to (i) the location
of V, (ii) A’s number of connections and (iii) V’s number
of connections (cf. Requirement 1). By gradually increasing
the number of connections of A from 40 to 800, we observe,
that A’s success increases with more connections. Namely,
our results show that Pr ≈ 0.89 when A has 800 connec-
tions. The more connections A maintains, the bigger is A’s
likelihood to receive a new block inv message before V. Sim-
ilarly, by gradually increasing the number of connections of
V from 40 to 200, we observe, that the adversary’s success
decreases when V maintains more connections. We do not
observe a strong correlation between the physical location,
and the resulting network latency from A to V. This implies,
that it is crucial for A to be connected to nodes advertising
blocks ﬁrst.

In summary, our results clearly indicate that an adversary
can successfully prevent the delivery of blocks to a particular
node with considerable probability.

In another experiment, we measured the amount of time
that a particular Bitcoin block can be denied to V (cf. Re-
quirement 2). Here, when A forwards a block B successfully
as a ﬁrst node to V, A actively responds to V’s ping requests,
but refrains from answering with a block message. We re-
peated this experiment for a number of times and observed
that in all cases, V actively disconnects from A after exactly
20 minutes.

Notice that the costs borne by A to deny V a given block
are modest. Namely, A needs to maintain an active TCP
connection with V and to frequently reply to V’s ping re-
quests. Moreover, A needs to simply transmit 101 bytes
comprising the inv message (i.e., 40 bytes for IP and TCP
header, and 61 bytes for an inv message advertising one
block object).

Denying the Delivery of Transactions.

In the following, we investigate the probability of A in
successfully denying the delivery of a transaction. In our ex-
periments, we assume that the transaction T is created by A
(for the reasoning why, refer to Section 5.2), and therefore, A
is guaranteed to be the ﬁrst node to relay the corresponding
inv message.

Our evaluation is conducted as follows. We connect only
two nodes to V; one node corresponds to a machine con-
troller by A, while the other node C emulates an honest
machine in the Bitcoin network. In our experiments, A cre-
ates an inv message for transaction T and forwards the inv
to V and C. Upon reception of the inv message, C also for-
wards the message to V. This captures a realistic transaction

announcement in the Bitcoin network. We repeated this ex-
periment 100 times during which A was able to successfully
deny the delivery of T each time for 2 minutes. Namely,
for all 100 experiments, V was always requesting T with a
getdata message from A, which was not responding to the
request. After 120 seconds, V issued a getdata request for T
to the other node C.

We then extended this attack such that A sends T ’s inv
message 10 times to V, even before C issues T ’s inv message.
We repeated this experiment 100 times during which V did
not request T from any other peer for a period of 20 min-
utes. This is consistent with our observations in Section 2.
Namely, every node which advertises a transaction object T
is inserted in a FIFO buﬀer and allocated a 2-minute time-
out to deliver T . After 2 minutes, T is requested from the
next node in the FIFO buﬀer. By advertising T x-times,
the adversary can therefore deny the delivery of T for 2x
minutes and arbitrarily extend the denial time.

We point out that the communication overhead of this
attack basically consists of 101 bytes for each 2 minutes of
delay8.

4. EXTENDING THE BLOCK DELIVERY

TIME

We explained in Section 3.2 how A can deny the delivery
of a block object to V for at least 20 minutes. In this sec-
tion, we build on our ﬁndings and study the possibility of
extending the time a block is denied from V. The necessary
requirements are that (i) V accepts at least one connection
from A, and (ii) A is capable of ﬁlling V’s remaining open
connection slots. For example, if V maintains 50 connec-
tions, A initiates one connection for advertising block inv
messages, and ﬁlls the remaining 125 − 51 = 74 open con-
nection slots with default Bitcoin connections. Note that
V’s existing 50 connections do not prevent the attack.

In Bitcoin, blocks are transmitted by performing a header-
ﬁrst synchronization. Given the header of a block, any node
can ﬁnd the longest chain and verify the proof of work. Once
the headers have been synchronized, Bitcoin nodes can se-
lectively request the corresponding blocks from their peers.
Headers are typically synchronized on two diﬀerent occa-

sions:

1. If V receives a new, previously unknown block inv ad-
vertisement from a peer A, V actively requests the
block headers from A with a getheaders message.

2. Once a node A connects to V, both nodes exchange a
Bitcoin version message. Each version message con-
tains a counter for the most recent block height the
respective node is aware of. If A has a higher block
height than V, V actively requests the block headers
from A with a getheaders message.

The header-ﬁrst synchronization is especially important
for the purpose of our analysis, since it allows V to actively
request a block from its peers as soon as it learns about new
headers. More speciﬁcally, if A prevents the delivery of block
B to V and V receives B’s header from another peer, then A
can prevent the delivery of B for at most 20 minutes. That
is, because after 20 minutes, V actively disconnects from A
and requests the block B from another peer. Clearly, if the
latter peer is not under A’s control, then V is likely to syn-

8Note that multiple inv messages could be embedded into
one inv message in order to lower the TCP overhead.

697Connections of A
Connections of V

Victim node
Zurich
Frankfurt
Ireland
N.Virginia
Oregon
N.California
Tokyo
Singapore
Sydney
S˜ao Paulo

Average Pr

40
40

Pr
0.63
0.29
0.67
0.55
0.38
0.36
0.55
0.40
0.31
0.29

80
40

Pr
0.40
0.46
0.47
0.92
0.80
0.46
0.86
0.51
0.37
0.45

200
40

Pr
0.97
0.61
0.94
0.88
0.82
0.83
0.96
0.76
0.60
0.63

800
40

Pr
0.90
0.83
0.85
0.96
0.90
0.96
0.98
0.92
0.77
0.83

80
80

Pr
0.35
0.29
0.24
0.34
0.36
0.68
0.22
0.63
0.35
0.20

80
200

Pr
0.29
0.34
0.18
0.18
0.12
0.25
0.16
0.19
0.21
0.20

avg. latency A, V (ms)

0.95 ± 0.3
43.1 ± 0.3
28.6 ± 0.5
91.0 ± 0.0
171.0 ± 3.0
180.0 ± 0.0
246.0 ± 4.9
303.0 ± 4.6
303.0 ± 4.6
400.0 ± 6.3

0.44 ± 0.14

0.57 ± 0.20

0.80 ± 0.14

0.89 ± 0.07

0.37 ± 0.16

0.21 ± 0.06

176.67 ± 128.3

Table 1: Pr with respect to the number of connections of A and V. Each experiment is measured over 100
consecutive blocks and across 10 diﬀerent geographical locations. Each data point of Pr corresponds to the
average of 100 measurements; where appropriate, we report the standard deviation (labelled as ‘±X’). Note
that we exclusively report the number of connections to full Bitcoin nodes.

chronize with the current main blockchain in the network. If
V, however, does not receive the header for block B, V does
not actively request block B from another peer after the 20-
minute timeout, even if V received the block inv message
from additional peers during the 20-minute timeout.

In order to continuously deny the delivery of block infor-
mation from V, A therefore needs to make sure that V does
not receive block headers from the network. This can be
achieved when the following two conditions are met.

First relayer for all blocks: A must be the ﬁrst node to
forward all block inv messages to V. For example,
when A starts to deny the delivery of block B from V,
and wants to deny the delivery of all blocks up to and
including block B + 5, A needs to be the ﬁrst node
relaying all block inv messages between and including
B and B + 5. Note that after a 20-minute timeout,
A is required to resend the corresponding block inv
message before other peers. Other nodes are unlikely
to advertise older blocks, and therefore A can reliably
extend the time a block is denied.

Connection depletion: In the mean time, V must not re-
ceive a new version message from another peer. This
can be ensured if A can keep all remaining open con-
nection slots of V occupied, such that V does not re-
ceive any version message from other peers. Notice
that existing connections do not exchange version mes-
sages and, do not impact this condition.

We exemplify the process of denying the delivery of 2 con-
secutive blocks in Figure 5. Here, we assume that V success-
fully receives B’s header and appends block B to its local
chain. Once block B + 1 is found, A prevents it from being
delivered to V . Here, a 20-minute timeout for A starts for
block B + 1. Once block B + 2 is found, A also prevents
the delivery of this block to V. Here again, a 20-minute
timeout for A starts for block B + 2. When the timeout
for block B + 1 expires, V does not actively request a block,
because it has not learned about any new headers. V would
only receive the headers if V establishes a new connection
to a peer with an up-to-date blockchain, or receives B + 1’s
inv message from another peer after the timeout. A now,
however, can re-advertise block B + 1 and thus re-activate
another 20-minute timeout for block B + 1.

y
t
i
l
i

b
a
b
o
r
P

1.0

0.8

0.6

0.4

0.2

0.0

0

P x
r

Expected success based on Pr=0.83

5

10

15

20

25

30

Number of consecutively denied blocks

Figure 6: P x
r w.r.t. the number x of consecutively
denied blocks. Here, A maintains 80 and V between
11 and 25 connections to full Bitcoin nodes.

Now, assume that when block B + 3 is found, A is not
the ﬁrst node to relay B + 3’s inv message. V consequently
requests getheaders and getdata from the advertising peer.
Because blocks B +1 and B +2, however, are currently being
awaited from A, V only receives block B + 3. In order to
validate block B + 3 in the main blockchain, V requires the
intermediate blocks B + 1 and B + 2. When the timeout
for B + 2 expires, V disconnects from A and requests block
B + 2 immediately from another peer. Still, V is not able to
connect B + 2 and B + 3 to the blockchain, because B + 1
is missing. Finally, when the timeout for B + 1 expires,
V requests block B + 1 from another peer and is able to
synchronize with the main blockchain.

Let P x

r denote the probability that A can successfully
prevent the delivery of x consecutive blocks. Clearly, the
delivery of diﬀerent blocks is an independent process, then
P x
r = (Pr)x, where Pr denotes the average probability of
denying the delivery of a single Bitcoin block. We conﬁrm
this analysis by means of experiments in the following para-
graphs.

698Miner

block B
found

block B+1

found

block B+2

found

block B+3

found

Node A

headers: B
mainchain: B

headers: B+1
mainchain: B+1

headers: B+2
mainchain: B+2

headers: B+3
mainchain: B+3

Action:

does not attack

denies
block B+1 from V

denies
block B+2 from V

fails at denying
block B+3 from V

Node V

headers: B
mainchain: B

headers: B
mainchain: B

headers: B
mainchain: B

headers: B+3
mainchain: B

headers: B+3
mainchain: B+3

Action:

synchronizes correctly

does not learn about
B+1 header or block

does not learn about 
B+2 header or block

learns about block B+1,
header B+3, B+2 and B+1

learns about
block B+1

time

Timeouts of V
for block B+1

Timeouts of V
for block B+2

20-minute timeout for B+1

advertising inv

V does not
request a
block

20-minute timeout for B+1 V requests block B+1

from another peer

advertising inv

20-minute timeout for B+2 V requests block B+2

from another peer

advertising inv

Figure 5: Example process of denying the delivery of multiple blocks. Here, A succeeds to deny the delivery
of 2 consecutive blocks.

Experimental Validation
In what follows, we assess the probability P x
r that an ad-
versary A can prevent the delivery of at least x blocks from
V.

Our experimental setup is designed as follows. The ad-
versary, in addition to trying to be the ﬁrst to advertise
consecutive blocks, makes sure that V does not establish
new connections by ﬁlling all remaining connection slots of
V. In our setup, we attempt to continuously prevent the de-
livery of blocks to 5 diﬀerent nodes (emulating 5 diﬀerent V)
running the default Bitcoin clients9. During our study, the
nodes’ connections to full Bitcoin nodes10 varied over time
(cf. Figure 7). On the other hand, the adversary maintained
at all times a ﬁxed number of 80 connections to full Bitcoin
clients. Here, all of the machines emulating V were located
in Europe, with a latency below 200ms to A.

In our experiments, the adversary performed a total of
2849 block denying attempts on all 5 nodes; A was successful
in denying the delivery of a total of 2364 blocks—resulting
in Pr = 0.83. In Figure 6, we measure P x
r , the probability to
prevent the delivery of at least x blocks, as follows. We count
the number of consecutive blocks, x, that are only requested
(i.e., using a getheaders and getdata) from the adversary.
Here, if we do not receive a getheaders and getdata message
within 30 seconds for a given advertised block or any inter-
mediate re-advertised block, we assume that the victim has
requested that block from elsewhere, compute the resulting
x, and restart the process. Our results (cf. Figure 6) con-
ﬁrm the analysis in Section 4, indeed show that P x
r ≈ (Pr)x
and indicate that the adversary can succeed in preventing
the delivery of consecutive blocks with considerable proba-
bility. For instance, the probability to prevent the delivery
of 5 consecutive blocks is approximately 0.4.

In Figure 7, we evaluate the number of consecutively de-
nied blocks with respect to the number of connections of V.

9These nodes were synchronized to the blockchain for almost
72 hours and had 11 to 25 connections to full Bitcoin nodes.
10Recall that lightweight Bitcoin clients do not forward
blocks or transactions and are therefore not relevant for our
study.

V

f
o

s
n
o
i
t
c
e
n
n
o
c

e
d
o
n

l
l

u
F

26

24

22

20

18

16

14

12

10

Regression line

0

5

10

15

20

25

30

Consecutively denied blocks

Figure 7: Number of consecutively denied blocks
w.r.t. the connections of V. Here, A maintains 80
full Bitcoin node connections.

Our results conﬁrm our previous observation (cf. Table 1)
that the fewer connections V maintains, the more blocks can
be denied. Recall that the more connections a node has (to
full nodes), the earlier the node can receive information from
the network.

5.

IMPLICATIONS

In the previous sections, we thoroughly investigated how
Bitcoin’s request management system can be abused by a
malicious adversary in order to delay information delivery
in the Bitcoin network.
In what follows, we evaluate the
impact of our ﬁndings on the security of the Bitcoin system.

5.1 Increasing Mining Advantage

In [15], Eyal and Sirer show that a mining pool which con-
trols more than 33% of the computing power in the network
can considerably increase its mining advantage (by more
than 10%) by withholding its mined blocks until new blocks
are found in the network. We show in what follows that the

69933% bound of Eyal and Sirer can be even further reduced
by leveraging our ﬁndings.

[P(1-P)+(1-P)](1-α)

α

(1-α)

(1-α)(1- )

1-α

0

α

1

α

2

1-α

1-α

α
1-α

3

α
1-α

4

...

α
1-α

Figure 8: Selﬁsh mining state machine adapted from
Eyal and Sirer [15].

Eyal and Sirer’s Selﬁsh Mining.

In the selﬁsh mining game (adapted from [15]), a selﬁsh
miner does not directly announce its newly mined blocks in
the network and instead keeps them secret, until the remain-
ing network ﬁnds new blocks. This strategy is captured in
the state machine shown in Figure 8.

The state machine depicts the adversary’s view on the
current state of the selﬁsh mining attack.
In state 0, A
and the network have the same view of the currently longest
blockchain. A controls a fraction α of the computing power
in the network, and is therefore likely to mine a block with
probability α. With probability 1 − α, the network ﬁnds and
publishes a block, leading to state 0. Once A, however, ﬁnds
a block, she keeps it secret from the network and state 1 is
reached. Moving on, diﬀerent cases can arise.

First, the network can ﬁnd a competing block BN with
probability 1 − α, moving the state to 0′. In this case, A
has an incentive to spread his single secret block BA in the
network as fast as possible, such that a fraction γ of the
network continues mining on BA. Namely, γ is the fraction
of the network that received BA before BN . Subsequently,
three cases arise: (i) A ﬁnds a block with probability α, (ii)
the network ﬁnds a block by building upon BA with proba-
bility (1 − α)γ, or (iii) the network ﬁnds a block building on
BN , with probability (1 − α)(1 − γ). For A, these three cases
generate two, one and zero block rewards, respectively.

Second, A can ﬁnd a second block and also keep it secret,
moving to state 2. Reaching state 2 guarantees A at least
two block rewards. If the network ﬁnds a block (transition
from 2 → 0 with probability 1 − α), A can publish the two
secret blocks, generate the longest chain and earn two block
rewards. A keeps additional blocks secret moving to states
further right and publishes these blocks individually while
moving left in the state machine whenever the network ﬁnds
a block.

Beyond Selﬁsh Mining.

To deter this misbehavior, Eyal and Sirer [15] propose the
following countermeasure. When a miner is aware of two
competing blocks, the miner should propagate both blocks
and select a random block to mine on. This solution does not
take into account the case where an adversary can selectively
deny miners from receiving a particular block—as conﬁrmed
by our results.

Even worse, by preventing the delivery of blocks to a frac-
tion of the network, an adversary can create multiple virtual
partitions in the network—each mining on diﬀerent blocks.
As we show below, this grants the adversary with an addi-
tional advantage in the selﬁsh mining scenario. Notice that

...

1-α

2

...
1-α
(1-P)(1-α)
21
P:
1-P:

0
1'

α

1-α

α

3

...

α

1-α

31
P:
1-P:

0
1'

...

α

(1-P)(1-α)

P(1-α)

...

P(1-α)

22
    P²:
P(1-P):
    1-P: 

0
1''
1'

P²(1-α)

...

32
    P²:
P(1-P):
    1-P: 

0
1''
1'

...

α

P²(1-α)

...

α

...
...

Figure 9: Extending Eyal and Sirer’s state machine
to capture the case where a selﬁsh miner can deny
the delivery of recently mined blocks to a fraction P
of the network.

miners can make use of additional relay networks in order to
receive blocks and transactions faster than the oﬃcial P2P
network can provide [6]11. For instance, Matt Corallo’s relay
network [6] is optimized to transmit blocks and transactions
as fast as possible, and is designed as a fallback mechanism
for the oﬃcial P2P network. Namely, Corallo’s relay net-
work does not follow the inv and getdata protocol of the
oﬃcial P2P network, but instead directly relays blocks and
transactions. Clearly, miners which rely on an additional
relay network will immediately receive information about
blocks and transactions. In what follows, we show that the
advantage of an attacker is considerable in selﬁsh mining as-
suming that a fraction 1 − P of the miners is connected to
the additional relay network.

To this end, we extend the state machine from Eyal and
Sirer by modeling the fact that A can deny the delivery
of blocks to a fraction of the mining power. The modiﬁed
state machine is depicted in Figure 9. Let’s assume that the
adversary currently reached state 3, representing 3 secret
blocks. With probability 1 − α the honest network ﬁnds a
block B1′ , resulting in state change to state 21. A manages
to deny the delivery of this block to a fraction P of the
network, and consequently, only a fraction 1 − P has learned
about the new block B1′ . Three states arise: (i) the fraction
1 − P ﬁnds a block (with probability (1 − P )(1 − α)) and
A publishes his remaining 2 secret blocks, resulting in state
0; (ii) A ﬁnds a block with probability α (resulting in state
31), or (iii) the fraction P which has not yet seen block B1′
ﬁnds with probability P (1 − α) a block resulting in state
22. All other cases follow the same principle; A virtually
partitions the miners by denying the delivery of new blocks
to other honest miners. This strengthens the selﬁsh mining
game as it leads to even more wasted computations by the
honest miners.

Based on the state machine of Figure 9, we measure the
revenue of the adversary in comparison with ﬁndings of [15].
For this purpose, we simulate both state machines; in each

11Note that some of the largest mining pools do not make
use of the relay network [4].

7001.0

0.8

0.6

0.4

0.2

e
u
n
e
v
e
r

l
o
o
p
e
v
i
t
a
l
e
R

0.0

0.0

P = 0.250, consec. denied blocks = 2
P = 0.500, consec. denied blocks = 2
P = 0.500, consec. denied blocks = 5
Honest mining

Network control
γ = 0.00 [Eyal]
γ = 1.00 [Eyal]

0.1

0.2

0.3

0.4

0.5

Pool size

Figure 10: Relative revenue gain of selﬁsh miners
with and without the delaying of block information.
For our simulations, we assume γ = 0 and always
perform better than [15].

state, our simulator chooses the next state by generating the
probability distribution of the possible transitions according
to the given parameters. We performed up to 1,000,000
iterations for both state machines and per data point of
Figure 10. Here, we assume that A is able to deny the
delivery of 2 and 5 consecutive blocks with probabilities 0.5
and 0.25, respectively. This assumption conforms with our
ﬁndings in Section 4. To compute the revenue, we adapt the
scheme from [15]; we refer the readers to Appendix A for
more details on the adopted revenue estimation.

Our results (cf. Figure 10) show that the 33% bound ad-
vertised by Eyal and Sirer can be considerably lowered. For
instance, an adversary which succeeds in denying the de-
livery of 2 consecutive blocks from 50% of the network will
proﬁt from selﬁsh mining if he controls 26.5% of the comput-
ing power in the network. This adversary eﬀectively controls
the Bitcoin mining network given only 35% of the actual
computing power—even if 50% of the miners leverage an ad-
ditional relay network to receive transactions/blocks. Even
worse, our results show that an adversary (with P = 0.5
and 5 consecutively denied blocks) which commands less than
34% of the computing power in the network can eﬀectively
sustain the longest block chain and therefore control the en-
tire network.

5.2 Double-Spending

In what follows, we show how an adversary can lever-
age our ﬁndings to double-spend (i) fast payments in which
the corresponding transactions have not yet been included
in any block of the main blockchain (also referred to as
zero-conﬁrmation transactions) [8], and (ii) 1-conﬁrmation
transactions, i.e., transactions which have been already con-
ﬁrmed in one Bitcoin block in the main blockchain. No-
tice that zero-conﬁrmation and one-conﬁrmation transac-
tions are common to handle payments in which the time
between exchange of the currency and goods is short.

Here, we assume that the adversary A creates two trans-
actions Td and Tl sharing the same input coins. Td is a
transaction whose output addresses are owned by A, while

4. Send Tl

Vendor

Figure 11: Circumventing the double-spend relay
protection of Bitcoin XT.

the outputs of Tl are owned by a vendor V. Similar to [8],
the goal of A is to convince V to accept Tl, acquire service
from V, while ensuring that Td is conﬁrmed by miners and
included in the main blockchain.

Double-Spending of Zero-Conﬁrmation Transactions.

Zero-conﬁrmation transactions are essential for the oper-
ation of several businesses. Recall that Bitcoin blocks are
generated within 10 minutes on average which prevents the
daily operation of businesses where the exchange between
the currency and the service is short (e.g. in the order of few
minutes). In light of the double-spending analysis in [20], an
enhanced version of Bitcoin, referred to as Bitcoin XT [7],
currently broadcasts the ﬁrst double-spend transaction in
the network. This allows a vendor to observe any double-
spending attempt for an upcoming payment, and to conse-
quently deny the processing of a fast payment. By Febru-
ary 2015, almost 16 full nodes in the Bitcoin network had
adopted the double-spend relay protection of Bitcoin XT.

Motivated by our ﬁndings, we show in what follows that
the protection of Bitcoin XT is not eﬀective in preventing
double-spending attacks of fast payments. We also show
that an adversary can perform double-spending attacks—without
the risk of loosing money.

To do so, the adversary ﬁrst sends an inv message adver-
tising Td to V; this prevents V from receiving Td from the
network—in spite of the protection embedded in Bitcoin XT.
A subsequently broadcasts Td in the network, and sends Tl
to V shortly after (cf. Figure 11). From the viewpoint of V,
Tl does not conﬂict with any other transaction, and there-
fore the trade can be concluded. Although other nodes in
the network can observe the two conﬂicting transactions, Td
and Tl, and issue the corresponding warnings, V cannot re-
ceive Td from its neighbors, and is therefore unable to detect
this attack. Shortly after, the ﬁrst observed transaction in
the network (i.e. Td) is typically included in the blockchain.
A can further prevent nodes in the network from detecting
the attack, as follows. Similar to before, A issues Td in the
network, while denying its delivery to V (e.g. for a 20 minute
period). As soon as Td is conﬁrmed in a block Bd, A directly
prevents the delivery of Bd to V by sending the latter an inv
advertising Bd (cf. Section 3.2). This ensures that V does
not receive Bd from the network for at least 20 minutes.
In the meantime, A sends Tl to V which will broadcast it
in the network. Because Bitcoin XT, however, only relays
conﬂicting transactions from the memory pool, a pool of
not yet conﬁrmed transactions, Tl is not considered double-
spent. Tl, nonetheless, is considered a conﬂicting transaction
w.r.t. the already conﬁrmed Td, and therefore is not relayed
in the network.
In this way, A does not bear any risk of

701loosing her money since Td was already included in a block
and will likely be accepted by most nodes in the network.

We empirically conﬁrm our analysis using a testbed com-
prising of three Bitcoin nodes emulating a vendor V, the
adversary A and a Bitcoin XT node12. All three nodes main-
tain a direct TCP connection in order to exchange Bitcoin
transactions. We performed the aforementioned double-spending
attack a number of times; our results conﬁrm that although
the Bitcoin XT node attempts to broadcast Td, V does not
receive Td. This clearly shows that the protection of Bitcoin
XT cannot deter double-spending.

Double-Spending of 1-Conﬁrmation Transactions.

Notice that if A is connected directly to a (honest) miner
M, then A can also attempt to double-spend a transac-
tion Tl which has already been conﬁrmed by one block Bl
in the blockchain.
In this case, the only means for A to
double-spend Tl would be to include the double-spending
transaction Td in a fork of the blockchain. Recall that forks
frequently occur in the Bitcoin network [13], and are re-
solved automatically by choosing the longest fork chain. If
the blockchain fork, which contains Td, eventually emerges
as the longest fork, Td will be accepted by the majority of
the peers in the network and double-spending is successful,
since V can no longer redeem Tl.

To double-spend Tl, A connects directly to both V and
M in order to prevent the delivery of Td to both prior to
broadcasting it in the network. As mentioned earlier, this
ensures that V and M do not receive Td, but the rest of the
network receives and mine for blocks which conﬁrm Td. A
then sends Tl to M, with the aim that M conﬁrms Tl in a
block.

With some probability, the Bitcoin network eventually in-
cludes Td in block Bd. Because Bd contains the double-
spend transaction Td, A has to again prevent Bd from being
received by V and M. Later on, if M ﬁnds and broadcasts
a block Bl, then Bl will be accepted by V since the latter
does not receive any conﬂicting transaction Td nor conﬂict-
ing block Bd. This process is summarized in Figure 12.
Here, we assume that M does not control a large fraction of
the computing power—otherwise Bl will be likely included
in the main blockchain. Notice that A can collude with M
(or can mine for blocks by herself) to further increase the
success probability of the attack.

5.3 Denial of Service

Delaying information propagation in a P2P-based crypto-
currency network such as Bitcoin can be very damaging as
it results in the delay of processing payments. Our ﬁndings
clearly suggest that e.g., Denial of Service (DoS) attacks
on Bitcoin can be made more easily realizable by exploit-
ing the object request management of Bitcoin. That is, an
adversary that controls a number of nodes in the network
(and establishes connections with many Bitcoin nodes) can
eﬀectively prevent the dissemination of information, such as
blocks and transactions, in the entire network.

Notice that there are approximately 6000 reachable Bit-
coin nodes in the network13. A resource-constrained adver-
sary can simply connect to all these nodes and deny them
the delivery of transactions and blocks.

12We employ the same setup as visualized in Figure 11, but
replace the Bitcoin network with the Bitcoin XT node.
13Available from: https://getaddr.bitnodes.io/

l

Vendor

Figure 12: The adversary A performs double-
spending of a 1-conﬁrmation transaction against a
vendor, by leveraging the computing power of a
weak miner. Td corresponds to the double-spending,
and Tl to the legitimate transaction.

Given an average block generation time g, and a timeout
of 20 minutes per block (cf. Section 3.2), we estimate the
number n of required inv messages to prevent the delivery
of consecutive blocks during time t:

n(t) =

l t
g m−1

Xi=1

(cid:24) t − g · i

20

(cid:25)

(1)

In addition, A needs to ﬁll and maintain the open con-
nection slots of V. To prevent the delivery of blocks to all
6000 reachable full Bitcoin nodes, A needs to maintain ap-
proximately 450,000 active Bitcoin TCP connections14 and
transmit about 101 · 6000 ≈ 600KB of inv messages per
block. During time t, every node requires moreover n(t) inv
messages. Assuming that A can operate 10000 connections
per node15, A requires approximately 45 nodes for attempt-
ing to constantly prevent block information propagation in
the Bitcoin network.

Notice that by denying the delivery of blocks from full
Bitcoin nodes, A implicitly prevents the reception of these
blocks by the various lightweight Bitcoin clients16.

This analysis complements the work of [19] and shows that
A can deny the delivery of blocks from the entire network
using almost 45 nodes, and by transmitting only 600 KB per
denied block for every 20 minute delay.

6. COUNTERMEASURES

14Assuming all 6000 Bitcoin nodes accept no more than
125 connections and maintain on average 50 connections.
Clearly, some Bitcoin nodes accept signiﬁcantly more than
125 connections (1500 or more).
15To limit the amount of information received from these
10,000 nodes, A can outsource a Bloom ﬁlter (similar to ex-
isting lightweight clients [18]) which match a small fraction
of transactions in the system. By doing so, A reserves his
bandwidth to perform his DoS attack.
16Lightweight Bitcoin clients (e.g. SPV nodes) do not vali-
date nor maintain the full blockchain, and therefore get their
information from a subset of the reachable Bitcoin nodes.
Users typically prefer operating SPV clients, because they
require signiﬁcantly less processing power and disk storage.

702Based on our ﬁndings, we discuss and explore possible
avenues for enhancing the security of Bitcoin without dete-
riorating its scalability.

Alternative Relay Networks.

As outlined in Section 5.1, miners (and users) can rely on
additional relay networks to receive up-to-date information
from the network. These networks allow miners to directly
exchange information, which would eﬀectively prevent an
adversary from denying/delaying object delivery.

Matt Corallo’s relay network is one of the most promi-
nent instantiations of an alternative relay network, currently
operating 5 relay nodes—each serving between 20 and 40
clients. Corallo’s network performs partial object valida-
tion and does not follow the request management system of
Bitcoin to ensure a faster spread of information in those net-
works. This allows any entity to ﬂood the network with ill-
formed objects—which might explain the reason why Corallo’s
network is still not widely used [4].

Notice, however, that alternative relay networks can be
built with diﬀerent trust models, and can incorporate arbi-
trary policies to counter DoS; for instance, one can construct
a small and trusted relay network only comprising one rep-
resentative node from each centralized mining pool.

Dynamic Timeouts.

As described in Measure 3, Bitcoin relies on static time-
outs in order to tolerate network delays. This implicitly
assumes that all nodes and resources in the network are
homogeneous—which is clearly not the case. As we show in
Figure 3, slow nodes require considerable time to download
blocks, while fast nodes can secure the download of blocks
in few seconds.

We believe that dynamic timeouts would suit better the
heterogeneity of resources in the Bitcoin network. For this
purpose, we suggest the inclusion of the size of the mes-
sage at advertisement time, which would allow each node
to dynamically estimate the timeout value according to its
resources, and the object size. For instance, when sending
block advertisements, we suggest that the miner includes
the block size into the block header17—which would allow
receiving nodes to know the total block size and to appro-
priately estimate a dynamic timeout for any given block.

By doing so, we argue that the advantage of an adversary
in abusing timeouts to delay block delivery can be consider-
ably reduced.

We observe that the current timeouts employed by Bitcoin
only capture the time starting from the getdata advertise-
ment until the full data reception. Here, a timeout between
the data request and the beginning of the data transfer could
additionally be considered. We argue that such an approach
would increase the costs of the adversary in delaying the de-
livery of information.

Updating Block Advertisements.

Based on our observations, we recommend updating the

current block request system as follows:

No inv messages: We suggest to drop the advertisement
of inv messages for blocks, and solely advertise the
block headers before transmitting the blocks. By doing

17Block headers contain an unused ﬁeld which was intended
for the number of transactions conﬁrmed in the block.

so, every receiver can immediately verify the correct-
ness of the PoW, and learn about any new discovered
blocks in the network. As mentioned in Section 4, this
will ensure that an honest node will always learn about
new blocks in the network even if the adversary ﬁlls
all of its remaining connections to deny the delivery of
such information. Notice that each block header is 80
bytes, while a block’s inv message occupies 36 bytes.
Therefore, we do not expect a considerable increase in
the communication overhead due to this modiﬁcation.

Keep track of block advertisers: Similar to transaction
advertisements, we suggest that Bitcoin nodes keep
track of the block headers’ advertisers. This recom-
mendation goes hand in hand with the advertisement
based on block headers since it allows the node to re-
quest the blocks from the peers announcing the longest
chain. Additionally, this allows the node to request
the block from (a randomly chosen) advertising peer
in case the chosen relay delays the delivery of the block.

Handling Transaction Advertisements.

As mentioned in Measure 4, a transaction is currently re-
quested from the peers that advertised it ﬁrst.
If a given
peer does not respond within an appropriate timeout, the
transaction will be requested from the next peer stored in
the FIFO queue. As mentioned in Section 3.2, this gives con-
siderable advantage for the adversary to prolong the timeout
before the receiver requests the transaction from any other
peer. To remedy this, we suggest the following hardening
measures:

Filtering by IP address: One way to deter against such
an adversary would be to accept only one inv of the
same transaction per IP address. Notice that this can-
not entirely prevent the adversary from advertising the
same transaction using diﬀerent IP addresses.

Randomly choosing sender: Another complementary ap-

proach would be to randomly choose an incrementing
number of peers to contact from the list of advertising
peers if the ﬁrst peer did not answer to the getdata
request. Here, a transaction is ﬁrst queried from the
ﬁrst advertising peer.
If this peer however does not
transmit the transaction within the speciﬁed timeout,
the transaction is requested from two randomly cho-
sen peers simultaneously, then from three peers, until
the transaction is ﬁnally received. This will limit the
advantage of an adversary which tries to advertise ﬁrst
the same transaction several times.

Given these suggestions, the probability to receive a trans-
action after the n’s timeout, when the ﬁrst advertising peer
is controlled by A, given ia inv messages sent by A and a
total of it inv messages is computed as follows:

Pt(n) =

n

i

Xi=0

[

Yj=1

2
j+1

((cid:0)ia− j(j+1)
(cid:0)it− j(j+1)

2
j+1

(cid:1)
(cid:1)

Equation 2 allows one to compute the probability Pt(n)
that a fast payment in Bitcoin is secure after a waiting time
of nt, where t is the timeout set by the node when handling
transactions. Figure 13 depicts Pt(n) with respect to the

2
i+2

) · (1 − (cid:0)ia− (i+1)(i+2)
(cid:0)it− (i+1)(i+2)

2
i+2

(cid:1)
(cid:1)

)]

(2)

703)
n
(
t
P

1.0

0.8

0.6

0.4

0.2

0.0

ia
it

ia
it

ia
it

= 0.50

= 0.75

= 0.95

30

60

90 120 150 180 210 240 270 300

Waiting time

Figure 13: Waiting time vs ia
it
and it = 125.

. Here, t = 30 seconds

waiting time. Here, we assume that it = 125,18 t = 30
seconds and that the adversary controls a fraction ia
of
it
the advertised inv messages. Our results show, that after
5 minutes waiting time, the node would be almost certain
to receive a transaction, even if the adversary controls 95%
of the advertised inv messages (in return about 6 out of
125 inv messages originate from honest peers). Notice that
the receiving peer can be alerted if a sudden increase in inv
advertisements occurs.

We conclude, that fast payments should only be accepted
after a waiting time nt to ensure with probability Pt(n) that
the transaction cannot be double-spent—even if the double-
spend ﬁrst-relay protection is implemented in the network.
For a transaction request timeout of t = 30 seconds, this
waiting time amounts to almost 5 minutes— which is half
the duration of the block generation time.

Operating Several Bitcoin Nodes.

Another eﬀective alternative to harden the realization of
our attack consists of the installation of several Bitcoin nodes
(operated by the same entity) in the oﬃcial Bitcoin network.
By doing so, an adversary would have to prevent the delivery
of objects to all these nodes in order to deny the entity from
receiving an object of interest. As shown in Section 3.2, the
more connections a Bitcoin entity exhibits, the less likely an
adversary can delay the propagation of blocks and transac-
tions. As shown in [20], this countermeasure can also eﬀec-
tively harden double-spending attacks on zero-conﬁrmation
payments in Bitcoin.

Penalizing Non-responding Nodes.

We also suggest extending the penalty system employed
by Bitcoin (cf. Measure 1) to penalize non-responding peers.
Namely, nodes which constantly delay information delivery
after a getdata message should be penalized, and when ap-
propriate disconnected from. Here, a careful design of the
appropriate penalty is needed in order not to penalize slow
nodes in the network.

7. RELATED WORK

The security and privacy of Bitcoin has received consid-
erable attention from the research community. Bonneau
et al. [11] provide a comprehensive exposition of the sec-
ond generation crypto-currencies, including Bitcoin and the

18The default maximum of neighbors per node is 125.

many alternatives that have been implemented as alternate
protocols.

In [13], Decker and Wattenhofer investigate transaction
and block propagation time in Bitcoin. Gervais et al. an-
alyze in [17] the limits of decentralization in Bitcoin, and
show that the vital operations and decisions that Bitcoin is
undertaking are not decentralized.

Finney [16] describe a double-spending attack in Bitcoin
where the attacker includes in her generated blocks transac-
tions that transfer some coins between her own addresses;
these blocks are only released in the network after the at-
tacker double-spends the same coins using fast payments and
acquires a given service. Barber et al. [10] analyze possible
ways to enhance the resilience of Bitcoin against a number
of security threats. Eyal and Sirer [15] show that Bitcoin
is not safe against attacks by selﬁsh miners that command
more than 33% of the total computing power of the network.
Similarly, Courtois and Bahack [12] study subversive min-
ing strategies where miners withhold their recently mined
blocks in order to increase their advantage in the network.
Karame et al. [20, 21] investigate double-spending attacks
in Bitcoin and show that double-spending fast payments in
Bitcoin can be performed in spite of the measures recom-
mended by Bitcoin developers. The authors also proposed
a countermeasure which is currently integrated in Bitcoin.

All these studies, however, assume that the information
disseminated in the Bitcoin network is directly received by
nodes. Recently, the Bitcoin developers discussed the possi-
bility that a transaction transmission can be delayed [2], and
hinted at the possibility to delay the delivery of blocks [3].
Miller et al. [22] exploited this observation and made use
of the 2-minute transaction timeout in order to try to dis-
cover Bitcoin’s topology.
In this paper, we extend these
studies and show that an adversary can eﬀectively prevent
the delivery of transaction and block information from the
network peers for a considerable amount of time. Our work
share similarities with Heilman’s et al. eclipse attacks on
Bitcoin [19]. Here, the authors showed that by monopoliz-
ing the connections of nodes in the system, an adversary can
perform selﬁsh mining, and abuse Bitcoin’s consensus pro-
tocol. Unlike [19], our work however shows that a resource-
constrained attacker can achieve considerable damage in the
network using only a handful of connections. By doing so,
our results suggest that the attacks outlined in [12,15,19,20]
can be even more aggravated (cf. Section 5).

8. CONCLUDING REMARKS

In this paper, we showed that the current scalability mea-
sures adopted by Bitcoin come at odds with the security of
the system. More speciﬁcally, we showed that an adversary
can exploit these measures in order to eﬀectively delay the
propagation of transactions and blocks to speciﬁc nodes—
without causing a network partitioning in the system.

We analyzed the implication of our ﬁndings and showed
that these threats enable an adversary to easily mount Denial-
of-Service attacks on the entire network by preventing the
delivery of blocks in the system. Moreover, mining pools
can exploit this vulnerability to claim a higher mining ad-
vantage in the network. When combined with the results of
Eyer and Sirer [15], our ﬁndings therefore suggest that selﬁsh
mining pools which command less than 33% of the comput-
ing power can considerably increase their mining advantage.
Finally, our ﬁndings show that the countermeasure adopted

704in Bitcoin XT to prevent the double-spending of fast pay-
ments can be easily circumvented by a resource-constrained
adversary.

Based on our ﬁndings, we explored a number of counter-
measures in order to enhance the security of Bitcoin without
deteriorating its scalability. Notice that our ﬁndings are not
particular to Bitcoin and also apply to P2P networks and
crypto-currencies which use a similar request management
system such as Litecoin, and Dogecoin. We therefore hope
that our ﬁndings solicit more research towards the re-design
of the request management system of Bitcoin.
Acknowledgements
This work was partially supported by the Zurich Information
Security Center. It represents the views of the authors. The
authors would like to thank the anonymous reviewers, as well
as Grgur Petric Maretic, Ognjen Maric and Erwin Fang for
their valuable feedback and comments.

9. REFERENCES
[1] Bitcoin Wiki, Available from https://en.bitcoin.

it/wiki/.

[2] Bitcoin dev commit 4547: prevent peer ﬂooding
request queue for an inv, 2015. Available from:
https://github.com/bitcoin/bitcoin/pull/4547.
[3] Bitcoin dev commit 4831: net: Better askfor request

management, 2015. Available from: https://github.
com/bitcoin/bitcoin/pull/4831.

[4] Bitcoin Mailing List - Peter Todd about how many

pools use an additional relay network, 2015. Available
from: http://sourceforge.net/p/bitcoin/mailman/
message/34152876/.

[5] Bitcoin market cap, 2015. Available from: https://

blockchain.info/charts/market-cap.

[6] Bitcoin Relay Network, 2015. Available from: http://

bitcoinrelaynetwork.org/.

[7] Bitcoin XT, 2015. Available from: https://github.

com/bitcoinxt/bitcoinxt.

[8] Double spending in Bitcoin, 2015. Available from:

https://medium.com/@octskyward/double-
spending-in-bitcoin-be0f1d1e8008.

[9] Stress Test Prepares VisaNet for the Most Wonderful
Time of the Year, 2015. Available from: http://goo.
gl/hba0oh.

[10] S. Barber, X. Boyen, E. Shi, and E. Uzun. Bitter to
Better - How to Make Bitcoin a Better Currency. In
Proceedings of Financial Cryptography and Data
Security, 2012.

[11] Joseph Bonneau, Andrew Miller, Jeremy Clark,

Arvind Narayanan, Joshua A. Kroll, and Edward W.
Felten. Research Perspectives and Challenges for
Bitcoin and Cryptocurrencies. In 2015 IEEE
Symposium on Security and Privacy, May 2015.

[12] Nicolas T. Courtois and Lear Bahack. On subversive

miner strategies and block withholding attack in
bitcoin digital currency. CoRR, abs/1402.1718, 2014.

[13] C. Decker and R. Wattenhofer. Information

Propagation in the Bitcoin Network. In 13-th IEEE
International Conference on Peer-to-Peer Computing,
2013.

[14] Bitcoin exchanges, 2013. Available from: https://en.

bitcoin.it/wiki/Exchanges.

[15] Ittay Eyal and Emin G¨un Sirer. Majority is not

enough: Bitcoin mining is vulnerable. In Financial
Cryptography and Data Security, pages 436–454.
Springer, 2014.

[16] The Finney Attack, 2013. Available from: https://
en.bitcoin.it/wiki/Weaknesses#The_.22Finney.
22_attack.

[17] Arthur Gervais, Ghassan Karame, Srdjan Capkun,

and Vedran Capkun. Is bitcoin a decentralized
currency? In IEEE Security and Privacy, 2014.

[18] Arthur Gervais, Ghassan O. Karame, Damian Gruber,

and Srdjan Capkun. On the privacy provisions of
bloom ﬁlters in lightweight bitcoin clients. In
Proceedings of the 30th Annual Computer Security
Applications Conference, ACSAC 2014, New Orleans,
LA, USA, December 8-12, 2014, 2014.

[19] E. Heilman, A. Kendler, A. Zohar, and S. Goldberg.

Eclipse attacks on bitcoin’s peer-to-peer network.
2015.

[20] Ghassan O. Karame, Elli Androulaki, and Srdjan

Capkun. Double-spending fast payments in bitcoin. In
Proceedings of the 2012 ACM conference on Computer
and communications security, CCS ’12, New York,
NY, USA, 2012. ACM.

[21] Ghassan O. Karame, Elli Androulaki, Marc Roeschlin,

Arthur Gervais, and Srdjan ˇCapkun. Misbehavior in
bitcoin: A study of double-spending and
accountability. ACM Trans. Inf. Syst. Secur.,
18(1):2:1–2:32, May 2015.

[22] Andrew Miller, James Litton, Andrew Pachulski, Neal

Gupta, Dave Levin, Neil Spring, and Bobby
Bhattacharjee. Discovering bitcoin’s public topology
and inﬂuential nodes, 2015.

APPENDIX

A. REVENUE FOR SELFISH MINING

In what follows, we detail Eyal and Sirer’s revenue scheme.

1. Current state: Any state, except 2 branches of length 1.
Event: The pool ﬁnds a block, adds it to its secret chain.
Reward: Block reward is determined later.
2. Current state: Two branches of length 1.

Event: Pool ﬁnds a block.
Reward: Pool publishes two blocks, revenue of two blocks.

3. Current state: Two branches of length 1.

Event: Other ﬁnd block on previous pool block.
Reward: Pool and other obtain revenue of one block each.

4. Current state: Two branches of length 1.

Event: Other ﬁnd block on previous other block.
Reward: Other obtain revenue of two blocks.

5. Current state: No secret block.

Event: Other ﬁnd block.
Reward: Other obtain revenue of one block.

6. Current state: One secret block.

Event: Other ﬁnd block. Pool publishes secret block.
Reward: Block reward is determined later, depends on γ.

7. Current state: Leading two secret blocks.
Event: Other ﬁnd block, only 1 secret left.
Reward: Pool publishes secret blocks, two blocks revenue.

8. Current state: Leading more than two secret blocks.

Event: Other ﬁnd block, only 1 secret left.
Reward: Pool publishes one block, revenue of one block.

705