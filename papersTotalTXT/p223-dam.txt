Formal Veriﬁcation of Information Flow Security for a

Simple ARM-Based Separation Kernel

Mads Dam, Roberto Guanciale,
Narges Khakpour, Hamed Nemati

KTH Royal Institute of Technology
SE-100 44, Stockholm, Sweden
{mfd, robertog, nargeskh,

hnnemati}@kth.se

ABSTRACT
A separation kernel simulates a distributed environment us-
ing a single physical machine by executing partitions in iso-
lation and appropriately controlling communication among
them. We present a formal veriﬁcation of information ﬂow
security for a simple separation kernel for ARMv7. Previous
work on information ﬂow kernel security leaves communica-
tion to be handled by model-external means, and cannot be
used to draw conclusions when there is explicit interaction
between partitions. We propose a diﬀerent approach where
communication between partitions is made explicit and the
information ﬂow is analyzed in the presence of such a chan-
nel. Limiting the kernel functionality as much as meaning-
fully possible, we accomplish a detailed analysis and veri-
ﬁcation of the system, proving its correctness at the level
of the ARMv7 assembly. As a sanity check we show how
the security condition is reduced to noninterference in the
special case where no communication takes place. The ver-
iﬁcation is done in HOL4 taking the Cambridge model of
ARM as basis, transferring veriﬁcation tasks on the actual
assembly code to an adaptation of the BAP binary analysis
tool developed at CMU.

Categories and Subject Descriptors
D4.6 [Operating Systems]: Security and Protection; D.2.4
[Software Engineering]: Software/Program Veriﬁcation—
formal methods, correctness proofs

Keywords
Formal veriﬁcation; Information Flow Security; Separation
Kernel; Hypervisor

1.

INTRODUCTION

The design of secure systems needs to ensure that soft-
ware components belonging to diﬀerent security domains are

Permission to make digital or hard copies of part or all of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage, and that copies bear this notice and the full ci-
tation on the ﬁrst page. Copyrights for third-party components of this work must be
honored. For all other uses, contact the owner/author(s). Copyright is held by the
author/owner(s).
CCS’13, November 4–8, 2013, Berlin, Germany.
ACM 978-1-4503-2477-9/13/11.
http://dx.doi.org/10.1145/2508859.2516702.

Oliver Schwarz
SICS Swedish ICT

Box 1263
SE-164 29

Kista, Sweden
oliver@sics.se

adequately isolated from each other, such that only autho-
rized communication can take place between them. One way
of achieving this is by dedicated hardware, e.g. TPM’s or
SIM’s. This, however, carries signiﬁcant overhead, in terms
of the hardware itself, and the associated infrastructure. An
alternative is to execute the components in isolated parti-
tions on shared hardware, using low-level software execution
platforms such as separation kernels [25, 12] or secure hyper-
visors [10, 27, 17]. A key requirement of this solution is the
veriﬁcation of the tamper resistant trusted computing base,
preferably by use of formal methods. Signiﬁcant progress
has been made recently in this direction, cf. the seL4 project
[14], Microsoft’s Hyper-V project [16], and Green Hills’ CC
certiﬁed INTEGRITY-178B separation kernel [23].

Our focusing scenario consists of an “untrusted” compo-
nent (e.g. a smartphone software stack) that interacts with
a set of trusted services, such as a virtual SIM card, or a
virtual TPM. A shared execution platform for this scenario
needs to provide the following minimal functionality:

1. Isolation of component resources

2. A communication mechanism that plays the role of ex-
ternal communication lines in a physically distributed
system

3. A scheduling mechanism to commit shared resources

(e.g. processors) among the components.

In this paper we present a proof-of-concept design and ma-
chine level veriﬁcation of the PROSPER separation kernel
for ARMv7 [3], which supports the above functionality. The
kernel allows the execution of two component systems, such
as a smartphone OS with a virtualized SIM application, on
top of a single physical machine. The interesting feature of
this set-up is that explicit, kernel-supported communication
between partitions is essential, and a critical aspect of the
security analysis is to ensure that this communication does
not introduce (deliberate or accidental) side channels that
can be exploited by an attacker.

This security analysis is far from trivial. The objective of
a separation kernel1, following Rushby [25], is ﬁrst to make

1We use the label “separation kernel” in this paper mainly
since no support for user/kernel space virtualization is pro-
vided to the component systems, but the borderline between
separation kernels and secure hypervisors, and our use of the
associated terminology, is admittedly fuzzy.

223it appear that each component system is executed on a sep-
arate, isolated, machine, and second to ensure that commu-
nication can only ﬂow as authorized along known external
channels. However, there are several problems in delegat-
ing communication to an external agent. First, it entails an
extension of the trusted computing base to include the exter-
nal channel itself. Second, virtualizing the component sys-
tems without also virtualizing the channel connecting them
is hardly a reasonable design. Third, potential side chan-
nels are ignored. In a case such as this, where a partition
must be able to access the virtualized SIM application at
will, communication can convey critical timing information
that an attacker can exploit to extract key material, as is
well known [15].

We propose instead an approach where communication
between partitions is made explicit in the top level speciﬁca-
tion (TLS), and information ﬂow is analyzed in the presence
of such an intended communication channel. We formulate
the TLS such that it directly formalizes, in suﬃcient detail,
the set of computation paths both allowed and required at
the implementation level, and then we check that the imple-
mentation indeed satisﬁes this speciﬁcation. The question
is how to do this, if it can be done while maintaining a
satisfactory account of isolation, and if it can be done at
a satisfactory level of abstraction (such that the TLS does
not conﬂate to become identical to the implementation it-
self). In this paper we present a proof-of-concept solution
in the sense that functionality is limited as much as mean-
ingfully possible, but such that the speciﬁcation, implemen-
tation and correctness proof is carried through in complete
detail from TLS to realization for ARMv7, and proved cor-
rect at the instruction reference semantics level using the
HOL4 model of ARM developed at Cambridge [7].

In our case, the goal of veriﬁcation is to show that there is
no way for the partitions to aﬀect each other, directly or in-
directly, except through the intended channel. In particular,
there should be no way for a partition to access the mem-
ory or register contents, by reading or writing, of the other
partition, other than when the communication is realized by
explicit usage of the intended channel, by both partitions in
collaboration. This is not an easy property to reconcile with
the standard information ﬂow tools such as noninterference
(NI) or intransitive noninterference:

• NI is problematic since the very purpose of the ker-
nel is to allow rather than prevent information ﬂow
(through the intended channel). For the sake of illus-
tration consider the recent NI-based veriﬁcation of the
seL4 kernel [20, 19]: A critical step in that work boils
down to a proof of the absence of information ﬂow from
the previously scheduled partition to the scheduler it-
self, in order to prevent the scheduler being used as a
communication channel. This type of approach is not
applicable in our setting since communication must be
allowed to aﬀect the partitions in ways that are outside
our control, as the partitions are not statically known.
Moreover, for the same reason we have no control over
what, where, or how the channel is intended to be used,
and thus the various NI-based declassiﬁcation schemes
(cf. [26]) do not help.

• Intransitive noninterference [24] relaxes NI with the
possibility to add unknown, but trusted, intermedi-
ary agents through which information ﬂows can be re-

Figure 1: Ideal model

quired to pass. In our case that agent is the kernel,
which is known, and not a priori trusted. This makes
intransitive noninterference diﬃcult to make use of in
the present context.

We thus take a diﬀerent approach. We formulate the TLS
as an “ideal model” which satisﬁes the required separation
properties by construction, and then reduce correctness to
trace equivalence w.r.t. a “real model”, reﬂecting actual sys-
tems behaviour. The key idea is to execute the partitions
on physically separate, ideal processors, connected by an
explicit, ideal communication channel, and equipped with
a little extra paraphernalia, as shown in Fig. 1. The ideal
processors need to accurately mimick the execution of user
space partitions on a real processor. This is done by aug-
menting the TLS processors by idealized functionality, the
“ideal handlers” of Fig. 1, which is invoked whenever the
actual processors would transition to privileged mode by an
exception (e.g. a hardware interrupt, or an exception). This
construction allows userland code to execute as desired (with
the exception of ﬁne grained timing diﬀerences we currently
do not take into account), but the idealized processors are
physically prevented from directly aﬀecting their sibling ma-
chine, with the exception of explicit communication using
the message delivery service.

The task is thus to show that, properly set up, the user ob-
servable traces of the ideal model are the same as those of a
“real model”, obtained by executing the software in diﬀerent
partitions on top of our separation kernel, on top of a real
ARMv7-A processor, including a Memory Management Unit
(MMU) for physical protection of memory regions belonging
to diﬀerent partitions. We prove this using the bisimulation
proof method [28], by exhibiting a concrete bisimulation re-
lation, a candidate relation, relating the state spaces of ideal
and real models. The proof that the candidate relation is
actually a bisimulation relation of the appropriate type is
in turn reduced to subsidiary properties, several of which
have natural correspondences in previous kernel veriﬁcation
literature, cf. [12, 23], namely that:

i The initial states of the ideal and the real models are
in the candidate relation. This is ensured by the cor-
rectness of the bootstrap code.

ii A partition does not perform any isolation-violating
operation while it is executing. Due to our use of
memory protection, this is really a noninterference-like
property of the ARMv7-A architecture rather than a
property of the separation kernel. This property is
similar to the partition management result reported in
[30].

iii The processor state switches correctly upon transition
to privileged mode. Again this is a processor architec-
ture rather than a kernel dependent result.

224iv Execution of ideal exception handlers vs the real sep-
aration kernel exception handlers preserve the candi-
date relation.

v Several invariants are preserved while partitions and

/or kernel handlers are running.

For the actual veriﬁcation we have used a combination of
theorem proving and binary code analysis. The real and
ideal models are built on top of the Cambridge ARM HOL4
model, extended with a simple MMU unit. The isolation
lemmas of ARM, items (ii) and (iii), are proved using a
tool, ARM-prover, developed for the purpose in HOL4. The
proofs are costly and involve traversing the full ARM in-
struction sets. The ARM-prover allows the proofs to be
automated to a large extent. This frees us from the onerous
task of verifying the two theorems on each element of the
large ARM instruction set. The ARM-prover tool is devel-
oped on top of the monadic ARM semantics reported in [7].
Handlers (item (iv)) are veriﬁed using pre/post conditions.
Manual generation of these handlers is an error-prone pro-
cess, and for this reason we generate the pre/post conditions
automatically based on the speciﬁcation of the ideal model,
the candidate relation, and the ARM isolation Lemmas. We
transfer the pre/post conditions to the binary code analysis
tool BAP [6], and use BAP to verify the bootstrap code and
the kernel handlers at the assembly code level. Several tools
have been developed for lifting the ARM code to the input
format of BAP and manipulating the code. Space prevents
us from more than outlining the ARM isolation lemmas and
the BAP extensions here; these will be reported in separate
publications.

The paper is organized as follows: In section 2 we present
the ARMv7 processor, MMU, and timing model. In sec-
tion 3, the PROSPER kernel is presented, and the the ideal
model is described in section 4. We then proceed to give an
overview of the proof strategy, including the decomposition
of the TLS into the ARM lemmas, and the handler veriﬁca-
tion tasks. In section 6 we partially validate our veriﬁcation
approach by proving a “monotonicity of release” property as
suggested by Sabelfeld and Sands [26], that a corollary of
our proof is an NI property in the special case where parti-
tions do not actually communicate. In section 7 we present
the proof implementation, and in section 8 information is
given on the status of the kernel and some performance ﬁg-
ures regarding the proof itself. In section 9 related work is
discussed, and ﬁnally in section 10, we conclude and discuss
some unresolved issues.

2. ARMv7
An ARMv7 CPU has execution mode m ∈ M where M =
{usr , svc, abort, undef , irq, ﬁq, sys}. The non-privileged usr
mode is used by the user partitions, while the privileged
modes Mp = M\{usr} are used to execute kernel activities.
A machine state is a record σ = (cid:104)regs, psrs, mem, coregs(cid:105)
where regs, psrs, mem and coregs, respectively represent
the registers, program status registers (psrs), memory and
coprocessors of the machine. The register set regs consists of
the sixteen user registers that are accessible in all modes as
well as the banked-registers of each privileged mode that are
available only in that mode. The program status registers
is a record

(cid:104)cpsr , psr svc, psr abort , psr undef , psr irq , psr ﬁq , psr sys(cid:105)

where cpsr is the current psr and each psr m is the banked
psr in mode m ∈ Mp. A psr encodes the arithmetical ﬂags,
the executing mode, the interrupt mask, and the instruction
decoding. The functions I(σ) and M (σ) return the hardware
interrupt mask and the current mode in state σ, respectively.
Moreover, the memory is the function mem ∈ word32 →
word8 .
The tuple coregs = (cid:104)c1, c2, c3(cid:105) contains the three 32-bit
registers of coprocessor CP15, used mainly to control the
Memory Management Unit (MMU). The register c1 repre-
sents whether the MMU is enabled or not, and c2 gives the
base address of the page table. In ARMv7, there are sixteen
domains, each representing a security role. The coprocessor
register c3 holds the current status of the domains. An en-
try of the page table determines the owner domain of the
corresponding page and its access permission.

In our setting, a “real’ system” is an ARM machine con-
nected to a timer device. A real system is modeled by the
record s = (cid:104)σ, t(cid:105) ∈ S, where σ is an ARM machine state
and t represents the clock cycles elapsed since system start.
The behavior of a system is deﬁned by the state transition
relation →⊆ S×S where a transition is performed due to ei-
ther the execution of an ARM instruction or a timer signal.
We assume a simple time model that constrains all transi-
tions to consume one clock cycle, i.e. if (cid:104)σ, t(cid:105) → (cid:104)σ(cid:48), t(cid:48)(cid:105) then
t(cid:48) = t + 1.

If the real system switches from the mode usr to a privi-
leged mode, then an exception has occurred. The privileged
mode svc is activated by a software interrupt (SWI). If the
current instruction is undeﬁned, then the system switches
to the mode undef . The mode irq is activated by a hard-
ware interrupt. In our setting, the timer triggers a hardware
interrupt every ﬁxed amount of clock (actually, instruction)
cycles. If the MMU prevents an access to the memory, then
the mode abort is enabled. In our setting, no exception can
activate the modes sys and ﬁq. In fact, sys mode can only
be explicitly entered from a privileged mode. Moreover, in
our model there is only one device (the timer) which delivers
standard hardware interrupts. For this reason the fast in-
terrupt mode ﬁq is never activated. Whenever an exception
occurs, the CPU backs up the program counter and the cpsr
into the banked registers and into the psr of the activated
mode, disables hardware interrupts and jumps to a prede-
ﬁned address in the vector table to transfer the control to
the corresponding exception handler.

Figure 2 (A) depicts an example computation of a real
system. White and grey circles represent states in user mode
and black circles represent states in privileged modes. The
circle labels represent the system clocks and the solid arrows
represent the transition relation. Transitions between two
states in user mode (e.g. 1 → 2) do not cause any exceptions.
The timer tick of this example is six clock cycles, then an
interrupt is delivered in the states 6 and 12, switching the
system to mode irq. The transition between the states 2
and 3 is caused by a diﬀerent exception, for example the
execution of a software interrupt. Finally, transitions from
privileged modes to user mode (e.g. 4 → 5) are caused by
instructions that explicitly change cpsr .

3. THE PROSPER KERNEL

The PROSPER kernel has four minimal functionalities:
execution of two user partitions on one physical machine,
protection of the partition resources, partition scheduling,

225other one. It is also in charge of delivering the pending mes-
sages to the resuming (receiver) partition; if the message-box
of the resuming partition is full, (i) its status is changed to
“message”, (ii) the context of its message status is updated
with the content of the pending message, and (iii) the pro-
gram counter of the resumed partition is updated to point to
its message handler code. The reception of a message causes
the resumed partition to enter into a local critical section,
i.e. no other message can be received while the partition
is running in the message status. To exist from the criti-
cal section, the receiver partition performs a status switch
hypercall.
To start the system, a memory image of the system must
be prepared by the linker. Let mem 1 : [min 1, max 1] →
word8 and mem 2 : [min 2, max 2] → word8 be two initial
partition memories in our setting. Then, the linker loads
the initial partition memories and the kernel memory into
the system memory, and activates the kernel bootstrap code.
The initial state of the real system is the ﬁrst reachable state
in user mode obtained after the execution of the bootstrap
code of the kernel. Clearly, this initial state of the system de-
pends on the partitions memories. We denote the behavior
of a real system starting from an initial state s0 with ini-
tial partition memories mem 1 and mem 2 by the transition
system Tr(mem 1, mem 2) = (cid:104)S, s0,→(cid:105).

4. THE IDEAL SYSTEM

The ideal system formalizes the top level speciﬁcation
which satisﬁes the required separation properties by con-
struction. The ideal system is composed of two separate
special ARMv7 machines communicating via asynchronous
message passing, a logical component and a shared timer
(see Fig. 1). Each machine of the ideal system is used to
execute one of the two partitions in a physically isolated
environment. Intuitively, the logical component can be con-
sidered as an external device. Our special ARMv7 machine
allows a partition to execute without the runtime support
of the kernel. This machine executes the user-mode compu-
tations as a regular ARMv7 processor, but if the processor
switches to a privileged mode, an abstract kernel function-
ality is atomically executed and the user mode is restored.
An ideal state is a record q = (cid:104)σ1, σ2, c1, c2, t, id(cid:105) ∈ Q
where t represents the clock cycles elapsed from the sys-
tem start. At each instant, only one of the machines can
perform computations, and id ∈ {1, 2} identiﬁes the ac-
tive machine. The logical component consists of the records
ci = (cid:104)rdy, ctx , msg(cid:105), i ∈ {1, 2}. The ﬂag rdy represents if
the machine is ready to handle the incoming messages and
the banked context ctx (set of registers and cpsr) is used to
back up the machine state whenever a message is received.
A message box msg ∈ word32 ∪ {⊥} can either contain a
pending message or be empty (⊥). Henceforth, we say that
an ideal system is in mode m if the active machine is in
mode m and the inactive one is in the mode usr .

The initial state of the ideal system, similar to the real
system, depends on the initial partition memories. We de-
note the behavior of a ideal system starting from an initial
state q0 with initial partition memories mem 1 and mem 2
by the transition system Ti(mem 1, mem 2) = (cid:104)Q, q0,→(cid:105). In
the initial state, all the components are initialized such that
the partitions memories and the page tables are loaded into
their corresponding machine memory, the program counter

Figure 2: (A) The real world and (B) the Top Level
Speciﬁcation

and inter-partition communication. All low-level tasks of the
kernel that depend on the architecture (e.g. accessing spe-
cial registers and coprocessors, context saving and restoring)
are implemented in assembly (∼ 150 lines of codes), while
all high-level tasks (e.g., hypercall, scheduling, page table
setup) are implemented in C (∼ 600 lines of code). The
current implementation can host OSs (e.g. µClinux [18],
FreeRTOS[8]) that do not require intra-partition memory
protection.

The machine memory is partitioned into three separate
regions: the region in the range of [min g, max g] for the par-
tition g ∈ {1, 2}, and a kernel memory region. The accesses
to the partitions are controlled by the MMU where three
ARMv7 domains 0,1, and 2 are used to represent the ker-
nel, the ﬁrst partition and the second partition, respectively.
When the kernel resumes a partition, it updates the copro-
cessor c3 to set the partition domain to the value client and
to disable the domain of the other partition. The MMU is
conﬁgured to enforce the following properties: (i) if a parti-
tion is running, then only its memory can be accessed, (ii)
whenever the kernel is activated (e.g. a partition performs
a software interrupt), it is able to read and write its mem-
ory and the memory of the “interrupted” partition. We have
no concurrency inside the kernel, i.e. an exception can not
interrupt while another exception is being handled.

The partitions communicate through asynchronous mes-
sage passing. Each partition has two executing status vari-
ables: message status is intended to process the incoming
messages while the task status is used for other activities. To
each status is associated a context that contains a set of user
registers and the cpsr. For the active partition, the context
corresponding to the active status is the current user regis-
ters and the cpsr and the context of the non-active status
is stored in the kernel memory. For the inactive partition,
both contexts are stored in kernel memory. The hypercalls
are used by the partitions to invoke the kernel by execut-
ing the software interrupt instruction. The kernel provides
two types of hypercalls: message sending hypercall and sta-
tus switching hypercall. To send a message, the partition
executes the instruction “SWI 1”. The software interrupt
handler stores the message into the message-box of the re-
ceiver and restores the sender. The status switching hyper-
call changes the executing status of the partition by execut-
ing “SWI 0”. The kernel backs up the CPU state into its
own memory and reactivates the interrupted partition.

The irq-handler implements a static round-robin sched-
uler, that suspends the active partition and resumes the

226M (σ1) = usr ∧ (cid:104)σ1, t(cid:105) → (cid:104)σ(cid:48)

1, t(cid:48)(cid:105)

(cid:104)σ1, σ2, c1, c2, t, 1(cid:105) → (cid:104)σ(cid:48)

1, σ2, c1, c2, t(cid:48), 1(cid:105)

UserR

M (σ1) = irq ∧ (c2.msg =⊥ ∨¬c2.rdy)

(cid:104)σ1, σ2, c1, c2, t, 1(cid:105) → (cid:104)RestoreUser (σ1), σ2, c1, c2, t + tsh , 2(cid:105)

M (σ1) = svc ∧ curr (σ1) = SWI 0
(σ(cid:48)
1, c(cid:48)
1) = Switch(RestoreUsr (σ1), c1)

(cid:104)σ1, σ2, c1, c2, t, 1(cid:105) → (cid:104)σ(cid:48)

1, σ2, c(cid:48)

M (σ1) = irq ∧ c2.rdy ∧ c2.msg (cid:54)=⊥

2) = Receive(σ2, c2)
(cid:104)σ1, σ2, c1, c2, t, 1(cid:105) → (cid:104)RestoreUsr (σ1), σ(cid:48)

(σ(cid:48)

2, c(cid:48)

2, c1, c(cid:48)

2, t + trcv , 2(cid:105)

SwitchR

1, c2, t + tswitch , 1(cid:105)
2 = (cid:104)c2.rdy, c2.ctx , Out(σ1)(cid:105)
c(cid:48)

M (σ1) = svc ∧ curr (σ1) = SWI 1

(cid:104)σ1, σ2, c1, c2, t, 1(cid:105) → (cid:104)IncPC (RestoreUsr (σ1)), σ2, c1, c(cid:48)

2, t + tsnd , 1(cid:105)

SendR

SchR

RcvR

Figure 3: Semantics of the Ideal System

of each machine points to the entry point of the correspond-
ing partition, and both machines are in the mode usr .

Figure 3 shows the semantics of the ideal system when
machine 1 is active. Due to lack of space, we only present the
semantics of hypercalls and scheduling. In all cases, the ideal
transitions yield the two machines in user mode. The rules
for machine 2 active are similar. Each kernel functionality
f comes with a ﬁxed time budget tf for its execution.

The rule UserR states that if the processor is in user mode,
execution of an instruction does not aﬀect the state of the
logical component and the inactive machine, and it behaves
as if it is executed on a regular ARMv7 machine. Instruc-
tions consume the same amount of cycles in the real and
ideal systems.

A machine is rescheduled whenever a hardware interrupt
is triggered by the timer. The function RestoreUser restores
user mode and the corresponding banked registers. The rule
SchR describes that if there is no message for the resumed
machine or the resumed machine is not ready to handle a
message, the active partition is changed to the current sus-
pended one. The rule RcvR expresses the reception of a
pending message by the resumed machine in which the func-
tion receive(σ2, c2) disables the rdy ﬂag for entering into a
critical section, moves the pending message into the input
buﬀer of the receiver, and sets the program counter to point
to the message handler of the receiver.

The rule SendR describes the semantics of message send-
ing (activated due to the execution of “SWI 1” in the pre-
vious state) that copies the message into the message box
of the inactive machine.
If the status switch hypercall is
invoked, the rule SwitchR toggles the rdy ﬂag and restores
the banked context.

Figure 2 (B) depicts an example computation of an ideal
system. In the states 2, 6 and 12 the system traps an ex-
ception raised on the active machine and atomically applies
an ideal kernel functionality.

5. PROOF STRATEGY

To prove that the real model does not introduce infor-
mation channels not already present in the ideal model it
suﬃces to show that the observable traces for each parti-
tion are the same in both cases. In order to pin down this
concept we need to deﬁne when each partition system is in
control of the system, and what its observations are.

Top Level Proof Goal.

Intuitively, for the real system, partition g is in control
when its program counter points to a location in mem g.
However, this is not entirely accurate. Instead we say that
partition g is active in state s, act g(s), if the processor is in
user mode and the status of the domain g, held by copro-
cessor register c3 is client. For the ideal system, partition g
is active, act g(q), if the id ﬁeld of the ideal state is g and
the corresponding machine is in the user mode.

The observations of partition g in real state s, assum-
ing that g is active, are the CPU and memory resources
observable by g in state s. This is the structure Og(s) =
(cid:104)uregs, cpsr , mem g(cid:105) of user registers, cpsr and partition mem-
ory in state s. If g is inactive in s, g’s observations are the
user registers and cpsr of the saved context of g along with
its partition memory. For the ideal system, Og(q) is the
user registers, cpsr and the memory allocated to g of the
corresponding machine in q.
Consider now an inﬁnite execution πr = s0 −→ s1 −→ ··· of
the real system. The g-trace of πr is the sequence ω(πr, g) of
observations obtained by ﬁrst projecting out those states for
which g is not active, and secondly extracting g’s observa-
tions, or in other words, ω(πr, g) = map(Og, prj (πr, act g))
where prj and map are the obvious projection/ﬁltering func-
tions. Similarly, if πi is an ideal execution, the g-trace of πi
is ω(πi, g) = map(Og, prj (πi, act g)).

Let now tr g,r(mem 1, mem 2) and tr g,i(mem 1, mem 2) be
the set of g-traces of the real system and the ideal system
with the initial partition memories of mem1 and mem2, re-
spectively, and for arbitrary states s, q, let tr g(s) and tr g(q)
be the sets of g-traces of executions starting in s, q, respec-
tively. The top level proof goal is thus to prove that the sets
of g-traces of the real and the ideal systems are identical,
for g ∈ {1, 2} and any arbitrary mem 1 and mem 2, or, more
precisely, that

tr g,r(mem 1, mem 2) = tr g,i(mem 1, mem 2)

(1)

for all initial partition memories mem 1, mem 2. If (1) holds
we say that the PROSPER kernel guarantees isolation.

In order to prove (1), we ﬁrst present three general lemmas
concerning the safe executions of an ARM machine in user
mode and its safe mode switching from user mode to priv-
ileged mode. Given the general ARM Lemmas, we prove
lemmas for the real and the ideal systems to ensure cor-
rect initialization, correct userland execution, and isolation-
guaranteed execution of the kernel handlers. We then pro-
ceed to present the proof of (1).

227ARM Lemmas.

Our proof strategy identiﬁes three lemmas concerning the
ARM instruction set architecture that may have signiﬁcance
beyond the veriﬁcation exercise reported here. The ﬁrst is a
general noninterference lemma stating that if an ARM ma-
chine executes in user mode in a memory protected conﬁg-
uration as studied here, the behavior of the active partition
is inﬂuenced only by those resources allowed to do so. The
predicate simg(s1, s2) indicates that the status of the do-
main g held by coprocessor register c3 is client in the user
mode states s1 and s2, and they have the same user regis-
ters, cpsr, MMU conﬁgurations and the memory allocated
to the domain g.

Lemma 1. If simg(s1, s2) and s1 → s(cid:48)

1, there exists s(cid:48)

2

s.t. s2 → s(cid:48)

2 and simg(s(cid:48)

1, s(cid:48)

2), and vice versa.

The second lemma establishes unmodiﬁed g(s, s(cid:48)) stating
that the non-accessible resources for a state s in user mode,
including the privileged psrs/registers, coprocessor registers,
interrupt ﬂags and the memory regions not allocated to the
active partition g, are not modiﬁed in a transition from s
to another user mode state s(cid:48). If s(cid:48) is in privileged mode
m, the privileged registers, psr m and the interrupt ﬂags, are
excluded from the non-modiﬁable resources. We obtain:

Lemma 2. If s → s(cid:48) and act g(s) then unmodiﬁed g(s, s(cid:48)).
The predicate priv const g(s, s(cid:48)) asserts that if an ARM
machine switches from s in user mode to s(cid:48) in privileged
mode m then the conditions for the execution of the handler
are prepared properly, e.g., the program counter points to
the correct entry of the vector table, the link register of m
contains the correct return address of the partition, and the
ﬂags of cpsr and psr m are set correctly.

Lemma 3. Suppose s → s(cid:48), act g(s) and M (s(cid:48)) (cid:54)= usr.

Then priv const g(s, s(cid:48)).

(g, m)-Compatible States.

We then turn to the conditions needed to ensure that the
partition observations are the same in the real and the ideal
systems. These conditions depend on many aspects of the
machine states and we are only able to outline the conditions
here.

These conditions are complex because several elements
can directly or indirectly inﬂuence the behavior of a par-
tition. We brieﬂy deﬁne the conditions for the user mode
states (i.e. when all machines are in the user mode) and
the switched mode states (i.e. the inactive machine of ideal
machine is in the user mode but the real system and the
active machine of ideal system have recently switched to the
privileged mode).

Say that two states s and q are (g, m)-compatible if (i) s
and q are in the mode m, (ii) g is the last active partition in
s and q, i.e. the status of the domain g, held by coprocessor
register c3 is client in s, and the id ﬁeld of the ideal state
is g, (iii) the partitions have the same observations in s and
q, Og(cid:48) (s) = Og(cid:48) (q) for g(cid:48) ∈ {1, 2}, (iv) the values of data-
structures in the logical component of state q agree with
the values of corresponding data structures in the kernel of
state s, e.g. the message box of a partition in the kernel
and the logical component contain the same values, (v) the

MMU and coprocessors are conﬁgured correctly in all three
machines, (vi) a set of invariants are held by the kernel data-
structure in s, (vii) the interrupt ﬂags are set correctly, e.g.
the fast interrupt ﬂag F of all machines are disabled, (viii)
if m is a privileged mode then psr m and the link register
of the mode m must be identical in the active machine of q
and s, to make sure that g is restored properly, (ix) s and q
have the same system clock.

User/Handler Lemmas.

The relation of (g,m)-compatibility is our candidate un-
it is in some suitable sense which we
winding relation, i.e.
go on to make precise preserved under computation. This
involves showing the following two key properties:

• User Lemma: Each user mode transition in the real
system is matched (in the sense of (g,m)-compatibility)
by a corresponding user mode transition in the ideal
system without interfering with the resources that are
not intended to be accessible by the partition, and vice
versa.

• Handler Lemma: Each complete handler execution in
the real system is matched (as (g,m)-compatibility) by
a corresponding execution of a kernel functionality in
the ideal model, and vice versa.

Similar to the unmodiﬁed g predicate for the real system
above, unmodiﬁed g(q, q(cid:48)) holds if the logical component, the
inactive machine, and the non-accessible resources of the ac-
tive machine are unmodiﬁed by an ideal transition from q
to q(cid:48) when g is active in q. The User Lemma then follows
from the ﬁrst and second ARM Lemmas as follows:

Lemma 4

(User). For all (g, usr)-compatible states s

and q, if q → q(cid:48) then there exist s(cid:48) and m such that
(i) s → s(cid:48),
(ii) the states s(cid:48) and q(cid:48) are (g, m)-compatible,
(iii) unmodiﬁed g(s, s(cid:48)), and (iv) unmodiﬁed g(q, q(cid:48)).
Vice versa, if s → s(cid:48) then q(cid:48) and m exists such that q → q(cid:48)
and the above properties (ii) and (iii) hold.

For the Handler Lemma we need to ensure that execution
of the kernel handlers terminates, and that the compatibil-
ity conditions are satisﬁed when the control returns back to
the partitions. Let s0 (cid:32) sn if there is a ﬁnite execution
s0 −→ ··· −→ sn such that M (sn) = usr and M (sj) (cid:54)= usr
for 0 < j < n. Similarly, we deﬁne (cid:32) for the ideal sys-
tem. These state relations are represented in Fig. 2 by the
dashed arrows. The additional black states in the real world
are internal kernel steps that can not be observed by the
partitions.

Lemma 5

(Handler). Suppose that s and q are two
(g, m)-compatible states, m (cid:54)= usr. Assume s and q are
respectively reached by a transition from the states s(cid:48) and q(cid:48),
and priv const g(q, q(cid:48)) and priv const g(s, s(cid:48)) hold. If q(cid:48) (cid:32) q(cid:48)(cid:48)
then there exist s(cid:48)(cid:48) and g(cid:48) ∈ {1, 2} such that s(cid:48) (cid:32) s(cid:48)(cid:48), and
the states s(cid:48)(cid:48) and q(cid:48)(cid:48) are (g(cid:48), usr)-compatible, and vice versa.

Furthermore, it is to be guaranteed that the initial states
of the real and the ideal systems are compatible. That is,

228we must verify that the MMU is set up according to our
model requirements, the kernel invariants are satisﬁed, the
partitions memory and the interrupt ﬂags are conﬁgured cor-
rectly. In addition, we must make sure that the kernel code
is loaded in the right part of the memory.

Proposition 1. For all initial partition memories mem 1,
mem 2, the kernel boot terminates in the state s0, and there
exists g ∈ {1, 2} s.t. s0 and q0 are (g, usr)-compatible

Proof of Main Theorem.

We can now proceed to prove (1). This is almost done once
we show that the initial states are related by a bisimulation
relation of a suitable form. To this end say that a relation
R on pairs (s, q) of user mode states is a candidate relation,
if whenever sRq then for some g ∈ {1, 2}, (i) act g(s), (ii)
act g(q), (iii) Og(s) = Og(q), and (iv) if q (cid:32) q(cid:48), then there
exists s(cid:48) such that s (cid:32) s(cid:48) and s(cid:48)Rq(cid:48), and (v) vice versa, if
s (cid:32) s(cid:48), then there exists q(cid:48) such that q (cid:32) q(cid:48) and s(cid:48)Rq(cid:48).
Note that for the user mode states s and s(cid:48), if s → s(cid:48)
then s (cid:32) s(cid:48). In Fig. 2, dotted lines exemplify a bisimulation
relation. It is easy to check that the existence of a candidate
relation is suﬃcient to ensure (1). In particular:

Proposition 2. Suppose that sRq for some candidate re-

lation R. Then tr g(s) = tr g(q).

Theorem 1. The PROSPER separation kernel guaran-

tees isolation.

The proof of 1 obviously relies on the proofs of the above
lemmas, which in turn, for Handler Lemma and the Lemma
1, relies on veriﬁcation of the handler and the bootstrap
code, as outlined in Section 7. But, it may be illustrative to
explain how these lemma come together to allow the main
Theorem 1 to be proved.

By Theorem 1 it suﬃces to ﬁnd a candidate relation relat-
ing the initial states s0 and q0. Deﬁne the candidate relation
as follows:

R = {(s, q)|(g, usr)-compatible(s, q) ∧ g ∈ {1, 2}}

We get s0Rq0 by prop. 1.

To prove that R is a candidate relation, assume that sRq.
Then s and q are (g, usr)-compatible. Thus, act g(s), act g(q)
and Og(s) = Og(q) hold.

Suppose now that q (cid:32) q(cid:48). There are two cases:

Case 1: If the ideal transition does not involve mode switch-
ing it follows from the User Lemma that s(cid:48) exists such that
s (cid:32) s(cid:48) and q(cid:48) and s(cid:48) are (g, usr)-compatible, whence s(cid:48)Rq(cid:48)
as desired.

If the ideal transition involves a switch to priv-
Case 2:
ileged mode m, it follows from the User Lemma that the
real and ideal system evolve to the (g, m)-compatible states
s(cid:48)(cid:48) and q(cid:48)(cid:48). According to the Third ARM Lemma, these
transitions are performed safely, i.e. priv const g(s, s(cid:48)(cid:48)) and
priv const g(q, q(cid:48)(cid:48)) hold. From the Handler Lemma, we can
conclude that there exist (g(cid:48), usr)-compatible states s(cid:48) and
q(cid:48) where s(cid:48)(cid:48) (cid:32) s(cid:48), q(cid:48)(cid:48) (cid:32) q(cid:48) and g(cid:48) ∈ {1, 2}. But then s(cid:48)Rq(cid:48),
as desired.
The converse direction, that s (cid:32) s(cid:48) implies q (cid:32) q(cid:48) and
s(cid:48)Rq(cid:48) for some q follows by a symmetric argument (or, in
this simple case, by determinacy of the (cid:32) relation). This
concludes the proof of Theorem 1.

6.

ISOLATION PROPERTIES

The main theorem shows that the real system does not
leak more information than the ideal system, under the
caveats we have imposed. However, it may not be clear what
information is leaked by the ideal system itself. Neither may
it be clear how leakage properties of the ideal system can be
transferred to the real system. In this section we throw light
on these two issues.

Data Separation.

Concerning the ideal system itself we use the approach
of [12] to analyze kernel data separation properties. Let
Qc = {q|∃s. sRq} be the image of the candidate relation.

The No-Exﬁltration property guarantees that a transition
with the partition g active in its target, does not modify the
resources of the other partition, except its communication
channel, i.e. the message box:

Lemma 6. Let g, g(cid:48) ∈ {1, 2}, g(cid:48) (cid:54)= g and q ∈ Qc. If q (cid:32) q(cid:48)
and q(cid:48).id = g, then Og(cid:48) (q) = Og(cid:48) (q(cid:48)), q.cg(cid:48) .rdy = q(cid:48).cg(cid:48) .rdy
and q.cg(cid:48) .ctx = q(cid:48).cg(cid:48) .ctx.

The No-Inﬁltration property is a noninterference property
guaranteeing that a transition for which g is active in its
target state, depends only on the partition observations, its
logical component and the MMU conﬁguration. In particu-
lar, a transition ending in a state with the partition g active,
is not inﬂuenced by data owned by the other partition.

Lemma 7. Let q1, q2 ∈ Qc such that q1.cg = q2.cg, q1.t =
1, q2 (cid:32)
q2.t, q1.id = q2.id and Og(q1) = Og(q2). If q1 (cid:32) q(cid:48)
q(cid:48)
1.t = q(cid:48)
2, act g(q(cid:48)
2.t and
Og(q(cid:48)

1) and act g(q(cid:48)

1) = Og(q(cid:48)
2)

2) then q(cid:48)

1.cg = q(cid:48)

2.cg, q(cid:48)

Similar properties can be proven for the real system using
the candidate relation and the properties of the ideal sys-
tem. Let Sc = {s|∃q. sRq} be the preimage of the candidate
relation, and the function lcg(s) extracts from the kernel
memory the content of the data-structure that corresponds
to cg in the logical component. The following corollary states
the no-inﬁltration and no-exﬁltration for the real system.

Corollary 1. Let s1, s2 ∈ Sc, s1.t = s2.t, act g(s1) ⇔

act g(s2).

• Suppose if g(cid:48) (cid:54)= g, s1 (cid:32) s(cid:48)

1 and act g(s(cid:48)

Og(cid:48) (s(cid:48)
lcg(cid:48) (s(cid:48)

1), lcg(cid:48) (s1).rdy = lcg(cid:48) (s(cid:48)
1).ctx.

1) then Og(cid:48) (s1) =
1).rdy and lcg(cid:48) (s1).ctx =

• Suppose if lcg(s1) = lcg(s2) , Og(s1) = Og(s2), s1 (cid:32)
1) =

1) and act g(s(cid:48)

2) then lcg(s(cid:48)

2, act g(s(cid:48)

1 and s2 (cid:32) s(cid:48)
s(cid:48)
lcg(s(cid:48)

2) and Og(s(cid:48)

1) = Og(s(cid:48)
2)

We sketch the proof of the second statement. Since s1 and
s2 are in Sc, then there exist q1 and q2 s.t. s1Rq1 and s2Rq2.
We follow from the assumptions and the deﬁnition of R that
q1.cg = q2.cg, q1.t = q2.t, Og(q1) = Og(q2) and q1.idx =
q2.idx. Since the candidate relation is a bisimulation, then
for j = 1, 2, there exists q(cid:48)
j. Thus,
act g(q(cid:48)
j). We conclude
the proof by showing that Og(q(cid:48)
2.cg
according to the Lemma 7.

j s.t. qj (cid:32) q(cid:48)
1) = Og(q(cid:48)

jRq(cid:48)
1.cg = q(cid:48)

j and s(cid:48)
2) and q(cid:48)

j.cg and Og(s(cid:48)

j) = Og(q(cid:48)

j), lcg(s(cid:48)

j) = q(cid:48)

229Noninterference.

The no-exﬁltration/no-inﬁltration properties give limited
data separation properties at the level of single transitions.
They do not, however, lift to executions, because messages
may be passed between partitions which can introduce ex-
plicit data dependencies. As a sanity check, we therefore
show how the security condition is reduced to noninterfer-
ence in the special case where no exception except timer
signal takes place. This property formalizes the intuition
that if the partition g does not communicate, then the ex-
ecution of the other partition is completely independent of
activities of g.
A partition with the initial memory mem is called non-
communicating, if for all arbitrary mem(cid:48) and all states q
that are reachable from the initial state of Ti(mem, mem(cid:48)),
M (q.σ1) = {usr, irq} holds.

Theorem 2. For any two non-communicating partitions
1, and an arbitrary

with the initial memories mem 1 and mem(cid:48)
partition with the initial memory mem 2,

tr 1,i(mem 1, mem 2) = tr 1,i(mem

(cid:48)
1, mem 2)

The symmetric theorem is proved when the non- com-
municating partition is deployed on the second machine.
The state of a machine can be externally changed only by
the reception of a message. Since the non-communicating
partition never raises an exception, it can not execute the
software interrupt and it can not send a message. More-
over, the system clock, shared between the two machines,
must be independent of the activity performed by the non-
communicating machine. This is possible because we assume
that all transitions, with the exception of the ideal function-
alities, require one clock cycle. Note that the candidate
relation allows Theorem 2 to be directly transferred to the
real system. The details are left out.

7. PROOF IMPLEMENTATION

The overall proof is carried out in the HOL4 theorem
prover, following the proof strategy presented in Section 5.
For those parts (the Handler Lemma and Proposition 1) that
depend on kernel code we generate contracts and transfer
the veriﬁcation to BAP. To realize this we have produced a
number of helper tools of which the main ones are: (i) an
ARMv7 prover tool implemented in SML/HOL4, (ii) vari-
ous tools and tool components interfacing HOL4 with BAP,
(iii) a lifter tool to convert ARM assembly to BAP’s input
language. Space prevents us from more than outlining the
BAP extensions and the proof of the ARM Lemmas here;
these will be reported in separate publications.
7.1 Veriﬁcation in HOL4

Overview of the ARM Model.

We use Fox et al’s monadic HOL4 model of the ARMv7
instruction set architecture. The model has been validated
against a development board, giving some credence to its
accuracy [7].

A computation in the monadic HOL4 ARM model is a

term of type

α M = arm state (cid:55)→ (α × arm state)error option.

a return value a of type α, or an error Error e. Errors rep-
resent all unpredictable computations, i.e., those that are
underspeciﬁed by the ARM speciﬁcation. The monad unit
injects a value into a computation, while binding is a sequen-
tial composition operation which passes the return value of
the ﬁrst computation to the input parameters of the second
one as follows:
f (cid:29)= g = (λs.

case f s of Error e (cid:55)→ Error e
|| ValueState y t (cid:55)→ g y t )

The execution of an ARM instruction is deﬁned by the
computation arm next modeling the entire processing of an
instruction, from fetching the instruction pointed to by the
program counter to the actual instruction execution.

The MMU Extension.

We extend the ARM model to support the MMU func-
tionality in our setting. Given the complexity of memory
management, the model is restricted to support only those
parts of the MMU functionality used by the PROSPER ker-
nel.2 We also proved that the MMU conﬁgurations of all
reachable states are supported by the extended model and
not underspeciﬁed. The original ARM model tracks the his-
tory of memory accesses, allowing to compute the set of
memory pages accessed by an instruction. To be accurate,
it is necessary to check the access list after each primitive
computation. To this end, the monadic structure is mod-
iﬁed so that access history checks are introduced at every
sequential composition of two computations. In case of an
access violation within the ﬁrst computation, the second one
is simply disregarded, returning the unspeciﬁed value ARB
along with the ﬁrst state where an access violation has been
recorded.

f (cid:29)= g = (λs.

case f s of Error e (cid:55)→ Error e
|| ValueState y t (cid:55)→
(if (access_violation t)
then (ValueState ARB t)
else (g y t)) )

Proof of the ARM Lemmas.

We use a relational Hoare logic framework to prove the
ARM Lemmas. For technical reasons we formulate the three
ARM Lemmas as a single statement. For any computa-
tion f and predicates p1, p2, we deﬁne a relational predicate
preserving(f, p1, p2) stating that, when starting from two
states in the relation simg and satisfying p1, then the states
returned by f (i) are in the relation simg, (ii) satisfy the non-
modiﬁcation and mode-switching constraints, as presented
in Section 5, and (iii) satisfy p2. The state predicates p1 and
p2 allow processor mode speciﬁc reasoning. The ﬁnal goal is
to show that the MMU-enabled variant of arm next satisﬁes
preserving when starting from user mode.

A set of sound inference rules have been implemented in
a semi-automatic HOL4 helper tool. An example is the rule
for sequential composition:

preserving(f1, p1, p1)

preserving(f2, p1, p2)

preserving(f1 (cid:29)= (λx.f2), p1, (p1 ∨ p2))

Computations act on a state arm state and return either
ValueState a s, a new state s of type arm state along with

2Only section-based one-level page tables without address
translation are supported so far.

230The tool recognizes the structure of a computation, decom-
poses the veriﬁcation goal in a set of sub-goals, proves the
sub-goals recursively and applies the suitable inference rule
to infer the initial goal. Moreover, it searches in the HOL4
database and the user-provided theorems to ﬁnd a suitable
theorem that can prove the goal. We prove preserving for
the write primitive computations manually, but the tool can
handle some read computations automatically, allowing to
prove a large share of the workload automatically.

Generation of Pre- and Postconditions.

HOL4 is also used to generate pre- and postconditions for
the kernel handlers, for subsequent veriﬁcation with BAP.
Consider a handler with the starting state s1 in mode m such
that s1 (cid:32) s2. Suppose that s1 and q1 are (g, m)-compatible
such that q1 is the starting state of the corresponding ideal
handler functionality. Let q2 be a state such that q1 (cid:32) q2.
These conditions allow to automatically generate the pre-
condition of the handler under which the ﬁnal state s2 will
be (g, usr)-compatible with q2. The preconditions are gen-
erated by the hypotheses of the Handler Lemma: the start-
ing state of the kernel handler s1 is (g, m)-compatible with
q1, and there are s0 and q0, such that priv const g(q0, q1),
priv const g(s0, s1), and s0 and q0 are in the candidate rela-
tion.

7.2 Binary Code Veriﬁcation

The kernel code veriﬁcation relies on Hoare logic. To prove
the Handler Lemma and Proposition 1, we are required to
verify several Hoare triples {P}C{Q} for the exception han-
dlers and the bootstrap code, that is we check that if the
precondition P holds in the starting state of C, then the
postcondition Q is guaranteed by C. When possible, we
adopt a standard semi-automatic strategy, i.e. ﬁrstly, we
compute the weakest liberal precondition wlp(C, Q) on the
starting state, then prove that the precondition P implies
the weakest precondition. This task can be fully automated
if the predicate P =⇒ wlp(C, Q) is equivalent to a predi-
cate of the form ∀x.A where A is quantiﬁer free. The valid-
ity of A can then be checked using a Satisﬁability Modulo
Theory (SMT) solver that supports bitvectors to handle op-
erations on words. In this work, we used STP [9].

Weakest preconditions can be computed directly in HOL4
using the ARMv7 model. However, this task requires a sig-
niﬁcant engineering eﬀort. We adopted a more practical
approach, by using (BAP) [6]. The BAP toolset provides
platform-independent utilities to extract control ﬂow graphs
and program dependence graphs, to perform symbolic exe-
cution and to perform wp calculations. These utilities reason
on the BAP Intermediate Language (BIL), a small and for-
mally speciﬁed language that models instruction evaluation
as compositions of variable reads and writes in a functional
style.

We found the existing BAP front-end to translate ARM
programs to BIL inadequate for our purpose: It supports
only ARMv4, it does not manage the processor status reg-
isters, and it does not handle banked registers for the privi-
leged modes and coprocessor management. To this end, we
developed a new front-end for ARMv7 programs using the
ARM model available in HOL4. This tool allows us to trans-
late the code of the kernel handlers and the bootstrap into
BIL.

The HOL4 ARM model provides the function arm_steps
to compute the set of pairs (cid:104)c1, t1(cid:105), . . .(cid:104)cn, tn(cid:105) for an in-
struction where the function ti transforms a state provided
that the condition ci holds on that state. In other words,
∀s:arm_state arm_next s = ValueState () ti(s) if ci(s).
In order to use arm_steps, the execution mode and the in-
struction set type (e.g. Thumb, ARM) must be known.
Our handlers preconditions set the value of these param-
eters. The translation from ARM to BIL is performed by
translating the HOL4 conditions ci and functions ti to BIL
fragments.

Verifying the Hoare triples using weakest preconditions
requires us to handle some common issues. Algorithms to
compute weakest preconditions rely on the absence of indi-
rect jumps, i.e. the jumps whose target address is a variable.
We used the SMT solver to automatically compute jump
targets, depending on the instruction precondition. Weak-
est preconditions can grow exponentially in the number of
instructions. We extended BAP to simplify the weakest pre-
condition during its backward propagation using ARM spe-
ciﬁc simpliﬁcation patterns. Finally, our veriﬁcation task
has been simpliﬁed by the structure of the kernel code. All
loops of the kernel have a single control ﬂow node that rep-
resents both the entry point and the exit point of the loop.
In the general case, we deﬁned a loop invariant and a loop
variant and applied the standard Hoare logic rules to prove
the contract. Veriﬁcation has been simpliﬁed by the absence
of loops in the kernel handlers and the fact that the boot
code contains only for-loops that iterate over integer sets.

8. EVALUATION

We tested the kernel implementation using OVP [21] as
main execution environment, which provides a simulation
infrastructure convenient to evaluate our kernel. Slightly
diﬀerent versions of the kernel have been deployed on Bea-
gleboard, Beagleboard-XM, Beaglebone, NovaThor and the
Integrator development board. The size of kernel code, in-
ternal data-structures and page table are respectively less
than 4 kB, 2 kB and 16 kB. The main functionality of the
kernel is provided by the software and hardware interrupt
handlers.
In the worst case, the hardware interrupt han-
dler executes 112 instructions, including 48 reading and 22
writing accesses to the memory. Similarly, the software in-
terrupt handler executes at most 46 instructions, including
20 reading and 8 writing accesses to the memory. All the
memory locations accessed by the kernel handlers belong to
the internal kernel data-structures. To minimize the system
overhead and avoid accesses to system memory during ker-
nel tasks, we can use scratchpad memory or cache locking
due to the size of the run-time footprint.

We identiﬁed and ﬁxed several bugs in the kernel imple-
mentation during the veriﬁcation process: (i) the registers
were not sanitized after the bootstrap, (ii) some of the ex-
ecution ﬂags were not correctly restored during the context
switch, (iii) the procedure to decode the hypercall identiﬁer
did not consider the case that the partition is running in
thumb execution mode.

The model of the ideal system, the formalization of the
veriﬁcation procedure and the proofs of the theorems consist
of 21k lines of HOL4 code. The tools developed to support
the veriﬁcation of the kernel contracts required 2k lines of
HOL4 and python code. The kernel binary code is veriﬁed
with respect to sixteen contracts, each of them consisting

231of ∼ 400 lines of assertions that are automatically gener-
ated from HOL4. In the worst case, the veriﬁcation of one
contract required ∼ 30 minutes using one Intel(R) Xeon(R)
X3470 core; the contract is generated in ∼ 5 minutes, the
indirect jumps are solved in ∼ 2 minutes, the weakest pre-
condition is computed in ∼ 10 minutes and the SMT solver
veriﬁes the validity of the resulting condition in ∼ 15 min-
utes.

9. RELATED WORKS

Past work on formal veriﬁcation of kernel information ﬂow
properties [12, 19, 23, 4] are based on variants of noninter-
ference [11]. Typically, the goal is to allow a number of
component systems, partitions, or guest systems, depend-
ing on terminology, to share a computing platform without
any interaction, leaving possible communication between the
partitions to be managed by mechanisms outside the model.
In Heitmeyer et al [12], for instance, partitions have explicit
input and output buﬀers, but communication is delegated
to external agents, in this way allowing properties like ab-
sence of inﬁltration (roughly: direct ﬂows) and exﬁltration
(indirect ﬂows) to be proved. Similar results are reported in
[23, 4] and in [30] at the ﬁrmware level. Murray et al [20]
considers noninterference in presence of a dynamic scheduler
and uses a version of intransitive noninterference [24] (actu-
ally, NI) to allow a scheduler to inﬂuence which partition is
scheduled, without permitting the scheduler to be used as a
covert channel, as discussed brieﬂy in the introduction.

Several recent works address hypervisor/microkernel ver-
iﬁcation, although without taking information ﬂow into ac-
count. In [14] a simulation property of an entire microkernel
down to a C implementation was veriﬁed using the Isabelle
theorem prover. This work was recently extended to ARM
assembly using decompilation techniques [29]. Alkassar et
al [2] proposed an automatic approach to verify a hypervi-
sor for a (simpliﬁed) MIPS machine by annotating the C
code with contracts and checking them using VCC. They
establish a reachability property: at any time the state of a
partition can be reached by executing the same partition on
a completely isolated machine. This is suﬃcient to estab-
lish simulation when the speciﬁcation is deterministic (but
not otherwise). To allow VCC to reason about statically un-
known partitions/guests, a C emulator of the MIPS machine
has been implemented and annotated. The C emulator has
been adopted also to verify parts of the hypervisor that mix
C and assembly code [22].

Most kernel security analyses address the kernel routines
one at a time, using suitable relational speciﬁcations. With-
out verifying the correct interaction between the kernel rou-
tines and the processor (e.g. mode switching and memory
protection), these speciﬁcations are not suﬃcient to guar-
antee security at system level, i.e. at the level of “full” ex-
ecutions that interleave kernel routines with userland ex-
ecution of the partitions. Performing such a systems-level,
integrated analysis (kernel and processor) has not been done
before for realistic processor architectures. For instance [30,
19] address kernel routines but not the processor interac-
tion. Analysing each kernel routine in isolation can be done
using existing versions of conditional non-interference (as
discussed in [19]). However, this does not guarantee infor-
mation ﬂow security at system level. Our approach to for-
mulating the TLS using idealized userland processors solves

this problem, simply by showing that the full executions for
the ideal and the real model are the same.

Barthe et al. [4] formalized a hypervisor model using the
Coq proof assistant. They focus on establishing that the
hypervisor ensures isolation properties between the guests,
abstracting away from actual hypervisor implementation.

10. DISCUSSION

We have presented a separation kernel, the PROSPER
kernel, for ARMv7-A and a machine-assisted proof of infor-
mation ﬂow correctness using a combination of tools (HOL4
[13] and BAP [6]). Our analysis has a number of distinguish-
ing features:

• Our top-level speciﬁcation (TLS) and veriﬁcation ap-
proach is deliberately designed to take inter-component
communication into account, an ever present challenge
in the veriﬁcation of information ﬂow properties for
real systems.

• We introduce a new technique for building a TLS for
this type of application, based on communicating ide-
alized userland processors.

• The security analysis is performed at systems level,
modeling both the MMU-constrained user space exe-
cution of arbitrary partitions, the kernel handlers, and
the interaction of the two.

• We validate the “monotonicity or release” property, as
suggested by Sabelfeld and Sands [26], by showing that
the security proof reduces to standard noninterference
for the special case of non-communicating partitions.
• The entire analysis is performed at machine code level

for a commodity processor architecture.

A number of subsidiary contributions include several tools
for managing and executing the proofs, including the ARM
prover tool for verifying critical partition correctness prop-
erties of the ARMv7 machine architecture based on an ex-
tension of Fox and Myreen’s monadic ARM semantics [7],
and several extensions to the BAP toolset.

By verifying the entire kernel at machine code level we
avoid reliance on a C compiler, and we can transparently
verify code that mix C and assembly. Generally speaking,
veriﬁcation at machine code level is time consuming, how-
ever we were supported by the fact that the code was mostly
compiler produced and loops were used in only a few places.
Since our TLS speciﬁes the exact set of traces allowed by
an implementation, a worry might be that the TLS becomes
overly detailed and unwieldy. We did not ﬁnd this to be the
case. Rather, the development of the ideal model, as we
progressed to understand the various issues involved, was a
great help in organizing the thinking.
It is true that our
approach (as in other work, cf.
[12]) precludes an abstract
treatment of scheduling, but this is to be expected when
information ﬂow is to be taken into account.

On two counts our model is not yet satisfactory. The ﬁrst
concerns timing. Our model counts instruction cycles 3, in-
stead of real clock cycles. In our implementation the former
is used. It is non-trivial to extend our analysis to a more

3This is the element of our “real system” that is not really
real.

232realistic time representation, as in this case well-known phe-
nomena such as cache delays and instruction pipelining come
into play. Cache leakage has been considered in the con-
text of virtualization by Barthe et al [5]. Zhang et al [31]
demonstrated an access-driven side-channel attack targeting
the Xen hypervisor. The authors (i) use interprocess inter-
rupts to aﬀect the Xen scheduler and to reduce the time slot
available to the victim and (ii) indirectly monitor the usage
of the instruction cache, which is shared among partitions.
Extending our approach to handle access-driven attacks re-
quires a more reﬁned analysis of timing behaviour, which is
part of our ongoing research eﬀorts.

The second count is unpredictable states. According to
the ARM Architecture Reference Manual [3], unpredictable
behaviour is not allowed to “perform any function that can-
not be performed at the current or lower level of privilege
using instructions that are not unpredictable”. This deﬁni-
tion is diﬃcult to accommodate in our framework. An in-
terpretation of allowed behaviour which is adequate for our
purpose is “compliant with the ARM Lemmas”. This enables
our proofs to go through, and in fact we posit that this may
be a more helpful and less prescriptive deﬁnition than that
of [3]. Practically, the ARM Lemmas can be used to certify
if a speciﬁc ARMv7-A implementation can be used to host
our kernel. In the proof implementation we have used the
error states introduced in the monadic ARM HOL4 model.
This is not really satisfactory, though, as this allows parti-
tions to exit the scope of our model at will, by entering an
unpredictable state. We leave a better treatment of unpre-
dictable behaviour, in addition to more realistic hardware
models and kernel functionality, to future work.

Finally we emphasize that virtualization and/or separa-
tion kernels are not the only tools available for secure parti-
tioning. The ARM-proprietary TrustZone solution [1] adds
to the standard ARMv7 architecture a secure partition that
can be used to split the CPU resources between an untrusted
and a trusted OS. Our results show that the kernel can be
protected using standard, less expensive hardware, and a
smaller TCB. Moreover, extending the proposed veriﬁcation
strategy can be straightforwardly extended to manage a dif-
ferent number (>2) of partitions.

11. ACKNOWLEDGMENTS

Work supported by framework grant “IT 2010” from the

Swedish Foundation for Strategic Research.

12. REFERENCES
[1] ARM TrustZone. http://www.arm.com/products/

processors/technologies/trustzone.php.

[2] E. Alkassar, M. A. Hillebrand, W. J. Paul, and

E. Petrova. Automated veriﬁcation of a small
hypervisor. In Proc. VSTTE, volume 6217 of Lecture
Notes in Computer Science, pages 40–54. Springer,
2010.

[3] ARMv7-A architecture reference manual.

http://infocenter.arm.com/help/index.jsp?
topic=/com.arm.doc.ddi0406c.

[4] G. Barthe, G. Betarte, J. D. Campo, and C. Luna.

Formally verifying isolation and availability in an
idealized model of virtualization. In Proc. FM’11,
volume 6664 of Lecture Notes in Computer Science,
pages 231–245. Springer, 2011.

[5] G. Barthe, G. Betarte, J. D. Campo, and C. Luna.

Cache-leakage resilient os isolation in an idealized
model of virtualization. In Proc. CSF’12, pages
186–197, Washington, DC, USA, 2012. IEEE
Computer Society.

[6] D. Brumley, I. Jager, T. Avgerinos, and E. J.

Schwartz. BAP: A binary analysis platform. In Proc.
CAV’11, volume 6806 of Lecture Notes in Computer
Science, pages 463–469. Springer, 2011.

[7] A. C. J. Fox and M. O. Myreen. A trustworthy

monadic formalization of the ARMv7 instruction set
architecture. In proc. ITP’10, volume 6172 of Lecture
Notes in Computer Science, pages 243–258. Springer,
2010.

[8] FreeRTOS. http://www.freertos.org/.
[9] V. Ganesh and D. L. Dill. A decision procedure for

bit-vectors and arrays. In Proc. CAV’07, volume 4590
of Lecture Notes in Computer Science, pages 519–531.
Springer, 2007.

[10] C. Gehrmann, H. Douglas, and D. Nilsson. Are there

good reasons for protecting mobile phones with
hypervisors? In Consumer Communications and
Networking Conference (CCNC), 2011 IEEE, pages
906 –911, jan. 2011.

[11] J. A. Goguen and J. Meseguer. Security policies and

security models. In IEEE Symposium on Security and
Privacy, pages 11–20, 1982.

[12] C. Heitmeyer, M. Archer, E. Leonard, and J. McLean.

Applying formal methods to a certiﬁably secure
software system. IEEE Trans. Softw. Eng.,
34(1):82–98, Jan. 2008.

[13] HOL4. http://hol.sourceforge.net/.
[14] G. Klein, K. Elphinstone, G. Heiser, J. Andronick,

D. Cock, P. Derrin, D. Elkaduwe, K. Engelhardt,
R. Kolanski, M. Norrish, T. Sewell, H. Tuch, and
S. Winwood. seL4: formal veriﬁcation of an OS kernel.
In Proc. SOSP’09, pages 207–220. ACM, 2009.

[15] P. C. Kocher. Timing attacks on implementations of

Diﬃe-Hellman, RSA, DSS, and other systems. In
Proceedings of the 16th Annual International
Cryptology Conference on Advances in Cryptology,
CRYPTO ’96, pages 104–113, London, UK, 1996.
Springer-Verlag.

[16] D. Leinenbach and T. Santen. Verifying the Microsoft

Hyper-V hypervisor with VCC. In Proc. FM’09,
volume 5850 of Lecture Notes in Computer Science,
pages 806–809. Springer Berlin Heidelberg, 2009.
[17] J. McDermott, B. Montrose, M. Li, J. Kirby, and
M. Kang. Separation virtual machine monitors. In
Proceedings of the 28th Annual Computer Security
Applications Conference, ACSAC ’12, pages 419–428,
New York, NY, USA, 2012. ACM.

[18] µClinux. http://www.uclinux.org/.
[19] T. C. Murray, D. Matichuk, M. Brassil, P. Gammie,

T. Bourke, S. Seefried, C. Lewis, X. Gao, and
G. Klein. seL4: From general purpose to a proof of
information ﬂow enforcement. In IEEE Symposium on
Security and Privacy, pages 415–429. IEEE Computer
Society, 2013.

[20] T. C. Murray, D. Matichuk, M. Brassil, P. Gammie,
and G. Klein. Noninterference for operating system
kernels. In CPP, volume 7679 of Lecture Notes in
Computer Science, pages 126–142. Springer, 2012.

233[21] Open Virtual Platforms. http://www.ovpworld.org/.
[22] W. J. Paul, S. Schmaltz, and A. Shadrin. Completing

the automated veriﬁcation of a small hypervisor -
assembler code veriﬁcation. In SEFM, volume 7504 of
Lecture Notes in Computer Science, pages 188–202.
Springer, 2012.

[23] R. Richards. Modeling and security analysis of a

commercial real-time operating system kernel. In D. S.
Hardin, editor, Design and Veriﬁcation of
Microprocessor Systems for High-Assurance
Applications, pages 301–322. Springer US, 2010.

[27] R. Sailer, E. Valdez, T. Jaeger, R. Perez, L. V. Doorn,
J. L. Griﬃn, S. Berger, R. Sailer, E. Valdez, T. Jaeger,
R. Perez, L. Doorn, J. Linwood, and G. S. Berger.
sHype: Secure hypervisor approach to trusted
virtualized systems. In IBM Research Report
RC23511, 2005.

[28] D. Sangiorgi. Introduction to Bisimulation and

Coinduction. Cambridge University Press, 2012.

[29] T. A. L. Sewell, M. O. Myreen, and G. Klein.

Translation validation for a veriﬁed os kernel. In Proc.
PLDI’13, pages 471–482, 2013.

[24] J. Rushby. Noninterference, transitivity, and

[30] M. M. Wilding, D. A. Greve, R. J. Richards, and D. S.

channel-control security policies. SRI International,
Computer Science Laboratory, 1992.

[25] J. M. Rushby. Design and veriﬁcation of secure
systems. In Proc. SOSP’81, pages 12–21, 1981.

[26] A. Sabelfeld and D. Sands. Declassiﬁcation:

Dimensions and principles. J. Comput. Secur.,
17(5):517–548, Oct. 2009.

Hardin. Formal veriﬁcation of partition management
for the AAMP7G microprocessor. In Design and
Veriﬁcation of Microprocessor Systems for
High-Assurance Applications, pages 175–191. Springer
US, 2010.

[31] Y. Zhang, A. Juels, M. K. Reiter, and T. Ristenpart.

Cross-VM side channels and their use to extract
private keys. In Proc. CCS’12, pages 305–316. ACM,
2012.

234