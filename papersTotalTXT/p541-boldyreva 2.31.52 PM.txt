Provable Security of S-BGP and other Path Vector

Protocols: Model, Analysis and Extensions

Alexandra Boldyreva

Georgia Institute of Technology, Atlanta, USA

sasha.boldyreva@cc.gatech.edu

ABSTRACT
This paper provides the provable-security treatment of path vector
routing protocols. We ﬁrst design a security deﬁnition for routing
path vector protocols by studying, generalizing, and formalizing
numerous known threats. Our model incorporates three major se-
curity goals.
It is quite strong, yet simple to use. We prove by
reduction that S-BGP satisﬁes two out of the security model’s three
goals, assuming the underlying signature scheme is secure. Under
the same assumption, we next show how the protocol can be mod-
iﬁed to meet all three security goals simultaneously. Finally, we
study security of partial PKI deployment of path vector protocols
when not all nodes have public keys. We investigate the possi-
bilities of relaxing the PKI requirement and relying on the non-
cryptographic physical security of the protocol in order to achieve
possibly weaker, but still well-deﬁned, notions of security. We also
present the necessary and sufﬁcient conditions to achieve full se-
curity in the partial PKI deployment scenario. We believe our con-
clusions will prove useful for protocol developers, standards bodies
and government agencies.

Categories and Subject Descriptors
C.2.2 [Network Protocols]: Routing Protocols, Protocol Veriﬁca-
tion

Keywords
Secure BGP, path vector protocols, provable security

1.

INTRODUCTION

MOTIVATION AND RELATED WORK. The Border Gateway Proto-
col (BGP) is currently the de facto standard for routing across the
Internet. Its current version, version 4, is deﬁned in a draft stan-
dard [44] and is in wide use. In the protocol, each router associated
with a particular autonomous system (AS)—an independent net-
work managed by a single administrative entity such as a Content
Provider or an Internet Service Provider (ISP)—maintains a list of
possible paths to various IP preﬁxes. Information about serviceable

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’12, October 16–18, 2012, Raleigh, North Carolina, USA.
Copyright 2012 ACM 978-1-4503-1651-4/12/10 ...$15.00.

Robert Lychev

Georgia Institute of Technology, Atlanta, USA

rlychev@cc.gatech.edu

preﬁxes is advertised to neighboring AS’s who propagate it to their
neighbors, and so on, so that reachability information is updated
globally.

BGP was designed to enable routing between parties that trust
each other and thus it lacks security features. Nowadays, however,
commercial interests invalidate the assumption of trust on the In-
ternet. Accordingly, the security of BGP has come under much
scrutiny [21, 38, 12, 40] because honest failures or malicious router
compromises may cause serious problems throughout the Internet.
For example, on April 25, 1997 an incorrect route map was injected
into the Internet forcing most Internet trafﬁc to be routed to a small
Internet Service Provider (ISP) in Virginia, crippling much of the
Internet for about two hours [13]. Similar misconﬁguration have
been recently documented for Pakistan and China [20, 25], as we
will discuss later in the paper. There is a widespread agreement
that due to increased importance of the Internet, it is extremely im-
portant to ensure security of its infrastructure. The Department of
Homeland Security views BGP security as part of the national strat-
egy for securing the Internet [41].

Vast related research, including [32, 50, 7, 33, 51, 49, 22, 23], in-
corporate additional measures to handle authenticity/ integrity and
authorization issues in BGP. In particular, a major security vulner-
ability, such as lack of integrity of the route announcements, has
been addressed. Secure BGP (S-BGP) protocol [34, 35] stands out
as the most comprehensive attempt to secure the Internet’s routing
infrastructure to date. It is currently under consideration for stan-
dardization by the Internet Engineering Task Force (IETF) [37].

Current security proposals for S-BGP rely on the use of the pub-
lic key infrastructure (PKI) [6, 36], each party holding a public-
secret key pair and a digital certiﬁcate on the public key issued
by a Certiﬁcation Authority (CA). Public-key cryptography tools
such as digital signatures and their variants should be able to en-
sure proper integrity/authentication and authorization veriﬁcation.
However, most existing proposals and analyses do not go further
than pointing out speciﬁc attacks and suggesting possible ﬁxes. For
example, a survey of BGP security [21] informally discusses such
threats as message tampering, session termination, preﬁx hijack-
ing, preﬁx deaggregation, subversion of path information, route
ﬂapping, etc. But it is not immediately clear what precisely an
adversary is allowed or supposed to do. Can it peek on communi-
cation, corrupt nodes, collude, etc.? And what are its goals? Even
though the proposed solutions may seem plausible, there is no prov-
able guarantee they actually “work”. For example, the proposal for
secure path vector routing described in [33] without provable se-
curity analysis was later shown to suffer from attacks that could be
mounted by 60% of AS’s on the Internet in [39]. What is missing is
the provable security analysis, which is the superior alternative to
the unproductive trial-and-error as it provides security guarantees.

541It is a must in modern cryptographic research and design, and it is
more and more often required by the standards bodies.

The only attempt to use provable security (to the best of our
knowledge) in the context of securing BGP has been done in [22]
(Appendix A). However, there are no details of the security model1
(it is not clear who is given what keys), the model is very weak:
collusions are not addressed (the adversary can only corrupt one
AS), route validity—when a route does not contain edges that do
not physically exist in the network and no node’s export policy on
that route is violated—is not captured, and there are no proofs of
security. Providing proper provable security treatment for routing
protocols is the main focus of our work.

It may be debatable how possible is widespread, near-future adop-
tion and deployment of S-BGP. The main technical reason is that
securing BGP adds time and space complexity overhead. There are
also political and economic factors, including the ﬁnancial cost of
secure routing. Finally, there is the problem of gradual deployment;
that is the necessity of bypassing the impossibility of an instanta-
neous global change of conﬁgurations. But as a position paper on
the subject [16] notices, many objections are inherent to any pos-
sible solution and are unavoidable. This should not by any means
give specialists reasons to stop working on existing problems to
make deployable secure BGP a reality, especially given the grow-
ing importance of the Internet and its security.

Moreover, several recent efforts in this ﬁeld justify an optimistic
view on S-BGP’s deployment [8, 36, 28]. Resource Public Key
Infrastructure (RPKI) [5, 36] is a major, real-life, current effort by
the Secure Inter-Domain Routing (SIDR) group of the IETF [4] to
protect and verify the association of AS numbers and IP preﬁxes
to their owners via cryptographic certiﬁcates. Intuitively, RPKI is
like an implementation of S-BGP that addresses only a fraction of
the attacks that S-BGP is supposed to address (i.e. preﬁx-hijacking
attacks). Results in [28] suggest that the majority of the Internet
would deploy secure routing protocols, such as S-BGP, if AS’s
were to prefer secure routes (routes where every AS deploys S-
BGP) to non-secure routes (because by adopting S-BGP, an AS
could attract more trafﬁc and increase its revenue). Thus, from an
economic point of view, S-BGP could be gradually deployed start-
ing from a small set of AS’s.

The above motivation is also applicable to other path vector rout-
ing protocols, e.g. BGPSEC [37] and Secure Origin BGP (SoBGP)
[50]. While S-BGP is our main focus, many of our results general-
ize for S-BGP variants and other path vector protocols.

Our work is the ﬁrst to study path vector routing protocols in the
provable-security framework. A major issue regarding S-BGP’s
use is the lack of understanding of its provable security guarantees
in scenarios of partial deployment [23]. Studying scenarios that
relax the PKI and the public-key-crypto-use requirements, while
still achieving reasonable (and well-deﬁned) security levels, is our
second main contribution.

Our paper continues a line of work providing provable security
treatment for practical protocols, such as SSH [14, 43] and Ker-
beros [9, 18]. We now describe our contributions in more detail.

INTERDOMAIN NETWORK AND PATH VECTOR PROTOCOL DEF-
INITIONS. We start with deﬁning an interdomain network (a net-
work of AS’s such as the Internet) and a path vector routing proto-
col. Our protocol deﬁnition is general enough, and we show how
both BGP and S-BGP (and SoBGP in the full version [19]) ﬁt.

SECURITY MODEL. Next we design the security deﬁnition. We

1The details are promised in the technical report, but they do not
appear there as well.

carefully study numerous known security threats and generalize
them in a new formal security notion. The deﬁnition is quite strong
in that the adversary we consider knows the conﬁguration of the
whole network, can observe and modify all communication on the
network, can select nodes that will not have public keys (for mod-
eling partial PKI deployment), can corrupt all but two AS’s, can
learn all secret information of the corrupted AS’s, and can act ar-
bitrarily on their behalf. We explain how this model takes into ac-
count adaptive corruptions. Our security deﬁnition elegantly cap-
tures scenarios when not all nodes have public keys (i.e. partial
PKI deployment). At the same time, our security deﬁnition is com-
pact and rather simple. The adversary is successful if it makes an
honest node accept a route announcement that is not legitimate in
at least one of the following three ways: (1) unauthentic origin, (2)
unauthentic route, (3) invalid route (). If no efﬁcient adversary can
succeed with noticeable probability in the above three ways, we
say that the protocol guarantees full security or (1) origin authenti-
cation, (2) route authentication and (3) route validity, respectively.
In Section 5 we explain how the numerous known vulnerabilities
are captured by just these three cases. For example, case (1) cap-
tures attacks of advertising preﬁxes that do not belong to the cor-
responding origins (that were not certiﬁed by the certiﬁcation au-
thority (CA)), also known as the preﬁx hijacking attacks [10]. Case
(2) captures all attacks that include tampering with any announce-
ment made by an honest AS. This includes as a special case a threat
known as violation of connection authentication. Case (3) captures
somewhat less known attacks on S-BGP such as export policy vio-
lations, sometimes known as “route leaks”, [30] and announcing a
route that cannot physically exist in the network [46]. Our uniﬁed
deﬁnition allows one to analyze full security of a routing protocol
or consider security against each of the aforementioned classes of
attacks separately.

S-BGP AND SOBGP SECURITY ANALYSES. We prove (by reduc-
tion) that S-BGP does indeed guarantee origin and route authen-
tication if the utilized building blocks such as a certiﬁcation and
signature schemes are secure (we also prove that a secure certiﬁca-
tion protocol can be constructed from a secure signature scheme).
This formally justiﬁes the design of S-BGP as a means to protect
against some of the major threats. However, we also show that
S-BGP does not guarantee route validity by presenting explicit at-
tacks under our deﬁnition. This is not surprising as it has been
shown before, albeit without provable security analysis, and sev-
eral solutions have been proposed [46, 30, 47, 26]. We propose
simple ﬁxes to S-BGP that involve the certiﬁcation authority certi-
fying links and ﬁnancial relationships between AS’s and we prove
that the modiﬁed protocol guarantees route validity if the underly-
ing certiﬁcation protocol is secure. This is somewhat similar to AS
policy certiﬁcates used in SoBGP [50]. Although requiring such
certiﬁcates may seem inefﬁcient AS’s may be unwilling make their
connections, business relationships and export policies known, we
argue that without link-certiﬁcates route validity cannot be guaran-
teed in general. Furthermore, in light of current efforts of RPKI
[5] to, even partially, protect approximately 400K currently exist-
ing preﬁxes [42, 2] with cryptographic certiﬁcates, we believe that
requiring the extra management of cryptographic link certiﬁcates to
protect all links, of which there are approximately only 150K [24],
to be still reasonable even though they may require more frequent
updates.

SoBGP [50] is another well-known effort to secure BGP. Al-
though this has already been discussed within the community, our
security model can be used to formally conﬁrm that SoBGP guar-
antees origin authentication but does not guarantee route authenti-

542cation and route validity (we provide sketches in the full version
[19]). Due to these weaknesses we focus only on S-BGP when
considering partial PKI deployment.

RELAXING THE PKI REQUIREMENT. Of course, reliance on full
PKI deployment and the use of public-key cryptography, while
seemingly necessary for strong security, are quite expensive mea-
sures. We study the effect on security from having partial PKI de-
ployment, i.e. when not all nodes have certiﬁed public keys, and
put forth results that can facilitate our understanding of how grad-
ual deployment (and even full deployment, but where, for efﬁciency
reasons, not all parties want to execute parts of the protocol that re-
quire the use of their private keys) of secure routing protocols on
the Internet could be made possible. Studying security of the par-
tial PKI deployment of path vector protocols is our second main
contribution, and the results here are more unexpected and techni-
cal.

We ﬁrst show that S-BGP fails to provide route authenticity if
there is at least one node without a certiﬁed public key. However,
we show that the loss of PKI-related security can be compensated
by exploiting physical security of links together with a trust rela-
tionship that neighboring nodes must have to establish a physical
communication link between them in the ﬁrst place, and we show
that full security is possible if nodes do not select routes with more
than one keyless node in a row at any part of those routes. We then
show that such restrictions are in fact necessary. Finally, we show
that if all preﬁxes and links are certiﬁed by a trusted certiﬁcation
authority, even when no node has a public key, nodes are guaran-
teed to discover valid routes with authentic origins, and the worst
thing that can happen is that an honest node may accept a route to
some preﬁx such that for at least one honest node on that route, the
latter does not prefer that its part of that route the most. We then
argue that in this setting, due the Internet’s lack of any provably
secure accountability mechanism, the Internet as a whole is just as
protected against adversaries whose primary goal is to divert traf-
ﬁc onto unwanted routes as when PKI is fully deployed. Although
requiring link certiﬁcates while not requiring full PKI deployment
may seem to have limited practical gains, this result is a major leap
toward understanding the security guarantees and efﬁciency trade-
offs that can be achieved even when no node has a public key. This
result suggests that in the initial stages of partial deployment of se-
cure path vector protocols, it may be more beneﬁcial to deploy link
certiﬁcates rather than have some nodes possess public keys while
deploying no link certiﬁcates. We discuss this further with respect
to partial and full deployment of RPKI on the Internet.

2. PRELIMINARIES
NOTATION AND CONVENTIONS. We denote by {0, 1}∗ the set of
all binary strings of ﬁnite length. If x, y are strings then (x, y) de-
notes the concatenation of x and y from which x and y are uniquely
decodable. If κ ∈ N then 1κ denotes the string consisting of κ con-
secutive “1” bits. If S is a ﬁnite set, then s $← S denotes that s
is selected uniformly at random from S . If A is a randomized al-
gorithm and n ∈ N, then a $← A(i1, i2, . . . , in) denotes that a
is assigned the outcome of the experiment of running A on inputs
i1, i2, . . . , in. The empty string is denoted by ε. An adversary is
an algorithm. By convention, the running-time of an adversary in-
cludes that of its overlying experiment. All algorithms are assumed
to be randomized and efﬁcient (i.e. polynomial in the size of the
input).

PROVABLE SECURITY APPROACH. In this work we apply the prov-
able security approach. Unlike the unproductive and cyclic trial-
and-error approach to security, this methodology allows us to have
protocols, whose security is provably guaranteed, as long as the as-
sumption about the underlying hard problem remains true for com-
putationally bounded adversaries. This approach consists of the
following components. (1) A formal deﬁnition of a protocol’s syn-
tax. (2) A formal deﬁnition of the security task in question that
includes a precise description of adversarial capabilities and when
is the adversary considered successful. (3) A reduction proof show-
ing that the only way to break the protocol according to the deﬁ-
nition is by breaking the underlying problem, believed to be hard.
Such treatment requires precise notation and deﬁnitions at each of
the above steps. Hence, we introduce some notation and deﬁni-
tions that were not common in the networking literature, but are
rather standard in the cryptographic literature. We provide infor-
mal explanations wherever possible to make the formalisms easier
to follow.

We note that our work does not follow the alternative formal-
methods (symbolic) approach. Such analysis has not been done to
the best of our knowledge as it requires some innovations, such as
dealing with lists. When done, it will allow for automatic veriﬁca-
tion, but still will not imply security in the strongest computational
model (and our analysis does) as the required soundness theorems
are to rely on the unrealistic properties of signatures.

PKI AND SIGNATURE SCHEMES. Whenever we use public keys,
we also (implicitly) assume that a public key infrastructure (PKI) is
supported, i.e. the public keys are valid, bound to users’ identities
and are publicly known.
A digital signature scheme SS = (Kg, Sign, Ver) with asso-
ciated message space MsgSp is deﬁned by three algorithms. The
randomized key generation algorithm Kg takes the security param-
eter 1k and outputs a public–secret key pair: (pk, sk) $← Kg(1k).
The (possibly randomized) signing algorithm Sign takes the secret
key and message M ∈ MsgSp and outputs a signature: σ $←
Sign(sk, M ). The deterministic veriﬁcation algorithm Ver takes
the public key, a message and a signature and outputs a bit b ∈
{0, 1} indicating whether the signature is deemed valid or not:
b ← Ver(pk, M, σ).
For correctness, it is required that for every (pk, sk) output by
Kg(1k) and every M ∈ MsgSp we have that Ver(pk, M, Sign(sk,
M )) = 1.
The traditional security notion for a scheme SS = (Kg, Sign,
Ver) considers an experiment Expuf-cma
SS (A) associated with an ad-
versary A. First, a pair of keys is generated: (pk, sk) $← Kg(1k).
Then A is given pk and the signing oracle, and it has to output
a message and a forgery: (M, σ) $← ASign(sk,·)(pk). The adver-
sary wins and the experiment returns 1 iff Ver(pk, M, σ) = 1,
M ∈ MsgSp and A never queried M to Sign(sk,·). We say that

SS is uf-cma-secure if Pr(cid:2) Expuf-cma

SS (A) = 1(cid:3) is negligible in k

for all efﬁcient algorithms A.

CERTIFICATION SCHEMES. To the best of our knowledge, the cer-
tiﬁcation scheme primitive has not been explicitly deﬁned, but it
has been considered as parts of other protocols, e.g. certiﬁed en-
cryption and digital signature schemes in [17]. (In the application
we consider we will involve the certiﬁcation protocols to certify
preﬁx ownership for the origins (known as address attestation) as
well neighbor relations of AS’s and, if they are, the type of business
relationship they have with each other.)

A two-party certiﬁcation protocol CP = (KgCA, (CA, U),

543Vercert) is deﬁned by a key generation algorithm, a pair of (possi-
bly) interactive randomized algorithms executed between the certi-
ﬁcation authority and a user (in our case, an AS), and a veriﬁcation
algorithm. The protocol is associated with an ID space IDSp and
data space DSp. KgCA takes the security parameter 1k and outputs
a public-secret key pair (pkCA, skCA) for the CA.
CA takes as input a secret key skCA, the identity of user ID ∈
IDSp and data D ∈ DSp. A node’s ID is the unique AS num-
ber given to the AS associated with that node by the Internet As-
signed Numbers Authority (IANA) [3], as is done for every AS
on the Internet. U takes as input the public key pkCA, the iden-
tity ID ∈ IDSp and data D ∈ DSp. As result of the interac-
tion, the outputs of both parties are ⊥, if something went wrong,
or (ID, D, cert), where cert is an issued certiﬁcate. We write
$← (CA(skCA, ID, D), U(pkCA,
((ID, D, cert), (ID, D, cert))
ID, D)) for the result of an honest interaction. Vercert takes as
input (pkCA, ID, D, cert) and outputs a bit.
The correctness requirement states that for any pair (pkCA, skCA)
output by KgCA(1k), any ID ∈ IDSp and D ∈ DSp, the result of
certiﬁcation ((ID, D, cert), (ID, D, cert)) $← (CA(skCA, ID, D),
U(pkCA, ID, D)) passes veriﬁcation, i.e. Vercert (pkCA, ID, D,
cert) = 1.
We now deﬁne the security of the certiﬁcation protocol CP =
(KgCA, (CA, U), Vercert) with IDSp, DSp. We call the notion un-
forgeability under chosen-data attack. Consider the following ex-
periment Expuf-cda
First, the CA’s keys are generated: (pkCA, skCA) $← KgCA(1k).
A gets pkCA and after that can repeatedly output (ID, D) so that
ID ∈ IDSp, D ∈ DSp and for each pair participate in (CA(skCA,
ID, D), A(pkCA, ID, D)) on behalf of the user interacting with
the CA.
The experiment outputs 1 iff A at some point returns (ID(cid:48), D(cid:48),
cert(cid:48)) so that ID(cid:48) ∈ IDSp, D(cid:48) ∈ DSp, Vercert(pkCA, ID(cid:48), D(cid:48),
cert(cid:48)) = 1 and CA never output (ID(cid:48), D(cid:48), cert(cid:48)(cid:48)), for any cert(cid:48)(cid:48).

CP (A) = 1(cid:3). We say that CP is uf-cda-secure if

be Pr(cid:2) Expuf-cda

We deﬁne A’s advantage Advuf-cda

CP (A) in this experiment to

CP (A) associated with an adversary A.

Advuf-cda
CP (A) is negligible in k for all efﬁcient algorithms A. Note
that one could deﬁne a stronger security notion, but that would be
an overkill for the purposes of our application.

CONSTRUCTION 2.1. Let SS = (Kg, Sign, Ver) be a signa-
ture scheme with MsgSp. We deﬁne the corresponding CP s =
(Kg, (CA, U), Vercert) with IDSp, DSp so that for every ID ∈
IDSp and D ∈ DSp, (ID, D) ∈ MsgSp. (CA, U) is then as fol-
lows. The CA sends cert = Sign(skCA, (ID, D)) to the user. The
user veriﬁes Ver(pkCA, (ID, D), cert) and, if correct, both output
cert: (ID, D, cert), otherwise they both output ⊥. Vercert(pkCA,
ID, D, cert) returns Ver(pkCA, (ID, D), cert).

THEOREM 2.2. Let SS = (Kg, Sign, Ver) be a signature scheme
with message space MsgSp and let CP s = (Kg, (CA, U), Vercert)
be its corresponding certiﬁcation scheme with identity and data
spaces IDSp, DSp as per Construction 2.1. Then, CP s is uf-cda-
secure if SS uf-cma-secure.

The proof is simple and is presented in the full version [19].

3.

INTERDOMAIN NETWORK ROUTING
We deﬁne syntaxes for interdomain networks and path vector

protocols which we use to model the Internet, BGP and S-BGP.

preferto, policy) where G is a ﬁnite, connected graph consisting of
a set of nodes, AS(cid:48)s, representing autonomous systems and a set of
edges deﬁned by a function link : AS(cid:48)s × AS(cid:48)s → {0, 1} return-
ing 1 iff the nodes are neighbors, Preﬁxes is a set of strings in
{0, 1}∗ representing preﬁxes, which specify sets of IP addresses,
The origin-for-preﬁx function OrforPr : Preﬁxes → AS(cid:48)s takes a
preﬁx and returns a node designated to own that preﬁx (called ori-
gin), and relation : AS(cid:48)s × AS(cid:48)s → BR is a function that takes two
nodes and returns their business relationship if they are neighbors
and ⊥ otherwise 2. Here BR deﬁnes the set of all possible pair-
wise business relationships in I between neighbors. For example,
the neighbors could be peers or one can be a provider and the other
its customer [27]. Before deﬁning the last components of I, we
introduce comments and auxiliary deﬁnitions.
Note that I implicitly deﬁnes the set of origins Origins ⊆ AS(cid:48)s
as the image set of function OrforPr. We denote the set of neigh-
bors of a node N as Neighbors(N ).
A route in I is a sequence of nodes (Nn, Nn−1, . . . , N2, N1),
for some n ∈ N and Ni ∈ AS(cid:48)s for all 1 ≤ i ≤ n, such that
N1 ∈ Origins. Here N1 is the destination of trafﬁc and Ni is a
possible source of trafﬁc for every 2 ≤ i ≤ n. Unless otherwise
speciﬁed, nodes on routes will be indexed in increasing order right-
to-left, starting with the origin, which is convenient for path vector
protocols. We say that Ni is up- or down-stream from node Nj on a
particular route, if i < j or i > j respectively. A subroute of some
route R = (Nn, . . . N2, N1) is a sequence of nodes (Ni, . . . N1),
for any 1 ≤ i ≤ n, that is deﬁned as the i right-most entries of R.
A route is said to be feasible if for every pair of consecutive nodes
(Ni+1, Ni) in that route, link(Ni+1, Ni) = 1 for n < i ≤ 1, i.e.
the nodes are neighbors. A route (Nn, . . . N2, N1) is said to be to
some preﬁx P ∈ Preﬁxes if OrforPr(P ) = N1.
preferto speciﬁes total and transitive binary relations prefertoN
on routes to the same preﬁx in Preﬁxes for each node N ∈ AS(cid:48)s.
policy speciﬁes functions policyN that deﬁne export policy rules
for each node N ∈ AS(cid:48)s; policyN takes a route to some preﬁx P
together with the output of relation on N and the ﬁrst node on that
route (the second parameter is ignored if N owns P ) and outputs
a set of nodes to which that node is allowed to export (i.e. adver-
tise) that route. With this syntax we consider only next-hop export
policy functions whose outputs depend on the routes and business
relationships of neighbors of the node exporting the route, since
they quite reasonably approximate the export policy rules that AS’s
on the Internet use to advertise their routes to different neighbors
[27, 30, 28]. We comment on how our results could be extended
for more complicated export policy functions in Section 7.
We say that Ni ∈ AS(cid:48)s prefers some route R to some other
route R(cid:48), both to the same preﬁx P , if R prefertoNi
R(cid:48), and we
say that a route R = (Nn−1, . . . , N2, N1) to preﬁx P ∈ Preﬁxes
is node Nn’s ith most preferred route to P , for some i ≥ 1, if
there are exactly i − 1 distinct routes R(cid:48) = (M(cid:96), . . . , M1, N1)
to P such that R(cid:48) prefertoNn R. We say that R is Nn’s most
preferred route to P if i = 1. For any node Nn, for any route R =
(Nn−1, . . . , N2, N1), R prefertoNn ε if and only if OrforPr(P ) =
N1, and ε is N1’s most preferred route to P if OrforPr(P ) = N1.
A route R = (Nn, . . . N2, N1) is valid if it is feasible and con-
sistent with policy of every node on that route, i.e. Ni ∈ policyNi−1
((Ni−1, . . . N2, N1), relation(Ni−1, Ni−2)) for all 2 ≤ i ≤ n.
A ROUTING PATH VECTOR PROTOCOL. Let I = (G = (AS(cid:48)s,
link), Preﬁxes, OrforPr, relation, preferto, policy) be an interdo-

AN INTERDOMAIN NETWORK. We model an interdomain net-
work as a tuple I = (G = (AS(cid:48)s, link), Preﬁxes, OrforPr, relation,

2link may be redundant given relation, but we keep the former to
maintain a general graph deﬁnition

544main network. An interactive and stateful path vector protocol
PV = (Init, An) is deﬁned by two algorithms.
• Init is an optional randomized algorithm run by a node (or a
CA) that takes the security parameter 1k and generates the corre-
sponding public and secret keys for the node (or the CA).
• An is a stateful and possibly randomized, interactive multi-
party algorithm run between the nodes and possibly the CA. Each
node N ∈ AS(cid:48)s is given inputs (N, Neighbors(N ), relationN ,
prefertoN , policy, PN , pkCA, pk), where relationN outputs
relation(N, N(cid:48)) for all N(cid:48) ∈ Neighbors(N ) and ⊥ otherwise.
PN ⊆ Preﬁxes is the set of preﬁxes N owns, pkCA is the op-
tional public key of the CA and pk denotes the optional set of
public keys of all nodes in AS(cid:48)s. The optional CA takes as in-
puts (I, pkCA). During the execution, Ni sends messages known
as announcements to Nj ∈ Neighbors(Ni), in accordance with
, of the form (Ni, Nj, R, P, W, Aux), where R is a route
policyNi
to P ∈ Preﬁxes known as the path attribute, W ∈ {0, 1} is the
withdrawal ﬂag, and Aux ∈ {0, 1}∗ holds any additional informa-
tion. Upon receipt of a message, Nj can reject that message by
outputting ⊥. Nj accepts a message if Nj does not reject it.

Note that although export policy function of each node is given
as input to each node, nodes cannot ﬁnd out other node’s decisions
with respect to exporting arbitrary routes, because they do not know
business relationships of remote nodes. We comment on how our
results could be extended for scenarios when other nodes’ policies
are not publicly known in Section 7.
We say that PV is correct for a class of networks if when every
node in AS(cid:48)s follows PV , every announcement during its execu-
tion is accepted for every network I ∈ C. One could consider a
stricter notion of correctness that would require path vector proto-
cols to be useful and allow nodes to learn routes to various des-
tinations, e.g.
in practice path vector protocols such as BGP are
considered useful for the Internet only if they converge—reach a
point after which no node receives an announcement with a route
that is preferred to a route that it has previously selected as its most
preferred. However, such requirement may be unnecessarily com-
plicated and is outside of the scope of this paper. Also, as explained
in Section 5, essential vulnerabilities of path vector protocols pre-
ventable with crypto stem from honest nodes accepting bogus an-
nouncements and, therefore, as with all crypto protocols, our se-
curity deﬁnitions are adequate even when a protocol may not be
useful by itself or due to adversaries.

4. BGP AND S-BGP

In this section we ﬁrst describe BGP, and then show how S-BGP
extends it to incorporate security features. Although in our model
we do not require communication to be either concurrent or asyn-
chronous, for the rest of the paper we assume only asynchronous
communication as it captures delays and re-ordering ubiquitous in
real life scenarios.

BORDER GATEWAY PROTOCOL. We present the essential aspects
of the the Border Gateway Protocol (BGP) that is used to estab-
lish routes on the Internet of today [27, 30, 28]. Let I = (G =
(AS(cid:48)s, link), Preﬁxes, OrforPr, relation, preferto, policy) be an in-
terdomain network. BGP uses no PKI and no CA, so the optional
algorithm Init is never invoked. The An algorithm is as follows.
Every node N ∈ AS(cid:48)s maintains state in the form of a table TN ,
called the routing table, which is initially empty. Each ﬁeld TN [P ]
indexed by a preﬁx P ∈ Preﬁxes, for which OrforPr(P ) (cid:54)= N, is a
list consisting of routes to P that N has received as announcements
from neighbors. Each route in TN [P ] is ranked such that TN [P ][i]
contains N’s ith most preferred route to P .

If the node’s input PN is nonempty (i.e. N ∈ Origins), then for
every preﬁx P ∈ PN , N sends an announcement (N, N(cid:48), (N ), P, 0,
ε), advertising access to P , to every neighbor N(cid:48) ∈ policyN ((N ), ε).
During BGP’s execution, when a node receives an announcement
advertising a new route to some preﬁx, that announcement is ig-
nored if that node is contained in the announced route or if the new
route is already contained in that node’s routing table to that preﬁx.
Otherwise, that node determines the new route’s rank in its routing
table to the same preﬁx, records that route and its rank, and, if nec-
essary, updates the ranks of the other routes to that preﬁx. If the
announced route becomes the most preferred route to that preﬁx,
that node propagates that route to its neighbors in accordance with
its export policy rules. If a node receives an announcement that
is a notiﬁcation of a withdrawal of a route (i.e. that route should
not to be used by the receiving node) stored in its routing table,
then that node deletes that entry from its table and propagates that
route’s withdrawal to its neighbors in accordance with its export
policy rules. We describe BGP more concretely below.
For every route announcement (N(cid:48), N, R, P, W, ε) that N re-
ceives from neighbor N(cid:48), if R and TN [P ] do not contain N and R
respectively, N sends a route announcement to every neighbor as
per policyN and updates TN [P ] according to rules (1)-(3) below.

(1) If the announcement presents the most preferred route to P ,

i.e. W = 0 and R prefertoN TN [P ][1], then N:
(a) sends a route withdrawal announcement (N, N(cid:48), (N,
TN [P ][1]), P, 1, ε) to every neighbor as per policyN , 3
(b) sends a route advertisement (N, N(cid:48), (N, R), P, 0, ε) to

(c) increments by one the rank of every route in TN [P ] and

every neighbor as per policyN ,
makes an update TN [P ][1] ← R.

(2) If the announcement presents a route to P that is not the most
preferred, i.e. W = 0 and TN [P ][1] prefertoN R, then N
determines rank i such that R is the ith most preferred route
out of all routes in TN [P ], increments by one the rank of
every route in TN [P ] that is less preferred than R, and makes
an update TN [P ][i] ← R.

(3) If the announcement is a withdrawal of a route that N has

stored, i.e. W = 1 and R ∈ TN [P ], then N:
(a) if R = TN [P ][1], sends a withdrawal announcement

(N, N(cid:48), (N, R), P, 1, ε) to every neighbor as per policyN ,

(b) if R = TN [P ][1] and TN [P ][2] (cid:54)= ε, sends a route ad-
vertisement (N, N(cid:48), (N, TN [P ][2]), P, 0, ε) to every
neighbor as per policyN ,

(c) removes R from TN [P ] and decrements the rank of ev-

ery route in TN [P ] ranked higher than R.

N ignores new announcements in all other cases. In the absence of
adversaries and errors, no message in BGP should be rejected, so
BGP should be correct for various interesting classes of networks
described in [27, 30, 28] that are believed to closely capture how
routing is done on the Internet.

SECURE BORDER GATEWAY PROTOCOL. The Secure Border Gate-
way Protocol (S-BGP) [34] is an extension to BGP that relies on
the full deployment of PKI (each AS should know authentic and
valid public keys of other AS’s). In S-BGP, public-key cryptogra-
phy is used to bind preﬁxes to their origins with certiﬁcates, called
3Although in practice withdrawals in this speciﬁc scenario may be
implicit, we make them explicit here for clarity.

545address attestations, issued by a third trusted party as well as to
generate route attestations—certiﬁcates generated by intermediate
nodes on a route announcements they propagate. Route announce-
ments recipients verify the origin of the preﬁx in that announcement
and the certiﬁcates of the nodes on the route that announcement has
traversed. We present the essential operations of S-BGP more con-
cretely below.
CONSTRUCTION 4.1. Let I = (G = (AS(cid:48)s, link), Preﬁxes,
OrforPr, relation, preferto, policy) be an interdomain network,
let SS = (Kg, Sign, Ver) be a signature scheme with MsgSp =
{0, 1}∗, and let CP s = (KgCA, (CA, U), Vercert) be the corre-
sponding certiﬁcation protocol as per Construction 2.1. In S-BGP =
(Init, An), as part of Init the CA runs KgCA(1k) to generate (pkCA,
skCA) and each AS runs Kg(1k) to generate (pk, sk). An is deﬁned
as follows.
If node Nj’s input PNj is nonempty (i.e. Nj ∈ Origins), then
for every preﬁx P ∈ PNj , Nj does the following:
• CA and Nj interact according to (CA, U), Nj being U. The
input to U is (pkCA, Nj, P ), the input to CA is (skCA, Nj, P ) and
the outputs of both parties are (Nj, P, cert). Address attestation
Nj ≡ cert is Nj’s certiﬁcate of ownership of P .
AAP
• Next, for every Ni ∈ policy(Nj, ), Nj runs Sign(skNj ,

, . . . , RA2

R1 , AAP

Rj−1

, (Ni+1, . . . N1, P ), RAi+1
Ri

(Ni, Nj, P )) to produce a route attestation, RAi
(Nj, Ni, R = (Nj), P, 0, Aux = (RAi
Rj , AAP
Ri

Rj , and sends
Nj )) to Ni; here
j is R’s subroute authorized by Nj for Ni to use and announce.
For every new route announcement (Nj−1, Nj, R = (Nj−1,
. . . , N1), P, W, Aux = (RAj
N1 )) that Nj
receives from Nj−1, Nj ﬁrst performs address attestation and route
attestation veriﬁcation steps as follows. Nj runs Vercert (pkCA, N1,
N1 ) and outputs ⊥ if the output of this computation is 0.
P, AAP
Otherwise, Nj runs Ver(pkNi
) for ev-
ery 1 ≤ i ≤ j − 1 and outputs ⊥ if at least one such computation
outputs 0. If none of the veriﬁcation steps above results in ⊥, then
Nj performs the same operations as Nj would do in BGP upon
receipt of (Nj−1, Nj, R, P, W, ε), as per rules (1)-(3) speciﬁed in
Section 4. Then, for every message (Nj, Nj+1, R(cid:48), P, W (cid:48), ε) that
Nj would send to Nj+1 in BGP, Nj now runs Sign(skNj , (Nj+1,
and sends (Nj, Nj+1, R(cid:48), P, W (cid:48), Aux(cid:48)) to
R(cid:48), P )) to get RAj+1
R(cid:48)
Nj+1 instead, where R(cid:48) = (Nj, R) and Aux(cid:48) = (RAj+1
, Aux).
R(cid:48)
If the underlying signature scheme SS is correct, the execution
of S-BGP is the same as that of BGP in terms of how nodes update
their routing tables and how they decide which routes to announce
to their neighbors. Therefore, S-BGP is correct for the same classes
of networks as BGP if the underlying signature scheme SS used to
generate address and route attestations is correct.

j

j

5. ROUTING PROTOCOL SECURITY

In this section we provide a security deﬁnition for path vector
protocols, show how it captures their security vulnerabilities, and
discuss the attacks not captured in our model because they cannot
be solved with cryptography.

INTUITION FOR THE FORMAL SECURITY MODEL. In our model,
we do not consider malicious CA’s, but we do consider malicious
AS’s. We consider an adversary which is given the CA’s public
key and the description of the network I with at least two nodes.
The adversary also speciﬁes the number of nodes that will not have
public keys and the partition of the nodes into the subsets of cor-
rupted and honest nodes, so that the size of the latter is at least
two.
In practice, it is unlikely that a malicious party knows the
complete conﬁguration of the network including the relations, and

can corrupt almost all AS’s, but in the deﬁnition we target a very
strong adversary. We allow the adversary to corrupt multiple nodes
to capture collusion. On the Internet, collusion is certainly a plausi-
ble scenario, given that multiple AS’s could be managed by a single
administration with presence in different geographic locations. The
adversary is given all the public and secret keys of the corrupted
nodes. We assume that the adversary is stateful, i.e. it can preserve
state in between stages. All nodes and the CA can interact: the
honest nodes and the CA follow the protocol, while the adversary
can act arbitrarily on behalf of the corrupted nodes. It can observe
and modify all communication.

I,PV

We note that even though it may not be obvious, our model does
take into account adaptive corruptions and does not assume syn-
chronous communication model. To model attackers who adap-
tively corrupts AS’s, our adversary, who can corrupt all but two
nodes, can just behave legitimately on behalf of AS’s not yet cor-
rupted in the original setting until the time they are corrupted. Sim-
ilarly, the adversary can delay, drop and re-order communication.
The adversary wins if it sends a route announcement to an hon-
est node, the node accepts it and either (1) the preﬁx in the an-
nouncement does not belong to the corresponding origin, (2) there
is a honest node on the route that never sent the corresponding an-
nouncement for the same preﬁx, and (3) the route is invalid. The
latter includes the possibilities of a non-existing (not-connected)
route and a route that does not satisfy the export policies of at least
one node on that route.
PATH VECTOR PROTOCOL SECURITY DEFINITION. Let k ∈ N be
the security parameter, I = (G = (AS(cid:48)s, link), Preﬁxes, OrforPr,
relation, preferto, policy) be an interdomain network, of size poly-
nomial in k, such that |AS(cid:48)s| ≥ 2, and let PV = (Init, An) be a
path vector protocol that is correct for I. We deﬁne the experi-
(A), for 0 ≤ m ≤ |AS(cid:48)s|, involving a stateful
ment Expsec-rout-m
adversary A as follows.
Given the description of I, A selects the set nopubk (cid:40) AS(cid:48)s
of nodes that will not have public keys, such that |nopubk| = m.
Then, the public–secret key pairs for the CA and all nodes in AS(cid:48)s\
nopubk are generated via Init(1k). Here and further in the paper
pk denotes the vector of public keys of nodes in AS(cid:48)s\nopubk and
pk[i] denotes its i’th component. Given all public keys, A outputs
the sets of corrupted and (at least two) honest nodes which form a
partition of G:
(Honest, Corrupted) $← A(I, pkCA, pk), so that |Honest| ≥ 2,
Honest ∪ Corrupted = AS(cid:48)s and Honest ∩ Corrupted = ∅.
Next A is given all the secret keys of the corrupted nodes {sk[i] :
sk[i] belongs to a corrupted node}, and it starts the execution of
An on behalf of all nodes in Corrupted with the CA and also with
the nodes in Honest. The CA and the honest nodes follow the
protocol legitimately, while the adversary can act arbitrarily.
In
particular, A is allowed to intercept and modify announcements
exchanged between neighboring honest nodes as well as send mes-
sages on behalf of any honest node. The adversary is given tran-
scripts of all communication (as it happens).
The goal of the adversary is to have an honest node, say N(cid:96) ∈
Honest, accept an announcement of the form (N(cid:96)−1, N(cid:96), R =
(N(cid:96)−1, . . . , N1), P, W, Aux), so that at least one of the follow-
ing conditions is true (the indexing of the nodes on the route is not
essential for the deﬁnition and is done for simplicity only).

1. Unauthentic origin: OrforPr(P ) (cid:54)= N1.

experiment outputs 1.

In this case the

2. Unauthentic route: there exists 1 ≤ i ≤ (cid:96) − 1 so that Ni ∈
Honest and Ni never sent announcement (Ni, Ni+1, R(cid:48) =

546(Ni, . . . , N1), P, W (cid:48), Aux(cid:48)) for any W (cid:48), Aux(cid:48) to Ni+1. In
this case the experiment outputs 2.

3. Invalid route: R is invalid. In this case the experiment out-

I,PV

(A) returns an output as soon as A wins; if more

puts 3.
Expsec-rout-m
than one condition above holds, Expsec-rout-m
est number. We deﬁne A’s advantage Advsec-rout-m-b

experiment as Pr(cid:2) Expsec-rout-m

(A) = b(cid:3), for b ∈ {1, 2, 3}.

(A) in this

(A) outputs the small-

I,PV

I,PV

I,PV

We deﬁne CPV

m to be the class of all networks which have m
nodes without public keys and for which a path vector protocol PV
is correct, for m ≤ |AS(cid:48)s|. PV guarantees origin authentication,
route authentication, and route validity with m-partial deployment
(m-PD) for a class of networks CPV
m , if for every I ∈ CPV
m , for
every efﬁcient adversary A, the probability that Expsec-rout-m
(A)
returns 1, 2 and 3 respectively is negligible in k. PV is fully secure
with m-PD for a class of networks CPV
m , if it guarantees origin au-
thentication, route authentication and route validity with m-PD for
CPV
m , i.e. for every I ∈ CPV
m , for every efﬁcient adversary A the
probability of Expsec-rout-m
(A) returning 1, 2 or 3 is negligible in
k. When m = 0, we omit the sufﬁx 0-PD when qualifying security
of protocols.

I,PV

I,PV

Our model does not consider rogue keys and replay attacks. This
is very common as it is known that the standard measures like
proofs of possession of secret keys during the key registration [6,
45] and the use of timestamps can be used to provide the additional
protection. To address rogue key attacks, we could require the ad-
versary to output the public and secret keys of corrupted users in or-
der model the situation where users are required to perform proofs
of knowledge of secret keys during key registration. However, all
of our results would still trivially hold in this setting, so we do not
complicate our model with this extension since rogue-key attacks
are not essential to routing protocols and do not enhance the in-
sights we get about the essential, routing-related attacks on BGP.
It may be relevant to investigate whether simpler proofs of posses-
sion [45, 17] will sufﬁce, but this is beyond the scope of this paper.
We discuss relevance of rogue key attacks with respect to RPKI in
Section 8.

We also note that our security notion does not guarantee that the
data that nodes send to those preﬁxes travels along the routes that
they have learned and selected, or whether it reaches those preﬁxes
at all. As shown in [29], path vector protocols cannot guarantee
that. These are not goals of path vector protocol, but of data-plane
accountability and veriﬁcation which is outside of the scope of this
paper and is not captured in our model.

Although our security model does not take into account all com-
plexities of routing protocols, in Sections 6 -8 we show that even a
simpliﬁed model can point out what is necessary, not just sufﬁcient,
to achieve security with respect to essential, fundamental vulnera-
bilities in path vector protocols in full and partial PKI deployment
scenarios .

KNOWN CAPTURED ATTACKS. We discuss how our compact model
captures many known vulnerabilities of path vector protocols. For
all ﬁgures in this section, a directed edge from N to N(cid:48) indicates
that N is N’s customer, i.e. N pays N(cid:48) for all trafﬁc exchanged on
their link.

The Unauthentic origin condition captures the preﬁx hijacking
attack on BGP, where a corrupt AS claims to own a preﬁx or an-
nounces a more speciﬁc preﬁx, say P , that is owned by another AS.
As a result, the corrupt AS could attract potentially all trafﬁc des-
tined to P . With such an attack, a malicious AS could deny access
to a particular website, e.g. Pakistan Telecom hijacking YouTube’s

(a) Origin Authentication Attack

(b) Route Authentication Attack

Figure 1: In (a) N7 claims to own preﬁx P and becomes a black
hole by attracting majority of trafﬁc destined to P and drop-
ping it. In (b) N7 attracts N5’s trafﬁc by advertising a fake
short route and then forwarding along a longer route via N6.

preﬁx in February 2008 [20], e.g. by creating a black hole—a lo-
cale where all trafﬁc destined to P disappears.
In addition, the
attacker could intercept sensitive, government-related trafﬁc to an-
alyze it for malicious reasons, as speculated by some with regards
to China Telecom diverting approximately 15% of Internet’s traf-
ﬁc in April, 2010 for about 20 minutes [25]. Preﬁx deaggration
attacks, in which an attacker deaggregates a preﬁx into more spe-
ciﬁc preﬁxes to attract trafﬁc, are also captured by the unauthentic
route condition. This works because routers on the Internet select
more speciﬁc preﬁxes over less speciﬁc ones by default. RPKI [5]
is a major, current effort by ARIN [1] to address origin authentica-
tion attacks, but by itself RPKI is not intended to address any other
types of attacks. Figure 1(a) presents an example of such an attack,
where AS N7 announces to its neighbors ownership of preﬁx P ,
whose actual owner is N1. As a result, N7 is able to attract trafﬁc
from N4, N5, and N6, because N7 is closer to them than N1. This
trafﬁc never reaches N1 because, other than through nodes N5 and
N6, N7 does not have an alternative route to N1.

The Unauthentic route condition captures known attacks on BGP
where an adversarial AS modiﬁes the path attribute of a route an-
nouncement by adding and/or taking AS’s out of this attribute as
well as pretending to be a different AS altogether. By taking AS’s
out of the path attribute, the attacker could attract more trafﬁc as
the advertised route would seem shorter (and thus more attractive).
Adding AS’s to a route may make a route less attractive if it makes
it seem longer, or contains the receiver of the announcement (which
would present a loop and cause the receiver to drop the announce-
ment); this is how an attacker could force an AS not to select certain
routes. Figure 1(b) presents an example of such an attack, where
AS N7 removes N6 and N2 from the shortest route that N7 has to
P , which is owned by N1. This makes N5 believe that N7 is pro-
viding a shorter route to N1 than the one through N4, and hence
N5 picks the route through N7. Thus, N5 selects a suboptimal
route to P , since the route to P through N7 is actually longer than
that through N4. The attacker beneﬁts not only from intercepting
N5’s trafﬁc but also from receiving N5’s payment, since N5 is N7’s
customer.

In the full version [19] we discuss route feasibility [46] and ex-
port violation [30, 47, 26] attacks on S-BGP captured by our model.

ATTACKS CRYPTO CANNOT PREVENT. Here we discuss several
attacks not captured by our security model for the reason that such
attacks cannot be prevented using cryptography.

Path vector protocol divergence cannot be prevented with cryp-
tographic tools since the adversary could keep on withdrawing and
then re-announcing the same set of routes ad inﬁnitum. However,

547since the number of total routes to every preﬁx is ﬁnite, when a
protocol diverges, some paths must be periodically withdrawn and
then re-announced again (this is called route ﬂapping), so protocol
divergence can be mitigated with tools that prevent route-ﬂapping,
e.g. route dampening [21]. Convergence of path vector protocols
to suboptimal routes, i.e. paths that are not the most preferred, also
cannot be prevented with cryptographic tools since the adversary
could just make sure that some nodes never receive announcements
of the most preferred routes.

Bellovin and Gansner have studied link cutting attacks which in-
volve physically (e.g. with a DDoS attack) taking out edges out
of a topology so that certain route announcements fail to propagate
[15]. These attacks do not involve the adversary listening and inter-
cepting data without being noticed. Although in our security model
the adversary, having access to all communication, can prevent any
link from being operational, we do not capture this attack in our
security model because, in general, crypto cannot resolve these at-
tacks due to their physical nature.

I,PV

Finally, contrary to common intuition, path vector protocols can-
not guarantee that a particular route announcement was propagated
along the route shown in that announcement. Concretely, no path
vector protocol PV can guarantee for every network I ∈ CP V
m , for
every efﬁcient adversary A, the following event occurs with neg-
(A): N(cid:96) ∈ Honest accepts
ligible probability in Expsec-rout-m
an announcement (N(cid:96)−1, N(cid:96), R = (N(cid:96)−1, . . . , N1), P, W, Aux)
such that there exists 1 ≤ i ≤ (cid:96) − 1 so that Ni has never out-
put announcement (Ni, Ni+1, R(cid:48) = (Ni, . . . , N1), P, W (cid:48), Aux(cid:48))
for any W (cid:48), Aux(cid:48) to Ni+1. Here Ni is not required to be hon-
est as it is in the unauthentic route condition in Section 5. In the
full version [19] we present an attack on S-BGP in which colluding
corrupted nodes avoid using their expensive link by sending a route
announcement through a path of honest nodes between them, and
then taking these honest nodes out of the route announcement. Col-
luding nodes can do that because they can sign on behalf of each
other. Note that in real-life scenarios, colluding nodes could belong
to a single administration with presence in different geographical
locations and multiple distinct AS numbers.

6. HOW SECURE IS S-BGP?

In this section we show that S-BGP guarantees origin and route
authentication, assuming security of the building blocks, but that it
is not fully secure because it does not guarantee route validity.
Let SS = (Kg, Sign, Ver) be a signature scheme, let CP s =
(Kg, (CA, U), Vercert) be the corresponding straight-forward cer-
tiﬁcation scheme as per Construction 2.1. Theorems 6.1, 6.2 and
6.3 below state our results; the ﬁrst two are positive and the last
one is negative. The proofs with concrete security statements are
presented in the full version [19].

THEOREM 6.1. S-BGP per Construction 4.1 guarantees origin

authentication for CS-BGP

0

if the underlying SS is uf-cma-secure.

THEOREM 6.2. S-BGP per Construction 4.1 guarantees route

authentication for CS-BGP

0

if the underlying SS is uf-cma-secure.

THEOREM 6.3. S-BGP as deﬁned in Construction 4.1 does not

guarantee route validity for CS-BGP

0

7. FULLY SECURE BGP

To address the attack in the proof of Theorem 6.3, we suggest
modiﬁcation to S-BGP and show that the resulting protocol prov-
ably guarantees route validity assuming the underlying signature

scheme is secure. We argue that this modiﬁcation is necessary. The
modiﬁed protocol is fully secure (according to our security deﬁni-
tion from Section 5) under the same assumption, so we call it fully
secure BGP or FS-BGP.

CONSTRUCTION 7.1. Let I = (G = (AS(cid:48)s, link), Preﬁxes,
OrforPr, relation, preferto, policy) be an interdomain network, let
SS = (Kg, Sign, Ver) be a signature scheme, and let CP s =
(KgCA, (CA, U), Vercert) be the corresponding certiﬁcation pro-
tocol as per Construction 2.1. Let S-BGP = (Init, An) be the con-
struction from Section 4. FS-BGP = (Init, An(cid:48)) is deﬁned exactly
like S-BGP, but An(cid:48) requires a few extra operations.

After all address attestations are generated and before any an-
nouncement is sent, each node Nj interacts with the CA via (CA, U).
In what follows, smaller input is always on the left corresponding
to any link (Nj, Ni), and for convenience only, suppose that Nj =
min(Nj, Ni), for every Ni ∈ Neighbors(Nj). For this interac-
tion, the input to U is (pkCA, Nj, ((Nj, Ni), relation(Nj, Ni))),
the input to CA is (skCA, Nj, ((Nj, Ni), relation(Nj, Ni))) and
the outputs of both parties are (Nj, ((Nj, Ni), relation(Nj, Ni)),
cert). We deﬁne link attestation to be LANj Ni ≡ cert. If Nj owns
preﬁx P ∈ Preﬁxes, for every Ni ∈ policyNj
((Nj), ε), Nj gener-
Rj just as in S-BGP and sends (Nj, Ni,
ates a route attestation RAi
Rj ,
R = (Nj), P, 0, Aux = ((relation(Nj, Ni), LANj Ni ), RAi
AAP

Nj )) to Ni.
For every new route announcement (Nj−1, Nj, R = (Nj−1,
. . . , N1), P, W, Aux = (relation(Nj−1, Nj), LANj−1Nj , RAj
Rj−1
N1 )) that Nj receives,
. . . relation(N1, N2), LAN1N2 , RA2
Nj ﬁrst performs address and route attestation veriﬁcation just as
in S-BGP, and, if these steps do not result in ⊥, then Nj performs
link attestation veriﬁcation as follows. Nj runs Vercert (pkCA, Ni,
((Ni, Ni+1), relation(Ni, Ni+1)), LANiNi+1 ), for every 1 ≤ i ≤
j−1, and outputs ⊥ if at least one such computation outputs 0. Oth-
erwise, Nj outputs ⊥ if there is at least one Ni, for 1 ≤ i ≤ j − 1,
such that Ni+1 /∈ policyNi
((Ni, . . . , N1), relation(Ni, Ni−1)).
If none of the veriﬁcation steps above results in ⊥, then Nj per-
forms the same operations as Nj would do in S-BGP upon receipt
of (Nj−1, Nj, R, P, W, RAj
N1 ))). For ev-
ery message (Nj, Nj+1, R(cid:48), P, W (cid:48), Aux(cid:48)) that Nj would send
to Nj+1 as a result in S-BGP, Nj now sends (Nj, Nj+1, R(cid:48), P,
W (cid:48), Aux(cid:48)(cid:48)) to Nj+1 instead, where R(cid:48) = (Nj, R) and Aux(cid:48)(cid:48) =
(relation(Nj, Nj+1), LANj Nj+1 , RAj+1
R(cid:48)

R1 , AAP

R1, AAP

, . . . RA2

, Aux).

Rj−1

j

,

Note that FS-BGP is correct for the same classes of networks that
BGP is correct for, if the underlying signature scheme SS used to
generate address, route attestations and link attestations is correct.
The proof of the following result along with a concrete security
statement is in the full version [19].

THEOREM 7.2. FS-BGP as deﬁned in Construction 7.1 is fully

secure for CFS-BGP

if the underlying SS is uf-cma.

0

Assigning link attestations for every link in the Internet may
seem impractical because the Internet contains many more edges
than AS’s (150K versus 40K [24]), their management is harder due
to periodic reconﬁguration, and AS’s may be unwilling to expose
their connections, business relationships and export policies. How-
ever, we argue that link attestations are necessary to prevent route
feasibility attacks in general. If a path vector protocol guarantees
route validity, every announcement received as part of this proto-
col can itself serve the role of a certiﬁcate for the links between
the nodes in the route of that announcement. Since in our model
arbitrary nodes on any route could be corrupted, such certiﬁcates

548would have to be generated independently by trusted parties. Anal-
ogously, to guarantee route validity when export policies of nodes
are not publicly known and/or are not next-hop, more sophisticated
certiﬁcates and in greater amounts (potentially one for every route
of every node to every origin) would have to be issued by a trusted
authority to ensure that honest nodes can check for export policy
violations of remote nodes.

Several plausible solutions to route leaks–unintentional export
policy violations—and route validity attacks have been suggested
without provable security analysis in [47, 26]. Although these so-
lutions are more practical than FS-BGP because they are mostly
based on restricted models of AS’s business relationships and ex-
port policies, e.g. models presented in [27], it is not clear whether
they work with respect to colluding adversarial AS’s. Also, because
business relationships and export policies of AS’s on the Internet
may be more complicated than in the model of [27], as we argued
above, a more sophisticated solution than what the ones proposed
in [47, 26] would be necessary.

In SoBGP [50], Origin Authorization Certiﬁcates are used to
bind preﬁxes to certain AS’s (just like address attestations in S-
BGP) while AS Policy Certiﬁcates are used to allow nodes to learn
of links and policies of remote nodes. Although similar to link at-
testations, these certiﬁcates are not generated for links by a third
trusted party; instead nodes (possibly corrupted) themselves dis-
seminate their neighborship information. In the full version [19]
we outline how our security model can be used to formally deﬁne
SoBGP and prove that it guarantees origin authentication but does
not guarantee route authentication and route validity. The latter
two points can be shown by constructing attacks similar to those in
Theorems 8.2 and 6.3 respectively.

8. PARTIAL DEPLOYMENT OF PKI

In this section we study the effect on security of the partial de-
ployment of PKI. We ﬁrst show that neither S-BGP nor FS-BGP
can guarantee route authenticity for networks in which there is at
least a single node without a public key, and then present variants
of these protocols with which full security can be guaranteed in
partial PKI scenarios.

PARTIAL PKI DEPLOYMENT: INTRODUCTORY RESULTS. We
modify S-BGP to allow some nodes to not have public keys.

CONSTRUCTION 8.1. Let I = (G = (AS(cid:48)s, link), Preﬁxes,
OrforPr, relation, preferto, policy) be an interdomain network and
k a security parameter. We deﬁne S-BGP with partial deployment
(S-BGP-PD) = (Init(cid:48), An(cid:48)) as a path vector protocol identical to
S-BGP = (Init, An) but with the following modiﬁcations. During
execution of Init(1k) not every node has to generate a public key.
During execution of An(cid:48), nodes that do not have public keys do not
generate route attestations, and route attestations of nodes without
public keys are not checked during the route attestation veriﬁcation.
Providing security guarantees in scenarios with partial PKI de-
ployment is a difﬁcult problem because nodes that do not have
public keys cannot generate route attestations. With pictorial ex-
amples of simple attacks in the full version [19] we show that we
can construct an attack on S-BGP-PD for any m ≥ 1. Let us de-
ﬁne FS-BGP-PD to account for partial PKI deployment similarly
to Construction 8.1.

THEOREM 8.2. For no m ≥ 1 does FS-BGP-PD guarantee

route authentication with m-PD for CFS-BGP-PD

.

m

The proof with a pictorial example is in the full version [19].
The attack in the proof of Theorem 8.2, deserves a special name

because we later show it to be the only type of attacks that can
prevent FS-BGP-PD from being fully secure later in this section. A
similar type of attack was known in the networking community to
prevent SoBGP from guaranteeing route authentication.

I,PV

DEFINITION 8.3

(THE VALID-ROUTE-SWITCHING ATTACK).
Let I = (G = (AS(cid:48)s, link), Preﬁxes, OrforPr, relation, preferto,
policy) be a network in CPV
m , for any 1 ≤ m ≤ |AS(cid:48)s|, such that
|AS(cid:48)s| ≥ 2, let PV = (Init, An) be a path vector protocol correct
for I and let k be the security parameter such that the size of the
description of I is polynomial in k. We consider the experiment
Expsec-rout-m
(A) outputs 2, i.e. when N(cid:96) ∈ Honest ac-
cepts announcement (N(cid:96)−1, N(cid:96), R = (N(cid:96)−1, . . . , N1), P, W, Aux),
such that ∃1 ≤ i ≤ (cid:96) − 1 so that Ni ∈ Honest has never output
announcement (Ni, Ni+1, R(cid:48) = (Ni, . . . , N1), P, W (cid:48), Aux(cid:48)) for
any W (cid:48), Aux(cid:48) to Ni+1, if in addition Ni ∈ nopubk and R(cid:48) is a
valid route to P , then this event is called a Valid-Route-Switching
(VRS) attack.

(A), involving an adversary A.
I,PV

When Expsec-rout-m

An honest node Ni may never announce to Ni+1 a valid route
R(cid:48) to a particular preﬁx P because Ni may have never received any
route announcements to P from its neighbors or because R(cid:48) is not
Ni’s most preferred route to P .

WEAKENED PATH VECTOR PROTOCOL SECURITY DEFINITION.
We ﬁrst present a new (weaker) security deﬁnition. Next we justify
that this relaxation is still reasonable by exploiting physical secu-
rity of links and the trust relationship that neighboring nodes must
have to establish physical links between them. Then we present
reﬁnements to S-BGP-PD and FS-BGP-PD that address the weak-
ness pointed out in the proof of Theorem 8.2, and prove that these
protocols meet our new deﬁnition. We relax the deﬁnition from
Section 5 as follows.

DEFINITION 8.4. Let I = (G = (AS(cid:48)s, link), Preﬁxes, OrforPr,
relation, preferto, policy) be a network in CPV
m , for any 1 ≤ m ≤
|AS(cid:48)s|, such that |AS(cid:48)s| ≥ 2, let PV = (Init, An) be a path vec-
tor protocol and let k be the security parameter such that the size
of the description of I is polynomial in k. We deﬁne experiment
Expw-sec-rout-m
(A) involving adversary A to be identical to the
experiment Expsec-rout-m
(A) involving an adversary A from the
I,PV
deﬁnition from Section 5 except for the following two additional
relaxations.

I,PV

1. (Physical-Link-Security Relaxation) A is not allowed to (i)
send announcements on behalf of honest neighboring nodes
and (ii) intercept and modify announcements exchanged be-
tween neighboring honest nodes.

I,PV

2. (Trusted-Next-Neighbor Relaxation) Whenever experiment
(A) outputs 2, i.e. N(cid:96) ∈ Honest accepts an-
Expsec-rout-m
nouncement (N(cid:96)−1, N(cid:96), R = (N(cid:96)−1, . . . , N1), P, W, Aux),
and there exists 1 ≤ i ≤ (cid:96) − 1 such that Ni ∈ Honest never
output (Ni, Ni+1, R(cid:48) = (Ni, . . . , N1), P, W (cid:48), Aux(cid:48)) for
any W (cid:48), Aux(cid:48) to Ni+1, Ni+1 ∈ Honest if Ni ∈ nopubk.

as Pr(cid:2) Expw-sec-rout-m

(A) = b(cid:3), for b ∈ {1, 2, 3}. We say that

We deﬁne A’s advantage Advw-sec-rout-m-b
(A) in this experiment
PV guarantees weakened origin authentication, route authentica-
tion, and route validity with m-PD for a class of networks CPV
m ,
if for every network I ∈ CPV
m , for every efﬁcient adversary A
the probability experiment Expw-sec-rout-m
(A) returns 1, 2 and
3 respectively while Relaxations 1-2 hold is negligible in k. The
weakened full security is deﬁned analogously to security deﬁnition
in Section 5.

I,PV

I,PV

I,PV

549RELEVANCE OF THE WEAKENED DEFINITION. We argue that
the above deﬁnition is relevant in practice because the adversary’s
behavior restricted by the above two conditions corresponds to the
adversary’s behavior limited in practice by the presence of some
physical or external security features.

The ﬁrst relaxation is justiﬁed if honest neighboring nodes,

whether with public keys or not, can establish a communication
channel that guarantees authentication and integrity. This could be
indeed the case. All nodes could establish communication chan-
nels with their neighbors via IPSec that could guarantee integrity
and authenticity, for which they do not need public keys as they
could establish a pre-shared keys off line since they would have
to establish a business relationship to have a physical connection
anyway. BGP TTL security hack [48] could also be used for this
purpose. Although physical attacks on links between nodes are pos-
sible and have been studied [15], they do not involve listening and
intercepting data without being noticed. Thus, such attacks do not
invalidate this relaxation as their only purpose is to take out links
out of a topology so that certain route announcements are never
made.

The second relaxation is justiﬁed if the nodes that do not have
public keys have trusted down-stream neighbors with public keys,
and the latter can “vouch” for the former with their signatures. This
is not unrealistic, since neighboring nodes must trust in each other
to establish a business relationship between themselves in the ﬁrst
place. Moreover, framing business partners may result in devastat-
ing consequences such as the tearing down of their business con-
tracts and physical links connecting them, which could result in
substantial ﬁnancial losses.

On the Internet, most connections between AS’s are made at
public or private Internet Exchange Points (IXP) which, intuitively,
serve the role of rendez-vous points for AS’s to exchange trafﬁc.
AS’s that wish to connect at a particular IXP have to physically
come and make a connection at that IXP. Thus, since IXP’s make
a proﬁt by providing basic infrastructure for AS’s to make connec-
tions and become neighbors, it would be in their interest to facil-
itate the establishment of physically secure communication chan-
nels and trust between neighboring AS’s, as this would guarantee
longer lasting business relationships for those AS’s (which would
equate to longer lasting proﬁts for the IXP connecting them).

SECURE CONSTRUCTIONS. We slightly modify S-BGP-PD and
then show that it meets the above deﬁnition.

CONSTRUCTION 8.5. Let I = (G = (AS(cid:48)s, link), Preﬁxes,
OrforPr, relation, preferto, policy) be an interdomain network. We
deﬁne S-BGP-PD with a restriction (S-BGP-PDR) = (Init, An(cid:48)) as
a path vector protocol identical to S-BGP-PD = (Init, An) but with
the following restrictions in An(cid:48). When a node receives an an-
nouncement of a route, that node rejects the announcement if that
route contains more than one node without public keys in a row
at any part of that route. Also, a node without a public key does
not propagate a route that was announced by its neighbor who also
does not have a public key.

We deﬁne FS-BGP-PD with a restriction (FS-BGP-PDR) sim-
ilarly; note that in S-BGP-PDR and FS-BGP-PDR, the last two
nodes on a route could be without public keys. This new restric-
tion implicitly requires that nodes reject announcements that are
missing a signature for at least one node in that route who has a
public key. Although checking whether a node has a public key or
not may be difﬁcult in practice, this is in fact necessary, otherwise
an adversarial node could simply strip an honest node’s signature
and send a bogus route on its behalf. The proof of the following
Theorem is in the full version [19].

THEOREM 8.6. S-BGP-PDR as deﬁned in Construction 8.5 guar-

antees weakened route authentication with m-PD for CS-BGP-PDR
for any m ≤ |AS(cid:48)s|, if the underlying SS is uf-cma-secure.

m

,

COROLLARY 8.7. FS-BGP-PDR is weakened fully secure with
, for m ≤ |AS(cid:48)s|, if the underlying SS and

m-PD for CFS-BGP-PDR
CP are uf-cma-secure and uf-cda-secure respectively.

m

The following results emphasize that the restrictions in the weak-
ened path vector protocol security deﬁnition posed by Relaxations
1-2 and the requirement to ignore routes that have more than one
node without a public key in a row, as is done in S-BGP-PDR and
FS-BGP-PDR, are in fact necessary. The latter restriction, in the
worst case, could cause some parts of the network to become dis-
connected as many routes may be ignored. The proofs are pre-
sented in the full version [19].

THEOREM 8.8. For the statements in Theorem 8.6 and Corol-
lary 8.7 to hold, each relaxation (Physical-Link-Security or Trusted-
Next-Neighbor) is necessary given the other one.

THEOREM 8.9. Even when the underlying SS is uf-cma-secure,
S-BGP-PD as per Construction 8.1 and FS-BGP-PD do not guar-
antee weakened route authentication with m-PD for CS-BGP-PDR
and
CFS-BGP-PDR

respectively, for any m ≥ 2.

m

m

A signiﬁcant practical implication of Theorem 8.6 and Corollary
8.7 is that new AS’s who have just joined the Internet but do not
have public keys, do not have to get a public key as long as they
establish a trust relationship with their neighbors in the sense that
for any route announcement that they make, they are sure that their
neighbors who have public keys will vouch for them.

Even if we do not rely on security Relaxation 2, we can still
show that it is possible to guarantee route authentication but with a
very restricted version of S-BGP-PD, where only the last two nodes
on any route are allowed not to have public keys. We provide the
details in the full version [19].

WHAT IF THERE IS NO PKI. We show that if all preﬁxes and links
are certiﬁed by a trusted certiﬁcation authority, even when no node
has a public key, nodes are guaranteed to discover valid routes with
authentic origins, and that VRS attacks are the only attacks that pre-
vent FS-BGP-PD from guaranteeing route authentication. In light
of this result, we then discuss the feasbility of achieving reason-
able security without PKI. The proof of the following is in the full
version [19].

THEOREM 8.10. If the underlying SS is uf-cma-secure and the
underlying CP is uf-cda-secure, for any 1 ≤ m ≤ |AS(cid:48)s|, if
Expsec-rout-m
I,FS-BGP-PD(A) = 2 (see security deﬁnition in Section 5), then
A must have carried out a VRS attack.

The goal of path vector protocols is for nodes to learn of routes
in the network to all preﬁxes, so the importance of Theorem 8.10
is that FS-BGP-PD guarantees that nodes learn of valid routes with
authentic origins and that, even without PKI, the worst thing that
can happen compared to when FS-BGP is deployed, is that due to a
VRS attack, at least one honest node N(cid:96) accepts at least one route
R = (N(cid:96)−1, . . . , N1) to some preﬁx P such that for at least one
honest node Ni in R, R’s subroute (Ni−1, . . . , N1) is not Ni’s the
most preferred route to P . Although requiring link-attestations di-
minishes the practical gains of having no PKI, having no PKI is still
very practical and facilitates gradual, Internet-wide deployment of
FS-BGP-PD as it relieves nodes of storing public keys of all other
nodes and generating signatures for their every announcement. It

550also reduces communication overhead by getting rid of nodes’ sig-
natures.

With respect to adversarial control of the ﬂow of trafﬁc on the
Internet, Theorem 8.10 is a major milestone in understanding the
security and efﬁciency tradeoffs that can be achieved in full ver-
sus no PKI deployment. Although with a VRS attack an adver-
sary could cause an honest node to send trafﬁc along an unintended
route without that node’s knowledge, the adversary could do the
same without a VRS attack by simply diverting trafﬁc to an unin-
tended route of its choosing without the source’s knowledge. The
latter is an issue of data-plane accountability, and if the Internet
does not deploy a provably secure accountability protocol, e.g. [11,
31], then FS-BGP-PD with no PKI is just as good as with fully de-
ployed PKI with respect to such an adversary. On the other hand,
the only provably secure accountability protocols that are known to
date require nodes to deploy a PKI or have shared keys, so having
no PKI for FS-BGP-PD would yield no practical gains if the Inter-
net does deploy a provably secure accountability protocol. Thus,
in the beginning stages of partial deployment of secure path vec-
tor protocols, it may be more beneﬁcial to deploy link certiﬁcates
rather than have some nodes possess public keys but deploy no link
certiﬁcates at all.

Currently, IETF [4] is considering standardizing a variant of S-
BGP, called BGPSEC [37], that could work together with RPKI
[5, 36]. RPKI consists of a hierarchy of authorities and AS’s for
certifying IP preﬁxes and AS numbers. Certiﬁcates for IP preﬁxes
and AS numbers also contain certiﬁed public keys that are gener-
ated by the entities receiving the certiﬁcates. These keys would be
used to run S-BGP (or its variants like BGPSEC), and the results
in this section apply to settings when either RPKI is partially de-
ployed (i.e. not every AS gets a certiﬁcate for a preﬁx and a key)
or RPKI is fully deployed but some AS’s choose not to use their
private keys to generate S-BGP’s route attestations. In the full ver-
sion [19] we further discuss these scenarios. We note, however,
that if an adversary is allowed to corrupt various nodes in the RPKI
(i.e. entities that generate and/or certify keys may be corrupted), as
we suggested in Section 5, to have well-deﬁned, provable security
guarantees in such scenarios, more sophisticated models and proto-
cols would be needed to address rogue key and certiﬁcate attacks.

9. CONCLUSIONS

We developed the framework for the provable-security treatment
of path vector routing protocols. We deﬁned an interdomain net-
work, a path vector protocol and designed a formal security model
for such protocols, which incorporates three general security re-
quirements and is quite strong in terms of adversarial capabilities.
Using our framework we analyzed security of the Secure BGP pro-
tocol. Assuming the underlying signature scheme is secure, we
proved that S-BGP meets two out of the security deﬁnition’s three
requirements and showed how the protocol can be modiﬁed to meet
all tree security requirements at the same time. We also studied
SoBGP and showed that it fails to meet two security goals. Finally,
we studied security of partial PKI deployment when not all nodes
have public keys. We investigated the possibilities of relaxing the
PKI requirement while relying on the non-cryptographic physical
security of the protocol in order to achieve possibly weaker, but
still well-deﬁned, notions of security. We also presented the nec-
essary and sufﬁcient conditions to achieve full security in the par-
tial PKI deployment scenario. We believe our results ﬁll the gap
between the advances of modern cryptography and provable secu-
rity methodology and practical networking protocols, and should
be useful for protocol developers, standards bodies, and govern-
ment agencies.

10. ACKNOWLEDGMENTS

We thank Nick Feamster, Vytautas Valancius and the anonymous
reviewers for very useful comments. We also thank Mamta Upad-
hya for her participation in the early stages of the project.

11. REFERENCES
[1] American Registry for Internet Numbers (ARIN).

https://www.arin.net/.

[2] BGP Routing table analysis reports.

http://bgp.potaroo.net.

[3] The Internet Assigned Numbers Authority (IANA).

http://www.iana.org/.

[4] Internet Engineering Task Force (IETF) secure inter-domain

routing group (SIDR). http:
//datatracker.ietf.org/wg/sidr/charter/.

[5] Resource Public Key Infrastructure (RPKI).

https://www.arin.net/resources/rpki.html.

[6] C. Adams and S. Farrell. Internet X.509 Public Key

Infrastructure: Certiﬁcate management protocols, 2004.

[7] W. Aiello, J. Ioannidis, and P. McDaniel. Origin

authentication in interdomain routing. In CCS ’03:
Proceedings of the 10th ACM conference on Computer and
communications security, pages 165–178, New York, NY,
USA, 2003. ACM Press.

[8] G. Andersen, H. Balakrishnan, N. Feamster, T. Koponent,
D. Moon, and S. Shenker. Accountable internet protocol
(AIP). In ACM SIGCOMM 2008, Aug. 2008.

[9] M. Backes, I. Cervesato, A. D. Jaggard, A.Scedrov, and J.-K.
Tsay. Cryptographically sound security proofs for basic and
public-key Kerberos. In D. Gollmann, J. Meier, and
A. Sabelfeld, editors, ESORICS, volume 4189 of Lecture
Notes in Computer Science, pages 362–383. Springer, 2006.

[10] H. Ballani, P. Francis, and X. Zhang. A study of preﬁx

hijacking and interception in the Internet. In ACM
SIGCOMM 2007, Aug. 2007.

[11] B. Barak, S. Goldberg, and D. Xiao. Protocols and lower

bounds for failure localization in the Internet. In
EUROCRYPT 2008, Apr. 2008.

[12] A. Barbir, S. Murphy, and Y. Yang. Generic threats to routing

protocols. Network Working Group. IETF Request for
Comments: 3962. Available at
http://www.ietf.org/rfc/rfc4593.txt, 2004.

[13] R. Barrett, S. V. Haar, and R. Whitestone. Routing snafu

snips net service. Interactive Week, 1997.
http://www.zdnet.com/zdnn/content/inwk/
0413/inwk0032.html.

[14] M. Bellare, T. Kohno, and C. Namprempre. Authenticated
encryption in SSH: provably ﬁxing the SSH binary packet
protocol. In CCS ’02. ACM Press, 2002.

[15] S. M. Bellovin and E. R. Gansner. Using link cuts to attack
internet routing. In Tech. Rep., ATT Research, 2004, Work in
Progress 2003 USENIX, 2003.

[16] S. M. Bellovin, J. Ioannidis, and R. Bush. Position paper:
Operational requirements for secured BGP. DHS Secure
Routing Workshop, 2005.

[17] A. Boldyreva, M. Fischlin, A. Palacio, and B. Warinschi. A
closer look at PKI: Security and efﬁciency. In T. Okamoto
and X. Wang, editors, Public Key Cryptography, volume
4450 of Lecture Notes in Computer Science, pages 458–475.
Springer, 2007.

551[18] A. Boldyreva and V. Kumar. Extended abstract:

Provable-security analysis of authenticated encryption in
Kerberos. In IEEE Symposium on Security and Privacy,
pages 92–100. IEEE Computer Society, 2007.

[19] A. Boldyreva and R. Lychev. Provable Security of (S-BGP)

and other Path Vector Protocols: Model, Analysis, and
Extenstions. Full Version of this Paper, 2012. Available from
the authors’ websites.

[20] M. A. Brown. Renesys blog. Pakistan hijacks YouTube,

2008. http://www.renesys.com/blog/2008/02/
pakistan_hijacks_youtube_1.shtml.

[21] K. Butler, T. Farley, P. McDaniel, and J. Rexford. A survey

of BGP security issues and solutions. Technical Report
TD-5UGJ33, AT&T Labs, 2004.

[22] K. Butler, P. McDaniel, and W. Aiello. Optimizing BGP

security by exploiting path stability. In CCS ’06:
Proceedings of the 13th ACM conference on Computer and
communications security, pages 298–310, New York, NY,
USA, 2006. ACM Press.

[23] H. Chan, D. Dash, A. Perrig, and H. Zhang. Modeling
adoptability of secure BGP protocols. In SIGMETRICS
’06/Performance ’06: Proceedings of the joint international
conference on Measurement and modeling of computer
systems, pages 389–390, New York, NY, USA, 2006. ACM
Press.

[24] Y.-J. Chi, R. Oliveira, and L. Zhang. Cyclops: The internet

as-level observatory. ACM SIGCOMM Computer
Communication Review, 2008.

[25] J. Cowie. Renesys blog. China’s 18-minute mystery, 2010.

http://www.renesys.com/blog/2010/11/
chinas-18-minute-mystery.shtml.

[26] B. Dickson. Route Leaks – Requirements for Detection and
Prevention thereof (v2). IETF Internet Draft, 2012. Available
at http://tools.ietf.org/html/
draft-dickson-sidr-route-leak-reqts-02.

[27] L. Gao and J. Rexford. Stable internet routing without global

coordination. SIGMETRICS Perform. Eval. Rev.,
28:307–317, June 2000.

[28] P. Gill, M. Schapira, and S. Goldberg. Let the market drive
deployment: A strategy for transitioning to BGP security. In
ACM SIGCOMM 2011, Aug. 2011.

[29] S. Goldberg, S. Halevi, A. Jaggard, V. Ramachandran, and
R. Wright. Rationality and trafﬁc attraction: Incentives for
honestly announcing paths in BGP. In ACM SIGCOMM
2008, Aug. 2008.

[30] S. Goldberg, M. Schapira, P. Hummon, and J. Rexford. How

secure are secure interdomain routing protocols? In ACM
SIGCOMM 2010, Aug. 2010.

[31] S. Goldberg, D. Xiao, B. Barak, J. Rexford, and E. Tromer.

Path-quality monitoring in the presence of adversaries. In
ACM SIGMETRICS 2008, June 2008.

[32] G. Goodell, W. Aiello, T. Grifﬁn, J. Ioannidis, P. McDaniel,

and A. Rubin. Working around bgp: An incremental
approach to improving security and accuracy in interdomain
routing, 2003.

[33] Y.-C. Hu, A. Perrig, and M. Sirbu. SPV: secure path vector

routing for securing BGP. In SIGCOMM ’04: Proceedings of
the 2004 conference on Applications, technologies,
architectures, and protocols for computer communications,
pages 179–192, New York, NY, USA, 2004. ACM Press.

[34] S. Kent, C. Lynn, and K. Seo. Secure border gateway

protocol (S-BGP). IEEE Journal on Selected Areas in
Communications, 18(4):582–592, 2000.

[35] S. T. Kent, C. Lynn, J. Mikkelson, and K. Seo. Secure Border

Gateway Protocol (S-BGP) - Real world performance and
deployment issues. In NDSS. The Internet Society, 2000.
[36] M. Lepinski. An infrustructure to support secure internet

routing.

[37] M. Lepinski. BGPSEC Protocol Speciﬁcation (v4). IETF

Internet Draft, 2012. Available at
http://tools.ietf.org/html/
draft-ietf-sidr-bgpsec-protocol-04.

[38] R. Mahajan, D. Wetherall, and T. Anderson. Understanding
bgp misconﬁguration. In ACM SIGCOMM 2002, Aug. 2002.
[39] A. Mityagin, S. Panjwani, and B. Raghavan. Analysis of the

SPV secure routing protocol. Cryptology ePrint Archive,
Report 2006/087, 2006. http://eprint.iacr.org/.
[40] S. Murphy. BGP security vulnerabilities analysis. Network

Working Group. IETF Request for Comments: 3962.
Available at
http://www.ietf.org/rfc/rfc4272.txt, 2006.

[41] D. of Homeland Security. The national strategy to secure

cyberspace, 2003.
http://www.whitehouse.gov/pcipb/.

[42] U. of Oregon Route Views Project.

http://www.routeviews.org.

[43] K. G. Paterson and G. J. Watson. Plaintext-dependent

decryption: A formal security treatment of SSH-CTR. In
H.Gilbert, editor, EUROCRYPT, volume 6110 of Lecture
Notes in Computer Science, pages 345–361. Springer, 2010.
[44] Y. Rikhter, T. Li, and S. Hares. A Border Gateway Protocol 4

(BGP-4). Network Working Group. IETF Request for
Comments: 4271. Available at
http://www.ietf.org/rfc/rfc4271.txt, 2006.

[45] T. Ristenpart and S. Yilek. The power of

proofs-of-possession: Securing multiparty signatures against
rogue-key attacks. In M. Naor, editor, EUROCRYPT, volume
4515 of Lecture Notes in Computer Science, pages 228–245.
Springer, 2007.

[46] L. Subramanian, V. Roth, I. Stoica, S. Shenker, and R. Katz.
Listen and whisper: Security mechanisms for BGP. In Proc.
First Symposium on Networked Systems Design and
Implementation (NSDI), San Francisco, CA, Mar. 2004.
[47] S. Sundaresan, R. Lychev, and V. Valancius. Preventing
attacks on BGP policies: One bit is enough. Technical
Report GT-CS-11-07, Georgia Institute of Technology, 2011.

[48] The BGP TTL Security Hack. http:

//tools.ietf.org/html/draft-gill-btsh-02.

[49] T. Wan, E. Kranakis, and P. C. van Oorschot. Pretty secure

BGP, psBGP. In NDSS. The Internet Society, 2005.

[50] R. White. Securing BGP through secure origin BGP. The

Internet Protocol Journal, 6(3), Sept. 2003. http:
//www.cisco.com/web/about/ac123/ac147/
archived_issues/ipj_6-3/ipj_6-3.pdf.

[51] M. Zhao, S. W. Smith, and D. M. Nicol. Aggregated path

authentication for efﬁcient BGP security. In CCS ’05:
Proceedings of the 12th ACM conference on Computer and
communications security, pages 128–138, New York, NY,
USA, 2005. ACM Press.

552