Preventing Use-after-free with
Dangling Pointers Nullification

Byoungyoung Lee† Chengyu Song† Yeongjin Jang† Tielei Wang†

Taesoo Kim† Long Lu∗ Wenke Lee†

†{blee, csong84, yeongjin.jang, tielei,

taesoo}@gatech.edu, wenke@cc.gatech.edu

School of Computer Science,
Georgia Institute of Technology

Abstract—Many system components and network applications
are written in languages that are prone to memory corruption
vulnerabilities. There have been countless cases where simple
mistakes by developers resulted in memory corruption vulnera-
bilities and consequently security exploits. While there have been
tremendous research efforts to mitigate these vulnerabilities, use-
after-free still remains one of the most critical and popular attack
vectors because existing proposals have not adequately addressed
the challenging program analysis and runtime performance
issues.

In this paper we present DANGNULL, a system that detects
temporal memory safety violations—in particular, use-after-free
and double-free—during runtime. DANGNULL relies on the key
observation that the root cause of these violations is that pointers
are not nullified after the target object is freed. Based on this
observation, DANGNULL automatically traces the object’s rela-
tionships via pointers and automatically nullifies all pointers when
the target object is freed. DANGNULL offers several benefits. First,
DANGNULL addresses the root cause of temporal memory safety
violations. It does not rely on the side effects of violations, which
can vary and may be masked by attacks. Thus, DANGNULL is ef-
fective against even the most sophisticated exploitation techniques.
Second, DANGNULL checks object relationship information using
runtime object range analysis on pointers, and thus is able to
keep track of pointer semantics more robustly even in complex
and large scale software. Lastly, DANGNULL does not require
numerous explicit sanity checks on memory accesses because
it can detect a violation with implicit exception handling, and
thus its detection capabilities only incur moderate performance
overhead.

I.

INTRODUCTION

Many system components and network applications are
written in the unsafe C/C++ languages that are prone to
memory corruption vulnerabilities. To address this problem, a

Permission to freely reproduce all or part of this paper for noncommercial
purposes is granted provided that copies bear this notice and the full citation
on the first page. Reproduction for commercial purposes is strictly prohibited
without the prior written consent of the Internet Society, the first-named author
(for reproduction of an entire paper only), and the author’s employer if the
paper was prepared within the scope of employment.
NDSS ’15, 8-11 February 2015, San Diego, CA, USA
Copyright 2015 Internet Society, ISBN 1-891562-38-X
http://dx.doi.org/10.14722/ndss.2015.23238

∗long@cs.stonybrook.edu

Department of Computer Science,

Stony Brook University

Severity Use-after-free

Critical
High
Medium
Low
Total

13
582
80
5
680

Heap

Stack
overflow overflow
0
107
98
3
208

0
12
5
0
17

Others

0
11
12
1
24

Table I: The number of security vulnerabilities in the
Chromium browser for two years (2011–2013), classified by
types of vulnerabilities and their severity.

large number of techniques have been developed to improve
memory safety and prevent memory corruption bugs from being
exploited [2, 4, 12, 19, 30–33, 38, 48]. However, the problem of
detecting and preventing use-after-free bugs remains unsolved.
Among the CVE identifiers of the Chromium browser that we
collected from Oct. 2011 to Oct. 2013 in Table I, use-after-
free vulnerabilities are not only 40x/3x more than stack and
heap overflows in quantity, but also have more severe security
impacts than traditional vulnerabilities: 88% of use-after-free
bugs are rated critical or high in severity, while only 51%
of heap overflows are considered as high severity. Not only
are there many use-after-free vulnerabilities, they have also
become a significant attack vector. In Pwn2Own 2014 [21], an
annual contest among hackers and security research groups,
the VUPEN team was awarded with the largest cash amount,
$100,000, for a single use-after-free exploit that affects all
major WebKit-based browsers.

Compared with many other vulnerability types, including
stack buffer overflows or heap buffer overflows, use-after-free is
generally known as one of the most difficult vulnerability type
to identify using static analysis. In modern C/C++ applications
(especially under object-oriented or event-driven designs), the
resource free (i.e., memory deallocation) and use (i.e., memory
dereference) are well separated and heavily complicated.
Statically identifying use-after-free vulnerabilities under this
difficult conditions involves solving challenging static analysis
problems (e.g., inter-procedural and point-to analysis while also
considering multi-threading effects), and is therefore feasible
only for small size programs [13, 34].

Category

Use-after-free detectors

Protection
Technique

DANGNULL
CETS [30]
Undangle [6]
Xu et al. [48]

Memory error detectors AddressSanitizer [38]

Memcheck [32]
Purify [19]
CCFIR [50]
bin-CFI [51]
SafeDispatch [22]

Control Flow Integrity

Safe memory allocators Cling [2]

DieHarder [33]

Explicit Liveness
Checks
Support

False positive Bypassable

Rates

Bypassing Exploit Technique

No
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
No
No

Yes
No
No
No
No
No
No
No
No
No
No
No

Low
High
Low
Low
Low
High
High
Low
Low
Low
Low
Low

No
No
No
No
Yes
No
No
Yes
Yes
Yes
Yes
Yes

N/A
N/A
N/A
N/A

Heap manipulation

N/A
N/A

Abusing coarse grained CFI

or

corrupting non-function pointers

Heap manipulation
Heap manipulation

Table II: Comparing the proposed system DANGNULL with other protection techniques detecting use-after-free. The
Explicit checks column represents whether the technique explicitly instruments checks to detect use-after-free except via pointer
propagation. The Liveness support column represents whether the technique may continuously run an instrumented application as
if use-after-free vulnerabilities are patched. The False positive rates column represents whether the technique would generate
the high/low number of false alarms on benign inputs, and high false positive rates imply that it would be difficult to be deployed
for large scale software. The Bypassable column shows whether the protection technique can be bypassable with the following
column’s exploitation technique. Overall, while all other protection techniques show either high false positive rates or being
bypassable, DANGNULL achieves both low false positive rates and being non-bypassable against sophisticated exploitation
techniques. §VII describes more details on each protection technique.

Most research efforts to detect use-after-free vulnerabilities
are relying on either additional runtime checks or dynamic
analysis (listed in Table II). For instance, use-after-free detectors
including [30, 48] have been proposed to address dangling
pointer issues. By maintaining metadata for each pointer and
tracking precise pointer semantics (i.e., which pointer points
to which memory region), these tools can identify dangling
pointers or prevent memory accesses through dangling pointers.
However, precisely tracking runtime semantics on a per-pointer
bases is non-trivial as there would be a huge number of pointers
and their metadata in runtime, which may result in high false
positive rates (i.e., identifying benign program behavior as
use-after-free) or significant performance degradation. Such
shortcomings would limit the potential for these techniques to
be deployed for large scale software.

Memory error detectors [19, 32, 38] are also able to
capture use-after-free bugs during the software testing phase.
By maintaining the allocated/freed status of memory, these
tools can prevent accesses to freed memory. However, these
tools are not suitable for detecting real-world exploits against
use-after-free vulnerabilities if attackers can partially control the
heap memory allocation process, especially for web browsers.
For example, by using Heap Spraying [10, 36] or Heap
Fengshui [39] like techniques, attackers can force the target
program to reuse certain freed memory.

In addition, Control Flow Integrity (CFI) tools can be used
to prevent use-after-free vulnerabilities from being exploited
to hijack the control-flow because the majority of vulnerability
exploitations hijack the control flow to execute malicious code
with Return-Oriented Programming (ROP) [35]. However, due
to the inherent limitations of these tools, most of them only
enforce coarse-grained CFI, which leaves some control-flows
exploitable [7, 11, 15, 16]. Moreover, since control-flow hijacks
are not the only method to compromise a program, it is still

possible to bypass these techniques even if they can enforce
perfect CFI, e.g., via non-control data attacks [8, 27].

Overall, all of the previous protection techniques show
either high false positive rates or are bypassable using certain
exploitation techniques. In other words, there is currently no
use-after-free mitigation solution that works well for large scale
software and can also stop all known forms of use-after-free
exploitation techniques.

In this paper, we present DANGNULL, a system that
prevents temporal memory safety violations (i.e., use-after-
free and double-free) at runtime. As suggested by many secure
programming books [37], a pointer should be set to NULL after
the target object is freed. Motivated by the fact that dangling
pointers obviously violate this rule, DANGNULL automatically
traces the object relationships and nullifies their pointers when
the object they pointed to is freed. In particular, rather than rely-
ing on a heavy dynamic taint analysis, DANGNULL incorporates
a runtime object range analysis on pointers to efficiently keep
track of both pointer semantics and object relationships. Based
on the collected object relationship information, DANGNULL
nullifies dangling pointers when the target memory is freed.
After this nullification, any temporal memory safety violation
(i.e., dereferencing the dangling pointers) turns into a null-
dereference that can be safely contained.

This unique design choice of DANGNULL offers several
benefits. First, since nullification immediately eliminates any
possible negative security impacts at the moment dangling
pointers are created, DANGNULL does not rely on the side
effects from use-after-free or double-free, and thus cannot
be bypassed by sophisticated exploit techniques. Second, a
runtime object range analysis on pointers allows DANGNULL
to efficiently keep track of pointer semantics. Instead of tracing
complicated full pointer semantics, DANGNULL only tracks

2

# All store instructions are
# in the LLVM IR form of ’lhs := rhs’.
for storeInstr in function.allStoreInstructions:

# Only insterested in a pointer on the heap.
if mustStackVar(lhs):

if not isPointerType(rhs):

lhs = storeInstr.lhs
rhs = storeInstr.rhs

1 for function in Program:
2
3
4
5
6
7
8
9
10
11
12
13
14
15

continue

continue

new = createCallInstr(trace, lhs, rhs)
storeInstr.appendInstr(new)

Algorithm 1: The algorithm for static instrumentation. For
every store instruction where the destination may stay on the
heap, DANGNULL inserts trace() to keep track of the relation
between the pointer and the object it points to.

On every memory allocation, DANGNULL initializes a
shadow object for the target object being created. Upon freeing
an object, DANGNULL retrieves all pointers that point to this
object (from shadowObjTree) and nullifies those pointers, to
prevent potential use-after-free or double-free.

Later in this section, we describe each component of
DANGNULL (the static instrumentation and the runtime library),
and explain how we maintain shadowObjTree with a concrete
running example (Example 1).

B. Static Instrumentation

The static instrumentation of DANGNULL is done at the
LLVM IR [24] level and is designed to achieve one primary
goal: to monitor pointer assignments to maintain the point-to
relations. To balance security, performance, and engineering
efforts, only appropriate pointers are instrumented. More
specifically, DANGNULL only tracks pointers located on the
heap (e.g., doc→child in Example 1) but not on the stack
(e.g., doc in Example 1). From our preliminary experiment on
the Chromium browser, we found that stack-located pointers
are unlikely to be exploitable, even though are many dangling
pointers. This is because stack-located pointers tend to have
a very short lifetime since the scope of stack variables are
bounded by the scope of a function and accesses to those
variables are limited in the programming language. Heap-
located pointers generally have much a longer lifetime (i.e.,
the number of instructions between free and use is larger). In
other words, unsafe dangling pointers located in the heap offer
better controls between the free and dereference operations,
and are thus are more likely to be exploited (§II). Therefore, to
reduce performance overhead and keep our engineering efforts
effective and moderate, we focus on heap-located pointers. Note
that the nullification idea of DANGNULL has no dependencies
on the pointer locations, and is generally applicable to both
heap- and stack-located pointers.

The algorithm for the static instrumentation is described
in Algorithm 1. At lines 1-4, all store instructions 1 in each
function are iterated. With the pointer information obtained at
lines 5-6, DANGNULL first opts out if lhs is a stack variable,
using a intra-procedure backward data-flow analysis (line 9-
10). Specifically, given a lhs variable, we leveraged a def-use

1In the LLVM IR, store instructions are always in the form of lhs := rhs.

5

chain provided by LLVM to see if this variable is allocated
on the stack via the allocation statement. Since this analysis is
conservative, it is possible that DANGNULL still instruments
some pointer assignments in the stack. However, as DANGNULL
does not instrument allocations and deallocations of stack
variables, such assignments will be ignored by the runtime
library. Next, DANGNULL performs a simple type signature
check to see if rhs is not of a pointer type (line 11-12) 2. With
these two opt-out checks, DANGNULL ignores all uninteresting
cases as the current version of DANGNULL only targets the
heap located pointers. Because the location of a heap pointer
cannot always be statically known due to pointer aliasing issues,
store instructions are conservatively instrumented unless it is
soundly determined to be a stack-located pointer. Any possible
over-instrumentation due to this conservative choice will be
handled using the runtime object range analysis, which we will
describe in the next subsection (§III-C).

Once all these sanity checks are passed, a trace() function
call is inserted after the store instruction. For example, to in-
strument doc->child = body in Example 1, DANGNULL inserts
trace(&doc->child, body) after its assignment instruction. In
this way, the DANGNULL’s runtime library can later correctly
trace the pointer references originating from doc->child.

Note that DANGNULL relies on the type signature of
C/C++. Coercing type signatures in the code might cause some
false negatives, meaning that DANGNULL can miss some
propagation of pointers at runtime. In particular, if developers
convert types of pointer objects (by casting) into a value of non-
pointer types, then DANGNULL will not be able to trace the
pointer propagation via that value. Moreover, if some libraries
are not built using DANGNULL (e.g., proprietary libraries),
DANGNULL would still be able to run them together, but the
protection domain will be limited only to the instrumented
code or modules.

C. Runtime Library

The runtime library of DANGNULL maintains all the object
relationship information with an efficient variant of a red-
black tree, called shadowObjTree. Object layout information (i.e.,
address ranges of an object) is populated by interposing all
memory allocation and deallocation functions (e.g., malloc
and free, new and delete, etc). Object relationships (i.e., an
object refers to another object) are captured with the help of
trace() added during the static instrumentation. Based on the
collected object relationship information, the runtime library
automatically nullifies all dangling pointers when the target
memory is freed.

In this subsection, we first describe shadowObjTree, a data
structure designed for maintaining the complex object re-
lationships (§III-C1). We then further describe how these
data structures are populated and how dangling pointers are
immediately nullified during runtime (§III-C2).

1) Shadow Object Tree: DANGNULL records and maintains
the relationships between objects3 in shadowObjTree. It has a
hierarchical structure because the object relationship itself

2In the LLVM IR, the type of lhs of a store instruction is always the pointer

of the rhs’s type.

3Since DANGNULL only tracks pointers stored on heap,

the point-to

relationship effectively becomes a relationship between heap objects.

and div as an out-bound sub-tree.

2) Runtime Operations and Nullification: Upon running
the instrumented binary, the runtime library of DANGNULL
interposes all memory allocations and deallocations, and
redirects their invocations to allocObj() and freeObj(). In addi-
tion, trace() instructions were inserted at pointer propagation
instructions from the static instrumentation. As a running
example, Example 2 illustrates how DANGNULL interposes and
instruments the example code in Example 1 where + marked
lines show the interposed or instrumented code.

The algorithm for the runtime library, which populates
shadowObjTree, is described in Algorithm 2. Upon the memory
allocation invocation, allocObj() first invokes corresponding
real allocation functions (line 2). With the base pointer address
from the real allocation, a shadow object is created and inserted
to shadowObjTree as a node (lines 3-4). When trace() is invoked,
the object relationship is added to the shadow objects. It first
fetches two shadow objects representing lhs and rhs pointers,
respectively (line 9-10). Next, with the concrete runtime values
on pointers, DANGNULL uses the object range analysis to
check whether lhs and rhs truly point to live heap objects (line
13). It is worth noting that this object range analysis not only
helps DANGNULL avoid tracing any incorrect or unnecessary
pointer semantics that are not related to dangling pointer issues,
but also makes DANGNULL more robust on object relationship
tracings, since it is based on concrete values and reasons about
the correctness of pointer semantics with the liveness of source
and destination heap objects. If the check passes, DANGNULL
first removes an existing relationship, if there is any (line 14).
It then inserts the shadow pointer to both shadow objects (line
16-17).

Note, by using shadowObjTree, DANGNULL does not need
to handle pointer arithmetic to trace pointers. Specifically,
because shadowObjTree contains information (base and size)
of all live heap objects, given any pointer p, DANGNULL
can locate the corresponding object through a search query
(shadowObjTree.find()), i.e., finding object that has its base ≤
q < (base + size). For the same reason, although DANGNULL
does not trace non-heap-located pointers (i.e., pointers in the
stack or global variables), DANGNULL can still trace correctly
when the pointer value is copied through them and brought
back to the heap.

When an object is freed with freeObj(), the actual nul-
lification starts. DANGNULL first fetches its shadow object
(line 21). Next, it iterates over all in-bound pointers (pointing
to the current object to be freed), and nullifies them with a
pre-defined value (NULLIFY_VALUE at line 27). Note that these
in-bound pointers are the pointers that would become dangling
otherwise, and the pre-defined value can be set as any relatively
small non-negative integer value (e.g., 0, 1, 2, ...). To avoid
the erroneous nullification due to later deallocation of objects
that the current object points to, DANGNULL also removes
the current object from the sub-tree of the out-bound pointers
(lines 29-31).

It is worth noting that DANGNULL nullifies not only unsafe
dangling pointers, but also benign dangling pointers. In spite
of this extra nullification, DANGNULL can still retain the same
program behavior semantics because benign dangling pointers
should not have any pointer semantics (i.e., never be used).

Figure 2: The shadow object tree and three shadow objects
(doc, body, and div) corresponding to Example 1. To simplify
the representation, only in- and out- bound pointers of the body
shadow object are shown. body keeps the in-bound pointer for
doc→child, which points to the shadow object of doc, and the
out-bound pointer for body->child, which points to the shadow
object of div.

is hierarchical: each running process has multiple objects,
and each object has multiple in/out-bound pointers. Thus,
shadowObjTree is composed of several sub-data structures as
nodes, to better represent this hierarchical structure.

Figure 2 shows a structural view of shadowObjTree. A node
of shadowObjTree is a shadow object, which holds the object’s
memory layout information (i.e., the object boundary with base
and end addresses) and in/out-bound pointers (i.e., directed
references between objects). To find a shadow object for the
given pointer p, shadowObjTree searches for a shadow object
such that the corresponding object’s base ≤ p < end. In
other words, as long as the pointer p points to a corresponding
object’s address range, shadowObjTree returns the shadow object.

To efficiently support operations like insert, remove, and
search, shadowObjTree uses a variant of the red-black tree as
the underlying data structure, which generally excels if 1)
the insertion order of keys shows random patterns and 2)
the number of search operations is significantly more than
that of insertion and remove operations. In shadowObjTree, the
key is the address of the object, and the order of allocated
objects’ addresses eventually depends on the mmap() system
call, which shows random behavior in modern ASLR enabled
systems. Moreover, DANGNULL requires significantly more
find() operations than allocObj() and freeObj() operations to
soundly trace the object relationships.

Note that a hash table would not be an appropriate data
structure for shadowObjTree because it cannot efficiently handle
the size information of an object. To be specific, a find operation
of shadowObjTree must answer range-based queries (i.e., finding
a corresponding shadow object given the address, where the
address can point to the middle of a shadow object), but a
hash function of a hash table cannot be efficiently designed to
incorporate such range information.

In addition, shadowObjTree has two sub-trees to maintain
in/out-bound pointer information, and each sub-tree uses a red-
black tree as the underlying data structure for the same reason
described for shadowObjTree. As the pointer reference is directed,
an in-bound reference of the object denotes that the object is
pointed to by some other object and an out-bound reference
denotes that it points to some other object. For example, the
body object in Example 1 has doc→child as an in-bound sub-tree

6

shadowObjTree......inoutinoutinoutdocbodydivbody→childdoc→child1 // (a) memory allocations
2 + Document *doc = allocObj(Document);
3 + Body *body = allocObj(Body);
4 + Div *div = allocObj(Div);
5
6 // (b) using memory: propagating pointers
7 doc->child = body;
8 + trace(&doc->child, body);
9
10 body->child = div;
11 + trace(&body->child, div);
12
13 // (c) memory free: unsafe dangling pointer, doc->child,
14 //
15 + freeObj(body);
16
17 // (d) use-aftre-free is prevented, avoid dereferencing it
18 if (doc->child)
19

is automatically nullified

doc->child->getAlign();

Example 2: Instrumented running example of Example 1
(actual instrumentation proceeds at the LLVM Bitcode level).
Memory allocations (new) and deallocations (free) are replaced
with allocObj() and freeObj(), and trace() is placed on every
memory assignment, according to the static instrumentation
algorithm (Algorithm 1).

In most cases as we quantified in §V, DANGNULL behaves
correctly without false positives. We have found one rare false
positive case, described in detail in §VI.

In our secured binary (Example 2), doc→child is auto-
matically nullified when body is freed: the shadow object
representing body was created (line 3), propagated to doc→child
(line 8), and nullified when the body is deallocated (line 15). As
a result, depending on NULLIFY_VALUE, the example would raise
the SIGSEGV exception (if NULLIFY_VALUE > 0) or continuously
run (if NULLIFY_VALUE == 0), both of which safely mitigates
negative security impacts by unsafe dangling pointers.

For the SIGSEGV exception cases, DANGNULL guarantees
that the program securely ends in a safe-dereference, which is
defined as follows.

Definition 4. Safe-dereference. If a dereference instruction
accesses the memory address in the range of [0, N] where it is
preoccupied as non-readable and non-writable memory pages
for a given constant N, such a dereference is a safe-dereference.
A safe-dereference guarantees that a dereference on nullified
unsafe dangling pointers turns into a secured crash handled
either by the operating system or DANGNULL’s SIGSEGV excep-
tion handler. In modern operating systems, it is common that
the first several virtual memory pages are protected to avoid any
potential null-dereference attacks (e.g., virtual address spaces
from 0 to 64K are protected in Ubuntu [46]). In other words,
DANGNULL can utilize this existing null address padding to
guarantee safe-dereferences (64K in Ubuntu). Even if this null
address padding is not supported by the operating system,
DANGNULL can still pre-allocate these spaces using the mmap()
system call to be non-readable and non-writable before any
other code runs.

For continuously running cases, DANGNULL utilized the
existing sanity check at line 18. This is because the semantic on
invalid pointers is identical to both DANGNULL’s nullification
and typical programming practices. In other words, because it
is common for developers to check whether the pointer value is
null before accessing it, DANGNULL’s nullification can utilize

ptr = real_alloc(size)
shadowObj = createShadowObj(ptr, size)
shadowObjTree.insert(shadowObj)
return ptr

lhsShadowObj = shadowObjTree.find(lhs)
rhsShadowObj = shadowObjTree.find(rhs)

# Check if lhs and rhs are eligible targets.
if lhsShadowObj and rhsShadowObj:

removeOldShadowPtr(lhs, rhs)
ptr = createShadowPtr(lhs, rhs)
lhsShadowObj.insertOutboundPtr(ptr)
rhsShadowObj.insertInboundPtr(ptr)

1 def allocObj(size):
2
3
4
5
6
7 # NOTE. lhs <- rhs
8 def trace(lhs, rhs):
9
10
11
12
13
14
15
16
17
18
19
20 def freeObj(ptr):
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35

return

shadowObj = shadowObjTree.find(ptr)

for ptr in shadowObj.getInboundPtrs():

srcShadowObj = shadowObjTree.find(ptr)
srcShadowObj.removeOutboundPtr(ptr)
if shadowObj.base <= ptr < shadowObj.end:

*ptr = NULLIFY_VALUE

for ptr in shadowObj.getOutboundPtrs():

dstShadowObj = shadowObjTree.find(ptr)
dstShadowObj.removeInboundPtr(ptr)

shadowObjTree.remove(shadowObj)

return real_free(ptr)

Algorithm 2: The Runtime library algorithm. All error handling
and synchronization code is omitted for clarity. DANGNULL has
a global data structure (thread-safe), shadowObjTree, to maintain
object relations with shadow objects. allocObj() and freeObj()
replaced the malloc() and free() (and their equivalence, new and
delete in C++), and trace() will be inserted on every memory
assignments as a result of the static instrumentation (§III-B).

such existing checks and keep the application running as if
there were no unsafe dangling pointers.

This example is oversimplified for the purpose of clarifying
the problem scope and showing how DANGNULL can nullify
dangling pointers. In §V-A, we show that DANGNULL is
effective when applied to real, complex use-after-free bugs in
Chromium.

IV.

IMPLEMENTATION

We implemented DANGNULL based on the LLVM Com-
piler project [43]. The static instrumentation module is imple-
mented as an extra LLVM pass, and the runtime library is
implemented based on LLVM compiler-rt with the LLVM
Sanitizer code base. Table III shows the lines of code to
implement DANGNULL, excluding empty lines and comments.
We placed the initialization function into .preinit_array as
a ELF file format so that the initialization of DANGNULL is
done before any other function4. In this function, all standard
allocation and deallocation functions (e.g., malloc and free,
new and delete, etc) are interposed. In total, DANGNULL
interposed 18 different allocation functions in the current
implementation, and any additional customized allocators for

4DANGNULL’s prototype is implemented on a Linux platform. Although
several implementation details are specific to Linux, these can be generally
handled in other platforms as well.

7

Components
Static Instrumentation
Runtime Library
shadowObjTree
Red-black tree
Runtime function redirection
Others

Total

Lines of code
389
3,955
1,303
476
233
1,943
4,344

Table III: Components of DANGNULL and their complexities,
in terms of their lines of code. All components are written in
C++.

the target application can be easily added with one line of its
function signature.

To avoid multi-threading issues when running DANGNULL,
we used mutex locks for any data structures with the potential
for data racing. One global mutex lock is used for shadowObjTree,
and all shadow objects and their in/out–bound pointer sub-trees
also hold their own mutex locks.

To retain the target program’s original memory layout,
DANGNULL uses a dedicated allocator from Sanitizer that has
dedicated memory pages. All memory for metadata, including
shadowObjTree and its pointer sub-trees, is allocated from this
allocator. Thus, DANGNULL does not interfere with the original
memory layout, and it can avoid any potential side effects by
manipulating the original allocators [14].

We also modified the front-end of LLVM so that users of
DANGNULL can easily build and secure their target applications
with one extra compilation option and linker option. To build
SPEC CPU 2006 benchmarks, we added one line to the build
configuration file. To build the Chromium browser, we added
21 lines to the .gyp build configuration files.

V. EVALUATION

We evaluated DANGNULL on two program sets, the SPEC
CPU2006 benchmarks [40] and the Chromium browser [41] 5.
First, we tested how accurately DANGNULL mitigates known
use-after-free exploits (§V-A). Next, we measured how much
overhead DANGNULL imposes during the instrumentation
phase (§V-B) and the runtime phase (§V-C). Finally, we
conducted a stress test to see if DANGNULL runs well without
breaking compatibility (§V-D). All experiments were conducted
on an Ubuntu 13.10 system (Linux Kernel 3.11.0) with a quad-
core 3.40 GHz CPU (Intel Xeon E3-1245), 16 GB RAM, and
1 TB SSD-based storage.

A. Attack Mitigation

The goal of DANGNULL is to turn use-after-free or double-
free attempts into safe-dereferences by nullifying dangling
pointers. In order to test how DANGNULL accurately nulli-
fied unsafe dangling pointers and eventually protected the
system from temporal memory safety violations, we tested the
DANGNULL-hardened Chromium browser with real-world use-
after-free exploits. Given the Chromium version instrumented

5The Chromium browser is the open source project behind the Chrome

browser, and these two are largely identical.

(29.0.1457.65), we first collected all publicly available use-after-
free exploits from the Chromium bug tracking system [42],
which opens vulnerability information to the public after
mitigation and includes a proof of concept exploit6.

Table IV lists seven use-after-free vulnerabilities that existed
in the targeted Chromium version. All of these were marked
as high severity vulnerabilities by the Chromium team, which
suggests that these have a high potential to be used for arbitrary
code execution. Bug ID 162835 was specifically selected to later
demonstrate that DANGNULL can mitigate this sophisticated
exploit technique.

Before applying DANGNULL, all proofs-of-concept can
trigger SIGSEGV exceptions at invalid addresses (No-Nullify
column in Table IV). These invalid addresses are memory
addresses that are dereferenced, i.e., the values of unsafe
dangling pointers. Although we only present one value for
each vulnerability, this value would randomly change between
different executions due to ASLR and the order of memory
allocations. These seemingly random SIGSEGV exceptions can
be abused to launch control-flow hijacking attacks, information
leaks, etc. They are particularly dangerous if the vulnerability
offers a control between free and use (the right-most column,
Control b/w free and use). For example, with this control,
malicious JavaScript code can place crafted data in freed
memory and turn the SIGSEGV exception (i.e., deference the
unsafe dangling pointer) into control-flow hijacking attacks or
information leakages depending on the context of dereference
operations. Moreover, this control between free and use also
implies that the attackers can bypass memory error detection
tools (e.g., AddressSanitizer [38]) because it allows the attackers
to force the reuse of a freed memory region (see more details
in §VII and a concrete bypassing case (Example 5)).

Once Chromium is instrumented with DANGNULL, all of
these cases were safely mitigated (Nullify-value column).
Depending on the nullify value provided as a parameter,
all 28 cases (7 rows by 4 columns) result in the following
three categories: 1) integer values represent that DANGNULL
securely contained SIGSEGV exceptions with safe-dereference;
2) stopped by assertion represents that DANGNULL re-utilized
existing safe assertions in Chromium; and 3) check marks (✓)
represent that Chromium continuously runs as if Chromium is
already patched.

For the safe-dereference cases, it is worth noting that the
dereferenced address values are quite small (at most 0x2e8).
Although these seven exploits would not be enough to represent
all use-after-free behaviors, we believe this implies that the
moderate size of null address padding for safe-dereference
(§III-C2) would be effective enough. DANGNULL’s null address
padding can be easily extended without actual physical memory
overheads if necessary, and 64-bit x86 architectures can allow
even more aggressive pre-mappings. Moreover, unlike the case
before applying DANGNULL, these dereferenced addresses
did not change between different executions. This indicates
that unsafe dangling pointers were successfully nullified using

6We have not found any double-free vulnerabilities for the given Chromium
version. However, we believe DANGNULL would be equally effective against
double-free exploits because DANGNULL nullifies exploit attempts where both
use-after-free and double-free share common erroneous behaviors (i.e., at the
moment when the unsafe dangling pointer is created).

8

Bug ID CVE

Severity

No-Nullify

261836
265838
279277
282088
286975
295010
162835

-
2013-2909
2013-2909
2013-2918
2013-2922
2013-6625
2012-5137

High
High
High
High
High
High
High

0x7f27000001a8
0x1bfc9901ece1
0x7f2f57260968
0x490341400000
0x60b000006da4
0x897ccce6951
0x612000046c18

Nullify-value
2
0x22
0x2
0x2
0xf0
0x16
0x2

0
1
0x2e8
0x21
✓
0x1
✓
0x1
0xf0
0xf0
✓ 0x15
0x1

0x30

stopped by assertion

3
0x23
0x3
0x3
0xf0
0x17
0x3

Control b/w
free and use
yes
yes
yes
difficult
yes
yes
yes

Table IV: DANGNULL safely nullified all seven real-world use-after-free exploits for Chromium. Among these seven cases,
three correctly run even after use-after-free exploits as if it was patched (represented as a ✓), and one is safely prevented as
DANGNULL re-utilized existing assertions in Chromium (represented as stopped by assertion). Without DANGNULL, all exploits
are potential threats, leading to control-flow hijacking attacks, information leakages, etc. To be concrete, we also include invalid
pointers causing an exception with various nullification values (0-3), and their threat in terms of the chances of an attacker’s
control between free and use.

Name

Lan.

bzip2
C
gcc
C
mcf
C
milc
C
namd
C++
gobmk
C
soplex
C++
povray
C++
hmmer
C
sjeng
C
libquantum C
h264ref
C
lbm
C
astar
C++
sphinx3
C
xalancbmk
C++

File Size (KB)

before
172
8,380
53
351
1,182
5,594
4,292
3,383
814
276
106
1,225
37
195
541
48,538

after
549
9,148
429
737
1,564
6,010
4,745
3,896
1,210
662
483
1,646
411
574
931
51,010

# of instructions
inserted
total
15,370
13
9,264
606,925
2,277
95
24,024
71
77,434
45
156,829
201
264
74,314
194,821
941
60,832
94
22,836
17
7,301
21
154
115,575
2,341
9
8,220
54
34,476
170
7,364
645,434

# of objects
peak
total
2
7
165k
3k
1
2
33
38
953
964
47
12k
1k
88
9k
15k
28
84k
1
1
2
49
9k
7k
1
2
5k
130k
703
6k
28k
4k

# of pointers
peak
total
0
0
3167k
178k
0
0
0
0
0
0
0
0
14k
172
26k
7923k
0
0
0
0
0
0
906
111
0
0
148
2k
14k
814k
256k
18k

# Nullify Memory (MB)
after
34
397
570
2,500
114
28
14
81
18
171
2
208
409
135
62
76

before
34
316
569
2,496
44
23
7
38
1
171
0
44
408
13
46
7

0
104k
0
0
0
0
140
6k
0
0
0
101
0
20
0
10k

incr.
378
768
376
386
382
416
453
513
396
386
378
420
374
378
389
2472

Table V: Details of instrumented binaries (the left half) and their runtime properties (the right half) in SPEC CPU2006. The
left half describes the details of incremented file size due to newly inserted instrumentation instructions. The runtime library of
DANGNULL is about 370 KB; DANGNULL requires approximately 40 B per instrumentation to trace pointer propagation. The
right half represents the details of the programs’ runtime behavior (e.g., increase of memory usage and the number of pointers
and objects in each benchmark). The increase of memory (due to shadowObjTree) depends on the number of objects and pointers
created and freed in total; bzip2, which has minimal memory allocation, imposed no extra memory overhead, while gcc, which
has many memory operations, imposes about 80 MB of extra memory overhead with DANGNULL.

Name

Chromium

File Size (MB)

before
1858

after
1868

incr.
10

# of instructions
total
inserted
140k
16,831k

Table VI: Static instrumentation results on Chromium

distribution or management of the instrumented binary.

C. Runtime Overheads

As DANGNULL must trace object relationships for nullifi-
cation, it increases both execution time and memory usage. To
determine how much runtime overhead DANGNULL imposes
on target applications, we measured various runtime overheads
of SPEC CPU2006 and the Chromium browser.

Figure 3 shows the runtime performance overheads of
DANGNULL running SPEC CPU2006 benchmarks. The over-

10

heads largely depend on the number of objects and pointers
that DANGNULL traced and stored in shadowObjTree. These
metadata tracing measurements are shown in the right half
of Table V. As we described in §V-B, each application has a
different number of object allocations and degree of pointer
propagation. Accordingly, each object allocation and pointer
propagation would insert extra metadata into shadowObjTree
unless it fails runtime range analysis. DANGNULL imposed an
average performance overhead of 80%. DANGNULL caused
more runtime overhead if the application had to trace a large
number of pointers. For example, in the povray case, a total
of 7,923,000 pointers were traced because it maintains a large
number of pointers to render image pixels, and thus increased
execution time by 270% with 213% memory overhead. On
the other hand, in h264ref, only 906 pointers were traced and
resulted in a 1% increase in execution time and 472% memory
overhead.

Benchmarks

(unit, [high or low])
Original
DANGNULL
Slowdown

Octane
(score, high)
13,874
13,431
3.2%

JavaScript
SunSpider Dromaeo JS
(ms, low)
(runs/s, high)
1,602.1
320.0
1,559.6
347.5
8.6%
2.7%

Rendering

Balls Dromaeo DOM Dromaeo JS Lib
(runs/s, high)
216.0
168.1
22.2%

(runs/s, high)
857.8
509.1
40.7%

(fps, high)
11.6
6.5
44.1%

html5
(sec, low)
10.1
20.7
105.3%

Table VII: Chromium Benchmark results with and without DANGNULL. High/low denotes whether performance was higher or
lower when compared to the unmodified test. For JavaScript benchmarks, DANGNULL imposes negligible overheads, varying
from 2.7-8.6%. For rendering benchmarks requiring lots of memory operations (e.g., allocating DOM elements), DANGNULL
exhibits 22.2%-105.3% overhead depending on type.

Page Complexity
# Req

# DOM Original

Website

Action

gmail.com
twitter.com
amazon.com
youtube.com
gmail.com
twitter.com

visit
visit
visit
visit
login
login

13
14
264
43
177
60

164
628
1893
2293
5040
3124

Loading Time (sec)
DANGNULL
0.60 (22.4%)
1.16 (10.5%)
1.60 (16.8%)
0.81 (32.8%)
7.66 (19.7%)
2.77 (28.2%)

0.49
1.05
1.37
0.61
6.40
2.16

# of objects
peak
total
123k
22k
23k
121k
25k
166k
23k
127k
31k
295k
172k
27k

# of pointers
peak
total
32k
12k
13k
35k
28k
81k
16k
46k
49k
165k
71k
23k

before

# Nullify Memory (MB)
after
171
178
200
178
301
276

7k
8k
16k
9k
32k
15k

46
48
57
49
96
98

Table VIII: Details of DANGNULL overhead when visiting four popular websites. The left half shows page complexities and
page load time. The right half shows detailed runtime properties.

•

exploits carefully developed for complex and large
scale software (e.g., Chromium).

Runtime use-after-free mitigation for end users: if
performance overhead is not the primary concern of
end users, DANGNULL is an effective use-after-free
mitigation tool with moderate performance overhead,
especially for web browsers.

• Use-after-free resilient programs: we have shown
that DANGNULL can utilize existing sanity check
routines and survive use-after-free attempts. By in-
tegrating automatic runtime repair work [25], we
believe DANGNULL can evolve to support use-after-
free resilient programs in the future.

Performance optimization. We believe DANGNULL’s
performance overhead can be further improved, especially for
performance critical applications. First of all, instrumentation
phases can be further optimized by leveraging more sophisti-
cated static analysis. For example, if it is certain that the original
code already nullifies a pointer, DANGNULL would not need
to nullify it again. Although we have not heavily explored this
direction, this has to be done carefully because soundly learning
this information involves pointer-aliasing problems, which are
well-known difficult problems in program analyses, and any
incorrect analysis results would lead to both false positives and
false negatives.

Moreover, we identified that manipulation of shadowObjTree
is the main performance bottleneck, and this can be optimized
by 1) leveraging transactional memory [20] to enhance locking
performance on shadowObjTree; 2) designing a software cache
for shadowObjTree; 3) using alternative data-structures to imple-
ment shadowObjTree (e.g., alignment-based metadata storage by
replacing the memory allocator [18]); or 4) creating a dedicated
analyzing thread or process for shadowObjTree [23].

False negatives. DANGNULL’s static instrumentation
assumes that a pointer is propagated only if either the left–
or right–hand side of a variable is a pointer type. This would
not be true if the program is written in a manner such that
the propagation is done between non-pointer-typed variables.
Consider the example we introduced in Example 1. If the child
member variable is typed as long (i.e., long child at line 4)
and all the following operations regarding child are using type
casting (i.e., doc->child=(long)body at line 13 and ((Elem*)doc-
>child)->getAlign() at line 21), then such a pointer propagation
would not be traced. DANGNULL would under-trace object
relationships in this case, and there would be false negatives if
child becomes an unsafe dangling pointer.

False positives. To stop dereferencing on unsafe dangling
pointers, DANGNULL nullifies not only unsafe dangling point-
ers but also benign dangling pointers. This implies DANGNULL
additionally nullifies benign dangling pointers, and it is possible
it may cause some false positives, although these should not
have any semantic meaning as they are “dangled”.

While testing DANGNULL for SPEC CPU benchmarks and
the Chromium browser, we found one rare false positive case.
This false positive case sporadically occurs when a new tab
is manually created inside the Chromium browser, and it is
related to the unique pointer hash table design (Example 4).
We believe this false positive example would not be a critical
concern for deploying DANGNULL due to its rareness. As we
described in the compatibility evaluation in §V-D, DANGNULL
passed more than 30,000 stress tests with the Chromium
browser, a large scale and highly complicated application.

VII. RELATED WORK

Memory-related issues, including invalid memory accesses,
memory leaks, and use-after-free bugs, have been studied for
many years. Numerous methods have been proposed for C/C++

12

1 enum child_status {IN_USE=0, DELETED=1};
2 hash_map <Element*, child_status, ptrHash> allChilds;
3
4 Document *doc = new Document();
5 Element *elem = new Element();
6
7 // hold child reference
8 doc->child = elem;
9
10 // mark it as in-use in the hash_map
11 allChilds[elem] = IN_USE;
12
13 // delete child, nullified accordingly
14 delete doc->child;
15
16 // doc->child is nullified,
17 //
18 allChilds[doc->child] = DELETED;
19
20 // makes sure all childs are deleted
21 for (it = allChilds.begin(); it != allChilds.end(); ++ it)
22
23

but Chromium relies on the stale pointer

if (it->second == IN_USE)

delete it->first;

Example 4: A simplified false positive example of DANGNULL
in the Chromium browser. This sporadically occurred when
the tab is manually created inside the browser. If applications
rely on the stale pointer (using the freed pointer as a concrete
value, as doc→child in line 18), DANGNULL can cause a false
positive. We fixed this issue for DANGNULL by switching the
order of deletion and marking operations (switching line 14
and line 18).

programs. In this section, we categorize them and compare
them with DANGNULL.

Use-after-free detectors. There is a line of research
specifically focusing on detecting use-after-free vulnerabilities.
In general, use-after-free vulnerabilities can be detected through
both static and dynamic analysis. However, since 1) a dangling
pointer itself is not erroneous behavior and 2) statically
determining whether a dangling pointer will actually be used in
the future requires precise points-to and reachability analyses
across all possible inter-procedure paths, even state-of-the-art
use-after-free detection tools based on the static analysis are
only suitable for analyzing small programs [13, 34].

For this reason, most use-after-free detectors [6, 30, 48] are
based on the runtime dynamic analysis. CETS [30] maintains a
unique identifier with each allocated object, associates this
metadata with pointers, and checks that the object is still
allocated on pointer dereferences. To handle pointer arithmetic,
CETS uses taint propagation (i.e., the resulting pointer will
inherit the metadata from the base pointer of the corresponding
arithmetic operation). Unfortunately, the assumption behind
this design choice —the propagated pointer should point to
the same object—does not always hold, which results in high
false positive rates. From our experiments, CETS raised false
alarms on 5 out of 16 tested programs while DANGNULL was
able to correctly run all 16 programs. In addition to high false
positive rates, CETS relies on explicit checks to guarantee
the memory access validity for all memory operations, thus
imposing higher performance overhead in SPEC CPU2006
compared to DANGNULL. For 4 programs (bzip2, milc, sjeng,
h264ref, and lbm) that CETS was able to run7, on average it
incurred 40% slow down, while DANGNULL incurred 1% slow

7CETS failed to compile 7 programs out of 16 SPEC CPU2006 programs

we tested.

13

down.

Undangle [6] is another runtime dynamic analysis tool to
detect use-after-free. It assigns each return value of memory
allocation functions a unique label, and employs a dynamic
taint analysis to track the propagation of these labels. On
memory deallocation, Undangle checks which memory slots
are still associated with the corresponding label, and then
determines the unsafe dangling pointers based on the lifetime
of dangling pointers (i.e., if the lifetime of a dangling pointer is
higher than the certain threshold number, it is identified as an
unsafe dangling pointer). While this approach can collect more
complete pointer propagation information than DANGNULL
(which would better help a bug triage or debugging process),
a significant performance cost is required.

Control flow integrity. Control flow integrity (CFI) [1, 49–
51] enforces indirect function calls to be legitimate (i.e., enforc-
ing integrity of the control-flows). Similarly, SafeDispatch [22]
prevents illegal control flows from virtual function call sites. Un-
like use-after-free and memory error detectors, CFI makes use-
after-free vulnerabilities difficult to exploit. Specifically, CFI
only shepherds function pointers to guarantee legitimate control
flows. In practice, however, most CFI implementations enforce
coarse-grained CFI to avoid heavy performance overheads
and false positive alarms, but recent research [7, 11, 15, 16]
has demonstrated that all the aforementioned coarse-grained
CFI implementations can be bypassed. Moreover, dangling
pointers can also be abused to corrupt non-control data (e.g.,
vector length variables, user privilege bits, or sandbox enforcing
flags) in objects [8], all of which are not function pointers,
which makes CFI based protection techniques bypassable. For
example, a recent attack [27] overwrote user permission bits in
the metadata to bypass user authorizations, including all other
defense mechanisms. As an another example, vector length
variable corruption is one popular technique to exploit use-after-
free vulnerabilities that lead to information leakage attacks or
additional heap buffer overflows.

DANGNULL eliminates dangling pointers at the moment
they are created. Thus, it can protect not only control flows but
also any other security sensitive metadata in the objects from
being abused by use-after-free or double-free vulnerabilities.
Memory error detectors. Memcheck (Valgrind) [32] and
Purify [19] are popular solutions for detecting memory errors.
Since their main goal is to help debugging, they are designed
to be complete (incurring no false negatives) and general
(detecting all classes of memory problems) in identifying
memory-leak vulnerabilities, imposing very high memory and
CPU overheads.

AddressSanitizer [38] is another popular tool developed
recently that optimizes the method of representing and probing
the status of allocated memory. However, due to an assumption
to support this optimization (a quarantine zone that prevents
reuse of previously freed memory blocks), it cannot detect
use-after-free bugs if the assumption does not hold (i.e.,
heap objects are reallocated). Specifically, attackers can easily
leverage various techniques to force reallocation of previously
freed memory blocks, such as Heap Spraying [10, 36] and
Heap Fengshui [39]. To clearly demonstrate this issue, we
developed a proof-of-concept exploit bypassing the detection of
AddressSanitizer (Example 5). However, with DANGNULL, all

drainBuffer = null;

gc();

}

// allocate/fill up the landing zone
var landBuffer = new Uint32Array(44);
for (var j = 0; j < 44; j ++)

landBuffer[j] = 0x1234;

// trigger use-after-free
buf.timestampOffset = 100000;

buf = ms.addSourceBuffer(...);
// disconnect the target obj
vid.parentNode.removeChild(vid);
vid = null;
// free the target obj
gc();

1 function onOpened() {
2
3
4
5
6
7
8
9 + var drainBuffer = new Uint32Array(1024*1024*512);
10 +
11 + // drain the quarantine zone
12 +
13
14 + for (var i = 0; i < 500; i ++) {
15 +
16 +
17 +
18 +
19 +
20
21
22
23 }
24
25 ms = new WebKitMediaSource();
26 ms.addEventListener(’webkitsourceopen’, onOpened);
27
28 // NOTE.
29 //
30 vid = document.getElementById(’vid’);
31 vid.src = window.URL.createObjectURL(ms);
Example 5: An example of exploits (Bug ID 162835) bypassing
AddressSanitizer [38]. Lines with + marks show the bypassing
routine, which keeps allocating the same sized memory to drain
the quarantine zone of AddressSanitizer. Once the quarantine
zone is drained, AddressSanitizer returns the previously freed
memory block (i.e., an object is allocated in the previously
freed memory region), which means it cannot identify memory
semantic mismatches introduced by unsafe dangling pointers.
Thus, AddressSanitizer cannot detect use-after-free exploits
in this case, and this technique can be generalized to other
use-after-free exploits with a different allocation size. However,
DANGNULL detected this sophisticated exploit.

<video id="vid"></video>

dangling pointers will be nullified upon the deallocation of their
objects, rendering use-after-free vulnerabilities unexploitable,
even with sophisticated manipulations.

Safe memory allocators. Many safe memory allocators
have been proposed to prevent dangling pointer issues. Cling [2]
can disrupt a large class of exploits targeting use-after-free
vulnerabilities by restricting memory reuse to objects of the
same type. Diehard and Dieharder [4, 33] mitigate dangling
pointer issues by approximating an infinite-sized heap.

Smart pointers. A smart pointer is an abstract data
type that encapsulates a pointer to support automatic resource
management. Theoretically, an application would not suffer
from use-after-free issues if all the pointers are represented with
smart pointers (i.e., no raw pointers are used in the application
code). However, it is common to expose raw pointers even in
applications heavily using smart pointers. For example, in order
to break the resource graph cycle connected with shared pointers
(e.g., std::shared_ptr in C++11), browser rendering engines
including WebKit [45] and Blink [5] usually expose a raw
pointer instead of using weak pointers (e.g., std::weak_ptr in
C++11) to avoid extra performance overheads and be compatible
with legacy code [26], and these exposed raw pointers have
been major use-after-free vulnerability sources for those engines.

14

Note that automatically wrapping raw pointers with smart
pointers is another challenging static analysis problem, as this
requires understanding precise raw pointer semantics to be
properly implemented.

VIII. CONCLUSIONS

In this paper, we presented DANGNULL, a system that
detects temporal memory safety violations in runtime. We
implemented DANGNULL, applied it to Chromium, and con-
ducted a thorough evaluation showing the effectiveness and
compatibility of DANGNULL. In particular, we demonstrated
that DANGNULL can be applied to complex,
large-scale
software, such as the Chromium browser, to effectively mitigate
use-after-free exploits with even the most sophisticated attack
techniques. We believe DANGNULL can be used for a range of
security applications: back-end use-after-free detection, runtime
use-after-free mitigation, or use-after-free resilient programs.

ACKNOWLEDGMENTS

The authors would like to thank the anonymous reviewers
and our shepherd, Juan Caballero, for their help and feedback,
as well as our operations staff for their proofreading efforts.
This material is based upon work supported in part by the
National Science Foundation under Grants No. CNS-1017265,
CNS-0831300, and CNS-1149051, by the Office of Naval
Research under Grant No. N000140911042, by the Department
of Homeland Security under contract No. N66001-12-C-0133,
and by the United States Air Force under Contract No.
FA8650-10-C-7025. Any opinions, findings, and conclusions
or recommendations expressed in this material are those of
the authors and do not necessarily reflect the views of the
National Science Foundation, the Office of Naval Research, the
Department of Homeland Security, or the United States Air
Force.

REFERENCES

[1] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti, “Control-flow
integrity,” in ACM Conference on Computer and Communications
Security (CCS), 2005.

[2] P. Akritidis, “Cling: A Memory Allocator to Mitigate Dangling

Pointers,” in USENIX Security Symposium (Security), 2010.

[3] Alexa, “The Top 500 Sites on the Web,” http://www.alexa.com/

topsites, Aug 2014.

[4] E. D. Berger and B. G. Zorn, “DieHard: Probabilistic Memory
Safety for Unsafe Languages,” in ACM SIGPLAN Conference
on Programming Language Design and Implementation (PLDI),
2006.

[5] Blink : the rendering engine used by Chromium, http://www.

chromium.org/blink, Aug 2014.

[6] J. Caballero, G. Grieco, M. Marron, and A. Nappa, “Undangle:
Early Detection of Dangling Pointers in Use-after-free and
Double-free Vulnerabilities,” in International Symposium on
Software Testing and Analysis (ISSTA), 2012.

[7] N. Carlini and D. Wagner, “ROP is still dangerous: Breaking
modern defenses,” in USENIX Security Symposium (Security),
2014.

[8] S. Chen, J. Xu, E. C. Sezer, P. Gauriar, and R. K. Iyer, “Non-
control-data Attacks Are Realistic Threats,” in USENIX Security
Symposium (Security), 2005.

[9] Chromium Projects, “Running Tests at Home,” http://www.

chromium.org/developers/testing/running-tests, Aug 2014.

[10] M. Daniel, J. Honoroff, and C. Miller, “Engineering Heap
Overflow Exploits with JavaScript,” in USENIX Workshop on
Offensive Technologies (WOOT), 2008.

[11] L. Davi, D. Lehmann, A.-R. Sadeghi, and F. Monrose, “Stitching
the Gadgets: On the Ineffectiveness of Coarse-Grained Control-
Flow Integrity Protection,” in USENIX Security Symposium
(Security), 2014.

[12] D. Dhurjati and V. Adve, “Efficiently Detecting All Dangling
Pointer Uses in Production Servers,” in International Conference
on Dependable Systems and Networks (DSN), 2006.

[13] J. Feist, L. Mounier, and M.-L. Potet, “Statically detecting use
after free on binary code,” Journal of Computer Virology and
Hacking Techniques, 2013.

[14] Flak, “Analysis of OpenSSL Freelist Reuse,” http://www.
tedunangst.com/flak/post/analysis-of-openssl-freelist-reuse, Aug
2014.

[15] E. Göktas, E. Athanasopoulos, H. Bos, and G. Portokalidis,
“Out of control: Overcoming Control-Flow Integrity,” in IEEE
Symposium on Security and Privacy (Oakland), 2014.

[16] E. Gökta¸s, E. Athanasopoulos, M. Polychronakis, H. Bos, and
G. Portokalidis, “Size does matter: Why using gadget-chain
length to prevent code-reuse attacks is hard,” in USENIX Security
Symposium (Security), 2014.

[17] Google, “Octane Benchmark,” https://code.google.com/p/octane-

benchmark, Aug 2014.

[18] Google, “Specialized memory allocator for ThreadSanitizer,
http://llvm.org/klaus/compiler-

MemorySanitizer,
rt/blob/7385f8b8b8723064910cf9737dc929e90aeac548/lib/
sanitizer_common/sanitizer_allocator.h, Nov 2014.

etc.”

[19] R. Hastings and B. Joyce, “Purify: Fast detection of memory
leaks and access errors,” in Winter 1992 USENIX Conference,
1991.

[20] M. Herlihy and J. E. B. Moss, Transactional memory: Architec-
tural support for lock-free data structures. ACM, 1993, vol. 21,
no. 2.

[21] HP, “Pwn2Own 2014: A recap,” http://www.pwn2own.com/2014/

03/pwn2own-2014-recap, Aug 2014.

[22] D. Jang, Z. Tatlock, and S. Lerner, “SafeDispatch: Securing C++
Virtual Calls from Memory Corruption Attacks,” in Network and
Distributed System Security Symposium (NDSS), 2014.

[23] K. Jee, V. P. Kemerlis, A. D. Keromytis, and G. Portokalidis,
“ShadowReplica: efficient parallelization of dynamic data flow
tracking,” in ACM Conference on Computer and Communications
Security (CCS), 2013.

[24] LLVM Project, “LLVM Language Reference Manual,” http://

llvm.org/docs/LangRef.html.

[25] F. Long, S. Sidiroglou-Douskos, and M. Rinard, “Automatic
Runtime Error Repair and Containment via Recovery Shepherd-
ing,” in ACM SIGPLAN Conference on Programming Language
Design and Implementation (PLDI), 2012.

[26] Mads Ager, Erik Corry, Vyachslav Egorov, Kentaro Hara, Gustav
Wibling, Ian Zerny, “Oilpan: Tracing Garbage Collection for
Blink,” http://www.chromium.org/blink/blink-gc, Aug 2014.

[27] Mallocat,

“Subverting without EIP,” http://mallocat.com/

subverting-without-eip, Aug 2014.

[28] Mozilla, “DROMAEO, JavaScript Performance Testing,” http:

//dromaeo.com, Aug 2014.

[29] S. Nagaraju, C. Craioveanu, E. Florio, and M. Miller, “Software

Vulnerability Exploitation Trends,” Microsoft, 2013.

15

[30] S. Nagarakatte, J. Zhao, M. M. K. Martin, and S. Zdancewic,
“CETS: Compiler Enforced Temporal Safety for C,” in Interna-
tional Symposium on Memory Management (ISMM), 2010.

[31] S. Nagarakatte, J. Zhao, M. M. Martin, and S. Zdancewic,
“SoftBound: Highly Compatible and Complete Spatial Memory
Safety for C,” in ACM SIGPLAN Conference on Programming
Language Design and Implementation (PLDI), 2009.

[32] N. Nethercote and J. Seward, “Valgrind: A Framework for
Heavyweight Dynamic Binary Instrumentation,” in ACM SIG-
PLAN Conference on Programming Language Design and
Implementation (PLDI), 2007, pp. 89–100.

[33] G. Novark and E. D. Berger, “DieHarder: Securing the Heap,”
in ACM Conference on Computer and Communications Security
(CCS), 2010.

[34] H. Post and W. Küchlin, “Integrated static analysis for linux de-
vice driver verification,” in Integrated Formal Methods. Springer,
2007, pp. 518–537.

[35] M. Prandini and M. Ramilli, “Return-oriented programming,”

IEEE Security & Privacy, 2012.

[36] P. Ratanaworabhan, B. Livshits, and B. Zorn, “NOZZLE: A
Defense Against Heap-spraying Code Injection Attacks,” in
USENIX Security Symposium (Security), 2009.

[37] R. Seacord, Secure Coding in C and C++, 1st ed. Addison-

Wesley Professional, 2005.

[38] K. Serebryany, D. Bruening, A. Potapenko, and D. Vyukov,
“AddressSanitizer: A Fast Address Sanity Checker,” in USENIX
Conference on Annual Technical Conference (ATC), 2012.

[39] A. Sotirov, “Heap Feng Shui in JavaScript,” Black Hat Europe,

2007.

[40] Standard Performance Evaluation Corporation, “SPEC CPU

2006,” http://www.spec.org/cpu2006, Aug 2014.

[41] The Chromium Project, http://www.chromium.org/Home, Aug

2014.

[42] The Chromium Projects, “Chromium Issues,” https://code.google.

com/p/chromium/issues, Aug 2014.

[43] The LLVM Compiler Infrastructure, http://llvm.org, Aug 2014.
[44] The Web Standards Project, “Acid Tests,” http://www.acidtests.

org/, Aug 2014.

[45] The WebKit Open Source Project, http://www.webkit.org, Aug

2014.

[46] Ubuntu, “0-address protection in Ubuntu,” https://wiki.ubuntu.

com/Security/Features#null-mmap, Aug 2014.

[47] WebKit, “SunSpider 1.0.2 JavaScript Benchmark,” https://www.

webkit.org/perf/sunspider/sunspider.html, Aug 2014.

[48] W. Xu, D. C. DuVarney, and R. Sekar, “An efficient and
backwards-compatible transformation to ensure memory safety
of C programs,” in ACM SIGSOFT International Symposium on
Foundations of Software Engineering (FSE), 2004.

[49] B. Zeng, G. Tan, and G. Morrisett, “Combining Control-flow
Integrity and Static Analysis for Efficient and Validated Data
Sandboxing,” in ACM Conference on Computer and Communi-
cations Security (CCS), 2011.

[50] C. Zhang, T. Wei, Z. Chen, L. Duan, L. Szekeres, S. McCamant,
D. Song, and W. Zou, “Practical Control Flow Integrity and
Randomization for Binary Executables,” in IEEE Symposium on
Security and Privacy (Oakland), 2013.

[51] M. Zhang and R. Sekar, “Control Flow Integrity for COTS

Binaries,” in USENIX Security Symposium (Security), 2013.

