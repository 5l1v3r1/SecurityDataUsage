On the Provable Security of (EC)DSA Signatures

Manuel Fersch

manuel.fersch@rub.de

Eike Kiltz

eike.kiltz@rub.de

Bertram Poettering

bertram.poettering@rub.de

Horst Görtz Institute for IT Security
Ruhr University Bochum, Germany

ABSTRACT
Among the signature schemes most widely deployed in prac-
tice are the DSA (Digital Signature Algorithm) and its ellip-
tic curves variant ECDSA. They are represented in many in-
ternational standards, including IEEE P1363, ANSI X9.62,
and FIPS 186-4. Their popularity stands in stark contrast
to the absence of rigorous security analyses: Previous works
either study modiﬁed versions of (EC)DSA or provide a se-
curity analysis of unmodiﬁed ECDSA in the generic group
model. Unfortunately, works following the latter approach
assume abstractions of non-algebraic functions over generic
groups for which it remains unclear how they translate to
the security of ECDSA in practice. For instance, it has been
pointed out that prior results in the generic group model ac-
tually establish strong unforgeability of ECDSA, a property
that the scheme de facto does not possess. As, further, no
formal results are known for DSA, understanding the secu-
rity of both schemes remains an open problem.

In this work we propose GenDSA, a signature framework
that subsumes both DSA and ECDSA in unmodiﬁed form.
It carefully models the “modulo q” conversion function of
(EC)DSA as a composition of three independent functions.
The two outer functions mimic algebraic properties in the
function’s domain and range, the inner one is modeled as a
bijective random oracle. We rigorously prove results on the
security of GenDSA that indicate that forging signatures in
(EC)DSA is as hard as solving discrete logarithms. Impor-
tantly, our proofs do not assume generic group behavior.

Keywords
Provable security; DSA; ECDSA; GOST; SM2

1.

INTRODUCTION

Digital signatures.

With the main application of message and entity authenti-
cation, digital signature schemes are an omnipresent crypto-

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’16, October 24 - 28, 2016, Vienna, Austria
c(cid:13) 2016 Copyright held by the owner/author(s). Publication rights licensed to ACM.
ISBN 978-1-4503-4139-4/16/10. . . $15.00
DOI: http://dx.doi.org/10.1145/2976749.2978413

graphic primitive in today’s security landscape. The speciﬁc
schemes deployed most often are the RSA-FDH variant from
PKCS#1v1.5, and the DLP-based DSA and ECDSA. For in-
stance, current versions of TLS authenticate servers exclu-
sively on basis of these schemes. Unfortunately, up to now,
for none of the schemes a rigorous security analysis is known
that would formally establish that the goal of unforgeabil-
ity is reached (partial results are known, the ones concern-
ing DSA and ECDSA are discussed below). Put diﬀerently,
currently it is only the (believed) absence of cryptanalytic
attacks that indicates the security of the three schemes in
practice. By providing new results on DSA and ECDSA this
paper aims at relaxing this clearly unsatisfactory situation.

The Fiat-Shamir transform and the forking lemma.

A classic strategy to construct digital signatures is through
the Fiat-Shamir heuristic. A standard example is the scheme
by Schnorr which is deﬁned in the discrete logarithm (DLP)
in a group G of prime order q, signing keys x co-
setting:
incide with exponents, veriﬁcation keys X = gx are group
elements, and a signature on a message m consists of the
components c = H(gr, m) and s = r + cx (mod q). Here,
exponent r is freshly picked per signing operation and H is
a hash function that maps into the exponent space. Veriﬁ-
cation works by recovering gr = gs/X c and checking that
c = H(gr, m).

Schnorr signatures are unforgeable if the DLP is hard [20].
The proof crucially relies on modeling H as a programmable
random oracle and involves a rewinding technique for ex-
tracting the signing key from any successful forger by solv-
ing a system of linear equations. The standard vehicle to
assess the extraction probability is the forking lemma [20].

DSA and ECDSA.

The signature scheme DSA and its close relative ECDSA
build on ideas of ElGamal and are deﬁned, like the Schnorr
scheme, in the DLP setting. However, they do not result
from the Fiat-Shamir heuristic.
Indeed, both DSA and
ECDSA require two independent hash functions, H and f ,
that map messages, respectively, group elements into the ex-
ponent space Zq. Function f is also known as the conversion
function. In a nutshell, if x is a signing key and X = gx the
corresponding veriﬁcation key, a signature on a message m
is a pair σ = (s, t) satisfying t = f (gr) for

r = (H(m) + xt)/s .

(1)

Signatures are veriﬁed by recovering gr = (gH(m)X t)1/s and
checking that f (gr) = t. While standards recommend us-

1651ing (truncated versions of) the hash functions of the SHA
family to instantiate H, ad-hoc constructions speciﬁc to the
discrete logarithm group are used for the conversion func-
tion f . Concretely, for DSA, which is deﬁned in a prime-
order subgroup of the multiplicative group of some prime
ﬁeld GF(p) and uses the canonic representation of group el-
ements as integers in [1 . . . p − 1], function f is deﬁned per
A (cid:55)→ (A mod p) mod q. In contrast, ECDSA is deﬁned on
elliptic curves over some ﬁnite ﬁeld F = GF(pn) and thus
group elements coincide with points (x, y) ∈ F × F; here,
mapping A (cid:55)→ A.x mod q is used to instantiate f , where A.x
denotes an encoding of the x-part of A as an integer. As the
quantities p and q in the DSA case, and the integer represen-
tation of a GF(pn) element and q in the ECDSA case, are
rather loosely related, the operations A mod p mod q and
A.x mod q do not make much sense from an algebraic point
of view. Indeed, as our studies suggest, likely the design-
ers of DSA and ECDSA aimed at exploiting speciﬁcally the
disruptive nature of these functions to achieve security for
their schemes.

Note that, although DSA and ECDSA evidently share
similarities with the construction of Schnorr, it is not clear at
all how to establish their security using the rewinding tech-
nique of the forking lemma.
Indeed, modeling hash func-
tion H as a random oracle and rewinding the adversary to
its m-queries does not seem to allow for the extraction of
the signing key: If the forger chooses a fresh ephemeral ex-
ponent for each forgery, in the corresponding equation sys-
tem to solve, the number of unknowns always dominates
the number of collected equations. Further, modeling f as
a random oracle seems prohibitive: For instance, in the case
of ECDSA, the result of applying f to a random element
in G is not uniformly distributed in Zq;1 even more prob-
lematic, ﬁnding preimages of the conversion function turns
out to be an easy task.2 As these are properties that a
random oracle does not possess, modeling the conversion
function as an ideal random function leads to questionable
overall results. Put diﬀerently, a formal result on the secu-
rity of DSA/ECDSA that is achieved by replacing f with
a random oracle says little about security in practice.3 De-
spite the described obstacles, partial results on the security
of DSA and ECDSA were established in prior work, as we
discuss next.

Prior analyses of DSA and ECDSA.

Brickell et al. [2] developed an extended version of the
forking lemma [20] and used it to study variants of DSA
signatures. In more detail, they deﬁned a general class of
signature schemes called Trusted El Gamal Type Signature
Scheme, and proved all signatures of this type unforgeable
in the random oracle model. Special cases of this framework
include the scheme DSA-I (reportedly due to Brickell, 1996)
in which the conversion function f is replaced by a random
oracle, and the scheme DSA-II which is like DSA but with

1On elliptic curves, for only about every second x-value a
corresponding curve point exists; this is responsible for a
huge bias of the ‘x mod q’ function.
2For DSA this is likely not the case: Inverting its conversion
function is conjectured hard in [4].
3Technically speaking, any proof in the random oracle model
has at most heuristic quality. However, modeling the conver-
sion functions of DSA and particularly ECDSA as a random
oracle goes far beyond the standard complications.

constraint (1) changed to r = (H(m, t) + xt)/s, i.e., hash
function H is applied to both the message and the ephemeral
value f (gr) (this idea ﬁrst appeared in [21]). Importantly,
their results do not apply to unmodiﬁed DSA signatures (nor
to ECDSA which the authors do not explicitly mention).
In a similar line of work, Malone-Lee and Smart [14] pro-
posed the variants ECDSA-II and ECDSA-III of the ECDSA
scheme. Here, with the motivation of strengthening ECDSA
against certain anomalies like duplicate signatures (one sig-
nature is valid for two messages [24]) and improving the
tightness of security reductions, the authors deliberately de-
viated from the original ECDSA speciﬁcation. Concluding,
all positive results from [21, 2, 14] apply only to modiﬁed
versions of DSA/ECDSA and thus say little about the sig-
natures as deployed in reality.

Basically all known positive results on unmodiﬁed ECDSA
In [5, 3] he models the discrete loga-
are due to Brown.
rithm setting of ECDSA with a generic group [22]. While
it appears at ﬁrst that only standard model properties are
required of functions H and f , as we explain below it seems
that Brown’s generic modeling approach for the group im-
plicitly also idealizes the conversion function f . Unfortu-
nately, crucial formal aspects of his idealization remain un-
clear, and thus also the impact of the results on the practical
security of ECDSA (and DSA).

The fact that Brown builds on idealized properties of
both G (explicitly) and f (implicitly) indeed causes alarming
side-eﬀects of practical relevance to emerge. The following
issue was noticed by Stern et al. [24]. Studying Brown’s
proof step-by-step reveals that he actually establishes that
ECDSA signatures are strongly unforgeable (i.e., the adver-
sary cannot forge a fresh signature on a message for which
it already knows a signature), in contrast to the fact that
it is actually trivial to attack ECDSA in this way.4 Brown
comments on this contradiction in [5, p. 9], saying “that
the [generic group] paradigm cannot be stretched to ridicu-
lous lengths” and that any eﬀort to adapt his version of the
generic group model to reﬂect the malleability of signatures
would likely “not exclude other properties [ . . . ] being con-
trived that ECDSA does not actually possess but would if
modeled by a generic group”. Besides the fact that aspects
of strong unforgeability actually do play a crucial role in
real-life applications like Bitcoin5 and one should thus be
careful with considering them contrived, Brown does not in-
dicate why his results on (plain) unforgeability do not follow
from “over-stretching” the generic group model. Thus, the
overall question remains open: From a security proof that
assumes generic groups behavior, how much can actually
be concluded about the real-world security of the scheme?
Arguably, a satisfactory argument for the unforgeability of
ECDSA was not given in [3]. Further, interestingly, Brown’s
results apply to ECDSA only and apparently cannot be
lifted to DSA as the conversion function of the latter seems
not to be ‘almost-invertible’ (as conjectured in [6]). Inde-
pendently of the ﬁndings discussed above, in [6, 4, 3] Brown
identiﬁes joint conditions on H, f ; some of them are suﬃ-
cient for the security of ECDSA (but considerably stronger
than DLP), others necessary.

4If (s, t) is a signature on m, then so is (−s, t). This property
ultimately has to do with the conversion function ignoring
the y-component of its input.
5See https://en.bitcoin.it/wiki/Transaction Malleability

1652Further results on the security of DSA and ECDSA are
by Vaudenay [25, 26], Howgrave-Graham and Smart [9],
Nguyen and Shparlinski [18], and Leadbitter et al. [13]. Some
of these papers either identify or survey conditions that are
necessary for the schemes’ security, others focus on the ro-
bustness of DSA/ECDSA against ﬂaws in implementations
and parameter selection.

Proofs in the Generic Group Model.

One can generally question the value of proofs in the
generic group model for assessing the security of systems
in reality. Reasons include that the model is non-falsiﬁable,
and that certain problems exist that are provably hard in
the generic group model yet easy to solve in real-life groups
[7]. An independent issue stems from the fact that, while
Shoup’s generic group model was originally proposed [22] as
a tool to study the hardness of purely algebraic problems
such as the discrete logarithm problem, the conversion func-
tion of ECDSA is a non-algebraic component in the sense
that it maps group elements to bit-strings without following
the operations induced by the group laws. For any corre-
sponding proof framework that replaces group operations
by generic versions, it needs to be deﬁned what it means to
apply a standard model function to a (generic) group ele-
ment. While in generic group models that represent group
elements with handles (e.g., the one by Maurer [16]) such
an operation has to be speciﬁed explicitly via oracles, for
models that use encodings (e.g., [23, 5, 17, 12]), even if
applying functions to corresponding random values might
be syntactically well-deﬁned, a closer inspection shows that
a corresponding proof implicitly would treat non-algebraic
components as ideal objects. Concretely, our understanding
is that Brown’s analyses of ECDSA implicitly model the con-
version function f as some idealized random object, and that
it thus remains unclear which conclusions on the practical
security of ECDSA can be drawn from his results. While a
reassessment of ECDSA’s security in a generic group model
with handles might potentially conﬁrm positive results, we
are not aware of any such work.6 The general issues with
generic group proofs involving non-algebraic functions are
further discussed in Appendix A.
1.1 Our Results

Modeling the conversion function.

We propose GenDSA, an abstract signature framework
that subsumes both DSA and ECDSA in unmodiﬁed form.
The scheme is deﬁned relative to a group G of prime or-
der q, a hash function H, and a conversion function f , and
uses a signing procedure compatible with (1). As our main
technical contribution, by suitably modeling function f we
prove that forging corresponding signatures is as hard as
computing discrete logarithms. More precisely, in contrast
to idealizing both the group (explicitly) and the conversion
function (implicitly, see discussion above), we require generic
behaviour exclusively for an inner building block of the con-
version function.

Recall that the conversion functions of DSA and ECDSA
map group elements in G to ﬁeld elements in Zq without
preserving a visible algebraic structure (the only direct con-
6Switching from Brown’s model to handle-based generic
groups is challenging: the crucial part is ﬁnding a suitable
model for the conversion function.

nection between domain and range seems to be the fact
|G| = |Zq|, but as practical instantiations of f are not bijec-
tive, |f (G)| < |Zq|). Our intuition is that this transforma-
tion is at the heart of the schemes’ security. Our approach
is to model the algebraically disruptive behaviour of f simi-
larly as one models the disordered behavior of cryptographic
hash functions with random oracles, but conscientiously tak-
ing care that the relevant real-world properties of practical
conversion functions are accounted for (e.g., if applicable,
their invertibility). More concretely, we decompose conver-
sion function f into three independent functions as per

f = ψ ◦ Π ◦ ϕ

(conversion function) ,

(2)

where we require Π to be a bijection. The idea is to reﬂect
in ϕ the structure of f that involves only its domain and to
reﬂect in ψ the structure that involves only its range; the
component that is responsible for disrupting any algebraic
link between the domain and the range is modeled by Π. In
security proofs we will replace Π by a bijective random oracle
(an idealized public bijection that is accessible, in both di-
rections, via oracles; cryptographic constructions that build
on such objects include the Even-Mansour cipher and the
SHA3 hash function) while assuming standard model prop-
erties for G, H, ϕ, and ψ. We show that DSA and ECDSA
can naturally be obtained, together with the speciﬁc pe-
culiarities of their conversion functions, by correspondingly
instantiating ϕ and ψ. For instance, in the case of ECDSA,
function ϕ is such that any two elliptic curve points with the
same x-component will be mapped to the same element, and
function ψ is the “modulo q function” that implements the
characteristic bias of the range of f . Note that our choices
of ϕ and ψ are invertible, so that also the composed f is.

The assumption that the concrete functions Π found in
(EC)DSA behave like a bijective random oracle may seem
quite strong. Indeed, at a bit-level it certainly does not hold:
For the Π functions of DSA and ECDSA it is feasible to ﬁnd
inputs x such that x and Π(x) are related in some mean-
ingful way. Recall however that the algebraic semantics of
the domain and range of Π are crucially diﬀerent (Π per-
forms the context switch from group G to ﬁeld Zq). That
is, even if speciﬁc bit patterns travel through Π in unmodi-
ﬁed form, what changes is what these patterns mean. Thus,
when assessing the applicability of the bijective random or-
acle paradigm for Π this should be done in conjunction with
a close study of its environment, i.e., functions ϕ and ψ
and their respective domains and co-domains. In particu-
lar for the settings of DSA and ECDSA we believe that our
positive results obtained by idealizing Π serve as a strong
indication for the practical security of the schemes. An al-
ternative, more conservative interpretation of our ﬁndings
would be that they give cryptanalysis a clear direction of
persue: If, despite our theorems, DSA and ECDSA turn out
to be insecure, then the problem is deﬁnitely the interplay of
the binary representations of elements of G and Zq. Let us
ﬁnally point out that a bijective random oracle component
implicitly also appears in Brown’s analyses (see Appendix A
for details).

Proving the security of GenDSA.

Consider GenDSA with conversion function f = ψ ◦ Π ◦ ϕ
from (2) and assume Π is a bijective random oracle. We
prove the existential unforgeability of GenDSA in a mod-
ular way. First, in Section 4.1, we show that the notions

1653of existential unforgeability and key-only unforgeability (no
signing oracle available) are equivalent for GenDSA, assum-
ing H is collision resistant and ϕ is semi-injective.7 Next, in
Section 4.2, using the forking lemma for Π we show that the
hardness of DLP implies key-only unforgeability of GenDSA,
assuming again semi-injectiveness for ϕ, and ψ-relative di-
vision resistance for H (a non-standard yet standard model
security property related to ψ, cf. Deﬁnition 5). The latter
property in particular holds if H is modeled as a random or-
acle; further, for the speciﬁc functions ψ used to instantiate
DSA and ECDSA it is implied by plausible standard-model
assumptions on H. As a corollary, the named results im-
ply the existential unforgeability of DSA and ECDSA. We
note that our reductions are not tight but lose a factor of
about Q (the number of bijective random oracle queries)
and square the success probabilities. This is standard for
forking lemma based analyses and correspondingly holds for
most other DLP-based signatures, e.g., Schnorr.

Extension of our results in the full version.

Recall that the results of Brown [5, 3] can be stretched to
imply the strong unforgeability of ECDSA, a property that
does not hold in practice. We highlight that our arguments
immediately fail when trying to stretch them in a similar
way (we understand this as supporting our approach). In
fact, by pin-pointing where exactly the corresponding proof
attempt fails, as a side result we are able to characterize the
strong unforgeability conditions of ECDSA and can conﬁrm,
for the ﬁrst time on formal grounds, the common conjecture
that the malleability mentioned in Footnote 4 is the only
one of ECDSA. In contrast to ECDSA, for DSA we establish
strong unforgeability.

In the full version we further propose a more general
scheme called GenericElGamal that also covers the standard-
ized signature schemes SM2 [10], GOST [8], and ECGOST [8].
We show that our proof techniques apply also there and es-
tablish corresponding unforgeability results. To the best of
our knowledge there is no previous security proof for the
GOST digital signature standard. For SM2, the only known
security evaluation is in the generic group model [27].

2. PRELIMINARIES
We denote random sampling from a ﬁnite set A according
to the uniform distribution with a ←$ A. We use symbol
←$ also for assignments from randomized algorithms, while
we denote assignments from deterministic algorithms and
calculations with ←. If q is a prime number, we write Zq for
the ﬁeld Z/qZ and assume the canonic representation of its
elements as a natural number in the interval [0 .. q − 1]. That
is, an element a ∈ Zq is invertible iﬀ a (cid:54)= 0. All algorithms
are randomized unless explicitly noted.

Most of our security deﬁnitions and proofs use code-based
games. Such a game G consists of an Init procedure, one
or more procedures to respond to adversary oracle queries,
and a Fin procedure. G is executed with an adversary A
as follows: Init is always run ﬁrst and its outputs are the
inputs to A. Next, the oracle queries of A are answered by
the corresponding procedures of G. Finally, A calls Fin and
terminates. Whenever the Stop command is invoked in a

7A function ϕ is semi-injective if it is 1-to-1 or 2-to-1, and for
any two group elements X, Y that collide under ϕ it holds
that Y ∈ {X, X−1}.

game procedure, its argument is considered the output of
the game (and the execution of the adversary is halted). By
GA ⇒ out we denote the event that G executed with A
invokes Stop with argument out. At the beginning of the
game, integer variables are initialized to 0 and set variables
to ∅. When using symbols like ⊥ we mean special symbols
that do not appear as elements of sets.

In games and reductions, when realizing a bijective ran-
dom oracle Π with domain A and range B via lazy sampling,
we consider Π interchangeably a partial function Π : A →
B, a partial function Π−1 : B → A, and a relation Π ⊆
A × B.
In particular, for (α, β) ∈ A × B we denote with
Π ← Π ∪ {(α, β)} the operation that ‘programs’ Π such
that Π(α) = β and Π−1(β) = α. We write Dom(Π) and
Rng(Π) for the domain and range of Π, i.e., for the sets
{α ∈ A | ∃β : (α, β) ∈ Π} and {β ∈ B | ∃α : (α, β) ∈ Π},
respectively. We write (α,·) ∈ Π and (·, β) ∈ Π shorthand
for the conditions α ∈ Dom(Π) and β ∈ Rng(Π).
2.1 Cyclic groups

Definition 1

(Discrete logarithm). Let (G, g, q) be
a prime-order group, i.e., G = (cid:104)g(cid:105) is a cyclic group of prime-
order q = |G|. We often write just G instead of (G, g, q). We
write 1 for the neutral element and let G∗ = G \ {1}. An
inverter algorithm I is said to (τ, ε)-break the discrete loga-
rithm problem (DLP) in G if it runs in time at most τ and
achieves inversion advantage ε = Pr[x ←$ Z∗
q ; x(cid:48) ←$ I(gx) :
x(cid:48) = x].

Definition 2

(Semi-Injective Function). Let G be
a prime-order group and A a set. A function ϕ : G∗ → A is
called semi-injective if (a) its range ϕ(G∗) ⊆ A is eﬃciently
decidable and (b) it is either injective or 2-to-1 with ϕ(X) =
ϕ(Y ) always implying Y ∈ {X, X−1}.
2.2 Signature schemes

Definition 3

(Signature scheme).

A signature
scheme consists of algorithms KGen,Sign,Verify such that: al-
gorithm KGen generates a signing key sk and a veriﬁcation
key pk; on input a signing key sk and a message m algorithm
Sign generates a signature σ or the failure indicator ⊥; on
input a veriﬁcation key pk, a message m, and a candidate
signature σ, deterministic algorithm Verify outputs 0 or 1 to
indicate rejection and acceptance, respectively.

A signature scheme is correct if for all sk, pk, and m, if

Sign(sk, m) outputs a signature then Verify accepts it.

Definition 4

(Unforgeability).

For a signature
scheme, an algorithm F that interacts in the CMA game (cf.
Figure 1), runs in at most time τ , poses at most Qs queries
to the Sign oracle, and has a forging advantage of ε =
Pr[CMAF ⇒ 1], is said to (τ, Qs, ε)-break the scheme’s exis-
tential unforgeability under chosen-message attack (euf-cma).
Forgers F that do not query the signing oracle, i.e., have
Qs = 0, are referred to as key-only forgers. We denote the
corresponding variant of the CMA game as KO.

If the signature scheme is speciﬁed in relation to some
idealized primitive that is accessed via oracles, we also an-
notate the maximum number of corresponding queries; for
instance, in the random oracle model for a hash function H
we use the expression (τ, Qs, QH , ε). We always assume that
forgers that output a forgery attempt (m∗, σ∗) pose a priori
all (public) queries that the veriﬁcation of σ∗ will require.

1654Procedure Init
00 (sk, pk) ←$ KGen
01 Return pk
Procedure Sign(m)
02 σ ←$ Sign(sk, m)
03 L ← L ∪ {(m, σ)}
04 Return σ

Procedure Fin(m∗, σ∗)
05 If (m∗,·) ∈ L: Stop with 0
06 If Verify(pk, m∗, σ∗) = 0:
07
08 Stop with 1

Stop with 0

Figure 1: Game CMA for modeling the existential
unforgeability of signatures. We refer to the key-
only variant of CMA (where no Sign queries can be
posed) as KO.

2.3 Hash functions
For a domain D and a prime q we consider implicitly keyed
hash functions H : D → Zq. Recall that practical hash func-
tions like MD5 and SHA1 are not explicitly keyed, but in-
stead have an implicit key k ∈ K (the initialization vector)
chosen and ﬁxed by their designer. The experiments of the
up-coming security deﬁnitions should be understood as im-
plicitly ﬁrst picking a random key k and giving it to the
adversary.

The following deﬁnition captures a security property of H
relative to a function ψ; it will be our main security require-
ment on H in the security analysis of GenDSA.

Definition 5

(ψ-DR). Let H : D → Zq be a hash func-
tion, B a set, and ψ : B → Zq a function. Let B∗ = ψ−1(Z∗
q ).
We say A = (A1,A2) (τψdr, εψdr)-breaks the ψ-relative divi-
sion resistance (ψ-DR) of H if it runs in at most time τψdr
and has an advantage of εψdr = Pr[β, β(cid:48) ←$ B∗; (m, Γ) ←$
A1(β); m(cid:48) ←$ A2(Γ, β(cid:48)) : H(m)/ψ(β) = H(m(cid:48))/ψ(β(cid:48))] .
Here, Γ is some arbitrary state information passed from A1
to A2.

We stress that in this deﬁnition A is not required to output
m (cid:54)= m(cid:48). We show in the full version of this paper that
in the case of DSA this notion is implied by preimage and
zero resistance (cf. [3]) of H. In the case of ECDSA it is
implied by a notion called high entropy division resistance,
meaning for any t, t(cid:48) sampled according to a distribution
with high entropy, the adversary cannot ﬁnd m, m(cid:48) such
that H(m)/t = H(m(cid:48))/t(cid:48).
2.4 The forking lemma

We reproduce details of the General Forking Lemma [1],

but adapt notation to the discrete logarithm setting.

Lemma 1

(General Forking Lemma). Fix a group
(G, g, q). Let Q ≥ 1 be an integer and B a non-empty ﬁ-
nite set. Consider a randomized algorithm A that takes as
input an element X ∈ G∗ and a sequence β1, . . . , βQ ∈ B,
and either outputs a pair (j, Σ), where j ∈ [1 .. Q] and Σ
is an arbitrary value, or aborts outputting a special sym-
bol ⊥. Associate to A the forking algorithm ForkA as spec-
iﬁed in Figure 2 that takes an element X ∈ G∗ and either
outputs a pair (Σ, Σ(cid:48)) or aborts with ⊥. Deﬁne the accept-
ing probability of A as acc := Pr[X ←$ G∗; β1, . . . , βQ ←$
B; A(X, β1, . . . , βQ) (cid:59) ⊥] and the probability of successful
forking as frk := Pr[X ←$ G∗; ForkA(X) (cid:59) ⊥]. Then we
have frk ≥ acc (acc/Q − 1/|B|).

// If A aborts outputting ⊥ then also ForkA aborts

ForkA(X)
00 Pick random coins ρ for A
01 Pick β1, . . . , βQ ←$ B
02 (j, Σ) ← A(X, β1, . . . , βQ; ρ)
03
04 Pick β(cid:48)
05 Abort if β(cid:48)
06 (j(cid:48), Σ(cid:48)) ← A(X, β1, . . . , βj−1, β(cid:48)
07
08 Abort if j (cid:54)= j(cid:48)
09 Output (Σ, Σ(cid:48))

j, . . . , β(cid:48)
j = βj

Q ←$ B

// If A aborts outputting ⊥ then also ForkA aborts

j, . . . , β(cid:48)

Q; ρ)

Figure 2: Forking algorithm ForkA. If ForkA aborts in
line 03, 05, 07, or 08, then it does so outputting ⊥.

3. COMMON DSA/ECDSA FRAMEWORK
We ﬁrst describe the abstract signature scheme GenDSA,
and then show that the standardized versions of DSA and
ECDSA can be obtained by instantiating the generic com-
ponents in the right way. Note that Brown [5] uses a similar
abstraction, but with a diﬀerent way to model the conver-
sion function.

Definition 6

(GenDSA framework). Let (G, g, q) be
a prime-order group, H : {0, 1}∗ → Zq be an (implicitly
keyed) hash function, and L be an integer. Deﬁne the con-
version function f = ψ ◦ Π ◦ ϕ : G∗ → Zq by its components

G∗ ϕ−→ {0, 1}L Π−→ [0 .. 2L − 1]

ψ−→ Zq ,

where ϕ and ψ are eﬃcient functions and Π is an eﬃcient
bijection. Then GenDSA is deﬁned by the algorithms of Fig-
ure 3.

The conversion function maps elements from group G to
ﬁeld Zq. The intuition behind its construction from com-
ponents ϕ, Π, ψ is that ϕ is an (injective) encoding function
that deterministically represents abstract group elements as
bit strings, ψ is an independent hash function that maps
integers from some range to elements of Zq, and Π is the
link in the middle, bridging the range of ϕ with the domain
of ψ. As computer implementations of G’s operations will
operate on bit string representations anyway, function ϕ will
often only exist implicitly. In principle, the linking compo-
nent Π is not required to fulﬁll any speciﬁc property and
both DSA and ECDSA instantiate it with function str2int L
(the canonic bijection between bit strings of length L and
integers in the range 0 .. 2L − 1). However, not surprisingly,
mandating speciﬁc properties of ϕ, ψ will be crucial for the
security analysis of GenDSA. Interestingly, as we will see,
the injectiveness of ϕ requested above can be traded for the
algebraic property of semi-injectiveness (cf. Deﬁnition 2).
Indeed, while DSA’s ϕ is injective, ECDSA’s ϕ is actually
only semi-injective.

Differences between (EC)DSA and GenDSA.

Before studying the components G, H, L, ϕ, Π, ψ of DSA
and ECDSA in detail, we discuss some diﬀerences between
the general structure of the standardized DSA/ECDSA ver-
sions and GenDSA. First, our version of the signing algo-
rithm has the option to abort without outputting a sig-
nature.
In contrast, signing with standardized DSA and
ECDSA never aborts and always outputs a valid signature.
Technically, the diﬀerence is that in standardized versions

1655q

KGen
00 x ←$ Z∗
01 X ← gx
02 sk := x
03 pk := X
04 Return (sk, pk)

Sign(x, m)
05 r ←$ Zq; R ← gr
06 If R = 1: Return ⊥
07 t ← f (R)
08 If t = 0: Return ⊥
09 h ← H(m)
10 u ← h + xt
11 If u = 0: Return ⊥
12 s ← u/r
13 Return (cid:104)s, t(cid:105)

Verify(X, m,(cid:104)s, t(cid:105))
14 If s = 0 ∨ t = 0:
Return 0
15
16 h ← H(m)
17 U ← ghX t
18 If U = 1: Return 0
19 R ← U 1/s
20 If f (R) (cid:54)= t:
Return 0
21
22 Return 1

Figure 3: GenDSA. In line 13, with (cid:104)·,·(cid:105) we denote any
ﬁxed encoding Zq × Zq → {0, 1}∗; correspondingly, in
Verify we assume that only signatures with s, t ∈ Zq
are considered.

the three “Return ⊥” statements of our Sign are replaced
with “Goto line 05” instructions. That is, eﬀectively, the
standardized DSA/ECDSA signing procedures iterate our
Sign algorithm until eventually succeeding with outputting
a pair (cid:104)s, t(cid:105). This change clearly does not aﬀect the secu-
rity assessment of the overall scheme. A second structural
diﬀerence between standardized DSA/ECDSA and our spec-
iﬁcation is that in the standards the last instruction of Sign
before returning the signature is to assert that s (cid:54)= 0∧ t (cid:54)= 0;
in our version these conditions are checked as early as pos-
sible. As a third change we note that the U = 1 abort con-
dition of line 18 is not present in DSA [11] (however, most
ECDSA speciﬁcations [19] assert that R (cid:54)= 1 after line 19,
which is equivalent to our condition). It is easy to check that
adding line 18 neither aﬀects the correctness nor the security
of DSA (see the full version for the worked out arguments).
3.1 Instantiations

DSA. We show how to instantiate G, H, L, ϕ, Π, ψ in order
to obtain the DSA signature scheme as standardized in [11,
Sec. 4] and [19] (modulo the diﬀerences already discussed).
As the prime-order group (G, g, q) a subgroup of the mul-
tiplicative group of a prime ﬁeld is used: For security pa-
rameters L ∈ {1024, 2048, 3072} and N ∈ {160, 224, 256}
(these are the values from [11]), two prime numbers p and q
and an element g ∈ Z∗
p are chosen such that p has bit-
length L, q has bit-length N , q | (p − 1), q2 (cid:45) (p − 1), and
ordp(g) = q. The group is then G := (cid:104)g(cid:105)p ⊆ Z∗
p. Fur-
ther, hash function H is constructed from any hash func-
tion of the SHA family speciﬁed in FIPS 180-4 that has
an output length of at least N bits: The construction is
H(m) := str2int N (sha(m)) mod q, where sha : {0, 1}∗ →
{0, 1}N stands for the N leftmost output bits of the cho-
sen hash function. As the conversion function f : G∗ → Zq
the mapping x (cid:55)→ x mod p mod q is used (assuming the rep-
resentation of G’s elements as numbers in [1 .. p − 1]).
In
the terms of Deﬁnition 6 this is achieved by letting function
ϕ : G∗ → {0, 1}L be the restriction of mapping [1 .. p − 1] →
{0, 1}L; x (cid:55)→ int2str L(x) to the domain G∗ (where int2str
is the canonic conversion of an integer to a bit string), deﬁn-
ing function Π : {0, 1}L → [0 .. 2L − 1] as x (cid:55)→ str2int L(x),
and deﬁning function ψ : [0 .. 2L − 1] → Zq such that x (cid:55)→
x mod q.
ECDSA. To obtain ECDSA, group G is instantiated with
a prime-order subgroup of the set of points of an elliptic
curve deﬁned over some ﬁnite ﬁeld. Speciﬁc such curves
over prime ﬁelds F = GF(p) and binary ﬁelds F = GF(2m)

are recommended by FIPS 186-4 [11]. For both types of
curves, the conversion function f : G∗ → Zq takes an elliptic
curve point (x, y) ∈ G∗ ⊆ F × F, understands x ∈ F as an
integer, and outputs the value x mod q. More precisely, if for
a prime curve L denotes the bit-length of p, and, for a binary
curve we have L = m and further fe2str : F → {0, 1}L is an
encoding of ﬁeld elements as bit strings of length L, then in
the terms of Deﬁnition 6 the function ϕ : G∗ → {0, 1}L is
implemented as the mapping (x, y) (cid:55)→ fe2str (x). Bijection
Π : {0, 1}L → [0 .. 2L − 1], function ψ : [0 .. 2L − 1] → Zq,
and hash function H are deﬁned as in DSA, i.e., per x (cid:55)→
str2int L(x) and x (cid:55)→ x mod q for the former two and the
latter based on a hash function of the SHA family.

Lemma 2. Let ϕ be deﬁned as in DSA and ECDSA, re-

p

spectively. Then ϕ is semi-injective (cf. Deﬁnition 2).

Proof. In the case of DSA, ϕ : G∗ → {0, 1}L is clearly
injective. To eﬃciently check if a given Z ∈ {0, 1}L has a
preimage in G∗ under ϕ, interpret Z as an element in Z∗
and accept it if Z (cid:54)= 1 and Z q = 1 mod p. This is a valid
membership test for G because q | (p − 1) but q2 (cid:45) (p − 1).
This establishes that ϕ as in DSA is semi-injective.
For elliptic curves over prime or binary ﬁelds, for each
x ∈ F there are at most two solutions y ∈ F such that
(x, y) is a point on the curve (at least for the Weierstrass
curves mandated by the ECDSA standards [19]). If there are
two such solutions then the corresponding points P = (x, y)
and Q = (x, y(cid:48)) are inverses of each other: P Q = 1 (we
assume multiplicative notation). Further, if there is only one
solution then the corresponding point P = (x, y) has order
two and is thus not an element of G (which is of prime order
and thus has no non-trivial subgroup). That is, in the case of
ECDSA ϕ is 2-to-1 and for all X, Y ∈ G∗ that collide under
ϕ we have either X = Y or XY = 1. Furthermore, for all
elliptic curves considered in the ECDSA standard, the range
of ϕ is eﬃciently decidable. Thus, ϕ is semi-injective.
4. SECURITY IN THE BRO MODEL

We establish that GenDSA signatures are unforgeable if
the DLP is hard in the underlying group, Π behaves like
a bijective random oracle, and certain standard model as-
sumptions on H, ψ, and ϕ are met. We split the proof
into two parts: In Section 4.1 we show that for GenDSA the
euf-cma notion is equivalent with the key-only notion (i.e.,
if one can forge GenDSA then one can do so without hav-
ing access to sample signatures), and in Section 4.2 we show
that any key-only forger can be used to break the DLP.
4.1 KO-unforgeability implies euf-cma

The following theorem says that if H is collision resis-
tant, then euf-cma unforgeability of GenDSA is implied by
key-only unforgeability, in the bijective random oracle model.
Theorem 1. Let ϕ be semi-injective. Let F be a forger
that (τ, Qs, QΠ, ε)-breaks euf-cma security of GenDSA. Then,
in the bijective random oracle model for Π, there exist a
forger F0 that (τ0, QΠ, ε0)-breaks the KO security of GenDSA
and an adversary that (τcr, εcr)-breaks the collision resistance
of H, where
ε ≤ ε0+εcr+

, τ0 = τ +O(Qs), τcr = τ +O(Qs).

3QQs

(q − 1)/2 − Q

Here, q denotes the group order, Qs denotes the maximum
number of signing queries of F, QΠ denotes the maximum

1656number of bijective random oracle queries of F and F0, and
Q = Qs + QΠ.

We remark that the security statement does not pose any
requirement on function ψ. Furthermore, it does not assume
the hardness of DLP in group G.

Proof. We write A := {0, 1}L and B := [0 .. 2L − 1]
throughout the proof, i.e., we have functions ϕ : G∗ → A,
Π : A → B, and ψ : B → Zq.
In the bijective random or-
acle model for Π, ﬁx a forger F against the euf-cma secu-
rity of GenDSA that runs in time at most τ and poses at
most Qs signature queries and QΠ bijective random ora-
cle queries (in the forward or reverse direction). Let Q =
Qs + QΠ. The concrete version of the CMA game from
Figure 1 with the GenDSA algorithms plugged in is given
as Game G0 in Figure 4 (excluding lines 18,19). Note
that access to bijective random oracle Π is provided via
oracles BRO and BRO−1. Our goal is to upper-bound
ε = Pr[CMAF ⇒ 1] = Pr[GF
0 ⇒ 1]. In line with Deﬁ-
nition 4 we assume that F does not output a forgery at-
tempt without having posed the corresponding Π query ﬁrst
(more precisely, if F outputs (m∗,(cid:104)s∗, t∗(cid:105)) and we let R∗ =
, then either BRO was queried on input
ϕ(R∗), or BRO−1 was queried such that ϕ(R∗) was the re-
sult; see the corresponding remark in line 27).

(cid:0)gH(m∗)X t∗(cid:1)1/s∗

q

Procedure Init
00 Pick Π : A → B
01 x ←$ Z∗
02 X ← gx
03 Return X
Procedure Sign(mi)
04 ri ←$ Zq; Ri ← gri
05 If Ri = 1: Return ⊥
06 αi ← ϕ(Ri)
07 βi ← Π(αi)
08 ti ← ψ(βi)
09 If ti = 0: Return ⊥
10 hi ← H(mi)
11 ui ← hi + xti
12 If ui = 0: Return ⊥
13 si ← ui/ri
14 L ← L∪{(mi,(cid:104)si, ti(cid:105))}
15 Return (cid:104)si, ti(cid:105)

Procedure BRO(α)
16 Return Π(α)
Procedure BRO−1(β)
17 Return Π−1(β)
Procedure Fin(m∗,(cid:104)s∗, t∗(cid:105))
18 For all (m,·) ∈ L, m (cid:54)= m∗: (G1)
If H(m) = H(m∗): Abort (G1)
19
20 If (m∗,·) ∈ L: Abort
21 If s∗ = 0 ∨ t∗ = 0: Abort
22 h∗ ← H(m∗)
23 U∗ ← gh∗
X t∗
24 If U∗ = 1: Abort
25 R∗ ← (U∗)1/s∗
26 α∗ ← ϕ(R∗)
27 β∗ ← Π(α∗) // was queried before
28 If ψ(β∗) (cid:54)= t∗: Abort
29 Stop with 1

G0 and G1: Game G0

Figure 4:
(excluding
lines 18,19) is the CMA game with the GenDSA al-
gorithms plugged in, in the bijective random ora-
cle model for Π. We make explicit the construction
f = ψ ◦ Π ◦ ϕ of the conversion function. Game G1
includes lines 18,19. We write ‘Abort’ as a shortcut
for ‘Stop with 0’.

0 ⇒ 1] ≤ Pr[GF

Game G1 in Figure 4 (including lines 18,19) is the mod-
iﬁcation of G0 in which forgeries obtained by ﬁnding a col-
lision of hash function H are not counted. By a standard
1 ⇒ 1] + εcr with an
argument we have Pr[GF
adversary that (τcr, εcr)-breaks the collision resistance of H,
where τcr = τ + O(Qs).
The intuition behind the overall proof is to use forger F
to construct a key-only forger F0 that has a similar forging
probability as F. More precisely, F0 shall invoke F, answer
all signing and bijective random oracle queries posed by F,
and ﬁnally forward F’s forgery to its own challenger. Signing

queries, as so often in proofs of unforgeability of signature
schemes based on the Fiat-Shamir transform, are processed
by simulation, which particularly includes programming the
Π bijection. More tricky is answering queries to the bijective
random oracle: Would F0 simulate the bijective random or-
acle all by itself, then also the forgery output by F would
be valid with respect to this instantiation of Π; however,
the challenger of F0 would consider the provided signature
invalid, as its own Π implementation would likely disagree.
On the other hand, if F0 would relay all bijective random
oracle queries to its own challenger, simulating signatures
for F (i.e., programming the bijective random oracle) would
not be possible any more. The solution is to let F0 combine
the two approaches: The bijective random oracle queries
that are related to simulated signatures are answered using
a local mechanism, all other queries are relayed to the own
challenger.

(G2)

Procedure Init
00 (ΠO, ΠS) ← (∅,∅)
01 x ←$ Z∗
q ; X ← gx
02 Return X
Procedure BRO(α)
03 If (α,·) ∈ Π: Return Π(α)
04 β ←$ B \ Rng(ΠO)
05 If (·, β) ∈ ΠS: Abort
06 ΠO ← ΠO ∪ {(α, β)}
07 Return β
Procedure Sign(mi)
08 ri ←$ Zq; Ri ← gri
09 If Ri = 1: Return ⊥
10 αi ← ϕ(Ri)
11 If (αi,·) ∈ Π: Abort
12 βi ←$ B
13 If (·, βi) ∈ Π: Abort
14 ΠS ← ΠS ∪ {(αi, βi)}
15 ti ← ψ(βi)
16 If ti = 0: Return ⊥
17 hi ← H(mi)
18 ui ← hi + xti
19 If ui = 0: Return ⊥
20 si ← ui/ri
21 L ← L ∪ {(mi,(cid:104)si, ti(cid:105))}
22 Return (cid:104)si, ti(cid:105)

(G3)

Procedure BRO−1(β)
23 If (·, β) ∈ Π: Return Π−1(β)
24 α ←$ A \ Dom(ΠO)
25 If (α,·) ∈ ΠS: Abort
26 ΠO ← ΠO ∪ {(α, β)}
27 Return α
Procedure Sign(mi)
28 βi ←$ B
29 If (·, βi) ∈ Π: Abort
30 ti ← ψ(βi)
31 If ti = 0: Return ⊥
32 hi ← H(mi)
33 Ui ← ghi X ti
34 If Ui = 1: Return ⊥
35 si ←$ Zq
36 If si = 0: Return ⊥
37 Ri ← Ui
38 αi ← ϕ(Ri)
39 If (αi,·) ∈ Π: Abort
40 ΠS ← ΠS ∪ {(αi, βi)}
41 L ← L ∪ {(mi,(cid:104)si, ti(cid:105))}
42 Return (cid:104)si, ti(cid:105)

1/si

Figure 5: Games G2 and G3. We use writing con-
vention Π := ΠO ∪ ΠS. Procedure Fin is as in G1 (in
Figure 4).

Game G2 in Figure 5 is a preparation towards the re-
duction step just described. The major diﬀerence to G1 is
that bijection Π is now implemented using lazy sampling.
In particular, in G2 we represent Π as a subset of A × B.
More precisely, the input-output pairs (α, β) that later shall
result from relayed bijective random oracle queries are man-
aged in a list ΠO, the ones originating from programming
the bijective random oracle are managed in a list ΠS, and
by convention we always have Π := ΠO ∪ ΠS.
In most
cases joint list Π will indeed represent a bijection. However,
with small probability the ΠO and ΠS parts may become
contradictory; whenever this happens, the game aborts (in
lines 05, 11, 13, 25). The task of lines 05 and 25 is to guard
that β ∈ B \ Rng(Π) and α ∈ A \ Dom(Π), respectively, and
lines 11 and 13 ensure that the independently sampled pairs
(αi, βi) can be added to Π without causing a conﬂict. As

1657F by assumption does not output a forgery without having
posed the corresponding bijective random oracle query ﬁrst,
Procedure Fin is not aﬀected by the switch to lazy sampling
and remains unmodiﬁed.

We assess the probability that G2 aborts in lines 05 or 25
as follows: In each case, a uniformly distributed value of a
set of cardinality at least 2L − Q is sampled and checked for
containedness in a set of at most Qs elements (elements are
added to ΠS only in Procedure Sign, and at most one ele-
ment is added per query). That is, per execution of lines 05
and 25 the probability of a hit is at most Qs/(2L − Q).
As these lines are executed at most QΠ times in total, the
overall probability of abort is bounded by QΠQs/(2L − Q).
Similarly, the probability of a hit in line 13 is at most Q/2L
and thus there the overall probability of abort is bounded
by QsQ/2L. Consider next the abort condition in line 11.
The value αi is uniformly distributed in a set of cardinality
at least (q − 1)/2 (as Ri is uniform in G∗ and ϕ is a semi-
injective function), and the abort condition is met if this
value hits one of the at most Q elements contained in Π.
Thus, the overall abort probability for line 11 is bounded
by 2QsQ/(q − 1). From the fact that ϕ is semi-injective
we can further deduce that (q − 1)/2 ≤ 2L. As G1 and
G2 are identical if no abort happens, all in all we obtain
2 ⇒ 1] + 3QQs/((q − 1)/2− Q) (see full
Pr[GF
version for the calculation).

1 ⇒ 1] ≤ Pr[GF

2 ⇒ 1].

3 ⇒ 1] = Pr[GF

Observe that G2 uses the signing key in line 18 to im-
plement the signature oracle. We deﬁne Game G3 (also
in Figure 5) like G2 but with a signature oracle that gets
along with only public information. We argue that the forg-
ing probability of F in G2 and G3 is identical. To see this,
observe that lines 28–34 correspond with lines 12–19 (except
for line 14) and induce the same distribution on βi, ti, and
ui = log Ui, and that lines 08, 09, 20 and lines 35, 36, 37
correspond and induce the same distribution on ri = log Ri
and si (as in both cases ui (cid:54)= 0, and the distribution of
ui is independent of the distribution of ri and si). Thus
Pr[GF
The code of Figure 6 constructs a forger F0 from forger F.
Importantly, F0 does not pose signature queries. Assume
that F0 is executed within the KO experiment (cf. Fig-
ure 1). Note that F0 acquires the public key X from its
challenger in line 01 and hands it on to F in line 02. The
signature queries posed by F are processed by F0 using the
code from the simulation in G3 (which in particular does
not require the signing key). There is, though, a diﬀerence
between how bijective random oracle queries are processed
in G3 and by F0: While list ΠO in both cases keeps track of
input-output pairs that do not originate from programming
the bijective random oracle, the sampling steps from lines 04
and 24 of Figure 5 are replaced by queries to the external or-
acles BRO∗ and (BRO∗)−1 in Figure 6, i.e., to the bijective
random oracle that is controlled by F0’s challenger. Clearly,
these changes are pure rewriting and not noticeable by F, so
the probabilities of reaching the last line of Procedure Fin
of G3 (annotated as line 29 in Figure 4) and reaching line 27
of F0 in Figure 6 are identical. In the following we argue that
this allows concluding that Pr[KOF0 ⇒ 1] = Pr[GF
3 ⇒ 1].
Assume that F delivers a valid forgery (m∗,(cid:104)s∗, t∗(cid:105)), i.e.,
that line 27 of F0 is reached. Let h∗, R∗, α∗, β∗ be the
corresponding values from lines 19, 22, 23, 24. We have
R∗ = (gh∗
and thus r∗s∗ = h∗ + xt∗ for implicit
values r∗ = log R∗ and x = log X. By assumption either

)1/s∗

X t∗

Procedure Fin(m∗,(cid:104)s∗, t∗(cid:105))
15 For all (m,·) ∈ L, m (cid:54)= m∗:
If H(m) = H(m∗): Abort
16
17 If (m∗,·) ∈ L: Abort
18 If s∗ = 0 ∨ t∗ = 0: Abort
19 h∗ ← H(m∗)
20 U∗ ← gh∗
X t∗
21 If U∗ = 1: Abort
22 R∗ ← (U∗)1/s∗
23 α∗ ← ϕ(R∗)
24 β∗ ← Π(α∗)
25
26 If ψ(β∗) (cid:54)= t∗: Abort
27 If (α∗,·) ∈ ΠS:
Find x = log X
28
as described in text
29
(cid:104)s∗, t∗(cid:105) ←$ SignBRO∗
30
31 Invoke Fin∗(m∗,(cid:104)s∗, t∗(cid:105))

Procedure Init
00 (ΠO, ΠS) ← (∅,∅)
01 X ←$ Init∗
02 Return X
Procedure BRO(α)
03 If (α,·) ∈ Π:
Return Π(α)
04
05 β ← BRO∗(α)
06 If (·, β) ∈ ΠS: Abort
07 ΠO ← ΠO ∪ {(α, β)}
08 Return β
Procedure BRO−1(β)
09 If (·, β) ∈ Π:
Return Π−1(β)
10
11 α ← (BRO∗)−1(β)
12 If (α,·) ∈ ΠS: Abort
13 ΠO ← ΠO ∪ {(α, β)}
14 Return α
Figure 6: Construction of key-only forger F0 from F.
Procedures Init∗, BRO∗, (BRO∗)−1, and Fin∗ are the
oracles of the KO game in which F0 is executed. The
invocation of the GenDSA signing algorithm in line 30
is relative to bijective random oracle BRO∗. We
write ‘Abort’ as a shortcut for ‘Invoke Fin∗(⊥,⊥)’.
Procedure Sign is as in G3 (cf. Figure 5).

// was queried before

(x, m∗)

(cid:18) ηs∗ −ti

(cid:19)(cid:18) ri

(cid:19)

(cid:18) h∗

(cid:19)

(α∗, β∗) ∈ ΠS or (α∗, β∗) ∈ ΠO. Consider ﬁrst the case
that pair (α∗, β∗) was established in a signature simulation,
i.e., (α∗, β∗) ∈ ΠS. In this case F0 knows αi, βi, Ri, hi, ti, si
such that (α∗, β∗) = (αi, βi) and Ri = (ghi X ti )1/si , i.e.,
risi = hi + xti for implicit ri = log Ri and x = log X. We
further have ϕ(R∗) = α∗ = αi = ϕ(Ri) and thus r∗ = ηri
with η ∈ {±1} (by the semi-injectiveness of ϕ, cf. Deﬁni-
tion 2), and t∗ = ψ(β∗) = ψ(βi) = ti. Taken together the
above observations result in the linear equation system

x

=

hi

si −ti

(3)
which, as ti (cid:54)= 0, has a unique solution whenever ηs∗ (cid:54)= si.
Observe that, as ri (cid:54)= 0, case ηs∗ = si would imply h∗ =
hi and thus H(m∗) = H(mi), which is excluded by lines
15, 16, 17. Thus F0 can always recover signing key x, and
the signature (cid:104)s∗, t∗(cid:105) freshly generated in line 30 is valid
with respect to oracle BRO∗, i.e., the bijective random or-
acle managed by the challenger of F0. That is, if F forges
successfully then so does F0. Assume next that pair (α∗, β∗)
was established by a relayed bijective random oracle query,
i.e., (α∗, β∗) ∈ ΠO. In this case, F’s forgery (m∗,(cid:104)s∗, t∗(cid:105))
is consistent with oracle BRO∗. Again, if F forges success-
fully then so does F0. We thus obtain Pr[KOF0 ⇒ 1] =
3 ⇒ 1], with a forger F0 that has a running time of at
Pr[GF
most τ0 = τ +O(Qs). All in all we proved Pr[CMAF ⇒ 1] ≤
Pr[KOF0 ⇒ 1] + εcr + 3QQs/((q− 1)/2− Q), as required.
4.2 DLP-hardness implies KO-unforgeability
We next show that if the DLP is hard in G and if H is
ψ-relative division resistant, then GenDSA is key-only un-
forgeable in the bijective random oracle model for Π.

Theorem 2. Let ϕ be semi-injective. Let F (τ, Q, ε)-
break the key-only security of GenDSA. Then if Π is mod-
eled as a bijective random oracle, there exist an adversary
B that (τψdr, εψdr)-breaks the ψ-relative division resistance

1658of H, and inverters that (τ(cid:48), ε(cid:48))-break and (τ(cid:48)(cid:48), ε(cid:48)(cid:48))-break, re-
spectively, the DLP in G, such that

ε ≤(cid:112)2Q2εψdr + 2Qε(cid:48) + ε

(cid:48)(cid:48)

+ Q2/2L

and τψdr = τ(cid:48) = 2τ + O(Q), τ(cid:48)(cid:48) = τ + O(Q). Here, Q denotes
a bound on the bijective random oracle queries.

Proof. We write A := {0, 1}L and B := [0 .. 2L − 1] as
in the proof of Theorem 1.
In the bijective random ora-
cle model for Π, ﬁx a forger F against the key-only secu-
rity of GenDSA that runs in time at most τ and poses at
most Q bijective random oracle queries. Following Deﬁni-
tion 4 we assume that F does not output a forgery attempt
(m∗,(cid:104)s∗, t∗(cid:105)) without having posed the corresponding bi-
jective random oracle query ﬁrst. The concrete version of
the KO game from Figure 1 with the GenDSA algorithms
plugged in is given as Game G0 in Figure 4 (for the cur-
rent proof, Procedure Sign and line 20 are redundant and
can be ignored). Our goal is to upper-bound forging proba-
bility ε = Pr[KOF ⇒ 1] = Pr[GF

0 ⇒ 1].

Game G1 (in Figure 7) is the modiﬁcation of G0 in which
bijective random oracle Π is implemented via lazy sam-
pling. Depending on whether they originate from a BRO
or a BRO−1 query, new input-output pairs (α, β) are stored
either in list Π(cid:1) or in list Π(cid:0) (lines 21 and 30). Taken
together, Π(cid:1) and Π(cid:0) make up list Π, i.e., we assume writ-
ing convention Π := Π(cid:1) ∪ Π(cid:0). The switch from G0 to G1

introduces abort conditions in lines 20 and 29. Inspection
shows that each condition is met with probability at most
Q/2L per oracle invocation, so the overall abort probability
for these lines is Q2/2L. As games G0 and G1 are identi-
0 ⇒ 1] ≤
cal as long as these conditions are not met, Pr[GF
Pr[GF

1 ⇒ 1] + Q2/2L.

(G2, G3)

Procedure Init
00 (Π(cid:1), Π(cid:0)) ← (∅,∅)
01 β1, . . . , βQ ←$ B
q ; X ← gx
02 x ←$ Z∗
03 Return X
Procedure Fin(m∗,(cid:104)s∗, t∗(cid:105))
04 If s∗ = 0 ∨ t∗ = 0: Abort
05 U∗ ← gH(m∗)X t∗
06 If U∗ = 1: Abort
07 R∗ ← (U∗)1/s∗
08 α∗ ← ϕ(R∗)
09 β∗ ← Π(α∗)
10
11 If ψ(β∗) (cid:54)= t∗: Abort
12 If (α∗, β∗) ∈ Π(cid:0): Abort (G3)
13 // Note: β∗ = βj
14 // for unique j ∈ [1 .. k]
15 Stop with 1

// was queried before

(G3)
(G3)

Return Π(α)

Procedure BRO(α)
16 If (α,·) ∈ Π:
17
18 β ←$ B
(G1)
19 k ← k+1; β ← βk (G2, G3)
20 If (·, β) ∈ Π: Abort
21 Π(cid:1) ← Π(cid:1) ∪ {(α, β)}
22 Return β
Procedure BRO−1(β)
23 If (·, β) ∈ Π:
24
25 α ←$ A
26 If α ∈ ϕ(G∗):
a ←$ Z∗
27
α ← ϕ(ga)
28
29 If (α,·) ∈ Π: Abort
30 Π(cid:0) ← Π(cid:0) ∪ {(α, β)}

(G2, G3)
(G2, G3)
(G2, G3)

Return Π−1(β)

q

31 Return α

Figure 7: Games G1, G2, and G3. We use writing

convention Π := Π(cid:1)∪Π(cid:0) and write ‘Abort’ as a short-

cut for ‘Stop with 0’.

Consider next Game G2 from Figure 7. There are two
diﬀerences to G1. First, in the BRO oracle, instead of sam-
pling values β individually for each query (line 18), these
are now sampled a priori (line 01) and spent one by one
(line 19). Second, in the BRO−1 oracle, if a sampled value α
happens to be an element of ϕ(G∗) it is resampled such that
the discrete logarithm a of a preimage under ϕ is known
(lines 26–28). As ϕ is a semi-injective function this change

)1/s∗

2 ⇒ 1].

1 ⇒ 1] = Pr[GF

does not aﬀect the distribution of sampled values α. We
thus have Pr[GF
Observe that if F succeeds in G2 with ﬁnding a valid
forgery (m∗,(cid:104)s∗, t∗(cid:105)) then the corresponding pair (α∗, β∗)
(cf. line 09) was established in either a forward or a back-
ward query to the bijective random oracle, i.e., it is con-

tained either in list Π(cid:0) or in list Π(cid:1). We next prove that

2 ⇒ 1] ≤ Pr[GF

from any adversary that forges using a pair established in a
backward query we can construct a DLP solver that recov-
ers the discrete logarithm of X with the same advantage.
Assume thus that F forges such that (α∗, β∗) ∈ Π(cid:0). Then
we have R∗ = (gH(m∗)X t∗
, which gives rise to equa-
tion H(m∗) + xt∗ = s∗r∗ with unknowns x = log X and
r∗ = log R∗, and we have ϕ(R∗) = α∗. By lines 26–28 and
the fact that ϕ is semi-injective we know that R∗ = gηa for
a known a and η ∈ {±1}. This allows solving above equa-
tion for x, as required. The speciﬁcation of Game G3 (in
Figure 7) adds to G2 an abort condition (in line 12) that
is triggered whenever F performs a forgery of the type just
considered. A standard reductionist argument thus shows
3 ⇒ 1] + ε(cid:48)(cid:48), for an inverter that
that Pr[GF
(τ(cid:48)(cid:48), ε(cid:48)(cid:48))-breaks DLP in time at most τ(cid:48)(cid:48) = τ + O(Q).
We employ the forking lemma (cf. Section 2.4) to analyze
3 ⇒ 1], i.e., the probability that F successfully forges
Pr[GF
using a forward query (in Π(cid:1)). To this end, from F we con-
struct an algorithm A that takes a vector (X, β1, . . . , βQ; ρ),
where X ∈ G∗ is a DLP instance, β1, . . . , βQ ∈ B, and ρ is a
set of random coins, as speciﬁed in Figure 8. The algorithm
invokes F as a subroutine, on input X and a random tape
derived from ρ, and processes bijective random oracle queries
as they are processed in G3. More precisely, queries to
BRO are answered using the β1, . . . , βQ values, and queries
to BRO−1 are answered using randomness derived from ρ.
When F stops and outputs a forgery (m∗,(cid:104)s∗, t∗(cid:105)), algo-
rithm A ﬁnds the index j of the BRO query correspond-
ing to the forgery (which necessarily exists), and outputs
it together with the triple (m∗, s∗, t∗). If F aborts also A
aborts. In Section 2.4 the probability acc = Pr[X ←$ G∗;
β1, . . . , βQ ←$ B; A(X, β1, . . . , βQ) (cid:59) ⊥] that A does not
abort is referred to as its accepting probability. A compar-
ison of A from Figure 8 with G3 from Figure 7 shows that
we have acc = Pr[GF
Consider next the DLP solver I speciﬁed in Figure 9. It
starts with invoking the forking algorithm ForkA (cf. Fig-
ure 2) as a subroutine (lines 01–09), on input X. The fork-
ing lemma (cf. Section 2.4) establishes that the probabil-
ity frk that ForkA(X) terminates without aborting, i.e., that
the execution of I reaches at least line 10, is bounded as
frk ≥ acc(acc/Q − 2−L).
To assess the success probability of I of solving DLP chal-
lenges it remains to bound the probability of abort in line 10,
and to assert the eﬀectiveness of the recovery step in line 11.
Concerning line 10, the probability of an abort can be
bounded using the ψ-relative division advantage εψdr (cf.
Deﬁnition 5) of a stateful adversary B = (B1,B2) as in Fig-
ure 10. Concretely, B1 gets input β and guesses j∗ ∈ [1 .. Q].
It then simulates lines 01 to 04 of I with the only diﬀerence
that it overwrites βj∗ ← β. Once it gets (j, (m, s, t)) from A
it checks if it guessed j correctly and forwards m to its own
challenger, together with state Γ = (X, j∗, β1, . . . , βj∗ , ρ).
When B2 is invoked on input (Γ, β(cid:48)), it simulates lines 05–09
of I, overwriting β(cid:48)
j∗ ← β(cid:48). Once it gets m(cid:48) from A, it for-
wards it to its challenger and wins if H(m)/t = H(m(cid:48))/t(cid:48)

3 ⇒ 1].

1659Procedure Init

00 (Π(cid:1), Π(cid:0)) ← (∅,∅)

01 Obtain (X, β1, . . . , βQ; ρ)
02 Return X
Procedure BRO(α)

as in G3 (cf. Figure 7)
Procedure BRO−1(β)
as in G3 (cf. Figure 7)

Procedure Fin(m∗,(cid:104)s∗, t∗(cid:105))
03 If s∗ = 0 ∨ t∗ = 0: Abort
04 U∗ ← gH(m∗)X t∗
05 If U∗ = 1: Abort
06 R∗ ← (U∗)1/s∗
07 α∗ ← ϕ(R∗)
08 β∗ ← Π(α∗)
09
10 If ψ(β∗) (cid:54)= t∗: Abort
11 If (α∗, β∗) ∈ Π(cid:0): Abort
12 Find j ∈ [1 .. k] s.t. β∗ = βj
13 Output j and (m∗, s∗, t∗)

// was queried before

Figure 8: Algorithm A is constructed from key-only
forger F. It obtains its input in line 01 and declares
its output, unless it aborts, in line 13. Procedures
Init, BRO, BRO−1, Fin are invoked by F. Note that
BRO−1 contains instructions for sampling from sets
A and Z∗
q ; in the context of A, these operations are
understood to take their randomness from ρ. Also
the randomness of F is taken from ρ. We write
‘Abort’ as shortcut for ‘Output ⊥ and stop’.

I(X)
00 Run forking algorithm ForkA(X) as a subroutine:
01
02
03
04
05
06
07
08
09
10 Abort if H(m)/t = H(m(cid:48))/t(cid:48)
11 Compute x as described in text
12 Output x

Pick random coins ρ for A
β1, . . . , βQ ←$ B
(j, (m, s, t)) ← A(X, β1, . . . , βQ; ρ)
// If A aborts outputting ⊥: Abort
Q ←$ B
β(cid:48)
j, . . . , β(cid:48)
Abort if βj = β(cid:48)
(j(cid:48), (m(cid:48), s(cid:48), t(cid:48))) ← A(X, β1, . . . , βj−1, β(cid:48)
// If A aborts outputting ⊥: Abort
Abort if j (cid:54)= j(cid:48)

j

j, . . . , β(cid:48)

Q; ρ)

Figure 9: DLP-solver I runs algorithm A (twice)
as a subroutine. We write ‘Abort’ as shortcut for
‘Output ⊥ and stop’.

j∗ ) and t, t(cid:48) (cid:54)= 0). It follows that
(since t = ψ(βj∗ ), t(cid:48) = ψ(β(cid:48)
the probability of an abort in line 10 of I is bounded by
Qεψdr.

)1/s(cid:48)

Now consider the case line 11 of Figure 9 is reached. Note
that the same ϕ(R) is used in both forgeries by construction
of A and ForkA, since the executions of I only diﬀer from
the jth BRO query onwards, so by the semi-injectiveness
of ϕ we have Rη = (gH(m)X t)η/s = (gH(m(cid:48))X t(cid:48)
= R(cid:48)
for η ∈ {±1}. Let r = log R, r(cid:48) = log R(cid:48), and x = log X.
Then r(cid:48) = ηr and hence sr − tx = H(m) and s(cid:48)ηr − t(cid:48)x =
H(m(cid:48)). By dividing the ﬁrst equation by t and the second
by t(cid:48) and subtracting them from each other, it follows that
r(s/t − s(cid:48)η/t(cid:48)) = H(m)/t − H(m(cid:48))/t(cid:48). Since the right-hand
side is nonzero by the condition in line 10 and r is nonzero by
validity of the forgery, so is s/t − s(cid:48)η/t(cid:48) and I can compute
r = (H(m)/t − H(m(cid:48))/t(cid:48))/(s/t − s(cid:48)η/t(cid:48)) and thus also x =
(sr − H(m))/t.
Recall that adversary F (τ, Q, ε)-breaks the key-only se-
curity of GenDSA, that adversary B (τψdr, εψdr)-breaks the
ψ-relative division resistance of H, and that there is an ad-
versary that (τ(cid:48)(cid:48), ε(cid:48)(cid:48))-breaks the DLP in G. As we saw, acc =
3 ⇒ 1] ≥ ε− ε(cid:48)(cid:48) − Q2/2L, and frk ≥ acc(acc/Q− 1/2L).
Pr[GF

q ; X ← gx

j∗ , . . . , β(cid:48)
j∗ ← β(cid:48)

B2(Γ, β(cid:48))
11 Recover X, j∗, β1, . . . , βj∗ , ρ
Q ←$ B
12 β(cid:48)
13 β(cid:48)
14 Abort if βj∗ = β(cid:48)
j∗
15 L(cid:48) ← (β1 . . . βj∗−1, β(cid:48)
j∗ . . . β(cid:48)
Q)
16 (j(cid:48), (m(cid:48), s(cid:48), t(cid:48))) ← A(X, L(cid:48); ρ)
// If A outputs ⊥: Abort
17
18 Abort if j (cid:54)= j(cid:48)
19 Return m(cid:48)

B1(β)
00 x ←$ Z∗
01 j∗ ←$ [1 .. Q]
02 Pick random coins ρ for A
03 β1, . . . , βQ ←$ B
04 βj∗ ← β
05 L ← (β1, β2, . . . , βQ)
06 (j, (m, s, t)) ← A(X, L; ρ)
// If A outputs ⊥: Abort
07
08 Abort if j (cid:54)= j∗
09 Γ ← (X, j∗, β1, . . . , βj∗ , ρ)
10 Return (m, Γ)
Figure 10: Construction of adversary B against the
ψ-relative division resistance of H. We write ‘Abort’
as a shortcut for ‘Return ⊥’.

We can assume w.l.o.g. that 1/2L ≤ acc/2Q, because oth-
erwise ε can be bounded by ε(cid:48)(cid:48) + Q(Q + 2)/2L and we are
done. Now overall, for the success probability ε(cid:48) of I we
have ε(cid:48) ≥ frk − Qεψdr ≥ acc(acc/Q − 1/2L) − Qεψdr ≥
acc(acc/Q − acc/2Q) − Qεψdr = acc2/2Q − Qεψdr ≥ (ε −
ε(cid:48)(cid:48) − Q2/2L)2/2Q − Qεψdr. All in all we proved Pr[KOF ⇒

1] ≤(cid:112)2Q2εψdr + 2Qε(cid:48) + ε(cid:48)(cid:48) + Q2/2L, as required.

5. CONCLUSIONS FOR DSA AND ECDSA
By combining Theorems 1 and 2 we obtain that if ϕ is
semi-injective and H is suﬃciently secure then GenDSA is
euf-cma secure if the discrete logarithm problem in G is hard,
in the bijective random oracle model for Π. Further, in the
full version we show that GenDSA is strongly unforgeable if
and only if ϕ is injective. In practice, the conditions on H
and G are arguably fulﬁlled for the standardized versions of
DSA and ECDSA. That is, if one accepts the random bijec-
tion model for Π, our overall results in a nutshell are: DSA
signatures are strongly unforgeable, and ECDSA signatures
are existentially unforgeable.

6. ACKNOWLEDGMENTS

Supported by ERC Project ERCC (FP7/615074).

7. REFERENCES
[1] M. Bellare, G. Neven. Multi-signatures in the plain
public-key model and a general forking lemma. In
A. Juels, R. N. Wright, S. Vimercati, eds., ACM CCS
06: 390-399, Alexandria, US, Oct. 2006. ACM Press.

[2] E. Brickell, D. Pointcheval, S. Vaudenay, M. Yung.

Design validations for discrete logarithm based
signature schemes. In H. Imai, Y. Zheng, Eds.,
PKC 2000, LNCS 1751: 276-292, Melbourne, AU,
Jan. 2000. Springer.

[3] D. Brown. On the provable security of ECDSA. In I.

Blake, G. Seroussi, N. Smart, Eds., Advances in
Elliptic Curve Cryptography: 21-40. Cambr. Uni. Pr.,
2005

[4] D. Brown. Generic groups, collision resistance, and

ECDSA. IACR ePrint 2002/026.
http://ia.cr/2002/026.

[5] D. Brown. Generic groups, collision resistance, and
ECDSA. Des. Codes Cryptography, 35(1):119-152,
2005.

1660[6] D. Brown. One-up problem for (EC)DSA. IACR

ePrint 2008/286. http://ia.cr/2008/286.

[7] A. W. Dent. Adapting the weaknesses of the random
oracle model to the generic group model. In Y. Zheng,
Ed., ASIACRYPT 2002, LNCS 2501: 100-109,
Queenstown, NZ, Dec. 2002. Springer.

[8] V. Dolmatov, A. Degtyarev. GOST R 34.10-2012:

Digital Signature Algorithm. RFC 7091, Dec. 2013.
http://www.ietf.org/rfc/rfc7091.txt.

[9] N. Howgrave-Graham, N. Smart. Lattice attacks on

digital signature schemes. Des. Codes Crypt.,
23(3):283-290, 2001.

[10] ISO/IEC 11889:2015. Information technology - trusted

platform module library, 2013.

[11] C. Kerry, P. Gallagher. FIPS PUB 186-4: Digital

Signature Standard (DSS), 2013.
http://dx.doi.org/10.6028/NIST.FIPS.186-4.

[12] E. Kiltz, K. Pietrzak. Leakage resilient ElGamal

encryption. In M. Abe, Ed., ASIACRYPT 2010, LNCS
6477: 595-612, SG, Dec. 2010. Springer.

[13] P. J. Leadbitter, D. Page, N. P. Smart. Attacking DSA

under a repeated bits assumption. In M. Joye, J.-J.
Quisquater, Eds., CHES 2004, LNCS 3156: 428-440,
Cambridge, US, Aug. 2004. Springer.

[14] J. Malone-Lee, N. P. Smart. Modiﬁcations of ECDSA.

In K. Nyberg, H. M. Heys, Eds., SAC 2002, LNCS
2595: 1-12, St. John’s, CA, Aug. 2003. Springer.

[15] U. Maurer. Abstract models of computation in

cryptography. In N. P. Smart, Ed., 10th IMA
International Conference on Cryptography and
Coding, LNCS 3796: 1-12, Cirencester, UK, Dec. 2005.
Springer.

[16] U. Maurer, S. Wolf. Lower bounds on generic

algorithms in groups. In K. Nyberg, Ed.,
EUROCRYPT’98, LNCS 1403: 72-84, Espoo, FI,
May/June 1998. Springer.

[17] G. Neven, N. P. Smart, B. Warinschi. Hash function

requirements for Schnorr signatures. J. Mathematical
Cryptology, 3(1):69-87, 2009.

[18] P. Q. Nguyen, I. Shparlinski. The insecurity of the

elliptic curve digital signature algorithm with partially
known nonces. Des. Codes Crypt., 30(2):201-217, 2003.

[19] P1363. IEEE P1363-2000: Standard speciﬁcations for

public key cryptography. IEEE, Inc., 2000.
http://grouper.ieee.org/groups/1363/.

[20] D. Pointcheval, J. Stern. Security proofs for signature
schemes. In U. Maurer, Ed., EUROCRYPT’96, LNCS
1070: 387-398, Saragossa, ES, May 1996. Springer.

[21] D. Pointcheval, S. Vaudenay. On provable security for

digital signature algorithms. Technical report,
Technical Report LIENS-96-17, LIENS, 1996.

[22] V. Shoup. Lower bounds for discrete logarithms and

related problems. In W. Fumy, Ed., EUROCRYPT’97,
LNCS 1233: 256-266, Konstanz, DE, May ’97.
Springer.

[23] N. P. Smart. The exact security of ECIES in the
generic group model. In B. Honary, Ed., 8th IMA
International Conference on Cryptography and
Coding, LNCS 2260: 73-84, Cirencester, UK,
Dec. 2001. Springer.

[24] J. Stern, D. Pointcheval, J. Malone-Lee, N. P. Smart.
Flaws in applying proof methodologies to signature
schemes. In M. Yung, Ed., CRYPTO 2002, LNCS
2442: 93-110, Sta. Barbara, US, Aug. 2002. Springer.
[25] S. Vaudenay. Hidden collisions on DSS. In N. Koblitz,
Ed., CRYPTO’96, LNCS 1109: 83-88, Sta. Barbara,
US, Aug. 1996. Springer.

[26] S. Vaudenay. The security of DSA and ECDSA. In
Y. Desmedt, Ed., PKC 2003, LNCS 2567: 309-323,
Miami, US, Jan. 2003. Springer.

[27] Z. Zhang, K. Yang, J. Zhang, C. Chen. Security of the

SM2 signature scheme against generalized key
substitution attacks. In L. Chen, S. Matsuo, Eds.,
Security Standardisation Research 2015, LNCS 9497:
140-153, Tokyo, JP, Dec. 2015. Springer.

APPENDIX
A. FUNCTIONS IN THE GGM

We consider how the generic group model should be used
for the analysis of DL-based signature schemes that make
use of a non-algebraic component such as a hash function.
Although they have never been written down at a formal
level (to the best of our knowledge), most of the observations
made in this section can be considered folklore. We thank
Ueli Maurer and others for useful discussions in this context.
Shoup [22] introduced the generic group model for study-
ing cryptographic problems (‘hardness assumptions’) related
to the discrete logarithm problem in the context of generic
algorithms. That is, “algorithms that do not exploit any spe-
cial properties of the encodings of group elements other than
the property that each group element is encoded as a unique
binary string” [22]. Generic group models proved useful for
establishing generic lower bounds for several newly proposed
cryptographic problems. Even though no concrete group can
be fully generic, it is generally believed in cryptography that
the generic group model approximates the behavior of ellip-
tic curve groups ‘well-enough’ in most cases.

The generic group model for algebraic problems.
Let Π[G] be a cryptographic problem deﬁned over some
prime-order group (G, g, q) which is expressed via a (poten-
tially interactive) probabilistic experiment between a chal-
lenger and an unbounded adversary. Suppose Π[G] is al-
gebraic in the sense that all operations of the experiment
can be described by group operations only. An example
for an algebraic cryptographic problem is the DLP; in con-
trast, a cryptographic problem involving a hash function
f : G → {0, 1}k (e.g., providing collision resistance) is not
algebraic. In order to analyze problem Π[G] in the generic
group model, one commonly executes the following experi-
ment. (There exist variants of the generic group model, but
the choice of the variant does not aﬀect our arguments.)
In the beginning, a random bijective encoding function

E : G → Aq := {0, . . . , q − 1}

(4)

is chosen (from the set of all possible such functions), where
Aq is naturally interpreted as a subset of {0, 1}m with m =
(cid:100)log(q)(cid:101). Set Aq can be viewed as an abstract copy of G,
but itself without any algebraic structure.
The interactive security experiment Π[G] is then executed
with the adversary where group G is substituted by Aq,

1661i.e., every appearance of a group element A ∈ G is re-
placed by the encoding E(A) of it. More precisely, if the
experiment is supposed to send A ∈ G to the adversary, it
sends A(cid:48) := E(A) ∈ Aq instead; if the adversary is sup-
posed to send A ∈ G to the experiment, it sends some value
A(cid:48) ∈ Aq instead which is interpreted by the experiment as
A = E−1(A(cid:48)). All other messages, including elements from
Zq, are exchanged unmodiﬁed. Importantly, the adversary
only sees encodings of group elements of the form E(A) but
it gets neither access to E itself nor to any group element
held by the experiment. Rather, it performs group opera-
tions through the group oracle
mult : Aq × Aq → Aq; (A
(cid:48)
Note (Aq, mult) can be considered a ‘group’ with neutral
element 1(cid:48) = E(1).

) (cid:55)→ E(E

−1(A
(cid:48)

)) .

−1(B

(cid:48)

)E

(cid:48)

, B

The intuition behind the described framework is that it
models an adversary that cannot exploit any speciﬁc prop-
erty of the underlying group G. This is a clean and well-
accepted model. It allows, for example, to prove that any
otherwise unbounded generic adversary that makes at most
t queries to the group oracle can solve the discrete logarithm
problem with probability at most O(t2/q) [22].

Generic groups for non-algebraic problems.

Once we drop the requirement that the cryptographic
problem be algebraic it becomes unclear how to adapt the
generic group model in order to obtain meaningful results.
Suppose the cryptographic problem Π[G, f ] involves hash
function f : G → {0, 1}k that takes group elements and out-
puts bit-strings such that the behavior of the function can-
not be described by group operations only (we call this a
non-algebraic function).
In fact, in such problems, func-
tion f really operates on bit-strings of some length n and
one silently assumes an encoding that represents each group
element A ∈ G as a unique bit-string of this length. It is
thus more precise to say that hash function f describes how
it acts on group elements that are represented by binary
strings. For example, if G is an elliptic curve group over
GF(p), one could set n = 2(cid:100)log(p)(cid:101) and represent group el-
ements A = (x, y) ∈ GF(p) × GF(p) in the canonic form;
further, f : {0, 1}n → {0, 1}k could be a member of the SHA
family.

How should one consider such a non-algebraic function f
in the generic group model? This turns out to be rather
unclear. The issue is that the generic group adversary only
sees elements from Aq, not from G, and yet, intuitively, any
reasonable model has to allow the adversary the evaluation
of f on group elements of its choice. Note here that one can-
not simply provide the adversary with oracle access to f via
Of (A(cid:48)) := f (E−1(A(cid:48))) since Of (A(cid:48)) may leak information
about group element A = E−1(A(cid:48)) ∈ G (as this informa-
tion could be exploited by the computationally unbounded
adversary, this would contradict the idea of the GGM). So
in order to give the adversary fair access to function f we
have to deﬁne another function f(cid:48) : Aq → {0, 1}k that some-
how mimics the behavior of f : G → {0, 1}k. The following
approach to deﬁne f(cid:48) was taken in previous generic group
proofs (e.g., [23, 5, 17, 12]). There, f : G → {0, 1}k is sim-
ply transferred, without any modiﬁcation, to Aq, i.e., the
generic group proof is carried out with respect to function

(cid:48)

: Aq → {0, 1}k, where f

(cid:48)

f

(cid:48)

(A

) := f (A

(cid:48)

) ,

(5)

instead of f . Note, however, that Aq and G are indepen-
dent, i.e., setting f(cid:48)(A(cid:48)) := f (A(cid:48)) is generally not even well-
deﬁned! But as Aq ⊆ {0, 1}m and G ⊆ {0, 1}n, they both
act on bit-strings and can usually be made well-deﬁned by
forcing Aq ⊆ G. Now, if we successfully carried out a generic
group proof with respect to function f(cid:48) deﬁned in (5), for
which concrete function f(cid:48)(cid:48) : G → {0, 1}k did we actually
prove the generic hardness of Π? Given f(cid:48) : Aq → {0, 1}k,
we can express f(cid:48)(cid:48) : G → {0, 1}k via the random bijection E
from (4) as f(cid:48)(cid:48) = f(cid:48) ◦ E = f ◦ E. Hence a generic group
proof using the approach to replace function f by f(cid:48) implic-
itly proves the hardness of Π[G, f(cid:48)(cid:48)]. Note, however, that
f(cid:48)(cid:48) = f ◦ E is necessarily an idealized object (as E is one).
It thus remains unclear how much impact a security result
on Π[G, f(cid:48)(cid:48)] has on the original problem Π[G, f ]. In partic-
ular, the generic group proof can now make use of the fact
that each group element is encoded as a unique random bi-
nary string, not only a unique binary string as motivated by
Shoup [22].

Maurer’s generic model for non-algebraic problems.

Maurer’s generic model of computation [15] diﬀers from
the one by Shoup in that the adversary never obtains rep-
resentations E(A) of group elements A, but can only access
known group elements via abstract handles. Consequently,
in this model it is unavoidable that any non-algebraic func-
tion f : G → {0, 1}k is modeled via explicit oracle access.
This solves the main problem of non-algebraic functions in
the generic group model we encountered above, namely that
it is not clear how the adversary can access function f . For
this reason we believe that Maurer’s model oﬀers a much
cleaner and rigorous way to analyze non-algebraic problems
in a generic model.

The security of ECDSA in the generic group model.
Brown provides a security proof of ECDSA in the generic
group model [5, 3], assuming f(cid:48) := f as in (5), where f is the
‘mod q’ conversion function of ECDSA. By our discussion
we can conclude that his proof implicitly considers an ide-
alized conversion function, namely ECDSA with conversion
function f(cid:48)(cid:48) = f ◦ E, which is some idealized version of the
real ‘mod q’ conversion function f .

In order to obtain a rigorous analysis of the generic secu-
rity of ECDSA, one can try to translate Brown’s proof to
Maurer’s generic model of computation. However, it remains
unclear how to setup the oracle for the conversion function.
A canonical candidate would be to give access to f ◦ E as
discussed above, but the problem is that Brown’s proofs re-
quire the conversion function to be almost-invertible, which
is arguably wrong for this function. We suspect that our
techniques can be used to restate and prove Brown’s result
in Maurer’s model of computation by deﬁning f = ψ ◦ Π ◦ φ
and providing the generic adversary oracle access to a bijec-
tive random oracle OΠ. However, we did not further look
into this, as our results imply stronger and more general
security guarantees for ECDSA. We stress that there is no
reason to believe that Brown’s proofs are ﬂawed. But, as
discussed above, their interpretation and impact to ECDSA
remain unclear.

1662