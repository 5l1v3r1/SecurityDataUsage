Policy-based Secure Deletion

Christian Cachin

IBM Research - Zurich
cca@zurich.ibm.com

Kristiyan Haralambiev

Hsu-Chun Hsiao

IBM Research - Zurich
kha@zurich.ibm.com

CyLab / CMU

hchsiao@cmu.edu

Alessandro Sorniotti
IBM Research - Zurich
aso@zurich.ibm.com

ABSTRACT

Securely deleting data from storage systems has become difﬁcult
today. Most storage space is provided as a virtual resource and tra-
verses many layers between the user and the actual physical stor-
age medium. Operations to properly erase data and wipe out all
its traces are typically not foreseen, particularly not in networked
and cloud-storage systems. This paper introduces a general cryp-
tographic model for policy-based secure deletion of data in stor-
age systems, whose security relies on the proper erasure of crypto-
graphic keys. Deletion operations are expressed in terms of a policy
that describes data destruction through deletion attributes and pro-
tection classes. The policy links attributes as speciﬁed in deletion
operations to the protection class(es) that must be erased accord-
ingly. A cryptographic construction is presented for deletion poli-
cies given by directed acyclic graphs; it is built in a modular way
from exploiting that secure deletion schemes may be composed
with each other. The model and the construction unify and gener-
alize all previous encryption-based techniques for secure deletion.
Finally, the paper describes a prototype implementation of a Linux
ﬁlesystem with policy-based secure deletion.

Categories and Subject Descriptors

D.4.3 [File Systems Management]: Access methods; D.4.3 [File
Systems Management]: File organization; D.4.6 [Security and
Protection]: Cryptographic controls

Keywords

Secure deletion; security policy; ﬁlesystem security

1.

INTRODUCTION

Modern storage systems do not include operations to reliably
destroy stored information. Common deletion operations simply
mark the occupied space as free and remove an entry from the di-
rectory, but some of the stored data may remain accessible for much
longer. A technically knowledgeable user with low-level access to
the storage system can still obtain the data. This description applies
to simple magnetic storage devices like disks or tapes, but holds as

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’13, November 4–8, 2013, Berlin, Germany.
Copyright 2013 ACM 978-1-4503-2477-9/13/11 ...$15.00.
http://dx.doi.org/10.1145/2508859.2516690.

well for networked storage services, such as storage controllers in
a data center, ﬁle servers, or cloud storage. Storage systems nowa-
days contain many layers of virtualization and perform aggressive
caching for increased performance. They leave around traces of
stored data beyond the control of the users, because such data can-
not be securely wiped out through the usual service interface.

However, users would like to control the deletion of their infor-
mation because supposedly deleted data that reappears later may
have undesirable consequences. Many companies have installed
detailed polices for retaining data and for deleting expired data;
also the Electronic Frontier Foundation recommends controlled de-
letion of data as a means to maintaining user privacy [9]. The Eu-
ropean Data Protection Directive mandates that personal data must
be erased upon request of the data subject [11].

With the advent of cloud computing, many clients who outsource
storage want to take control over the shredding of their data them-
selves. They would like to retain an element of control that lets
them erase their outsourced data from the cloud, without relying on
the cooperation of the storage service. At the same time, providers
of storage services are also interested to offer guaranteed destruc-
tion as a feature to their customers. For instance, providers would
like to erase data so that no trace of it reappears later, not even
during a forensic investigation.

In this paper, we explore the use of encryption and key man-
agement for securely deleting data. When data is stored encrypted,
only the corresponding key has to be destroyed for erasing the data.
Deleting (remote) data becomes a problem of managing and delet-
ing (local) keys. We introduce the concept of policy-based secure
deletion, where the stored data is grouped into protection classes,
and attributes control the selective erasure of data through a pol-
icy. The design relies on a master key stored in a controlled and
erasable memory, so that operations to delete data manipulate the
master key, e.g., by updating it or erasing parts of it. No bulk data
is ever re-encrypted.

This paper makes the following contributions.

• We introduce the notion of a secure deletion scheme and pro-
vide ﬁrst formal model and a security deﬁnition for encryp-
tion-based secure deletion. It uses a coercive adversary that
obtains the master key at the time of attack. The notion is
formulated in the secret-key setting, but it can be extended to
a public-key model.

• We construct a secure deletion scheme from encryption and
threshold secret sharing; it supports arbitrary policies that are
modeled as a circuit with AND, OR, and threshold gates.

• We show how secure deletion schemes can be composed in a
modular way. Our approach uniﬁes and generalizes all exist-
ing constructions for cryptographic secure deletion.

259• We present a prototype implementation of a Linux ﬁlesystem

with policy-based secure deletion.

Our encryption-based deletion methods apply to all kinds of stor-
age systems, regardless of their physical storage media, and they
can be integrated into existing systems with minimal effort. In con-
trast, solutions based on overwriting at the physical level [16, 23]
only work in close connection with the media properties. This work
aims at erasing data from large networked storage systems and as-
sumes a small, controlled, and erasable keystore. Thus, it lever-
ages physical (local) deletion to achieve secure deletion on (remote)
large-scale data stores.

1.1 Related work

Secure deletion. Many systems have been proposed which es-
sentially overwrite the data in order to delete it [16, 23]. Some
methods are very ﬂexible and can be integrated with arbitrary ﬁle-
systems [17], provided their source code is available. Recent work
has addressed solid-state storage, which requires completely dif-
ferent approaches than magnetic disks for destroying data [28, 22].
However, all solutions using overwriting depend heavily on the
properties of the underlying physical storage. With cloud comput-
ing and the virtualized storage models that are widely used today,
physical control over data-storage locations is no longer feasible.
Therefore we do not further consider secure deletion mechanisms
based on overwriting or other physical properties.

Employing encryption for the explicit goal of erasing informa-
tion goes back to the work of Boneh and Lipton [4]. Di Crescenzo
et al. [8] introduce a tree construction for efﬁcient secure deletion
of arbitrary ﬁles among a group of ﬁles. The master key at the root
of the tree is kept in erasable memory, and every key in the tree
encrypts several keys below, until the keys at the leaves encrypt the
ﬁles themselves.

Mitra and Winslett [19] describe a method for creating an in-
verted index of keywords found in stored data records. The method
uses encryption and allows to selectively delete a data record and
the corresponding keywords in the index by assuming the encryp-
tion keys can be destroyed.

Perlman’s Ephemerizer [20] employs a temporal sequence of
keys modeling different expiration times for encrypted data. The
FADE system [27] uses public-key cryptography and introduces
some simple policies with Boolean operators governing deletion.
FADE comes closest to our approach among the existing work.
The policies of FADE are restricted to one- or two-level Boolean
expressions, though, and its policies are intertwined with an im-
plementation from a particular public-key cryptosystem. In con-
trast, our work permits general policies using Boolean expressions
with threshold operators, may use generic cryptosystems, including
secret-key systems, and supplies security proofs for all construc-
tions.

Peterson et al. [21] use all-or-nothing transforms (AONT) at the
block level for secure deletion, in combination with overwriting.
The idea is to store every block through an AONT and then to over-
write only a part of it, which will render the whole block inaccessi-
ble.

Vanish [13] is a practical system for publishing content online
with an expiration date, e.g., providing secure deletion for user data
published in social networks. It encrypts the content and splits the
key using secret sharing. The shares are then maintained by a peer-
to-peer distributed system that gradually forgets the stored items
unless they are refreshed. This gives the user some control over the
expiration of his content.

Key-assignment schemes. Our approach to secure deletion is
related to monotone secret sharing schemes and to key-assignment

schemes for hierarchical access control. The survey by Crampton
et al. [6] presents a summary of the literature on key assignment.
Key assignment considers a publisher and multiple users. The pub-
lisher distributes one key to each user; every user can later derive
suitable keys that allow the user to access information according
to a hierarchical policy. The constructions may use public storage
as well [1, 7]. Many constructions and improvements are avail-
able in the literature [6, 1, 2, 5]; they may be applied to the policy
formulation and to the implementation of secure deletion schemes
described here.

Attribute-based encryption. Our work also relates to the attri-
bute-based encryption (ABE) schemes developed in the last few
years [24], especially to ciphertext-policy ABE (CP-ABE) sche-
mes [3]. Similar to CP-ABE, our policy-based secure deletion
construction maintains keys for different attributes and the dele-
tion policy is linked to the protected ﬁles. Many existing CP-
ABE constructions suffer from creating large ciphertexts, though
this deﬁciency has been removed recently [15]. While conceptu-
ally related to secure deletion in the sense that data is encrypted
in a policy-speciﬁc way, CP-ABE does not already yield secure
deletion. CP-ABE maintains a master key from which it produces
attribute-speciﬁc decryption keys. Without knowing the attributes
relevant in future decryption operations, either all such possible de-
cryption keys must be generated in advance so the master key can
be deleted or it must be kept around for generating decryption keys.
However, this either is not efﬁcient or contradicts the goal of secure
deletion under coercion, when the master key must be revealed.

1.2 Organization

Section 2 introduces our notion of policy-based secure deletion.
Multiple implementations of secure deletion schemes and the com-
position operation appear in Section 3, and Section 4 discusses their
efﬁciency and other properties. Finally, Section 5 presents a ﬁlesys-
tem with policy-based secure deletion.

2. MODEL

This section deﬁnes policy-based secure deletion schemes using

a deletion policy represented by a graph.

2.1 Selective secure deletion

The goal of a policy-based secure deletion scheme is to main-
tain, on a permanent storage medium, a collection of ﬁles and to
selectively delete some of them. Each ﬁle consists of a bit string of
arbitrary length and is protected under a protection class from a set
P, as speciﬁed by a deletion policy; the formal deﬁnition of a dele-
tion policy will be presented in the next section. A protection class
is a logical grouping of ﬁles governed by an identical deletion rule.
The universe of protection classes is denoted by P = {p1, p2, . . . }.
The scheme provides operations for protecting a ﬁle, for access-
ing a ﬁle, and for securely deleting ﬁles. Secure deletion schemes
in our model represent specialized encryption schemes and provide
cryptographic security. We model only a secret-key secure deletion
scheme, where the same key serves for protection of ﬁles and ac-
cess to ﬁles; our model applies also to public-key schemes that may
be deﬁned analogously.

At the beginning, ﬁles of all protection classes are protected un-
der an initial master key. The master key is stored in a closely
guarded erasable memory, which is kept secret from an adversary.
The master key will be changed later as a result of deletion opera-
tions. In contrast, all other data produced by the scheme is called
ciphertext and stored in immutable non-erasable memory, which is
public and exposed to the adversary at all times.

260Each protection class is deﬁned by means of attributes from a
set A of strings over a ﬁxed alphabet. Secure deletion operates on
a subset of attributes, by ensuring that protection classes subject
to those attributes become inaccessible. When a secure deletion
operation is executed, a new master key is computed and stored
in the erasable memory; the master key stored there previously is
erased. Secure deletion may also change the ciphertext, i.e., add
new ciphertext to the non-erasable memory.

2.2 Policy graph

A deletion policy graph G suitable for a secure deletion scheme
is given by a pair (V, E) with V = A ∪ P such that (V, E) is a
directed acyclic graph (DAG). It has two kinds of nodes, sources
and interior nodes. Nodes with no incoming edges (indegree zero)
are sources and correspond one-to-one to the attributes in A. All
other nodes are called interior nodes; each of them is associated
with a threshold parameter m, which is a positive integer less than
or equal to the indegree of the node. Every interior node is labeled
by a distinct protection class in P. A policy graph must contain at
least one source and one interior node, hence, the minimum policy
graph has two nodes and one edge from the source node to the
interior node.

Every node and every edge of the graph is associated to a Boolean
value. All outgoing edges from a node take the same value as the
node. The source nodes are assigned a value through the secure
deletion scheme. An interior node with threshold m and n in-
coming edges corresponds to a Boolean threshold gate with thresh-
old m: the node is TRUE whenever at least m among the n incom-
ing edges are TRUE. Notice that G has a natural interpretation as a
Boolean circuit whose sources correspond to A. Threshold nodes
subsume AND and OR gates as special cases.

2.3 Operation

Intuitively, deletion operations can be triggered by setting a sub-
set of attributes to TRUE. The corresponding source nodes in G are
then set to TRUE, which may cause some protection classes of G
to become TRUE. This means that all ﬁles protected under these
classes are deleted. Multiple secure deletion steps may follow each
other.

More precisely, secure deletion works as follows. All protection
classes are initially accessible, i.e., all source nodes and all their
outgoing edges are FALSE at the start. As the circuit is monotone,
this means that also all other nodes initially evaluate to FALSE ac-
cording to G. Hence, none of the protection classes speciﬁed has
been deleted and all ﬁles are accessible in the sense that their plain-
text can be obtained from the ciphertext with the master key. A se-
cure deletion operation takes a subset of the attributes as parameter
and changes the associated source nodes, and, consequently, some
edges in G to TRUE. Those ﬁles governed by protection classes
that change their value to TRUE are no longer accessible after the
master key has been updated. This model allows secure deletion
of many ﬁles according to the policy and the given attributes. The
attributes to delete can be speciﬁed independently of each other in
arbitrary order.

Example 1. The policy graph of Figure 1 has six attributes (resp.,
source nodes) named Alice, Bob, Project_X, Exp_2014, Exp_2015,
and Audit and six protection classes (resp., interior nodes) named
p1, . . . , p6. The latter are threshold nodes that implement binary
AND and OR gates. The attributes model users that own ﬁles with
different protection needs, a project category, expiration dates for
stored data, and a special audit need for deleting stored data.

For example, protection class p3 is governed by a policy Alice
OR Exp_2015; thus data in p3 becomes inaccessible as soon as a

Figure 1: A sample policy graph.

delete operation for protection classes owned by Alice is executed
or a delete operation for the ﬁles with expiration Exp_2015 takes
place.

Protection class p1 has policy (Alice OR Exp_2014) AND Audit.
Data protected under this class only disappears after the attribute
Alice or the attribute Exp_2014 has been deleted, and, furthermore,
after a secure deletion operation for Audit has been executed. This
might apply when data protected under p1 is more important for
retention than data under p2, as data in class p1 can be destroyed
only after an auditor has given consent to its erasure.

User Bob owns the data protected under p4, p5, and p6. The
policy dictates that classes p5 and p6 become inaccessible after se-
curely deleting the attributes Exp_2014 or Exp_2015, respectively,
or when data owned by Bob and data labeled by Project_X is se-
curely deleted. For instance, Bob might be a temporary user work-
ing on project X, and regardless of whether Bob leaves the organiza-
tion, his data must be retained until the end of the project, i.e., until
it is erased explicitly by specifying Project_X for secure deletion.
Consider the initial state and suppose a secure deletion operation
with attribute Exp_2014 is invoked. Then p2 and p5 become inac-
cessible, but p1 remains present as Audit has not been speciﬁed for
deletion. If data protected with owner Alice securely deleted later,
then p3 becomes inaccessible but p1 can still be retrieved.

2.4 System model

In a practical system supporting policy-based secure deletion,
there are two distinct kinds of storage space: erasable and perma-
nent memory. A small erasable memory forms the root of trust and
must be under close control of the system operators. It is provided,
for instance, by key-management systems, hardware-security mod-
ules (HSM), or local ﬁlesystems which support physical secure
deletion. Content that has been deleted from the erasable mem-
ory is impossible to retrieve for both legitimate and malicious par-
ties. On the other hand, permanent memory is readily available
with large capacity, but its content can neither be erased nor hidden
from an adversary. Many forms of storage encountered in practice
fall in this category, ranging from the complex storage hierarchies
of a data center to the mobile end-user devices attached to storage
back-ends in the cloud.

In this work, we consider a user with access to erasable mem-
ory and permanent memory. Her goal is to store a potentially large
number of ﬁles and to selectively delete ﬁles according to a dele-
tion policy. Information to be stored is protected, resulting in ci-
phertext being written to permanent memory. The ciphertext is
available later for accessing non-deleted ﬁles. Secure deletion op-
erations make it impossible for an adversary to retrieve the deleted
ﬁles, even if the adversary uses coercion and obtains all keys in
the erasable memory. The constructions exploit the capability to

261remove data from erasable memory. (In other words, we assume a
“bounded peek-a-boo adversary” according to Reardon et al. [23].)
We assume the adversary is passive and cannot modify data sto-
red on either type of memory. In practice, one can ensure this easily
through orthogonal data-authentication methods.

2.5 Secure deletion schemes

We now introduce the formal notion of a policy-based secure
deletion scheme. The model is cryptographic and formulated as a
secret-key scheme for simplicity.

We deﬁne a predicate deleted(G, D, p) for a deletion policy
with attributes A, policy graph G, and protection classes P that
denotes whether deleting all attributes in a set D ⊆ A implies that
the protection class p ∈ P should become inaccessible. In terms of
the Boolean circuit interpretation of G, suppose those source nodes
of G corresponding to the attributes in D are set to TRUE; then
deleted(G, D, p) denotes the value of node p in G. The notation
[a, b] for two integers a and b denotes the set of integers {a, . . . , b};
the expression [a] is short for [1, a].

Deﬁnition 1. A policy-based deletion scheme E is a tuple (Init,
Protect, Access, Delete), consisting of four probabilistic polyno-
mial-time algorithms (in terms of a security parameter κ) with the
following properties:

• Init(κ, G) → (M0, S0)

The initialization algorithm takes as inputs the security pa-
rameter κ and a policy graph G. It outputs an initial master
key M0 and initial auxiliary state S0.

• Delete(Mt, St, At) → (Mt+1, St+1)

The secure deletion algorithm takes as inputs a master key Mt,
auxiliary state St, and a set of attributes At ⊆ A, and outputs
a new master key/auxiliary state pair reﬂecting the deletion
of the supplied attributes.
Throughout the operation of the scheme, a set D ⊆ A that
contains the union of all attributes deleted so far is implicitly
maintained. That is, after t + 1 calls to Delete, it holds D =
∪t

i=0Ai.

• Protect(Mt, St, p, f ) → c

The protect algorithm takes as inputs a master key Mt, aux-
iliary state St, a protection class p ∈ P, and a ﬁle f which
is a binary string of any length, and outputs a ciphertext c.
If deleted(G, D, p) = TRUE, i.e., the protection class has
already been deleted, then c = ⊥. Otherwise, the protection
class is still accessible and c ∈ {0, 1}∗ is a protected version
of the ﬁle f .

• Access(Mt, St, p, c) → f

The access algorithm takes as inputs a master key Mt, aux-
iliary state St, a protection class p, and a ciphertext c, and
outputs a string f ∈ {0, 1}∗ or ⊥.

Whenever a master key/auxiliary state tuple (Mt, St) appears
here, we assume that Mt and St are well-formed and result from
a call to Init and a number of subsequent repeated calls to Delete.
In other words, for some Init(κ, G) = (M0, S0) and a sequence
A0, A1, . . . , At−1 of subsets of A, it holds Delete(Mi, Si, Ai) =
(Mi+1, Si+1), for i ∈ [t − 1]. Note that this assumption incurs no
loss of generality in the adversarial model considered here.

All four algorithms except for Access are usually probabilis-
tic; they output a random variable induced by their internal random
choices. In statements about particular output values of an algo-
rithm, such as in the preceding paragraphs, it is implied that these
outputs may occur with non-zero probability.

Next, we discuss the completeness and security properties of a

policy-based deletion scheme E .

Deﬁnition 2. A policy-based deletion scheme deﬁned as above is
said to be complete if any protected ﬁle can be accessed at a later
time unless it has been deleted. That is, for any t and j ≤ t, for all
p ∈ P, for all f ∈ {0, 1}∗, for all {Ai}t−1
i=0 , where Ai ⊆ A, and
all key/state tuples (Mi, Si), for i ∈ [t − 1], such that Init(κ, G) =
(M0, S0) and Delete(Mi, Si, Ai) = (Mi+1, Si+1), it holds that

Access(cid:0)Mt, St, p, Protect(Mj , Sj, p, f )(cid:1) = f.

i=0 Ai, p) = FALSE.

conditioned on deleted(G, ∪t−1

The security of a policy-based deletion scheme is deﬁned using
the following experiment for an adversary A and a security param-
eter κ.

Secure deletion experiment SecdelA,E (κ) :
1. The adversary A is given κ and outputs a policy graph G
with corresponding sets A and P for the attributes and the
protection classes, respectively. Also, the adversary outputs
a set D ⊆ A of all attributes to be deleted at the end.
Then, algorithm Init(κ, G) → (M0, S0) is executed and S0
is given to A.

2. A is given oracle access to protection and deletion operations.
In particular, the set D of deleted attributes, the index t, and
the current master key/auxiliary state pair (Mt, St) are main-
tained; A may choose inputs (p, f ) for protection and re-
ceives the output of Protect(Mt, St, p, f ); A may also spec-
ify At ⊆ D, which causes algorithm Delete(Mt, St, At) →
(Mt+1, St+1) to be invoked, then A receives St+1.

3. The adversary A outputs some p∗ ∈ P such that deleted(G,
D, p∗) = FALSE and two strings f0, f1 ∈ {0, 1}∗ of the
same length.

4. After a random bit b ← {0, 1} is chosen, a ciphertext c∗ ←

Protect(Mt, St, p∗, fb) is computed and given to A.

5. The adversary is given further oracle access to protection
and deletion operations, continued from step 2, until A stops
under the condition that deleted(G, D, p∗) = TRUE and
D = D, i.e., p∗ is inaccessible for the current set D of
deleted attributes and that set is the same as the one deﬁned
in step 1.

6. A receives the current value of Mt and outputs a bit ˆb. The

experiment returns 1 if ˆb = b and 0 otherwise.

Deﬁnition 3. A policy-based deletion scheme E is called secure
when for all probabilistic polynomial-time adversaries A, there ex-
ists a negligible function ε such that

PrhSecdelA,E (κ) = 1i ≤

1
2

+ ε(κ).

Remark. A secure deletion scheme maintains the secrecy of the
protected and deleted content. According to the security deﬁnition,
in the last step of Secdel, the adversary receives the master key. At
this point, the ﬁles protected under all classes that have not yet been
deleted are obviously exposed to A. However, any protected ﬁle
that has already been deleted is guaranteed to remain conﬁdential,
even after the master key has been leaked.

Note that the security model requires the adversary to declare
the attributes to delete upfront, before it can observe any output
produced by the scheme and adaptively choose in what order to
delete these attributes. Our security notion is similar to “selective
security” for attribute-based encryption [24, 14].

The security notion may readily be extended to cover adver-
sarial modiﬁcations to permanent memory, analogous to chosen-
ciphertext attacks against encryption schemes. As storage systems
typically protect data integrity through different means (that addi-
tionally prevent replay attacks), we omit this extension for clarity.

2622.6 Measuring efﬁciency

We will characterize implementations of secure deletion schemes
in terms of the cost incurred for executing their operations. We de-
ﬁne the deletion cost, protection cost, and access cost as the com-
plexities of running the deletion, protection, and access algorithms,
respectively. Complexities are expressed in terms of computation
steps or, more usually, through the number of calls to an encryption
primitive made by the algorithm.

We consider deletion schemes with constant deletion cost, inde-
pendent of the number of protected ﬁles, to be the most interesting.
For the constructions considered in this work, protection and access
cost do not differ, hence we are mainly interested in access cost.

Furthermore, the size of the erasable memory for storing the
master key and the permanent memory for storing the auxiliary
state are important parameters. We quantify them as the master-
key size and auxiliary-state size, respectively. Note the protected
ﬁles must be maintained outside the secure deletion scheme.

3. CONSTRUCTIONS

3.1 Prerequisites

In the constructions described below, we assume for simplicity
that master keys and auxiliary state values Mt and St, returned
by Init and Delete operations, are associative arrays indexed by
nodes and edges of G. Thus, the values St[v] and St[e] denote the
auxiliary data, if any, associated to v ∈ V and e ∈ E, respectively.
The notation St|V ′,E ′
denotes only the collection of entries of St
restricted to v ∈ V ′ ⊆ V and e ∈ E′ ⊆ E; of course, we require
E′ ⊆ V ′ × V ′ for such restrictions.

Secret-key encryption schemes. A secret-key encryption sche-
me S consists of three algorithms Keygen, Encrypt, and Decrypt.
The probabilistic key generation algorithm Keygen(κ) outputs a
key K; algorithm Encrypt(K, m) takes a key K and a plaintext m
as inputs and returns a ciphertext c; algorithm Decrypt(K, c) takes
a key K and a ciphertext c as inputs and returns a plaintext m.
We assume S is complete and IND-CPA secure according to the
standard notions.

Secret-sharing schemes. A (m + 1)-out-of-n secret-sharing
scheme denotes a method to split a secret s into n shares s1, . . . , sn
such that m + 1 or more shares are sufﬁcient to recover s, but m or
fewer shares give away no statistical information about s. The oper-
ation of sharing s is expressed by (s1, . . . , sn) ← Sharen
m+1(s),
and the algorithm to recover s from shares ¯s1, . . . , ¯sm+1 is written
as s ← Recover(¯s1, . . . , ¯sm+1). We use, for instance, the well-
known implementation based on polynomial interpolation [25].

3.2 Direct secure deletion schemes

We now introduce a class of secure deletion schemes with a par-
ticularly simple implementation of the deletion operation. We call
them direct because their deletion operation merely erases parts of
the master key that corresponds directly to the deleted attributes.

More precisely, a direct secure deletion scheme always generates
a master key Mt in the form of a tuple with exactly one component
for every attribute in A. The deletion operation for a set of at-
tributes At ⊆ A erases those components of Mt that correspond
to At. In other words, every master key Mt is an associative array
indexed by a ∈ A, where Mt[a] denotes the component corre-
sponding to a. The deletion operation for At computes Mt+1 as

Figure 2: Basic secure deletion scheme, implemented from en-
cryption and secret sharing.

Stronger security for direct schemes. Recall from Deﬁnition 3
that in the last step of its experiment, the adversary is given the
current value of the master key. Given that D is supplied by A,
the set of all attributes to be deleted eventually, in the ﬁrst step,
it is clear that the master key given to the adversary at the end is
M0|ArD . As a consequence, A can receive it in the ﬁrst rather
than last step, hence providing the adversary with more information
earlier in the experiment. We use this stronger security deﬁnition
when showing the security of direct policy-based deletion schemes.

3.3 Basic scheme

A secure deletion scheme with a very basic policy can be im-
plemented directly from a secret-key encryption scheme S and a
secret-sharing scheme.

Let G = (V, E) be a policy graph with n ≥ 1 source nodes,
connected to a single interior node that is also the only protection
class. In other words, as shown in Figure 2, the nodes V = A ∪ P
are given by a set of attributes A = {a1, . . . , an} and a set P =
{p} composed of a single protection class, and the edges are E =
{e1, . . . , en}, where ei = (ai, p) for i ∈ [n]. The interior node p
has a threshold parameter m.

We construct E = (Init, Protect, Access, Delete) as follows:
• Init(κ, G)

– For each attribute ai ∈ A select a random key Ki ←

S.Keygen(κ) and set M0[ai] ← Ki;

– Select a random key Kp ← S.Keygen(κ) and con-
struct a (n−m+1)-out-of-n secret sharing for the key,
i.e., (s1, . . . , sn) ← Sharen
n−m+1(Kp); then, com-
pute xi ← S.Encrypt(Ki, si) for i ∈ [n] and set the
initial auxiliary state to be S0[p] ← (x1, . . . , xn);

– Output (M0, S0).

• Delete(Mt, St, At)

As this is a direct secure deletion scheme, proceed as deﬁned
in Section 3.2.

• Protect(Mt, St, p, f )

If deleted(G, D, p) = TRUE, set c ← ⊥. Otherwise, let
(x1, . . . , xn) ← St[p]; for each i ∈ [n] such that ai 6∈ D
compute the share si ← S.Decrypt(Mt[ai], xi) and recon-
struct the key Kp from the shares; ﬁnally, compute c ←
S.Encrypt(Kp, f ). Output c as a protected version of the
ﬁle f .

• Access(Mt, St, p, c)

If deleted(G, D, p) = FALSE, reconstruct Kp as above and
output f ← S.Decrypt(Kp, c). Otherwise, when the pro-
tection class is inaccessible, return f ← ⊥.

The auxiliary state St contains data only for the interior node p,
i.e., the shares of the key Kp encrypted under the keys represent-
ing the n attributes. Note that the Protect and Access methods
obtain at least n − m + 1 shares for reconstructing Kp whenever
deleted(G, D, p) = FALSE; this is shown in the next theorem.

Mt+1[a] ← (⊥

if a ∈ At
Mt[a] otherwise.

Theorem 1. The direct secure deletion scheme E with a policy graph G
deﬁned above is complete and secure.

263Proof. Given the structure of G with p being an interior node with
threshold m, it follows that the predicate deleted(G, D, p) is TRUE
if and only if |D| ≥ m.

It is easy to check that the scheme is complete because as long
as deleted(G, D, p) = FALSE, fewer than m attribute keys have
been deleted; in other words, more than n − m of the keys K1,
. . . , Kn are present in the master key. Using the auxiliary data
St[p], this allows to recover more than n − m of the secret shares
s1, . . . , sn. Then the key Kp can be obtained by running algo-
rithm Recover of the secret-sharing scheme. Hence, Protect and
Access can operate on all ﬁles protected under p.

The proof that the scheme is secure proceeds in a sequence of

games [26]:

Game 0. This is the original game and its experiment is de-
ﬁned according to the security deﬁnition. Note that in the ﬁrst step
of the experiment, A is required to specify the set of attributes D
which satisﬁes deleted(G, D, p) = TRUE. As mentioned above,
this happens if and only if |D| ≥ m.

Game 1. We proceed as in the previous game except that for
each i ∈ [n] such that ai ∈ D, the Init algorithm sets xi ←
S.Encrypt(Ki, ri), for a randomly chosen ri ∈ {0, 1}|si|, and
stores these in the auxiliary state value S0[p] = (x1, . . . , xn). By
the security of the encryption scheme S and the fact that all Ki
with ai ∈ D are removed from the master key before it is revealed
to A, it holds that the adversary’s advantage changes by at most
negligible probability from the previous game.

Game 2. This game is initially the same as the previous game,
in which Init chooses a random key Kp ← S.Keygen(κ), secret-
shares it to obtain the shares s1, . . . , sn, and uses these for comput-
ing the auxiliary state. However, we also choose a different random
key K ′
p ← S.Keygen(κ) and use this key rather than Kp to protect
and access any ﬁles under p in responses to queries of A.

Recall that A will ask for at least m attributes to be deleted before
it obtains the master key. Then, by the security of the secret-sharing
scheme, the adversary cannot tell which key is secret-shared, hence
behaves like in the previous game except for a negligible differ-
ence. Also, note that the key K ′
p is completely independent from
the master key and the auxiliary state.

Game 3.

In this last game, when the adversary presents ﬁles
f0 and f1 with the same length, the challenger computes c∗ ←
S.Encrypt(K ′
p, r) for a randomly chosen r ∈ {0, 1}∗ of the same
length as the ﬁles. By the security of the encryption scheme S, the
advantage of A changes at most by a negligible amount from the
previous game. Moreover, as r is independent of f1 and f2, the
adversary cannot do better than guess the bit b at random, hence
Pr[ˆb = b] = 1
2 .

As the adversary A can guess b exactly with probability 1

2 in the
last game and her advantage changes only negligibly between every
two consecutive games, it follows that E is secure.

Note that the auxiliary state contains values neither for the at-
tributes nor for the edges incident with them. We use this prop-
erty when constructing more complex secure deletion schemes and
maintain this invariant for all direct schemes.

basic policy graphs. We consider ﬁrst the case when both schemes
are direct and relax this requirement later on.

Suppose the two secure deletion schemes are arranged in a hier-
archy as a higher and a lower scheme. The key step of the compo-
sition uses the higher secure deletion scheme to protect the master
key of the lower scheme. The protection classes applied to partic-
ular components of the lower scheme’s master key will determine
the policy graph of the resulting scheme. Importantly, the lower
master key needs no longer be stored in the erasable memory. In
this way, secure deletion operations of the higher scheme extend to
ﬁles protected with the lower scheme.

Let Eh and El be secure deletion schemes with policy graphs
Gh = (Vh, Eh) and Gl = (Vl, El), protection classes Ph and Pl,
and potentially overlapping attribute sets Ah and Al, respectively.
Apart from Ah and Al, the nodes Vh and Vl in the two graphs are
mutually exclusive. Then, a secure deletion scheme E with policy
graph G, attributes A, and protection classes P is constructed as
follows.

The composition speciﬁes two sets PJ and AJ , where PJ ⊆ Ph
and AJ ⊆ Al, as well as a map J : AJ → PJ . The map J
determines to which protection class in PJ each attribute of AJ is
joined. Also, we require that AJ ∩ Ah = ∅, i.e., the attributes to
be joined contain no attributes of Gh, so that the new policy graph
will not contain cycles. The policy graph G = (V, E) is deﬁned
as:

• V = Vh ∪ Vl \ AJ , i.e., G contains all nodes from Gh and
Gl except those attributes of Gl which are being joined to a
protection class in Gh;

• E = Eh ∪ {(u, v) | (u, v) ∈ El ∧ u /∈ AJ } ∪ {(w, v) |
(u, v) ∈ El ∧ u ∈ AJ ∧ w = J(u)}; this denotes (1)
all edges of Gh, (2) the edges of Gl not incident to nodes
in AJ , and (3) one edge (w, v) for every edge (u, v) ∈ El
with u ∈ AJ , where w = J(u) is the protection class to
which u is joined according to the composition. Note that
|E| = |Eh|+|El| and there is a one-to-one mapping between
E and Eh ∪ El determined by J and the original graph.

The attributes of E are all attributes of Gh and Gl except for those
involved in the composition, i.e., A = Ah ∪ Al \ AJ , and the set
of protection classes is the union of the present protection classes,
P = Ph ∪ Pl. An illustration of how two policy graphs are com-
posed is shown in Figure 3.

The algorithms (Init, Protect, Access, Delete) of E are com-

posed from those of Eh and El:

• E .Init(κ, G)

Compute (Mh,0, Sh,0) ← Eh.Init(κ, Gh) and
(Ml,0, Sl,0) ← El.Init(κ, Gl), and for every a ∈ A set

Mh,0[a]
Ml,0[a]
Mh,0[a] k Ml,0[a]

if a ∈ Ah and a /∈ Al,
if a /∈ Ah and a ∈ Al,
if a ∈ Ah ∩ Al,

M0[a] =


where k denotes the concatenation of two entries or tuples
into one tuple. Note that M0[a] may contain more than one
entry; in general, M0[a] is a tuple with one entry for ev-
ery edge incident to node a. For notational convenience, we
write M0[a][v] for the entry in M0[a] that corresponds to the
speciﬁc edge from a to v.
The initial auxiliary state stores no data for the attributes in
our constructions.1 For every protection class p ∈ V , the

3.4 Composition

Two secure deletion schemes can be composed into a more elab-
orate scheme whose policy graph results from combining the two

1This may not necessarily be true for other constructions; should
that be the case, auxiliary data for AJ speciﬁed by the composition
map can be stored either in the auxiliary data of the nodes to which

264auxiliary data S0[p] is simply Sh,0[p] or Sl,0[p] respective to
whether p ∈ Vh or p ∈ Vl.
As there is one-to-one mapping between E and Eh ∪ El,
we consider every edge e = (u, v) ∈ Eh ∪ El and deﬁne
the initial auxiliary state of its corresponding edge in E as
follows:

– S0[(u, v)] = Sh,0[(u, v)], if (u, v) ∈ Eh;
– S0[(u, v)] = Sl,0[(u, v)], if (u, v) ∈ El ∧ u /∈ AJ ;
– S0[(w, v)] = Sl,0[(u, v)] k

Eh.Protect(Mh,0, Sh,0, w, Ml,0[u][v]),
if (u, v) ∈ El for u ∈ AJ and w = J(u),

where w ∈ PJ is the protection class to which u ∈ AJ is
joined. That is, all edges in E which are also present in Eh
or El keep their initial auxiliary state unchanged. The edges
from a node w ∈ Vh to a node v ∈ Vl store the auxiliary
data of (u, v) and the master-key component from El related
to (u, v) protected under w with Eh; here, u ∈ Vl is the at-
tribute which was joined to w such that the edge (u, v) ∈ El
corresponds to (w, v) ∈ E. Note that in our construction,
edges adjacent to the attributes have no auxiliary data; thus,
in the last case, S0[(w, v)] = Eh.Protect(Mh,0, Sh,0, w,
Ml,0[u][v]).
Protecting the components of the master key from the lower
scheme with the higher scheme represents the main mecha-
nism of the composition. It is also the building block for the
hierarchical implementation of secure deletion schemes with
arbitrary policy graphs, as explained in Section 3.5.

• E .Delete(Mt, St, At)

Execute Eh.Delete(Mt|Vh ,Eh , St|Vh ,Eh , At ∩ Ah) and
El.Delete(Mt|Vl ,El , St|Vl,El , At∩Al), and update the mas-
ter key and auxiliary state accordingly. Recall that when a
scheme is direct, the deletion operation does not change the
auxiliary state but only deletes part of the master key; hence,
the deletion operations are trivial.

• E .Protect(Mt, St, p, f )

If p ∈ Ph, then c ← Eh.Protect(Mt|Vh ,Eh , St|Vh ,Eh , p, f ).
Otherwise, when p ∈ Pl, we reconstruct Ml,t by computing
for a ∈ Al:

– If a /∈ AJ , then Ml,t[a] = Mt[a];
– If a ∈ AJ , then Ml,t[a] is computed as the concatena-

tion of all Eh.Access(Mt|Vh ,Eh , St|Vh ,Eh , w, St[(w, v)])
for (a, v) ∈ El,

where w = J(a). Then, compute c ← El.Protect(Ml,t,
St|Vl ,El , p, f ). Note that any node u ∈ Vl and any edge
(u, v) ∈ El, where u ∈ AJ , are not present in G; hence,
they are not deﬁned in St and its restriction St|Vl ,El . This
agrees with the invariant deﬁned in the last section that a di-
rect secure deletion scheme stores no data in the auxiliary
state for attributes and edges incident with them.2 Return c.

• E .Access(Mt, St, p, c):

This operation proceeds analogously to Protect:

– If p ∈ Ph, then compute f ←

Eh.Access(Mt|Vh ,Eh , St|Vh ,Eh , p, c);

– If p ∈ Pl, then reconstruct the master key Ml,t of El
as described in the E .Protect algorithm and compute
f ← El.Access(Ml,t, St|Vl ,El , p, c).

Finally, return f .

they are joined or in the new edges created in the composition, i.e.,
those in case (3) described above.
2In the general case, when there is auxiliary data associated with
attributes or their adjacent edges, we adjust the reconstruction of
Ml,t and Sl,t easily to match the modiﬁcation needed in that case
as described in the Init algorithm.

Figure 3: Two policy graphs (Vh, Eh) and (Vl, El) on the top
are combined to (V, E), shown below. Note that AJ = {x, u}
and PJ = {w, z}, and the composition map speciﬁes J(x) = z
and J(u) = w. Only the edges of case (3) in E .Init are drawn
here; the remaining edges are omitted and not affected by the
composition.

Theorem 2. The above policy-based secure deletion scheme E is
direct, complete, and secure if Eh and El are direct policy-based
secure deletion schemes,

Proof. It is easy to show that E is complete from the fact that Eh
and El are complete and from the way they are composed.

The proof of security proceeds in a sequence of games. In each
game, we modify slightly further E when an algorithm B plays the
role of a challenger in the experiment SecdelA,E (κ) against an ad-
versary A attacking E by running the experiments SecdelB,Eh (κ)
and/or SecdelB,El (κ); note that B plays the role of a challenger
against A for E and the role of an adversary for Eh and/or El.

Game 0. The experiment SecdelA,E (κ) proceeds according to

its deﬁnition for the E deﬁned above.

Game 1. The simulator B performs the experiment SecdelB,Eh (κ)

in the role of the adversary, while simulating SecdelA,E (κ) for
A. The scheme E is modiﬁed to use oracle access to protection
and deletion operations for Eh, and every time A moves from one
step to the next in her experiment SecdelA,E (κ), so does B in
SecdelB,Eh (κ).

In particular, for a set D given by A in the ﬁrst step of her ex-
periment, B outputs Dh ← D|Vh ,Eh in the ﬁrst step of his experi-
ment. The E .Init algorithm computes the auxiliary state as deﬁned
with the exception that B runs only (Ml,0, Sl,0) ← El.Init(κ, Gl),
whereas Sh,0 is obtained from the challenger in his experiment; at
any time, the respective induced calls to Eh.Delete, Eh.Protect,
and Eh.Access are replaced by oracle calls provided to B by the
challenger of SecdelB,Eh (κ).

This game is indistinguishable to A from the previous one as
the only difference is the way B handles the recursive calls to Eh

265which are perfectly simulated from the experiment B runs against
his challenger.

Game 2. This game is identical to the previous one except for
computing the auxiliary state for edges in case (3) in the E .Init algo-
rithm (see Figure 3). Previously, the auxiliary value for the edge in
G corresponding to (u, v) ∈ Eh ∪ El, for u ∈ AJ , was computed
as S0[(w, v)] = Eh.Protect(Mh,0, Sh,0, w, Ml,0[u][v]), where
(u, v) ∈ El for u ∈ AJ and w = J(u).

For the same u ∈ AJ and w = J(u), if deleted(G, D, w) =

TRUE, this is modiﬁed to:

S0[(w, v)] = Eh.Protect(Mh,0, Sh,0, w, r),

for a randomly chosen r ← {0, 1}∗ of the same length as the cor-
responding key component.

This game is indistinguishable to A from the previous one except
for a negligible probability due to the security of Eh; in particular,
for protection classes which are deleted before the master key is
revealed, A cannot distinguish between a chosen value or a random
value being protected under such a class.

Game 3. The simulator B performs the experiments SecdelB,Eh (κ)

and SecdelB,El (κ) while simulating SecdelA,E (κ) for A. In the
ﬁrst step of the main experiment, A returns a set D, from which B
derives his set Dh ← D|Vh ,Eh for the SecdelB,Eh (κ) experiment
as before; for the experiment SecdelB,El (κ), Dl is computed as the
union of all attributes a ∈ Al such that:

• a /∈ AJ ∧ a ∈ D; or
• a ∈ AJ ∧ deleted(G, D, J(a)) = TRUE.

That is, all attributes of Al which are present in G and belong to D
or which are attributes joined in the composition and whose protec-
tion classes from Gh become inaccessible when all attributes from
D are deleted. Once B returns Dh and Dl in the ﬁrst step of the re-
spective experiments against his challengers, he is able to compute
M0, S0 for E as deﬁned in the previous game. As before, every
time A moves from one step to the next in her experiment so does
B for his.

This game is indistinguishable to A from the previous one as the
only difference is the way B handles the respective induced calls
to El which are perfectly simulated from experiment that B runs
against his challengers.

Note that in the last game B simulates SecdelA,E (κ) perfectly
without the knowledge of Mh,0 and Ml,0 using only oracle ac-
cess provided by SecdelB,Eh (κ) and SecdelB,El (κ). Hence, any
adversary A winning SecdelA,E (κ) with non-negligible advantage
implies an adversary B which can break the security of Eh or El.
Therefore, if Eh and El are secure, so is the composed E .

Next, we observe that we can relax the requirement that Eh is a
direct scheme if Eh and El share no attributes; note this implies Vh∩
Vl = ∅ as the composition requires that the nodes of both graphs
are disjoint except for the attributes. Hence, one may compose
an arbitrary policy-based secure deletion scheme Eh with a direct
scheme El.

Theorem 3. Let Eh and El be policy-based secure deletion schemes,
where El is direct. If Vh ∩ Vl = ∅, the two schemes can be com-
posed as described above and the resulting scheme E is complete
and secure.

Proof. The construction above and proof do not utilize the fact that
Eh is direct except for the possibility that Eh and El share attributes.
Thus, if Ah ∩ Al = ∅, the result follows analogously.

3.5 Direct policy-graph construction

One may use the basic secure deletion scheme of Section 3.3
and the composition operation to implement direct secure deletion
schemes for arbitrary policy graphs. Recall that every DAG G =
(V, E) has a topological order, computable in time O(|V | + |E|),
which arranges the nodes of G in a sequence that respects the di-
rection of all edges.

We traverse G in the topological order and gradually build up a
secure deletion scheme for G. Initially we take the ﬁrst encoun-
tered interior node v0 and implement a secure deletion scheme for
v0 according to the basic scheme of Section 3.3. Subsequently,
whenever we encounter the next interior node v, we take the sub-
graph Gv induced by v and its incoming edges, implement a basic
secure deletion scheme for Gv according to Section 3.3, and com-
pose it with the secure deletion scheme realized so far.

The resulting secure deletion scheme for G implicitly contains a
key for every node and a key for certain edges. More precisely, for a
source node (attribute) a, the key Ka is explicitly stored in the mas-
ter key and has one entry for every outgoing edge; for any interior
node (protection class) p with n incoming edges and threshold m,
the key Kp is stored encrypted as follows. For every incoming
edge (v, p), except for those incident to an attribute, the auxiliary
state contains an encryption of a key Kv,p under the key Kv, which
corresponds to node v. In turn, the auxiliary state associated to p
contains a vector (xp,1, . . . , xp,n), where some xp,j is associated
to v and represents an encryption of sp,j under Kv,p. The value
sp,j is a share of Kp in a (m + 1)-out-of-n secret sharing scheme.
Thus, every node in G is associated with one encryption key
and every edge in G not incident to a source is also associated
with one encryption key. The resulting structure is an iterative key-
encrypting key-assignment scheme (IKEKAS) according to Cramp-
ton et al. [6].

The access cost is proportional to the size of G. More precisely,
accessing a node p needs a maximum of two secret-key crypto-
graphic operations for every edge that must be traversed (i.e., set to
TRUE), in order to derive p (i.e., set p to TRUE). The master key
contains one component for every attribute and the total size of the
auxiliary state is in O(|V | + |E|).

Observe that one may eliminate the encryption keys associated to
the edges and encrypt the share of a child node directly with the key
of the parent node. This reduces the number of cryptographic oper-
ations without impacting the security of the construction. However,
the resulting scheme cannot obtained from the modular composi-
tion operation in Section 3.4, and a detailed security proof is left
for future work.

Furthermore, the master key component for an attribute a, the
key Ka, is a tuple of keys with one entry for every outgoing edge.
This is done so that the resulting secure deletion scheme is the
same, regardless of which topological order is used during com-
position, as the edges adjacent to attributes are used in a special
way in the composition. However, once constructed, one can re-
place the tuple Ka with a single key K ′
a, and for every edge (a, p)
store the key Ka,p protected with K ′
a in the auxiliary state of the
edge (a, p), as done for all other edges; this reduces the master-key
size.

3.6 Tree construction

In early work on secure deletion, Di Crescenzo et al. [8] intro-
duce a tree construction that protects data in an arbitrary number of
emulated memory locations. The scheme is realized from persistent
storage exposed to an adversary and allows to overwrite individual
memory locations. Only a small erasable memory of constant size
is needed for maintaining a master key.

266Using our terminology, their scheme permits n protection classes
p1, . . . , pn and each one can be speciﬁed for deletion indepen-
dently of the others. The deletion policy graph consists of n at-
tributes a1, . . . , an, the n protection classes p1, . . . , pn, and n edges
(ai, pi) for i ∈ [n].

A balanced tree with n leaves, labeled by p1, . . . , pn, is con-
structed as follows. First, a key Kv of a secret-key encryption
scheme is generated, ranging over all nodes v in the tree. Next,
for every node v, the keys of all children of v are encrypted with
Kv and the resulting ciphertext is added to the auxiliary state asso-
ciated to v. The key of the root node represents the master key; is
not stored in the auxiliary state.

For protecting or for accessing a ﬁle under protection class pi, all
keys along the path from the root to pi are decrypted, starting from
the root, and Kpi is used to encrypt or decrypt the ﬁle, respectively.
Deletion for attribute ai makes all data protected under pi inac-
cessible. This operation is implemented by generating fresh keys
for all nodes on the path from the root to pi in the tree. More pre-
cisely, the keys of all nodes and their siblings along this path are
ﬁrst decrypted, then a fresh key is generated for every node on the
path except for pi, and ﬁnally all fresh keys are encrypted under
the fresh key of the respective parent node and stored in the auxil-
iary state. The fresh root key is written to the master key and the
previous root key is deleted in the erasable memory.

Clearly, this construction represents a secure deletion scheme,
which can be proved secure assuming a secret-key cryptosystem
along the lines of the existing proof [8]. The access cost of the
scheme as well as its deletion cost are O(log n) secret-key opera-
tions. The erasable memory contains only one key of the secret-key
encryption scheme as the master key and the auxiliary state is of
size O(n).

3.7 Time-tree construction

Our model and the tree construction above make no assumption
about the order in which attributes are deleted. However, one may
sometimes exploit such restrictions. Consider a sequence of at-
tributes a1, . . . , an modeling expiration time such that any ai can
only be deleted if a1, . . . , ai−1 have been deleted beforehand. This
property gives way to build a more efﬁcient scheme.

More precisely, consider a deletion policy graph consisting of at-
tributes a1, . . . , an, protection classes p1, . . . , pn, and edges (ai,
pi) for i ∈ [n], which represent an ordered sequence of time units
from [n]. We want to support deletion only as ordered by time, and
we want to support an efﬁcient operation that deletes multiple sub-
sequent units at once. To this end, we construct a balanced tree over
the leaves p1, . . . , pn, design a master key of size O(log n), but
use no auxiliary storage. The leaves of the tree represent the time
units in a left-to-right order. The key of a node is computed from
its parent’s key using a pseudo-random function (PRF), where the
parent’s key serves as the PRF key and the input denotes whether
the node is a left or right child. The root node’s key is chosen uni-
formly at random. The master key consists of the key of the leaf
corresponding to the earliest non-deleted time unit and the keys of
all right siblings on the path from the root to that leaf. This way,
only the keys for time units following the last deleted one can be
derived. Storing only right-siblings like this is a well-known tech-
nique [18] to achieve forward-secure cryptosystems without chang-
ing the public key of an encryption scheme.

The deletion for the attribute at updates the master key to contain
the key for the leaf pt+1 and the keys of all right siblings on the path
from the root to that leaf; keys for all time periods greater than t can
be derived from the master key in time O(log n) from the stored
right-siblings. Deleting an arbitrary attribute at and all attributes

preceding it takes O(log n) cryptographic operations, though the
amortized cost is only O(1) if the attributes are deleted one by one.
Hence, this tree construction is superior to the previous one both
for deleting time units in order and for deleting in arbitrary incre-
ments.

3.8 Combined construction

Recall that for composing two secure deletion schemes with The-
orem 2, only the lower scheme must be direct. Therefore, we can
combine the tree construction of Section 3.6 with the direct scheme
of Section 3.5 to obtain a secure deletion scheme with some at-
tributes organized in a tree, as described above, whereas the rest
are organized using a direct scheme. This is useful for modeling a
case where many attributes are values from a large set or interval,
such as user identities or dates.

One can further combine two or more such tree constructions
trivially through logical expressions if the attributes in the trees
are all distinct. In this way, we can compose many separate tree
schemes with a direct scheme to obtain an elaborate and practical
secure deletion scheme. The prototype implementation described
later follows this approach.

4. PROPERTIES

4.1 Efﬁciency of the schemes

In Table 1, we present a comparison of the direct graph and tree
schemes described, respectively, in Section 3.5 and Section 3.6;
as well as two obvious “trivial” constructions, discussed next. As
mentioned earlier, the protection cost is the same for all schemes
considered in this paper.

The ﬁrst trivial scheme uses a separate key for each protection
class. This results in a large master secret key but achieves fast
deletion operations. The Ephemerizer [20], for instance, encrypts
all ﬁles with a particular expiration time with the same time-speciﬁc
key, and Vanish [13] encrypts every user-data object with an in-
dependent key. Likewise, the Data Node Encrypted Filesystem
(DNEFS) [22] uses this approach for protecting every data node
of the ﬂash ﬁlesystem independently.

The second trivial scheme implements a tree of depth one:

it
uses a single encryption key as a master key and one encryption
key for each protection class; the master key is used to encrypt the
keys of the protection classes and the ciphertexts are stored in the
auxiliary state. Deletion requires the re-encryption of all remaining
protection-class keys with a new master key. This scheme appears,
e.g., in the extension of DNEFS to an encrypted ﬁlesystem [22].
Note that removing this level of indirection, and using the master
key to protect the ﬁles directly, would result in much worse deletion
performance, as the number of ﬁles is typically much greater than
the number of protection classes.

The operational cost of our direct policy-graph secure deletion
scheme is determined by the parameters of its graph, namely, the
maximum in-degree d of a node and the longest path ℓ. The main
advantages of this scheme are its fast deletion operation coupled
with its high expressibility. Unlike the other schemes, which con-
sider only protection classes mapped one-to-one to attributes, the
policy-graph scheme allows ﬂexible policies formulated through
logical expressions over attributes. In practice, d and ℓ will often
be small numbers, though in O(|A|) and O(|P|), respectively.

4.2 Relation to secret-key encryption

Every secure deletion scheme is also a secret-key cryptosystem
with security against chosen-plaintext attacks. We only sketch this
relation here; adding the formal details is straightforward.

267Scheme
Trivial direct
Trivial tree
Direct graph
Tree
Time-tree∗

Deletion cost Access cost Master-key size

O(1)
O(|P|)
O(1)

O(log |P|)

O(1)

O(1)
O(1)

O(d · ℓ)

O(log |P|)
O(log |P|)

O(|P|)
O(1)
O(|A|)
O(1)

O(log |P|)

Table 1: Efﬁciency comparison. |A| and |P| denote the number
of attributes and protection classes in the policy graph, d is the
maximum in-degree of a node, and ℓ is the longest path in the
graph. ∗ The time-tree supports only deletion going forward in
time; its amortized deletion cost is O(1) and O(log |P|) in the
worst case.

Recall that a secret-key cryptosystem S consists of three algo-
rithms for key generation, encryption, and decryption, respectively.
The following steps emulate S from a secure deletion scheme E :

1. Let G1 be the minimal policy graph with one attribute a,
one protection class p, and one edge from a to p. For key
generation in S, run the initialization algorithm of E with G1
and use its output as the secret key.

2. For encryption of a plaintext m with S, invoke the protection
algorithm of E on p and m, obtain a ciphertext c, and output
(p, c).

3. For decrypting a ciphertext (p, c) of S, invoke the access al-

gorithm of E , and output the response.

We claim that S is a secret-key cryptosystem with indistinguish-
able ciphertexts under chosen-plaintext attacks (IND-CPA secu-
rity). To see this, suppose S is not secure. Then we construct
a simulator SIM that contradicts the security of E in experiment
Secdel, by interacting with an adversary AS that breaks the secu-
rity of S.

The simulator executes the operations of S according the de-
scribed emulation of S from E ; note that SIM does not call Delete.
When AS outputs two plaintexts m0 and m1 such that one is to
be encrypted as challenge, the simulator outputs p, m0, and m1.
Then Secdel responds with a ciphertext c∗ that contains a repre-
sentation of mb, where b ∈ {0, 1}. According to the emulation of
S, the simulator gives (p, c∗) to AS . When AS outputs a bit ˆbS
as its guess for the challenge plaintext, then SIM queries its oracle
for the deletion operation with attribute set {a}, ignores the master
key that it receives, and outputs ˆbS . Note that SIM emulates the
IND-CPA security experiment perfectly. By the assumption that
AS breaks the indistinguishability of ciphertexts of S, it follows
that Pr[SecdelSIM,E (κ) = 1] − 1
2 is not negligible. Hence, E is not
a secure policy-based deletion scheme.

5. PROTOTYPE IMPLEMENTATION

Here we describe a ﬁlesystem prototype of a policy-based secure
deletion scheme according to Sections 2 and 3. The secure-deletion
ﬁlesystem (delfs) is implemented as an extension to EncFS [10], a
virtual cryptographic ﬁlesystem in Linux based on FUSE [12]. As a
virtual ﬁlesystem, delfs does not handle space allocation itself, just
like EncFS, but acts as a transparent protection layer and projects
the stored directories and ﬁles with the same structure onto a lower-
layer (physical) ﬁlesystem.

5.1 Overview

Data stored in delfs seamlessly beneﬁts from secure deletion. To-
gether with every instance of a delfs-mounted directory tree, the
user speciﬁes a deletion policy in the format described later. Every
ﬁle maintained by delfs is associated with a protection class and

Figure 4: delfs architecture.

protected accordingly. A ﬁle can be accessed as long as its protec-
tion class is accessible according to the deletion policy.

As shown in Figure 4, three directories are involved in operating
a delfs ﬁlesystem. First, secure_dir contains the master key of delfs
and must be backed by erasable memory. It should be accessible
only to the process running delfs and protected against exposure to
any other entity during operation. In practice, it may be a POSIX-
compatible local ﬁlesystem that supports physical secure deletion
and that is never backed up. The delfs prototype uses a small ext2-
formatted partition on a magnetic disk that supports secure deletion
through in-place updates and free-space ﬁlling [23]. Second, bulk
storage is provided by raw_dir, which represents the non-erasable
memory such as a NAS server or cloud storage; only protected ver-
sions of ﬁles and auxiliary data reside here. Finally, the user stores
and accesses protected ﬁles through mount_dir.

When a delfs directory is mounted for the ﬁrst time, an initializa-
tion ﬁle has to be provided as well, which speciﬁes the initial dele-
tion policy and its attributes. All ﬁles written to mount_dir beneﬁt
from secure deletion. Files can be securely deleted by running a
dedicated delfsctl utility and specifying attributes to delete. This
securely deletes ﬁles according to the deletion policy such that an
adversary can no longer recover them later. The adversary might
obtain the contents of secure_dir afterwards and see all data that
has ever been written to raw_dir, but can no longer infer anything
about the data in the deleted ﬁles.

5.2 Attributes and policy speciﬁcation

In order not to burden the user with specifying a deletion pol-
icy graph that may contain hundreds or thousands of possible at-
tributes, delfs implements only restricted deletion policies com-
pared to the model of Section 2. We argue below that these are
sufﬁcient for practical purposes.

All attributes in delfs are partitioned into attribute types such that
every attribute occurs in one type. Types represent the categories
relevant for secure deletion, such as owners, projects, organiza-
tions, or expiration dates. For each attribute type, many different
attribute values can be speciﬁed through enumeration of strings or
by giving a range for numeric attributes. A range is expanded into
an enumeration. A sample delfs attribute speciﬁcation in the initial-
ization ﬁle might look like this (written in libConfig++ syntax):

types = (

{

{

name = "user";
attributes = ["Alice", "Bob", "Charlie"];
implementation = "simple";

},

name = "project";

268invoked. These are further combined according to the delfs policies
through the policy-graph construction in Section 3.5. The resulting
scheme implements the combined model of Section 3.8.

When delfs is invoked for the ﬁrst time on a particular mount
point, the initial policy must be given. The current policy, some
defaults, and auxiliary state are then stored in a system-wide state
ﬁle in the root of raw_dir. Information speciﬁc to a ﬁle, such as
its attribute values, the applicable policy, and the encrypted ﬁle-
encryption key, are stored together with the ﬁle itself in its extended
attributes.

Once the ﬁlesystem is mounted, every new ﬁle created inside
mount_dir is protected according to the policy. The ﬁle takes its
initial attribute values and policy from a special defaults ﬁle, lo-
cated inside the directory where the ﬁle will reside; note that FUSE
makes it possible to obtain the pathname when creating a ﬁle. If
the defaults ﬁle is not present, parent directories in the path to
mount_dir are searched; if no ﬁle defaults ﬁle is found, the system-
wide initial policy stored in raw_dir is applied. An example delfs
defaults ﬁle may contain:

Figure 5: An illustration of the two delfs policies preferred and
conﬁdential as described in the text. The attribute type expira-
tion uses the tree implementation, indicated by the triangle.

attributes = ["X", "Y", "Z"];
implementation = "simple";

},

{

name = "expiration";
attributes = ["2000", "2099"];
specification = "range",
implementation = "tree";

} );

attributes = ["project=X", "expiration=2013"];
policy = "confidential";

Here, attribute type expiration is speciﬁed as a range, and this
simply maps to an enumeration of the 100 different attributes. The
meaning of implementation is explained in the next section. The
attribute types in delfs model the familiar convention that objects
have typed attributes and that every attribute can have only one
value (for example, attributes of a POSIX ﬁle in the stat structure
or attributes in a tuple of a relational database).

The deletion policy is given as a collection of policies, where
each policy has a name and is represented by a logical expression
over the attribute types, using AND and OR operators. By instanti-
ating every attribute type with all of its possible values, each policy
maps to many different multiple protection classes. Hence, the ex-
act protection class is deﬁned by the policy and the attribute values
associated to a ﬁle. Below is a sample delfs deletion policy from
the initialization ﬁle, as shown in Figure 5:

policies = (

{

{

name = "preferred";
expr = "((user AND project) OR expiration)"; },

name = "confidential";
expr = "(expiration AND project)";

} );

When a ﬁle stored with policy preferred has attributes user =
Bob, project = X, and expiration = 2014, this corresponds to
protection class p5 in the graph of Figure 1. Compared to the dele-
tion policy graph in Section 2, delfs policies support only AND and
OR gates. We discuss how attribute values are associated to ﬁles
below.

5.3 Implementation

delfs implements the constructions of Section 3, with the excep-
tion of threshold gates and the time-tree scheme. The master key
structure M is stored in secure_dir, whereas the auxiliary state S
and all protected data reside in permanent memory under raw_dir.
Every ﬁle stored in delfs is associated to one policy. If more ﬂexi-
bility is required, the policy graph should be extended.

A delfs attribute type with simple implementation corresponds to
a direct secure deletion scheme with one protection class for every
delfs-attribute value according to Section 3.3. For delfs attribute
types with tree implementation, which are typically those with a
large number of attribute values, the construction of Section 3.6 is

The user can perform regular ﬁlesystem operations on the ﬁles
under delfs without affecting their deletion policy, as long as these
operations leave the extended attributes intact.

Deletion-speciﬁc operations are done through a delfsctl admin-
istrative tool. In particular, (1) it performs secure deletion opera-
tions according to one or more given attributes and may update se-
cure_dir during this operation; (2) it can reclaim space in raw_dir
for ﬁles that have been deleted according to the policy and there-
fore have become inaccessible; and (3) it can manipulate the delfs
policy and modify the attributes of existing ﬁles. However, the
policy graph can only be extended. As this is, strictly speaking,
not captured in our cryptographic model, we note that by allowing
only extensions, each subsequent policy contains also the previous
ones; hence, the security analysis for the latest policy captures also
the previous states.

When delfs starts, it reads the master key from a ﬁle in secure_dir
and buffers it in the daemon during operation. For every secure
deletion operation, delfs ﬁrst updates the auxiliary state and writes
it back to raw_dir; then it updates the master key and overwrites
the ﬁle in secure_dir with the changed contents.

Note that the design so far has no provision for securely delet-
ing a directory and all its subdirectories. This can be achieved as
follows. A predeﬁned attribute named PARENT exists and can be
used to formulate policies. The attribute may occur directly in a
deletion policy. It represents the presence, in the ﬁlesystem, of the
parent directory of a ﬁle, such that deleting that directory through
a ﬁlesystem command triggers a secure deletion operation for the
attribute PARENT on the children of the directory. Its implementa-
tion uses the tree construction of Section 3.6 with the topology of
the ﬁlesystem tree and metadata maintained in per-directory state
ﬁles. All delfs operations that modify the directory tree may thus
implicitly modify the auxiliary state.

5.4 Evaluation

The prototype uses AES-256 for secret-key encryption in the
delfs-speciﬁc code and the “standard conﬁguration” of EncFS with
AES-192 encryption. For the policy described in Figure 5, delfs
has a master key composed of 7 encryption keys. The auxiliary
state stores one ciphertext per edge and two ciphertexts per inte-
rior node plus the auxiliary data for the expiration tree, i.e., 201
ciphertexts in total with a binary tree of depth 7; all ciphertexts are

269encryptions of 256-bit AES keys. Every read and write operation
has an overhead of 8 AES operations for the conﬁdential protection
class and of 12 AES operations for the preferred protection class,
whereby all paths leading to the protection class’ node are evalu-
ated in the straightforward manner. In principle, the key-derivation
could be optimized only for the necessary nodes; however, delfs re-
sorts to caching and evaluates the whole graph only once at mount
time. Every delete operation merely removes entries from the mas-
ter key for the direct policies, performs the re-encryptions (in the
auxiliary storage) for each of the 7 levels of the policy tree, and up-
dates the root key stored in the delfs master key. The master key ﬁle
is overwritten with the master key from the cached representation
to complete the deletion operation.

The actual time incurred for secure deletion mainly depends on
the choice of storage medium for the master key. When using
a small ext2-formatted partition, one should also ﬁll the ﬁlesys-
tem with arbitrary data, in order to overwrite any potentially freed
blocks from the master-key ﬁle. Measuring the performance of
reading and writing ﬁles protected with EncFS and delfs shows that
delfs introduces only a negligible overhead, as the encryption and
decryption of the payload dominates the read and write operations.

Acknowledgments

We thank Robert Haas, Alexis Hafner, and Anıl Kurmu¸s for inter-
esting suggestions and discussions about this topic.

This work has been supported in part by the European Union’s
Seventh Framework Programme (FP7/2007–2013), grant number
ICT-257243 TCLOUDS.

6. REFERENCES
[1] M. J. Atallah, M. Blanton, N. Fazio, and K. B. Frikken.

Dynamic and efﬁcient key management for access
hierarchies. ACM Transactions on Information and System
Security, 12(3), 2009.

[2] M. J. Atallah, M. Blanton, and K. B. Frikken. Incorporating
temporal capabilities in existing key management schemes.
In Proc. 12th European Symposium On Research In
Computer Security (ESORICS), volume 4734 of Lecture
Notes in Computer Science, pages 515–530. Springer, 2007.

[3] J. Bethencourt, A. Sahai, and B. Waters. Ciphertext-policy
attribute-based encryption. In Proc. 28th IEEE Symposium
on Security & Privacy, pages 321–334, 2007.

[4] D. Boneh and R. Lipton. A revocable backup system. In

Proc. 6th USENIX Security Symposium, 1996.

[5] J. Crampton. Practical and efﬁcient cryptographic

enforcement of interval-based access control policies. ACM
Transactions on Information and System Security, 14(1),
2011.

[6] J. Crampton, K. M. Martin, and P. R. Wild. On key

assignment for hierarchical access control. In Proc. 19th
IEEE Computer Security Foundations Symposium (CSF),
pages 98–111, 2006.

[7] A. De Santis, A. L. Ferrara, and B. Masucci. Efﬁcient
provably-secure hierarchical key assignment schemes.
Theoretical Computer Science, 412:5684–5699, 2011.

[8] G. Di Crescenzo, N. Ferguson, R. Impagliazzo, and
M. Jakobsson. How to forget a secret. In Proc. 16th
Symposium on Theoretical Aspects of Computer Science
(STACS), volume 1563 of Lecture Notes in Computer
Science, pages 500–509. Springer, 1999.

[9] Electronic Frontier Foundation. Surveillance self-defense

project. https://ssd.eff.org/, 2013.

[10] EncFS. EncFS encrypted ﬁlesystem.

http://www.arg0.net/encfs.

[11] European Parliament and Council. Protection of individuals

with regard to the processing of personal data and on the free
movement of such data. Directive 95/46/EC, 1995.

[12] FUSE. Filesystem in userspace.

http://fuse.sourceforge.net/.

[13] R. Geambasu, T. Kohno, A. A. Levy, and H. M. Levy.

Vanish: Increasing data privacy with self-destructing data. In
Proc. 18th USENIX Security Symposium, 2009.

[14] V. Goyal, O. Pandey, A. Sahai, and B. Waters.

Attribute-based encryption for ﬁne-grained access control of
encrypted data. In Proc. 13th ACM Conference on Computer
and Communications Security (CCS), pages 89–98, 2006.
[15] S. Hohenberger and B. Waters. Attribute-based encryption

with fast decryption. In Public Key Cryptography, pages
162–179, 2013.

[16] N. Joukov, H. Papaxenopoulos, and E. Zadok. Secure

deletion myths, issues, and solutions. In Proc. 3rd
International IEEE Security in Storage Workshop (SISW),
2005.

[17] N. Joukov and E. Zadok. Adding secure deletion to your

favorite ﬁle system. In Proc. 3rd International IEEE Security
in Storage Workshop (SISW), 2005.

[18] H. Krawczyk. Perfect forward secrecy. In Encyclopedia of

Cryptography and Security. 2005.

[19] S. Mitra and M. Winslett. Secure deletion from inverted

indexes on compliance storage. In Proc. Workshop on
Storage Security and Survivability (StorageSS), pages 67–72,
2006.

[20] R. Perlman. File system design with assured delete. In Proc.

Network and Distributed Systems Security Symposium
(NDSS), 2007.

[21] Z. N. J. Peterson, R. Burns, J. Herring, A. Stubbleﬁeld, and
A. D. Rubin. Secure deletion for a versioning ﬁle system. In
Proc. 4th USENIX Conference on File and Storage
Technologies (FAST), pages 143–154, 2005.

[22] J. Reardon, S. Capkun, and D. Basin. Data node encrypted
ﬁle system: Efﬁcient secure deletion for ﬂash memory. In
Proc. 21st USENIX Security Symposium, 2012.

[23] J. Reardon, S. Capkun, and D. Basin. SoK: Secure data
deletion. In Proc. 34th IEEE Symposium on Security &
Privacy, 2013.

[24] A. Sahai and B. Waters. Fuzzy identity-based encryption. In

Proc. EUROCRYPT, volume 3494 of Lecture Notes in
Computer Science, pages 457–473. Springer, 2005.

[25] A. Shamir. How to share a secret. Communications of the

ACM, 22(11):612–613, Nov. 1979.

[26] V. Shoup. Sequences of games: A tool for taming complexity

in security proofs. Cryptology ePrint Archive, Report
2004/332, 2004. http://eprint.iacr.org/.

[27] Y. Tang, P. P. C. Lee, J. C. S. Lui, and R. Perlman. FADE:
Secure overlay cloud storage with ﬁle assured deletion. In
Proc. Securecomm, 2010.

[28] M. Wei, L. M. Grupp, F. E. Spada, and S. Swanson. Reliably
erasing data from ﬂash-based solid state drives. In Proc. 9th
USENIX Conference on File and Storage Technologies
(FAST), 2011.

270