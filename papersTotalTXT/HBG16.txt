Blindly Signed Contracts:

Anonymous On-Blockchain and Off-Blockchain

Bitcoin Transactions

Ethan Heilman, Foteini Baldimtsi, and Sharon Goldberg

{heilman, foteini}@bu.edu, goldbe@cs.bu.edu

Boston University

Abstract. Although Bitcoin is often perceived to be an anonymous currency, re-
search has shown that a user’s Bitcoin transactions can be linked to compromise
the user’s anonymity. We present solutions to the anonymity problem for both
transactions on Bitcoin’s blockchain and off the blockchain (in so called micro-
payment channel networks). We use an untrusted third party to issue anonymous
vouchers which users redeem for Bitcoin. Blind signatures and Bitcoin transac-
tion contracts (aka smart contracts) ensure the anonymity and fairness during the
bitcoin ↔ voucher exchange. Our schemes are practical, secure and anonymous.

Keywords: Bitcoin, blockchain, smart contracts, blind signatures, anonymity.

1

Introduction

When Bitcoin was ﬁrst introduced in 2008, one of its key selling points was anonymity—
users should be able to spend bitcoins “without information linking the transaction to
anyone” [15]. In the last few years, however, researchers have shown that Bitcoin offers
much weaker anonymity than was initially expected [12, 17], by demonstrating that they
could follow the movement of funds on the Bitcoin blockchain. The community has re-
acted to this by proposing two key approaches to improve the anonymity of Bitcoin: (1)
new anonymity schemes that are compatible with Bitcoin [1, 7, 18, 23, 3, 11, 2, 19, 24],
and (2) new anonymous cryptocurrencies that are independent of Bitcoin [14, 2]. In
this paper we take the former approach by developing new anonymity schemes that are
compatible with Bitcoin via a soft fork. Our schemes offer a new trade-off between
practicality (i.e., transaction speed), security (i.e., resistance to double-spending, denial
of service (DoS) and Sybil attacks) and anonymity (i.e., unlinkable transactions). As we
will see below, previous work either provided schemes that are efﬁcient but achieve lim-
ited security or anonymity [7, 18, 23, 24, 19] or schemes that provide strong anonymity
but are slow and require large numbers of transactions [11, 3, 1].
Our ﬁrst scheme is an “on-blockchain” scheme providing anonymity at reasonable
speed, i.e., requiring four transactions to be conﬁrmed in three blocks (≈ 30 mins). Our
protocol runs in epochs, and provides set-anonymity within each epoch. That is, while
the blockchain publicly displays the set of payers and payees during an epoch, no one
can tell which payer paid which payee. To do this, we introduce an untrusted (possibly
malicious) intermediary I between all payers and payees.

Our second “off-blockchain” scheme uses a new payment technology called micro-
payment channel networks [16, 9]. Micropayment channel networks use Bitcoin as a
platform to conﬁrm transactions within seconds, rather than minutes, and already pro-
vide a degree of anonymity—most of the transactions are made outside of the blockchain,
and thus not shown to the public—but this anonymity is incomplete. Critically, because
micropayment channel networks chain payments through pre-established paths of con-
nected users (explained in Section 5.1), these users that participate in the path learn
transaction details, including the cryptographic identities of the sending and receiving
party. We provide anonymity against malicious users by using an honest-but-curious
intermediary I (Section 5.3); set-anonymity within an epoch is preserved as long as I
does not abort or deny service to payers or payees.
Our technique, inspired by eCash [8], works as follows. For a user A to anony-
mously pay another user B, she would ﬁrst exchange a bitcoin for an anonymous
voucher through intermediary I. B could then redeem the anonymous voucher with
I to receive a bitcoin back. Our scheme overcomes two main challenges: (i) Ensur-
ing that the vouchers are unlinkable (i.e., hiding the link between the issuance and the
redemption of a voucher), and (ii) enforcing fair exchange between participants (i.e.,
users can redeem issued vouchers even against an uncooperative or malicious I, and
no party can steal or double-spend vouchers and bitcoins). We use blind signatures to
achieve unlinkability, and the scripting functionality of Bitcoin transactions to achieve
fair exchange via transaction contracts (aka smart contracts [20]).

We provide an overview of our scheme in Section 2 and deﬁne the required prop-
erties. We discuss our use of transaction contracts in Section 3. Our scheme for on-
blockchain anonymous transactions is in Section 4. Our off-blockchain scheme which
uses micropayment channel networks is in Section 5. Finally, we analyze the anonymity
of our schemes in Sections 4.2 and 5.3 and their security in Section 6.

1.1 Related Work
We now review some of the most representative related works in the literature.
Anonymous Payment Schemes. Zerocash [2] and Zerocoin [14] provide anonymous
payments through the use of a novel type of cryptographic proofs (ZK-SNARKs). Un-
like our schemes, they are “stand-alone” cryptocurrencies and can not be integrated with
Bitcoin. Meanwhile, [19] is an anonymous payment scheme that can offer anonymity
protections to Bitcoin that provides excellent blockchain privacy and is very fast. How-
ever, the parties entrusted to anonymize transactions in [19] can still violate users’
anonymity, even if they are honest-but-curious.
Mixing Services. A bitcoin mixing service provides anonymity by transferring pay-
ments from an input set of bitcoin addresses to an output set of bitcoin addresses, such
that is it hard to trace which input address paid which output address. Mixcoin [7] uses a
trusted third party to mix Bitcoin addresses, but this third party can violate users privacy
and steal users’ bitcoins; theft is detected but not prevented. Blindcoin [23] improves on
Mixcoin by preserving users privacy against the mixing service, as with Mixcoin, theft
is still not prevented. CoinParty [24] is secure if 2/3 of the mixing parties are honest.
CoinJoin [10] and CoinShufﬂe [18] improve on prior work by preventing theft. [13]
shows a rigorous proof of anonymity for a scheme “almost identical” to CoinShufﬂe.

2

CoinShufﬂe’s anonymity set is thought to be small due to coordination costs [3, 6];
meanwhile, our schemes are not limited to small anonymity sets. Moreover, both Coin-
Shufﬂe and CoinJoin run an entire mix in a single bitcoin transaction. Thus, a single
aborting user disrupts the mix for all other users. Moreover, mix users cannot be forced
to pay fees upfront, so that these schemes are vulnerable to DoS attacks [6, 22] (where
users join the mix and then abort) and Sybil attacks (where an adversary deanonymizes
a user by forcing it to mix with Sybil identities secretly under her control) [3].

XIM [3] is a decentralized protocol which builds on the fair-exchange mixer in [1]
and prevents bitcoin theft and resists DoS and Sybil attacks via fees. We also prevent
bitcoin theft resist DoS and Sybil attacks with fees (Section 4.1). One of XIM’s key
innovations is a secure method for partnering mix users. Unfortunately, this partnering
method adds several hours to the protocol execution because users have to advertise
themselves as mix partners on the blockchain. Our schemes are faster because they do
not require a partnering service.

CoinSwap [11] is a fair-exchange mixer that allows two parties to anonymously
send Bitcoins through an intermediary. Like our schemes, the CoinSwap intermediary is
prevented from stealing funds by the use of fair exchange. Unlike our schemes, however,
CoinSwap does not provide anonymity against even a honest but curious intermediary.
Our on-blockchain scheme takes ≈ 30 mins, slower than Coinshufﬂe’s ≈ 10 mins.
Off-blockchain however, our scheme is faster than CoinShufﬂe, since it only runs in
seconds [16]; however, our off-blockchain only supports anonymity against a honest-
but-curious intermediary1.

2 Overview and Security Properties

We introduce two schemes: (a) on-blockchain anonymous payments and coin mixing,
and (b) off-blockchain anonymous payments. By on-blockchain we denote the standard
method of transferring bitcoins i.e., using the Bitcoin blockchain, as opposed to the
newly proposed “off-blockchain” methods that utilize micropayment channel networks.
On-blockchain Anonymous Payments. We ﬁrst consider the scenario where a user
A, the payer wants to anonymously send 1 bitcoin, BTC , to another user B, the payee2
If A were to perform a standard Bitcoin transaction, sending 1 bitcoin from an address
Addr A (owned by A) to a fresh ephemeral address Addr B (owned by B) there would be
a record of this transaction on Bitcoin’s blockchain linking Addr A to Addr B. Even if
A and B always create a fresh address for each payment they receive, the links between
addresses can be used to de-anonymize users if, at some point, they “non-anonymously”
spend a payment (e.g., buying goods from third party that learns their mailing address)
or receive a payment (e.g., a Bitcoin payment processor like BitPay) [12].
One idea A and B could use to protect their privacy is to employ an intermediary
party I that breaks the link between them. A would ﬁrst send one bitcoin to I, and then

1 Our off-blockchain scheme is fast because it uses micropayment channel networks. It’s un-
clear how to retroﬁt prior work onto these networks, e.g., mapping Coinshufﬂe’s single atomic
transaction onto the arbitrary graph topology of a micropayment channel network.
2 We assume that all transactions in our schemes are of 1 bitcoin value.

3

I would send a different bitcoin to B. Assuming that a sufﬁcient number of users make
payments through I, it becomes more difﬁcult for an outsider to link A to B by looking
at the blockchain (more on this below). The downside of this idea, however, is that the
intermediary I knows everything about all users’ payments, violating their anonymity.

We could apply techniques used in online
anonymous eCash schemes [8] to prevent I
from learning who A wants to pay. The proto-
col is in Figure 1. A pays one bitcoin to I, and
obtains an anonymous voucher V = (sn, σ) in
return. (A chooses a random serial number sn,
blinds it to sn and asks I to compute a blind
signature σ on sn. A unblinds these values to
obtain V = (sn, σ). The blind signature re-
quires only a minor change to Bitcoin and can be implemented using a soft fork (Sec-
tion 3). Then A pays B using V , and ﬁnally B redeems V with I to obtain one bitcoin.
How do we ensure that I does not know who A wants to pay? This follows from
the blindness of blind signatures—namely, that the signer (I) cannot read the blinded
serial number sn that it signs, and also cannot link a message/signature (sn, σ) pair
to its blinded value (sn, σ). Blindness therefore ensures that even a malicious I cannot
link a voucher it redeems with a voucher it issues. Blind signatures are also unforgeable,
which ensures that a malicious user cannot issue a valid voucher to itself.

Fig. 1: Strawman eCash protocol.

While this eCash-based approach solves
our anonymity problem, it fails when I is ma-
licious since it could just refuse to issue a
voucher to A after receiving her bitcoin. To
solve this issue, we use Bitcoin transaction con-
tracts to achieve blockchain-enforced fair ex-
change. The key idea is that A transfers a bit-
coin to I if and only if
it receives a valid
voucher V in return. Figure 2 presents the high-
level idea, and full description is in Section 4.
At a high-level, our scheme consists of
four blockchain transactions that are conﬁrmed
in three blocks on the blockchain, as shown
in Figures 2-3. The protocol
involves two
blockchain-enforced fair exchanges. The ﬁrst is
V →BTC , which exchanges a voucher from B
for a bitcoin from I, and is realized using the following two transaction contracts: (1)
Toﬀer (V →BTC ), which is created by I, conﬁrmed in the ﬁrst block on the blockchain
and offers a fair exchange of one bitcoin (from I) for one voucher (from B), and (2)
Tfulﬁll(V →BTC ), which is created by B to fulﬁll the offer by I and is conﬁrmed in
the third block on the blockchain. These transaction contracts ensure that a malicious
I cannot redeem B’s voucher without providing B with a bitcoin in return (see Sec-
tions 3,4). The second fair exchange is BTC→V and works in a similar fashion,
fairly exchanging a bitcoin from A for a voucher from I via two transaction con-

Fig. 2: Our protocol: Circles (step
numbers from Section 4), black ar-
rows (objects transfered via transac-
tion), grey arrows (messages).

4

I A BTIMEIssuanceσsn=)V(snσ,1 btc1 btcRedemption,Vh=H(sn)I A BToffer(BTC→V)Tfulfill(BTC→V)Tfulfill(V→BTC)Toffer(V→BTC)TIME234567{Issuanceσsnh=)V(snσ,1 btcV1 btcRedemption8tracts: (1) Toﬀer (BTC→V ), created by A and conﬁrmed on the second block, and (2)
Tfulﬁll(BTC→V ), created by I and conﬁrmed in the third block. These two fair ex-
changes are arranged to realize the anonymity protocol shown on the previous page; the
fair exchange BTC→V stands in for the interaction between A and I, while the fair
exchange V →BTC stands in for the interaction between B and I.
Mixing Service. A mixing service allows a user to move bitcoins from one address
it controls to a fresh ephemeral (thus anonymous) address, without directly linking the
two addresses on the blockchain. To use our on-blockchain anonymous payments as a
mixing service, users can just anonymously pay themselves from one address to another
fresh ephemeral address, thus playing the role of both A and B in the protocol above.
Off-blockchain Payments. We also adapt our scheme to the recently proposed off-
blockchain micropayment channel networks. Our off-blockchain scheme uses the same
four transactions described above, but conﬁrms them on a micropayment channel net-
work. See Section 5 for details.

Fig. 3: Payment Epoch

2.1 Anonymity Properties
In the strawman eCash protocol of Figure 1, the
anonymity level of users depends on the total
number of payments using I as users can obtain
or redeem vouchers at arbitrary times. However,
our anonymous fair-exchange protocol of Figure 2
provides anonymity only for payments starting
and completing within an epoch (Figure 3) i.e., a
three block window.
Assumptions. We make the following assumptions for our schemes:
1. We assume that all users coordinate on epochs (by e.g., choosing the starting block
to have a block height that is divisible by three).
2. As with traditional eCash schemes, we assume that if A pays B, then A and B
trust each other. (A malicious A or B could easily conspire with I to reveal the
other party of the transaction; for instance, A could just tell I the serial number the
voucher she was issued, and then I can identity B when he redeems that voucher.)
This is a reasonable assumption in cases where A is purchasing goods from B, since
A is likely already trusting B with far more personal and identifying information
including e.g., her shipping address or IP address.
3. For our on-blockchain scheme only, payees B always receive payments in a fresh
ephemeral Bitcoin address Addr B controlled by them. Any communication be-
tween Addr B and I is done anonymously (e.g., using Tor). The payee can transfer
the payment from Addr B to his long-lived Bitcoin address if the protocol success-
fully completes.

4. Payers only make one anonymous payment per epoch. Similarly, payees only ac-
cept one payment per epoch (i.e., we assume they do not create multiple ephemeral
addresses to receive multiple payments in one epoch). 3

3 We could allow users to perform multiple payments (by using multiple Bitcoin addresses that
belong to them) but this would reduce their anonymity and make our analysis more complex.

5

 ATIMEBlocki Toffer(V→BTC)Toffer(BTC→V)Tfulfill(V→BTC)Tfulfill(V→BTC)Blocki+1 Blocki+2 II B1 Epoch......Given these assumptions, the anonymity properties of our on-blockchain scheme are:
Set-Anonymity within an Epoch. Our assumptions imply that in every epoch there
are exactly n addresses making payments (playing the role of payer A) and n receiving
addresses (playing the role of B). All these Bitcoin addresses should belong to different
users. Anyone looking at the blockchain can see the participating addresses of payers
and payees, but should not be able to distinguish which payer paid which payee within
a speciﬁc epoch. Thus, for all successfully completed payments within an epoch, the
offered anonymity set has size n. In other words, the probability of successfully linking
any chosen payer A to a payee should not be more than 1/n plus some negligible
function. This means that an adversary (or a potentially malicious I) can do no better
than randomly guessing who paid whom during an epoch.
Resilient Anonymity. All payments should be totally anonymous until the recipient,
B, chooses to transfer them to an address linkable to B. Even if a party aborts our
protocol before it completes in an epoch, the intended recipient of a payment should
remain totally anonymous.
Transparency of Anonymity Set. Users in our on-blockchain scheme learn the mem-
bership of their anonymity set after a transaction completes, just like anyone else who
might be looking at the blockchain. This property is unusual for eCash schemes, but
quite common for bitcoin mixes. Thus, if a particular B feels his anonymity set is too
small in one epoch, he can increase the size of his anonymity set by remixing in a sub-
sequent epoch. For instance, if Addr B gets paid in an epoch with n = 4, he can create
(cid:48)
B in a subsequent epoch.
a fresh ephemeral address Addr
If the subsequent epoch has a n = 100, then B increases the size of his anonymity set.
Our on-blockchain protocol achieves all the above anonymity properties, which also
generalize to our mixing service (Section 4.2). Our mixing service has the additional ad-
vantage that A does not need to trust B since they are the same user. Our off-blockchain
scheme only offers set-anonymity against I when I is honest-but-curious, rather than
malicious (Section 5.3). Additionally, our off-blockchain scheme does not achieve the
anonymity-set transparency or the anonymity resilience property.

(cid:48)
B and have Addr B pay Addr

Remark: Intersection Attacks. Anyone observing the anonymity-set membership in
each epoch can attempt intersection attacks that de-anonymize users across epochs (e.g.,
frequency analysis). This follows because we are composing set-anonymity across mul-
tiple epochs, and is a downside of any mix-based service that composes across epochs.
([3] has a detailed description of intersection attacks.) By anonymity transparency, any-
one looking at the blockchain can attempt an intersection attack on our on-blockchain
scheme. Our off-blockchain scheme (roughly) only allows I to do this (Section 5.3).

2.2 Security properties
Fair-exchange. There will always be a fair-exchange between V ↔ BTC . Our prop-
erty ensures that: (i) malicious intermediary I cannot obtain a bitcoin from A unless
it honestly creates a voucher for her, and (ii) malicious intermediary I cannot obtain a
voucher V from B and refuse to pay a bitcoin back. This property is also true against

6

malicious users: (iii) malicious A cannot refuse to give a bitcoin to I when receiving
V , and (iv) malicious B cannot receive a bitcoin from I without presenting a (valid) V .
Unforgeability. A user cannot create a valid V without interacting with I.
Double-spending Security. A user can not redeem the same V more than once.
DoS Resistance. The intermediary I should be resistant to Denial of Service (DoS)
attacks where a malicious user starts but never ﬁnishes many parallel fair exchanges
(redemptions) of a V for a BTC .
Sybil Resistance. The protocol should be resistant to a Sybils (i.e., identities that are
under the control of single user) that attempt to de-anonymize a target user.

3

Implementing fair exchange via scripts and blind signatures

We explain how the transaction contracts Toﬀer (BTC→V ) and Tfulﬁll(BTC→V ) imple-
ment the fair exchange BTC→V used in our protocol (V →BTC is analogous).

We start with some background on transaction contracts. Recall that Bitcoin has no
inherent notion of an “account”; instead, users merely move bitcoins from old trans-
actions to new transactions, with the blockchain providing a public record of all valid
moves. To do this, each transaction contains a list of outputs. These outputs hold a
portion of that transaction’s bitcoins and a set of rules describing the conditions under
which the portioned bitcoins in that output can be transferred to a new transaction. The
rules for spending outputs are written in a non-Turing-complete language called Script.
One transaction spends another transaction when it successfully satisﬁes the rules in a
script. Transaction contracts (aka smart contracts [20]) are written as scripts, e.g., A
will only pay B if some condition is met. Using the CHECKLOCKTIMEVERIFY fea-
ture [21] of scripts, we can timelock a transaction, so that funds can be reclaimed if a
contract has not been spent within a given time window tw.
We use timelocking to implement the BTC→V fair exchange. The fair exchange
begins when a user A generates (and the blockchain conﬁrms) a transaction contract
Toﬀer (BTC→V ) which says that A offers one bitcoin to I under the condition “I must
compute a valid blind signature on the blinded serial number sn within time window
tw”; if the condition is not satisﬁed, the bitcoin reverts to A. More precisely, A ﬁrst
chooses a random serial number sn, blinds it to sn, and then uses sn to create a transac-
tion contract Toﬀer (BTC→V ) with an output of one bitcoin that is spendable in a future
transaction Tf if one of the following conditions is satisﬁed:
1. Tf is signed by I and contains a valid blind signature σ on sn4, or
2. Tf is signed by A and the time window tw has expired.
The contract Toﬀer (BTC→V ) is fulﬁlled if I posts a transaction Tf = Tfulﬁll(BTC→V )
that contains a valid blind signature σ on sn. This would satisfy the ﬁrst condition of
Toﬀer (BTC→V ) and so the offered bitcoin is transferred from A to I. If I does not
fulﬁll the contract within the time window tw, then A signs and posts a transaction
Tf that returns the offered bitcoin back to A, thus satisfying the second condition of
Toﬀer (BTC→V ).
4 I signs Tf to stop a malicious miner that learns σ from stealing the bitcoin A gives I.

7

Blind Signature Scheme. Our fair exchange requires blind signatures with exactly two
rounds of interaction. We use Boldyreva’s [4] scheme, instantiated with elliptic curves
for which the Weil or Tate pairing are efﬁciently computable and the computational
Difﬁe-Hellman problem is sufﬁciently hard. While bitcoin supports elliptic curve oper-
ations, it uses a curve (Secp256k1) that does not support the required bilinear pairings.
Thus, we need a soft fork to add an opcode that supports elliptic curves with efﬁcient
bilinear pairings (i.e., supersingular curves of the type y2 = x3 + 2x ± 1 over Fe(cid:96)).
We use standard multiplicative notation and overlines to denote blinded values. Let
G be a cyclic additive group of prime order p in which the gap Difﬁe-Hellman prob-
lem [5] is hard and G(cid:48) a cyclic multiplicative group of prime order q. By e we denote
the bilinear pairing map: e : G× G → G(cid:48). Let g be a generator of the group and H be a
hash function mapping arbitrary strings to elements of G\{1}. Let (p, g, H) be public
parameters and (sk , pk = gsk ) be the signer’s secret/public key pair.
– To blind sn, user A picks random r ∈ Z∗
– To sign sn, signer I computes σ = sn sk .
– To unblind the blind signature σ, user A computes σ = σpk
– To verify the signature σ on sn, anyone holding pk checks that the bilinear pairing

p and sets sn = H(sn)gr.

−r.

e(pk , H(sn)) is equal to e(g, σ).

– To verify that the blinded signature σ on the blinded sn, anyone holding pk can
verify that this is valid (intermediate) signature by checking if e(pk , m) = e(g, σ).

4 On-Blockchain Anonymous Protocols

We now discuss the details of on-blockchain protocol depicted in Figure 2-3.
As shown in Figure 2, our protocol interleaves two fair exchanges BTC→V (im-
plemented using Toﬀer (V →BTC ) and Tfulﬁll(V →BTC )) and V →BTC (implemented
using Toﬀer (BTC→V ) and Tfulﬁll(BTC→V )). The interleaving is designed to ensure
that a malicious I cannot issue a voucher V to A and then subsequently refuse to re-
deem V from B. The key idea is that it is in the interest of both A and B to force I
to commit to redeeming the voucher V = (sn, σ). To do this A starts by choosing the
serial number sn for the voucher and sending its hash h = H(sn) to B; notice that h
hides the value of sn and thus does not harm anonymity. Then, B uses h to force I to
commit to redeeming a voucher with serial number sn. Speciﬁcally, B asks I to create
the transaction contract Toﬀer (V →BTC ) that offers one bitcoin to B under the condition
“B must provide a valid voucher V with serial number sn such that h = H(sn) within
time window tw”. To prevent double-spending, I agrees to create Toﬀer (V →BTC ) iff
the hash value h does not match the h of any prior transaction contract that I has signed.
Once Toﬀer (V →BTC ) is on the blockchain, committing that I will redeem the voucher
with serial number sn, our two fair exchanges proceed as in Figure 2.
The details of the scheme are as follows. Let k be the security parameter. We assume
that I performs a one-time setup by posting public parameters on the blockchain. These
parameters include the public parameters for the blind signature scheme, the fee value
f and reward value w, and the time windows (tw 1, tw 2). (We deﬁne f, w below.)
1. B creates a fresh ephemeral Bitcoin address to receive the payment.

8

2. A randomly chooses sn r←− {0, 1}k, computes h ← H(sn) and sends h to B.
3. B sends h to I and asks I to create transaction contract Toﬀer (V →BTC ) offering
one bitcoin to B under condition: “B must provide a valid voucher V with serial
number whose hash is equal to h within time window tw 2”.
4. If h does not match any h from prior transaction contracts signed by I, then I
creates the requested contract Toﬀer (V →BTC ) and posts it to the blockchain.
5. A blinds sn to obtain sn and waits for Toﬀer (V →BTC ) to be conﬁrmed on the
blockchain. Then A creates transaction Toﬀer (BTC→V ), offering a 1 + w bitcoins
to I under the condition “I must provide a valid blind signature on the blinded
serial number sn within time window tw 1” (where tw 1 > tw 2 so that I cannot
cheat by waiting until Toﬀer (BTC→V ) expires but Toﬀer (V →BTC ) has not).
6. To prevent A from double-spending the bitcoin offered in Toﬀer (BTC→V ), I waits
until the blockchain conﬁrms Toﬀer (BTC→V ). I then fulﬁlls the BTC→V fair
exchange by creating transaction Tfulﬁll(BTC→V ) which contains the blinded sig-
nature σ on sn. Tfulﬁll(BTC→V ) is posted to the blockchain, and transfers (1 + w)
bitcoins from Toﬀer (BTC→V ) to I.

7. A learns σ from Tfulﬁll(BTC→V ), unblinds σ to σ and sends V = (sn, σ) to B.
8. B creates a transaction Tfulﬁll(V →BTC ) which contains the voucher V = (sn, σ),
and thus transfers the bitcoin in Toﬀer (V →BTC ) to B. Tfulﬁll(V →BTC ) is posted to
the blockchain and conﬁrmed in the same block as Tfulﬁll(BTC→V ).

Rewards. A offers 1+w bitcoins to I in Toﬀer (BTC→V ), but I only offers B 1 bitcoin
in Toﬀer (V →BTC ). The remaining w bitcoin is kept by I as a “reward” for completing
its role in the protocol. I cannot steal w because w is paid via a fair exchange.

4.1 Anonymous Fee Vouchers

Bitcoin transactions include a transaction fee that is paid to the miner who conﬁrms
the transaction in the blockchain; if this transaction fee is not paid or is too low, it is
extremely unlikely that this transaction will be conﬁrmed. Since I can not trust B or
A, I should not be required to cover the cost of the transaction fee for ﬁrst transaction
contract Toﬀer (V →BTC ) that I posts to the blockchain.
Following ideas from [3], we have A buy a special anonymous fee voucher V (cid:48) of
value f bitcoin from I. The value f (cid:28) 1 should be very small and is set as a public
parameter. Since fee vouchers are anonymous and have low value, A should buy them
out-of-band in bulk with cash, credit or bitcoin. Then, whenever A wishes to mix or
make an anonymous payment, A sends an anonymous fee voucher V (cid:48) to B, who in turn
sends it to I with a request that I initiate the protocol. All this happens out-of-band.
Note though, that the fee voucher V (cid:48) is not created with a fair exchange, and thus I
could steal f bitcoin by accepting V (cid:48) but refusing to initiate the protocol. However,
we argue that I has very little incentive to do this if, upon completing the protocol, I
obtains a reward w that is signiﬁcantly larger than f.
DoS Resistance. Fees raise the cost of an DoS attack where B starts and aborts many
parallel sessions, locking I’s bitcoins in many Toﬀer (V →BTC ) transaction contracts.
This is because B must forward an anonymous fee voucher V (cid:48) from A to I every time
B wishes to initiate our protocol. This method also works for our mixing service, where

9

A and B are the same user. Moreover, if a party aborts a run of our protocol during an
epoch, this has no affect on other runs in that epoch. This is in contrast to [18, 10] where
a single aborting player terminates the protocol for all parties in that mix.
Sybil Resistance. In a sybil attack, the adversary creates many sybil identities secretly
under her control, and deanonymizes a target user by forcing the target to mix only with
sybils [3, 22]. To launch this attack on our protocol, the attacker could create m runs
of our protocol (i.e., m payers and payees) that occupy most of the intermediary I’s
resources, leaving only a single slot available for the targeted payer and payee. Again,
we use fees to raise the cost of this attack, by requiring each of the m Sybil runs to pay
a fee voucher of value f.

4.2 Anonymity Analysis

Before discussing the anonymity properties of our scheme we start by noting that in
the ﬁrst step of our protocol, B is always required to create a fresh ephemeral Bit-
coin address Addr 0. Upon creation, this address is completely anonymous, in the sense
that there is no way to link it to B’s identity; this is a much stronger notion than the
set anonymity deﬁned in Section 2.1. Now suppose that A uses our protocol to pay a
bitcoin to Addr 0. Then, as we will argue below, Addr 0 is now linkable to A with prob-
ability 1/n (if n payments happened in that epoch). However Addr 0 is still completely
anonymous with respect to B’s “Bitcoin identity”, i.e., the long-lived Bitcoin address
that B uses to send and receive payments. If the funds from Addr 0 were paid into an-
other fresh ephemeral Bitcoin address Addr 1 controlled by B, these funds would still
be unlinkable to B. Indeed, the funds in Addr 0 only become linkable to B if they are
transferred to an address controlled by B that already contains some bitcoins.
Set-Anonymity within an Epoch. Our on-blockchain payment scheme achieves an
anonymity set of size n within an epoch, as deﬁned in Section 2.1. Suppose that n pay-
ments successfully complete during an epoch, and recall that each payer may only per-
form one payment per epoch and each payment is made to a fresh ephemeral address.
It follows that there are n payers and n payees during the epoch. Any adversary (in-
cluding I) observing the blockchain can see the following: n payers’ addresses, n pay-
ees’ addresses, and n sets of transactions of the type Toﬀer (BTC→V ), Tfulﬁll(BTC→V ),
Toﬀer (V →BTC ), Tfulﬁll(V →BTC ). For the adversary to link a payer to a payee, it would
need to link a Toﬀer (BTC→V ), Tfulﬁll(BTC→V ) pair (BTC→V ) to a Toﬀer (V →BTC ),
Tfulﬁll(V →BTC ) pair (V →BTC ). Let us ﬁrst examine what do these pairs of transac-
tion contracts reveal on the blockchain. The BTC→V pair reveals a blinded serial
number sn and the corresponding intermediate (blinded) blind signature σ. Meanwhile,
the V →BTC pair reveals a serial number sn and the corresponding signature σ. As
long as the blinding factor of sn is not revealed, the blind signature ensures that no one
can link an sn to an sn. The signatures σ and σ are similarly unlinkable (except with
some negligible probability ν(k)). Thus, the adversary’s best strategy is to randomly
link a payer to a payee, which succeeds with probability 1/n + ν(k).

The same analysis applies to our mixing service. Moreover, mix users can repeat-
edly rerun the mix over several epochs, thus boosting the size of their anonymity set
beyond what could be provided during a single epoch.

10

Resilient Anonymity and Transparency of Anonymity Set. Ephemeral address pre-
vent I from de-anonymizing a payment from A to B by aborting or denying service.
Suppose I aborts by refusing to issue Tfulﬁll(BTC→V ) to A (Figure 2). If this happens,
A does not obtain voucher V = (sn, σ) and cannot pass V on to B. By the unforge-
ability of vouchers, it follows that B will not be able to issue a valid Tfulﬁll(V →BTC )
that fulﬁlls Toﬀer (V →BTC ). Thus, I can de-anonymize the payment between A and B
by matching the aborted exchange with A with the incomplete exchange with B. As an-
other possible attack, malicious I could instead refuse service to all payers apart from a
target A, and then identify B by ﬁnding the single V →BTC exchange that completes
during the epoch. Fortunately, however, anonymity-set transparency allows B to detect
these attacks. B can recover by discarding the ephemeral address it used in the attacked
epoch, and chose a fresh ephemeral address in a subsequent epoch.

Note that for both our payment and mixing service one could attempt an intersection

attack as discussed in Section 2.1.

5 Off-Blockchain Anonymous Payments over Micropayment

Channel Networks

We start by reviewing off-blockchain transactions via micropayment channel networks
and then describe how to make our protocol faster by adapting it to work with them.

5.1 Micropayment Channel Networks
Micropayment Channels. To establish a pairwise micropayment channel, A and B
each pay some amount of bitcoins into an escrow transaction Te which is posted to the
blockchain. This escrow transaction is on-blockchain and therefore slow (≈ 10 min-
utes), but all subsequent transactions are off-blockchain and therefore fast (≈ seconds).
Te ensures that no party reneges on an off-blockchain transaction. Suppose x bitcoins
are paid into Te. Te offers these x bitcoins to be spent under condition: “The spend-
ing transaction is signed by both A and B”. Then, the spending transaction Tr has the
form: “a bitcoins are paid to A and b bitcoins are paid to B” where a and b reﬂect the
agreed-upon balance of bitcoins between A and B.
Once Te is conﬁrmed on the blockchain, A and B can transfer funds between
themselves off-blockchain by signing a spending transaction Tr. Importantly, Tr is
not posted to the blockchain. Instead, the existence of Tr creates a credible threat that
either party can claim their allocated bitcoins by posting Tr to the blockchain; this pre-
vents either party from reneging on the allocation reﬂected in Tr. To continue to make
off-blockchain payments, A and B just need to sign a new transaction T (cid:48)
r that reﬂects
the new balance of bitcoins a(cid:48) and b(cid:48). Micropayment channels have mechanisms that
ensure that this later transaction T (cid:48)
r always supersedes an earlier transaction Tr. Our
protocol applies generically to any micropayment channel with such a mechanism, e.g.,
Lightning Network [16], Duplex Micropayment Channels (DMC) [9].
Micropayment Channel Networks. Micropayment channel networks are designed to
avoid requiring each pair of parties to pre-establish a pairwise micropayment channel

11

between them. Indeed, such a requirement would be infeasible, since it requires each
pair of users to lock funds into many different escrow transactions Te on the blockchain.
Instead, suppose a pair of users A and B are connected by a path of users with estab-
lished pairwise micropayment channels (i.e., A has a channel with A1, A1 has a channel
with A2, ..., Am−1 has a channel with Am, Am has a channel with B). Then, the path
of users can run a protocol to transfer funds from A to B. However, it will not suf-
ﬁce to simply have each user Ai create a transaction paying the next user Ai+1 in the
path, since a malicious user Ak could steal funds by failing to create a a transaction for
Ak+1. Instead, the Lightning Network and DMC use a protocol based on hash time-
locked contracts or HTLCs. A transaction T is an HTLC if it offers bitcoins under the
condition: “The spending transaction must contain the preimage of y and be conﬁrmed
within timewindow tw”, where y = H(x) and x is a random value, i.e., the preimage.
We say that T is locked under the preimage of y.
Micropayment channels use HTLCs as follows. Suppose the existing balance be-
tween A and B is a bitcoin for A and b bitcoin for B. Now suppose that A wants to
transfer  bitcoin to B, updating the balances to a −  and b + . First, B chooses a
random value x, computes y = H(x), and announces y to everyone in the path. Then,
A asks each pair of parties (Ai,Ai+1) on the path to transfer  bitcoin locked under the
preimage of y using the micropayment channel from Ai to Ai+1. The mechanics of the
transfer between Ai and Ai+1 are as follows. Suppose the existing balance between Ai
and Ai+1 is c bitcoin for Ai and d bitcoin for Ai+1. Then Ai and Ai+1 jointly sign
r of the form “c −  bitcoins are paid to Ai and d + 
a new spending transaction T (cid:48)
bitcoins are paid to Ai+1” under the condition “the spending transaction contains the
preimage of y within timewindow tw”. Once A sees that all the transactions on the
path have been signed, it releases the preimage x to the path and the funds ﬂow from
Ai to Aj. If any user refuses to sign a transaction, the timelock tw allows all signing
users to reclaim their funds. The timelock is decremented along the path to prevent race
conditions. This entire protocol occurs off-blockchain, with x and the HTLCs creating
a credible threat that users can reclaim their funds if they are posted to the blockchain.

5.2 Anonymizing Micropayment Channel Networks
As a strawman for anonymous transactions in micropayment channel networks, we
can replace the hash lock with the transaction contracts conditions in that we use in
Toﬀer (V →BTC ) and Toﬀer (BTC→V ) (see Section 4). The protocol assumes paths of
intermediate channels (path 1, path 2) connecting A to I and I to B respectively, and
has Setup phase as in our original on-blockchain protocol.
1. A chooses a random serial number sn, hashes it to h = H(sn) and sends h to B.
2. B uses h to lock a path of micropayment channels (path 2) to I under the condi-
tion: “The spending transaction must provide a valid voucher V with serial number
whose hash is equal to h within time window tw 2.”
3. A blinds the serial number sn to obtain sn. A asks B to conﬁrm that each party on
path 2 from A to I has properly locked the path. Then, A asks I to lock a path path 1
of micropayment channels between Ai and I under the condition: “The spending
transaction must provide a valid blind signature on the blinded serial number sn
within time window tw 1” where tw 1 > tw 2.

12

4. I then reveals σ to every party on path 1, unlocking the path from I to A. A obtains
σ, unblinds it to σ and thus obtains the voucher V = (σ, sn). A sends V = (σ, sn)
to B who releases it to every party on path path2, unlocking the path from I to B.
We again need the notion of an epoch. Since we do not have blocks to coordinate these
epochs, we instead use synchronized clocks. We break an epoch of q seconds into three
equal divisions of q
3 seconds long. path 2 is set up in ﬁrst division, path 1 is set up second
and path 1 and path 2 are resolved in third division. Also, we can add anonymous fee
vouchers to this protocol, since fee vouchers are redeemed out of band (Section 4.1).

5.3 Anonymity Analysis
Of the properties in Section 2.1, our off-blockchain scheme only supports set anonymity
within an epoch (as discussed in Section 4.2) when I is honest-but-curious. That is, I
follows the protocol without aborting or denying services to other payers and payees,
but is still curious to learn which payer is paying which payee. However, we still support
fair-exchange against a malicious I (Section 6) as well as set-anonymity within an
epoch against malicious third parties.
We only support anonymity against honest-but-curious I because we cannot use
fresh ephemeral addresses in this off-blockchain context. This follows because choosing
a fresh address amounts to establishing a fresh micropayment channel. Because this
requires a fresh escrow transaction Te to be posted on the blockchain (taking ≈ 10
minutes), it obviates the speed beneﬁts of the off-blockchain scheme. Recall that B
discards its ephemeral address in order to recover from an epoch where a malicious I
de-anonymized the payment from A to B by aborting or denying service (Section 4.2).
We have also given up on anonymity transparency. Because transactions are no
longer posted on the blockchain, even users that participate in the protocol cannot learn
the size or membership of their anonymity set.
Proxy Addresses. We need the notion of proxy addresses to ensure that no parties
(other than I) can break anonymity by behaving maliciously. Notice that in a micro-
payment channel network, a malicious user Ai along the path path 1 from A to I can
abort the protocol by refusing to create the appropriate transactions. Now if Ai is also
on the path path 2 from I to B, then Ai can abort the protocol and de-anonymize A and
B in the same way that I can. To prevent this attack, we need to make sure that I is the
only party that is on both path 1 and path 2. The idea is that every user B of our system
has an additional proxy address Addr px
B , and uses this address to establish, just once,
a (reusable) micropayment channel directly to I. This ensures that path 2 consists of
only I and Addr px
B using
the strawman protocol of Section 5.2 in a one epoch. In the subsequent epoch, I will
B (acting as user A) to its
rerun the strawman protocol to transfer funds from Addr px
long-lived address Addr B (acting as user B).
Intersection Attacks. The lack of anonymity set transparency and the use of proxy ad-
dresses implies that only I can observe the full membership of the anonymity set during
each epoch. As payments between proxy Addr px
B and identity Addr B addresses occur
in contiguous epochs, I could use an intersection attack [3] to infer their relationship.
Other adversaries only observe off-blackchain transactions ﬂowing through them.

B . Then, I will receive payments to its proxy address Addr px

13

6 Security Analysis

Fair-Exchange Our schemes prevent parties from stealing from each other.
1. The BTC→V fair exchange (Section 3) ensures that (1) I cannot steal A’s bitcoin
without issuing her a valid voucher V , and (2) A cannot refuse to pay I a bitcoin
upon receiving a V . (Fair exchange properties (i) and (iii) from Section 2.2.)
2. The V →BTC fair exchange ensures that B cannot steal I’s bitcoins without ac-
tually redeeming V . Also, I cannot refuse to redeem a V = (sn, σ) that it issued
to A. This follows because, as discussed in Section 4, I commits to the redemp-
tion of V when it posts Toﬀer (V →BTC ) (which contains h, where h = H(sn)).
Moreover, recall that Tfulﬁll(BTC→V ) is transaction where (a) 1 + w bitcoin are
transferred from A to I, and (b) I issues V by providing the blind signature σ.
Since Toﬀer (V →BTC ) is posted to the blockchain before Toﬀer (V →BTC ), it fol-
lows that A does not pay I for V until I has committed to redeeming V . (Fair
exchange properties (ii) and (iv) from Section 2.2.)
3. I cannot prevent B from redeeming V by issuing V just before Toﬀer (V →BTC )
expires. This follows because A choose tw 1 such that tw 1 > tw 2 which ensures
that Toﬀer (BTC→V ) expires earlier that Toﬀer (V →BTC ). This way, if I takes too
long to issue Toﬀer (BTC→V ), A will have already reclaimed her refunds. (Fair
exchange property (ii) from Section 2.2.)

Unforgeability and Double-spending. Unforgeability follows from the underlying
blind signature scheme, which ensures that only the intermediary I can issue vouchers
V = (sn, σ). Moreover, vouchers cannot be double-spent because if I has previously
seen h = H(sn), I will refuse to post Toﬀer (V →BTC ).
DoS and Sybil Resistance. Both our on- and off-blockchain schemes support anony-
mous fee vouchers, and thus resist DoS and sybil attacks (Section 4.1).

7 Conclusion

In this work we developed an eCash inspired technique that can be used to enhance
anonymity in Bitcoin transactions that happen on the blockchain or via micropayment
channel networks (off-blockchain). Both our schemes provide fair-exchange security,
forgery and double-spending security and moreover are resistant to DoS and Sybil at-
tacks. Regarding anonymity, our on-blockchain scheme is anonymous against mali-
cious users or a malicious intermediary I. Our off-blockchain scheme is still anony-
mous against malicious users but is only anonymous against an honest-but-curious I.
Achieving anonymity against a malicious intermediary for off-blockchain schemes is
left as an interesting open problem.

Acknowledgments.

We thank Dimitris Papadopoulos, Ann Ming Samborski and the anonymous reviewers
for comments on this draft. This work was funded by the National Science Foundation
under grants 1012910 and 1350733.

14

References

1. Simon Barber, Xavier Boyen, Elaine Shi, and Ersin Uzun. Bitter to better - how to make

bitcoin a better currency. In Financial Cryptography and Data Security. Springer, 2012.

2. Eli Ben Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers, Eran
Tromer, and Madars Virza. Zerocash: Decentralized anonymous payments from bitcoin. In
IEEE Security and Privacy (SP), pages 459–474, 2014.

3. George Bissias, A Pinar Ozisik, Brian N Levine, and Marc Liberatore. Sybil-resistant mixing
for bitcoin. In Workshop on Privacy in the Electronic Society, pages 149–158. ACM, 2014.
4. Alexandra Boldyreva. Threshold signatures, multisignatures and blind signatures based on
the gap-difﬁe-hellman-group signature scheme. In PKC, volume 2567, pages 31–46, 2003.
In

5. Dan Boneh, Ben Lynn, and Hovav Shacham. Short signatures from the weil pairing.
ASIACRYPT, volume 2248 of Lecture Notes in Computer Science, pages 514–532, 2001.

6. Joseph Bonneau, Andrew Miller, Jeremy Clark, Arvind Narayanan, Joshua A Kroll, and Ed-
ward W Felten. Sok: Research perspectives and challenges for bitcoin and cryptocurrencies.
In IEEE Security and Privacy (SP), 2015.

7. Joseph Bonneau, Arvind Narayanan, Andrew Miller, Jeremy Clark, JoshuaA. Kroll, and Ed-
wardW. Felten. Mixcoin: Anonymity for bitcoin with accountable mixes. In Financial Cryp-
tography and Data Security, 2014.

8. David Chaum. Blind signature system. In CRYPTO, 1983.
9. Christian Decker and Roger Wattenhofer. A fast and scalable payment network with bitcoin
duplex micropayment channels. In Stabilization, Safety, and Security of Distributed Systems,
pages 3–18. Springer, 2015.

10. G Maxwell. Coinjoin: Bitcoin privacy for the real world, 2013.
11. Gregory Maxwell. Coinswap: transaction graph disjoint trustless trading, 2013.
12. S Meiklejohn, M Pomarole, G Jordan, K Levchenko, GM Voelker, S Savage, and D McCoy.
A ﬁstful of bitcoins: Characterizing payments among men with no names. In Proceedings of
the ACM SIGCOMM Internet Measurement Conference, IMC, pages 127–139, 2013.

13. Sarah Meiklejohn and Claudio Orlandi. Privacy-enhancing overlays in bitcoin. In Financial

Cryptography and Data Security, volume 8976, pages 127–141. 2015.

14. Ian Miers, Christina Garman, Matthew Green, and Aviel D Rubin. Zerocoin: Anonymous

distributed e-cash from bitcoin. In IEEE Security and Privacy (SP), pages 397–411, 2013.

15. Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system. (2012):28, 2008.
16. Joseph Poon and Thaddeus Dryja. The bitcoin lightning network: Scalable off-chain instant

payments. Technical report, Technical Report (draft). https://lightning. network, 2015.

17. Dorit Ron and Adi Shamir. Quantitative analysis of the full bitcoin transaction graph. In

Financial Cryptography and Data Security, pages 6–24. Springer, 2013.

18. Tim Rufﬁng, Pedro Moreno-Sanchez, and Aniket Kate. Coinshufﬂe: Practical decentralized

coin mixing for bitcoin. In ESORICS, pages 345–364. Springer, 2014.

19. Amitabh Saxena, Janardan Misra, and Aritra Dhar.

Increasing anonymity in bitcoin.

In

Financial Cryptography and Data Security, pages 122–139. Springer, 2014.

20. Nick Szabo. Formalizing and securing relationships on public networks. First Monday, 2(9),

1997.

21. Peter Todd. Bip 65: Op checklocktimeverify. Bitcoin improvement proposal, 2014.
22. Florian Tschorsch and Bj¨orn Scheuermann. Bitcoin and beyond: A technical survey on

decentralized digital currencies.

23. Luke Valenta and Brendan Rowan. Blindcoin: Blinded, accountable mixes for bitcoin. In

Financial Cryptography and Data Security, pages 112–126. Springer, 2015.

24. Jan Henrik Ziegeldorf, Fred Grossmann, Martin Henze, Nicolas Inden, and Klaus Wehrle.
Coinparty: Secure multi-party mixing of bitcoins. In Proceedings of the 5th ACM Conference
on Data and Application Security and Privacy, pages 75–86. ACM, 2015.

15

