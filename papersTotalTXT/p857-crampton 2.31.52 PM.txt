On the Parameterized Complexity of the Workﬂow

Satisﬁability Problem

Jason Crampton

Royal Holloway

University of London

United Kingdom

jason.crampton@rhul.ac.uk

Gregory Gutin
Royal Holloway

University of London

United Kingdom

g.gutin@rhul.ac.uk

Anders Yeo

South Africa

University of Johannesburg

anders.yeo.work@gmail.com

ABSTRACT
A workﬂow speciﬁcation deﬁnes a set of steps and the order
in which those steps must be executed. Security require-
ments may impose constraints on which groups of users are
permitted to perform subsets of those steps. A workﬂow
speciﬁcation is said to be satisﬁable if there exists an as-
signment of users to workﬂow steps that satisﬁes all the
constraints. An algorithm for determining whether such
an assignment exists is important, both as a static analysis
tool for workﬂow speciﬁcations, and for the construction of
run-time reference monitors for workﬂow management sys-
tems. Finding such an assignment is a hard problem in gen-
eral, but work by Wang and Li in 2010 using the theory of
parameterized complexity suggests that eﬃcient algorithms
exist under reasonable assumptions about workﬂow speciﬁ-
cations. In this paper, we improve the complexity bounds
for the workﬂow satisﬁability problem. We also generalize
and extend the types of constraints that may be deﬁned in a
workﬂow speciﬁcation and prove that the satisﬁability prob-
lem remains ﬁxed-parameter tractable for such constraints.

Categories and Subject Descriptors
D4.6 [Operating Systems]: Security and Protection—Ac-
cess controls; F2.2 [Analysis of Algorithms and Prob-
lem Complexity]: Nonnumerical Algorithms and Prob-
lems; H2.0 [Database Management]: General—Security,
integrity and protection

General Terms
Algorithms, Security, Theory

Keywords
authorization constraints, workﬂow satisﬁability, parameter-
ized complexity

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’12, October 16–18, 2012, Raleigh, North Carolina, USA.
Copyright 2012 ACM 978-1-4503-1651-4/12/10 ...$15.00.

1.

INTRODUCTION

It is increasingly common for organizations to comput-
erize their business and management processes. The co-
ordination of the tasks or steps that comprise a computer-
ized business process is managed by a workﬂow management
system (or business process management system). Typically,
the execution of these steps will be triggered by a human
user, or a software agent acting under the control of a hu-
man user, and the execution of each step will be restricted
to some set of authorized users.

A workﬂow typically speciﬁes the tasks that comprise a
business process and the order in which those tasks should
be performed. Moreover, it is often the case that some form
of access control should be applied to the execution of tasks.
Hence, most workﬂow management systems may implement
security controls that enforce authorization rules and busi-
ness rules, in order to comply with statutory requirements
or best practice. It is such “security-aware” workﬂows that
will be the focus of the remainder of this paper. The most
widely cited rules include separation-of-duty (also known as
the “two-man” or “four-eyes” rule), which may be used to
prevent sensitive combinations of steps being performed by
a single user, and binding-of-duty, which requires that a par-
ticular combination of steps is executed by the same user.

A simple, illustrative example for purchase order process-
ing [5] is shown in Figure 1. In the ﬁrst step of the work-
ﬂow, the purchase order is created and approved (and then
dispatched to the supplier). The supplier will present an in-
voice, which is processed by the create payment step. When
the supplier delivers the ordered goods, a goods received
note (GRN) must be signed and countersigned. Only then
may the payment be approved. Note that a workﬂow speci-
ﬁcation need not be linear: the processing of the GRN and
of the invoice can occur in parallel, for example.

In addition to deﬁning the order in which steps must be
performed, the workﬂow speciﬁcation includes rules to pre-
vent fraudulent use of the purchase order processing system.
These rules take the form of constraints on users that can
perform pairs of steps in the workﬂow: the same user may
not sign and countersign the GRN, for example.

It is apparent that it may be impossible to ﬁnd an assign-
ment of authorized users to workﬂow steps such that all con-
straints are satisﬁed. In this case, we say that the workﬂow
speciﬁcation is unsatisﬁable. The Workflow Satisfiabil-
ity Problem (WSP) is known to be NP-hard, even when
the set of constraints only includes constraints that have a

857s3

s5

s1

s2

s4

s6

(a) Ordering on steps and constraints

(cid:2)=

(cid:2)=

s5

s6

s3

s2

s4

s1

=

(cid:2)=
(cid:2)=

(b) Constraints

create purchase order
approve purchase order
sign goods received note
create payment
countersign goods received note
approve payment

s1
s2
s3
s4
s5
s6
(cid:2)= diﬀerent users must perform steps
= same user must perform steps

(c) Legend

Figure 1: A simple constrained workﬂow for pur-
chase order processing

relatively simple structure (and that would arise regularly
in practice).1

An algorithm that solves WSP can be used to perform
a static analysis of a workﬂow speciﬁcation to determine
whether there exists an instance of the workﬂow that can
complete. The NP-hardness of the problem suggests that
the worst-case run-time of such an algorithm will be expo-
nential in the size of the input. Hence, it is important to
ﬁnd an algorithm that is as eﬃcient as possible. Moreover,
we may wish to construct a reference monitor that decides
whether a user should be permitted to execute a particular
step in a workﬂow instance. Part of that reference monitor’s
functionality will be to conﬁrm that the user is authorized to
execute that step; the second part of its functionality will be
to determine whether allowing the request would render the
remaining steps in the workﬂow instance unsatisﬁable [5].
Assuming that such a reference monitor should incur as lit-
tle delay as possible (in the interest of the end-user experi-
ence), it becomes even more important to ﬁnd an algorithm
that can decide WSP as eﬃciently as possible.

It has been argued that it would be of practical value to be
able to deﬁne constraints in terms of organizational struc-
tures, rather than just the identity of particular users [17].
The ﬁrst contribution of this paper is to introduce a model

for hierarchical organizations based on the notion of equiv-
alence classes and partition reﬁnements. We demonstrate
how to construct an instance of our model from a manage-
ment structure and illustrate why constraints deﬁned over
such models are of practical value.

Wang and Li [17] observed that the number of steps in a
workﬂow is likely to be small relative to the size of the input
to the workﬂow satisﬁability problem. This observation led
them to study the problem using tools from parameterized
complexity and to prove that the problem is ﬁxed-parameter
tractable for certain classes of constraints. These results
demonstrate that it is feasible to solve WSP for many work-
ﬂow speciﬁcations in practice. However, Wang and Li also
showed that for many types of constraints the problem is
ﬁxed-parameter intractable unless one of the parameterized
complexity hypotheses, FPT (cid:2)= W[1], fails, which is highly
unlikely. (We provide a short introduction to parameterized
complexity in Section 4.1.)

In this paper, we extend the results of Wang and Li in

three diﬀerent ways.

1. First, we signiﬁcantly improve their bound on the
ﬁxed-parameter complexity of WSP for those classes
of constraints for which Wang and Li proved that the
problem is tractable. This bound arises from a new
approach to the problem and the application of a pow-
erful, recent result in the area of exponential-time al-
gorithms [3]. Moreover, we demonstrate that our re-
sult cannot be signiﬁcantly improved, provided a well-
known hypothesis about the complexity of solving 3-
SAT holds.

2. Our second extension to the work of Wang and Li
is to deﬁne constraints in terms of hierarchical struc-
tures and to prove that WSP remains ﬁxed-parameter
tractable in the presence of such hierarchical structures
and hierarchy-related constraints.

3. In their work, Wang and Li impose a restriction on
what we might informally call the structure of a con-
straint. Our ﬁnal contribution is to remove this restric-
tion and prove that Wang and Li’s results on ﬁxed-
parameter tractability of WSP still hold, albeit with
an increase in the complexity of the algorithm that
solves the problem.

In the next section, we introduce the workﬂow satisﬁabil-
ity problem, as deﬁned by Wang and Li. In Section 3, we
introduce a model for an organizational hierarchy and a class
of constraint relations deﬁned in terms of such hierarchies.
Then, in Section 4, we introduce our approach to the work-
ﬂow satisﬁability problem and prove a result that reduces
the complexity of the problem for a particular class of con-
straints. We demonstrate that this approach generalizes to
workﬂow speciﬁcations that include constraints deﬁned over
an organizational hierarchy and prove that the satisﬁability
problem remains ﬁxed-parameter tractable.
In Section 5,
we discuss a number of extensions to the workﬂow satisﬁ-
ability problem, including generalizations of the constraint
structure and of the satisﬁability problem itself. The paper
concludes with a summary of our contributions and discus-
sions of related and future work.

2. THE SATISFIABILITY PROBLEM

1In particular, the Graph k-Colorability problem can be
reduced to a special case of WSP in which the workﬂow spec-
iﬁcation only includes separation-of-duty constraints [17].

In this section, we introduce our notation and deﬁnitions,
derived from earlier work by Crampton [5] and Wang and
Li [17], and then deﬁne the workﬂow satisﬁability problem.

858Let U be a set of users and let Rel(U ) denote the set of
In other words, Rel(U ) is the
all binary relations on U .
powerset of U × U . We will write ρ= and ρ(cid:2)= to denote
the relations {(u, u) : u ∈ U} and {(u, v) : u, v ∈ U, u (cid:2)= v},
respectively. Given ρ ∈ Rel(U ), let (cid:2)ρ = {(v, u) : (u, v) ∈ ρ}.
Note that if ρ is symmetric (as are ρ= and ρ(cid:2)=), then ρ = (cid:2)ρ.
If (X, (cid:2)) is a partially ordered set, then we write x (cid:4) y if
x (cid:2)(cid:2) y and y (cid:2)(cid:2) x. We may write x (cid:3) y whenever y (cid:2) x. We
may also write x < y whenever x (cid:2) y and x (cid:2)= y. Finally,
we will write [n] to denote {1, . . . , n}.

Definition 1. A workﬂow speciﬁcation is a partially or-
dered set of steps (S, (cid:2)). An authorization policy for a work-
ﬂow speciﬁcation is a relation A ⊆ S × U . A workﬂow au-
thorization schema is a tuple (S, U, (cid:2), A), where (S, (cid:2)) is a
workﬂow speciﬁcation and A is an authorization policy.

(cid:3)
If s < s

(cid:3)

then s must be performed before s

in any in-
stance of the workﬂow; if s (cid:4) s
may be per-
formed in either order. User u is authorized to perform step
s only if (s, u) ∈ A.2 We assume that for every step s ∈ S
there exists some user u ∈ U such that (s, u) ∈ A.

then s and s

(cid:3)

(cid:3)

Definition 2. Let (S, U, (cid:2), A) be a workﬂow authoriza-
tion schema. A plan is a function π : S → U . A plan π is
authorized for (S, U, (cid:2), A) if (s, π(s)) ∈ A for all s ∈ S.

Definition 3. Let S1, S2 ⊆ S, where either S1 or S2 (or
both) is a singleton set and ρ ∈ Rel(U ). Then a workﬂow
constraint has the form (ρ, S1, S2). A constrained workﬂow
authorization schema is a tuple (S, U, (cid:2), A, C), where C is
a set of workﬂow constraints.

Definition 4. A plan π : S → U satisﬁes constraint
(ρ, S1, S2) if there exist s1 ∈ S1 and s2 ∈ S2 such that
(π(s1), π(s2)) ∈ ρ. Given a constrained workﬂow authoriza-
tion schema (S, U, (cid:2), A, C), a plan π is valid if it is autho-
rized and it satisﬁes all constraints in C.

The above deﬁnition of a workﬂow constraint was intro-
duced by Wang and Li [17]. It generalizes that of Cramp-
ton [5], in which both S1 and S2 were singleton sets. A
further natural generalization is to deﬁne a constraint to be
a triple (ρ, S1, S2), where S1 and S2 are arbitrary subsets
of S, and to say that plan π satisﬁes constraint (ρ, S1, S2)
provided there exist si ∈ Si such that (π(s1), π(s2)) ∈ ρ.
In order to facilitate direct comparison with the work of
Wang and Li, we defer the discussion of these more general
constraints until Section 5.1. We will write s, rather than
the mathematically correct {s}, when s ∈ S appears as a
singleton in a constraint. When ρ is a symmetric relation
(meaning that (ρ, s, S
, s) is
) is satisﬁed if and only if (ρ, S
(cid:3)
satisﬁed), we will write constraints in the form (ρ, s, S
); that
is, the set of cardinality greater than or equal to 1 appears
after the set of cardinality 1.
2In practice, the set of authorized step-user pairs, A, will not
be deﬁned explicitly. Instead, A will be inferred from other
access control data structures. In particular, R2BAC – the
role-and-relation-based access control model of Wang and
Li [17] – introduces a set of roles R, a user-role relation U R ⊆
U × R and a role-step relation SA ⊆ R × S from which it is
possible to derive the steps for which users are authorized.
For all common access control policies (including R2BAC), it
is straightforward to derive A. We prefer to use A in order
to simplify the exposition.

(cid:3)

(cid:3)

(cid:3)

(cid:3)

The plan π satisﬁes constraint (ρ=, s, s

), for example, if
the same user is assigned to both steps by π, and satisﬁes
constraint (ρ(cid:2)=, s, s
) if diﬀerent users are assigned to s and
(cid:3)
s
. In other words, these represent, respectively, binding-of-
duty and separation-of-duty constraints. Abusing notation
in the interests of readability, we will replace ρ= and ρ(cid:2)= by =
and (cid:2)=, respectively. The constraint ((cid:2)=, s, S
(cid:3)
), for example,
(cid:3)
is satisﬁed by plan π if there is some step in S
to which some
user other than the one who performed step s is assigned.

We may now deﬁne the workﬂow satisﬁability problem, as

deﬁned by Wang and Li [17].

Workflow Satisfiability Problem (WSP)

Input: A constrained workﬂow authorization schema
Output: A valid plan π : S → U or an answer that there

(S, U, (cid:2), A, C)

exists no valid plan

Note that the above deﬁnition does not make any reference
to the ordering on the set of steps. The original deﬁnition,
as formulated by Crampton [5], required an algorithm for
WSP to output an execution schedule (a topological sort
of (S, (cid:2))) in addition to a valid plan. Again, to facilitate
direct comparison with the work of Wang and Li on the
ﬁxed parameter tractability of WSP, we defer discussion of
Crampton’s version of the problem until Section 5. Hence-
forth, we will write WSP(ρ1, . . . , ρt) to denote a special case
of WSP in which all constraints have the form (ρi, s, S
) or
(ρi, S

, s) for some i ∈ [t] and for some s ∈ S and S

(cid:3)
(cid:3) ⊆ S.

(cid:3)

3. ORGANIZATIONAL CONSTRAINTS

The work of Crampton [5, § 2] and of Wang and Li [17, Ex-
amples 1, 2] has noted that a constraint of practical interest
is that users performing two steps must be from the same
department.3 Indeed, in our example illustrated in Figure 1
one could require that the two users who perform steps s3
and s5 belong to the same department. Note, however, that
we will still require that these two users must be diﬀerent.
Similarly, we might wish to insist that the user who approves
the purchase order (step s2) belongs to the same department
as the user who creates the order (step s1).

In short, one can imagine many practical situations in
which some auxiliary information deﬁnes an equivalence re-
lation on the set of users (membership of department, for
example) and that we may wish to require that two steps are
performed by users belonging to either the same department
or to diﬀerent departments. In this section, we introduce two
relations that allow us to model organizational structures, in
which users are partitioned (possibly at several levels) into
diﬀerent organizational units, such as departments.
It is well known that an equivalence relation ∼ on a set X
induces a partition of X into equivalence classes. Conversely,
a partition of X gives rise to an equivalence relation. Given
an equivalence relation on U , we write ∼ in a constraint to
indicate that two users must belong to the same equivalence
class and (cid:2)∼ to denote that two users must belong to diﬀerent
equivalence classes. Hence, (∼, s3, s5) would indicate the
requirement that the signing and countersigning of the goods
received note must be performed by users belonging to the
same equivalence class (department, in this example).
3However, little is known about the complexity of the WSP
when such constraints are used, a deﬁciency we address in
the next section.

8593.1 Organizational Hierarchies

We now show how we can use multiple partitions to deﬁne
an organizational hierarchy. In Section 4.4, we describe a
ﬁxed-parameter tractable algorithm to solve WSP in the
presence of constraints deﬁned over such structures.
Let S be a set. An n-partition of S is an n-tuple
(F1, . . . , Fn) such that F1 ∪ ··· ∪ Fn = S and Fi ∩ Fj = ∅
for all i (cid:2)= j ∈ [n]. We will refer to the elements of an
n-partition as blocks.4

Definition 5. Let (X1, . . . , Xp) and (Y1, . . . Yq) be p-
and q-partitions of the same set. We say that (Y1, . . . Yq)
is a reﬁnement of (X1, . . . , Xp) if for each i ∈ [q] there ex-
ists j ∈ [p] such that Yi ⊆ Xj.

Definition 6. Let U be the set of users in an organi-
zation. An organizational (cid:4)-hierarchy is a collection of (cid:4)
partitions of U , U (1), . . . , U ((cid:2)), where U (i) is a reﬁnement of
U (i+1).

The ith partition is said to be the ith level of the hierarchy.
Each member of U (i) is a subset of U ; we write u(i) to denote
a block in the ith level of the hierarchy.
A constraint of the form (∼i, s1, s2), for example, is sat-
isﬁed by plan π if π(s1), π(s2) ∈ u(i) for some u(i) ∈ U (i).
that we may still deﬁne a constraint
Note, however,
((cid:2)=, s1, s2) which requires that the steps s1 and s2 are per-
formed by diﬀerent users.
More generally, a constraint of the form (∼i, S1, S2) is sat-
isﬁed by plan π if there exists s1 ∈ S1 and s2 ∈ S2 such that
π(s1) and π(s2) belong to the same block in U (i). A con-
straint of the form ((cid:2)∼i, S1, S2) is satisﬁed byπ if there exist
s1 ∈ S1 and s2 ∈ S2 such that π(s1) and π(s2) belong to
diﬀerent blocks in U (i). Note that if π satisﬁes (∼i, S1, S2),
then it satisﬁes (∼j, S1, S2) for all j > i. Conversely, if π
satisﬁes ((cid:2)∼i, S1, S2), then it also satisﬁes ((cid:2)∼j, S1, S2) for all
In other words, for each S1, S2 ⊆ S, we may and
j < i.
will assume without loss of generality that there is at most
one constraint of the form (∼i, S1, S2) and at most one con-
straint of the form ((cid:2)∼j, S1, S2).

We now introduce the notion of a canonical hierarchy. In-
formally, each level of a canonical hierarchy is diﬀerent, the
top level comprises a single block and the bottom level com-
prises the set of all singleton blocks. A canonical hierarchy
is shown in Figure 2, in which a, . . . , j represent users and
the rectangles deﬁne the partition blocks. Note that each
level is a reﬁnement of the one above.

More formally, we have the following deﬁnition.
Definition 7. Let H = U (1), . . . , U ((cid:2)), where U (i) is a
reﬁnement of U (i+1), be a hierarchy. We say H is canonical
if it satisﬁes the following conditions: (i) U (i) (cid:2)= U (i+1);
(ii) U ((cid:2)) is a 1-partition containing the set U ; (iii) U (1) is
an n-partition containing every singleton set (from U ).

Let U (1), . . . , U ((cid:2)) be some hierarchy and let C be a set of
workﬂow constraints. We conclude this section by showing
how we may convert the hierarchy into a canonical hierar-
chy by ﬁrst removing duplicate levels, adding suitable top
and bottom levels (if required), and making appropriate ad-
justments to C. More formally, we perform the following
operations:
4One or more blocks in ann -partition may be the empty
set.

a

a

a

a

a

a

a

b

b

b

b

b

b

b

c

c

c

c

c

c

c

d

d

d

d

d

d

d

e

e

e

e

e

e

e

f

f

f

f

f

f

f

g

g

g

g

g

g

g

h

h

h

h

h

h

h

i

i

i

i

i

i

i

j

j

j

j

j

j

j

Figure 2: A canonical organizational hierarchy

• If U (i) = U (i+1)

for

some

i

then we

re-
place all constraints of the form (∼i+1, S1, S2) and
((cid:2)∼i+1, S1, S2) with constraints of the form (∼i, S1, S2)
and ((cid:2)∼i, S1, S2), respectively. We then remove U (i+1)
from the hierarchy as there are now no constraints that
apply to U (i+1).
• If no partition in the hierarchy has one element (con-
sisting of a single block U ), then add such a partition to
the hierarchy. Clearly every partition is a reﬁnement
of the 1-partition (U ).
• If no partition in the hierarchy has n elements, then
add such a partition to the hierarchy. Clearly such a
partition is a reﬁnement of every other partition.
• Finally, we renumber the levels and the constraints

where appropriate with consecutive integers.

The conversion of a hierarchy to canonical form can be
performed in O((cid:4)n + c) time (since we require O((cid:4)n) time
to ﬁnd all layers that may be deleted and then delete them,
and O(c) time to update the constraints). The number of
levels in the resulting canonical hierarchy is no greater than
(cid:4) + 2.
3.2 Organizational Hierarchies from Man-

agement Structures

We now illustrate how organization hierarchies may be
constructed in a systematic fashion from management struc-
tures. Given a set of users U , we assume that an organiza-
tion deﬁnes a hierarchical binary relation (cid:4) on U in order to
specify management responsibilities and reporting lines. We
assume that the Hasse diagram of (U, (cid:4)) is a directed tree in
which non-leaf nodes represent users with some managerial
responsibility and edges are directed from root node to leaf
nodes. Let Gman = (U, Eman) denote the Hasse diagram of
(U, (cid:4)). The fact that Gman is a tree means that no user has
more than one manager. A user u has direct responsibil-
ity for (or is the line manager of) user v if (u, v) ∈ Eman.
We also assume that the out-degree of a non-leaf node is
at least two. Both of these assumptions would seem to be
reasonable for most organizations with a hierarchical man-
agement structure. (The study of more exotic management
structures such as matrix management is deferred to future
work.)

We now describe one method by which an organizational
hierarchy may be derived from a management tree. Given
a management tree Gman we iteratively construct manage-
ment trees with fewer and fewer nodes as follows:

1. we ﬁrst identify every sub-tree in which there is a single

non-leaf node;

8602. for each such sub-tree we form a single leaf node whose
label is formed from the labels for the respective leaf
nodes;

3. for each resulting sub-tree we form a single node whose
label is formed from the labels of the child and parent
nodes.

We then repeat for the resulting tree, terminating when we
have a tree containing a single node. The above procedure is
illustrated in Figure 3. The ﬁgure shows a sequence of trees,
the ﬁrst of which deﬁnes the management tree in which each
node is labeled with a single user.

j

j

d

b

a

c

e

i

f

d

i

h

abc

e

g

h

f g

a | b | c | d | e | f | g | h | i | j

abc | d | e | f g | h | i | j

j

i

abcd

i

abcd

j

e

abcd | e | f gh | i | j

f gh

ef gh
abcd | ef gh | i | j

j

j

ef ghi
abcd
abcd | ef ghi | j

abcdef ghi
abcdef ghi | j

abcdef ghij

abcdef ghij

Figure 3: Building the blocks of an organizational
hierarchy from a management tree

Each management tree thus derived is associated with a
partition; the corresponding partition of U is written be-
low each tree in Figure 3, with a vertical bar indicating the
block boundaries. By construction, the collection of parti-
tions forms a canonical organizational hierarchy. The orga-
nizational hierarchy derived from the management tree in
Figure 3 is displayed in Figure 2. Note that the number
of levels in the organizational hierarchy is equal to 2p + 1,
where p is the number of edges in the longest directed path
in Gman.

Having constructed the organizational hierarchy, we may
now deﬁne constraints on step execution. We will use our
purchase order workﬂow from Figure 1 as an example and
the organizational hierarchy in Figure 2.
We could, for example, deﬁne the constraint (∼5, s1, s2).
In the absence of other constraints, this constraint means
that users from the set {a, b, c, d} or {e, f, g, h, i} (which we
might suppose represent two distinct departments within
the management structure) or user j could raise (step s1)
and approve (step s2) purchase orders, but an attempt by a

user from one department to approve an order raised by a
member of another department would violate the constraint.
We could deﬁne a second constraint ((cid:2)4, s1, s2), which
means that user i must perform one of s1 and s2 (and also
means that no user from{ a, b, c, d, j} can perform either s1
or s2 because there would no way to simultaneously satisfy
constraints (∼5, s1, s2) and ((cid:2)4, s1, s2)). If we assume that
junior members of the department (users e, f , g and h) are
not authorized to approve purchase orders, the collective ef-
fect of the two constraints above and the authorization pol-
icy is to require that (a) purchase orders are only approved
by managers, and (b) purchase orders are only raised by
junior members of staﬀ.

Pursuing the last point brieﬂy, it has long been recognized
that a limitation of role-based access control is the “feature”
that (senior) users assigned to the most powerful roles ac-
crue all the permissions of more junior roles (see [14], for
example). It is interesting to note that the constraints and
the method of constructing an organizational hierarchy de-
scribed above can be used to restrict the steps that senior
managers can perform.

In summary, we believe that our deﬁnition of organiza-
tional hierarchy provides an appropriate way of modeling
hierarchical management structures and supports the spec-
iﬁcation of constraints that provide greater ﬂexibility than
those in the literature [2, 5, 17]. Moreover, as we will see
in the next section, the complexity of WSP for these new
constraints remains ﬁxed-parameter tractable.

Finally, we note that there are several ways in which the
construction of an organizational hierarchy from a manage-
ment tree described above could be modiﬁed: for example,
each iteration might collapse a single sub-tree rather than
all sub-trees or each iteration might immediately collapse
the root node and all the leaf nodes into a single node. Each
construction will give rise to diﬀerent organizational hierar-
chies, some with more levels, some with fewer. These organi-
zational hierarchies each admit the speciﬁcation of diﬀerent
constraints. The study of such hierarchies and the utility
of the constraints that can be deﬁned over them will be the
subject of future work.

4. FPT ALGORITHMS FOR WSP
In this section, we prove a new bound for the ﬁxed parame-
terized complexity of WSP((cid:2)=, =). We also prove that WSP
remains ﬁxed-parameter tractable when we include con-
straints based on equivalence relations and organizational
hierarchies. In order to make the paper self-contained, we
ﬁrst provide a short overview of ﬁxed-parameter complexity
and state an important, recent result in this area.
4.1 Parameterized Complexity

A na¨ıve approach to solving WSP would consider every
possible assignment of users to steps in the workﬂow. There
are nk such assignments if there are n users and k steps,
so an algorithm of this form would have complexity O(cnk),
where c is the number of constraints. Moreover, Wang and
Li showed that WSP is NP-hard, by reducing Graph k-
Colorability to WSP((cid:2)=) [17, Lemma 3]. In short, WSP
is hard to solve in general. The importance of ﬁnding an
eﬃcient algorithm for solving WSP [5] led Wang and Li to
look at the problem from the perspective of parameterized
complexity [17].

Suppose we have an algorithm that solves an NP-hard

861problem in time O(f (k)nd), where n denotes the size of
the input to the problem, k is some (small) parameter of
the problem, f is some function in k only, and d is some
constant (independent of k and n). Then we say the al-
gorithm is a ﬁxed-parameter tractable (FPT) algorithm. If
a problem can be solved using an FPT algorithm then we
say that it is an FPT problem and that it belongs to the
class FPT. Wang and Li showed that WSP(=,(cid:2)=) is FPT:
speciﬁcally, they constructed an algorithm that runs in time
O(kk+1(k − 1)k2
n), where k is the number of steps in
the workﬂow and n is the size of the input to the prob-
lem [17, Theorem 8]; it follows that WSP(=,(cid:2)=) is FPT.

k−1

Wang and Li also proved that WSP is W[1]-hard in gen-
eral [17, Theorem 10]. By deﬁnition, FPT is a subset of W[1]
and a parameterized analog of Cook’s Theorem [8] as well
as the Exponential Time Hypothesis [9,11] strongly support
the widely held view that FPT is not equal to W[1]. One of
the main contributions of this paper is to extend the set of
special cases of WSP that are known to be FPT.

When the runtime O(f (k)nd) is replaced by the much
more powerful O(nf (k)), we obtain the class XP, where each
problem is polynomial-time solvable for any ﬁxed value of
k: There is an inﬁnite number of parameterized complexity
classes between FPT and XP (for each integer t ≥ 1, there
is a class W[t]) and they form the following tower: FPT ⊆
W[1] ⊆ W[2] ⊆ ··· ⊆ W[P] ⊆ XP. For formal deﬁnitions of
Henceforth, we often write (cid:2)O(T ) instead of O(T logd T ) for
classes W[t], see [8, 9], for example.
any constant d. That is, we use the notation (cid:2)O to suppress

polylogarithmic factors. This notation is often used in the
literature on algorithms – see, for example, [3, 12] – to avoid
cumbersome runtime bounds.

Our work on WSP makes use of the following result, due
to Bj¨orklund et al. [3], regarding the complexity of the Max
Weighted Partition problem.

Max Weighted Partition

Input: A setS of k elements and n functions φi,
i ∈ [n], from 2S to integers from the range
[−M, M ] (M ≥ 1).

Output: An n-partition (F1, . . . , Fn) of S that

(cid:3)n
i=1 φi(Fi).

maximizes

Theorem 1. Max Weighted Partition can be solved

in time (cid:2)O(2kn2M ).
4.2 A New Algorithm for WSP

iﬀ π(s) = π(s

(cid:3)

More formally,

We now introduce a new method for solving WSP. The
basic idea is to construct a valid plan by partitioning the set
of steps S into blocks of steps, each of which is allocated to
a single (authorized) user.
let π be a valid plan for a workﬂow
(S, U, (cid:2), A, C) and deﬁne an equivalence relation ∼π on S,
where s ∼π s
). We denote the set of equiv-
alence classes of ∼π by S/π and write [s]π to denote the
equivalence class containing s.
(cid:3)

Now it is easy to see that there are certain subsets S
of S for which there cannot exist a valid plan π such that
(cid:3) ∈ S/π. In particular, consider the constraint ((cid:2)=, s, s
(cid:3)
S
),
for example. Then, for any valid plan π, it must be the case
that [s]π (cid:2)= [s
]π. In other words, there does not exist a valid
plan π such that {s, s
(cid:3)} ∈S/π . We call such sets ineligible.

(cid:3)

(cid:3)

We solve WSP by computing a partition of S in which
each block of the partition is assigned to a diﬀerent user
and each user is authorized to perform all steps in the block
to which she is assigned. Our strategy for solving WSP,
then, is the following:

1. take the powerset of S and eliminate all subsets that

are ineligible;

2. for each remaining set F , identify which users are au-

thorized for all steps in F ;

3. construct a partition of S such that each block is allo-
cated to a user authorized for each step in that block
and no user is allocated to more than one block (we
can ﬁnd such a partition using Theorem 1).

The resulting partition and allocation of users to blocks in
that partition deﬁnes a valid plan.

Remark 1. Note that a constraint ((cid:2)=, S1, S2) is equiv-
alent5 to ((cid:2)=, S1, S2 \ S1) and that a constraint (=, S1, S2)
is always satisﬁed when S1 ∩ S2 (cid:2)= ∅. Thus, in the rest
of the paper we assume that, in constraints ((cid:2)=, S1, S2) and
(=, S1, S2), the sets S1 and S2 are disjoint.

It is easy to determine whether a set is ineligible when
the set of constraints only contains constraints of the form
((cid:2)=, S1, S2) or of the form (=, S1, S2), when S1 is a singleton.
In particular, we have the following simple result, illustrated
schematically in Figure 4.

(cid:3)
1, S

i, for some i ∈ {1, 2}.
(cid:3)

Proposition 1. Let (S, U, (cid:2), A, C) be a workﬂow and let
C contain constraints ((cid:2)=, S1, S2) and (=, S
(cid:3)
2), where S1
1 are singleton sets. Then F ⊆ S is ineligible if either
(cid:3)
and S
of the following conditions hold: (i) F ⊇ S1 ∪ S2; (ii) F ∩
1 ∪ S
(cid:3)
(cid:3)
(S
2) =S
Proof. Suppose (in order to obtain a contradiction) that
F ⊇ S1 ∪ S2 is eligible. Then, by deﬁnition, there must exist
a valid plan π such that F ∈ S/π, which, in turn, means that
a single user has been allocated to all steps in F by π. But
such an allocation violates constraint ((cid:2)=, S1, S2) and hence
the plan is not valid. A similar proof by contradiction can
be used to establish the second result.

F

S1

S2

(a) ((cid:2)=, S1, S2)

F

S1

S2

(b) (=, S1, S2)

F

S2

S1

(c) (=, S1, S2)

Figure 4: Ineligible sets F for constraints (ρ, S1, S2),
ρ ∈ {=,(cid:2)=}

5Equivalent in the sense that a plan π satisﬁes the former
constraint iﬀ it satisﬁes the latter.

862Example 1. Using the workﬂow in Figure 1, for exam-
ple, we ﬁnd that any subset of cardinality four or greater
is ineligible; and all subsets of cardinality three are ineligi-
ble, except for {s1, s3, s6}, {s2, s4, s5} and {s2, s5, s6}. We
also have that {s1} and {s3} are ineligible (because of the
binding-of-duty constraint on s1 and s3). Similarly any su-
perset of {s1} that does not contain s3 is ineligible and vice
versa.

If we were to ﬁnd that there existed a user u, authorized
for s1, s3 and s6, and a diﬀerent user v, authorized for s2,
s4 and s5, then we would know that this instance of WSP is
satisﬁable. Note the requirement that u and v be diﬀerent: if
they were the same then u would perform all steps, violating
all separation-of-duty constraints. Conversely, if we were to
ﬁnd that there is no user authorized for s1 and s3 then we
would know that the workﬂow is unsatisﬁable.
Suppose now that we replace the constraint (=, s1, s3) with
the constraint (=, s1,{s3, s5}), which has the eﬀect of requir-
ing that the same user that creates the order either signs or
countersigns the goods received note (but not both, given the
constraint ((cid:2)=, s3, s5)). Then {s1} is ineligible (as before)
but {s3} and {s1, s5} are no longer ineligible; any superset
of {s3, s5} is ineligible.
Theorem 2. WSP(=,(cid:2)=) can be solved in time (cid:2)O(2k(c +

n2)), where k is the number of steps, c is the number of
constraints and n is the number of users.

Proof. Consider an instance W = (S, U, (cid:2), A, C) of
WSP(=,(cid:2)=). We construct a binary matrix with n rows
(indexed by elements of U ) and 2k columns (indexed by el-
ements of 2S) in which the entry indexed by u ∈ U and
F ⊆ S is deﬁned to be 0 if and only if F (cid:2)= ∅ is ineligible
or there exists s ∈ F such that (s, u) (cid:2)∈ A. (Note that every
entry in the column labeled with ∅ is set to 1.) In other
words, each non-zero matrix entry represents a set of steps
that could be assigned to a single user in a valid plan.

The matrix deﬁned above encodes a family of

tions {φu}u∈U , φu : 2S → {0, 1}. We now solve Max
Weighted Partition on input S and {φu}u∈U . Observe
(cid:3)n
i=1 φi(Fi) (cid:2) n, with equality if and only if W is

func-

that
satisﬁable.

We now consider the complexity of the above algorithm.
We consider each of the 2kn elements in the matrix. We
set the entry for (u, F ) equal to 0 if one of the following
conditions holds:
• there exists a constraint of the form ((cid:2)=, S1, S2) with
S1 ∪ S2 ⊆ F ;
• there exists a constraint of the form (=, S1, S2) with
F ∩ (S1 ∪ S2) = Si for i ∈ {1, 2};
• there exists s ∈ F such that (s, u) (cid:2)∈ A.

The ﬁrst two conditions check whether F is ineligible (see
Proposition 1), while the last condition tests whether u is
authorized for all the steps in F . We can identify the ineli-

gible sets in time O(2kck) = (cid:2)O(2kc). We can then construct
the matrix in O(2knk) = (cid:2)O(2kn) time. Finally, we can solve
Max Weighted Partition in (cid:2)O(2kn2) time. Thus, the to-
tal time required to solve WSP(=,(cid:2)=) is in (cid:2)O(2k(c+n2)).

The special case of the workﬂow satisﬁability problem
WSP((cid:2)=) was studied by Wang and Li from the perspec-
tive of ﬁxed-parameter tractability; the complexity of their
algorithm is O(kk+1N ) = 2O(k log k)N , where N is the size of

the input [17, Lemma 8]. Fellows et al. considered the ﬁxed-
parameter tractability of a special case of the constraint sat-
isfaction problem [15] in which all constraints have the same
form. With these restrictions, the constraint satisfaction
problem is identical to WSP in which all constraints have
the form ((cid:2)=, s1, s2). The algorithm of Fellows et al. has
complexity O(k!kn) = 2O(k log k)n, where n is the number
algorithm with complexity (cid:2)O(2k(c + n2)), so we have im-
of users [10, Theorem 3.1]. Theorem 2 above exhibits an
proved the exponential factor of the best known bounds for
WSP((cid:2)=) in terms of the function in k (which is often the
dominating factor in the complexity of FPT algorithms).
We now demonstrate that it is impossible, assuming the
well-known Exponential Time Hypothesis [11], to improve
this result to any signiﬁcant degree.

Exponential Time Hypothesis
There exists a real number  >0 such that 3-SAT
cannot be solved in time O(2n), where n is the number
of variables.
Theorem 3. Even if there are just two users, WSP((cid:2)=)
cannot be solved in time (cid:2)O(2k) for some positive real ,

where k is the number of steps, unless the Exponential Time
Hypothesis fails.

The proof of this result (and Theorem 5) can be found in

the appendix.
4.3 Equivalence Relation Constraints

Observe that the equality relation is an equivalence re-
lation in which each of the equivalence classes comprises a
single element, and so = and (cid:2)= may be modelled as in-
stances of ∼ and (cid:2)∼. Henceforth, therefore, we only consider
constraints of the form (∼, S1, S2) and ((cid:2)∼, S1, S2).
In Proposition 2 below, we prove that WSP(∼,(cid:2)∼) is FPT,
thereby extending the class of workﬂow speciﬁcations for
which the satisﬁability problem is in FPT. In turn, Propo-
sition 2 will be signiﬁcantly extended in Theorem 4.

(cid:3)

(cid:3)

(cid:3)

(cid:3)

.

(cid:3)

relation ∼ deﬁned on U , WSP(∼,(cid:2)∼) is FPT.

Proposition 2. For any user set U and any equivalence
Proof. Consider an instance of the problem W =
(S, U, (cid:2), A, C) and let V1, . . . , Vm be the equivalence classes
of ∼. Then consider the following workﬂow speciﬁcation:
W(cid:3)

, (cid:2), A
= {V1, . . . , Vm};
(cid:3)
(cid:3) ⊆ S × U
(cid:3)
that (s, u) ∈ A;

= (S, U
• U
• A
if there exists u ∈ Vi such
• each constraint of the form (∼, S1, S2) inC is replaced
• each constraint of the form ((cid:2)∼, S1, S2) inC is replaced

), where

, C
and (s, Vi) ∈ A

; and

(cid:3)

by (=, S1, S2) in C
by ((cid:2)=, S1, S2) in C

is, and

It is easy to see that W is satisﬁable if and only if W(cid:3)
deciding the satisﬁability of W(cid:3)
is FPT by Theorem 2.
4.4 Organizational Hierarchy Constraints
We have seen that if we are given a single equivalence
relation and only use the binary relations ∼ and (cid:2)∼ then
WSP(∼,(cid:2)∼) is equivalent to WSP(=,(cid:2)=), which is known to
be FPT. Moreover, we prove in Theorem 4 that the problem
remains in FPT for such hierarchies. In fact, the results in
Theorem 2 and Proposition 2 correspond to special cases of

863Theorem 4, in which the hierarchy has two levels. Figure 5
illustrates these hierarchies, where each user is represented
by an unﬁlled circle and blocks of users are enclosed by a
rectangle. Conversely, it is these special cases that provide
the foundation for the bottom-up iterative method that we
use in the proof of Theorem 4 to solve WSP for more com-
plex hierarchical structures.

(a) Single users

(b) Non-trivial equivalence relation

Figure 5: Two-level hierarchies

Theorem 4. Given a workﬂow (S, U, (cid:2), A, C) and a
canonical hierarchy with (cid:4) levels, WSP(∼1,(cid:2)∼1, . . . ,∼ (cid:2),(cid:2)∼(cid:2))
can be solved in time (cid:2)O(cn2k + n23k), where n, k and c are

the numbers of users, steps and constraints, respectively.

To prove the above result, we iteratively identify ineligible
sets, from the bottom of the hierarchy up, for particular
types of blocks in the hierarchy (those shaded in Figure 6)
and solve multiple instances of WSP for each of those blocks.
Theorem 2 is, essentially, a special case of the above result,
in which the canonical hierarchy contains two levels, where
U (1) = ({u1} , . . . ,{ un}) and U (2) = (U ).

a

a

a

a

a

a

a

b

b

b

b

b

b

b

c

c

c

c

c

c

c

d

d

d

d

d

d

d

e

e

e

e

e

e

e

f

f

f

f

f

f

f

g

g

g

g

g

g

g

h

h

h

h

h

h

h

i

i

i

i

i

i

i

j

j

j

j

j

j

j

Figure 6: The canonical hierarchy of Figure 3 with
its signiﬁcant blocks shaded

Proof of Theorem 4. Each level in a canonical hierar-
chy is a reﬁnement of the one below it and no two levels are
equal, so we have n = |U (1)| > ··· > |U ((cid:2))| = 1, and we may
conclude that (cid:4) (cid:2) n.
We say V ∈ U (i) is signiﬁcant if V (cid:2)∈ U (i+1). The sig-
niﬁcant blocks are shaded in the hierarchy shown in Fig-
ure 6. We deﬁne the level range of V to be an interval [a, b],
where a is the least value i such that V ∈ U (i) and b is the
largest value i such that V ∈ U (i). The level range of block
{a, b, c, d} in Figure 6 is [3, 5], for example.
Each signiﬁcant block V with level range [a, b], a > 1, can
be partitioned into blocks in level (a − 1). (Block {a, b, c, d}
is partitioned into {{a, b, c} ,{d}} in level 2, for example.)
We denote this set of blocks by Δ(V ). It is easy to see that
the graph G = (V, E), where V is the set of signiﬁcant blocks
and (V1, V2) ∈ E if V1 ∈ Δ(V2), is a tree.

For each signiﬁcant block V in the hierarchy with level
range [a, b], working from the bottom level to the top level
of the hierarchy, we compute a function φV : 2S → {0, 1},

where φV (F ) = 1 if and only if there exists an assignment
of authorized users from V to steps in F that satisﬁes all
the constraints at level b and below. Informally, we will be
solving multiple instances of WSP for the sub-tree rooted
at V in order to compute φV .
Each signiﬁcant block V with level range [1, b] comprises
a single user (see Figure 6). For F ⊆ S we set φV (F ) = 0 if
one of the following conditions hold:
• there exists a constraint of the form ((cid:2)∼t, S1, S2), t ∈
[1, b], such that S1 ∪ S2 ⊆ F ;
• there exists a constraint of the form (∼t, S1, S2), t ∈
[1, b], such that F ∩ (S1 ∪ S2) = Si for i ∈ {1, 2};
• there exists s ∈ F such that (s, u) (cid:2)∈ A.
For each signiﬁcant block V , we now compute a binary
matrix with rows indexed by members of Δ(V ) and columns
indexed by subsets of S. The entry indexed by W ∈ Δ(V )
and F ⊆ S is deﬁned to be 0 if and only if one of the following
conditions holds:
• there exists a constraint of the form ((cid:2)∼t, S1, S2), t ∈
• there exists a constraint of the form (∼t, S1, S2), t ∈
• φW (F ) = 0.

[a, b], such that S1 ∪ S2 ⊆ F ;
[a, b], such that F ∩ (S1 ∪ S2) =S i for i ∈ {1, 2};

A non-zero matrix entry indicates that the steps in F could
be assigned to the block W (which implies that no con-
straints in levels 1, . . . , a − 1 would be violated) and that
no constraints would be violated in levels a, . . . , b by allo-
cating a single block to F . The matrix encodes a family of
functions {φW}W∈Δ(V ), φW : 2S → {0, 1}. We then solve
Max Weighted Partition with inputs F ⊆ S, and {φW}
and set φV (F ) = 1 if Max Weighted Partition returns
W φW (F ) =|Δ(V )|. Note that U
a partition such that
is a signiﬁcant block (being the single block in the top level
of the hierarchy). Note also that WSP is satisﬁable if and
only if φU (S) = 1.

(cid:3)

This completes the description of the algorithm. We now
consider its complexity. Consider the signiﬁcant block V
with level range [a, b], a >1, and m children. (It takes time
O((cid:4)) = O(n) to compute the level range of V .) Note that we
can initialize the matrix using the functions {φW} that were
computed for the (a − 1)th level. We then change the non-
zero entries for those F ⊆ S that are ineligible. As in the
takes time O(2kck) = (cid:2)O(2kc), so the time taken to update
proof of Theorem 2, the identiﬁcation of the ineligible sets
the matrix is (cid:2)O(2kcm).
The time taken to compute φV for V with level range [1, b]
sets, which takes (cid:2)O(2kc). For V with level range [a, b], a > 1,
is dominated by the time taken to compute the ineligible
we solve Max Weighted Partition for all F ⊆ S. The
Partition is (cid:2)O(2
time taken to solve a single instance of Max Weighted
instances of WSP (for V ) is (cid:2)O(3km2).6 Finally, the total
m2). Hence, the time taken to solve all
time taken to compute φV is (cid:2)O(n + cm2k + m23k).

|F|

We next count the number of signiﬁcant blocks. As we ob-
served earlier, the set of signiﬁcant blocks ordered by subset
inclusion forms a tree. Moreover, every non-leaf node in G
has at least two children, which implies that G has no more
than 2n − 1 nodes (so |V| (cid:2) 2n − 1).

Finally, let mV denote the number of children of a signif-

(cid:3)

S(cid:2)⊆S 2

|S(cid:2)|

=

(cid:3)k

i=0

(cid:5)

(cid:4)

k
i

2i = 3k.

6Note that

864icant block V . Then(cid:6)

(cid:2)O(mV ) =

(cid:6)
V ∈V

O(mV log

b

mV )

V ∈V

b

b

mV log

V ∈V log

mV (cid:2) max

for some b (cid:3) 0. But
(cid:6)
V ∈V
(cid:3)
V ∈V (cid:2)O(m2
time taken to compute φV for all V is (cid:2)O(cn2k + n23k).

V ∈V (cid:2)O(mV ) = (cid:2)O(n). Similarly, we can show that
V ) = (cid:2)O(n2). Hence, we conclude that the total

(cid:6)
V ∈V

mV = O(n log

Hence

(cid:3)

mV

n) = (cid:2)O(n).

b

5. EXTENSIONS TO WSP

The workﬂow satisﬁability problem studied in this paper
was deﬁned by Wang and Li, which, in turn, was based on
the workﬂow model proposed by Crampton [5]. Wang and
Li’s formulation of the problem diﬀers in two crucial aspects
from that of Crampton. Both aspects are related to the
deﬁnition of constraints. On the one hand, Wang and Li
make the constituent sets of the constraints more complex:
where Crampton assumed that both sets were singletons,
Wang and Li allow at most one of those sets to have car-
dinality greater than one; this means that more complex
relationships between the users that perform the steps can
be speciﬁed using constraints. On the other hand, Wang
and Li ignore the partial ordering on workﬂow steps when
deﬁning constraints, whereas Crampton made a distinction
between the constraints (ρ, s1, s2) and (ρ, s2, s1) and disal-
lowed a constraint of the form (ρ, s2, s1) if s1 < s2.

In this section, we discuss several diﬀerent ways in which
WSP may be extended. First, we extend the deﬁnition of
constraints so that they are more general than those consid-
ered by Wang and Li. Second, we consider the original work-
ﬂow satisﬁability problem deﬁned by Crampton and demon-
strate that special cases of the problem are FTP.
5.1 More General Constraints

Crampton’s model for workﬂows assumed that constraints
had the form (ρ, s1, s2). In other words, constraints are ap-
plied to pairs of steps. Wang and Li then extended con-
straints so that they could have the form (ρ, S1, S2), where
only one of S1 and S2 was required to be a singleton. It is
easy to see that the equality relation is not interesting (at
least for workﬂow satisﬁability) for constraints of the origi-
nal, simpler form. Indeed, WSP(=) can be solved in polyno-
mial time [17] for constraints of Crampton’s form. However,
the equality relation does have a signiﬁcant impact on the
complexity when the constraints may include non-singleton
sets.

It is interesting to consider, therefore, the eﬀect on WSP
of having constraints of the form (ρ, S1, S2), where S1 and
S2 are arbitrary subsets of S. The criterion for a plan to
be valid remains the same: there should exist si ∈ Si, i =
1, 2, such that (π(s1), π(s2)) ∈ ρ. For ease of reference,
Type 1 constraints will refer to those of the form deﬁned by
Crampton [5], Type 2 will refer to Wang-Li constraints [17],
and Type 3 will mean the most general form of constraints
described above.

Theorem 5. Let ∼1, . . . ,∼ (cid:2) deﬁne an organizational hi-
erarchy. Let (S, U, (cid:2), A, C ∪ C∼ ∪ C(cid:2)∼) be a workﬂow,
where C is the set of Type 2 constraints, C∼ is the set of

Type 3 constraints of the form (∼i, S1, S2) and C(cid:2)∼ is the
set of Type 3 constraints of the form ((cid:2)∼i, S1, S2). Then
WSP(∼1, . . . ,∼ (cid:2),(cid:2)∼1, . . . ,(cid:2)∼(cid:2)) can be solved in time

(cid:2)O((c + 2c

(cid:3)

)n2
where c = |C| + |C(cid:2)∼| and c
(cid:3)
WSP(∼1, . . . ,∼ (cid:2),(cid:2)∼1, . . . ,(cid:2)∼(cid:2)) is FPT.
5.2 Ordered WSP

k+c(cid:2)

+ n23

k+c(cid:2)
= |C∼|. Moreover, c

),

(cid:3) (cid:2) 3k, so

We note that the version of WSP considered so far in this
paper makes no use of the order relation on the set of steps.
This is a simpliﬁcation introduced by Wang and Li [17].
In fact, the deﬁnition of workﬂow constraints in Cramp-
(cid:3)
ton’s model [5] prohibited constraints of the form (ρ, s, s
)
for s > s
. Moreover, a plan was required to specify an
execution order for the steps in the workﬂow (in addition
to the assignment of steps to users). This, in turn, means
that Crampton’s deﬁnition of constraint satisfaction (and
hence of the workﬂow satisﬁability problem) is more com-
plex. More formally, we have the following deﬁnitions.

(cid:3)

Definition 8. Let W = (S, U, (cid:2), A, C) be a workﬂow
comprising k steps. A tuple (s1, . . . , sk) is an execution
schedule for W if {s1, . . . , sk} = S and, for all 1 (cid:2) i <
j (cid:2) k, si (cid:2)(cid:3) sj.7 We say si precedes sj in an execution
schedule if i < j.

For the workﬂow depicted in Figure 1, (s2, s1, . . .) is not
an execution schedule, for example, but (s1, s2, s3, s5, s4, s6)
and (s1, s2, s3, s4, s5, s6) are.

Definition 9. The (Type 1) constraint (ρ, s, s

) is satis-
ﬁed by execution schedule σ and plan π if one of the follow-
)) ∈ ρ; (ii) s
(cid:3)
ing holds: (i) s precedes s
precedes s in σ.

in σ and (π(s), π(s

(cid:3)

(cid:3)

(cid:3)

(cid:3)

The intuition here is that a constraint (ρ, s, s

) is well-
(cid:3)
formed only if s could precede s
in the execution of some
or s (cid:4) s
instance of the workﬂow (that is, either s < s
).
(cid:3)
Moreover, if s does occur before s
, then the execution of
(cid:3)
s
is constrained by ρ and the identity of the user that per-
formed s. A modiﬁed version of WSP, based on the above
deﬁnitions, is deﬁned in the following way.

(cid:3)

(cid:3)

Ordered WSP (OWSP)

Input: A constrained workﬂow authorization schema

(S, U, (cid:2), A, C).

Output: True if there exists an execution schedule σ
and a plan π that satisfy all constraints in C,
and False otherwise.

Note that it may not be possible to ﬁnd a valid plan π for
a particular execution schedule σ. Conversely, there may be
a plan π for which there exist schedules σ and σ
such that
(σ, π) satisﬁes all constraints but (σ

, π) does not.

(cid:3)

(cid:3)

Example 2. Suppose S = {s1, s2, s3, s4}, such that s1 <
s2 < s4, s1 < s3 < s4 and s2 (cid:4) s3, and C = {((cid:2)=, s2, s3)}.
Then we may deﬁne a plan π with the property that π(s2) =
π(s3), in which case ((s1, s2, s3, s4), π) is not a solution to
OWSP (since there is a restriction on the user that performs
7In other words, an execution schedule is a linear extension
or topological sort of (S, (cid:2)).

865s3 once the identity of the user that performs s2 has been
ﬁxed), whereas ((s1, s3, s2, s4), π) is a solution (since there is
no restriction on the user that performs s2 if s3 is performed
ﬁrst).

In other words, there exist workﬂows for which a plan π
is not a solution to WSP, but for which (σ, π) is a solution
to OWSP for certain choices of σ. Crampton introduced
the notion of a well-formed workﬂow, which has the follow-
for all si (cid:4) sj, (ρ, si, sj) ∈ C if and only if
ing property:
(˜ρ, sj, si) ∈ C. To ensure that the workﬂow in the above ex-
ample is well-formed, we would add the constraint ((cid:2)=, s3, s2)
to C. It is easy to see that OWSP for well-formed work-
ﬂows and WSP are essentially equivalent, since a valid plan
for one execution schedule will be a valid plan for any exe-
cution schedule [5, Lemma 9]. However, there are practical
examples of workﬂows that are not well-formed [6].

Note that OWSP is only deﬁned for Type 1 constraints
(see Deﬁnition 9). Since WSP is shown to be W[1]-hard even
if only Type 1 constraints are used [17] and since OWSP is
a generalization of WSP provided only Type 1 constraints
are used, OWSP is W[1]-hard. However, we can prove the
following analog of Theorem 2. (We can also prove a similar
analog of Theorem 4.)

Proposition 3. OWSP(=,(cid:2)=) is FPT.
Proof. The crucial point is that the number of linear ex-
tensions of (S, (cid:2)) (and hence possible execution schedules)
is determined only by k. Speciﬁcally, the number of linear
extensions is no greater than k!. Then for each linear ex-
tension, we ﬁrst eliminate any constraints that are rendered
irrelevant by that linear extension and then solve an instance
of WSP(=,(cid:2)=) for the remaining constraints. Thus the com-
plexity of OWSP(=,(cid:2)=) is that of WSP(=,(cid:2)=) multiplied by
a function f (k) dominated by k!.

It is also worth noting that Crampton’s constraints in-
cluded the option of restricting the set of users to which the
constraint applied. A constraint of the form (D, ρ, s1, s2)
(D ⊆ U is the domain of the constraint) is satisﬁed by a
plan π : S → U if one of the following conditions holds:
(i) π(s1) (cid:2)∈ D; (ii) (π(s1), π(s2)) ∈ ρ. In other words, the
constraint on the execution of s2 only applies if s1 is per-
formed by a user in D; users in U \ D are exempt. This
allows us to specify that certain senior (trusted) users are
not subject to separation-of-duty constraints, for example.
Some entries in the table indexed by users and subsets
of S will be set to 1 rather than 0 with this extended form
of constraints. It is easy to see, therefore, that the use of
such constraints does not increase the complexity of WSP
provided that we can test whether a user belongs to the
domain of a constraint in time polynomial in n.

6. CONCLUDING REMARKS

6.1 Related Work

Work on computing plans for workﬂows that must simul-
taneously satisfy authorization policies and constraints goes
back to the seminal paper of Bertino et al. [2]. This work
considered linear workﬂows and noted the existence of an
exponential algorithm for computing valid plans.

Crampton extended the model for workﬂows to partially
ordered sets (equivalently, directed acyclic graphs) and to

directed acyclic graphs with loops [5]. Wang and Li further
extended this model to include Type 2 constraints and es-
tablished the computational complexity and, signiﬁcantly,
the existence of ﬁxed-parameter tractable algorithms for
WSP(=,(cid:2)=) [17]. Moreover, they established that WSP is
W[1]-hard, in general.

Recent work by Basin et al. [1] introduces the notion of
release points to model certain types of workﬂow patterns
and deﬁnes the concept of obstruction, which is related to the
notion of unsatisﬁability. They prove that the enforcement
process existence problem (EPEP), which is analogous to
WSP for this extended notion of unsatisﬁability, is NP-hard
with complexity doubly-exponential in the number of users
and constraints.

Independently of the work on authorization in workﬂows,
there exists a vast literature on constraint satisfaction prob-
lems. In this context, Fellows et al. [10] studied WSP((cid:2)=) for
Type 1 constraints and proved that this problem is ﬁxed-
parameter tractable.

Our work improves on that of Wang and Li and of Fel-
lows et al. by establishing a tighter bound on the exponen-
tial factor of the ﬁxed-parameter complexity for the rele-
vant instances of WSP (Theorem 2). Moreover, our work
establishes that it is unlikely that our bound can be sig-
niﬁcantly improved (Theorem 3). We extend the type of
constraints that can be deﬁned, introducing Type 3 con-
straints and demonstrating that WSP(=,(cid:2)=) remains ﬁxed-
parameter tractable (Theorem 5).
In addition, we extend
the set of binary relations that can be used to specify autho-
rization constraints. Speciﬁcally, we introduce a model for
hierarchical organizations – suitable for organizations that
are organized into mutually disjoint departments, or similar
organizational units – and prove that WSP remains ﬁxed-
parameter tractable when such constraints are used (Theo-
rem 4).

6.2 Future Work

There are many opportunities for further work in this
area, both on the more theoretical complexity analysis and
on extensions of WSP to richer forms of workﬂows.
It is
not hard to see that the function f (k), in the complexity of
the algorithm described in Proposition 3, equals 2O(k log k).
Is there an algorithm such that the term in k has complex-
ity 2O(k)? Note that such a reduction may be impossible to
achieve (unless the Exponential Time Hypothesis fails), as
in some problems considered by Lokshtanov et al. [13]. Does
OWSP generalize in a natural way to Type 2 and Type 3
constraints? Are the resulting instances of OWSP(=,(cid:2)=)
FPT?

There exists a sizeable body of work on workﬂow patterns.
Many workﬂows in practice require the ability to iterate a
subset of steps in a workﬂow, or to branch (so-called OR-
forks and AND-forks) and to then return to a single ﬂow
of execution (OR-joins and AND-joins) [16]. A variety of
computational models and languages have been used to rep-
resent such workﬂows, including Petri nets and temporal
logic. To our knowledge, the only complexity results for
richer workﬂow patterns are those of Basin et al. described
above, which can handle cycles. We will consider the ﬁxed-
parameter tractability of EPEP, and WSP for richer work-
ﬂow patterns, in our future work.
lation P ⊆ Σ

A parameterized problem P can be represented as a re-
In partic-

∗ × N over a ﬁnite alphabet Σ.

866(cid:3)

(cid:3)

(cid:3)

+|x

ular, WSP is a parameterized problem with parameter k,
the number of steps. The idea of input reduction prior to
solving the parameterized problem under consideration is
captured in the following deﬁnition. Given a parameterized
problem P , a kernelization of P is a polynomial-time algo-
(cid:3)
(cid:3)
rithm that maps an instance (x, k) to an instance (x
, k
)
such that (i) (x, k) ∈ P if and only if (x
) ∈ P and
, k
(cid:3)| ≤ g(k) for some function g; (x
(cid:3)
(cid:3)
(ii) k
, k
) is the kernel
and g is the size of the kernel. It is well-known and easy to
prove that a decidable parameterized problem is FPT if and
only if it has a kernel. It is easy to see that polynomial-size
kernels will be particularly useful in practice. Unfortunately,
many ﬁxed-parameter tractable problems have no such ker-
nels, unless NP ⊆ coNP/poly (which is highly unlikely);
see [4], for example.
We can show that, in general, WSP(=,(cid:2)=) has no poly-
nomial kernel unless NP ⊆ coNP/poly. However,
if all
constraints in WSP(=,(cid:2)=) involve only singletons, then
WSP(=,(cid:2)=) admits a kernel with at most k users. For a
canonical organizational 3-hierarchy even the restriction to
singletons does not help: there is no polynomial kernel unless
NP ⊆ coNP/poly. We will provide proofs of these results in
a journal version of this paper.

7. REFERENCES
[1] D.A. Basin, S.J. Burri, and G. Karjoth.

Obstruction-free authorization enforcement: Aligning
security with business objectives. In Proc. 24th IEEE
Symp. on Comput. Sec. Foundations, 99–113, 2011.

[2] E. Bertino, E. Ferrari, and V. Atluri. The speciﬁcation

and enforcement of authorization constraints in
workﬂow management systems. ACM Trans. Inf. Syst.
Secur. 2(1): 65–104, 1999.

[3] A. Bj¨orklund, T. Husfeldt, and M. Koivisto. Set

partitioning via inclusion-exclusion. SIAM J. Comput.
39(2): 546–563, 2009.

[4] H.L. Bodlaender, R.G. Downey, M.R Fellows, and

D. Hermelin, On problems without polynomial
kernels. J. Comput. Sys. Sci. 75 (2009), 423–434.

[5] J. Crampton. A reference monitor for workﬂow

systems with constrained task execution. In Proc. 10th
ACM Symp. on Access Control Models and
Technologies 38–47, 2005.

[6] J. Crampton and M. Huth. Synthesizing and verifying

plans for constrained workﬂows: transferring tools
from formal methods. In Proc. 3rd ICAPS Workshop
on Veriﬁcation and Validation of Planning and
Scheduling Systems, 2011.

[7] R. Crowston, G. Gutin, M. Jones, V. Raman, and
S. Saurabh. Parameterized complexity of MaxSat
above average. Proc. LATIN 2012, Lect. Notes
Comput. Sci. 7256 (2012), 184–194.

[8] R.G. Downey and M.R. Fellows. Parameterized

Complexity, Springer Verlag, 1999.

[9] J. Flum and M. Grohe. Parameterized Complexity

Theory, Springer Verlag, 2006.

[10] M. Fellows, T. Friedrich, D. Hermelin, N. Narodytska,

and F. Rosamond. Constraint satisfaction problems:
Convexity makes AllDiﬀerent constraints tractable. In
Proc. 27th Intern. Joint Conf. on Artif. Intell.
522-527, 2011.

[11] R. Impagliazzo, R. Paturi and F. Zane. Which

problems have strongly exponential complexity?
J. Comput. Sys. Sci. 63(4): 512–530, 2001.

[12] T. Kaufman, M. Krivelevich, and D. Ron. Tight

bounds for testing bipartiteness in general graphs.
SIAM J. Comput. 33(6): 1441–1483, 2004.

[13] D. Lokshtanov, D. Marx, and S. Saurabh. Slightly

superexponential parameterized problems. In
Proceedings of SODA’2011, 760–776, 2011.

[14] J. Moﬀett and E.C. Lupu. The uses of role hierarchies

in access control. In Proceedings of Fourth ACM
Workshop on Role-Based Access Control, 153–160,
1999.

[15] E. Tsang. Foundations of Constraint Satisfaction,

Academic Press, 1993; available at
http://en.scientificcommons.org/43256499.

[16] W.M.P. van der Aalst, A. ter Hofstede,

B. Kiepuszewski, and A. Barros. Workﬂow patterns.
Distributed and Parallel Databases 14(1): 5–51, 2003.

[17] Q. Wang and N. Li. Satisﬁability and resiliency in
workﬂow authorization systems. ACM Trans. Inf.
Syst. Secur. 13(4): 1–35, 2010.

APPENDIX
In this appendix, we provide proofs of Theorems 3 and 5.
Before proving Theorem 3, we deﬁne two problems related
to 3-Sat and prove two preparatory lemmas.

c-Linear-3-Sat

Input: A 3-CNF formula φ with m clauses, and n

variables such that m ≤ cn, where c is a
positive integer.

Output: Decide whether there is a truth assignment

satisfying φ.

Let φ be a CNF formula. A truth assignment for φ is a
NAE-assignment if, in each clause, it sets at least one literal
true and at least one literal false. We say φ is NAE-satisﬁable
if there is a NAE-assignment for φ.

Not-All-Equal-3-Sat (NAE-3-Sat)

Input: A CNF formula φ in which every clause has

exactly three literals.

Output: Decide whether φ is NAE-satisﬁable.

The ﬁrst of our lemmas, which we state without proof, is

due to Impagliazzo et al. [11] (see also [7]).

Lemma 1. Assuming the Exponential Time Hypothesis,
there exist a positive integer L and a real number δ > 0 such
that L-Linear-3-SAT cannot be solved in time O(2δn).

Lemma 2. Assuming the Exponential Time Hypothesis,
there exists a real number  >0 such that NAE-3-SAT with
n variables cannot be solved in time O(2n), where n is the
number of variables.

Proof. Let L be an integer and δ be a positive real such
that L-Linear-3-SAT cannot be solved in time O(2δn).
Such constants L and δ exist by Lemma 1. Suppose we
have a polynomial time reduction from L-Linear-3-SAT to
NAE-3-SAT and a positive integer c
such that if a formula
in L-Linear-3-SAT has n variables then the corresponding
formula in NAE-3-SAT has n
n. Let

variables and n

(cid:3) ≤ c

(cid:3)

(cid:3)

(cid:3)

867(cid:3)

 = δ/c
time O(2n(cid:2)
L-Linear-3-SAT can be solved in timeO (2n(cid:2)
a contradiction to the deﬁnition of δ.

and suppose that NAE-3-SAT can be solved in
is the number of variables. Then
) = O(2δn),

), where n

(cid:3)

It remains to describe the required polynomial time reduc-
tion from L-Linear-3-SAT to NAE-3-SAT. Recall that for
every formula in L-Linear-3-SAT we have m ≤ Ln, where
m and n are the numbers of clauses and variables, respec-
(cid:3) ≤ 2(1 + L).
tively. We will show that our reduction gives c
Let φ be a formula of L-Linear-3-SAT. Replace every
clause C = (u ∨ v ∨ w) in φ by

(u ∨ v ∨ xC ) ∧ (w ∨ xC ∨ yC ) ∧ (xC ∨ yC ∨ z)

(1)

to obtain a formula ψ of NAE-3-SAT. Here variables xC
and yC are new for every clause C and z is a new variable
but it is common for all clauses of φ. We will show that φ is
satisﬁable if and only if ψ is NAE-satisﬁable. This will give
us c

n ≤ n + 2m + 1 ≤ 2(1 + L)n implying c

(cid:3) ≤ 2(1 + L).

(cid:3)

Let Vφ and Vψ be the sets of variables of φ and ψ, respec-

tively. Hereafter 1 stands for true and 0 for false.
Assume that φ is satisﬁable and consider a truth as-
signment τ : Vφ → {0, 1} that satisﬁes φ. We will ex-
tend τ to Vψ such that the extended truth assignment is
a NAE-assignment for ψ. We set τ (z) = 1. For each
clause C = (u ∨ v ∨ w) ofφ, we set
τ (yC ) = 0 and
τ (xC ) = 1− max{τ (u), τ (v)}. Consider (1). Since τ (yC ) = 0
and τ (z) = 1, τ is a NAE-assignment for the third clause in
(1). Since max{τ (u), τ (v)} (cid:2)= τ (xC ), τ is a NAE-assignment
for the ﬁrst clause of (1). Also, τ is a NAE-assignment for
the second clause of (1) because either τ (xC ) = τ (yC ) = 0
or τ (u) = τ (v) = 0 and, hence, τ (w) = 1.

(cid:3)

(cid:3)

(cid:3)(cid:3)

Since τ

Now assume that ψ is NAE-satisﬁable and consider a
Vψ → {0, 1} for ψ.
NAE-assignment τ :
:
Vψ → {0, 1} is a NAE-assignment for ψ if and only if
(t), t ∈ Vψ, we may assume that
(t) = 1 − τ
so is τ
τ (z) = 1. Since τ is a NAE-assignment for the third clause
of (1), we have min{τ (xC ), τ (yC )} = 0. If τ (xC ) = 0
then max{τ (u), τ (v)} = 1; otherwise τ (xC ) = 1 and
τ (yC ) = 0 implying that τ (w) = 1. Therefore, either
max{τ (u), τ (v)} = 1 or τ (w) = 1 and, thus, C is satisﬁed
by τ .
Proof of Theorem 3. Consider a CNF formula φ,
which is an instance of NAE-3-SAT. Let {s1, . . . , sn} be
the variables of φ and let us denote the negation of si by
si+n for each i ∈ [n]. For example, a clause (s1 ∨ s2 ∨ s3)
will be written as (s1 ∨ sn+2 ∨ sn+3). For j ∈ [2n], we write
sj = 1 if we assign true to sj and sj = 0, otherwise.
Now we construct an instance of WSP. The set of steps
is {s1, . . . , sk}, where k = 2n, and there are two users, u0
and u1. We will assign user ui to a step sj if and only if
sj is assigned i in φ. For each j ∈ [n] we set constraint
((cid:2)=, sj, sj+n). For every clause of φ with literals s(cid:2), sp, sq
we set constraint ((cid:2)=, s(cid:2),{sp, sq}). We also assume that each
user can perform every step subject to the above constraints.
Observe that the above instance of WSP is satisﬁable if
and only if φ is NAE-satisﬁable. Thus, we have obtained a
polynomial time reduction of NAE-3-SAT to WSP with (cid:2)=
being the only binary relation used in the workﬂow and with
just two users. Now our theorem follows from Lemma 2.

Proof of Theorem 5. The result follows from a very
similar argument to that used in the proof of Theorem 4. No-
tice that our method for identifying ineligible sets for Type

2 constraints of the form ((cid:2)∼i, s, S
) works equally well for
Type 3 constraints of the form ((cid:2)∼i, S1, S2) (since a set F is
ineligible if S1 ∪ S2 ⊆ F ).

(cid:3)

(cid:3)

However, we cannot use our method for constraints in
C∼.8 Nevertheless, we can rewrite the set of constraints
in C∼ as Type 2 constraints, at the cost of
introduc-
ing additional workﬂow steps. Speciﬁcally, we replace an
Type 3 constraint (∼i, S1, S2) with two Type 2 constraints,
(∼i, S1, snew) and (∼i, snew, S2), where snew is a “dummy”
step. Every user is authorized for snew. This construction re-
quires the replacement of c
Type 2
constraints and the creation of c
new steps. Finally, we solve
straints, which has complexity (cid:2)O((c + 2c
WSP for a workﬂow with n users, k+c
con-
+ n23k+c(cid:2)
).
We may assume without loss of generality that for all con-
straints of the form (∼i, S1, S2) in C∼, S1 ∩ S2 = ∅. (The
constraint is trivially satisﬁed if there exists s ∈ S1 ∩ S2,
since we assume there exists at least one authorized user for
every step.) Hence the number of constraints having this
form is no greater than

steps and c+2c
)n2k+c(cid:2)
(cid:3)

Type 3 constraints by 2c

2k−j = 3k.

(cid:3)k

(cid:4)

(cid:5)

(cid:3)

(cid:3)

(cid:3)

(cid:3)

k
j

j=1

for

example,

8Consider,
constraint
(=,{s1, s2} ,{s3, s4}):
then (in the absence of other
constraints) {si} is eligible for i ∈ [4]; but any plan
π(si) = ui such that ui = uj if and only if i = j does not
satisfy the constraint (and is, therefore, invalid).

the Type

3

868