Optimizing Semi-Honest Secure Multiparty Computation

for the Internet

Aner Ben-Efraim∗

Dept. of Computer Science
Ben-Gurion University, Israel
anermosh@post.bgu.ac.il

Yehuda Lindell†

Dept. of Computer Science
Bar-Ilan University, Israel

lindell@biu.ac.il

Eran Omri‡

Dept. of Computer Science

Ariel University

omrier@gmail.com

Abstract
In the setting of secure multiparty computation, a set of
parties with private inputs wish to compute some function
of their inputs without revealing anything but their output.
Over the last decade, the eﬃciency of secure two-party com-
putation has advanced in leaps and bounds, with speedups of
some orders of magnitude, making it fast enough to be of use
in practice. In contrast, progress on the case of multiparty
computation (with more than two parties) has been much
slower, with very little work being done. Currently, the only
implemented eﬃcient multiparty protocol has many rounds
of communication (linear in the depth of the circuit being
computed) and thus is not suited for Internet-like settings
where latency is not very low.

In this paper, we construct highly eﬃcient constant-round
protocols for the setting of multiparty computation for semi-
honest adversaries. Our protocols work by constructing a
multiparty garbled circuit, as proposed in BMR (Beaver et
al., STOC 1990). Our ﬁrst protocol uses oblivious transfer
and constitutes the ﬁrst concretely-eﬃcient constant-round
multiparty protocol for the case of no honest majority. Our
second protocol uses BGW, and is signiﬁcantly more eﬃcient
than the FairplayMP protocol (Ben-David et al., CCS 2008)
that also uses BGW.

We ran extensive experimentation comparing our diﬀer-
ent protocols with each other and with a highly-optimized
implementation of semi-honest GMW. Due to our protocol
being constant round, it signiﬁcantly outperforms GMW in
Internet-like settings. For example, with 13 parties situated
in the Virginia and Ireland Amazon regions and the SHA256
∗
Supported by Israel Science Foundation grant 544/13, the cyber se-
curity research center at Ben Gurion University, and by the Frankel
center for computer science.
†
Supported by the European Research Council under the ERC con-
solidators grant agreement n. 615172 (HIPS) and by the BIU Center
for Research in Applied Cryptography and Cyber Security in conjunc-
tion with the Israel National Cyber Bureau in the Prime Minister’s
Oﬃce.
‡
istry and by Israel Science Foundation grant 544/13.

Supported by a grant from the Israeli Science and Technology min-

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS’16, October 24-28, 2016, Vienna, Austria
c(cid:13) 2016 ACM. ISBN 978-1-4503-4139-4/16/10. . . $15.00
DOI: http://dx.doi.org/10.1145/2976749.2978347

circuit with 90,000 gates and of depth 4000, the overall run-
ning time of our protocol is 25 seconds compared to 335
seconds for GMW. Furthermore, our online time is under
half a second compared to 330 seconds for GMW.

1.

INTRODUCTION

1.1 Background

In the setting of secure multiparty computation (MPC),
a set of parties wish to compute a joint function of their
private inputs without revealing anything but the output.
Protocols for secure computation guarantee privacy (mean-
ing that the protocol reveals nothing but the output) and
correctness (meaning that the correct function is computed),
in the presence of adversarial behavior. There are two classic
adversary models that are typically considered: semi-honest
(where the adversary follows the protocol speciﬁcation but
may try to learn more than is allowed from the protocol
transcript) and malicious (where the adversary can run any
arbitrary polynomial-time strategy in its attempt to breach
security). In this paper, we focus on the multiparty setting
and semi-honest adversaries. Our focus is on the construc-
tion of concretely eﬃcient protocols for this case (where by
“concrete eﬃciency” we mean faster run time in practice).

Two paradigms for secure computation. There are
two main paradigms for constructing general secure two-
party and multiparty computation protocols that can be
used to securely compute any function. The GMW (Goldreich-
Micali-Wigderson) paradigm [15] works by having the par-
ties interact to compute every (AND) gate in the circuit (this
approach is also followed for information-theoretic protocols
and arithmetic circuits). Such protocols typically send very
little bandwidth per gate, but suﬀer from multiple rounds
of communication, being linear in the depth of the circuit.
They are therefore very fast in LAN settings, but very slow
when communicating over the Internet. In contrast, in the
garbled-circuit paradigm [32] an entire circuit is constructed
in a way that enables it to be evaluated without reveal-
ing anything but the output. The original construction by
Yao [32] worked only for two parties, and the notion of a
multiparty garbled circuit was later shown by BMR (Beaver-
Micali-Rogaway) in [5]. Such protocols are typically slower
in LAN settings since they require much more bandwidth,
but have the potential to be much faster on slower net-
works like the Internet since they have a constant number
of rounds.

578Concrete eﬃciency and the last decade. Secure two-
party computation has progressed in the past decade in leaps
and bounds. It has progressed from a notion of theoretical
interest only, into a technology that is even being commer-
cialized by multiple companies. In order to demonstrate this
progress, we go back to the ﬁrst implementation of Yao’s gar-
bled circuits in Fairplay [29] in 2004. In this paper, they ran
a secure computation on a “large circuit” with 4383 gates
overall, with security in the presence of semi-honest adver-
saries. On a LAN, their protocol ran in 7.09 seconds.
In
2014, it takes approximately 16 milliseconds to run an anal-
ogous execution on a circuit that is about 5 times the size
with over 22,000 gates, of which 6800 are AND gates [17].1
This therefore constitutes a multiplicative improvement of
approximately 2000 (or over 3 orders of magnitude). Ob-
serve that Moore’s law (the version saying that computing
power doubles every 2 years) can only account for a speedup
of a factor of 32. This amazing progress was due to a long
series of works that focused on all cryptographic and algo-
rithmic aspects of the problem, as well as the advent of ubiq-
uitous crypto hardware acceleration in the form of AES-NI
and more; see [25, 20, 18, 3, 6, 31, 33] for just some exam-
ples. The current situation is that we now have a very good
understanding of the cost of secure two-party computation
in practice.

We stress that not only did these works yield impressive
progress for protocols that are secure for semi-honest adver-
saries, they also fueled progress for protocols that are se-
cure for malicious adversaries. In particular, the techniques
and methods used to speed up garbled circuit generation
and evaluation were directly incorporated in protocols for
malicious adversaries, and fast OT extensions for the semi-
honest case served as a basis for fast OT extensions for the
malicious case.

Analogously, the ﬁrst implementation of a multiparty pro-
tocol (with more than two parties) was FairplayMP [7] in
2008, which followed the multiparty garbled circuit approach
of [5]. The largest circuit they computed had 1024 gates, and
the time it took to run the protocol ranged from approxi-
mately 10 seconds for 5 parties to 55 seconds for 10 parties.
In 2012, [10] implemented the GMW protocol for the multi-
party setting. For a circuit with 5,500 AND gates (about 5
times that of FairplayMP), they reported times ranging from
approximately 7 seconds for 5 parties to about 10 seconds
for 10 parties.2 Surprisingly, to the best of our knowledge,
there has been no additional work on general (circuit-based)
multiparty secure computation for the case of semi-honest
adversaries and no honest majority.3
In particular, there
have been no improvements to the multiparty garbled circuit
approach since FairplayMP, and the time that it takes to run
multiparty computations is orders of magnitude more than
for two-party computations. Furthermore, the FairplayMP

1

Indeed, we are comparing the total number of gates, since the in-
vention of free-XOR is one of the factors involved in the progress that
took place over this decade.
2

The implementation of [10] is actually highly optimized and per-
forms far better than reported. This is because they included the
initial synchronization of communication in their times, which can
include large delays unless done carefully. We use their code for our
comparisons, but run the timer only once the actual MPC protocol be-
gins.
3

In contrast, work has been done for malicious adversaries; e.g. [12,
27, 28]. However, the basic semi-honest case has been skipped over,
and along with it techniques and understanding that are extremely
valuable for the malicious case as well.

protocol is only secure for an honest majority. Thus, no
concretely-eﬃcient constant-round multiparty protocol for
the case of no honest majority semi-honest adversaries has
ever been described or implemented.

We remark that the multiparty setting is needed for many
applications like auctions, trading, elections, privacy-preser-
ving surveys and more. Thus, we believe that it is of great
importance to remedy the current situation where eﬃcient
multiparty computation lags so far behind eﬃcient two-party
computation.
1.2 Our contributions

In this paper, we study the problem of multiparty com-
putation with semi-honest adversaries. We have three main
contributions:

1. We present the ﬁrst concretely-eﬃcient constant-round
multiparty protocol that is secure for any number of cor-
rupted parties. Our protocol is based on the multiparty
garbled-circuit approach of [5], and requires each party
to run an oblivious transfer with every other party per
gate in order to construct the garbled circuit.

2. Following FairplayMP [7], we also present protocols for
constructing a multiparty garbled circuit based on BGW
[8] (BenOr-Goldwasser-Wigderson), that are secure for
an honest majority. Our protocols are far more eﬃcient
than those presented in [7].

3. We ran extensive experiments comparing the performance
of our diﬀerent protocols to each other and to multi-
party GMW. We ran experiments over 3 diﬀerent net-
works, with diﬀerent numbers of parties, and with dif-
ferent circuits. Our results deepen our understanding of
the impact of round complexity on eﬃciency, and which
protocols are suited to low and high latency networks.

Our protocols are all secure for semi-honest adversaries. Semi-
honest security is suﬃcient when parties somewhat trust
each other, but are concerned with inadvertent leakage or
cannot share their raw information due to privacy regula-
tions. It is also suﬃcient in cases where it is reasonable to as-
sume that the parties running the protocol are unable to re-
place the installed code. Nevertheless, security against mali-
cious adversaries is preferable, providing far higher guaran-
tees. However, such protocols will always be far less eﬃcient.
In addition, we argue that the ﬁrst step towards obtaining
highly eﬃcient protocols for malicious adversaries is to un-
derstand the semi-honest case and how it can be made very
eﬃcient. This was indeed the case for two-party compu-
tation, where optimizations and work carried out for the
semi-honest case was an important factor towards obtaining
eﬃcient protocols for the case of malicious adversaries.

Before proceeding, we remark that the garbled-circuit ap-
proach in the multiparty case is fundamentally diﬀerent to
the two-party case and introduces many diﬃculties. In the
two-party case, one party constructs the garbled circuit and
the other evaluates it. Thus, the computation involved in
constructing and evaluating the garbled circuit is local. In
contrast, in the multiparty case, it is not possible for one
party to construct the garbled circuit on its own. This is
due to the fact that if that party colludes with one of the
parties evaluating the circuit, then the parties’ inputs will
all be revealed (since the party who constructed the circuit
knows all of the keys). Rather, it is necessary for all of the

579parties to collaboratively construct the circuit via a secure
protocol. Thus, an eﬃcient instantiation of this approach
requires (a) an eﬃcient garbled-circuit approach, and (b)
an eﬃcient way of collaboratively generating it. Note that
the construction of the garbled circuit (which is the more
expensive part of the protocol) can be carried out in an of-
ﬂine phase. Then, once inputs are received, an online phase
can be run with very minimal communication and just local
evaluation of the multiparty garbled circuit.

We will now elaborate on each of our major contributions.

Dishonest majority. As we have mentioned, [7] designed
a protocol for securely computing a multiparty garbled cir-
cuit using the BGW protocol. Since the construction of a
garbled gate requires multiplication between a large value
and a bit, this lends itself naturally to an arithmetic cir-
cuit approach. However, this introduces many complica-
tions in [7], especially since they work over a prime-order
ﬁnite ﬁeld.
In contrast, we observe that multiplication of
a string by a bit can actually be carried out with a single
string oblivious transfer (OT). Furthermore, bit and string
OT is very cheap today, due to the extremely fast OT exten-
sion protocols that exist that reach rates of approximately
only one microsecond per oblivious transfer on a LAN and
whatever the latency is on slower networks [20, 3]. In addi-
tion to our basic protocol, we show how approximately 1/4
of the OT cost can be removed. This uses a novel approach
that enables us to compute one of the entries in each garbled
gate by sending a single message and combining it with the
results of the OTs used to compute the other entries in the
garbled gate. We then further reduce the cost by utilizing
the fact that we actually only need a variant of OT, called
correlated OT, which is even more eﬃcient [3]. Finally, we
are the ﬁrst to incorporate free-XOR [25] into a multiparty
garbled circuit. Previous works did not utilize free-XOR [7,
28] since they work over a prime-order ﬁnite ﬁeld. Needless
to say, as in the two-party case, this optimization is crucial
for obtaining high performance.

We remark that the incorporation of garbled-circuit opti-
mizations that exist for the two-party case is not necessarily
straightforward. This is because the circuit must itself be
computed via a secure protocol. For example, we do not
know how to eﬃciently perform garbled row-reduction when
building a multiparty garbled circuit. This makes the half-
gates optimization for Yao’s garbled circuits [33] unsuitable
since it is less eﬃcient when there is no row reduction. We
conjecture that row reduction (and thus half-gates) is not
suitable for the multiparty setting.

Honest majority. The FairplayMP multiparty garbled-
circuit construction used BGW and worked over a prime-
order ﬁnite ﬁeld. As we have mentioned, this has some dis-
advantages: ﬁrst, it is not compatible with the free-XOR op-
timization; second it requires an additional multiplication to
convert shares of values which may be {−1, +1} into shares
of bits in {0, 1}. In contrast, we work over GF (2128) which
is of characteristic 2. This enables us to incorporate free-
XOR and to save the multiplication to convert {−1, +1} to
{0, 1}. As another beneﬁt of using free-XOR, we were able
to deﬁne a formula for computing each value in each gar-
bled gate that saves an additional multiplication. Thus, [7]
require 4 secure multiplications per element per gate inside
BGW, whereas we only require 2 secure multiplications per

element per gate inside BGW. Beyond computational costs,
this reduces the round complexity from 6 to 4.

Experimental evaluations. We ran multiple experiments
to compare our diﬀerent constant-round protocols to each
other as well as to a highly optimized implementation of
GMW [10]. These are described in depth in Section 4. Our
code is open-source and available in the SCAPI library [2]
to enable others to reproduce our results and compare to
future work.

Our results show that

for computing deep circuits
on Internet-like networks, our protocols way outperform
GMW. For example, in executions ran on Amazon with ma-
chines communicating between Virginia and Ireland (with a
75ms round-trip) on the SHA256 circuit with 90,000 AND
gates and depth 4,000, the GMW protocol took over 5 min-
utes (for 3 to 13 parties) whereas our protocol ranged from
about 6 seconds for 3 parties to 25 seconds for 13 parties.
Furthermore, the vast majority of the time in GMW is the
online time whereas the vast majority of the time in our pro-
tocol is the oﬄine time. Thus, we obtain online times rang-
ing from 170ms to 455ms for 3 and 13 parties, respectively,
while the online time for GMW is approximately 5 minutes.
To our surprise, our protocol that is secure without an
honest majority and uses oblivious transfer is almost al-
ways more eﬃcient than our protocols based on BGW. This
was unexpected since oblivious transfer uses cryptographic
operations, whereas BGW uses only simpler information-
theoretic operations. However, a closer look shows that the
number of ﬁeld multiplications in BGW is actually cubic in
the number of parties, whereas the cost in the oblivious-
transfer protocol is quadratic. Combining this with the fact
that the best oblivious transfer extension protocols today [3,
24, 22] are so fast, the BGW protocol only outperforms the
oblivious transfer a small number of parties.

Another interesting outcome from our experiments is that
the GMW protocol actually performs very well on low-depth
circuits or in very fast networks. This is due to the fact
that when the circuit is shallow then the number of rounds
in GMW is also small. In this case, the small bandwidth
is a big advantage over the garbled circuit approach which
requires large message transmission.
In addition, in fast
networks with very low latency, GMW’s many rounds does
not signiﬁcantly aﬀect the running time.

Conclusions.
In the setting of secure multiparty compu-
tation over the Internet (which is the natural setting for the
aforementioned applications of auctions, elections, privacy-
preserving surveys and so on), our protocol following the
garbled circuit approach is much faster than all previous
protocols. Furthermore, our protocol has an extremely fast
online time, making it suitable for scenarios where prepro-
cessing is possible and fast response time is needed.

It is important to also note that the complexity of GMW
grows linearly in the number of parties, in contrast to the
multiparty garbled-circuit approach which is quadratic in the
number of parties (we count the complexity per party, and
thus linear complexity for GMW means that each party’s
work is linear in the number of parties per gate). Thus,
when the number of parties is very large, this cost can be
signiﬁcant. A very interesting open question coming out of
our work is whether or not it is possible to construct and
evaluate a multiparty garbled circuit in time that is linear
in the number of parties, with concrete eﬃciency.

5801.3 Related Work

As we have mentioned, there has been a long line of work
optimizing secure two-party computation, both in the semi-
honest and malicious settings; cf. [25, 20, 18, 3, 6, 31, 33].
The ﬁrst protocol implemented for the multiparty setting
with semi-honest adversaries was that of FairplayMP [7] in
2008. Later, in 2012, a highly optimized version of the mul-
tiparty GMW protocol for semi-honest adversaries was pre-
sented by [10]. This implementation uses oblivious transfer
extensions [20], making the cost of the oblivious transfers in-
signiﬁcant. In addition, [10] run all of the oblivious transfers
on random input in an oﬄine phase, and then only need to
send a single bit in each direction per oblivious transfer in
the online phase. This makes the online phase very fast with
very little bandwidth. For the speciﬁc case of three parties,
the Sharemind protocol achieves fast computation [9], but
only for 3 parties and only for an honest majority. In addi-
tion, their protocol also has many rounds, like GMW, and
so is not suitable for Internet-like settings. The recent work
of [30] achieves malicious security for 3 parties with an hon-
est majority using Yao garbled-circuits, but does not extend
to beyond 3 parties.

In addition to the work on semi-honest multiparty compu-
tation, there has been work on multiparty computation that
is secure in the presence of malicious adversaries The SPDZ
protocol [13, 12], with improvements in [23], is the state-
of-the-art in this area. The oﬄine phase of these works is
over an order of magnitude slower than ours, which is fully
justiﬁed by the fact that they achieve security for malicious
adversaries which is much more diﬃcult. More signiﬁcantly,
the SPDZ protocol’s online time follows the GMW paradigm
(but is somewhat more expensive due to the necessity to en-
force correctness). Thus, in a slow network, it suﬀers from
the same problems as the GMW protocol that we compare
with here. Other protocols for the multiparty setting that fo-
cus on eﬃciency include [21] and [27]; however, these proto-
cols have not been implemented and seem to be considerably
slower in practice. The closest comparison to our protocol
in the malicious setting is that of [28] which uses SPDZ in
order to build a multiparty garbled circuit. Thus, [28] is
expected to have an online time similar to that of our proto-
col. However, its oﬄine time is estimated at over 400 seconds
for 3 parties computing the AES circuit (over two orders of
magnitude slower than ours). We stress that this discussion
regarding protocols secure for malicious adversaries is not
for the purpose of comparing our protocol (since we only
achieve semi-honest security) but to stress that the semi-
honest model yields far more eﬃcient protocols and is thus
important to study for applications where semi-honest se-
curity suﬃces. The comparison also highlights that much
progress is needed in this area; our belief is that improve-
ments for the semi-honest case will signiﬁcantly help in the
malicious case as well.

2. THE BMR PROTOCOL

2.1 Background

As we have mentioned, in the BMR protocol the par-
ties construct a multiparty analog of Yao’s garbled circuit.
In Yao’s garbled circuit construction, random labels (which
are just keys) are assigned to each wire; one label repre-
sents the 0-value and the other label represents the 1-value.

Then, each gate is constructed by encrypting the appropri-
ate output-wire label with the appropriate input-wire label.
For example, let g be an AND gate with input wires u, v
and output wire w, and let κ denote the security parame-
ter. Furthermore, let ku,0, ku,1 ∈ {0, 1}κ denote the labels
on wire u, and likewise for wires v and w. Then, kw,0 is
double encrypted under ku,0, kv,0, under ku,0, kv,1, and un-
der ku,1, kv,0, while kw,1 is double encrypted under ku,1, kv,1.
Observe that given a single label on each input wire, it is pos-
sible to compute the correct output-wire label by decrypting
the single ciphertext that can be decrypted with one label
on each input wire. Furthermore, by providing these cipher-
texts in random order, the party computing the gate has no
idea whether it obtained kw,0 or kw,1 (since they are both
just random values). Thus, the party evaluating the circuit
learns nothing at all from the computation. In the setting of
two parties, one party prepares the garbled circuit and the
other evaluates it.

In the multiparty setting, all the parties must prepare the
garbled circuit together, and it must have the property that
no subset of colluding parties can learn anything about what
value is being computed. The multiparty garbled circuit is
therefore constructed by having all parties contribute to the
garbling of every gate.
In particular, all n parties choose
their own random 0-labels and random 1-labels on every
wire, and the output wire labels are encrypted separately
under every single party’s input wire labels. Thus, a single
honest party’s input-wire labels hide the output-wire labels
from all other parties. Let ki
u,b be the input-label that party
Pi holds for value b ∈ {0, 1} on wire u; likewise for wires v
and w. Since there are n parties and n output-wire labels for
each value b ∈ {0, 1}, the encryption works by masking all
of k1
v,1) and
v,0). To be more exact, let F 2 denote a double-key
(ki
pseudorandom function that takes two keys k, k(cid:48) and main-
tains security as long as at least one key is secret. Abusing
notation and denoting the gate function by g(·,·) (as well as
the gate index by g), we have that for every a, b ∈ {0, 1} the
output labels of all parties P1, . . . , Pn associated with the
bit g(a, b) are encrypted by

w,0 with each pair (ki

w,0, . . . , kn

u,1, ki

u,0, ki

v,0), (ki

u,0, ki

(cid:33)

(cid:41)n

(cid:40)(cid:32) n(cid:77)

i=1

F 2
u,a,ki
ki

v,b

(g ◦ j)

⊕ kj

w,g(a,b)

(1)

j=1

w,g(a,b), . . . , kn

where ◦ denotes string concatenation. Observe that the keys
on the input wires of all of the parties are needed in or-
der to learn k1
w,g(a,b) (the concatenation of all
keys/labels is called the “superseed” in [5, 7]). We remark
that the value input to the PRF is the gate number followed
by the index of the label being masked. This ensures that
all output-wire labels are masked with independent values.
In order to hide which values of a and b are being dealt
with, the “point-and-permute technique” (that was originally
invented by BMR) is used. According to this technique, a
random secret “permutation bit” λu is associated with every
wire u (this is achieved by each party Pi choosing a random
u and setting λu = ⊕n
λi
u). Then, if the actual bits on
inputs wire u and v to gate g are a and b, then the parties
see λu ⊕ a and λv ⊕ b, and this guides them as to which
ciphertext to decrypt. In addition, they obtain the output
λw ⊕ g(a, b) that enables them to proceed to the next gate.

i=1λi

Constructing the multiparty garbled circuit.
In the
ﬁrst part of the protocol, the parties run a secure protocol

581to compute the garbled circuit. This phase is independent
of the parties’ actual inputs and so can therefore be run in
a separate oﬄine phase. The important property that is
the “BMR claim-to-fame” is the fact that the entire circuit
can be constructed in a constant number of rounds, inde-
pendently of the depth of the circuit. This is due to the fact
that the circuit computing a multiparty garbled gate is very
shallow, and all garbled gates can be computed in parallel
(since given the garbled labels on all wires, each gate can
be independently computed). Thus, it is possible to use any
protocol for general secure computation with round com-
plexity linear in the depth of the circuit in order to securely
compute a multiparty garbled circuit in a constant number
of rounds (irrespective of its depth). Intuitively, each party
(g ◦ j) for every a, b ∈ {0, 1}
Pi locally computes F 2
u,a,ki
ki
and j ∈ [n], and these are input to a circuit that computes
the gate. Observe that this means that each party must
carry out 4n double-key PRF computations per gate.

v,b

u,a and k1

v,b, . . . , kn

u,a, . . . , kn

w,g(a,b), . . . , kn

Evaluating the BMR circuit. As with Yao’s garbled cir-
cuits, given the sets of n keys k1
v,b,
it is possible to decrypt a single row in the garbled gate and
obtain k1
w,g(a,b). This method can therefore be
used to evaluate the entire circuit. Furthermore, once the
parties receive the sets of keys on every circuit-input wire,
they can each locally compute the entire circuit and obtain
the output. Thus, the online running-time of the protocol is
very small: parties send a very small amount of information,
and then the entire circuit is just locally computed. Observe
that in order to carry out the gate computation, each party
(g ◦ n), for
needs to compute F 2
u,a,ki
ki
i = 1, . . . , n. Thus, evaluation of the multiparty garbled
circuit requires n2 PRF computations per gate.
2.2 Free XOR

(g ◦ 1), . . . , F 2

u,a,ki
ki

v,b

v,b

In this section, we describe how we incorporated the free-
XOR optimization into the multiparty garbled circuit. The
original work by BMR [5], and the FairplayMP [7] system
were both published before the free-XOR technique [25].
This technique enables XOR gates to be computed for free
in Yao’s garbled circuits, and has become standard for use
in that setting. In the recent BMR-SPDZ protocol of [28]
that uses BMR to achieve security in the presence of mali-
cious adversaries, free XOR was also not incorporated. This
seems to be due to the fact that they work in a ﬁnite ﬁeld
of prime order (in order to optimize the SPDZ portion of
the protocol) and this does not lend itself to free XOR. Our
ﬁrst optimization in this work is to incorporate free-XOR
into BMR. This is important for two reasons. First, and
most obviously, free-XOR reduces the number of AES op-
erations in garbling and evaluating the circuit. Since eval-
uation requires n2 AES operations per gate (for n parties),
this is signiﬁcant. Second, free-XOR signiﬁcantly reduces
the bandwidth of the garbled circuit since only AND gates
require encryptions. The large amount of communication in
BMR is problematic and so this is important.

Intuitively, the free XOR in BMR works in the same way
as in Yao. For every i = 1, . . . , n, a ﬁxed (random) diﬀer-
ence parameter Ri ∈ {0, 1}κ is chosen (known only to Pi).
Then, for every wire w, the label ki
w,0 is random whereas
w,0 ⊕ Ri. Due to this relation,
the label k1
XOR gates can be computed by simply XORing the garbled
labels on the input wires, and taking the garbled label on

w,1 is set to equal ki

the output wire to be the result. We formally describe the
functionality that outputs a BMR circuit in Figure 1; this
functionality needs to be securely computed in the oﬄine
phase. We design the functionality in a way that minimizes
the computation necessary within the secure computation
protocol (thus, all shares of all values are prepared by par-
ties before running FGC ).

Functionality FGC for Constructing a

Multiparty Garbled Circuit

Inputs: All parties hold the circuit C, the number of
parties n, and the security parameter κ.
In addition,
each party Pi has the following private inputs:
1. A global diﬀerence string Ri ∈ {0, 1}κ.
2. A share λi

w ∈ {0, 1} of the permutation bit for every
w,1 ∈ {0, 1}κ of the garbled labels for
w ∈
w,1 ∈ {0, 1}κ values are chosen in

every wire w ∈ W .
(As described in Section 2.3 (Figure 2), the λi
{0, 1} and ki
a special way to enable free XOR.)

3. Its parts ki

w,0, ki

w,0, ki

wire w.

Computation: The functionality computes the garbled
circuit GC. For every AND gate g ∈ C with input wires
u, v and output wire w, every α, β ∈ {0, 1}, and every
j ∈ [n], compute:

(cid:33)

˜gj
α,β =

(cid:32) n(cid:77)
⊕(cid:16)

i=1

(g ◦ j)

⊕ kj

v,β

w,0

F 2
u,α ,ki
ki
Rj · ((λu ⊕ α) · (λv ⊕ β) ⊕ λw)
α,β ◦ · · · ◦ ˜gn
˜g1

(cid:16)

(cid:17)

(2)

(cid:17)

α,β

Outputs: The functionality outputs
for every g and every α, β ∈ {0, 1} to all parties.

Figure 1: Functionality FGC

We explain the computation of ˜gj

α,β in Figure 1. The
permutation bits λu, λv, λw randomly permute the values
on each wire. In particular, the parties see α, β on the input
wires, but the actual value on wires u and v are α ⊕ λu and
β⊕λv, respectively. (Since λu, λv are random, it follows that
α, β reveal nothing about the actual values, as required.)
Now, it follows that the output of the AND gate is exactly
(λu ⊕ α) · (λv ⊕ β) since this is the product of the actual
values. Assume for a moment that λw = 0. Then, ˜gj
α,β will
w,0 if (λu ⊕ α) · (λv ⊕ β) = 0, and
be an encryption of kj
otherwise it will be an encryption of kj
w,1, as
required.
In contrast, if λw = 1, then the result will be
reversed. Thus, this preserves the invariant that the parties
hold the key kj
w,b where b equals the XOR of the actual value
on the wire with λw.

w,0 ⊕ Rj = kj

In the full version of this paper, we formally prove security
of the free-XOR construction in the context of BMR, under
a correlation-robust circularity assumption as in [11] (which
holds for a random oracle).
2.3 MPC Using Multiparty Garbled Circuits
Given the functionality FGC , we now show how any multi-
party functionality can be securely computed in a constant
number of rounds. We have already explained informally
how the protocol works in Section 2.1, and we now present
the formal speciﬁcation of the oﬄine protocol and of the on-
line phases. These speciﬁcations assume an implementation
of FGC which is the main protocol challenge, as we will see
below in Section 3.

582The MPC protocol that we describe is a variant of the
BMR protocol and is designed in the FGC -hybrid model.
The main diﬀerence between this variant and the original
BMR protocol is the fact that our BMR circuit incorporates
free-XOR. (Of course, our full protocol has additional dif-
ferences in the eﬃcient computation of FGC .) The protocol
consists of two phases:

Part 1 - the Oﬄine Phase: In this phase, the parties
ﬁrst run a local computation to prepare their inputs to FGC .
A formal speciﬁcation of this local computation is given in
Figure 2. Observe that the parties choose the wire labels
in a special way in order to ensure that the free-XOR prop-
erty works. Next, the parties securely compute Functional-
ity FGC in order to obtain the garbled circuit. Finally, each
party Pi sends its shares of the permutation bits λw on every
circuit-output wire w. In addition, all parties send Pi their
shares of the permutation bits on the circuit-input wires as-
sociated with Pi’s private input. (Recall that a formal spec-
iﬁcation of Functionality FGC appears above in Figure 1.)

The BMR Oﬄine Phase

1. Each Pi chooses a random key oﬀset Ri ∈R {0, 1}κ.
2. For every wire w that is not the output of a XOR

gate, each party Pi works as follows:
(a) Pi chooses a random bit λi
(b) Pi chooses its part of the 0-garbled label ki

w as a share of λw.

w,0 ∈

{0, 1}κ at random.
w,0 ⊕ Ri.

w,1 = ki
ki

(c) Pi sets its part of the 1-garbled label to be

3. For every wire w that is the output of a XOR gate (in
topological order over the circut) with input wires u, v
and output wire w, each party Pi works as follows:
(a) Pi sets its share of the permutation bit λi

w =

u ⊕ λi
λi
v.

(b) Pi sets its part of the garbled labels on wire w

as ki

w,0 = ki

u,0 ⊕ ki

v,0, and ki

w,1 = ki

w,0 ⊕ Ri.

w,0, ki

4. Each party Pi calls FGC with the inputs Ri, and
λi
w, ki
w,1 for every wire w. The parties receive
back all garbled gates as output. (This step involves
running one of the protocols described in Section 3 for
securely computing FGC .)
all other parties, who all compute λw = ⊕n

5. For every circuit-output wire w, each Pi sends λi
i=1λw.

w to

w to Pi. Party Pi computes λw = ⊕n

6. For every circuit-input wire w, if Pi’s is the party
whose input is associated with wire w, then each Pj
sends λj
As in [7], this step can be skipped by having all parties
Pj with j (cid:54)= i set λj
w = 0 for all circuit-input wires w.
Figure 2: Oﬄine phase – BMR circuit construction

i=1λw.

Part 2 - the Online Phase: Given their private inputs,
this phase begins with the parties broadcasting the XOR of
their private input with the permutation bit on the asso-
ciated wire. Next, the other parties send the appropriate
garbled labels. Finally, each party locally computes the gar-
bled circuit and obtains the output (using knowledge of λw
on the output wire to convert the output garbled value into
an actual output bit). Thus, the online phase consists of
very little communication and primarily local computation.
A formal speciﬁcation of this phase is given in Figure 3.

The BMR Online Phase

1. Send garbled labels associated with inputs: For

every circuit-input wire w:

(a) Let Pi be the party whose input is associated
with wire w and let xiw be Pi’s input bit as-
sociated with the wire. Then, Pi sends αw =
xiw ⊕ λw to all parties, where λw = ⊕n
i=1λi
w.
For every wire w, we denote by αw the XOR of
the actual value on the wire (based on the input)
and λw; we call this the public value.

(b) Each party Pj sends its part kj

w,αw of the gar-

bled label on w to all other parties.

(c) At this point, each party holds k1

w,αw , . . . , kn

w,αw

for every circuit-input wire.

2. Local circuit computation: Each party locally
evaluates the garbled circuit. The circuit is evaluated
by traversing the circuit in topological order, comput-
ing the garbled labels on the output wire of each gate
one at a time.
Each gate is computed as follows. Let g be the cur-
rent gate with input wires u, v and output wire w.
Let α and β be the public values on wires u and v,
respectively.

(a) If g is a XOR gate, then each party computes
the public value on the output wire w to be γ =
α ⊕ β.
In addition, for every j = 1, . . . , n it
computes kj

u,α ⊕ kj

w,γ = kj

v,β .

(b) If g is an AND gate, then each party computes

(cid:33)

kj
w,γ = ˜gj

α,β ⊕

F 2
u,α,ki
ki

v,β

(g ◦ j)

(cid:32) n(cid:77)

i=1

for every j ∈ [n], and for α, β which are the
public values on wires u, v as above. Given
k1
w,γ , . . . , kn
w,γ , each party Pi compares the ith
value to the garbled labels ki
w,1 that it in-
put in the oﬄine phase on this wire. If it equals
ki
w,0 then it sets the public value on wire w to
be γ = 0; otherwise it sets γ = 1.

w,0, ki

3. Output determination: For every output wire w,
each party computes the actual output bit of wire w
to be αw ⊕ λw, where αw is the public value on wire
w and λw is as received in the oﬄine phase.

Figure 3: Online phase – BMR circuit evaluation

The following theorem follows directly from the security of
the multiparty garbled circuit and how to use it, as proven
in [5] (with our addition of free-XOR), and from the fact
that FGC securely computes the circuit:

Theorem 2.1. Let f be an n-party functionality. Then,
the Protocol in Figures 2 and 3 securely computes f in the
presence of a semi-honest adversary corrupting any number
of parties.
2.4 The Double Key PRF

Both the oﬄine and the online phases use the double-
key PRF F 2. We implemented F 2 in two ways: (1) by
concatenating the two 128-bit keys and using it as a a single
AES-256 key, as proposed by [26], (2) using ﬁxed-key AES,
as proposed by [6]. Since the online time is dominated by the
AES computations (with very little communication), ﬁxed-
key AES is considerably faster than the ﬁrst method, even
when AES-NI is used in both. For the oﬄine times, the
diﬀerence between these 2 methods was minor.

5833. SECURELY COMPUTING FGC

It is clear that the online phase of the protocol is fast,
as it is essentially n2 times the cost of locally computing a
standard Yao garbled circuit, where the latter is known to
be extremely fast [6]. Thus, the main challenge in making
the protocol concretely eﬃcient is in constructing an eﬃcient
protocol that securely computes the multiparty garbled cir-
cuit. Stated diﬀerently, the goal is to construct an eﬃcient
protocol that securely computes the FGC functionality.

The original BMR protocol [5] considered an honest ma-
jority of parties, although this is only needed for achieving
security in the presence of malicious adversaries. In any case,
[5] did not specify a concrete protocol for securely comput-
ing FGC (or, more exactly their version of it), but rather
stated that any secure protocol can be used.
In [7], they
use the BGW protocol [8] for an honest majority in order
to securely compute FGC . Surprisingly, no concretely eﬃ-
cient protocol has been suggested to securely compute FGC
without an honest majority. We will present two main pro-
tocols here: (1) a protocol for a dishonest majority using
oblivious transfer (OT) as a black box, (2) several variants
of the protocol based on BGW (with signiﬁcant protocol
improvements over [7]).
3.1 Protocol for No Honest Majority
In this section, we present a protocol that securely com-
putes FGC in the OT-hybrid model, in the presence of semi-
honest adversaries. As we have mentioned, this is the ﬁrst
concretely-eﬃcient constant-round protocol for this setting.
Our protocol securely computes Eq. (2) in Figure 1 for every
j = 1, . . . , n and all four choices of α, β ∈ {0, 1}. Intuitively,
in order to compute Eq. (2), the parties will need to generate
shares of Rj · ((λu ⊕ α) · (λv ⊕ β) ⊕ λw) for all j. Observe
that Pj holds Rj, and the other values are all shared (i.e.,
each party holds λi
u, and so on). As we
will see, this computation can be reduced to a computation
whereby parties securely compute XOR shares of the prod-
uct of two parties’ input bits.
3.1.1

Secure Multiplication

u and λu = ⊕n

i=1λi

Secure bit-bit multiplication. The main operation that
we use is the secure computation of XOR shares of the
product of input bits. That is, we deﬁne the functional-
ity f×(a, b) = (c, d) where c⊕ d = a· b. The folklore protocol
for computing f× works as follows:
1. Parties P1 and P2 hold input bits a ∈ {0, 1} and b ∈

{0, 1}, respectively.

2. P1 chooses a random r ∈ {0, 1}. P1 sets x0 = r and

x1 = r ⊕ a.

3. P1 and P2 run a bit oblivious transfer where P1 plays the
sender with inputs (x0, x1) and P2 plays the receiver with
input bit b. Party P2 receives xb.

4. P1 outputs r and P2 outputs xb.
Observe that xb = r ⊕ a · b (since b = 0 implies that xb =
x0 = r and b = 1 implies that xb = x1 = r ⊕ a). Thus,
r ⊕ xb = a · b, as required. The cost of securely computing
f× is therefore a single OT. The protocol is trivially secure
since the only information received is via the OT; thus P1
learns nothing and P2 learns only its share of the output.

Secure string-bit multiplication. Observe that within
Eq. (2), we need to also multiply Rj by a bit. It is possible
to use f× for this. However, since Rj is of length κ (in
practice, say 128), this increases the number of oblivious
transfers by κ, which is very signiﬁcant. We therefore would
like to securely compute the functionality f κ×(s, b) = (c, d)
where c ⊕ d = s · b and where s ∈ {0, 1}κ and b ∈ {0, 1}.
Fortunately, f κ× can be securely computed using a single
string OT in the exact same way as f× with P1 inputting
(r, r ⊕ s) in the oblivious transfer. Thus, this also costs a
single oblivious transfer.
3.1.2 The Protocol for FGC
We describe our protocol in the (f×, f κ×)-hybrid model
where the parties have access to a trusted party computing
f× and f κ× for them. As we have seen, these functionalities
can be securely computed eﬃciently using oblivious transfer.

Protocol 3.1

(Securely Computing Eq. (2)).

1. Step 1: In this step, the parties securely compute XOR
def= λu · λv. Recalling that each party Pi

shares of λuv
holds λi

u, λi
v, we have that
λuv = λu · λv =

(cid:16)⊕n

=

i=1λi

u · λi

v

(cid:16)⊕n
(cid:17) ·(cid:16)⊕n
(cid:17) ⊕(cid:16)⊕i(cid:54)=jλi

i=1λi
u

i=1λi
u
u · λj

v

(cid:17)
(cid:17)

.

(3)

u · λi

u, λi

u·λi

v. In addition,
u, λj
v)
v) in order to obtain XOR shares of the prod-
v together with all of the
uv.

Each party Pi can locally compute λi
each pair of parties Pi, Pj (with i (cid:54)= j) runs f×(λi
and f×(λj
ucts. Finally, each Pi XORs λi
output shares received from f×; denote the result by λi
By Eq. (3), it follows that ⊕n
uv = λuv, as required.
2. Step 2: Given shares of λuv = λu · λv, the parties gener-
def= λu · ¯λv ⊕
def= ¯λu · ¯λv ⊕ λw.

def= λuv ⊕ λw, of λu¯vw

ate XOR shares of λuvw
λw, of λ¯uvw
This can be carried out using local computation only.

def= ¯λu · λv ⊕ λw, and of λ¯u¯vw

i=1λi

uv ⊕ λi

w (where λi

Trivially, in order to obtain shares of λuvw it suﬃces for
each Pi to compute λi
uvw = λi
w is its
input share on the output wire).
Furthermore, observe that λu · ¯λv = λu · (λv ⊕ 1) = λu ·
λv ⊕ λu. Thus, each Pi can compute its share λi
u¯vw =
uv ⊕ λi
λi
w. In a similar way, each Pi computes its
u⊕λi
v⊕λi
shares λi
w
(where P1 XORs its result with 1 in this last case).

u ⊕ λi
¯uvw = λi

uv⊕λi

uv⊕λi

¯u¯vw = λi

w and λi

v⊕λi

3. Step 3: In this step, the parties securely compute XOR
shares of Rj · ((λu ⊕ α) · (λv ⊕ β) ⊕ λw), for every j =
1, . . . , n and every α, β ∈ {0, 1}. Observe that they al-
ready have XOR shares of λuvw, λu¯vw, λ¯uvw, λ¯u¯vw, and
so need only to run f κ×. That is, for every j = 1, . . . , n,
party Pj runs four invocations of f κ× with every Pi. In ev-
ery invocation Pj inputs Rj, whereas Pi inputs its share
λi
uvw in the ﬁrst invocation, λi
u¯vw in the second invoca-
tion, and so on. Denote by ρi
j,α,β party Pi’s share of
Rj · ((λu ⊕ α) · (λv ⊕ β) ⊕ λw).

4. Step 4: In this ﬁnal step, the parties conclude the secure
computation of Eq. (2); recall that the aim is for each
party to hold the 4n values {˜gj
j=1. We
describe this for general α, β and use the shares of ρi
that were generated above.

1,1}n

1,0, ˜gj

0,0, ˜gj

0,1, ˜gj

j,α,β

584For every j = 1, . . . , n and every α, β ∈ {0, 1}, party Pj
sends F 2
j,α,β to all other parties,
u,α,kj
kj

(g ◦ j) ⊕ kj

w,0 ⊕ ρj

v,β

and each party Pi sends the string F 2
u,α,ki
j,α,β
ki
to all other parties. The parties then XOR all these values
together, and the result is ˜gj

α,β, as required.

v,β

(g◦j)⊕ρi

Security. Intuitively, the protocol is secure since in Steps 1–
3 the only values that the parties see are random shares out-
put from f× and f κ×. Then, in Step 4, the parties all send
their shares to each other. However, these shares are all
random under the constraint that their XOR is ˜gj
α,β, and so
reveal nothing but the result. The full proof of the following
will appear in the full version of this paper.

Theorem 3.2. Protocol 3.1 securely computes the n-party
FGC functionality with n parties in the (f×, f κ×)-hybrid model,
in the presence of a semi-honest adversary corrupting any
number of parties.

Cost. Using the OT extension protocol of [20, 3], we have
that each (bit or string) oblivious transfer costs two hash
function invocations and two rounds of communication (a
single message from the receiver to the sender and a sin-
gle message back). However, bit-OT is signiﬁcantly cheaper
than string-OT since it requires much less communication,
which is the bottleneck. Note that bit-OT is much faster
than string-OT, but a single string-OT for strings of length
κ is much faster than running κ executions of bit-OT.

We count the number of OT calls run by each party (as
sender and as receiver); recall that f× is just a single bit-
OT and f κ× is just a single string-OT. The number of OT
invocations equals 2(n−1) bit-OT plus 8(n−1) string-OT: in
Step 1 each party computes 2(n− 1) bit-OTs, and in Step 3
each party computes 8(n− 1) string-OTs (4(n− 1) as sender
and 4(n− 1) as receiver). Observe that the use of f κ× instead
of κ calls to f× is very signiﬁcant and reduces the cost in
Step 3 from 8(n − 1)κ bit-OTs to 8(n − 1) string-OTs. The
number of rounds in the entire protocol is ﬁve; two rounds
in each of Step 1 and 3, and a single message in Step 4.
3.1.3 Reducing the Number of String-OTs
We now show that it is possible to reduce the number of
string-OTs from 8(n−1) to 6(n−1), saving 25%. Speciﬁcally,
we show how it is possible to securely compute ˜gj
1,1 from the
shares ρi
j,1,0 (see Step 3 of the protocol) without
running any OTs. As a result, the parties do not need to
run the f κ× invocations where the receiver inputs its share
of λi
¯u¯vw. This means that each Pj only needs to run three
invocations of f κ× as sender, instead of four.
j,0,1⊕ρj
parties, and each party Pi sends the string F 2
ki
u,1,ki
j,0,0 ⊕ ρi
ρi
XOR of all these values is ˜gj
denote ⊕n
the XOR of all these values equals

1,1, party Pj sends the message
j,1,0 to all other
(g◦ j)⊕
j,1,0 to all other parties. We argue that the
In order to see this, ﬁrst
(g ◦ j) by Kg,j. Then, we have that

w,0 ⊕ Rj(cid:1)⊕ρj

(g◦j)⊕(cid:0)kj

In order to compute ˜gj

i=1F 2
ki
u,1,ki

j,0,1 ⊕ ρi

j,0,0⊕ρj

F 2
kj
u,1,kj

j,0,1, ρi

j,0,0, ρi

1,1.

v,1

v,1

v,1

Kg,j ⊕ kj

w,0 ⊕ Rj ⊕ Rj · (λu · λv ⊕ λw)

⊕ Rj ·(cid:0)¯λu · λv ⊕ λw

(cid:1) ⊕ Rj ·(cid:0)λu · ¯λv ⊕ λw

(cid:1) .

Rewriting the above, we have that it equals Kg,j ⊕ kj
⊕Rj · (1 ⊕ λu · λv ⊕ ¯λu · λv ⊕ λu · ¯λv ⊕ λw).

w,0
(Note that

v,1

λw appears 3 times and so 2 cancel out.) Now, for any bits
x, y ∈ {0, 1}, it holds that 1 ⊕ x · y ⊕ ¯x · y ⊕ x · ¯y = ¯x · ¯y.
Thus, we conclude that the XOR of all the values equals
Kg,j ⊕ kj

w,0 ⊕ Rj ·(cid:0)¯λu · ¯λv ⊕ λw

(cid:1) which is exactly ˜gj

1,1.

The security of this optimization holds since all messages
(g◦j) and therefore reveal noth-

sent are masked by F 2
ki
u,1,ki
ing. (They look random and so can be easily simulated.)
3.1.4 Using More Efﬁcient OT
It was shown in [3] that in the Yao protocol, it is pos-
sible to use a variant of OT – called correlated OT – that
is signiﬁcantly more eﬃcient. This version of OT can be
used when there is a diﬀerence ∆ and the sender’s input
is a random pair (x0, x1) with x0 ⊕ x1 = ∆. When using
the free-XOR method within Yao’s protocol, it follows that
the garbled labels on the input wires can be random un-
der the constraint that they have a ﬁxed diﬀerence. Thus,
correlated-OT suﬃces. Observe now that all the calls to OT
are for computing f× and f κ×. In these protocols, party P1
with input bit a (resp., string s) runs the OT-sender with
random inputs (x0, x1) under the constraint that x0⊕x1 = a
(resp., x0 ⊕ x1 = s). The protocols are not described in that
way, but this is the result of choosing r and setting x0 = r
and x1 = r⊕ a. Thus, it is possible to use the correlated-OT
protocol here and save additional cost.
3.2 A New BGW-Based Protocol
The FairplayMP [7] system used the information-theoretic
BGW protocol [8] in order to securely compute the FGC
functionality. In this section, we present a protocol that also
uses the BGW protocol in order to securely compute FGC .
However, there are a number of important diﬀerences:

1. We point out and ﬁx a small bug in the FairplayMP pro-
tocol: In FairplayMP, each party singlehandedly chooses
all the keys for its input wires. This renders the protocol
insecure: every party is able to compute the circuit mul-
tiple times, with diﬀerent inputs of its own (with a ﬁxed
setting of the other parties’ inputs).

2. FairplayMP works over a prime-order ﬁeld. In contrast,
we work in GF (2k) which is a ﬁeld of characteristic 2.
First and foremost, this makes it possible to incorporate
the free-XOR technique into BMR. Second, by using a
ﬁeld of characteristic 2, we are able to reduce the round
complexity of the protocol. This is due to the fact that
in such a ﬁeld the XOR of λuv with λw (as required when
computing Eq. (2)) can be carried out with local compu-
tation only. In contrast, FairplayMP requires interaction
to compute this (XOR is not addition in their ﬁnite ﬁeld,
and so they need a protocol to compute this).

3. We use a ﬁnite ﬁeld that is large enough to embed each
individual key kj
u,α, whereas FairplayMP embed the en-
u,α of length n · κ in the ﬁnite
u,α, . . . , kn
tire “superseed” k1
In the case of 33 parties and keys of length 128
ﬁeld.
bits, FairplayMP would have to work in a ﬁnite ﬁeld with
elements of size at least 4,224 bits. This means that Fair-
playMP scales poorly for large numbers of parties (since
each operation becomes more expensive). In contrast, we
work with each key separately and so the ﬁnite ﬁeld is
always of length κ, resulting in linear growth in the cost
per party (at least with respect to the basic operations
over k1

u,α, . . . , kn

u,α).

5854. We compute multiplications of the λ combinations only
with R1, . . . , Rn. In contrast, FairplayMP compute their
analog of Eq. (2) by multiplying both k1
u,0 and
u,1 ◦ ··· ◦ kn
k1
u,1 with the λ combinations.

u,0 ◦···◦ kn

As we will see below, the focus of our protocol design here
was to reduce the number of rounds to an absolute minimum.

Our basic BGW-based protocol. In general, BGW can
be used to compute any arithmetic circuit. Furthermore,
addition is free in the circuit, and multiplication requires in-
teraction (and computation). When working in a ﬁnite ﬁeld
of characteristic 2, it follows that XOR equals addition, mak-
ing the computation of Eq. (2) trivial. Speciﬁcally, Eq. (2)
simply deﬁnes an arithmetic circuit over the ﬁeld with two
multiplications and 4n additions. To be exact, in order to
compute ˜gj

α,β:

⊕ kj

F 2
kj
u,α,kj

1. Party Pj inputs values Kj, Rj, Uj, Vj, Wj where Kj =
v ⊕ β and Wj = λj
w.
2. Each party Pi (i (cid:54)= j) inputs Ki, Ui, Vi, Wi where Ki =

u⊕ α, Vj = λj

w,0, Uj = λj

v,β

F 2
u,α,ki
ki

v,β

, Ui = λi

u, Vi = λi

v and Wi = λi

w.

3. Using BGW, the parties evaluate the circuit for:
i=1Wi)).

i=1Ki)⊕Rj·((⊕n

i=1Vi)⊕(⊕n

i=1Ui)·(⊕n

(⊕n

Beyond the ability to use free-XOR, we therefore see that
the choice of the ﬁeld to be of characteristic 2 yields a much
simpler protocol as well. Since BGW is secure, we have that
this protocol for computing FGC is automatically secure.

Protocol details and round complexity – BGW4. The
above BGW protocol can be carried out in just 4 rounds of
communication; for this reason we call it BGW4 (to distin-
guish it from other variants that we will describe below). In
order to see how 4 rounds suﬃce, we describe its steps in de-
α,β values (for all j = 1, . . . , n, all α, β ∈ {0, 1} and
tail. All ˜gj
all gates) are computed in parallel. Each value is computed
as follows:

Communication round 1: All inputs are shared using t-out-
of-n Shamir secret sharing, with t = (cid:100)n/2(cid:101) − 1.
Local computation: The parties carry out local additions, as
required by the circuit, in order to obtain shares of λu⊕ α =
i=1Ui and λv⊕β = ⊕n
⊕n
i=1Vi. In addition, the parties locally
multiply their shares of λu ⊕ α and λv ⊕ β. Denote this
product by λα,β
u,v .
Communication round 2: The parties run the GRR [14] de-
gree reduction step on the product λα,β
u,v to recover legitimate
shares of λα,β
u,v of degree t. This is best achieved by each
party i resharing ci · λα,β
u,v in a t-out-of-n sharing, where ci is
a ﬁxed (degree-reduction) constant of that party (which is
precomputed once), and then summing the received shares.

u,v ⊕ λw with Rj.

Local computation: The parties locally add their shares of
λw to λα,β
u,v . Next, the parties once again locally multiply
their shares of λα,β
Communication round 3: The parties run the GRR degree
reduction step on Rj · (λα,β
Local computation: The parties locally add the shares of the
Ki values to the result of the previous step.
Communication round 4: The parties send their shares to
each others and reconstruct to obtain ˜gj

u,v ⊕ λw) as above.

α,β.

Computational complexity. The above is repeated 4n
times for each gate with each computation requiring 3 Shamir
secret sharings. Each sharing requires evaluating a degree-t
polynomial on n points, which takes t· n ≈ n2/2 ﬁeld multi-
plications. The number of multiplications is therefore dom-
inated by the ﬁrst and third communication rounds, where
the number of shares is ≈ 4n per gate, thus requiring ≈ 2n3
multiplications per gate. Therefore, asymptotically, the par-
ties compute 4n3 ﬁeld multiplications per gate of the circuit
(concretely, there are slightly more), which is cubic in the
number of parties. As we will see in Section 4, this signiﬁ-
cantly aﬀect performance when the number of parties is not
small. (We stress that the number of multiplications would
be only quadratic had we worked in a ﬁeld of size n·κ. How-
ever, since multiplication is quadratic, the cost of computing
one multiplication in a ﬁeld of size n · κ is n2 · κ2, versus a
cost of n · κ2 for n multiplications in a ﬁeld of size κ.)
3.3 Reducing the Round Complexity

In this section, we brieﬂy describe how the number of
rounds can be further reduced. The idea of reducing rounds
by omitting reduction steps in BGW already appeared in
[19], but the following is a more concretely eﬃcient way of
achieving this.

BGW3 – three rounds with an honest majority. The
protocol described above that is secure with an honest ma-
jority has 4 rounds of communication. However, it is possible
to save one round of communication by simply not running
the degree reduction step on the Rj · (λα,β
u,v ⊕ λw) values.
This works since the parties only add their shares of the Ki
values to Rj · (λα,β
u,v ⊕ λw). Thus, if the Ki values are shared
using a 2t-degree polynomial instead (at the onset), then the
degrees of the shares of Ki and Rj ·(λα,β
u,v ⊕λw) will be equal,
and so they can be locally added. The reconstruction works
in the same way, and thus this yields a 3-round protocol. We
remark that beyond the fact that this has one round less, it
also has far less communication. This is because the second
degree-reduction is carried out on the shares of Rj · (λα,β
u,v )
and so there are 4n degree-reductions per gate, resulting in
a large amount of bandwidth. Thus, as we will see in Sec-
tion 4, this protocol is always better, and often signiﬁcantly
better, than the 4-round protocol BGW4.

BGW2 – two rounds with more than 2/3 honest.
It
is possible to further reduce the round complexity of the
protocol to just two rounds in the case that more than 2/3
of the parties are guaranteed to be honest, since no degree
reduction is needed at all. However, this has less eﬀect on
the amount of communication (since there are only a small
number of degree reductions remaining).
3.4 Optimizing Field Multiplications

We use κ = 128 and therefore work in GF (2128). We use
the Intel PCLMULQDQ carry-less multiplication instruc-
tion to obtain extremely fast pipelined multiplication oper-
ations in GF (2128) [16]. This works by combining 4 carry-
less multiplication operations over 64-bit operands. In addi-
tion, observe that the majority of the multiplications are for
generating Shamir secret sharing. This works by taking a
distinct ﬁeld element ωi for every party, and evaluating ran-
dom polynomials on these values (which means multiplying
by ωi, ω2
i ). By choosing ωi to be of small degree, we
have that for a small enough d, all of ωi, ω2
i are less

i , . . . , ωd

i , . . . , ωd

586than 64 bits long, and so a 128-bit element is multiplied with
a 64-bit element. This can be achieved in just 2 carry-less
multiplications instead of 4. When the number of parties
exceeds 15, at least 5 bits are needed for each ωi value and
so the length of ωd
i exceeds 64 bits, making the optimization
no longer applicable.

4. EXPERIMENTAL EVALUATION

We implemented our protocols and ran multiple experi-
ments for diﬀerent circuit sizes and depths, diﬀerent num-
ber of parties, and diﬀerent latencies. In order to obtain a
deeper understanding of the strengths and (possible) weak-
nesses of the BMR protocol, we included the GMW proto-
col in our experiments. The GMW protocol has multiple
rounds of communication, but far less bandwidth than the
BMR protocol. In addition, it is currently the only other
general protocol for multiparty computation for the case of
dishonest majority known. We used the code of [10] for
these experiments. As described in Section 1.3, this code is
highly optimized and uses OT extension in an oﬄine phase
for precomputing the oblivious transfers. We ran their code
on the same circuits and platforms as our BMR code. (For
the sake of brevity, in this section we refer to “BMR” as
our diﬀerent protocols; it is not to be misinterpreted as the
original protocol of [5] which was purely theoretical.)

We measured times separately for the oﬄine and online
portion of the executions. In BMR, the entire construction
of the circuit can be run oﬄine, before the inputs are given.
Thus, the online phase has very little communication and
is dominated by local computation of the circuit. In con-
trast, in the GMW protocol, the oﬄine phase consists only
of preprocessing the oblivious transfers. We stress that the
code of [10] does not merely run the base OTs as part of
the OT extensions in the oﬄine phase. Rather, they run
random OTs and use the OT preprocessing method of [4].
Thus, in the online phase, the receiver sends a single bit to
the sender and the sender replies with two bits. In addition,
the parties entire computation requires merely XORing the
preprocessed bits with the actual inputs. As a result, the
GMW online phase has very little computation and com-
munication, but many rounds of communication. We stress
that in applications where low latency is required, the online
time of a protocol is the main factor to be considered (as-
suming reasonable oﬄine time). In contrast, in cases where
the overall throughput is what is important, the total time
is the main factor to be considered.

Platforms and parameters. We ran our experiments on
three diﬀerent platforms. First, we ran them on a clus-
ter with a very low latency network called CREATE [1]
(which is part of the DETER project). The cluster is com-
prised of Intel XEON 2.20 GHz machines (E5-2420) with
6 cores running Linux (Ubuntu1404-64-STD), and with a
1Gb connection and ping time between computers of ap-
proximately 0.1ms.
In addition, we ran our experiments
on Amazon c4.8xlarge instances (running Windows Server
2012 R2 Base) in two conﬁgurations:
in the ﬁrst, all ma-
chines are located in a single zone (Virginia); in the second,
the machines were split between Ireland and Virginia (in
preliminary experiments, this gave similar performance to
where the latency was the same between all parties). The
ping time within a single region is approximately 1ms, and
the ping time between Virginia and Ireland is approximately

75ms. The bandwidth of all connections (according to Ama-
zon’s speciﬁcations) is 10Gb. The experiments in CREATE
provide a very clean (low-latency) environment without ex-
ternal network eﬀects, whereas the experiments in Amazon
reﬂect performance in more “real-world” settings with net-
working ﬂuctuation.

We ran the protocol for 3, 5, 7, 9, 11 and 13 parties, and in
some cases 33 parties. We used 2 diﬀerent circuits: a circuit
computing the AES function with 6,800 AND gates and 256
input wires per party, and a circuit computing SHA256 with
90,825 AND gates and 512 input wires per party. Since the
depth of the circuit is very signiﬁcant for GMW, we also
generated 4 synthetic circuits of the same size as the SHA256
circuit, but with respective depths of d = 10, d = 100, d =
1000 and d = 4000 (the real SHA256 circuit has depth 4000).

Raw results. Each experiment was run 50 times, and we
computed the mean and standard deviation of all runs. The
numbers in the tables here are measured in milliseconds,
and present a 95% conﬁdence interval. Observe that the
interval is sometimes very large. This is especially true in
Amazon in Virginia-Ireland. This expresses the reality that
when sending a large amount of data over the Internet, the
ﬂuctuations are signiﬁcant. The full tables containing all
results will appear in the full version of this paper.
4.1 Protocol Improvements Measurements

We measured the eﬀect of the diﬀerent protocol optimiza-
tions on the running time. We ran the basic OT-based pro-
tocol without additional optimizations (Section 3.1.2), with
the reduced number of OTs (Section 3.1.3), using correlated-
OT (Section 3.1.4), with the free-XOR optimization, and
with two threads between every pair of parties (increasing to
more than two threads between every pair of parties reduced
performance since the number of threads becomes very high
with many parties). Our measurements were made on the
CREATE platform, with 13 parties and the SHA-256 circuit
with 90,825 AND gates and 42,029 XOR gates. The results
are as follows:

Basic Red. OT

Free-XOR 2 OT-Threads
OT-Oﬀ 6434 5549 ± 207 4011 ± 156 2851 ± 101 2633 ± 117
311 ± 20
OT-On

399 ± 46

434 ± 36

313 ± 18

C-OT

The gain by using a reduced number of OTs and by using
the correlated-OT protocol is very signiﬁcant. In all cases,
free-XOR provides exactly the expected speedup by drop-
ping the cost by the ratio of XOR gates to overall gates.

Since all the improvements are also related to communica-
tion, we also tested them in a network with network latency
of 76 ms (with 13 parties and the SHA-256 circuit, as above).
The results are:

Basic Red. OT

Free-XOR 2 OT-Threads
OT-Oﬀ 45631 42408 ± 6300 40644 ± 6266 31071 ± 6720 28805 ± 6878
OT-On

664 ± 128

746 ± 56

773 ± 49

655 ± 81

C-OT

We also ran our 3-round BGW-based protocol in the LAN
setting on the CREATE platform, measuring the inﬂuence
of optimized multiplications, free-XOR, and multithreading.

Basic

Opt. Mult. Free-XOR 2 Mult. Threads

BGW3 Oﬄine 9179 ± 278 8472 ± 294 5809 ± 236
4.2 Protocol Comparison – High Latency

5027 ± 101

Our focus in this paper is the design and implementation
of a protocol that is suitable for Internet settings with high

587computation time of BMR-type protocols may become a fac-
tor. See Fig. 4 for a graph comparing the total running time.

latency. We compared our OT-based protocol of Section 3.1
with the BGW-based protocols described in Section 3.2 and
with GMW. The running-time of our protocol using mul-
tiparty garbled circuits is unaﬀected by the circuit depth,
in contrast to GMW. We therefore ran GMW on diﬀerent
depths for the SHA256-type circuit but not our protocols.
The results of these executions are found in Tables 1 and 2.
We remark that the variance of the executions is very
large, resulting in some unexplained anomalies. (For exam-
ple, the online time should be the same for all versions, and
should increase with the number of parties. However, in Ta-
ble 1 you can see that the online time for 7 parties in the OT
version is lower than expected.) We conjecture that this is
due to the large bandwidth of the protocols and the “noisy”
Amazon environment.

3

OT

698 ± 930
138 ± 88
329 ± 688
143 ± 81

Oﬀ
On
BGW3 Oﬀ
On
BGW2 Oﬀ
On
498 ± 737
BGW4 Oﬀ
139 ± 78
On
231 ± 143
GMW Oﬀ
On 3337 ± 166

7

13

9699 ± 6119
1093 ± 1249
362 ± 515
107 ± 87
9774 ± 8181
2314 ± 1218
329 ± 533
142 ± 76
2212 ± 1440
8745 ± 6832
264 ± 409
148 ± 92
3149 ± 2065 13298 ± 10576
308 ± 473
159 ± 70
277 ± 1067
382 ± 290
3232 ± 9
3341 ± 213

Table 1: The AES circuit – 6800 AND gates (depth 40)

OT

BGW2

BGW4

BGW3

Off
On
Off
On
Off
On
Off
On
Off
(d=4000) On
Off
On
Off
On
Off
(depth=10) On

(d=1000)

(d=100)

GMW

GMW

GMW

GMW

3

6426 ± 1651
5404 ± 11751

172 ± 76
182 ± 77

8124 ± 8000
226 ± 78
850 ± 900
701 ± 556
77147 ± 4031
735 ± 509
8038 ± 518
598 ± 362
880 ± 75

7

226 ± 62
237 ± 91
283 ± 86
282 ± 86

10291 ± 4968
17011 ± 23574
14781 ± 12134
23521 ± 20794
5002 ± 10643
3581 ± 4976
83168 ± 19932
2610 ± 8173
8327 ± 80
1180 ± 521
906 ± 25

13

456 ± 357
520 ± 659
459 ± 325
454 ± 281

25215 ± 4784
38584 ± 35997
37585 ± 17255
65736 ± 45895
5042 ± 9212
7932 ± 16242
82111 ± 5584
4969 ± 9222
8341 ± 271
5360 ± 12829
904 ± 84

309741 ± 32130 333996 ± 92024 329220 ± 31340

Table 2: The SHA256 circuit – 90,825 AND gates

In this Internet-setting, for not shallow circuits, the com-
munication rounds become the dominating factor and so
GMW becomes untenable in the online phase for deep cir-
cuits. At its most extreme, for the real SHA256 circuit of
depth 4000, we have that BMR-OT with 13 parties took 26
seconds overall and under half a second online time, whereas
GMW took 335 seconds overall and 330 seconds online time
(a diﬀerence of one order of magnitude overall, and two or-
ders of magnitude for the online time). This diﬀerence grows
even larger for 3 parties since GMW is less aﬀected by the
number of parties than our protocols.

It is important to note that for low-depth circuits, GMW
performs remarkably well even in an Internet setting. This
is no surprise for depth-10 and overall time, since the round
complexity of both protocols is almost the same. However,
even for depth-100, GMW outperforms our protocols for 7
or more parties. This is very informative and is important
to explain. The complexity of GMW is linear in the number
of parties, versus BMR that is quadratic. Thus, when the
number of parties grows, this becomes a factor. Despite this,
the online time of our protocols are always better (even for
depth 10 circuits alone), and the number of parties is heavily
outweighed by the networking cost for non-shallow circuits.
However, for a very large number of parties, the quadratic

Figure 4: Total time GMW vs BMR in Amazon (Virginia-Ireland)
4.3 Protocol Comparison – Low Latency

Over the past years it has become clear that diﬀerent se-
cure computation protocols are better suited to diﬀerent set-
tings. As such, an important question to answer is when is
one protocol better than another. We therefore ran experi-
ments comparing our protocols on two low latency networks:
on the CREATE platform with a ping time of 0.1ms and
within the Amazon Virginia region with a ping time of 1ms.
Our aim was to understand at what point GMW becomes
better than our constant-round protocols based on BMR.

Before proceeding to the results, we review the running-
time of the protocol as a function of the number of parties. A
theoretical analysis shows that with respect to the number of
parties, in the oﬄine phase: GMW scales linearly, the BMR-
OT protocol scales quadratically (the OT part is linear, but
each party sends messages of length 4nκ|C| to each other
party, meaning that each party must send messages of total
size 4n2κ|C|), while the BMR-BGW protocols scale cubically
(recall that by this we mean that each party works linearly,
quadratically or cubically). In contrast, in the online phase,
the BMR protocols are all the same and we have that GMW
scales linearly and BMR scales quadratically.

This analysis yields an interesting and rather complicated
tradeoﬀ. On the one hand, GMW scales better than BMR
with respect to the number of parties; on the other hand,
BMR scales far better as the depth of the circuit increases.
This tradeoﬀ becomes more extreme when considering the
BGW-based protocols for BMR since they are cubic. As we
will see, this is the cause of their downfall, and they rarely
perform well.

CREATE – 0.1ms ping time. The aforementioned dif-
ference in computational time is most evident in CREATE
where latency is very low; see Figure 5 for a graph of the
total times including both the oﬄine and online phases (OT
stands for the protocol in Section 3.1) Recall that the mul-
tiplication optimization for BGW in Section 3.4 only works
for up to 15 parties; thus the curve steepens for 33 parties.
Before proceeding, we stress that the scale factor is exactly
as expected from the theoretical analysis. However, the big
surprise is that in this setting GMW actually outperforms
all of the BMR versions of the protocol when the number
of parties is 7 or more, even though the circuit has depth

5884000.
In [31], they showed that in the two-party setting,
GMW can outperform Yao for low-depth circuits and low-
latency networks. Our conclusion here is far more dramatic;
in low-latency networks GMW can outperform BMR even
for very deep circuits. We stress that BMR protocols have
between 3 and 5 rounds whereas GMW has 8000 rounds (2-
rounds per level of the circuit). The disparity between this
and the two-party setting is due to the signiﬁcant additional
communication and computational overhead in BMR versus
Yao (observe that for only a few parties, the running times
are comparable).

with 91,000 AND gates for 33 parties requires 332× 91000 ≈
10,000,000 invocations of AES. This therefore becomes a
dominating factor.
In the two-party setting, the protocol
cost has been reduced so signiﬁcantly that communication
is the bottleneck. In the multiparty setting, this is currently
not the case. (We stress that state-of-the-art pipelining us-
ing AES-NI with a ﬁxed-key was used, as in the fastest Yao
garbled circuit implementations.)

Amazon Virginia – 1ms ping time. The above relates
to a very low latency network with a single message latency
of approximately 0.05ms.
In the Virginia-Virginia setting
of Amazon, a similar phenomenon happens in terms of the
scaling curves. However, they are less pronounced because
(a) the latency of the network plays more of a role, and (b)
the CPUs on the Amazon machines are stronger, reducing
the cost of computation. See Figure 7. For the online time
in this setting, the GMW protocol already behaves much
more poorly; see Figure 8, even though this is still a fast
network (with a 1ms latency). Nevertheless, it is clear from
the graph that BMR degrades quickly and so with a larger
number of parties (say, 50), GMW will beat BMR even in
the online time in Amazon Virginia.

Figure 5: Total time GMW vs BMR in CREATE

Of course, the above considers the total running time.
However, the strength of our protocols over GMW is in the
online time, since BMR requires sending only garbled values
on the input wires and local computation. In contrast, GMW
still has 8000 rounds of communication in the online phase.
This means that GMW cannot go below 400ms in the online
time. To our great surprise, although BMR was signiﬁcantly
faster than GMW for a small number of parties, GMW was
faster for 33 parties. Indeed, although for 3 parties, GMW
takes approximately 400ms, it grows to only 1113ms for 33
parties. In contrast, BMR takes only 85ms for 3 parties but
grows to 1506ms for 33 parties; see Figure 6.

Figure 7: Total time GMW vs BMR in Amazon Virginia

Figure 6: Online time GMW vs BMR in CREATE

We explain this as being due to the quadratic complexity
of the BMR circuit. Speciﬁcally, evaluating a BMR circuit

Figure 8: Online time GMW vs BMR in Amazon Virginia

589Acknowledgements
We sincerely thank Meital Levy, Assi Barak, Shay Gueron,
and Roi Inbar for their help on the implementations and
experiments in this paper.

5. REFERENCES

[1] Cyber-defense technology experimental research

laboratory (in cooperation with DETER lab).
https://www.create.iucc.ac.il.

[2] SCAPI – the Secure Computation API.

https://github.com/cryptobiu/libscapi.

[3] G. Asharov, Y. Lindell, T. Schneider, and

M. Zohner. More eﬃcient oblivious transfer and
extensions for faster secure computation. In ACM
CCS, pages 535–548, 2013.

[4] D. Beaver. Correlated pseudorandomness and the

complexity of private computations. In the 28th
STOC, pages 479–488, 1996.

[5] D. Beaver, S. Micali, and P. Rogaway. The round

complexity of secure protocols. In the 22nd STOC,
pages 503–513, 1990.

[6] M. Bellare, V.T. Hoang, S. Keelveedhi, and

P. Rogaway. Eﬃcient garbling from a ﬁxed-key
blockcipher. In IEEE Security and Privacy, pages
478–492, 2013.

[7] A. Ben-David, N. Nisan, and B. Pinkas.

FairplayMP: a system for secure multi-party
computation. In ACM CCS, pages 257–266, 2008.

[8] M. Ben-Or, S. Goldwasser, and A. Wigderson.

Completeness theorems for noncryptographic
fault-tolerant distributed computations. In the 20th
STOC, pages 1–10, 1988.

[9] D. Bogdanov, S. Laur and J. Willemson.

Sharemind: A framework for fast privacy-preserving
computations. In ESORICS 2008, Springer (LNCS
5283), 192–206, 2008.

[10] S.G. Choi, K.W. Hwang, J. Katz, T. Malkin, and
D. Rubenstein. Secure multi-party computation of
boolean circuits with applications to privacy in
on-line marketplaces. In CT-RSA 2012, pages
416–432, 2012.

[11] S.G. Choi, J. Katz, R. Kumaresan, and H.S. Zhou.
On the security of the ”free-xor” technique. In the
9th TCC, pages 39–53, 2012.

[12] I. Damg˚ard, M. Keller, E. Larraia, V. Pastro,

P. Scholl, and N.P. Smart. Practical covertly secure
MPC for dishonest majority - or: Breaking the
SPDZ limits. In 18th ESORICS, pages 1–18, 2013.

[13] I. Damg˚ard, V. Pastro, N.P. Smart and S. Zakarias.

Multiparty Computation from Somewhat
Homomorphic Encryption. In CRYPTO 2012,
pages 643–662, 2012.

[14] R. Gennaro, M.O. Rabin, and T. Rabin. Simpliﬁed

VSS and fast-track multiparty computations with
applications to threshold cryptography. In
PODC’98, pages 101–111, 1998.

[15] O. Goldreich, S. Micali, and A. Wigderson. How to
play any mental game. In the 19th STOC, 218–229,
1987.

[16] S. Gueron and M.E. Kounavis. Eﬃcient

implementation of the galois counter mode using a

carry-less multiplier and a fast reduction algorithm.
Inf. Process. Lett., 110(14-15):549–553, 2010.

[17] S. Gueron, Y. Lindell, A. Nof and B. Pinkas. Fast

Garbling of Circuits Under Standard Assumptions.
In the 22nd ACM CCS, pages 567–578, 2015.

[18] Y. Huang, D. Evans, J. Katz, and L. Malka. Faster

secure two-party computation using garbled
circuits. In the USENIX Security Symposium, 2011.

[19] Y. Ishai and E. Kushilevitz. Randomizing
Polynomials: A New Representation with
Applications to Round-Eﬃcient Secure
Computation. In the 41st FOCS, pages 294–304,
2000.

[20] Y. Ishai, J. Kilian, K. Nissim, and E. Petrank.

Extending oblivious transfers eﬃciently. In
CRYPTO 2003, pages 145–161, 2003.

[21] Y. Ishai, M. Prabhakaran and A. Sahai. Founding

Cryptography on Oblivious Transfer - Eﬃciently. In
CRYPTO 2008, pages 572–591, 2008.

[22] M. Keller, E. Orsini and P. Scholl. Actively Secure

OT Extension with Optimal Overhead. In
CRYPTO 2015, Springer (LNCS 9215), pages
724–741, 2015.

[23] M. Keller, P. Scholl and N.P. Smart. An

architecture for practical actively secure MPC with
dishonest majority. ACM CCS, pp. 549–560, 2013.

[24] V. Kolesnikov and R. Kumaresan: Improved OT

Extension for Transferring Short Secrets. In
CRYPTO 2013, Springer (LNCS 8403), pages
54–70, 2013.

[25] V. Kolesnikov and T. Schneider. Improved garbled

circuit: Free xor gates and applications. In
Automata, Languages and Programming, pages
486–498, 2008

[26] B. Kreuter, a. shelat, and C. Shen. Billion-gate

secure computation with malicious adversaries. In
USENIX Security Symposium, pages 285–300, 2012.

[27] E. Larraia, E. Orsini, and N.P. Smart. Dishonest

majority multi-party computation for binary
circuits. In CRYPTO 2014, pages 495–512, 2014.
[28] Y. Lindell, B. Pinkas, N.P. Smart, and A. Yanai.
Eﬃcient constant round multi-party computation
combining BMR and SPDZ. In CRYPTO 2015,
pages 319–338, 2015.

[29] D. Malkhi, N. Nisan, B. Pinkas and Y. Sella.

Fairplay-secure two-party computation system. In
the USENIX Security Symposium, 2004.

[30] P. Mohassel, M. Rosulek and Y. Zhang. Fast and

Secure Three-party Computation: The Garbled
Circuit Approach. ACM CCS, pp. 591–602, 2015.

[31] T. Schneider and M. Zohner. GMW vs. Yao?

eﬃcient secure two-party computation with low
depth circuits. In Financial Cryptography and Data
Security, pages 275–292, 2013.

[32] A. C. Yao. How to generate and exchange secrets.

In the 27th FOCS, pages 162–167, 1986.

[33] S. Zahur, M. Rosulek and D. Evans: Two Halves

Make a Whole - Reducing Data Transfer in Garbled
Circuits Using Half Gates. In EUROCRYPT,
220–250, 2015.

590