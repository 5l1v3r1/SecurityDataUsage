Towards Discovering and Understanding Task 

Hijacking in Android

Chuangang Ren, The Pennsylvania State University; Yulong Zhang, Hui Xue,  

and Tao Wei, FireEye, Inc.; Peng Liu, The Pennsylvania State University

https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/ren-chuangang

This paper is included in the Proceedings of the 24th USENIX Security SymposiumAugust 12–14, 2015 • Washington, D.C.ISBN 978-1-931971-232Open access to the Proceedings of  the 24th USENIX Security Symposium is sponsored by USENIXTowards Discovering and Understanding Task Hijacking in Android

Chuangang Ren1, Yulong Zhang2, Hui Xue2, Tao Wei2 and Peng Liu1

1Pennsylvania State University, State College

2Fireeye, Inc.

Abstract
Android multitasking provides rich features to enhance
user experience and offers great ﬂexibility for app de-
velopers to promote app personalization. However, the
security implication of Android multitasking remains
under-investigated. With a systematic study of the com-
plex tasks dynamics, we ﬁnd design ﬂaws of Android
multitasking which make all recent versions of An-
droid vulnerable to task hijacking attacks. We demon-
strate proof-of-concept examples utilizing the task hi-
jacking attack surface to implement UI spooﬁng, denial-
of-service and user monitoring attacks. Attackers may
steal login credentials, implement ransomware and spy
on user’s activities. We have collected and analyzed over
6.8 million apps from various Android markets. Our
analysis shows that the task hijacking risk is prevalent.
Since many apps depend on the current multitasking de-
sign, defeating task hijacking is not easy. We have noti-
ﬁed the Android team about these issues and we discuss
possible mitigation techniques in this paper.

1

Introduction

In the PC world, computer multitasking means multiple
processes are running at the same period of time.
In
Android systems, however, multitasking is a unique and
very different concept, as deﬁned in Android documenta-
tion: “A task is a collection of activities that users interact
with when performing a certain job” [1]. In other words,
a task contains activities [4] (UI components) that may
belong to multiple apps, and each app can run in one or
multiple processes. The unique design of Android multi-
tasking helps users to organize the user sessions through
tasks and provides rich features such as the handy ap-
plication switching, background app state maintenance,
smooth task history navigation using the “back” button,
etc. By further exposing task control to app developers,
Android tasks have substantially enhanced user experi-

ence of the system and promoted personalized features
for app design.

Despite the merits, we ﬁnd that the Android task man-
agement mechanism is plagued by severe security risks.
When abused, these convenient multitasking features can
backﬁre and trigger a wide spectrum of task hijacking at-
tacks. For instance, whenever the user launches an app,
the attacker can condition the system to display to the
user a spoofed UI under attacker’s control instead of the
real UI from the original app, without user’s awareness.
All apps on the user’s device are vulnerable, including
the privileged system apps. In another attack, the mal-
ware can be crafted as one type of ransomware, which
can effectively “lock” the tasks that any apps belong to
on the device (including system apps or packages like
“Settings” or “Package Installer”), i.e.
restricting user
access to the app UIs and thus disabling the functionality
of the target apps; and there is no easy way for a normal
user to remove the ransomware from the system. More-
over, Android multitasking features can also be abused
to create a number of other attacks, such as phishing and
spyware. These attacks can lead to real harms, such as
sensitive information stolen, denial-of-service of the de-
vice, and user privacy infringement, etc.

The Android multitasking mechanism and the under-
lying feature provider,
the Activity Manager Service
(AMS), haven’t been thoroughly studied before. In this
paper, we take the ﬁrst step to systematically investi-
gate the security implications behind Android multitask-
ing design and the AMS. At the heart of the problem,
although the Android security model renders different
apps sandboxed and isolated from one another, Android
allows the UI components (i.e., activities) from differ-
ent apps to co-reside in the same task. Given the com-
plexity of task dynamics, as well as the vagaries of addi-
tional task controls available to developers, the attacker
can play tricky maneuvers to let malware reside side by
side with the victim apps in the same task and hijack the
user sessions of the victim apps. We call this task hijack-

USENIX Association  

24th USENIX Security Symposium  945

Attacks
Types
Spooﬁng

Denial-of-service

Consequences

Sensitive info stolen

Restriction of use access

to apps on device

Vulnerable

system & apps

all; all

all; all

Monitoring

User privacy infringement

Android 5.0.x; all

Table 1: Types of task hijacking attacks presented in this paper
(system versions considered - Android 3.x, 4.x, 5.0.x).

ing.

Given the security threats, it becomes important to
fully study Android multitasking behaviors in a system-
atic way. We approach this topic by projecting the task
behaviors into a state transition model and systematically
study the security hazards originated from the discrep-
ancies between the design assumptions and implementa-
tions of Android tasks. We ﬁnd that there is a plethora
of opportunities of task hijacking exploitable to create a
wide spectrum of attacks. To showcase a subset of the
attack scenarios and their consequences, we implement
and present a set of proof-of-concept attacks as shown in
Table 1.

We do vulnerability assessment to the task hijacking
threats and discover that all recent Android versions, in-
cluding Android 5, can be affected by these threats, and
all apps (including all privileged system apps) are vul-
nerable to most of our proof-of-concept attacks on a vul-
nerable system. By investigating the employment of task
control features by app developers based on 6.8 million
apps in various Android markets, we ﬁnd that despite the
serious security risks, the “security-sensitive” task con-
trol features are popular with developers and users. We
have reported our ﬁndings to the Android security team,
who responded to take a serious look into the issue. We
summarize our contributions below:

• To the best of our knowledge, we are the ﬁrst to sys-
tematically study the security implications of An-
droid multitasking and the Activity Manager Ser-
vice design in depth.

• We discover a wide open attack surface in Android
multitasking design that poses severe threats to the
security of Android system and applications.

• Base on our vulnerability analysis over 6.8 million
apps, we ﬁnd that this problem is prevalent and can
lead to a variety of serious security consequences.

• We provide mitigation suggestions towards a more

secure Android multitasking sub-system.

2 Background

Android Application Sandbox: The Android security
model treats third-party apps as untrusted and isolates

them from one another. The underlying Linux kernel en-
forces the Linux-user based protection and process iso-
lation, building a sandbox for each app. By default, the
components of one app run in the same Linux process
with an unique UID. Components from different apps
run in separate processes. One exception is that differ-
ent apps can run in one process only if they are from the
same developer (same public key certiﬁcate), and the de-
veloper explicitly speciﬁes the same process in the man-
ifest ﬁle. The Linux sandbox provides the foundation for
app security in Android. In addition, Android provides a
permission model [12, 19] to extend app privileges based
on user agreement, and offers an inter-component com-
munication scheme guarded by permissions for inter-app
communication.

Activity: Activity is a type of app component. An ac-
tivity instance provides a graphic UI on screen. An app
typically has more than one activities for different user
interactions such as dialing phone numbers and reading
a contact list. All activities must be deﬁned in an app’s
manifest ﬁle.

Intent:
To cross the process boundaries and enable
communication between app components, Android pro-
vides an inter-component communication (ICC) scheme
supported by an efﬁcient underlying IPC mechanism
called binder. To perform ICC with other components,
an component use intent, an abstract description of the
operations to be performed. An intent object is the mes-
sage carrier object used to request an action from another
component, e.g., starting an activity instance by calling
startActivity() function. Intent comes in two ﬂa-
vors. Explicit intent speciﬁes the component to start ex-
plicitly by name. Implicit intent instead encapsulates a
general type of action, category or data for a component
to take. The system will launch a component “capable”
of handling this intent. If more than one target activi-
ties exist in the system, the user is prompted to choose a
preferred one.

Activity Manager Service (AMS): AMS is an Android
system service that supervises all the activity instances
running in the system and controls their life cycles (cre-
ation, pause, resume, and destroy). The interaction
and communication protocols between activities and the
AMS are implemented by the Android framework code,
which is transparent to app developers, leaving devel-
opers focusing on the app functionality. While Win-
dow Manager Service (WMS) manages all windows in
the system and dispatches user inputs from the windows,
AMS organizes all the activities in the system into tasks,
and is responsible for managing the tasks and support-
ing the multitasking features as will be described in Sec-
tion 3.

946  24th USENIX Security Symposium 

USENIX Association

2

In addition, AMS is in charge of supervising ser-
vice components, intent routing, broadcasting, content
providers accesses, app process management, etc., mak-
ing itself one of the most critical system services in the
Android system.

T1: 

(

S0 

Foreground 

Home 

Launcher Task 

s s e 
0

start

,

,

,

1

newtask

)

T2: 

(

,
s s e 
1

start

,

,

2

default

)

S1 

Foreground 

Home 

A 

Home 

S2 

Foreground 

B 
A 

Launcher Task  App Task 

Launcher Task  App Task 

3 Android Tasks State Transition Model

T4: 

( ,
s s e 
1

back

,

,

0

default

)

T3: 

(

s s e 
2

back

,

,

,

1

default

)

3.1 Task and Back Stack
In Android, a task [1] is a collection of activities that
users have visited in a particular job. The activities in a
task are kept in a stack, namely back stack, ordered by
the time the activities are visited, such that clicking the
“back” button would navigate the user back to the most
recent activity in the current task. The activities in the
back stack may be from the same or different apps.

The activity displayed on the screen is a foreground
activity (on the top of the back stack) and the task as-
sociated with it is a foreground task. Therefore, there is
only one foreground task at a time and all other tasks are
background tasks. When switched to the background,
all activities in a task stop, and remain intact in the back
stack of the task, such that when the users return they can
pick up from where they left off. This is the fundamental
feature that Android multitasking offers to users.

3.2 A Tasks State Transition Model
The status of tasks in a system keeps changing as a re-
sult of user interaction or app program behaviors. To
understand the complex task dynamics and its behind se-
curity implications, we view the task transitions through
time as a state transition model. The model is described
by (S,E,Λ,→), where S denotes a set of task states; E
and Λ are sets of events and conditions respectively; and
→ indicates a set of feasible transactions allowed by the
system under proper events and conditions.
1. Task state (s ∈ S): represents the state of all tasks
(speciﬁcally, the back stacks) in the system and their
foreground/background statuses.
In other words,
the tasks in the system remain in one state i f f the
activity entries and their orders in the back stacks
stay the same, and the foreground task remains to
be the same task.

2. Event (e ∈ E): denotes the event(s) it takes to
trigger the state transition, for example, pressing
the “back” button or calling startActivity()
function.

3. Condition (λ ∈ Λ): the prerequisites or conﬁgura-
tions (usually default) that enable a state transition
under certain events. We denote λ de f ault as the sys-
tem default conditions in this paper.

Figure 1: A simple task state transition example.

4. Transition (→): stands for a feasible state transi-
tion. Not all task transitions are feasible, e.g., the
order of activities in back stack cannot be changed
arbitrarily (only push and pop are viable operations
over the stack). A viable transaction is also repre-
sented as s1 → s2, or (s1,s2,e,λ ), where s1,s2 ∈ S.

3.3 A Task State Transition Example
Given the state transition model, we depict a simple task
state transition example in Figure 1. The ﬁgure shows
three task states, and the state transitions reﬂect the pro-
cess in which the user ﬁrst launches an app from the
home screen (s0 → s1), visits an additional activity UI
in the app (s1 → s2) and returns to the home screen by
pressing the “back” button twice (s2 → s1 → s0).
In each task state, we show all existing tasks and their
back stacks. For example, s0 is a task state in which no
task, except the launcher task, is running in the system.
The launcher task has only one activity in its back stack -
the home screen from which users can launch other apps.
In (s0,s1,estart ,λ newtask), a new app task is created and
brought to the foreground in the resulting state s1. estart
represents the event that startActivity() is called
by the home activity in the launcher task. This event
could happen when the user clicks the app’s icon on the
home screen. λ newtask speciﬁes a special condition, i.e.,
the FLAG_ACTIVITY_NEW_TASK ﬂag is set to the in-
put intent object to startActivity() function. This
ﬂag notiﬁes the AMS the intention of creating a new task
to host the new activity. Note that in this example most
state transitions are under default conditions, indicated
by λ de f ault, while here s0 → s1 is an exception because
the launcher app customizes the condition (λ newtask) for
a valid design purpose: start the app in a brand new task
when the user launches an new app. This is an example
where app developers can customize certain conﬁgurable
conditions to implement helpful app features. However,
condition like λ newtask can be abused in a task hijacking
attack, as discussed in Section 4.

Next, (s1,s2,estart ,λ de f ault) is triggered by event estart
again (this time called by activity A instead), yet un-
der the default condition. By default, AMS pushes the
new activity instance B on top of the current back stack

USENIX Association  

24th USENIX Security Symposium  947

3

Activity Manager Service

ActivityStack
ActivityStack

TaskRecord

TaskRecord
TaskRecord
TaskRecord

ActivityRecord
ActivityRecord
ActivityRecord

Back Stack

Figure 2: Data structures of tasks, activities and back stacks
in the Activity Manager Service.

as shown in s2. The previous activity A is stopped and
its state is retained. In (s2,s1,eback,λ de f ault), eback repre-
sents the event of user pressing the “back” button. As ex-
pected by the user, the next activity A on stack is brought
back to the screen, and its original state is resumed. Ac-
tivity B is popped from the back stack and destroyed by
the system. The initial state s0 is ﬁnally restored through
(s1,s0,eback,λ de f ault) when the user presses “back” but-
ton again. The app’s task is destroyed because when the
popped activity is the last activity in the back stack, the
activity is destroyed together with the “empty” task.

Note that activities from different apps can co-reside
in the same task (e.g. activity A and B in this exam-
ple). In other words, although activities from different
apps are isolated and protected within their own process
sandboxes, Android allows different apps to co-exist in
a common task. This creates opportunities for malicious
activities to interfere with other activities once they are
placed in the same task, and the system passes the pro-
gram control to the malicious activities.

In reality, the amount of possible task states in a sys-
tem is big, and the state transitions can be complex, e.g.,
each state may again have numerous incoming and out-
going transitions connecting with other states. In Sec-
tion 4, we discuss what may go wrong during the com-
plex task state transitions.

3.4 Android Implementation

AMS maintains Android tasks and activities in a hier-
archy shown in Figure 2. AMS uses TaskRecord and
ActivityRecord objects to represent tasks and activ-
ities in the system respectively. A TaskRecord main-
tains a stack of ActivityRecord instances, which is
the back stack of that task. Similar to the activities in a
back stack, tasks are organized in a stack as well, main-
tained by a ActivityStack object, such that when
a task is destroyed, the next task on stack is resumed
and brought to the foreground. There are usually two
ActivityStack containers in the system - one con-
taining only the launcher’s tasks and the other holding
all remaining app tasks.

S0
Foreground

Home
Launcher 

mal-main
mal-root

Malware

A

B

S1

mal-main
mal-root
Malware

S1’

Home
Launcher

Hijacked

State

Home
Launcher

mal-root
Malware

Foreground

main
Victim

Foreground
mal-main

main
Victim

Figure 3: Task state transition of spooﬁng attack (A: task state
transition by system-default. B: Hijacking state transition).

4 Task Hijacking in Android

In this section, we ﬁrst discuss an example showing how
an attacker could manipulate the task state transitions to
his advantage, causing task hijacking attacks. We then
explore the extent of different task hijacking methods and
how they can be used for other various attack goals.

4.1 Motivating Example
Suppose attacker’s goal is to launch an UI spooﬁng at-
tack. Speciﬁcally, when the user launches a victim app
from the home screen, a spooﬁng activity with an UI
masquerading the victim app’s main activity (e.g. the lo-
gin screen of a bank app) shows up instead of the original
activity.

Figure 3 shows the task state transitions of the UI
spooﬁng attack. Initially in s0, the home screen is dis-
played to the user while a malware task waits in the back-
ground. Like the task state transition example just shown
in Section 3.3, when the user launches the victim app
from the launcher, state transition A is supposed to occur
by default, i.e. a new task is created and the app’s main
activity is displayed on screen. However, as shown in
state transition B, the malware can manipulate the task
state transition conditions such that the system instead
displays the spooﬁng UI of activity ”mal-main” by relo-
cating ”mal-main” from the background task to the top
of victim app’s back stack. The user has no way to detect
the spooﬁng UI since the original activity UI is not shown
on screen at all, and the ”mal-main” activity appears to
be part of the victim app’s task (perceivable in recent task
list). By this means, the victim task is smoothly hijacked
by the malware activity from launch time, and all user
behaviors within this task are now under malware’s con-
trol.

In this example, the attacker successfully misleads the
system and launches the spooﬁng UI by abusing some
task state transition conditions, i.e. taskAffinity
and allowTaskReparenting. We will introduce
them together with other exploitable conditions/events in

948  24th USENIX Security Symposium 

USENIX Association

4

Conditions

Intent Flags

(FLAG_ACTIVITY_*)

Activity Attribute

NEW_TASK
SINGLE_TOP
CLEAR_TOP

NO_HISTORY
CLEAR_TASK

REORDER_TO_FRONT

launchMode

allowTaskReparenting

taskAfﬁnity

allowTaskReparenting

documentLaunchMode (API 21)

NEW_DOCUMENT (API 21)

ﬁnishOnTaskLaunch

MULTIPLE_TASK

Callback Function

onBackPressed()

Events

Framework APIs
startActivity()
startActivities()

TaskStackBuilder class

Table 2: Task control knobs - conﬁgurable task state transition
conditions and events provided by Android.

Section 4.5 and 4.6.

4.2 Adversary Model
We assume the user’s Android device already has a mal-
ware installed (similar assumptions are made in [8, 25,
34, 38]). The malware pretends to seem harmless, requir-
ing only a minimum set of widely-requested permissions
such as INTERNET permission. The attacker’s goal is
clear: blend the malicious activities with the target app’s
activities in one task, and intercept the normal user oper-
ations to achieve malicious purposes.

4.3 Hijacking State Transition
A hijacked task state is a desirable state to attackers, in
which at least one task in the system contains both ma-
licious activities (from malware) and benign activities
(from the victim app). The task state s(cid:31)
1 in the spoof-
ing attack is an example of hijacked task state. A hijack-
ing state transition (HST) is a state transition which turns
the tasks in the system to a dangerous hijacked task state,
e.g., the task state transition B in the previous example.
Conceptually, there are two types of HSTs:

1. The malicious activity gets pushed onto the victim

task’s back stack (malware⇒victim);
2. The victim app activity is “tricked” by mal-
ware and pushed on the malware’s back stack
(victim⇒malware).

4.4 The Causes of HSTs
Android provides a rich set of task control features, i.e.,
task state transition conditions and events. We call these
features as task control knobs. The task control knobs
provide app developers with broad ﬂexibility in control-
ling the launch of new activities, the relocation of ex-
isting activity to another task, “back” button behaviors,

even the visibility of a task in the recent task list (a.k.a
overview screen), etc. Table 2 lists such conditions and
events in four categories: activity attribute, intent ﬂags,
call-back functions, and framework APIs. All these con-
trol ﬂexibility further complicates task state transitions.
Due to HST’s potential threats to app and system se-
curity, understanding the extent of HSTs in the complex
task state transitions becomes important. To achieve this,
we simulate the task state transitions in a Android system
and try to capture all possible HSTs and hijacked task
states that occur during the state transitions.

In theory, there are a huge number of possible task
states (each app may have a number of activities, and an
activity can be instantiated for multiple times). We con-
ﬁne the number of task states to more interesting cases
by adding two constraints: (1) each app only has two ac-
tivities - the main activity and another public exported
activity (can be invoked by other apps), and (2) each ac-
tivity can only be instantiated once. In the simulation,
we specify three apps in the system - namely, Alice, Bob
and Mallory (the malware) - as it covers most HST cases.
Given the task states, we generate the task state tran-
sition graph by connecting pairs of states with directed
edges. For instance, state s1 and s2 are connected only
if ∃e ∈ E,λ ∈ Λ, such that (s1,s2,e,λ ) or (s2,s1,e,λ )
are valid transitions, where E denotes all feasible events
and Λ represents all possible conditions in Table 2. After
constructing the task state transition graph, all hijacked
states and HSTs are highlighted. We show a sub-graph of
the resulting task state transition graph in Figure 4(a) and
visualize the task states in Figure 4(b). For clarity of the
presentation, we only show the interesting branches of
the over-sized graph and have skipped many duplicated
HST cases. Moreover, we zoom in each of the HSTs and
show their detailed information in Table 3, including the
conditions and events that trigger the HSTs. We manu-
ally verify all presented HSTs on real systems and these
HSTs are proven to be exploitable to launch real attacks
(indicated in the last column in Table 3).

We make two important observations from our result.
First, once exploited, the hijacked states shown in Fig-
ure 4(a) could result in serious security hazards. For ex-
ample, HST#3 is the task state transition of our exam-
ple attack discussed earlier. As a result of this HST, the
screen is under attacker’s control in state s14. As another
example, in HST#2, the benign activity B2 is tricked to
be placed in Mallory’s task instead of Alice’s task dur-
ing start-up. This can also lead to spooﬁng attack or GUI
conﬁdentiality breaches.

Second, compared with the HST triggered by the
system-default conditions and events (e.g., HST#1),
more HST scenarios are produced under the conﬁgurable
conditions and events (HST#2-6) .
It means that, by
abusing the ﬂexible task control “knobs” readily offered

USENIX Association  

24th USENIX Security Symposium  949

5

S5

S6

S8

S1

S0

S2

#4

S4

S3

S7

S11

S13

S12

S9

(a)

S16

#6

S14

#2

S15

S18

S10

S17

S

S

Tasks State
Hijacked State
Tasks State Trans.
HST

S1

S2

S3

S4

S5

S6

F
A1

F
M2
A1

S7

S8

F
M1

B
M2
M1

F
B1

S9

F
A1
M1

S13

S14

S15

F
A1

M2
M1

F
M2
A1

M1

F
A2
A1

M2
M1

F
B2
A2
A1

(b)

B
M1

S10

F
M2
A1
M1

S16

F
A2
A1

A1

F
B2
A2
A1

F
M1
A1

S11

S12

F
M1

S17

M2
M1

F
A1

A2
A1

M1

S18

F
B2
M2
M1

Figure 4: (a) A sub-graph of the over-sized task state transition graph for a simulated system with three apps. The sub-graph shows
the typical cases of HSTs (red edges with HST indexes) and the resulting hijacked task states (red nodes). s0 represents the initial
state, i.e., no tasks except the launcher task exists in the system. (b) Visualization of task states of all nodes in ﬁgure (a). A, B and
M represent the activities from Alice, Bob and Mallory (the malware) respectively. We skip showing the launcher task in the task
states. Hijacked states are highlighted as red boxes. F and B denote foreground and background tasks respectively.

HST

#
1

2

3

4

5

6

HST Type

malware⇒victim
victim⇒malware
malware⇒victim
victim⇒malware

victim⇒malware
malware⇒victim

Conditions

Default

NEW_TASK intent ﬂag set or B2:launchMode=”singleTask”

M1:taskAfﬁnity=B2

M2:taskAfﬁnity=A1; M2:allowTaskReparenting=”true”

NEW TASK intent ﬂag set

Events

A1: startActivity(M1)

A2: startActivity(B2)

Attacks

in Section 5
phishing I

phishing II

launcher: startActivity(A1)

spooﬁng

M1:taskAfﬁnity=A1; NEW_TASK intent ﬂag set

launcher: startActivity(A1)

denial-of-use;
ransomware;

spyware

phishing III

M1:taskAfﬁnity=B2; B2:allowTaskReparenting=”true”

NEW_TASK intent ﬂag set or M2:launchMode=”singleTask”

M2:taskAfﬁnity=A1

startActivities([M1, M2])
or use TaskStackBuilder

M1: startActivity(M2)

-

Table 3: Detailed information of the HSTs (red edges with HST indexes in Figure 4). E.g., condition “M1:taskAfﬁnity=B2”
indicates that the taskAfﬁnity attribute of activity M1 is set to that of B2; Event “launcher:startActivity(A1)” means that activity
A1 is started by the launcher.

by the Android system, the attacker can actively create a
plethora of HSTs that harm other apps. In Figure 4(a),
we only show several typical HST cases, yet there are
much more HST instances of these types in the complete
state transition graph.

The HST cases and their conditions/events summa-
rized in Table 3 may now look mysterious. We will de-
mystify these conditions and events in the rest of this sec-
tion.

4.5 Exploiting Conditions
In Table 3, HSTs #2, #4, #6 are similar with respect
to their state transition conditions, i.e. all three HSTs
occur by virtue of customized activity launch mode
(by setting launchMode attribute or NEW_TASK in-
tent ﬂag). HSTs #3, #5 are similar as they both use
allowTaskReparenting attribute to enable activity
re-parenting.

4.5.1 Activity Attributes
One can deﬁne the attributes [2] of an activity in the
<activity> element in manifest ﬁle. The attributes

not explicitly deﬁned are set to default values.

Task Afﬁnity: Task afﬁnity declares what
task an
activity prefers to join. It is a hard-coded string deﬁned
as
<android:taskAffinity="affinity">,
where affinity is the task afﬁnity string that can be
deﬁned arbitrarily. By explicitly declaring a task afﬁnity,
an activity is able to actively “choose” a preferable task
to join within its life cycle. If not explicitely speciﬁed
in the manifest, the task afﬁnity of an activity is the app
package name, such that all activities in an app prefer
to reside in the same task by default. The afﬁnity of a
task is determined by the task afﬁnity of the task’s root
activity (the activity on the bottom of back stack).

Task afﬁnity is a crucial condition used in most of
the HSTs in Table 3. There are two occasions in
which an activity can “choose” its preferred host task:
(1) when an activity attempts to be started as a new
task (i.e., “singleTask” launch mode or NEW_TASK
intent ﬂag as in HST#2, #4, #6), and (2) if the
allowTaskReparenting activity attribute is set to
true, and another task with the same task afﬁnity is
brought to the foreground (as in HST#3, #5). We explain

950  24th USENIX Security Symposium 

USENIX Association

6

the above two cases in detail in the following paragraphs.

Launch Mode: Activity launch mode deﬁnes how an
activity should be started by the system. Based on the
launch mode, the system determines: (1) if a new ac-
tivity instance needs to be created, and (2) if yes, what
task should the new instance be associated with. The
launch mode can be either statically declared by spec-
ifying <android:launchMode="value"> in the
manifest ﬁle or dynamically deﬁned using intent ﬂags
discussed in Section 4.5.2.

By default, launchMode="standard".

In this
mode, the AMS would create a new activity instance and
put it on top of the back stack on which it is started. It’s
possible to create multiple instances of the same activ-
ity and those instances may or may not belong to the
same task. With launchMode="singleTask", the
decision-making of activity start-up is more complex.
An investigation into Android source code reveals three
major steps the AMS takes towards starting an activity.
First, if the activity instance already exists, Android re-
sumes the existing instance instead of creating a new one.
It means that there is at most one activity instance in the
system under this mode. Second, if creating a new ac-
tivity instance is necessary, the AMS selects a task to
host the newly created instance by ﬁnding a “matching”
one in all existing tasks. An activity “matches” a task
if they have the same task afﬁnity. After ﬁnding such a
“matching” task, the AMS puts the new instance into the
“matching” task. This explains why in HST #2 and #6,
the newly-started and foreground activities (B2 and M2)
are put on other “matching” tasks (with the same task
afﬁnity) instead of the tasks who start them. Third, with-
out ﬁnding a “matching” task, the AMS creates a new
task and makes the new activity instance the root activity
of the newly created task.

Task Re-parenting: By default, once an activity starts
and gets associated with a task, such association per-
sists for the activity’s entire life cycle. However, setting
allowTaskReparenting to true breaks this restric-
tion, allowing an existing activity (residing on an “alien”
task) to be re-parented to a newly created “native” task,
i.e., a task having the same task afﬁnity as the activity.

For example, in HST#3 resembles the spooﬁng at-
tack example discussed in Section 4.1. M2 is sup-
posed to stay on Mallory’s task at all time. However,
M2 has its allowTaskReparenting set to true, and
taskAffinity set to Alice’s package name, such
that when Alice’s task is started (A1 as the root activ-
ity) by the launcher, M2 is re-parented to Alice’s new
task and the user sees M2 on screen instead of A1.
In this process, A1 is never brought to the screen at
all. Likewise, HST #5 occurs due to similar reason,

except that this time the benign activity B2 (with its
allowTaskReparenting set to true) is re-parented
to the malware task.

The above activity attributes offer attackers with great
ﬂexibility. The attackers can put their malicious activ-
ities to a preferred hosting tasks under certain events,
e.g., singleTask launch mode during an activity start-
up and allowTaskReparenting during a new task
creation. Furthermore, an activity is free to choose any
app as their preferred task owner (including the privi-
leged system apps) by specifying the target app’s pack-
age name as their task afﬁnity. These conditions lead to
a bulk of HSTs in the simulation, and these HSTs can
be employed to launch powerful task hijacking attacks
as we will see in Section 5.

4.5.2

Intent Flags

Before sending an intent to start an activity, one could
set
intent ﬂags to control how the activity should
be started and maintained in the system by calling
intent.setFlags(flags). intent is the intent
object to be sent, and flags is an int value (each bit
indicates a conﬁguration ﬂag to the AMS).

if set,

Noticeably, the FLAG_ACTIVITY_NEW_TASK in-
tent ﬂag,
lets an activity be started as if its
launchMode="singleTask", i.e. the system goes
through the same procedures as explained in launch
mode to ﬁnd a “matching” task or create a new task for
the new activity instance. This is the dynamic way of set-
ting activity’s launch mode. Launcher app always uses
this ﬂag to start an app in a new task as in HST#4.

4.6 Exploiting Events
4.6.1 Callback Function

Android framework provides a variety of callback func-
tions for activities to customize their behaviors under
particular events, e.g., activity life cycle events (start,
pause, resume or stop), key pressing events, system
events, etc.

onBackPressed() is a callback function deﬁned
in Activity class, and is invoked upon user pressing
the “back” button. The default implementation in frame-
work code simply stops and destroys the current activity,
and it then resumes the next activity on top of the current
back stack, as we have seen in Section 3.3. However, an
attacker can override this callback function for its mali-
cious activity and arbitrarily deﬁne a new behavior upon
“back” button pressing, or simply disable the “back” but-
ton by providing an empty function. As a result, once the
malicious activity is brought to the foreground, pressing
the “back” button triggers the code of attacker’s control.

USENIX Association  

24th USENIX Security Symposium  951

7

(a)

(b)

(c)

(d)

(e)

(f)

Figure 5: The process of “back hijacking” phishing attack to a well-known bank app. (a) shows the main activity of the bank
app. A new user taps on the tutorial video link in the bank app; In (b), a system dialog prompts the user to choose a video player
available in the system; In (c), the video player activity is started, and the user later clicks “back” button, intending to “goes back”
to the original main activity; In (d) and (e), the back button directs the user to the phishing UIs, which spoof the user and steal bank
account credentials. The phishing activity then quits after user clicks “Sign On”; In (f), the original main activity is resumed, with
a log-in failure toast message displayed by the quitting malware.

4.6.2 Framework API
Android framework provides APIs to create new
tasks with established back stacks.
For example,
TaskStackBuilder is a utility class that allows an
app developer to construct a back stack with speciﬁed
activities, and to start the back stack as a brand new task
in the system at a later time (e.g. using a PendingIntent).
Similarly, startActivities() in Activity class
achieves the same thing except that it builds and starts the
tasks in one API function call. These framework APIs
are helpful for attackers to build and launch new tasks
containing designated back stacks without explicitly dis-
playing all activities in the back stacks on screen.

5 Task Hijacking Attack Examples

In this section, we demonstrate more attack examples uti-
lizing exploitable HSTs in Table 3. These attacks can
breach the integrity, availability and conﬁdentiality of
victim apps’ UIs respectively. We have tested these at-
tacks on Android 3.x, 4.x and 5.0.x.

5.1 Breaching UI Integrity
The UI integrity here means the “origin/source integrity”
of the victim app’s activities, instead of the “data in-
tegrity”. That is, instead of modifying the original ac-
tivities of the victim app, attackers deceive the user by
spooﬁng UIs, which can prevent the original UIs from
being displayed on screen.

5.1.1 Spooﬁng Attack
As we have already seen in Section 4.1 and
4.5,
by manipulating allowTaskReparenting and
taskAffinity, an attacker can successfully hijack

a new task with a spooﬁng activity. This attack affects
all apps on device including the most privileged system
apps (e.g., Settings).
The attacker can even target
multiple apps on user device at the same time, as long as
the background malware tasks (targeting different task
afﬁnity) are started in advance.
Stealthiness: In order to make the spooﬁng attack more
stealthy, the attacker could take advantage of other task
transition conditions and events to achieve this. For
example,
the attacker can make its background mal-
ware tasks absent from the recent task list by setting
the activity attribute excludeFromRecents to true.
As another example, the user may accidentally resume
the app’s original activity (the root activity of victim
app’s task) by clicking the “back” button from the on-
screen spooﬁng activity. To prevent users from observ-
ing this abnormal app behavior, the attacker can override
onBackPressed() of the spooﬁng activity, bringing
the home screen back to the foreground, such that it gives
the user an illusion that it is in coherence with the sys-
tem’s default ”back” behavior.

5.1.2 Phishing Attack - “Back Hijacking”
The back button is popular with users because it allows
users to navigate back through the history of activities.
However, attackers may abuse the back button to mislead
the user into a phishing activity.

We devise three phishing attack methods that target the
same banking app, and demonstrate two of them in this
paper. Figure 5 shows the screen shots of the phishing
attack process. The phishing UIs show up when the user
returns from a third-party app activity, and the user un-
wittingly believes that he/she has returned to the original
bank activity.

Figure 6 shows the state transition diagrams of two
attack methods. The two attack methods differ in that,

952  24th USENIX Security Symposium 

USENIX Association

8

S1 

mal-player 

Foreground 

B 
A 

Bank App 

S2 

Foreground 

mal-player 

B 
A 

Bank App 
(a) 

Player 

S1 

Foreground 

B 
A 

mal-B 
mal-A 

S3 

Foreground 

mal-B 
mal-A 

B 
A 

Bank App 

Malware 

S2 

Foreground 

Player 
mal-B 
mal-A 

B 
A 

Bank App 

Malware 

Bank App 

Malware 

Figure 6: Tasks state transition diagrams of “back hijacking”
attacks. Figure (a) and (b) shows method I and II respectively.

(b) 

user chooses a malicious video player in the ﬁrst attack,
while in the second attack, even though the user chooses
a benign player, the bank task can still be hijacked when
the user launches the video player.
Method I: Figure 6(a) shows the state transition diagram
of the ﬁrst attack method. We skip the unrelated task(s)
(e.g. launcher) in the system and only show tasks of in-
terest. In s1, the bank app task contains activities A and
B, in which B is the login activity. The HST occurs in
s1 → s2, triggered by the event that the user clicks the
tutorial video from the login UI, sending out a implicit
intent to look for an exported activity in the system capa-
ble of playing the tutorial video. Unfortunately, the user
selects the malicious video player activity “mal-player”
from the system pop-up and this results in the hijacked
state s2. After user ﬁnishes watching the video, s2 → s3
is triggered by user pressing the “back” button. How-
ever, the “back”-pressing event is modiﬁed by overrid-
ing onBackPressed() in the “mal-player” activity.
As a result, instead of resuming activity B, a new mali-
cious task is created (by using TaskStackBuilder)
and brought to the front. As can be seen, the HST takes
place under default conditions as in HST#1 (in Table 3).
The user session is hence hijacked to the malware
task, which contains “mal-A” and the foreground “mal-
B” phishing activities. Note that in this attack, the mal-
ware need to camouﬂage as a useful app (e.g. a video
player in this case) that users are likely to use.
Method II: As shown in Figure 6(b), the same phishing
attack can succeed even when the user selects a benign
video player. In s1, a malware task with two phishing ac-
tivities lurks in the background. Similarly, HST occurs in
s1 → s2, when the user launches a benign video player.
However, as shown in the resulting state s2, instead of
joining the banking task, the new video player activity is
pushed in the malware task’s back stack, such that press-
ing the “back” button after the video play resumes the
phishing activity “mal-B”.

This HST is similar to HST#2 (in Table 3) in that the
benign video player attempts to be started as a new task,
either because of the NEW_TASK ﬂag set in the intent by
the bank activity, or the “singleTask” launch mode set by
the video player. Furthermore, the existing malware task
has its taskAffinity maliciously set to the benign
video player.
Stealthiness: We employ similar methods in the previ-
ous spooﬁng attack to ensure the stealthiness of the back-
ground malware tasks in both phishing attack methods.
Moreover, we disable the animation of task switching,
producing an illusion to the user that the screen transi-
tion is within the same task/app.

5.2 Breaching UI Availability
Task hijacking can also be leveraged to restrict the avail-
ability of an app’s UI components, or in other words, to
prohibit user access to part or all functionality of an vic-
tim app.

5.2.1 Preventing Apps from Being Uninstalled

In this example, the attacker is able to completely prevent
apps from being uninstalled.
Ways to Uninstall An App: There are generally three
ways for a user to uninstall an app from the device: (1)
uninstall from the system Settings app; (2) dragging the
app icon to the “trash bin” on home screen; or (3) unin-
stall with the help of a third-party app, e.g. an anti-virus
app. In these scenarios, the Settings, Launcher, and the
third-party apps will respectively generate an request to
uninstall the app. Such a request eventually reaches the
system package installer, which has the exclusive privi-
lege to install/uninstall apps. Upon receiving the request,
package installer pops up a dialog for the user to con-
ﬁrm. The dialog itself is an activity (namely uninstaller
activity) from the system package installer and is pushed
in the back stack of whoever is making the request (e.g.
s4 in Figure 7). No app can be uninstalled without user
conﬁrmation on the uninstaller activity.
Attack Method: The attacker can prevent app un-
installation by restricting user access to the uninstaller
activity when it shows up on screen. In this attack, once
the uninstaller is found to be in the foreground, a mali-
cious activity is immediately pushed on top of the unin-
staller activity in the same back stack, such that the unin-
staller is “blocked” and becomes inaccessible to the user.
Figure 7 shows the state transition diagram of this at-
tack targeting Settings app. Similar methods can be eas-
ily adopted to block app un-installation from the launcher
or the anti-virus apps (e.g. when malware is detected).

In s1, a task with only one root activity (“mal-
root”) from the malware is waiting in the background,

USENIX Association  

24th USENIX Security Symposium  953

9

S1 

S2 

S3 

Foreground 

setting 
mal-root 

uninstaller 

Foreground 

setting-sub 

setting 
mal-root 

Malware Task 

Malware Task 

Background 

mal-root 

Malware Task 

computer, and uninstall the malware from adb. However,
in order to use adb, the user needs to ﬁrst enable USB de-
bugging in the Settings. The malware can block it in the
Settings using similar technique and prevent the use of
adb, as long as the USB debugging is not enabled before
the attack (which is the case for most normal users).

S5 

Foreground 
mal-blocker 
uninstaller 
setting-sub 

setting 
mal-root 

S4 

Foreground 

uninstaller 
setting-sub 

setting 
mal-root 

Malware Task 

Malware Task 

Figure 7: Tasks state transition diagram of application unin-
stall prevention attack.

with its taskAffinity set
to the Settings app
(com.android.settings). The HST occurs in s1 → s2, trig-
gered when the user opens up the Settings from the home
screen (we skip Launcher task in the ﬁgure). In s2, in-
stead of hosting the newly-created “setting” activity in a
new task, “setting” activity is pushed on top of the mal-
ware’s back stack because the it is started by the launcher
with a NEW_TASK ﬂag. As a result, upon start-up, the
privileged Settings app is unwittingly “sitting” on a task
owned by the malware. This is similar to HST#4 in Ta-
ble 3.

The user then goes through a few more sub-setting
menus to ﬁnd the app (as shown in s3) and clicks
the uninstall button, after which the uninstaller activity
shows up for user conﬁrmation (as shown in s4). Once
this happens, a malicious activity namely “mal-blocker”
is immediately (even without user awareness of the unin-
staller dialog) launched by a malicious background ser-
vice, which keeps monitoring the foreground activity.
The “mal-blocker” activity, started by a NEW_TASK
ﬂagged intent and with the same task afﬁnity as the Set-
tings app, is thus pushed in the same task, and effectively
blocks the uninstaller as shown in s5. The “mal-blocker”
activity has its “back” button disabled, such that the user
has no way to access the uninstaller activity right below
it in the back stack whatsoever, and thus cannot conﬁrm
the app uninstalling operation.

In fact,

that

triggers s5 → s6:

the “back” button of “mal-blocker” is
not only disabled, but
is also augmented with a
invoking (call
new event
startActivity()) the “mal-root” activity with an
intent having CLEAR_TOP ﬂag set, which results in the
killing of the uninstaller and Settings activities in the
task.
Preventing Un-installation from adb: An advanced
user may resort to Android Debug Bridge (adb), a client-
server program used to connect Android devices from a

5.2.2 Ransomware

Ransomware blackmails people for money in exchange
of their data, and it has recently hit Android in a large
scale [5]. The attackers may use UI hijacking to imple-
ment ransomware.

The malicious background service mentioned above
takes the following two responsibilities and is difﬁcult
to be completely stopped. (1) Assure the malicious root
activity (“mal-root”) is alive:
it re-creates a new root
activity once the activity is found to be destroyed; and
(2) monitor the foreground activity: if the target activity
shows up, it immediately starts “mal-blocker” to block
user access to the target activity, as we have seen in
s4 → s5. To prevent itself from being killed, the ser-
vice registers itself in the system alarm service, who ﬁres
a pending intent in every given ﬁxed time interval, re-
launching the service if it is found to be killed.

By this mean, the ransomware is able to restrict user
access to any target apps of attacker’s choice, and can po-
tentially render the Android device completely useless.

5.3 Breaching UI Conﬁdentiality
The attack method in Section 5.2 can also be deployed
to devise a new spyware, namely “TaskSpy” capable of
monitoring the activities within any tasks in the newest
Android 5.0.x systems (API 21), without requiring any
permissions.

In Android, the system regards the owner of the root
activity in a back stack to be the owner of the correspond-
ing task. Android 5.0 allows an app to get the informa-
tion of the caller app’s own tasks (including the activities
in the tasks) without requiring any permission. It means
that, if a spyware can “own” the tasks of all the apps
it intends to spy on, it is able to get the information of
these tasks that in fact contain the victim apps’ activi-
ties. Task hijacking is especially useful to “TaskSpy” in
this case. In other words, “TaskSpy” can use the HST
presented in Section 5.2 to “own” the tasks of any victim
apps and thus stealthily spy on their activities without us-
ing any permission. Chen et. al. have achieved the same
goal in their work [8] by monitoring and interpreting the
shared VM information via public side channels. Com-
pared with their attack, task hijacking can do this in a
more direct and reliable way on Android 5.0.x.

954  24th USENIX Security Symposium 

USENIX Association

10

Vul.
app

Atk
#

Vul. conditions

Send implicit intent for

exported activities

Send implicit intent for

exported activities and use
intent ﬂag NEW_TASK
Contains public exported

V

S

I

II

II

III

activity and

lauchMode=“singleTask”
Contains public exported

activity and

allowTaskReparenting=“true”

Tol. %
of vul.

93.9

14.4

% of
vul.

93.9

65.5

14.2

1.4

Number of Vul. Victim Apps

Number of Vul. Service Apps

Comm
Social
Finance
Shopping
Bussiness
Medical

Media
Tools
Comm
Product
Photo
Social

0

100

(a)

200

300

0

100

200

300

(b)

Figure 8: (a) Breakdown of vulnerable victim apps in security-
sensitive app categories.
(b) Breakdown of vulnerable “ser-
vice” apps in the most widely useful app categories.

Table 4: Percentage of vulnerable victim apps (V) and “ser-
vice” apps (S) to the “back hijacking” phishing attacks respec-
tively, among 10,985 most popular Google Play apps.

6 Evaluation

We ﬁrst seek to understand the extent of vulnerable sys-
tems and apps to the attacks we have presented in Sec-
tion 5. By doing large-scale app analysis across various
markets, we then provide the current use status of the task
control knobs in real implementations. Base on our in-
sights from the result, we provide mitigation suggestions
to defend against task hijacking threats in Section 7.

6.1 Vulnerability Analysis
Vulnerable Android Versions: We say an Android ver-
sion is vulnerable to a particular attack if a malware can
successfully launch the attack to a victim app on the sys-
tem. Since the unique multitasking is part of Android de-
sign and most features have been introduced early in An-
droid’s evolution, we ﬁnd that recent Android versions,
including 3.x, 4.x and 5.0.x, are vulnerable to all our
presented attacks, except the “TaskSpy” attack. As dis-
cussed in Section 5.3, “TaskSpy” relies on speciﬁc APIs
introduced from API 21, and therefore, only affects the
newest Android 5.0.x systems.

Apps Vulnerable to Task Hijacking Attacks: As sum-
merized in Table 1, all the apps installed on a vulnerable
Android system (including the privileged system apps)
are vulnerable to all the attacks presented in this paper,
except the “Back Hijacking” phishing attacks, which re-
quire certain prerequisites for an app to be vulnerable.
Despite the prerequisites, the “Back Hijacking” phishing
attacks are extremely stealthy, can be easily crafted and
can cause serious consequnces. We try to further under-
stand the scale of apps vulnerable to the “Back Hijack-
ing” phishing attack by analyzing the most popular apps
in Google Play.

Apps Vulnerable to “Back Hijacking”: In a phishing
attack, the attacker would be likely to target the most

popular and valuable apps. Therefore, we focus our vul-
nerability analysis on the most popular 10,985 apps from
Google Play, i.e., apps with over 1 million installs.

We indicate a vulnerable app in the phishing attacks
to be of either one or both of the following two types:
(1) victim app - the target victim app of the phishing
attack (e.g.
the bank app); and (2) “service” app - the
benign app that provides publicly exported activities and
is exploitable by the attacker to conduct user phishing
on the victim apps (e.g.
the benign video player). We
do static analysis on the apps. Speciﬁcally, we perform
inter-procedural analysis to identify all implicit intents
(without permissions guarded) and the associated ﬂags,
and conduct manifest scan to ﬁnd all activity attributes
and public exported activities (excluding the main activ-
ities which are always exported). Table 4 lists the vul-
nerability conditions, and shows the percentages of both
vulnerable victim apps and “service”apps to each and all
the attack methods respectively.

As can be seen, 93.9% of the most popular apps in
Google Play are vulnerable. This is partially because
most apps would send out implicit intents (without per-
missions guided), which could potentially invoke a mal-
ware activity as in attack I. By taking a closer look at the
results, among these apps, a majority (65% of apps) are
vulnerable to attack II, i.e., they are vulnerable to phish-
ing attack even if users launch trusted benign “service”
apps from these apps. Moreover, 14.36% “service” apps
can be exploited to “help” attack the apps who invoke
these “service” apps, even if the apps being attacked may
not be vulnerable by themselves.

The consequence and severity of a phishing attack de-
pend on the content and sensitivity of the stolen informa-
tion. To have a rough idea of the potential consequences
caused by the “Back Hijacking” phishing attacks, we se-
lectively show in Figure 8(a) the population of vulner-
able victim apps in a few security-sensitive app cate-
gories. Noticeably, We observe that a signiﬁcant num-
ber of security-sensitive apps are vulnerable, including
the ﬁnancial apps like banking and credit card payment
(e.g., Citibank, Chase, Google Wallet), the most popu-
lar communication and social media apps (e.g. Google
Hangouts, facebook), and shopping apps from the ma-

USENIX Association  

24th USENIX Security Symposium  955

11

Activity Attribute

allowTaskReparenting=“true”

launchMode=“singleTask”

launchMode= other non-default modes

taskAfﬁnity= own pck. name

taskAfﬁnity= other

excludeFromRecents=“true”
alwaysRetainTaskState=“true”

% of
Apps
0.80
24.63
24.75
2.36
1.60
12.45
2.03

Intent Flag
NEW_TASK
CLEAR_TOP

EXCLUDE_FROM_RECENTS

Events

onBackPressed()
TaskStackBuilder
startActivities()

% of
Apps
79.42
37.59
10.08

62.00
7.27
5.47

Task Afﬁnity

com.android.settings
com.android.camera
com.android.update

com.tencent.mm

com.gau.go.launcherex

com.fractalist

com.android.activity
com.xiaomi.payment

# of
Apps
492
325
279
273
237
194
158
147

Table 5: Percentage of 6.8 million market apps that use each of the “security-
sensitive ” task control knobs.

Table 6: Top package names speciﬁed as
the task afﬁnity by other apps

jor electronic commerce companies (e.g. Ebay, Amazon
Shopping), etc. Similarly, in Figure 8(b), we show the
statistics of a few app categories in which the vulnerable
“service” apps and their functionality are most widely
used, including the most famous photo editing tools, doc-
ument editors, and ﬁle sharing services, etc.

6.2 Market-scale Study on the Use of Task

Control Knobs

Due to the task hijacking threats, we have a pressing
need for a defense strategy that can mitigate these threats
while minimizing the side effects on Android multitask-
ing features. To this end, it is important to ﬁrst under-
stand the current status about the use of Android mul-
titasking features in real implementation, especially the
use of “security-sensitive” task control knobs.

We analyzed 6.8 million Android apps from a vari-
ety of markets including Google Play and other 12 popu-
lar third-party app markets worldwide (e.g., from China).
The analysis does not include duplicated apps (apps with
same package name, public key certiﬁcate and app ver-
sion number) distributed across multiple markets.

Table 5 shows the percentage of apps that use each of
the task control knobs respectively. As shown in the ta-
ble, a majority of the task control features are popular
with app developers and users. For example, “single-
Task” launch mode and NEW_TASK intent ﬂag are used
in a signiﬁcant portion of apps to control the association
of new activities with tasks. The ﬂexibility of “back”
button customization is widely adopted (as high as 62%
apps). One reason is that the onBackPressed() call-
back function is heavily used by ad libs (which embed
ads in app activities) for data clean-up before the activi-
ties are destroyed. In addition, a signiﬁcant portion of ac-
tivities can hide their associated tasks from the overview
screen (by deﬁning “excludeFromRecents” attribute or
setting EXCLUDE_FROM_RECENTS intent ﬂag).

Case Study - Task Afﬁnity: Since task afﬁnity can be
abused in the most dreadful attacks, we are particularly
interested in its use. 3.96% apps we studied explicitly

declare task afﬁnity. A considerable portion (1.6% of all
apps) set their activities’ taskAfﬁnity string without con-
taining their own package names. It means that, if there
are task afﬁnity conﬂicts, these 1.6% apps (totally 109
thousand apps) may interfere with the multitasking be-
haviors of one another. They may even affect other apps
if the task afﬁnity attributes are intentionally set to the
package name of other apps (recall that the taskAfﬁn-
ity string can be set arbitrarily). We are especially inter-
ested in the latter case, and in our analysis, we ﬁnd a total
of 3293 apps of this kind. Table 6 lists the top package
names designated as task afﬁnity by these apps.

By reverse engineering a number of these apps, we
ﬁnd that intentionally setting the task afﬁnity as another
app is particularly useful in a class of “plug-in” apps,
i.e. apps that provide complementary features to exist-
ing (and usually popular) apps just like a web browser’s
plug-ins (except that here the “plug-in” itself is imple-
mented in a separate app). By being in the same task
with the popular app, the “plug-in” app can change nor-
mal user experience and fulﬁll its feature functionality
in the context of the app it serves. For example, an
phone call recorder app namely FonTel can display an
array of buttons on screen whenever there is a phone
call, letting users to control phone call recording. The
control buttons are contained in an mostly transparent
activity. By setting the task afﬁnity of the activity to
com.android.phone, it can be pushed on top of the
Android telephony task when a phone call occurs, such
that users can access both the recording control buttons
and telephony activity at the same time.

In summary, despite the security risks, Android mul-
titasking features are popular with developers and even
become indispensable to the normal functions of a sig-
niﬁcant number of apps that provide favorable features.

7 Defense Discussion

Given the pervasive use of the “security-sensative” task
control features, simply disabling these features would
greatly hurt app functions and user experience. Mitigat-
ing the task hijacking threats become a trade-off between

956  24th USENIX Security Symposium 

USENIX Association

12

app security and multitasking features.

7.1 Detection in Application Review
Existing app vetting processes such as Bouncer [31] may
conduct a inspection over the “sensitive” task control
knobs, a light-weight defense strategy without signiﬁ-
cantly affecting existing multitasking features.

However, specifying a guideline balancing the secu-
rity/feature trade-off is non-trivial. For example, a ten-
tative guideline could be: taskAffinity attribute
should be speciﬁed in a strict format, e.g., with app pack-
age name followed by developer-deﬁned afﬁnity name
(now task afﬁnity can be any string); and the task afﬁnity
should not contain any other app’s package name, except
that the two apps are from the same developer. This ef-
fectively eliminates a big portion of hijacking state tran-
sitions where a malicious activity speciﬁes the victim app
as its preferred afﬁnity. However, this rule also restricts
useful features and contradicts with an important princi-
ple of Android multitasking design - give an activity the
freedom to live in its preferred task even though they are
from different apps. This contradiction cannot be solved
by app review alone in this case. We need system sup-
port together with app review to achieve a good balance
of security/feature trade-off.

Moreover, detecting problematic events can be some-
times difﬁcult for the app review. For instance, one
could conﬁne the behaviors in onBackPressed(),
preventing it from generating potential hijacking tran-
sition event. However, discovering all possible pro-
gram behaviors using static analysis is an undecid-
able problem. A skillful attacker can replace class
methods (onBackPressed() method in Activity
class) with another method by changing Dalvik inter-
nals using native code during runtime, and static anal-
ysis does not know this by simply looking at the original
onBackPressed() method. Dynamic analysis is of
little help as well since this behavior can be triggered
only after passing the app review.

As a result, completely mitigating task hijacking risks
and without affecting existing features in app review re-
mains challenging.

7.2 Secure Task Management
An alternative approach involves security enhancement
to the task management mechanism of Android system.
A more secure task management could introduce ad-
ditional security guides or logic, which draws develop-
ers’ awareness of the security risk and limits the attacker
surface. Take the above task afﬁnity for example, an
additional boolean attribute can be introduced for each
app to decide if it allows the activities from other apps

to have the same afﬁnity as the app. If the boolean is
“false” (also by default), the system would not uncondi-
tionally relocate the “alien” activities to the app’s task or
vice versa, even though the “alien” activities declare to
have the same task afﬁnity as the app. Likewise, a ﬁner-
grained boolean attribute can be further employed for
allowParentReparenting attribute - determining
if to allow “alien” activities to be re-parented to the app’s
task (even though deﬁning the same task afﬁnity is per-
mitted). For other “security-sensative” features, we sug-
gest ﬁrst consider the same approach. Considering the
serious security hazards that can be prevented, it is well
worth of making such changes. At the very least, en-
hanced security scheme like this has to be applied to as-
sure the security of the most privileged system apps.

Completely defeating task hijacking is not easy. As
we have discussed in the last section, it is difﬁcult to
identify the exact behavior of pressing “back” in an ac-
tivity during app review phase. For these popular and
security-sensitive features, more powerful runtime mon-
itoring mechanism is required to fully mitigate task hi-
jacking threats.

In summary, we advocate future support for security
guidance and/or mechanism, which can protect Android
apps from task hijacking threats and bring along a both
secure and feature-rich multitasking environment for An-
droid users and developers.

8 Related Work

GUI security : GUI security has been extensively stud-
ied in traditional desktop and browser environments [14,
29], e,g., UI spooﬁng [9], clickjacking [3, 17], etc. An-
droid, on the other hand, is unique in the design of its
GUI sub-systems. It has been shown that the GUI conﬁ-
dentiality in Android can be breached by stealthily taking
screen shots due to adb ﬂaws [22], via embedded mali-
cious UIs [28, 24], or through side channels, e.g. shared-
memory side channel [8] or reading device sensors infor-
mation [25, 34]. In contrast to existing work, this paper
focuses on the fundamental design ﬂaws of the task man-
agement mechanism (supported by the AMS), the control
center that organizes and manages all existing UI compo-
nents in the Android system.

Android Vulnerability: The security threats in the inter-
component communication (ICC) has been widely stud-
ied [13, 23, 10, 20, 32]. Moreover, there has been con-
siderable prior work on emerging Android vulnerabili-
ties and their mitigation measures in many aspects [38,
40, 18, 33, 27, 7, 30, 15, 21]. However, the critical An-
droid multitasking mechanism and the feature provider,
the AMS, have not been deeply studied before. This pa-
per ﬁlls in this gap by systematically studying the An-

USENIX Association  

24th USENIX Security Symposium  957

13

droid multitasking and the security implications of this
design.

Android Malware: Many prior efforts focus on
large-scale detection of malicious or high-risk Android
apps [39], e.g., ﬁngerprinting or heuristic-based meth-
ods [26, 41, 16], malware classiﬁcation based on ma-
chine learning techniques [37, 6], and in-depth data ﬂow
analysis for app behaviors [11, 35, 36, 6]. The attack sur-
face discovered in this paper can be easily employed by
attackers to create a wide spectrum of new malwares, as
discussed in Section 5. We report our threat assessment
based on over 6 million market apps and provide defense
suggestions in order to prevent the outburst of task hi-
jacking threats in advance.

9 Conclusion

This paper systematically investigated the security im-
plications of Android task design and task management
mechanism. We discover a plethora of task hijacking op-
portunities for attackers to launch different attacks that
may cause serious security consequences. We ﬁnd that
these security hazards can affect all recent versions of
Android. Most of our proof-of-concept attacks are able
to attack all installed apps including the most privileged
system apps. We analyzed over 6.8 million apps and
found task hijacking risk prevalent. We notiﬁed the An-
droid team about these issues and we discussed possible
mitigation techniques.

10 Acknowledgment

We would like to thank anonymous reviewers whose comments
help us improve the quality of this paper. We thank Dr. Sen-
cun Zhu and Dr. Dinghao Wu from Pennsylvania State Uni-
versity for providing valuable feedback. Chuangang Ren was
supported in part by ARO W911NF-09-1-0525 (MURI). Peng
Liu was supported by ARO W911NF-09-1-0525 (MURI) and
ARO W911NF-13-1-0421 (MURI).

References

[1] Task and Back Stack.

http://developer.android.

com/guide/components/tasks-and-back-stack.
html.

[2] App Manifest.

http://developer.android.com/

guide/topics/manifest/activity-element.
html.

[3] AKHAWE, D., HE, W., LI, Z., MOAZZEZI, R., AND SONG, D.
Clickjacking Revisited: A Perceptual View of UI Security.
In
Proceedings of the USENIX Workshop on Offensive Technologies
(WOOT) (2014).

[4] Android Activity.

http://developer.android.com/

reference/android/app/Activity.html.

[5] Simplocker: First Conﬁrmed File-Encrypting Ransomware for
Android, 2014. http://www.symantec.com/connect/
blogs/simplocker-first-confirmed.

[6] ARP, D., SPREITZENBARTH, M., HUBNER, M., GASCON, H.,
AND RIECK, K. Drebin: Effective and Explainable Detection of
Android Malware in Your Pocket. In Proceedings of Network and
Distributed System Security Symposium (NDSS) (2014).

[7] CHEN, E., PEI, Y., CHEN, S., TIAN, Y., KOTCHER, R., AND
TAGUE, P. OAuth Demystiﬁed for Mobile Application Develop-
ers. In Proceedings of ACM Conference on Computer and Com-
munications Security (CCS) (2014).

[8] CHEN, Q. A., QIAN, Z., AND MAO, Z. M. Peeking into Your
App without Actually Seeing It: UI State Inference and Novel
Android Attacks. In Proceedings of the USENIX Security Sym-
posium (2014).

[9] CHEN, S., MESEGUER, J., SASSE, R., WANG, H., AND WANG,
Y. A Systematic Approach to Uncover Security FLaws in GUI
Logic. In Proceedings of IEEE Symposium on Security and Pri-
vacy (S&P) (2007).

[10] CHIN, E., FELT, A. P., GREENWOOD, K., AND WAGNER, D.
Analyzing Inter-Application Communication in Android. In Pro-
ceedings of the International Conference on Mobile Systems, Ap-
plications, and Services (MobiSys) (2011).

[11] ENCK, W., GILBERT, P., CHUN, B., COX, L. P., JUNG, J., MC-
DANIEL, P., AND SHETH, A. TaintDroid: An Information-Flow
Tracking System for Realtime Privacy Monitoring on Smart-
phones.
In Proceedings of USENIX Symposium on Operating
Systems Design and Implementation (OSDI) (2010).

[12] FELT, A. P., CHIN, E., HANNA, S., SONG, D., AND WAGNER,
D. Android Permissions Demystiﬁed. In Proceedings of ACM
Conference on Computer and Communications Security (CCS)
(2011).

[13] FELT, A. P., WANG, H. J., MOSHCHUK, A., HANNA, S., AND
CHIN, E. Permission Re-delegation: Attacks and Defenses. In
Proceedings of the USENIX Security Symposium (2011).

[14] FESKE, N., AND HELMUTH, C. A Nitpickers Guide to a
In Proceedings of Annual

Minimal-complexity Secure GUI.
Computer Security Applications Conference (ACSAC) (2005).

[15] GRACE, M., ZHOU, Y., WANG, Z., AND JIANG, X. Systematic
Detection of Capability Leaks in Stock Android Smartphones. In
Proceedings of Network and Distributed System Security Sympo-
sium (NDSS) (2012).

[16] GRACE, M., ZHOU, Y., ZHANG, Q., ZOU, S., AND JIANG, X.
RiskRanker: Scalable and Accurate Zero-day Android Malware
Detection.
In Proceedings of the International Conference on
Mobile Systems, Applications, and Services (MobiSys) (2012).

[17] HUANG, L., MOSHCHUK, A., WANG, H. J., SCHECHTER, S.,
AND JACKSON, C. Clickjacking: Attacks and Defenses. In Pro-
ceedings of the USENIX Security Symposium (2012).

[18] JIN, X., HU, X., YING, K., DU, W., AND YIN, H. Code Injec-
tion Attacks on HTML5-based Mobile Apps: Characterization,
Detection and Mitigation. In Proceedings of ACM Conference on
Computer and Communications Security (CCS) (2014).

[19] K. W. Y. AU AND Y. ZHOU AND Z. HUANG AND D. LIE.
PScout: Analyzing the Android Permission Speciﬁcation. In Pro-
ceedings of ACM Conference on Computer and Communications
Security (CCS) (2012).

[20] KANTOLA, D., CHIN, E., HE, W., AND WAGNER, D. Reducing
attack surfaces for intra-application communication in android.
In Proceedings of the ACM workshop on Security and privacy in
smartphones and mobile devices (SPSM) (2012).

958  24th USENIX Security Symposium 

USENIX Association

14

[21] LI, T., ZHOU, X., XING, L., LEE, Y., NAVEED, M., WANG,
X., AND HAN, X. Mayhem in the Push Clouds: Understand-
ing and Mitigating Security Hazards in Mobile Push-Messaging
Services. In Proceedings of ACM Conference on Computer and
Communications Security (CCS) (2014).

[22] LIN, C., LI, H., ZHOU, X., AND WANG, X. Screenmilker:
How to Milk Your Android Screen for Secrets. In Proceedings
of Network and Distributed System Security Symposium (NDSS)
(2014).

[23] LU, L., LI, Z., WU, Z., LEE, W., AND JIANG, G. CHEX:
Statically Vetting Android Apps for Component Hijacking Vul-
nerabilities.
In Proceedings of ACM Conference on Computer
and Communications Security (CCS) (2012).

[24] LUO, T., HAO, H., DU, W., WANG, Y., AND YIN, H. Attacks
on WebView in the Android System. In Proceedings of Annual
Computer Security Applications Conference (2011).

[25] MILUZZO, E., VARSHAVSKY, A., AND BALAKRISHNAN, S.
TapPrints: Your Finger Taps Have Fingerprints. In Proceedings
of the International Conference on Mobile Systems, Applications,
and Services (MobiSys) (2012).

[26] PENG, H., GATES, C., SARMA, B., LI, N., QI, Y.,
POTHARAJU, R., NITA-ROTARU, C., AND MILLOY, I. Using
Probabilistic Generative Models for Ranking Risks of Android
Apps.
In Proceedings of ACM Conference on Computer and
Communications Security (CCS) (2012).

[27] POEPLAU, S., FRATANTONIO, Y., BIANCHI, A., KRUEGEL, C.,
AND VIGNA, G. Execute This! Analyzing Unsafe and Malicious
Dynamic Code Loading in Android Applications. In Proceedings
of Network and Distributed System Security Symposium (NDSS)
(2014).

[28] ROESNER, F., AND KOHNO, T. Securing Embedded User In-
terfaces: Android and Beyond. In Proceedings of the USENIX
Security Symposium (2013).

[29] SHAPIRO, J., VANDERBURGH, J., NORTHUP, E., AND CHIZ-
In

MADIA, D. Design of the EROS Trusted Window System.
Proceedings of the USENIX Security Symposium (2004).

[30] SOUNTHIRARAJ, D., SAHS, J., GREENWOOD, G., LIN, Z.,
AND KHAN, L. SMV-HUNTER: Large Scale, Automated Detec-
tion of SSL/TLS Man-in-the-Middle Vulnerabilities in Android
Apps. In Proceedings of Network and Distributed System Secu-
rity Symposium (NDSS) (2014).

[31] Android and Security, 2012.

http://googlemobile.

blogspot.com/2012/02/android-and-security.
html.

[32] WEI, F., ROY, S., OU, X., AND ROBBY. Amandroid: A Precise
and General Inter-component Data Flow Analysis Framework
for Security Vetting of Android Apps. In Proceedings of ACM
Conference on Computer and Communications Security (CCS)
(2014).

[33] WU, L., GRACE, M., ZHOU, Y., WU, C., AND JIANG, X. The
Impact of Vendor Customizations on Android Security. In Pro-
ceedings of ACM Conference on Computer and Communications
Security (CCS) (2013).

[34] XU, Z., BAI, K., AND ZHU, S. TapLogger: Inferring User Inputs
on Smartphone Touchscreens Using On-board Motion Sensors.
In Proceedings of the ACM Conference on Security and Privacy
in Wireless and Mobile Netowrks (WiSec) (2012).

[35] YANG, W., XIAO, X., ANDOW, B., LI, S., XIE, T., AND ENCK,
W. AppContext: Differentiating Malicious and Benign Mobile
App Behavior under Contexts. In Proceedings of International
Conference on Software Engineering (ICSE) (2015).

[36] YANG, Z., YANG, M., ZHANG, Y., GU, G., NING, P., AND
WANG, X. S. AppIntent: Analyzing Sensitive Data Transmission
in Android for Privacy Leakage Detection. In Proc. CCS13.

[37] ZHANG, M., DUAN, Y., YIN, H., AND ZHAO, Z. Semantics-
Aware Android Malware Classiﬁcation Using Weighted Contex-
tual API Dependency Graphs. In Proc. CCS14.

[38] ZHOU, X., DEMETRIOU, S., HE, D., NAVEED, M., PAN, X.,
WANG, X., GUNTER, C., AND NAHRSTEDT, K. Identity, Lo-
cation, Disease and More: Inferring Your Secrets from Android
Public Resources. In Proceedings of ACM Conference on Com-
puter and Communications Security (CCS) (2013).

[39] ZHOU, Y., AND JIANG, X. Dissecting Android Malware: Char-
acterization and Evolution. In Proceedings of IEEE Symposium
on Security and Privacy (S&P) (2012).

[40] ZHOU, Y., AND JIANG, X. Detecting Passive Content Leaks and
In Proceedings of Network

Pollution in Android Applications.
and Distributed System Security Symposium (NDSS) (2013).

[41] ZHOU, Y., WANG, Z., ZHOU, W., AND JIANG, X. Hey, You,
Get Off of My Market: Detecting Malicious Apps in Ofﬁcial and
Alternative Android Markets.
In Proceedings of Network and
Distributed System Security Symposium (NDSS) (2012).

USENIX Association  

24th USENIX Security Symposium  959

15

