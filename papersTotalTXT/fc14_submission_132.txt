Attack on U-Prove Revocation Scheme from FC’13 -

Exploiting the Weakness of the Underlying Accumulator

Scheme (Short Paper) (cid:63)

Lucjan Hanzlik, Kamil Kluczniak, and Mirosław Kutyłowski

Faculty of Fundamental Problems of Technology, Wrocław University of Technology

{firstname.secondname}@pwr.wroc.pl

Abstract. We analyse security of the scheme proposed in the paper “Accumu-
lators and U-Prove Revocation", published in the Financial Cryptography 2013
proceedings. Its authors propose an extension for the U-Prove, the credential sys-
tem developed by Microsoft. This extension allows to revoke tokens (containers
for credentials) using a new cryptographic accumulator scheme. We show that,
under certain conditions, there exists a weakness that allows a user to pass the
veriﬁcation while using a revoked U-Prove token. It follows that the proposed
solution fails to fulﬁl the primary goal of revocation schemes.
Recently, a closely related system has been published by Microsoft Research in
“U-Prove Designated-Veriﬁer Accumulator Revocation Extension, Draf 1 Revi-
sion". Our attack does not work for this scheme, but the draft lacks formal justi-
ﬁcation and immunity against our attack might be just a coincidence.

Key words: anonymous credential, U-Prove, revocation, attack

1

Introduction

Anonymous credentials. In this paper we discuss U-Prove [1] - one of the most promi-
nent implementations of anonymous credentials. Today, anonymous credentials is one
of the hottest research topics, as they aim to realize the idea of systems where the
privacy is protected “by design”. Recent developments are driven in particular by in-
creasing (legal) pressure from European Union to deploy such systems.

Anonymous credential is a cryptographic system in which a person receives an au-
thentication token from the trust provider. The token conﬁrms some attributes of the
owner, e.g. her or his rights to login to some systems. A holder of such a token, say
Alice, can use it for authentication. For any subset of attributes A of the attributes con-
tained in the token she can execute an authentication protocol with Bob so that:

– she proves that she holds an authentication token with all attributes from A,

however, at the same time

(cid:63) This research was conducted in cooperation with the National Centre of Cryptology, Warsaw.
Part of the work was done within project 2012-9/4 of the Ventures programme of Foundation
for Polish Science, coﬁnanced from European Union, Regional Development Fund.

2

Lucjan Hanzlik, Kamil Kluczniak, and Mirosław Kutyłowski

– Bob cannot conclude anything about the attributes not contained in A.

Note that “the attributes not contained in A” may include among others identity data

such as the ﬁrst name, the family name, and the personal ID number.

Based on the presented token (and the value of attributes) the receiver (also called
a veriﬁer) can make appropriate decisions. A good example of an attribute is the legal
age enabling to engage in civil contracts. Note that this attribute should not be the exact
physical age but a logical value true or false indicating whether a given person reached
the age necessary to enter civil contracts.

There are many models of anonymous credentials and subtle differences between
them. The functionality discussed in this paper is possibility to revoke an authentication
token by the token issuer so that it cannot be used anymore by the token holder.

U-Prove. It is based on the work of Stefan Brands on e-cash [2] and PKI [3]. The origi-
nal idea evolved into an anonymous credential system. It was implemented by Microsoft
and is known today under its current name U-Prove. For a description of U-Prove and
other material we refer the reader to the web page [1] maintained by Microsoft.

One of the major disadvantages of this system is that the standard U-Prove speci-
ﬁcation does not allow to revoke credentials. So if a user receives a U-Prove token for
some attributes, then he can use it indeﬁnitely, in particular after loosing some of the
attributes conﬁrmed by the token. This is a major disadvantage limiting the application
scope, since many attributes are temporal: e.g. status of a student, employee of a com-
pany, customer of a company, inhabitant of a local community (the attribute enabling to
participate actively in democracy on a local level) and so on.

U-Prove extension. During Financial Cryptography’2013, a solution expanding U-
Prove by revocation technique has been presented [4]. The solution is fairly complicated
in design – this is witnessed for example by the number of variables used in algorithm
description. It is an extension to U-Prove, which is a very nice property from business
point of view as it does not require rewriting already developed U-Prove products.

In September 2013 Microsoft Research published a technical description [5] closely
related to the paper [4]. There some differences between both U-Prove extensions, how-
ever the main idea seems to be the same. Maybe the most important visible difference is
removing the pairing function (this deﬁnitely makes implementation much easier, since
we are more ﬂexible about the choice of the underlying algebraic structures). It turns
out that there is another important difference indicated by our attack.

Neither [4] nor [5] contains a (complete) security proof. In fact, we have done our
work without making an attempt to understand the mechanism of the proposed exten-
sions. Perhaps it even helps to mount an attack as we do not follow the steps of the
system designers and do not share the same intuitions.

Our Contribution. We show that the extension proposed in [4] has a weakness in the
sense that a revoked person may provide a fake authentication token that passes authen-
tication despite the fact that this person’s ID is already contained in the accumulator.
“Easily” means here that a simple computer program can deliver the fake token. Of
course, derivation of the fake token is different from the original algorithm of creating
authentication token described in [4].

U-Prove Revocation from FC’13 - Weakness in the Accumulator Scheme

3

In Sect. 2 we present chosen details describing the extension from [4]. In Sect. 3 we

describe the attack against this scheme.

2 U-Prove Revocation Extension from FC’2013

Below we give a brief description of the extension of U-Prove proposed in [4] and
aiming to provide revocation functionality. We describe only the details of the system
and its extension which is essential for understanding the discovered weakness of the
system. For a more detailed description we refer the reader to the original paper [4].

2.1 Parameters
Beside the standard U-Prove Issuer parameters

IP = (UIDP , desc(Gq), UIDH, (g0, g1, . . . , gn, gt), (e1, . . . , en), S)).

there are parameters related to Blacklist Authority (BA). Namely, BA holds a secret key
δ and the following public parameters:

param = (q, G1, G2, GT , e, P1, P2, Ppub, H, K, G1)
2 , K = H δ, G1, H ∈ G1, P2 ∈ G2 and e : G1 × G2 → GT is a

where Ppub = P δ
pairing function.

2.2 Blacklist
Instead of a list of identiﬁers the Blacklist Authority maintains an accumulator indicat-
ing identiﬁers of all revoked users. Each user receives a special attribute, which is the
revocation identiﬁer xID. In addition, a user receives a witness w = (d, W, Q) that can
be used to prove that his xID is not in the accumulator.
i=1(δ+xIDi )

, where xID1, . . . , xIDk are the
identiﬁers of the revoked users. All users must update their witness w each time a new
identiﬁer is revoked. To enable local update of the witness, the Blacklist Authority
publishes a vector t = (P δ
1 ) and the revoked identiﬁers xID1, . . . , xIDk.

The accumulator is of form V = P

1 , P δ2

1 , . . . , P δk

(cid:81)k

1

2.3 Creating a Proof of not Being Revoked
According to the speciﬁcation, the standard proof of possession of attributes is extended
in the following way:
First, the following numbers are chosen at random from Zq:

x, u, t1, t2, t3, rx, ru, rt1 , rt2, rt3 , rβ1, rβ2 , rβ3, rd, rd(cid:48).

Then the following numbers are computed:

X := W H t1,
A := Grx
1 H u,
rt1
1 H rt2 ,
T1 := G
T4 := H rβ3 S−rd ,

Y := QK t1,
R := Gt1
1 H t2,
1 H rβ2 R−rx ,
rβ1
T2 := G
Γ := X−rxH rβ1 K rt1 P

−rd
1

.

C := Gx
S := Gd(cid:48)
T3 := Grd(cid:48)

1 H u
1 H t3 ,
1 H rt3 ,

4

Lucjan Hanzlik, Kamil Kluczniak, and Mirosław Kutyłowski

The next steps are computing

a := H(hw0((cid:81)

i∈U gwi ),H(X, Y, R, S, T1, T2, T3, T4, Γ, param))

and the challenge

c := GenerateChallenge(IP, T, a, m,∅, D;{xi}i∈D),

where GenerateChallenge and the parameters involved (apart from a) are some U-Prove
parameters independent from revocations; numbers w0, wi for i ∈ U are for the stan-
dard U-Prove token and have nothing to do with revocation. Finally, c and other param-
eters are used to generate the following numbers:

:= d−1,

β1 := t1xID,
d(cid:48)
st1 := −ct1 + rt1,
sβ1 := −cβ1 + rβ1,
su := −cu + ru,
sd := −cd + rd,

β2 := t2xID,
st2 := −ct2 + rt2,
sβ2 := −cβ2 + rβ2 ,
sx := −cx + rx,
d := −cd(cid:48) + rd(cid:48),
s(cid:48)

β3 := t3d,
st3 := −ct3 + rt3 ,
sβ3 := −cβ3 + rβ3,

They will be used by the veriﬁcation procedure presented below to reconstruct all the
arguments of H used to compute a. In fact, some of these values are related to Schnorr
signatures. Finally, for the revocation part of the proof, the following tuple is presented:

c, su, sx, sd, sd(cid:48), st1 , st2, st3, sβ1 , sβ2, sβ3, C, X, Y, R, S

2.4 Veriﬁcation
Let T be a U-Prove token and let the tuple (c, su, sx, sd, s(cid:48)
d, st1, st2, st3 , sβ1, sβ2, sβ3,
C, X, Y, R, S) be its extension part. Apart from the standard veriﬁcation of T , the Ver-
iﬁer performs the following operations:

1. compute the following values:

(cid:101)T1 = G
(cid:101)T3 = Gsd(cid:48)
(cid:101)A = Gsx

st1
1 H st2 Rc,
1 H st3 Sc,
1 H su C c,

(cid:101)T2 = G
(cid:101)T4 = G−c
(cid:101)Γ = X−sx H sβ1 K st1 P

1 H sβ2 R−sx ,
1 H sβ3 S−sd ,

sβ1

−sd
1

(V −1Y )c,

2. verify if: e(Y, P2) ?= e(X, Ppub),
3. verify that for
a := H((g0gxt

i )−chro(
gxi

(cid:89)

t

i∈D

(cid:89)

i∈U

i ),H((cid:101)A, X, Y, R, S,(cid:101)T1,(cid:101)T2,(cid:101)T3,(cid:101)T2,(cid:101)Γ , param)).

gri

we have c = GenerateChallenge(IP, T, a, m,∅, D;{xi}i∈D).

U-Prove Revocation from FC’13 - Weakness in the Accumulator Scheme

5

3 The Weakness in the Extention from FC’2013

In this section we show that having a valid U-Prove token T and revocation identiﬁer
xID, one can pass the veriﬁcation from Sect. 2.4 even if the identiﬁer xID is revoked
and included in the accumulator V . First we show how to compute the parameters X, Y
of the token. Then we show how to create the remaining parameters so that we allude
revocation test, but still the token will be good as a U-Prove token.

Computing X and Y . Let us deﬁne the following polynomial:

i=1(x + xIDi) = anxn + an−1xn−1 + . . . + a1x + a0.

f (x) =(cid:81)k

Then the accumulator V equals P f (δ)

1

. Further, we deﬁne the following polynomials:

f(cid:48)(x) = f (x) − a0 = anxn + an−1xn−1 + . . . + a1x
g(x) = f(cid:48)(x)/x = anxn−1 + an−1xn−2 + . . . + a1.

Thus, we can compute X := P g(δ)
in the exponent. Note that:

1

and Y := P f(cid:48)(δ)

1

using the vector t and interpolation

, P2) = e((P f(cid:48)(δ)

1

)δ−1

, P δ

2 ) = e(P g(δ)

1

, Ppub) = e(X, Ppub)

e(Y, P2) = e(P f(cid:48)(δ)

1
and that V = Y P a0
1 .

In the above procedure the attacker has to know the vector t in order to perform
interpolation in the exponent for computing X and Y . However, there is an option for
the extended U-Prove where t and the revoked identiﬁers are not published. Instead, the
users could get the current value of the accumulator. In this case the attack does not work
directly. Nevertheless, the attacker can get the values from t = (P δ
1 ).
Imagine that all the revoked identiﬁers belong to the attacker and the identiﬁers are
, the attacker can compute
revoked one by one. As the users ﬁrst become V = P
(δ+xID1 )(δ+xID2 )
1 as V /P
P δ
=
1
1 ·(P δ
P δ2
, so the adversary can easily compute P δ2
1 . This procedure
can be continued. It sufﬁces to know the identities of the revoked users and the values
of the accumulator V to perform the computations and derive the vector t.

. After the second revocation the users get V = P

1 )xID1 +xID2 ·P

1 , P δ2

1 , . . . , P δk

xID1·xID2

δ+xID1
1

xID1
1

1

Passing veriﬁcation without witness w. In the previous subsection we have shown
how to compute X and Y . Now we will show how to compute the remaining values. To
do so, we perform the following steps:
1. Choose x1, x3, rx, ru, r(cid:48)
2. Compute:

d, rt1, rt2, rt3, rβ1, rβ2 , rβ3 at random.

x2 = a−1
0 ,
R = H x1
1 ,
T3 = Grd(cid:48)
1 H rt3 ,
A = Grx
1 H ru .

S = Gx2
1 ,
rt1
1 H rt2 ,
T1 = G
T4 = H rβ3 ,

C = H x3,
1 H rβ2 R−rx ,
rβ1
T2 = G
Γ = X−rx H rβ1 K rt1 ,

rt1

(cid:101)T1 = G
(cid:101)T2 = G
(cid:101)T3 = Gsd(cid:48)
(cid:101)T4 = G−c
(cid:101)A = Gsx
(cid:101)Γ = X−sx H sβ1 K st1 P

st1
1 H st2 Rc = G
1 H sβ2 R−sx = G
sβ1
rβ1
d−cx2
1 H st3 Sc = Gr(cid:48)
1
1 H sβ3 S−sd = G−c
1 H su C c = Grx

rt1
1 H rt2 = T1,

1 H rt2−cx1(H x1)c = G
1 H rβ2 R−rx = T2,
1 )c = Gr(cid:48)
1 )cx

1 H rβ3 (Gx2

H rt3 (Gx2

d

1 H rt3 = T3,
−1
2 = H rβ3 = T4,

6

Lucjan Hanzlik, Kamil Kluczniak, and Mirosław Kutyłowski

3. Compute a and c according to the original speciﬁcation.
4. Compute

sd = −cx−1
2 ,
st1 = rt1,
sx = rx,
sβ1 = rβ1,

d = rd(cid:48) − cx2,
s(cid:48)
st2 = rt2 − cx1,
su = ru − cx3,
sβ2 = rβ2 ,

st3 = rt3,

sβ3 = rβ3.

5. Return (su, sx, sd, s(cid:48)

of the attribute presentation proof.

d, st1, st2 , st3, sβ1, sβ2 , sβ3, C, X, Y, R, S) as the revocation part

Correctness. We will show that the values computes above will pass the veriﬁcation
from Sect. 2.4. For this purpose we have to show that the veriﬁcation procedure will
deliver the same values as used for computing a by the adversary:

1 H ru−cx3(H x3)c = Grx
−1
−sd
(V −1Y )c = X−rxH rβ1 K rt1 P cx
2
1
−1
−1
= X−rx H rβ1 K rt1 P cx
)c = X−rx H rβ1 K rt1 P cx
(P
2
2
= X−rx H rβ1 K rt1 = Γ.

1 H ru = A,

−a0
1

1

1

1 )−1Y )c

((Y P a0
−1
P
2

−cx
1

1

Recall, that X and Y fulﬁl the equation e(Y, P2) = e(X, Ppub). Thus, we will
pass all steps of the veriﬁcation related to the revocation extension. As we have not
manipulated the creation of the U-Prove traditional token, it will accepted as well.

Final remarks. The reader might ask what is the magic behind the choice of the pa-
rameters for the fake proof of the non-revoked status. Deﬁnitely, ﬁrst the parameters for
computation of c must be ﬁxed (unless we aim to break the hash function). Then we
have to ﬁnd the other parameters from the proof that during the veriﬁcation would yield
the arguments used originally for computing c.

Our solution has been found by analyzing dependencies. Of course, in a secure de-
sign we have a kind of loop: an attampt to cheat leads to setting the same value in differ-
ent ways to satisfy different equations. This is the basic property of constructions such
as Schnorr signatures. Unfortunately, driven by pure intuition and reverse-engineering
methodology (“do not try to analyze ﬁrst all details of the attacked system”) we have
found a path to set all values in a way to fulﬁll all equations in a way different than
designed by the authors of the extension.

U-Prove Revocation from FC’13 - Weakness in the Accumulator Scheme

7

References

1. Microsoft: U-Prove. Webpage of the project (retrieved 2013). Available from: http://

research.microsoft.com/en-us/projects/u-prove/

2. Brands, S.: Untraceable off-line cash in wallets with observers (extended abstract). In Stinson,

D.R., ed.: CRYPTO. Vol. 773 of LNCS, Springer (1993) 302–318

3. Brands, S.A.: Rethinking Public Key Infrastructures and Digital Certiﬁcates: Building in
Privacy. 1 edn. MIT Press, Cambridge-London (2000). Available from: http://www.
credentica.com/the_mit_pressbook.html

4. Acar, T., Chow, S.S.M., Nguyen, L.: Accumulators and U-Prove revocation. In Sadeghi, A.R.,

ed.: Financial Cryptography. Vol. 7859 of LNCS, Springer (2013) 189–196

5. Lan Nguyen, C.P.: U-Prove designated-veriﬁer accumulator revocation extension. Technical

Report Draft Revision 1, Microsoft Research (2013)

