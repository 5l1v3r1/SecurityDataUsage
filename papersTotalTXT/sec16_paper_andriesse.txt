An In-Depth Analysis of Disassembly 

on Full-Scale x86/x64 Binaries

Dennis Andriesse, Xi Chen, and Victor van der Veen, Vrije Universiteit Amsterdam;  

Asia Slowinska, Lastline, Inc.; Herbert Bos, Vrije Universiteit Amsterdam

 https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/andriesse

This paper is included in the Proceedings of the 25th USENIX Security SymposiumAugust 10–12, 2016 • Austin, TXISBN 978-1-931971-32-4Open access to the Proceedings of the 25th USENIX Security Symposium is sponsored by USENIX An In-Depth Analysis of Disassembly on Full-Scale x86/x64 Binaries

Dennis Andriesse†§, Xi Chen†§, Victor van der Veen†§, Asia Slowinska‡, and Herbert Bos†§

†{d.a.andriesse,x.chen,v.vander.veen,h.j.bos}@vu.nl

Computer Science Institute, Vrije Universiteit Amsterdam

§Amsterdam Department of Informatics

‡asia@lastline.com

Lastline, Inc.

Abstract

It is well-known that static disassembly is an unsolved
problem, but how much of a problem is it in real software—
for instance, for binary protection schemes? This work
studies the accuracy of nine state-of-the-art disassemblers
on 981 real-world compiler-generated binaries with a
wide variety of properties. In contrast, prior work focuses
on isolated corner cases; we show that this has led to a
widespread and overly pessimistic view on the prevalence
of complex constructs like inline data and overlapping
code, leading reviewers and researchers to underestimate
the potential of binary-based research. On the other hand,
some constructs, such as function boundaries, are much
harder to recover accurately than is reﬂected in the litera-
ture, which rarely discusses much needed error handling
for these primitives. We study 30 papers recently pub-
lished in six major security venues, and reveal a mismatch
between expectations in the literature, and the actual ca-
pabilities of modern disassemblers. Our ﬁndings help
improve future research by eliminating this mismatch.

1

Introduction

The capabilities and limitations of disassembly are not
always clearly deﬁned or understood, making it difﬁcult
for researchers and reviewers to judge the practical fea-
sibility of techniques based on it. At the same time, dis-
assembly is the backbone of research in static binary
instrumentation [5, 19, 32], binary code lifting to LLVM
IR (for reoptimization or analysis) [38], binary-level vul-
nerability search [27], and binary-level anti-exploitation
systems [1, 8, 29, 46]. Disassembly is thus crucial for
analyzing or securing untrusted or proprietary binaries,
where source code is simply not available.

The accuracy of disassembly strongly depends on the
type of binary under analysis. In the most general case,
the disassembler can make very few assumptions on the
structure of a binary—high-level concepts like functions
and loops have no real signiﬁcance at the binary level [3].

Moreover, the binary may contain complex constructs,
such as overlapping or self-modifying code, or inline
data in executable regions. This is especially true for ob-
fuscated binaries, making disassembly of such binaries
extremely challenging. Disassembly in general is unde-
cidable [43]. On the other hand, one might expect that
compilers emit code with more predictable properties,
containing a limited set of patterns that the disassembler
may try to identify.

Whether this is true is not well recognized, leading
to a wide range of views on disassembly. These vary
from the stance that disassembly of benign binaries is
a solved problem [48], to the stance that complex cases
are rampant [23]. It is unclear which view is justiﬁed in
a given situation. The aim of our work is thus to study
binary disassembly in a realistic setting, and more clearly
delineate the capabilities of modern disassemblers.

It is clear from prior work that obfuscated code may
complicate disassembly in a myriad of ways [18, 21].
We therefore limit our study to non-obfuscated binaries
compiled on modern x86 and x64 platforms (the most
common in binary analysis and security research). Specif-
ically, we focus on binaries generated with the popular
gcc, clang and Visual Studio compilers. We explore a
wide variety of 981 realistic binaries, including stripped,
optimized, statically linked, and link-time optimized bi-
naries, as well as library code that includes handcrafted
assembly. We disassemble these binaries using nine state-
of-the-art research and industry disassemblers, studying
their ability to recover all disassembly primitives com-
monly used in the literature: instructions, function start ad-
dresses, function signatures, Control Flow Graphs (CFG)
and callgraphs. In contrast, prior studies focus strongly
on complex corner cases in isolation [23, 25]. Our results
show that such cases are exceedingly rare, even in opti-
mized code, and that focusing on them leads to an overly
pessimistic view on disassembly.

We show that many disassembly primitives can be re-
covered with better accuracy than previously thought. For

USENIX Association  

25th USENIX Security Symposium  583

1

instance, instruction accuracy often approaches 100%,
even using linear disassembly. On the other hand, we
also identify some primitives which are more difﬁcult to
recover—most notably, function start information.

To facilitate a better match between the capabilities of
disassemblers and the expectations in the literature, we
comprehensively study all binary-based papers published
in six major security conferences in the last three years.
Ironically, this study shows a focus in the literature on
rare complex constructs, while little attention is devoted
to error handling for primitives that really are prone to in-
accuracies. For instance, only 25% of Windows-targeted
papers that rely on function information discuss potential
inaccuracies, even though the accuracy of function detec-
tion regularly drops to 80% or less. Moreover, less than
half of all papers implement mechanisms to deal with
inaccuracies, even though in most cases errors can lead to
malignant failures like crashes.

Contributions & Outline
The contributions of our work are threefold.

(1) We study disassembly on 981 full-scale compiler-
generated binaries, to clearly deﬁne the true capa-
bilities of modern disassemblers (Section 3) and the
implications on binary-based research (Section 4).

(2) Our results allow researchers and reviewers to ac-
curately judge future binary-based research—a task
currently complicated by the myriad of differing opin-
ions on the subject. To this end, we release all our raw
results and ground truth for use in future evaluations
of binary-based research1.

(3) We analyze the quality of all recent binary-based
work published in six major security venues by com-
paring our results to the requirements and assump-
tions of this work (Section 5). This shows where
disassembler capabilities and the literature are mis-
matched, and how this mismatch can be resolved
moving forward (Section 6).

Visual Studio 2015 compilers—the most recent versions
at the time of writing. The x86/x64 instruction set is
the most common target in binary-based research. More-
over, x86/x64 is a variable-length instruction set, allowing
unique constructs such as overlapping and “misaligned”
instructions which can be difﬁcult to disassemble. We
exclude obfuscated binaries, as there is no doubt that they
can wreak havoc on disassembler performance and we
hardly need conﬁrm this in our experiments.

We base our disassembly experiments on a test suite
composed of the SPEC CPU2006 C and C++ benchmarks,
the widely used and highly optimized glibc-2.22 li-
brary, and a set of popular server applications consisting
of nginx v1.8.0, lighttpd v1.4.39, opensshd v7.1p2,
vsftpd v3.0.3 and exim v4.86. This test suite has several
properties which make it representative: (1) It contains a
wide variety of realistic C and C++ binaries, ranging from
very small to large; (2) These correspond to binaries used
in evaluations of other work, making it easier to relate
our results to the literature; (3) The tests include highly
optimized library code, containing handwritten assembly
and complex corner cases which regular applications do
not; (4) SPEC CPU2006 compiles on both Linux and
Windows, allowing a fair comparison of results between
gcc, clang, and Visual Studio.

To study the impact of compiler options on disassembly,
we compile the SPEC CPU2006 part of our test suite
multiple times with a variety of popular conﬁgurations.
Speciﬁcally: (1) Optimization levels O0, O1, O2 and O3
for gcc, clang and Visual Studio; (2) Optimization for
size (Os) on gcc and clang; (3) Static linking and link-
time optimization (-flto) on 64-bit gcc; (4) Stripped
binaries, as well as binaries with symbols. We compile the
servers for both x86 and x64 with gcc and clang, leaving
all remaining settings at the Makeﬁle defaults. Finally,
we compile glibc-2.22 with 64-bit gcc, to which it is
speciﬁcally tailored. In total, our test suite contains 981
binaries and shared objects.

2 Evaluating Real-World Disassembly

2.2 Disassembly Primitives

This section outlines our disassembly evaluation approach.
We discuss our results, and the implications on binary-
based research, in Sections 3–4. Sections 5–6 discuss how
closely expectations in the literature match our results.

2.1 Binary Test Suite

We focus our analysis on non-obfuscated x86 and x64 bi-
naries generated with modern compilers. Our experiments
are based on Linux (ELF) and Windows (PE) binaries,
generated with the popular gcc v5.1.1, clang v3.7.0 and

1https://www.vusec.net/projects/disassembly/

We test all ﬁve common disassembly primitives used in
the literature (see Section 5). Some of these go well
beyond basic instruction recovery, and are only supported
by a subset of the disassemblers we test.

(1) Instructions: The pure assembly-level instructions.
(2) Function starts: Start addresses of the functions

originally deﬁned in the source code.

(3) Function signatures: Parameter lists for functions

found by the disassembler.

(4) Control Flow Graph (CFG) accuracy: The sound-
ness and completeness of the CFG digraphs Gc f g =
(Vbb , Ec f ), which describe how control ﬂow edges Ec f ⊆
Vbb × Vbb connect the basic blocks Vbb. In practice, dis-

584  25th USENIX Security Symposium 

USENIX Association

2

assemblers deviate from the traditional CFG; typically
by omitting indirect edges, and sometimes by deﬁning
a global CFG rather than per-function CFGs. Therefore,
we deﬁne the Interprocedural CFG (ICFG): the union of
all function-level CFGs, connected through interprocedu-
ral call and jump edges. This allows us to abstract from
the disassemblers’ varying CFG deﬁnitions, by focusing
our measurement on the coverage of basic blocks in the
ICFG. We pay special attention to hard-to-resolve basic
blocks, such as the heads of address-taken functions and
switch/case blocks reached via jump tables.

(5) Callgraph accuracy: The correctness of the digraph
G = (Vcs ∪ Vf , Ecall) linking the set Vcs of call sites to
the function starts Vf through call edges Ecall ⊆ Vcs ×Vf .
Similarly to the CFG, disassemblers deviate from the
traditional callgraph deﬁnition by including only direct
call edges. In our experiments, we therefore measure the
completeness of this direct callgraph, considering indirect
calls and tailcalls separately in our complex case analysis.

2.3 Complex Constructs

We also study the prevalence in real-world binaries of
complex corner cases which are often cited as particularly
harmful to disassembly [5, 23, 34].

(1) Overlapping/shared basic blocks: Basic blocks may
be shared between different functions, hindering disas-
semblers from properly separating these functions.

(2) Overlapping instructions: Since x86/x64 uses
variable-length instructions without any enforced memory
alignment, jumps can target any offset within a multi-byte
instruction. This allows the same code bytes to be in-
terpreted as multiple overlapping instructions, some of
which may be missed by disassemblers.

(3) Inline data and jump tables: Data bytes may be
mixed in with instructions in a code section. Examples of
potential inline data include jump tables or local constants.
Such data can cause false positive instructions, and can
desynchronize the instruction stream if the last few data
bytes are mistakenly interpreted as the start of a multi-
byte instruction. Disassembly then continues parsing this
instruction into the actual code bytes, losing track of the
instruction stream alignment.

(4) Switches/case blocks: Switches are a challenge for
basic block discovery, because the switch case blocks are
typically indirect jump targets (encoded in jump tables).
(5) Alignment bytes: Some code (i.e., nop) or data
bytes may have no semantic meaning, serving only to
align other code for optimization of memory accesses.
Alignment bytes may cause desynchronization if they do
not encode valid instructions.

(6) Multi-entry functions: Functions may have multiple
basic blocks used as entry points, which can complicate
function start recognition.

Recursive

<f0>
  

<BB0>
    cmp ecx, edx
    jl <BB2>
    jmp <BB1>

<inline data>

<BB1>
    mov eax,[fptr+ecx]
    call eax

<BB2>
    mov eax,[fptr+edx]
    call eax

<f1>
  
<f2>
  

Linear
<f0>
  

<BB0>
    cmp ecx, edx
    jl <BB2>
    jmp <BB1>

<inline data>

<BB1>
    mov eax,[fptr+ecx]
    call eax

<BB2>
    mov eax,[fptr+edx]
    call eax

<f1>
  
<f2>
  

Figure 1: Disassembly methods. Arrows show disassem-
bly ﬂow. Gray blocks show missed or corrupted code.

(7) Tail calls: In this common optimization, a function
ends not with a return, but with a jump to another function.
This makes it more difﬁcult for disassemblers to detect
where the optimized function ends.

2.4 Disassembly & Testing Environment

We conducted all disassembly experiments on an Intel
Core i5 4300U machine with 8GB of RAM, running
Ubuntu 15.04 with kernel 3.19.0-47. We compiled our
gcc and clang test cases on this same machine. The
Visual Studio binaries were compiled on an Intel Core i7
3770 machine with 8GB of RAM, running Windows 10.
We tested nine popular industry and research dis-
IDA Pro v6.7, Hopper v3.11.5, Dyninst
assemblers:
v9.1.0 [5], BAP v0.9.9 [7], ByteWeight v0.9.9 [4], Jakstab
v0.8.4 [17], angr v4.6.1.4 [36], PSI v1.1 [47] (the suc-
cessor of BinCFI [48]), and objdump v2.22. ByteWeight
yields only function starts, while Dyninst and PSI sup-
port only ELF binaries (for Dyninst, this is due to our
Linux testing environment). Jakstab supports only x86
PE binaries. We omit angr results for x86, as angr is opti-
mized for x64. PSI is based on objdump, with added error
correction. Section 3 shows that PSI (and all linear dis-
assemblers) perform equivalently to objdump; therefore,
we group these under the name linear disassembly.

All others are recursive descent disassemblers, illus-
trated in Figure 1. These follow control ﬂow to avoid
desynchronization by inline data, and to discover com-
plex cases like overlapping instructions. In contrast, linear
disassemblers like objdump simply decode all code bytes
consecutively, and may be confused by inline data, possi-
bly causing garbled code like BB1 in the ﬁgure. Recursive
disassemblers avoid this problem, but may miss indirect
control ﬂow targets, such as f1 and f2 in the ﬁgure.

USENIX Association  

25th USENIX Security Symposium  585

3

2.5 Ground Truth

3.1 Application Binaries

Our disassembly experiments require precise ground truth
on instructions, basic blocks and function starts, call sites,
function signatures and switch/case addresses. This in-
formation is normally only available at the source level.
Clearly, we cannot obtain our ground truth from any dis-
assembler, as this would bias our experiments.

We base our ELF ground truth on information collected
by an LLVM analysis pass, and on DWARF v3 debug-
ging information. Speciﬁcally, we use LLVM to collect
source-level information, such as the source lines belong-
ing to functions and switch statements. We then compile
our test binaries with DWARF information, and link the
source-level line numbers to the binary-level addresses us-
ing the DWARF line number table. We also use DWARF
information on function parameters for our function sig-
nature analysis. We strip the DWARF information from
the binaries before our disassembly experiments.

The line number table provides a full mapping of source
lines to binary, but not all instructions correspond directly
to a source line. To ﬁnd these instructions, we use Cap-
stone v3.0.4 to start a conservative linear disassembly
sweep from each known instruction address, stopping
at control ﬂow instructions unless we can guarantee the
validity of their destination and fall-through addresses.
For instance, the target of a direct unconditional jump
instruction can be guaranteed, while its fall-through block
cannot (as it might contain inline data).

This approach yields ground truth for over 98% of
code bytes in the tested binaries. We manually analyze
the remaining bytes, which are typically alignment code
unreachable by control ﬂow. The result is a ground truth
ﬁle for each binary test case, that speciﬁes the type of
each code byte, as well as instruction and function starts,
switch/case addresses, and function signatures.

We use a similar method for the Windows PE tests,
but based on information from PDB (Program Database)
ﬁles produced by Visual Studio instead of DWARF. This
produces ﬁles analogous to our ELF ground truth format.
We release all our ground truth ﬁles and our test suite,
to aid in future evaluations of binary-based research and
disassembly.

3 Disassembly Results

This section describes the results of our disassembly ex-
periments, using the methodology outlined in Section 2.
We ﬁrst discuss application binaries (SPEC and servers),
followed by a separate discussion on highly optimized
libraries. Finally, we discuss the impact of static linking
and link-time optimization. We release all our raw results,
and present aggregated results here for space reasons.

This section presents disassembly results for application
code. We discuss accuracy results for all primitives, and
also analyze the prevalence of complex cases.

3.1.1 SPEC CPU2006 Results

Figures 2a–2e show the accuracy for the SPEC CPU2006
C and C++ benchmarks of the recovered instructions,
function starts, function signatures, CFGs and callgraphs,
respectively. We show the percentage of correctly recov-
ered (true positive) primitives for each tested compiler
at optimization levels O0–O3. Note that the legend in
Figure 2a applies to Figures 2a–2e. All lines are geo-
metric mean results (simply referred to as “mean” from
this point); arithmetic means and standard deviations are
discussed in the text where they differ signiﬁcantly. We
show separate results for the C and C++ benchmarks, to
expose variations in disassembly accuracy that may result
from different code patterns.

Some disassemblers support only a subset of the tested
primitives. For instance, linear disassembly provides only
instructions, and IDA Pro is the only tested disassembler
that provides function signatures. Moreover, some disas-
semblers only support a subset of the tested binary types,
and are therefore only shown in the plots where they are
applicable. For clarity, the graphs only show results for
stripped binaries; our tests with standard symbols (not
DWARF information) are discussed in the text.

3.1.1.1

Instruction boundaries

Figure 2a shows the percentage of correctly recovered
instructions. Interestingly, linear disassembly consistently
outperforms all other disassemblers, ﬁnding 100% of the
instructions for gcc and clang binaries (without false
positives), and 99.92% in the worst case for Visual Studio.

Linear disassembly. The perfect accuracy for linear
disassembly with gcc and clang owes to the fact that
these compilers never produce inline data, not even for
jump tables. Instead, jump tables and other data are placed
in the .rodata section.

Visual Studio does produce inline data, typically jump
tables. This leads to some false positives with linear disas-
sembly (data treated as code), amounting to a worst-case
mean of 989 false positive instructions (0.56% of the dis-
assembled code) for the x86 C++ tests at O3. The number
of missed instructions (false negatives, due to desynchro-
nization) is much lower, at a worst-case mean of 0.09%.
This is because x86/x64 disassembly automatically resyn-
chronizes within two or three instructions [21].

586  25th USENIX Security Symposium 

USENIX Association

4

Figure 2: Disassembly results. The legend in Figure 2a applies to Figures 2a–2e. Section 2.4 describes which platforms
are supported by each tested disassembler.

gcc-5.1.1 x86

gcc-5.1.1 x64

clang-3.7.0 x86

clang-3.7.0 x64

Visual Studio '15 x86

Visual Studio '15 x64

angr 4.6.1.4
BAP 0.9.9
ByteWeight 0.9.9
Dyninst 9.1.0
Hopper 3.11.5
IDA Pro 6.7
Jakstab 0.8.4
Linear

SPEC (C)
SPEC (C++)

O0

O1

O2

O3

gcc-5.1.1 x86

O0

O1

O2

O3

gcc-5.1.1 x86

 100

)
n
a
e
m
c

 

i
r
t
e
m
o
e
g
(
 
t
c
e
r
r
o
c
%

 

 90

 80

 70

 60

 50

 40

 30

 20

 100

)
n
a
e
m
c

 

i
r
t
e
m
o
e
g
(
 
t
c
e
r
r
o
c
%

 

 80

 60

 40

 20

 0

 100

)
n
a
e
m
 
c
i
r
t
e
m
o
e
g
(
 
t
c
e
r
r
o
c
 
%

 80

 60

 40

 20

 0

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

O0

O1

O2

O3

O0

O1

O2

O3

O0

O1

O2

O3

(a) Correctly disassembled instructions.

gcc-5.1.1 x64

clang-3.7.0 x86

clang-3.7.0 x64

 

 

 

 

 

 

 

 

 

 

 

 

O0

O1

O2

O3

O0

O1

O2

O3

O0

O1

O2

O3

(b) Correctly detected function start addresses.

gcc-5.1.1 x64

clang-3.7.0 x86

clang-3.7.0 x64

 

 

 

 

 

 

 

 

 

 

 

 

O0

O1

O2

O3

Visual Studio '15 x86

O0

O1

O2

O3

Visual Studio '15 x86

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

O0

O1

O2

O3

Visual Studio '15 x64

O0

O1

O2

O3

Visual Studio '15 x64

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

O0

O1

O2

O3

O0

O1

O2

O3

O0

O1

O2

O3

O0

O1

O2

O3

O0

O1

O2

O3

O0

O1

O2

O3

(c) Correctly detected non-empty function argument lists (IDA Pro only).

USENIX Association  

25th USENIX Security Symposium  587

5

gcc-5.1.1 x86

gcc-5.1.1 x64

clang-3.7.0 x86

clang-3.7.0 x64

Visual Studio '15 x86

Visual Studio '15 x64

 100

)
n
a
e
m
c

 

i
r
t
e
m
o
e
g
(
 
t
c
e
r
r
o
c
%

 

 80

 60

 40

 20

 0

 100

)
n
a
e
m
c

 

i
r
t
e
m
o
e
g
(
 
t
c
e
r
r
o
c
%

 

 90

 80

 70

 60

 50

 40

 30

 20

O0

O1

O2

O3

gcc-5.1.1 x86

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

O0

O1

O2

O3

O0

O1

O2

O3

O0

O1

O2

O3

(d) Correct and complete basic blocks for the ICFG.

gcc-5.1.1 x64

clang-3.7.0 x86

clang-3.7.0 x64

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

O0

O1

O2

O3

Visual Studio '15 x86

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

O0

O1

O2

O3

Visual Studio '15 x64

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

O0

O1

O2

O3

O0

O1

O2

O3

O0

O1

O2

O3

O0

O1

O2

O3

O0

O1

O2

O3

O0

O1

O2

O3

(e) Correctly resolved direct function calls (indirect calls discussed separately).

Recursive disassembly. The most accurate recursive
disassembler in terms of instruction recovery is IDA Pro
6.7, which closely follows linear disassembly with an
instruction coverage exceeding 99% at optimization lev-
els O0 and O1, dropping to a worst case mean of 96%
for higher optimization levels. The majority of missed in-
structions at higher optimization levels are alignment code
for functions and basic blocks, which is quite common in
optimized binaries. It consists of various (long) nop in-
structions for gcc and clang, and of int 3 instructions
for Visual Studio, and accounts for up to 3% of all code
at O2 and O3. Missing these instructions is not harmful
to common binary analysis operations, such as binary
instrumentation, manual analysis or decompilation.

False positives in IDA Pro are less prevalent than in lin-
ear disassembly. On gcc and clang, they are extremely
rare, amounting to 14 false positives in the worst test
case, with a mean of 0. Visual Studio binaries produce
more false positives, peaking at 0.16% of all recovered in-
structions. Overall, linear disassembly provides the most

complete instruction listing, but at a relatively high false
positive rate for Visual Studio. IDA Pro ﬁnds only slightly
fewer instructions, with signiﬁcantly fewer false positives.
These numbers were no better for binaries with symbols.
Dyninst and Hopper achieve best case accuracy com-
parable to IDA, but not quite as consistently. Some disas-
semblers, notably BAP, appear to be optimized for gcc,
and show large performance drops when used on clang.
The BAP authors informed us that BAP’s results depend
strongly on the disassembly starting points (i.e., function
starts), provided by ByteWeight. We used the default ELF
and PE signature ﬁles shipped with ByteWeight v0.9.9.
Our angr results are based on the CFGFast analysis rec-
ommended to us by the angr authors.

Overall, IDA Pro, Hopper, Dyninst and linear disas-
sembly show arithmetic mean results which are extremely
close to the geometric means, exhibiting standard devia-
tions below 1%. Other disassemblers have larger standard
deviations, typically around 15%, with outliers up to 36%
(for BAP on clang x86, as visible in Figure 2a).

588  25th USENIX Security Symposium 

USENIX Association

6

6caf10 <ix86 fp compare mode>:

6caf10:
6caf16:
6caf19:
6caf1c:
6caf1e:
6caf21:

mov
and
cmp
sbb
add
retq

0x3f0dde(%rip),%eax
$0x10,%eax
$0x1,%eax
%eax,%eax
$0x3a,%eax

Listing 1: False negative indirectly called function for
IDA Pro in gcc, compiled with gcc at O3 for x64 ELF.

480970 <autohelperowl defendpat156>:

480970:
480971:
480973:
480975:
480976:

push
push
push
push
push

%rbp
%r15
%r14
%rbx
%rax

Listing 2: False positive function (shaded) for Dyninst,
due to misapplied prologue signature, gobmk compiled
with clang at O1 for x64 ELF.

C versus C++. Accuracy between C and C++ differs
most in the lower scoring disassemblers, but the difference
largely disappears in the best performing disassemblers.
The largest relative difference appears for clang.

3.1.1.2 Function starts

The results for function start detection are far more diffuse
than those for instruction recovery. Consider Figure 2b,
which shows the mean percentage of correctly recovered
function start addresses. No one disassembler consistently
dominates these results, though Hopper is at the upper
end of the spectrum for most compiler conﬁgurations
in terms of true positives. Dyninst also provides high
true positive rates, though not as consistently as Hopper.
However, as shown in Figure 3, both Hopper and Dyninst
suffer from high false positive rates, with worst case mean
false positive rates of 28% and 19%, respectively. IDA
Pro provides lower false positive rates of under 5% in
most cases (except for x86 Visual Studio, where it peaks
at 20%). However, its true positive rate is substantially
lower than those of Hopper and Dyninst, regularly miss-
ing 20% or more of functions even at low optimization
levels. As with instruction recovery, the results for BAP
and ByteWeight depend heavily on the compiler conﬁg-
uration, ranging from over 90% accuracy on gcc x86 at
O0, to under 20% on clang x64.

Even for the best performing disassemblers, function
start identiﬁcation is far more challenging than instruction
recovery. Accuracy drops particularly as the optimization
level increases, repeatedly falling from close to 99% true
positives at O0, to only 82% at O3, and worsened by high
false positive rates. For IDA Pro, the worst case mean true
positive rate is even lower, falling to 62% for C++ on x64
gcc at O3. Moreover, the standard deviation increases to
over 15% even for IDA Pro.

8060985:

pop

%ebx

8060986:
8060987:
8060988:
8060989:

pop
ret
nop
lea

%esi

0x0(%esi,%eiz,1),%esi

Listing 3: False positive function (shaded) for Dyninst,
due to code misinterpreted as epilogue, sphinx compiled
with gcc at O2 for x86 ELF.

46b990 <Perl pp enterloop>:

46ba02:
46ba08:
46ba0b:
46ba0e:
46ba11:
46ba14:

46bb47:
46bb49:
46bb4a:
46bb50:

[...]
ja
mov
shl
mov
and
je
[...]
pop
retq
nopw
sub

46bb50 <Perl pp enterloop+0x1c0>
%rsi,%rdi
%cl,%rdi
%rdi,%rcx
$0x46,%ecx
46bb50 <Perl pp enterloop+0x1c0>

%r12

0x0(%rax,%rax,1)
$0x90,%rax

Listing 4: False positive function (shaded) for Dyninst,
due to code misinterpreted as epilogue, perlbench com-
piled with gcc at O3 for x64 ELF.

False negatives. The vast majority of false nega-
tives is caused by indirectly called or tailcalled functions
(reached by a jmp instead of a call), as shown in List-
ing 1. This explains why the true positive rate drops
steeply at high optimization levels, where tail calls and
functions lacking standard prologues are common (see
Section 3.1.3). Symbols, if available, help greatly in im-
proving accuracy. They are used especially effectively
by IDA Pro, which consistently yields over 99% true
positives for binaries with symbols, even at higher opti-
mization levels.

False positives. Several factors contribute to the false
positive rate. We analyzed a random sample of 50 false
positives for Dyninst, Hopper and IDA Pro, the three best
performing disassemblers in function detection.

For Dyninst, false positives are mainly due to erro-
neously applied signatures for function prologues and
epilogues. As an example, Listing 2 shows a false posi-
tive in Dyninst due to a misidentiﬁed prologue: Dyninst
scans for the push %r15 instruction (as well as several
other prologue signatures), missing preceding instructions
in the function. We observe similar cases for function
epilogues. For instance, as shown in Listings 3 and 4,
Dyninst assumes a new function following a ret; nop
instruction sequence. This is not always correct: as shown
in the examples, the same code pattern can result from
a multi-exit function with padding between basic blocks.
Note that both examples could be handled correctly by
control ﬂow and semantics-aware disassemblers. In List-
ing 4, there are intraprocedural jumps towards the basic
block at 0x46bb50, showing that it is not a new function.

USENIX Association  

25th USENIX Security Symposium  589

7

gcc-5.1.1 x86

gcc-5.1.1 x64

clang-3.7.0 x86

clang-3.7.0 x64

Visual Studio '15 x86

Visual Studio '15 x64

angr 4.6.1.4
BAP 0.9.9
ByteWeight 0.9.9
Dyninst 9.1.0
Hopper 3.11.5
IDA Pro 6.7
Jakstab 0.8.4
SPEC (C)
SPEC (C++)

 100

)
n
a
e
m
c

 

i
r
t
e
m
o
e
g
(
 

s
e
v

i
t
i
s
o
p
e
s

 

l

a
f
 

%

 80

 60

 40

 20

 0

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

O0

O1

O2

O3

O0

O1

O2

O3

O0

O1

O2

O3

O0

O1

O2

O3

O0

O1

O2

O3

O0

O1

O2

O3

Figure 3: False positives for function start detection (percentage of total detected functions).

42cec3:
42cecb:
42ced0:

movss
jmpq
mov

%xmm0,-0x340(%rbp)
42cfc8 <P7PriorifyTransitionVector+0x622>
-0x344(%rbp),%eax

Listing 5: False positive function (shaded) for Hopper,
due to misclassiﬁed switch case block, hmmer compiled
with gcc at O0 for x64 ELF.

The false positive in Listing 3 is in effect a nop instruction,
emitted for padding by gcc on x86.

All false positives we sampled for Hopper are located
directly after padding code, or after a direct jmp (with-
out a fallthrough edge), and are not directly reached by
other instructions. An example is shown in Listing 5.
Since these instructions are never reached directly, Hop-
per assumes that they represent function starts. This is not
always correct; for instance, the same pattern frequently
results from case blocks belonging to switch statements,
as seen in Listing 5.

Similarly, the majority of false positives for IDA Pro
is also caused by unreachable code assumed to be a new
function. However, these cases are far less common in
IDA Pro than in Hopper, as IDA Pro more accurately
resolves difﬁcult control ﬂow constructs such as switches.
Interestingly, the false positive rate for IDA Pro drops
to a mean of under 0.3% for x64 Visual Studio 2015.
This is because 64-bit Visual Studio uses just one well-
deﬁned calling convention, while other compilers use a
variety [22].

3.1.1.3 Function signatures

Of the tested disassemblers, only IDA Pro supports func-
tion signature analysis. Figure 2c shows the percentage
of non-empty function argument lists where IDA Pro cor-
rectly identiﬁed the number of arguments. We focus on

non-empty argument lists because IDA Pro defaults to an
empty list, skewing our results if counted as correct.

Argument recovery is far more accurate on x86 code,
where parameters are typically passed on the stack, than
it is on the register-oriented x64 architecture. For x86
code generated by gcc and clang, IDA Pro correctly
identiﬁes between 64% and 81% of the argument lists
on non-optimized binaries, dropping to 48% in the worst
case at O3. Results for Visual Studio are slightly worse,
ranging from 36% worst case to 59% in the best case.
As for function starts, the standard deviation is just over
15%. On x64 code, IDA Pro recovers almost none of the
argument lists, with accuracy between 0.38% and 1.87%.
Performance is signiﬁcantly better for binaries with
symbols, even on x64, but only for C++ code. For in-
stance, IDA Pro’s accuracy for gcc x64 increases to a
mean of 44% for C++, peaking at 75% correct argument
lists. This is because IDA Pro parses mangled function
names that occur in C++ symbols, which encode signature
information in the function name.

3.1.1.4 Control Flow Graph accuracy

Figure 2d presents the accuracy of basic blocks in the
ICFG, the union of all function-level CFGs. We found
these results to be representative of the per-function CFG
accuracy. The accuracy of the ICFG is strongly correlated
with instruction discovery; indeed, recursive disassem-
blers typically ﬁnd instructions through the process of
expanding the ICFG itself. Thus, the disassemblers that
perform well in instruction recovery also perform well in
CFG construction. For some disassemblers, such as IDA
Pro, the basic block true positive rate at high optimization
levels even exceeds the raw instruction recovery results
(Figure 2a). This is because for the ICFG, we did not
count missing nop instructions as false negatives.

590  25th USENIX Security Symposium 

USENIX Association

8

IDA Pro consistently achieves a basic block recovery
rate of between 98–100%, even at high optimization lev-
els. Even at moderate optimization levels, the results
for Hopper and Dyninst are considerably less complete,
regularly dropping to 90% or less. For the remaining
disassemblers, basic block recovery rates of 75% or less
are typical.

All disassemblers except IDA Pro show a considerable
drop in accuracy on gcc and clang for x64, compared
to the x86 results. This is strongly correlated with the
diminishing instruction and function detection results for
these disassembler/architecture combinations (see Fig-
ures 2a–2b). This implies that when functions are missed,
these disassemblers also fail to recover the instructions
and basic blocks contained in the missed functions. In
contrast, IDA Pro disassembles instructions even when
it cannot attribute them to any function. The difference
between x86/x64 and C/C++ results is less pronounced
for Visual Studio binaries than for gcc/clang.

3.1.1.5 Callgraph accuracy

Like ICFG accuracy, callgraph accuracy depends strongly
on the completeness of the underlying instruction analy-
sis. As mentioned, the callgraphs returned by the tested
disassemblers contain only the direct call edges, and do
not deal with address-taken functions. For this reason,
Figure 2e presents results for the direct component of the
callgraph only. We study the impact of indirect calls on
function identiﬁcation accuracy in our complex case anal-
ysis instead (Section 3.1.3). The direct callgraph results in
Figure 2e again show IDA Pro to be the most accurate at
a consistent 99% function call resolve rate (linking func-
tion call edges to function starts), in most cases followed
closely by Dyninst and Hopper. This illustrates that the
lower accuracy for function starts (Figure 2b) is mainly
due to indirectly called functions (such as those called via
function pointers or in tail call optimizations).

3.1.2 Server Results

Table 1 shows disassembly results for the servers from
our test suite. For space reasons, and because the rel-
ative accuracy of the disassemblers is the same as for
SPEC, we only show results for IDA Pro, the best overall
disassembler. All other results are available externally,
as mentioned at the start of Section 3. We compiled all
servers for both x86 and x64 with gcc and clang, using
their default Makeﬁle optimization levels.

The server tests conﬁrm that the SPEC results from
Section 3.1.1 are representative; all results lie well within
the established bounds. As with SPEC, linear disassembly
achieved 100% correctness. The nginx results warrant
closer inspection; given its optimization level O1, the

Instructions

u
F

nctions

Signatures

G
F
IC

h

Callgrap

Instructions

u
F

nctions

Signatures

G
F
IC

h

Callgrap

x86

x64

gcc-5.1.1

nginx 99.9 65.5 49.6

100
lighttpd 99.9 99.5 85.9 99.9

100 99.9 59.2 0.9 99.9
100 99.9 99.5 0.0 99.9
vsftpd 95.4 93.4 73.6 95.9 99.5 93.0 92.5 4.3 99.9
100 99.9 86.2 0.0
100
100 99.9 89.9 4.5 99.9

100
exim 99.9 90.1 58.2 99.9

opensshd 99.9 86.2 74.9

100
100
100
100
100

clang-3.7.0

nginx 98.5 57.5 44.0 99.5
lighttpd 98.7 99.5 87.9 99.9
vsftpd 96.8 93.3 72.9 99.8
100
exim 99.0 82.7 54.6 99.3

opensshd 98.9 86.5 78.1

100
100 98.6 53.0 0.7 99.4
100 99.0 99.5 0.0 99.9
100
100 97.0 92.0 6.6 99.5 99.9
100
100 99.2 86.3 0.0
100
100 99.1 81.7 5.4 99.4
100

Table 1: IDA Pro 6.7 disassembly results for server tests
(% correct, per test case).

function start and argument information is on the low
end of the accuracy spectrum. Closer analysis shows that
this results from extensive use in nginx of indirect calls
through function pointers; Section 3.1.1 shows that this
negatively affects function information. Indeed, for all
tested servers, the accuracy of function start detection is
inversely proportional to the ratio of address-taken func-
tions to the total number of instructions. This shows that
coding style can carry through the compilation process to
have a strong effect on disassembler performance.

3.1.3 Prevalence of Complex Constructs

Figure 4 shows the prevalence of complex constructs in
SPEC CPU2006, which pose special disassembly chal-
lenges. We also analyzed these constructs in the server
binaries, ﬁnding no signiﬁcantly different results.

We did not encounter any overlapping or shared basic
blocks in either the SPEC or server tests on any compiler.
This is surprising, as these constructs are frequently cited
in the literature [5, 17, 23]. Closer inspection showed
that all the cited cases of overlapping blocks are due to
constructs which we classify more speciﬁcally, namely
overlapping instructions and multi-entry functions. These
constructs are exceedingly rare, and occur almost exclu-
sively in library code (discussed in Section 3.2.2). This
ﬁnding ﬁts with the examples seen in the literature, which
all stem from library code, most commonly glibc.

No overlapping instructions occur in Linux applica-
tion code, and only a handful in Windows code (with a
mean of zero, and a maximum of 3 and 10 instructions
for x86 and x64 Visual Studio, respectively). Multi-entry
functions are somewhat more common. All cases we
found consisted of functions with optional basic blocks
that can execute before the main function body, and ﬁnish
by jumping over the main function body prologue. Fig-
ure 4 lists such jumps as multi-entry jumps, and shows

USENIX Association  

25th USENIX Security Symposium  591

9

gcc-5.1.1 x86

gcc-5.1.1 x64

clang-3.7.0 x86

clang-3.7.0 x64

Visual Studio '15 x86

Visual Studio '15 x64

BB overlap
ins overlap
multi-entry jmps
multi-entry targets
tailcall jmps
tailcall targets

SPEC (C)
SPEC (C++)

)
n
a
e
m
c

 

i
r
t
e
m
o
e
g
(
 

s
e
s
a
c

 

l

x
e
p
m
o
c

 

#

 600

 500

 400

 300

 200

 100

 0

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

O0

O1

O2

O3

O0

O1

O2

O3

O0

O1

O2

O3

O0

O1

O2

O3

O0

O1

O2

O3

O0

O1

O2

O3

Figure 4: Prevalence of complex constructs in SPEC CPU2006 binaries.

the targeted main function bodies as multi-entry targets.
In binaries compiled with gcc and clang, we found up
to 18 multi-entry jumps for C code, and up to 64 for C++,
with the highest prevalence in x64 binaries. Visual Studio
produced up to 172 multi-entry jumps for C, and up to
88 for C++, the construct being most prevalent in x86
code. This kind of multi-entry function is handled well by
disassemblers in practice, producing no notable decrease
in disassembly accuracy compared to other functions.

Tailcalls form the most prevalent complex case, and
do negatively affect function start detection if the target
function is never called normally (see Section 3.1.1). The
largest number of tailcalls (listed as tailcall jumps in Fig-
ure 4) is found in clang x64 C++ binaries, at a mean
of 545 cases. Visual Studio produces a similar number
of tailcalls. For clang, the number of tailcalls peaks at
optimization level O1, while Visual Studio peaks at O3.
For clang (and to a lesser extent gcc), higher optimiza-
tion levels can lead to a decrease in tailcalls through other
modiﬁcations like code merging and code elimination.

Jump tables (due to switches) are by far the most com-
mon case of inline data. They occur as inline data only
on Visual Studio (gcc and clang place jump tables in
the .rodata section). As seen in Section 3.1.1, inline
data causes false positive instructions especially in linear
disassembly (peaking at 0.56% false positives).

Another challenge due to jump tables is locating all
case blocks belonging to the switch; these are typically
reached indirectly via a jump that loads its target ad-
dress from the jump table. Linear disassembly covers
100% of case blocks correctly on gcc and clang (see
Section 3.1.1), and also achieves very high accuracy for
Visual Studio. The best performing recursive disassem-
blers, most notably IDA Pro, also achieved very high
coverage of switch/case blocks; coverage of these blocks
is comparable to the overall instruction/basic block recov-

ery rates. This is because many recursive disassemblers
have special heuristics for identifying and parsing stan-
dard jump tables.

3.1.4 Optimizing for Size

At optimization levels O0–O3, no overlapping or shared
basic blocks occur. A reasonable hypothesis is that com-
pilers might more readily produce such blocks when op-
timizing for size (optimization level Os) rather than for
performance. To verify this, we recompiled the SPEC C
and C++ benchmarks with size optimization, and repeated
our disassembly tests.

Even for size-optimized binaries, we did not ﬁnd any
overlapping or shared blocks. Moreover, the accuracy of
the instruction boundaries, callgraph and ICFG did not
signiﬁcantly differ from our results for O0–O3. Function
starts and argument lists were comparable in precision to
those for performance-optimized binaries (O2–O3).

3.2 Shared Library Objects

This section discusses our disassembly results and com-
plex case analysis for library code. Libraries are often
highly optimized, and therefore contain more complex
(handcrafted) corner cases than application code. We fo-
cus our analysis on glibc-2.22, the standard C library
used in GNU systems, compiled in its default conﬁgura-
tion (gcc with optimization level O2). This is one of the
most widespread and highly optimized libraries, and is
often cited as a highly complex case [5, 23].

3.2.1 Disassembly Results

Table 2 shows disassembly results for glibc-2.22, for
all tested disassemblers that support 64-bit ELF bina-
ries. Nearly all disassemblers display signiﬁcantly lower

592  25th USENIX Security Symposium 

USENIX Association

10

Instructions

u
F

nctions

Signatures

G
F
IC

h

Callgrap

gcc-5.1.1 x64

angr 64.4 75.6 — 70.2 87.9
BAP 65.3 79.6 — 72.4 84.8
ByteWeight — 29.3 — — —
Dyninst 79.7 85.2 — 87.6 95.5
Hopper 84.3 93.3 — 90.6 93.9
IDA Pro 96.0 92.0 5.4 99.9 99.9
Linear 99.9 — — — —

Table 2: Disassembly results for glibc (% correct).

accuracy on instruction boundaries than the mean for ap-
plication binaries in equivalent compiler conﬁgurations.
Only IDA Pro and linear disassembly are on par with their
performance on application code, achieving very good
accuracy without any false positives. Note that objdump
achieves 99.9% accuracy instead of the usual 100% for
ELF binaries. This is because unlike IDA Pro, it does not
explicitly separate the overlapping instructions that occur
in glibc (see Section 3.2.2).

Function start results are on par with, or even exceed
the mean for application binaries; this holds true for all
disassemblers. Moreover, the accuracy of function argu-
ment lists (5.4%) is much higher than one would expect
from the x64 SPEC CPU2006 results (under 1% accu-
racy). This is because IDA Pro comes with a set of code
signatures designed to recognize standard library func-
tions that are statically linked into binaries.

For the ICFG, we see the same pattern as for instruc-
tions: all disassemblers perform worse than for applica-
tion code, while IDA Pro delivers comparable accuracy.
Callgraph accuracy is below the mean for most disassem-
blers, though IDA Pro and Dyninst perform very close to
the mean, and BAP well exceeds it.

3.2.2 Complex Constructs

Overall, we found the glibc-2.22 code to be surpris-
ingly well-behaved. Our analysis found no overlapping
or shared basic blocks, and no inline data. Indeed, the
glibc developers have taken special care to prevent this,
explicitly placing data and jump tables in the .rodata
section even when manually declared in handwritten as-
sembly code. Prior work has analysed earlier versions
of glibc, showing that inline jump tables are present in
glibc-2.12 [23]. Moreover, inline zero-bytes used for
function padding are conﬁrmed in versions up to 2.21.
This is worth noting, as older glibc versions may still be
encountered in practice. Our analysis of glibc versions
ranging from 2.12 to 2.22 shows consistently improving
disassembler-friendliness over time.

We did ﬁnd some complex constructs that do not occur
in application code, the most notable being overlapping

7b05a:
7b063:
7b065:

cmpl
je
lock cmpxchg %rcx,0x3230fa(%rip)

$0x0,%fs:0x18
7b066

Listing 6: Overlapping instruction in glibc-2.22.

e9a30 <splice>:

e9a30:
e9a37:

cmpl
jne

$0x0,0x2b9da9(%rip)
e9a4c < splice nocancel+0x13>

e9a39 < splice nocancel>:
%rcx,%r10
$0x113,%eax

e9a39:
e9a3c:
e9a41:
e9a43:
e9a49:
e9a4b:
e9a4c:
e9a50:
[...]

mov
mov
syscall
cmp
jae
retq
sub
callq

$0xfffffffffffff001,%rax
e9a7f < splice nocancel+0x46>

$0x8,%rsp
f56d0 < libc enable asynccancel>

Listing 7: Multi-entry function in glibc-2.22.

instructions. We found 31 such instructions in glibc. All
of these are instructions with optional preﬁxes, such as the
one shown in Listing 6. These overlapping instructions
are deﬁned manually in handcrafted assembly code, and
typically use a conditional jump to optionally skip a lock
preﬁx. They correspond to frequently cited complex cases
in the literature [5, 23].

In addition, we found 508 tailcalls resulting from the
compiler’s normal optimization; a number comparable
to application binaries of similar size as glibc. We also
found signiﬁcantly more multi-entry functions than in
the SPEC benchmarks. Most of these belong to the
nocancel family, explicitly deﬁned in glibc, an ex-
ample of which is shown in Listing 7. These functions
provide optional basic blocks which can be preﬁxed to
the main function body to choose a threadsafe variant of
the function. These preﬁx blocks end by jumping over
the prologue of the main function body, a pattern also
sometimes seen in application code.

Given that all non-standard complex constructs in
glibc are due to handwritten assembly, we manually
analyzed all assembly code in libc++ and libstdc++.
However, the amount of assembly in these libraries is
very limited and revealed no new complex constructs.
This suggests that the optimization constructs in glibc
are typical for low-level libraries, and less common in
higher-level ones such as the C++ standard libraries.

3.3 Static Linking & Linker Optimization

Static linking can reduce disassembler performance on
application binaries by merging complex library code into
the binary. Link-time optimization performs intermodu-
lar optimization at link-time, as opposed to more local
compile-time optimizations. It is a relatively new feature
that is gaining in popularity, and could worsen disassem-
bler performance if combined with static linking, by opti-
mizing application and library code as a whole. To study

USENIX Association  

25th USENIX Security Symposium  593

11

Instructions

u
F

nctions

Signatures

G
F
IC

h

Callgrap

Control-Flow Integrity, (2) Decompilation, and (3) Auto-
matic bug search. A detailed comparison of our results to
assumptions in the literature is given in Section 5.

gcc-5.1.1 x64 with -static

SPEC/C O0 96.2 69.4 0.1 98.3 98.2
SPEC/C O1 96.2 68.4 0.2 98.6 98.4
SPEC/C O2 95.5 67.1 0.2 98.8 98.9
SPEC/C O3 95.6 65.7 0.2 98.7 98.7
SPEC/C Os 95.9 67.8 0.2 98.7 98.4

gcc-5.1.1 x64 with -static and -ﬂto

SPEC/C O0 96.3 69.3 0.2 98.5 98.3
SPEC/C O1 96.0 68.6 0.3 98.6 98.4
SPEC/C O2 95.0 67.4 0.3 98.3 98.0
SPEC/C O3 95.2 66.9 0.3 98.3 98.4
SPEC/C Os 95.5 67.8 0.2 98.4 97.7

Table 3: IDA Pro 6.7 disassembly results for static and
link-time optimized SPEC C benchmarks (% correct, ge-
ometric mean).

the effects of these options, we recompiled the SPEC
CPU2006 C benchmarks, statically linking them with
glibc-2.22 using gcc’s -static ﬂag. Subsequently,
we repeated the process with both static linking and link-
time optimization (gcc’s -flto) enabled.

As expected, static linking merges complex cases from
glibc into SPEC, including overlapping instructions.
The effect on disassembly performance is shown in Ta-
ble 3 for IDA, the overall best performing disassembler in
our glibc tests. The impact is slight but noticeable, with
an instruction accuracy drop of up to 3 percentage points
compared to baseline SPEC; about the same as for glibc.
As can be seen in Table 3, link-time optimization does not
signiﬁcantly decrease disassembly accuracy compared to
static linking only.

Function start detection suffers from static linking
mostly at lower optimization levels, dropping from a
mean of 80% to just under 70% for O0; at level O3 the per-
formance is not signiﬁcantly reduced. Again, link-time
optimization does not worsen the situation compared to
pure static linking. For the ICFG and callgraph tests, a
small accuracy drop is again seen at lower optimization
levels, again with no more adverse effects due to link-time
optimization. For instance, ICFG accuracy drops from
close to 100% mean in baseline SPEC to just over 98%
in statically linked SPEC at O0, while the results at O2
and O3 show no negative impact. We suspect that this is
a result of optimized library code being linked in even
at lower optimization levels. Overall, we do not expect
any signiﬁcant adverse impact on binary-based research
as link-time optimization gains in popularity.

4

Implications of Results

This section discusses the implications of our results for
three popular directions in binary-based research: (1)

4.1 Control-Flow Integrity

Control-Flow Integrity (CFI) is currently one of the most
popular research directions in systems security, as shown
in Table 6. Binary-level CFI typically relies on binary
instrumentation to insert control ﬂow protections into pro-
prietary or legacy binaries [1, 10, 24, 29, 41, 45, 46, 48].
Though a wide variety of CFI solutions has been proposed,
most of these have similar binary analysis requirements,
due to their common aim of protecting indirect jumps,
indirect calls, and return instructions. We structure our
discussion around what is needed to analyze and protect
each of these control edge types.

Indirect calls. Typically, protecting an indirect call
requires instrumenting both the call site (the call in-
struction itself, possibly including parameters), and the
call target (the called function). Finding call sites relies
mainly on accurate and complete disassembly of the ba-
sic instructions. As shown in Figure 2a, these can be
recovered with extremely high accuracy, even 100% ac-
curacy for linear disassembly on gcc and clang binaries.
Thus, a binary-level CFI solution is unlikely to encounter
problems analyzing and instrumenting call sites.

For Visual Studio binaries, there is a chance that a small
percentage of call sites may be missed. Depending on the
speciﬁc CFI solution, it may be possible to detect calls
from uninstrumented sites in the target function, trigger-
ing a runtime error handling mechanism (see Section 5).
Since these cases are rare, it is then feasible to perform
more elaborate (slow path) alternative security checks.

The main challenge is to accurately detect all possible
target functions for each indirect call. As a basic prereq-
uisite, this requires ﬁnding the complete set of indirectly
called functions. As shown in Section 3.1.1 and Figure 2b,
this is one of the most challenging problems in disassem-
bly — at high optimization levels, 20% or more of all
functions are routinely missed.

Moreover, ﬁne-grained CFI systems must perform even
more elaborate analysis to decide which functions are le-
gal targets for each indirect call site. Overestimating the
set of legal targets leads to attacks which redirect indirect
calls to unexpected functions [12]. Matching call sites to
a set of targets typically requires an accurate (I)CFG, so
that control-ﬂow and data-ﬂow analysis can be performed
to determine which function pointers are passed to each
call site. Figure 2d and Sections 3.1.1–3.1.3 show that an
accurate and complete ICFG is typically available, includ-
ing accurate resolution of switch/jump tables in the best
disassemblers. Although this type of analysis remains

594  25th USENIX Security Symposium 

USENIX Association

12

extremely challenging, especially if done interprocedu-
rally (requiring accurate indirect call resolution), it is at
least not limited by the accuracy of basic blocks or direct
control edges.

Additionally, ﬁne-grained CFI systems can beneﬁt
from function signature information, to further narrow
down the set of targets per call site by matching the func-
tion prototype to parameters passed at the call site [39].
Though signature information is often far from complete
(Figure 2c), especially on x64, the information which is
available can still be useful — even with incomplete infor-
mation, the target set can be reduced, directly leading to
security improvements. However, care must be taken to
make the analysis as conservative as possible; if this is not
done, the inaccuracy of function signature information
can easily cause illegal function calls to be allowed, or
worse, can cause legal calls to be inadvertently blocked.

Indirect jumps. Protecting indirect jumps requires
analysis similar to the requirements for indirect calls.
However, as indirect jumps are typically intraprocedu-
ral, protecting them usually does not rely on function
detection. Instead, accurate switch/jump table resolution
is required, which is available in disassemblers like IDA
Pro (Section 3.1.3).

Return instructions. Return instructions are typi-
cally protected using a shadow stack, which requires in-
strumenting all call and return sites (and jumps, to handle
tailcalls) [8]. Given the accurate instruction recovery pos-
sible with modern disassemblers (Figure 2a), it is possible
to accurately and completely instrument these sites.

Summarizing, the main challenge for modern CFI lies
in accurately and completely protecting indirect call sites.
The reasons for this are twofold: (1) Function detection
is one of the most inaccurate primitives (especially for
indirectly called functions), even in state of the art disas-
semblers, and (2) It is currently very difﬁcult to recover
rich information, such as function signature information,
through disassembly. This makes it extremely challenging
to accurately couple indirect call sites with valid targets.

4.2 Decompilation

Instead of translating a binary into assembly instructions,
decompilers lift binaries to a higher-level language, typ-
ically (pseudo-) C. Decompilers are typically built on
top of a disassembler, and therefore rely heavily on the
quality of the disassembly [33, 44].

As most decompilers operate at function granularity,
they rely on accurate function start information. More-
over, they must translate all basic blocks belonging to
a function, requiring knowledge of the function’s CFG.
In effect, this requires not only accurate function start

detection, but accurate function boundary detection. As
described in related work, function boundary detection
is even more challenging than function start detection, as
it additionally requires locating the end address of each
function [4]. This is difﬁcult, especially in optimized bi-
naries, where tailcalls often blur the boundaries between
functions (since the jmp instructions used in tailcalls can
easily be mistaken for intraprocedural control transfers).
In addition to function detection, decompilers rely on
accurate instruction disassembly, and can also greatly
beneﬁt from function signature/type information. More-
over, switch detection is required to correctly attribute all
switch case blocks to their parent function. Finally, call-
graph information is useful to understand the connections
between decompiled functions.

The impact of inaccuracies for decompilation is not
as severe as for CFI systems, since decompiled code is
typically intended for use in manual reverse engineering
rather than automated analysis. However, disassembly
errors can still affect the decompilation process itself,
especially in later passes (such as stack frame analysis
or data type analysis passes) over the raw decompiled
function. Such analysis phases, as well as human reverse
engineers, must take into account the high probability of
errors in function boundary and signature information.

4.3 Automatic Bug Search

The binary analysis requirements of automatic bug search
systems depend on the type of bug being searched for,
and the granularity of the search. In practice, many such
systems operate at the function level, both for ease of
analysis, and because it is a suitable search-granularity
for common bugs, such as stack-based bugs [14, 27, 50].
Operating at the function level is also useful for interop-
erability with other binary analysis primitives, such as
symbolic execution, which are powerful tools for seman-
tic analysis but do not scale to full binaries [14].

Thus, like decompilation, many automatic bug search
systems rely on accurate function boundary information
and per-function CFGs. Fortunately, despite the relatively
large inaccuracies in the input information, the output
of bug detection systems tends to degrade gracefully —
input inaccuracies may lead to bugs being missed, but
typically do not affect the correctness of the analysis for
other parts of the code. Quantifying the accuracy of the
inputs (disassembly, CFG, function boundaries) helps
users to determine the expected output completeness of
automatic bug search systems.

5 Disassembly in the Literature

Given our disassembly results, we studied recent binary-
based research to determine how well the capabilities

USENIX Association  

25th USENIX Security Symposium  595

13

Instructions

u
F

nctions

Signatures

G
F
C

h

Callgrap

Property

Subproperty

# %

# %

All papers

Top-tier

Windows PE x86/x64 (16 papers, 12 top-tier)

Papers

#

0
2
0
1
0
13
0
4
2
8

30

angr
BAP
ByteWeight
Dyninst
Hopper
IDA Pro
Jakstab
PSI/BinCFI
Linear
Other/Custom

Total

0
1
0
1
0
11
0
3
2
7

25

0
2
0
0
0
6
0
3
1
2

14

0
1
0
0
0
2
0
0
0
0

3

0
2
0
1
0
11
0
3
1
6

24

0
0
0
1
0
4
0
2
1
3

11

Obfuscated code
Optimized binaries
Stripped binaries
Recursive disassembly
Needs relocation info
Primitive errors discussed Instructions

Complex cases discussed
Primitive errors handled

Functions
Signatures
Callgraph
CFG

Overestimate
Underestimate
Runtime

31%
5
88%
14
15
94%
16 100%
12%
2
38% 5 (9)
20% 1 (4)
0% 0 (2)
80% 4 (5)
38% 5 (10)
31%
5
4
25%
2
19%
1
6%
81%
11

33%
4
92%
11
11
92%
12 100%
17%
56%
25%
0%
80%
50%
42%
33%
17%
8%
92%

2
5 (13)
1 (5)
0 (2)
4 (5)
5 (13)
5
4
3
1
13

Table 4: Primitives/disassemblers used in the literature.

Errors are fatal

of disassemblers match the expectations in the literature.
Our study covers research published between 2013 and
2015 in all top-tier systems security conferences, namely
S&P (Oakland), CCS, NDSS and USENIX Security. In
addition, we cover research published in these same years
at RAID and ACSAC, two other major conferences which
are popular targets for such research.

We found 30 papers on binary-based research published
in these venues, summarized in Table 6. The rest of this
section presents aggregated ﬁndings to provide a degree
of anonymization for these papers.

Table 4 shows the primitives and disassemblers used
in these papers. IDA Pro is by far the most popular, for
all primitives; our disassembly results (Section 3) justify
this choice. Despite its good accuracy, linear disassembly
is among the least used, even for papers that handle only
ELF binaries. This may result from the widespread belief
that inline data causes far more problems than we found.
Instructions are the most often needed primitive, used
by 25 of the 30 papers. It is followed by the CFG (24
papers) and function starts (14 papers). Function signature
information is needed by only 3 of the analyzed papers.
One paper used linear disassembly as a basis for building
a CFG and callgraph, and scanning for function starts.

Table 5 provides a more detailed insight into the prop-
erties of the papers we analyzed. We distinguish between
papers that target Windows PE binaries, and those that
target Linux ELF. This is because some complex cases,
such as inline data, are more often generated by Visual
Studio, deserving closer attention in Windows papers.

Most papers that support obfuscated binaries target
Windows (33% of papers versus 10% for Linux). This is
because obfuscation typically occurs in malware, which is
more prevalent on Windows. Though we do not consider
obfuscated binaries in our tests, it is still interesting to
know how many papers target such binaries. After all,
these papers should pay special attention to disassembly
errors and complex corner cases. Unfortunately, this is
not the case; only 50% of papers that support obfusca-
tion discuss potential errors, while 33% implement error

Linux ELF x86/x64 (14 papers, 10 top-tier)

Obfuscated code
Optimized binaries
Stripped binaries
Recursive disassembly
Primitive errors discussed Instructions

Functions
Signatures
Callgraph
CFG

Overestimate
Underestimate
Runtime

Complex cases discussed
Primitive errors handled

Errors are fatal

1
7%
9
93%
7
79%
86%
8
50% 6 (9)
33% 3 (6)

10%
1
90%
13
70%
11
80%
12
67%
6 (12)
50%
3 (9)
1 (1) 100% 1 (1) 100%
50%
2 (6)
62%
5 (11)
10%
1
30%
4
0%
0
1
10%
60%
8

33% 2 (4)
45% 5 (8)
1
3
0
1
6

7%
29%
0%
7%
57%

Table 5: Properties of binary-based papers (number and
percentage of papers). Numbers in parentheses indicate
the total number of papers that use this primitive.

handling. This is no better than the overall number. More-
over, only 17% of these papers explicitly discuss complex
cases; far below the overall rate for Windows.

Nearly all papers support optimized binaries (90% or
more for both Linux and Windows, overall as well as
top-tier). Stripped binaries are supported by an equally
large majority of papers on Windows, and by a slightly
smaller majority on Linux. Curiously, the number of top-
tier papers that support stripped binaries on Linux (70%)
is signiﬁcantly less than the overall number (79%).

The vast majority of papers use recursive disassembly
(100% on Windows and 86% on Linux), with IDA Pro
being the most popular disassembler. The few papers
that do use linear disassembly are based on objdump, and
augment it with a layer of error correction. Interestingly,
these papers claim perfect (100% accurate) or close to
perfect disassembly. As shown in Section 3.1.1, this
precision on Linux binaries owes entirely to the core linear
disassembly, making any error correction redundant other
than for a few corner cases in library code (and obfuscated
code, which these papers do not consider).

A relatively small percentage of Windows papers use
relocation information to ﬁnd disassembly starting points.
At 17%, this number is slightly higher for top-tier papers.
Discussion on disassembly errors and complex cases is
somewhat lacking in the analyzed papers. For most prim-

596  25th USENIX Security Symposium 

USENIX Association

14

Title

Authors

Venue

Year

Top-tier

A Principled Approach for ROP Defense [30]
Binary Code Continent: Finer-Grained Control Flow Integrity (...) [41]
Blanket Execution: Dynamic Similarity Testing for Program (...) [11]
BYTEWEIGHT: Learning to Recognize Functions in Binary Code [4]
CoDisasm: Medium Scale Concatic Disassembly of Self-Modifying (...) [6]
Control Flow and Code Integrity for COTS binaries [49]
Control Flow Integrity for COTS Binaries [48]
Cross-Architecture Bug Search in Binary Executables [27]
DUET: Integration of Dynamic and Static Analyses for Malware (...) [15]
Dynamic Hooks: Hiding Control Flow Changes within (...) [40]
Hardware-Assisted Fine-Grained Control-Flow Integrity (...) [10]
Heisenbyte: Thwarting Memory Disclosure Attacks using (...) [37]
High Accuracy Attack Provenance via Binary-based (...) [20]
Improving Accuracy of Static Integer Overﬂow Detection in Binary [50]
Leveraging Semantic Signatures for Bug Search in Binary Programs [28]
Native x86 Decompilation Using Semantics-Preserving (...) [33]
No More Gotos: Decompilation Using Pattern-Independent (...) [44]
Opaque Control-Flow Integrity [24]
Oxymoron Making Fine-Grained Memory Randomization Practical (...) [2]
Practical Context-Sensitive CFI [1]
Practical Control Flow Integrity & Randomization for (...) [46]
Reassembleable Disassembling [42]
Recognizing Functions in Binaries with Neural Networks [35]
ROPecker: A Generic and Practical Approach for Defending (...) [9]
StackArmor: Comprehensive Protection from Stack-based (...) [8]
Towards Automated Integrity Protection of C++ Virtual Function (...) [13]
Towards Automatic Software Lineage Inference [16]
vfGuard: Strict Protection for Virtual Function Calls (...) [29]
VTint: Protecting Virtual Function Tables’ Integrity [45]
X-Force: Force-Executing Binary Programs for Security (...) [26]

Qiao et al.
Wang et al.
Egele et al.
Bao et al.
Bonfante et al.
Zhang et al.
Zhang et al.
Pewny et al.
Hu et al.
Vogl et al.
Davi et al.
Tang et al.
Hyung Lee et al.
Zhang et al.
Pewny et al.
Schwartz et al.
Yakdan et al.
Mohan et al.
Backes et al.
Andriesse et al.
Zhang et al.
Wang et al.
Chul et al.
Cheng et al.
Chen et al.
Gawlik et al.
Jang et al.
Prakash et al.
Zhang et al.
Peng et al.

ACSAC
ACSAC
USENIX Sec
USENIX Sec
CCS
ACSAC
USENIX Sec
S&P
ACSAC
USENIX Sec
RAID
CCS
NDSS
RAID
ACSAC
USENIX Sec
NDSS
NDSS
USENIX Sec
CCS
S&P
USENIX Sec
USENIX Sec
NDSS
NDSS
ACSAC
USENIX Sec
NDSS
NDSS
USENIX Sec

2015
2015
2014
2014
2015
2015
2013
2015
2013
2014
2015
2015
2013
2015
2014
2013
2015
2015
2014
2015
2013
2015
2015
2014
2015
2014
2013
2015
2015
2014

✓
✓
✓

✓
✓

✓

✓
✓

✓
✓
✓
✓
✓
✓
✓
✓
✓
✓

✓
✓
✓
✓

Table 6: Set of papers discussed in the literature study.

itives on Windows, at best 50% of papers discuss what
happens if the primitive is not recovered perfectly. This
number applies to the top-tier papers; overall, the num-
ber is even lower. The number for Linux-based papers is
slightly better, though even here only a small majority of
papers devote signiﬁcant attention to potential problems.
One would expect more thorough discussion, especially
given that between 80% and 90% of Windows papers,
and around 60% of Linux papers, may suffer malignant
failures given imperfect primitives. The issue is most
apparent in the Windows papers that require function start
information. Only 25% of the top-tier papers that require
function starts consider potential errors in this informa-
tion, even though Section 3.1.1 shows that function starts
are quite challenging to recover accurately.

The percentage of Windows papers that discuss com-
plex cases such as inline data varies from 31% overall
to 42% for top-tier papers. Again, this is less than we
would expect given the prevalence of inline jump tables
generated by Visual Studio. The number for papers that
target Linux is even lower, though this causes fewer issues
as complex cases in ELF binaries are rare.

There is a strong correlation within all papers between
discussion of errors and complex cases, and support for
error handling. Papers that discuss such cases also tend
to implement some mechanism for dealing with errors
if they occur. Conversely, papers that do not implement
error handling nearly always fail to discuss errors at all.

We identiﬁed three popular and recurring categories of

error handling mechanisms.

(1) Overestimation: For instance, CFG and callgraph
overestimation are popular in papers that build binary-
level security; it minimizes the risk of accidentally pro-
hibiting valid edges, though the precision of security poli-
cies may suffer slightly.

(2) Underestimation: This is used in papers where

soundness is more important than completeness.

(3) Runtime augmentation: Some papers use static
analysis to approximate a primitive, and use low-cost
runtime checks to ﬁx errors in the primitive where needed.
Overestimation is the most popular error handling strat-
egy, used in around 30% of top-tier papers. It is followed
by underestimation and runtime augmentation.

6 Discussion

Our ﬁndings show a dualism in the stance on disassem-
bly in the literature. On the one hand, the difﬁculty
of pure (instruction-level) disassembly is often exagger-
ated. The prevalence of complex constructs like overlap-
ping basic blocks, inline data, and overlapping instruc-
tions is frequently overestimated, especially for gcc and
clang [5, 23]. This leads reviewers and researchers to
underestimate the effectiveness of binary-based research.
We showed that unless binaries are deliberately ob-
fuscated, instruction recovery is extremely accurate, es-

USENIX Association  

25th USENIX Security Symposium  597

15

pecially in ELF binaries generated with gcc or clang.
We did not ﬁnd any inline data for these binaries, even
in optimized library code; even jump tables are explic-
itly placed in the .rodata section. Moreover, in Visual
Studio binaries with jump tables in the code section, mod-
ern disassemblers like IDA Pro recognize and resolve
them quite accurately. The rare overlapping instructions
in handcrafted library code take on a limited number of
forms, typically using a direct conditional jump over a
preﬁx. These are resolved without problems by IDA Pro
and Dyninst, among others. The same is true for multi-
entry functions, which are also rare. Moreover, overlap-
ping/shared basic blocks (commonly cited as particularly
challenging for binary analysis), do not appear in our
ﬁndings at all.

On the other hand, some primitives really do often suf-
fer from inaccuracies. Some recursive disassemblers used
for binary instrumentation (notably Dyninst) regularly
miss up to 10% of basic blocks in optimized binaries, call-
ing for special attention in systems which rely on basic
block-level binary instrumentation. Additionally, func-
tion signatures in 64-bit code are extremely inaccurate;
fortunately, they are also rarely used in the literature.

However, function starts are regularly needed, though
the false negative rate regularly rises to 20% or more
even for the best performing disassemblers. This is es-
pecially true in optimized binaries, or in coding styles
that make extensive use of function pointers. Worse, false
positive function starts are almost as common. This can
lead to problems in some binary-based research, espe-
cially binary instrumentation, if care is not taken to en-
sure graceful failure in the event of misdetected function
starts. Symbols offer a great deal of help, especially in
reducing the false negative rate. Unfortunately, they are
rarely available in practice.

It is surprising then, to ﬁnd that only 20% to 25%
(top-tier) of Windows papers that use function starts, and
33% to 50% (top-tier) of the Linux papers, devote any
attention to discussing these problems. A similarly small
number of papers implement error handling, even though
errors can cause malignant failures in a majority of pa-
pers. While it is not impossible to base well-functioning
binary-based systems on function start information (or
other primitives), it is crucial that such work implement
mechanisms for handling inaccuracies. Three effective
classes of error handling (depending on the situation) have
already been proposed in the literature: overestimation,
underestimation, and runtime augmentation.

We hope our study will facilitate a better match be-
tween expectations on disassembly in future research, and
the performance actually delivered by modern disassem-
blers. Moreover, we believe our ﬁndings can be used to
better judge where problems are to be expected, and to
implement effective mechanisms for dealing with them.

7 Related Work

Prior work on disassembly precision focused on complex
corner cases [5, 23, 25] or obfuscated code [18, 34], show-
ing that these can strongly reduce disassembly accuracy.
We focus instead on the performance of modern disas-
semblers given realistic full-scale binaries without active
anti-disassembly techniques.

Miller et al. center their analysis around complex cases
in glibc-2.12 [23]. Their ﬁndings largely correspond
to our own, though we found no inline jump tables in
glibc-2.22. In addition to their glibc analysis, Miller
et al. ﬁnd complex cases in SPEC CPU2006; however,
this analysis focuses exclusively on statically linked bina-
ries. We show in Section 3.3 that these cases are entirely
due to embedded library code, and are extremely rare in
non-statically linked applications.

Our ﬁnding that function starts are among the most
challenging primitives to recover is in agreement with
results by Bao et al. [4].

Paleari et al. study instruction decoders in disassem-
blers [25], which parse individual x86 instructions. Spe-
ciﬁc instructions that are sometimes wrongly parsed have
also been outlined by the authors of Capstone [31].

Complex constructs in obfuscated code are discussed
by Schwarz et al. [34], Linn et al. [21] and Kruegel et
al. [18]. We show that these worst-case complex con-
structs are exceedingly rare in non-obfuscated code.

8 Conclusion

Our study contradicts the widespread belief that complex
constructs severely limit the usefulness of binary-based
research. Instead, we show that modern disassemblers
achieve close to 100% instruction disassembly accuracy
for compiler-generated binaries, and that constructs like
inline data and overlapping code are very rare. Errors in
areas where disassembly is truly lacking, such as function
start recovery, are not discussed nearly as often in the
literature. By analyzing discrepancies between disassem-
bler capabilities and the literature, our work provides a
foundation for guiding future research.

Acknowledgements

We thank the anonymous reviewers for their valuable
input to improve the paper. We also thank Mingwei
Zhang and Rui Qiao for their proofreading and feedback.
This work was supported by the European Commission
through project H2020 ICT-32-2014 “SHARCS” under
Grant Agreement No. 644571, and by the Netherlands
Organisation for Scientiﬁc Research through grant NWO
CSI-DHS 628.001.021 and the NWO 639.023.309 VICI
“Dowsing” project.

598  25th USENIX Security Symposium 

USENIX Association

16

References

[1] ANDRIESSE, D., VAN DER VEEN, V., G ¨OKTAS¸ , E., GRAS, B.,
SAMBUC, L., SLOWINSKA, A., BOS, H., AND GIUFFRIDA,
C. Practical Context-Sensitive CFI. In Proceedings of the 22nd
Conference on Computer and Communications Security (CCS’15)
(Denver, CO, USA, October 2015), ACM.

[2] BACKES, M., AND N ¨URNBERGER, S. Oxymoron Making Fine-
Grained Memory Randomization Practical by Allowing Code
Sharing. In Proceedings of the 23rd USENIX Security Symposium
(USENIX Sec’14) (2014).

[3] BALAKRISHNAN, G., AND REPS, T. WYSINWYX: What You
See is Not What You eXecute. ACM Transactions on Program-
ming Languages and Systems 32, 6 (Aug. 2010), 23:1–23:84.

[4] BAO, T., BURKET, J., WOO, M., TURNER, R., AND BRUMLEY,
D. BYTEWEIGHT: Learning to Recognize Functions in Binary
Code. In Proceedings of the 23rd USENIX Security Symposium
(USENIX Sec’14) (2014).

[5] BERNAT, A. R., AND MILLER, B. P. Anywhere, Any-Time Bi-
nary Instrumentation. In Proceedings of the 10th ACM SIGPLAN-
SIGSOFT Workshop on Program Analysis for Software Tools
(2011).

[6] BONFANTE, G., FERNANDEZ, J., MARION, J.-Y., ROUXEL, B.,
SABATIER, F., AND THIERRY, A. CoDisasm: Medium Scale Con-
catic Disassembly of Self-Modifying Binaries with Overlapping
Instructions. In Proceedings of the 22nd Conference on Computer
and Communications Security (CCS’15) (2015).

[13] GAWLIK, R., AND HOLZ, T. Towards Automated Integrity Pro-
tection of C++ Virtual Function Tables in Binary Programs. In
Proceedings of the 30th Annual Computer Security Applications
Conference (ACSAC’14) (2014).

[14] HALLER, I., SLOWINSKA, A., NEUGSCHWANDTNER, M., AND
BOS, H. Dowsing for Overﬂows: A Guided Fuzzer to Find Buffer
Boundary Violations. In Proceedings of the 22nd USENIX Security
Symposium (USENIX Sec’13) (2013).

[15] HU, X., AND SHIN, K. G. DUET: Integration of Dynamic and
Static Analyses for Malware Clustering with Cluster Ensembles.
In Proceedings of the 29th Annual Computer Security Applications
Conference (ACSAC’13) (2013).

[16] JANG, J., WOO, M., AND BRUMLEY, D. Towards Automatic
Software Lineage Inference. In Proceedings of the 22nd USENIX
Security Symposium (USENIX Sec’13) (2013).

[17] KINDER, J. Static Analysis of x86 Executables. PhD thesis,

Technische Universit¨at Darmstadt, 2010.

[18] KRUEGEL, C., ROBERTSON, W., VALEUR, F., AND VIGNA, G.
Static Disassembly of Obfuscated Binaries. In Proceedings of the
13th USENIX Security Symposium (USENIX Sec’04) (2004).

[19] LAURENZANO, M., TIKIR, M. M., CARRINGTON, L., AND
SNAVELY, A. PEBIL: Efﬁcient Static Binary Instrumentation
for Linux. In Proceedings of the International Symposium on
Performance Analysis of Systems and Software (2010).

[20] LEE, K. H., ZHANG, X., AND XU, D. High Accuracy Attack
Provenance via Binary-based Execution Partition. In Proceed-
ings of the Network and Distributed System Security Symposium
(NDSS’13) (2013).

[7] BRUMLEY, D., JAGER, I., AVGERINOS, T., AND SCHWARTZ,
E. J. BAP: A Binary Analysis Platform. In Proceedings of the
23rd International Conference on Computer Aided Veriﬁcation
(CAV’11) (2011).

[21] LINN, C., AND DEBRAY, S. Obfuscation of Executable Code to
Improve Resistance to Static Disassembly. In Proceedings of the
10th ACM Conference on Computer and Communications Security
(CCS’03) (2003).

[8] CHEN, X., SLOWINSKA, A., ANDRIESSE, D., BOS, H., AND
GIUFFRIDA, C. StackArmor: Comprehensive Protection from
Stack-Based Memory Error Vulnerabilities for Binaries. In Pro-
ceedings of the Network and Distributed System Security Sympo-
sium (NDSS’15) (San Diego, CA, USA, February 2015), Internet
Society.

[9] CHENG, Y., ZHOU, Z., YU, M., DING, X., AND DENG, R. H.
ROPecker: A Generic and Practical Approach for Defending
Against ROP Attacks. In Proceedings of the Network and Dis-
tributed System Security Symposium (NDSS’14) (2014).

[10] DAVI, L., KOEBERL, P., AND SADEGHI, A.-R. Hardware-
Assisted Fine-Grained Control-Flow Integrity: Towards Efﬁcient
Protection of Embedded Systems Against Software Exploitation.
In Proceedings of the 18th International Symposium on Research
in Attacks, Intrusions, and Defenses (RAID’15) (2015).

[11] EGELE, M., WOO, M., CHAPMAN, P., AND BRUMLEY, D. Blan-
ket Execution: Dynamic Similarity Testing for Program Binaries
and Components. In Proceedings of the 23rd USENIX Security
Symposium (USENIX Sec’14) (2014).

[12] EVANS, I., LONG, F., OTGONBAATAR, U., SHROBE, H., RI-
NARD, M., OKHRAVI, H., AND SIDIROGLOU-DOUSKOS, S.
Control Jujutsu: On the Weaknesses of Fine-Grained Control
Flow Integrity. In Proceedings of the 22nd Conference on Com-
puter and Communications Security (CCS’15) (Denver, CO, USA,
2015), ACM.

[22] MICROSOFT DEVELOPER NETWORK. Overview of x64 Calling
Conventions, 2015. https://msdn.microsoft.com/en-us/
library/ms235286.aspx.

[23] MILLER, B. P., AND MENG, X. Binary Code is Not Easy, 2015.

Technical report, University of Wisconsin-Madison.

[24] MOHAN, V., LARSEN, P., BRUNTHALER, S., HAMLEN, K. W.,
AND FRANZ, M. Opaque Control-Flow Integrity. In Proceed-
ings of the Network and Distributed System Security Symposium
(NDSS’15) (2015).

[25] PALEARI, R., MARTIGNONI, L., FRESI ROGLIA, G., AND BR-
USCHI, D. N-Version Disassembly: Differential Testing of x86
Disassemblers. In Proceedings of the 19th International Sympo-
sium on Software Testing and Analysis (2010), ISSTA’10.

[26] PENG, F., DENG, Z., ZHANG, X., XU, D., LIN, Z., AND SU, Z.
X-Force: Force-Executing Binary Programs for Security Applica-
tions. In Proceedings of the 23rd USENIX Security Symposium
(USENIX Sec’14) (2014).

[27] PEWNY, J., GARMANY, B., GAWLIK, R., ROSSOW, C., AND
HOLZ, T. Cross-Architecture Bug Search in Binary Executables.
In Proceedings of the 36th IEEE Symposium on Security and
Privacy (S&P’15) (2015).

[28] PEWNY, J., SCHUSTER, F., ROSSOW, C., BERNHARD, L., AND
HOLZ, T. Leveraging Semantic Signatures for Bug Search in
Binary Programs. In Proceedings of the 30th Annual Computer
Security Applications Conference (ACSAC’14) (2014).

USENIX Association  

25th USENIX Security Symposium  599

17

[29] PRAKASH, A., HU, X., AND YIN, H. vfGuard: Strict Protection
for Virtual Function Calls in COTS C++ Binaries. In Proceed-
ings of the Network and Distributed System Security Symposium
(NDSS’15) (San Diego, CA, USA, February 2015), Internet Soci-
ety.

[30] QIAO, R., ZHANG, M., AND SEKAR, R. A Principled Approach
for ROP Defense. In Proceedings of the 31st Annual Computer
Security Applications Conference (ACSAC’15) (2015).

[31] QUYNH, N. A. Capstone: Next-Gen Disassembly Framework. In

Blackhat USA (2014).

[32] ROMER, T., VOELKER, G., LEE, D., WOLMAN, A., WONG, W.,
LEVY, H., BERSHAD, B., AND CHEN, B. Instrumentation and
Optimization of Win32/Intel Executables Using Etch. In Proceed-
ings of the USENIX Windows NT Workshop (NT’97) (1997).

[33] SCHWARTZ, E. J., LEE, J., WOO, M., AND BRUMLEY, D. Na-
tive x86 Decompilation Using Semantics-Preserving Structural
Analysis and Iterative Control-Flow Structuring. In Proceedings of
the 22nd USENIX Security Symposium (USENIX Sec’13) (2013).

[34] SCHWARZ, B., DEBRAY, S., AND ANDREWS, G. Disassembly
of Executable Code Revisited. In Proceedings of the 9th Working
Conference on Reverse Engineering (WCRE’02) (2002).

[35] SHIN, E. C. R., SONG, D., AND MOAZZEZI, R. Recognizing
Functions in Binaries with Neural Networks. In Proceedings of
the 24th USENIX Security Symposium (USENIX Sec’15) (2015).

[36] SHOSHITAISHVILI, Y., WANG, R., HAUSER, C., KRUEGEL, C.,
AND VIGNA, G. Firmalice - Automatic Detection of Authentica-
tion Bypass Vulnerabilities in Binary Firmware.

[37] TANG, A., SETHUMADHAVAN, S., AND STOLFO, S. Heisenbyte:
Thwarting Memory Disclosure Attacks using Destructive Code
Reads. In Proceedings of the 22nd Conference on Computer and
Communications Security (CCS’15) (2015).

[41] WANG, M., YIN, H., BHASKAR, A. V., SU, P., AND FENG, D.
Binary Code Continent: Finer-Grained Control Flow Integrity for
Stripped Binaries. In Proceedings of the 31st Annual Computer
Security Applications Conference (ACSAC’15) (2015).

[42] WANG, S., WANG, P., AND WU, D. Reassembleable Disassem-
bling. In Proceedings of the 24th USENIX Security Symposium
(USENIX Sec’15) (2015).

[43] WARTELL, R., ZHOU, Y., HAMLEN, K. W., KANTARCIOGLU,
M., AND THURAISINGHAM, B. M. Differentiating Code from
Data in x86 Binaries. In Proceedings of the European Conference
on Machine Learning and Knowledge Discovery in Databases
(2011).

[44] YAKDAN, K., ESCHWEILER, S., GERHARDS-PADILLA, E., AND
SMITH, M. No More Gotos: Decompilation Using Pattern-
Independent Control-Flow Structuring and Semantics-Preserving
Transformations. In Proceedings of the Network and Distributed
System Security Symposium (NDSS’15) (2015).

[45] ZHANG, C., SONG, C., CHEN, K. Z., CHEN, Z., AND SONG, D.
VTint: Protecting Virtual Function Tables’ Integrity. In Proceed-
ings of the Network and Distributed System Security Symposium
(NDSS’15) (2015).

[46] ZHANG, C., WEI, T., CHEN, Z., DUAN, L., SZEKERES, L.,
MCCAMANT, S., SONG, D., AND ZOU, W. Practical Control
Flow Integrity and Randomization for Binary Executables. In
Proceedings of the 34th IEEE Symposium on Security and Privacy
(S&P’13) (2013).

[47] ZHANG, M., QIAO, R., HASABNIS, N., AND SEKAR, R. A
Platform for Secure Static Binary Instrumentation. In Proceedings
of the 10th ACM SIGPLAN/SIGOPS International Conference on
Virtual Execution Environments (VEE’14) (2014).

[38] TRAIL OF BITS. A Preview of McSema, 2014. Techni-
cal report. http://blog.trailofbits.com/2014/06/23/a-
preview-of-mcsema/.

[48] ZHANG, M., AND SEKAR, R. Control Flow Integrity for COTS
Binaries. In Proceedings of the 22nd USENIX Security Symposium
(USENIX Sec’13) (2013).

[39] VAN DER VEEN, V., G ¨OKTAS¸ , E., CONTAG, M., PAWLOSKI, A.,
CHEN, X., RAWAT, S., BOS, H., HOLZ, T., ATHANASOPOULOS,
E., AND GIUFFRIDA, C. A Tough call: Mitigating Advanced
Code-Reuse Attacks At The Binary Level. In Proceedings of the
37th Symposium on Security and Privacy (S&P’16) (May 2016).

[40] VOGL, S., GAWLIK, R., GARMANY, B., KITTEL, T., PFOH, J.,
ECKERT, C., AND HOLZ, T. Dynamic Hooks: Hiding Control
Flow Changes within Non-Control Data. In Proceedings of the
23rd USENIX Security Symposium (USENIX Sec’14) (2014).

[49] ZHANG, M., AND SEKAR, R. Control Flow and Code Integrity
for COTS binaries. In Proceedings of the 31st Annual Computer
Security Applications Conference (ACSAC’15) (2015).

[50] ZHANG, Y., SUN, X., DENG, Y., CHENG, L., ZENG, S., FU, Y.,
AND FENG, D. Improving Accuracy of Static Integer Overﬂow De-
tection in Binary. In Proceedings of the 18th International Sympo-
sium on Research in Attacks, Intrusions, and Defenses (RAID’15)
(2015).

600  25th USENIX Security Symposium 

USENIX Association

18

