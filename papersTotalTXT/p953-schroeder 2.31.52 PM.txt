Veriﬁable Data Streaming

Dominique Schröder

Saarland University, Germany
University of Maryland, USA

Heike Schröder

Technical University of Darmstadt, Germany

ABSTRACT
In a veriﬁable data streaming protocol, the client streams a
long string to the server who stores it in its database. The
stream is veriﬁable in the sense that the server can neither
change the order of the elements nor manipulate them. The
client may also retrieve data from the database and update
them. The content of the database is publicly veriﬁable such
that any party in possession of some value s and a proof π
can check that s is indeed in the database.

We introduce the notion of veriﬁable data streaming and
present an eﬃcient instantiation that supports an exponen-
tial number of values based on general assumptions. Our
main technique is an authentication tree in which the leaves
are not ﬁxed in advanced such that the user, knowing some
trapdoor, can authenticate a new element on demand with-
out pre- or re-computing all other leaves. We call this data
structure chameleon authentication tree (CAT). We instan-
tiate our scheme with primitives that are secure under the
discrete logarithm assumption. The algebraic properties of
this assumption allow us to obtain a very eﬃcient veriﬁca-
tion algorithm. As a second application of CATs, we present
a new transformation from any one-time to many-time sig-
nature scheme that is more eﬃcient than previously known
solutions.

Categories and Subject Descriptors
F.0 [Theory of Computation]: General

General Terms
Security, Theory

Keywords
Outsourcing, streaming, veriﬁable delegation

INTRODUCTION

1.
In a veriﬁable data streaming protocol (VDS), the client
C streams a long string S = s[1], . . . , s[m] to the server S

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’12, October 16–18, 2012, Raleigh, North Carolina, USA.
Copyright 2012 ACM 978-1-4503-1651-4/12/10 ...$10.00.

who stores the string in its database DB. The length of S
exceeds the client’s memory such that C cannot read or store
the entire string at once. Instead, C reads some substring
s[i] ∈ {0, 1}k and sends it to the server. The stream is
veriﬁable in the sense that the server cannot change the
order of the elements or manipulate them. The entries in
the database are publicly veriﬁable such that any party in
possession of s[i] and a proof πs[i] can check that C stored
s[i] in DB hold by S.

The client has also the ability to retrieve and update any
element in the database. Whenever the client wishes to get
some value s[j] from DB, then the server appends a proof
πs[j] that shows the authenticity of s[j] with respect to some
veriﬁcation key PK. To update some element i in DB, the
client retrieves (s[i], πs[i]) from S, checks its validity, and
sends the updated value s(cid:48)[i] back to the server.

1.1 Trivial Approaches

It seems that a VDS can easily obtained by letting the
client sign all values it streams to the server. This solution
indeed works for append-only databases that do not con-
sider the order of the elements (clearly, a stateful solution
encodes the position into each element). What makes the
problem interesting is that the client can update the ele-
ments in the database. In this setting, the trivial solution
does not work anymore, because all previous entries in DB
would still verify under the public key and it is unclear how
to revoke previous signatures. One could let the client store
all previous elements locally in order to keep track of all
changes. This approach, however, would not only lead the
problem ad absurdum, but it simply is impossible due to the
limited storage capacities of the client.

1.2 Applications

Several companies oﬀer already storage in the Internet
such as, e.g., Google drive, Dropbox, Apple’s iCloud, and
many more. The basic idea is that users can outsource most
of their data to a seemingly unbounded storage.
In some
cases, such as Google’s Chromebook, the complete data are
stored in the cloud while the client keeps only a small portion
of the data. Google provides for the users of the Chrome-
book some free storage, but they have to pay a yearly fee
for any additional space.

From a high-level point of view, this can be seen as data
streaming, where a weak client streams a huge amount of
data to a very powerful server. A crucial point here is the
authenticity of the data. How can the client make sure that
the server is not charging the client for space it is not using

953(e.g., by adding random data to the user’s database)? Fur-
thermore, the client needs to verify that the server keeps the
current version of the data without modifying it, or switch-
ing back to an old version.

Taking the order of data into account is a very natural
requirement in computer science. As an example consider a
server that stores the DNA sequences for a health insurance.
A diﬀerence in the sequence of the DNA usually means some
sort of mutation which eﬀects, e.g., in a disease. Thus, if a
malicious server manages to change the order in a patient’s
DNA sequence, then the client might have to pay a higher
fee due to some medical risks (such as genetic disease) that
might be implied by this mutation. The website of the Mu-
seum of Paleontology of UC Berkley describes the aﬀect of
mutations [oCMoP12].
1.3 Our Contribution

We introduce the notion of veriﬁable data streaming and
present an instantiation that supports an exponential num-
ber of values based on general assumptions. Our solution
has eﬃcient updates and the data in the database are pub-
licly veriﬁable. Moreover, our construction is secure in the
standard model. We summarize our contributions as follows:
• Our main technical contribution is an authentication
tree that authenticates an exponential number of val-
ues, but where the leaves are not deﬁned in advance.
The owner of a trapdoor can add elements to the tree
without pre- or re-computing all other elements. We
call such a tree a chameleon authentication tree (CAT).
• We show the generality of our technique by applying
it to two diﬀerent problems: Firstly, we build a veri-
ﬁable data streaming protocol based on CATs. This
scheme supports an exponential number of elements,
eﬃcient updates, and the items in the database are
publicly veriﬁable. The second application of CATs is
a new transformation from any one-time to many-time
signature scheme in the standard model that is more
eﬃcient than all previous approaches.

• We instantiate our construction with primitives that
are secure under the discrete logarithm assumption in
the standard model. This assumption is not only very
mild, but the algebraic structure allows us to obtain a
more eﬃcient veriﬁcation algorithm. The basic idea is
to apply batch veriﬁcation techniques to our veriﬁca-
tion algorithm.

1.4 Related Work

Veriﬁable data streaming is related to veriﬁable databases
(VDB) by Benabbas, Gennaro, and Vahlis [BGV11]. The
main diﬀerence to their work is that the data during the
setup phase in a streaming protocol are unknown. Moreover,
our notion has an algorithm that allows adding elements to
the database that consists of a single message from the user
to the server (which does not change the veriﬁcation key of
the database). One might wonder if VDBs can be used to
simulate veriﬁable data streaming protocols by generating a
database of exponential size and adding the entries via the
update algorithm. This idea, however, does not work be-
cause the update procedure usually requires interaction and
the server updates the veriﬁcation key afterwards. Another
diﬀerence is that the data in a VDB are usually unordered.

That is, the element di in the database DB is associated
to some key xi, i.e., DB(xi) = di. But there is no explicit
ordering of the elements.

The problem of VDBs has previously been investigated in
the context of accumulators [Ngu05, CKS09, CL02] and au-
thenticated data structures [NN00, MND+01, PT07, TT10].
These approaches, however, often rely on non-constant as-
sumptions (such as the q-Strong Diﬃe-Hellman assumption)
as observed in [BGV11]. Recent works, such as [BGV11]
or [CF11], focus on storing speciﬁc values (such as poly-
nomials) instead of arbitrary ones and they usually only
support a polynomial number of values (instead of expo-
nentially many). Moreover, the scheme of [BGV11] is not
publicly veriﬁable.

Proofs-of-retrievability are also similar in the sense that
the server proves to the client that it is actually storing all of
the client’s data [SW08, FB06, SM06]. The interesting re-
search area of memory delegation [CKLR11] is also diﬀerent,
because it considers veriﬁable computation on (streamed)
data. A more eﬃcient solution has been suggested by Cor-
mode, Mitzenmacher, and Thaler in [CMT12].
2. VERIFIABLE DATA STREAMING
In a veriﬁable data streaming protocol (VDS), a client C
reads some long string S = s[1], . . . , s[m] ∈ {0, 1}mk that
C wishes to outsource to a server S in a streaming manner.
Since the client cannot store and read the entire string at
once, C reads a substring s[i] ∈ {0, 1}k of S and sends s[i]
to the server who stores the value in its database DB. We
stress that we are interested in a streaming protocol, i.e.,
the communication between the client and the server at this
stage is unidirectional and the string is ordered. The data
must be publicly veriﬁable in the sense that the server holds
some public key PK and everybody in possession of some
data s[i] and a proof πs[i] can verify that s[i] is stored in
DB. Whenever the client wishes to retrieve some data s[i]
from the database DB, C sends i to the server who returns
s[i] together with a proof πs[i]. This proof shows that s is the
ith element in DB and its authenticity with respect to PK.
In addition, the client has the ability to update any value
s[i] to a new string s(cid:48)[i] which leads to a new veriﬁcation
key PK(cid:48). More formally:

Deﬁnition 1. A veriﬁable data streaming protocol VDS =
(Setup, Append, Query, Verify, Update) is a protocol between
two PPT algorithms: a client C and a server S. The server
S can store an exponential number n of elements in its
database DB and the client keeps some small state O(log n).
The scheme consists of the following PPT algorithms:
Setup(1λ): The setup algorithm takes as input the security
parameter 1λ. It returns a veriﬁcation key PK and a
secret key SK. The veriﬁcation key PK is given to the
server S and the secret key to the client C. W.l.o.g.,
SK always contains PK.

Append(SK, s): This algorithm appends the value s to the
database DB hold by the server. The client sends a
single message to the server who stores the element
in DB. Adding elements to the database may change
the private key to SK(cid:48), but it does not change the
veriﬁcation key PK.

Query(PK, DB, i): The interactive query protocol

is exe-
cuted between S(PK, DB) and C(i). At the end of the

954protocol, the client either outputs the ith entry s[i] of
DB together with a proof πs[i], or ⊥.

(2) add an element to the database without the help of the
user; (3) break the update mechanism. More formally:

Verify(PK, i, s, πs[i]): The veriﬁcation algorithm outputs s[i]
if s[i] is the ith element in the database DB, otherwise
it returns ⊥.

Update(PK, DB, SK, i, s(cid:48)): The interactive update protocol
(cid:104)S(PK, DB),C(SK, i, s(cid:48))(cid:105) takes place between the server
S(PK, DB) and the client C(SK, i, s(cid:48)) who wishes to
update the ith entry of the database DB to s(cid:48). At the
end of the protocol the server sets s[i] ← s(cid:48) and both
parties update PK to PK(cid:48).

A veriﬁable data streaming protocol must fulﬁll the usual
completeness requirements.
2.1 Efﬁciency and Security Evaluation of VDS
Veriﬁable data streaming protocols should fulﬁll both “sys-
tem” and “crypto” criteria. System criteria usually require
that a scheme must be as eﬃcient as possible. In our setting,
eﬃciency should be evaluated w.r.t. computational complex-
ity, storage complexity, and communication complexity. The
server in a VDS must be able to store an exponential number
of elements and we require that there is no a-priori bound
on the number of queries to the server. The veriﬁers in the
system should be stateless with public veriﬁability. Every-
body in possession of a data s and a proof πs should be able
to verify that s is stored at position i and that s is valid
w.r.t. the veriﬁcation key PK.
The most important crypto criteria are the following: A
malicious server A should not be able to add elements to
the database outsourced by the client without its help. This
means that A might ask the client to add q elements to its
database DB (where q is adaptively determined by A), but
he is unable to add any further element that veriﬁes under
PK. A veriﬁable streaming protocol is order-preserving, i.e.,
the malicious server A cannot change the order of any ele-
ment in the database. Furthermore, A should not be able
to change any element in the database. Again, this prop-
erty must hold even if A has the ability to ask the client to
update q elements of its choice. Finally, the server should
only be able to issue proofs that allow to recover the stored
ﬁle. These criteria follow the ones that have been suggested
in the context of proofs-of-retrievability [SW08].
2.2 Security of VDS

The security notion of VDS is similar to the one of veriﬁ-
able databases [BGV11], but diﬀers in many aspects: First,
our model considers the case of public veriﬁability, while
the one of [BGV11] does not. Second, we are dealing with
a stream of data that has an explicit ordering. In contrast,
the model of [BGV11] ﬁxes the size of DB during the setup
and guarantees authenticity only for these data. In partic-
ular, the adversary breaks the security in our model if he
manages to output a data s[i] with a valid proof πs[i], but
where s[i] is not the ith value in DB.
We model this intuition in a game between a challenger
and an adversary A that adaptively adds and updates el-
ements to resp. in the database. At the end of the game,
A tries to compute a false statement saying that a diﬀerent
data s[i] is the ith value in the database. This covers the
diﬀerent attack scenarios we have discussed so far. A suc-
cessful attacker could (1) change the order of an element;

Setup: The challenger runs Setup(1λ) to generate a private
key SK and a public key PK. It sets up an initially
empty database DB and gives the public key PK to
the adversary A.

Queries: The challenger provides two interfaces for A that
A may query adaptively and in an arbitrary order.
If the adversary queries the append interface on some
data s, then the challenger will run Append(SK, s) to
append s to its database DB. Subsequently, it re-
turns the corresponding proof πs to A. The second
interface is an update interface that takes as input
an index j and an element s(cid:48)[j]. Whenever A in-
vokes this interface, the challenger will run the pro-
tocol Update(PK, DB, SK, i, s(cid:48)) with A. Notice that
each call to this interface will update the veriﬁcation
key as well. By DB = s[1], . . . , s[q] we denote the state
of the database after A’s last query and PK∗ is the cor-
responding veriﬁcation key stored by the challenger.

Output: Eventually, the adversary outputs (i∗, s∗, π∗

let ˆs ← Verify(PK∗, i∗, s∗, π∗
to win the game if ˆs (cid:54)= ⊥ and ˆs (cid:54)= s[i∗].

s∗ ) and
s∗ ). The adversary is said

We deﬁne AdvosA to be the probability that the adversary A
wins in the above game.

Deﬁnition 2. A veriﬁable data streaming protocol is se-
cure if for any eﬃcient adversary A the probability AdvosA
is negligible (as a function of λ).

3. PRELIMINARIES

Before describing our construction formally, we introduce
the following basic notations for binary trees (c.f. consider
the tree depicted in Figure 1). The algorithms using this
tree will be described in the subsequent sections. Let CAT
be a binary tree consisting of a root node ρ, a set of in-
ner nodes υ, and some leaf nodes (cid:96). The depth of the
tree is deﬁned by D = poly(λ) and the level of a node
in the tree is denoted by h = 0, . . . , D − 1, where leaf
nodes have level h = 0 and the root node in turn has level
h = D − 1. At each level h the nodes are deﬁned by υh,i,
where i = 0, . . . , 2D−h is the position of the node in the
Ch(vh−1,(cid:98)i/2h−1(cid:99)||vh−1,(cid:98)i/2h−1−2(cid:99); rh,(cid:98)i/2h+1(cid:99)), if (cid:4)i/2h(cid:5) ≡
tree counted from left to right. Furthermore, inner nodes of
the tree are computed according the following rule: vh,i ←
if (cid:4)i/2h(cid:5) ≡ 0 mod 2. Notice that H is a hash function,
1 mod 2 and vh,i ← H(vh−1,(cid:98)i/2h−1(cid:99)−2||vh−1,(cid:98)i/2h−1−1(cid:99)),

Ch a chameleon hash function, and r some randomness. By
(cid:96)i we denote the ith leaf counted from left to right. The
authentication path aPath of a leaf (cid:96) consists of all siblings
of the nodes on the path from (cid:96) to ρ.
If a parent node
is computed by a chameleon hash, then it also stores the
corresponding randomness in a list R. E.g., the authen-
tication path aPath(cid:96)15 of the leaf (cid:96)15 is aPath(cid:96)15 = ((cid:96)14,
v1,6, r2,3, v2,2, r3,1, v3,0) and R(cid:96)15 = (r1,7, r2,3, r3,1, rρ).
3.1 Chameleon Hash Functions and their Se-

curity

A chameleon hash function is a randomized hash function
that is collision-resistant but provides a trapdoor [KR00].

955ρ

h=4

υ3,0

0

υ2,0

0

υ2,1

1

υ2,2

2

υ1,3

υ1,4

υ1,5

υ3,1

h=3

1

υ2,3

h=2

3

υ1,6

. . .

υ1,7

h=1

7

υ1,0

0

υ1,1

1

υ1,2

. . .

(cid:96)0

0

(cid:96)1

1

(cid:96)2

2

(cid:96)3

3

(cid:96)4

. . .

(cid:96)5

(cid:96)6

(cid:96)7

(cid:96)8

(cid:96)9

(cid:96)10

(cid:96)11

(cid:96)12

(cid:96)13

(cid:96)14

. . .

(cid:96)15

h=0

15

Figure 1: Given a binary tree CAT which consists of a root node ρ, a set of inner nodes υ, and some leaf nodes
(cid:96). The blue nodes deﬁne the authentication path of leaf (cid:96)4. The gray nodes right-handed of (cid:96)5 do not exist
at this stage.

Given the trapdoor csk, a message x with some randomness
r, and any additional message x(cid:48), it is possible to eﬃciently
compute a value r(cid:48) such that the chameleon hash algorithm
Ch maps to the same y, i.e., Ch(x; r) = Ch(x(cid:48); r(cid:48)) = y.

Deﬁnition 3. A chameleon hash function is a tuple of PPT

algorithms CH = (Gen, Ch, Col):
Gen(1λ): The key generation algorithm returns a key pair

(csk, cpk) and we set Ch(·) := Ch(cpk,·).

Ch(x; r): The input of the hash algorithm is a message x ∈
{0, 1}in and some randomness r ∈ {0, 1}λ (which is
eﬃciently sampable from some range Rcpk). It outputs
a hash value h = Ch(x; r) ∈ {0, 1}out.

Col(csk, x, r, x(cid:48)): The collision-ﬁnding algorithm returns a

value r(cid:48) such that Ch(x; r) = y = Ch(x(cid:48); r(cid:48)).

Uniform Distribution: The output of Ch is uniformly dis-
tributed, i.e., it also holds that for any cpk, x, r, x(cid:48) the
distribution of Col(csk, x, r, x(cid:48)) (over the choice of r)
is the same as the distribution of r itself, also imply-
ing that a hash value Ch(x; r) (over the choice of r) is
distributed independently of x.

A chameleon hash function must be collision-resistant. This
means that any malicious party should not be able to ﬁnd
two pairs (x0, r0) and (x1, r1) that map to the same image.
More precisely is the following deﬁnition.

Deﬁnition 4. A chameleon hash function CH = (Gen, Ch,
Col) is collision-resistant if the advantage function Advch-col
CH,A
(cid:21)
is a negligible function in λ for all PPT adversaries A, where

(cid:20) Ch(x; r) = Ch(x(cid:48); r(cid:48))

(csk, cpk) ← Gen(1λ);
(x, x(cid:48), r, r(cid:48)) ← A(Ch)

.

Advch-col

CH,A := Pr

and (x, r) (cid:54)= (x(cid:48), r(cid:48))

:

Observe that collision-resistance only holds as long as the ad-
versary has not learned a collision. Indeed, some chameleon
hash functions allow to recover the private key if a collision
is known, such as, e.g., [KR00]. A comprehensive discussion
about this problem is given in [Ad04]. Collision-resistance
of hash functions is deﬁned analogously and omitted here.

4. CATS

The central building block that we use in our VDS pro-
tocol is a technique that we call chameleon authentication
tree (CAT). A CAT is an authentication tree that has the
ability to authenticate an exponential number of 2D leaves
that are not ﬁxed in advanced, where D = poly(λ). Instead,
the owner of a trapdoor can authenticate a new element on
demand without pre- or re-computing all other leaves.
4.1 Formal Deﬁnition of CATs

We formalize CATs as a triple of eﬃcient algorithms: A
CAT generation algorithm catGen, a path generation algo-
rithm addLeaf that adds a leaf to the tree and returns the
corresponding authentication path, and a path veriﬁcation
algorithm catVrfy that checks if a certain leaf is part of the
tree.

Deﬁnition 5. A chameleon authentication tree is a tuple of

PPT algorithms CAT = (catGen, addLeaf, catVrfy):

catGen(1λ, D): The CAT generation algorithm takes as in-
put a security parameter λ and an integer D that de-
ﬁnes the depth of the tree. It returns a private key sp
and veriﬁcation key vp.

addLeaf(sp, (cid:96)): The path generation algorithm takes as in-
put a private key sp and a leaf (cid:96) ∈ L from some leaf
space L. It outputs a key sp(cid:48), the index i of (cid:96) in the
tree, and the authentication path aPath.

catVrfy(vp, i, (cid:96), aPath): The veriﬁcation algorithm takes as
input a public key vp, an index i, a leaf (cid:96) ∈ L, and a
path aPath. It outputs 1 iﬀ (cid:96) is the ith leaf in the tree,
otherwise 0.

A CAT must fulﬁll the usual completeness requirements.
4.2 Security of CATs
We identify two security properties that a CAT should
support. Loosely speaking, an adversary A should not be
able to change the structure of the CAT. In particular, chang-
ing the sequence of the leaves, or substitute any leaf should

956be a successful attack. We call this property structure-
preserving. Furthermore, an adversary should not be able
to add further leaves to a CAT. We refer to this property as
one-wayness.
Structure-Preserving. We formalize the ﬁrst property
by an interactive game between the challenger and an ad-
versary A. The challenger generates a key pair (sp, vp) and
hands the veriﬁcation key vp over to the adversary A. The
attacker may then send q leaves (cid:96)1, . . . , (cid:96)q(λ) (adaptively) to
the challenger who returns the corresponding authentication
paths (aPath1, . . . , aPathq(λ)). Afterwards, the adversary A
tries to break the structure of the CAT by outputting a leaf
that has not been added to the tree at a particular position.
More formally:

Setup: The challenger runs the algorithm catGen(1λ, D) to
compute a private key sp and a veriﬁcation key vp. It
gives vp to the adversary A.

Streaming: Proceeding adaptively, the attacker A sends a
leaf (cid:96) ∈ L to the challenger. The challenger computes
(sp(cid:48), i, aPath) ← addLeaf(sp, (cid:96)) and returns (i, aPath)
to A. Denote by Q := {((cid:96)1, 1, aPath1), . . . , ((cid:96)q(λ), q(λ),
aPathq(λ))} the ordered sequence of query-answer pairs.
Output: Eventually, A outputs ((cid:96)∗, i∗, aPath∗). The at-
tacker A is said to win the game if: 1 ≤ i∗ ≤ q(λ) and
((cid:96)∗, i∗, aPath∗) (cid:54)∈ Q and catVrfy(vp, i∗, (cid:96)∗, aPath∗) = 1.
We deﬁne AdvspA to be the probability that the adversary A
wins in the above game.

Deﬁnition 6. A chameleon authentication tree CAT, de-
ﬁned by the eﬃcient algorithms (catGen, addLeaf, catVrfy)
with n leaves, is structure-preserving if for any q ∈ N, and for
any PPT algorithm A, the probability AdvspA is negligible
(as a function of λ).

One-Wayness. We model the second property in a game
between a challenger and an adversary as follows:

Setup: The challenger runs the algorithm catGen(1λ, D) to
compute a private key sp and a veriﬁcation key vp. It
gives vp to the adversary A.

Streaming: Proceeding adaptively, the attacker A streams
a leaf (cid:96) ∈ L to the challenger. The challenger computes
(sp(cid:48), i, aPath) ← addLeaf(sp, (cid:96)) and returns (i, aPath)
to A.

Output: Eventually, A outputs ((cid:96)∗, i∗, aPath∗). The at-
tacker A is said to win the game if: q(λ) < i∗ ≤ n and
catVrfy(vp, i∗, (cid:96)∗, aPath∗) = 1.

We deﬁne AdvowA to be the probability that the attacker A
wins in the above game.

Deﬁnition 7. A chameleon authentication tree CAT, de-
ﬁned by the PPT algorithms (catGen, addLeaf, catVrfy) with
n leaves, is one-way if for any q ∈ N, and for any PPT algo-
rithm A, the probability AdvowA is negligible (as a function
of λ).

5. OUR SCHEME

Recall that in a chameleon hash function the owner of the
trapdoor can easily ﬁnd collisions, i.e., for a given string x
(and randomness r) there exists an eﬃcient algorithm that
computes a value r(cid:48) such that Ch(x; r) = y = Ch(x(cid:48); r(cid:48)). We
ﬁrst discuss why obvious approaches do not seem to work.
After explaining the main ideas of our construction, we de-
ﬁne them formally and give a proof of security.
5.1 Naïve Approaches do not Work

The ﬁrst idea would be to build a Merkle tree, where the
server stores the entire tree and the client keeps the last au-
thentication path in its state. This idea, however, does not
work, because all leaves are necessary to compute the root.
Using dummy nodes does not solve the problem, because
the root would change whenever a new leaf is authenticated.
Thus, the second approach might be to store the outputs of
chameleon hash functions as the leaves with the idea that
whenever the client wishes to authenticate a new value, it
simply applies the trapdoor such that the new leaf authen-
ticates under the same root. This idea, however, does still
not work. One reason is that the client would have to store
all leaves (together with the corresponding randomness) in
order to compute a collision. One might be temped to let
the server store these values, but this does not work for sev-
eral reasons: First of all, the data are streamed. This means
that there is no communication from the server to the client
at this stage. But even if we would allow bi-directional in-
teraction, it would immediately lead to an attack: Suppose
that the client wishes to append the leaf ˆ(cid:96). To do so, C asks
the server to send the dummy leaf (cid:96) with the correspond-
ing randomness r. Then, the client applies the trapdoor
to compute the matching randomness ˆr and sends the up-
dated values ˆ(cid:96), ˆr to the server. The problem is that the ma-
licious server would learn a colluding pair ((cid:96), r), (ˆ(cid:96), ˆr) such
that Ch((cid:96); r) = Ch(ˆ(cid:96); ˆr). In many schemes, this knowledge
would allow the server to compute another pair ((cid:96)∗, r∗) such
that Ch((cid:96); r) = Ch(ˆ(cid:96); ˆr) = Ch((cid:96)∗; r∗) (some schemes even al-
low to recover the trapdoor csk if one knows a collision, such
as, e.g., [KR00]).
5.2 Intuition of our Construction

ρ

v2,0 ← H(v1,0(cid:107)v1,1)

v2,1 ← Ch(x2,1; r2,1)

v1,1 ← Ch(x1,1; r1,1)

(cid:96)0

(cid:96)1

Figure 2: A CAT of depth 3 that authenticates the
leaves (cid:96)0 and (cid:96)1. The root and the right nodes are
computed by a chameleon hash and the left nodes
by a collision-resistant hash function. The leaves
(cid:96)2, . . . , (cid:96)7 are unknown.

The basic idea of our construction is a careful combina-
tion of hash functions H and chameleon hash functions Ch.

As a warm up, we ﬁrst illustrate the high-level idea of
our instantiation with the tree shown in Figure 2. We stress

957that our actual construction is slightly diﬀerent, because the
catGen algorithm does not know the leaves (cid:96)0 and (cid:96)1.

We set up the tree such that the root and every right-
handed node of the tree are computed by a chameleon hash
function and all left-handed nodes with a collision-resistant
hash function. The ﬁrst step is to set up the tree by com-
puting the hash value of the leaves (cid:96)0 and (cid:96)1 as v1,0 ←
H((cid:96)0(cid:107)(cid:96)1). Then, the algorithm picks two random values
x1,1, r1,1 to compute the dummy right-handed node v1,1 ←
Ch(x1,1; r1,1). The next step is to compute the parent node
v2,0 ← H(v1,0(cid:107)v1,1) and to pick two additional random val-
ues x2,1, r2,1. The algorithm then sets v2,1 ← Ch(x2;1; r2,1)
and ρ ← Ch(v2,0(cid:107)v2,1; rρ) using some randomness rρ. The
authentication path of the leaves (cid:96)0 and (cid:96)1 only consists of
the nodes v1,1, v2,1 and the randomness rρ. It does not con-
tain the pre-images x1,1, r1,1 (resp. x2,1, r2,1). We stress that
this is crucial for the security proof.
To add the elements (cid:96)2 and (cid:96)3 to the tree, the algorithm
1,1 ← ((cid:96)2(cid:107)(cid:96)3) and computes the collision for the node
sets x(cid:48)
1,1 ←
v1,1 using its trapdoor csk and randomness r1,1, i.e., r(cid:48)
Col(csk, x1,1, r1,1, x(cid:48)
1,1). This means that the chameleon hash
function maps to the same value v1,1 = Ch(x1,1; r1,1) =
Ch(x(cid:48)
1,1) and thus, the tree authenticates the leaves
(cid:96)2, (cid:96)3 (using randomness r(cid:48)
1,1). The authentication path of
the leaves (cid:96)2, (cid:96)3 consists of aPath = (v0,1, v2,1) and R =
(r(cid:48)
1,1, rρ). Thus, the attacker only learns x(cid:48)
1,1 and not
the dummy values x1,1, r1,1 that has been used to compute
v1,1.

1,1; r(cid:48)

1,1, r(cid:48)

ρ

v1,3 ← Ch(x1,3; r1,3)

(cid:96)4

(cid:96)5

Figure 3: Appending the leaves (cid:96)4 and (cid:96)5 to the CAT,
requires the computation of a collision in node v2,1.

Now, assume that we would like to add two additional el-
ements (cid:96)4 and (cid:96)5 to the CAT (c.f. Figure 3). Observe that
we are in the situation where all leaves in the left part of
tree are used and the right part of the tree consists only
of the element v2,1. The complete right subtree with root
node v2,1 does not exist at this point as it was unneces-
sary to authenticate any of the previous leaves.
In order
to authenticate the leaves (cid:96)4 and (cid:96)5, our algorithm gen-
erates the skeleton of the right subtree that is needed for
the corresponding authentication path. That is, the algo-
rithm computes v1,2 ← H((cid:96)4(cid:107)(cid:96)5), picks two random values
x1,3, r1,3, and sets v1,3 ← Ch(x1,3; r1,3). The last step is
to apply the trapdoor to the chameleon hash function used
2,1 ← (v1,2(cid:107)v1,3)
in node v2,1 = Ch(x2,1; r2,1), i.e., it sets x(cid:48)
computes r(cid:48)
2,1). The authentica-
tion path of the leaves (cid:96)4, (cid:96)5 consists of aPath = (v1,3, v2,0)
and R = (r2,1, rρ).

2,1 ← Col(csk, x2,1, r2,1, x(cid:48)

We would like to draw the readers attention to the way we
apply the trapdoor to the nodes. The idea is to apply the

trapdoor to the ﬁrst node on the path from the leaf (cid:96)i to the
root ρ that is computed by a chameleon hash. This way we
guarantee that each trapdoor is applied to each node only
once and therefore, the one who stores the tree never sees a
collision.
5.3 Special Property of the Construction

One of the interesting properties of our construction is the
amount of information that is needed to add an element to
the tree. In fact, only the current authentication path, the
pre-images of the chameleon hashes with the corresponding
randomness, and the trapdoor are needed. More precisely,
consider the tree shown in Figure 2. It is basically the au-
thentication path for the leaves (cid:96)0, (cid:96)1 and the missing nodes
that are required to compute the authentication path for the
leaves (cid:96)4 and (cid:96)5 are computed on the ﬂy. This means that
if the tree has depth 2D for some D = poly(λ), the clients
stores only log(2D) = poly(λ) elements. As it turns out, this
property will be very useful for our veriﬁable data streaming
protocol, where the client essentially stores these elements
and the sever the entire tree.

6. OUR CONSTRUCTION

Although the high level idea of CATs is quickly graspable,
the formal description is rather complicated. To simplify the
exposition, we denote by [a] a vector of elements, i.e., [a] =
(a0, . . . , aD−1) and [(x, r)] = ((x0, r0), . . . , (xD−1, rD−1)),
resp.

Construction 1. Let H be a hash function and let CH =
(Gen, Ch, Col) be a chameleon hash function. We deﬁne
the chameleon authentication tree CAT = (catGen, addLeaf,
catVrfy) as follows:

catGen(1λ, D): The key generation algorithm computes keys
of the chameleon hash function (cpk, csk) ← Gen(1λ)
and (cpk1, csk1) ← Gen(1λ). It picks two random val-
ues xρ, rρ, sets ρ ← Ch(xρ; rρ), sets the counter c ← 0,
and the state to st ← (c, D, xρ, rρ).
It returns the
private key sp as (csk, st) and the public key vp as
(cpk, ρ).

addLeaf(sp, (cid:96)): The path generation algorithm parses the
private key sp as (csk, st) and recovers the counter
c from st. Then,
it picks a random value r, sets
((cid:96)c, (cid:96)c+1) ← Ch1((cid:96); r) and distinguishes between two
cases:
c = 0: addLeaf picks random values xh,1 ← {0, 1}2len
rh,1 ← {0, 1}λ (for h = 1, . . . , D − 2), and sets
vh,1 ← Ch(xh,1; rh,1). Subsequently, it computes
the authentication path for (cid:96) as deﬁned in the
algorithm catVrfy up to the level D − 2. De-
note by x(cid:48)
ρ the resulting value. Then, addLeaf
applies the trapdoor csk to the root node ρ to
ρ ←
obtain the matching randomness r(cid:48)
ρ, i.e., r(cid:48)
Col(csk, xρ, rρ, x(cid:48)
ρ) and sets R = (r(cid:48)
ρ, r). The algo-
rithm computes the corresponding authentication
path for the leaf (cid:96) as aPath = ((vh+1,1, . . . , vD−1,1),
it sets the counter c ← 2, and the state
R),
st’ ← (c, D, x(cid:48)
ρ, [x, r], (cid:96)0, (cid:96)1). The algorithm
returns sp(cid:48) = (csk, st
(cid:48)), the index 0, and the au-
thentication path aPath.

ρ, r(cid:48)

958c ← c + 2
for h = 1 to D − 2 do

if (cid:98)c/2h(cid:99) is even then
if (vh,(cid:98)c/2h(cid:99)+1) (cid:54)∈ st then
xh,(cid:98)c/2h(cid:99)+1 ← {0, 1}2len
rh,(cid:98)c/2h(cid:99)+1 ← {0, 1}λ
vh,(cid:98)c/2h(cid:99)+1 = Ch(xh,(cid:98)c/2h(cid:99)+1; rh,(cid:98)c/2h(cid:99)+1)
st.add(xh,(cid:98)c/2h(cid:99)+1, rh,(cid:98)c/2h(cid:99)+1)
aPath.add(vh,(cid:98)c/2h(cid:99)+1)

else

aPath.add(vh,(cid:98)c/2h(cid:99)+1)

end if

end if
end for
R.add(r)
output (sp’,c,(aPath, R))

if (cid:98)c/2h(cid:99) is odd then
if (vh,(cid:98)c/2h(cid:99)) ∈ st then
h,(cid:98)c/2h(cid:99) = (vh−1,(cid:98)c/2h−1(cid:99)||vh−1,(cid:98)c/2h−1(cid:98)+1)
x(cid:48)
h,(cid:98)c/2h(cid:99) ← Col(csk, xh,(cid:98)c/2h(cid:99), rh,(cid:98)c/2h(cid:99), x(cid:48)
r(cid:48)
h,(cid:98)c/2h(cid:99))
vh,(cid:98)c/2h(cid:99)−1 = H(vh−1,(cid:98)c/2h−1(cid:99)−2||vh−1,(cid:98)c/2h−1(cid:99)−1)
R.add(r(cid:48)
st.add(r(cid:48)
aPath.add(vh,(cid:98)c/2h(cid:99)−1)
st.del(vh−1,(cid:98)c/2h−1(cid:99)−2, vh−1,(cid:98)c/2h−1(cid:99)−1, xh,(cid:98)c/2h(cid:99), rh,(cid:98)c/2h(cid:99))

h,(cid:98)c/2h(cid:99))
h,(cid:98)c/2h(cid:99))

else
end if

Figure 4: Algorithm to generate the authentication path.

c > 0: The algorithm addLeaf gets the counter c from
the state st, creates a new list aPath and proceeds
as deﬁned in Figure 4.

ρ

catVrfy(vp, i, (cid:96), aPath): The input of the path veriﬁcation al-
gorithm is a public key vp = (cpk, ρ), the index i
of the leaf (cid:96), and the authentication path aPath =
((v1,(cid:98)i/2(cid:99), . . . , vD−2,(cid:98)i/2D−2(cid:99)), R), where R is a non-
empty set that contains all randomness that are nec-
essary to compute the chameleon hash functions. The
veriﬁcation algorithm sets ((cid:96)i, (cid:96)i+1) ← Ch1((cid:96); r) and
computes the node vh,i for h = 2, . . . , D− 2 as follows:

If (cid:4)i/2h(cid:5) ≡ 1 mod 2:
(cid:16)
If (cid:4)i/2h(cid:5) ≡ 0 mod 2:

x ← vh−1,(cid:98)i/2h−1(cid:99)||vh−1,(cid:98)i/2h−1(cid:99)+1,
vh,i ← Ch

x; rh,(cid:98)i/2h(cid:99)

(cid:17)

, with rh,(cid:98)i/2h(cid:99) ∈ R.

x ← vh−1,(cid:98)i/2h−1(cid:99)−2||vh−1,(cid:98)i/2h−1(cid:99)−1,

vh,i ← H(x).

Finally, the veriﬁer computes the root node ˆρ as ˆρ ←
Ch(vD−2,0||vD−2,1; rρ) (with rρ ∈ R). If ˆρ = ρ, then
the leaf is authenticated, and otherwise rejected.

6.1 Intuition of the Security Proof
To explain the proof idea, consider an eﬃcient adversary
A that inserts at most q := q(λ) leaves. Since the adversary
is eﬃcient, the number of leaves are polynomially bounded.
The idea is to store the q leaves (cid:96)1, . . . , (cid:96)q in the tree and
then to choose dummy nodes such that the entire tree has
polynomial depth D = poly(λ). Notice that the entire tree
does not exist at any time (cf. the tree shown in Figure 5),
i.e., the subtree consists of the leaves (cid:96)1, . . . , (cid:96)q, but the gray
nodes, and the dotted nodes in the tree are dummy nodes.
Now, recall that the adversary wins if it outputs a tuple
((cid:96)∗, i∗, aPath∗) (cid:54)∈ Q. We distinguish between the case where
1 ≤ i∗ ≤ q and where q + 1 ≤ i∗ ≤ 2D.
In the ﬁrst part of the proof, where 1 ≤ i∗ ≤ q, we show
how to ﬁnd a collision in either (1) the hash function or
(2) the chameleon hash function. In the second case where
we assume that q + 1 ≤ i∗ ≤ 2D, we further distinguish

...

...

...

...

...

...

(cid:96)1

(cid:124)

(cid:123)(cid:122)

q

(cid:96)∗

(cid:96)q

(cid:125)

Figure 5: This ﬁgure shows how we set up the tree
in the proof. The gray path corresponds to the case
where the adversary outputs a pair ((cid:96)∗, i∗, aPath∗)
such that i∗ > q.

between the cases where either (2.1) the adversary inverts
the chameleon hash function or (2.2) it ﬁnds a collision in
it.
The main observation in the second part is that the path
from the leaf (cid:96)∗ to the root ρ must contain a right-handed
node on the authentication path of the node (cid:96)q. In partic-
ular, this node must be one of the dummy nodes. Since we
only create a polynomial number of dummy nodes, we can
guess which of these nodes is contained in the path. If the
reduction guesses this index correctly, then it can embed
the challenge of the one-wayness game. Notice, that the ad-
versary might compute a diﬀerent pre-image. In this case,

959however, we break the collision-resistance of the chameleon
hash function. Notice that embedding this challenge is only
possible, because of the careful construction of the tree as
discussed in Section 5.2. In particular, this technique would
not work if we would use the trapdoor of the chameleon
hash function in a diﬀerent way. Observe, that the tree still
authenticates an exponential number of leaves (even if A is
only capable of adding polynomial number of leaves to the
tree).

Theorem 1. If H is a collision-resistant hash function
and CH a one-way collision-resistant chameleon hash func-
tion, then Construction 1 is a chameleon authentication tree
with depth D = poly(λ) that is structure-preserving and one-
way.

The proof is giving in the full version [SS12].

7. CONSTRUCTION OF A VERIFIABLE

DATA STREAMING PROTOCOL

Our VDS is not a completely black-box construction from
a CAT, because updating leaves is not supported by a CAT
in general. Instead, we use the algorithms of a CAT when-
ever it is possible and exploit the concrete structure of our
scheme when we describe the update mechanism and also in
the proof.
The main idea of our construction is to split the data in
the CAT between the server S and the client C. That is,
the client basically stores the trapdoor and the authentica-
tion path of the current value. As discussed in Section 5.3,
this information is suﬃcient to authenticate the next leaf.
The server, however, stores the entire tree (as it has been
speciﬁed so far) and the randomness of all chameleon hashes
learned so far. As an example, consider the tree in Figure 1.
The client stores the blue authentication path including the
values (x3,1, r3,1) and (x1,3, r1,3) of the two “unused” inner
nodes and the trapdoor csk, while the sever stores the entire
tree.

To retrieve any element from the database, the client sends
the index i to the server who returns the element s[i] to-
gether with the corresponding authentication path πs[i] =
aPaths[i]. Verifying works straightforwardly by checking the
authentication path.
Updating an element s[i] to s(cid:48)[i] in DB work as follows:
First, C runs the query algorithm to obtain the element s[i]
and the corresponding authentication path πs[i] = aPaths[i].
If the veriﬁcation algorithm Verify(PK, i, s, πs[i]) evaluates to
1, then C updates the leaf (cid:96)i = s[i] to s[i](cid:48). Subsequently, it
updates the authentication path aPath(cid:96)[i] to aPaths(cid:48)[i] anal-
ogously to the algorithm wcatVrfy as deﬁned in Construc-
tion 1. Denote by ρ(cid:48) the resulting value. The client C sets
ρ ← ρ(cid:48) in its public key PK and sends the new authentica-
tion path aPaths(cid:48)[i] to S. The server updates the entry in
DB, all leaves, and the root, which results in a new public
key PK(cid:48).

Construction 2. Let CAT = (catGen, addLeaf, catVrfy) be
the chameleon authentication tree as deﬁned in Construc-
tion 1. We deﬁne the veriﬁable data streaming protocol
VDS = (Setup, Append, Query, Verify, Update) as follows:
Setup(1λ): The setup algorithm picks some D = poly(λ)
and generates the CAT (sp, vp) ← catGen(1λ, D) as
deﬁned in Construction 1. In particular, the private

key is SK = sp = (csk, csk1, st) and the public key is
PK = vp = (cpk, cpk1, ρ), where ρ is the root of the
initially empty tree. The client C gets the private key
SK and the server the public key PK. The server also
sets up an initially empty database DB.

Append(SK, s): To append an element s to DB, the client
C runs the algorithm addLeaf(sp, s) locally which re-
turns a key sp(cid:48), an index i, and an authentication path
aPathi. It sends i, s and aPathi to the sever S. The
server appends s to DB, it adds the unknown nodes
from aPathi = ((v1,(cid:98)i/2(cid:99), . . . , vD−2,(cid:98)i/2D−2(cid:99)), R) to its
tree, and stores the new randomness from R.

Query(PK, DB, i): The client sends the index i to the server
who responses with s[i] and the corresponding authen-
tication path πs[i] = aPathi, or with ⊥ if the ith entry
in DB is empty.

Verify(PK, i, s, πs[i]): The veriﬁcation algorithm parses PK
as vp and πs[i] as aPaths[i], it returns s if the algorithm
catVrfy(vp, i, s, πi) outputs 1. Otherwise, it outputs ⊥.
Update(PK, DB, SK, i, s(cid:48)): To update the ith element in DB
to s(cid:48), the clients parses SK as the trapdoor sp of the
CAT, its state st, and the pairs (xi,j, ri,j) of the “un-
used” nodes computed via the chameleon hash func-
tion (“unused” means that the trapdoor has not been
applied to these nodes). The ﬁrst move in the proto-
col is by the client who sends the index i to S. The
server returns s[i] and the corresponding proof πs[i]
(which is the authentication path aPathi). The client
C runs Verify(PK, i, s[i], πs[i]) to check the validity of
If Verify returns ⊥, then C aborts. Otherwise,
s[i].
it sets the leaf (cid:96)i = s[i] to s(cid:48) and re-computes the
authentication path with the new leaf (as described in
Construction 1). The output of this algorithm is a new
root ρ(cid:48). Subsequently, the client updates all nodes that
are stored in its state st, but that have been updated
by re-computing the authentication path with the new
leaf (this includes at least the root ρ and thus, the veri-
ﬁcation key PK). Notice that the randomness used for
the chameleon hash functions remain the same. Then,
C sends the new authentication path aPath(cid:48)
i, the up-
dated leaf s(cid:48), and the updated veriﬁcation key PK(cid:48) to
the server. The server ﬁrst veriﬁes the authentication
path. If it is valid, then S updates the stored value s[i]
to s[i](cid:48), the corresponding nodes in the CAT, as well
as its veriﬁcation key PK(cid:48). Otherwise, it aborts.

Regarding security, we prove the following theorem:

Theorem 2. If H is a collision-resistant hash function
and CH = (Gen, Ch, Col) a chameleon hash function that
is one-way and collision-resistant, then Construction 2 is a
secure veriﬁable data streaming protocol w.r.t. Deﬁnition 2.

The proof is giving in the full version [SS12].

8. CONCRETE INSTANTIATION WITH

FASTER VERIFICATION

Our construction can be instantiated with any chameleon
hash function, but we choose the one of Krawczyk and Rabin
(in the following called KR chameleon hash function) [KR00].

960The scheme is secure under the discrete logarithm assump-
tion (in the standard model)1, which is a very appealing
and mild assumption. Furthermore, the algebraic proper-
ties allow us to construct a very eﬃcient path veriﬁcation
algorithm by applying batch veriﬁcation techniques.

(2) If X is incorrect, then the probability that V outputs

1 is at most 2−λb .

The na¨ıve batch veriﬁer re-computes all instances, i.e., it
consists of computing R(insti) for each i = 1, . . . , D, and
checking that each of these D values is 1.

Assumption 1. Let q be a prime and let p = 2q + 1 be a
strong prime. Let G be the unique cyclic subgroup of Z∗
p of
order q and let g be a generator of G. Then, the discrete
logarithm problem holds if for all eﬃcient algorithms A the
probability

(cid:20) y ← G ; α ← A(p, q, g, y) :

(cid:21)

Prob

0 ≤ α ≤ q − 1 ∧ gα ≡ y mod p

= ν(λ)

is negligible (as a function of λ).
8.1 Building Block

The KR chameleon hash function CH = (Gen, Ch, Col) is

deﬁned as follows:

Gen(1λ): The key generation algorithm picks a prime q such
that p = 2q + 1 is also prime. It also chooses a random
q . It returns (csk, cpk) ←
generator g and a value α ∈ Z∗
((α, g), (X, g, p, q)) with X = gα mod p.

Ch(cpk, x): The input of the hash algorithm is a key cpk =
q . It picks a random

(X, g, p, q) and a message x ∈ Z∗
value r ∈ Z∗

q and outputs gxX r mod p.

Col(csk, x, r, x(cid:48)): The collision ﬁnding algorithm returns r(cid:48) ←

α−1(x − x(cid:48)) + r mod q.

8.2 Batch Veriﬁcation of Chameleon

Hash Functions

The most expensive operation in a CAT of depth D is the
veriﬁcation of an authentication path. This computation in-
volves (in the worst case) D computations of the chameleon
hash function (which is the authentication of the last leaf).
For our concrete instantiation this means that the veriﬁca-
tion algorithm veriﬁes D times equations of the form hi =
gxi X ri . This step is rather expensive as it involves many
modular exponentiations. Instead of verifying all equations
straightforwardly, we apply batch veriﬁcation techniques as
introduced by Bellare, Garay, and Rabin [BGR98]. The ba-
sic idea is to verify sequences of modular exponentiations
signiﬁcantly faster than the na¨ıve re-computation method.
In what follows, let λb be the security parameter such that
the probability of accepting a batch that contains an invalid
hash is at most 2−λb . Note, that it is necessary to test that
all elements belong to the group G as discussed comprehen-
sively by Boyd and Pavlovski in [BP00]. The size of λb is a
trade oﬀ between eﬃciency and security. Therefore, it de-
pends heavily on the application. Camenisch, Hohenberger,
and Pedersen suggest λb = 20 bits for a rough check and
λb = 64 bit for higher security [CHP07].

Deﬁnition 8. A batch veriﬁer for a relation R is a proba-
bilistic algorithm V that takes as input (possibly a descrip-
tion of R) a batch instance X = (inst1, . . . , instD) for R, and
a security parameter λ. It satisﬁes:

(1) If X is correct, then V outputs 1.

1To the best of our knowledge, this instantiation is currently
the most eﬃcient one based on the discrete logarithm as-
sumption in the standard model.

8.2.1

Small Exponent Test for
Chameleon Hash Functions

(cid:80)

D yi = g

check if(cid:81)

Bellare, Garay, and Rabin suggest three diﬀerent methods
of computing batch veriﬁcation for modular exponentiations
[BGR98]. Here, we focus only on the small exponent test be-
cause it is the most eﬃcient one for the veriﬁcation of up to
200 elements. In our scenario, 200 elements means that we
can authenticate 2200 elements. The authors consider equa-
tions of the form yi = gxi . The na¨ıve approach would be to
D xi . This, however, is not suﬃcient as
it is easy to produce two pairs (x1, y1) and (x2, y2) that pass
the veriﬁcation but each individual does not. One example
of such a pair is (x1 − β, y1) and (x2 + β, y2) for any β.
According to [FGHP09], the small exponent test works as
follows: Pick D exponents δi of a small number of {0, 1}λb
D xiδi mod q and y ←
i . Output 1 iﬀ gx = y. The probability of accepting
a bad pair is 2−λb and the value λb is a trade oﬀ between
eﬃciency and security.
8.3 Batch Veriﬁcation of KR Chameleon Hash

at random and compute x ← (cid:80)
(cid:81)

D yδi

Function

The algorithm Batch that performs the batch veriﬁca-
tion of D chameleon hash values h1, . . . , hD on messages
x1, . . . , xD using the randomness r1, . . . , rD works as follows:
It ﬁrst checks that all elements are in the group. If not, then
it rejects the query. Otherwise, it picks D random elements
δ1, . . . , δD where δi ∈ {0, 1}λb and checks that

(cid:80)

(cid:80)

g

D xiδi X

D riδi =

hδi
i .

(cid:89)

D

It outputs 1 if the equation holds and otherwise 0.

Theorem 3. The algorithm Batch is a batch veriﬁer for

the KR chameleon hash function.

The following proof follows the proofs of [CHP07, BGR98].

Proof. We ﬁrst show that if all hash values have the
desired form, then our batch veriﬁcation algorithm accepts
with probability 1. Keeping in mind that the validation of
the hash function checks that hi = gxi X ri , then we can
easily show that

(cid:80)

g

D xiδi X

(cid:80)

(cid:89)

(cid:89)
(cid:89)

D

D riδi =

=

hδi
i =

(gxi X ri )δi

D

gxiδi X riδi = g

D xiδi X

(cid:80)

(cid:80)

D riδi .

D

The next step is to show that the other direction is also
true. To do so, we apply the technique for proving small
exponents test as in [BGR98]. Since our batch veriﬁcation
algorithm accepts, it follows that hi ∈ G. This allows us to
write hi = gρi for some ρi ∈ Zq. Moreover, we know that
X = gx for some x ∈ Zq. We then can re-write the above

961equation as(cid:89)

D

hδi
i = gρiδi = g

D δi(mi+αri)

⇒(cid:88)
⇒(cid:88)

D

D

ρiδi =

(cid:80)
(cid:88)
ρiδi −(cid:88)
(cid:89)

D

D

D

δi(xi + αri)

δi(xi + αri) ≡ 0 mod q.

Setting βi = ρi − (xi + αri) this is equivalent to:

δiβi ≡ 0 mod q.

(1)

D(cid:88)

δ1 = −γ1

Now, assume that Batch((h1, x1, r1), . . . , (hD, xD, rD)) out-
puts 1, but there exists an index i = 1 (this holds w.l.o.g.)
such that gx1δ1 X r1δ1 (cid:54)= hδ1
1 . In particular, this means that
β1 (cid:54)= 0. Since q is prime, then β1 is the inverse of γ1 such
that β1γ1 ≡ 1 mod q. Taking this and Equation (1), we
obtain

δiβi mod q.

(2)

i=2

Now, given the elements ((h1, x1, r1), . . . , (hD, xD, rD)) such
that Batch((h1, x1, r1), . . . , (hD, xD, rD)) = 1 and let bad
denote the event that we break the batch veriﬁcation, i.e.,
gx1δ1 X r1δ1 (cid:54)= hδ1
1 . Observe that we do not make any as-
sumptions about the remaining values. Let ∆(cid:48) = δ2, . . . , δD
and let |∆(cid:48)| be the number of possible values for this vec-
tor. It follows from Equation 2 and from the fact that ∆(cid:48) is
ﬁxed that there exists exactly one value δ1 that will make
bad happen. This means, however, that the probability that
bad occurs is Prob[ bad | ∆(cid:48) ] = 2−λb . Choosing the value δ1
at random and summing over all possible choices of ∆(cid:48), we
i=1(Prob [ bad | ∆(cid:48) ] · Prob [ ∆(cid:48)]). Thus,
we can calculate the overall probability as Prob [ bad] ≤

get Prob [ bad] ≤ (cid:80)∆(cid:48)
(cid:80)2λb (D−1)

(2λb · 2−λb(D−1)) = 2−λb .

i=1

8.4 Efﬁciency

tions. First, we have to compute(cid:81)

We analyze the eﬃciency of our batch veriﬁer for the KR
chameleon hash using the following notation. By exp(k1)
we denote the time to compute gb in the group G where
|b| = k1. The eﬃciency is measured in number of multiplica-
i . Instead of comput-
ing this product straightforwardly, we apply the algorithm
FastMult((h1, δ1), . . . , (hD, δD)) obtaining a total number of
λb + Dλb/2 multiplications on the average [BGR98]. In ad-
dition we have to compute 2D multiplications and ﬁnally
2exp(k1) exponentiations. Thus, the total number of multi-
plications is λb + D(2 + λb/2) + 2exp(k1).
8.5 Benchmarking Results

a hδi

We estimate the performance of our scheme by analyzing
the most expensive component of our construction. That
is, we have implemented the KR chameleon hash function
and we use the implementation of SHA1 provided by the
Java security package. These are the two main components
of our construction. The additional overhead determining
the nodes should add only a negligible overhead to the over-
all computational costs (recall that computing a chameleon
hash involves modular exponentiations, which we believe
is the most expensive step). We have implement the KR
chameleon hash in Java 1.6 on a Intel Core i5 using 4GB

1333MHz DDR3 RAM. We have conducted two diﬀerent ex-
periments where we executed each algorithm 500 times with
a CAT of depth 80 (thus it authenticates 280 elements). The
bit length of the primes in the ﬁrst experiment is 1024 bits
and in the second 2048 bits. The following values are the
average computational costs. Adding a leaf to the tree in the
worst case (this happens when the tree is empty) takes on
average 283ms for 1024 bits and 1400ms for 2048 bits. Each
of these executions involves 40 evaluations of the chameleon
hash (including the generation of randomness), 40 SHA1
computations, and the computation of a collision. The tim-
ings to verify a path and to update it are slightly faster,
because both operations do neither include the generation
of random values, nor the computation of a collision. In the
full version of this paper, we will include running times of
the full implementation.
9. FROM ONE-TIME TO MANY-TIME

SIGNATURE SCHEMES USING CATS

The second application of CATs is a new transforma-
tion that turns any one-time signature (OTS) scheme into a
many-time signature (MTS) scheme. A one-time signature
scheme allows a user to sign a single message. This primitive
is well-known and has been introduced by Lamport [Lam79]
and Rabin [Rab79]. One-time signature schemes are inter-
esting from both, a theoretical and a practical point of view.
Theoreticians study the primitive because it is used as a
building block in realizing secure signature schemes based
on one-way functions (in a black-box way). On the other
hand, several extremely eﬃcient instantiations have been
suggested in practice. However, the “one-timeness” of such
schemes regrettably causes a complex key-scheduling process
since the signer has to generate a new key pair whenever it
wishes to sign a new message. Motivated by this drawback
– and also by the hope of obtaining an eﬃcient many-time
signature scheme – several publications investigate eﬃcient
transformations from a OTS to a MTS scheme.
9.1 Construction

The basic idea of our construction is to store the keys
of the one-time signature scheme in the leaves of the CAT.
Since the keys are generated uniformly at random (and in
particular, independent of the message to be signed) a weaker
security notion than the one giving in Deﬁnition 4.2 is suf-
ﬁcient. We refer the reader to the full version [SS12].

Construction 3. Let Sig = (Gen, Sign, Vrfy) be a signature
scheme deﬁned over the message space M = {0, 1}λ and
let wCAT = (wcatGen, waddLeaf, wcatVrfy) be a chameleon
authentication tree. We deﬁne the signature scheme cSig =
(cGen, cSign, cVrfy) as follows:
cGen(1λ): The key generation algorithm runs (wsp, wvp) ←
It returns the private key SK ← wsp,

wcatGen(1λ).
and the corresponding public key PK ← wvp.

cSign(SK, m): To sign a message m ∈ {0, 1}λ, the signing
algorithm generates a key pair (SK(cid:48), PK(cid:48)) ← Gen(1λ),
signs the message σ0 ← Sign(SK(cid:48), m), and adds the
public key to the CAT by computing (wsp(cid:48), i, waPath) ←
waddLeaf(wsp, PK(cid:48)). It sets σ1 ← (i, waPath) and re-
turns the signature σ ← (σ0, σ1, PK(cid:48)).

cVrfy(PK, m, σ): The veriﬁcation algorithm parses PK =
It

wvp and σ = (σ0, σ1, PK(cid:48)) and σ1 = (i, waPath).

962outputs 1 if both condition hold: catVrfy(wvp, i, PK(cid:48),
aPath) = 1 and Vrfy(PK(cid:48), m, σ0) = 1.

As already discussed in Section 6.1, the security of our con-
struction holds for a tree that authenticates an exponential
number of 2D signatures. Again, this follows from our con-
struction (as we never store all elements at the same time).
Let q := q(λ) be an upper bound on the number of signing
queries from the adversary. Then, we distinguish the case
where the adversary outputs a forgery for a leaf 1 ≤ i∗ ≤ q
and the case where q + 1 ≤ i∗ ≤ 2D. In the ﬁrst case, where
1 ≤ i∗ ≤ q is, we build an adversary that either breaks
the structure-preserving property of the CAT or that forges
the one-time signature scheme. In the second case, where
q + 1 ≤ i∗ ≤ 2D is, we show how to beak the one-wayness
the CAT.

Theorem 4. If Sig is a secure one-time signature scheme
and CAT a weakly structure-preserving and weakly one-way
chameleon authentication tree, then Construction 3 is un-
forgeable under adaptive chosen message attacks.

The proof is giving in the full version of this paper [SS12].
Acknowledgements
We are very thankful to Nick Hopper for his comprehen-
sive suggestions. We thank Marc Fischlin for suggesting
batch veriﬁcation techniques to improve the running time of
our veriﬁcation algorithm. We also thank the anonymous
reviewers for valuable and comprehensive comments. This
work was supported by the German Ministry for Educa-
tion and Research (BMBF) through funding for the Cen-
ter for IT-Security, Privacy and Accountability (CISPA —
www.cispa-security.de) and by CASED — www.cased.de.
This work was partially supported by the US Army Research
Laboratory and the UK Ministry of Defense under Agree-
ment Number W911NF-06-3-0001. The views and conclu-
sions contained in this document are those of the authors
and should not be interpreted as representing the oﬃcial
policies, either expressed or implied, of the US Army Re-
search Laboratory, the US Government, the UK Ministry of
Defense, or the UK Government. The US and UK Govern-
ments are authorized to reproduce and distribute reprints for
Government purposes, notwithstanding any copyright nota-
tion herein.
10. REFERENCES
[Ad04]

Giuseppe Ateniese and Breno de Medeiros. On
the key exposure problem in chameleon hashes.
In Carlo Blundo and Stelvio Cimato, editors,
SCN 04: 4th International Conference on
Security in Communication Networks, volume
3352 of Lecture Notes in Computer Science,
pages 165–179, Amalﬁ, Italy, September 8–10,
2004. Springer, Berlin, Germany.

[BDK+07] Johannes Buchmann, Erik Dahmen, Elena
Klintsevich, Katsuyuki Okeya, and Camille
Vuillaume. Merkle signatures with virtually
unlimited signature capacity. In Jonathan
Katz and Moti Yung, editors, ACNS 07: 5th
International Conference on Applied
Cryptography and Network Security, volume
4521 of Lecture Notes in Computer Science,
pages 31–45, Zhuhai, China, June 5–8, 2007.
Springer, Berlin, Germany.

[BGR98] Mihir Bellare, Juan A. Garay, and Tal Rabin.

[BGV11]

[BP00]

[CF11]

[CHP07]

Fast batch veriﬁcation for modular
exponentiation and digital signatures. In Kaisa
Nyberg, editor, Advances in Cryptology –
EUROCRYPT’98, volume 1403 of Lecture
Notes in Computer Science, pages 236–250,
Espoo, Finland, May 31 – June 4, 1998.
Springer, Berlin, Germany.
Siavosh Benabbas, Rosario Gennaro, and
Yevgeniy Vahlis. Veriﬁable delegation of
computation over large datasets. In Phillip
Rogaway, editor, Advances in Cryptology –
CRYPTO 2011, volume 6841 of Lecture Notes
in Computer Science, pages 111–131, Santa
Barbara, CA, USA, August 14–18, 2011.
Springer, Berlin, Germany.
Colin Boyd and Chris Pavlovski. Attacking
and repairing batch veriﬁcation schemes. In
Tatsuaki Okamoto, editor, Advances in
Cryptology – ASIACRYPT 2000, volume 1976
of Lecture Notes in Computer Science, pages
58–71, Kyoto, Japan, December 3–7, 2000.
Springer, Berlin, Germany.
Dario Catalano and Dario Fiore. Vector
commitments and their applications.
Cryptology ePrint Archive, Report 2011/495,
2011. http://eprint.iacr.org/.
Jan Camenisch, Susan Hohenberger, and
Michael Østergaard Pedersen. Batch
veriﬁcation of short signatures. In Moni Naor,
editor, Advances in Cryptology –
EUROCRYPT 2007, volume 4515 of Lecture
Notes in Computer Science, pages 246–263,
Barcelona, Spain, May 20–24, 2007. Springer,
Berlin, Germany.

[CKLR11] Kai-Min Chung, Yael Tauman Kalai, Feng-Hao

[CKS09]

[CL02]

Liu, and Ran Raz. Memory delegation. In
Phillip Rogaway, editor, Advances in
Cryptology – CRYPTO 2011, volume 6841 of
Lecture Notes in Computer Science, pages
151–168, Santa Barbara, CA, USA,
August 14–18, 2011. Springer, Berlin,
Germany.
Jan Camenisch, Markulf Kohlweiss, and
Claudio Soriente. An accumulator based on
bilinear maps and eﬃcient revocation for
anonymous credentials. In Stanislaw Jarecki
and Gene Tsudik, editors, PKC 2009: 12th
International Conference on Theory and
Practice of Public Key Cryptography, volume
5443 of Lecture Notes in Computer Science,
pages 481–500, Irvine, CA, USA, March 18–20,
2009. Springer, Berlin, Germany.
Jan Camenisch and Anna Lysyanskaya.
Dynamic accumulators and application to
eﬃcient revocation of anonymous credentials.
In Moti Yung, editor, Advances in Cryptology
– CRYPTO 2002, volume 2442 of Lecture
Notes in Computer Science, pages 61–76,
Santa Barbara, CA, USA, August 18–22, 2002.
Springer, Berlin, Germany.

[CMT12] Graham Cormode, Michael Mitzenmacher, and

963[FB06]

Justin Thaler. Practical veriﬁed computation
with streaming interactive proofs. In
Innovations in Theoretical Computer Science
(ITCS), 2012.
D´ecio Luiz Gazzoni Filho and Paulo S´ergio
Licciardi Messeder Barreto. Demonstrating
data possession and uncheatable data transfer.
Cryptology ePrint Archive, Report 2006/150,
2006. http://eprint.iacr.org/.

[NY89]

Journal on Selected Areas in Communications,
18(4):561–570, 2000.
Moni Naor and Moti Yung. Universal one-way
hash functions and their cryptographic
applications. In 21st Annual ACM Symposium
on Theory of Computing, pages 33–43, Seattle,
Washington, USA, May 15–17, 1989. ACM
Press.

[oCMoP12] University of California Museum of

[FGHP09] Anna Lisa Ferrara, Matthew Green, Susan

[GMR88]

[KR00]

[Lam79]

[Mer88]

[Mer90]

Hohenberger, and Michael Østergaard
Pedersen. Practical short signature batch
veriﬁcation. In Marc Fischlin, editor, Topics in
Cryptology – CT-RSA 2009, volume 5473 of
Lecture Notes in Computer Science, pages
309–324, San Francisco, CA, USA,
April 20–24, 2009. Springer, Berlin, Germany.
Shaﬁ Goldwasser, Silvio Micali, and Ronald L.
Rivest. A digital signature scheme secure
against adaptive chosen-message attacks.
SIAM Journal on Computing, 17(2):281–308,
April 1988.
Hugo Krawczyk and Tal Rabin. Chameleon
signatures. In ISOC Network and Distributed
System Security Symposium – NDSS 2000, San
Diego, California, USA, February 2–4, 2000.
The Internet Society.
Leslie Lamport. Constructing digital
signatures from a one-way function. Technical
Report SRI-CSL-98, SRI International
Computer Science Laboratory, October 1979.
Ralph C. Merkle. A digital signature based on
a conventional encryption function. In Carl
Pomerance, editor, Advances in Cryptology –
CRYPTO’87, volume 293 of Lecture Notes in
Computer Science, pages 369–378, Santa
Barbara, CA, USA, August 16–20, 1988.
Springer, Berlin, Germany.
Ralph C. Merkle. A certiﬁed digital signature.
In Gilles Brassard, editor, Advances in
Cryptology – CRYPTO’89, volume 435 of
Lecture Notes in Computer Science, pages
218–238, Santa Barbara, CA, USA,
August 20–24, 1990. Springer, Berlin,
Germany.

[Ngu05]

[MND+01] Chip Martel, Glen Nuckolls, Prem Devanbu,
Michael Gertz, April Kwong, and Stuart G.
Stubblebine. A general model for authenticated
data structures. Algorithmica, 39:2004, 2001.
Moni Naor. Bit commitment using
pseudorandomness. Journal of Cryptology,
4(2):151–158, 1991.
Lan Nguyen. Accumulators from bilinear
pairings and applications. In Alfred Menezes,
editor, Topics in Cryptology – CT-RSA 2005,
volume 3376 of Lecture Notes in Computer
Science, pages 275–292, San Francisco, CA,
USA, February 14–18, 2005. Springer, Berlin,
Germany.
Moni Naor and Kobbi Nissim. Certiﬁcate
revocation and certiﬁcate update. IEEE

[Nao91]

[NN00]

[PT07]

[Rab79]

Paleontology. The eﬀects of mutations.
understanding evolution., 2012. Last access
05/03/12 - http://evolution.berkeley.edu/
evolibrary/article/0_0_0/mutations_05.
Charalampos Papamanthou and Roberto
Tamassia. Time and space eﬃcient algorithms
for two-party authenticated data structures. In
Proceedings of the 9th international conference
on Information and communications security,
ICICS’07, pages 1–15, Berlin, Heidelberg,
2007. Springer-Verlag.
Michael O. Rabin. Digital signatures and
public key functions as intractable as
factorization. Technical Report
MIT/LCS/TR-212, Massachusetts Institute of
Technology, January 1979.

[RLB+08] Andy Rupp, Gregor Leander, Endre Bangerter,

Alexander W. Dent, and Ahmad-Reza
Sadeghi. Suﬃcient conditions for intractability
over black-box groups: Generic lower bounds
for generalized DL and DH problems. In Josef
Pieprzyk, editor, Advances in Cryptology –
ASIACRYPT 2008, volume 5350 of Lecture
Notes in Computer Science, pages 489–505,
Melbourne, Australia, December 7–11, 2008.
Springer, Berlin, Germany.
Thomas Schwarz and Ethan L. Miller. Store,
forget, and check: Using algebraic signatures
to check remotely administered storage.
Proceedings of the IEEE Int’l Conference on
Distributed Computing Systems (ICDCS ’06),
July 2006.
Dominique Schr¨oder and Heike Schr¨oder.
Veriﬁable data streaming. Cryptology ePrint
Archive, Report 2012, 2012. Full version,
available at http://eprint.iacr.org/.
Hovav Shacham and Brent Waters. Compact
proofs of retrievability. In Josef Pieprzyk,
editor, Advances in Cryptology –
ASIACRYPT 2008, volume 5350 of Lecture
Notes in Computer Science, pages 90–107,
Melbourne, Australia, December 7–11, 2008.
Springer, Berlin, Germany.
Michael Szydlo. Merkle tree traversal in log
space and time. In Christian Cachin and Jan
Camenisch, editors, Advances in Cryptology –
EUROCRYPT 2004, volume 3027 of Lecture
Notes in Computer Science, pages 541–554,
Interlaken, Switzerland, May 2–6, 2004.
Springer, Berlin, Germany.
Roberto Tamassia and Nikos Triandopoulos.
Certiﬁcation and authentication of data
structures. In AMW, 2010.

[SM06]

[SS12]

[SW08]

[Szy04]

[TT10]

964