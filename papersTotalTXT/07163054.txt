2015 IEEE Symposium on Security and Privacy
2015 IEEE Symposium on Security and Privacy

A Generic Approach to Automatic Deobfuscation of Executable Code

Babak Yadegari

Brian Johannesmeyer

Benjamin Whitely

Saumya Debray

Department of Computer Science

The University of Arizona

{babaky, bjohannesmeyer, whitely, debray}@cs.arizona.edu

Tucson, AZ 85721

Abstract—Malicious software are usually obfuscated to avoid
detection and resist analysis. When new malware is encountered,
such obfuscations have to be penetrated or removed (“deobfus-
cated”) in order to understand the internal logic of the code
and devise countermeasures. This paper discusses a generic
approach for deobfuscation of obfuscated executable code. Our
approach does not make any assumptions about the nature of the
obfuscations used, but instead uses semantics-preserving program
transformations to simplify away obfuscation code. We have
applied a prototype implementation of our ideas to a variety
of different kinds of obfuscation,
including emulation-based
obfuscation, emulation-based obfuscation with runtime code
unpacking, and return-oriented programming. Our experimental
results are encouraging and suggest that this approach can be
effective in extracting the internal logic from code obfuscated
using a variety of obfuscation techniques, including tools such as
Themida that previous approaches could not handle.

Keywords-Deobfuscation; Virtualization-Obfuscation; Return

Oriented Programming

I. INTRODUCTION

Malicious software are usually deployed in heavily ob-
fuscated form, both to avoid detection and also to hinder
reverse engineering by security analysts. Much of the research
to date on automatic deobfuscation of code has focused on
obfuscation-speciﬁc approaches. While important and useful,
such approaches are of limited utility against obfuscations
that are different from the speciﬁc ones they target, and
therefore against new obfuscations not previously encountered.
We aim to address this problem via a generic semantics-based
approach to deobfuscation; in particular, this paper focuses
on two very different kinds of programming/obfuscation tech-
niques that can be challenging to reverse engineer: emulation-
based obfuscation and return-oriented programming.

In emulation-based obfuscation, the computation being ob-
fuscated is implemented using an emulator for a custom-
generated virtual machine together with a byte-code-like rep-
resentation of the program’s logic [1]–[4]. Examination of the
obfuscated code reveals only the emulator’s logic, not that of
the emulated code. Existing techniques for reverse engineering
emulation-obfuscated code ﬁrst reconstruct speciﬁcs of the
virtual machine emulator, then use this to decipher individual
byte code instructions, and ﬁnally recover the logic embedded
in the byte code program [5]. Such approaches typically make
strong assumptions about the structure and properties of the
emulator and may not work well if the analyzer’s assumptions
do not ﬁt the code being analyzed, e.g., if parts of the emulator

are unpacked at runtime [4] or if there are multiple layers of
interpretation with distinct virtual program counters that are
difﬁcult to tease apart. The work of Coogan et al. [6] has
similar goals to us, but is based on equational reasoning about
assembly-level instruction semantics, which is technically very
different from our work (see Section VI) and has the short-
coming that controlling the equational reasoning process can
be challenging, making it difﬁcult to recover the logic of the
underlying computation into a program representation such as
control ﬂow graphs.

A second class of programs that can be challenging to
reverse-engineer are return-oriented programs (ROP) [7], [8].
While originally devised to bypass defenses against code
injection, this programming technique can result in highly
convoluted control ﬂow between many small gadgets, leading
to program logic that can be tricky to decipher. Other than the
work of Lu et al. [9], there has been little work on automatic
deobfuscation of ROPs.

This paper describes a generic approach to deobfuscation of
executable code that is conceptually simpler and more general
than those described above. Obfuscation-speciﬁc approaches
have the signiﬁcant limitation that they can only be effective
against previously-seen obfuscations; they are, unfortunately,
of limited utility when confronted by new kinds of obfusca-
tions or new combinations of obfuscations that violate their
assumptions. Our work on generic deobfuscation is motivated
by the need for deobfuscation techniques that can be effective
even when applied to previously unseen obfuscations. The
underlying intuition is that the semantics of a program can be
understood as a mapping, or transformation, from input values
to output values. Deobfuscation thus becomes a problem of
identifying and simplifying the code that effects this input-
to-output transformation. We use taint propagation to track
the ﬂow of values from the program’s inputs to its outputs,
and semantics-preserving code transformations to simplify the
logic of the instructions that operate on and transform values
through this ﬂow. We make few if any assumptions about
the nature of the any obfuscation being used, whether that
be emulation, or ROP, or anything else. Experiments using
several emulation-obfuscation tools, including Themida, Code
Virtualizer, VMProtect, and ExeCryptor, as well as a number
of return-oriented implementations of programs, suggest that
the approach is helpful
in reconstructing the logic of the
original program.

© 2015, Babak Yadegari. Under license to IEEE.
© 2015, Babak Yadegari. Under license to IEEE.
DOI 10.1109/SP.2015.47
DOI 10.1109/SP.2015.47

674
674

II. BACKGROUND

A. Emulation-based Obfuscation

In emulation-based obfuscation, a program P is represented
using the instruction set of virtual machine VP and interpreted
using a custom emulator IP for VP . A common representation
choice for P is as a sequence of byte code instructions
BP for VP , where the emulator IP uses the familiar fetch-
decode-execute loop of byte-code interpreters; however, other
interpreter implementations, such as direct or indirect thread-
ing, are also possible. The instruction set for VP can be
perturbed randomly such that different instances of VP look
very different even if the program P does not change. Further,
emulation can be combined with other obfuscations, such as
run-time code unpacking, to further complicate analysis.

Reverse engineering of emulation-obfuscated code is chal-
lenging because examining the code for the emulator IP
reveals very little about the logic of the original program P ,
which is actually embedded in the byte-code program BP . For
example, an execution trace of the emulator IP on the byte-
code program BP will show only the instructions in the emula-
tor IP . Memory accesses in this trace will contain a mixture of
the data manipulation behavior of the original program P and
memory operations pertaining to the operation of the emulator
IP ; teasing these apart to isolate the memory operations of
only the original program P , or only the emulator IP , can be
challenging. Control transfers in the trace, similarly, will be
a mixture of those stemming from the logic of P and those
corresponding to the dispatch loop of IP .

B. Return-Oriented Programming

Return-oriented programming (ROP) was introduced as a
way to bypass Data Execution Prevention and other defenses
against code injection attacks [7], [8]. It uses a multitude of
“gadgets,” which are small snippets of code ending in return
instructions, that are present in the existing code in a computer
system, whether in the kernel, libraries, or running applica-
tions. Each gadget achieves a small piece of computational
functionality. The gadgets are strung together by writing their
addresses as a contiguous sequence into a buffer that is then
used to effect a chain of return actions: each return then causes
the invocation of the next gadget in the buffer. This basic idea
has been generalized in various ways to obviate the need for
explicit return instructions [10], [11].

There are a number of characteristics of ROPs that can
make reverse engineering challenging. The ﬁrst is that the
code for a ROP can be scattered across many different
functions and/or libraries, making it difﬁcult to discern the
logical structure of the code. If these libraries employ Address
Space Layout Randomization, or are loaded into dynamically
allocated memory, they may occur at different addresses. ROP
sequences can take advantage of this fact by being generated
just-in-time for the attack, making it difﬁcult to examine what
the ROP sequence will do without knowledge of the memory
space of the target machine. Secondly, since ROP gadgets are
constructed opportunistically from whatever code is already

available on a system, they may contain “useless” instructions
(from the gadget’s perspective) that can be tolerated as long
as they do not interfere with the desired functionality of the
gadget. However, this opens up the possibility that the same
gadget can be invoked in different ways at different times,
where a given instruction within the gadget may serve a
useful purpose in some invocations and be useless in others.
Finally, gadgets can overlap in memory in ways not usually
encountered in ordinary programs.

C. Threat Model

Our threat model assumes that the adversary knows our
semantics-based approach to deobfuscation as described in
this paper, as well as some—but not necessarily all—of
the transformation rules used for trace simpliﬁcation. The
latter assumption is justiﬁed by the fact that our approach
is parameterized by the set of transformation rules used, and
these rules do not form a static set but can be augmented with
new rules as needed or desired.

III. OUR APPROACH

We use the term deobfuscation to refer to the process of
removing the effects of obfuscation from a program—i.e.,
given an obfuscated program P , analyzing and transforming
the code for P to obtain a program P (cid:2) that is functionally
equivalent to P but is simpler and easier to understand.

A. Overview

Any approach to deobfuscation needs to start out by
identifying something in the code (or its computation) as
“semantically signiﬁcant;” this is then used as the basis
for subsequent analysis. For example, when disassembling
obfuscated binaries, Kruegel et al. begin by identifying control
transfer instructions [12]. Automatic unpacking tools such as
Renovo [13] look for memory locations that are written to and
then executed. More directly relevant to this work, Sharif et
al. use memory access characteristics of emulation-obfuscated
code to identify the emulator’s virtual program counter, which
they then use to reverse-engineer the emulator [5]. Typically,
such notions of semantic signiﬁcance are based on speciﬁc
aspects of the code that are either preserved by the obfuscation
(e.g., control transfers in the work of Kruegel et al. [12])
or else are introduced by the obfuscation (e.g., write-then-
execute memory locations for unpacked code [13], emulator
components in the work of Sharif et al. [5]). In each case, the
notion of what constitutes semantically signiﬁcant code, and
the process of identifying such code, is intimately tied to the
particular obfuscation(s) being considered.

While such obfuscation-speciﬁc assumptions may simplify
the process of deobfuscation, they have two drawbacks. First,
such assumptions limit
the future applicability of the de-
obfuscation technique to new and as-yet-unseen types of
obfuscation. Second, they may provide an adversary a point
of attack against the deobfuscation technique by perturbing
existing obfuscation techniques in a way that violates the

675675

binary
input

Collect

Instructions Trace

T1

Generate other inputs

Path Exploration

Concolic Execution

Constraint Solver

Flow Analysis

Initial CFG

Forward/Backward

Taint Analysis

Control

Dependencies

T2

Code Simpliﬁcation

Transformations

T3

Construct
Final CFG

Final CFG

Fig. 1. Overview of the deobfuscation. T1 is the original trace, consisting of instructions and register values. T2 is a trace with taint analysis and control
dependence information and T3 is a simpliﬁed trace from which a ﬁnal control ﬂow graph is constructed.

assumptions (an example we encountered recently is illustrated
in Figure 10 and discussed in Section VI).

In our case, therefore, we want to minimize assumptions
about the obfuscated code; in particular, we do not want to
presuppose that any particular kind of obfuscation is being
used. Since the identiﬁcation of semantically signiﬁcant code
is typically closely tied to the obfuscations under considera-
tion, this poses a quandary: what can be considered signiﬁcant
without making assumptions about what obfuscations are
being used? To address this, we take an approach inspired
by a notion of program semantics where programs are seen
as mappings, or transformations, from inputs to outputs [14].
Since malicious code often involves self-modifying and/or
dynamically unpacked code, which is difﬁcult
to analyze
statically, we use dynamic analysis: we collect one or more
execution traces of the program, then analyze and simplify
these traces. Our approach consists of the following steps:

a) Identifying Input and Output Values: We consider the
notion of “input” broadly so as to comprise values obtained
from the command line and execution environment of the pro-
cess (e.g., the Process Environment Block, which is sometimes
used by malware to check whether it is being debugged or
otherwise monitored, e.g., see [15]) as well as those obtained
via explicit input operations; similarly, the notion of “output”
is considered to be any externally observable side effect (e.g.,
creation or deletion of ﬁles or processes) as well as the results
of explicit output operations and computations.

In our current prototype implementation, input and output
values are determined as follows. Any value that is obtained
from the command line, or which is deﬁned (written) by a
library routine and subsequently read by an instruction in the
program, is treated as an input value; any value that is deﬁned
(written) by an instruction in the program and subsequently
read by a library routine is treated as an output value.1 Our
dynamic analysis environment, which uses a modiﬁed version
of Ether [16], collects execution traces for library routines as
well as the main program, and the ﬂow of values written within
the program and subsequently read within a library routine,
or vice versa, can be determined by examining the trace. We
use a combination of taint propagation and control-dependence

1This is an over-approximation, since not all library routines interact with
the program’s execution environment, and so may sometimes lead to a loss
in precision of analysis. However, it is conservative.

676676

analysis to identify instructions in the execution trace that are
inﬂuenced by input values and/or inﬂuence output values.

b) Forward taint propagation: After identifying Input
sources, we should propagate the input taint through the trace
to ﬁnd all the instructions which are inﬂuenced by input values.
In order to do this, we use a taint propagation technique which
is a well-known and useful analysis tool in the ﬁelds of static
and dynamic analysis. It turns out that a conventional byte-
level taint analysis is not precise enough for our needs, so
we use an enhanced bit-level taint-analysis [17]. This initial
computation captures explicit information ﬂow from input to
output, but does not capture implicit ﬂows, i.e., associations
between data values that arise due to control dependencies
rather than data dependencies. To this end, we use dependence
analysis to identify control dependencies, which we then
combine with the explicit data dependencies identiﬁed earlier
to capture implicit as well as explicit ﬂow of information from
inputs to outputs.

As mentioned before, dynamic analysis is more powerful
when dealing with self-modiﬁcation or run-time code unpack-
ing but we also need to address the possible low-code coverage
issue resulting from recording one execution path. In order to
solve this problem we have implemented a concolic execution
system which can operate on a trace and produce constraints
to solve for other possible inputs to the program to record
other execution paths. We can feed both the obfuscated trace
and the simpliﬁed one to produce alternative inputs to the
program. There have been many studies on symbolic execution

c) Code Simpliﬁcation: Once we have identiﬁed the
input-to-output value ﬂows, we iteratively apply semantics-
preserving code transformations to simplify the execution
trace. The resulting simpliﬁed trace represents the behavior of
a program that is functionally equivalent to the original pro-
gram (at least for the particular execution that was observed)
but which is simpler.

d) Control Flow Graph Construction: The simpliﬁed
trace is used to construct a control ﬂow graph (CFG) that
makes explicit some of the higher-level control ﬂow structures
such as conditionals and loops. The ﬁnal step of our deobfus-
cation process is to apply semantics-preserving transforma-
tions to the CFG to eliminate some spurious execution paths
and produce a more precise CFG. The resulting simpliﬁed
CFG is then produced as the output of our deobfuscation
system.

and multi-path exploration techniques (e.g [18]–[21]) so we
do not discuss the details here. Figure 1 gives a high level
overview of our approach. We discuss each of these steps in
more detail below.

B. Identifying Input-to-Output Flows

The ﬁrst step of our algorithm is to identify the ﬂow of
values from input operations to output operations, and thereby
the instructions that transform input values to output values.
To this end, we ﬁrst use taint propagation to identify the
explicit ﬂow of values from inputs to outputs, then use control
dependence analysis to identify implicit ﬂows.

1) Taint Analysis: Taint analysis ﬁnds many important
applications in dynamic security analysis. We use it to identify
the runtime ﬂow of values from a program’s inputs to its
outputs; this information is then used for control dependency
analysis. The essential idea is to associate each value computed
by the program with a bit indicating whether or not it is
“tainted,” i.e., derived directly or indirectly from an input
value. Initially, only values that are obtained directly from
inputs are marked as tainted. Taint is then propagated itera-
tively to other values by marking any value that is computed
from a tainted value as tainted. There is a considerable body
of literature on taint analysis (e.g., see the paper by Schwartz
et al. [22]) so we omit the details of the algorithm.

Our approach uses two kinds of taint analysis:
1) Forward taint analysis. This is used to identify the ﬂow
of input values through the program. It is especially
important for ﬁnding code that is control dependent on
input values. We perform taint analysis for registers,
memory, and condition-code ﬂags.

2) Backward taint analysis. This starts from output values
and works backwards identifying variables and values
that inﬂuence the program’s outputs. In some ways this
resembles dynamic program slicing where the slicing
criterion is the program’s observable output. This is im-
portant because static statements under dynamic controls
which affect the output should not be simpliﬁed away.
The precision of the forward taint analysis is particularly
important because the rest of the deobfuscation depends sig-
niﬁcantly on how well the taint analysis identiﬁes the decision
points in the program being examined. As discussed in more
detail later, when simplifying the code it is important to iden-
tify static computations whose iteration counts are inﬂuenced
by dynamic input, e.g. loops where the iteration is determined
by input values, and imprecision in taint propagation adversely
affects the deobfuscation of such loops, e.g., under-tainting
leads to too much of the code getting simpliﬁed away, and
over-tainting leads to too little simpliﬁcation.

It turns out that traditional byte- or word-level taint analysis
is too imprecise for our needs and can result in signiﬁcant over-
tainting. To address this problem, we use an enhanced taint-
analysis that differs from conventional taint analyses in two
ways. First, in order to deal with obfuscated code—including
obfuscations that scramble together the bits from different
words—we maintain and propagate taint information at the

level of individual bits. Second, instead of simply indicating
taintedness via a single bit, indicating whether or not a location
is tainted or not, we keep track of the source of each distinct
taint value [17]. Keeping track of taint sources turns out to
be very helpful for reasoning about the taint of the result
of an operation where both inputs originate from the same
value; it turns out that such operations are often used in
obfuscated code to construct opaque predicates or constants
[23]. The propagation of taint values is conceptually analogous
to traditional taint analysis, though arithmetic operations have
to be handled carefully, e.g., a single tainted bit in a source
operand for an add instruction can cause several bits to
become tainted in the result due to carry propagation. This
enhanced taint analysis Indeed, ROPs frequently use the carry
ﬂag for conditional statements.

As mentioned earlier, the precision of the forward taint
analysis algorithm is particularly important for our approach to
deobfuscation. Figure 2 illustrates the impact of different taint
propagation algorithms on the quality of deobfuscation. The
input program is a simple binary search routine whose control
ﬂow graph is shown in Figure 2(a). The control ﬂow graph
of the program resulting from obfuscating this code using a
commercial obfuscation tool named ExeCryptor [2] is shown
in Figure 2(b). Figure 2(c) shows the effect of deobfuscation
using traditional byte-level taint analysis: this can be seen to be
only marginally better that Figure 2(b), indicating that the taint
propagation is of limited utility. When a bit-level taint analysis
is used, the quality of deobfuscation improves considerably,
as shown by the control ﬂow graph in Figure 2(d); however,
although this control ﬂow graph is much simpler than that
of Figure 2(c), it can be seen to still be signiﬁcantly more
convoluted than the original control ﬂow graph of Figure 2(a).
However, using our enhanced bit-level taint analysis, which
tracks taintedess together with taint source information at the
level of individual bits, the deobfuscation process yields much
better results, as shown by the control ﬂow graph of Figure
2(e).

2) Control Dependency Analysis: Given two instructions
(statements) I and J in a program, J is said to be control-
dependent on I if the outcome of I determines whether or
not J is executed. More formally, J is control dependent
on I if and only if there is a non-empty path π from
I to J such that J post-dominates each instruction in π
except I [24]. The identiﬁcation of control dependencies has
been well-studied in the compiler literature [24]. However,
the situation is a little different in our case since, because
when dealing with emulation-obfuscated code, some of the
control transfers encountered correspond to the logic of the
program being emulated while others are simply an artifact
of the emulation process and therefore not interesting from
the perspective of identifying dependencies. We want to ﬁnd
control dependencies of the original program, but we cannot
do this simply by examining the control ﬂow graph of the
emulator, so we need to untangle the emulator’s control ﬂow
structure apart from that of the original program.

677677

(a)

Key:
(a)
(b)
(c)
(d)
(e)

(b)

(c)

(d)

(e)

Original program
Obfuscated program
Deobfuscation result: traditional byte-level taint analysis
Deobfuscation result: bit-level analysis (taintedness information only)
Deobfuscation result: enhanced bit-level analysis (taintedness + taint source information)
(our algorithm)

Fig. 2.

Impact of different taint analysis algorithms on quality of debofuscation (Input program: binary search; obfuscated using: ExeCryptor)

Algorithm 1: Finding Control Dependencies
Input: An initial input/output tainted trace T
Result: The trace T with control dependencies between

instructions identiﬁed

1 Construct an initial control ﬂow graph G
2 Compute post-dominator relations in G [24]
3 Use post-dominator relationships to compute explicit

control dependencies [24]:

4 (a) C = the set of input-tainted conditional control
transfers; and
5 (b) DepVars ={x | ∃C ∈ C: x control dependent on C}
6 while ∃ an indirect control transfer Ins dependent on
some x ∈ DepVars do

BBl ← basic block of Ins in G
Mark BBl as dependent on the direct control transfer
in C that x is dependent on

7
8

9 end

dencies is straightforward using post-dominators [24]. Implicit
control ﬂows are those indirect control transfers of the form
‘jmp [(cid:3)]’ where the location (cid:3) is data-dependent on the set
DepVars of dependent variables identiﬁed in Algorithm 1.
Intuitively, implicit control dependencies account for the fact
that a control dependence between two instructions I and J
may arise indirectly through an assignment D of the value
of a variable x if D is control dependent on I and where x
determines the target of an indirect control transfer to J (this
happens in, but is not restricted to, the dispatch jump of an
emulator).

Figure 3 shows an example of explicit and implicit control
ﬂows. The value of register eax on line 6 is dependent on the
conditional jump on line 2, so the target of the jmp instruction
of line 6 also depends on which path is taken on line 2. This
way the basic block following the jmp on line 6 is also control
dependent on the conditional transfer on line 2. It is fair to say
that the data dependency from line 6 to lines 3 and 5, through
the value of eax, is really a control dependency in disguise.

The approach we take is shown in Algorithm 1. We consider
two types of control ﬂows: explicit and implicit. Explicit
control ﬂows are those control transfers where the predicate
is explicitly reﬂected in the transfer of control, e.g., as in
conditional jump instructions. Finding explicit control depen-

C. Trace Simpliﬁcation

Once we have identiﬁed the instructions in the trace that
participate in computing output values from input values, the
next step is to map these instructions to an equivalent but
simpler instruction sequence. Since we want to make as few

678678

1
2
3
4
5
6

test ecx, eax
jnz L1
mov eax, 0
jmp L2

L1: mov eax, 1
L2: jmp [edx+4*eax]

Fig. 3. An example of implicit control ﬂow

assumptions as possible about the obfuscations we may be
dealing with, we use a set of simple and general semantics-
preserving transformations for this.

An important concept in this context is the notion of a quasi-
invariant location. We deﬁne a location (cid:3) to be quasi-invariant
for an execution if (cid:3) contains the same value (cid:3)c at every use
of (cid:3) in that execution. For constant propagation purposes, we
consider a value to be a constant during an execution if either
it is an immediate operand of an instruction or if it comes from
a memory location that is quasi-invariant for that execution.
Quasi-invariant locations allow us to handle transient mod-
iﬁcations to the contents of memory locations, e.g., due to
unpacking, as long as we see the same value each time a
location is used. Quasi-invariants can be identiﬁed in a single
forward pass over a trace keeping track of memory locations
that are modiﬁed and, for each such modiﬁcation, the value
that is written. The notion of quasi-invariance can be extended
in various ways, e.g., we may consider whether a memory
word contains the same value every time it is used for an
indirect branch (this is useful, for example, for dealing with
jump tables whose elements are kept in encrypted or encoded
form, decrypted prior to use, and then re-encrypted).

The transformations we use include the following (this is a

non-exhaustive list):

1) Arithmetic simpliﬁcations. In essence this is a straight-
forward adaptation of the classic compiler optimization
of constant folding to work with dynamic traces and
quasi-invariant locations. However, as described below,
it has to be controlled to avoid over-simpliﬁcation.
For example, in the code sequence shown above, the
constant value 0xa4 loaded into the register bh can
be propagated through the bit-manipulation instructions
following it, and the entire sequence of instructions
manipulating bh can be replaced by a single instruction
‘mov bh, 0x8b’.

2) Indirect memory reference simpliﬁcation. An indirect
memory reference through a quasi-invariant location (cid:3)
that holds a value A is simpliﬁed to refer directly to A.
This transformation is applied to both control transfers
and data references.

3) Data movement simpliﬁcation. We use pattern-driven
rules to identify and simplify data movement. For ex-
ample, one of our rules states that the following simpli-
ﬁcation can be performed provided that the sequence of
instructions Instr does not access the stack and does not
change the value of A:

push A
Instrs
pop B

−→ Instrs

mov B, A /* B := A */

4) Dead code elimination. Instructions whose destinations
are dead, i.e., not used subsequently in the computation,
are deleted. This transformation must consider all desti-
nations of an instructions, including destination operands
that are implicit and which may not be mentioned in the
instruction (such implicit destinations includes condition
ﬂags).

5) Control transfer simpliﬁcation Control transfer instruc-
tions whose targets are constant are replaced by direct
jumps. Candidates for this transformation include return
instructions to constant targets in ROP code as well
as indirect jumps to ﬁxed targets in emulation-based
obfuscation. Using control ﬂags implicitly to control
the transfer ﬂow of the program is common among
interpreters and is also used in ROPs. For example one
can implement loops in ROPs as follows:

mov eax,0
sub counter,1
adc eax,eax
push [L+eax*4]
ret

/* eax := 1 if counter=0 */

where L is the address of the memory location which
points to the beginning of the loop and subsequent
location points to where loop should exit to. In this
example, the target of the return instruction is affected
by the outcome of carry ﬂag so the ret instruction can
be replaced by a conditional jump which directly uses
the carry ﬂag.

Example 3.1: Figure 4 gives an example of indirect memory
reference simpliﬁcation. Figure 4(a) shows a small program
that sits in a loop making indirect jumps through successive
elements of a read-only array T. Figure 4(b) shows the unsim-
pliﬁed trace for this code. Since T is read-only, its elements are
constant, making indirect calls through this table amenable to
indirect memory reference simpliﬁcation; the resulting trace
is shown in Figure 4(c). Since T is no longer being used
for indirect jumps, instructions that load from T then become
dead and are removed via dead code elimination. Similarly,
constant propagation converts the add instructions into mov
instructions that load constants into register ebx. This then
determines the outcome of each of the cmp instructions, and
allows the cmp and jne instructions to be simpliﬁed away;
once this happens the instructions that load into ebx also
become dead and are removed.

The ﬁnal simpliﬁed trace is shown in Figure 4(d). What is
left is pretty much just the code executed at the addresses that,
in the original program, had been reached via a sequence of
indirect jumps through the jump table T. In the simpliﬁed trace,
almost everything other than the code eventually executed has
been simpliﬁed away.

The indirect jump behavior illustrated in this example is
very similar to the dispatch code of an emulator. Indirect
memory reference simpliﬁcation allows us to replace the
dispatch jumps of an emulator with direct jumps that can

679679

(read-only)
T:

0x500000
0x520000
0x550000

L:

mov ebx, 0
mov eax, T[ebx]
jmp [eax]
add ebx, 4
cmp ebx, 12
jne L

mov ebx, 0
mov eax, T[ebx]
jmp [eax]
Trace of code at 0x500000
add ebx, 4
cmp ebx, 12
jne L

mov eax, T[ebx]
jmp [eax]
Trace of code at 0x520000
add ebx, 4
cmp ebx, 12
jne L

mov eax, T[ebx]
jmp [eax]
Trace of code at 0x550000
add ebx, 4
cmp ebx, 12
jne L

(a) Static code

(b) Unsimpliﬁed trace

mov ebx, 0
mov eax, 0x500000
jmp 0x500000
Trace of code at 0x500000
mov ebx, 4
cmp ebx, 12
jne L

mov eax, 0x520000
jmp 0x520000
Trace of code at 0x520000
mov ebx, 8
cmp ebx, 12
jne L

mov eax, 0x550000
jmp 0x550000
Trace of code at 0x550000
mov ebx, 12
cmp ebx, 12
jne L

(c) Trace after constant
propagation and indirect
memory reference simpli-
ﬁcation

mov ebx, 0
mov eax, 0x500000
jmp 0x500000
Trace of code at 0x500000
mov ebx, 4
cmp ebx, 12
jne L

mov eax, 0x520000
jmp 0x520000
Trace of code at 0x520000
mov ebx, 8
cmp ebx, 12
jne L

mov eax, 0x550000
jmp 0x550000
Trace of code at 0x550000
mov ebx, 12
cmp ebx, 12
jne L

(d) Trace after dead code
elimination

Fig. 4. An example of indirect memory reference simpliﬁcation

then be candidates for further optimization. Importantly, this is
being done via a completely general transformation that makes
no assumptions about whether or how an emulator might be
dispatching code.

While the trace simpliﬁcation process described above is
crucial for removing obfuscation code, it has to be carefully
controlled so that it does not remove too much of the logic
of the computation. The problem is illustrated by Figure
5. Figure 5(a) shows the static code for a simple iterative
factorial computation, written in a C-like notation for ease
of understanding. Figure 5(b) shows the execution trace for
this program for an input value of 3, with input-tainted
instructions shown underlined. Figure 5(c) shows the result of
trace simpliﬁcation: it can be seen that constant propagation
has been applied to all of the updates to the variables fact
and i, and as a result the output operation at the end has been
reduced to ‘write(6)’. This is not helpful for understanding
the logic of the computation, i.e., the mapping from input
values to output values.
To understand the problem, consider the instruction I5 ≡
‘fact := fact * i’. The variables i and fact have
both been initialized to the value 1 at
this point, so the
value of the expression ‘fact * i’ is inferred to be a
constant. Constant propagation then simpliﬁes this instruction
to the assignment ‘fact := 1’. Arguably, this simpliﬁcation
does not preserve the logic of this computation because it
suggests that this assignment computes a ﬁxed constant value
when, in reality, the value that is computed by this instruction
depends on the number of iterations of the loop, which in turn
depends on the input value. The same observation applies to
the other arithmetic simpliﬁcations carried out on this trace.
The problem arises because the simpliﬁcation fails to take into

account the fact that the instruction being simpliﬁed is control-
dependent on the input-tainted instruction I4 ≡ ‘if (i >
n) goto Bot’, which induces an implicit information ﬂow
from the input to I5.

We address this problem by restricting the propagation of
constants across input-tainted conditional jumps. This is done
as follows. We ﬁrst identify control dependencies as described
in Algorithm 1. Given an instruction X, let ControlDeps(X)
denote the set of input-tainted instructions in the execution
trace that X is control-dependent on. Then, a backward-
tainted arithmetic operation I is simpliﬁable only if every
source operand of I is either an immediate operand, or else
is deﬁned by an instruction J such that ControlDeps(J) =
ControlDeps(I). Applying this condition to the trace of Fig-
ure 5(b), we ﬁnd that instruction I5 is control-dependent on the
input-tainted instruction I4 ≡ ‘if (i > n) goto Bot’,
but its operands fact and i, which are deﬁned by instructions
I3 and I2 respectively, which are not control dependent on
any instruction and therefore in particular are not control
dependent on I4. Thus, ControlDeps(I5) (cid:6)= ControlDeps(I3)
and so I5 is not simpliﬁable. The constant value of fact
deﬁned by I3 is therefore not propagated to I5, which is what
we want.

D. Control Flow Graph Construction

The ﬁnal step in our deobfuscation process is to construct a
CFG [24] from the simpliﬁed trace obtained from the trace
simpliﬁcation step. For deobfuscation purposes, one issue
that arises in this context
is that of reuse of code in a
way that complicates the program’s control ﬂow structure. In
obfuscated code, we very often ﬁnd that a given functionality
I—e.g., an emulator operation such as addition or subtrac-

680680

n := read()
i := 1
fact := 1

Top: if (i > n) goto Bot

fact: = fact * i
i := i + 1
goto Top

Bot: write(fact)

halt

n := read()
i := 1
fact := 1
if (i > n) goto Bot
fact := fact * i
i := i + 1
goto Top
if (i > n) goto Bot
fact := fact * i

I1
I2
I3
I4
I5
I6
I7
I8
I9
I10 i := i + 1
I11 goto Top
I12 if (i > n) goto Bot
I13 fact := fact * i
I14 i := i + 1
I15 goto Top
I16 if (i > n) goto Bot
I17 write(fact)
I18 halt

(a) Static code

(b) Unsimpliﬁed trace (input = 3).
Input-tainted instructions are shown un-
derlined.

Fig. 5. An example illustrating over-simpliﬁcation

n := read()
i := 1
fact := 1
if (i > n) goto Bot
fact := fact * i 1
i := i + 1 2
goto Top
if (i > n) goto Bot
fact := fact * i 2

I1
I2
I3
I4
I5
I6
I7
I8
I9
I10 i := i + 1 3
I11 goto Top
I12 if (i > n) goto Bot
I13 fact := fact * i 6
I14 i := i + 1 4
I15 goto Top
I16 if (i > n) goto Bot
I17 write(fact 6)
I18 halt

(c) Result of oversimpliﬁcation.

Algorithm 2: Final Control Flow Graph Construction
Input: Set of simpliﬁed execution trace T
Result: Control ﬂow graph G for T

1 Let B0 be ﬁrst basic block in T
2 tcurr := vcurr := B0
3 G := (V, E) where V = {vcurr} and E = ∅
4 EdgeStk := NULL
5 while there are unprocessed blocks in T do
6
7
8
9
10
11

let tnext be the next block after tcurr in T
if tnext is already a successor of vcurr then

else if a successor can be added to vcurr then

/* add tnext as a successor to vcurr */
Let vnext be a basic block in G that its entry
point has the same address as tnext in T
if vnext = NULL then

vnext := tnext

vnext := tnext
add vnext to V

add e ≡ ‘vcurr → vnext’ to E
push e on EdgeStk

/* backtrack using EdgeStk */
pop e ≡ ‘a → b’ from EdgeStk
tcurr := block in T corresponding to a
tnext := block in T corresponding to b
vcurr := block in G corresponding to tcurr
vnext := Duplicate(tnext)
add e ≡ ‘vcurr → vnext’ to E
push e on EdgeStk

else

12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29 end
30 Output G

end
vcurr := vnext
tcurr := tnext

tion (in emulation-obfuscation), or a gadget for an operation
such as copying one register to another (in return-oriented
programming)—is implemented using a single code fragment
CI; control is then directed to CI whenever the functionality
I is needed in the program. This means that if there are k
different occurrences of I in the original program, they will
end up executing the same piece of code CI in the emulated
program k times, with k corresponding repetitions of CI in
the execution trace. A CFG constructed in a straightforward
way will then have k pairs of control ﬂow edges coming into
and out of the code region CI, which will cause the control
ﬂow behavior of the program to appear very tangled.

During deobfuscation, therefore, we try to construct the
CFG in a way that attempts to untangle some of the paths
by judiciously duplicating basic blocks. Intuitively, we want
to minimize the amount of such code duplication, while at the
same time reducing the number of “spurious” control ﬂow
paths (paths that are possible in the CFG constructed but
which are not observed in the trace(s) used to construct the
CFG). Solving this problem optimally seems combinatorially
challenging, and related problems in computational learning
theory that are known to be computationally hard: the problem
of identifying a CFG that is consistent with a given trace (i.e.,
which admits that trace but may also admit other execution
paths) can be modeled as that of constructing a DFA consistent
with a given set of strings (i.e., which accepts those strings but
may also accept other strings). Unfortunately the problem of
ﬁnding the smallest DFA (or the smallest regular expression)
that is consistent with a given regular language is NP-hard
[25], [26] and is not even efﬁciently approximable [27].

Given these results, we augment the usual CFG construction
algorithm [24] with heuristics aimed at balancing the number
of vertices and the complexity of the constructed CFG, using a
depth-ﬁrst backtracking search to explore the search space as
is shown in the Algorithm 2. We brieﬂy sketch the algorithm
here.

681681

The simpliﬁed trace, from which we construct the deob-
fuscated control ﬂow graph, is a sequence of instructions that
can also be considered as a sequence of basic blocks such
that if a block B is followed by a block B(cid:2) in the (simpliﬁed)
trace it corresponds to an edge B → B(cid:2) in the corresponding
control ﬂow graph. Our algorithm traverses the sequence of
basic blocks in the trace, constructing a control ﬂow graph G
using the usual CFG construction algorithm, by adding basic
blocks and/or edges to G, as long as this does not violate
any structural constraints of any vertex in G; currently, the
primary structural constraint that is enforced is the out-degree
constraint: namely, that a basic block ending with a conditional
jump can have at most two successors or if it is ending with
an indirect jump, there is no restriction on the number of its
succesors. This requirement is checked at the line 9 of the
Algorithm 2. If the algorithm encounters a situation where
adding a block and/or edge to G would violate this structural
constraint, it backtracks to the most recently added vertex that
can be duplicated without violating the out-degree constraint
(Algorithm 2 lines 18-25). This vertex is then duplicated,
together with vertices and edges that were added to G more
recently, after which the algorithm resumes in the forward
direction.

Another problem that

the simpliﬁcation might cause is
removing dynamically dead instrucitons that affects the ﬁnal
CFG in such a way that causes the CFG construction algorithm
to produce a new basic block for the code in which dynam-
ically dead instructions are missing. The ﬁnal step of deob-
fuscation is to apply semantics-preserving transformations to
simplify the control ﬂow graph. In particular, we identify and
merge basic blocks that differ solely due to dynamically dead
instructions. The following snippet of code, to compute the
factorial function, illustrates the problem:2

int factorial(int n) {

int i, p;
p = i = 1;
while (n > 0) {

p = p*i
i = i+1
n = n-1

}
return p;

}

Suppose this function is called with the argument n = 2. The
resulting execution trace for this function is:

/* 1 */
/* 2 */
/* 3 */
/* 4 */
/* 5 */
/* 6 */
/* 7 */
/* 8 */
/* 9 */
/* 10 */

i = 1
p = 1
n > 0?
p = p*i
i = i+1
n = n-1
n > 0?
p = p*i
i = i+1
n = n-1

/* n == 2 */

/* n == 1 */

2In reality we work with assembly instructions. This example uses C code
for the program, and a quasi-C syntax for the trace, for simplicity and ease
of understanding.

682682

/* 11 */
/* 12 */

n > 0?
return p

/* n == 0 */

The statement at position 9 in this trace, ‘i = i+1’,
is
dynamically dead, since the value it computes at that point in
the execution is not used later, and so it is removed during trace
simpliﬁcation. When a control ﬂow graph is constructed from
the simpliﬁed trace, however, we get two different versions of
the loop body:

p = p*i
i = i+1
n = n-1
n > 0?

and

p = p*i

n = n-1
n > 0?

The ﬁrst of these corresponds to the iterations up to the last
iteration, while the second corresponds to the last iteration.
More generally, depending on the dependence structure/dis-
tance of the loop(s) we may get multiple such loop body
fragments with some code simpliﬁed away. Such blocks are
treated as distinct by the control ﬂow graph construction
algorithm, resulting in a graph that has more vertices, and
is more cluttered, than necessary. A similar situation arises
with function calls if some call sites use the return value but
others do not.

We deal with this situation by identifying and merging basic
blocks that are identical modulo dynamically dead instructions.
Deﬁne two blocks B1 and B2 to be mergeable if the following
conditions hold:

1) B1 and B2 span the same range of addresses (except
possibly for any dynamically dead instructions at the
beginning and/or end of either block).

2) [Non-dynamically dead instructions] If an instruction
I occurs in both B1 and B2, then it is the identical
instruction in both B1 and B2. I.e., the operands should
not have changed (e.g. due to constant propagation).
3) [Dynamically dead instructions] For each instruction
I ∈ B1 that does not occur in B2, I is dead if it is added
into B2 at the appropriate position; and analogously with
instructions that are in B2 but not in B1.

To simplify the control ﬂow graph, we repeatedly ﬁnd merge-
able basic blocks and merge them to obtain the ﬁnal control
ﬂow graph.3

IV. EXPERIMENTAL EVALUATION

We have evaluated our ideas using a prototype implemen-
tation of our approach. Execution traces of the original and
obfuscated binaries were collected using a modiﬁed version of
Ether [16]. Trace simpliﬁcation was carried out on a machine
with 2× quad-core 2.66 GHz Intel Xeon processors with 96
GB of RAM running Ubuntu Linux 12.04. The results of our
experiments are discussed below. To quantify the similarity
between the original and the deobfuscated programs (and, for
completeness, the obfuscated programs as well), we use an

3From an implementation perspective, it turns out to be simpler to mod-
ify the simpliﬁed trace to reintroduce, where necessary, dynamically dead
instructions that had been simpliﬁed away, and then rebuild the control ﬂow
graph.

algorithm of Hu, Chiueh, and Shin for computing the edit
distance between two control ﬂow graphs [28]. Given two
control ﬂow graphs G1 and G2, this algorithm computes a
correspondence between the vertices of G1 and G2 using
maximum bipartite matching, then uses this correspondence to
determine the number of edits, i.e., the number of vertex and
edge insertion/deletion operations necessary to transform one
graph to the other. To facilitate comparisons between CFGs
of different sizes, we normalize the edit distance to the total
size of the graphs being compared. Let δ(G1, G2) be the edit
distance between two control ﬂow graphs G1 and G2, then
their similarity is computed as

sim(G1, G2) = 1 − δ(G1, G2)
|G1| + |G2|

where |G| is the size of the graph G and is given by the total
number of vertices and edges in G. A similarity score of 0
means that the graphs are completely dissimilar; a similarity
score of 1 means that the graphs are identical.

Our experimental samples, including source code for the test
programs and executables for the original and obfuscated pro-
grams, are available at www.cs.arizona.edu/projects/
lynx/Samples/Obfuscated/.

A. Emulation-based Obfuscation

We evaluated our deobfuscator using four commercial
emulation-obfuscation tools: Code Virtualizer [1], EXECryp-
tor [2], Themida [4], and VMProtect [3]. Code Virtualizer and
VMProtect are representative of obfuscation tools that have
been considered in previous work [5], [6]; these authors do
not discuss EXECryptor so we do not know whether they are
able to handle software obfuscated using this tool. As far as
we know, none of the existing approaches on deobfuscation
of emulation-obfuscated software are able to handle binaries
obfuscated using Themida. When obfuscating programs using
Themida, users can select various parameters, including the
complexity of the VM instructions: for our experiments used
the setting ‘mutable CISC processor’ with one VM whose
opcode type is ‘metamorphic level-2’.4

1) Single-Level Emulation: Single-level emulation refers to
obfuscation where there is just a single level of emulation,
namely, that of the emulator introduced by the obfuscation
process. This is the only kind of emulation-based obfuscation
considered thus far by other researchers on this topic.

To evaluate the quality of deobfuscation results using our
approach on single-level emulation, we applied the commer-
cial obfuscators named above to several malware programs,
whose source code we obtained from VX Heavens [31],
together with two synthetic benchmarks we wrote ourselves.
The malware programs we used were: Blaster [29], Cairuh,
epo, hunacha, newstar, and netsky ae [30]. Of these programs,
Blaster is a network worm; Cairuh is a P2P worm; hunatcha

4“Mutable CISC processor” and “metamorphic level-2” are settings in the
Themida tool; the available documentation does not specify, in any further
detail, exactly how these settings affect the low-level characteristics of the
obfuscated code.

683683

is a ﬁle dropper; newstar and epo are ﬁle infectors that imple-
ment different ﬁle infection mechanisms to drop payloads into
other ﬁles; and netsky ae is a worm whose functionality we
divided into different pieces: netsky ae1 searches and elimi-
nates antivirus and monitoring software running on the system,
netsky ae2 installs the malware for surviving the system boots,
netsky ae3 infects the system with encrypted variations of the
malware and netsky ae4 recursively copies the malware into
shared folders. In addition to these malware programs, we used
two synthetic benchmarks, huffman, and matrix-multiply, to
explore how our techniques handled various combinations of
conditionals and nested loops.

Our Ether-based tracing infrastructure crashed on the Cairuh
and blaster programs obfuscated with Themida so we were
unable to collect an execution trace for these programs.

Space constraints preclude showing the full control ﬂow
graph of each of our test inputs; Figure 6 gives a high-level
visual impression of the effect of emulation-based obfuscation,
together with the deobfuscated programs obtained using our
approach, for two different malware samples: Netsky ae1, Hu-
natcha, and the matrix multiply program, that have reasonably
interesting control ﬂow structure, consisting of nested loops
and conditionals; and three widely-used obfuscation tools:
Code Virtualizer, ExeCryptor, and Themida. In order to focus
the discussion on the core portion of the computation, the
graphs shown omit the program setup/takedown and I/O code.
It can be seen, from visual inspection, that the control ﬂow
graph resulting from deobfuscation is in each case very similar
to that of the original program.

The results of the similarity comparisons are shown in Table
I. Columns labeled ‘Obf.’ give the similarity of the obfuscated
programs with the original programs; those labeled ‘Deobf.’
give the similarity between the deobfuscated programs and the
original programs. Not surprisingly, the obfuscated programs
are usually very different from the original code structurally:
by and large these similarity numbers are in the 6%–8%
range, with several programs showing similarities of less that
10%, and a few (e.g. huffman, hunatcha and epo for Code
Virtualizer, and huffman for VMProtect) with similarity values
over 15%. The exceptions here are Cairuh, netsky ae2 and
netsky ae4 which because of having switch statements in their
code, they are structurally similar to the virtualized binaries
so they are in fact more similar to the obfuscated binaries
than the other programs. By contrast, the control ﬂow graphs
resulting from our deobfuscation algorithm have signiﬁcantly
higher similarities. While nearly similar on average, they are
highest for Code Virtualizer and Execryptor, ranging from
72% to 95% for Code Virtualizer and in the range of 75%
to more than 94% for EXECryptor. On average the similarity
values for Code Virtualizer and EXECryptor are 86.6% and
86.4%. The deobfuscation results are comparable for Themida
and VMProtect, ranging from 82% to 96% for Themida and
from 46% to 96% for VMProtect. However, it should be noted
that our approach still achieves signiﬁcant improvements in
similarity relative to the obfuscated code.

EnumProcesses

strcpy

OpenProcess

TerminateProcess

EnumProcessModules

GetModuleBaseNameA

CloseHandle

_strupr

FreeLibrary

strcmp

Original





















EnumProcesses

strcpy

OpenProcess

TerminateProcess

EnumProcessModules

GetModuleBaseNameA

CloseHandle

_strupr

FreeLibrary

strcmp

Obfuscated (cropped)

Deobfuscated

(a) Netsky ae1: Code Virtualizer

Original

Obfuscated (cropped)

Deobfuscated

(b) Hunatcha: ExeCryptor

Original

Obfuscated (cropped)

Deobfuscated

(c) Matrix multiply: Themida

Fig. 6. Effects of obfuscation and deobfuscation on the control ﬂow graphs of some malware samples

684684

Control ﬂow graph similarity (%)
THEMIDA

PROGRAM

huffman
hunatcha
matrix-mult
Cairuh
blaster
newstar
epo
netsky ae1
netsky ae2
netsky ae3
netsky ae4
AVERAGE

CODE VIRTUALIZER
Deobf.
72.24
90.30
81.63
89.02
84.54
94.38
92.51
88.03
80.85
92.85
86.60
86.63

Obf.
20.75
22.43
06.50
39.37
13.25
09.09
29.26
19.78
50.90
11.52
30.30
23.01

EXECRYPTOR
Obf.
06.08
04.82
01.31
26.46
02.40
02.15
07.86
08.19
13.12
02.43
20.71
08.68

Deobf.
83.50
90.04
83.95
94.04
84.87
92.56
80.92
87.27
93.40
85.49
75.04
86.43
TABLE I

Obf.
06.03
05.60
01.56
NA
NA
02.21
09.28
06.15
19.75
03.84
14.04
07.60

Deobf.
83.91
84.84
81.63
NA
NA
96.70
81.23
84.14
88.17
82.81
82.66
85.12

VMPROTECT
Obf.
16.45
15.57
07.22
28.68
14.07
08.49
20.03
19.00
24.50
09.35
22.65
16.91

Deobf.
46.40
73.65
75.55
82.39
89.24
75.20
96.28
82.81
89.95
94.36
87.85
81.24

SIMILARITY OF ORIGINAL AND DEOBFUSCATED CONTROL FLOW GRAPHS: EMULATION-OBFUSCATION

In Figure 7 we have included the CFGs of a subtrace
of the netsky1 ae program with instructions included in the
graph: Figure 7(a) corresponds to the original program and
(b) corresponds to the deobfuscated program obfuscated us-
ing Code Virtualizer. This shows that with the high level
information that can be recovered by the CFGs, program
semantic information is also included at the instructions level.
For example in Figure 7, it can be seen that in both graphs,
there is a test on the output of the strcmp function call
marked with label 1. The program is trying to kill all the
unwanted processes currently running in the system and by
comparing process names with ones in a list, it determines
whether to terminate the process or not. If the comparison
satisﬁes, it calls OpenProcess (labeled with 2) and then
terminates the process using a call to TerminateProcess
(labeled with 3). There is correspondence between two graphs
and the semantics are equivalent in both the original and
deobfuscated programs. Getting this level of information from
the obfuscated program, where the graph is shown on Figure
6(a), is very unlikely, if not impossible, and requires signiﬁcant
amount of time and efforts.

However, there is one difference between two graphs that
should be noted here. As it was discussed in Section III-D, the
CFG construction algorithm tries to balance between the code
duplications and the number of paths in the ﬁnal graph. Doing
so, the CFG constructed for the deobfuscated program uses an
existing block (pointed by label 4) rather than duplicating it
for the corresponding block in original program (also pointed
by label 4). This is mostly because in the original program,
only one target branch is observed (for the basic block pointed
by label 4) and so the CFG construction algorithm does not
have a clue about the other branch existing in the original
program. It should also be noted that this does not however
affect the semantics of the program and the constructed graph
still represents the original logic correctly and this is a general
limitation for dynamic analysis where the code coverage is an
issue rather a speciﬁc limitation of our approach.

Analysis speed depends partly on the input trace size but
mostly on the number of iterations of code simpliﬁcation

685685

needed, which in turn depends on how entangled the ob-
fuscations are; there seems to be a non-linear component to
the execution time that we are currently looking into. Execu-
tion times for the three largest trace ﬁles, Cairuh-VMProtect
(6.4M instructions), hunatcha-Themida (7.7M instructions),
and huffman-Themida (56.6 M instructions) are 188 sec, 244
sec, and 4,726 sec respectively, which translate to speeds
of 34,042 instrs/sec, 31,557 instrs/sec, and 11,976 instrs/sec
respectively.

We have also applied our deobfuscator

to a number
of emulation-obfuscated malicious binaries that we ob-
tained from virusshare.com, including Win32/Kryptik, Trojan-
Downloader.Banload, Win32.Dubai, W32/Dialer, and Back-
door.Vanbot. Space constraints preclude showing the origi-
nal and simpliﬁed CFGs for these programs, so we brieﬂy
summarize our ﬁndings. We found that in the samples we
tested, emulation was typically applied selectively to selected
sensitive code regions, with multiple layers of unpacking
added subsequently to further obfuscate the malicious payload.
Our deobfuscator was able to remove all of the emulation
and unpacking code, leaving only the logic of the malicious
payload with a much simpler CFG. The time taken to perform
this simpliﬁcation for the malware samples we tested was
around 10 minutes per sample.

Overall, these results show that while our prototype imple-
mentation is not yet perfect, it is nevertheless able to extract
control ﬂow graphs that closely resemble those of original
unobfuscated programs. Notably, it is able to do this for both
“ordinary” emulation-obfuscated programs and also Themida-
obfuscated programs, which combine runtime unpacking with
emulation and, as far as we know, are not handled by any
previously proposed techniques for automatic deobfuscation.
Considering that we make very few assumptions about the
nature of the obfuscations applied, we consider this encourag-
ing. We are currently working on improving our analyses to
improve the deobfuscation results further.

2) Multi-level Emulation: We have also applied our ap-
proach to programs obfuscated using multiple levels of em-
ulation, i.e., where one emulator interprets another emulator

 jmp dword near [0x4020b0] 

 strcpy

2

 mov edx, [ebp+0xfffffee0] 
 mov eax, 0x458 
 push eax 
 push 0x0 
 push dword 0x410 
 mov dword [0x12e79c], 0x0 

 OpenProcess

 cmp dword [ebp+0xffffedec], 0x0 
 lea ecx, [ebp+0xfffffdb0] 
 push ecx 
 push 0x4 
 lea edx, [ebp+0xfffffed8] 
 push edx 
 mov eax, [ebp+0xffffedec] 
 push eax 
 mov dword [0x12e798], 0x0 

 cmp dword [ebp+0xffffedec], 0x0 
 push 0x0 
 mov edx, [ebp+0xffffedec] 
 push edx 
 mov dword [0x12e7a0], 0x0 

3

 EnumProcessModules

 TerminateProcess

 push dword 0x104 
 lea ecx, [ebp+0xfffffdc8] 
 push ecx 
 mov edx, [ebp+0xfffffed8] 
 push edx 
 mov eax, [ebp+0xffffedec] 
 push eax 
 mov dword [0x12e798], 0x0 

 GetModuleBaseNameA

 mov ecx, [ebp+0xffffedec] 
 push ecx 
 mov dword [0x12e7a4], 0x0 

 CloseHandle

 push edx 
 lea eax, [ebp+0xfffffdc8] 
 push eax 
 mov dword [0x12e7a0], 0x0 

 _strupr

 push eax 
 call 0x40101c 

 push eax 
 call 0x40101c 

1

 jmp dword near [0x4020bc] 

 strcmp

 test eax, eax 
 jnz dword 0x401ad9 

 test eax, eax 
 mov dword [ebp+0xfffffeec], 0x1 
 mov eax, [ebp+0xfffffee0] 
 mov ecx, 0x568 
 push ecx 
 push 0x0 
 push 0x1 
 mov dword [0x12e79c], 0x0 

 lea ecx, [ebp+0xfffffef0] 
 push ecx 
 lea edx, [ebp+0xfffffdc8] 
 push edx 
 mov dword [0x12e7a0], 0x0 

4

 mov edx, [ebp+0xfffffee0] 
 add edx, 0x1 
 mov [ebp+0xfffffee0], edx 
 mov eax, [ebp+0xfffffee0] 
 cmp eax, [ebp+0xffffe9fc] 
 jae dword 0x401ade 

 jmp dword near [0x4020b0] 

 strcpy

2

 sub esp, 0x4 
 mov dword [esp], 0x432 
 sub esp, 0x4 
 mov dword [esp], 0x0 
 sub esp, 0x4 
 mov dword [esp], 0x410 
 mov dword [0x12e7a8], 0x0 
 jmp 0x406038 

 OpenProcess

 mov [esp], eax 
 sub esp, 0x4 
 mov edi, 0x404200 
 push eax 
 pop ecx 
 cmp ecx, 0x0 
 pushfd  
 mov eax, 0x7 
 pop dword [edi+eax*4] 
 mov eax, 0x40421c 
 mov ecx, [eax] 
 and ecx, 0x40 
 shr ecx, 0x6 
 mov eax, 0x1 
 xor eax, ecx 
 mov [esp], eax 
 not dword [esp] 
 mov eax, [esp] 
 and eax, 0x1 
 mov edx, eax 
 shl edx, 1 
 mov [0x404220], edx 
 mov edi, 0x404200 
 cmp dword [edi+0x20], 0x0 
 sub esp, 0xc 
 mov dword [esp], 0x0 
 mov eax, [0x12eba0] 
 push eax 
 jmp 0x406038 

3

 TerminateProcess

 add esp, 0x6 
 mov dword [esp], 0x40273c 
 sub esp, 0x6 
 mov dword [esp], 0xfffffdc8 
 add esp, 0x2 
 mov dword [esp], 0x40903b 
 jmp dword near [0x4020b0] 

 push dword 0x0 
 push dword 0x404200 
 mov edx, 0x404200 
 add esp, 0x6 
 pop dword [edx] 
 mov edx, 0x404218 
 add esp, 0x12 
 pop dword [edx] 
 mov [esp], eax 
 add esp, 0x4 
 mov edi, 0x404200 
 push eax 
 pop ecx 
 add esp, 0x8 
 cmp ecx, 0x0 
 pushfd  

4

 add esp, 0x2 
 mov eax, 0x7 
 pop dword [edi+eax*4] 
 mov eax, 0x40421c 
 mov ecx, [eax] 
 and ecx, 0x40 
 shr ecx, 0x6 
 mov eax, 0x1 
 xor eax, ecx 
 mov [esp], eax 
 not dword [esp] 
 mov eax, [esp] 
 and eax, 0x1 
 mov edx, eax 
 shl edx, 1 
 mov [0x404220], edx 
 mov edi, 0x404200 
 cmp dword [edi+0x20], 0x0 
 jz dword 0x406fb5 

 sub esp, 0x4 
 mov eax, 0x3 
 push dword [edi+eax*4] 
 add esp, 0x4 
 push dword [esp] 
 pop edx 
 sub esp, 0x4 
 push edx 
 mov eax, [0x12e7a4] 
 sub eax, 0x2b0d0c86 
 add eax, 0x2cb87490 
 add eax, 0xfffffdb0 
 sub eax, 0x2cb87490 
 add eax, 0x2b0d0c86 
 mov edx, eax 
 sub esp, 0x8 
 mov [esp], edx 
 sub esp, 0xa 
 mov dword [esp], 0x4 
 mov eax, [0x12eba0] 
 sub esp, 0xa 
 push eax 
 sub esp, 0x4 
 mov dword [esp], 0x40904f 
 mov edx, 0x404218 
 push dword [edx] 
 mov edx, 0x404200 
 push dword [edx] 
 jmp 0x406038 

 EnumProcessModules

 sub esp, 0x8 
 mov dword [esp], 0x104 
 mov dword [0x404204], 0x1000000 
 mov edx, 0x404204 
 push dword [edx] 
 mov eax, [esp] 
 add esp, 0x4 
 push eax 
 sub esp, 0x4 
 mov dword [esp], 0x409059 
 jmp 0x406038 

 GetModuleBaseNameA

 mov eax, [0x12eba0] 
 add esp, 0x6 
 push eax 
 sub esp, 0x4 
 mov dword [esp], 0x409063 
 jmp 0x406038 

 CloseHandle

 sub esp, 0x2 
 mov dword [esp], 0xfffffdc8 

 add esp, 0x8 
 mov dword [esp], 0x40906d 
 jmp 0x406038 

 _strupr

 add esp, 0xc 
 push eax 
 sub esp, 0x2 
 mov dword [esp], 0x409077 
 jmp dword near [0x4020bc] 

1

 strcmp

 mov eax, 0x0 
 mov ecx, 0x0 
 add esp, 0x4 
 test eax, ecx 
 pushfd  
 mov eax, 0x7 
 pop dword [edi+eax*4] 
 mov eax, 0x40421c 
 mov ecx, [eax] 
 and ecx, 0x40 
 shr ecx, 0x6 
 mov eax, 0x0 
 xor eax, ecx 
 mov [esp], eax 
 not dword [esp] 
 mov eax, [esp] 
 and eax, 0x1 
 mov edx, eax 
 shl edx, 1 
 mov [0x404220], edx 
 mov edi, 0x404200 
 cmp dword [edi+0x20], 0x0 
 jz dword 0x406fb5 

 mov eax, 0x1 
 mov ecx, 0x1 
 add esp, 0x4 
 test eax, ecx 
 pushfd  

 add esp, 0x4 
 mov dword [esp], 0xfffffdc8 

(a) Original program

(b) Deobfuscated program

Fig. 7. Example of CFGs with instructions

which in turn interprets byte code for the program to be
executed: the results are similar to those presented here, in
that we are able to remove most of the obfuscation and recover
deobfuscated control ﬂow graphs that are very similar to those
shown here. We selected a subset of our test programs which
we used for single-level emulation, including binary-search,
bubble-sort and matrix-multiply and obfuscated them using
Code Virtualizer, and then applied another round of emulation
using EXECryptor. Each of these programs therefore had two
levels of emulation. We also wrote an emulator, modeled
on DLXsim and SPIM, for a small RISC-like processor
that we call tinyRISC, and ran it on hand-compiled byte-
code for a binary-search program. This program was also
obfuscated using CodeVirtualizer and EXECryptor and is

included as tinyRISC:bin-search; this program uses three levels
of emulation (the tinyRISC emulator, Code Virtualizer, and
EXECryptor). Table II shows the similarity numbers for the
obfuscated and deobfuscated CFGs of our test programs. It
can be seen that the similarity of the deobfuscated CFGs and
the original CFGs ranges from 80.6% to 87.9%. This shows
that our approach is effective in cutting through multiple levels
of emulation.

The similarity between the numbers for the multi-level
emulated binaries and the ones obfuscated using only Code
Virtualizer in Table I suggests that applying additional levels
of emulation does not change the structure of the underlying
interpreted program, although the obfuscated programs are
quite different (see CFG similarity numbers for the obfus-

686686

cated programs in the two cases), and the execution traces
differ signiﬁcantly with those for multi-level emulation being
signiﬁcantly larger.

PROGRAM
binary-search
bubble-sort
matrix-multiply
tinyRISC:bin-search
AVERAGE

No. of
Levels
2
2
2
3

CFG similarity (%)
Obf.
4.45
6.41
5.26
4.45
5.14

Deobf.
85.29
80.64
81.63
87.87
83.85

SIMILARITY OF ORIGINAL AND DEOBFUSCATED CONTROL FLOW GRAPHS:

MULTI-LEVEL EMULATION. No. of Levels GIVES THE NUMBER OF

EMULATION LEVELS IN THE OBFUSCATED CODE.

TABLE II

B. Return-Oriented Programs

We evaluated our prototype implementation with two differ-
ent sets of ROP test cases. The ﬁrst set of binaries were sim-
ple synthetic programs including factorial, ﬁbonacci, matrix-
multiply and bubble-sort. These programs were implemented
by chaining relevant ROP gadgets from Windows system
libraries such as ntdll.dll and msvcrt.dll rather than
a high level programming language to carry out the intended
computation so they can simulate the behavior of ROP attacks.
We chose these programs because they have enough complex
structures such as loops and conditional statements to measure
the ability of a reverse engineering system which tries to
recover the logic of the underlying computation. For com-
parison purposes we also created the non-ROP version of the
programs which are written in C. We also applied our approach
to several ROP malware samples, but found that our ROP
malware samples had a relatively simple control ﬂow structure
since all they were trying to do was to change the access
permissions on some memory pages to make them executable.
As a result, our hand-crafted ROP benchmarks presented a
greater challenge for deobfuscation than the malware samples
we tested. For our hand-crafted ROP sample, we tried to use
ROPC [31] to create the ROP programs but, for a variety of
technical reasons, were not able to get it to work.

The similarity numbers for our synthetic programs are
presented in Table III. The column labeled Obf. shows the CFG
similarity of the ROP version of the program to its non-ROP
version and column labeled Deobf. shows the similarity of the

PROGRAM
factorial
ﬁbonacci
matrix-multiply
bubble-sort
AVERAGE

CFG similarity (%)

Obf.
47.61
30.61
64.51
48.22
47.73

Deobf.
88.88
85.71
79.22
82.85
84.16

SIMILARITY OF ORIGINAL AND DEOBFUSCATED CONTROL FLOW GRAPHS:

TABLE III

ROPS

deobfuscated ROP program to its non-ROP version. The table
shows that our method is also able to reverse engineer the ROP
gadgets and produce a very similar control ﬂow graph to the
non-ROP version by simplifying the ROP version execution
trace.

We have included the set of control ﬂow graphs of two ROP
programs, factorial and ﬁbonacci in Figure 8 very similar to
Figure 6. Note that the factorial program has a nested loop;
the reason is that we did not ﬁnd a multiplication gadget in
ntdll.dll or msvcrt.dll, so we simulated this using a
loop of additions.5

C. Comparison With Coogan et al.

We tested our approach against that of Coogan et al. [6]; the
results are shown in Figure 9. Coogan’s approach results in
complex equations that are difﬁcult to map to CFGs, especially
for nontrivial programs. Our approach, by contrast, produces
CFGs that can be meaningfully compared to the original
program’s CFGs. So we think that our approach produces more
understandable results than Coogan’s. We ran Coogan’s tool on
their set of test programs and mapped the resulting relevant
subtraces (which is equivalent to the deobfuscated program
in our terminology) to CFGs. We ﬁrst applied our tool on
the traces used by Coogan et al. in their experiments [6] and
compared the similarity of the resulting deobfuscated traces
with the original ones. To compare the result of the two tools,
we also generated CFGs of the relevant subtraces produced by
their tool and compared the CFGs to the original programs.
It can be seen, from Figure 9, that our system outperforms
Coogan’s tool with a 30% to 60% higher similarity numbers
in all the programs. We were not able to get a result of their
tool on the md5 program obfuscated using Code Virtualizer
because the computation did not ﬁnish on time so we did not
have any data for that. The small difference between similarity
numbers of the programs that are common in our set of input
programs and the set they used for evaluation, e.g., hunatcha,
is that the programs used by Coogan et al. and represented in
Figure 9 are slightly different from those used for Table I.

Coogan et al. do not apply their technique to obfuscations
other than emulation, nor do they provide results for multi-
level emulation.

V. DISCUSSION

Like all other work on automatic malware analysis, we
presuppose that the malicious code has been analyzed and
(since we are using dynamic analysis) an execution trace has
been collected. If a program attempts to thwart analysis via
anti-analysis defenses then those defenses will have to be
overcome before our techniques can be applied. This problem
is common to all work on automated malware analysis and is
orthogonal to the topic of this paper, so we do not pursue it
further here.

5This problem with unavailability of multiplication gadgets in Windows
system libraries, and a solution using iterated addition, is also discussed by
Roemer et al. [7].

687687

Original

ROP

(a) factorial

Deobfuscated

ROP

(b) ﬁbonacci

Deobfuscated

Fig. 8. Some examples of ROP deobfuscation results

CODE VIRTUALIZER

VMPROTECT

Original

)

%

(
y
t
i
r
a
l
i

m

i
s
G
F
C

100

80

60

40

20

0

i
c
c
a
n
o
b
ﬁ

e
s
o
o
M

l
l
u
B

t
l
u
m
-
x
i
r
t
a
m

a
h
c
t
a
n
u
h

l
a
i
r
o
t
c
a
f

5
d
m

e
g
a
r
e
v
A

i
c
c
a
n
o
b
ﬁ

e
s
o
o
M

l
l
u
B

t
l
u
m
-
x
i
r
t
a
m

a
h
c
t
a
n
u
h

l
a
i
r
o
t
c
a
f

5
d
m

e
g
a
r
e
v
A

Coogan’s approach

Our Approach

Fig. 9. Comparison with Coogan et al.

Code coverage can be an issue since we rely on dynamic
analysis, where only one execution path through the program
is observed. To overcome this problem we apply multi-path
exploration techniques based on concolic execution to iden-
tify inputs that will exercise alternative execution paths and
increase code coverage [21], [18]. The constraints used to iden-
tify such alternative inputs are computed from an execution
trace; in our system one can use either the original (obfuscated)
trace or the simpliﬁed trace for this. Our experiments indicate
that, due to the effects of obfuscation, the original traces

are often much larger and more complex than the simpliﬁed
traces, and result in correspondingly larger and more complex
constraints whose solutions require more time and memory.
We found that, in many cases, the constraint solver (our ex-
periments used STP [32]) fails to ﬁnd a solution for constraints
obtained from the original traces, e.g., because it runs out of
time or memory, but is able to solve those obtained from the
simpliﬁed traces. The process of deobfuscation is therefore
also helpful for exploring alternative behaviors in obfuscated
executables.

688688

   VirtualProtect

   GetProcAddress

   GetTickCount

   LoadLibraryA

   KiUserExceptionDispatcher

   __set_app_type

   __p__fmode

   __p__commode

   _controlfp

   _initterm

   __getmainargs

   GetStartupInfoA

   GetModuleHandleA

   SetErrorMode

   FreeLibrary

   GetSystemDirectoryA

   lstrcat

   GetModuleFileNameA

   lstrcpy

   lstrcmpi

   VirtualProtect

   GetProcAddress

   LoadLibraryA

   GetTickCount

   KiUserExceptionDispatcher

   __set_app_type

   __p__fmode

   __p__commode

   _controlfp

   _initterm

   GetStartupInfoA

   __getmainargs

   GetModuleHandleA

   FreeLibrary

   SetErrorMode

   GetSystemDirectoryA

   lstrcat

   GetModuleFileNameA

   lstrcpy

Original (cropped)

Deobfuscated (cropped)

Fig. 10.
shown in green while basic blocks that perform code unpacking, i.e., write to memory locations that are subsequently executed as code, are shown in red.

Partial Control ﬂow graphs for Win32/Kryptik.OHY Trojan before and after deobfuscation. The emulation-obfuscated portion of the program is

As discussed in Section II-C, our threat model assumes
that the adversary knows our semantics-based approach to
deobfuscation. We recognize three ways in which an adversary
can try to reduce the effectiveness of our analysis. The ﬁrst
is to leave the I/O operations of the input program unchanged
but entwine the obfuscation code with the original input-to-
output computation much more deeply in order to prevent the
obfuscation code from being simpliﬁed away. The second is to
introduce additional input/output operations into the program
along with (obfuscation) code that operates on the new input-
to-output ﬂow of values that this gives rise to. The third
approach is to hide some of the computation performed by
the program.

With the ﬁrst approach, entwining the obfuscation code
with the input-to-output ﬂow of values of the original pro-
gram in a way that is semantically signiﬁcant, but which at
the same time can be guaranteed to preserve the behavior
of the program being obfuscated, is a challenging problem
in general. The reason is that even simple transformations
can affect the observable behavior of the program, e.g., by
changing use/deﬁnition relationships, introducing arithmetic
overﬂow/underﬂow, or perturbing condition code settings. This
means that any such entanglement of the obfuscation code

will, at the very least, require sophisticated program analyses
that go well beyond the capabilities of today’s obfuscation
tools. Alternatively, instead of relying on general-purpose tools
capable of obfuscating arbitrary programs, the adversary could
try to hand-craft custom malware where the obfuscation code
is semantically integrated into the program logic. While such
an approach would reduce the efﬁcacy of our approach, it
would also require a lot more time and effort for malware
writers and would not scale.

The second approach actually changes the program’s se-
mantics (i.e., its observable interactions with its environment).
Since deobfuscation must preserve program semantics, a deob-
fuscation tool cannot reasonably be expected to automatically
disregard some of the semantically signiﬁcant operations of the
program. Thus, our approach will not be able to automatically
recover the logic of the original program in this case. However,
our ideas can be easily extended to deal with such obfuscations
interactively: the tool user can (optionally) specify some set
of input and/or output operations to be disregarded, and the
deobfuscation tool can simply not perform taint propagation
for the disregarded operations.

With the third approach, some of the logic of computation
can be hidden by performing the computation elsewhere, e.g.,

689689

on a remote host, where it cannot be observed. We note that
this would be a problem for every approach to automatic
deobfuscation that we are aware of, and believe that it is a
fundamental limitation of any automatic deobfuscation tool.
In summary, for each of these cases we signiﬁcantly raise

the bar for obfuscation of malicious code.

VI. RELATED WORK

the most

important being that

The work that is philosophically closest to ours is that
of Coogan et al. [6], who use equational reasoning about
assembly-level instruction semantics to simplify away obfus-
cation code from execution traces of emulation-obfuscated
programs. While their goals are similar to ours, the technical
details are very different. The biggest difference between the
two is in the processing and simpliﬁcation of execution traces.
The equational reasoning approach of Coogan et al. has some
signiﬁcant drawbacks,
is
difﬁcult to control the equational simpliﬁcation, making it hard
to separate out the different components of nested loops or
complex control ﬂow. This makes it difﬁcult for their approach
to extract the logic of the underlying computation into higher-
level structures such as control ﬂow graphs or syntax trees.
By contrast, our approach offers a lot more control over the
deobfuscation process and allows us to recover higher-level
representations, such as control ﬂow graphs, with a high degree
of precision, as illustrated by the data in Figure 9. Importantly,
Coogan et al. limit themselves to emulation-based obfuscation,
and provide data only for one level of emulation; by contrast,
we are able to handle multiple levels of emulation with good
results, and applies to other kinds of programs, e.g., ROPs.

it

Sharif et al. describe an approach [5] that works from the
outside in: it ﬁrst reverse engineers the VM emulator; uses
this information to work out individual byte code instructions;
and ﬁnally, recovers the logic embedded in the byte code
program. This outside-in approach can be very effective when
the structure of the emulator meets the assumptions of the
analyzer. However, when the emulator uses techniques that do
not ﬁt these assumptions the deobfuscator may not work well.
For example, this approach does not fully deobfuscate code
that has been obfuscated using Themida, which virtualizes the
unpacker routine for emulator instructions; for such programs,
it is able to automatically recover only the unpacker logic
(rather than that of the application), with further analysis then
done manually. We have recently seen similar characteristics
in code obfuscated with other emulation-based obfuscators
as well: e.g., a malware sample for Win32/Kryptik, whose
executable we obtained from virusshare.com, was found to
have been obfuscated using Code Virtualizer, with emulation-
obfuscation applied to just
the top-level unpacker routine
rather than the application logic (see Figure 10). We conjecture
that this selective application of emulation-based obfuscation
may have been motivated by a desire to avoid the space and
time overheads that would result from applying this obfusca-
tion to the entirety of the code; nevertheless, this development
suggests that obfuscation-speciﬁc approaches that focus on
identifying and reverse-engineering the emulator may become

690690

less effective in the face of selective application of obfuscation.
This approach may also not generalize easily to code that
uses multiple layers of emulation, since it may be difﬁcult to
distinguish between instruction fetches for various emulators.
Some researchers have proposed static approaches for sim-
plifying (quasi-)interpretive code. Udupa et al. [33] discuss
techniques for deobfuscating code that has been obfuscated
using control ﬂow ﬂattening [34], which in some ways resem-
bles emulation-based obfuscation. Jones et al. [35] describe
a technique called partial evaluation for specializing away
interpretive code. The analyses and transformations described
in these works are static, which suggests that it may not be
straightforward to apply them to highly obfuscated malware
binaries, e.g., due to dynamic unpacking and self-modifying
code.

There is a signiﬁcant and growing body of literature on
return-oriented programming, but most of it deals with attacks
[7], [8], [10], [11] or defenses [9], [36]–[38]. Lu et al. discuss
the conversion of ROP shellcode to semantically equivalent
shellcode that does not use ROP [9], but this work is speciﬁc
to ROP and not a generic technique.

VII. CONCLUSIONS

This paper describes a generic approach to deobfuscation
of executable code. Instead of making strong assumptions
about the obfuscation, e.g., the structure of the emulator, we
consider the semantics of the program in terms of the input-to-
output transformation it implements, and focus on identifying,
extracting, and simplifying the code that carries out
this
transformation. We have evaluated our approach on emulation-
based obfuscation and return-oriented programs. Experiments
using sophisticated commercial obfuscation tools indicate that
our approach is effective in stripping out the obfuscation and
extracting the logic of the original code.

VIII. ACKNOWLEDGMENTS

We are grateful to Patrick Chan for his implementation
of the control ﬂow graph similarity algorithm used in our
evaluation.

REFERENCES

[1] Oreans Technologies, “Code virtualizer: Total obfuscation against re-
verse engineering,” www.oreans.com/codevirtualizer.php.
[2] StrongBit Technology, “EXECryptor – bulletproof software protection,”

www.strongbit.com/execryptor.asp.

[3] VMProtect Software, “VMProtect – New-generation software protec-

tion,” www.vmprotect.ru/.

[4] Oreans Technologies, “Themida: Advanced windows software protection

system,” www.oreans.com/themida.php.

[5] M. Sharif, A. Lanzi, J. Gifﬁn, and W. Lee, “Automatic reverse engineer-
ing of malware emulators,” in Proc. 2009 IEEE Symposium on Security
and Privacy, May 2009.

[6] K. Coogan, G. Lu, and S. Debray, “Deobfuscating virtualization-
obfuscated software: A semantics-based approach,” in Proc. ACM Con-
ference on Computer and Communications Security (CCS), Oct. 2011,
pp. 275–284.

[7] R. Roemer, E. Buchanan, H. Shacham, and S. Savage, “Return-oriented
programming: Systems, languages, and applications,” ACM Transactions
on Information and System Security, vol. 15, no. 1, pp. 2:1–2:??, Mar.
2012.

[8] H. Shacham, “The geometry of innocent ﬂesh on the bone: return-into-
libc without function calls (on the x86),” in proc. ACM Conference on
Computer and Communications Security, 2007, pp. 552–561.

[9] K. Lu, D. Zou, W. Wen, and D. Gao, “deRop: removing return-oriented
programming from malware,” in Proc. 27th. Annual Computer Security
Applications Conference (ACSAC), Dec. 2011, pp. 363–372.

[10] T. Bletsch, X. Jiang, V. Freeh, and Z. Liang, “Jump-oriented program-
ming: A new class of code-reuse attack,” in Proc. 6th ACM Symposium
on Information, Computer and Communications Security, ser. ASIACCS
’11, 2011, pp. 30–40.

[11] S. Checkoway, L. Davi, A. Dmitrienko, A.-R. Sadeghi, H. Shacham, and
M. Winandy, “Return-oriented programming without returns,” in Proc.
ACM Conference on Computer and Communications Security, 2010, pp.
559–572.

[12] C. Kruegel, W. Robertson, F. Valeur, and G. Vigna, “Static disassembly
of obfuscated binaries,” in Proc. 13th USENIX Security Symposium,
Aug. 2004.

[13] M. G. Kang, P. Poosankam, and H. Yin, “Renovo: A hidden code
extractor for packed executables,” in Proc. Fifth ACM Workshop on
Recurring Malcode (WORM 2007), Nov. 2007.

[14] J. Stoy, Denotational Semantics of Programming Languages: The Scott-

Strachey Approach to Programming Language Theory. MIT, 1977.

[15] P.

Ferrie,

“Prophet

Sep.
www.virusbtn.com/virusbulletin/archive/2008/
09/vb200809-prophet-loss.

loss,” Virus Bulletin,

and

2008,

[16] A. Dinaburg, P. Royal, M. I. Sharif, and W. Lee, “Ether: malware analy-
sis via hardware virtualization extensions,” in Proc. ACM Conference on
Computer and Communications Security (CCS), Oct. 2008, pp. 51–62.
[17] B. Yadegari and S. Debray, “Bit-level taint analysis,” in Source Code
Analysis and Manipulation (SCAM), 2014 IEEE 14th International
Working Conference on.

IEEE, 2014, pp. 255–264.

[18] D. Brumley, C. Hartwig, Z. Liang, J. Newsome, D. Song, and H. Yin,
“Automatically identifying trigger-based behavior in malware,” in Botnet
Detection. Springer, 2008, pp. 65–88.

[19] V. Chipounov, V. Kuznetsov, and G. Candea, S2E: A platform for in-vivo

multi-path analysis of software systems. ACM, 2011, vol. 39, no. 1.

[20] K. Sen, D. Marinov, and G. Agha, CUTE: a concolic unit testing engine

for C. ACM, 2005, vol. 30, no. 5.

[21] A. Moser, C. Kruegel, and E. Kirda, “Exploring multiple execution
paths for malware analysis,” in Security and Privacy, 2007. SP’07. IEEE
Symposium on.

IEEE, 2007, pp. 231–245.

[22] E. J. Schwartz, T. Avgerinos, and D. Brumley, “All you ever wanted to
know about dynamic taint analysis and forward symbolic execution (but
might have been afraid to ask),” in IEEE Symposium on Security and
Privacy, 2010, pp. 317–331.

[23] C. Collberg, C. Thomborson, and D. Low, “Manufacturing cheap,

resilient, and stealthy opaque constructs,” in Proc. 25th. ACM Symp.
Principles of Programming Languages (POPL 1998), Jan. 1998, pp.
184–196.

[24] A. V. Aho, M. S. Lam, R. Sethi, and J. D. Ullman, Compilers –
Principles, Techniques, and Tools. Reading, Mass.: Addison-Wesley,
2007.

[25] D. Angluin, “On the complexity of minimum inference of regular sets,”

Information and Control, vol. 39, no. 3, pp. 337–350, 1978.

[26] E. M. Gold, “Complexity of automaton identiﬁcation from given data,”

Information and Control, vol. 37, pp. 302–320, 1978.

[27] L. Pitt and M. K. Warmuth, “The minimum consistent DFA problem
cannot be approximated within any polynomial,” J. ACM, vol. 40, no. 1,
pp. 95–142, 1993.

[28] X. Hu, T.-C. Chiueh, and K. G. Shin, “Large-scale malware indexing
using function-call graphs,” in Proc. ACM Conference on Computer and
Communications Security, Nov. 2009, pp. 611–620.

www.cert.org/historical/advisories/CA-

[29] W. worm,

2003-20.cfm.
[30] W32.Netsky.AE,

writeup.jsp?docid=2004-102522-4640-99&tabid=2.

[31] pakt,

“ROPC – Turing

complete ROP

compiler,” http:

www.symantec.com/security_response/

//gdtr.wordpress.com/2013/12/13/ropc-turing-
complete-rop-compiler-part-1/.

[32] V.

T.
https://github.com/stp/stp.

Ganesh

and

Hansen,

“STP,”

[33] S. K. Udupa, S. K. Debray, and M. Madou, “Deobfuscation: Reverse
engineering obfuscated code,” in Proc. 12th IEEE Working Conference
on Reverse Engineering, Nov. 2005, pp. 45–54.

[34] C. Wang, J. Davidson, J. Hill, and J. Knight, “Protection of software-
based survivability mechanisms,” in Proc. International Conference of
Dependable Systems and Networks, Jul. 2001.

[35] N. D. Jones, C. K. Gomard, and P. Sestoft, Partial Evaluation and

Automatic Program Generation. Prentice Hall, 1993.

[36] L. Davi, A.-R. Sadeghi, and M. Winandy, “ROPdefender: a detection
tool to defend against return-oriented programming attacks,” in Proc.
6th ACM Symposium on Information, Computer and Communications
Security (ASIACCS), Mar. 2011, pp. 40–51.

[37] K. Onarlioglu, L. Bilge, A. Lanzi, D. Balzarotti, and E. Kirda, “G-free:
defeating return-oriented programming through gadget-less binaries,”
in Proc. 26th. Annual Computer Security Applications Conference
(ACSAC), Dec. 2010, pp. 49–58.

[38] Y. Cheng, Z. Zhou, M. Yu, X. Ding, and R. H. Deng, “ROPecker: A
generic and practical approach for defending against ROP attack,” in
Proc. 21th Annual Network and Distributed System Security Symposium
(NDSS), Feb. 2014.

691691

