Tailing RFID Tags for Clone Detection

Davide Zanetti

Srdjan Capkun

Ari Juels

ETH Zurich, Switzerland

ETH Zurich, Switzerland

RSA, The Security Division of EMC

zanettid@inf.ethz.ch

capkuns@inf.ethz.ch

ajuels@rsa.com

Abstract

RFID (Radio-Frequency IDentiﬁcation) is a key emerg-
ing technology for supply-chain monitoring and detection
of counterfeit and grey-market goods. The most preva-
lent RFID tags are, however, simply “wireless barcodes,”
themselves vulnerable to cloning and counterfeiting. While
continuous monitoring can, in principle, detect cloning at-
tacks, real-world supply chains often contain signiﬁcant
blind zones where tag readings are unavailable, allowing
attackers to inject counterfeit goods with cloned tags into
supply chains undetectably.

This paper introduces tailing, a novel approach, both
simple and practical, for detecting cloned RFID tags in sup-
ply chains. With tailing, RFID readers write random values
to tags as they pass through a supply chain, creating in each
tag a tail composed of random values. The tails of legitimate
tags and cloned ones diverge over time, making cloning de-
tectable by a centralized detector even across blind zones.

We show that tailing works with existing barcode-type
tags (e.g., EPC tags). The centralized detector is non-
interactive, and requires no modiﬁcation of existing supply-
chain data ﬂows. We characterize the cloning-detection ef-
ﬁcacy of tailing analytically and through supply-chain sim-
ulations, showing that tailing presents high detection rates
and low false positive rates, as well as rate tradeoffs out-
performing those of previous schemes.

1

Introduction

Radio-Frequency IDentiﬁcation (RFID) tags are inex-
pensive wireless microchips used to identify physical ob-
jects. RFID tags are present in passports, drivers’ licenses,
clothing, payment cards, and on shipping cases.

A major driver of the deployment of RFID systems is to
prevent/detect counterfeiting, the introduction of fake goods
into a supply chain. By afﬁxing RFID tags directly to goods
or the cases in which they are transported, supply-chain
partners can automatically track goods in transit, facilitat-
ing detection of counterfeits. Counterfeit detection is of vi-

tal importance to many industries, such as the pharmaceu-
tical industry, in which counterfeit goods have caused not
only large proﬁt losses, but also patient deaths [25]. De-
tection of counterfeit items in RFID-enabled supply chains
may seem straightforward, since RFID tags typically emit
unique identiﬁers: A supply-chain partner can in principle
conﬁrm an object’s authenticity by checking its serial num-
ber against a shipping manifest or with a directory service
spanning supply-chain partners, e.g., EPCIS [10]. However,
two major challenges to RFID counterfeit detection remain:
Cloning attacks and fragmentary supply-chain visibility.

Cloning attacks. Due to cost and power constraints, most
RFID tags used in supply chains, known as EPC (Electronic
Product Code) tags [11], have only “barcode”-like function-
ality. They emit raw data, with no authentication; their full
data contents may then be easily extracted and copied into
a special-purpose clone device or another tag [20]. Even
tags with cryptography generally offer minimally effective
tamper resistance or side-channel protections [12, 28].

Fragmentary supply-chain visibility. RFID tags are gen-
erally passive devices that transmit data only to nearby
RFID readers. Their range is often limited to just tens of
meters, and potentially further reduced by factors such as
tag orientation, tag placement, and nearby materials (e.g.,
metal, water). Additionally, in supply chains, large pop-
ulations of tags are often scanned in a short time (like a
pallet of tagged goods passing through an RFID-enabled
gate), causing read failures. Finally, some commercial part-
ners cannot share supply-chain information or do not do so
for fear of disclosing sensitive business intelligence. Entire
segments of a supply chain may be opaque to participating
entities. Thus, real-world supply chains often have large
“blind zones,” in which RFID tags scans do not happen or
are not reported.

These two challenges undermine the effectiveness of
unique identiﬁers in clone detection. Authentic identiﬁers
do not ensure authentic tags or goods. Even natural de-
tection strategies like looking for multiple, simultaneous
appearances of the same tag identiﬁer have limited effect.
Blind zones can mask evidence of cloned tags or create in-
consistencies in observed tag paths that lead to false alarms.

In this paper, we introduce a new approach to clone de-
tection in RFID-enabled supply chains that we call tailing.
Tailing consists of RFID readers writing random symbols
into tags, creating in each tag a tail of values that evolves
over time. Writing multiple symbols into the tags grad-
ually randomizes the tails; this preserves symbol discrep-
ancies over time, propagating them through blind zones.
While passing through the supply chain, clones and authen-
tic tags thus diverge in appearance, rendering clones more
easily detectable. Tailing does not rely on any pre-deﬁned
(in)correct information based on supply-chain structure or
product ﬂow, which would make it sensitive to shifts in
supply-chain dynamics.
It relies instead on purpose-built
evidence in the form of tails.

We analyze tailing both analytically and through sim-
ulations. To this end, we introduce an adversarial model
suitable for the study of RFID clone-detection, which cap-
tures a broad space of adversarial capabilities such as reader
compromise, and factors in chain conﬁguration and visibil-
ity. To the best of our knowledge, it is the ﬁrst supply-chain
model in which adversaries can compromise readers.

We ﬁrst explore tailing analytically by evaluating the
probability of successful clone injection, i.e., undetected
passage of a clone through the supply chain. We show that
tailing diminishes the success probability of even strong ad-
versaries that compromise many readers. We then eval-
uate the impact of blind zones and reader errors, show-
ing the effectiveness of tailing in the face of the resulting
fragmentary visibility.

Secondly, we holistically evaluate the security of tail-
ing by simulating its use in various supply-chain scenarios
with different degrees of visibility, chain structures, prod-
uct ﬂows, and adversaries. These simulations show that
tailing achieves high clone-detection rates and low false-
alarm rates even when visibility is highly fragmentary, as in
real-world RFID-enabled supply chains. We further com-
pare our mechanism against existing approaches [24, 36];
we ﬁnd that tailing outperforms them in terms of true posi-
tive rate / false negative rate tradeoffs.

Finally, we show that tailing meets the resource require-
ments of ordinary, barcode-type RFID, such as EPC tags
(e.g., tailing requires only 8 bits of tag memory).
In ad-
dition, we show that tailing should scale with acceptable
overhead in real-world supply chains.

The rest of the paper is organized as follows.

In Sec-
tion 2 we describe the considered supply-chain scenario and
our system and adversarial models. We introduce tailing in
Section 3 and provide an overview of our main results in
Section 4. We present the results of analytic, simulation-
based, and performance evaluations in Sections 5, 6, and 7
respectively. We compare tailing to existing work in Sec-
tion 8, while Section 9 gives an overview of related work.
We conclude the paper in Section 10.

2 Problem Statement

We now describe the considered RFID-enabled supply-
chain scenario and present our system and adversarial mod-
els, which are depicted in Figure 1.

2.1 RFID(cid:173)enabled Supply Chains

RFID-enabled supply chains are traditional supply
chains enhanced such that each product (or pallet of prod-
ucts) is equipped with an RFID tag containing a unique
identiﬁer (ID). Supply-chain partners, like manufacturers,
distributors, and retailers deploy RFID systems to create,
store, and share observations of the tags/products circulat-
ing in the supply chain. An RFID system is typically com-
posed of a front end, which includes RFID tags and read-
ers, and a back end, which includes databases and service-
oriented platforms like discovery and tracking services.

A product and its tag are considered to be a single, in-
separable element. Tag hardware is constrained: Tags have
limited memory and only basic functional capabilities. We
assume no (cryptographic) authentication between tags and
readers, as is the case with the EPC C1G2 standard [11] – a
de facto RFID standard for supply chains. We also assume
that the tag ID is not writable, but the tag memory can be
read and (re)written by any nearby reader.

On each tag observation by a reader, an event is created
and stored in a local database. An event encapsulates in-
formation about the process S (e.g., receiving, stocking, or
shipping), occurrence time T , and location L in which a
product/tag ID is sighted. Two special events are created
when tags enter the supply chain (an into-the-chain event,
created at the manufacturer when tags and IDs are assigned
to products) and when tags leave the chain (out-of-the-chain
event, created at the retailer). Each supply-chain partner is
equipped with multiple RFID readers and local databases.
Third party services may be authorized to access, aggregate,
and analyze events from partners’ local databases, typically
to optimize business processes.

Our approach assumes failures in the front end during
tag-reader communication, but that back-end failures are
negligible. We also consider that some partners may not
share data. We call it a misevent when an event is not re-
ported (shared), a misread when a tag passes unnoticed (i.e.,
when no events are created), and a miswrite when a tag write
operation fails (possibly corrupting memory). We do not
consider broken or damaged tags and we assume that phan-
tom reads are negligible and that multiple reads of the same
tag are ﬁltered out during data collection.

As for the supply-chain structure, we assume that part-
ners know only their direct business partners and may con-
tinuously join and leave the chain. In terms of product ﬂow,
we consider recalls as well as misdeliveries.

Counterfeiter

123

1

Manufacturer

L1

123

ID

123

T

L

S

11:20.120
25/07/12

L1 Shipping

Distributor

L2

2

123

123

3

Distributor

L3

123

123

123

5

6

Retailer

L4

123

4

Retailer

L5

Retailer

L6

123

123

7

1

2

3

Counterfeiter

Counterfeit injection point

4

5

Compromized RFID reader

Inactive RFID reader

Misread

6 Misevent (DB not online)

7 Miswrite

Figure 1. An RFID(cid:173)enabled supply chain af(cid:173)
fected by blind zones and reader failures (mi(cid:173)
sevents, misreads, miswrites, inactive read(cid:173)
ers), as well as by counterfeiter’s actions
(clone injection, reader compromise), while
a genuine product (ID = 123) and its clone
are circulating in it.

2.2 System and Adversarial Models

The goal of the adversary is to inject counterfeit goods
into the supply chain without detection by a centralized de-
tector. This detector has a global view of the tags/goods
in the supply chain: It collects and correlates events from
the local databases of supply-chain partners. The adversary
seeks to hide the presence of its counterfeits from the de-
tector. We assume that all genuine products in the supply
chain carry RFID tags. Therefore, a counterfeit product will
pass as genuine only if it is equipped with a tag. Moreover,
that tag must bear a valid and unique ID associated with a
genuine product.

The visibility of the detector into the supply chain is lim-
ited to a subset of readers that participate in clone detection,
and is affected by misevents, misreads, and miswrites. The
detector does not rely on any pre-deﬁned information about
the supply-chain structure (e.g., partner relationships and
locations) and product ﬂow (e.g., transportation times).

The adversary controls a subset of readers. Such control
models several forms of adversarial intrusion into the sup-
ply chain, including collusion with supply-chain partners,
corruption of reader hardware/software, bribery of employ-
ees, and so forth. When the adversary compromises readers
participating in the clone detection, it controls the channel
to the detector and can dictate if and what data the latter
receives. The adversary can inject new products into the

supply chain with RFID tags bearing data of its choice and,
additionally, knows valid identiﬁers for all tags in the sup-
ply chain at any given time. We call a clone a counterfeit
product that carries a valid ID. The adversary may perform
any of the following actions at the compromised readers:

• Emulation: The adversary may simulate the presence

of an RFID tag, with data of its choice.

• Blocking: The adversary may prevent a compromised

reader from scanning selected nearby RFID tags.

• Tampering: The adversary may alter the data contents
of passing tags, but not tags’ IDs, which are read-only.

The adversary also knows the paths followed by products
in the supply chain.
(Paths tend to be dictated by easy-
to-ascertain commercial relationships, and are often fairly
stable over time.) Thus it has the following capabilities:

• Injection point selection: The adversary can select

counterfeit injection points.

• Knowledge of genuine path: The adversary knows the

paths of genuine products.

• Knowledge of counterfeit path: The adversary knows

the paths of counterfeit products.

The adversary is, however, restricted in three key regards:

• No access to detector database: The adversary cannot
read or modify data gathered by the detector (but can
add data to the database via emulation).

• No product ﬂow (path) modiﬁcation: The adversary
cannot modify the paths followed by genuine goods in
the supply chain (but can specify the paths taken by
counterfeit products).

• No product ﬂow (lead time) modiﬁcation: The adver-
sary cannot modify the product lead times (i.e., the
times that products spend in the different steps of the
supply chain like warehousing or transportation). The
adversary does, though, learn the relative timestamps
of the events for both genuine and counterfeit prod-
ucts. (For example, the adversary knows that reader i
scans a genuine product before reader j scans the cor-
responding counterfeit.)

Finally, we assume that a counterfeit appearing before
the genuine product enters, or after it leaves the supply
chain is easily detected by verifying the corresponding into-
the-chain and out-of-the-chain events. We refer to such a
detection mechanism as whitelist-based detection.

3 Tailing for Clone Detection

Tail, Pointer

AXC,2

AXY,3

WXY,1

WMY,2

Genuine product

123

123

123

123

Tailing relies on the creation and veriﬁcation of traces
of collected tag events. It requires collaboration between
supply-chain partners and a service-oriented platform, the
detector, and draws information from across the entire
RFID system. It involves four different steps: (i) Tail mod-
iﬁcation, (ii) event collection, (iii) rule veriﬁcation, and
(iv) clone detection.

3.1 Tail Modiﬁcation

As previously mentioned, a tag’s tail consists of a se-
quence of random symbols that evolve over time. Tail mod-
iﬁcation is performed individually by each RFID reader par-
ticipating in clone detection. It requires no interaction with
the detector or other supply-chain partners (or other read-
ers, for that matter). The operation of tail modiﬁcation is
an extension of the tag observation operation as detailed in
Section 2.1, and affects both the tag memory and the obser-
vation event stored in the local database.

To modify a tag’s tail, a reader refers to a stored value (in
the tag memory) that we call the tail pointer, which points
to the most recently modiﬁed tail position. It then writes a
piece of random data (some random bits), a symbol, to the
next available position in the tag memory, and increments
and writes the new tail pointer value. The associated event
created and stored in a local database includes, in addition
to the ID, T , L, and S attributes, the tag tail T T and the
tail pointer T P . It also includes a tailing ﬂag T F , which
indicates if the event is usable by the detector (i.e., that the
reader is participating in tailing and the event appears to be
valid). More precisely, to modify a tail, a reader: (i) Reads
the tag ID, tail, and tail pointer from tag memory, (ii) up-
dates the tail pointer (unitary increment, with wraparound)
and stores it in the tag memory, (iii) picks a random symbol
and inserts it in the tail, i.e., writes it to the next available
position indicated by the pointer, and (iv) creates an event
containing attributes (ID, T, L, S, T T, T P, T F ) and adds
it to its local database.

Naturally, partners must agree on or standardize system
parameters for use by the detector. A reader can at any time
signal non-participation by marking its events as unusable
using the tailing ﬂag (T F ).

3.2 Rule Veriﬁcation and Clone Detection

Upon request by a supply-chain partner, the detector col-
lects all of the events (with valid T F s) related to a speciﬁc
tag ID to build what we call a tag trace. It validates this
trace, looking for evidence of cloning, against a set of rules
that we now describe.

Tag trace
(events)

AXC,2

AXY,3

WXY,1

WMY,2

Rule Verification

t0

t1

(a)

t2

t3

t

Tail, Pointer

AXC,2

AXY,3

WXY,1

WMY,2

Genuine product

123

123

123

123

Tail, Pointer
Counterfeit
product

Tag trace
(events)

Rule Verification

AMC,2

AML,3

PML,1

123

123

123

Clone

injection

AXC,2

AXY,3

AML,3

WXY,1

PML,1

WMY,2

t0

t1

t2

t3

t4

t5

t6

t

(b)

Figure 2. Rule veriﬁcation on (a) the tag tail
and pointer of a genuine product and (b) the
tails and pointers of a genuine and a coun(cid:173)
terfeit product together. Values are given af(cid:173)
ter a reader updates the tail and pointer.
In
this example, the tail is composed of 3 sym(cid:173)
bols. Each symbol is an 8(cid:173)bit value (exempli(cid:173)
ﬁed with ASCII characters).

Intuitively, a pair of events should reﬂect the results of
valid tag modiﬁcation operations. In particular, a pair com-
posed of two time-consecutive events ei and ei+1, having
tail and tail pointer equal to T Ti and T Pi, and to T Ti+1
and T Pi+1, respectively, is considered correct if and only
if: (i) The symbols in the tail T Ti+1 are the same of those
in T Ti (except in position T Pi+1), and (ii) the tail pointer
T Pi+1 presents a unitary increment with respect to T Pi.
Formally, these two rules are:

( T Ti+1[n] = T Ti[n]

T Pi+1 − T Pi = 1 (mod t),

∀n \ T Pi+1

(1)

where n ranges from 1 to tail size t (in symbols) and T T [n]
indicates the n-th symbol in the tail T T .

Figure 2(a) shows a (genuine) tagged product and its tag
tail and tail pointer when it circulates in an RFID-enabled
supply chain with tailing enabled (the tail and pointer values
are shown after a reader’s update). All the pairs of time-
consecutive events are successfully veriﬁed, i.e., meet the
two above rules. In contrast, Figure 2(b) shows two prod-
ucts with the same tag ID, i.e, a genuine and a counterfeit

Tail, Pointer

AB,1

Genuine product

123

AX,2

123

Tail, Pointer

AB,1

AX,2

Miswrite
HG,2

RG,1

Genuine product

123

123

123

123

RT,2

123

Tail, Pointer
Counterfeit
product

Tag trace
(events)

Rule Verification

AZ,1

AR,2

GR,1

GL,2

AL,1

123

123

123

123

123

Clone

injection

AB,1

AR,2

GR,1

GL,2

AL,1

AX,2

Tail, Pointer
Counterfeit
product

Tag trace
(events)

ED,1

ED,1

123

123

Clone

injection

Misread

Misevent

AB,1

AX,2

WX,1

RG,1

RT,2

t0

t1

t2

t3

t4

t5

t6

t

t0

t1

t2

t3

t4

t5

t6

t

Rule Verification

(a)

(b)

Figure 3. Tailing rule veriﬁcation under (a) false event consistency and (b) weak visibility (misev(cid:173)
ents, miswrites leading to memory corruption, and misreads). To avoid clone evidence, in (a) the
counterfeit tail and pointer at times t1 and t5 have to be correctly set.

product. Due to tail and pointer inconsistencies, some pairs
fail the rule veriﬁcation and show evidence of cloning.

3.3 Main Challenges

There are two main obstacles to successful detection via
tailing: False event consistency, i.e., suppression or loss of
clone evidence, and weak visibility, i.e., event streams that
are fragmentary or error-prone.

False event consistency. Continuously updating tails with
random values makes it difﬁcult for the adversary to guess
tail contents: Even if the adversary knows a tail value at
time ti, at time ti+j, there are j new symbols to guess. Ad-
ditionally, updating the tail and incrementing the pointer in
an ordered sequence builds a relationship between two time-
consecutive events: Any extra adversarial event between
two time-consecutive events will break this relationship, re-
sulting in clone evidence.

An adversary can nonetheless, with some probability,
cancel out clone evidence. This is clearly possible when the
adversary controls all the readers through which a counter-
feit product (or the genuine one) passes. Even if the adver-
sary has no control or partial control of readers, though, a
chance remains that no clone evidence appears. Figure 3(a)
illustrates, given a genuine and a counterfeit product, how
this can happen. If the counterfeit tail and pointer are, by
chance, consistent with the genuine tail and pointer at the
injection time t1 and at time t5, no clone evidence would ap-
pear between events at times t0 and t2, and between events
at times t5 and t6. By controlling only a subset of the read-
ers, an adversary may increase the probability of such de-
tection failure. For example, by controlling the reader that
operates the genuine product at time t0, the adversary would
learn the genuine product tail and pointer and could ensure
consistency at time t1. For the adversary’s clone now to

pass undetected, the adversary would only need the coun-
terfeit tail to be correctly set by chance at time t5. Obvi-
ously, many factors (e.g., tail and symbol sizes) impact the
probability of such undesired chance events.

Weak visibility. Blind zones and reader errors create frag-
mentary and erroneous visibility in the supply chain, mask-
ing evidence of clone tags or creating inconsistencies in the
observed tag paths that lead to false alarms. The causes
of fragmentary and erroneous visibility are misevents, mis-
reads, and miswrites. A misevent occurs when a relevant
event is not available to the detector. Misevents do not
obstruct the tailing operation, i.e., the tag memory is cor-
rectly modiﬁed, but they result in lost events. As shown in
Figure 3(b), this loss creates inconsistencies in tag traces
as two reported time-consecutive events appear as non-
consecutive, potentially raising a false alarm. Misevents
may also mask clone evidence, as may misreads. A mis-
read occurs when a tag passes unnoticed through a reader,
so that no tail update or event creation results. As shown in
Figure 3(b), misreads can lead to missed clones. A miswrite
occurs when a tag write operation fails. Miswrites include
cases when tags (i) reply with a write failure message (tag
memory is not modiﬁed); alternatively, they may not re-
port the result of the write operation and may have: (ii) Not
modiﬁed, (iii) correctly modiﬁed, or (iv) incorrectly modi-
ﬁed (corrupted) the tag memory. When a reader reports a
miswrite by ﬂagging an event as unusable using T F , case
(iii) is comparable to a misevent, while cases (i) and (ii) are
comparable to a misread. As shown in Figure 3(b), case (iv)
creates inconsistencies that potentially raise a false alarm.

4 Overview of Main Results

We evaluate our tailing mechanism in terms of security
and robustness through both an analytic (Section 5) and a

simulation-based (Section 6) study. We also evaluate its
performance in terms of required storage, computational ef-
fort, communication costs, scalability, and tag processing
speed (Section 7). Finally, we compare it against previous
work [24, 36] in a simulation-based study (Section 8).

In our analytic evaluation, we abstract the supply chain
and the product ﬂow into two independent event sequences
associated, respectively, with a genuine product and its
clone. For each of the possible combinations of these se-
quences and a given adversary, we compute the probabil-
ity that a combination does not present any clone evidence.
By summing probabilities across combinations, we quan-
tify the adversary’s success probability in injecting clones,
i.e., the probability that injected clones pass unnoticed by
tailing detection.

In the simulation-based evaluation, we model a sup-
ply chain by its structure (partners and their relationships),
product paths, lead times, and RFID system (readers and
failures). We deploy a custom-built RFID-enabled supply-
chain simulator to generate a ﬂow of products from the
manufacturers (both genuine and counterfeit) to the retail-
ers, and to populate the detector’s database with tag events
recorded by each partner’s reader during the simulation.
We then compute the clone-detection and false-alarm rates
when products leave the chain at the retailers.

Analytic evaluation. We show that our tailing mechanism
drastically limits the adversary’s success probability, even
when the majority of the readers in the clone path have
been compromised. For example, blocking 2, 3, or 4 out
of 5 readers in the clone path leads to an adversary’s suc-
cess probability of 0.81, 3.6, and 12.5% respectively. We
also show that the optimal symbol size is 1 bit, while a
tail larger than 5 symbols does not provide any signiﬁcant
advantage over adversaries that compromise readers. This
means that our mechanism requires a limited tag memory
space as small as 8 bits (5 bits for the tail, 3 bits for the
tail pointer). Additionally, we compute an upper bound on
the adversary’s success probability by considering an adver-
sary that can select the optimal strategy (in terms of read-
ers to compromise and actions to perform) for each injected
clone. Although such a strong and arguably non-realistic
adversary presents high(er) success probabilities, e.g., 15,
52, and 90% when compromising 2, 3, or 4 readers respec-
tively (5 on the clone path), our tailing mechanism is still
able to detect a fraction of the injected clones.

Our mechanism relies on purpose-built, artiﬁcial infor-
mation that is independent from the supply-chain structure
and the product ﬂow. That is, it does not require any pre-
deﬁned (in)correct information such as “Product X has to
go through locations Lx, Ly, and Lz at times tx, ty, and tz.”
Thus our mechanism is unaffected by extraordinary ﬂow
deviations and changes in the supply-chain structure, due,
for example, to product recalls, misdeliveries, and partners

joining and leaving the chain. Although blind zones and
reader failures (i.e., misevents, misreads, and miswrites)
negatively impact our mechanism, we show that it miti-
gates the negative effects of misevents and miswrites (false
alarms) with no (signiﬁcant) increase in the adversary’s suc-
cess probability. Misevents are mitigated by hypothesiz-
ing missing events between two reported time-consecutive
events that present tail and pointer inconsistencies. If there
exists at least one missing event that would resolve these
inconsistencies, the ostensible clone evidence is discarded.
Such ﬂexibility is possible because our tailing mechanism
updates the tail and increments the pointer in an ordered
sequence, allowing for trace reconstruction. Miswrites are
mitigated by speciﬁcally reporting write failures through
an additional event attribute. A reader that does not re-
ceive a correct write response from a tag sets this attribute
in the corresponding event. The detector will then ignore
the inconsistencies resulting from that event and succeed-
ing one. We ﬁnd that misreads create clone misses that may
signiﬁcantly increase the adversary’s success probability.
We show, however, that even for a high number of mis-
reads, our mechanism is still able to detect a portion of the
injected clones. For example, an adversary that compro-
mises 4 out of 5 readers in the clone path presents a suc-
cess probability of 56% even when half of all events are
subject to misreads.

Simulation-based evaluation. We show that our mecha-
nism presents a high detection rate for a relatively low false-
alarm rate, as well as a relatively high detection rate for
a false-alarm rate of 0. For example, in a scenario where
an adversary injects clones with no reader compromise and
more than 60% of all traces contain at least one inconsis-
tency due to misevents, misreads, or miswrites, we observe
detection rates of 93% and 80% for false-alarm rates of
0.95% and 0% respectively. This result holds for differ-
ent supply-chain structures and clone injection rates. We
also show that our mechanism presents good detection and
false-alarm rates in scenarios where a large majority of the
tag traces (85%) present inconsistencies: We observe de-
tection rates of 86% and 64% for false-alarm rates of 2.8%
and 0.01% respectively. We observe that our mechanism is
affected by the length of clone paths: The longer the path,
the higher the number of instances of clone evidence. Even
within scenarios where clone paths are short (e.g., when the
adversary injects at the retailers), our detection mechanism
still provides a high detection rate (>85%) for a relatively
low false-alarm rate (0.95%). We also observe that although
an adversary compromising readers can signiﬁcantly reduce
the detection rate, only controlling the (quasi) totality of all
clone paths leads to no detection at all. For example, in a
simulated scenario with a 15-partner supply chain, we ob-
tain detection rates of 74% and 6% for an adversary con-
trolling 3 and 12 of the 15 partners, respectively.

Performance evaluation. Our mechanism’s resource costs
are independent of the overall number of tags in the system.
Instead, its required storage capacity, computational / ac-
cessing effort, and communication costs are linearly depen-
dent on the number n of events in the traces under evalua-
tion; thus the mechanism’s resource costs also scale linearly
with n. The tag processing speed (i.e., speed at which tag
IDs can be read) is affected by the tailing operation between
a tag and reader, which includes (tail and pointer) read and
write operations on tag memory. Despite the limited tag-
memory requirement of our mechanism, it reduces the nom-
inal tag processing speed in an EPC C1G2-compliant im-
plementation from 24.4/1838 tags/s (lower/upper bound) to
9.6/44.5 tags/s. We argue, however, that tailing can be per-
formed by a few readers in a supply-chain facility (e.g., only
upon product receipt and shipping); thus it is a rare opera-
tion with little overall processing overhead. Consequently,
we believe that tailing promises to be highly scalable in real-
world supply-chain environments.

Comparison. We compare our tailing mechanism against
the mechanisms proposed by Lehtonen et al. [24] and
Zanetti et al. [36]. Our exploration indicates that both mech-
anisms present limitations that make our tailing mechanism
the most suitable solution for scenarios in which inconsis-
tent information may undermine clone detection. This su-
periority holds not only by comparison with the mentioned
mechanisms, but also for their robust variants that we pro-
pose and explore in our evaluation. The mechanism pro-
posed by Lehtonen et al. suffers mainly from false alarms
due to misevents and miswrites. Its robust variant mitigates
miswrite effects, but is not effective against misevents. The
mechanism proposed by Zanetti et al. suffers mainly from
false alarms due to misevents and misreads. Although its ro-
bust variant mitigates both misevent and misread effects, no
improvement in its detection/false-alarm tradeoff results. In
a scenario where an adversary injects clones with no reader
compromise and more than 60% of all traces contain at least
one inconsistency, we observe detection/false-alarm rates of
89%/32%, 94%/16%, and 93%/0.95% for the Lehtonen et
al., the Zanetti et al., and our tailing mechanisms, respec-
tively. With their false-alarm rates set to 0%, their respec-
tive detection rates drop to 37%, 34%, and 80%.

All three mechanisms present the same (asymptotic)
required database storage capacity, computational effort,
communication costs, and scalability. However, despite
its poor detection/false-alarm tradeoff, the mechanism pro-
posed by Zanetti et al. has the beneﬁt of not relying on
tags’ rewritable memory, and thus avoids a mechanism-
dependent degradation of the nominal tag processing speed
(max. 1838 tags/s). Although the mechanism proposed
by Lehtonen et al. presents severely limited tag processing
speeds due to its online execution (max. 4.5 tags/s), an of-
ﬂine variant offers the same performance as tailing.

5 Analytic Evaluation

We now evaluate the success probability of an adversary
in injecting a counterfeit product into a supply chain given
the use of tailing (Section 5.2). We also evaluate the robust-
ness of tailing against misreads, miswrites, and misevents
(Section 5.3).

5.1 Deﬁnitions

We model the supply chain S as an acyclic, directed
graph H = (V, K), in which nodes V represent readers
and edges K represent supply-chain paths between readers.
Products enter the graph / supply chain at a source node and
traverse edges along a path π until they reach the sinks.

The detector D has limited visibility into the supply
chain, corresponding to a subset of readers VD ⊆ V . We de-
ﬁne G = (g0, ..., gm) as the sequence of detection-relevant
events associated with a genuine product following a path
πG with start node vG,0 and sink vG,m. VG indicates the
nodes in πG (VG ⊆ VD). For a clone product, we deﬁne
C = (c0, ..., cn), πC (with start node vC,0 and sink vC,n),
and VC (VC ⊆ VD) analogously.

The detector performs event collection at some time tD,
triggered by a product reaching its sink. We deﬁne an event
trace GC as a time-sorted combination of the sequences
G and C at the detection time tD. We consider g0 to
be the into-the-chain event for the genuine product; there-
fore, the ﬁrst event of a combination GC is g0. We de-
ﬁne TGC(G, C) = (GC0, ..., GCj) as the set of all possible
combinations of the sequences G and C. The set size |TGC|

is equal to(cid:0)|G|+|C|+1

|C|+1 (cid:1) − 1.1

Each reader may fail with probability pmw in a tag write
operation and with probability pmr in a tag read operation.
The detector receives an event in G or C with probability

by the detector at detection time tD.

Trace evidence. We deﬁne Ppass as the probability that a

pme. Thus we deﬁnedGC as the actual event trace received
tracedGC contains no clone evidence according to the detec-

tor D and given adversary A. E = (ǫ0, ..., ǫi) denotes clone
evidence instances observed under the rule set of Equation 1
based on a tailing operation with tag tail size t (in symbols),
tail symbol size s (in bits), and tail pointer size p = log2(t).
The size m of the tag memory dedicated to the detection
mechanism is equal to t · s + ⌈p⌉ bits. We specify Ppass as:

Ppass =

|E|−1Yi=0

Pǫi =(cid:18)

1

2(t−1)·s+p(cid:19)a0

·

|E|−1Yi=1 (cid:18) 1

2(t−1)·s(cid:19)ai

· bi.

1Combination with repetitions (cid:0)n+k−1

k

(cid:1) for n = |G|+1, k = |C|+1.

−4

10

−6

10

t=2, s=15

t=3, s=10

−8

10

c
c
u
s

P

 

t=4, s=7

 

t=7, s=4

t=14, s=2

t=27, s=1

0
10

−4

10

−8

10

c
c
u
s

10

P

−12

−10

10

−12

10

 

 
1

2

−16

10

−20

10

−24

10

 

0

9 10

4

3
8
|C| (# of clone events)

5

6

7

 m=4 bits

 m=8 bits

 m=16 bits

 m=32 bits

 m=64 bits

1
| (# of compromized readers)

3

4

2

|V

A

5

 

0
10

−1

10

−2

10

c
c
u
s

P

−3

10

−4

10

−5

10

 

 
0

 

 

)
s
r
e
d
a
e
r
 
f

o

 

m=16 bits

m=32 bits

m=64 bits
m=8 bits, A
1

m=4 bits

m=8 bits

#
(
 
|

i

n
m
A

,

V

|

 ES
 K
h

5

4

3

2

1

1
| (# of compromized readers)

2

3

4

|V

A

5

 
 
 

 

1

2

4

3
8
|C| (# of clone events)

5

6

7

 

 
 
 

9 10

(a)

(b)

(c)

(d)

Figure 4. Study of clone events and compromised nodes for 1bit(cid:173)tailing (|G| = 10 events). Graphs
show: (a) Success probability Psucc for adversary A0 as a function of number |C| of clone events for
various values of tail size t and tail symbol size s (m = 32 bits); (b) Psucc for adversaries A0 and A1 as
a function of compromised nodes |VA| for various tag memory sizes m (s = 1 bit, |C| = 5, and |VA| = 0
for A0); (c) Same as graph (b), but for A2; (d) Mean number of readers that A3 must compromise to
suppress evidence fully in a set TGC(G, C), as a function of |C|, for strategies Kh and ES.

Here, Pǫi is the probability that clone evidence ǫi passes
unnoticed (does not appear); ai = 0 when adversary A can-
cels out evidence ǫi (otherwise ai = 1); bi = 0 when the
number n of (clone or genuine) events between evidence
ǫi−1 and ǫi is not a multiple of t (otherwise bi = 1). The
ﬁrst term (i = 0) captures the probability that a clone is in-
jected with correct tail and pointer values (w.r.t. the genuine
product). The second term (i > 0) captures the probability
that consistent genuine and clone tails (and pointers) remain
consistent after n tailing operations on one of the two tails
(i.e., lack of clone evidence persists).

Adversary’s success probability. We deﬁne Psucc as the
probability that a clone injected by adversary A into the
supply chain at node vC,0 ∈ V is not observed by the de-
tector D. This success probability sums over all possible
combinations of the sequences G and C. It is deﬁned as:

Psucc =

|TGC |−1Xi=0

PGC(GCi) · Ppass(dGC i, A),

where PGC(GCi) is the probability associated with combi-
nation GCi under probability distribution PGC .

Adversary. Under the model of Section 2.2, we deﬁne a
hierarchy of adversaries, ordered by increasing capability:

A0: The adversary injects clones into the supply chain at
some selected node vC,0, but does not compromise
readers or inﬂuence product paths.

A1: The adversary injects clones at some selected node
vC,0 and compromises a set of readers VA (chosen ran-
domly) on the clone path πC (VA ⊆ VC ⊂ VD). Since
the adversary has no knowledge of the genuine path

πG, it only prevents compromised readers from scan-
ning clones (i.e., blocks them).

A2: Along with A1’s capabilities, the adversary can eaves-
drop on genuine path πG so as to inject clones with
correct memory content, i.e., Pǫ0 = 1 for all GCi.

A3: The adversary knows relative event timestamps and
also knows genuine paths and forces its clones to fol-
low them. After injecting a clone with correct mem-
ory contents at some selected node vC,0, it can com-
promise any reader in VD to cancel out clone evi-
dence in a sequence GCi. The adversary can abuse
readers to prevent tag scanning (blocking), inject fake
events into local databases (emulation), and modify
tag memory contents (tampering). Readers are se-
lected and misused according to a strategy K detailed
in the next section.

5.2 Security Evaluation

In this section we evaluate the security of tailing in terms
of success probability Psucc for the above-described adver-
saries. We let PGC be uniformly distributed.

Figure 4(a) shows the success probability Psucc for ad-
versary A0 as a function of the number of clone events |C|
and over different combinations of tail size t and symbol
size s (dedicated tag memory size m = 32 bits and number
of genuine events |G| = 10). The best performing combi-
nation of (t, s) is t = 27 symbols and s = 1 bit. Intuitively,
with 1-bit symbols, the adversary has to guess all bits in the
tail but one, resulting in maximal uncertainty. For the rest
of our study, we only consider 1-bit symbols and call this
1bit-tailing.

The impact of the number of nodes |VA| that an ad-
versary compromises and of different memory sizes m is
shown in Figures 4(b) and 4(c) for adversaries A0-A1 and
A2, respectively.
(Here, |G| = 10, |C| = 5; for A0,
|VA| = 0.) For A1 and A2, compromising nodes dramati-
cally raises the adversary’s success probability, even elim-
inating the beneﬁts of a larger tag memory (m > 8 bits).
For A0, though, the larger m, the lower Psucc. By inject-
ing clones with correct memory contents, A2 achieves the
highest Psucc values.

As adversary A3 can compromise readers, it deﬁnes a
lower bound on the number of compromised readers needed
to cancel out clone evidence in a tag trace. In fact, it may:
(i) Block all events between evidence instances ǫi−1 and ǫi
or (ii) between ǫi and ǫi+1, (iii) inject fake events between
events ej and ej+1 that lead to ǫi, or (iv) tamper with the
memory of the tag that generates ej+1. Actions (i) and (ii)
aim to remove events that create inconsistencies, while ac-
tions (iii) and (iv) aim to create consistent event transition.
Different strategies can be deployed to suppress evidence
in a sequence GC; Figure 4(d) shows, for varying numbers
of clone events, the mean minimum number of readers that
adversary A3 has to compromise in order to suppress evi-
dence in every trace GCi. Two choices of strategy K are
depicted. Strategy ES represents the optimal solution (in
terms of sequences of permitted A3 actions) computed by
exhaustive search individually for each trace GCi. Strat-
egy Kh is a heuristic derived from study of ES action se-
quences. Kh suppresses clone evidence ǫi by injecting fake
events between events ej and ej+1; if there is just one event
between ǫi and ǫi+1, Kh instead blocks ej+1. Interestingly,
this simple strategy yields results comparable to the optimal
solution ES. Both strategies highlight the power of A3 to
successfully suppress evidence with relatively few readers,
e.g., 5.5 readers on average for |C| = 10 events.

Table 1 summarizes the percentage of the combinations
in TGC that lead to Ppass = 1 (i.e., that present no clone
evidence) for the four adversary types (|G| = 10 events and
|C| = 5 events; valid for any m). For the weakest adversary,
A0, all combinations in TGC present clone evidence. The
highest Ppass, equal to 2−[(t−1)·s+p], is obtained only for
those |G|+|C| combinations (15 combinations, or 0.19% of
the total) with a single and uninterrupted sequence of clone
events at the end. For A1, A2, and A3, some combinations
have Ppass = 1 (thus their higher Psucc values). For A1, be-
ing able to block |VA| nodes (VA ⊂ VC ) allows full suppres-

sion of clone evidence in(cid:0)|G|+|VA|

|VA| (cid:1)−1 combinations out of

the |TGC| possible ones, corresponding to the alignment of
|VA| clone events with compromised readers. For example,
for |VA| = 3, A1 is able to suppress evidence fully in all of
the 285 combinations (3.6% of the total) that contain only
events (c0), (c0, c1), or (c0, c1, c2). For A2, having A1’s ca-
pabilities plus injecting clones with correct tails allows suc-

Table 1. Percentage of combinations in the
set TGC(G, C) that lead to Ppass = 1 under
adversaries A0 to A3.
|G| = 10 events and
|C| = 5 events.

|VA| (# of compromised readers)

1

-

2

-

3

-

4

-

5

-

0.12% 0.81% 3.6% 12.5% 100%

0

0%

0%

0.19% 0.3% 0.97% 3.7% 12.6% 100%

0.19% 2.2% 14.8% 52% 89.9% 100%

A0

A1

A2

A3

cessful doctoring of a set of(cid:0)|G|+|VA|

|VA| (cid:1)−1+|G|+|C|−|VA|

combinations, corresponding to the union of sets leading to
the highest Ppass for A0 and A1. We note that adversaries
A1 and A2 are most likely to achieve success in cases where
they randomly compromise the leading nodes in the path
πC , i.e., from vC,0 to vC,|VA|−1. In fact, for m ≥ 8 bits,
values in Table 1 correspond to upper bounds on Psucc for
A1 and A2. A3 is more powerful in that it can compromise
readers adaptively; thus it achieves the highest Psucc values,
applicable as upper bounds for all adversary types.

5.3 Robustness Evaluation

In this section we evaluate the robustness of 1bit-tailing

against misevents, misreads, and miswrites.

Misevents cause inconsistencies in (genuine) tag traces,
which then raise false alarms.2 Figure 5(a) (curve em = 0)
shows the ratio of false alarms as a function of the misevent
probability pme for a trace composed of 10 genuine events.
To mitigate the effect of misevents, the set of rules in Equa-
tion 1 can be relaxed to accept a number em of missing
events between two (reported) time-consecutive events. In
this relaxation, a pair of events ei and ei+1 is considered
correct for which: (i) The symbols in the tail T Ti+1 are
the same as those in T Ti, except for the symbols rewritten
between positions T Pi (exclusive) and T Pi+1 (inclusive),
and (ii) the difference between the two tail pointers is at
most em plus one (the one corresponding to the pointer in-
crement). Formally, Equation 1 is then extended to:



T Ti+1[n] = T Ti[n]

∀n\ (T Pi, T Pi+1]
∀n ∈ (T Pi+1, T Pi]

if ∆T P > 0
if ∆T P < 0

∆T P (mod t) ≤ me + 1,

2Misevents may also cause clone misses. We evaluate this effect when

considering misreads.

−11

10

Psucc

−12

10

 

0
10

−2

10

−4

10

 

 

0
10

−2

10

−4

10

 em=0

 em=1

 em=2

 em=3

c
c
u
s

−6

10

P

−8

10

−10

10

−12

10

 

 

0

 |V

|=0 (A
)
0

A

 |V

|=1 (A
)
1

A

 |V

|=2 (A
)
1

A

 |V

|=3 (A
)
1

A

 |V

|=4 (A
)
1

A

c
c
u
s

10

−6

P

−8

10

−10

10

−12

10

0.2

0.3

 (misread probability)

0.4

0.5

 

0

 

 Blocking

 Exploiting TMF

1

2

3

4

5

|V

| (# of compromized readers)

A

1

0.8

0.6

0.4

em=0

em=1

em=2

em=3

)
e

t

a
r
 

l

 

m
r
a
a
e
s
a
f
(
 

l

R
A
F

0.2

0

 

0

 

0
10

−1

10

c
c
u
s

P

−2

10

−3

10

 

|V

| = 0

A

0.1
p

0.2

0.4
 (misevent probability)

0.3

me

0.5

1

2

3

4

5

|V

| (# of compromized readers)

A

0.1
p

mr

(a)

(b)

(c)

(d)

Figure 5. Study of misevents, misreads, and miswrites in 1bit(cid:173)tailing. Graphs are: (a) False(cid:173)alarm rate
as a function of misevent probability pme for a trace composed of 10 genuine events and for various
values of em, the number of allowed missing events between consecutive trace events; (b) Success
probability Psucc for A0 and A1 as a function of compromised nodes |VA| for various values of em (with
A0, |VA| = 0); (c) Psucc for A0 and A1 as a function of misread probability pmr for various numbers
|VA| of compromised nodes; (d) Psucc for A1 that either blocks clone events (Blocking) or exploits
the miswrite ﬂag (Exploiting TMF) to mark clone events as affected by miswrites. For all graphs,
|G| = 10 events, |C| = 5 events, and m = 32 bits.

where n ranges from 1 to tail size t, T T [n] indicates the n-th
symbol in the tail T T , and ∆T P is equal to (T Pi+1−T Pi).3
Figure 5(a) shows the strong impact of different em val-
ues on the false-alarm rate. Allowing missing events could
have the side effect of increasing the adversary’s success
probability. However, as shown in Figure 5(b), adversary
A0 (|VA| = 0) only marginally beneﬁts from em > 0. The
adversarial beneﬁt of compromised nodes is overwhelming
compared to that of allowing missing events; adversaries
A1, A2, and A3 do not beneﬁt signiﬁcantly from em > 0.
Misreads may mask clone events and cause the detec-
tor to miss clones. As shown in Figure 5(c), even a small
misread probability pmr signiﬁcantly increases A0’s suc-
cess probability; in fact, due to missing clone events, a few
traces do not present any clone event (i.e., Ppass = 1) even
for A0. However, for small pmr (< 0.1), A0’s Psucc is still
relatively low (< 10−4); it becomes signiﬁcant (> 10−2)
only for large pmr (> 0.5). Although the success proba-
bility for adversary A1 is primarily a function of the num-
ber of compromised readers, misreads also contribute in in-
creasing Psucc. This contribution becomes signiﬁcant for
relatively large pmr. (The same holds for A2 and A3).

Miswrites include cases when tags (i) reply with a write
failure message (no memory modiﬁcation); they also in-
clude cases when tags do not acknowledge a failed write op-
eration and have (ii) not modiﬁed, (iii) correctly modiﬁed,
or (iv) incorrectly modiﬁed (corrupted) the tag memory. If
miswrites are reported through the tailing ﬂag TF, cases (i)

3For ∆T P = 0, the tail has been completely rewritten, which makes
the result of the rule veriﬁcation not reliable. It may be also possible that
the tail is completely rewritten even for ∆T P 6= 0. In order to avoid such
situation, the tail size t should be larger than ⌈|G| · pme⌉ + 1.

and (ii) are comparable to misreads, and case (iii) to a mi-
sevent. To mitigate the effect of memory corruption, i.e.,
case (iv), we extend tag events with a miswrite ﬂag (TMF).
A reader not receiving any write operation result from a tag
will set both the tailing and the miswrite ﬂags in an event
ei; the detector will then ignore a clone evidence between
events ei and ei+1. Although the miswrite ﬂag could be
misused by an adversary to mark clone events as miswrites,
as Figure 5(d) shows (for A1), this provides no advantage in
terms of Psucc over blocking clone events. In fact, misusing
the miswrite ﬂag only cancels out clone evidence resulting
from a clone event followed by a genuine event, but not
vice versa; blocking can cancel both. These observations
hold also for A2. For A3, misusing the miswrite ﬂag is
equivalent to injecting fake events; no additional advantage
in terms of Psucc is achieved.4

We refer to our mechanism as basic 1bit-tailing (TAIL)
when em = 0 and the miswrite ﬂag TMF is not deployed,
and robust 1bit-tailing (R-TAIL) when em = 3 and the ﬂag
TMF is deployed.

6 Simulation-based Evaluation

We further evaluate our tailing mechanism through a
custom-built, RFID-enabled supply-chain simulator. This
allows us to explore more realistic and complex scenarios
than those in Section 5.

4Injecting fake events may suspiciously increase the number of events

in a trace, though, while misuse of the miswrite ﬂag does not.

CF

MN

L1

V

k

CI

VDT

L2

V

k

CI

VDT

L9

V

CI

k

DT

V

L3

k

CI

DT

V

L6

CI

k

DT

V

L10

k

CI

DT

V

L13

V

V

V

V

CI

k

k

CI

CI

k

k

CI

CI

k

k

CI

CI

k

k

CI

RT

V

L4

RT

V

L5

RT

V

L7

RT

V

L8

RT

V

L11

RT

V

L12

RT

V

L14

RT

V

L15

POS

POS

POS

POS

POS

POS

POS

POS

MN: Manufacturer,  

DT: Distributor,  

RT: Retailer,  
CF: Counterfeiter,  

v: reader,  

k: link,  

POS: Point-of-sale
CI: Counterfeit injection point

Figure 6. 4(cid:173)level binary(cid:173)tree supply chain with
one manufacturer (MN), two 2nd(cid:173)level distrib(cid:173)
utors (DT), four 3rd(cid:173)level distributors (DT),
and 8 retailers (RT). A counterfeiter (CF) in(cid:173)
jects clone products at different points (CI)
in the chain. L, v, k, and POS stand for lo(cid:173)
cation, reader, link, and point(cid:173)of(cid:173)sale respec(cid:173)
tively. The relation between each element and
the simulation parameters summarized in Ta(cid:173)
ble 2 is also shown.

6.1 Description and Baseline Scenario

Our simulator generates a ﬂow of genuine products in a
supply chain from the product manufacturer to one or sev-
eral distributors, and ﬁnally retailers.
It also generates a
ﬂow of counterfeit products from injection points (poten-
tially any partner in the chain) to retailers. The product ﬂow
is deﬁned by the supply-chain structure, product demand,
and lead times (stocking time within a partner, shipping
time from a partner, and transport time between two part-
ners). Each partner has RFID readers that record events and
may perform tailing. Clone detection occurs when products
leave the chain, i.e., at retailers’ points-of-sale.

As a baseline scenario for our study, we deﬁne a supply
chain of 15 partners (and locations) distributed in a 4-level
binary tree (Figure 6). Participating readers are those asso-
ciated with receiving and shipping operations. We consider
EPC C1G2 tags, which operate on 16-bit data blocks (Sec-
tion 7); tail and symbol sizes of 12 symbols and 1 bit respec-
tively allow use of just one such block. The counterfeiter is
adversary A0 (Section 5.1). It can simply inject counterfeit
products with valid IDs. In our baseline scenario, it does
so at a randomly selected partner, excluding the manufac-
turer, as soon as a new and valid ID is obtained. (In prac-
tice, a counterfeiter injects clones by posing as a legal seller
and obtaining valid IDs right after the genuine products en-

Table 2. Simulation parameters for the consid(cid:173)
ered baseline scenario. N (µ, σ) represents a
normal distribution.

Parameter

Value

pmr

Misread probability

pmw Miswrite probability

pme

Misevent probability

N (5%, 1%)

N (5%, 1%)

N (5%, 1%)

rg

rc

Tp

tsh

Tst

Ttr

ol

S

m

Genuine production rate

1000 products/day

Counterfeit production rate

10 products/day

Production time

2 months

Shipping time

Stocking time

Transport time

1/day at 8AM

N (3, 0.5) days

N (1, 0.25) days

Output load (demand)

Uniformly distributed

Supply-chain structure

4-level binary tree

Tag memory size

16 bits

(t, s)

Tail and symbol sizes

(12, 1) bits

Adversary

A0

Counterfeit injection point

Random at any partner

ter the chain.) Table 2 summarizes the parameters for this
baseline scenario.

Detection depends on the number |E| of instances of
suspected clone evidence in a given trace, i.e., pairs of
time-consecutive events that fail the rule veriﬁcation stage.
Cloning is suspected if |E| ≥ DT , for a parameterized de-
tection threshold DT . For each scenario, 10 runs are exe-
cuted, each over 2 months of production.5 A trace contains
all events for genuine and clone products with a given ID
until one such product reaches a point-of-sale. (The second
product to reach a point-of-sale eventually triggers an alarm
under the basic whitelist-based detection.)

6.2 Experimental Results

We let TPR and FPR respectively denote the true positive

rate and false positive rate for a given setting.

Figure 7(a) shows the superior performance of robust
1bit-tailing (R-TAIL) over basic 1bit-tailing (TAIL).6 (As de-

5For each system element (e.g., a reader, Figure 6), the value of its
parameters that refer to some probability distributions (e.g., the misread
probability) is drawn from the given probability distribution at each run.

6Small variance can be observed when considering different simulation

runs. This is valid for all the simulation-based results in this paper.

TPR

 

FPR
p

mx

 = N(5%,1%)

p

p

mx

mx

 = N(1%,0.2%)

 = N(10%,2%)

 

1

0.8

 TPR

 FPR

 TAIL

 R−TAIL

0.6

0.4

0.2

0

 

0  1  2  3  4  5  6  7  8  9  10

DT (# of clone evidences)

0  1  2  3  4  5  6  7  8  9  10

DT (# of clone evidences)

1

0.8

0.6

0.4

0.2

0

 
(0,0)

(1,2)

(2,4)

1

0.8

0.6

0.4

0.2

0

 

1

0.8

0.6

0.4

0.2

 

 TPR

 FPR

 DT=1

 DT=2

(3,5)
|,|V

A

A

(|L

(5,8)

(4,6)
|) (# of controlled partners and compromised readers)

(7,10) (8,12) (9,14) (10,15)(11,16)(12,18)(13,19)(14,20)

(6,9)

Figure 8. Detection rate (TPR) and false(cid:173)alarm
rate (FPR) as a function of detection threshold
DT for R-TAIL in the baseline scenario (Sec(cid:173)
tion 6.1), but considering adversary A2 that
controls |LA| locations (partners) and com(cid:173)
promises |VA| readers.

Figure 7(b) shows the impact of different misread, mis-
write, and misevent probabilities on detection and false-
alarm rates (pmr = pmw = pme = pmx = N (µ, σ), i.e.,
each probability is normally distributed with µ and σ). As
the rate of misreads and misevents rises, of course, coun-
terfeit products are more likely to go unnoticed, decreasing
the detection rate. Even under highly adverse conditions,
though, e.g., pmx = N (10%, 2%) (which translates into
85% of traces presenting at least one inconsistency), R-TAIL
detects 86% of all clones with a false-alarm rate of 2.8%
(DT = 1); with a false-alarm rate of 0.01%, the detection
rate is 64% (DT = 2).

The impact on the detection and false-alarm rates of the
stocking and transport times (Tst and Ttr) is shown in Fig-
ure 7(c). Varying Tst and Ttr does not impact the false-
alarm rate. Ttr > Tst, though, decreases the detection rate:
Under this condition, a counterfeit product injected at a re-
tailer can emerge (exits the chain) before the genuine prod-
uct reaches a 2nd-level partner.

As shown in Figure 7(d), the supply-chain structure has
a limited impact on both rates for DT = 1, and a larger
impact for DT > 1. The main determinant of the detec-
tion rate is the (average) length of the paths traversed by
products: Structures with longer paths (e.g., a 6-level binary
tree) generate more clone evidence than those with shorter
paths (e.g., a 4-level binary tree).

Similarly, counterfeit goods are harder to detect when in-
jected toward the end of the supply chain, and thus travers-
ing fewer partners, as shown in Figure 7(e). Finally, detec-
tion and false-alarm rates are invariant to the rate of injec-
tion/production of counterfeit goods (Figure 7(f)).

Figure 8 shows the impact on detection and false-alarm
rates of the stronger adversary A2, as deﬁned above in Sec-
tion 5.1. A2 controls a subset LA of supply-chain locations
(partners) and the full set of readers within these locations.
A2 injects clones at the 2nd-level distributors (Figure 6)
and compromises locations so as to control the maximum
number of complete manufacturer-retailer paths. (E.g., for

(a)

T

 = N(3,0.5), T
 = N(1,0.25)
tr

 

st

T

 = N(1,0.25), T
 = N(3,0.5)
tr

st

T

 = N(1,0.25), T
 = N(6,1)
tr

st

T

 = N(6,1), T
 = N(1,0.25)
tr

st

 TPR

 FPR

0

 

 

0  1  2  3  4  5  6  7  8  9  10

DT (# of clone evidences)

(c)

1

0.8

0.6

0.4

0.2

0

 TPR

 FPR

 2nd−4th level

 2nd level

 3rd level

 4th level

1

0.8

0.6

0.4

0.2

0

1

0.8

0.6

0.4

0.2

0

 
0 

2 

 

 

(b)

 TPR

 FPR

 

 4−level binary tree

 6−level binary tree

 4−level quaternary tree

6 

4 
12
DT (# of clone evidences)

10

8 

14

16

(d)

 

 TPR

 FPR
 r
 = 10 products/day
c

 r
 = 1
c

 r
 = 100
c

 
0  1  2  3  4  5  6  7  8  9  10 11 12 13 14

DT (# of clone evidences)

 
0  1  2  3  4  5  6  7  8  9  10 11 12 13 14

DT (# of clone evidences)

(e)

(f)

Figure 7. Detection rate (TPR) and false(cid:173)
alarm rate (FPR) as a function of detec(cid:173)
tion threshold DT for R-TAIL in (a) the base(cid:173)
line scenario (Section 6.1) and while varying:
(b) Misread, miswrite, and misevent proba(cid:173)
bilities (pmx = pmr = pmw = pme); (c) Stocking
and transport times (Tst and Ttr,
in days);
(d) Supply(cid:173)chain structure; (e) Counterfeit in(cid:173)
jection point (supply(cid:173)chain level); (f) Counter(cid:173)
feit production rate (rc).

ﬁned in Section 5.3.) TAIL is more sensitive to inconsis-
tencies generated by miswrites and misevents than R-TAIL;
it occasionally detects a cloned ID when direct clone evi-
dence is effaced by misreads. But this sensitivity yields sub-
stantially higher false-alarm rates than R-TAIL with nearly
TPRs. The best results occur with a small DT : With
DT = 1, R-TAIL detects 93% of clones with a false-alarm
rate of 0.95%; with DT = 2, the false-alarm rate drops to
0% for a detection rate of 80%. (DT > 2 merely lowers the
TPR.) Given these results, all experiments that follow use
R-TAIL only.

|LA| = 4, A2 controls locations L2 to L5.) Curves here rep-
resent the TPR and FPR for the detection thresholds leading
to the highest detection rate (F P R = 0.95%, DT = 1) and
the lowest false-alarm rate (F P R = 0, DT = 2) as a func-
tion of the number |LA| of supply-chain partners under the
control of the adversary, as well as of the number |VA| of
compromised readers. An aggressive adversary can signif-
icantly impact detection rates: Compromise of 50% of all
readers reduces the detection rate to 27%.

7 Performance Evaluation

In this section we evaluate the resource costs of tailing
in terms of storage, computation, and communication costs,
as well as its performance in terms of tag processing speed.
We assume use of EPC C1G2 RFID tags [11].

An RFID reader executing R-TAIL must read the entire
tag tail and tail pointer from tag memory and write an up-
dated pointer and a new symbol. A single EPC C1G2 write
operation operates on a data block of 16 bits, while a sin-
gle read operation operates on up to 128 bits. In a minimal
conﬁguration (8 bits for tail and pointer), a tailing operation
requires a single read and a single write operation. Figure 9
shows the corresponding communication sequence between
a reader and a tag in an inventorying and tailing operation.
The following performance results.

Storage capacity. Tailing consumes little memory, even by
the standards of low-cost tags, e.g., 8 bits. A local database
requires storage equal to the number of events generated by
the reader(s), i.e., tailing creates no additional events. Each
event, though, has to be extended with tail-related attributes
TT, TP, TF, and TMF, resulting in a minimum 7% increase
in the event size for an 8-bit tag dedicated memory.7 Use
of an EPC C1G2 tag’s full minimal data block size, i.e.,
16 bits, results in event size increasing by 10%.

Computation. Tags perform no computation, while readers
perform only lightweight operations, e.g., pseudo-random
or random number generation for bit updates. The de-
tector needs to perform the rule evaluation on each pair
of two time-consecutive events, a form of basic complex-
event-processing (CEP) that imposes fairly little computa-
tional overhead.

Communication. Tailing requires readers to perform extra
write operations (see below on tag processing speed), but
carries no extra cost on back-end communication between
local databases and the detector;8 however, as for its storage

7Assuming a basic event that comprises 28 bytes:

(ID(12 bytes),
T (8 bytes), L(4 bytes), P (4 bytes)). For one-byte storage granularity,
an 8-bit dedicated memory requires 2 bytes of storage, and a 16-bit one,
3 bytes of storage.

8We assume that events are already collected by other service-oriented

platforms to optimize business processes.

Figure 9. EPC C1G2(cid:173)compliant tailing oper(cid:173)
ation and tag inventorying for one tag. CW
stands for continuous waveform.

overhead for events, messages have to additionally include
the tail-related attributes.

Tag processing speed. The EPC C1G2 standard requires
a nominal tag processing speed for inventory operations
(reads) of 24.4 to 1838 tags/s, depending on several pa-
rameters (e.g., the tag data rate, encoding scheme, and data
modulation). As noted above, tailing requires writing into
tag memory, currently a time-intensive operation: The EPC
C1G2 standard allows a write time up to 20 ms for a sin-
gle 16-bit memory block. With an 8-bit dedicated memory,
writing a new tail bit and updating the tag pointer (4 bits
in total) would require writing an entire memory block, re-
sulting in a nominal tag processing speed of 9.6/44.5 tags/s.
Commercial tags, however, outperform EPC speciﬁcations;
e.g., the Impinj Monza 5 chip [1] supports a write speed of
approx. 2.5 ms, potentially boosting processing speed to
11.5/200 tags/s. (Other tags, we believe, are similar.)

In summary, tailing carries little overhead. Its main cost
is the slowdown on reader-to-tag communication caused by
tag writes. However, tailing can be performed by a few
readers in a supply-chain facility (e.g., upon product receipt
and shipping as explored in Section 6), which makes it a rare
operation. Consequently, we believe that tailing promises to
be highly scalable in real-world supply-chain environments.

8 Comparison

Using our supply-chain simulator from Section 6.1, we
now compare tailing against the clone detection schemes of
Lehtonen et al. [24] and Zanetti et al. [36].

The Lehtonen et al. [24] scheme resembles tailing: It
writes a fresh, single random value in tag memory at each
tag observation. A tag event includes the old (read) value
and the fresh (written) one.
In contrast to tailing, this
scheme relies on an online centralized entity that creates and
stores tag events and veriﬁes consistency between them. If a
previously written value (stored in event ei−1) is identical to
the currently read one (event ei), the tag and the centralized
entity are said to be synchronized; otherwise a clone alert
is raised. We refer to this scheme as synchronization (or
SYNCH). The Zanetti et al. [36] scheme veriﬁes the correct-
ness of consecutive shipping and receiving operations using

1

0.8

0.6

0.4

0.2

0

 

0 

 

1 

2 

 TPR

 FPR

 

 

 R−TAIL

 SYNCH

 PROC

1

0.8

0.6

0.4

0.2

0

 

 TPR

 FPR

 

 
 R−TAIL

 R−SYNCH

 R−PROC

1

0.8

0.6

0.4

0.2

0

 

 TPR

 FPR

 
 R−TAIL

 R−SYNCH

 PROC

4 

3 
7 
DT (# of clone evidences)

5 

6 

8 

9 

10

0

 

1

2

4

3
7
DT (# of clone evidences)

5

6

8

9

10

 

0

1

2

3

4

DT (# of clone evidences)

(a)

(b)

(c)

Figure 10. Detection rate (TPR) and false(cid:173)alarm rate (FPR) as a function of detection threshold DT
for robust 1bit(cid:173)tailing (R-TAIL), synchronization (SYNCH and R-SYNCH), and process(cid:173)based (PROC and
R-PROC) schemes for: (a,b) The baseline scenario (Section 6.1); (c) A more challenging, highly adverse
scenario with pmr = pmw = pme = N (10%, 2%), Tst = N (1, 0.25) days, Ttr = N (6, 1) days, counterfeit
products injected at the retailers, and a 4(cid:173)level quaternary(cid:173)tree chain structure.

 

 

1

0.8

0.6

0.4

0.2

0

 
(0,0)

(1,2)

(2,4)

 TPR  

 FPR  

R−TAIL   

R−SYNCH   

PROC

 

1

0.8

0.6

0.4

0.2

0

(3,5)
|,|V

A

A

(|L

(5,8)

(4,6)
|) (# of controlled partners and compromised readers)

(7,10) (8,12) (9,14) (10,15)(11,16)(12,18)(13,19)(14,20)

(6,9)

 TPR   

 FPR   

 R−TAIL   

 R−SYNCH   

PROC

 
(0,0)

(1,2)

(2,4)

(3,5)
|,|V

A

A

(|L

(5,8)

(4,6)
|) (# of controlled partners and compromised readers)

(7,10) (8,12) (9,14) (10,15)(11,16)(12,18)(13,19)(14,20)

(6,9)

(a)

(b)

Figure 11. Detection rate (TPR) and false(cid:173)alarm rate (FPR) as a function of detection threshold DT for
robust 1bit(cid:173)tailing (R-TAIL), robust synchronization (R-SYNCH), and process(cid:173)based (PROC) schemes
in the baseline scenario (Section 6.1), but considering adversary A2 that controls |LA| locations
(partners) and compromises |VA| readers. Graphs show rates for (a) the highest detection rate
(DT = 1) and (b) the lowest false(cid:173)alarm rate (F P R = 0).

process and location information in tag events (attributes S
and L). In particular, it veriﬁes: (1) That a product shipped
from location A (event ei with S = shipping and L = A)
is received at some location B (ei+1 with S = receiving
and L = B), or (2) that a product received at location A
(ei with S = receving and L = A) is then shipped from
the same location (ei+1 with S = shipping and L = A).
If neither condition is met, an alarm is raised. Unlike tail-
ing and SYNCH, this approach involves no modiﬁcation of
tag memory or attribute extension to tag events. Like tail-
ing, though, tag events are stored in local databases and col-
lected later for rule evaluation and clone detection. We refer
to this scheme as process-based (or PROC).

As in Section 6, we consider EPC C1G2 tags operating
on 16-bit data blocks. R-TAIL thus uses a tail and symbol
size of 12 symbols and 1 bit respectively, while SYNCH uses
a 16-bit synchronized value (nominally 32 bits in [24]).

8.1 Security and Robustness

Figure 10(a) shows clone-detection and false-alarm rates
(TPR and FPR) across schemes (R-TAIL, SYNCH, and
PROC), as a function of detection threshold DT in the base-
line scenario (Section 6.1). R-TAIL and SYNCH achieve

comparable TPRs, but both somewhat outperform PROC
(93% vs. 89% for DT = 1). R-TAIL, however, achieves
substantially lower FPR than SYNCH and PROC: 0.95% vs.
35% and 32% respectively (DT = 1).

Like TAIL, SYNCH is affected by misevents and mis-
writes, which lead to false alarms.
In contrast, it lacks
linkage between non-time-consecutive tag observations (as
provided by the pointer in tailing), which implies no mit-
igation for misevents. We can introduce a miswrite ﬂag
to mitigate miswrites, however, yielding a reﬁned scheme
that we call robust synchronization (R-SYNCH). As in R-
TAIL, the two-rule system of PROC can be relaxed to al-
low em missing events; for example, a pair of events ei
and ei+1 having, respectively, (L = A, S = receiving)
and (L = B, S = receiving) will not raise an alarm if an
event with (L = A, S = shipping) is assumed to be miss-
ing between them. This would mitigate both misevents and
misreads leading to false alarms. We call this new scheme
robust process-based (R-PROC). Figure 10(b) shows the ef-
fect of robustness in these new schemes. It yields a lower
FPR in the synchronization scheme of Lehtonen et al. (16%
vs. 35% for DT = 1), although still higher than for tail-
ing (16% vs. 0.95% for DT = 1); the impact on TPR

Table 3. Comparison between detection schemes. FN and FP stand for False Negatives and False
Positives respectively. Tag speeds are nominal (see Section 7 for discussion).

Baseline scenario (Section 6.1) Misreads Misevents Miswrites
(TPR, FPR)

(TPR, FPR)

impact

impact

impact

Event-size
overhead

Tag memory

Tag speed

[bits]

[tags/s]

PROC [36]

(89%, 32%)

(34%, 0%)

FN, FP

FN, FP

R-PROC

(38%, 0.95%)

(22%, 0%)

SYNCH [24]

(94%, 35%)

(38%, 0%)

R-SYNCH (ofﬂine)

(93%, 16%)

(37%, 0%)

R-TAIL

(93%, 0.95%)

(80%, 0%)

FN

FN

FN

FN

FN

FN, FP

FN, FP

FN

-

-

FP

FN

FN

0%

0%

14%

14%

10%

-

-

16

16

16

24.4–1838

24.4–1838

3.3–4.5

9.6–44.5

9.6–44.5

is negligible. In contrast, for the process-based scheme of
Zanetti et al., robustness lowers both FPR and TPR, such
that PROC presents better tradeoffs than R-PROC; e.g., for
F P R = 0%, R-PROC achieves T P R = 22% compared
with T P R = 34% for PROC. Thus, we henceforth use R-
SYNCH and PROC in our experimental comparisons.

Figure 10(c) compares the three schemes R-TAIL, R-
SYNCH, and PROC in a highly adverse scenario, with
the simulation settings yielding pessimal performance in
Section 6: High misread, miswrite, and misevent prob-
abilities (pmr = pmw = pme = N (10%, 2%)), long
transport time (Ttr = N (6, 1) days), short stocking time
(Tst = N (1, 0.25) days), counterfeit products injected at
retailers, and a 4-level quaternary tree. Here,
tailing
achieves the best performance, with a better FPR than R-
SYNCH (2.8% vs. 25% for DT = 1) and globally better
TPR and FPR than PROC.

Figure 11(a) explores a stronger adversary A2 (as in Sec-
tion 6.2 above).
It shows the TPR and FPR as a func-
tion of the number |LA| of adversarially controlled supply-
chain locations (partners) and the number |VA| of compro-
mised readers; here, we choose DT = 1, which yields
the highest detection rates. Tailing has the lowest TPR
(e.g., 27%, vs. 42% for PROC and 35% for R-SYNCH for
(|LA| = 7, |VA| = 10)—but uniformly with substantially
lower FPR (0.95% vs. 17% and 31%). A more balanced
comparison is achieved with a normalized FPR, for which
tailing achieves the highest TPRs. Figure 11(b) compares
the three schemes for FPR = 0%.

8.2 Cost Comparison

All three schemes impose asymptotic storage, computa-
tion, and communication costs linear in the number of trace
events n evaluated by the detector. Storage costs are a func-
tion of the number of tag observations, as is communication
between readers and the back-end detector, while compu-
tation is dominated by the execution of rule evaluation se-
quentially over events.

Synchronization requires extending each event with old
and fresh synchronization values, 32 bits in total, while tail-
ing requires 3 bytes (16 bits for the tail and pointer, 8 bits
for the ﬂags), leading to event size increases of 14% and
10% respectively (see Section 7).

Unlike tailing and synchronization, PROC requires no
tag writes, and thus has no impact on tag processing speeds.
In an EPC-compliant implementation, it can reach the nom-
inal values of 24.4/1838 tags/s. Tailing and synchroniza-
tion require tag writes. Synchronization further requires
online interaction with the centralized entity, imposing net-
work latency of about 200 ms [24] and limiting process-
ing speed to a mere 4.5 tags/s.
It is possible, though, to
modify R-SYNCH (to resemble R-TAIL) so that readers gen-
erate random values and detection occurs ofﬂine. Both
schemes then have a nominal top tag processing speed of
about 44.5 tags/s. (Higher performance is likely in practice:
See Section 7.)

8.3 Summary

Table 3 summarizes our key results and presents the dis-
tinct vulnerabilities of the various schemes to misreads, mi-
sevents, and miswrites, further illuminating their respective
performance. R-TAIL outperforms other approaches, with a
high detection rate for a relatively low false-alarm rate, and
a distinctly high detection rate for FPR = 0%.

9 Related Work

Anti-counterfeiting solutions based on track-and-trace
data within RFID-enabled supply chains were initially dis-
cussed by Kuh et al. [18] and Staake et al. [33], who high-
lighted the negative impact on counterfeit detection of in-
complete traces when partners do not record or share track-
ing data. More recently, several solutions based on ver-
ifying the (in)correctness of event traces and tag behav-
iors have been proposed [3, 9, 17, 22–24, 27, 36]. These

solutions rely on intrusion detection, classifying activity
based on pre-deﬁned models of suspicious patterns (misuse)
and normal tag/product behaviors (anomaly). Mirowski
et al. [27] apply statistical anomaly detection to identify
RFID tag ownership changes indicative of theft or cloning
of tags based on reader operations, tag and reader IDs, and
event timestamps. Similarly, Lehtonen et al. [22, 23] ex-
plore anomaly and anomaly/misuse intrusion detection, ac-
commodating incomplete traces caused by tag misreads and
partners not sharing tag observations. Kerschbaum and Oer-
tel [17] propose a pattern-matching approach to detect illicit
transactions between supply-chain partners. Blass et al. [3]
and Elkhiyaoui et al. [9] leverage tag memory to store ver-
iﬁable tag paths (visited readers). While all of these mech-
anisms are suitable for low-cost (EPC C1G2) tags, they re-
quire training or deep knowledge of supply-chain structures
and product ﬂows, causing fragility in the face of supply-
chain changes, product recalls, and product misdeliveries.
Moreover, only Lehtonen et al. [22,23] consider incomplete
(but still not faulty) traces.

Closest to our work are Lehtonen et al. [24] and Zanetti
et al. [36]. These schemes do not rely on pre-deﬁned infor-
mation about chain structures and product ﬂows, but have
the limitations demonstrated in Section 8. Thus tailing
proves the most effective for typical supply-chain scenarios
in which inconsistent information (due to blind zones and
reader failures) complicates clone detection. Additionally,
other solutions do not consider adversarial abilities beyond
injection of cloned tags (e.g., reader compromise).

Other approaches to detect/prevent

tag cloning in-
clude physical-layer ﬁngerprinting techniques, authentica-
tion based on low-cost primitives or cryptographic ones,
and Physical Unclonable Functions (PUFs). As shown
in [29, 35], EPC C1G2 tags can be ﬁngerprinted with
high accuracy over the air at the physical layer, without
added tag hardware. Such ﬁngerprinting is sensitive to
environmental factors, though, limiting its use in supply-
chain scenarios. Low-cost authentication protocols that ex-
ploit native EPC C1G2 computation have also been pro-
posed [5,6,19], but follow-up work has identiﬁed signiﬁcant
weaknesses [26, 30, 31]. Use of native EPC C1G2 storage
and access control is a complementary approach [16], but
is vulnerable to eavesdropping attacks. PUFs [13] are low-
complexity (hundreds of gates), purpose-built circuits that
exploit manufacturing variations for authentication. Sev-
eral low-cost PUF-based security solutions have been pro-
posed [8, 21, 34], but recent attacks highlight the need for
better understanding of tradeoffs among PUF circuit size,
security level, and stability [32]. Several solutions leverag-
ing symmetric- and public-key cryptography have been pro-
posed for RFID tags [2]. High-security crypto primitives,
though, are prohibitively expensive for low-cost tags today,
requiring a few thousand gate-equivalents for symmetric-

key primitives as in, e.g., [7], and more for public-key prim-
itives, e.g., [14]. Additionally, most of these cryptographic
solutions introduce non-trivial key-management challenges.

10 Conclusion

As the use of RFID as an anti-counterfeiting technology
in supply chains grows, cloning attacks against tags, exacer-
bated by blind zones, are a pressing systemic vulnerability.
We have shown that tailing is a simple and a practical coun-
termeasure and is effective even across blind zones, where
the centralized detector lacks visibility into tag emissions.

Tailing outperforms previous anti-cloning schemes. In
a 4-level supply-chain simulation, for instance, we ob-
serve detection rates (93%) equal to the next best approach
(synchronization), but with much better false positive rates
(0.95% vs. 16%). In addition, tailing requires limited tag re-
sources and no extra infrastructure resources and introduces
minimal overhead on supply-chain processes.

We believe that tailing is a potent new tool meriting ex-
ploration in other settings. For instance, tailing may help
detect cloning of post-supply-chain goods carried by con-
sumers, such as luxury goods. (An interesting new RFID
privacy challenge then arises: Abuse of tails as “cookies.”)
Similarly, tailing might supplement cryptographic and other
anti-cloning protections. RFID-enabled payment devices
and travel documents, both shown vulnerable to cloning at-
tacks [4, 15, 20], are attractive potential beneﬁciaries.

References

[1] http://www.impinj.com/.
[2] http://www.avoine.net/.
[3] E.-O. Blass, K. Elkhiyaoui, and R. Molva. Tracker: Security
and privacy for RFID-based supply chains. In NDSS, 2011.
[4] S. Bono, M. Green, A. Stubbleﬁeld, A. Juels, A. Rubin, and
M. Szydlo. Security analysis of a cryptographically-enabled
RFID device. In USENIX Security Symposium, 2005.

[5] C.-L. Chen and Y.-Y. Deng. Conformation of EPC Class 1
Generation 2 standards RFID system with mutual authenti-
cation and privacy protection. Engineering Applications of
Artiﬁcial Intelligence, 22, 2009.

[6] H.-Y. Chien and C.-H. Chen. Mutual authentication proto-
col for RFID conforming to EPC Class 1 Generation 2 stan-
dards. Computer Standards & Interfaces, 29, 2007.

[7] M. David. Lightweight cryptography for passive RFID tags.

PhD thesis, Aalborg University, 2011.

[8] S. Devadas, E. Suh, S. Paral, R. Sowell, T. Ziola, and
V. Khandelwal. Design and implementation of PUF-based
”unclonable” RFID ICs for anti-counterfeiting and security
applications. In IEEE RFID, 2008.

[9] K. Elkhiyaoui, E.-O. Blass, and R. Molva. CHECKER: On-
site checking in RFID-based supply chains. In ACM WiSec,
2012.

[10] EPCglobal. EPCIS Standard v. 1.0.1. Standard, 2007.

[11] EPCglobal. UHF Class 1 Gen 2 standard v. 1.2.0. Standard,

2008.

[12] F. Gandino, B. Montrucchio, and M. Rebaudengo. Tam-
pering in RFID: A survey on risks and defenses. Mobile
Networks and Applications, 15(4), 2010.

[13] B. Gassend, D. Clarke, M. van Dijk, and S. Devadas. Silicon

physical random functions. In ACM CCS, 2002.

[14] D. Hein, J. Wolkerstorfer, and N. Felber. ECC is ready for

RFID - A proof in silicon. In SAC, 2008.

[15] T. S. Heydt-Benjamin, D. V. Bailey, K. Fu, A. Juels, and
T. O’Hare. Vulnerabilities in ﬁrst-generation RFID-enabled
credit cards. In FC, 2007.

[16] A. Juels. Strengthing EPC tags against cloning.

In ACM

WiSe, 2005.

[17] F. Kerschbaum and N. Oertel. Privacy-preserving pattern
matching for anomaly detection in RFID anti-counterfeiting.
In RFIDSec, 2010.

[18] R. Koh, E. W. Schuster, I. Chackrabarti, and A. Bellman. Se-
curing the pharmaceutical supply chain. White paper, Auto-
ID Labs, MIT, 2003.

[19] D. M. Konidala, Z. Kim, and K. Kim. A simple and cost-
effective RFID tag-reader mutual authentication scheme. In
RFIDSec, 2007.

[20] K. Koscher, A. Juels, V. Brajkovic, and T. Kohno. EPC
RFID tag security weaknesses and defenses: Passport cards,
enhanced drivers licenses, and beyond. In ACM CCS, 2009.
[21] L. Kulseng, Z. Yu, Y. Wei, and Y. Guan. Lightweight mutual
authentication and ownership transfer for RFID systems. In
IEEE INFOCOM, 2010.

[22] M. Lehtonen, F. Michahelles, and E. Fleisch. Probabilistic
approach for location-based authentication. In IWSSI, 2007.
[23] M. Lehtonen, F. Michahelles, and E. Fleisch. How to detect
cloned tags in a reliable way from incomplete RFID traces.
In IEEE RFID, 2009.

[24] M. Lehtonen, D. Ostojic, A. Ilic, and F. Michahelles. Se-
curing RFID systems by detecting tag cloning. In Pervasive,
2009.

[25] T. Mackey and B. Liang. The global counterfeit drug trade:
Patient safety and public health risks. Journal of Pharma-
ceutical Sciences, 100(11), 2011.

[26] J. Melia-Segui,

J. Garcia-Alfaro,

and J. Herrera-
Joancomarti. A practical implementation attack on weak
pseudorandom number generator designs for EPC Gen2
tags. Wireless Personal Communications, 59(1), 2011.

[27] L. Mirowski and J. Hartnett. Deckard: A system to detect

change of RFID tag ownership. IJCSNS, 7(7), 2007.

[28] Y. Oren and A. Shamir. Remote password extraction from

RFID tags. IEEE Transaction on Computers, 56(9), 2007.

[29] S. C. G. Periaswamy, D. R. Thompson, and J. Di. Finger-

printing RFID tags. IEEE TDSC, 8(6), 2011.

[30] P. Peris-Lopez, J. C. Hernandez-Castro, J. M. Estevez-
Tapiador, and J. C. A. van der Lubbe. Cryptanalysis of
an EPC C1G2 standard compliant authentication protocol.
Engineering Applications of Artiﬁcial Intelligence, 24(6),
2011.

[31] P. Peris-Lopez, T. Li, T.-L. Lim, J. C. Hernandez-Castro, and
J. M. Estevez-Tapiador. Vulnerability analysis of a mutual
authentication scheme under the EPC Class-1 Generation-2
standard. In RFIDSec, 2008.

[32] U. R¨uhrmair, F. Sehnke, J. S¨olter, G. Dror, S. Devadas, and
J. Schmidhuber. Modeling attacks on physical unclonable
functions. In ACM CCS, 2010.

[33] T. Staake, F. Thiesse, and E. Fleisch. Extending the EPC
In

network: The potential of RFID in anti-counterfeiting.
ACM SAC, 2005.

[34] P. Tuyls and L. Batina. RFID-tags for anti-counterfeiting. In

CT-RSA, 2006.

[35] D. Zanetti, B. Danev, and S. Capkun. Physical-layer identi-

ﬁcation of UHF RFID tags. In ACM Mobicom, 2010.

[36] D. Zanetti, L. Fellmann, and S. Capkun. Privacy-preserving
In IEEE

clone detection for RFID-enabled supply chains.
RFID, 2010.

