Garbled Searchable Symmetric Encryption

Kaoru Kurosawa

Ibaraki University, Japan

kurosawa@mx.ibaraki.ac.jp

Abstract. In a searchable symmetric encryption (SSE) scheme, a client
can keyword search over symmetrically-encrypted ﬁles which he stored
on the server (ideally without leaking any information to the server). In
this paper, we show the ﬁrst multiple keyword search SSE scheme such
that even the search formula f (AND, OR and so on) is kept secret. Our
scheme is based on an extended garbled circuit satisfying label-reusable
privacy which is introduced in this paper.

Keywords: searchable symmetric encryption, multiple keyword search,
garbled circuit

1

Introduction

1.1 Searchable Symmetric Encryption

Cloud storage service is a major industry trend in the Internet society. In the
model of searchable symmetric encryption (SSE) schemes, a client ﬁrst stores a

set of encrypted ﬁles {Ci} on the server. Later, in the search phase, he can eﬃ-

ciently retrieve the encrypted ﬁles which contain some speciﬁc keywords without
any loss of data conﬁdentiality. While single keyword search SSE schemes have
been studies extensively so far [24, 12, 11, 7, 19, 22, 21, 20], there are only a few
works that study multiple keyword search SSE schemes.

Conjunctive (AND) keyword search in the SSE setting was ﬁrst considered
by Golle et al. [17]. In their scheme, a client can specify at most one keyword in
each keyword ﬁeld. For example, the keyword ﬁelds consist of ”To”, ”From” and
”Subject” in emails. This framework was followed up by [4, 5]. In such schemes,
however, the client cannot retrieve ﬁles which contain both Alice and Bob some-
where in all the keyword ﬁelds (for example, somewhere in ”To”, ”From” and
”Subject”).

Wang et al. [25] showed a keyword ﬁeld free conjunctive keyword search
scheme. However, their scheme does not support any other search formulas (for
example, OR).

Recently, Cash et al. [8] showed a keyword ﬁeld free SSE scheme which can
support any search formula in the random oracle model. However, the search
formulas are leaked to the server [9, Page 16]. Further , their search phase requires
four moves. Namely in the ﬁrst two moves, the client receives the set of encrypted
indexes {rind} of the ﬁles he wants to retrieve [9, Figure 3]. He then decrypts
them to DB = {ind}. In the next two moves, the client sends DB to the server,
and the server returns all encrypted ﬁles Ci such that i ∈ DB.

1.2 Garbled Circuit

Garbled circuits were initially presented by Yao [26] in the context of secure
two-party computation. They were proven secure by Lindell and Pinkas [23].
Recently, the notion has been formalized by Bellare et al. [3].

Over the years, garbled circuits have found many applications: two-party
secure protocols [27], multi-party secure protocols [16], one-time programs [15],
KDM-security [2], veriﬁable computation [13], homomorphic computations [14]
and others.

A garbled circuit is an encoding garble(f ) of a boolean circuit f such that
one can compute f (X) from (garble(f ), label(X)) without learning anything
about (f, X) other than f (X), where label(X) is an encoding of X. This security
notion is called circuit and input privacy.

Usually, (garble(f ), label(X)) is one-time use. Namely if garble(f ) or label(X)

is reused, then some information on (f, X) is leaked. Very recently, Goldwasser
et al. [18] constructed a reusable garbled circuit garble(f ), which can be reused
for multiple inputs X1, X2, . . ..

1.3 Our Contribution

In this paper, we show the ﬁrst multiple keyword search SSE scheme such that
even the search formula f is kept secret. Also, (1) it is keyword ﬁeld free, (2)
it can support any search formula and (3) the search phase requires only two
moves.

Table 1. Keyword ﬁeld free SSE scheme.

search formula search phase search formula secrecy

Wang et al. [25]
Cash et al. [8]

Proposed

only AND

any
any

2 moves
4 moves
2 moves

no
no
yes

Our scheme is based on an extended garbled circuit satisfying label-reusable
privacy which is introduced in this paper. In such a scheme, one can com-
pute f1(X), f2(X), . . . from label(X), garble(f1), garble(f2), . . . without learn-
ing anything about (X, f1, f2, . . .) other than f1(X), f2(X), . . ..

Table 2. Reusable Garbled Circuit.

Goldwasser et al. [18] garble(f ) can be reused

This paper

label(X) can be reused

We ﬁrst formulate this security notion, and then present a simple scheme
which satisﬁes it. We next construct a multiple keyword search SSE scheme by
using an extended garbled circuit which satisﬁes label-reusable privacy. (In the
ﬁrst place, no SSE scheme is known which uses a garbled circuit.)

Suppose that a client wants to retrieve all ﬁles which contain two keywords

w1 AND w2. Let List(w) = {i | a ﬁle Di contains a keyword w}. Then in any
multiple keyword search SSE scheme, the server learns at least List(w1) ∩
List(w2) because she must return all encrypted ﬁles Ci such that i ∈ (List(w1)∩
List(w2)). In addition to this, our scheme allows the server to learn only π(1)
and π(2), where π is a random permutation.

On the other hand, in the scheme of Cash et al. [8], the server additionally
learns (i) that the search formula is AND, (ii) List(w1) or List(w2), and some
more information (see [9, Sec.5.3] for the details).

The communication overhead of our search phase is cλ + 4msλ bits, where λ
is the security parameter (say λ = 128), m is the number of ﬁles, c is the input
size of a search formula f (namely c is the number of search keywords) and s
is the number of gates of f . We also present a more eﬃcient variant for small c
such that the communication overhead is cλ + m2c bits, which is 2λ + 4m bits
for 2(= c) keyword search.1 2

This paper is organized as follows. Sec. 2 is preliminaries. In Sec. 3, we
introduce a notion of label-reusable privacy of garbled circuits. We then present
a simple construction which satisﬁes this security notion. Sec. 4 deﬁnes multiple
keyword query SSE schemes. In Sec. 5, we show how to construct a multiple
keyword query SSE scheme from a label-reusable garbled circuit. Sec. 6 presents
an example.

2 Preliminaries
PPT means probabilistic polynomial time. If A is an algorithm, then y ←
A(x1, . . ., xn; r) represents the act of running the algorithm A with inputs
x1, . . . , xn and coins r to get an output y, and y ← A(x1, . . . , xn) represents
the act of picking r at random and letting y ← A(x1, . . . , xn; r).
If X is a set, then x $← X represents the act of choosing x randomly from
X. |X| denotes the cardinality of X.
If X is a string, then |X| denotes the bit length of X, and lsb(X) denotes

the least signiﬁcant bit of X.

For X = (x1, . . . , xn) and U = (i1, . . . , ic), we deﬁne

X|U = (xi1, . . . , xic ).

1 Our scheme can be combined with an eﬃcient single keyword search SSE scheme

such as [22]. Then a single keyword search will be faster.

2 The scheme of Cash et al. [8] achieves sublinear in m while their search phase requires

4 moves, and some amount of information is leaked to the server.

3 Label Reusable Garbled Circuit

In this section we introduce a notion of label-reusable privacy of garbled circuits.

3.1 Garbled Circuit

According to Bellare et al. [3], a boolean circuit is a 5-tuple f = (n, s, A, B, G).
Here n ≥ 2 is the number of inputs, and s ≥ 1 is the number of gates. We
let Inputs = {1, ..., n}, Gates = {n + 1, ..., n + s}, Wires = {1, ..., n + s} and
OutputWire = {n + s}. Then A: Gates → Wires\OutputWire is a function to
identify each gate’s ﬁrst incoming wire, and B : Gates → Wires\OutputWire
is a function to identify each gate’s second incoming wire. We require A(g) <
B(g) < g for each gate g ∈ Gates. Finally G : Gates ×{0, 1}2 → {0, 1} is a
function that determines the functionality of each gate. For example, if g is an
AND gate, then Gg(x, y) = x ∧ y.

Each gate has two inputs and arbitrary functionality. The ith bit of the input
is presented along wire i. Every non-input wire is the outgoing wire of some gate.
The wires are numbered 1 to n + s, and the output wire is n + s. The outgoing
wire of each gate serves as the name of that gate.

Fig. 1. A boolean circuit f with n = 4 and s = 3.

−

We say that f

= (n, s, A, B) is a topological circuit of f = (n, s, A, B, G).
Thus a topological circuit is like a circuit except that the functionality of the
gates is unspeciﬁed.

We deﬁne a garbling scheme by a tuple of PPT algorithms (GenLab, GenGC, EvalGC)

as follows:

– GenLab(1λ, n) chooses v0
i

∈ {0, 1}λ and v1

i

∈ {0, 1}λ such that

lsb(v0

i ) ̸= lsb(v1
i )

for i = 1, . . . , n randomly, and outputs

V = ((v0

1, v1

1), . . . , (v0

n, v1

n)).

Fig. 2. The topological circuit f

(cid:0)

of Figure 1.

– GenGC(f, V ) outputs a garbled circuit Γ , where

f = (n, s, A, B, G) and V = ((v0

1, v1

1), . . . , (v0

n, v1

n)).

−

– EvalGC(f
such that

, Γ, (vx1

1 , . . . , vxn

n )) is a deterministic algorithm which outputs z

z = f (x1, . . . , xn),

where xi ∈ {0, 1} for each i.
Correctness requires that if V ← GenLab(1λ, n) and Γ ← GenGC(f, V ), then

−

EvalGC(f

for any X = (x1, . . . , xn).

, Γ, (vx1

1 , . . . , vxn

n )) = f (x1, . . . , xn).

A garbling scheme (GenLab, GenGC, EvalGC) is said to satisfy circuit and input
n )) leaks no information on f and (x1, . . . , xn) other

, Γ , (vx1

−

1 , . . . , vxn
privacy if (f
−
than z = f (x1, . . . , xn) and f

.

3.2 Label Reusable Privacy

We ﬁrst extend a garbling scheme (GenLab, GenGC, EvalGC) to an extended gar-
bling scheme (GenLab, eGenGC, eEvalGC). The diﬀerence is that eGenGC and eEvalGC
take a positive integer counter as an additional input. Namely

Γ ← eGenGC(counter, f, V ),
z ← eEvalGC(counter, f
−

, Γ, (vx1

1 , . . . , vxn

n )).

The correctness requires that if V ← GenLab(1λ, n) and Γ ← eGenGC(

counter, f, V ), then

eEvalGC(counter, f

−

for any X = (x1, . . . , xn).

, Γ, (vx1

1 , . . . , vxn

n )) = f (x1, . . . , xn)

We next deﬁne label-reusable privacy for extended garbling schemes. Roughly
speaking, it means that no information on X and (f1, f2, . . .) is leaked from

(cid:19)

(cid:18)

Extended Garbling Scheme

(cid:16)

GenLab

#
1); : : : ; (v0
#

V = ((v0

1; v1

n; v1

n))

counter ! eGenGC   a boolean circuit f

#

the garbled circuit (cid:0)

#

counter ! eEvalGC   the topologocal circuit f

(cid:0)

,

(cid:17)

(vx1

1 ; : : : ; vxn
n )

#

f (x1; : : : ; xn)

Fig. 3. Extended Garbling Scheme

1 , . . . , vxn

(vx1
boolean circuits f1, f2, . . ..

n ) and (Γ1, Γ2, . . .), where a ﬁxed input X is reused for multiple

To formally deﬁne this security notion, we consider a real game

Garblereal and a simulation game Garblesim as shown in Figure 4 and Figure
5. In both games, the adversary A chooses

– X = (x1, . . . , xn) in the setup phase, and
– (Ui, fi) in the query phase for i = 1, . . . , q, where Ui ⊆ {1, . . . , n} and fi =
(|Ui|, si, Ai, Bi, Gi) is a boolean circuit,

and sends them to the challenger. In Garblereal, the challenger returns (vx1
in the setup phase, and a garbled circuit Γi in the query phase. In Garblesim,
the simulator must return

1 , . . . , vxn
n )

n ) based solely on n in the setup phase, and

1 , . . . , vxn

– fake (vx1
– fake Γi based solely on |Ui|, zi = fi(X|Ui) and f
Our requirement is that (vx1
other than n, {zi = fi(X|Ui )} and {(|Ui|, f
i )}3. Let
−

1 , . . . , vxn

−
i

n ) and {Γi} should not leak any information

in the query phase.

Advgarble
Advgarble

(A) = Pr(A outputs b = 1 in Garblereal),
real
sim (A) = Pr(A outputs b = 1 in Garblesim).

Deﬁnition 1. We say that an extended garbling scheme (GenLab,
eGenGC, eEvalGC) satis(cid:12)es label-reusable privacy if there exists a PPT simulator
3 f(jUij; f

i )g corresponds to the side-information function (cid:8)topo of [3].
(cid:0)

(cid:19)

Real Game for a Garbling Scheme (Garblereal)

{ Setup Phase:

1. An adversary A chooses X = (x1; : : : ; xn) and sends it to the challenger.
2. The challenger runs GenLab(1(cid:21); n) to generate V = ((v0
n)).

1); : : : ; (v0

n; v1

1; v1

He then returns (vx1

1 ; : : : ; vxn

n ) to A.

{ Query Phase (i = 1; : : : ; q):

1. A chooses Ui (cid:18) f1; : : : ; ng and fi = (jUij; si; Ai; Bi; Gi), and sends them
2. The challenger returns a garbled circuit (cid:0)i   eGenGC(i; fi; V jUi ) to A.

to the challenger.

{ Finally A outputs a bit b.

Fig. 4. Real Game for a Garbling Scheme: Garblereal.

Simulation Game for a Garbling Scheme (Garblesim)

(cid:18)
(cid:19)

(cid:18)

(cid:16)

(cid:17)
(cid:16)

(cid:17)

{ In the setup phase,

{ In the query phase, for i = 1; : : : ; q,

1. An adversary A chooses X = (x1; : : : ; xn) and sends it to the challenger.
2. The challenger sends n to a simulator Sim.
3. Sim returns (v1; : : : ; vn) to the challenger who relays it to A.
1. A chooses Ui (cid:18) f1; : : : ; ng and fi = (jUij; si; Ai; Bi; Gi), and sends them
2. The challenger computes zi = fi(XjUi ), and sends (i; Ui; f

(cid:0)
i ; zi) to Sim.

to the challenger.

3. Sim returns (cid:0)i to the challenger who relays it to A.

{ Finally A outputs a bit b.

Fig. 5. Simulation Game for a Garbling Scheme: Garblesim.

Sim such that |Advgarble
A.

real

(A) − Advgarble

sim (A)| is negligible for any PPT adversary

3.3 Construction

We present a simple construction of an extended garbling scheme which satisﬁes

label-reusable privacy. Let H0 : {0, 1}∗ → {0, 1}λ and H1 : {0, 1}∗ → {0, 1}

be two hash functions. They will be treated as random oracles in the security
proofs.

On input counter, f = (n, s, A, B, G) and V = ((v0

1, v1

1), . . . , (v0

n, v1

n)), eGenGC

behaves as follows.
1. For i ∈ {n + 1, . . . , n + s − 1}, choose ¯v0

i ) ̸= lsb(¯v1

i ) randomly.

lsb(¯v0
2. Deﬁne

{

Lx

i =

i if 1 ≤ i ≤ n
vx
i if n < i ≤ n + s − 1
¯vx

i and ¯v1
i

from {0, 1}λ such that

for 1 ≤ i ≤ n + s − 1 and x ∈ {0, 1}.

3. For (g, x, y) ∈ {n + 1, . . . , n + s} × {0, 1} × {0, 1}, do

a ← A(g), b ← B(g), ℓa ← lsb(Lx

a), ℓb ← lsb(Ly
b ),

{

P [g, ℓa, ℓb] =

H0(counter, g, Lx
H1(counter, g, Lx

if g ̸= n + s
b ) ⊕ LGg(x,y)
b ) ⊕ Gg(x, y) if g = n + s

g

a, Ly
a, Ly

4. Output a garbled circuit

On input counter, f

Γ = [P (n + 1,·,·), . . . , P (n + s,·,·)].
, Γ = [P (n + 1,·,·), . . . , P (n + s,·,·)] and (v1, . . . , vn),
−

(1)

eEvalGC behaves as follows. Let Li = vi for i = 1, . . . , n.

1. For g = n + 1, . . . , n + s, do

a ← A(g), b ← B(g), ℓa ← lsb(La), ℓb ← lsb(Lb),

vg = P [g, ℓa, ℓb] ⊕ H0(counter, g, La, Lb) if g ̸= n + s
z = P [g, ℓa, ℓb] ⊕ H1(counter, g, La, Lb) if g = n + s

2. Output z.

Namely our extended garbling scheme is almost the same as the usual gar-
bling scheme except for that the additional input counter is included in the
inputs to H0 and H1, and each value of ¯vx
is chosen freshly for each value of
i
counter.

Also P (n + s,·,·) encrypts a bit Gn+s(x, y) instead of a string

n+s

LGn+s(x,y)
able symmetric encryption. (We must encrypt LGn+s(x,y)
secure two-party computation, though.)

(by one-time pad) because this is enough for our application to search-
by one-time pad in

n+s

(Example 1) Let n = 2. In GenLab, we choose

v0
1, v1

1, v0

2, v1
2

$← {0, 1}λ.

For simplicity, assume that

lsb(v0

1) = lsb(v0

2) = 0, lsb(v1

1) = lsb(v1

2) = 1.

In eGenGC, for a boolean circuit f (·,·), the garbled circuit Γ is constructed

as

where

Γ = [P (3, 0, 0), . . . , P (3, 1, 1)],

P (3, 0, 0) = H1(counter, 3, v0
P (3, 0, 1) = H1(counter, 3, v0
P (3, 1, 0) = H1(counter, 3, v1
P (3, 1, 1) = H1(counter, 3, v1

2) ⊕ f (0, 0)
2) ⊕ f (0, 1)
2) ⊕ f (1, 0)
2) ⊕ f (1, 1)

1, v0
1, v1
1, v0
1, v1

(2)
(3)

(4)
(5)

In eEvalGC, we are given Γ , counter and some (v1, v2). Suppose that (v1, v2) =
1, v0

2). Then we ﬁrst compute

(v0

(lsb(v0

1), lsb(v0

2)) = (0, 0)

We next compute

f (0, 0) = P (3, 0, 0) ⊕ H1(counter, 3, v0

1, v0

2).

Theorem 1. The above extended garbling scheme (GenLab, eGenGC,
eEvalGC) satis(cid:12)es label-reusable privacy in the random oracle model.

3.4 Proof

We construct a simulator Sim as follows. In the setup phase, Sim is given n.
Then, Sim runs GenLab(1λ, n) to generate V = ((v0
n)). It then
returns (v0

1), . . . , (v0

n) to the challenger.

1, . . . , v0

n, v1

1, v1

−
i , zi). Let f

−
i = (ci, si, Ai,

In the ith query phase, Sim is given (i, Ui, f

Bi).

1. Sim chooses G such that f
′
i (0, . . . , 0) arbitrarily.

2. Sim computes Γi ← eGenGC(i, f

zi = f

i , V |Ui ) and returns Γi.
′

′
i = (ci, si, Ai, Bi, G) is a boolean circuit and

For i = 1, . . . , q, we say that (i, g, La, Lb) is visible if we must query (i, g, La, Lb)

to the H0-oracle or to the H1-oracle when computing zi ← EvalGC(i, f
Otherwise we say that (i, g, La, Lb) is invisible.

−
i , Γi, (vx1

1 , . . . , vxn

n )).

Then, consider a game Garble1 which is the same as Garblereal except for
that each H0(i, g, La, Lb), such that (i, g, La, Lb) is invisible, is replaced by a
random string, and each H1(i, g, La, Lb), such that (i, g, La, Lb) is invisible, is
replaced by a random bit. Deﬁne

Lemma 1. |Advgarble

real

p1 = Pr(A outputs b = 1 in Garble1).
(A) − p1| is negligible.

Proof. Let BAD be the event that an adversary A queries some invisible (i, g, La, Lb)
to the H0-oracle or to the H1-oracle. Until BAD occurs, Garblereal and Garble1
are the same because H0 and H1 are random oracles. Therefore |Advgarble
(A) −
p1| ≤ Pr(BAD).
Next Pr(BAD) is negligible because A has no information on v1−xi
i = 1, . . . , n. Therefore, we can see that Hence |Advgarble

for

real

real

(A) − p1| is negligible.⊓⊔

i

Similarly, let Garble2 be a game which is the same as Garblesim except for
that each H0(i, g, La, Lb), such that (i, g, La, Lb) is invisible, is replaced by a

random string, and each H1(i, g, La, Lb), such that (i, g, La, Lb) is invisible, is
replaced by a random bit. Let

p2 = Pr(A outputs b = 1 in Garble2).

Then, |Advgarble
sim (A) − p2| is negligible similarly to Lemma 1. Finally, it is easy
to see that Garble1 and Garble2 are identical. Therefore p1 = p2. Consequently
(A) − Advgarble
|Advgarble

sim (A)| is negligible.

real

4 Multiple Keyword Query SSE
Let D = {D1, . . . , Dm} be a set of documents and W = {w1, . . . , wn} be a set
of keywords. Let Index = {ei,j} be an m × n binary matrix such that

{

ei,j =

1 if Di contains wj
0 otherwise

.

(6)

For a list of keywords ¯w = (wj1 , . . . , wjc) and a boolean circuit f = (c, s, A, B, G),

we write IB(f, ¯w) for the set of identities of documents that satisfy f . Namely
this means that i ∈ IB(f, ¯w) if and only if

f (ei,j1, . . . , ei,jc ) = 1.

For example, suppose that ¯w = (w1, w2) and f1(x1, x2) = x1 ∧ x2. Then

i ∈ IB(f1, ¯w) if and only if Di contains w1 AND w2.

4.1 Model

A multiple keyword search SSE scheme is a protocol between a client and a
server as follows.
(Store Phase) On input (D,W, Index), the client sends (C,I) to the server,
where C = (C1, . . . , Cm) is the set of encrypted documents, and I is an encrypted
Index.

(Search Phase)

1. The client chooses a list of keywords ¯w = (wj1 , . . . , wjc) and a boolean
circuit f = (c, s, A, B, G). He then sends a trapdoor information t(f, ¯w) to
the server.
IB(f, ¯w)} to the client.
IB(f, ¯w)}.

2. The server somehow computes IB(f, ¯w) and returns CB(f, ¯w) = {Cj | j ∈
3. The client decrypts each Ci ∈ CB(f, ¯w) and outputs DB(f, ¯w) = {Dj | j ∈

(cid:19)

Real Game for Multiple Keywords (SSEreal)

{ Store Phase:

1. An adversary A chooses (D;W; Index) and sends them to the challenger.
2. The challenger returns (I;C).

{ Search Phase (i = 1; : : : ; q):

1. A chooses ¯w = (wj1 ; : : : ; wjc ) and f , and sends (f; ¯w) to the challenger.
2. The challenger returns t(f; ¯w) to A.

(cid:18)

{ Finally A outputs a bit b.

(cid:16)

(cid:17)

Fig. 6. Real Game for Multiple Keywords: SSEreal.

4.2 Security

We consider a real game SSEreal and a simulation game SSEsim as shown in
Figure 6 and Figure 7. In both games, the adversary A chooses
– (D,W, Index) in the setup phase, and
– ¯w = (wj1, . . . , wjc) and f in the query phase for i = 1, . . . , q,
and sends them to the challenger. In SSEreal, the challenger returns (I,C) in the
setup phase, and t(f, ¯w) in the query phase to A. In SSEsim, on the other hand,
the simulator must return

– fake (I, C) based solely on |D1|, . . . ,|Dm| and n = |W| in the setup phase,

−

– and fake t(f, ¯w) based solely on IB(f, ¯w), f

and U = (σ(j1), . . . ,

σ(jc)) in the query phase, where σ is a random permutation chosen by the
challenger at the beginning of the query phase.

In any multiple keyword search SSE scheme, the server learns |D1|, . . ., |Dn|

and |W| in the store phase, and IB(f, ¯w)4 and f
in the query phase. In addition
to these, our deﬁnition will allow the server to learn only U = (σ(j1), . . . , σ(jc)).
Let

−

Advsse
Advsse

real(A) = Pr(A outputs b = 1 in SSEreal),
sim(A) = Pr(A outputs b = 1 in SSEsim).

Deﬁnition 2. We say that a multiple keyword search SSE scheme is secure if
there exists a PPT simulator Sim such that

|Advsse

real(A) − Advsse

sim(A)|

is negligible for any PPT adversary A.

4 This is because the server must be able to return CB(f; ¯w) = fCj j j 2 IB(f; ¯w)g.

(cid:16)

(cid:17)

(cid:19)

Simulation Game for Multiple Keywords (SSEsim)

{ In the store phase,

{ In the search phase, the challenger ﬁrst chooses a random permutation (cid:27) on

1. A chooses (D;W; Index) and sends them to the challenger.
2. The challenger sends jD1j; : : : ;jDmj and n = jWj to a simulator Sim.
3. Sim returns (I; C) to the challenger who relays them to A.
f1; : : : ; ng. Then for i = 1; : : : ; q,
1. A chooses ¯w = (wj1 ; : : : ; wjc ) and f , and sends (f; ¯w) to the challenger.
2. The challenger sends IB(f; ¯w), U = ((cid:27)(j1); : : : ; (cid:27)(jc)) and f
3. Sim returns t(f; ¯w) to the challenger who relays it to A.

to Sim.

(cid:0)

(cid:18)

{ Finally A outputs a bit b.

Fig. 7. Simulation Game for Multiple Keywords: SSEsim.

5 How to Construct Multiple Keyword SSE

In this section we construct a multiple keyword search SSE scheme by us-
ing an extended garbling scheme which satisﬁes label usable privacy. Deﬁne

D,W, Index = (eij) and IB(f, ¯w) as shown in Sec. 4.

5.1 Construction

Let (GenLab, eGenGC, eEvalGC) be an extended garbling scheme. Let SKE
= (Gen, E, D) be a CPA-secure symmetric-key encryption scheme [1], where
Gen is a key generation algorithm, E is an encryption algorithm and D is a
decryption algorithm. Let PRF : {0, 1}ℓ × {0, 1}∗ → {0, 1}λ be a pseudorandom
function, where ℓ is the size of keys.

(Store Phase)

1. The client generates (ke, k0) randomly, where ke is a key of SKE, and k0 is a

key of the PRF. He also chooses a random permutation π on {1, . . . , n}.

2. He computes Ci = Eke(Di) for i = 1, . . . , m, and

kwj = PRFk0(wj)

for j = 1, . . . , n.

3. For i = 1, . . . , m and j = 1, . . . , n, do:

(a) Compute

v0
i,j = PRFk0 (i, wj, 0), v1

i,j = PRFk0(i, wj, 1).

(b) If lsb(v0

i,j) = lsb(v1

i,j), then let
← v1

v1
i,j

i,j

⊕ (0, . . . , 0, 1).

(7)

(8)

(9)

(c) Let

vi,j = vei;j
i,j ,

where ei,j is deﬁned by Eq.(6).

4. For i = 1, . . . , m, let

(10)

(11)

Yi = (vi,π(1), . . . , vi,π(n)).

Ym) to the server. (See Table 3.)

5. He then stores C = (C1, . . . , Cm) and I = (kwπ(1), . . . , kwπ(n), Y1, . . . ,
6. Let counter ← 0. He holds (counter, m), and keeps (ke, k0) secret.
(Example 2) Consider Index such that

)

(

)

(

Index =

e1,1, e1,2, e1,3
e1,1, e1,2, e1,3

=

1, 1, 0
1, 0, 1

,

(12)

where m = 2 and n = 3. Suppose that π(i) = i for i = 1, 2, 3. Then the
client stores the following table to the server, where v0
i,j are computed
according to Eq.(8) and Eq.(9). After this, he holds (counter = 0, m = 2), and
keeps (ke, k0) secret.

i,j and v1

kw1 kw2 kw3
1;1 v1
1;2 v0
1;3
2;2 v1
2;1 v0
2;3

C1 v1
C2 v1

Table 3. Example of the store phase.

(Search Phase) The client chooses ¯w = (wj1 , . . . , wjc) and f = (c, s, A, B,
G). Then he does the following.
1. Let counter ← counter + 1.
2. Compute kwj1 = PRFk0(wj1), . . . , kwjc = PRFk0 (wjc ).
3. For i = 1, . . . , m, do:
, v1
, v1

) as in the store phase.
))

(a) Compute (v0
(b) Let Vi = ((v0

), . . . , (v0
), . . . , (v0

, v1
, v1

i,j1

i,j1

4. For i = 1, . . . , m, compute Γi ← eGenGC(counter, f, Vi).

i,j1

i,j1

i,jc

i,jc

i,jc

i,jc

5. Send

t(f, ¯w) = [counter, f

−

, (kwj1 , . . . , kwjc), (Γ1, . . . , Γm)]

to the server.

The server does the following.

1. For i = 1, . . . , m, do

Find (vi,j1 , . . . , vi,jc) from Yi by using (kwj1 , . . . , kwjc).
Compute zi ← eEvalGC(counter, f
, Γi, (vj1, . . . , vjc)).

−

2. Return all Ci such that zi = 1.

5.2 Security

Theorem 2. The above multiple keyword search SSE scheme is secure if the
extended garbling scheme (GenLab, eGenGC, eEvalGC) satisﬁes label-reusable pri-
vacy and SKE = (Gen, E, D) is CPA-secure.

Proof. Since (GenLab, eGenGC, eEvalGC) satisﬁes label-reusable privacy, there ex-
ists a simulator Simg which satisﬁes Def. 1. We will construct a simulator Simsse
which satisﬁes Def. 2 by using Simg as a subroutine (see Figure 8).

Let A be an adversary against our multiple keyword search SSE scheme. Let
SSE1 be a game which is the same as SSEreal except for the fact that all the
outputs of PRF are replaced by random strings. Deﬁne

p1 = Pr(A outputs b = 1 in SSE1).

Then, |Advsse
Let Sim1

real(A) − p1| is negligible because PRF is a pseudorandom function.
g be m copies of Simg such that each Simi
g, . . . , Simm
g has indepen-
dent random coins. Then, our simulator Simsse behaves as follows.
(Store Phase) Simsse receives |D1|, . . . ,|Dm| and n = |W| from the challenger.
1. Simsse chooses ke randomly, where ke is a key of SKE. Then, it computes

) for i = 1, . . . , m. Also let kwi

$← {0, 1}λ for i = 1, . . . , n.
2. For i = 1, . . . , m, Simsse sends n to Simi
g, and receives Yi = (vi,1, . . . ,
3. Simsse returns C = (C1, . . . , Cm) and I = (kw1, . . . , kwn, Y1, . . . , Ym).

vi,n) from Simi
g.

Ci = Eke (0

|Di|

(Search Phase) For ctr = 1, . . . , q, Simsse receives IB(f, ¯w), U = (σ(j1),
. . . , σ(jc)) and f

from the challenger.

−

1. For i = 1, . . . , m, let

zi =

1 if i ∈ IB(f, ¯w)
0 if i ̸∈ IB(f, ¯w).

−

2. For i = 1, . . . , m, Simsse sends (ctr, U, f

, zi) to Simi

g, and receives Γi from

Simi
g.

3. Simsse returns

{

−

t(f, ¯w) = [ctr, f

Then, we can show that |Advsse

, (kwσ(j1), . . . , kwσ(jc)), (Γ1, . . . , Γn)].
sim(A) − p1| is negligible by using a hybrid
argument because Simg is a simulator of (GenLab, eGenGC, eEvalGC). Otherwise,
we can construct an adversary B against (GenLab, eGenGC,
eEvalGC) by using A and Simsse as subroutines.

Consequently, |Advsse

real(A) − Advsse

sim(A)| is negligible.

Corollary 1. There exists a secure multiple keyword search SSE scheme in the
random oracle model if there exists a pseudorandom function and a CPA-secure
symmetric-key encryption scheme.

Proof. The proof follows from Theorem 1 and 2.

⊓⊔

⊓⊔

Fig. 8. Proof of Theorem 2.

5.3 Eﬃciency

Suppose that we use our extended garbling scheme given in Sec. 3.3. Then, from
Eq.(7), (8), (10) and (11), we have

|kwi| = λ and |Yi| = nλ

for all i. Also from Eq.(1), we have

|Γi| = 4(s − 1)λ + 4

for all i.

Therefore, in the store phase, the communication overhead is

m∑

m∑

|I| =

|kwi| +

|Yi| = m(n + 1)λ.

i=1

i=1

In the search phase, suppose that the client chooses a list of keywords ¯w =
(wj1, . . . , wjc) and a boolean circuit f = (c, s, A, B, G). Then, the communication
overhead is

c∑

i=1

m∑

i=1

|counter| + |f
= |counter| + |f
≃ |counter| + |f

| +

|Γi|

|kwji

−| +
−| + cλ + 4m((s − 1)λ + 1)
−| + (c + 4m(s − 1))λ

where s is the number of gates of f .

5.4 More Eﬃcient Variant

In the search phase, let c be the input size of f , i.e, the number of search
keywords. If c is small, then we can consider a more eﬃcient variant such as
follows. We can naturally extend our garbling scheme to f which consists of a
single gate whose fan-in is c. Then, while the communication overhead of the
store phase remains the same, that of the search phase is reduced to

|counter| + cλ + 2c · m.

(For example, if c = 2, then |Γi| = 4 as can be seen from the next section.)

Suppose that λ = 128. Then this, variant is more eﬃcient for c ≤ 7. Further,
is leaked in this variant. (Namely no information on

−

no information on even f
f is leaked at all.)

6 Example

Consider an example of the store phase shown in Sec. 5.1. After the store phase,
the client holds (counter = 0, m = 2), and keeps (ke, k0) secret. In the search
phase, suppose that the he wants to retrieve the documents which contain w1
AND w2. Namely in eq.(12), he wants to know if ei,1∧ ei,2 = 1 for i = 1, 2. Then,

the client does the following.
1. Let counter ← counter + 1.
2. Compute kw1 = PRFk0 (w1) and kw2 = PRFk0 (w2).
3. For i = 1, 2, compute (v0

i,1) and (v0

i,2, v1

i,1, v1

Eq.(9).

i,2) according to Eq.(8) and

4. For simplicity, suppose that

lsb(v0

i,1) = lsb(v0

i,2) = 0, lsb(v1

i,1) = lsb(v1

i,2) = 1

for i = 1, 2.

5. For i = 1, 2 and (x, y) = (0, 0), . . . , (1, 1), compute

Pi(3, x, y) ← H1(counter, 3, vx

i,2) ⊕ (x ∧ y).

i,1, vy

(See Eq.(2) ∼ Eq.(5).)

6. For i = 1, 2, let

Γi ← [Pi(3, 0, 0), Pi(3, 0, 1), Pi(3, 1, 0), Pi(3, 1, 1)].

7. Send [counter, (kw1, kw2), (Γ1, Γ2)] to the server.
The communication cost is |counter| + 2λ + 4× 2 bits. If there are m documents,
then the communication cost is |counter| + 2λ + 4m bits.

The server has the table of Table 3. She now receives [counter, (kw1, kw2), (Γ1, Γ2)]

from the client. Then she does the following.

1. From (kw1, kw1) and Table 3, ﬁnd (v1
2. Compute

1,1, v1

1,2) and (v1

2,1, v0

2,2).

(lsb(v1
(lsb(v1

1,1), lsb(v1
2,1), lsb(v0

1,2)) = (1, 1)
2,2)) = (1, 0)

3. Compute

z1 = P1(3, 1, 1) ⊕ H1(counter, 3, v1
z2 = P2(3, 1, 0) ⊕ H1(counter, 3, v1

1,2) = 1 ∧ 1 = 1
2,2) = 1 ∧ 0 = 0

1,1, v1
2,1, v0

4. Return only C1 because z1 = 1 and z2 = 0.

References

1. M. Bellare, A. Desai, E. Jokipii, P. Rogaway: A Concrete Security Treatment of

Symmetric Encryption. FOCS 1997: pp.394–403 (1997)

2. Boaz Barak, Iftach Haitner, Dennis Hofheinz, and Yuval Ishai. Bounded key-

dependent message security. In EUROCRYPT, pp.423–444, 2010.

3. Mihir Bellare, Viet Tung Hoang, Phillip Rogaway: Foundations of garbled circuits.

ACM Conference on Computer and Communications Security 2012: 784-796

4. Lucas Ballard, Seny Kamara, Fabian Monrose: Achieving Eﬃcient Conjunctive

Keyword Searches over Encrypted Data. ICICS 2005, pp.414-426 (2005)

5. J. W. Byun, D. H. Lee, and J. Lim: Eﬃcient conjunctive keyword search on en-

crypted data storage system. EuroPKI, pp.184–196 (2006)

6. N. Baric and B. Pﬁtzmann. Collision-free accumulators and fail-stop signature
schemes without trees. In Advances in Cryptology: Proc. EUROCRYPT, volume
1233 of LNCS, pages 480–494. Springer-Verlag, 1997.

7. R.Curtmola, J.A. Garay, S.Kamara, R.Ostrovsky: Searchable symmetric encryp-
tion: improved deﬁnitions and eﬃcient constructions. ACM Conference on Com-
puter and Communications Security 2006: pp.79–88 (2006)

8. David Cash, Stanislaw Jarecki, Charanjit S. Jutla, Hugo Krawczyk, Marcel Rosu,
Michael Steiner: Highly-Scalable Searchable Symmetric Encryption with Support
for Boolean Queries. CRYPTO 2013.

9. ePrint version of the above paper: Cryptology ePrint Archive, Report 2013/169,

http://eprint.iacr.org/

10. M. Chase and S. Kamara: Structured encryption and controlled disclosure. ASI-

ACRYPT 2010, pp. 577–594 (2010)

11. Y.Chang and M.Mitzenmacher: Privacy Preserving Keyword Searches on Remote

Encrypted Data. ACNS 2005: pp.442–455 (2005)

12. Eu-Jin Goh: Secure Indexes. Cryptology ePrint Archive, Report 2003/216,

http://eprint.iacr.org/ (2003)

13. Rosario Gennaro, Craig Gentry, and Bryan Parno. Non-interactive veriﬁable com-
puting: Outsourcing computation to untrusted workers. In CRYPTO, pp.465–482,
2010.

14. Craig Gentry, Shai Halevi, and Vinod Vaikuntanathan. A simple BGN-type cryp-

tosystem from LWE. In EUROCRYPT, pp.506–522, 2010.

15. Shaﬁ Goldwasser, Yael Tauman Kalai, and Guy N. Rothblum. One-time programs.

In CRYPTO, pp.39–56, 2008.

16. Oded Goldreich, Silvio Micali, and Avi Wigderson. How to play any mental game.

In STOC, pp.218–229, 1987.

17. Philippe Golle, Jessica Staddon, Brent R. Waters: Secure Conjunctive Keyword

Search over Encrypted Data. ACNS 2004, pp.31-45 (2004)

18. Shaﬁ Goldwasser, Yael Tauman Kalai, Raluca A. Popa, Vinod Vaikuntanathan,
Nickolai Zeldovich: Reusable garbled circuits and succinct functional encryption.
STOC 2013: pp.555-564

19. Kaoru Kurosawa, Yasuhiro Ohtaki: UC-Secure Searchable Symmetric Encryption.

Financial Cryptography 2012: 285-298

20. Kaoru Kurosawa, Yasuhiro Ohtaki: How to Update Documents Veriﬁably in

Searchable Symmetric Encryption. CANS 2013: 309-328

21. Seny Kamara and Charalampos Papamanthou: Parallel and Dynamic Searchable

Symmetric Encryption. FC 2013

22. Seny Kamara, Charalampos Papamanthou, Tom Roeder: Dynamic searchable sym-
metric encryption. ACM Conference on Computer and Communications Security
2012: 965-976

23. Yehuda Lindell and Benny Pinkas. A proof of security of Yao (cid:671)s protocol for two-

party computation. J. Cryptol., 22:161–188, April 2009.

24. D.Song, D.Wagner, A.Perrig: Practical Techniques for Searches on Encrypted Data.

IEEE Symposium on Security and Privacy 2000: pp.44–55 (2000)

25. Peishun Wang, Huaxiong Wang, Josef Pieprzyk: Keyword Field-Free Conjunctive
Keyword Searches on Encrypted Data and Extension for Dynamic Groups. CANS
2008: 178-195

26. Andrew C. Yao. Protocols for secure computations. In FOCS, pp.160–164, 1982.
27. Andrew C. Yao. How to generate and exchange secrets (extended abstract). In

FOCS, pp.162–167, 1986.

