Android Root and its Providers: A Double-Edged Sword

Hang Zhang, Dongdong She, Zhiyun Qian

University of California, Riverside

hzhan033@ucr.edu, sdongdong@engr.ucr.edu, zhiyunq@cs.ucr.edu

ABSTRACT
Android root is the voluntary and legitimate process of gain-
ing the highest privilege and full control over a user’s An-
droid device. To facilitate the popular demand, a unique
Android root ecosystem has formed where a variety of root
providers begin to oﬀer root as a service. Even though le-
gitimate, many convenient one-click root methods operate
by exploiting vulnerabilities in the Android system. If not
carefully controlled, such exploits can be abused by malware
author to gain unauthorized root privilege.

To understand such risks, we undertake a study on a num-
ber of popular yet mysterious Android root providers focus-
ing on 1) if their exploits are adequately protected. 2) the
relationship between their proprietary exploits and publicly
available ones. We ﬁnd that even though protections are
usually employed, the eﬀort is substantially undermined by
a few systematic and sometimes obvious weaknesses we dis-
cover. From one large provider, we are able to extract more
than 160 exploit binaries that are well-engineered and up-
to-date, corresponding to more than 50 families, exceeding
the number of exploits we can ﬁnd publicly. We are able
to identify at least 10 device driver exploits that are never
reported in the public. Besides, for a popular kernel vulner-
ability (futex bug), the provider has engineered 89 variants
to cover devices with diﬀerent Android versions and conﬁg-
urations. Even worse, we ﬁnd few of the exploit binaries can
be detected by mobile antivirus software.

Categories and Subject Descriptors
D.4.6 [Operating Systems]: Security and Protection—In-
vasive software

General Terms
Security, Measurement

Keywords
Android root exploit, root provider

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS’15, October 12–16, 2015, Denver, Colorado, USA.
c(cid:2) 2015 ACM. ISBN 978-1-4503-3832-5/15/10 ...$15.00.

DOI: http://dx.doi.org/10.1145/2810103.2813714.

1.

INTRODUCTION

We are in an age when customers are not given full control
over the purchased personal mobile devices such as smart-
phones and tablets. Due to the popular demand by users,
a unique ecosystem of oﬀering smartphone root or jailbreak
has formed. Root and jailbreak are the process of obtaining
full privilege on Android and iOS devices respectively. They
allow users to bypass restrictions set by carriers, operating
systems, and hardware manufactures. With full control over
the device, a user can uninstall bloatware, enjoy the addi-
tional functionalities by specialized apps that require root
privileges, or run paid apps for free.

Classiﬁed by whether a device is ﬂashed, there are two
types of root methods: 1) soft root. 2) hard root. The
former refers to the case where root is obtained directly by
running a piece of software (i.e., root exploits). The latter
refers to the case where su binary is ﬂashed externally via
an update package or ROM. Depending on the device model
and OS version, diﬀerent root methods may be applicable.
For instance, due to locked bootloaders, some devices cannot
use hard root. Similarly, if a particular device has no soft-
ware or hardware vulnerabilities whatsoever, soft root would
not be possible. In practice, like any other systems, Android
devices do have a variety of vulnerabilities in various compo-
nents: kernel, driver, and application as summarized in §2.
In this paper, we focus on the soft root as the same ex-
ploits can be potentially abused by malware authors and
therefore much more dangerous than hard root. In Android,
such root service is provided by a number of parties. Indi-
vidual developers or hackers often identify vulnerabilities,
develop, and publish exploit tools to gain fame and possibly
fortunate. However, due to the diversity of Android devices
in terms of hardware, fragmented OS versions, and vendor
customization [34], it is simply not scalable for individuals
to engineer a large number of exploits to cover a wide range
of the devices. Therefore, the business of oﬀering root as a
service has emerged [10, 8, 13].

Interestingly, most commercial root providers are free to
use. They operate by requiring the exploit to run on an
Android device by a user voluntarily, e.g., through an one-
click root app [10, 8, 13]. Unfortunately, attackers can also
acquire such exploits easily by impersonating a regular user.
To make the problem worse, some of the large root providers
have a large repository of root exploits or even invent new
ones so they stay ahead of their competitors. This may give
attackers a strong incentive to target such providers.

In this paper, we examine the root ecosystem closely to
understand the following high-level questions: 1) How many

1093The contributions of the paper are the following:

types and variations of Android root exploits exist pub-
licly and how they diﬀer from the ones in commercial root
providers. 2) How diﬃcult is it to abuse the exploits oﬀered
by the root providers. We answer the above questions by
undertaking a series of measurement and characterization of
root exploits as well as the providers that oﬀer them.
• We conduct a comprehensive measurement study on An-
droid soft root methods to understand their origin and over-
all trend. We ﬁnd that 1) most public Android root exploits
target the application-layer vulnerabilities that aﬀect only
speciﬁc types of devices. 2) Although kernel vulnerabilities
are considered the most dangerous, an exploit developed on
one device may need to be adapted to work on another. 3)
As kernel vulnerabilities become rare, device drivers become
the dominating target to ﬁnd root exploits.
• We analyze the security protections employed by a num-
ber of root providers on their exploits. While larger root
providers often employ more protections, we identify sys-
tematic weaknesses and ﬂaws which substantially undermine
their eﬀort. The result calls for better security practices on
protecting such dangerous exploits.
• We survey the availability and variety of the exploits
online versus the ones extracted from root providers which
range from large security companies to individual develop-
ers. We report that a large root provider not only keeps
“secret” exploits, but also spent signiﬁcant engineering ef-
fort to polish and adapt existing exploits.
2. PUBLICLY AVAILABLE ANDROID

ROOT EXPLOITS

In this section, we attempt to exhaustively collect all pub-
licly known Android root exploits or vulnerabilities and un-
derstand their characteristics. Even though root exploits
are reported to have been used by malware in the wild al-
ready [43, 28, 19], we still lack a complete and up-to-date
picture. We are not aware of any systematic research stud-
ies on root exploits used by malware in the recent two years.
It is unclear what exploits may be currently used and which
ones are easily usable by malware, thus likely to appear in
the future. We aim to understand the question by analyz-
ing the current and publicly available resources to malware
authors.

Data sources and collection methodology. We sur-
vey a large number of public sources including academic
papers [30], research projects [1], published books [26], as
well as online knowledge base(e.g., CVE database or forum
post such as XDA forum) [9, 6, 2, 5]. Search terms includ-
ing “Android root”, “root exploit”, and “privilege escalation”
are used to locate the relevant information. Note that even
though we attempt to collect an exhaustive list based on our
expertise, it is inherently a best eﬀort. The list eventually
leads to a dataset of 73 exploits or vulnerabilities.

In most cases, a vulnerability (with a CVE number) maps
to a corresponding exploit. However, as will be described
in §2.2, we are unable to locate publicly available exploits
for some small subset of CVEs. In many other cases, the
opposite is also possible — no CVE number is assigned but
the exploit is readily available, likely because of its limited
impact on very few device types.

We also observe that some exploits require multiple vul-
nerabilities to gain root. For instance, master key vulnera-
bility (e.g., ANDROID-8219321) only leads to system user

privilege. Additional vulnerabilities are necessary to com-
plete a root exploit [16]. In such few cases, we consider them
two separate ones. In the survey, we found 5 vulnerabilities
which can gain system privilege only and 3 vulnerabilities
which can gain root permission from system privilege (we
count them as 8 still). In addition, some exploits are related
to each other and can be considered variations of one anoth-
er. When it is possible to locate diﬀerent CVE numbers or
vulnerabilities through the technical details, we also consid-
er them diﬀerent exploits. This inclusive strategy is more
likely to lead to a more complete discovery of exploits and
vulnerabilities.

At a high level, we are able to locate enough technical
descriptions of the vulnerabilities or exploits, although they
vary signiﬁcantly in detail, clarity, and availability of source
code or binaries. Perhaps expectedly, we ﬁnd that the ma-
jority of the exploits are not produced by academic research.
Questions to answer. We aim to answer the following

questions from the analysis:

1. How many general vs. speciﬁc exploits exist? Intu-
itively, some exploits are more general than others, especial-
ly those exploiting kernel vulnerabilities. Some exploits may
be applicable to certain vendors only.

2. Whether the exploit source code or binaries are publicly
available? What’s the requirement to run the exploit? Can
the exploit work via a standalone app, e.g., without user
intervention or booting into recovery mode?

3. Whether antivirus can recognize the exploits?

2.1 Root Exploit Impact and Coverage

To understand the impact and coverage of an exploit, we
ﬁrst try to identify the layer that is targeted. This is be-
cause the impact could be diﬀerent depending on the layer.
For instance, if it is a vulnerable setuid program (in the ap-
plication layer) installed only a certain models of a vendor,
then its impact will be limited. We divide the layers into
four categories based on the Android Architecture:

Linux Kernel. Due to its privileged position, targeting
Linux Kernel is natural to achieve full control over an An-
droid device. In particular, a vulnerability in the kernel has
a large impact as all devices that run the vulnerable kernel
can potentially be aﬀected. For instance, TowelRoot (CVE-
2014-3153) exploits the futex syscall bugs to gain root access
and it is considered to aﬀect all kernel versions before 3.14.5.
In this category, we include everything running inside kernel
except the cases described below.

Vendor-Speciﬁc Kernel or Drivers. Diﬀerent from
the main kernel code that runs on almost every device,
vendors either customize the kernel (e.g., Qualcomm’s cus-
tom Linux kernel branch) or provide vendor-speciﬁc device
drivers for various peripherals (e.g., camera, sound) [42],
Such code runs inside the kernel space and the compromise
of which can also lead to full control over the device. Giv-
en that they are produced by a single party without much
open auditing, and sometimes closed source (e.g., especially
the device drivers), the chance of them having security vul-
nerabilities can be high, as conﬁrmed in our measurement
results. However, since not all Android devices run the same
set of customized kernel or device drivers, an exploit on a
speciﬁc customized device can only impact a subset of An-
droid devices (e.g., certain Samsung devices).

Libraries Layer. Exploits at the libraries layer target
the Android libraries or external libraries used for support-

109440
35
30
25
20
15
10
5
0

l

s
t
i
o
p
x
e
 
f
o
 
r
e
b
m
u
N

Application

Layer

General
Vendor-specific

Library Layer

Android Layers

Externel
Drivers

Linux Kernel

Layer

20

15

10

5

0

Application Layer
Library Layer
Externel Drivers
Kernel Layer

2009 2010 2011 2012 2013 2014 2015

Figure 1: Number of exploits by layer

Figure 2: Number of exploits by year

ing diﬀerent applications. For instance, in ZergRush ex-
ploit (CVE-2011-3874), libsysutils used by Volume Manager
daemon (running as root) in Android is shown to have a
stack overﬂow vulnerability that leads to root privilege es-
calation [26]. The vulnerability in such libraries can have
a large impact because they may be embedded by multiple
programs, as long as one such program runs with root priv-
ilege and exercise the vulnerable code, a root exploit can be
successfully constructed. The ObjectInputStream vulnera-
bility (CVE-2014-7911) is another example.

Application and Application Framework Applica-
tion layer root exploits mostly include vulnerable logics in-
troduced by setuid utilities, system applications, or services.
The impact of such exploits depends on whether it is a third-
party one or not. So far, most cases are from third-parties
which indicate a limited impact. One example is a vulner-
able setuid utility that is only present on XoomFE devices
that has a command injection vulnerability [21]. Another in-
stance is a backdoor-like setuid binary shipped with certain
ZTE Android devices (CVE-2012-2949).

In general, from the highest to lowest, the order of impact
and generality of exploits would be 1) the kernel exploits,
2) the exploits targeting libraries that are used by Android
system processes, 3) exploits targeting system applications
or services, and 4) exploits against vendor-speciﬁc device
drivers, applications, and programs.

Even though we cannot accurately predict the number of
devices impacted by each exploit, the reasoning is that ker-
nel and Android system code is much more widely used than
the vendor-speciﬁc code. In addition, patches of kernel vul-
nerabilities are much harder to reach the end-user whereas
application updates can be quickly pushed out.

Breakdown by layer. As shown in Figure 1, out of
73 exploits, there are 54 exploits that are vendor-speciﬁc
(in lighter gray) and 19 general exploits (in darker gray).
The vendor-speciﬁc ones include all device driver exploits,
and vendor-speciﬁc applications or programs. The applica-
tion layer is found to have the largest number of exploits,
although most of them are vendor-speciﬁc. The external
drivers layer has the second largest number of exploits but
all of them are vendor-speciﬁc by deﬁnition. It is expected
that the kernel layer and library layer have the smaller num-
ber of exploits which are very general and extremely dan-
gerous. The number of new kernel layer exploits occurred
each year is also relatively stable in our survey – only one
or two per year on average.

Time dimension. Another important dimension is time.
Speciﬁcally, the lifetime of vulnerability is determined by the

patch version and date. The later the discovery, the longer
the vulnerability lives and therefore a higher impact. On the
other hand, the sooner the discovery, the more quickly the
root exploits can be developed. Figure 2 shows the number
of exploits discovered in each year. As we can see, vulner-
abilities explode around year 2013 due to a large number
of vulnerabilities introduced by vendor customization at the
external drivers layer and application layer. One of the key
problems is that device ﬁles on many vendor-customized An-
droid systems have weak permissions [42], without which an
app process cannot even open these device ﬁles and launch
exploits. Such period also coincides with the increased mar-
ket share of Android and participating vendors. On the
other hand, the kernel and library layers have a relatively
stable pattern.

Obviously, with common mistakes corrected in the vendor
customization process, the number of vendor-speciﬁc vulner-
abilities will drop. However, it is always hard to predict the
new trend or classes of exploits that may surface. As long as
there is strong need from users, we believe root exploits will
still continue to exist in the foreseeable future. For instance,
at the time of writing, a new kernel-level root exploit named
PingPong root [40] is announced.

Coverage. Theoretically, a kernel vulnerability aﬀects all
kernel versions between when the vulnerability is introduced
and when it is ﬁxed. Therefore, a recently discovered kernel
vulnerability such as TowelRoot (CVE-2014-3153) should
have a signiﬁcant coverage. However, as will be discussed
in §3, it is most often not the case.
In practice, a ker-
nel exploit may depend on system conﬁgurations, address
space layout, compiler options, etc.. Therefore, to success-
fully root a device, multiple exploits are usually attempted
in both the malware [43] and the root providers.

2.2 Exploit (Source or Binary) Availability

In this section, we aim to understand how readily avail-
able the exploit source code or binaries are on the Internet
for public use. In particular, the availability is a direct in-
dication on whether malware authors can ﬁnd and leverage
such exploits. Even though it is well known that malware
already start to embed root exploits that are often copied
from the public sources [43], it is unclear how many such
exploits can be located and abused.

To locate exploit source code or binaries, the method-
ology is to simply use the relevant keywords (when appli-
cable) of an exploit that typically include the CVE number
(e.g., CVE-2014-3153), the Google Bug ID (e.g., ANDROID
3176774), impacted device model, and the exploit nickname

109545
40
35
30
25
20
15
10
5
0

l

s
t
i
o
p
x
e
 
f
o
 
r
e
b
m
u
N

General
Vendor-specific

None or
permission

Reboot

Adb shell

Highest Requirement

User

interaction

Root exploit
exploid(2010)

Zimperlich(2010)
Gingerbreak(2011)
BurritoRoot(2012)

Poot(2013)

LGPwn(2013)

WeakSauce(2014)
Framaroot(2014)
Towelroot(2014)

PingPong root(2015)

AVG Lookout Norton Trend Micro

X
X
X

X
X
X

X
X
X

X

X

X

X

X

X
X
X
X

X
X
X

Figure 3: Exploit requirement breakdown

Figure 4: Detection results of mobile antivirus

(e.g., TowelRoot). To ensure adequate coverage, we undergo
two rounds of independent web searches.

Out of the 73 cases, we are able to locate either the source
code or binary of 68 exploits. Only 5 of them have neither
found. One of them is not available because it is only de-
scribed in a research abstract. Others are not available even
though the corresponding CVEs clearly indicate they allow
arbitrary code execution with elevated privileges. We are
not certain about the root cause but one plausible expla-
nation is that the person who discovered the vulnerability
did not release the technical details or any proof-of-concept
exploits. It is also possible that the vulnerabilities are not
generic enough to attract individual hackers to build an ex-
ploit.

Theoretically, both the binary and the source code are
valuable to malware authors. A malware can embed the
binary directly so long as it is an independent piece (e.g.,
executable or libraries) and has an easy-to-identify interface.
Of course, source code has many advantages since it can be
freely customized and improved.

Overall, there are 46 exploits with source code available,
18 of them are simple exploits that leverage weak ﬁle per-
missions and symbolic link attacks [14] which are typically
introduced by vendor customization. Such exploits can be
mostly implemented in shell scripts. The rest are written in
C (and one in Java against CVE-2014-7911). On the oth-
er hand, there are 22 exploits with binaries available only,
which are in the following two forms: 1) PC-side scripts that
may push additional binaries onto the device and 2) apk ﬁles
that run on the device directly. There are 10 and 12 of them
respectively.

We observe that even though source code is generally more
valuable, it may not be as robust as the binaries, especially
when the source code is oﬀered as “third-party” proof-of-
concept. Particularly, in order to accommodate diﬀerent
devices and models, considerable iterations and engineering
eﬀorts are required. For instance, TowelRoot is binary only
and it has evolved over three major revisions supporting
diﬀerent devices. The available source code, however, is just
proof-of-concept and is written by other developers [4].

To summarize, malware will likely be able to integrate
most of the exploits, even if some may have limited coverage.

2.3 Exploit Requirements

Even if an exploit source or binary can be found, one
still needs to understand the requirement to run them. For
instance, an exploit may require an adb shell setup through
a PC connection — since only processes running as shell

user can perform the exploit. In other cases, an exploit may
require user interactions (e.g., booting into recovery mode
at least once to trigger the vulnerable code).

To understand the exploit requirements, we perform two
steps: 1) locate technical reports or tutorials published ei-
ther by the exploit authors or other interested parties [21].
2) if 1) is not available, we attempt to read the exploit source
code or script, which will typically contain such information.
It turns out the two steps can cover most exploits.

From the technical details of the exploits and source code,
we are able to identify the following major requirements
(from the most rigid to the least):
• Requiring user interactions. This category have few
cases. One case is asking the user to download an app and
manually interrupt the installation [7]. One is asking the
user to boot into recovery at least once [18]. Another is
asking the user to manually put the device into “battery
saving” mode [12]. The last asks the user to open a vendor-
speciﬁc app and hit a button [15].
Intuitively, exploits in
this category are diﬃcult to be used by malware authors to
fully automate the exploit.
• Requiring adb shell through a PC connection. For
some exploits, adb shell connection is required because of the
following most common reasons: 1) The exploit can success-
fully modify a setting in local.prop which enables root for
adb shell only. 2) The exploit needs to write to a ﬁle owned
by group shell and group-writable (not world-writable) [14].
3) The exploit targets the adb daemon process that requires
the attack process to run with shell user. For instance, the
Rage Against the Cage exploit [11] targets the vulnerability
of adb daemon’s missing check on return value of setuid().
• Reboot. Generally, many root exploits require at least
one reboot. For instance, a symbolic link attack would
allow an attacker to delete a ﬁle owned by system with
weak permission, e.g., /data/sensors/AM I304 Conf ig.ini,
to setup a link at the same location to a protected ﬁle,
e.g., /data/local.prop. After a reboot, the corresponding
init scripts would attempt to change the permission of the
original ﬁle (i.e., /data/sensors/AM I304 Conf ig.ini) to
world-writable, which in reality changes the permission of
the linked ﬁle (i.e., /data/local.prop).
• None or permission. The exploits in this category
have no hard requirements, however, some of them may re-
quire certain Android permissions like READ LOGS in or-
der for the process owner to be placed in certain user group.
If an exploit has multiple requirements, we will only count
the most rigid one (e.g., one exploit needs both adb shell and
reboot will fall into “adb shell” category). The results are

1096summarized in Figure 3. 6 of them require user interactions.
17 of them require adb shell through a PC connection. 6 of
them require rebooting the device. The rest 44 do not have
any hard requirements, in which 5 do require certain An-
droid permissions. Most exploits are vendor-speciﬁc, how-
ever, there are 4 and 15 general exploits in “Adb shell” and
“None or permission” categories, respectively.

Correlating with the 68 exploits that have source code
or binaries, there are 39 available exploits that need only
reboot, permission, or none and can potentially be abused
in a malware silently gaining root access.
2.4 Root Exploits Detection by Anti-Virus

Since root exploits can be potentially abused by malware
to gain the highest privilege, we expect they are of high
priority to antivirus software. To verify the hypothesis, we
download 21 root exploits in the form of 10 apk ﬁles or ARM
ELF executables. In order for the antivirus to recognize a
malicious app, when there is a lack of apk ﬁle, we package
the ARM ELF executables into a simple Android app (stored
in the libs folder). Since some source code is only proof-of-
concept, we decide to use the binary only for experiment.

We downloaded 4 antivirus software from the Google
Play: AVG AntiVirus Free 4.3.1.1.213361, Lookout Secu-
rity and Antivirus (lookout) 9.18.1, Norton Mobile Security
V3.10.0.2361, Trend Micro Mobile Security V6.0.1.2050.

We use a Galaxy S3 phone to carry out the experiment in
the early May of 2015. We install the antivirus software one
at a time and never keep two or more running simultaneously
to prevent potential conﬂicts. The antivirus software all
have real-time protection enabled and will pop up a window
when they believe a malware or suspicious app is detected.
Table 4 shows the results with exploits ordered by year.
Note that in the case of Framaroot, 12 exploits are packed
in the same apk, and only one row is shown to represent
them. As we can see, most exploit binaries are ﬂagged by
more than one antivirus software, which is expected as most
of them are well-known root exploits.

There is one exploit, exploid that cannot be recognized.
Poot and PingPong root are detected by one antivirus on-
ly,
indicating that some exploits can still ﬂy under the
radar(The reason may be that our samples are diﬀerent from
those used by malware). Interestingly, the very recent Ping-
Pong root exploit, published a few days ago at the time of
writing (early May 2015), is already detected by Trend Mi-
cro, indicating that they are speciﬁcally sensitive about the
publicly available exploits.
In contrast, as will be shown in §6.3, the exploit binaries
engineered by large root providers are surprisingly “clean” as
all major antivirus software have diﬃculty detecting them.
3. ADAPTATION OF ROOT EXPLOITS

vspace0.03in Android is well known for its fragmentation
due to carrier and vendor customization [34]. On one hand,
the availability of a large number of customized Android de-
vices allow greater market penetration. On the other hand,
the diversity of Android devices makes it extremely diﬃ-
cult to write robust root exploits that work on devices with
varying application/kernel conﬁgurations and settings.

It is known that many exploits require adaptations to work
across devices. In fact, it is believed that adaptations direct-
ly discourage the malware authors to use certain exploits
(e.g., zergrush and mempodroid) in the wild [28].

Typically, an exploit needs speciﬁc environment to work.
Diﬀerence in CPU, kernel version, OS version may cause
a failure.
In memory corruption based exploits, requiring
the knowledge of absolute or relative memory addresses of
certain key data structures are common reasons why adap-
tation may be necessary. For instance, in the exploits a-
gainst CVE-2014-4322, the address of a kernel symbol needs
to be determined which diﬀers across devices. Note that a
bruteforce approach will not work as it may crash the sys-
tem jumping to an undesirable address. In rare cases such
as Exynos-abuse, adaptations may not be necessary. This
exploit can access arbitrary physical memory through a vul-
nerable device driver and overwrite kernel data to gain root
privilege. Instead of using a hard-coded static address, the
exploit can search from the beginning of kernel space to lo-
cate the target kernel symbol. Of course, such a special
vulnerability allowing the whole kernel space access is un-
likely to occur and is limited to certain device type only. In
general, kernel exploits require substantial adaptation, as is
demonstrated through the case study below.
3.1 CVE-2014-3153 (Futex bug)

Figure 5: CVE-2014-3153: kernel stack overwrite by invok-
ing system calls

The futex kernel vulnerability is reported to aﬀect all k-
ernel versions prior to Jun 3rd 2014 and its ﬁrst exploited
by TowelRoot.
It was originally designed to root Verizon
Galaxy S5, then modiﬁed to be compatible with more de-
vices, including ATT Galaxy S5,Galaxy S4 Active, Nexus
5. Although it claims to possibly work on every android de-
vice with a vulnerable kernel, a slight variation of hardware
platform or kernel versions may cause this exploit with high
precision requirement to fail. To cover more devices, it adds
a feature named mod strings for users to modify 5 diﬀer-
ent exploit variables. We explain one of the key variables,
system call, in detail below.

The system call variable speciﬁes one of the four possible
system calls utilizable to carry out part of the exploit. The
context is that the attack sets up a pointer in kernel heap to
point to a kernel stack address that is subject to overwrite
by a system call. As shown in Figure 5, an attacker needs
to pass a malicious parameter to a system call, which will
be copied into the kernel stack, and hope that it will even-
tually land on the target address in kernel stack. Depending
on the exact kernel version and conﬁguration, there are t-
wo obstacles: 1) the target stack address may be diﬀerent
relative to the base stack address. 2) the depth that the
malicious system call parameter reaches can also be diﬀer-
ent. We illustrate such obstacles in the ﬁgure. In the ﬁrst
case, the parameter of syscall sendmmsg() can be success-
fully placed to overwrite the target stack address.
In the
second case, however, due to the wrong syscall chosen, the

1097Name

Components Devices supported (claimed)

360 Root

Root Genius PC/MOBI
PC/MOBI
PC/MOBI
King Root PC/MOBI
SRSRoot

IRoot

PC

Baidu Root PC/MOBI
Root Master PC/MOBI

20,000+
20,000+
10,000+
10,000+
7,000+
6,000+
5,000+

N/A
Towelroot
Framaroot
N/A
1 PC:PC-side software MOBI:Android app

MOBI
MOBI

PC-side software

1. Provide device information

2. Obtain exploits

ADB Link

1. Provide device information

2. Obtain exploits

3. Apply exploits

Online/Local store

Android app

Table 1: Root Providers List

Figure 6: General Root Architecture

parameter may fail to hit the target address. In the third
case, the same syscall sendmmsg() is chosen, but due to ker-
nel version diﬀerence, the reached depth is diﬀerent, missing
the target. Due to the above diﬃculties, Towelroot suggests
users try diﬀerent syscalls in combination with other vari-
ables to hope that the target address will be hit.

It practice, we have tried the Towelroot on 3 devices that
we can get our hands on, all with a vulnerable kernel built
prior to Jun 3rd, 2014, yet Towelroot fails to root 2 of them.
4. ROOT PROVIDERS OVERVIEW

As alluded before, there exist a large number of root
providers, ranging from ones developed by individuals to
large companies. In this section, we aim to study them in the
following aspects: 1) survey diﬀerent types of root providers
and understand how they operate. 2) characterize the pro-
tection strength on the carried dangerous root exploits. 3)
measure the extracted providers’ exploits and understand
their relationship with the publicly available ones.

In general, the discrepancy of the available resources be-
tween small and large providers is likely a key factor in decid-
ing the above aspects. There are a number of popular root
providers which contain both the largest and newest ones
as listed in Table 1. We conﬁrm that the larger providers
do oﬀer a much more comprehensive set of exploits, howev-
er, even though present, the corresponding protections are
substantially far from being adequate. In fact, we ﬁnd se-
rious weaknesses that allow us to extract and study a large
portion of the exploit binaries from one large provider.

We study 7 out of the 9 providers in depth and anonymize

their names for security concerns, as shown in Table 2.

Methodology and collected results. We collect in-
formation of three main categories: 1) Public information
about each provider, e.g., number of devices that they claim
to support, whether it has a PC-side program and/or an in-
dependent Android app, as shown in Table 1. 2) Exploit
information including the location of the binaries (e.g., on
a remote backend or local), and the quantity of them. 3)
Protection employed by root providers to prevent the ex-
ploit binaries from being reverse engineered and abused by
others. This gives a rough estimate on the level of diﬃculty
to extract the valuable exploits for malicious purposes. The
information collected in 2) and 3) requires understanding of
the inner workings of providers via reverse engineering.

Root provider architecture. From all the providers we
studied, a common architecture is depicted in Figure 6. The
service is typically through either a PC-side program and/or
an independent Android one-click root app. The former can
control a device via the ADB interface and thus utilize both

ADB-related exploits like “rage against the cage” and others
launched directly on the Android device. The latter Android
app can operate independently to execute root exploits.

The main program logic involves three key steps:
STEP 1: Collect device information such as model name,

kernel and Android version, hardware platform and so on.

STEP 2: Based on the information, obtain proper exploits

from either remote servers or local store.

STEP 3: Execute the chosen exploits on the device to gain

root permission.

As shown in Table 1, the providers are sorted by their cov-
erage. It is obvious that all larger root providers are com-
prehensive in oﬀering both the PC-side program and the in-
dependent Android app, whereas smaller providers typically
oﬀer exploits in one way or the other.

Number of exploits. Here we focus on the exploits
that can be launched directly through the Android app, s-
ince they are much more likely to be abused once stolen by
attackers. In Table 2, we list the number of exploit binaries
we are able to locate for each provider. It is surprising to see
that the number goes over one hundred for the largest one.
In addition, the number is only a lower bound as there can
be others that we are not able to ﬁnd (See §5.1 for details
on how to locate the exploits). Such number is signiﬁcantly
higher than what we can ﬁnd from public sources, highlight-
ing the potential risk of being targeted by attackers. Note
that we sort the table by the number of exploits we can ﬁnd,
yet it does not correspond to the same order presented in
Table 1, therefore, not revealing the provider names.

We do realize that diﬀerent providers may organize their
exploits diﬀerently into binaries. One binary could corre-
spond to a single exploit with or without its variants. There-
fore, simply counting the number of exploit binaries can be
biased. In §6, we oﬀer a more comprehensive analysis on the
exploits and compare them with the publicly available ones.
Protection Strength. Perhaps expectedly, we observe
that larger root providers with more exploits tend to employ
stronger protection of their products, and smaller provider-
s usually employ little to no protection. For instance, as
shown in Table 2, provider 1 and 2 not only protect the
Android one-click root apps, but also introduce tamper-
detection and encryption in their exploit binaries (typical-
ly in native code) to prevent them from being stolen and
abused. In addition, the network communication to retrieve
exploits from its remote store is also encrypted. In contrast,
provider 6 and 7 only equip some basic protection in their ex-
ploits, which is easy to bypass. In the study we also ﬁnd that
some larger providers will integrate small providers’ apps or
exploit binaries directly, this observation again reﬂects the

1098NO.

Exploits

Store

Amount

Protection

PC-side Device-side Exploits
COPS

ANP*

A

N/A
None
N/A

P

NO
ANP

O

N/A
None
None

CS
S
CS
None

C
O

1
2
3
4
5
6
7

LOC/OL
LOC/OL

LOC
LOC
LOC
LOC
LOC

160+
60+
40+
20+
20+
10+
<10

Store
OL

OL/LOC

LOC
LOC
None
None
None

N/A
N/A
1 *: Not true for its app from a special channel

Table 2: Root Providers Measurement Result. OL:Online LOC:Local N/A:Not applicable or studied. A:Anti-debug
C:Tamper-detection N:Code Protection with JNI. O:Obfuscation P:Packing S:String Encryption.

lack of protection for small root providers which are usu-
ally individual hobbyists. Unfortunately, as we will show
in §5.1, the seemingly strong protections in large provider-
s can in fact be broken down fairly quickly due to several
severe weaknesses we identify.

PC-side vs Device-side Protection. It is important to
realize the PC-side program and independent Android app
contain duplicate functionality of reading device information
and retrieving exploits from local or remote store. Therefore,
as long as either one has a weak protection, the procedure
can be revealed and exploits maliciously retrieved. Indeed,
security is only as strong as its weakest link.

Interestingly, we observe the protection strength is in-
deed typically inconsistent. Compared to PC, Android
has a much shorter history which results in fewer avail-
able commercial-grade protection methods, e.g., VM-based
protection [23]. This is supported by our ﬁnding that
most providers have weaker protections on its Android app
compared to its PC counterparts, even though they usu-
ally throw in a number of protections, hoping that they
are strong enough (e.g., ProGuard). On the other hand,
provider 3 does employ a stronger commercial protection
solution called Bangcle on its Android app, yet it has no
protection whatsoever on its PC program. The result is
summarized in Table 2. In the cases of a “N/A”, it indicates
that we did not study it since the other side can already be
successfully reverse engineered.

Besides above observation, extra opportunities exist where
inconsistently protected software may be distributed. First,
older versions and newer versions of the same software may
implement the same core functionality, but stronger protec-
tions are added only to the newer versions. For instance,
we observe an old version of an Android one-click root ap-
p from a provider has signiﬁcantly weaker protection than
the new ones. Second, in rare cases, some root providers
may share code with each other, yet one version may have
much weaker protection than others. We observe one such
case among the providers - the involved two providers have
a cooperating relationship.
5. CASE STUDIES OF PROTECTION

MECHANISMS

Given the competitiveness of the providers is purely deter-
mined by the variety and quality of the engineered exploits,
they should be highly security minded, whether individual
hackers or large companies who even oﬀer security product-
s. We expect to see best practices in protecting their code.
However, even when strong protection is indeed employed,
we identify some critical (and some obvious) ﬂaws which
greatly undermine the eﬀort. In the end, we are able to seize

virtually all exploit binaries oﬀered by the root providers. In
this section, based on the number of exploits, we divide the
providers into three categories. From each category we will
choose representative providers for detailed study, aiming to
locate ﬂaws and weaknesses in their protection methods.

As depicted in Section 4, there are three steps in the root
procedure. By reversing how each step is performed, one
can easily steal all exploit ﬁles and run them in any piece
of malware to gain root privilege. Even the most diﬃcult
provider only took a graduate student, who is not a profes-
sional hacker, about one month of part-time work to ﬁnish,
which is far less than expected for such a highly sensitive ser-
vice. For reference, it took a professional Symantec research
group about six months to ﬁgure out the basic structure and
behavior of Stuxnet [27], which is a piece of state-sponsored
malware created to attack industrial control systems. In the
rest of the section, we will describe the protection methods
and the weaknesses in each step for diﬀerent root providers
in detail.

5.1 Large Root Providers

Provider P1 (we will refer provider n in Table 2 to Pn)
is one of the largest root providers currently with over a
hundred exploit binaries. Its service is provided by either the
PC-side program or the Android app. The most critical part
in P1’s architecture is an online exploit store. To update the
service, P1 simply needs to add new exploits to the store.
For a given device, only a selected subset is downloaded and
attempted.

Protection Methods.
STEP 1: Provide device information. P1 encrypts the
gathered device information such as Android device mod-
el and kernel version before sending them out to a remote
server with a combination of standard encryption algorithm-
s. Similar protection is also widely used by other large root
providers to secure their online exploit stores.

STEP 2: Obtain exploits. After receiving encrypted de-
vice information, P1 servers ﬁrst return a ﬁle which is an
array of exploit descriptors. Each descriptor contains elabo-
rate information about a speciﬁc exploit including an inter-
nal exploit identiﬁer, a download link, and comments such
as the aﬀected devices. Related exploit binaries can then
be fetched based on its descriptor. The descriptor ﬁle is en-
crypted with the same algorithm as in STEP 1. Besides,
each ﬁle URL is encoded in a random string to prevent ex-
haustive crawling. A similar “descriptor ﬁle mechanism” can
also be observed for P2, but with a diﬀerent format.

STEP 3: Apply exploits. P1 encapsulates each exploit
into a separate Linux dynamically linked shared object ﬁle
(.so). These library ﬁles share a common interface of entry

1099point and thus can be executed, in a uniform fashion, one
after another. Such ﬁles are downloaded every time when
the PC-side program or the Android app is run. It is obvious
that such ﬁles have to be protected in order to prevent mis-
use. We encounter the following: 1) The code is obfuscated
by redundant instructions [33] and a custom re-arrangement
procedure of the ELF binary to destroy the header and pre-
vent disassembling. 2) A custom packing method scrambles
the actual exploit code. 3) Most constant strings are en-
crypted. 4) There is a tamper-detection in every exploit
ﬁle to ensure that the exploit can only be launched by an
authentic P1 product (its own Android app), based on the
app’s embedded signature or the package name.

Security Flaws. Unfortunately, there exist a number
of ﬂaws that substantially undermine the strength of the
protection employed by P1. We highlight them below:
• Inconsistent protection for the same Android app ob-
tained through diﬀerent channels. After studying P1 for a
while, we realize that there are in fact two ways to get its
Android app: 1) Download from P1 oﬃcial website or oth-
er third-party app markets directly (Google Play prohibits
such apps to be published). 2) Obtain the copy from the
PC-side program’s download cache. This is possible since
the PC-side program will download and install the app to
the connected device automatically if none is detected.

Surprisingly, the apps from these two channels behave ex-
actly the same on mobile devices, yet there is a world of
diﬀerence in their protections. The one downloaded from
the oﬃcial website is well protected with main “Classes.dex”
encrypted and packed. This is an eﬀective practice found
in some commercial solutions (e.g., Bangcle). The one
obtained through the PC-side program, in contrast, does
not include any protection whatsoever. Considering that
Android apps tend to update frequently with only minor
changes, if the core encryption logic remains the same in
future versions, an attacker can misuse it for a long period
of time to continually extract new exploits developed by the
provider. This ﬂaw eﬀectively reveals all encryption algo-
rithms used in STEP 1 and STEP 2.
• Custom obfuscation procedure leaked through online se-
curity contest held by the provider itself. P1 employs some
obfuscation methods such as a custom redundant instruc-
tion pattern and ELF header scrambling, these methods are
in fact exposed in an online security contest. By simply
reading the answers provided by the crowd, all details are
revealed, including the obfuscation pattern and the way to
restore metadata in the ELF header. Once the obfuscation
is understood, remaining protections in STEP 3 are much
less eﬀective.
• Discrepancy in protection strength of device-side and
PC-side software. Similar to what is discussed in §4, the
unprotected Android app of P1 obviate the need to deal with
the PC-side program protection such as anti-debug. The
opposite occurs in P3 where unprotected PC-side program
enables us to ignore its well-protected Android app.
• Leave informative names of critical functions untrans-
formed. Root providers often employ standard cryptograph-
ic and compression algorithms (e.g., AES) to protect the
code and data. However, if such obfuscation logic leaves its
function and variable names untransformed (e.g., a function
named “md5” or a variable named “AESKey”), one can im-
mediately recognize the algorithm and reverse the obfusca-
tion. Such form of leakage exists in both SMALI and ARM

native code of P1 and many other root providers, which un-
dermines their protection drastically. This ﬂaw impacts all
three steps of P1.
• Vulnerable tamper-detection mechanism Signature or
package name based tamper-detection can be found in many
providers’ exploit ﬁles. However, the detection is executed
only one time at the beginning, which makes it easy to by-
pass — modifying one conditional jump suﬃces and works
in all cases. Scattered and repeated tamper detection will
substantially raise the protection level in STEP 3.

To verify that all P1’s protections are successfully by-
passed, we develop a piece of proof-of-concept Android mal-
ware which can fetch and run the root exploits as well as
successfully obtaining root privilege on a few tested devices,
including HTC One V and Sony Ericsson ST18i. In theory,
this malware can leverage the full capacity of P1 since it
can use all current and future exploits P1 maintains, as long
as the procedure remains the same. Although we did not
include the exploits that can only be launched from the PC
program, they can also be downloaded and used the same
way.

5.2 Medium Root Providers

We choose P4, a popular moderate-sized provider to study
in this section. Diﬀerent from P1, P4 stores all its exploits
locally. Although there are some protection for the local
store, it is overall much weaker than P1’s protection. It only
took us three days to obtain all P4’s exploits and bypass the
protection mechanism, which will be described below.

Protection Methods
STEP 1: Provide device information. Since all P4’s ex-
ploits are stored locally, there is no need to send device in-
formation to any remote server. All device information is
gathered locally and will then be used to guide the selection
of proper exploits.

STEP 2: Obtain exploits. As soon as a speciﬁc exploit is
considered proper for current device, P4 will fetch it from
the local store. There are two layers of protection in this
process: First, inside the Android app, MD5-based name
transformation procedure is used to map an internal exploit
name to the corresponding obscured ﬁle name in local store.
Second, actual exploit binaries are compressed in gzip, while
no informative ﬁle suﬃx can be seen.

STEP 3: Apply exploits. P4’s exploits are all ELF exe-
cutables. Similar to P1, there is also a package name based
tamper-detection mechanism in each exploit binary. Be-
sides, although no packing and obfuscation techniques are
employed, all strings are encrypted and there are no infor-
mative function names.

Security Weaknesses
• Weak protection for the device-side app. Unlike P1,
even the original apk downloaded directly from P4’s oﬃ-
cial website has little protection — only some basic class
and function name obfuscation is used. The major body
of SMALI code is still highly readable and has given out all
detailed functional and encryption/decryption logic involved
in STEP 1 and STEP 2. For instance, reference strings such
as “md5” are not encrypted, which dramatically accelerates
the reverse engineering progress.
• Debug output turned on in ELF binaries. The exploit
binaries will output decoded strings (e.g., path of a vul-
nerable device driver) directly to the console. Obviously
the developers forgot to turn oﬀ the debug option carelessly

1100and this mistake signiﬁcantly eases the task of locating the
string decode and tamper-detection procedures. The pro-
tection in STEP 3 is thus greatly weakened. Unfortunately,
besides P4, we also ﬁnd informative debug output in other
providers’ exploit binaries.
5.3 Small Root Providers

Small providers typically have only the device-side An-
droid app, besides, they usually contain few but highly spe-
cialized exploits. In our survey, P6 and P7 are classiﬁed as
small providers, both of their Android apps simply invokes
the native exploit binary and the entire procedure has no
protection. For the exploit binaries, although there are cer-
tain protections such as code obfuscation and tamper detec-
tion, they are generally primitive and easy to spot and by-
pass. Interestingly, the lack of eﬀective defenses also makes
it possible for larger root providers to take small providers’
exploits and integrate them directly into their own products,
as we observed in two larger providers.
6. CHARACTERIZATION AND CASE S-

TUDIES OF EXPLOITS

As shown in Table 2, several top providers oﬀer a large
selection of root exploits. In this section, we dissect the 167
unique exploits from the largest provider P1 by beginning
with the methodology to collect the exploits.

Exploits Collection Methodology. To download ex-
ploits from P1’s online database, we need to provide suﬃ-
cient information of diﬀerent device models to P1’s remote
server (See Figure 6). Without access to a large number of
real Android devices, we resort to online sources and factory
images publicly available [42]. After crawling several such
websites, we collect 5742 sets of device information and 2458
unique phone models with kernel ranging from 2.6.32.9 to
3.10.30 and Android version from 2.3.4 to 5.0.2. The list
covers all mainstream manufacturers such as SAMSUNG,
HTC, and SONY. They allow us to download 167 unique
exploit binaries. Note that large providers claim to support
over 10,000 or 20,000 Android device models and therefore
the number of exploits we obtained may be far smaller than
the actual number. Nevertheless, 167 unique exploit samples
are still impressive from only 2458 phone models.
6.1 Breakdown of Exploits

Families of exploits. We hypothesize that these binaries
are of high value to attackers since the number appears to be
much larger than what we can ﬁnd publicly. However, there
is an important caveat that multiple binary ﬁles may simply
be variations and adaptations of the same core exploit. In
order to perform a fair comparison, we need a way to group
similar binaries into families. Fortunately, the decrypted
descriptor ﬁles returned from P1’s server, as mentioned in
Section 5.1, have an internal naming scheme to identify each
exploit. An example of the internal name is exploit98-3.2-v1,
in which “98” is used to number the exploit type, “3.2” is a
speciﬁc kernel version, and “v1” indicates that this exploit is
the 1st variation of an original exploit. Based on the naming
scheme, we estimate that 59 diﬀerent families exist, which
is more than the 37 abusable public exploits still (See §2.3).
From the naming schemes, we can also estimate the current
size of P1’s exploit families to be in the hundreds.

Based on the knowledge gained from the public exploits
targeting diﬀerent layers, we analyze P1’s exploit binaries

and its logic, e.g., system calls and their parameters, we can
classify a large portion of them into two main categories:
20 families belonging to kernel layer, typically featured with
the use of vulnerable system calls such as futex (CVE-2014-
3153) and perf_event_open (CVE-2013-2094), and 37 fam-
ilies belonging to driver layer, featured with operations on
vulnerable device ﬁles such as /dev/exynos mem. The re-
maining 2 families are diﬃcult to classify.
In the kernel
layer, we have identiﬁed 17 families that can be mapped to
publicly available exploits, but are unable to fully analyze
the other 3. According to the exploit descriptors, we cannot
locate the exploit for most aﬀected devices from any public
sources. For the driver layer exploits, we recognize 22 fami-
lies as already published, but surprisingly, as we will discuss
later, the remaining 15 families are potentially new exploit-
s. Interestingly, we did not encounter any application layer
exploits that typically check the existence of a process by
name or a well-known ﬁle path.

New Driver-Layer Exploits. We identify 37 families
of driver exploits, All driver layer exploits have the standard
behavior of open() on a vulnerable device ﬁle in the form of
/dev/ﬁle followed by ioctl() or other syscalls on the ﬁle. We
diﬀerentiate the device ﬁle name as kernel’s built-in device
or vendor-speciﬁc device and include the latter only. Even
though many of them match existing exploits, we do ﬁnd 15
new exploit families targeting 10 vulnerable unique device
names. We are able to locate the unique device ﬁle name
to speciﬁc devices which match the aﬀected device models
in P1’s own exploit ﬁle descriptor. The aﬀected devices in-
clude popular brands like SAMSUNG and some new models
released less than a year ago. Due to security reasons we do
not reveal the vulnerable device ﬁle names.
Interestingly,
in a recent research [42], it is suggested that vendor cus-
tomizations of Android introduce considerable driver-layer
vulnerabilities (no root exploit is discovered however).
In
our study, we ﬁnd that such vulnerabilities can in fact lead
to root privilege escalation. In retrospect, now that kernel
exploits are harder and harder to come by with the latest
OS security technology in place, it is natural to target the
drivers to develop new exploits.

Adaptation. The most noticeable exploit family in P1’s
database is the one with 89 variants. By reverse engineering
the exploit ﬁles we identiﬁed the family as implementations
of CVE-2014-3153, the well-known “futex” kernel vulnera-
bility. This conﬁrms the need of adaptation of exploits as
discussed in §3. To understand why this many variants are
developed, we analyze the intended kernel version target-
ed by the 89 exploits and ﬁnd 14 diﬀerent kernel versions
are targeted. Even for the same kernel version, P1 will ap-
ply diﬀerent variants according to the kernel “build informa-
tion” (e.g., [#1 SMP PREEMPT Wed May 15 23:25:44 KST
2013]). The result is summarized in Table 3, P1 has covered
most major linux kernel versions used by Android. For some
popular versions such as “3.4.0”, there exist more variants.
Beside the adaptation for kernel versions, from the exploit
descriptors, we also see that some variants speciﬁcally de-
signed for certain device manufactures such as SAMSUNG
and HUAWEI. The rest of the exploit families do not have
many variants, e.g., 42 families have only one binary.

Overall, we are impressed by the scale at which exploits
are engineered by P1. It will be extremely diﬃcult for an
individual to match the amount of resources and engineering
eﬀort. We believe similar high impact kernel-level vulnera-

1101Kernel Version 2.6.32.9 2.6.35.7 3.0.15 3.0.16 3.0.31 3.0.8 3.4.0 3.4.39 3.4.43 3.4.5 3.4.67 3.10.0 3.10.9 3.10.30
Variants Count
1
1 The calculation is based on our own collection, actual amount of P1’s variants may be larger.

10

2

21

8

2

1

9

2

1

1

1

3

3

Table 3: P1’s adaptation for CVE-2014-3153 (based on kernel version)

bility such as CVE-2015-3636 (currently pioneered as Ping-
Pong Root) may be of similar value and require substantial
adaptation eﬀort. It is reported that the root exploit aﬀects
many latest Android devices such as Samsung Galaxy S6
and HTC One (M9) and the list is growing.

Timeline to add new exploits. As we have shown, ex-
ploits from large commercial root providers largely overlap
with publicly available ones. One important metric indicat-
ing the competitiveness of the providers is the time it took
from the date original exploits were ﬁrst published to the
date that they are incorporated. Even though there is no
comprehensive data, we do have a unique data point on the
latest PingPong root exploit, which was ﬁrst published in
May 2015. The same exploit is incorporated in P1 roughly
two to three months later. We note that PingPong root is
techinically intrisnic and involved. It is impressive that the
provider has ﬁnished reverse engineering, developing, and
testing of the exploit within such a short period. In fact,
the incorporation happened before the full technical detail
of the exploit is released and any proof-of-concept code is
available. This demonstrates that commercial root provider-
s are capable and swift, which is another reason why they
may become targets of attackers.
6.2

Interaction with Advanced Security
Mechanism

In 109 out of 167 P1’s exploits (including all “futex” ex-
ploits), we observe special treatment for SELinux, which
forms the base of the advanced Android security mecha-
nisms such as SEAndroid [37] and Knox [17]. To support
ﬁne-grained mandatory access control, SELinux introduced
the concept of “security context” whereby a process running
as root may still be subject to restrictions imposed by the
policies on the “context” it is running as. This eﬀectively
eliminates the powerful root in the traditional Linux. How-
ever, in AOSP, SELinux policy in Android 4.4 and below
generally make the app domain either permissive or uncon-
ﬁned. Unless customized by vendors such as Samsung, it
means that SELinux is eﬀectively “disabled”. Furthermore,
even when SELinux policies are conﬁgured to be enforcing,
as is done since Android 5.0 (AOSP), kernel-layer exploits
can subvert SELinux easily by overwriting the related kernel
data structures, given SELinux operates under the assump-
tion that the kernel is intact. Speciﬁcally, almost in all cases
of the 109 exploits, they overwrite not only the uid but al-
so the sid and osid so that the security context eﬀectively
becomes “init”, which is the most privileged one and is able
to access almost all system resources. After that, they will
write to /proc/self /attr/current to change its string repre-
sentation of security context to “u:r:init:s0”.

Similarly, we also observe modiﬁcations to Linux “pro-
cess capability” related kernel data structures such as
cap ef f ective to 0xFFFFFFFF. Since process capabilities
in Linux share the same threat model as SELinux, it is not
hard to imagine that they can be subverted in the same way.
When compared with public proof-of-concept exploit
source code, we rarely ﬁnd such level of care in dealing with
the additional restrictions set by SELinux and process ca-
pabilities.

AVG Lookout Norton Trend Micro

N
Original
N
N
Unpacked N
Bypassed N
N
1 N:No threat detected
2 All anti-virus at newest version when testing.
Table 4: Anti-Virus Test Results on P1’s exploits

N
13
N

N
N
N

6.3 Anti-Virus Test

Since the root exploits are highly sensitive and may be
leveraged by various Android malware, it is expected that
anti-virus software on Android platform can identify most
of them, including the ones implemented by root provider-
s. We select the same 4 representative Android anti-virus
products to test P1’s 167 exploits. Because originally down-
loaded exploits from P1’s database have packed the actual
exploit code and employed a tamper-detection mechanism,
we crafted 3 diﬀerent versions for every exploit: 1) Origi-
nal exploit fetched directly from P1’s servers, with packing
and tamper-detection on. 2) Unpacked exploit, which will
expose all actual exploit logic to anti-virus products. 3)
Re-packed exploit with tamper-detection disabled. The last
version can be highly dangerous since it can be utilized freely
by malware that can unpack and execute at run time.

To test the antivirus software, we embed all exploit ﬁles
of one version at a time in a self-developed Android app to
trigger the proper scan. We test one antivirus software at a
time. If a message is prompted that the app is safe to open,
it indicates the antivirus software fails to detect any exploit
in the app, and we uninstall the antivirus and install the
next. If an alert is given ﬂagging our app as malicious, we
attempt to identify which subset of exploits are ﬂagged by
embedding one exploit ﬁle at a time and retest.

The test results are shown in Table 4. It is disappointing
to see that no packed exploit is detected by any antivirus
software. It is likely due to the custom obfuscation imple-
mented by the provider that is not recognized. However,
even for the unpacked ones, only Trend Micro can recognize
13 out of 167 exploit ﬁles as malicious.
It is worth men-
tioning that the highly dangerous futex exploits as well as
the PingPong root exploit are not caught by any antivirus
software. This contrasts with the result in §2.4 where the
public PingPong root exploit is in fact detected by Trend
Micro. This suggests 1) P1’s implementation of PingPong
root is suﬃciently diﬀerent; 2) Trend Micro uses some kind
of signature-based detection that is not eﬀective at catching
variants of the same exploit. Overall, the result shows that
the state-of-the-art security products on Android platform
still cannot address root exploits eﬀectively. Worse, packing
and obfuscation can easily evade detection.

7. RELATED WORK

Android malware analysis. Android malware detec-
tion and analysis attracted much attention of research in
the past few years [43, 32, 44, 22]. The Android Malware
Genome Project [43] has oﬀered a public dataset of Android
malware from year 2010 to 2012. The analysis covers behav-
iors from privacy invasion, ﬁnancial charges, remote control,

1102to root exploits embedded in the malware. In the ANDRU-
BIS [32] project, a more recent malware set of 400K samples
collected between 2012 and 2014 is examined. It gives a more
up-to-date view, yet little discussion is on malware carrying
root exploits. Other sources include Contagio minidump [3]
and VirusTotal [20]. DroidRanger [44] and DREBIN [22] at-
tempt to detect Android malware by leveraging a carefully
selected set of features.

So far, no evidence has shown that a single piece of mal-
ware embeds a large number of root exploits, likely because
of the engineering challenge, e.g., many exploits need to be
adapted to work on speciﬁc device models. In our study, it
is alarming to see the potential that malware can abuse the
root provider logic to achieve this goal.

Android root exploits and defense. While a com-
prehensive characterization of Android root exploits is lack-
ing, point studies have shown that root exploits were indeed
abused by malware in the wild [44, 43]. As described in
the Android Malware Genome Project [43], 36.7% of 1260
malware samples had embedded at least one root exploit.

Root providers present a unique position in computer his-
tory that they legitimately collect and distribute a large
number of fresh root exploits.
In theory, all commercial
root providers should provide adequate protections on the
exploits.
In practice, unfortunately, as long as one of the
providers fails to achieve that, malware authors can success-
fully “steal” the well engineered, adapted, and tested exploits
against a diverse set of Android devices.

The development of Android comes with much improve-
ment in Security. SeAndroid was shown to be eﬀective a-
gainst many root exploits that target user-level application-
s [37]. Research proposals use dynamic behaviors such as
system calls and other events to detect root exploits [44, 29,
35]. Unfortunately, none of them is bullet-proof. For in-
stance, new exploits such as TowelRoot and PingPong Root
are not impacted by SeAndroid since they exploit kernel-
layer vulnerabilities directly. In addition, the more expen-
sive dynamic analysis techniques require root privilege to
operate which limits their applicability and not to mention
its impact on battery life.

Reverse engineering and anti-reverse engineering.
Anti-reverse engineering aims at transforming a program in-
to a semantically equivalent one yet much more diﬃcult
to comprehend and reverse engineer [25, 24]. Encryption,
packing, symbol stripping, instruction reordering, etc. are
commonly used obfuscation techniques against reverse engi-
neering [24]. The key used to encrypt the code can either be
embedded directly in the binary or burned onto the hard-
ware [23, 38]. Most programs simply embed the key directly
in its binary, including the famous STUXNET [27] and the
binaries in root providers, as there is little support from the
hardware to encrypt and decrypt instructions on the ﬂy in
general-purpose computing systems [38]. In addition, a dif-
ferent program binary encrypted with a diﬀerent key needs
to be distributed for every machine, which can be costly and
complex to manage. More advanced techniques such as VM-
based software protection [23] also exist. They dramatically
increase the cost of reverse engineering by employing custom
instruction set architectures.

In response to such anti-reverse engineering and obfus-
cation techniques, deobfuscation techniques are also devel-
oped [31, 36, 23]. It is not clear when such arms race will
end as fundamentally the code under protection has to run

physically on a machine controlled by the adversary. In a
recent work, Zeng et al. proposes to use trace-oriented pro-
gramming to implement binary code reuse [41]. The idea is
that as long as the execution trace is observed and recorded
at runtime, they can be extracted and reused. In principle,
such ideas can be applied to extract obfuscated root exploit
code. However, it is not suﬃcient as the self-veriﬁcation
logic still needs to be identiﬁed and removed.

On Android, the situation is not much diﬀerent excep-
t some advanced obfuscation tools such as custom-VM-
based protections are not yet available. As most large root
providers need to protect both PC-side software and device-
side app, the obfuscation strength is determined by the
weaker side.

8. DISCUSSION AND CONCLUSION

Ethics. The study on root providers can be controversial.
We study them because of two reasons: 1) root provider is
a unique product in history that has unique characteristic-
s. 2) Although legitimate, the functionality is implement-
ed by exploiting vulnerabilities of the target system, which
presents signiﬁcant security risks. The goal of our research is
to understand and characterize the risk that well-engineered
exploits from the root providers can be stolen and easily
repackaged in malware. By studying the protection mecha-
nisms employed by root providers, we aim to quantify their
strength and point out areas of weaknesses.

To protect the root providers, in the paper, we intention-
ally anonymize their names when detailed results are shown.
Further, we plan to release our ﬁndings to the corresponding
root providers and device vendors.

Android-side root vs. PC-side root. In this study,
we cover in detail mostly the root exploits implemented di-
rectly on Android devices. Most large root providers in fact
oﬀer both PC-side as well as Android-side root methods.
The reason we focus on Android-side root is its risk of being
abused by malware. It is worth mentioning that, as demon-
strated by recent studies [39], a compromised PC can infect
the mobile devices connected to it. Under such threats, the
PC-side root exploits also become dangerous and are subject
to abuse by PC malware. We leave this for future study.

Conclusion. In this paper, for the ﬁrst time, we uncover
the mysterious Android root providers. We ﬁnd they not
only make signiﬁcant eﬀorts to incorporate and adapt exist-
ing exploits to cover more devices, but also craft new ones
to stay competitive. However, these well-engineered exploits
are not well protected, it is extremely dangerous if they fall
in the wrong hands. This may also trigger a public policy/le-
gal discussion on whether to regulate such companies that
manufacture up-to-date exploits that are freely distributed.

Acknowledgments
Research was sponsored by the Army Research Labora-
tory and was accomplished under Cooperative Agreement
Number W911NF-13-2-0045 (ARL Cyber Security CRA).
The views and conclusions contained in this document are
those of the authors and should not be interpreted as rep-
resenting the oﬃcial policies, either expressed or implied,
of the Army Research Laboratory or the U.S. Government.
The U.S. Government is authorized to reproduce and dis-
tribute reprints for Government purposes notwithstanding
any copyright notation here on.

11039. REFERENCES

[1] Android Vulnerabilities – All vulnerabilities.

http://androidvulnerabilities.org/all.html.

[2] Beating up on Android.

http://titanium.immunityinc.com/infiltrate/
archives/Android_Attacks.pdf.

[3] Contagio minidump.

http://contagiominidump.blogspot.com.

[4] CVE-2014-3153 aka towelroot.

https://github.com/timwr/CVE-2014-3153.

[5] Don’t Root Robots: Breaks in Google’s Android

Platform.
https://jon.oberheide.org/files/bsides11-
dontrootrobots.pdf.

[6] Exploit DB database. https://exploit-db.com/.
[7] How To Root An AT&T HTC One X.

http://rootzwiki.com/topic/26320-how-to-root-
an-att-htc-one-x-this-exploit-supports-185/.

[8] iRoot, Retrieved on May 10, 2015.

http://www.mgyun.com/m/en.
[9] It’s Bugs All the Way Down.

http://vulnfactory.org/.

[10] One Click Root for Android, Retrieved on May 10,

2015. http://www.oneclickroot.com/.

[11] Rage Against the Cage. http://stealth.openwall.

net/xSports/RageAgainstTheCage.tgz.

[12] Razr Blade Root.

http://vulnfactory.org/public/razr_blade.zip.

[13] Root Genius, Retrieved on May 10, 2015.

http://www.shuame.com/en/root/.

[14] Root the Droid 3. http://vulnfactory.org/blog/

2011/08/25/rooting-the-droid-3/.

[15] [Root] ZTE z990g Merit (An avail variant).

http://forum.xda-
developers.com/showthread.php?t=1714299.

[16] [Root/Write Protection Bypass] MotoX (no unlock

needed). http://forum.xda-developers.com/moto-
x/orig-development/root-write-protection-
bypass-motox-t2444957.

[17] Samsung Knox. https://www.samsungknox.com/.
[18] TacoRoot.

https://github.com/CunningLogic/TacoRoot.

[19] Virus Proﬁle: Exploit/MempoDroid.B.

http://home.mcafee.com/virusinfo/virusprofile.
aspx?key=1003986.

[20] VirusTotal. https://www.virustotal.com/.
[21] Xoom FE: Stupid Bugs, and More Plagiarism.

http://vulnfactory.org/blog/2012/02/18/xoom-
fe-stupid-bugs-and-more-plagiarism/.

[22] D. Arp, M. Spreitzenbarth, M. Hubner, H. Gascon,
and K. Rieck. DREBIN: Eﬀective and Explainable
Detection of Android Malware in Your Pocket. In
NDSS, 2014.

[23] A. Averbuch, M. Kiperberg, and N. Zaidenberg.
Truly-Protect: An Eﬃcient VM-Based Software
Protection. Systems Journal, IEEE, 2013.

[24] C. Collberg, C. Thomborson, and D. Low. A

Taxonomy of Obfuscating Transformations. Technical
report, The University of Auckland, 1997.

[25] C. S. Collberg and C. Thomborson. Watermarking,

Tamper-proﬃng, and Obfuscation: Tools for Software
Protection. IEEE Trans. Softw. Eng., 2002.

[26] J. J. Drake, Z. Lanier, C. Mulliner, P. O. Fora, S. A.

Ridley, and G. Wicherski. Android Hacker’s Handbook.
Wiley, 2014.

[27] N. Falliere, L. O. Murchu, and E. Chien. W32.Stuxnet

Dossier. Technical report, Symanetic, 2011.

[28] D. Guido and M. Arpaia. The Mobile Exploit

Intelligence Project. Blackhat EU, 2012.

[29] Y. J. Ham, W.-B. Choi, and H.-W. Lee. Mobile Root
Exploit Detection based on System Events Extracted
from Android Platform. In SAM, 2013.

[30] X. Hei, X. Du, and S. Lin. Two Vulnerabilities in

Android OS Kernel. In ICC, 2013.

[31] C. Kruegel, W. Robertson, F. Valeur, and G. Vigna.

Static Disassembly of Obfuscated Binaries. In Proc. of
USENIX Security Symposium, 2004.

[32] M. Lindorfer, M. Neugschwandtner, L. Weichselbaum,

Y. Fratantonio, V. van der Veen, and C. Platzer.
Andrubis - 1,000,000 Apps Later: A View on Current
Android Malware Behaviors. In BADGERS, 2014.
[33] C. Linn and S. Debray. Obfuscation of Executable

Code to Improve Resistance to Static Disassembly. In
ACM CCS, 2003.

[34] OpenSignal. Android Fragmentation Visualized.

http://opensignal.com/reports/2015/08/android-
fragmentation/, 2015.

[35] Y. Park, C. Lee, C. Lee, J. Lim, S. Han, M. Park, and

S.-J. Cho. RGBDroid: A Novel Response-Based
Approach to Android Privilege Escalation Attacks. In
LEET, 2012.

[36] R. Rolles. Unpacking Virtualization Obfuscators. In

WOOT, 2009.

[37] S. Smalley and R. Craig. Security Enhanced (SE)

Android: Bringing Flexible MAC to Android. In
NDSS, 2013.

[38] J. I. Torrey. HARES: Hardened Anti-Reverse

Engineering System. Technical report, Assured
Information Security, Inc., 2015.

[39] T. Wang, Y. Jang, Y. Chen, S. Chung, B. Lau, and

W. Lee. On the Feasibility of Large-Scale Infections of
iOS Devices. In Proc. of USENIX Security
Symposium, 2014.

[40] W. Xu. Ah! Universal Android Rooting is Back.

Blackhat, 2015.

[41] J. Zeng, Y. Fu, K. A. Miller, Z. Lin, X. Zhang, and

D. Xu. Obfuscation Resilient Binary Code Reuse
Through Trace-oriented Programming. In ACM CCS,
2013.

[42] X. Zhou, Y. Lee, N. Zhang, M. Naveed, and X. Wang.

The Peril of Fragmentation: Security Hazards in
Android Device Driver Customizations. In IEEE
Security and Privacy, 2014.

[43] Y. Zhou and X. Jiang. Dissecting Android Malware:

Characterization and Evolution. In IEEE Security and
Privacy, 2012.

[44] Y. Zhou, Z. Wang, W. Zhou, and X. Jiang. Hey, You,

Get Oﬀ of My Market: Detecting Malicious Apps in
Oﬃcial and Alternative Android Markets. In NDSS,
2012.

1104