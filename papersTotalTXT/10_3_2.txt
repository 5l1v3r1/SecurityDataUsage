Securing the Software-Deﬁned

Network Control Layer

Phillip Porras, Steven Cheung, Martin Fong, Keith Skinner, and Vinod Yegneswaran

Computer Science Laboratory

{porras,cheung,mwfong,skinner,vinod}@csl.sri.com

SRI International

Abstract—Software-deﬁned networks (SDNs) pose both an
opportunity and challenge to the network security community.
The opportunity lies in the ability of SDN applications to
express intelligent and agile threat mitigation logic against hostile
ﬂows, without the need for specialized inline hardware. However,
the SDN community lacks a secure control-layer to manage
the interactions between the application layer and the switch
infrastructure (the data plane). There are no available SDN
controllers that provide the key security features, trust models,
and policy mediation logic, necessary to deploy multiple SDN
applications into a highly sensitive computing environment. We
propose the design of security extensions at the control layer to
provide the security management and arbitration of conﬂicting
ﬂow rules that arise when multiple applications are deployed
within the same network. We present a prototype of our design
as a Security Enhanced version of the widely used OpenFlow
Floodlight Controller, which we call SE-Floodlight. SE-Floodlight
extends Floodlight with a security-enforcement kernel (SEK)
layer, whose functions are also directly applicable to other
OpenFlow controllers. The SEK adds a unique set of secure appli-
cation management features, including an authentication service,
role-based authorization, a permission model for mediating all
conﬁguration change requests to the data-plane, inline ﬂow-rule
conﬂict resolution, and a security audit service. We demonstrate
the robustness and scalability of our system implementation
through both a comprehensive functionality assessment and a
performance evaluation that
illustrates its sub-linear scaling
properties.

I.

INTRODUCTION

SDN frameworks, such as OpenFlow (OF), embrace the
paradigm of highly programmable switch infrastructures [1]
managed by a separate centralized control layer. Within the
OpenFlow network stack, the control layer is the key com-
ponent responsible for mediating the ﬂow of information and
control functions between one or more network applications
and the data plane (i.e., OpenFlow-enabled switches). The net-
work applications are typically trafﬁc-engineering applications,
such as ﬂow-based load or priority management services, or
perhaps applications designed to mitigate hostile ﬂows or to
enable ﬂows to bypass faulty network segments.

Permission to freely reproduce all or part of this paper for noncommercial
purposes is granted provided that copies bear this notice and the full citation
on the ﬁrst page. Reproduction for commercial purposes is strictly prohibited
without the prior written consent of the Internet Society, the ﬁrst-named author
(for reproduction of an entire paper only), and the author’s employer if the
paper was prepared within the scope of employment.
NDSS ’15, 8-11 February 2015, San Diego, CA, USA
Copyright 2015 Internet Society, ISBN 1-891562-38-X
http://dx.doi.org/10.14722/ndss.2015.23222

To date, OpenFlow controllers [2], [3], [4], [5] have largely
operated as the coordination point through which network
applications convey ﬂow rules, submit conﬁguration requests,
and probe the data plane for state information. As a controller
communicates with all switches within its network, or network
slice [6], it provides the means to distribute a coordinated set of
ﬂow rules across the network to optimize ﬂow routes and divert
and balance trafﬁc to improve the network’s efﬁciency [7].

From a network security perspective, OpenFlow offers
researchers a unique point of control over any ﬂow (or ﬂow
participant) deemed to be hostile. An OpenFlow-based secu-
rity application, or OF security app, can implement much
more complex ﬂow management logic than simply halting
or forwarding a ﬂow. Such apps can incorporate stateful
ﬂow-rule production logic to implement complex quarantine
procedures of the ﬂow producer, or they could migrate a
malicious connection into a counter-intelligence application in
a manner not easily perceived by the ﬂow participants. Flow-
based security detection algorithms can also be redesigned
as OF security apps but implemented much more concisely
and deployed more efﬁciently [8]. Thus, there is a compelling
motivation for sensitive computing environments to consider
SDNs as a potential source of innovative threat mitigation.

However,

there are also signiﬁcant security challenges
posed by OpenFlow, and SDN’s more broadly. The question
of what network security policy is embodied across a set of
OF switches is entirely a function of how the current set of OF
apps react to the incoming stream of ﬂow requests. When peer
OF apps submit ﬂow rules, these rules may produce complex
interdependencies, or they may produce ﬂow handling con-
ﬂicts. The need for ﬂow-rule arbitration, as new candidate rules
are created by the application layer, is an absolute prerequisite
for maintaining a consistent network security policy.

Within the OpenFlow community, the need for security pol-
icy enforcement is not lost. Efforts to develop virtual network
slicing, such as in FlowVisor [6] and in the Beacon OpenFlow
controller [9], propose to enable secure network operations
by segmenting, or slicing, network control into independent
virtual machines. Each network domain is governed by a
self-consistent OF app, which is architected to not interfere
with those OF apps that govern other network slices. In this
sense, OpenFlow security has been cast as a non-interference
property. However, even within a given network slice, the
problem remains that security constraints within the slice must
still be enforced.

Contributions: This paper explores the challenges of
deﬁning a security mediation layer between the OpenFlow
application layer (where both security and trafﬁc-engineering
application must co-exist) and the data-plane (where switches
implement the ﬂow policies embodied in the ﬂow rules pro-
duced by the OF Apps). To address the security mediation
challenge, we propose the design of a security enforcement
service embedded within the control layer, which mediates all
ﬂow rule submissions and control protocol requests produced
by OF apps operating within the same network slice.

We examine the basic question of what it means to provide
a complete mediation of all communications between the
application layer and the data plane, and explore why the
absence of such mediation makes OpenFlow unsuitable for
secure network deployment. We then present a complete design
description of a control-layer security mediation service, which
we have implemented and deployed on one of the most widely
used open-source controllers available today.

Among the critical technical challenges that our design
must address is that of reconciling the dynamic production of
ﬂow-rule logic with the need to maintain consistent security
policy constraints. Within OpenFlow networks, these security
policy constraints are essentially ﬂow rules, produced by an
administrator or dynamically inserted by OF security apps in
response to perceived threats. While we present our solution
to the ﬂow policy mediation challenge through the design de-
scription of SE-Floodlight, the described security features are
fully applicable to the broader family of OpenFlow controllers.

II. DEFINING SECURITY MEDIATION IN AN OPENFLOW

NETWORK

This section enumerates several of the security challenges
that face those seeking to deploy applications within an Open-
Flow network. Here, we examine these challenges by way of
motivating examples. We then follow this discussion with the
presentation of a secure control-layer design that overcomes
these challenges.

A. Challenge 1: Application Co-existence

Consider the basic challenge of implementing two or more
OF apps within the same network, as depicted in Figure 1.
Suppose A1 initiates a series of ﬂow rule insertions designed to
quarantine the ﬂows to and from a local Internet server, which
is operating in a malicious manner. A2, a load-balancing app,
redirects incoming ﬂow requests to an available host within
the local Internet server pool. Suppose the Internet server
quarantined by A1 subsequently becomes the preferred target
for new connection ﬂows by A2, as this quarantined server is
now the least loaded server in the pool. Who should arbitrate
the quarantine imposed by A1 against subsequent conﬂicting
rules produced by A2, and which OF app (A1 or A2) should
prevail?

Such conﬂicts in trafﬁc engineering objectives may happen
often. An excellent example of an OpenFlow Stack imple-
menting multiple (competing) trafﬁc engineering algorithms
is Google’s OpenFlow-based B4 private WAN network man-
ager [7]. Using an OpenFlow implementation of a centralized
WAN-wide trafﬁc engineering (TE) application, Google’s B4
accommodates three parallel trafﬁc-engineering components:

Fig. 1. Multi-app co-existence scenario

•

•

•

trafﬁc throttling: arbitrates competing application ﬂow
demands during periods when its networks resources
are constrained.
ﬂow balancing: utilizes SDN’s virtual circuit facilities
to leverage available network capacity according to
application priority.
ﬁne-grained path manipulation: it dynamically reallo-
cates bandwidth in the face of link/switch failures or
shifting application demands.

In combination, these trafﬁc engineering functions enable
Google to run the B4 private-WAN at near 100% utilization,
with all links averaging 70% utilization over sustained periods,
shattering the need for the typical 3-fold over-provisioning of
capacity recommended by the standard networking model. In
short, the centralized control paradigm of SDNs provides B4
the agility to dynamically navigate and throttle ﬂows given the
global operating needs of the private-WAN.

But how do these competing TE functions co-exist when
they embody such diverse trafﬁc TE objectives? How are
conﬂicts resolved when a fair load-balancing strategy would
dictate ﬂows be directed down one network path, while a fault
or ﬂow-priority based assessment dictates otherwise?

To date, as in B4, the solution for OpenFlow developers
has been to design competing TE logic into a monolithic ap-
plication, where the arbitration of conﬂicting ﬂow rules occurs
fully within the app. Unfortunately, monolithic app designs are
not extensible, reusable, secure, or reliably maintainable.

In this paper, we explore the potential for implementing
conﬂict detection and resolution inline at the OpenFlow control
layer. An intelligent control layer capable of arbitrating ﬂow
rule conﬂicts could offer an alternative for developing modular
and reusable OF apps that may be co-instantiated within
a single network. The trade-off of implementing multi-app
arbitration logic at the control layer is that when an OpenFlow
application loses arbitration, it must be informed of the failure,
the basis for rejection, and must incorporate its own recovery
logic (Section IV-F). This approach to implementing exception

2

Server%Pool%Controller%App%A1%App%A2%OF%Switch%Applica7on%Layer%Control%Layer%Data%Plane%App%N%logic to recover from loss from conﬂict arbitration is an
essential element toward the design of robust and modular OF
applications.

B. Challenge 2: Flow Constraints vs. Flow Circuits

Deﬁning ﬁlters to constrain communications between net-
work entities is a central element for deﬁning network security
policies. However, the OpenFlow protocol’s introduction of
the Set action empowers apps to instruct a switch to rewrite
the header attributes of a matching ﬂow. Indeed, perhaps the
central beneﬁt of SDNs is this ability to deploy software-
enabled orchestration of ﬂows to manage network resources
in an agile manner. However, this inherent ﬂexibility in the
OpenFlow protocol to deﬁne complex virtual circuit paths,
also introduces signiﬁcant management challenges, such as the
origin binding [10] problem.

The creation of virtual circuits offers a particular challenge
to designing a control layer capable of maintaining a consistent
network security policy, where the conﬂicts between incoming
candidate ﬂow rules and existing ﬂow rules are detected and
resolved before rules are forwarded to the switch.

For example, let us consider the submission of a ﬂow rule
by a security application A1, which seeks to prevent two hosts
from communicating.

Rule 1: (criteria) A to B, (action) drop

As this ﬂow constraint (i.e., dropping ﬂows from A to B)
is installed to protect the network, it should hold that any
subsequent candidate ﬂow rule should be rejected if it conﬂicts
with Rule 1. Now consider the potential submission of three
subsequent ﬂow rules submitted by app A2, which may arrive
in any order.

Rule m: * to D, set D→B, Output to table
Rule n: A to *, set A→C, Output to table
Rule o: C to B, forw

We observe that, individually, none of the three ﬂow rules
(m, n, o) conﬂicts with Rule 1. The action ”Output to table”
indicates that once the set operation is performed, the result
should continue evaluation among the remaining ﬂow rules.

In one possible rule submission ordering [m, n, then o],
if the controller were to allow rule o to be forwarded to the
switch, then a logic chain will arise. That is, a ﬂow from A to
D results in the following: D’s address is set to B by rule m,
A’s address is set to C by n, and rule o cause the ﬂow to be
forward to B. In effect, any submission order of m, n, and o,
leads to the circumvention of Rule 1.

The inability to reliably handle invariant property violations
in recursive ﬂow rule logic chains established by such virtual
circuits, using the Set action, is a fundamental deﬁciency
of existing systems such as VeriFlow [11] and commercial
systems like VArmour [12]. Without a scalable inline solution,
this basic challenge will hinder the deployment of multi-
application deployments of OpenFlow in networks that require
strong policy enforcement.

C. Challenge 3: An Application Permission Model

In addition to creating ﬂow rules, OpenFlow provides
apps with a wide range of switch commands and probes. For
example, applications may reconﬁgure a switch in a manner
that changes how the switch processes ﬂow rules. Apps may
query statistics and register for callback switch events, and
they can issue vendor-speciﬁc commands to the switch.

While network operators might choose to run a third party
OF app, OpenFlow offers them no ability to constrain which
commands and requests the apps will issue to the switch. This
notion of constraining a third party OF app’s permissions may
seem analogous to that of smartphone users who can choose to
accept or deny a mobile app permission to access certain phone
features or services. Why provide an OF App unneeded access
to issue low-level vendor-speciﬁc commands, if the intent of
the running app has no requirement for such calls to be issued?

D. Challenge 4: Application Accountability

The absence of design considerations for multi-app support
in OpenFlow also results in a lack of ability for the control
layer to verify which app has issued which ﬂow rule. Co-
existing applications could issue interleaved ﬂow rules, all of
which are then treated identically by the control layer and data
plane. An arbitration system cannot assign unique precedence
or priority to ﬂow rules or switch commands produced from
any application. Rather, OpenFlow’s design requires that arbi-
tration of conﬂicting ﬂow rules occurs among the applications
themselves. This approach limits the reusability of OF apps and
results in the monolithic application designs, such as Google’s
B4 example.

E. Challenge 5: Privilege separation

The legacy of well-known OpenFlow controllers have
essentially treated the application layer as a library layer,
in which the trafﬁc engineering logic is instantiated as in-
terpreted scripts, module plugins, or loadable libraries that
execute within the process space of the controller. This has
largely been for the purpose of performance, but as shown
in [13], the current state of established controllers are highly
susceptible to network collapse from minor coding errors,
vulnerabilities, or malicious logic embedded within a trafﬁc
engineering application. Even a slow memory leak within a
TE application can cease the entire control layer, rendering
the network unresponsive to new ﬂow requests.

While [13] explored the robustness challenges of merging
the application layer into the control layer, the implications
of current controller architectures are equally problematic for
implementing security mediation services. Among its implica-
tions, privilege separation dictates that the element responsible
for security mediation should operate independently from those
elements it mediates. Thus, for the OpenFlow control layer to
operate as a truly independent mediator, applications should
not be instantiated in the same process context as the controller.
In OpenFlow, separation between the application and con-
trol layer is achieved through a Northbound API, which is
essentially an API deﬁned to transmit messages between the
OpenFlow application and control layers, where each operates
in a separate process context. There is substantial effort to

3

establish a Northbound API standard [14], but in addition to
providing the process separation necessary for fair mediation,
the Northbound API should also provide strong authentication
and identiﬁcation services to link each app to all ﬂow rules it
has created.

F. Toward a Security-Enhanced Control Layer

In the remainder of this paper, we present our design
of a security enhanced control layer that address all of the
above outlined challenges. Based on this design, we created
a security-enhanced version of an existing controller, which
we call SE-Floodlight. This implementation represents the
ﬁrst fully functional prototype OpenFlow controller designed
to provide a comprehensive security mediation of multi-
application OpenFlow network stacks.

III. DESIGNING AN OPENFLOW MEDIATION POLICY
To better understand the notion of secure mediation in the
context of OpenFlow networks, let us delve more precisely into
what information is exchanged by the parties being mediated
through the control layer.

Table I enumerates the forms of data and control function
exchanges that occur between the application layer and data
plane within an OpenFlow v1.0 stack.1 Each row identiﬁes
the various data exchange operations that must be mediated
by the control layer, and indicates the mediation policy that
is implemented. Protocol handshakes used to manage the
controller-to-switch communication channel are excluded: the
focus here is the mediation of application layer to switch
exchanges.

SE-Floodlight

introduces a security enforcement kernel
(SEK) into the Floodlight controller, whose purpose is to medi-
ate all data exchange operations between the application layer
and the data plane. For each operation, the SEK applies the
application to data plane mediation scheme shown in in Table I.
The Minimum authorization column in Table I identiﬁes the
minimum role that an application must be assigned to perform
the operation. As discussed in Section IV-A, SE-Floodlight
implements a hierarchical authorization role scheme, with three
default authorization roles. The lowest authorization role, APP,
is intended primarily for (non-security-related) trafﬁc engi-
neering applications, and provides sufﬁcient permissions for
most such ﬂow-control applications. The security authorization
role, SEC, is intended for applications that implement security
services. The highest authorization role, ADMIN, is intended
for applications such as the operator console app.

The objective of the mediation service is to provide a
conﬁgurable permission model for a given SE-Floodlight de-
ployment, in which both the set of roles may be extended and
their permissions may be customized for each newly deﬁned
role.

Column 3 of Table I presents the default Mediation policy
that
is assigned to each available interaction between the
application layer and data plane. First, the ability to deﬁne

1While the Open Network Foundation (ONF) continues to introduce new
features and data types in the evolving OpenFlow standards, we believe the
broad majority of these emerging features will translate into a variation of
these data exchange operations.

Flow
Direction
01: A to D
02: D to A
03: D to A
04: A to D
05: D to A
06: D to A
07: A to D
08: A to D
09: D to A
10: A to D
11: A to D
12: D to A
13: A to D
14: D to A
15: A to D
16: D to A
17: D to A
18: A to D

TABLE I.

Data Exchange
Operation
Flow rule mod
Flow removal messages
Flow error reply
Barrier requests
Barrier replies
Packet-In return
Packet-Out
Switch port mod
Switch port status
Switch set conﬁg
Switch get conﬁg
Switch conﬁg reply
Switch stats request
Switch stats report
Echo requests
Echo replies
Vendor features
Vendor actions

Mediation

Policy

RCA (Section IV-C)

Global read
Global read
Permission
Selected read
Selected read
Permission
Permission
Permission
Permission
Permission
Selected read
Permission
Selected read
Permission
Selected read
Permission
Permission

Minimum
Authorization
APP
APP
APP
APP
APP
APP
SEC
ADMIN
ADMIN
ADMIN
APP
APP
APP
APP
APP
APP
ADMIN
ADMIN

A SUMMARY OF CONTROL LAYER MEDIATION

POLICIES FOR DATA FLOWS INITIATED FROM THE APPLICATION
LAYER TO DATA PLANE (A to D) AND FROM THE DATA PLANE TO

APPLICATION LAYER (D to A)

or override existing ﬂow policies within a switch (row 1) is
the inherent purpose of every OpenFlow application. However,
SE-Floodlight introduces Rule-based Conﬂict Analysis (RCA),
described in Section IV-C, to ensure that each candidate ﬂow
rule submitted does not conﬂict with an existing ﬂow rule
whose author is associated with a higher authority than the
author of the candidate rule.

In OpenFlow, a rule conﬂict arises when the candidate
rule enables or disables a network ﬂow that is otherwise in-
versely prohibited (or allowed) by existing rules. In OpenFlow,
conﬂicts are either direct or indirect. A direct conﬂict occurs
when the candidate rule contravenes an existing rule (e.g.,
an existing rule forwards packets between A and B while
the candidate rule drops them). An indirect conﬂict occurs
when the candidate rule logically couples with pre-existing
rules that contravenes an existing rule. We discuss rule conﬂict
evaluation in Section IV-C.

A second class of operations involve event notiﬁcations
used to track the ﬂow table state. These operations do not
alter network policies, but provide trafﬁc engineering appli-
cations with information necessary to make informed ﬂow
management decisions. The default permission model deﬁnes
these operations as two forms of public read. The Global
read represents data-plane events that are streamed to all
interested applications who care to receive them (rows 2 and
3). Selected read operations refer to individual events for
which an application can register through the controller to
receive switch state-change notiﬁcations (rows 5, 6, 12, 14, and
16). Selected read notiﬁcation represent replies to permission-
protected operations, which are discussed next. The Packet-In
notiﬁcation is an exception, in that it is received in response
to ﬂow rule insertions (vetted through RCA) that trigger the
switch to notify that application when packets are received that
match the ﬂow rule criteria or when no matching ﬂow rule is
found.

The third class of operations involve those that require
explicit permissions (Rows 4, 7-11, 13, 15, 17, and 18). These
operations either perform direct alterations to the network ﬂow
policies implemented by the switch, or enable the operator to

4

• A Conﬂict Analyzer is responsible for evaluating each
candidate ﬂow rule against the current set of ﬂow rules within
the Aggregate Flow Table (Section IV-C).
• The State Table Manager and Switch Callback Tracking
components enable the SEK to maintain a locally accurate
snapshot of the switch ﬂow table (Section IV-E). This local
representation is essential for enabling the Conﬂict Analyzer
to determine whether a new candidate rule is in conﬂict with
one or more ﬂow rules already resident in the ﬂow table.
• The Permission mediator mediates the non-ﬂow-rule-based
messages that are exchanged between the application layer
and data plane. The Permission mediator denies access to
an operation unless the application is authenticated under a
role for which the administrator has granted permission to the
operation.

An application may be run in two possible modes. First,
in Section IV-B we present an application authentication
scheme, which support author identity linkage for every SEK-
mediated message. We present a module authentication ser-
vice, which enables a Java class to be integrity-checked and
assigned a cryptographically-signed operating role. Floodlight
implements network applications as Java classes, as do other
Java-based controllers; there is a substantial legacy base of
OpenFlow applications implemented in this manner. Thus,
a key pragmatic feature of SE-Floodlightis to validate the
integrity of an OF app loaded as a class module at load time,
and then to assign all messages it produces to the module’s
signed authorization role.

However, in secure deployments of SE-Floodlight, to ad-
dress the challenge of privilege separation one should employ
the digitally authenticated Northbound remote API, with per-
message credential assignment. In Section IV-F, we discuss
the beneﬁts of using this API to enable the security mediation
service to operate as a truly independent mediator between the
application layer and the data plane. This is the method that
secure deployments of SE-Floodlight would use to ensure the
integrity of the security mediation service.

Finally, Section IV-G presents the ﬁrst OpenFlow security
audit subsystem, which tracks all security-relevant events oc-
curring within the OpenFlow control layer. This audit sub-
system satisﬁes an important prerequisite for environments
that must address security compliance speciﬁcations pertaining
to audit of administrative functions. More broadly, the audit
subsystem offers individual application accountability for all
OpenFlow messages processed to and from the application
layer, as well as capturing all controller-internal and switch-
reported security relevant events.

A. Role-based Authorization

Today’s OpenFlow controllers simply do not address con-
tentions that may arise when co-resident OF apps produce
conﬂicting ﬂow rules. Before we describe our conﬂict detection
and resolution strategy (Section IV-C), we must introduce the
notion of authorization roles, which administrators may assign
to individual OpenFlow applications.

Fig. 2. High-level overview of the SE-Floodlight architecture

control switch conﬁguration or to test switch accessibility. The
intent is to grant an application permissions to the minimum
set of operations necessary for it to perform the its expected
functions. Custom permission sets can be granted to applica-
tions by creating additional authorization roles. Note that each
permission is associated with a minimum authorization role,
such that roles hierarchically above the minimum role are also
granted permission to the operation. For the APP authorization
role, permissions are granted for those operations that do not
provide methods for altering network security policy. One
exceptional operation is Packet-Out. SE-Floodlight restricts
Packet-out to the SEC authorization role because this operation
is used to formulate custom packets that are sent directly to
the switch, bypassing ﬂow table evaluation within the switch.
For this operation, SE-Floodlight requires the administrator to
speciﬁcally grant this permission to individual non-security-
related trafﬁc engineering applications.

IV. DESIGN OF A SECURE CONTROL MEDIATION LAYER

Figure 2 illustrates the components integrated into SE-
Floodlight, which extend baseline Floodlight to implement
our security mediation service. Not shown in Figure 2 is a
set of critical software patches which we introduce to alter
and extend key elements of Floodlight. These alterations are
necessary to ensure that our added components can perform
full mediation of all data exchanges between the control layer
and data plane. The extensions are also necessary to en-
able source-credential validation of each application message,
and to enable our permission extensions to restrict certain
application-layer interactions with the data plane.

From the bottom of Figure 2,

the SEK empowers an
OpenFlow stack to support multiple applications in parallel,
introduce
arbitration when apps produce
conﬂicting ﬂow logic, and imposes the application permission
constraints described in Table I. The SEK extends Floodlight
with ﬁve major components.

control-layer

• A Role-based Source Authentication module provides digital
signature validation for each ﬂow-rule insertion request to
provisionally limit a candidate ﬂow rule’s priority based upon
the application’s operating role (Section IV-A).

5

Permission))Mediator)Aggregate'Flow'Table'Administrator))ﬂow)rules)Security)Service)ﬂow)rules)Applica8on)ﬂow)rules)Security Enforcement Kernel Role:based)Source)Auth)State)Table)Manager)Switch)Callback)Tracking)RCA)–)Conﬂict)Analyzer)Floodlight))controller)with)security)extensions)Northbound*Proxy*Server*Security*Audit*Subsystem*App*Creden8al*Management*Java*Class*OF@App*App*Creden8al*Management*To*Applica8on*Layer*To*Data*Plane*Security*Audit**Trail*Role/based'Segrega3on'Network*applica8on*as*controller@resident*Java*class*An application’s authorization role is assigned during the
application authentication procedure, which is described in
Section IV-B. Authorizations are group roles, whose members
inherit both the rule authority used in conﬂict resolution dis-
cussed in Section IV-C, and the set of associated permissions
presented in Section III. This authorization scheme introduces
three default application authorization roles (types), which may
be augmented by the operator with additional sub-roles, as
desired.

Applications assigned the administrator role, ADMIN, such
as an administrative console application, may produce ﬂow
rules that are assigned highest priority by the ﬂow-rule conﬂict-
resolution scheme. Second, network applications that are in-
tended to dynamically change or extend the security policy
should be assigned the security application, SEC, authorization
role. Security applications will typically produce ﬂow rules
in response to perceived runtime threats, such as a malicious
ﬂow, an infected internal asset, a blacklisted external entity,
or an emergent malicious aggregate trafﬁc pattern. Flow rules
produced with the SEC role are granted the second highest
priority in the rule conﬂict resolution scheme, overriding all
other messages but those from the administrator. All remaining
apps are assigned the APP authorization role.

B. Module Authentication

For multi-application environments it

to un-
derstand which application has submitted which OpenFlow
message. Module authentication provides the foundation for
mechanisms such as application permission enforcement, role-
based conﬂict resolution, and security audit for holding errant
applications accountable.

is critical

SE-Floodlight enables two operating modes when mediat-
ing OpenFlow network applications. First, it can mediate an
application that is implemented as an internally-loaded Java
class module, which is the (legacy) method used by Floodlight.
Second, SE-Floodlight introduces a client-server Northbound
API, which enables operators to separate the controller process
(the security mediator) from the process space of the applica-
tion (the agent being mediated); see Section IV-F.

We begin by explaining the authentication and credential-
assignment scheme used when the OpenFlow application is
spawned as a class module. Our approach utilizes the Java pro-
tected factory method construct, which produces a protected
subclass for each message sent from the client application
Java class to the SEK. The protected factory supplies the
authentication-supporting API extensions used to communicate
with the SEK, and it embeds the application’s credential into a
protected subclass for each object passed to the SEK. Neither
the factory nor its protected sub-classes are modiﬁable by the
Java client, unless the client contains embedded JNI code or
violates coding conventions, which we discuss in Step 1 below.
is to introduce a class-based OF application
an administrator-assigned
messaging scheme
credential
to each message produced by the app, while
preventing the app from tampering with this credential. The
following steps outlines our approach:

Our goal

adds

that

• Step 1: JNI pre-inspector module: Prior to credential
establishment of the Java class module, the Java class module

6

must be pre-parsed by an inspection utility. If the module
is discovered to contain application-supplied JNI code or
classes that are declared within or extend classes in ”reserved”
packages, the Java class will fail pre-inspection.2

• Step 2: Application role assignment: Java class integra-
tion begins with an installation phase, in which the adminis-
trator generates a runtime credential, which includes a signed
manifest for a speciﬁed Java class module, its superclasses,
and embedded classes. The credential uniquely identiﬁes the
application and incorporates the authorization group role to
which the application will be assigned when instantiated.
The administrator also assigns the authorization role to a
security group, which speciﬁes an upper limit of group priority
that group members may assign to the messages sent to the
controller. This upper limit enables the application to assign
precedents to its own stream of ﬂow rules within the sub-range
of priorities corresponding to their role.

• Step 3: Class validation function: If a credential has
been assigned to the class module by the administrator, the
the integrity of the manifest and class ﬁles contained within
the running JVM context are digitally veriﬁed. If veriﬁed, the
class is provided a protected factory that will populate each
created object with a non-accessible subclass that contains the
role found within the application’s credential (i.e., all objects
produced through this factory are assigned the credential pro-
vided by the administrator in Step 2). Integrity check failures
result in unloading of the application and a raised exception.
If no credential is present, SE-Floodlight can be conﬁgured to
either not load the module or to automatically load the module
using the default (APP) credential.

• Step 4: The application submits a message to the
SEK: When the SEK receives a message from a Java
class module, it inspects the message to determine whether
it contains a factory-supplied protected subclass.
the
the SEK assigns
message contains the protected subclass,
the message the group speciﬁed within the credential. If
the protected subclass is not present,
the SEK associates
the message with a default role assigned by the administrator.3

If

C. Conﬂict Detection and Resolution

The SEK employs an algorithm called Rule-chain Conﬂict
Analysis (RCA) 4 to detect when a candidate ﬂow-rule conﬂicts
with one or more rules resident in the switch ﬂow table. By
conﬂict, we mean that the candidate ﬂow rule by itself, or when
combined with other resident ﬂow rules, enables or prevents a
communication ﬂow that is otherwise prohibited by one more
existing ﬂow rules.

2Any application requiring native code should be deployed using the
Northbound API, Section IV-F, while applications containing classes that
inject themselves into ”reserved” packages will be summarily rejected.

3This may occur if the application employs Floodlight’s legacy message
API. No Floodlight API enables the application to bypass SEK message
evaluation, and all such messages will
the administrator-assigned
default authorization role (ideally, the lowest [APP] authorization role).

inherit

4The version presented here is motivated by the Alias-set Rule Reduction

(ARR) algorithm presented in a previous workshop paper [15].

1) RCA Internal Rule Representation: RCA maintains an
internal representation of each OpenFlow rule, r, present in
the switch. This representation is composed of the following
elements:

•

•

•

•

•

r.criteria: This corresponds to the ﬂow-rule-match
structures, as speciﬁed in the OpenFlow 1.0 speciﬁ-
cation.
r.action: Corresponds to the ﬂow-rule action ﬁeld: the
SET action effects are captured in the r.SET mods
ﬁeld (below).

D

O f

O t

- No output. Drop packets corresponding to this
criteria
- Forward: output to port, output to controller,
or broadcast
- Output to table: the ﬂow may continue evalua-
tion by other ﬂow rules. This action enables two
or more rules to be logically chained together
when one rule whose action is O t also contains
logic to alter the ﬂow’s attributes to satisfy the
criteria of a second rule (i.e. the two rules form
a rule chain).

r.ﬂow altering: Indicates whether the rule incorporates
a SET action that alters the attributes involved in the
match criteria
r.SET mods: Captures the alterations to the ﬂow at-
tributes performed by the SET action. (r.SET mods
equals r.criteria for all ﬂow rules that exclude the SET
action).
r.priority: The priority of the rule as assigned by the
application that authored the rule. (Each authorization
role speciﬁes a maximum priority that the applications
may use.)

2) Synthetic Rules: Synthetic rules are produced by RCA
and stored in the SEK’s state table, but they are not forwarded
to the switch. Rather, synthetic ﬂow rules augment the state
table by capturing the end points of virtual ﬂows established
through rule chains. From the OpenFlow controller perspec-
tive, rule chains are reducible to two deterministic end-points.
A completed rule chain is one that is terminated by a ﬂow rule
whose action is either drop (D) or forward (O f). A candidate
rule can be chained to an existing rule in either of two ways.
Tail chaining occurs with a resident rule, r, when r.action ==
O t and r.SET mods matches rc.criteria (the criteria of our
candidate rule). Head Chaining is the complementary case,
where rc.action == O t and rc.SET mods matches r.criteria.
Tracking the correspondence between rules that contribute
to the formation of a synthetic rule is accomplished by adding
two attributes to the internal rule representation:
• r.parents: ∅ if this r is not a synthetic rule. Otherwise
it speciﬁes the two rules that were chained to produce the
synthetic rule.
• r.child : ∅ if not a parent of a synthetic rule. Otherwise it
speciﬁes the synthetic rule created from r. Upon deletion of r,
the child is garbage collected.

D. The RCA Algorithm

Set Deﬁnitions: The set of active RCA internal rules, which
implicitly and explicitly correspond to ﬂow rules resident in

each switch’s ﬂow table,
is denoted by the set A. Upon
initialization of RCA, set A = ∅. From A, we also create
a subset, Hf , which represents the set of resident rules that
may become participants at the head of a rule chain, i.e.,
r.ﬂow altering == true and r.action == O t.

Much of RCA’s task is to match the candidate rule criteria,
rc.criteria against a resident rule’s ri.criteria. To perform
rule matching, RCA employs a binary tree with source and
destination n-tuples as keys. For each candidate rule, rc, RCA
performs the follow steps:

Step 1: Testing for direct conﬂict: For each binary tree
match between candidate rc and A, RCA determines which
rule takes precedence. Rule precedence is assigned to the rule
with the highest priority. If ri takes precedence over rc, then
rc is rejected with a permission (PERM) error code and RCA
exits (no further evaluation is required). If rc takes precedence
over ri,
is deleted from the ﬂow table (a delete
notiﬁcation is produced) and we proceed to Step 2. Otherwise,
the two rule priorities are equal. In this case, if neither rc nor
ri’s action is O t, their actions do not match, and rc.SET mods
match ri.SET mods, then the matching precedence policy is
applied. Otherwise, RCA proceeds to Step 2, and considers
whether rc will form a chain with other resident rules.

then ri

Matching Precedence Policy: When the two rule priorities
are equal,
then by administrative conﬁguration, RCA will
employ either a FIFO or LIFO strategy, assigning precedence
to either the resident rule (FIFO) or the candidate (LIFO).
FIFO is the default strategy, in that it rejects the existing
candidate rule, thereby requiring the explicit recognition and
removal of the conﬂicting resident rule before the candidate is
added.

function DIRECT FLOW TESTING(rc)

for ri ∈ A matching rc do

if (ri.priority > rc.priority) then return ;
else if (ri.priority < rc.priority) then goto step2;
else if ((ri.action (cid:54)= Ot) || (rc.action (cid:54)= Ot)) then
else if rc.set mods (cid:54)= ri.set mods then goto step2;
else goto match precedence;
end if

goto step2;

end function
function MATCH PRECEDENCE(ri, rc)

if (strategy == LIFO) then reject rc and exit;
else if (strategy == FIFO) then

mark ri for deletion and goto step2

end for

end if

end function

The next task is to identify conﬂicts that arise when the
candidate combines with a resident rule to produce a rule
chain. Here, let us introduce two synthetic rule variables: a
synthetic tail-chain rule rtr = ∅, and a synthetic head-chain
rule rhr = ∅. We also set rc−orig = rc.

Step 2: Detect a tail-chaining candidate rule: For each
rule ri, in Hf , if rc.criteria.src matches ri.SET mods.src and
rc.criteria.dst matches ri.SET mods.dst, then we construct a
synthetic tail chain rule that combines the ﬂow logic of ri fol-
lowed by rc. Synthetic rule rtr.criteria is set to ri.criteria.src

7

and rc.criteria.dst. Rule rtr.SET mods.dst is set to the desti-
nation address of the last non-synthetic rule in the chain. For
synthetic rules with output O t, rtr.SET mods.src is the source
address of the last non-synthetic rule in the chain; otherwise
the rule chain terminates, and rtr.SET mods.src is the source
address of the ﬁrst non-synthetic rule in the chain. Finally, set
rtr.priority = lowest (rc, ri), and set rtr.action to the last non-
synthetic action in the rule chain. We then add rtr as a child
of rc and ri, mark ri for deletion (its logic is now incorporated
in the synthetic rule), and set rc = rtr.

function STEP 2: DETECT TAIL CHAINING(rc)
for ri ∈ Hf | rc.criteria ≡ ri.set mods do

(cid:76) rc;

rtr = ri
rtr.criteria = (rc.criteria.src, ri.criteria.dst);
(rf , rl) = (f irst, last) non-synthetic rule in chain;
if (rtr.output = Ot) then rtr.set mods.src = rl.src;
else rtr.set mods.src = rf .src;
end if
rtr.priority = min(rc.priority, ri.priority);
rtr.action = rl.action;
rc.child = rtr;
ri.child = rtr; and mark ri for deletion
rc = rtr;

end for

end function

Step 3: Detect a head-chaining candidate rule:

If
rc.ﬂow altering == true and rc.action == O t, we conduct
a binary tree match of rc.SET mods to each ri.criteria in A.
Each match represents a head chaining link from rc to ri, and
the synthetic rule rhr is constructed to represents the rule set
logic. Synthetic rule rhr.criteria is set to rc.criteria.src and
ri.criteria.dst. We determine rhr.SET mods, rhr.action, and
rhr.priority, in the same manner as in Step 2 for rtr. We then
add rhr as a child of rc and ri, mark ri for deletion, and set
rc = rhr.

function STEP 3: DETECT HEAD CHAINING(rc)

if rc.f low altering and rc.action = Ot then
for ri ∈ A | rc.set mods ≡ ri.criteria do

(cid:76) ri;

rhr = rc
rhr.criteria = (rc.criteria.src, ri.criteria.dst);
set rhr.set mods, action, and priority as in Step 2;
rc.child = rhr;
ri.child = rhr; and mark ri for deletion
rc = rhr;

end for

end if

end function

Step 4: Chained rule conﬂict analysis: For rule chain rc,
we conduct a binary tree match of rc.SET mods against all
ri.criteria in A. If a match is found such that rc.action (cid:54)=
ri.action, then a policy conﬂict exists and RCA determines
which rule takes precedence in the same manner as in Step
1. If rc.priority is lower than ri.priority then rc is rejected
with a permission (PERM) error code and RCA exits. If
rc.priority is higher than ri.priority, then ri is deleted from
the ﬂow table (a delete notiﬁcation is produced). If rc.priority
== ri.priority and RCA enforces LIFO, then ri is marked for
deletion; otherwise rc.action = ri.action.

8

function STEP 4: CHAINED CONFLICT ANALYSIS(rc)

for ri ∈ A | rc.set mods ≡ ri.criteria do

if (rc.action == ri.action) then continue;
end if
// policy conﬂict exists
if (rc.priority < ri.priority) then
else if (rc.priority > ri.priority)||(strategy == LIFO)

reject rc with PERM error and exit;

delete ri and notify

else rc.action = ri.action
end if

then

end for

end function

Step 5: Integrate rule changes to Hf and A: Provisionally,
if the r (cid:54)= ∅, add rc−orig, rtr, and rhr to Hf and A. 5 Delete
all ri marked for deletion.

1) Multiple Switches: For simplicity,

the algorithm de-
scribed in Section IV-D is for a single switch. However, SE-
Floodlight can also handle ﬂow-rule mediation among mul-
tiple switches. To accomplish this, we provide an OpenFlow
switch port connectivity table, where each row has two switch
identiﬁer:physical port pairs, S:P and S’:P’, that represent
a bi-directional physical connection between two OpenFlow
switches S and S’.

At a high level,

the multi-switch algorithm uses RCA
for individual switches. When a ﬂow-rule transitions from
one switch to another, SE-Floodlight changes the evaluation
context to that of the receiving switch. Speciﬁcally, when a
ﬂow rule is evaluated for a given switch S with an Output-to-
Port action to port P, SE-Floodlight checks for S:P in the table.
If S:P is found, SE-Floodlight replaces the action with a Goto-
Connected-Switch pseudo-instruction referencing S’. When the
instruction is evaluated, it then changes the table context to S’
before continuing to the RCA evaluation.

2) Complexity:

In Step 1, the binary tree search of rc
through A requires O(log N) comparisons, where N is the
number of rules that are present in A. This step represents the
bulk of switch forwarding and ﬁltering rules that are produced
for direct ﬂow handling in a switch. However, trafﬁc engi-
neering applications will also produce rules to conduct ﬂow
rerouting logic, and rule candidates involved in altering ﬂow-
rule criteria attributes must be further processed by Steps 2-5.
Tail chain analysis requires O(log M) comparisons, where M
is the number of n-tuples that are present in Hf , M ≤ N. Steps
3 only occurs when rc is a chaining candidate, and requires
O(log N) comparisons, Step 4 requires O(log N) comparisons
when rc produces a synthetic rule, and Step 5 requires O(log
N + log M) comparisons. Thus, in the degenerate case, where
M == N, RCA conﬂict resolution remains O(log N).

E. Flow Policy Synchronization

A key facility of ﬂow-rule conﬂict resolution is the ability
for the control layer to maintain an accurate picture of the ﬂow
table state of the managed switch. SE-Floodlight maintains
5The respective conditions are rc−orig = ∅; rtr (cid:54)= ∅ ∧ rtr.child (cid:54)= ∅ ;

rhr (cid:54)= ∅ ∧ rhr.child (cid:54)= ∅.

this state synchronization using two modules: the state table
manager, and the switch callback tracer. Combined, these two
modules maintain an accurate state of all active ﬂow rules, their
disposition within the switch’s ﬂow table, and the authorization
role of the rule producer.

When a ﬂow rule is inserted into the switch, the rule and
the associated role of the ﬂow-rule author, are recorded in the
aggregate state table in its internal rule form. Before inserting
a ﬂow rule in the switch, the SEK enables the ﬂow removal
notiﬁcation ﬂag (OFPFF SEND FLOW REM) on the rule,
informing the switch to send a ﬂow removal notiﬁcation
message when a deletion occurs. A ﬂow rule may be deleted
by the switch through rule-speciﬁc idle and hard timers. The
SEK may also initiate the expulsion of a resident rule from
the switch ﬂow table.

When the SEK forwards a ﬂow rule to the switch, it also
records the rule or its derived rule chain in its local rule
table. When a local rule is purged from the local rule table,
its corresponding ﬂow rule in the switch ﬂow table is also
purged and the SEK performs a barrier request to ensure
the rule is removed prior to processing the next application
layer message. The barrier notiﬁcation is tracked by the switch
callback tracer.

The memory complexity of the state table manager is
linearly bounded by the capacity of the switch ﬂow table. State
table manager memory usage is not a function of the packet
stream processed by the switch.

F. Process Separation

The Northbound API enables an application to be in-
stantiated as a separate process and ideally operated from a
separate non-privileged account. The main elements of the
Northbound API are the protocol speciﬁcation, the controller-
side server module, and the language-speciﬁc access libraries.
Connections to the server can be secured using standard SSL
communication with either server or mutual authentication. In
addition, the initial dialog can be conﬁgured to include an
additional password-based authentication handshake.

The most unique and important aspect of this Northbound
API speciﬁcation is its ability to assign an authenticated
application credential to every OpenFlow message that passes
through the API. The initial connection establishment be-
tween an application and the Northbound API employs both
a credential-based mutual authentication and password ex-
change over OpenSSL. Either or both authentication schemes
may be used for author and role validation. Upon successful
authentication, the validated role is checked against a pre-
loaded conﬁguration ﬁle, that is conﬁgured and managed by
the network administrator, which contains the authorization
role and privileges that this application will inherit. The role
inheritance occurs by the instantiation of an individual server-
side proxy object, which is assigned to marshal all messages to
the SEK from this client. This proxy is instantiated using the
same protected factory method described previously for client
Java classes (Section IV-B), wherein this case the factory (and
the application’s credential) is assigned to the proxy. Upon
successful authentication, all client API messages are received
by its server-side proxy, and marshaled to the SEK as message
objects.

Northbound API messages are divided into four types:
Southbound-OpenFlow, controller-service,
internal, and ex-
tensions. The Southbound-OpenFlow messages contain the
OpenFlow protocol elements plus additional required context
elements, such as the data-path identiﬁer for a speciﬁc switch.
While the structure of OpenFlow protocol elements embedded
in the Northbound API protocol remains logically the same
as in the OpenFlow speciﬁcation, the elements are encoded
using the GPB framework to provide a consistent and compact
encoding scheme for all Northbound API protocol messages.
The controller-service messages provide remote clients
with access to essential controller services, such as registering
and deregistering to receive Southbound OpenFlow messages
(e.g., Packet-In messages), query for permission to use an
OpenFlow protocol type (e.g., send a Packet-Out message), and
properly handling a switch-synchronizing barrier request-reply
pair. Extension messages provide access to auxiliary controller
functions, such as a device query for switch-port location
or known IP address information. Internal messages include
the initial handshake, any conﬁgured non-SSL authentication,
setting or changing queue policy, error events related to server
connections, and testing connection stability or latency with a
ping request.

G. Security Audit Service

OpenFlow-based network event auditing and packet-level
logging facilities have garnered increased attention in response
to the dire need for advance solutions in understanding stability
issues in complex trafﬁc engineering applications, and for
diagnosing ever increasingly complex network topologies. For
example, systems like NetSight [16] and ndb [17] offer
reﬁned packet-level tracing facilities to understand how trafﬁc
traverses the network infrastructure. In the case of ndb, a
postcard-based strategy is used to recover the route that packets
take to complete the connection. NetSight builds upon this
concept but introduces a system for tracking packet traversal
history through the network, and for driving interactive debug-
ging and monitoring systems. NetSight also records the data
plane’s ﬂow table state and logs packet traces. OFRewind is
an example network-event-based audit system for recording
and playing back SDN control-plane trafﬁc [18]. OFRewind
is able to replay these network events through topologies for
troubleshooting or debugging network device and control plane
anomalies.

SE-Floodlight introduces yet another form of auditing in
OpenFlow. Here our intention is focused on holding individual
applications accountable for the OpenFlow messages they
produce, and for tracking all all security-relevant events which
are visible to the control plane. This OpenFlow audit subsys-
tem satisﬁes an important functional prerequisite for environ-
ments requiring conformance with most security compliance
speciﬁcations pertaining to audit of administrative functions.
More broadly, it offers substantial help in tracking OpenFlow
application-layer behavioral issues, such as for troubleshooting
application correctness or comparing ﬂow record production
performance among similar applications that are exposed to
the same network trafﬁc.

Here, we introduce a translation of the common security
audit requirements deﬁned in criteria such as in the DoD

9

layer.

TCSEC standard [19] into the context of the OpenFlow
control
In doing so, we enumerate the following
security-relevant auditable events, which are both necessary
and present in this audit subsystem:
• use of identiﬁcation and authentication events
• ﬂow-rule modiﬁcation events
• ﬂow-rule conﬂict resolutions
• ﬂow-rule delete and error notiﬁcations
• alterations to the conﬁguration of the switch or controller,
including application REST APIs
• packet in and out transactions
• statistics requests and replies
• use of vendor speciﬁc switch functions
• shutdown, startup, and connection to the audit subsystem
• SEK-speciﬁc application permission grant and denial events
• audit API used to add auditable event

The audit records are variant-preﬁxed binary Google Proto-
col Buffer records, compatible with the protobuf-2.5.0 speciﬁ-
cation [20]. Floodlight modules may obtain access to the audit
control service (e.g., for administrative application developers)
using an audit logger factory from Floodlight’s service registry.
Use of the audit API is restricted through the SEK permissions
service and, by default, audit messages require a minimum
SEC authorization role. Through the audit factory, Floodlight
modules can create and write audit events and conﬁgure the
audit service.

the application credential,

For each audit record, SEK reports the event time, message
type, full message content,
the
disposition (outcome) of the message, and optional message-
speciﬁc ﬁeld attributes. The audit service leverages the appli-
cation authentication service to provide the digitally validated
identity of the application that produced the event, or a switch
identiﬁer to uniquely identify switch-initiated audit events.

Finally, the audit subsystem provides facilities for audit
event selection, event output management, and audit queue
exhaustion recovery strategy. The recovery strategy offers
either a conﬁgurable event drop policy or a system halt policy,
in which all control layer processing is halted until the audit
queue is consumed to a low-water mark. System halting when
audit exhaustion occurs has been the required mode in military
standards for operating system audit services, such as deﬁned
in the DoD TCSEC standard [19]. For completeness, the drop
policy enables LIFO or FIFO discard, discard preferential
selection based on event type, and the queue high and low
watermark deﬁnitions for discard activation.

V. FUNCTIONALITY ASSESSMENT

In this section we consider the functional aspects of SE-
Floodlight’s features, both through a real use-case scenario and
through a brief summary of security feature validation testing.

A. A Multi-application Use Case

Designing an OpenFlow control layer capable of securely
managing multi-app network conﬁgurations allows operators
to ﬁelds OF security apps in parallel with other network
applications. While the security app may be deployed to
detect and mitigate threats to network operations, there is

Fig. 3.
The topology of a self-defending wireless network that uses SE-
Floodlight to manage an anti-malware security service, called BotHunter, in
parallel with a learning switch application. Combined, the applications manage
wireless network trafﬁc within our laboratory and automatically quarantine all
ﬂows to and from a local wireless client when BotHunter detects that the
wireless client is infected with malware.

still the basic need for an independent app to handle all of
the foreground non-malicious ﬂow request. One real-world
live deployment scenario of SE-Floodlight has been deployed
within our laboratory as a publicly available wireless network
access point manager. We refer to this deployment instance
as an example self-defending wireless network. The network
topology is shown in Figure 3.

The data plane of the OpenFlow-based wireless network is
implemented using the software switch OpenVswitch, which
connects a set of 802.11b access points to the Internet. SE-
Floodlight implements a control layer, which runs two Open-
Flow applications. The ﬁrst app is a variant of the Floodlight
learning switch, operating with the APP security role, and is
used to forward network ﬂows from wireless clients on to
the laboratory gateway. The second app is actually composed
of three independent applications. BotHunter monitors a log-
ical switch span port, analyzing all trafﬁc from the wireless
clients. BotHunter applies its dialog correlation algorithm to
identify local wireless clients operating in a manner that
is consistent with coordination-centric malware [21]. When
BotHunter produces an infection proﬁle, the proﬁle is for-
warded to BHResponder, which implements a simple policy-
matching algorithm to decide whether the local asset should
be quarantined from the network. If so, BHResponder sends
a quarantine security directive that identiﬁes the IP address of
the local wireless client to the SDN Security Actuator.

The SDN Security Actuator is an OpenFlow application
operating with the SEC role, and uses the SE-Floodlight
Northbound API to communicate with SE-Floodlight. When
activated, it registers a callback to receive notiﬁcation of all
ﬂow requests to and from the infected client. All connection
to and from the client are then denied, except those involving
DNS and Web requests. These client ﬂows are redirected to
a quarantine notiﬁcation web page, indicating that the user
should speak to the site administrator as soon as possible.

10

existing resident rules. Here,
the candidate rule does not
independently violate an existing rule policy. However, when
it combines with a set of existing resident ﬂow rules, they
form a virtual ﬂow logic (captured by the RCA synthetic rule,
Section IV-C2 for this chain) that is found to conﬂict with an
existing ﬂow rule. Note that the synthetic rule is assigned the
lowest authorization role of all rules in the chain, such that
if it is found to be lower than the conﬂicting rule, then our
candidate rule is rejected.

We begin this test with three rules currently resident in the

switch ﬂow table:

ADMIN Rule #1: A to B; drop
ADMIN Rule #2: A to C; set A to A(cid:48), output to
table
SEC Rule #3: A(cid:48) to C; set C to B, output to
table

Fig. 4. Data ﬂow for malicious trafﬁc redirection

B. Functional Evaluation

Table II summarizes blackbox validation testing conducted
on the various security mechanisms designed within SE-
Floodlight.

The ﬁrst rule indicates that all ﬂows from A to B should
be ﬁltered from our network. However, rules 2 and 3 contain
logic to transform the source address from A to A(cid:48) and
from C to B. Next, an application running with the APP
authorization role submits a ﬂow that states:

Functional Tests
1: Rule rejection due to insufﬁcient priority

APP Rule #4: A(cid:48) to B; forward

Features
Role-based
Authorization
RCA
Audit service
Module
Authentication

TABLE II.

2: Dynamic ﬂow tunnel via tail chaining
3: Audit log record generation
4: Application credential validation
5: Remote application using NB API

authentication

SUMMARY OF TESTS FOR EVALUATING THE

SECURITY FUNCTIONALITIES OF SE-FLOODLIGHT

Test 1: Rule rejection due to insufﬁcient priority: To test the
detection of a direct rule conﬂict, we establish a network ﬂow
policy in which a security application installs a rule to prevent
an external entity from communicating with an internal asset.
We illustrate our example scenario in Figure 4.

to the internal host B, but

We establish a test case in which malicious host A would
like to connect
is prevented
from doing so via a ﬂow rule that is inserted by an OF
application running with the SEC authorization role. Next, an
application operating at a lower authorization role (Non-Sec
app in Figure 4) registers for PACKET IN for ﬂows originated
from host A. Upon receipt of a matching ﬂows, the application
inserts a ﬂow rule to rewrite C’s IP addresses to B, thereby
causing the ﬂow to be diverted from C to B.

When running the malicious application with the (origi-
nal) Floodlight controller, network trafﬁc from the adversary-
controlled external IP address succeeds in communicating
with a host in the internal network. When SE-Floodlight is
used, the conﬂict between the candidate ﬂow rule and the
SEC application’s ﬂow rule is detected, causing the SEK to
determine that the candidate ﬂow rule possesses insufﬁcient
authority to displace the drop rule.

Test 2: Dynamic ﬂow tunnel via tail chaining: We evaluate
the ability of SE-Floodlight to recognize conﬂicts that arise
when the candidate rule combines to form a rule chain with

11

This rule, does not directly violate any of the existing
resident rules. However, when combined with rules 2 and 3,
rule 4 produces a tail chain that creates a synthetic rule that
inherits the lowest authorization role, APP, and which forms
the logical ﬂow rule:

APP Synthetic Rule: (A, A(cid:48)) to (C, B); forward

In the synthetic rule we show all attributes that the set
transformations in rules 2-4, produce. That is, A is transformed
to A(cid:48) in rule 2, and C is transformed to B in rule 3. When
the synthetic rule is compared to ADMIN rule 1, the candidate
rule is found to produce an logical conﬂict with rule 1, and
the candidate rule is therefore rejected.

With Floodlight, all rules in this scenario are successfully
inserted into the ﬂow table. When a ﬂow is submitted to Flood-
light from A to C, the ﬂow is then faithfully tunneled from
A to B, even though ﬂow rule 1 (A to B; drop) prohibits this
ﬂow. With SE-Floodlight, rules 1-3 are successfully inserted
into the ﬂow table. However, on evaluation of rule 4, RCA
computes the tail chain between the candidate and rules 2-
3, determines that the result chain is in conﬂict with rule 1,
and rejects rule 4 because the synthetic rule derives a lower
authorization role than rule 1.

Test 3: Audit log record generation: The security audit
service of SE-Floodlight can be conﬁgured to log controller
security-relevant events of interest
to the users. The audit
log may be useful for network troubleshooting as well as
a data source for security monitoring. We performed a test
with the StaticFlowPusher Floodlight module, which provided
a REST API for modifying ﬂow tables. Also, we granted
the PACKET OUT privilege to the module. Figure 5 depicts

Internal	  host	  C	  External	  hosts	  Host	  A	  OpenFlow	  switch	  Host	  B	  Controller	  Non-­‐Sec	  App	  Sec	  App	  A-­‐>B,	  drop	  an audit
log record generated when we used the module
to manually add a ﬂow rule to a switch, with part of the
Southbound OpenFlow message truncated.

posixTime: 2014-05-05T11:22:33.444
agentID: "n.f.security.SEFloodlight"
instanceID: "n.f.security.SEFloodlight@29422384"
status: INFO
detail {

category: "OF"
instanceID: "n.f.s.SEStaticFlowEntryLoader@197ebe66"
clientID: "SEStaticFlowEntryLoader"
group: "packetOut"
memberID: "packetOut"

}
sbOFMessage {

datapathID: 00:00:00:00:00:01 (1)
ofMessage {

ofType: FLOW_MOD

...

Fig. 5. Example audit log record

Test 4: Application credential validation: To counter the
threats in which an adversary may forge an application or may
compromise the integrity of an existing one, SE-Floodlight
employs credential ﬁles for applications. Our test involves
creating new applications and modifying existing applications.
With Floodlight, which does not support the notion of
application credentials, we could create new applications and
modify existing ones, and successfully ran the applications.
With SE-Floodlight, the newly created applications (for which
we did not create credential ﬁles) and the modiﬁed applications
(for which we did not regenerate the corresponding credential
ﬁles) failed to run.

Test 5: Remote application using NB API authentication:
The Northbound API supports mutually authenticated connec-
tions between northbound client and SE-Floodlight, includ-
ing two types of authentication: password-based and SSL-
certiﬁcate-based. Also, Northbound authentication enables the
use of the veriﬁed client identiﬁer as the member ID for SE-
Floodlight. We performed a test that involves running an appli-
cation on a remote machine sending a password over a secure
connection to perform authentication with SE-Floodlight using
the Northbound API.

While Floodlight supports a REST API for remote message
exchange, this interface does not support ﬁne-grained appli-
cation authentication. SE-Floodlight’s module authentication
service is designed to support
individual authentication of
applications. With SE-Floodlight, we showed that a remote
application that did not have the right authentication token
was prevented from performing any actions against OpenFlow
switches using SE-Floodlight.

VI. PERFORMANCE EVALUATION

We conducted experiments to measure the latency overhead
for our prototype implementation of SE-Floodlight. We deﬁne
latency as the time that SEK takes to perform ﬂow table
maintenance and RCA resolution for a new ﬂow rule insertion.
In our experiments, we ran an OpenFlow controller on
a Linux machine, and ran Open vSwitch (a software-based
OpenFlow switch; http://openvswitch.org) on another Linux
machine. By using separate machines for the controller and
the switch, we can more accurately measure the performance

Fig. 6. Cumulative distribution function for the latency of adding new ﬂows

of the controller without being affected by the switch activities
that do not involve the controller. To measure the latency,
we implemented a timing module for SE-Floodlight, which
provides a REST API for obtaining the statistics of the latency
measurements.

We used nmap (http://www.nmap.org) on a host S to send
UDP packets to random unique ports of another host D. On
host D, we ran the discard service listening to a speciﬁed port,
and conﬁgured iptables to redirect UDP trafﬁc for a range of
ports to the discard service port. Also, we employed a purpose-
built IP-address-based learning switch module for Floodlight
that generated ﬂowmods with source and destination IP address
ﬁelds, source and destination ports, and the protocol. Recall
that the overhead of RCA is a function of the number of active
ﬂow rules. Thus, we constructed these ﬂowmods not to timeout
to create a worst case scenario for SE-Floodlight.

To measure the latency overhead of SE-Floodlight as a
function of the number of new ﬂow rules, we conducted a
series of tests in which we created different number of ﬂow
rules starting with an empty ﬂow table. Figure 6 depicts the
latency CDF for the tests, with the X-axis corresponding to
latency (milliseconds) for adding new ﬂow rules and the Y-
axis corresponding to the cumulative percentage.

The results (as shown in Figure 6) indicate that the maxi-
mum latency pertaining to the majority of the ﬂows remained
relatively ﬂat as we increased the number of new ﬂow rules
in the experiment. This suggests that our implementation has
good scaling properties. The ﬁgure also illustrates that the
addition of most new ﬂows incurs an additional overhead of
approximately 35 ms. Despite being an unoptimized prototype
implementation, our ﬂow management overheads seem to be
in line with measured median inter-arrival times, for new ﬂows
in a datacenter, of around 30 ms [22].

VII. LIMITATIONS AND DISCUSSION

We have scoped the central security objective of this
paper to that of reconciling the need for a reliably enforced
security policy against the ability for SDN applications to
deliver highly dynamic trafﬁc ﬂow management. Our security-
enhanced controller, SE-Floodlight, does not enforce non-
interference among co-resident applications;
interference is

12

0	  0.2	  0.4	  0.6	  0.8	  1	  1	  11	  21	  31	  41	  51	  61	  71	  81	  91	  101	  111	  121	  Percentage	  Latency	  (ms)	  1000	  ﬂows	  2000	  ﬂows	  3000	  ﬂows	  4000	  ﬂows	  5000	  ﬂows	  6000	  ﬂows	  7000	  ﬂows	  8000	  ﬂows	  9000	  ﬂows	  10000	  ﬂows	  explicitly allowed, as applications may override each other,
depending on their respective authorizations. Neither does SE-
Floodlight prevent disclosure of the operations performed by
peer applications. For example, applications may observe ﬂow
rule delete notiﬁcations produced from peer applications. SE-
Floodlight does not safeguard the SDN-stack from actions
that would cause it to halt operations. SDN resilience at the
data plane is explored in [23], which is complementary to our
security-focused design solution.

This design presentation also does not discuss the admin-
istrative responsibilities in conﬁguring and operating a secure
control layer in an operational deployment scenario. For ex-
ample, SE-Floodlight can be deployed in a manner that would
enable a malicious application to bypass or corrupt the SEK
(e.g., employing an application with embedded JNI designed
to alter the control
layer state). However, SE-Floodlight’s
Northbound API enables applications to be run in a separate
process context, and ideally within a separate user account.
Thus, SE-Floodlight is conﬁgurable to provide strong privilege
separation between the controller and the applications that it
mediates.

VIII. RELATED WORK

SE-Floodlight is built over the foundations laid by previous
studies such as Ethane
[24], SANE [25] and 4D [26] that
ﬁrst made the case for control-ﬂow separation and clean-
slate design of the Internet and catalyzed the development
of OpenFlow. We build our system on Floodlight, which is
an open-source OF controller [4]; however, our methodology
could be extended to other architectures like Beacon [5],
Maestro [27], and DevoFlow [28]. A more basic version of our
system implementation on the NOX controller was described
in a workshop version of our paper [15]. FlowVisor [6] is a
platform-independent OF controller that seeks to ensure non-
interference across different logical planes (slices) but does
not instantiate network security constraints within a slice. It is
possible that an OF application could use packet modiﬁcation
functions to result in ﬂow rules that are applied across multiple
network switches within the same slice. In such cases, we need
a security enforcement kernel such as SE-Floodlight to resolve
conﬂicts.

The problem of routing misconﬁgurations has been well
studied in the context of traditional enterprise monitoring
and inter-domain routing protocols For example, researchers
have investigated the problem of modeling network devices to
conduct reachability analysis [29], [30], ﬁrewall conﬁguration
using decision diagrams
[31] and test case generators [32],
[33]. The router conﬁguration checker (rcc) uses constraint
solving and static analysis to ﬁnd faults in BGP conﬁgura-
tions [34].

The need for better policy validation and enforcement
mechanisms in SDN networks has been touched on by prior
and concurrent research efforts on dynamic access control [35],
automated application testing [36] and language abstractions
to guarantee consistency of ﬂow updates [37]. In addition,
there are multiple competing efforts that build a control plane
for middleboxes and argue for decoupling middleboxes from
controllers [38], [39], [40]. In our workshop paper
[15], we
presented a conﬂict analysis algorithm and the need for a

security enforcement kernel. This paper presents an alternate
conﬂict analysis algorithm with improved computational per-
formance (logarithmic vs. linear) and support for multi-switch
deployments.

The FlowChecker system encodes OpenFlow ﬂow tables
into Binary Decision Diagrams (BDD) and uses model check-
ing [41] to verify security properties. Veriﬂow is a real-time
system that slices ﬂow rules into equivalence classes to efﬁ-
ciently check for invariant property violations [11]. However,
the evaluation of FlowChecker and Veriﬂow do not consider
handling of set action commands, which we consider to be
a signiﬁcant distinguisher for OpenFlow networks, i.e., these
systems do not handle recursive rewrite rules that result in
dynamic ﬂow tunnels, as described in Section II. Header space
analysis is an ofﬂine static analysis technique for detecting
network misconﬁgurations [42]. A recent paper, extends HSA
for inline rule-conﬂict detection and resolution in the context of
ﬁrewalls. Their system faces similar challenges to ours in terms
of detecting rule conﬂict violations. However, their goal is to
build more robust ﬁrewalls for SDN environments and does not
deal with the problem of conﬂict resolution among competing
OpenFlow applications. Further, they operate on single-switch
environments and their algorithm does not handle inter-table
dependencies [43].

IX. CONCLUSION

While OpenFlow has gained much attention in the network
research community, and arguably a fair amount of momentum
among modern network designers,
the OpenFlow protocol
and its current control-layer implementations are signiﬁcantly
lacking in an ability to support multiple applications within a
single network. We surveyed the security challenges involved
in not
just managing competing OF apps within a single
network, but design an extensive set of features that would
enable a multi-apps OpenFlow network to run in a sensitive
network computing environment that must meet stringent se-
curity requirements.

The central contribution of this work is the presentation of
a reference implementation of a security-enhanced controller,
called SE-Floodlight. We introduce the notion of OF-app
security roles and an OpenFlow-speciﬁc permission model to
cover all OpenFlow message exchanges between apps and the
data plane. We also introduce the Rule-chain Conﬂict Analy-
sis algorithm, which is an inline ﬂow-rule conﬂict detection
algorithm capable of identify invariant property violations in
recursive ﬂow-rule logic chains that arise from OpenFlow’s
virtual circuit facilities. We propose a role-based hierarchical
resolution strategy that resolves conﬂicts, and a Northbound
API that provides authenticated per-message credentials. Fi-
nally, we introduce an application-layer audit subsystem into
the OpenFlow control layer, and deﬁne the mapping of events
and audit attributes necessary to satisfy common security-audit
requirements.

In August 2013, we released an early prototype of SE-
Floodlight on the Internet, which has received over 300
downloads. The prototype is intended to stand as a reference
implementations of our ongoing research toward future secure
SDN infrastructures. We intend this work to help accelerate
the eventual development of a robust OpenFlow control layer

13

that can make compelling SDN-enabled security applications
available in the networks that need them most.

X. ACKNOWLEDGMENTS

The authors would like to gratefully acknowledge fruitful
discussions with Guofei Gu, Andrew Moore, Peter Neumann,
and Seungwon Shin during various stages of this project. The
work described in this paper was sponsored by the Defense
Advanced Research Projects Agency (DARPA) MRC2 Pro-
gram and the Air Force Research Laboratory (AFRL), under
contract FA8750-11-C-0249. The views, opinions, and/or ﬁnd-
ings contained in this paper are those of the authors and should
not be interpreted as representing the ofﬁcial views or policies,
either expressed or implied, of the Defense Advanced Research
Projects Agency or the Department of Defense.

REFERENCES

[1] N. McKeown, T. Anderson, H. Balakrishnan, G. Parulkar, L. Peterson,
J. Rexford, S. Shenker, and J. Turner, “OpenFlow: Enabling Innovation
in Campus Networks,” in Proceedings of ACM Computer Communica-
tions Review, April 2008.

[2] POX, “Python network controller,” http://www.noxrepo.org/pox/about-

pox/.

[3] N. Gude, T. Koponen, J. Pettit, B. Pfaff, M. Casado, N. McKeown, and
S. Shenker, “NOX: Towards an Operating System for Networks,” in
Proceedings of ACM Computer Communications Review, July 2008.

[4] FloodLight, “Open SDN controller,” http://ﬂoodlight.openﬂowhub.org/.
[5] D. Erickson, “The beacon openﬂow controller,” in Proceedings of the
Second ACM SIGCOMM Workshop on Hot Topics in Software Deﬁned
Networking, 2013.

[6] R. Sherwood, G. Gibb, K.-K. Yap, G. Appenzeller, M. Casado, N. McK-
eown, and G. Parulkar, “Can the Production Network Be the Testbed,”
in Proceedings of the Usenix Symposium on Operating System Design
and Implementation (OSDI), 2010.

[7] S. Jain, A. Kumar, S. Mandal, J. Ong, L. Poutievski, A. Singh,
S. Venkata, J. Wanderer, J. Zhou, M. Zhu, J. Zolla, U. H¨olzle, S. Stuart,
and A. Vahdat, “B4: Experience with a Globally-deployed Software
Deﬁned WAN,” in Proceedings of ACM SIGCOMM, 2013.

[8] S. Shin, P. Porras, V. Yegneswaran, M. Fong, G. Gu, and M. Tyson,
“Fresco: Modular composable security services for software-deﬁned
networks,” in Proceedings of the 20th Annual Network and Distributed
System Security Symposium (NDSS’13), February 2013.

[9] OpenFlowHub,

Beacon.

“BEACON,”

http://www.openﬂowhub.org/display/

[10] S. K. Fayazbakhsh, V. Sekar, M. Yu, and J. C. Mogul, “FlowTags: En-
forcing Network-wide Policies in the Presence of Dynamic Middlebox
Actions,” in Proceedings of the Second ACM SIGCOMM Workshop on
Hot Topics in Software Deﬁned Networking, 2013.

[11] A. Khurshid, W. Zhou, M. Caesar, and P. B. Godfrey, “VeriFlow:
Verifying Network-Wide Invariants in Real Time,” in Proceedings of
ACM Sigcomm HotSDN Workshop, 2012.

[12] VArmour, http://www.varmour.com/.
[13] S. Shin, Y. Song, T. Lee, S. Lee, J. Chung, P. Porras, V. Yegneswaran,
J. Noh, and B. B. Kang, “Rosemary: A robust, secure, and high-
performance network operating system,” in Proceedings of the ACM
SIGSAC Conference on Computer Communications Security, ser. CCS,
2014.

[14] Open Networking Foundation Northbound Interfaces Working Group,

https://www.opennetworking.org/images/stories/downloads/working-
groups/charter-nbi.pdf/.

[15] P. Porras, S. Shin, V. Yegneswaran, M. Fong, M. Tyson, and G. Gu, “A
Security Enforcement Kernel for OpenFlow Networks,” in Proceedings
of the ACM SIGCOMM Workshop on Hot Topics in Software Deﬁned
Networking (HotSDN), 2012.

[16] N. Handigol, B. Heller, V. Jeyakumar, D. Mazieres, and N. McKeown,
“I Know What Your Packet Did Last Hop: Using Packet Histories to
Troubleshoot Networks ,” in Proceedings of the Usenix Symposium on
Operating System Design and Implementation, 2014.

[17] N. Handigol, B. Heller, V. Jeyakumar, D. Mazi´eres, and N. McKeown,
“Where is the debugger for my software-deﬁned network?” in Proceed-
ings of the First Workshop on Hot Topics in Software Deﬁned Networks,
ser. HotSDN ’12. ACM, 2012.

[18] A. Wundsam, D. Levin, S. Seetharaman, and A. Feldmann, “Ofrewind:
Enabling record and replay troubleshooting for networks,” in Proceed-
ings of the 2011 USENIX Conference on USENIX Annual Technical
Conference, ser. USENIXATC’11. USENIX Association, 2011.

[19] Department of Defense, Trusted Computer System Evaluation Criteria,

Dec. 1985.

[20] K. Varda, “Protocol buffers: Google’s data interchange format,” Google,
[Online]. Available: http://google-opensource.

Tech. Rep., 2008.
blogspot.com/2008/07/protocol-buffers-googles-data.html

[21] G. Gu, P. Porras, V. Yegneswaran, M. Fong, and W. Lee, “BotHunter:
Detecting Malware Infection Through IDS-driven Dialog Correlation,”
in Proceedings of 16th USENIX Security Symposium on USENIX
Security Symposium, 2007.

[22] S. Kandula, S. Sengupta, A. Greenberg, and P. Patel, “The nature of
datacenter trafﬁc: Measurements and analysis,” in In Proceedings of
Usenix/ACM IMC, 2009.

[23] S. Shin, V. Yegneswaran, P. Porras, and G. Gu, “Avant-guard: Scalable
and vigilant switch ﬂow management in software-deﬁned networks,”
in Proceedings of the 2013 ACM SIGSAC Conference on Computer
Communications Security, ser. CCS, 2013.

[24] M. Casado, M. J. Freedman, J. Pettit, J. Luo, N. McKeown, and
S. Shenker, “Ethane: Taking Control of the Enterprise,” in Proceedings
of ACM SIGCOMM, 2007.

[25] M. Casado, T. Garﬁnkel, M. Freedman, A. Akella, D. Boneh, N. McKe-
owon, and S. Shenker, “SANE: A Protection Architecture for Enterprise
Networks,” in Proceedings of the Usenix Security Symposium, 2006.

[26] A. Greenberg, G. Hjalmtysson, D. A. Maltz, A. Myers, J. Rexford,
G. Xie, H. Yan, J. Zhan, and H. Zhang, “A Clean Slate 4D Approach to
Network Control and Management,” in Proceedings of ACM Computer
Communications Review, 2005.

[27] Z. Cai, A. L. Cox, and T. E. Ng, “Maestro: A System for Scalable

[28]

OpenFlow Control,” in Rice University Technical Report, 2010.
J. C. Mogul, J. Tourrilhes, P. Yalagandula, P. Sharma, A. R. Curtis, and
S. Banerjee, “DevoFlow: Cost-effective Flow Management for High
Performance Enterprise Networks,” in Proceedings of the 10th ACM
Workshop on Hot Topics in Networks (HotNets), 2010.

[29] E. Al-shaer, W. Marrero, A. El-atawy, and K. Elbadawi, “Network
Conﬁguration in A Box: Towards End-to-End Veriﬁcation of Network
Reachability and Security,” in Proceedings of the IEEE International
Conference on Network Protocols, 2009.

[30] G. Xie, J. Zhan, D. Maltz, H. Zhang, A. Greenberg, G. Hjalmtysson,
and J. Rexford, “On Static Reachability Analysis of IP Networks,” in
Proceeding of IEEE INFOCOM, 2005.

[31] A. Liu, “Formal Veriﬁcation of Firewall Policies,” in Proceedings of

the International Conference on Communications (ICC), 2008.

[32] D. Senn, D. Basin, and G. Caronni, “Firewall Conformance Testing,”

in Proceedings of the IFIP TestCom, 2005.

[33] A. El-atawy, T. Samak, Z. Wali, E. Al-shaer, F. Lin, C. Pham, and
S. Li, “An Automated Framework for Validating Firewall Policy En-
forcement,” Tech. Rep., 2007.

[34] N. Feamster and H. Balakrishnan, “Detecting BGP Conﬁguration Faults
with Static Analysis,” in Proceedings of the Usenix Symposium on
Network Systems Design and Implementation, 2005.

[35] A. Nayak, A. Reimers, N. Feamster, and R. Clark, “Resonance: Dy-
namic Access Control for Enterprise Networks,” in Proceedings of the
1st ACM SIGCOMM WREN Workshop, 2009.

[36] M. Canini, D. Venzano, P. Peresini, D. Kostic, and J. Rexford, “A NICE
Way to Test OpenFlow Applications,” in Proceedings of the Symposium
on Network Systems Design and Implementation, 2012.

[37] M. Reitblatt, N. Foster, J. Rexford, and D. Walker, “Consistent Update

14

for Software-Deﬁned Networks: Change You Can Believe In!” in
Proceedings of the ACM Workshop on Hot Topics in Networks, 2011.
[38] B. Anwer, T. Benson, N. Feamster, D. Levin, and J. Rexford, “A
slick control plane for network middleboxes,” in Proceedings of the
Second ACM SIGCOMM Workshop on Hot Topics in Software Deﬁned
Networking, 2013.

[39] Z. A. Qazi, C.-C. Tu, L. Chiang, R. Miao, V. Sekar, and M. Yu, “Simple-
fying middlebox policy enforcement using sdn,” in Proceedings of the
ACM SIGCOMM Conference, 2013.

[40] A. Gember, A. Krishnamurthy, S. S. John, and A. Akella, “Virtual
middelboxes as ﬁrst-class entities in the cloud,” in Proceedings of the
Open Network Summit, 2012.

[41] E. Al-Shaer and S. Al-Haj, “FlowChecker: Conﬁguration Analysis and
Veriﬁcation of Federated Openﬂow Infrastructures,” in Proceedings of
the 3rd ACM SafeConﬁg Workshop, 2010.

[42] P. Kazemian, G. Varghese, and N. McKeown, “Header Space Analysis:
Static Checking for Networks,” in Proceedings of the Symposium on
Network Systems Design and Implementation, 2012.

[43] H. Hu, W. Han, G.-J. Ahn, and Z. Zhao, “Flowguard: Building robust
ﬁrewalls for software-deﬁned networks,” in Proceedings of the Third
ACM SIGCOMM Workshop on Hot Topics in Software Deﬁned Net-
working, 2014.

15

