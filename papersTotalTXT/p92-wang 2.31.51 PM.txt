Call Me Back! Attacks on System Server and System Apps

in Android through Synchronous Callback

Kai Wang, Yuqing Zhang(cid:3)

National Computer Network Intrusion

Protection Center

University of Chinese Academy of Sciences

{wangk, zhangyq}@nipc.org.cn

Peng Liu

College of Information Sciences and Technology

The Pennsylvania State University

pliu@ist.psu.edu

ABSTRACT
Android is the most commonly used mobile device opera-
tion system. The core of Android, the System Server (SS),
is a multi-threaded process that provides most of the system
services. Based on a new understanding of the security risks
introduced by the callback mechanism in system services,
we have discovered a general type of design ﬂaw. A vulner-
ability detection tool has been designed and implemented
based on static taint analysis.We applied the tool on all the
80 system services in the SS of Android 5.1.0. With its help,
we have discovered six previously unknown vulnerabilities,
which are further conﬁrmed on Android 2.3.7-6.0.1. Accord-
ing to our analysis, about 97.3% of the entire 1.4 billion real-
world Android devices are vulnerable. Our proof-of-concept
attack proves that the vulnerabilities can enable a malicious
app to freeze critical system functionalities or soft-reboot the
system immediately. It is a neat type of denial-of-service at-
tack. We also proved that the attacks can be conducted at
mission critical moments to achieve meaningful goals, such
as anti anti-virus, anti process-killer, hindering app updates
or system patching. After being informed, Google conﬁrmed
our ﬁndings promptly. Several suggestions on how to use
callbacks safely are also proposed to Google.

Keywords
Mobile Security; Denial of Service; Vulnerability Detection;
Synchronous Callback; Taint Analysis

1.

INTRODUCTION

Android is an operating system for mobile devices, which
is based on the Linux kernel.
It occupies a large market
share [7, 24] and is used in various mission critical tasks, such
as vehicle-mounted systems [3], POS devices [5, 6], medical
devices [1, 2, 4] and aircraft navigation [22, 28]. In order
to make systems more powerful and secure, new versions of
Android are released at a fast pace. One important but often
(cid:3)

Corresponding author.

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full cita-
tion on the ﬁrst page. Copyrights for components of this work owned by others than
ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’16, October 24-28, 2016, Vienna, Austria
c⃝ 2016 ACM. ISBN 978-1-4503-4139-4/16/10. . . $15.00
DOI: http://dx.doi.org/10.1145/2976749.2978342

unnoticed result of the system updates is that the number
of system services has increased in every new version from
about 50 in v2.3.7 to more than 100 in v6.0.01.

The number of system services is continually increased
because Android needs to: 1) support emerging hardware,
such as Near Field Communication (NFC) and ﬁngerprint
scanning; and 2) support new functions, such as dynamic
permission authorization.
It is clear that system services
are critical function components in Android. They package
the low level functionalities and provide essential higher lev-
el functions to apps through the Inter-Process Communica-
tion (IPC) mechanism in Android, named Binder. However,
system services are very fragile since they provide easily ac-
cessible interfaces to third-party apps, including malicious
apps. On Nexus 6 with Android 5.1.0, the System Server
(SS) provides 80 Java-based services and exposes as many
as 1572 interfaces. In this sense, if one failure situation oc-
curs during the handling of one service request, the whole
process may be aﬀected. Since the SS is in fact the Android
Application Framework, such failure situations can disable
some core functionalities or even crash the entire system,
which is clearly a single point of failure for Android system.
This paper uncovers a general type of design ﬂaw in the
SS which is caused by improper use of synchronous callback.
The callback handle is received from a client process (i.e.,
an app). It is used to ﬂexibly inform the client app about
the handling result of a service request. A malicious ap-
p can forge a callback handle and inject it to the SS. We
found that, if a synchronous callback is invoked under spe-
ciﬁc conditions inside the SS or inside a cooperator system
app, vulnerability would occur. This new family of vulner-
ability is named as the “call me back” vulnerabilities.

Using a synchronous callback to “communicate” with un-
trusted apps without anticipating the worst-case situations
is indeed a design ﬂaw from the security viewpoint. In this
work, we have uncovered most if not all of these worst-case
situations. According to our study, in order to exploit a
“call me back” vulnerability, a malicious app only needs to
issue a single IPC call to the SS. The IPC sends a set of
parameters to a particular service interface in the SS. For a
vulnerable service interface, one of the parameters is a syn-
chronous callback method handle. The hazard situations of
the vulnerabilities are varied because the callbacks could be
invoked in diﬀerent contexts of the SS, or could alternative-
ly be invoked in the context of system apps, which are the
cooperators of the SS. When invoked, the malicious callback

1Summarized based on the Genymotion emulator, whose
source code is identical to Android Open Source Project.

92method can leverage two measures to conduct an attack: 1)
prevent the callback method from returning, or 2) throw an
exception. The attacks will result in the “freeze” of system
functionalities or even the soft-reboot of the system.

According to our analysis, the attacks on the “call me
back” vulnerabilities are diﬃcult to detect and prevent. We
believe the best defense method is to identify and patch the
vulnerabilities as quickly as possible. However, there are
several unique challenges: 1) callback handles can be inject-
ed not only as an IPC call parameter, but also as an inner
ﬁeld of a parameter object; 2) a callback handle can stay
dormant inside the SS context for a long period of time be-
fore its invocation is triggered by some “not suspicious at
all” SS operations; 3) a malicious app could try any partic-
ular combination of the IPC call parameter values; 4) any
system service and any system app could be vulnerable.

We have designed and implemented a vulnerability de-
tection tool which is based on static taint analysis. Our
tool can successfully address these challenges. We applied
it on all the 80 system service in the SS of Android 5.1.0
and successfully identiﬁed 6 vulnerabilities. The vulnerabil-
ities are further conﬁrmed on Android 2.3.7-6.0.1. It means
that about 97.3% [8] of the entire 1.4 billion real-world An-
droid devices [9] are vulnerable. The attacks prove that the
vulnerabilities can enable a malicious app to freeze critical
system functionalities or soft-reboot the system immediate-
ly. We also proved that our attacks can be conducted at
mission critical moments to achieve very meaningful goals.
Our contributions are summarized as follows:
(cid:15) New Understanding and Discovery. Based on new un-
derstanding of the security risks introduced by the callback
mechanism in system services, we have discovered a general
type of design ﬂaw which makes the Android system vulner-
able to denial-of-service attacks.
(cid:15) Designing a New Vulnerability Detection Tool. We have
designed and implemented a vulnerability detection tool based
on static taint analysis, which is the ﬁrst work on detecting
the “call me back” vulnerabilities in the SS.
(cid:15) Identifying New Vulnerabilities. Our tool successfully an-
alyzed 1,591 service interfaces of all the 80 system services in
Android 5.1.0. We have discovered six previously unknown
vulnerabilities which can aﬀect about 97.3% of the entire 1.4
billion real-world Android devices.
(cid:15) Attack. We have implemented several attack scenarios
to show that attacks can be conducted at mission critical
moments to achieve meaningful goals, such as anti anti-virus,
anti process-killer, hinder app updates or system patching.
(cid:15) Defenses. We proved it is hard to distinguish the attack
from benign service requests. The best way is to detect and
patch the vulnerabilities promptly. We also proposed several
suggestions about how to use callbacks more safely.
2. BACKGROUND AND VULNERABILITY

OVERVIEW

2.1 Android System Server

At runtime, the SS is a process. Every app is also a pro-
cess. If an app wants to request a service from the SS, it
will need to conduct IPC with the SS.
2.1.1 Binder Mechanism and Service Interfaces
Android introduces a new mechanism of IPC, namely Binder,

into the kernel. Binder supports communication between an

app process and the SS process following the Client-Server
model. The SS leverages Binder to provide system services,
which exposes several interfaces for the client apps.A service
interface is typically a Java method inside the SS. In most
cases, when an app invokes an Android API, it is actually
invoking some wrapper code to conduct IPC with the target
system service interface. For example, when an app invokes
the LocationManager.requestLocationUpdates() API to
register a listener for location updates, it is calling the wrap-
per code to send a service request to the interface request-
LocationUpdates() in the system service named location.

Every system service has its own service name and inter-
face descriptor. Using the service name, an app can query
the Service Manager to get an instance of the system ser-
vice’s proxy class, which will work as the handle of the sys-
tem service. The interface descriptor is an identiﬁcation of
service interfaces. When the app sends a request to a target
service interface, it will specially declare the interface de-
scriptor of the service in the transmitted data of IPC. And
when the service receives the request, it will ﬁrstly compare
the transmitted interface descriptor with its own interface
descriptor. Only if the descriptors match will the request be
handled by the SS.

Usually, the interface descriptor of a service is also the
name of the interface-deﬁnition class for Java-based system
services. This class contains an inner class named Stub and
Stub also contains an inner class named Proxy. The ser-
vice should extend Stub and implement the deﬁned service
interfaces. When a request arrives at the service, the im-
plemented service interfaces will be invoked. For a client
app, the handle of a service is just an object of respective
Stub.Proxy class. Stub.Proxy implements the service inter-
faces by packaging the IPC call parameters in the transmit-
ted data, sending the service request to the corresponding
server, parsing the reply from the server and returning it to
the client app.

2.1.2 Threads in the System Server
When a service request arrives at the SS, the Binder driver
will start a new thread in the context of the SS to handle it.
We call this kind of thread a “primary” thread. A number
of system service interfaces will handle the requests with
the help of an “assistant” thread to complete some time-
consuming and return-value-unrelated operations. Hence,
there are two kinds of thread in the server process, namely
the primary threads and the assistant threads. One impor-
tant diﬀerence between them is the way in which uncaught
exceptions are handled.

In a primary thread, uncaught exceptions will be packaged
into the reply data of the IPC. It can eﬀectively protect the
server because all the uncaught exceptions will be caught
and handled. By default, when a client app receives the
reply, it will automatically invoke reply.readException()
to cause the remote exception, if exists, to be re-thrown in
the context of the client app.

An assistant thread cannot re-throw the uncaught excep-
tion to the client app because it has no ability or opportu-
nity to package the exceptions into the reply data of IPC.
Actually, the uncaught exception will ﬁnally arrive at the
handling code in ART/Dalvik, which maintains the VM in-
stance for the SS. In order to recover from the bad inﬂuence
of the uncaught exception, ART/Dalvik will kill the SS and
soft-reboot the system.

932.1.3 Callback Mechanism in the System Server
Some system service interfaces receive a callback handle
as one parameter. Using a callback handle, the handling
result can be transmitted to the client app more ﬂexibly. In
this situation, the handling result could not only be returned
by the normal reply of IPC, but also be transmitted using
the received callback handle.
It is a more ﬂexible way to
produce the result notiﬁcation.

A callback handle is actually an object of a service’s proxy
class. It is a handle of a service component in an app that is
waiting for the notiﬁcation of the handling result from the
SS. It will work as a callback method handle in the context
of the SS. When it arrives at the SS through IPC, it is an
object of android.os.IBinder class, which is the mutual an-
cestor class of any service’s proxy class. When the callback
handle is received, the SS needs to transform it into concrete
class. Taking the android.app.IInstrumentationWatcher
class as an example, the code fragment is shown as fol-
lows. We can observe that, during the transformation of
an IBinder object, there are some validation checks (line
4). Any correct object can pass the check and be cast to the
target class (line 5). However, in the event that these check-
s fail, the object is still forced to be treated as an instance
of the target proxy class in line 6. Therefore, any received
IBinder object will be regarded as correct.

Example of IBinder Object Transformation
I I n s t r u m e n t a t i o n W a t c h e r
a s I n t e r f a c e ( a n d r o i d . o s . I B i n d e r o b j )f
i f
a n d r o i d . o s . I I n t e r f a c e

( o b j==n u l l ) f r e t u r n n u l l ;g

i i n =

o b j . q u e r y L o c a l I n t e r f a c e (DESCRIPTOR ) ;

i f

( ( ( i i n != n u l l )
&&( i i n i n s t a n c e o f
r e t u r n ( ( I I n s t r u m e n t a t i o n W a t c h e r ) i i n ) ;g

I I n s t r u m e n t a t i o n W a t c h e r ) ) ) f

r e t u r n new Stub . P r o x y ( o b j ) ;

1 . p u b l i c

s t a t i c

2 .
3 .

4 .

5 .
6 .
7 .g

Callbacks can be divided into two types:

(cid:15) Synchronous callback is deﬁned when the caller needs
to get the return value from the callback method. Execu-
tion of the caller method will be blocked until the callback
method returns.
(cid:15) Asynchronous callback is deﬁned when the caller does
not care about the handling process of the callback. Exe-
cution of the caller method will continue (right after each
invocation) without waiting for the callback to return.

2.2 Vulnerability Overview

All of our newly identiﬁed vulnerabilities are directly re-
lated to the IPC-based service interfaces in the SS. These
interfaces receive a callback handle as an IPC call param-
eter. The callback can be invoked by the SS or passed to
a cooperator system app to be invoked by the system ap-
p. According to the runtime context when the callback is
invoked, we have identiﬁed four hazard situations:

A. Inside the SS:

A1. The callback is invoked in a synchronized code

block of any service thread;

A2. The callback is invoked in an assistant thread

without involving any synchronized block.

B. Inside a cooperator system app:

B1. The callback is invoked in an activity component;
B2. The callback is invoked in a service component or

a broadcast receiver component.

For the situations A1 and B1, attackers can block the
execution of the caller method to freeze the SS or system
apps. For the situations A2 and B2, attackers can throw
a carefully selected exception to the SS or system apps to
crash their processes.

In our approach, we formulate the vulnerability as follows.
A vulnerability is a controllable way (e.g., calling an inter-
face of a system service with special parameter values) for
a malicious app to let the execution of the SS or a system
app reach a vulnerability point. A vulnerability point is a
Java program statement which calls a synchronous callback
method. A vulnerability condition is the dependent condi-
tion which determines whether a vulnerability is exploitable
or not when a vulnerability point is reached.

2.2.1 Hazard Situation A1
If a synchronous callback is invoked in a synchronized code
block in any thread inside the SS, a malicious app can im-
plement its callback method to block the caller for a con-
trollable duration. This results in the hazard of the freeze
of a system service.

How this hazard is generated: When a service request ar-
rives, Binder mechanism will start a new thread in the SS to
handle it. Diﬀerent threads may need to operate on the same
global variable (value) in the context of the SS concurrent-
ly. Therefore, concurrency control is needed by the service
threads to guarantee mutual exclusion of the multi-threaded
code. The most frequently used concurrency control mech-
anism in the SS is based on the synchronized block mecha-
nism from the Java library, named java.util.concurrent.
An example is synchronized{lock}{code}. Threads that
want to run the code in the block should acquire the lock
ﬁrst. The lock is accessible for only one thread in one point
of time and other threads must wait for it to be released.
With this mechanism, developers can ensure that: only one
thread can execute the synchronized block at a time; each
thread entering the synchronized block can see the eﬀects
of previous modiﬁcations; and each thread entering the syn-
chronized block can inﬂuence later threads without conﬂicts.
Diﬀerent synchronized blocks can be protected with the
same lock. If one thread holds the lock for a long period,
other threads that want to acquire this lock will be blocked
and the system service will lose the ability to serve new-
ly arrived requests. Some system services specially start a
watchdog thread to monitor this kind of failure. The watch-
dog sets a timer-based monitor for the target lock. Once it
ﬁnds that the lock cannot be acquired in a preset period, it
will “bite” on the SS and force it to restart to recover from
a failure state [17].

According to our new ﬁndings, some service interfaces in
the SS receive a synchronous callback handle as an IPC call
parameter and actually invoke it in a synchronized block.
To exploit this vulnerability, attackers can implement a ma-
licious callback method and inject its handle to these inter-
faces. When the callback is invoked, the attacker can block
the invocation, which can freeze the SS and may ﬁnally cause
the watchdog to bite on the SS.

2.2.2 Hazard Situation A2
If a synchronous callback is invoked in an assistant thread
of the SS, the attacker can choose to reply to the service
request with an exception. The exception will be thrown
at the invocation statement of the callback method in the

94context of the SS. If the exception cannot be handled prop-
erly, it will immediately cause the crash of the SS and the
soft-reboot of the system.

For Java-based programs, Exception is commonly used to
represent the exceptional situations. A method can inform
the caller of an exceptional situation using a throw new Ex-
ception() statement. The caller must use try-catch block to
catch and handle the possibly thrown exception, otherwise
the code won’t compile.

In this way, most kinds of Exception are forced to be han-
dled explicitly by the developer, except one subclass named
RuntimeException. RuntimeException can be thrown by
the Java Virtual Machine (VM) in Android, i.e., DVM/ART.
For instance, NullPointerException will be thrown when
DVM/ART ﬁnds that a statement invokes a method of a
null object. This kind of exception is more likely to be ig-
nored by developers because it is not required to be caught
explicitly. If an exception cannot be handled properly, it will
ﬁnally be caught and handled by the code in DVM/ART.
DVM/ART will choose to kill the process.

Our study reveals a new kind of vulnerability which is
triggered when the SS invokes a malicious callback method.
When invoked, the callback method chooses a subclass of
Exception, generates one instance of the class and replies
it to the caller. In the context of the SS, the exception is
thrown at the invocation statement of the callback. As de-
scribed in Section 2.1, the assistant threads in the SS are
under the threat of uncaught exceptions.
If an assistant
thread invokes a malicious callback and does not handle ex-
ceptions properly, a vulnerability will occur. There are then
two options for attack measures:
(cid:15) Implement a service component inside the mali-
cious app. The instance of a malicious service component’s
proxy class is leveraged as the callback handle to conduct the
attack. When the callback is invoked, the service component
will reply a well-chosen exception to the caller. This kind of
attack has more alternatives on the replied exceptions.
(cid:15) Leverage a system service or a service component
in a normal app. The instance of a normal service’s proxy
class (Servicex) is forged as the callback handle to conduct
the attack. This normal service could be a system service or
a service component in an app. As described in Section 2.1,
when an instance of Servicex’s proxy class is received by
the SS as an IPC call parameter, the SS will transform it to
another service, which is believed to be the right one, such
as Servicey. However, the interface descriptors of Servicex
and Servicey do not match. When the callback is invoked,
Servicex will not handle the request. It will throw a Secu-
rityException back, which might not be handled properly
by the callback caller.

2.2.3 Hazard Situation B1 & B2
Some system services expose data ﬂow paths for a mali-
cious app to inject malicious callback handles into system
apps. A vulnerability will be triggered when the callback is
invoked in the context of system apps.

One system service is not an islanding function module.
There exists a synergic relationship between system ser-
vices and system apps. An app often consists of four types
of component, namely the activity (user interface), service
(background task), broadcast receiver (mailbox for broad-
cast), and content provider (local database server). Some
system services may interact with app components.The in-

teractions are based on ICC (Inter-Component Communica-
tion).According to our analysis, a system service may rely
on app components to perform the two following functions.
(cid:15) GUI Interaction. Sometimes, a system service needs
to interact with the device user through GUI. For example,
the usb system service which is in charge of USB device
management needs to let the user decide whether an app
should get the permission to use the USB devices.
(cid:15) Functional Module. Some system services will imple-
ment their functions by calling the service interfaces of the
service components in system apps. For example, the imms
system service will interact with the service component in
the Phone app to download/send MMS.

No matter what type of work the system service assigns
to a system app, it needs to inform the client app of the
handling result. Usually, the system service does not work
as the notiﬁer. Instead, it passes a callback handle, which
is received from the client app as an IPC call parameter, to
the system app.

This seemingly neat design results in vulnerabilities. At-
tackers can inject a forged callback handle into a component
of a system app. If a callback is invoked in an activity com-
ponent of the system app (Situation B1 ), a malicious app
can prevent the callback method from returning in order to
freeze the GUI. And if a callback is invoked in a non-activity
component of the system app (Situation B2 ), an exception
can be leveraged to crash the system app process.

3. VULNERABILITY DETECTION TOOL
In order to discover the “call me back” vulnerabilities, we

have designed a vulnerability detection tool named KMHunter
(short for “Callback(K)-Mechanism-Hunter”). The high lev-
el idea is to implement a static taint analysis tool to identify
where vulnerability exists: the IPC call parameters of sys-
tem service interfaces are deﬁned as the taint sources; and
the callback invocation statements using the tainted callback
handles are deﬁned as the taint sinks.

KMHunter ’s design is based on a widely used taint anal-
ysis tool for Android apps named FlowDroid. In order to
apply static taint analysis on the SS, KMHunter is facing
four challenges, which are not addressed by FlowDroid :
C1. Code (call-graph) dependencies of system services are
more complex than apps, which makes the original
class loading scheme inappropriate;

C2. Some system services utilize assistant threads to re-
spond to service requests, which requires KMHunter to
transform the call-graph from multi-threaded to single-
threaded;

C3. ICC/IPC takes place during the handling of some ser-
vice requests, which requires the generated call-graph
to support ICC/IPC;

C4. A callback handle can stay dormant inside the SS con-
text for a long period of time before its invocation is
triggered by some other SS operations.

In order to address the challenges, we have modiﬁed the
implementation of FlowDroid. The framework of KMHunter
is shown as Figure 1 and consists of six components: Inter-
face Analyzer is in charge of summarizing the information
of service interfaces in the SS; Class Loader loads the class
ﬁles as required according to speciﬁc rules; CG and CFG
Generator constructs the call graph and control-ﬂow graph
centering on the target system service interface; Taint An-
alyzer is in charge of conducting the taint analysis based

95Figure 1: Framework of KMHunter

Figure 2: Examples of Class Loading Control

(a) Invocation Tree (b) Invocation Graph

on the call graph and control-ﬂow graph; and Vulnerabili-
ty Alarms can guide the Manual Audit to inspect the vul-
nerability conditions and develop exploit code for Dynamic
Tester.
3.1 Class Loading Control

Code (call-graph) dependencies for system services are
more complex than apps. This challenges the Class Loader
components (C1). KMHunter will load the code of system
services on demand instead of loading all the related code
to address Challenge C1.

Like FlowDroid, the development of KMHunter is based
on Soot. Soot is in charge of the class loading in FlowDroid.
When an app is loaded by Soot, the classes of the target app
will be resolved explicitly and the classes of Android APIs
will be loaded as “phantom”. Therefore, the class loader only
needs to load the classes in the target app.

But when Soot is used to load the code of the SS, the
class loading will be time-consuming because there is no ob-
vious distinction between system service code and other Java
libraries. KMHunter addresses this challenge by setting u-
nimportant classes and methods as “phantom” to stop the
loading of further related code. The key point is determining
whether a method or a class is important.

One simpliﬁed example is shown in Figure 2(a). The call
graph is in the form of a tree structure. The nodes represent
methods and the edges represent method invocations. We
deﬁne the target system service interface as T(arget) and
other related methods as M. The strategy is to limit the
depth of the invocation path to N (which is 3 in this ex-
ample) starting from T. Hence, methods on the third level,
i.e., M111, M211 and M221, will be resolved as phantom and
their dependence will not be further loaded.

But in normal programs, the invocation relationship is an
invocation graph instead of an invocation tree. We add some
call edges in Figure 2(a) and get a call graph as shown in
Figure 2(b). We can observe that, starting from T, the depth
of method is not a constant value. For example, the depth
of M1 can be 1 on path T ! M1 or 3 on path T ! M2 !
M21 ! M1, and the depth of M22 can be [2; +1). Under
this situation, we deﬁne a function depthmin(M ) to calculate
the depth of the shortest invocation path of method M . And
if depthmin(M ) > N , M will be set as phantom.

For a non-phantom method, its related classes will also be
loaded as normal classes. The classes include the container
class of the method, the classes of parameters and local vari-
ables. For a phantom method, its related classes will also
be loaded as phantom.
3.2 Call Graph Generation

The SS is a multi-threaded process (C2). It also interacts
with other processes at runtime (C3). The CG&CFG Gen-

erator needs to address both challenges. The basic idea is
to transform these complex situations into a single-threaded
situation.

Multi-Threaded SS challenge. Commonly, a system
service will start an assistant thread by two means: the
Runnable mechanism in Java and the Handler mechanism
in Android.

FlowDroid provides some basic transformations for multi-
threaded situations. However, its implementation is too sim-
ple and incomplete to be used in real program analysis. We
have made some improvements to complete the implementa-
tion of FlowDroid. The major improvement is that we take
care of the Handler mechanism in a more subtle way. One
basic usage of the Handler mechanism is to invoke the Han-
dler.sendMessage(msg) API. When invoked, the Handler
mechanism will dispatch the message msg to corresponding
handling code according to the value of msg.what. The value
of msg.what can vary, but the implementation code of one
system service interface usually adopts only one concrete val-
ue of msg.what to invoke the API. If necessary, KMHunter
will extract the code fragments, which are directly related to
this concrete value, from the entire handling code for every
system service interface.

ICC/IPC challenge. KMHunter needs to address the
ICC/IPC challenge to analyze the taint propagation between
system services and system apps. Intent is commonly used
to perform ICC with app components. For instance, the SS
can start an activity component in the system app by call-
ing Context.startActivity(intent) API. The SS also can
bind on the service component in a system app and perfor-
m IPC though Binder mechanism. No matter whether the
communication is conducted by Intent or Binder, KMHunter
will replace the IPC/ICC statements with a newly created
statement. This new statement will directly invoke the cor-
responding handling methods in the target component. In
addition, the life-circle of an app component is also consid-
ered during the call graph generation.
3.3 Deﬁning the Taint Sources and Sinks

By neatly deﬁning the sources and sinks, we can address

the challenge of the dormant callback handle (C4).

During the taint propagation in the SS, we deﬁne the set of
tainted objects as TOS (Tainted Object Set). The tainted
state of the target system service can be divided into two
types: temporarily tainted and durably tainted.
The SS is temporarily tainted if every t 2 T OS is a
local variable. The tainted objects will be destroyed when
the handling of one service request ﬁnishes. Therefore, the
taint analysis just needs to consider the implementation code
of one system service interface. We deﬁne the source and
sink of the taint analysis as:

Interface AnalyzerClass LoaderLoadManagerCG&CFGGeneratorMulti-Thread ManagerTaint AnalyzerDynamic TesterTaint WrapperSourceSink ManagerIPC ManagerManualAuditVulnerability AlarmsVulnerability ReportsTM1M2M21M11M22M111M211M221(cid:104)(cid:104)(cid:104)TM1M2M21M11M22M111M211M221(cid:104)(cid:104)(cid:104)96Sourceinject =< SSI; i; p >;

Sinkcrash =< condition; callback statement; t >

In the deﬁnition of Sourceinject, i is the index of the IPC call
parameter p of the service interface SSI. And in the deﬁni-
tion of Sinkcrash, t means the tainted data which will be used
by the callback statement under the given condition.
The SS is durably tainted if there exists at least one
t 2 T OS that is a global variable. The tainted object can
stay dormant inside the SS context for a long period of time
before its invocation is triggered by other SS operations.
KMHunter has to consider the cooperative relation of ser-
vice interfaces and other trigger points such as registered
broadcast receivers. The strategy is to separate the taint
analysis into two steps. The deﬁnitions of source and sink
in the two steps are:
Step 1:

Sourceinject =< SSI; i; p >;

Sinkglobal =< none condition; derived(SSO:x; t); t >

Step 2:

Sourceglobal =< SSO; x >;

Sinkcrash =< condition; callback statement; t >

In the deﬁnition of Sinkglobal in Step 1, a statement is re-
garded as a sink if a global value, namely SSO.x, is derived
from a tainted valuable t. In the deﬁnition of Sourceglobal
in Step 2, a global variable SSO.x is regarded as a source if
it is tainted in Step 1.
3.4 Human Intelligence

Currently, KMHunter still needs human intelligence to
manually craft the test cases. The taint analysis results do
not directly enable automated generation of dynamic test
cases. Another limitation is that our tool does not guaran-
tee completeness (i.e., identifying all the vulnerability condi-
tions). It ignores the code statements which do not operate
on the tainted data; however, these code statements could
relate to the vulnerability conditions, such as checking the
permissions of the client app.

4. VULNERABILITY DETECTING RESULT
4.1 Result Overview

We applied KMHunter on the code of Android 5.1.0. Ac-
cording to the Interface Analyzer component in KMHunter,
the SS contains 80 Java-based system services. These ser-
vices expose 1592 service interfaces. KMHunter has success-
fully analyzed 1591 of them (the only failure is because that
the class loading process failed). Vulnerability alarms sound-
ed for eleven service interfaces. After manual inspection, we
identiﬁed six vulnerabilities in nine service interfaces. The
vulnerabilities are listed in Table 1. All the identiﬁed vul-
nerabilities have been further tested on Android 2.3.7-6.0.12.
The test result indicates that the “call me back” vulnerabil-
ities exist widely.

There are two false positives. The ﬁrst false positive is
an interface which is provided by the window system ser-
vice.
It is protected by a permission which could not be
acquired by third-party apps. The other false positive is

2v2.3.7-v5.0.0 on Genymotion emulator, v5.1.0 on Nexus 6
and v6.0.1 on Nexus 6p.

Service
activity
location

package
usb

Table 1: Newly Discovered Vulnerabilities
Versions
4.2 - 6.0.1
4.2 - 6.0.1
(cid:3)
? - 5.1.0
2.3.7 - 5.1.0
4.1.1 - 6.0.1

Id
Vul#1
Vul#2
Vul#3 mount
Vul#4
Vul#5

Service Interface
startInstrumentation
requestLocationUpdates
registerListener
freeStorage
requestDevice-
(Accessory)Permission
send(Stored)Message,
downloadMessage

Vul#6

imms

5.0.0 - 6.0.1

*: Tests of mount service need real devices. Hence, it is only
tested on v5.1.0 and v6.0.1.

a service interface which is provided by the display system
service. This interface checks the validation of the received
callback handle. Only the instance of a speciﬁc system ser-
vice’s proxy class will be accepted. This system service is
media projection. There may be false negatives. But they
cannot be analyzed since there is no ground truth; we are
the ﬁrst to reveal the “call me back” vulnerabilities. False
negatives may exist because of our class loading strategy.
Some methods will not be loaded because their shortest in-
vocation paths are deeper than a threshold. Although the
analyzed call graph is not complete, our analysis managed to
cover most of them. For example, the analyzed call graph
of the setLastChosenActivity() interface in PMS contains
10,595 edges.
4.2 Vulnerability Details

4.2.1 Vulnerability in Activity Manager Service
AMS (Activity Manager Service) is in charge of interac-
tions with overall activities running in Android. The vul-
nerable service interface is startInstrumentation(). Apps
can call it to start an instrumentation component of a giv-
en app. This interface receives a callback handle, named
watcher, as an IPC call parameter.
If a failure situation
happens while starting target instrumentation, this callback
will be invoked to inform the client app. The class of watch-
er is android.app.IInstrumentationWatcher. It contain-
s two synchronous callback methods, named instrumenta-
tionStatus() and instrumentationFinished().

The vulnerable code is shown in Fragment 1 of Appendix
A. We can observe that the code statements of startIn-
strumentation() enter the synchronized(AMS.this) block.
In the synchronized block, if a failure situation (such as
wrong instrument info) occurs, the method named report-
StartInstrumentationFailure() will be called (line 16466).
This method receives the watcher object as an actual pa-
rameter. Code in this method invokes the callback method
watcher.instrumentationStatus() (line 16525). This is a
typical vulnerability in hazard situation A1.

This vulnerability exists in Android 4.2-6.0.1. The vul-
nerable service interface does not check any permission of
the client app. Hence, malicious apps can exploit this vul-
nerability without restrictions.

4.2.2 Vulnerability in Location Manager Service
LMS (Location Manager Service) manages location provider-

s and issues location updates and alerts. Apps can in-
voke a service interface of LMS named requestLocationUp-
dates() to register a callback for location updates. This in-
terface receives a parameter of android.app.PendingIntent

97class named intent. The intent object is not a callback
handle. But it carries a member variable named mTarget,
which is a callback handle. The class of mTarget is an-
droid.content.IIntentSender. In this class, only the call-
back method named send() is deﬁned as synchronous.
If
LMS invokes intent.send(), it is actually invoking the in-
tent.mTarget.send() method.

The vulnerable code is in Fragment 2 of Appendix A.
The callback is invoked (line 854) in a synchronized block
(line 1574). When this vulnerability is exploited, the system
would get into hazard situation A1.

This vulnerability exists in Android 4.2-6.0.1. The vulner-
able service interface requires the client app to hold the ac-
cess_coarse(fine)_location permissions. These permis-
sions are all acquirable for a malicious app.

4.2.3 Vulnerability in Mount Service
MS (Mount Service) is responsible for various storage me-
dia. It connects to vold to watch for and manage dynami-
cally added storage, such as SDcards and USB mass storage.
The service interface in MS, named registerListener(),
can be called to register a listener (i.e., callback) on the state
changes of storage or USB mass storage. The class of this lis-
tener is android.os.storage.IMountServiceListener.
It
deﬁnes two synchronous callback methods. As shown in
Fragment 3 of Appendix A, the tainted callback handle prop-
agates into the global variable named mListeners (line 1557).
MS also registers a broadcast receiver to listen on the inten-
t, which is broadcasted when the state of USB storage is
changed (line 1498). When MS receives the intent, it will
make callbacks based on every element in mListeners (line
1247, 1249). During this period, it is necessary to ensure the
mutual exclusiveness of mListeners. Therefore, the related
code is in a synchronized block. When this vulnerability is
exploited, the system would get into hazard situation A1.

This vulnerability exists in Android 5.1.0 and no longer
exists in Android 6.0.1, because Android has changed the
type of the callback from synchronous to asynchronous. The
vulnerable service interface has no permission requirement
on the client app.

4.2.4 Vulnerability in Package Manager Service
PMS (Package Manager Service) keeps track of all those
.apks everywhere. The vulnerable service interface in PMS
is freeStorage().
It is in charge of clearing the cache of
given volume Universally Unique Identiﬁer (UUID). The re-
lated code is shown in Fragment 4 of Appendix A. Cache
clearing is a time-consuming work. PMS carries out this
work in an assistant thread leveraging the Handler mecha-
nism (line 2196). Code from the assistant thread is imple-
mented inside the freeStorage() method. Hence, it can
operate the IPC call parameter named pi. The class of pi is
android.content.IntentSender. Similar to PendingInent,
this class also contains a member variable, which is a call-
back handle. The member variable is named as mTarget.
The class of mTarget is also IIntentSender. This class on-
ly deﬁnes one synchronous callback method named send().
After the cleaning work ﬁnishes, the assistant thread will
invoke the pi.sendIntent() method (line 2207). Actually,
it is invoking the callback method of pi.mTarget.send().

In line 2206, PMS tries to check on the validity of pi. How-
ever, it could not validate the identity of the service repre-
sented by pi.mTarget. What’s more, PMS can only handle

one type of exception, namely SendIntentException in line
2212. Hence, we could not expect it to survive any other
types of exception that may be replied from the callback
method. When this vulnerability is exploited, the system
would get into hazard situation A2.

The vulnerable service interface is protected with permis-
sion clear_app_cache. This permission is acquirable for
third party apps before Android 5.1.0, but not in Android
6.0.1. Therefore, although the vulnerability still exists in
Android 6.0.1, it is only exploitable in v2.3.7-v5.1.0.

4.2.5 Vulnerability in SystemUI App
US (USB Service) manages all USB-related state, includ-
ing both host and device support. The requestAccesso-
ryPermission() interface in US can be invoked by a client
app to request the permission of USB accessories. When it is
invoked, US will start an activity in the SystemUI app to let
the device user decide whether or not the permission should
be granted. This interface receives a callback handle as an
IPC call parameter. The parameter is named as pi, whose
class is android.os.PendingIntent. It will be passed to the
activity component in SystemUI. SystemUI uses it to inform
the client app of the decision of the device user. As described
in Section 4.2.2, when pi.send() is invoked by the activity
component in SystemUI, a synchronous callback method is
actually invoked.

The related code is shown in Fragments 5.1, 5.2 and 5.3
of Appendix A. We can see that US starts the activity com-
ponent in SystemUI and passes the callback handle to it by
the intent object (line 1045 in 5.2). The target activity
component acquires the callback handle in the onCreate()
method (line 68 in 5.3) and invokes it when the activity is to
be destroyed (line 146 in 5.3). Malicious services can block
the code of the activity component by preventing the call-
back method from returning until it is too late. When this
vulnerability is exploited, the system would get into hazard
situation B1.

This vulnerability exists in Android 4.1.1-6.0.1. The vul-
nerable service interface is not protected with any permis-
sion. Another interface of US named requestDevicePer-
mission() also has this vulnerability.

4.2.6 Vulnerability in Phone App
The imms system service bridges the public SMS/MMS
APIs with the service interfaces of the MmsService compo-
nent in the Phone app. This kind of design can protect the
integrity of the SS. However, it leaves the Phone app at risk
of attack.

The vulnerable service interfaces in imms are download-
Message(), sendMessage() and sendStoredMessage(). They
all receive an IPC call parameter whose class is Pending-
Intent. As described in Section 4.2.2, the object of the
PendingIntent class contains a callback handle as its mem-
ber variable.

We take the downloadMessage() interface as an example.
The related code is shown in Fragments 6.1, 6.2 and 6.3
of Appendix A. Line 253 in Fragment 6.1 shows that imms
calls the corresponding service interface of the MmsService
component. The received callback handle is also passed to
MmsService. This callback handle is used to inform the
client app about the result of sending/downloading MMS
(line 230 in Fragment 6.3). The invocation of this callback
is located in an assistant thread of MmsService (line 427 in

98Figure 3: One Attack on ActivityManagerService

Fragment 6.2). The invocation statement is not protected
by any try-catch block to handle exceptions. When this
vulnerability is exploited, the system would get into hazard
situation B2.

This vulnerability exists in Android 5.0.0-6.0.1. The ex-
ploit code needs the permission of receive(send)_mms, which
is acquirable for a malicious app.

5. PROOF-OF-CONCEPT ATTACKS
5.1 Basic Attacks and Hazards

We present the basic exploitation of the new vulnerabili-
ties here. The attacks are implemented by directly invoking
the vulnerable service interfaces of the SS instead of some
APIs [17]. Therefore, they are more direct and ﬂexible.

5.1.1 System Service Freeze
In order to freeze a system service, the malicious app needs
to implement a callback method which prevents the return-
ing of callback for a long period of time.

Taking V ul#1 as example, the logical relationship of the
attack is shown in Figure 3. The instance of MyMaliciousSer-
vice’s proxy class is forged as an IPC call parameter. It is
passed to the service interface startInstrumentation() of
AMS. Then AMS starts thread X to handle the request.
When thread X invokes the callback method, the onTrans-
act() method in the MyMaliciousService component will
be in charge of the handling. The attack code in MyMali-
ciousService is very simple in that it sleeps for ten minutes.
Therefore, thread X becomes blocked. Thread Y is another
thread which is started by another service request. It also
wants to acquire the AMS.this lock, but it has to wait until
thread X releases it. After a period of time, the watchdog
thread in AMS will kill the process which provides AMS,
namely the SS. The crash of the SS will result in the soft-
reboot of the system.

V ul#2 is similar to V ul#1, except that it requires speciﬁc
permission. V ul#3 is a little diﬀerent, because it is not
triggered immediately after the callback handle is injected.
Hence, the attacks on V ul#3 are more latent than others.

5.1.2 System Soft-Reboot
To soft-reboot the system in a timely manner, a malicious
app must ﬁnd a way to make the SS throw an exception.
The attacks are varied because there are two possible attack
measures.

(a) Leverage a Malicious Service Component to Attack

(b) Induce PackageManagerService to Attack Itself

Figure 4: Two Attacks on PackageManagerService

as an example. In Figure 4(a), a malicious service is used
to conduct the attack. When the callback method is in-
voked, the malicious service selects one exception, namely
NullPointerException, and throws it back. In Figure 4(b),
PMS is attacked by the exception thrown by itself. First-
ly, the instance of PMS’s proxy class is forged as a callback
handle. It is injected to the freeStorage() interface of PM-
S as an IPC call parameter. PMS invokes this callback in
one of its assistant threads. It believes the callee is a service
whose interfaces are deﬁned by the IIntentSender class.
However, the real callee is itself, whose interfaces are de-
ﬁned by the android.content.pm.IPackageManager class.
As the callee, PMS starts a new thread. Code in this new
thread ﬁnds that the interface descriptors do not match.
Then a java.lang.SecurityException is thrown from the
new thread back to the assistant thread in PMS. It is able to
cause the crash of the process which provides PMS, namely
the SS.

System Application Freeze and Crash

5.1.3
Even if the victim of an attack is a system app, the at-
tack hazard also will seriously threaten some critical system
functionalities.

When V ul#5 is exploited, SystemUI will raise an activity
component on the screen. No matter how the device user
interacts with the activity, the callback method in the mali-
cious app will be invoked. The attacker can block the code
in this activity to make SystemUI unresponsive. V ul#6 ex-
ists in the Phone app. The Phone app is in charge of the
cellular networks. Attacks on this app can cause it to crash
and disable all the functionalities of the cellular networks.

We take the logical relationship of the attacks on V ul#4

The logical relationships of the attacks on V ul#5 and

inject(callback, targetService, ssi);attacker.MyMaliciousService.onTransact()(cid:658)  InjectMA Thread Battacker.Component.doAttack()MA Thread AAMS.finishActivity(...)SS Thread YAMS.startInstrumentation(...) synchronized(this){injectedCallback.rpc();}SS Thread XThread.sleep(10*60*1000);Watchdog.Run()SS Thread Zsynchronized(this){/* Codes */;}(cid:659) CallbackHoldMonitorAMS.this(cid:661)(cid:660)inject(callback,targetService,ssi);attacker.MyMalicousService.onTransact()writeExceptionIntoReply(new NullPointerException())MA Thread Battacker.Component.doAttack()MA Thread APMS.freeStorage(...)mHandler.post(new Runnable() {(cid:540)});SSI Primary ThreadPMS.(new Runnable()).run()SSI Secondary ThreadinjectedCallback.rpc();SSI Assistant Thread(cid:658)Inject(cid:659) Start Thread(cid:660):Invoke Callback.(cid:661):Reply Exceptioninject(callback, targetService, ssi);PMS.onTransact()//Throw exception if interfaces descriptor do not match.data.enforceInterface(DESCRIPTOR);attacker.Component.doAttack()MA Thread APMS.freeStorage(...)mHandler.post(new Runnable() {(cid:258)});SSI Primary ThreadPMS.(new Runnable()).run()New ThreadinjectedCallback.rpc();SSI Assistant Thread(cid:659)(cid:658)  Inject(cid:660)(cid:661) Reply Exception(cid:659): Start Thread.  (cid:660): Invoke Callback.99V ul#6 are similar to Figure 3 and 4. The only diﬀerence
is that the callback handle is passed from a system service
to a vulnerable app. Therefore, we do not provide detailed
ﬁgures here. Although the victim apps can be restarted
quickly, the malicious app can continuously trigger the vul-
nerabilities to conduct repetitive attacks.
5.2 Representative Attack Scenarios

Indiscriminate attacks are meaningless.

If an attacker
wants to maximize the attack eﬀect, it should choose the
best time to exploit the vulnerabilities. Previous work [14]
has shown that it is possible to peek into the apps through
a UI state inference attack. Therefore, attackers can trig-
ger the vulnerabilities when the system is conducting critical
tasks. For example:
V ul#2 can block the location updates of map apps, which

will disable the navigation functions;

V ul#3 can make the SDcard unusable, which may contain

installed apps and app data;

V ul#5 can repetitively block the SystemUI to prevent the

user from pressing speciﬁc buttons;
V ul#6 can disable the cellular networks.

V ul#1 and V ul#4 are the two most signiﬁcant among the
new vulnerabilities. We have leveraged some side channels
to monitor the system and designed four attack scenarios
exploiting these two vulnerabilities. A video of the attacks
has been uploaded onto https://youtu.be/w9BMZdvZZec.

5.2.1 Anti Process Killer
Scenario. In order to conduct a timely attack, the pro-
cess of a malicious app needs to stay alive in the background.
However, a background process is unwelcome and may be
killed irregularly.

Design. Android supports an app to run its services in
diﬀerent processes.
If an app is forced to stop, all of its
processes will be killed successively. In our design, the mali-
cious app registers N services in N diﬀerent processes. Each
service listens to the death of the other N-1 services by im-
plementing the ServiceConnection.onServiceDisconnected()
method. Code in this method will exploit the V ul#4, which
can immediately cause the soft-reboot of the system. The
malicious app can register a broadcast receiver component
to listen to the boot_completed intent. Then it can start
its services again to stay alive.

Result. We installed the PoC app on Android 5.1.0,
Nexus 6. This app registers 10 services in 10 processes. We
tried killing the processes of the app using the third par-
ty app 360 Mobile Safe and the system app Settings. The
test result proves that the PoC app can function as an anti
process killer.

5.2.2 Anti Anti-Virus
Scenario. When a device user encounters too many in-
stances of system crash and functional failure, he/she may
suspect that the device is infected by malicious apps. Most
user will choose an anti-virus app to make a security inspec-
tion. The malicious apps need to hinder this to ensure their
survival.

Design. A malicious app can utilize many characteristics
to detect whether an anti-virus app is scanning the apps. For
example, the scanning signiﬁcantly increases the memory
usages of the anti-virus app. Some anti-virus apps start
new processes to do the scanning. The malicious app only

needs a list of the process names of the anti-virus apps. It
can carry out a real-time monitor on the listed processes to
detect the virus scanning.

Result. We installed the PoC app on Android 5.1.0,
Nexus 6. 360 Mobile Safe was selected as the attack tar-
get. According to our study, it starts two processes, namely
scan and engine when scanning the installed apps. The PoC
app checks whether these processes are alive every one sec-
ond. The vulnerability V ul#1 was selected to conduct the
attack. Exploiting V ul#1 can make the device unresponsive
to any GUI operation. It gives the impression that the virus
scanning consumes too many computing resources. The s-
canning also will be blocked until the system soft-reboots.

5.2.3 Hindering Critical Application Patching
Scenario. Due to the evolving nature of mobile systems,
apps have to update for vulnerability patching. Malicious
apps need to hinder the patching of critical apps, which will
render the vulnerable apps unpatched.

Design. The app updating is conducted by PMS. It can
be divided into three sequential subtasks: removing the o-
riginal app, adding a new app and conﬁguring the new app.
When each subtask ﬁnishes, a broadcast will be send with
corresponding action tags. The malicious app can check
the existence of the target apps by calling PackageManag-
er.getApplicationInfo() frequently. This helps to moni-
tor the removal of the old version. Once the target app no
longer exists, the malicious app can hinder the installation
of the new version or soft-reboot the system immediately.
When the system ﬁnishes the soft-reboot, PMS will roll back
the unﬁnished update task to ensure its atomicity.

Result. The PoC app was deployed on Android 5.1.0 of
Nexus 6 to prevent the update of 360 Mobile Safe. It checks
the existence of the target app every 5 milliseconds. The
V ul#1 was leveraged to conduct the attack. It led to the
freeze of AMS. Hence, PMS could not utilize AMS to send
the broadcast after the old version app was removed. After
about 62 seconds of blocking, the whole system crashed. The
update rolled back after reboot.

5.2.4 Hindering System Updating
Scenario. Android is evolving rapidly. The newly found
vulnerabilities are patched quickly in the new versions. If an
attacker can ﬁnd a way to hinder the update of the system,
it will ensure the system remains vulnerable forever.

Design and Implementation. For ordinary users, the
most frequently used measure to update the system is through
an OTA (Over-The-Air) update. The OTA update needs to
download the update ﬁles from the network server and store
them in local devices. To monitor the OTA update, the ma-
licious app can scan the ﬁle system to detect the downloaded
update ﬁles. It also could monitor the process in charge of
the OTA update by checking the amount of received bytes
from the internet. When the malicious app ﬁnds the system
is updating, it will have many options. It can exploit V ul#1
or V ul#4 to freeze and soft-reboot the system. It also can
exploit V ul#6 to crash the Phone app in order to hinder
the download through the mobile network.

Result. We deployed the PoC app on Nexus 6, which
needed to update from 5.1.0 to 5.1.1. The size of the up-
date package was about 110MB. The Google Mobile Service
(GMS) app was in charge of the OTA update. The PoC
app monitored the number of bytes received by the GMS

100app by invoking the TrafficStats.getUidRxBytes() API.
When the number surpassed 10 MB, V ul#4 was triggered.
It soft-rebooted the system immediately. The test result
shows that the PoC app can successfully prevent the OTA
update.

6. DEFENSE APPROACHES

Attacks on the new vulnerabilities are diﬃcult to prevent

due to the reasons:

1). in the aspect of the Binder driver, a malicious service

request is indistinguishable from benign requests;

2). in the aspect of the SS, a received callback handle is

unveriﬁable to prevent attack;

3). in the aspect of dynamic monitoring, when the call-
back is invoked, the malicious service component could
choose to attack under certain timing to avoid expos-
ing its aggressive behavior;

4). in the aspect of static audit, the attack code can be

developed with both Java and C/C++ languages.

Therefore, the best way to defend against the attacks is
to identify and patch the vulnerabilities as quickly as possi-
ble. To patch these vulnerabilities, we propose the following
suggestions for the developers of system services.

For some callbacks, the callers have no need to wait for
the reply. These callbacks must be declared as asynchronous.
AMS receives a callback handle whose interfaces are deﬁned
in the IInstrumentationWatcher class. MS receives a call-
back handle whose interfaces are deﬁned in the IMountSer-
viceListener class. These two system services are vulner-
able to the “call me back” vulnerability. After an in-depth
study on them, we ﬁnd that all the return types of their
interfaces are void. There is no need to wait for the re-
turn of these callback methods at all. Therefore, there is a
very convenient way to patch these vulnerabilities, which is
to change the type of these callbacks from synchronous to
asynchronous.

For some callbacks, the callers have to wait for the reply.
Their invocation statements must not be in a synchronized
block. And a caller should invoke a callback in a try-catch
block which can handle all possible exceptions. Four of the
new vulnerabilities are caused by receiving a parameter that
contains a callback handler as a member variable. Actual-
ly the class of the callback handles is the same, which is
the IIntentSender class. This class only declares one call-
back method named send(). This callback method returns
a value which indicates whether or not an intent is sent suc-
cessfully. Hence, it has to be a synchronous callback. Under
this circumstance, the developers should not invoke the call-
back in a synchronized block. He/she should try to catch
and handle all the possible exceptions using try-catch blocks.
From another perspective, although the developers can
anticipate the worst-case situations before implementing a
new service interface which accepts a callback handle as a
parameter, a more fundamental security design question is
whether a system service developer should ever use a syn-
chronous callback to “communicate” with untrusted apps.
There are some other ways to “communicate” with an un-
trusted app, such as socket, pipe and shared memory. No
matter which way is chosen, the key point is whether the
communication should be synchronous. We insist that one
design principle of system services is that it should never
communication with untrusted apps in a synchronous way.

7. RELATED WORK

Vulnerabilities in system services have been explored by
several previous studies. A general design trait in the con-
currency control mechanism of the system services has been
discovered by [17]. This new kind of vulnerability is named
as ASV, which makes the Android system vulnerable to
Denial-of-Service attacks. The hazard situation of ASV is
similar to the situation A1 in this paper (see Section 2.2).
The limitation of [17] is that: 1) they believe that the at-
tack surfaces are the APIs which wrap the invocation code of
vulnerable service interfaces instead of the interfaces them-
selves; 2) the exploitation code needs to repeatedly invoke
the attack surfaces or register unusually large numbers of
resources, which is easy to detect and prevent; 3) only AMS
and PMS are found to be vulnerable and the attacks only
can freeze parts of their functionalities immediately. Our
work have found four hazard situations, which makes the
attacks more various. Our attacks only need to invoke the
vulnerable service interfaces once. They can freeze critical
target functionalities or soft-reboot the system immediately.
Therefore, our attacks are more ﬂexible to be leveraged in
diﬀerent attack scenarios (see in Section 5.2).

Some other works designed fuzzing tools targeted on the
system services in Android [13, 16, 19]. They leveraged the
idea that Binder provides a very convenient way to inject
test cases into system services. Fuzzing tests are easy to im-
plement and eﬀective on vulnerability detection. However,
there are two main challenges to designing a perfect fuzzing
tool for the system services in Android. Firstly, the strate-
gy of test data generation can seriously aﬀect the eﬀect and
eﬃciency of a fuzzing test. The designer cannot guarantee
that the test cases cover all the execution paths of the target
system service. Secondly, it is hard to deﬁne the abnormal
behavior for every system service interface. Therefore, the
false negative rate is highly dependent on the deﬁnitions of
abnormal behaviors.
If a designer wants to cover all the
possible failure situations, he/she has to manually inspect
the source code of every system service. This is heavy and
clumsy work. Our static taint analysis tool can easily cover
all the execution paths. Since we have clearly characterized
the feature of the “call me back” vulnerabilities, we do not
have to blindly generate test cases and struggle to monitor
all the possible failure situations of the system services.

Taint analysis has been widely applied to diﬀerent plat-
forms for diﬀerent purposes [11, 12, 21, 25, 26, 27]. For
Android, the main usage of taint analysis is to detect priva-
cy leakages of the apps. They can be divided into dynamic
taint analysis [15, 23] and static taint analysis [10, 18, 20, 29,
30]. TaintDroid is a dynamic taint analysis tool for real-time
privacy monitoring on Android apps [15]. It uses variable-
level tracking within the VM interpreter while the target
app is running.
It is very eﬀective on real-time monitor-
ing but cannot guarantee that all the execution paths have
been covered. Other researchers focus on the design of stat-
ic taint analysis tools. FlowDroid is an excellent framework
for static taint analysis. It can provide precise context, ﬂow,
ﬁeld, and object-sensitive and lifecycle-aware taint analysis
for Android apps [10]. However, it is not entirely applicable
for vulnerability detection on the SS, as we have described
in Section 3. Our work is the ﬁrst to introduce static taint
analysis on the code audit and vulnerability detection tar-
geted on the SS in Android.

1018. CONCLUSIONS

Based on a new understanding of the security risks in-
troduced by the callback mechanism in system services, we
have discovered a general type of design ﬂaw. It reveals a
new kind of vulnerability in system services and system app-
s. We have designed and implemented a vulnerability detec-
tion tool based on static taint analysis.Our tool has success-
fully analyzed all the 80 system services in Android 5.1.0.
With its help, we discovered six previously unknown vul-
nerabilities, which are further conﬁrmed on Android 2.3.7-
6.0.1. These vulnerabilities aﬀect about 97.3% of the entire
1.4 billion real-world Android devices. We crafted several
PoC apps and illustrated the serious attack hazards from the
freeze of critical functionalities to the soft-reboot of the sys-
tem. We also designed several attack scenarios and proved
that the vulnerabilities can enable malicious apps to attack
the system at mission critical moments, such as system up-
dating and virus scanning. The newly found vulnerabilities
have been reported to Google and Google conﬁrmed them
promptly. Some suggestions are also proposed for the devel-
opers of system services and apps to patch and prevent this
new kind of vulnerability.

9. ACKNOWLEDGMENTS

Kai Wang and Yuqing Zhang were supported by the Na-

tional Natural Science Foundation of China (61272481, 61572460),
the National Key Research and Development Project (2016YF-
B0800703), the National Information Security Special Projects
of National Development and the Reform Commission of
China [(2012)1424]. Peng Liu was supported by ARO W911NF-
13-1-0421 (MURI), NSF CNS-1422594, and NSF CNS-1505664.

10. REFERENCES
[1] 27 million doctors’ mobile devices at high risk of malware |

ITProPortal.com. http://goo.gl/BJs5Mu.

[2] Android and RTOS together: The dynamic duo for today‘s

medical devices - embedded computing design.
http://goo.gl/StURzu.

medical devices | hughes systique. http://goo.gl/aO0NFk.

[3] Android auto. https://www.android.com/auto/.
[4] Android OS for smart medical equipment, developing embedded
[5] Android point of sale | android POS restaurants, cafes, bars |
[6] The best android POS of 2016 | top ten reviews.

tablet POS. http://www.posandro.com/.

goo.gl/9xykVH.

[7] Gartner says worldwide smartphone sales grew 9.7 percent in

fourth quarter of 2015. http://goo.gl/M0ZwSk.

[8] Google says there are now 1.4 billion active android devices

worldwide. http://goo.gl/utHxO8.

[9] Lollipop is now the most-used version of android, marshmallow

up to 2.3 percent. http://goo.gl/Q598DH.

[10] S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel, J. Klein,
Y. Le Traon, D. Octeau, and P. McDaniel. FlowDroid: Precise
context, ﬂow, ﬁeld, object-sensitive and lifecycle-aware taint
analysis for android apps. In Proceedings of the 35th ACM
SIGPLAN Conference on Programming Language Design and
Implementation, PLDI ’14, pages 259–269. ACM.

[11] J. Bell and G. Kaiser. Dynamic taint tracking for java with
phosphor (demo). In Proceedings of the 2015 International
Symposium on Software Testing and Analysis, ISSTA 2015,
pages 409–413. ACM.

[12] E. Bodden. Inter-procedural data-ﬂow analysis with IFDS/IDE
and soot. In Proceedings of the ACM SIGPLAN International
Workshop on State of the Art in Java Program Analysis,
SOAP ’12, pages 3–8. ACM.

[13] C. Cao, N. Gao, P. Liu, and J. Xiang. Towards analyzing the

input validation vulnerabilities associated with android system
services. In Proceedings of the 31st Annual Computer Security
Applications Conference, ACSAC 2015, pages 361–370. ACM.

[14] Q. A. Chen, Z. Qian, and Z. M. Mao. Peeking into your app

without actually seeing it: Ui state inference and novel android
attacks. In 23rd USENIX Security Symposium (USENIX
Security 14), pages 1037–1052, San Diego, CA, Aug. 2014.
USENIX Association.

[15] W. Enck, P. Gilbert, B.-G. Chun, L. P. Cox, J. Jung,

P. McDaniel, and A. N. Sheth. TaintDroid: An information-ﬂow
tracking system for realtime privacy monitoring on
smartphones. In Proceedings of the 9th USENIX Conference
on Operating Systems Design and Implementation, OSDI’10,
pages 393–407. USENIX Association.

[16] G. Gong. Fuzzing android system services by binder call to

escalate privilege.
https://www.blackhat.com/us-15/brieﬁngs.html.

[17] H. Huang, S. Zhu, K. Chen, and P. Liu. From system services
freezing to system server shutdown in android: All you need is
a loop in an app. In Proceedings of the 22Nd ACM SIGSAC
Conference on Computer and Communications Security, CCS
’15, pages 1236–1247. ACM.

[18] W. Huang, Y. Dong, A. Milanova, and J. Dolby. Scalable and
precise taint analysis for android. In Proceedings of the 2015
International Symposium on Software Testing and Analysis,
ISSTA 2015, pages 106–117. ACM.

[19] W. Kai, Z. Yuqing, L. Qixu, and F. Dan. A fuzzing test for

dynamic vulnerability detection on android binder mechanism.
In 2015 IEEE Conference on Communications and Network
Security (CNS), pages 709–710.

[20] W. Klieber, L. Flynn, A. Bhosale, L. Jia, and L. Bauer. Android
taint ﬂow analysis for app sets. In Proceedings of the 3rd ACM
SIGPLAN International Workshop on the State of the Art in
Java Program Analysis, SOAP ’14, pages 1–6. ACM.

[21] V. B. Livshits and M. S. Lam. Finding security vulnerabilities
in java applications with static analysis. In Proceedings of the
14th USENIX Security Symposium.

[22] D. Lundberg, B. Farinholt, E. Sullivan, R. Mast, S. Checkoway,
S. Savage, A. C. Snoeren, and K. Levchenko. On the security of
mobile cockpit information systems. In Proceedings of the 2014
ACM SIGSAC Conference on Computer and
Communications Security, CCS ’14, pages 633–645. ACM.
[23] J. Paupore, E. Fernandes, A. Prakash, S. Roy, and X. Ou.

Practical always-on taint tracking on mobile devices. In
Proceedings of the 15th USENIX Conference on Hot Topics
in Operating Systems, HOTOS’15, pages 29–29.
share worldwide 2009-2015 | statistic. http://goo.gl/9mI3Qw.

[24] S. V. President and BCG. Android OS smartphone market

[25] A. Rountev, M. Sharp, and G. Xu. IDE dataﬂow analysis in the
presence of large object-oriented libraries. In Proceedings of the
Joint European Conferences on Theory and Practice of
Software 17th International Conference on Compiler
Construction, CC’08/ETAPS’08, pages 53–68. Springer-Verlag.
[26] M. Sridharan, S. Artzi, M. Pistoia, S. Guarnieri, O. Tripp, and

R. Berg. F4f: Taint analysis of framework-based web
applications. In Proceedings of the 2011 ACM International
Conference on Object Oriented Programming Systems
Languages and Applications, OOPSLA ’11, pages 1053–1068.

[27] Z. Wei and D. Lie. LazyTainter: Memory-eﬃcient taint

tracking in managed runtimes. In Proceedings of the 4th ACM
Workshop on Security and Privacy in Smartphones & Mobile
Devices, SPSM ’14, pages 27–38. ACM.

[28] R. Wilkers. Northrop to demo DARPA navigation system on

android; charles volk comments. http://goo.gl/dLmhXN.

[29] Z. Yang and M. Yang. LeakMiner: Detect information leakage

on android with static taint analysis. In Proceedings of the
2012 Third World Congress on Software Engineering, WCSE
’12, pages 101–104. IEEE Computer Society.

[30] Z. Zhao and F. C. Colon Osono. ”TrustDroidT M ”: Preventing

the use of SmartPhones for information leaking in corporate
networks through the used of static analysis taint tracking. In
Proceedings of the 2012 7th International Conference on
Malicious and Unwanted Software (MALWARE), MALWARE
’12, pages 135–143. IEEE Computer Society.

APPENDIX
A. VULNERABLE CODE

The source code is excerpted from the AOSP v5.1.0 r3.
Some unrelated code is omitted.Some unrelated parameters
are also replaced with dots.

1021 0 4 5 .
1 0 5 1 . g

m U s e r C o n t e x t . s t a r t A c t i v i t y A s U s e r ( i n t e n t ,

. . . ) ;

Fragment 5.3. Code in UsbPermissionActivity

c l a s s U s b P e r m i s s i o n A c t i v i t y f

p r i v a t e P e n d i n g I n t e n t m P e n d i n g I n t e n t ;
p u b l i c v o i d o n C r e a t e ( . . . ) f

m P e n d i n g I n t e n t = ( P e n d i n g I n t e n t )

i n t e n t .

g e t P a r c e l a b l e E x t r a ( I n t e n t . EXTRA INTENT ) ;

p u b l i c

4 6 .
5 5 .
6 2 .
6 8 .
1 1 5 . g
1 1 8 . p u b l i c v o i d o n D e s t r o y ( )f
1 4 6 .
1 7 5 . gg

m P e n d i n g I n t e n t . s e n d ( t h i s , 0 ,

i n t e n t ) ;

Fragment 6.1. Code in MmsServiceBroker

2 3 9 . p u b l i c v o i d do w n l o a d M e s s a g e ( . . . ,

P e n d i n g I n t e n t d o w n l o a d e d I n t e n t )f
g e t S e r v i c e G u a r d e d ( ) . // r e t u r n MmsService p r o x y

do w n l o a d M e s s a g e ( . . . , d o w n l o a d e d I n t e n t ) ;

2 5 3 .
2 5 5 . g

Fragment 6.2. Code in MmsService
p u b l i c v o i d h a n d l e M e s s a g e ( Message msg ) f

c l a s s RequestQueue e x t e n d s H a n d l e r f

1 1 5 . p r i v a t e
1 2 1 .
1 2 5 .
1 2 8 . gg
2 0 4 . p u b l i c v o i d do w n l o a d M e s s a g e ( . . . ,

r e q u e s t . e x e c u t e ( . . . ) ; // r e q u e s t = msg . o b j

P e n d i n g I n t e n t d o w n l o a d e d I n t e n t )
// r e q u e s t . m D o w n l o a d e d I n t e n t = d o w n l o a d e d I n t e n t
a d d S i m R e q u e s t ( r e q u e s t ) ;

2 1 9 .
2 2 1 . g
3 6 7 . RequestQueue [ ] mRunningRequestQueues ;
4 1 7 . p r i v a t e v o i d a d d T o R u n n i n g R e q u e s t Q u e u e S y n c h r o n i z e d (

4 2 5 .
4 2 6 .
4 2 7 .

MmsRequest
f i n a l Message me s s ag e = Message . o b t a i n ( ) ;
me s s a g e . o b j=r e q u e s t ;
mRunningRequestQueues [ queue ] . s e n d M e s s a g e ( m e s s a g e ) ;g

r e q u e s t )f

Fragment 6.3. Code in MmsRequest
p r o c e s s R e s u l t ( . . . ) ; g

1 3 1 . p u b l i c v o i d e x e c u t e ( . . . ) f
1 9 7 .
2 0 8 . p u b l i c v o i d p r o c e s s R e s u l t ( . . . ) f
2 3 0 .
2 3 7 . g

p e n d i n g I n t e n t . s e n d ( . . . ) ;

Fragment 1. Code in ActivityManagerService

1 6 4 4 2 . p u b l i c b o o l e a n s t a r t I n s t r u m e n t a t i o n ( . . . ,
. . . ) f

I I n s t r u m e n t a t i o n W a t c h e r w a t c h e r ,
s y n c h r o n i z e d ( t h i s ) f

1 6 4 5 4 .
1 6 4 6 6 .
1 6 5 0 6 . gg
1 6 5 1 7 . p r i v a t e v o i d r e p o r t S t a r t I n s t r u m e n t a t i o n F a i l u r e (

r e p o r t S t a r t I n s t r u m e n t a t i o n F a i l u r e (

w a t c h e r , . . . ) ;

I I n s t r u m e n t a t i o n W a t c h e r w a t c h e r ,
w a t c h e r . i n s t r u m e n t a t i o n S t a t u s ( . . . ) ;

. . . ) f

1 6 5 2 5 .
1 6 5 3 0 . g

Fragment 2. Code in LocationManagerService

c l a s s R e c e i v e r f // I n n e r C l a s s

p r i v a t e

5 8 4 .
5 9 1 .
8 2 5 .
8 5 4 .
1 5 4 8 . p u b l i c v o i d r e q u e s t L o c a t i o n U p d a t e s ( . . . ,

m P e n d i n g I n t e n t . s e n d ( . . . ) ) ; g g

f i n a l P e n d i n g I n t e n t m P e n d i n g I n t e n t ;
p u b l i c b o o l e a n c a l l P r o v i d e r E n a b l e d L o c k e d ( . . . ) f

f i n a l

P e n d i n g I n t e n t
s y n c h r o n i z e d ( mLock ) f

i n t e n t , . . . ) f

// r e c e v i e r . m P e n d i n g I n t e n t = i n t e n t
r e q u e s t L o c a t i o n U p d a t e s L o c k e d (

. . . ,

r e c e i v e r ,

. . . ) ; g g
. . . ) f

1 5 8 4 . p r i v a t e v o i d r e q u e s t L o c a t i o n U p d a t e s L o c k e d ( . . . ,

R e c e i v e r
r e c e i v e r . c a l l P r o v i d e r E n a b l e d L o c k e d ( . . . )

r e c e i v e r ,

1 5 7 4 .

1 5 7 7 .

1 6 1 2 .
1 6 1 3 . g

1 1 9 .
2 3 6 .
6 9 0 .

6 9 2 .
6 9 5 .
6 9 7 .
1 2 4 3 .
1 2 4 4 .

1 2 4 7 .
1 2 4 9 .

1 2 9 0 .
1 4 7 8 .
1 4 9 8 .
1 5 4 1 .
1 5 5 2 .

1 5 5 7 .
3 1 3 8 . gg

Fragment 3. Code in Code in MountService

c l a s s M o u n t S e r v i c e f

A r r a y L i s t m L i s t e n e r s = new A r r a y L i s t < . . . > ( ) ;
p r i v a t e

f i n a l B r o a d c a s t R e c e i v e r m U s b R e c e i v e r =

new B r o a d c a s t R e c e i v e r ( ) f
p u b l i c v o i d o n R e c e i v e ( . . . ) f

n o t i f y S h a r e A v a i l a b i l i t y C h a n g e ( a v a i l a b l e ) ;

gg ;
p r i v a t e v o i d n o t i f y S h a r e A v a i l a b i l i t y C h a n g e ( . . . ) f

s y n c h r o n i z e d ( m L i s t e n e r s ) f

// i ^a(cid:19)L(cid:19)L [ 0 , m L i s t e n e r s ) . s i z e ( ) )
b l = m L i s t e n e r s . g e t ( i ) ;
b l . m L i s t e n e r .

o n U s b M a s s S t o r a g e C o n n e c t i o n C h a n g e d ( . . . ) ;

gg
p u b l i c M o u n t S e r v i c e ( . . . ) f
g
p u b l i c v o i d r e g i s t e r L i s t e n e r ( // t a r g e t S S I

mContext . r e g i s t e r R e c e i v e r ( m U s b R e c e i v e r ,

. . . ) ;

I M o u n t S e r v i c e L i s t e n e r
m L i s t e n e r s . add ( b l ) ; // b l . m L i s t e n e r = l i s t e n e r

l i s t e n e r ) f

Fragment 4. Code in PackageManagerService

mHandler . p o s t ( new R u n n a b l e ( ) f

2 1 9 2 . p u b l i c v o i d f r e e S t o r a g e ( . . . ,
2 1 9 6 .
2 1 9 7 .
2 2 0 6 .
2 2 0 7 .
2 2 1 2 .

p u b l i c v o i d r u n ( ) f
!= n u l l ) f

t r y f p i . s e n d I n t e n t ( . . . ) ;
g c a t c h ( S e n d I n t e n t E x c e p t i o n e1 ) f . . . g g g g ) ; g

i f ( p i

I n t e n t S e n d e r p i ) f

Fragment 5.1. Code in UsbService
mHandler . p o s t ( new R u n n a b l e ( ) f

I n t e n t S e n d e r p i ) f

2 1 9 2 . p u b l i c v o i d f r e e S t o r a g e ( . . . ,
2 1 9 6 .
2 1 9 7 .
2 2 0 6 .
2 2 0 7 .
2 2 1 2 .

p u b l i c v o i d r u n ( ) f
!= n u l l ) f

i f ( p i

t r y f p i . s e n d I n t e n t ( . . . ) ;
g c a t c h ( S e n d I n t e n t E x c e p t i o n e1 ) f . . . g g g g ) ; g

Fragment 5.2. Code in UsbSettingsManage

1 0 2 3 . p r i v a t e v o i d r e q u e s t P e r m i s s i o n D i a l o g (

I n t e n t
i n t e n t . s e t C l a s s N a m e ( ‘ ‘ com . a n d r o i d . s y s t e m u i ’ ’ ,

i n t e n t ,

. . . , P e n d i n g I n t e n t p i )f

‘ ‘ . us b . U s b P e r m i s s i o n A c t i v i t ’ ’ ) ;

i n t e n t . p u t E x t r a ( I n t e n t . EXTRA INTENT , p i ) ;

1 0 3 8 .
1 0 3 9 .
1 0 4 1 .

103