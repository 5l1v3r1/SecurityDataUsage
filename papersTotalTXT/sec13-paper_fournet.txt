ZQL: A Compiler for Privacy-Preserving 

Data Processing

Cédric Fournet, Markuld Kohlweiss, and George Danezis, Microsoft Research; 

Zhengqin Luo, MSR-INRIA Joint Centre

Open access to the Proceedings of the 22nd USENIX Security Symposium is sponsored by USENIXThis paper is included in the Proceedings of the 22nd USENIX Security Symposium.August 14–16, 2013 • Washington, D.C., USAISBN 978-1-931971-03-4ZQL: A Compiler for Privacy-Preserving Data Processing

C´edric Fournet
Microsoft Research

Markulf Kohlweiss

Microsoft Research

George Danezis
Microsoft Research

Zhengqin Luo

MSR-INRIA Joint Centre

Abstract

ZQL is a query language for expressing simple compu-
tations on private data.
Its compiler produces code to
certify data, perform client-side computations, and verify
the correctness of their results. Under the hood, it synthe-
sizes zero-knowledge protocols that guarantee both in-
tegrity of the query results and privacy for all other data.
We present the ZQL language, its compilation scheme
down to concrete cryptography, and the security guaran-
tees it provides. We report on a prototype compiler that
produces F# and C++. We evaluate its performance on
queries for smart-meter billing, for pay-as-you-drive in-
surance policies, and for location-based services.

Introduction

1
A variety of private user data is used to tailor modern ser-
vices, and some go as far as billing based on ﬁne grained
customer readings. For example, smart meters are used
to charge a different tariff depending on the time of elec-
tricity usage; pay-as-you-drive insurance premiums de-
pend on detailed driving pattern of drivers. Such schemes
are currently implemented by collecting ﬁne-grained in-
formation, and processing it on the service side—an ar-
chitecture that has led to serious privacy concerns.

This paper supports an alternative approach: clients
could perform sensitive computations on their own data
certiﬁed by meters or car on-board units [55, 60], and
upload only the results, together with a proof of correct-
ness to ensure their integrity. We propose ZQL, a simple
query language to express at a high level such compu-
tations, without any cryptographic details. Queries are
compiled to code for the data sources, the clients, and
the veriﬁers by synthesizing zero-knowledge protocols.
The most popular language for querying and perform-
ing computations on user data is SQL [29] based on re-
lational algebra. The ZQL feature set was chosen to sup-
port a subset of SQL. Data is organized into tables of
rows, with private and public columns. Queries accept

tables as inputs, and can iterate over them to produce
other tables, or aggregate values. Simple arithmetic oper-
ations on rows are supported natively, and so is a limited
form of SQL joins through table lookups.

ZQL offers advantages over hand-crafted protocols, in
that computations are ﬂexible and can be expressed at a
high level by application programmers. The computa-
tions can also be modiﬁed and recompiled, without the
need to involve cryptography experts.

The ZQL compiler is free to synthesize custom zero-
knowledge protocols behind the scene, and we currently
support two main branches, for RSA and Elliptic Curve
primitives. We also support a symbolic execution back-
end to derive estimates of the cost of evaluating and ver-
ifying queries. Synthesized protocols themselves are in-
ternally represented and optimized as fragments of an
extended ZQL language until the ﬁnal code is emitted.
Intermediate ZQL is strongly typed, and precise reﬁne-
ment types can be used to verify security properties on
the ﬁnal compiled code, using F7 [16] or F* [58].

Informally, for a given source query, the desired secu-
rity properties on the resulting ZQL-compiled code are:
• Correctness. For any given source inputs, the se-
quential composition of the cryptographic queries
for the data sources, the user, and the veriﬁer yields
the same result as the source query.

• Integrity. An adversary given the capabilities of
the user cannot get the veriﬁer to accept any other
result—except with a negligible probability.

• Privacy. An adversary given the capabilities of the
veriﬁer, able to choose any two collections of in-
puts such that the source query yields the same re-
sult, and given the result of the user’s cryptographic
query, cannot tell which of the two inputs was used.

This corresponds to the source query being executed by
a ﬁctional trusted third party sitting between the data
sources, the user, and the veriﬁer.

USENIX Association  

22nd USENIX Security Symposium  163

1

164  22nd USENIX Security Symposium 

USENIX Association

ContentsTherestofthepaperisorganizedasfol-lows.§2introducesourquerylanguageusingaseriesofprivacy-preservingdataprocessingexamples.§3speci-ﬁesourtargetprivacyandintegritygoals.§4reviewsthemaincryptographicmechanismsusedbyourcompiler.§5describesthecompilationprocess.§6givesourmainsecuritytheorems.§7discussesapplicationsand§8pro-videsexperimentalresultsanddiscussesfuturework.Thisshortversionofthepaperomitsmanydetailsanddiscussions;anextendedversionwithauxiliarydef-initions,proofs,andexamplesisavailableathttp://research.microsoft.com/zql.RelatedworkTheZQLlanguageprovidesprivatedataprocessing.Thezero-knowledgeprotocolssynthesizedarestandardΣ-protocols[32,30,33],butinZQLtheyareusedforprovingthecorrectnessofgeneralcomputationsratherthanforcryptographicprotocoldesign.Arguably,previousworksonzero-knowledgecompil-ersfocusedonthelatterastheprimaryuse-case[19,51,2,1].Theuseofzero-knowledgeforauthenticationandauthorizationasincredentialande-cashtechnolo-gies[23,51,4]receivedparticularattention,but,toourknowledge,no-oneconsideredtheuseofΣ-protocolstoprovetheexecutionofgeneralprograms.Morespeciﬁcally,alonglineofwork[19,7,2]culminatingintheCACEcompilertacklestheprob-lemofautomaticallytranslatingproofgoalsspeciﬁedintheCamenisch-Stadlernotation[22]intoefﬁcientΣ-protocols.IntermediatetranslationsstepsofZQL(thesharedtranslation)areatasimilarlevelofabstractiontotheCamenisch-StadlernotationbutZQLalsosyn-thesizesthoserepresentationsfromsourcecode,andthenproceedstocompilethemtolowleveloperations.ZKPDL[51],analternativecompilerforΣ-protocols,usesanaturallanguageinspiredspeciﬁcationofzero-knowledgeproofgoals.Thisspeciﬁcationlanguagemaybeevencloserinspirittoourintermediarynotation,asitallowsforthepossibilitytospecifythegenerationoftheprotocolinputs.TheauthorsoftheCACEcompilerdiscussthedifferenceandsimilaritybetweenthesetwoapproachesinaUsenixposter[9].ThecryptographicprototypinglanguageCharm[1]alsoincludesazero-knowledgeproofcompilerforCamenisch-Stadlerstate-mentswhichiscurrentlyprimarilyaproofofconceptandthuslesssophisticatedthanCACEandZKPDL.Wearealsoawareofanembeddingofazero-knowledgelan-guageinC++[45].ZQLdiffersfromstandardmulti-partycomputationcompilers[49],inthatitassumestheclientknowsallprivatedata.Thisassumptionallowsforsingleroundprotocols,andtheefﬁcientnon-interactiveimplementa-tionofnon-linearoperationsincludingjoins.ZQL SourceQueryVerifierCodeProver CodeData SourcecodeData SourcesClientServiceCertified DataCertified Query ResultsFigure1:ZQLinaprivacyfriendlycomputationsystem.2ALanguageforPrivateDataProcessingWhyZQL?WedesignZQLtosupportprivacyproto-colsthatrelyonclient-sidecomputationwhilerequiringhighintegrity[35].Inthissetting,anumberof(possiblyindependent)datasourcesprovidesignedpersonaldataitemstoauser.Thesigneddataisthenusedasaninputtosomecomputationperformedonauserdeviceonwhichtheoperationofaservicerelies(forexamplebillingforautility,determiningtheproximityoftoaspeciﬁcpath,orproﬁlingtheshoppinghabitsofauser).Theresultsofthecomputationarethensenttotherelyingservice,whileprivateinputdataiskeptsecret.TheZQLcompilertakesahighleveldescriptionofthecomputationandisresponsibleforproducingthecodeexecutedbythedatasourcestosignpersonaldata,thecomputationproverandthecomputationveriﬁer,asillustratedinFigure1.Itisassumedthatcommunicationstakeplaceoverpri-vateauthenticatedchannels;thedatasourcesaretrustedbyalltomaintaintheprivacyoftherawpersonaldatatheyproduce,andtosecurelysignthem.Giventhis,ourprotocolsguaranteeintegritythroughcryptographicproofsthatestablishtheauthenticityofthepersonaldatainputsandthecorrectnessofaparticularcomputation.Thus,amaliciousclientcannotmanipulatetheresultofthecomputation.Ontheotherhand,theprivateinputstothecomputationsarekeptsecretbytheuser,andtheproofsdonotleakanythingaboutthem.Thus,privacyispreserved,andonlytheresultofthecomputations(andanyinferencesthatcanbedrawnfromthem)becomeknowntotherelyingservice.Compilingallowsustostaticallyverifythesecurityoftheresultingprotocolsus-ingreﬁnementtypes(seethefullpaper).Hence,boththeproverandtheveriﬁer,oranyonetheytrust,cansepa-ratelyreviewthesourcequery,compiletheprotocol,andverifyitssecuritybytyping.Thereareadvantagesinde-couplingdatasourcesfromspeciﬁccomputations.Itallowsformeters,orservicesprovidingpersonaldata,toremainsimple,cheap,andgeneric.Inturn,thecomputations,suchasbilling,canbe2e

op

τ

::=
x
|
op ˜e
|
let ρ = e in e
|
↓ e
|
::=
|
( , ) | ( , , ) | . . .
|
+ | − | ∗
|
= | ∧
| map (ρ → e)
fold (ρ → e)
|
lookup ρ
|
::=
|
|
|

int [pub]
ρ table
ρ lookuptable

ρ,θ ,Γ ::= ε | x : τ,ρ

Expressions
variable
application
let binding
declassiﬁcation
Operators
tuples
arithmetic
boolean
map iterator
fold iterator
table lookup

Types
security type
table
lookup table

Tuple types

Figure 2: ZQL Syntax

updated without changing the devices that certify read-
ings. Finally, private computations can aggregate dis-
parate data sources that are not aware of one another, or
may not trust one another with the privacy or integrity of
the computations.

We ﬁrst provide a brief description of our source lan-
guage and then illustrate its primitives through simple
examples. §7 provides larger examples of protocols that
have been proposed in the literature.

The ZQL language At its core, ZQL is a pure expres-
sion language, with built-in operators that act on integers
and tables. Figure 2 gives its abstract syntax. A query
θ → e consists of the declaration of input variables (θ)
that can be either public or private, and of an expression
body (e).

Expressions consist of variables, operators applied to
sub-expressions ˜e (including constants as a special case
when ˜e is empty), and let bindings for sequential com-
position. Expressions evaluate to tuples of values: for
example, the expression let x : int,y : int = e in e0 ﬁrst
evaluates the sub-expression e to a pair of integers vx,vy,
then evaluates e0 after substituting vx and vy for x and y.
A variety of operators support arithmetic (0, 1, +, ∗),
booleans (=, ∧), and operations on tables (map, fold,
lookup). The iterators map and fold are parametrized
by a ZQL expression, conceptually acting as the body of
the corresponding loop. (We write these expressions as
functions, but they can only specialize the iterator; they
cannot be assigned to variables.)

Query inputs and expression results are speciﬁed us-
ing tuples of typed variables (θ for query inputs and ρ
for sub-expressions). Each base type can be marked as

public, and is otherwise treated as private. Types also in-
clude tables, where ρ indicates the type of each row in
the table. Tables can contain mixtures of public and pri-
vate columns; for example, (time:int pub, reading: int)table
is the type of tables of private readings indexed by pub-
lic times. On the other hand, the current ZQL compiler
does not attempt to hide the query deﬁnition itself, or the
number of rows in tables.

Intermediate expressions are automatically classiﬁed
as public or private, depending on the types of their vari-
ables, following a standard information ﬂow discipline:
public inputs can ﬂow to private results, but not the con-
verse. Alternatively, a ZQL expression can be explicitly
declassiﬁed, using the special operator ↓ e which speci-
ﬁes that the result of e can be released to the veriﬁer, and
marks it as public.

A ZQL query itself deﬁnes the privacy goals of the
synthesized zero-knowledge protocols. For example, a
query θ →↓ e, where e does not contain any declassi-
ﬁcation, states that only the ﬁnal result of the query is
released, and that the protocol should not leak any side
information on inputs marked as private in θ. A key fea-
ture of the language is that the underlying cryptographic
mechanisms are totally hidden in the deﬁnition of the
ZQL query. Since the ZQL query deﬁnes what results
are declassiﬁed, it is important that users, or their prox-
ies, review it to ensure no more than the necessary in-
formation leaks from it. Additional privacy mechanisms,
such as differential privacy [37], could be used to mea-
sure or minimize any leakage resulting from the query
declassiﬁcation.

The ZQL language is strongly typed, with a type sys-
tem simple enough to allow for automated type checking
and type inference, which means that the programmer
only has to write the input types of the query. We write
Γ (cid:24) e : ρ to state that expression e has type ρ in environ-
ment Γ. The type system ensures both runtime safety: e
returns only to values of types ρ, and non-interference:
in the absence of declassiﬁcation, e does not leak inputs
typed as private in Γ to results typed as public in ρ. The
type system can also be used to track the maximal length
of private variables to statically prevent arithmetic over-
ﬂows. We omit the formal deﬁnition of the language
semantics and type system, which are standard.
Inter-
nally, ZQL relies on a richer type system with reﬁne-
ments types [14, 42] to keep track of various properties
and to structure our security proofs—see the full paper.

ZQL by example We present the ZQL language and
semantics through simple concrete examples, building to
fuller queries that address problems in the literature in §7.
The ﬁrst example query computes the discriminant of the
polynomial xk2 + zk + y, for public x and private y and z.
let discriminant (x:int pub) (y:int) (z:int) = ↓ (z∗z − 4∗x∗y)

USENIX Association  

22nd USENIX Security Symposium  165

3

Anticipating on its compilation, the part of the expres-
sion that is linear in the secrets, namely −4∗ x ∗ y, can
be proved efﬁciently through homomorphisms of Peder-
sen commitments, while the non-linear z ∗ z requires a
Σ-protocol to prove the correctness of the private multi-
plication. The ZQL compiler will choose to synthesize
the right proof mechanisms for each case.

The query declassiﬁes its result, which leaks some in-
formation about y and z. For instance, given x = 30 and
discriminant x y z = 1000, if the veriﬁer knows a priori that
0 ≤ y < 200 and 0 ≤ z < 200, then it can infer that (y,z) is
one of the pairs (5,40), (45,80), (75,100) or (155,140),
but our privacy theorem ensures that its does not learn
which pair was actually used.

Our next examples illustrate the use of tables and it-
erators map and fold. The ﬁrst query computes the sum
of all integers in table X, while the second returns the
sum of their squares. The third query takes a table with a
public column and two secret columns and returns a table
with the same public column, and the element-wise sum
of the secret columns. By design, the size of the tables
is not hidden by ZQL. (Hiding table sizes naively would
involve padding the computation to the maximum size of
allowed tables, which would be very expensive.)

let sum of x (X : int table) =

↓ (fold ((s, x) →s + x) 0X)
let sum of square (X : int table) =
↓ (fold ((s, x) →s + x∗x) 0X)
↓ (map ((a,x,y) →a, x+y) T)

let linear (T: (int pub ∗ int ∗ int) table) =

In these queries, the iterators are parametrized by a sub-
query, which is applied to every row of the table, accu-
mulating the sums in s, or building another table of re-
sults. The equivalent SQL statements would be written
select SUM(x) from X, select SUM(x*x) from X, and se-
lect a, x+y from T. The ﬁrst and third queries compute
linear combinations of secrets; we compile them without
the use of any expensive Σ-protocols.

We found sum queries to be frequent enough to jus-
tify some derived syntax: we write sum (ρ → e) T as
syntactic sugar for fold (s,ρ → s + e) 0 T .
A key feature of the ZQL language is the ability to
perform lookups on input tables. This provides a lim-
ited form of join and enable the computation of arbitrary
functions with small domains. The expression lookup x T
ﬁnds a row x,v1, . . .v n in T that matches x, and returns
v1, . . . ,v n. From an information-ﬂow viewpoint, the re-
sult of a lookup on a private variable is also private (even
if the lookup table is public); in that case, ZQL leaks
no information about which row is returned.
If multi-
ple rows match x, the veriﬁer is only able to assert that
any matching row was used. If no row matches x, a run-
time exception is raised on the prover side, and the proof
fails. This semantics allow the implementation of func-

tions, set membership tests, and half-joins.

To enable lookups, each row of the input table cur-
rently needs to be signed using a re-randomizable signa-
ture by a trusted source, so these tables are given a spe-
cial type (ρ lookuptable) and lookups on intermediate,
computed tables are not supported.

The example blur,

listed below, repeatedly uses a
lookup to map private city identiﬁers to their respective
countries; the resulting table is then declassiﬁed.
let blur (X: int table) (F: (int ∗ int) lookuptable ) =
↓ (map (city →lookup city F) X)

The equivalent SQL statement would be select F.country
from X, F where F.city = X.city. The query implementa-
tion relies on a data source that issues a signed table from
cities to countries.

3 Security
The next two sections provide rigorous security deﬁni-
tions for what the ZQL compiler achieves and the crypto-
graphic building blocks it uses, necessary for formulating
our security theorems in §6. The mere fact that we can
give formal cryptographic deﬁnitions for a large class of
cryptographic protocols relies on our simple expression
language having a formal semantic for both source and
compiled programs. Readers interested in compiler ar-
chitecture can jump straight to §5, or those curious about
applications can ﬁnd them in §7.
Notations Consider a well-typed ZQL source query
Q (cid:25)= θ →↓ e, with (cid:28) input variables θ = (xi : τi)i=0..(cid:28)−1,
that declassiﬁes only its result. As explained in §2, the
typed variables θ specify the data sources and privacy
policy. Let (cid:27)T range over values of type θ, and R = Q((cid:27)T )
be the corresponding query result. Given Q, our com-
piler produces queries (S, (Ki, Di)i=0..(cid:28)−1, P, V) with for-
mal parameters indicated in parentheses as follows. (We
use primed variables for compiled values.)

χ used by the commitment scheme;

• S, the setup generator, generates global parameters
• (Ki)i=0..(cid:28)−1, the data sources key generation, gener-
ate key pairs ski,vki := Ki(χ) used to sign data and
verify their signatures;

input: T(cid:23)i := Di(χ,ski,Ti);

• (Di)i=0..(cid:28)−1, the data sources, extend and sign each
• P, the prover, produces an extended result from ex-
• V, the veriﬁer, returns either some source result

tended inputs: R(cid:23) := P(χ, (cid:27)vk,(cid:27)T(cid:23));

R := V(χ, (cid:27)vk,R(cid:23)) or a veriﬁcation error.

Main Properties We ﬁrst deﬁne functional correctness
when all participants comply with the protocol.

4

166  22nd USENIX Security Symposium 

USENIX Association

Deﬁnition 1 (S, (Ki, Di)i=0..(cid:29)−1, P, V) correctly imple-
ments the source query Q when, for any source inputs
(cid:28)T : θ and χ := S, (ski,vki := Ki(χ))i=0..(cid:29)−1, we have
V(χ, (cid:28)vk, P(χ, (cid:28)vk, Di(χ,ski,Ti)i=0..(cid:29)−1)) = Q((cid:28)T ).
We deﬁne privacy as indistinguishability between two
series of chosen inputs that yield the same query result.

Deﬁnition 2 Given a source query Q and an adver-
sary A , let AdvPriv
A = |2Pr[A wins]− 1| where the event
‘A wins’ is deﬁned by the following game:
(1) The challenger runs S and Ki to generate setup χ

and keys (cid:28)sk, (cid:28)vk; it provides χ and (cid:28)vk to A .

(2) The adversary A provides two vectors of input data
(cid:28)T 0 : θ and (cid:28)T 1 : θ such that (a) they coincide on pub-
lic data and (b) Q((cid:28)T 0) =Q( (cid:28)T 1).

corresponding inputs (cid:28)T(cid:29) := (Di(χ,ski,T b
and generates R(cid:29) := P(χ, (cid:28)vk,(cid:28)T(cid:29)).

(3) The challenger picks a random bit b, encodes the
i ))i=0..(cid:29)−1,
(4) Given R(cid:29), A returns his guess b(cid:29), and wins iff b = b(cid:29).
(S, (Ki)i=0..(cid:29)−1, (D)i=0..(cid:29)−1, P, V) is (t,ε)-private when,
for all A running at most for time t, we have AdvPriv
A ≤ ε.
Note that we do not formally provide privacy protection
against corrupted data sources. To strengthen our scheme
against data source attacks, we would have to rerandom-
ize all cryptographic material ﬂowing from data sources
to veriﬁers, which precludes our efﬁcient use of homo-
morphic commitments.

We deﬁne integrity as a game in which an adversary

has to produce an invalid but accepted response.
Deﬁnition 3 Given a source query Q and an adver-
sary A ,
A = Pr[A wins] where the event
‘A wins’ is deﬁned by the following game:
(1) The challenger runs S and Ki to generate setup χ

let AdvSnd

and keys (cid:28)sk, (cid:28)vk; it provides χ and (cid:28)vk to A .

(2) The adversary A can adaptively corrupt data
sources Di to get their signing keys ski and, at
the same time, it can obtain signed inputs T(cid:29)i
:=
Di(χ,ski,Ti) for source inputs Ti : τi of its choice.

(3) Valid results are source values R = Q((cid:28)T ) such
that, for each i, either i was corrupted or Ti was
signed. The adversary wins if he outputs R(cid:29) such
that V (χ, (cid:28)vk,R(cid:29)) returns any invalid result R(cid:27).

(S, (Ki)i=0..(cid:29)−1, (D)i=0..(cid:29)−1, P, V) is (t,ε)-sound when,
for all A running at most for time t, we have AdvSnd
A ≤ ε.
Depending on the adversary, there can be zero, one,
or numerous valid responses. In fact, depending on the
query and the input tables, whether a response is valid
may not even be efﬁciently checkable. The deﬁnition is,
however, still meaningful.

4 Main Cryptographic Tools (Review)
Signatures A digital signature scheme allows every-
one in possession of the veriﬁcation key vk to verify the
authenticity of data signed by the owner of the corre-
sponding signing key sk. We use signatures to let veri-
ﬁers authenticate data sources. Instead of signing private
data in the clear, data sources sign public commitments;
thus, the resulting signature tags are also public.
Cryptographic groups Besides conventional digital
signatures, for which we use standardized schemes, our
remaining cryptographic tools can either be speciﬁed for
composite order groups, obtained by computing modulo
an RSA modulus, or for prime order groups with a bi-
linear pairing. We use the latter for our presentation and
formal analysis as it offers both performance and con-
ceptual advantages.
ˆG, and GT be groups of prime order q. Let
Let G,
g ∈ G and ˆg ∈ ˆG be generators of G and ˆG respectively.
A bilinear pairing is an efﬁciently computable function
ˆe : G∗ ˆG → GT that is bilinear, i.e. ∀a,b ∈ Fq : e(ga, ˆgb) =
e(g, ˆg)ab and non-degenerate, i.e. e(g, ˆg) (cid:23)= 1. Whenever
possible we perform all operations in the base group G
with the shortest representation.
Commitments A commitment scheme allows a user to
commit to a hidden value such that he can reveal the com-
mitted value at a later stage. The properties of a commit-
ment scheme are hiding: the committed value must re-
main hidden until the reveal stage, and binding: the only
value which may be revealed is the one that was chosen
in the commit stage. We use the perfectly hiding commit-
ment scheme proposed by Pedersen [54]: given a group
G of prime order q with generators g and h, generate a
commitment Cx to x ∈ Fq by sampling a random opening
ox ← Fq and computing Cx = gxhox. The commitment is
opened by revealing both x and ox.
Two useful properties of Pedersen commitments are
(i) their homomorphic property that allows to derive a
commitment to the linear combination of input values;
and (ii) their algebraic structure that allows for efﬁcient
zero-knowledge proofs. For RSA groups, we use com-
mitments with similar properties [43, 34].
Zero-knowledge proofs
[59, 39, 11] provide a verify-
ing algorithm with an efﬁcient means for checking the
truth of a statement by guaranteeing that given access
to a successful proof generation algorithm one can ex-
tract a secret witness for said truth. At the same time,
zero-knowledge proofs [47, 46], and the related concepts
of witness indistinguishable proofs [38, 32], allow the
prover to keep this witness secret. We make use of a
long line of work on efﬁcient proofs of conjunctions of
discrete logarithm (DL) representations [57, 28, 52, 32,
30, 18, 26, 33, 50]. For non-linear computations such as

USENIX Association  

22nd USENIX Security Symposium  167

5

multiplication, we use the approach of Brands [18], Ca-
menisch [26], and Cramer and Damg˚ard [31].

DL representation proofs are interactive protocols of
three or more messages. To ease deployment and min-
imize communications, we use the Fiat-Shamir Heuris-
tic [40] and replace random messages sent by the veriﬁer
with hash function computations. The resulting proto-
cols can still be formally analyzed in the random oracle
model [12, 62].

Proof compatible signatures The combination of
zero-knowledge proofs and digital signatures allows us
to prove authentication properties on private data, such
as, for instance, the existence and properties of a match-
ing row when performing a private lookup.

We use CL signatures [20], as they are compatible
with DL representation proofs. The original scheme was
proven secure under the Strong RSA assumption and re-
quires groups with hidden order [6, 24]. Other CL signa-
ture proposals rely on a variety of assumptions based on
bilinear pairings [21, 17, 3, 25] and require more stan-
dard prime order DL-representation proofs. We also use
the scheme of [25], a good trade-off between security and
performance. An additional beneﬁt is that it is syntacti-
cally very close to RSA-based CL signatures.

To certify our lookup tables, data sources extend each
row of the table with a CL signature. For instance,
tables of triples of private integers (x0,x1,x2) are ex-
tended to tables with rows of the form (x0,x1,x2,e,v,A).
The veriﬁcation equations for RSA and bilinear pairing
based CL signatures are of the form Z = AeRx0
2 Sv
and ˆe(Z, ˆg) = ˆe(A,pk∗ge) ˆe(Rx0
2 Sv, ˆg) respectively,
where (Z,R0,R1,R2,S,pk) are group elements that form
the components of the veriﬁcation key vk. Both veriﬁ-
cation equations can be proven using efﬁcient DL repre-
sentations. The security of these two schemes is based on
the strong RSA assumption and the strong Difﬁe-Hellman
(SDH) assumption respectively.

0 Rx1

1 Rx2

0 Rx1

1 Rx2

5 Compiler Architecture
Protocol Overview The ZQL compiler takes a source
query, which contains no cryptographic computations,
and automatically produces programs for each data
source, for the prover, and for the veriﬁer.

First, the compiler augments the source query with
various cryptographic commitments to secrets and repre-
sentation equations to generate a shared translation that
will lead to both prover and veriﬁer code. Some com-
mitments are computed and signed by the data sources
that certify the computation inputs, and simply passed to
the prover and veriﬁer programs. Others, representing
intermediate secrets in the query, are interleaved with the
source computation: for any such secret x, the prover
may sample a secret opening ox, compute a Pedersen

commitment Cx =G gxhox, and send it to the veriﬁer; and
the veriﬁer may check it using a zero-knowledge proof.
Linear relations between secrets do not require com-
plex zero knowledge proofs, as they can be checked by
the veriﬁer simply by using the homomorphisms of Ped-
ersen commitments. For example, a private sum z = x +y
will have commitment Cz =G Cx ∗ Cy. Such commit-
ments need not be transmitted, as they can be recom-
puted by the veriﬁer. On the other hand, non-linear re-
lations between secrets, including multiplication and ta-
ble lookup, require Σ-protocol proofs to be synthesized.
For instance, to prove that z is the product of a secret x
committed in Cx and a secret y, one proves the con-
junction of the representation equations Cx =G gxhox and
1 =G (Cx)−ygzhoz. Note that the second equation uses a
variable commitment Cx as a base.

All Σ-protocols used in the compiler come down to
proving knowledge of the secret values underlying the
discrete logarithm representations of public group el-
ements, and equality relations between the secret val-
ues. Assume the ZQL query reduces to proving in zero-
knowledge the representations (cid:30)C =G (cid:30)e[ ˜x] of a number of
commitments (cid:30)C, represented by public group elements,
using a number of secrets ˜x (including secret openings).
For the multiplication example above, we have two equa-
tions on ﬁve secrets: (cid:30)C ≡ (Cx,1),
˜x ≡ (x,ox,y,z,oz)
and (cid:30)e[(α,β ,γ,δ ,ε)] ≡ (gα ∗ hβ ,C−γ
x gδ hε ). The zero-
knowledge protocol synthesized works as follows. The
prover

(1) samples a vector of random values ˜t, one for each
secret in ˜x; We call ˜t values the proof randomness;

(2) computes the challenge c = H((cid:30)e[˜t]);
(3) computes the responses ˜r = ˜t − c∗ ˜x, for all secrets.
The proof sent to the veriﬁer consists of the public pa-
rameters and values, the commitments (cid:30)C, the global chal-
lenge c, and the responses ˜r. The veriﬁer checks that
H((cid:30)Cc ∗G(cid:30)e[˜r]) = c, which ensures that the prover knows
the secret values in the commitments [40, 12]. As de-
tailed below, our compiled prover and veriﬁer programs
introduce secrets and process equations on the ﬂy, de-
pending on the query and its inputs.

Once the shared translation is decided, its specializa-
tion into prover and veriﬁer code is relatively straight-
forward. It involves mainly ensuring the right data ﬂows
within the query processing to compute all commitments
and responses, and to correctly verify them in the same
order. The inputs of the shared translation also deter-
mine the data source programs that generate keys, com-
pute commitments, and sign extended data.
Embedding cryptography within ZQL Our compiler
mostly operates within ZQL, with F# and C++ back-ends
to turn the compiled queries into executable code. This

168  22nd USENIX Security Symposium 

USENIX Association

6

e

op

τ

assert ϕ;e

::= . . .
|
::= . . .
−1,0,1, . . .
|
sample | random | div
|
*G |=G| expG
|
ˆe : G∗ ˆG → GT
|
extend | ﬁnalize
|
keygen | sign | verify
|
| mapP | mapV
foldP | foldV
|
::= . . .
num | x opening | x rand
|
eltG | x ox commitment
|
hash
|
tagi | ski | vki
|
Figure 3: ZQL internal constructs

Expressions
static assertion

Operators
constants
exponents (mod q)
group operations
EC bilinear form
cryptographic hash
plain signatures

translated iterators
Types
exponents (mod q)
group elements
cryptographic hash
plain signatures

enables us to reason about code in a simple, domain-
speciﬁc language. To this end, Figure 3 supplements
the source language of Figure 2 with the types and op-
erators for expressing cryptographic operations. Expres-
sions are extended with assert, used in the shared trans-
lation to embed proof obligations. As an invariant, all
asserted equations ϕ must hold at runtime. We have
types and operations for integers modulo q (Fq, written
num), for group elements (eltG), and for bitstrings, and
more speciﬁc sub-types to keep track of their usage. For
instance, hash is the sub-type of bitstrings representing
cryptographic hashes, and xopening is a sub-type of num
tracking openings generated for the secret value x. In our
presentation, we use standard abbreviated forms for their
operations; for instance we often omit group parameters,
writing gx for expG g x.
Setup and Key Generation The abstract setup S pro-
duces global parameters χ supplied by our cryptographic
runtimes, including q, the prime order of G, ˆG, and GT ;
and independent, random generators g, h, (Ri)i=0..n, S,
Z in G; and ˆg in ˆG. Its ﬁxed code is provided by our
cryptographic libraries.

We use DLT ⊆ 0..(cid:29) − 1 to denote the subset of data
sources that sign lookup table. The key generation
Ki is deﬁned as keygen χ when τi is a scalar or a ta-
ble (i /∈ DLT ), and as the CL-key generation let sk =
sample() in sk, ( ˆg)sk when τi is a lookup table (i ∈ DLT ).
The data source code Di is explained below, as we dis-
cuss these two representations.
Shared Translation We extend the source query with
openings and commitments, but not yet with the corre-
sponding proof randomness and responses.

The main difﬁculty of the translation is to select cryp-
tographic mechanisms, and notably intermediate com-

mitments, to run the private computation: for every pri-
vate sub-expression, our compiled protocol may rely on
zero, one, or more Pedersen openings and commitments,
and it may allocate some proof randomness or not.

In this presentation, for simplicity, we give a formal
translation that assumes that all source private integer
variables are handled uniformally, with a commitment in
the same group, sharing the same bases, and (later) with
a proof randomness for the secret and for its opening.
Figure 4 and 5 show how we translate types and expres-
sions, respectively, in this special case. We discuss our
general, more efﬁcient compilation scheme below.

A source expression is public in a typing environment
when all its free variables have public types. The trans-
lation leaves public types (1) and expressions (3) un-
changed. The translation of a private integer expression
is a triple of an integer for the source value, its opening,
and its commitment, with the types given on line (2).
Fresh commitments Our compilation rules may require
openings and commitments on their arguments, and may
not produce openings and commitments on their re-
sults. Our compiler attempts to minimize those cases.
Nonetheless, assuming for instance that we need a com-
mitment for z, we produce it on demand, using the ex-
pression abbreviation Commit z below

Commit z (cid:25)=

let oz : z opening = sample() in
let Cz : zoz commitment = gz∗G hoz in
assert Cz = gz∗G hoz;
z,oz,Cz

The translation is compositional, as can be seen on
lines (4,5,6) in the ﬁgure. For instance, we translate let
expressions by translating their two sub-expressions, and
we translate source maps to maps that operate on their
translated arguments.

The translation assumes prior rewriting of the source
query into simpler sub-expressions. For instance, to
compile the discriminant query of §2, we ﬁrst introduce
intermediate variables for the private product and the de-
classiﬁcation, rewriting expression ↓ (z∗z−4∗x∗y) into

ed (cid:25)= let p = z∗ z in let d = p− 4∗ x∗ y in ↓ d.
As a sanity check, our translation preserves typing, in
an environment extended with the constants used in our
cryptographic libraries; variants of this lemma with more
precise reﬁnement types for the prover and veriﬁer trans-
lation can be used to verify their privacy and integrity.

Lemma 1 (Typing the shared translation) Let Γ0 (cid:25)=
g,h,Z,R0, . . .R n,S : eltG, ˆg, (pki)i∈DLT : elt ˆG. If Γ (cid:22) e : ρ,
then Γ0, [[Γ]] (cid:22) [[Γ (cid:22) e]] : [[ρ]].

Next, we explain and illustrate the base cases of the

shared translation on private expressions.

USENIX Association  

22nd USENIX Security Symposium  169

7

[[x : τ{ϕ}]] = x : τ{ϕ} when τ is public;

otherwise:
[[x : int{ϕ}]] = x : int{ϕ},

ox : x opening,
Cx : x ox commitment

(1)

(2)

[[ρ table]] = [[ρ]] table,s : tag

[[ρ lookuptable]] = (ρ,σ ) table

σ = e : num,v : num,A : eltG

[[ε]] = ε

[[x : τ{ϕ},ρ]] = [[x : τ{ϕ}]], [[ρ]]

Figure 4: Shared translation of types and environments

Expressions afﬁne in private variables are translated
by supplementing the expression with a linear expres-
sion on openings and an homomorphic product of com-
mitments (7); we easily check that the resulting triple
(z,oz,Cz) is such that Cz = gz ∗G hoz. Note that the public
constant a0 is not included in the opening computation.
Expressions polynomial in private variables are trans-
lated using an auxiliary representation equation for every
product of private expressions, depending on the avail-
ability of openings and commitments—see translation
rule (8). To illustrate afﬁne and quadratic expressions,
let us translate the discriminant query θ → ↓ (ed) where
the source environment θ = x : int pub,y : int,z : int spec-
iﬁes that x is public, whereas y and z are private. By
deﬁnition, the translated environment [[θ ]] is

x : int pub,
y : int,oy : y opening,Cy : y oy commitment,
z : int,oz : z opening,Cz : z oz commitment

and, from the translation invariant, we already know that
Cy =G gyhoy and Cz =G gzhoz. Applying rules (4), (8), (7),
and (10) and inlining the deﬁnition of Commit we arrive
at the shared translation

let p, op , Cp =
let p = z∗z in
let o(cid:26) = oz∗ z in
assert 1 = (Cz)z∗G g−p∗G h−o(cid:26);
let op = sample() in
let Cp = gp∗G hop in
assert Cp = gp∗G hop;
(p, op, Cp)
let d, od , Cd =

(E1)

(E2)

)

(p− 4∗ x∗ y), (op− 4∗ x∗ oy), (Cp ∗C−4∗x

y

↓ d
and we easily check that Cd is a commitment to z2 − 4xy
with opening op−4x∗oy. The code of the shared transla-
tion makes explicit the two representation equations for
the private multiplication, presented more abstractly at
the beginning of §5. Anticipating on the next stages of

(3)

(4)

(5)

(6)

(9)

[[Γ (cid:23) e]] = e when e is public
[[Γ (cid:23) x]] = [[Γ(x)]]
otherwise

[[Γ (cid:23) let ρ = e in e0]] =

[[Γ (cid:23) map (ρ → e) T ]] =

let [[ρ]] = [[Γ (cid:23) e]] in [[Γ,ρ (cid:23) e0]]

map ([[ρ]] → [[Γ,ρ (cid:23) e]]) [[Γ (cid:23) T ]]
where Γ(T ) = ρ table and Γ,ρ (cid:23) e : ρ(cid:26)

[[Γ (cid:23) fold (a : τ,ρ → e) a T ]] =

[[Γ (cid:23) a]] [[Γ (cid:23) T ]]

i=1 ai ∗ xi,
G,i=1(Cxi )ai

fold ([[a : τ,ρ]] → [[Γ,a : τ,ρ (cid:23) e]])
where Γ(T ) = ρ table and Γ,a : τ,ρ (cid:23) e : τ
[[Γ (cid:23) a0 + ∑n
(7)
i=1 ai ∗ xi]] =
a0 + ∑n
∑n
i=1 ai ∗ oxi,
ga0 ∗G ∏n
when the ai are public and the xi private
[[Γ (cid:23) x∗ y]] =
let p : int = x∗ y in
let o(cid:26) : num = ox∗ y in
assert 1 = (Cx)y∗G g−p∗G h−o(cid:26);
Commit p
when x and y private

(8)

[[Γ (cid:23) lookup x0 Ti]] =

eg−ph−o(cid:26)

let x1, . . . ,x n,e,v,A = lookup x0 Ti in
let d,od,Cd = Commit (random()) in
let p = d ∗ e in
let o(cid:26) = od ∗ e in
assert 1 =G Cd
let A(cid:26) = A∗ h−d in
assert ˆe(Z, ˆg) ˆe(1/A(cid:26),pki) =GT
(∏n
i=0 ˆe(Ri, ˆg)xi ) ˆe(A(cid:26), ˆg)e
ˆe(S, ˆg)v ˆe(h, ˆg)p ˆe(h,pki)d
Commit x1, . . . ,Commit xn
where Γ(Ti) = (xi : int)i∈0..n−1 lookuptable
[[Γ (cid:23)↓ x]] = ↓ x when x private
(10)

Figure 5: Shared translation of typed source expressions

the translation, the prover will compute Cp, pass it to the
veriﬁer, and extend its challenge computation with equa-
tion E2, whereas the veriﬁer will receive some Cp and
use it to check this equation. Note that the cryptographic
overhead depends on the target level of privacy: given
instead a source environment θ declaring that x is also
private, the same discriminant expression would involve
representation proofs for two private products.

Private lookups are translated using proofs of knowl-
edge of signatures. To enable this, data sources extend
input tables T : ρ lookuptable, where ρ is of the form
x0 : int, . . . ,x n : int, into tables T(cid:26) : (ρ,σ )table with a CL
signature at the end of each row, as follows:

8

170  22nd USENIX Security Symposium 

USENIX Association

Di (cid:31)= χ,sk,T → map (x0 . . . xn →

xiSvZ−1)

1
sk+e in

let e = random() in
let v = random() in
let A = (∏n
G,i=0 Ri
x0, . . ., xn, e, v, A)

T

Although this pre-processing may be expensive for large
tables, it can be amortized over many queries.

A lookup within a source query, such as the one from
the blur query of §2, is translated to a proof of posses-
sion of a CL signature. For instance, let us translate the
expression lookup c F in environment

ρ = F : (city : int,country : int) lookuptable,c : int.

The environment is ﬁrst translated to

[[ρ]] = (city : int,country : int,σ )table,

c : int,oc : c opening,Cc : c oc commitment

The lookup itself is translated (using rule 9) to

[[Γ (cid:27) lookup c F]]=

let country, e,v,A = lookup c Fin
let d, od, Cd = Commit(random()) in
let p, o(cid:26) = d ∗ e, od ∗ e in
eg−ph−o(cid:26);
assert 1 =G Cd
let A(cid:26) = A∗ h−d in
assert ˆe(Z, ˆg)· ˆe(1/A(cid:26),pki) =GT
ˆe(R0, ˆg)c · ˆe(R1, ˆg)country·
ˆe(A(cid:26), ˆg)e · ˆe(S, ˆg)v · ˆe(h, ˆg)p · ˆe(h,pki)d ;

Commit country

This code ﬁrst looks for a signed tuple (city,country,
e,v,A) in F such that c = city and retrieves the remaining
elements; it then proves knowledge of this tuple, without
revealing which tuple is used in the proof, by blinding
the element A of the signature. (Note that this proof in-
ternally relies on a proof of multiplication.)
Iterators and Committed Tables ZQL supports tables
with mixed public and private columns, as well as itera-
tors map and fold. To enable processing on their private
contents, data sources extend tables with commitments
and sign them. For instance, here is the code for the
provider of the table of cities for the blur query.

Di (cid:31)= χ,sk,X →
let X(cid:26) = map (x: int →Commit x) X in
let H = fold (H,x,ox,Cx →extend H Cx) H0 X(cid:26) in
X(cid:26), sign sk H

This code ﬁrst uses map to extend each source inte-
ger with a fresh opening and commitment, using the
Commit abbreviation; this yield the extended table X(cid:26)
It then uses fold to compute the
passed to the prover.
joint hash of these commitments, and ﬁnally signs the re-
sult. (In the hash computation, H0 is some ﬁxed tag, and
we omit a conversion from eltG to hash). As outlined
at the end of this section, both the prover and the veri-
ﬁer perform some initial processing for these extended

tables: the prover must show his knowledge of the repre-
sentation for these commitments, and the veriﬁer must
verify the signature and the representation proofs for
these commitments.

We illustrate the translation of the map iterator (5) on
the blur query from §2. The translation of fold (6) is
similar. The map expression of blur is translated to an-
other map expression, in a translated environment that
provides the extended input X : [[x : int]] table:

[[Γ (cid:27) map(c → lookup c F) X]] =

map (c,oc,Cc → [[Γ,c : int (cid:27) lookup c F]]) X

and the translation continues with the lookup expression,
as explained above.
Prover Translation Continuing from the result of the
shared translation, the prover translation uniformly turns
its assertions into a custom non-interactive Σ-protocol, in
two passes, written [[ ]]1 and [[ ]]2, that produce code ﬁrst
for the message randomness, then for the responses.

Figure 6 deﬁnes these two passes, as well as the top-
level query translation [[ ]]PROVER that combines [[ ]]1
and [[ ]]2 with additional glue. Overall, the prover for a
source query θ → e is thus deﬁned using this translation
after the shared translation: P (cid:31)= [[ [[θ (cid:27) e]] ]]PROVER.
First-message translation In the ﬁrst pass, H is the pub-
lic hash incrementally computing the global challenge;
a is the accumulated cryptographic evidence that will be
sent to the veriﬁer; and every private variable x is re-
placed with a pair x,tx where tx is the proof random-
ness for x. (Openings are treated as any other secrets.)
In combination with the shared translation, every private
source expression becomes a tuple of the form [[[[e]]]]1 :
(x,tx,ox,tox,Cx) where x is the value of e, tx is the ran-
domness for x, ox is an opening for x, tox is the random-
ness for ox, and Cx is a commitment to x. For efﬁciency,
all these additional values are optional in our compiler.
the type translation [[ρ]]1 maps
shared environments to environments extended with an
entry for each proof randomness, and leaves the other en-
tries unchanged; the expression translation [[ ]]1 takes H
and a as free variables and returns their updated values of
the form extend . . . (extend H E1) ... En, with one exponen-
tial expression Ei for each assertion in e, and a, a1, . . .a m
for each additional evidence a j produced by e.

Compositionally,

We explain the main cases of the ﬁrst-pass translation.
Public expressions are (still) unaffected. Note that they
may includes public expressions generated by the shared
translation, such as products of commitments. Afﬁne pri-
vate expressions are translated homomorphically, adding
a corresponding linear expression on the proof random-
ness. Private exponential computations yields evidence
that must be communicated to the veriﬁer; we add their
results to a. More complex private expression are supple-
mented with the sampling of a fresh message randomness

USENIX Association  

22nd USENIX Security Symposium  171

9

for their result—we rely on the assertions introduced by
the shared translation to prove those expressions.

Assertions of equations of the form eP = ex are trans-
formed into extensions of the global-challenge compu-
tation. The left-hand-side must be a public expression,
and is discarded. The right-hand-side must be an ex-
pression on private variables. Let et be the expressions
obtained by replacing each of theses variables x with tx.
The translation computes it, and extends H with the re-
sult. Declassiﬁcations are similarly translated: the de-
classiﬁed value x is added to a, and the hash is extended
with gtx to link it to its proof randomness (as if we were
translating assert gx=gx). Continuing with our example,
we give below the expression e1, obtained by translating
the shared-translation of the discriminant query, after re-
moving the unnecessary commitment Cd. (This code has
been rearranged for simplicity; the full code produced by
the translation rules appears in the full paper.)

let p = z∗z in
let tp = random() in
let o(cid:31) = oz ∗ z in
let to(cid:31) = random() in
let H = extend H ((Cz)tz ∗G g−tp ∗G h−to(cid:31) ) in
let op = sample() in
let top = random() in
let Cp = gp ∗G hop in
let H = extend (extend H Cp) (gtp ∗G htop ) in
let d = p− 4∗ x∗ y in
let td = tp − 4 ∗ x ∗ ty in
let H = extend (extend H gd) gtd in
let a = a, (p,tp), (o(cid:31),to(cid:31)), (op, top), Cp, d in
(H, a, d)

Response Translation In the second pass, after complet-
ing the computation of the global challenge c, we revisit
the collected evidence a, and we replace every pair of a
private value x and associated proof randomness tx with
the response rx = tx−c∗x. This pass is deﬁned by induc-
tion on the type of a, produced by the ﬁrst-message trans-
lation, which indicates where those pairs are. (Techni-
cally, this pass also needs to re-balance nested tuples, as
the prover produces (. . .(a 0,a1),a2, . . . ,a n) whereas the
veriﬁer consumes (a0, (a1, (. . .a n) . . .)); we omit those
details.) Continuing with the discriminant prover, the re-
sulting evidence a : δ binds the series of variables

(z, tz), (oz, toz), (p,tp), (o(cid:31),to(cid:31)), (op, top), Cp, d

and thus [[δ ]]2 simply computes the responses for the ﬁve
pairs of secret and associated proof randomness:

[[δ ]]2

(cid:28)= let (z,tz), (oz,toz), (p,tp), (o(cid:31),to(cid:31)), (op, top), Cp, d = a

let rz = tz − c∗ z
let roz = toz − c∗ oz
let rp = tp − c∗ p
let r(cid:31)o = to(cid:31) − c∗ o(cid:31)
let rop = top − c∗ op
(rz, roz, rp, ro(cid:31), rop, Cp, d)

Top-Level Prover Translation (P) We arrive at the fol-
lowing code for the prover, given here for the discrim-
inant query. (See Figure 6 for the general case.) This
prover relies on data sources extending both private
source inputs y and z with an opening, a commitment,
and a signature on that commitment

x, (y, oy, Cy, σy), (z, oz, Cz, σz) →
let H = extend (extend H0 Cy) Cz
let tz = random()
let toz = random()
let a = (z,tz), (oz,toz)
let H = extend H (gtz ∗G htoz )
let H, a: δ , d = [[[[θ ]] (cid:26) [[e]]]]1 // phase 1 detailed above
let c = ﬁnalize H in
let a = [[δ ]]2
// phase 2 detailed above
(x, (Cy, σy), (Cz, σz), a, c)

In this code, H0 is the hash of all public values used as
bases in the Σ-protocol, [[θ ]]D is the tuple type of the
(extended) provided data, and [[θ ]]pub is an expression
that extracts their public parts (including the plain signa-
tures, excluding lookup tables). The type δ of the ad-
ditional evidence depends on the ﬁrst-pass of the transla-
tion, and is used to drive the second part. In-between, the
ﬁnal value H : hash is ﬁnalized into the global challenge
c : num. The last line assembles the message passed from
the prover to the veriﬁer, which consists of (1) the public
parts of the input data and of the result; (2) the additional
evidence for proving this result; and (3) the global chal-
lenge for verifying this proof.
Veriﬁer Translation Also following the shared trans-
lation, the prover translation leaves the public parts of
the query unchanged, and it incrementally re-computes
the challenge using the responses and additional evi-
dence prepared by the prover for the private parts of the
query. Figure 7 gives the compositional translation ap-
plied to the result of the shared translation, and the top-
level translation [[ ]]VERIFIER. In combination, the veriﬁer
is deﬁned as V (cid:28)= [[ [[θ (cid:26) e]] ]]VERIFIER.
Compositional translation [[ ]]v In the veriﬁcation pass,
H is the public hash incrementally re-computing the
global challenge, a is the received evidence consumed
by the veriﬁer, and every private variable x is replaced
with a (public) response variable rx—the type translation
[[ρ]]v performs this replacement. In combination with the
shared translation, every private source expression now
yields a tuple of the form rx,rox,Cx where rx and rox are
(presumably) responses associated with the exponents
committed to Cx.
(Again, all these values are actually
optional in the compiler.)

The veriﬁer expression [[e]]v takes free variables H
and a, and additionally returns the updated H and the rest
of a. Public expressions are unchanged. Private expres-
sions are discarded, and replaced with response expres-
sions, either computed (for afﬁne expressions) or read

172  22nd USENIX Security Symposium 

USENIX Association

10

off the evidence a (for more complex expressions). Note
that the translation of afﬁne expressions includes a term
−c∗ a0 for the constant, to ensure that, given correct re-
sponses for its free variables, the translation of an expres-
sion also produces a correct response.

Assertions of equations of the form eP = ex are trans-
lated to hash computations, by computing the expression
(eP)c ∗ er, where er is obtained from ex by replacing ev-
ery variable x with rx, and by extending H with the result.
Declassiﬁcations ↓ x are similarly translated by reading x
off the evidence a and extending the hash with gx+c∗rx.
For instance, continuing with the discriminant query,

the (simpliﬁed) veriﬁer translation [[[[ρ]] (cid:28) [[ed]]]]v is

let rp,ro(cid:27),rop, Cp, d, a = a in
let H = extend H ((Cz)rz ∗G g−rp ∗G h−ro(cid:27) ) in
let H = extend (extend H Cp) ((Cp)c∗G grp ∗G hrop ) in
let rd = rp − 4 ∗ x ∗ ry in
let H = extend (extend H gd) ((gd)c ∗G grd ) in
(H, a ,d)

Top-Level Veriﬁer We ﬁnally give below the top-level
veriﬁer translation, also for our sample discriminant
query; see Figure 7 for additional details.

x, Cy, σy, Cz, σz, a, c →
verify vky Cy σy;
verify vkz Cz σz;
let H = extend (extend H0 Cy) Cz
let rz, roz, a = a in
let H = extend H Cc
let H, a, d = [[[[θ ]] (cid:28) [[e]]]]v in // translation detailed above
check c = ﬁnalize H;
d

z ∗G hroz in

z ∗G gr

The prover ﬁrst veriﬁes the signatures on the two re-
ceived commitments for y and z; it starts the challenge
re-computation on the representation equation for input z
(since we need a response for z an oz to check the proof
of the square z2), then proceeds with the veriﬁcation for
the query expression; it checks that the received and re-
computed challenges match; it ﬁnally returns the public
result d (unless of course verify or check raised an error.)

6 Security Theorems
Consider a well-typed ZQL source query Q (cid:25)= θ →↓ e,
with (cid:31) input variables θ = (xi : τi)i=0..(cid:31)−1, that declassi-
ﬁes only its result and its translation (S, (Ki, Di)i=0..(cid:31)−1,
P, V). We give our main results based on the deﬁnitions
of §3. We refer to the full paper for the proof outlines,
and for a discussion of automated, type-based veriﬁca-
tion for the compiled protocols. For functional correct-
ness and soundness, we also suppose that there is no
source-program overﬂow—formally, integers and their
operations are computed modulo q.

Theorem 1 (Functional Correctness)
(S, (Ki, Di)i=0..(cid:31)−1, P, V) is correct.

Theorem 2 (Perfect Privacy)
(S, (Ki, Di)i=0..(cid:31)−1, P, V) is (t,0)-private.

Our soundness theorem below is in the random-oracle
model, requiring that extend and ﬁnalize are indepen-
dent random oracles. It assumes that the Discrete Loga-
rithm (DL) and Strong Difﬁe Hellman (SDH) assump-
tions hold—to guarantee the security of commitments
and CL signatures, respectively—and assuming that the
(cid:31)CMA conventional signatures primitives of data-sources
are chosen message attack secure (CMA).

is

Theorem 3 (Computational Soundness)
(t,ε)-sound, where the
(S, (Ki, Di)i=0..(cid:31)−1, P, V)
execution time t and success probability ε are respec-
tively lower- and upper-bounded by the corresponding
parameters of the assumptions.

Concretely, let tDL, tSDH, tCMA and εDL, εSDH, εCMA
be those parameters, for large enough bounds on the
number of calls to their primitives. If t < tCMA − tred1,
t < (tDL − tred2)/2, and t < (tSDH − tred3)/2, where the
then ε < (cid:31)CMA · εCMA + Q ·
tredi are small constants,
(cid:31)εDL + ((cid:31)− (cid:31)CMA)· εSDH + Q2/q, where Q is the num-
ber of random oracle queries made by A and q is the
order of G and thus also the size of the challenge.

In contrast with our privacy theorem, which is
information-theoretic, our concrete-security soundness
theorem is somewhat more cumbersome than the asymp-
totic security theorems often found in theoretical cryp-
tography, but it remains closer to reality, in which cryp-
tographic primitives come with concrete security bounds,
and thus provides guidance for conﬁguring these primi-
tives to achieve adequate security.

7 ZQL applications
The expressivity of ZQL stems from the ease with which
the primitive operators can be composed to build larger
queries. We illustrate this by providing queries for appli-
cations in prior literature.

In the setting of smart metering, a meter issues signed
private readings, and a household needs to compute their
bill on the basis of a public tariff policy that maps each
reading to a fee over time. A number of custom privacy
protocols have been proposed to do this [55, 48]. One
such billing policy takes a table of public times and pri-
vate readings, as well as a lookup table from readings to
prices to be summed:
let smart meter bill
(R: (int pub ∗ int) table) // time, reading
(T: (int ∗ int) lookuptable) = // reading, fee
↓ (sum ((time, reading) →lookup reading T) R)

The query looks up the non-linear price of each reading
in the table T using lookup and sums the results.

USENIX Association  

22nd USENIX Security Symposium  173

11

Another popular application in the literature involves
pay-as-you-drive insurance schemes. Such schemes re-
quire drivers to ﬁt a black box in their car that records
their driving habits, and allow the insurer to compute a
premium based on the safety of the driving, as well as
distance or time. The use of zero-knowledge protocols
to support such automotive settings, including road us-
age billing and tolling has been well established in the
literature [5, 61, 44].

An example policy used by a UK auto insurance pi-
lot scheme involves recording the segment of road trav-
elled, the distance and the speed and use those to sub-
tract “points” from a virtual driving license. Points are
linked to the magnitude of speed violations on the road
segments travelled. The insurance rate per mile is then
computed as a function of the points subtracted, up to
a threshold where the insurance becomes invalid. We
can express such a policy in ZQL using a table for the
recorded road segments used, and lookup tables to en-
code the speed limit of road segments, the penalty points
per magnitude of violation, and ﬁnally the insurance pre-
mium for a certain number of points:

let pay as you go
(Segments : (int ∗ int ∗ int ∗ int) table)
(Limits : (int ∗ int) lookuptable )
(Penalties : (int ∗ int) lookuptable )
(Rates : (int ∗ int) lookuptable ) =
let points =
sum ((time, road, speed, miles) →

let limit = lookup road Limits
lookup (speed − limit) Penalties) Segments

let rate = lookup points Rates
let miles =
sum ((time, road, speed, miles) →miles) Segments
↓ (miles ∗ rate)

The pay as you go application makes extensive use of
lookup tables to simulate traditional database half-joins
between tables. The values of these tables are largely ar-
bitrary and related to the insurance policy. We note that
to fully secure this insurance mechanism, some informa-
tion about the start and end times of the segments must
also be signed by the black box and veriﬁed to avoid ma-
licious replays or omissions. We also note that, depend-
ing on policies, the query leaks information from indi-
vidual secret inputs to the computed premium. Securing
against source query leakage is beyond the remit of ZQL,
but could be achieved by adapting differentially private
schemes [36].

The ﬁnal example illustrates how ZQL lookups can be
used to approximate functions on real numbers. A very
common problem in privacy preserving protocols for lo-
cation based services is to prove that the reading from a
trusted sensor is at a certain distance from a speciﬁc loca-
tion. For example privacy friendly theft prevention sys-
tem may need to periodically prove that a trusted reading

is within a certain distance from their (secret) home lo-
cation [56]. Similar protocols can be of use for offender
monitoring, curfew enforcement or tracking of trucks of
goods. Previous work has proposed zero-knowledge dis-
tance protocols, such as [15].

The gps distance protocol takes as secret inputs the
longitude and latitude of two points, as well as some
precomputed tables, and returns an approximation of the
distance between the two points in meters. The approxi-
mation used works for small distances under the assump-
tion that the curvature of the earth is negligible. It still
requires the computation of the trigonometric function
cos(x/2). To achieve this, we assume the input longitude
and latitudes are in the units rad/105, and that interme-
diate computations are precise to two decimal points.
let gps distance (lat1: int) (lon1: int) (lat2: int) (lon2: int)

(hcos: (int ∗ int) lookuptable )
(red: (int ∗ int) lookuptable)
(dist: (int ∗ int) lookuptable) =

let latsum = lat1 + lat2
// Table: hcos(x) = round(cos((x)/2· 105)· 102)
let hc = lookup latsum hcos
let dlat = lat2 − lat1
let dlon = lon2 − lon1
let lon cos = dlon ∗ hc
// Table: red(x) = round(x/102)in(rad/105)2
let r2 = lookup lon cos red
let squares = dlat∗dlat + r2
// Table: dist(x) =round( √x· R/105)
// where R is earth’s radius (meters).
↓ (lookup squares dist)

In this example, lookups are used to approximate real
functions, including trigonometric functions and division
which is not yet natively supported. The hcos table has a
large domain (∼ 1 million items) but can be reused across
multiple operations. Other tables have a relatively small
domain related to the distances of the points compared.

8 Discussion

Prototype implementation & limitations Our com-
piler uses the language development and testing facili-
ties of F#: we program source queries as (a small sub-
set of) F#, then extract the ZQL abstract syntax tree
(AST) through reﬂection. The compilation pipeline per-
forms ZQL type-checking, applies the shared translation,
and ﬁnally produces the data-source, prover and veriﬁer
code. Each of these steps operates on well-typed ZQL
expressions. This enables us to share many optimizations
as ZQL-to-ZQL transformations.

Besides standard optimizations, the compiler supports
a more general variant of lookup primitive, named ﬁnd,
that returns any lookup-table row that meets a condition
expressed as a boolean expression on the whole content

174  22nd USENIX Security Symposium 

USENIX Association

12

of the row. This provides more ﬂexibility on the use of
lookup tables, but its compilation is more complex.

In addition to cryptographic code, ZQL also synthe-
sizes a custom marshaller and un-marshaller for the cryp-
tographic evidence and results of the query. Following
the ZQL approach, this code is specialized and compiled
for a speciﬁc proof. Hence, the size and location of all
ﬁelds, parametrized on the input table lengths, in known
at compile time and there is no need to rely on a general-
purpose parser, a component that is traditionally a source
of security ﬂaws.

We support three distinct compiler back-ends:

Concrete F# The main branch of the compiler trans-
forms and compiles the ﬁnal ZQL data source, prover
and veriﬁer into F# code, linked either to the standard
.NET big integer libraries, or to proprietary managed li-
braries that support pairing based cryptography.
Symbolic F# The second branch of the compiler is
linked against symbolic execution libraries for all the op-
erators and primitives. Interestingly, since the F# branch
makes extensive use of abstract types in the ﬁnal prover
and veriﬁer, there is no need to write a separate symbolic
execution environment: the mathematical functions can
simply be replaced with equivalents computing on sym-
bolic polynomials. The resulting code jointly computes
the execution time and the proof size, as polynomial ex-
pressions of the input lengths and the unit costs of each
cryptographic operation. We use symbolic execution to
predict the performance of the compiler, and hope to use
it in the future to chose between alternative optimization
strategies at compile time.
Concrete C++ Finally, we support compilation of the
veriﬁer to native C++ code, linked with high perfor-
mance native big integer libraries. This branch in-
volves transforming the functional ZQL veriﬁer and un-
marshaller code into an imperative program and optimiz-
ing it using standard low-level techniques such as remov-
ing dead code, removing spurious copies, and minimiz-
ing memory re-allocations. The resulting native program
takes a proof as an input, and outputs the veriﬁed result.
The native branch does not support on-the-ﬂy compila-
tion and execution, and currently works for RSA groups
only. Yet the resulting binary can be easily deployed
where .NET runtimes are not available.

The process of compiling a query remains fast even on
small devices. Thus, a service could simply send ZQL
queries to the user, to be reviewed, compiled, then ex-
ecuted locally. To this end, our compiler also has an
API that takes source ZQL ASTs, compiles them to F#,
then also compiles and dynamically load the resulting F#
code. This is likely to be faster, cheaper, safer and more
reliable than providing custom binaries every time the
query is updated.

The prototype compiler is still subject to limitations.
For instance, some optimizations, such as moving de-
classiﬁcations up in the dataﬂow to minimize the size of
the Σ-protocol, or batching some exponential computa-
tions, could be systematically applied.
Performance Evaluation Table 1 illustrates the per-
formance of ZQL code for the three applications pre-
sented in Section 7. It provides the execution time for the
F# provers and veriﬁers, as well as the size of the proof,
for different security parameters of RSA (1024 bits, 2048
bits) and the pairing based cryptography over a 254 bits
Barreto-Naehrig curve (BN254). The smart meter bill
readings table is of size (cid:31)read = 5 and the pay as you go
query road segments table is of size (cid:31)seg = 25. This
means that for the 1024 bit RSA branch, the prover can
process a meter reading every ∼ 120mS or a segment
of road every ∼ 360mS. The proof size for the pair-
ing based branch is ∼ 755 bytes per reading and ∼ 1921
bytes per segment. As expected, the pairing based proofs
are more compact than their RSA counterparts for the
same or even higher levels of security: a 254 bits curve
provides about 128 bits of security which would corre-
spond to a 3072 bits RSA modulus.1 This is further ag-
gravated by the lack of tightness in RSA-based security
reductions [8]. Prover timings take into account the gen-
eration of random numbers. We note that these numbers,
while slow by the standards of non-privacy friendly com-
putation, are perfectly adequate for computing bills and
insurance premiums in real time.

Besides the main F# backend we experimented with
a C++ back-end that compiles to a native veriﬁer. Al-
though more performant in absolute terms, the native
veriﬁer is not signiﬁcantly faster than its F# counterpart.
The RSA 1024 bit computation of the pay as you go ver-
iﬁer took 4,290mS as compared with the F# backend us-
ing native big integer binding that took 5,111mS. Pro-
ﬁling the C++ execution indicates that more than 90%
of the time is spent inside the modular multiplication
function performing exponentiations. Thus, improving
the performance of ZQL comes down to either faster ex-
ponentiations (through batching, multi-exponentiation or
hardware) or reducing the number of operations required
through more aggressive simpliﬁcation of the protocols.
Finally, table 1 illustrates the output of the symbolic
execution engine on these three applications, in a conﬁg-
uration that measures the number of exponentiations (E),
pairings ( ˆe), and signature veriﬁcation operations (sigv)
in terms of the length of the input tables ((cid:31)read and (cid:31)seg),
and ignore all other costs.
Where next? The current ZQL language is subject to
some intrinsic limitations, and we are actively exploring
options to overcome them.

1http://www.cryptopp.com/wiki/Security_Level

USENIX Association  

22nd USENIX Security Symposium  175

13

Examples (branch)
smart meter bill (1024)
smart meter bill (2048)
smart meter bill (BN254)

smart meter bill (symbolic)

pay as you go (1024)
pay as you go (2048)
pay as you go (BN254)

pay as you go (symbolic)

gps dist (1024)
gps dist (2048)
gps dist (BN254)

gps dist (symbolic)

prover (mS)
586
3,498
1,374
E + 16· E· (cid:30)read+
6· (cid:30)read · ˆe
5,314
32,442
8,305
15· E + 40· E· (cid:30)seg+
12· (cid:30)seg · ˆe + 6· ˆe
501
3,017
841
60· E + 18· ˆe

veriﬁer (mS)
599
3,148
2,092
6· E + 14· E· (cid:30)read+
8· (cid:30)read · ˆe + sigv
5,111
30,859
12,261
29· E + 35· E· (cid:30)seg+
16· (cid:30)seg · ˆe + 8· ˆe + sigv
529
2,889
1,253
71· E + 24· ˆe + 4· sigv

proof size (Bytes)
6,106
10,585
3,773
67 +|h| +|sig| + 2· (cid:30)Ga+
(cid:30)Ga · (cid:30)read + 22· (cid:30)read+
2· (cid:30)read · q + num + 7· q
57,368
100,099
28,819
167 +|h| +|sig| + 6· (cid:30)Ga+
4· (cid:30)Ga · (cid:30)seg + 56· (cid:30)seg+
8· (cid:30)seg · q + num + 23· q
5044
8629
2751
233 +|h| + 4·|sig|+
10· (cid:30)Ga + 33· q

Table 1: Performance for our three applications: runtime, and communicated proof sizes. The smart meter bill readings table is
of size (cid:30)read = 5, the pay as you go query road segments table is of size (cid:30)seg = 25, the gps distance is between two points.

Many of the limitations are cryptographic and could
be overcome by applying more advanced protocols. For
example, lookup and ﬁnd are currently restricted to ex-
ternally signed tables. Lookup tables based on accumu-
lators [13] or vector commitments [27] would be more
ﬂexible and may reduce cost. At a lower level, table
processing leads to many similar cryptographic opera-
tions in a data-parallel style. Batch proof and veriﬁcation
techniques and homomorphic signature schemes could
speed them up [10]. Well known, zero-knowledge proofs
for disjunctions, would allow ZQL branching statements.
The shared translation could bundle multiple secrets per
commitment. Alternatively one could also employ com-
pletely different low-level proof engines, e.g., [53]. We
note that choosing automatically the best encoding and
technique, as well as compiling them in a compositional
manner are challenging open problems. For some pre-
liminary work in this direction see [41].

On the language design side, we illustrated in §7 how
functions can be approximated though lookups. ZQL
could automate and optimize the process by compiling
data sources that calculate and sign function-tables ap-
propriately. Finally, by design, our source language
shields programmers from cryptography, and this may
hinder power-users that wish to customize our compila-
tion scheme, or experiment with its variants. Similarly,
some users may wish to rely on external, unveriﬁed pro-
cedures, and use ZQL only to validate their results. Ad-
vanced APIs exposing the internals of the ZQL compiler
without breaking its invariants would help them.
Acknowledgments The authors would like to thank
Ian Goldberg for early discussions of languages for zero-
knowledge proofs and the advantages of compilation ver-
sus interpretation, and Nikhil Swamy for his comments.

References

[1] J. A. Akinyele, M. D. Green, and A. D. Rubin. Charm: A frame-
work for rapidly prototyping cryptosystems. Cryptology ePrint
Archive, Report 2011/617, 2011.

[2] J. B. Almeida, M. Barbosa, E. Bangerter, G. Barthe, S. Krenn,
and S. Z. B´eguelin. Full proof cryptography: veriﬁable compi-
lation of efﬁcient zero-knowledge protocols.
In ACM Confer-
ence on Computer and Communications Security, pages 488–
500, 2012.

[3] M. H. Au, W. Susilo, and Y. Mu. Constant-size dynamic k-TAA.
In R. D. Prisco and M. Yung, editors, SCN 2006, volume 4116 of
LNCS, pages 111–125, Maiori, Italy, 2006. Springer.

[4] M. Backes, M. Maffei, and K. Pecina. Automated synthesis of
privacy-preserving distributed applications. 19th Annual Network
& Distributed System Security Symposium (NDSS12), 2012.

[5] J. Balasch, A. Rial, C. Troncoso, B. Preneel, I. Verbauwhede, and
C. Geuens. PrETP: Privacy-preserving electronic toll pricing. In
USENIX Security Symposium, pages 63–78, 2010.

[6] E. Bangerter, J. Camenisch, and U. M. Maurer. Efﬁcient proofs
of knowledge of discrete logarithms and representations in groups
with hidden order. In Public Key Cryptography, pages 154–171,
2005.

[7] E. Bangerter, T. Briner, W. Henecka, S. Krenn, A.-R. Sadeghi,
and T. Schneider. Automatic generation of sigma-protocols. In
EuroPKI, pages 67–82, 2009.

[8] E. Bangerter, S. Krenn, A.-R. Sadeghi, T. Schneider, and J.-
K. Tsay. On the design and implementation of efﬁcient zero-
knowledge proofs of knowledge. ECRYPT workshop on Soft-
ware Performance Enhancements for Encryption and Decryption
and Cryptographic Compilers (SPEED-CC ’09), 2009.

[9] E. Bangerter, S. Krenn, A.-R. Sadeghi, and T. Schneider. Yaczk:
Yet another compiler for zero-knowledge. In USENIX Security
Symposium, 2010.

[10] S. Bayer and J. Groth. Efﬁcient zero-knowledge argument for
correctness of a shufﬂe. In EUROCRYPT, pages 263–280, 2012.
[11] M. Bellare and O. Goldreich. On deﬁning proofs of knowledge.

In CRYPTO, pages 390–420, 1992.

[12] M. Bellare and P. Rogaway. Random oracles are practical: A
paradigm for designing efﬁcient protocols. In ACM Conference
on Computer and Communications Security, pages 62–73, 1993.
[13] J. C. Benaloh and M. de Mare. One-way accumulators: A de-
centralized alternative to digital sinatures (extended abstract). In

176  22nd USENIX Security Symposium 

USENIX Association

14

EUROCRYPT, pages 274–285, 1993.

[14] J. Bengtson, K. Bhargavan, C. Fournet, A. D. Gordon, and
S. Maffeis. Reﬁnement types for secure implementations.
In
21st IEEE Computer Security Foundations Symposium (CSF’08),
pages 17–32, 2008.

[15] T. S. Benjamin. Zero-knowledge protocols to prove distances.

Personal communication, 2008.

[16] K. Bhargavan, C. Fournet, and A. D. Gordon. F7: reﬁnement

types for F#, 2008. Microsoft Research Technical Report.

[17] D. Boneh, X. Boyen, and H. Shacham. Short group signatures.

In CRYPTO, pages 41–55, 2004.

[18] S. Brands. Rapid demonstration of linear relations connected by

boolean operators. In EUROCRYPT, pages 318–333, 1997.

[19] T. Briner. Compiler for zero-knowledge proof-of-knowledge pro-
tocols. Master thesis, ETH Zurich & IBM Research Lab Zurich,
2004.

[20] J. Camenisch and A. Lysyanskaya. A signature scheme with efﬁ-

cient protocols. In SCN, pages 268–289, 2002.

[21] J. Camenisch and A. Lysyanskaya. Signature schemes and anony-
mous credentials from bilinear maps. In CRYPTO, pages 56–72,
2004.

[22] J. Camenisch and M. Stadler. Efﬁcient group signature schemes
for large groups. In B. Kaliski, editor, Advances in Cryptology —
CRYPTO ’97, volume 1296 of LNCS, pages 410–424. Springer
Verlag, 1997.

[23] J. Camenisch and E. Van Herreweghen. Design and implementa-
tion of the idemix anonymous credential system. Technical Re-
port Research Report RZ 3419, IBM, May 2002.

[24] J. Camenisch, A. Kiayias, and M. Yung. On the portability of
In EUROCRYPT, pages 425–442,

generalized schnorr proofs.
2009.

[25] J. Camenisch, M. Kohlweiss, and C. Soriente. Solving revocation
with efﬁcient update of anonymous credentials. In SCN, pages
454–471, 2010.

[26] J. L. Camenisch. Group Signature Schemes and Payment Sys-
tems Based on the Discrete Logarithm Problem. PhD thesis, ETH
Z¨urich, 1998. Diss. ETH No. 12520, Hartung Gorre Verlag, Kon-
stanz.

[27] D. Catalano and D. Fiore. Vector commitments and their appli-

cations. Cryptology ePrint Archive, Report 2011/495, 2011.

[28] D. Chaum and T. P. Pedersen. Wallet databases with observers.

In CRYPTO, pages 89–105, 1992.

[29] E. F. Codd. A relational model of data for large shared data banks.

Commun. ACM, 13(6):377–387, 1970.

[30] R. Cramer. Modular Design of Secure yet Practical Crypto-
graphic Protocols. PhD thesis, University of Amsterdam, 1997.
[31] R. Cramer and I. Damg˚ard. Zero-knowledge proofs for ﬁnite ﬁeld
In CRYPTO,

arithmetic; or: Can zero-knowledge be for free?
pages 424–441, 1998.

[32] R. Cramer, I. Damg˚ard, and B. Schoenmakers. Proofs of partial
knowledge and simpliﬁed design of witness hiding protocols. In
CRYPTO, pages 174–187, 1994.

[33] I. Damg˚ard. On Σ-protocols, 2002. Available at http://www.

daimi.au.dk/~ivan/Sigma.ps.

[34] I. Damg˚ard and E. Fujisaki. An integer commitment scheme
IACR Cryptology ePrint

based on groups with hidden order.
Archive, 2001:64, 2001.

[35] G. Danezis and B. Livshits. Towards ensuring client-side compu-

tational integrity. In CCSW, pages 125–130, 2011.

[36] G. Danezis, M. Kohlweiss, and A. Rial. Differentially private
In Information Hiding, pages 148–162,

billing with rebates.
2011.

[37] C. Dwork. Differential privacy: A survey of results. Theory and

Applications of Models of Computation, pages 1–19, 2008.

[38] U. Feige and A. Shamir. Witness indistinguishable and witness

hiding protocols. In STOC, pages 416–426, 1990.

[39] U. Feige, A. Fiat, and A. Shamir. Zero knowledge proofs of iden-

tity. In STOC, pages 210–217, 1987.

[40] A. Fiat and A. Shamir. How to prove yourself: Practical solutions
to identiﬁcation and signature problems. In CRYPTO, pages 186–
194, 1986.

[41] M. Fredrikson and B. Livshits. Z0: An optimizing distributing

zero-knowledge compiler. 2013. MSR Technical report.

[42] T. Freeman and F. Pfenning. Reﬁnement types for ML.

In
Programming Language Design and Implementation (PLDI’91),
pages 268–277. ACM, 1991.

[43] E. Fujisaki and T. Okamoto. Statistical zero knowledge protocols
to prove modular polynomial relations. In CRYPTO, pages 16–
30, 1997.

[44] F. D. Garcia, E. R. Verheul, and B. Jacobs. Cell-based roadpric-

ing. In EuroPKI, pages 106–122, 2011.

[45] I. Goldberg. Natural zero-knowledge embedding in c++. Personal

communication, October 2011.

[46] O. Goldreich, S. Micali, and A. Wigderson. How to prove all
np-statements in zero-knowledge, and a methodology of crypto-
graphic protocol design. In CRYPTO, pages 171–185, 1986.

[47] S. Goldwasser, S. Micali, and C. Rackoff. The knowledge com-
plexity of interactive proof systems. SIAM J. Comput., 18(1):
186–208, 1989.

[48] M. Jawurek, M. Johns, and F. Kerschbaum. Plug-in privacy for

smart metering billing. In PETS, pages 192–210, 2011.

[49] D. Malkhi, N. Nisan, B. Pinkas, and Y. Sella. Fairplay - a secure
two-party computation system. In USENIX Security, pages 287–
302, 2004.

[50] U. M. Maurer. Unifying zero-knowledge proofs of knowledge.
In B. Preneel, editor, AFRICACRYPT, volume 5580, pages 272–
286. Springer, 2009.

[51] S. Meiklejohn, C. C. Erway, A. K¨upc¸ ¨u, T. Hinkle, and A. Lysyan-
skaya. ZKPDL: A language-based system for efﬁcient zero-
knowledge proofs and electronic cash. In USENIX Security Sym-
posium, pages 193–206, 2010.

[52] T. Okamoto. Provably secure and practical identiﬁcation schemes
and corresponding signature schemes. In CRYPTO, volume 740,
pages 31–53. Springer, 1992.

[53] B. Parno, C. Gentry, J. Howell, and M. Raykova. Pinocchio:
Nearly practical veriﬁable computation. In IEEE Symposium on
Security and Privacy, 2013.

[54] T. P. Pedersen. Non-interactive and information-theoretic secure
veriﬁable secret sharing. In CRYPTO ’92, volume 576 of LNCS,
pages 129–140, 1992.

[55] A. Rial and G. Danezis. Privacy-preserving smart metering. In

WPES, pages 49–60, 2011.

[56] T. Ristenpart, G. Maganis, A. Krishnamurthy, and T. Kohno.
Privacy-preserving location tracking of lost or stolen devices:
Cryptographic techniques and replacing trusted third parties with
dhts. In 17th USENIX Security Symposium, pages 275–290, 2008.
[57] C.-P. Schnorr. Efﬁcient signature generation by smart cards. J.

Cryptology, 4(3):161–174, 1991.

[58] N. Swamy, J. Chen, C. Fournet, P.-Y. Strub, K. Bhargavan, and
J. Yang. Secure distributed programming with value-dependent
types. In ICFP, pages 266–278, 2011.

[59] M. Tompa and H. Woll. Random self-reducibility and zero
In

knowledge interactive proofs of possession of information.
FOCS, pages 472–482, 1987.

[60] C. Troncoso, G. Danezis, E. Kosta, and B. Preneel. PriPAYD:
privacy friendly pay-as-you-drive insurance. In P. Ning and T. Yu,
editors, WPES, pages 99–107. ACM, 2007.

[61] C. Troncoso, G. Danezis, E. Kosta, J. Balasch, and B. Preneel.
IEEE

Pripayd: Privacy-friendly pay-as-you-drive insurance.
Trans. Dependable Sec. Comput., 8(5):742–755, 2011.

[62] H. Wee. Zero knowledge in the random oracle model, revisited.

In ASIACRYPT, pages 417–434, 2009.

USENIX Association  

22nd USENIX Security Symposium  177

15

First stage:

[[x : τ,ρ]]1 = x : τ, [[ρ]]1 when x public (including all group elements)
[[x : τ,ρ]]1 = x : τ,tx : x witness, [[ρ]]1 when x private int or num

[[Γ (cid:31) e]]1 = H,a,e
[[Γ (cid:31) e]]1 = let C = e in extend H C, (a,C),C
i=1 ai ∗txi

i=1 ai ∗ xi]]1 = H,a,a0 + ∑n

i=1 ai ∗ xi,∑n

[[Γ (cid:31) a0 + ∑n

when the xi are private and the ai public:
(Γ(ai) =pub num) i=0..n, (Γ(xi) =num) i=1..n

when e public expression, that is, whose variables are all public in Γ.

when Γ (cid:31) e : eltG and e is not public

[[Γ (cid:31) e]]1 = let a,ρ = e in (let txi = random() in )xi

H, (a, [[ρ]]1), [[ρ]]1

when Γ (cid:31) e : ρ non-linear private expression (including assoc, random, opening...)
and xi ranges over the private variables bound in ρ

[[Γ (cid:31) assert eC =G ex]]1 = extend H et ,a,ε

[[Γ (cid:31)↓ x]]1 = let a = a,x in extend (extend H gx) gtx ,a,x
[[Γ (cid:31) let ρ = e in e0]]1 = let H,a, [[ρ]]1 = [[Γ (cid:31) e]]1 in [[Γ,ρ (cid:31) e0]]1

when eC public and ex algebraic on private exponents

Second stage:

[[δ ,ρ]]2 = let a, [[ρ]]1 = a in [[δ ]]2, [let rx = tx − c∗ x in ]x [[ρ]]v
where x ranges over the private variables bound in ρ

[[δ ,δ(cid:27) table]]2 = let a,A = a in [[δ ]]2,map (δ(cid:27) → [[δ(cid:27)]]2) A

[[ε]]2 = ε

[[θ → e]]PROVER = [[θ ]]D →let H = H0 in let a = () in

// hash and prove commitments for all private inputs (omitted)
let H : hash,a : δ ,r = [[θ (cid:31) e]]1 in
let c = ﬁnalize H in
[[θ ,r]]pub, [[δ ]]2,c

Figure 6: Prover Translation (see full paper for map and fold)

[[x : τ,ρ]]v = x : τ, [[ρ]]v when x public (including all group elements)
[[x : τ,ρ]]v = rx : (c,x) response, [[ρ]]v when x private

[[Γ (cid:31) e]]v = H,a,e
[[Γ (cid:31) e]]v = let C,a = a in extend H C,a,C

[[Γ (cid:31) a0 + ∑n

i=1 ai ∗ xi]]v = H,a,−c∗ a0 + ∑n

i=1 ai ∗ rxi

when the xi are private and the ai public:
(Γ(ai) =pub num) i=0..n, (Γ(xi) =num) i=1..n

when e public expression, that is, whose variables are all public in Γ.

when Γ (cid:31) e : eltG and e is not public

[[Γ (cid:31) e]]v = let a, [[ρ]]v = a in H,a, [[ρ]]v

when Γ (cid:31) e : ρ non-linear private-exponent expression (including assoc, random, opening...)
and ρ binds private exponents and public elements

[[Γ (cid:31) assert eC =G ex]]v = extend H ((eC)c ∗G [[ex]]v),a,ε

[[Γ (cid:31)↓ x]]v = let x,a = a in

extend (extend H gx) gc∗x+rx ,a,x

when ex algebraic on private exponents

[[Γ (cid:31) let ρ = e in e0]]v = let H,a, [[ρ]]v = Γ (cid:31) [[e]]1 in [[Γ,ρ (cid:31) e0]]v

[[θ → e]]VERIFIER = [[θ ,r]]pub(cid:27) ,a,c →

// check plain signatures, hash commitments into H,
// and check commitment proofs for all private inputs (omitted)
let H = H0 in
let H,a,r = [[Γ (cid:31) e]]v in
check c = ﬁnalize H;
r

Figure 7: Veriﬁer Translation (see full paper for map and fold)

16

178  22nd USENIX Security Symposium 

USENIX Association

