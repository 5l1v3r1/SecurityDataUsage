MACE: Detecting Privilege Escalation Vulnerabilities in

Web Applications

Maliheh Monshizadeh

Department of Computer Science

University of Illinois at Chicago

Chicago, IL

mmonsh2@uic.edu

Prasad Naldurg
IBM Research India

Bangalore, India

pnaldurg@in.ibm.com

V. N. Venkatakrishnan

Department of Computer Science

University of Illinois at Chicago

Chicago, IL

venkat@uic.edu

ABSTRACT
We explore the problem of identifying unauthorized privilege es-
calation instances in a web application. These vulnerabilities are
typically caused by missing or incorrect authorizations in the server
side code of a web application. The problem of identifying these
vulnerabilities is compounded by the lack of an access control pol-
icy speciﬁcation in a typical web application, where the only sup-
plied documentation is in fact its source code. This makes it chal-
lenging to infer missing checks that protect a web application’s sen-
sitive resources. To address this challenge, we develop a notion of
authorization context consistency, which is satisﬁed when a web
application consistently enforces its authorization checks across the
code. We then present an approach based on program analysis
to check for authorization state consistency in a web application.
Our approach is implemented in a tool called MACE that uncov-
ers vulnerabilities that could be exploited in the form of privilege
escalation attacks. In particular, MACE is the ﬁrst tool reported
in the literature to identify a new class of web application vulner-
abilities called Horizontal Privilege Escalation (HPE) vulnerabil-
ities. MACE works on large codebases, and discovers serious,
previously unknown, vulnerabilities in 5 out of 7 web applications
tested. Without MACE, a comparable human-driven security audit
would require weeks of effort in code inspection and testing.

Categories and Subject Descriptors
D.2.4 [Software Engineering]: Software/Program Veriﬁcation; D.2.8
[Access Control]: Metrics—Software Engineering,

General Terms
Security Languages

Keywords
Access Control, Web Security, Authorization

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’14, November 3–7, 2014, Scottsdale, Arizona, USA.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-2957-6/14/11 ...$15.00.
http://dx.doi.org/10.1145/2660267.2660337.

1.

Introduction

Web applications are powerful engines that drive modern soci-
eties, as they play a pivotal role in e-commerce, social networking
and ﬁnance. Due to their open nature and wide deployment, they
make appealing targets to criminals who want to gain access to
users’ data and resources. Security of web applications therefore
has become an important concern.

To protect from such threats, web applications implement ac-
cess control (a.k.a. authorization) policies. A typical authorization
check in a web application involves verifying whether a given au-
thenticated user with an associated functional role has the required
privilege to access a given resource such as a database table. Since
authorization is expected to be performed before every resource ac-
cess, it therefore forms the basis for security of the web application.
Several high-proﬁle data breaches were caused due to the au-
thorization errors in web applications. A most notable one is the
Citibank data breach [1], wherein more than 360k credit card num-
bers were stolen. Such breaches suggest that web application au-
thorization errors could be disastrous for organizations. Further-
more, such vulnerabilities appear to be widespread, as a recent
Cenzic technical report [6] listed that authorization vulnerabilities
occurred in 56% of the applications that were tested in the 2013
study.

There are several reasons why such authorization errors are nu-
merous. First, unlike conventional operating systems, web appli-
cations (such as those written using PHP) do not come with built-
in support for access control. The access control policy is often
coded by a developer into the application. Developers often focus
on other key functionalities of the applications, and often make er-
rors in programming authorization code, as illustrated by the 2011
CWE / SANS report [3], in which missing authorization and im-
proper authorization are ranked 6th and 15th in the top 25 most
dangerous software errors. Second, a web application (such as one
written using PHP and SQL) often connects directly to the database
resource as a superuser who enjoys all administrative privileges on
the database, and any ﬂaws in the authorization logic often lead
to catastrophic data breaches. Further, web application develop-
ers often implement roles [16] as a privilege management solu-
tion. However, the unavailability of a standard framework, and the
lack of developer’s knowledge of access control design, have led to
buggy and inconsistent role implementations in applications [24].
The academic and industrial communities have identiﬁed sev-
eral solutions to the problem. Virtual private databases [5] provide
a way for applications to execute queries on behalf of users, and
provide effective privilege separation. Web application frameworks
such as Rails [23] provide software engineering solutions to struc-
ture the access control logic of an application effectively. Despite
these advances, a vast majority of web applications continue to be

690developed in languages such as ASP, Java and PHP where the onus
of developing and enforcing the access control policy largely falls
on developers.

In this landscape, we take a closer look at the problem of iden-
tifying whether an existing web application contains authorization
errors. This vulnerability analysis problem is often a challenge for
open source web applications that come with almost no documenta-
tion (except their code) of their access control policies. It is indeed
possible for a vulnerability analyst to look for errors by understand-
ing the access control policy, inspecting the source for missing au-
thorizations. However, in order to arrive at the access control policy
of the application by studying its source in detail, the manual effort
involved is signiﬁcant and could be time-consuming and tedious for
large web applications. Therefore automated solutions that identify
authorization errors are desirable, and we present one such strong
approach in this paper.

The crux of our approach to vulnerability analysis is rather than
try to uncover the unwritten access control policy of a given ap-
plication, to instead turn our focus towards identifying whether the
application enforces its policy consistently across various resource
accesses. For example, consider a banking web application that
enforces a complex policy based on principals such as managers,
tellers, and customers.
Instead of trying to uncover the applica-
tion’s intended authorizations, we examine if it consistently en-
forces the same authorization rules for accesses to a resource by
the same principal. When such authorization checks are inconsis-
tently checked along two different paths of an application, it is a
strong indication that access control may be incorrect in one, lead-
ing to privilege escalation vulnerabilities and resulting in loss of
sensitive data to outside attackers or malicious insiders.

Our technical approach to ﬁnd authorization inconsistencies in
applications involves deﬁning a notion of authorization context for
web applications that is associated with every program point in the
application. We then develop a notion called authorization context
consistency, which is satisﬁed when the application uses the same
authorization context in order to access the same resource along
different paths of a web application. When there is a mismatch in
authorization contexts along two different paths, we ﬂag that as an
potential access control violation.

We develop algorithms for computing authorization contexts
and checking for authorization context consistency. These algo-
rithms involve a variety of program analysis techniques that in-
clude control ﬂow analysis, data ﬂow analysis and symbolic eval-
uation. These algorithms are implemented in a tool that we call
MACE (Mining Access Control Errors). These algorithms are
bootstrapped by a small set of annotations provided by the vul-
nerability analyst, and we show that the effort for providing these
annotations is small.

Using our approach, we are able to detect two kinds of privilege
the conventional (1) Vertical Privilege
escalation vulnerabilities:
Escalation (VPE) when an attacker (outsider) or a malicious user
(insider) tries to change her privilege level (access more than they
are entitled to, say according to their role) and (2) Horizontal Priv-
ilege Escalation (HPE) when a malicious user tries to access the
system resources of other users. In particular, our modeling of au-
thorization context and our detection algorithms facilitate the detec-
tion of the latter kind of privilege escalation, thus making MACE
the ﬁrst tool in the literature that is capable of identifying HPE vul-
nerabilities in web applications.

Evidence of the usability and usefulness of MACE is demon-
strated by running it against a large number of open-source code-
bases. We test our tool against 7 applications and detect both hor-
izontal and vertical privilege escalations in 5 of them. Without

MACE, a security audit would have to manually inspect hundreds
of thousands of lines of code.

The rest of the paper is organized as follows: Section 2 describes
the problem with a running example. In Section 3, we explain the
key ideas behind our approach, including the notion of the autho-
rization state, as well as computing authorization contexts. We
present implementation details and related challenges in Section
4. Section 5 presents results of our analysis on our testbed of web
applications. Section 6 is related work, and we summarize our con-
tributions in Section 7.

2. Running Example

In this section, we illustrate the key aspects of the authorization
problem for web applications with the help of an extended exam-
ple. The traditional authorization or privilege escalation problem is
tied to the functional role of a user in this context. If this user can
exercise privileges that are not usually associated with their func-
tional role, a vertical privilege escalation vulnerability is detected.
In addition, as described in CWE-639 [2] the horizontal authoriza-
tion problem describes a situation where two users may have the
same role or privilege level, and must be prevented from accessing
each other’s resources.

Listings 1 to 7 present the source of a running example that illus-
trates these authorization vulnerabilities. The example is a simpli-
ﬁed version of real-world code samples analyzed by our tool, and
describes typical vulnerabilities that were discovered. The partic-
ular web application here is a blog that permits its registered users
to insert, edit, delete, or comment on blog articles. There are two
functional roles: admin and user, with the admin having control
over all posts in the blog, whereas the individual users should only
be able to insert, edit, or delete their own blog, and comment on
other blogs.

Listings 1, 2 and 3 refer to a secure implementation of the ap-
plication. Function verifyUser, shown in Listing 1, checks if
the request is coming from an authenticated user. In Listing 2, an
article is being added to the articles table in the database. The
user name of the current logged-in user speciﬁes the owner of the
article, and the request includes the article text that is inserted into
the database. Note that this insert implementation is secure, as the
user is veriﬁed, and is found to have the required permission. List-
ing 3 refers to the delete operation, where the user can delete any
post that she owns. Additionally, an admin user, as speciﬁed by the
role userLevel, can delete all entries in a blog as shown by the
second DELETE operation.

without checking if the user is authorized.

Listings 4, 5, 6 and 7 show example PHP ﬁles that implement
the delete operation. Each implementation of the delete operation
is vulnerable as described below:
• No authorization In Listing 4, the application performs a delete
• Improper permissions.

In Listing 5, the application does not
check if the user has the appropriate permissions to delete an ar-
ticle.
• Improper Delete-all In Listing 6, the application does not check
if the user trying to delete-all belongs to the Admin role, and
therefore permits a privilege escalation attack.
• Improper Delete In Listing 7, the application does not check
whether the user requesting the delete is the owner of the article,
and is authorized to delete it. It therefore allows the currently
logged in user to delete articles owned by any other user in the
system, as long as the (public) article-ID is supplied as query
argument.

6911
2
3
4
5
6

1
2
3
4
5
6

1
2
3
4

5
6

7

2.a
3.a

1.b
2.b
3.b

1.c
...
6.c
7.c

1.d
2.d
3.d

The last two examples in the above list deserve special mention.
Listing 6 is the conventional form of privilege escalation allowing
an ordinary user to assume admin privileges, i.e., vertical privilege
escalation (VPE). In contrast, Listing 7 allows for an ordinary user
to assume privileges of any other ordinary user in the system, a
form of privilege escalation known as horizontal privilege escala-
tion (HPE) [4]. To the best of our knowledge, this paper is the ﬁrst
to discuss an approach for detecting HPE vulnerabilities automati-
cally, in addition to detecting VPEs.
function verifyUser(){

if(!isset($_SESSION[’userID’]))

header(’Location: /login.php’);

else $userID = $_SESSION[’userID’];
return;

}

Listing 1: verifyUser.php

verifyUser();
if($permission[’canWrite’]&&$action == ’insert’)

query("INSERT INTO tbl_articles VALUES (
sanit($_GET[’article_code’]),
$_SESSION[’userID’],
sanit($_GET[’article_msg’]))");

Listing 2: insert.php

verifyUser();
if($permission[’canWrite’]&&$action==’delete’)

query("DELETE FROM tbl_articles WHERE
article_ID = ’" + sanit($_GET[’article_ID’]) + "’

and

author_ID = ’" + $userID + "’");

else if($_SESSION[’userLevel’] == ’Admin’ && $action ==

’deleteAll’)

query("DELETE FROM tbl_articles");

Listing 3: delete.php

if($action == ’delete’)

query("DELETE FROM tbl_articles WHERE article_ID =

’" + sanit($_GET[’article_ID’]) + "’");

Listing 4: delete1.php (vulnerable version)

verifyUser();
if($action == ’delete’)

query("DELETE FROM tbl_articles WHERE article_ID =

’" + sanit($_GET[’article_ID’]) + "’");

Listing 5: delete2.php (vulnerable)

verifyUser();
...
if($permission[’canWrite’] && $action == ’deleteAll’)

query("DELETE FROM tbl_articles");

Listing 6: delete3.php (vulnerable)

verifyUser();
if($permission[’canWrite’] && $action == ’delete’)

query("DELETE FROM tbl_articles WHERE article_ID =

’" + sanit($_GET[’article_ID’]) + "’");

Listing 7: delete4.php (vulnerable)

Lack of Policy Speciﬁcation Note that our techniques are designed
to work directly on the source code of our target applications, with-
out relying on the existence of a well-articulated policy manifest to
clarify these functional roles. In order to know whether the web
application is implementing its access control correctly, one needs
to know what access control policy is implemented. Unfortunately,
the only documentation of this policy is in fact the source code of
the web application. Furthermore, we also face the problem that

this policy implementation can be incomplete or incorrect. This
makes the problem of checking for access control errors quite chal-
lenging.

3. Approach

To reason about a web application’s authorization correctness,
one must examine each sensitive operation (e.g. each SQL query
execution) of the program and examine the authorization informa-
tion required to perform that operation. Recall from Section 2,
the running example identiﬁes what can go wrong in the imple-
mentation of access control, including the absence of any autho-
rization checks, improper ownership or privileges corresponding to
user role, and untrusted session variables.

Authorization state Applications should ideally have a well-
deﬁned policy manifest of what authorizations should be granted
to what users, taking into account the session context, but unfortu-
nately this is not always explicit. Even in applications that manage
to have policy documents, the implementation may not match the
speciﬁcation. The best understanding of access policy therefore
is the operating context of each access request in the implementa-
tion. For each access request in a user session, corresponding to
a particular control and dataﬂow in the program execution, we ar-
gue that the four tuple (cid:104)U,R,S,P(cid:105) represents the associated access
control rule explicitly, with U the set of authenticated users, R the
set of roles deﬁned over the users, capturing different authoriza-
tions, S the set of session identiﬁers or session variables, and P the
permissions deﬁned on the resources (e.g., read, write). This
set (cid:104)U,R,S,P(cid:105) is our authorization state. We illustrate this in our
running example:
• In Listing 4 the identity of user is not checked. The value of
$action (i.e., delete) comes from the input form and therefore
is controllable by the user, and cannot be trusted. We infer that
the access rule checked here is (cid:104)−,−,−,−(cid:105), which means any
user in any role can actually execute this DELETE query provid-
ing any article if they know the corresponding article_id, which
is a placeholder for session context.
the following access rule is being checked
(cid:104)user,non_admin,−,−(cid:105). Access is allowed to any user, and it
is not checked if they are an admin or not.
• In Listing 6 the appropriate role is not being checked, the incor-
rect (inferred) access rule here is (cid:104)user,−,−,canW rite(cid:105) whereas
the actual rule needs to include a check that the user is admin.
• In Listing 7 the correct ownership information, correspond-
ing to the user who created the article_id is missing
in the access check.
the rule inferred here is
(cid:104)user,non_admin,−,canW rite(cid:105).
From these examples, we now see that the correct access rule
associated with the delete query on tbl_articles, depending on the
role of the user, should be:
• (cid:104)user,non_admin,−,canwrite(cid:105) and
• (cid:104)user,admin,−,−(cid:105)

• In Listing 5,

Instead,

However, determining that this is the access rule, and that this is
correct is not at all obvious. As mentioned earlier, all we have is
the implementation, where the access rule is both control and data
sensitive. Depending on whether the user is admin or not, different
rules apply, indicating dependence on control. The ability to delete
an article also depends on whether the same user had created the
article, or had permissions to create it, requiring knowledge of data
variables using data-ﬂow analysis. Also implicit is the notion of
the underlying access model. In this example, though the admin

692Table 1: The Authorization Context for different queries in Running Example

Query
Listing 2

Listing 3 Line 3

Listing 4
Listing 5
Listing 7

Listing 3 Line 8

Listing 6

Authorization Context
$_SESSION[’userID’], $permission[’canWrite’], Column<$_SESSION[’userID’]>
$_SESSION[’userID’], $permission[’canWrite’], Column<author_ID>==$_SESSION[’userID’]
/0
$_SESSION[’userID’]
$_SESSION[’userID’],$permission[’canWrite’]
$_SESSION[’userID’], $userLevel == ’Admin’
$_SESSION[’userID’],$permission[’canWrite’]

user may not be the owner of the article, an implicit role hierar-
chy lets her delete items and use the permission canWrite. Un-
fortunately, if the implementation is incorrect, the task of ﬁnding
authorization errors becomes even more difﬁcult.

Authorization Context One of the main ideas in our approach
is the notion of matching what we call the authorization context,
across related or complementary security sensitive operations, in
terms four-tuple we have identiﬁed. We have no prior assumption
about the authorization policy used by the web application authors.
This authorization context is garnered by examining the code and
trying to ﬁll out the four-tuple at a given program point automat-
ically. To do this we will ﬁrst need to annotate the code to iden-
tify some of these ﬁelds manually. We populate our analysis by
tagging the variables corresponding to user-ids, roles, session iden-
tiﬁers (i.e., those sets of variables that change every session) and
permissions.

With each security sensitive operation identiﬁed, our goal is to
try to infer what access rule is being enforced by the code. Using
the annotated variables and the clauses in the query, we can now
compute the actual authorization context at a given program point
using a combination of control ﬂow and data ﬂow analysis. More
details of these techniques are presented in Section 4. In Table 1 we
show the actual context from a correct program from Listings 2 and
3 for INSERT and DELETE, and the actual context inferred from
each of the incorrect inserts and deletes from Listings 4 through 8.
Independent of what is correct, we observe that there are missing
gaps in the conditions checked for access, across INSERTs and
DELETEs to the same rows in the same table. Once we construct
the authorization context, this acts as a speciﬁcation for the access
policy as implemented by the developer. The obvious question now
is whether this policy is correct. However, we do not have any
information about whether this is the case or not.
It is possible
for us to take this actual context to the developers and ask them to
establish its validity, but this may not be always possible.

Authorization Context Consistency We observe that we can
also compare the authorization context for different, but matching
queries on the same tables. When the application uses the same
authorization context in order to access the same resource along
different paths of a web application, we term its authorization con-
texts to be consistent across the application. Any inconsistencies
identiﬁed in this manner could indicate a potential problem with
the access control implementation. Note that we do not know the
correct access policy here, what we are trying to do is detect incon-
sistencies across related operations. We illustrate this idea with an
example:

INSERT queries in a database are a good example of code
segments that contain rich authorization information. For ex-
ample, during creation of a row in a database table, we
can expect to ﬁnd some information about the owner of the
row. Consider table articles with columns (article_id,

article_author, article_text). The following query
adds an entry to this table:
INSERT INTO articles (article_author, article_text)

VALUES ($_SESSION[’userID’],
sanitize($_GET[’post’]));

The variable article_id is incremented automatically. The
ownership information, as to who can insert into this table can be
inferred from article_author and the value for this column
comes from $_SESSION[’userID’]. This ownership informa-
tion is being checked on access, the authorization column tuple be-
ing (cid:104)$_SESSION[’userID’],−,−,−(cid:105).

Let us now examine the corresponding DELETE query on the
same table article. Here, the only parameter for delete comes
from the user input (via GET).
DELETE FROM article WHERE article_id = $_GET[’post_ID’];

From the listing, it is clear that the authorization context for
the delete does not check ownership, i.e., the inferred context is
(cid:104)−,−,−,−(cid:105). If any user can guess the range of the current IDs in
the table, she can delete any row owned by any other user. This sim-
ple example now suggests that it is useful to make the constraints or
authorization states for these queries consistent and add the userID
to the authorization context of DELETE as:
DELETE FROM article WHERE article_id = $_GET[’post_ID’]

AND article_author = $_SESSION[’userID’];

The notion of computing the actual context and comparing it
with those obtained from matching rules as discussed, using the
authorization state four-tuple is both powerful and general. It ac-
commodates a variety of different application access control mod-
els, being agnostic to the actual models directly. No a priori deﬁ-
nitions or models are required, and the violations detected can en-
compass scenarios such as dynamic authorization and separation of
duty (SoD), and the DAC model as shown. In fact, the DAC model
is implied with the ownership information in the INSERT query.
As long as the attributes that determine access can be captured by
the authorization state abstraction, rich context variables such as
time of day, location, integrity constraints, keys and shared secrets,
etc., can all ﬁt easily with the techniques discussed.

Note that normal sanitization of the user input, without associat-
ing it with the current session token is not sufﬁcient. Of course,
there are many challenges associated with this kind of match-
ing. The obvious one is that this could be intended behavior, i.e.,
DELETES may have different permissions from Inserts. The actual
context on the INSERT could be incorrect. Further, there could
be more than one insert, corresponding to different roles or differ-
ent session characteristics and the corresponding delete has to be
matched up accurately. Nevertheless, as we show in this paper,
searching for inconsistencies in matching operations helps us re-
solve errors in real applications. The question is how often they
lead to false positives or negatives and we explore this in detail in
Section 5.

693Algorithm Overview We now describe our algorithm to compute
the authorization context, and compare contexts across matching
requests to discover inconsistencies. To start the analysis, we need
to ﬁnd all the queries in the code, and proceed to compute the con-
text at these query locations. Next, we compare the contexts of
similar access locations (i.e. query locations).
Inconsistency in
the contexts or in the way the authorization tokens are used in ac-
cessing the DB, e.g., using where clauses can lead to detecting
vulnerabilities as described.

Algorithm 1: Algorithm Overview
input : Application source, Authorization variables, Possible values for role

variables

1 cfg := ControlFlowAnalysis();
2 dda := createDependencyGraphs(cfg);
3 sinkPaths := enumeratePaths(dda);
4 foreach sp ∈ sinkPaths do
AuthzContextAnalysis(sp);
5
if sink ∈ {INSERT, UPDATE, DELETE} then
6
7
8 analyzeInserts();
9 analyzeDeletes();
10 analyzeUpdates();

queries += <symbolicQuery(sink), authz-c(sink)>;

As shown in Algorithm 1, the main input to our analysis is the
application source code (PHP code), annotated variables that corre-
spond to user ids, roles, session speciﬁc attributes and permissions
appropriately. Once we have these annotations we perform a con-
trol ﬂow analysis to identify paths involving these authorization
sensitive variables. Next, we construct a data dependency graph
using the annotated control ﬂow graph to capture dataﬂows be-
tween the identiﬁed variables. A source-sink graph corresponding
to entry points (sources) in web applications to particular sensi-
tive queries (sinks) is now ready. On this graph, we gather the
constraints at each sink as well as the annotated information ﬂow
context and construct our query context (lines 4-8). Context for
different queries is computed in Algorithms 2 and 3 and checked
for consistency to ﬁnd errors. Further details are presented in Sec-
tion 4.

4.

Implementation

Figure 1 shows the architecture of MACE, identifying the vari-
ous components of our tool, with (numbered) outputs produced by
each component that are subsequently used as (numbered) inputs
to other components.
Inputs. There are two sets of inputs to MACE: (1) source ﬁles
and (2) annotations or hints provided by the developer / end user.
Speciﬁcally, the set of hints provided by the developer is a small
set of super global variables that constitute the various components
of the authorization 4-tuple as described earlier. In PHP, typically
these annotations are on super-global variables such as SESSION.
In our running example, the hint provided to the tool is that the
super-global userID constitutes the speciﬁcation of the user com-
ponent of our 4-tuple. In our experience, the effort required to spec-
ify these hints is not high, as it took only a few minutes for each
application that we tested (as discussed in our evaluation). With
this information, together with the source code, MACE is able to
identify potential privilege escalation errors.
Control Flow Analysis To identify authorization errors in the pro-
gram, MACE uses static analysis methods to analyze the code. The
advantage of using static analysis is that it can identify all sensitive
accesses to important resources of a given type (e.g. SQL queries),
and analyze all execution paths that lead to them. MACE includes

a front-end to parse source ﬁles (in PHP). Subsequently a control-
ﬂow analysis is performed that results in a CFG (numbered 3 in
ﬁgure) for the application, which explicitly identiﬁes control ﬂows
throughout the whole application. In addition, this component also
identiﬁes a set of sensitive sinks in the application. Currently, sink
identiﬁcation in MACE is performed for SQL query locations (as
identiﬁed by calls to mysql_query).
Data Dependency Analysis The next step in MACE is to compute
a data dependency analysis. To illustrate the need for data depen-
dency analysis, let us consult the running example. In Listing 1,
the variable $userID holds the user information, which it receives
from the super-global $_SESSION[’userID’]. $userID is
subsequently used, and we need to capture these types of dataﬂows
to reason about authorization. This requires a data dependency
analysis, which is done by constructing data dependence graphs
(DDGs) for each procedure.

In addition, MACE’s analysis is inter-procedural. To see the
need for inter-procedural analysis, let us consult the running ex-
ample again. The assignment of $userID happens in procedure
verifyUser (Listing 3), whereas the use of $userID happens
in another ﬁle (delete.php). Since this analysis requires us
to see such data-ﬂows across all procedures, MACE also builds
a system dependence graph (SDG) [18], which is essentially an
inter-procedural DDG. The output of this step is a SDG (numbered
output 5) in Figure 1.
Slicing In order to look for authorization errors at a particular sink,
MACE analyzes paths that lead from the sources (entry points in
a web application) to that sink. Such analysis needs to be path
sensitive. Consider the running example in Listing 1. In this func-
tion, there are two paths, one that successfully checks if the user
ID has been set (through a prior authentication step, not shown in
the example for brevity), and the other that exits the application.
The authorization context therefore exists in only one of the paths,
and our analysis must be able to select such paths for further anal-
ysis, as well as ignore the other path, as it would not lead to a sink.
Therefore we require a path sensitive analysis.

In order to analyze each path, we perform inter-procedural slic-
ing using the SDG [18].
Intuitively, for a given sink such as a
SQL query, the corresponding SDG captures all program state-
ments that construct these queries (data dependencies) and control
ﬂows among these statements. MACE performs backward slicing
for the sinks such that each slice represents a unique control path
to the sink. Each of these control paths is therefore an instance of
sensitive resource-access. A number of steps are performed during
the slicing operation. Loops are expanded by unrolling, either 0 or
1 or 2 times. In addition, the conditional expressions are preserved
in the SDG by nop nodes, so that the information that is checked
by these conditional expressions can be used in computing the au-
thorization context. For instance, in our running example, the con-
dition isset($_SESSION[’userID’]) is stored along each
control path. Paths that do not reach a sensitive sink are omitted
from subsequent analysis. At the end of this slicing step, MACE
outputs a list of source-sink paths (numbered 6 in Figure 1. For our
running example involving Listings 1, 2 and 3, we have three, one
that reaches the INSERT query, another that reaches the DELETE
query, and a third that reaches the same query but corresponds to
deleteAll.
Authorization Context Analysis Using the paths computed dur-
ing the slicing step, MACE computes the authorization state along
each such path from the source to the sink. To do this, it starts
with the super-globals identiﬁed from the user provided annota-
tions (numbered by 2 in Figure 1) and checks if they (or other

694Figure 1: System Architecture. The numbers shown refer to outputs produced during various components, which are used as inputs for
subsequent components.

program variables that get receive values from these super-globals
through data-ﬂows) are consulted in conditions along the path
from the source to the sink.
If so, that information is symboli-
cally represented in the authorization context 4-tuple. For instance,
for our running example involving Listings 1 and 3, deleting
(Line 3) involves an authorization context that checks both the
user has logged on, the permission (canWrite) and therefore
the corresponding context is inferred: (cid:104)userID,_,_,{canW rite}(cid:105)
whereas Listing 1 and 5 involve the following authorization con-
text: (cid:104)userID,_,_,_(cid:105). This step is computed using our sliced
SDGs, which provide the data-ﬂow information. At the end of this
step, MACE outputs source-sink paths with annotated authoriza-
tion context at each location along the path.

Resource Access Analysis Having computed the authorization
context at all program points in any given path, the next step in
MACE is to see how these are used towards accessing applica-
tion resources. The main resources in web application are DB
tables, and we need to check whether the authorization contexts
across all resources are consistent. However, the access control
context at the query location may still be incomplete in captur-
ing the access restrictions the application places along the cur-
rent path being analyzed. To see this, we refer to Listing 3.
In the ﬁrst DELETE operation, the query is constrained by two
WHERE clauses: (1) the speciﬁc article to be deleted and (2) the
author_ID ﬁeld from postAuthor of the table restricted to the
current userID. The latter constrains the authorization context
by way of row restriction:
i.e., each article can be deleted only
by a user who has her userID stored in the same row of the ta-
ble. This happens only when the corresponding INSERT query
for the same row (shown in Listing 2) inserts the userID in the
ﬁeld author_ID. This implicit form of “ownership” needs to be
captured by MACE in the authorization context. Thus, the relation-
ship between author_ID and userID that is implicit in the code
needs to become explicit. The tool captures this information as Au-
thorization Columns for each table. Each authorization column el-
ement captures the column name and the symbolic value used to
constrain the query. Returning to our running example, the autho-
rization columns for the table tbl_articles is: [author_ID
= $_SESSION[’userID’]]

Note that, in cases where the developer did not specify col-
umn names in INSERT queries, MACE uses DB schemas, which
are automatically generated by parsing database creation ﬁles
(CREATE TABLE queries) to mark the authorization columns.

For this purpose, MACE symbolically evaluates the source-to-
sink path that leads to the query so that the relationship between
the super-global variables that eventually reach the query becomes
explicit. Symbolically executing the path that leads to the ﬁrst

Algorithm 2: Analysis of INSERT Queries
input : List of queries and their authorization contexts
output: List of Tables, Tables’ authorization contexts, Tables’ authorization

columns

1 sortSymbolicQueries();

// based on Table names

2 foreach table t do
3
4

foreach ins-q ∈ getInsertQueries(t) do

authzContexts(t)+=getAuthzContext(ins-q);
authzCols+=getAuthzColumns(ins-q);

if AuthzContext(t).size > 1 then

diff := compare(authzContexts(t));
if diff then

raiseWarning(INSERT_Conﬂict);

5
6
7
8
9
10
11
12
13 return authzCols, authzContexts;

if authzCols(t).size > 1 then

diff := compare(authzCols(t));
if diff then

raiseWarning(INSERT_AuthzColumn_Conﬂict);

DELETE query in Listing 3 makes this relationship explicit. For
instance, we obtain the following symbolic query for the above ex-
ample.
DELETE FROM tbl_articles WHERE article_id =

$_GET[’article_ID’] AND author_ID =
$_SESSION[’userID’];

Notice that the query is now entirely expressed in terms of sym-
bolic super-globals such as user inputs $_GET[’post_id’] and
$_SESSION[’userID’]. Having the symbolic query for each
query location allows us to compare similar accesses to the column
authorID in the DB, and compare the authorization contexts for
similar accesses to the same table.

In addition to identifying inconsistencies, the previous steps al-
low one to see if there is a possibility of privilege escalation due to
insecure use of user-supplied parameters in authorization decisions.
User supplied parameters such as $_COOKIE can be tampered, and
therefore authorization decisions must not refer to them. Having
a symbolic query that makes any such use explicit also facilitates
MACE to identify these types of errors. At the end of this step,
MACE outputs a set of symbolic queries. These queries contain
the resources (tables) and together with the authorization context
at each resource along every path that leads to the resource. The
speciﬁc type of access (INSERT, UPDATE, DELETE) is also
available through the symbolic query. As mention earlier, paths
that lead to SELECT queries or those that do not lead to sensitive
resources are discarded.

Context Comparison The goal of this step is to compare the au-
thorization context at each resource access and identify inconsis-
tencies. To this point, we have gathered two sets of information
with respect to authorization in previous steps: 1) the authorization

Con. FlowAnalysisDep.AnalysisSlicingAuth.AnalysisResourceAccess AnalysisContextComparisonConﬂicts2: Hints3:CFG4:SinksDDG, 5:SDG34,56:Source-SinkPath List2,67: Auth Contextat each location8:SymbolicQueries6,77,81:source ﬁles695Algorithm 3: Analysis of DELETE Queries
input : authzCols, authzContexts

1 foreach table t do
2

foreach del-q ∈ getDeleteQueries(t) do

3

4
5
6
7

8
9

10

// Compare Authorization Contexts
if getAuthzContext(del-q) == getAuthzContext(t) then

// Compare Authorization Cols
authzClause = getAuthz(getWhereClauseCols(del-q));
if authzClause != getAuthzColumns(t) then

raiseWarning(HORIZONTAL_ESC);

else if getRole(getAuthzContext(q)) < getRole(getAuthzContext(t))
then

raiseWarning(VERTICAL_ESC);

else

// Other inconsistencies may have various

authorization vulnerabilities

raiseWarning(INCONSISTENCY);

contexts for query locations and 2) the resource access parameters
(authorization columns) for each table.

The ﬁrst step in context comparison is to group the query-path
pairs based on the table names in the query (Line 1 in Algo-
rithm 2. During symbolic execution analysis done in the previ-
ous phases, we are able to resolve the table names for static and
dynamic queries in each possible sink-path pair. Then, for each ta-
ble, we gather the authorization context and authorization columns,
which are used in table accesses. The number of distinct authoriza-
tion contexts and authorization columns may be more than one,
for different queries in different program locations. Therefore, we
need to resolve these differences and in any case report these con-
ﬂicts. Lines 7-11 in Algorithm 2 compare the contexts for INSERT
queries on a given table. The discussion about the analysis of these
conﬂicts comes in Section 4.1. After ﬁnishing all INSERT queries,
we proceed to analyze DELETE and UPDATE queries. The reason
we start this way is because ownership information is added to the
resources at their creation time, in a DAC model, which is typical
of such applications. INSERT queries show us where the owner-
ship information comes from in the program and in which column
of the table they are going to be stored.

In the next step, to analyze the rest of the queries (i.e. DELETE
and UPDATE queries) we compare their authorization contexts
shown by 1) the resource accesses (where clauses in queries) and
2) the authorization context annotations, with the information we
gathered from INSERT queries. Algorithm 3 shows the analysis
of delete queries. The analysis of UPDATE queries is done in the
same way.

The data in database tables should be changed exclusively with a
privilege level equal or more than the level speciﬁed in their autho-
rization context so that the integrity of these tables remains intact.
Lines 9 and 10 in Algorithm 3 show how we check for vertical
privilege escalation vulnerabilities in our tool.

In addition to the authorization context, we check table access
parameters (lines 4-6 in Algorithm 3) to detect horizontal privilege
escalation vulnerabilities. These attacks happen in the same privi-
lege level as the legitimate users, however, a malicious insider can
manipulate the data stored in DB tables owned by other users. This
additional check of accesses tries to prevent such attacks.

Lines 12-15 in Algorithm 3 detect any other inconsistency in
the authorization contexts. These inconsistencies are also reported
back to the user for further analysis.

4.1 Conﬂicting Contexts

During the comparison phase, both for authorization contexts
and the resource access comparisons, there may be scenarios in
which the contexts or access parameters do not match entirely. In
these cases, the authorization context or WHERE clause with more

restrictions is viewed as the stronger context / clause. This is intu-
itive – quite often, the more restrictive the context, the more speciﬁc
(or precise) it is about the access rules regarding the resource being
referred to. Below, we discuss different conﬂict scenarios and how
MACE addresses these conﬂicts.

In the case of one INSERT query present in the application for
a given resource, we assume that the authorization information ex-
tracted from the query must be present in the authorization context
of further accesses (UPDATEs or DELETEs). In case of any conﬂict
after the comparison, if the authorization context of the INSERT
query is stronger than the other query’s context, we raise a warn-
ing. Depending on the missing element in the authorization 4-tuple,
the type of the warning may vary. A missing or weaker role infor-
mation is generally an indication of a vertical privilege escalation
vulnerability caused by the current privilege role level being less
than what was present in the INSERT query’s context. A miss-
ing user element in the context, while it was present at the time of
the insert, indicates a horizontal privilege escalation vulnerability.
Relying on user provided inputs (such as GET, POST or COOKIE
variables) in the 4-tuple is an indication of a general mismanage-
ment of sessions and authorization in the application.

4.2 Precision and minimizing warnings

MACE is a ‘best effort’ tool to detect missing or inconsistent au-
thorization information. It is based on the intuition that developers
aim to get most cases right, and some occasional cases wrong. In
the rare case that the developer gets none of the cases right, then
MACE’s approach cannot detect errors.

To have a more effective tool with a better conﬁdence rate, there
are a few general steps we took in order to improve the overall
precision and lower the false positive rate.
INSERT queries with missing authorizations So far, we set au-
thorization contexts in INSERT queries as the base for consistency
analysis. If an INSERT query misses some crucial authorization in-
formation, then our tool may not report faulty DELETE or UPDATE
queries (as long as they are consistent with the faulty INSERT),
causing possible false negatives.
User-controllable query parameters. There are some applica-
tions that permit user-controlled parameter (such as those of GET,
POST, COOKIE) values in authorization decisions. Since MACE
uses data ﬂow analysis, it is able to observe these incorrect autho-
rizations and reports them (we identify and report 10 such errors
in our evaluation). In such cases of vulnerabilities, MACE does
not further proceed to analyze the queries that are impacted by
these ﬂaws, so that the number of warnings reported by the tool
is minimized. After ﬁxing these vulnerabilities, the user can re-run
MACE to identify if there are still missing authorizations.
SELECT queries. Technically speaking, it is possible for MACE
to include SELECT queries and analyze them for inconsistencies,
as the analysis required to identify authorization for a SELECT
query (e.g.
dataﬂow analysis) is no different compared to an
INSERT. However, including SELECT queries is primarily a ques-
tion of the user’s tolerance of the signal / noise ratio for an policy-
agnostic tool such as MACE. To see this, let us consider an ex-
ample of a news article website. The news articles are publicly
viewable and so at the corresponding SELECT query there would
be no authorization information, whereas the users of the website
often have to authenticated and authorized to be able to post news
articles. Comparing such SELECT queries with INSERT queries
often will lead to false alarms. Therefore, in order to eliminate
such false alarms, a user might decide to omit analyzing SELECT
queries, as we did in the evaluation of MACE. Another choice that

696Application
phpns 2.1.1alpha
DCPPortal 5.1.44
DNScript
myBloggie 2.1.3
miniBloggie 1.1
SCARF 1.0
WeBid 1.0.6

Table 2: PHP Applications
# query
Locs
40
308
27
24
5
13
687

SLOC
4224
89074
1322
6261
1283
978
27803

# php
ﬁles
30
362
60
59
11
19
266

# DB
tables
13
34
7
5
2
7
47

Analysis
time (s)
8220
982
35093
373
35
54
1492

Application

phpns

DCPPortal
DNScript
myBloggie
miniBloggie

SCARF
WeBid

Table 3: Overview of Vulnerabilities
# query conﬂicts
TP
FP
0
7
0
46
0
0
0
6
1
0
0
11
0
0

HPE
(cid:88)
(cid:88)
-
(cid:88)
-
(cid:88)
-

VPE
(cid:88)
(cid:88)
-
(cid:88)
(cid:88)
(cid:88)
-

known,
unknown
0, 7
0, 46
-
3,3
1, 0
1, 10
-

a user has, which involves additional manual effort, is to provide
additional annotations that identify the tables that store sensitive
data (and therefore require authorization on SELECT queries).

4.3 Other Issues
Unsupported PHP features MACE is implemented for PHP, and
makes use of the Pixy [19] tool for control ﬂow analysis. A small
set of features in PHP language are not handled by Pixy and there-
fore MACE does not deal with them. For instance, dynamic in-
clusions and certain object-oriented features of PHP are not han-
dled entirely. However, these have not limited the applicability of
MACE to the application suite that used in our evaluation. Note
that, while MACE works in the context of PHP, which is widely
used, our technique (using authorization context differentials, sym-
bolic execution, dataﬂow analysis) is independent of any platform.

Counting the number of vulnerabilities. Many vulnerable
queries might be ﬁxed by a single common authorization check at a
shared program location. However, MACE treats each query loca-
tion as an independent operation and reports and counts vulnerable
queries separately. We prefer to do so because we think each of
the reported vulnerable queries might lead to a different instance
of attack. By treating the queries in isolation, we can identify the
vulnerability type with more precision. As we see in section 5, we
may report large number of vulnerable locations because of one
single missing authorization check, but in each such case of mul-
tiple vulnerabilities due to a single reason, we explicitly indicate
so.

5. Evaluation
Implementation MACE is designed to analyze PHP Web appli-
cations. MACE is implemented in Java and is about 10K lines of
code. We use an open-source tool and library (TAPS [9]) to get the
control ﬂow graphs and enumerate execution paths for PHP appli-
cations. The experiments described in this section were performed
on a MacBook Pro (2.4 GHz Intel, 4.0 GB RAM).

5.1 Effectiveness
Experiments. We ran our tool to analyze the effectiveness of
MACE on a suite of seven small to large PHP free and open-source
Web applications. As shown in Table 2, the applications range from
approximately 1k to 89k source lines of code (SLOC). These appli-
cations were used as benchmarks in previous research studies [28,
8, 24]. The results of our evaluation fall under the following cate-
gories: (1) vulnerabilities identiﬁed by MACE and detailed statis-
tics about the vulnerabilities identiﬁed in our experiments, (2) per-
formance, scalability of MACE and (3) the annotation effort re-
quired from the developers. We have veriﬁed by hand all of the au-
thorization vulnerabilities in the applications, which were reported
by the tool.

For each application, we annotate the authorization tuple vari-
ables and then run MACE with given annotations and the source
code. MACE then lists all of the conﬂicts, the vulnerabilities, their

locations in the source code and the values, which cause the incon-
sistencies.
Results summary. Table 3 presents the summary of our exper-
iments. The table lists the number of conﬂict reports, and also
shows how many of these were indeed vulnerabilities (true posi-
tives - TP) and how many of them were reported incorrectly (false
positives -FP) by our tool. Furthermore, the breakdown of the vul-
nerabilities (true positives) between the two types of privilege es-
calations namely HPEs and VPEs is presented in columns 4 and 5.
The last column in this table gives the breakdown of the identiﬁed
vulnerabilities were known (i.e. previously reported in CVEs or by
previous studies) versus unknown (i.e. zero-day vulnerabilities).

As reported in the last column of the table, MACE is able iden-
tify zero-day authorization vulnerabilities in the following appli-
cations: phpns, DCPportal, mybloggie and SCARF. In the
following subsection, we will go through the details of these vul-
nerabilities.

5.2 Vulnerabilities Identiﬁed
phpns The phpns application is an open-source news system. The
application allows three roles in the system for the users: 1) guest
users (unauthenticated users) who can only view the news articles;
2) normal users who must be logged into the system and use the
article management panels and 3) admin user who also must be
logged into the system and can access both article and user man-
agement panels. Basic permissions such as adding, deleting and
updating articles are set by default for the new users of the system.

$new_res = general_query(’INSERT INTO articles
(article_title, artcle_sbtitle,
article_author, article_cat,
article_text,...)

VALUES(’.$data[’article_title’].’,’
.$data[’article_subtitle’].’,’
.$_SESSION[’username’].’,’
.$data[’article_cat’].’,’
.$data[’article_text’]’’);

Listing 8: Inserting an article item in in inc/function.php, phpns

$items = $_POST; //get vars
...
$sql = general_query("DELETE FROM

".$databaseinfo[’prefix’]."".’articles’." WHERE id
IN (".$items.")");

Listing 9: Deleting an article item in article.php, phpns
Using MACE, we found seven vulnerabilities in this application,
all of which are previously unknown, two of which we describe be-
low. Consider the actual code for the inserting and deleting users,
shown in Listings 8 and 9 respectively. The ﬁrst vulnerability al-
lows an unauthenticated user can delete any comment without any
authorization checks. MACE was able to identify this because the
relevant authorization context is not consulted at the delete opera-
tion. The implication of this vulnerability is that an outside attacker
(who has no credentials in a given installation of phpns) can delete
any comment item in the application. This is an example of a verti-

1
2
3
4
5
6
7
8
9

1
2
3

697Table 4: Details of Warnings
Number of violations

insert-update
5
21
0
3
0
8
0

insert-delete
2
25
0
3
1
3
0

Application

phpns

DCPPortal
DNScript
myBloggie
miniBloggie

SCARF
WeBid

insert-insert
0
0
0
0
0
1
0

cal privilege escalation attack (VPE). Another detected vulnerabil-
ity is found in manage.php that allows for an authenticated user
to delete other users’ news articles by providing arbitrary article
IDs (which are available to all users through inspection of URLs).
This vulnerability is a horizontal privilege escalation (HPE). We
have reported these and other vulnerabilities in phpns.
dcp-portal The dcp-portal application is an open-source con-
tent management system. This application allows two authenti-
cated roles: admin user and non-admin user (normal user). Con-
sider Listings 10, 11, and 12, which refer to the authorization op-
eration, insertion and deletion of agenda items in a calendar table.
Variable $_COOKIE["dcp5_member_admin"] is being used
to determine whether the user is an admin user or not. While insert-
ing an item in the agenda, this variable is consulted, and the agenda
item is entered in the table t_agenda. However, while deleting
the item, while the authorization function is consulted, the deletion
is based on a (user supplied) value $_REQUEST["agid"], thus
making the requests inconsistent. The implication of this vulnera-
bility is that it allows any user in the system to delete another user’s
agenda entries, thus making it a HPE, which was a previously un-
known vulnerability.

if (UserValid($_COOKIE["dcp5_member_id"])) {

...}

Listing 10: Authorization function in lib.php, dcp-portal

if ((isset($_REQUEST["action"])) && ($_REQUEST["action"]

== "add") && ($_REQUEST["mode"] == "write")) {

$sql = "INSERT INTO $t_agenda (user_id,
subject, message, date) VALUES

($_COOKIE[’dcp5_member_id’] ," .

htmlspclchars($_REQUEST[’subject’]).",".
htmlspclchars($_REQUEST[’aktivite’]).",
$date)";
$result = mysql_query($sql);}

Listing 11: Inserting an agenda in calendar.php, dcp-portal

if ((isset($_REQUEST["action"])) &&

($_REQUEST["action"]=="delete")) {

$sql = "DELETE FROM $t_agenda WHERE id =

’".$_REQUEST["agid"]."’";
$result = mysql_query($sql);}

Listing 12: Deleting an agenda in calendar.php, dcp-portal

1
2

1

2
3

4
5
6
7

1

2

3

this

function takes

We also found 44 other VPEs due to the incorrect implemen-
tation of UserStillStillAdmin function in dcp-portal.
The ﬁrst argument of
the value of
$_COOKIE["dcp5_member_id"] and determines whether the
user with this userID is an admin. The value for the userID comes
from a cookie variable and not from an established authorization
state at the server side, which makes all 44 distinct queries in the
admin path vulnerable to VPE.
myBloggie The MyBloggie application is an open-source blog-
ging software. When we ran MACE on this application, we found
six privilege escalation vulnerabilities. In three of these vulnera-

bilities, the validity of a session is not checked in many instances
as the check shown in Listing 13 does not appear in del.php, del-
cat.php, deluser.php ﬁles. Even in the ﬁles that do check this con-
straint, MACE found horizontal escalation attacks. The parame-
ters used to delete rows do not check for authorization informa-
tion. For instance, the parameter used to access and delete the
rows in POST_TBL is coming from user-supplied values such as
GET["post_id"] and is prune to HPE. MACE found three such
unreported vulnerabilities in this application.

1

if (!isset($_SESSION[’username’]) &&

!isset($_SESSION[’passwd’])) //go to login;

Listing 13: authorization Check in addcat.php, MyBloggie

miniBloggie The miniBloggie application is also a blogging
Web application. In this application, there is no role or privilege
level deﬁned for the users. Thus, users are either authenticated
($_SESSION[’user’] is set) or not. Even with this simple au-
thorization rule, the application is vulnerable to privilege escalation
as detected by MACE. These scenarios involved missing checks
that need to be present in order to ensure the user is a valid one
before access to table rows is granted. In del.php (Listing 15),
function verifyuser() is omitted, making way for the vulner-
ability, which was previously unknown.

1
2
3
4
5
6
7
8
9

1
2
3
4
5
6

1
2

3

session_start();
if (!verifyuser()){

header( "Location: ./login.php" );

}else {...

if (isset($_POST["submit"])) {

$sql = "INSERT INTO blogdata SET
user_id=’$id’,
subject=’$subject’,
message=’$message’"...";

Listing 14: Inserting a blog user in add.php, miniBloggie

session_start();
if (isset($_GET[’post_id’])) $post_id = $_GET[’post_id’];
if (isset($_GET[’confirm’])) $confirm = $_GET[’confirm’];
if ($confirm=="yes") {

dbConnect();
$sql = "DELETE FROM blogdata WHERE

post_id=$post_id";

Listing 15: Deleting a blog user in del.php, miniBloggie

SCARF The SCARF application is an open-source conference
management software which helps the user to submit and review
papers. The possible roles in SCARF are admin and normal user.
Both roles must be authenticated to interact with the software. Vari-
able $_SESSION[’privilege’] indicates whether a user is
an admin or not.

MACE detects several

types of authentication and autho-
rization bypass vulnerabilities in SCARF. For example,
in
generaloptions.php, the admin can delete users and mod-
ify the option table. The page has no authorization check be-
fore it proceeds to performing admin tasks. As a result of this
vulnerability, a normal user of the system who is legitimately au-
thenticated can delete other users. To ﬁx the problem this method,
require_admin(), should be added at the beginning of the ﬁle
which veriﬁes whether the current session is the admin session or
not. If it is not the admin session, the program exits.

if (isset($_GET[’delete_email’])) {

query("DELETE FROM users WHERE email=’" .

escape_str($_GET[’delete_email’]) . "’");

}

Listing 16: Deleting a user in generaloptions.php, SCARF

698Table 5: Analysis of Queries

Application

phpns

DCPPortal
DNScript
myBloggie
miniBloggie

SCARF
WeBid

# query-path pairs
insert
update
222
2564
60
56
2
8
0
5
3
9
26
4
131
22

delete
920
58
13
2
1
12
7

# query-authzInfo
pairs
78
158
26
40
3
19
323

1
2
3
4
5
6
7
8

function require_admin() {

if (!is_admin()) {

die ("...");}

}
function is_admin() {

if ($_SESSION[’privilege’] == ’admin’) return TRUE;
else return FALSE;

}

Listing 17: Missing Authorization in generaloptions.php, SCARF
Ten other vulnerabilities reported by MACE in this applica-
tion can be attributed to a single reason. The reason for these
vulnerabilities being reported is that the constraining parameter
used in certain UPDATE or DELETE queries derives it value from
$_GET[’session_id’], which is an untrusted source (i.e.,
the HTTP client). The corresponding INSERT query uses the
$_SESSION[’user_id’] which is an authorization variable as
shown in the following code snippets. The column session_id
in table sessions is an auto-increment key. Since untrusted val-
ues are never part of server authorization state, the authorization
contexts for these queries were reported empty. Since the param-
eter $_GET[’session_id’] is provided by the user, and the
values are guessable (auto-incremented value), an attacker can im-
pose himself on any guessable session.

INSERT INTO sessions (name, user_id, starttime,

duration) VALUES
(mysql_real_escape_string($_POST[’name’]),
$_SESSION[’user_id’], $date, $duration)

Listing 18: Inserting a session addsession.php, SCARF

UPDATE sessions SET user_id=$_POST[’chair’] WHERE

session_id=$_GET[’session_id’]

Listing 19: Updating a session in editsession.php, SCARF

Webid and DNScript MACE did not report any conﬂicts in these
two applications.
Vulnerability & Inconsistency Reports. Table 4 shows the break-
down of the number of inconsistencies reported by our tool. The
inconsistencies between various types of query pairs (insert-insert,
insert-update and insert-delete). Together with table 3, we see that
MACE is precise and produces no false positives. This low FP
rate is due to the use of authorization 4-tuple to model the autho-
rization state of sessions at the server. Using the reports generated
by the tool (including the locations of the queries and the missing
authorization), a developer can proceed to ﬁx the application.

5.3 Performance & Scalability

We evaluated MACE on a suite of Web applications with differ-
ent sizes ranging from 1K to 90K. Columns 2-3 in Table 2 show
the size and number of php ﬁles in the applications, and column 4
gives an estimation of the number of query (insert-update-delete)
locations (in source).

Table 2 (column 6) shows the total analysis time for each Web
application ranging from 35 seconds to 35093 seconds. About %95

of the analysis time has been spent to create the dependency graphs
and enumerate execution paths.

The increase in the number of possible paths increases the num-
ber of created symbolic queries. However, the number of distinct
symbolic queries may still remain relatively low as shown in the
last column of table 5, where we present the number of unique
symbolic queries and their authorization information 4-tuple. Cur-
rently, MACE analyzes each ﬁle separately and builds the aggre-
gated contexts when all the queries are gathered. The performance
of MACE can be improved, especially if we summarize recurring
contexts for basic user-deﬁned functions. Since MACE is a static
tool, the analysis times are quite acceptable for the beneﬁts pro-
vided by the tool.

5.4 Annotation Effort

To run MACE, we manually identify the 4-tuple variables for
each of the applications as hints for our tool. Developers typi-
cally use global and super-global variables (e.g.
in SESSION or
COOKIE) to represent user roles, user IDs, and the possible per-
missions for the logged-in users. These variables are further used
to hold the authentication and authorization-related values through-
out the program. Table 6 in Appendix A shows the variables we
identiﬁed as hints for our programs.

The manual annotations are developed by observing the session
management functions in login procedures. In our experience, de-
veloping these annotations is not hard for users familiar with the
application, and certainly for developers who coded the applica-
tion. To objectively measure the annotation effort, we performed
a user-study experiment. To assist this experiment, MACE was
extended to automatically generate a list of global and superglobal
variables, which are used in if-statements, which is a superset of au-
thorization variables. This list is then reﬁned to exclude user input
variables (such as GET and POST superglobals), and is provided as
a starting point to the user.

To measure the effort needed to identify the 4-tuple, we asked a
graduate student who had basic knowledge about Web applications
to develop these annotations. We provided the application sources
and the globals list generated by MACE. The student was provided
the mybloggie and phpns applications, which are mid-tier ap-
plications in our benchmark suite. She was able to produce anno-
tations that matched our own annotations for both the applications,
and took about 50 minutes for generating and verifying the anno-
tations. This experiment lends evidence that only modest efforts
are required in providing annotations. We also note that our experi-
ence with providing such annotations is consistent with prior work
in web access control that makes use of similar annotations [11,
29]. Given the number of unknown vulnerabilities identiﬁed by
MACE, we believe such annotation-assisted automated bug ﬁnd-
ing is an attractive alternative to weeks of human effort and manual
code inspection.

6. Previous work

We summarize related work in three broad categories: research
focused on prevention of access control vulnerabilities, research
aimed at detecting access control bugs in legacy web applications,
and general program analysis techniques to ﬁnd vulnerabilities in
software. We contrast how MACE differs from many of these ap-
proaches, while uses some techniques in common.

Prevention of Authorization Vulnerabilities Nemesis [11] uses
Dynamic Information Flow Tracking (DIFT) to establish a shadow
authentication system that tracks user authentication state. Access
control lists can be speciﬁed by programmers, which help the sys-

699tem enforce authorization properties at run-time. CLAMP [21]
uses virtual web servers to prevent authorization vulnerabilities in
web applications: by migrating the user authentication module of a
web application into a separate, trusted virtual machine (VM). All
database access requests (queries) are mediated by a trusted VM
that enforces deﬁned access control rules and restricts the queries
if necessary. Diesel [15] provides a proxy-based framework to
limit database accesses at run-time. It uses the principle of least-
privilege to secure the database through developer-deﬁned policies.
Capsules [20] develops a language based technique which uses
Object-Capability languages to isolate objects from each other, in
order to separate web applications into components. While these
works are focused on dynamic prevention of access control errors,
MACE is focused on static detection of access control vulnerabil-
ities.

Swaddler [10] is an dynamic anomaly detection tool which is
able to detect several types of bugs including workﬂow bugs.
Swaddler has a Daikon-based invariant learning phase followed by
an analysis phase which checks the invariants against the applica-
tion state model. Although the Swaddler tool uses the notion of
session and checks for the presence of session variables in execu-
tion paths, it does not take into account the access control model of
the application with respect to various resources.

Finding Authorization Bugs in Legacy Web Applications Gana-
pathy et al. [17], where they add checks to enforce authorization
rules in legacy software systems, such as X SERVER. They use
a reference monitor for enforcing deﬁned authorization policies at
run-time.

RoleCast [24] uses common software engineering patterns to
model authorization requirements and develops techniques to
check if any sensitive operation is performed after authorization.
While the advantage of using patterns is that it frees the need for
developer annotations, we have noticed that the RoleCast patterns
do not hold consistently across all web applications. The approach
proposed by Sun et al. [26] detects vertical escalation vulnerabil-
ities using static analysis. This approach builds a sitemap of the
Web application, modeling the accesses to privileged webpages per
role. It then checks if forced browsing cause the privileged pages
to be accessed. Both approaches ([24] and [26]) use course-grained
modeling of authorization requirements through grouping the roles.
They only accommodate detection of vertical escalation vulnera-
bilities. In contrast, MACE employs a precise and ﬁne-grained au-
thorization model that is supported by user annotations of modest
effort, giving it the ability to detect a larger class of vulnerabilities,
including horizontal privilege escalation.

Doupe et al. [12] present an analysis of Execution after Redirect
(EAR) vulnerabilities in web applications. They discuss a static
control ﬂow analysis for web applications that detect EAR attacks.
While MACE is not built to detect EARs, the analysis infrastruc-
ture of MACE could be extended in a straightforward way to detect
EAR vulnerabilities. In addition, the context inference for sinks in
MACE could form the basis for automatically distinguishing be-
nign EARs from vulnerable EARs.

Vulnerability Analysis in Applications Waler [14] uses a combi-
nation of static and dynamic analysis techniques to extract program
speciﬁcations in terms of likely invariants and then uses model
checking to verify the extracted invariants. MACE is similar in
its objectives to Waler as both approaches aim to work with source
code as the only speciﬁcation. However, being focused on logic
errors, Waler is not built to precisely compute authorization con-
texts. This limits its ability to identify access control discrepancies
that require global reasoning across the entire web application, es-

pecially related to how a particular resource is accessed in various
operations.

Engler et al.

[13] also try to extract program speciﬁcations,
through behavioral patterns called beliefs. They use static analy-
sis techniques to infer these patterns and rank them using statistical
analysis of the patterns. The patterns speciﬁed can be used to detect
certain types of vulnerabilities caused by inconsistency in the pro-
grams, such as pointer dereference and use of locks on resources.
Srivastava et al. [25] detect security vulnerabilities through com-
paring different implementations of the same API. They use secu-
rity policies as input to their analysis. Any inconsistency between
the security policy and any of the implementations or any inconsis-
tency between different implementations are being reported as er-
rors. AutoISES [27] can detect bugs in standard C libraries through
mining for common security-related patterns and identifying devi-
ations from these as vulnerabilities.

Blackbox approaches (NoTamper [7] and the approach proposed
by Pellegrino et al.
[22]) have some potential to reason about ac-
cess control vulnerabilities in an application, but they are inher-
ently limited in their ability to reason about authorization errors that
manifest as a result of missing checks along speciﬁc paths present
in source code which can only effectively gleaned through access
to the application source code.

7. Conclusion

We present MACE, a program analysis tool for automatic detec-
tion of authorization vulnerabilities in Web applications. The tool
is based on our study and characterization of different authorization
attacks and the underlying vulnerabilities. We ﬁnd privilege escala-
tion vulnerabilities by ﬁnding inconsistencies in the authorization
contexts at access request points without knowing the correct ac-
cess control policies. While the analysis is best effort, the greatest
value of MACE is in identifying ﬂaws in these applications using
fundamental abstractions, in the absence of any policy speciﬁca-
tions, with the beneﬁt of ﬁnding important vulnerabilities that were
not discovered earlier.

Acknowledgment
The authors would like to thank the anonymous reviewers for their
constructive comments. We would also like to thank Kalpana
Gondi, Abeer Alhuzali and Ivan Brugere who helped us with the
annotation experiments.

This material is based upon work supported in part by the Na-
tional Science Foundation under Grant Nos. 0845894, 1069311
and 1065537. Any opinions, ﬁndings, and conclusions or recom-
mendations expressed in this material are those of the author(s) and
do not necessarily reﬂect the views of the National Science Foun-
dation or the U.S. government.
8. References
[1] Citi breach: 360k card accounts affected.

http://www.bankinfosecurity.com/
citi-breach-360k-card-accounts-affected-a-3760.

[2] Cwe-639. http://cwe.mitre.org/data/deﬁnitions/639.html.
[3] Mitre top 25. http://cwe.mitre.org/top25/.
[4] OWASP: Testing for privilege escalation.

https://www.owasp.org/index.php/Testing\_for\
_Privilege\_escalation\_(OWASP-AZ-003).

[5] Virtual private database. http://www.oracle.com/technetwork/

database/security/index-088277.html.

[6] Application vulnerability report. Tech. rep., http://www.cenzic.com/
downloads/Cenzic_Vulnerability_Report_2014.pdf, 2014.

[7] BISHT, P., HINRICHS, T., SKRUPSKY, N., BOBROWICZ, R., AND

VENKATAKRISHNAN, V. N. Notamper: Automatic blackbox detection of
parameter tampering opportunities in web applications. In Proceedings of the

70017th ACM Conference on Computer and Communications Security (New York,
NY, USA, 2010), CCS ’10, ACM, pp. 607–618.

[8] BISHT, P., HINRICHS, T., SKRUPSKY, N., AND VENKATAKRISHNAN, V. N.

Waptec: Whitebox analysis of web applications for parameter tampering exploit
construction. In Proceedings of the 18th ACM Conference on Computer and
Communications Security (New York, NY, USA, 2011), CCS ’11, ACM,
pp. 575–586.

[9] BISHT, P., SISTLA, A. P., AND VENKATAKRISHNAN, V. N. Taps:

Automatically preparing safe sql queries. In Proceedings of the 17th ACM
Conference on Computer and Communications Security (New York, NY, USA,
2010), CCS ’10, ACM, pp. 645–647.

[10] COVA, M., BALZAROTTI, D., FELMETSGER, V., AND VIGNA, G. Swaddler:

An approach for the anomaly-based detection of state violations in web
applications. In Proceedings of the 10th International Conference on Recent
Advances in Intrusion Detection (Berlin, Heidelberg, 2007), RAID’07,
Springer-Verlag, pp. 63–86.

[11] DALTON, M., KOZYRAKIS, C., AND ZELDOVICH, N. Nemesis: Preventing

authentication & access control vulnerabilities in web applications. In USENIX
Security Symposium (2009), USENIX Association, pp. 267–282.

[12] DOUPÉ, A., BOE, B., KRUEGEL, C., AND VIGNA, G. Fear the ear:
Discovering and mitigating execution after redirect vulnerabilities. In
Proceedings of the 18th ACM Conference on Computer and Communications
Security (New York, NY, USA, 2011), CCS ’11, ACM, pp. 251–262.

[13] ENGLER, D., CHEN, D. Y., HALLEM, S., CHOU, A., AND CHELF, B. Bugs
as deviant behavior: A general approach to inferring errors in systems code. In
Proceedings of the Eighteenth ACM Symposium on Operating Systems
Principles (New York, NY, USA, 2001), SOSP ’01, ACM, pp. 57–72.

[14] FELMETSGER, V., CAVEDON, L., KRUEGEL, C., AND VIGNA, G. Toward

automated detection of logic vulnerabilities in web applications. In Proceedings
of the 19th USENIX Conference on Security (Berkeley, CA, USA, 2010),
USENIX Security’10, USENIX Association, pp. 10–10.

[15] FELT, A. P., FINIFTER, M., WEINBERGER, J., AND WAGNER, D. Diesel:
Applying privilege separation to database access. In Proceedings of the 6th
ACM Symposium on Information, Computer and Communications Security
(New York, NY, USA, 2011), ASIACCS ’11, ACM, pp. 416–422.

[16] FERRAIOLO, D. F., SANDHU, R., GAVRILA, S., KUHN, D. R., AND

CHANDRAMOULI, R. Proposed nist standard for role-based access control.
ACM Trans. Inf. Syst. Secur. 4, 3 (Aug. 2001), 224–274.

[17] GANAPATHY, V., KING, D., JAEGER, T., AND JHA, S. Mining

security-sensitive operations in legacy code using concept analysis. In
Proceedings of the 29th International Conference on Software Engineering
(Washington, DC, USA, 2007), ICSE ’07, IEEE Computer Society,
pp. 458–467.

[18] HORWITZ, S., REPS, T., AND BINKLEY, D. Interprocedural slicing using

dependence graphs. In Proceedings of the ACM SIGPLAN 1988 Conference on
Programming Language Design and Implementation (New York, NY, USA,
1988), PLDI ’88, ACM, pp. 35–46.

[19] JOVANOVIC, N., KRUEGEL, C., AND KIRDA, E. Pixy: A static analysis tool

for detecting web application vulnerabilities (short paper). In IN 2006 IEEE
SYMPOSIUM ON SECURITY AND PRIVACY (2006), pp. 258–263.

[20] KRISHNAMURTHY, A., METTLER, A., AND WAGNER, D. Fine-grained

privilege separation for web applications. In Proceedings of the 19th
international conference on World wide web (New York, NY, USA, 2010),
WWW ’10, ACM, pp. 551–560.

[28] XIE, Y., AND AIKEN, A. Static detection of security vulnerabilities in scripting

languages. In Proceedings of the 15th Conference on USENIX Security
Symposium - Volume 15 (Berkeley, CA, USA, 2006), USENIX-SS’06, USENIX
Association.

[29] YIP, A., WANG, X., ZELDOVICH, N., AND KAASHOEK, M. F. Improving

application security with data ﬂow assertions. In Proceedings of the ACM
SIGOPS 22Nd Symposium on Operating Systems Principles (New York, NY,
USA, 2009), SOSP ’09, ACM, pp. 291–304.

APPENDIX
A. Appendix

Table 6 shows the set of input information (hints) we provided
for our tool MACE. Gathering this information about each appli-
cation requires minimal effort and some familiarity with the appli-
cations, as discussed in Section 5.4.

Table 6: Provided Annotations to MACE

Application
phpns

DCPPortal

DNScript

myBloggie

miniBloggie
SCARF

WeBid

Input Variables
$globalvars[’rank’],
$_COOKIE[’cookie_auth’],
$_SESSION[’auth’],
$_SESSION[’username’],
$_SESSION[’userID’],
$_SESSION[’permissions’],
$_SESSION[’path’]
$_COOKIE["dcp5_member_id"],
$_COOKIE["dcp5_member_admin"],
$HTTP_COOKIE_VARS-
-["dcp5_member_admin"]
$_SESSION[’admin’],
$_SESSION[’member’]
$_SESSION[’username’],
$userid[’level’],
$_SESSION[’user_id’]
$_SESSION[’user’]
$_SESSION[’privlege’],
$_SESSION[’user_id’]
$_SESSION[’WEBID_LOGGED_IN’],
$user_data[’groups’],
$_SESSION[’WEBID_ADMIN_USER’],
$_SESSION[’WEBID_ADMIN_IN’],
$group[’can_sell’],
$group[’can_sell’],
$group[’auto_join’]

Role Values
(dynamic)

(dynamic)

1for admin,
0 for non-admin
1(for admin),
2 (for normal)

-
’admin’, ’user’

admin
role ﬂag,
user groups have
dynamic values

[21] PARNO, B., MCCUNE, J. M., WENDLANDT, D., ANDERSEN, D. G., AND

PERRIG, A. Clamp: Practical prevention of large-scale data leaks. In
Proceedings of the 2009 30th IEEE Symposium on Security and Privacy
(Washington, DC, USA, 2009), SP ’09, IEEE Computer Society, pp. 154–169.
[22] PELLEGRINO, G., AND BALZAROTTI, D. Toward black-box detection of logic

ﬂaws in web applications. In NDSS 2014, Network and Distributed System
Security Symposium, 23-26 February 2014, San Diego, USA (San Diego,
UNITED STATES, 02 2014).

[23] Ruby on rails website. http://rubyonrails.org/, 2011.
[24] SON, S., MCKINLEY, K. S., AND SHMATIKOV, V. Rolecast: ﬁnding missing
security checks when you do not know what checks are. In Proceedings of the
2011 ACM international conference on Object oriented programming systems
languages and applications (New York, NY, USA, 2011), OOPSLA ’11, ACM,
pp. 1069–1084.

[25] SRIVASTAVA, V., BOND, M. D., MCKINLEY, K. S., AND SHMATIKOV, V. A

Security Policy Oracle: Detecting Security Holes using Multiple API
Implementations. In PLDI’11: Proceedings of the 2011 ACM SIGPLAN
Conference on Programming Language Design and Implementation (San Jose,
CA, USA, 2011).

[26] SUN, F., XU, L., AND SU, Z. Static detection of access control vulnerabilities
in web applications. In Proceedings of the 20th USENIX conference on Security
(Berkeley, CA, USA, 2011), SEC’11, USENIX Association, pp. 11–11.
[27] TAN, L., ZHANG, X., MA, X., XIONG, W., AND ZHOU, Y. Autoises:

Automatically inferring security speciﬁcations and detecting violations. In
Proceedings of the 17th Conference on Security Symposium (Berkeley, CA,
USA, 2008), SS’08, USENIX Association, pp. 379–394.

701