Eradicating DNS Rebinding with the  

Extended Same-Origin Policy
Martin Johns and Sebastian Lekies, SAP Research;  

Ben Stock, Friedrich-Alexander-Universität Erlangen-Nürnberg

Open access to the Proceedings of the 22nd USENIX Security Symposium is sponsored by USENIXThis paper is included in the Proceedings of the 22nd USENIX Security Symposium.August 14–16, 2013 • Washington, D.C., USAISBN 978-1-931971-03-4Eradicating DNS Rebinding with the Extended Same-Origin Policy

Martin Johns
SAP Research

martin.johns@sap.com

Sebastian Lekies
SAP Research

sebastian.lekies@sap.com

Ben Stock

FAU Erlangen-Nuremberg

ben.stock@cs.fau.de

Abstract

The Web’s principal security policy is the Same-Origin
Policy (SOP), which enforces origin-based isolation of
mutually distrusting Web applications. Since the early
days, the SOP was repeatedly undermined with variants
of the DNS Rebinding attack, allowing untrusted script
code to gain illegitimate access to protected network re-
sources. To counter these attacks, the browser vendors
introduced countermeasures, such as DNS Pinning, to
mitigate the attack. In this paper, we present a novel DNS
Rebinding attack method leveraging the HTML5 Appli-
cation Cache. Our attack allows reliable DNS Rebinding
attacks, circumventing all currently deployed browser-
based defense measures. Furthermore, we analyze the
fundamental problem which allows DNS Rebinding to
work in the ﬁrst place: The SOP’s main purpose is to en-
sure security boundaries of Web servers. However, the
Web servers themselves are only indirectly involved in
the corresponding security decision.
Instead, the SOP
relies on information obtained from the domain name
system, which is not necessarily controlled by the Web
server’s owners. This mismatch is exploited by DNS Re-
binding. Based on this insight, we propose a light-weight
extension to the SOP which takes Web server provided
information into account. We successfully implemented
our extended SOP for the Chromium Web browser and
report on our implementation’s interoperability and se-
curity properties.

Introduction

1
The Web has won. No other platform for distributed ap-
plications can rival the Web’s ubiquity and ﬂexibility.
The functionality demands of the ever-expanding Web
application paradigm caused the browser to evolve from
a simple program to display hypertext documents into a
full-ﬂedged runtime environment for sophisticated, net-
worked applications. This evolution is still in full effect,
with HTML5 and related JavaScript APIs being the latest

addition to the browser model. In the context of Web ap-
plications, fundamental security properties are governed
by the Same-Origin Policy (SOP): The SOP is the Web’s
principal security policy. It provides origin-based isola-
tion of Web applications.

In the recent past, low-level vulnerabilities have be-
come considerably harder to ﬁnd and exploit. Hence, the
ever growing capabilities of the Web browser make it an
increasingly interesting offensive tool for attackers [8]:
The Web browser runs behind the ﬁrewall within the
boundaries of the internal network and executes code that
was retrieved from the Internet. Thus, the SOP consti-
tutes the only barrier between attacker provided code and
the crown jewels in the internal network. Unfortunately,
the SOP is far from bulletproof: Soon after the introduc-
tion of the policy in 1996, clever students at Princeton
university found a way to utilize attacker controlled DNS
settings to subvert the policy [25]. The underlying attack
is today known as “DNS Rebinding” [14]. Since then,
DNS Rebinding remained a constant problem of the SOP
that was (re)discovered multiple times and, subsequently,
attempted to be ﬁxed.

In this paper, we demonstrate how the HTML5 Ofﬂine
Application Cache can be misused to conduct reliable
DNS Rebinding attacks. Our attack works with all major
browsers, circumvents all current browser-based coun-
termeasures, and affects most browser-based scripting
runtime environments (JavaScript, Flash, Silverlight).
Furthermore, we revisit the underlying problem of the
SOP and propose a light-weight but powerful extension
to the policy, which tackles the root cause of the problem.
Contribution and paper organization: After cover-
ing the required technical background (see Sec. 2) and
the history of DNS Rebinding (see Sec. 3), we make the
following contributions:

• DNS Rebinding and the AppCache (Section 4): We
present a novel attack technique, capable of circum-
venting any existing browser-based countermeasure

USENIX Association  

22nd USENIX Security Symposium  621

In our attack, we utilize
against DNS Rebinding.
the HTML5 Ofﬂine AppCache to persist a malicious
script until any domain-to-IP information is lost. In
theory, caching-based attack scenarios are already
known. However, the unpredictable and short-lived
nature of the browser’s caching behavior rendered
them fragile to a level of unfeasibility.
In this pa-
per, we show how the unique characteristics of the
AppCache can be leveraged by the attacker to create
highly reliable DNS Rebinding attacks.

• Vulnerability demonstration (Section 5): To validate
our attack method and to demonstrate its severity, we
present two practical attacks on real-world applica-
tions utilizing Web interfaces. For our experiments,
we chose the light-weight proxy server Polipo, and
the Unix-based printing system CUPS. The effects of
our demonstration exploits range from simple infor-
mation leakage to remote code execution.

• Extended Same-Origin Policy (Section 6): We ana-
lyze the fundamental problem that causes DNS Re-
binding to work. Thereby we identify a mismatch
between the semantics and the implementation of the
Same-Origin Policy: The SOP’s main purpose is to
ensure security boundaries of Web servers. How-
ever, the Web servers themselves are only indirectly
involved in the corresponding security decision.
In
order to overcome this mismatch, we propose a light-
weight extension to the Same-Origin Policy that con-
siders server-provided origin information. Our ex-
tended SOP reliably defeats DNS Rebinding attacks
while increasing interoperability with mechanisms
that rely on ﬂexible DNS setups, such as DNS-based
load-balancing or Content Distribution Networks.

• Implementation for the Chromium browser (Sec-
tion 7): To demonstrate the practical applicability of
our approach, we implemented it for the open-source
browser Chromium. The implementation required in
total 34 lines of code and does not cause a perceivable
performance overhead.

We end the paper with a review of related work (Sec. 8)
and a conclusion (Sec. 9).

2 Technical Background
In this section, we brieﬂy cover selected topics that are
necessary to discuss the paper’s technical content.

2.1 The Same-Origin Policy
The Same-Origin Policy (SOP) was designed to enforce
origin-based isolation of mutually distrusting Web appli-
cations. Several variants of the policy exist [38]. In this
section, we focus the SOP for JavaScript [31].

In general, the Same-Origin Policy [14] is the main
security policy for all active content that is executed in a

Web browser within the context of a Web page. This pol-
icy restricts all client-side interactions to objects which
share the same origin. In this context, an object’s origin
is deﬁned by the domain, port, and protocol, which were
utilized to obtain the object. Hence, a JavaScript snip-
pet is only allowed to access a resource if its own origin
exactly matches the origin of the resource. The SOP for
plug-in based script content, such as Flash or Silverlight,
enforces similar rules.

Developers can adjust a JavaScript snippet’s origin
slightly by modifying the document.domain DOM
property: The value of this property can be set to omit
the values of subdomains up to the second level domain
value (e.g., relaxing www.example.org to example.org).
This process is known under the term “domain relax-
ation”.

2.2 The HTML5 AppCache
Modern Web applications have one crucial disadvantage
compared to desktop applications: Such applications can
only be used when a network connection is available. In
order to eradicate this disadvantage the HTML5 Ofﬂine
Application Cache (AppCache) was introduced [10]. The
AppCache is a mechanism that can be utilized to store re-
sources (such as HTML documents, images, etc) within
the browser for ofﬂine usage. In order to employ the Ap-
plication Cache, a Web site may provide a manifest ﬁle
containing a list of resources. The manifest ﬁle’s loca-
tion can be speciﬁed within the manifest attribute of a
document’s HTML tag as shown in Listing 1.

Listing 1: HTML5 Manifest attribute

1

2

<html manifest="manifest.mf">
[...]

When a browser discovers this attribute, it fetches the
ﬁle and caches the listed resources within the AppCache.
Listing 2 shows an exemplary manifest ﬁle that advises
the browser to cache index.php as well as a ﬂash
applet named flash.swf. As soon as a cached re-
source is requested again, the Application Cache returns
the cached HTTP response even if an Internet connec-
tion is available. After each access to the AppCache,
the browser downloads the manifest ﬁle again to check
whether it has changed. The resources within the App-
Cache are only updated if the manifest has changed - oth-
erwise the resources reside within the cache even if their
server-side counterparts have changed.

Listing 2: Exemplary manifest ﬁle (excerpt)

CACHE MANIFEST

http://example.org/index.php
http://example.org/flash.swf

1

2

3

4

622  22nd USENIX Security Symposium 

USENIX Association

USENIX Association  

22nd USENIX Security Symposium  623

3DNSRebindingDNSRebindingisatermintroducedby[14],whichde-scribesaclassofWebbrowser-basedattacksthatunder-minetheSOPthroughsophisticatedmappingofDNSentriestorestrictednetworkresources.InSection3.1wegiveafullaccountonthehistoricaldevelopmentoftheseattackmethods.Intheremainderofthissection,webrieﬂyrevisitthebasicattackpattern.ThedecisionifagivenJavaScriptisgrantedaccesstoacertainresource(e.g.,browserwindow,ornetworklocation)isgovernedbytheSOP.Asexplainedearlier,theSOPreliesonthedomainpropertyoftherespectiveentity’sorigins.However,theHTTPprotocoldoesnotrequireanyinformationabouttherequesteddomain.TheactualHTTPconnectionsaremadeusingtheserver’sIP.Anattackercanexploitthisfactanattackerissuesaveryshort-livedDNSentryforanattackercontrolledwebpage.WheneveravictimvisitsthisparticularWebsite,thevictim’sbrowserfetchestheDNSentry,con-nectstotheprovidedIPaddressanddownloadsattackercontrolledJavaScriptorplug-incode.Thiscodeisonlycapableofcreatingnetworkconnectiontosame-domainhostsduetotheSOP.Inthemeantime,theDNSentryexpiredandtherefore,assoonasanotherrequestiscon-ductedtowardsthesamedomain,anewDNSentryhastobefetched.Theattackerisabletoexploitthisbehav-iorbyalteringthedomain-to-IP-mapping.ByprovidinganIPofthevictim’sintranet,thebrowserconnectstotheintranetIPassoonastheJavaScriptconductsasame-domainrequest(seeFig.1).AstheIPisnotapartoftheSame-Origincheck,thepolicyisstillfulﬁlledand,therefore,theattackercontrolledscriptisgrantedaccesstotheresponseoftheintranethost.Thereby,potentialoffensivescenariosarenotlimitedtoinformationleak-ageattacksoninternalservers.DNSRebindingcan,forinstance,alsobeusedtoconductclickfraud,defeatingIP-basedauthentication,orhijackingofIPaddresses(re-ferto[14]foracomprehensiveoverview).Nonetheless,forreadabilityreasons,fromnowonwewillusethein-formationleakageattackasthemotivationalexample.3.1TheHistoryofDNSRebindingAswewillshowinthissection,thehistoryofDNSRe-bindingreachesbackintimetotheearlydaysinwhichtheSOPjuststartedtoemerge.Overtheyears,theattackwasdiscussedunderseveraldifferentnames,including“anti-DNSpinning”[7]and“Quick-swapDNS”[21].Inthistime,severalvariantsoftherebindingattackhavebeendeveloped,eitherwithfocusondifferentbrowser-basedtechnologies[18,25,29],withnewtech-niquestocircumventtheimplementedmitigationmea-sures[3,15,28,34],orwithfocusonnovelattacktar-gets[9,14].Nonetheless,thegeneraltechniquere-6.6.6.610.10.10.2010.10.10.10InternetFigure1:Intranetattackscenariomainedstable:Mappinganattacker-controlledDNSen-trytoarestrictednetworkresourceandsubsequentlyus-ingactivebrowsercontenttoaccesstheresource.Inthissection,wegiveabriefoverviewonthedevel-opmentsofthepastyears.Ingeneral,thehistoryofDNSRebindingcanbedividedintothreedistincttimespans,eachstartingwiththe(re)discoveryofthebasicissueforaseparatebrowser-basedtechnology:1996(Javaap-plets),2002(JavaScript),2006(Flash,JavaScript,Java).3.1.11996-JavaAppletsPrinceton’sSecureInternetProgramminggroupﬁrstmentionedtheattackmethodin1996[25].Backthen,JavaScriptnetworkingcapabilitieswereratherlimited,whileJavaAppletsalreadyallowedcomparativelyso-phisticatednetworkingfunctionality[4,25].Tobeprecise,thePrincetonattackdidnotrelyonDNSRebindingperse.Instead,theattackutilizedDNSrecords,whichreturnedtwoIPaddressesforthead-versary’sdomain:TheIPoftheattacker’sserver,fromwhichtheappletwasloadedandanotherIPpointingtothetargetoftheattack.Astheadversarycontrolstheor-derofthevaluesintheDNSresponse,theappletcouldbetrickedtoconnecttothetargetsystem.Tomitigatetheis-sue,Java’svendorSUNintroducedstrictIPbasedaccesscontrol[24]:Aftertheinitialloadingofanapplet,theonlyIPtheappletisallowedtoaccessistheIPaddressitwasoriginallyobtainedfrom,regardlessofinformationprovidedbyDNS.Thisrestrictionismaintainedfortheentirelifespanoftheapplet.3.1.22002-JavaScriptThePrincetonattackwasextendedbyAdamMegacztoJavaScriptin2002[21].Megaczpresentedtwovariantsof the attack. For one, he utilized domain relaxation. In
this case, the malicious JavaScript was hosted on a sub-
domain of the adversary’s server, e.g., sub.attacker.org.
The DNS entry for the father domain attacker.org pointed
to the internal host. After being loaded in the victim’s
browser,
the script relaxed its document.domain
value to the father domain and, thus, was subsequently
granted access to the internal server. The second attack
variant, named “Quick-swap DNS” was roughly equiva-
lent to the general attack scheme presented in Section 3.
In response to Megacz’s security advisory, Netscape
implemented explicit “pinning” of the domain-to-IP
mapping for the lifetime of the Web page. In addition,
to mitigate the domain relaxation based attack, a patch
was created that required both parties in a domain relax-
ation scenario to assign the document.domain prop-
erty to the same value. Versions of Internet Explorer that
followed Megacz disclosure, exposed behavior similar to
Netscape’s browser. However, in 2007 Microsoft’s Dave
Ross gave to record that the observed DNS pinning was
incidental and not introduced as a security measure [30].

3.1.3 2006 - The full browser experience

In 2006, Martin Johns discovered a technique to reliably
cause Firefox and Internet Explorer to drop any domain-
to-IP mapping, which in turn re-enabled the rebinding
attack for JavaScript [15]. In the following months, sev-
eral additional DNS Rebinding attack methods were dis-
closed: Kanatoko showed that Flash applets were also
susceptible to the attack [18]. Also, Johns and Kanatoko
documented a method to use the LiveConnect JavaScript-
to-Java bridge to utilize Java methods in rebinding at-
tacks [16]. Moreover, two further methods were discov-
ered which allowed DNS Rebinding attacks on Java Ap-
plets: Rios and McFeters [28] tricked Java’s applet cache
by using multiple instances of the Java VM and David
Byrne leveraged a mismatch in communication channels,
in case the Java VM was conﬁgured to access the net-
work with a Web proxy [3]. Finally, Dafydd Stuttard ex-
amined the effects of Web proxies on DNS pinning [34].
The susceptibility of the plug-in technologies Flash
and Java enabled the usage of low-level socket commu-
nication in rebinding. This expanded the resulting at-
tack surface towards non-HTTP network services. Fur-
thermore, socket connections could be utilized to cir-
cumvent HTTP-based countermeasures, such as host-
header checking [7].

Additionally, multiple public demonstrations on the
capabilities of the attack vector have been given. No-
table in this context are the experiments by Jackson et
al. [14]: Using a speciﬁcally crafted Flash advertisement
delivered by a major advertising network, the group was
able to take over 27,480 unique IPs for a total amount

of less then 30 US dollars. In response to the disclosed
attacks, the vendors of Flash and Java introduced further
restrictions on their socket-level network capabilities.

3.2 Capabilities and limitations of avail-

able countermeasures

Over the years, several practical and experimental coun-
termeasures to protect against DNS Rebinding attacks
have been introduced.

3.2.1 DNS Pinning

As previously discussed, most browser and plug-in ven-
dors primarily reacted to DNS Rebinding by introduc-
ing DNS Pinning. When DNS Pinning is used, a Web
resource’s IP-to-DNS mapping is maintained for a pro-
longed timespan, ideally exceeding the lifetime of the
resource.While being able to provide basic protection
properties, DNS Pinning has security and functionality
drawbacks: For one, DNS pinning is inherently incom-
patible with all technical measures that rely on dynamic
and potentially changing DNS answers, such as load bal-
ancing, active failover, disaster recovery [1], or Content
Distribution Networks. Also, DNS Pinning is unable to
protect if Web proxies are part of the communication
path to the server [21, 34] or in content caching scenarios
(more on this in Section 4).

3.2.2 Limiting internal IP ranges

Due to the speciﬁc nature of DNS Rebinding, internal
servers are the prime target of the attack. Hence, sev-
eral techniques have been presented that protect internal
network resources against external scripts.
In general,
these approaches primarily protect resources hosted on
the “private” netblocks of the IPv4 space, as deﬁned by
RFC 1918 [26]. For one, such protection can be imple-
mented on the DNS level: DNSWall [2] is a daemon
that is designed to be used in conjunction with an ex-
isting recursive DNS resolver.
It ﬁlters out RFC 1918
addresses in DNS responses. Also, the OpenDNS ser-
vice offers a similar option [36]. Furthermore, similar
protection can be achieved within the browser: Opera re-
fuses script code which was obtained from an external
source to access internal RFC 1918 IP ranges. The Fire-
fox extensions NoScript [20] and LocalRodeo [17] can
be conﬁgured to do the same.

The attempt to provide protection by restricting ac-
cess to private IP ranges is necessarily incomplete. For
one, network based access control is not limited to
RFC 1918 ranges. In addition, bigger organizations, such
as large companies or universities, do not always use

624  22nd USENIX Security Symposium 

USENIX Association

RFC 1918 addresses for their internal networks. Fur-
thermore, with the growing support for IPv6 many use
cases for RFC 1918 addresses cease to exist, as there is
no shortage of IPv6 addresses. Finally, Craig Heffner
has demonstrated [9], that even in cases where access to
the private IP ranges is protected against DNS Rebind-
ing attacks, under certain conditions the adversary can
use rebinding to gain privileged access to local network
resources, if these resource listens both on a private and
a public IP address.

3.2.3 Application-layer protection of servers
Servers can implement active protection against the at-
tack. A straight forward choice is requiring authenti-
cation before an internal server can be accessed. As
the rebinding attack utilizes the adversary’s domain, pre-
existing authentication credentials, such as session cook-
ies, cannot be abused by the attacker and, hence, the re-
stricted data should be safe. Additionally, servers can
implement host-header checking: The attacker’s HTTP
requests carry the domain name of the attacker’s server
in their host-header. Hence, the attack can be spot-
ted and the access can be stopped, which usually is done
by throwing a 400/500 server error or responding with a
standard error message. However, this measure does not
resolve the issue completely. The browser still allows
the script to omit the request and receive the response.
So even though, the server’s data cannot be obtained, the
attack vector may still leak valuable information to the
attacker, such as validation that the server exists and ma-
terial to do server-type and software ﬁngerprinting. Also,
while sounding straight-forward, host-header checking
can be error-prone, as our experiments with CUPS has
shown (see Sec. 5.2): Even though CUPS implements
the check, the implementation is incomplete and grants
an attacker access to a subset of the tool’s data. Both
techniques have in common, that they have to be intro-
duced manually for each server on the application layer.

4 DNS rebinding using HTML5 AppCache

In the previous section we explained the basic mech-
anisms of DNS Rebinding.
In order to counter these
attacks browser vendors introduced a technique called
DNS Pinning. In this section we show how this technique
can be circumvented to reliably conduct DNS Rebinding
attacks using the HTML5 Ofﬂine Application Cache.

4.1 Rebinding HTML/JavaScript content
pinning is to avoid the interaction of content that is
served via the same origin, but received from different
hosts. As soon as a DNS query is conducted, the browser

pins the received domain-to-IP mapping. Subsequent re-
quests conducted towards this origin are then exclusively
sent to the host utilizing the “pinned” IP. Thus, while
DNS pinning is active, content fetched from one ori-
gin always corresponds to the same host.
Ideally, the
pinning information should be stored as long as a re-
source resides within the browser. However, as men-
tioned already, DNS Pinning interferes with techniques
such as load-balancing, active failover and disaster re-
covery [5]. The longer the pinning times, the bigger is
the negative effect on these techniques. In the worst case,
if the domain-to-IP mapping information are stored by
the browser for an unlimited amount of time, these tech-
niques would be more or less useless. Therefore, pinning
durations differ substantially from browser to browser.
However, all major browsers have one thing in common:
As soon as the user closes the browser, the pinning infor-
mation is automatically deleted. This also affects Web
content which ended up in the browser’s cache. Hence,
a hunch about potential DNS Rebinding issues through
cached content existed for some time [32].

The basic attack via cached content is similar to the
general DNS Rebinding attack as described in Section 3.
This time, however, we assume that DNS Pinning is in
place and therefore the basic attack does not work as de-
scribed. When caching comes into play, an attacker can
re-enable the attack. This advanced attack, thereby, con-
sists of two separate steps. In the ﬁrst step the attacker
lures the victim onto a prepared Web site and forces
the browser to cache the attacker controlled contents.
As DNS pinning is active this content is not yet able
to launch a DNS Rebinding attack. However, browsers
do not persist the domain-to-IP mapping and dispose it
eventually. In the second step, at some later point in time,
the attacker again lures the victim onto the Web page.
This time the content is fetched from cache and therefore
no DNS Queries or TCP connections are created. Only
the origin information (protocol, domain, port) and the
resources are retrieved from cache. When the cached re-
sources attempt to create network connections to its own
origin, no domain-to-IP mapping is available and there-
fore a fresh DNS Query is conducted opening up a vector
for DNS rebinding.

Until today, it was difﬁcult to launch such an attack
as a browser’s caching behavior is rather unpredictable
and the adversary has only limited means to inﬂuence
which content actually gets cached. The browser cache
has a ﬁxed size and in general handles cached content
in a ﬁrst-in-ﬁrst-out fashion. Given the size of current
Web sites, even a moderately used browser’s cache ﬁlls
up quickly and even recently cached content often gets
discarded quickly [11]. Hence, depending on the given
circumstances, the chances of keeping the attack script
in the cache long enough for a successful attack tend

USENIX Association  

22nd USENIX Security Symposium  625

to be small. This changes with the introduction of the
HTML5 Ofﬂine Application Cache. Compared to a tra-
ditional cache the AppCache provides an attacker with
two novel capabilities that make attacks feasible:

• Controllable caching behavior: Using the AppCache
manifest, the attacker can advise the browser to cache
certain resources in a reliable way. As soon as the
resources are stored within the AppCache, they reside
in the browser for a potentially unlimited amount of
time (until the attacker’s application or the user decide
to empty the cache manually).

• JavaScript API: The AppCache provides an API that
allows JavaScript to identify whether it was loaded
from cache or via the network.

Using these two ingredients, an attacker can conduct
reliable DNS Rebinding attacks:
In the ﬁrst step the
attacker lures the victim onto his Web site. The Web
site uses a manifest ﬁle to cache an adversary con-
trolled Web page within the Application Cache. After
the browser deleted the DNS Pinning information, the
adversary waits until the user visits the same site again.
This time the Web page is loaded from the AppCache and
no domain-to-IP mapping is available. Using the App-
Cache’s JavaScript API, scripts contained in the page
can verify that they indeed have been retrieved without
network interaction. Hence, the cached script can now
conduct same-origin requests towards the IP returned
in the second DNS query (which the attacker controls
completely). After the attacker’s payload was loaded
from cache, the AppCache revalidates the manifest ﬁle
by downloading it from the attacker’s domain. As this
domain now points to the victim’s IP address, the mani-
fest will not be found and the cache will automatically be
deleted (including the evidence for the attack). However,
the attack has already taken place.
In Section 4.2 we
demonstrate, how an attacker is able to avoid the dele-
tion of its content, in case he wants to conduct multiple
attacks upon the same victim.

The attack demonstrated in this section only targets
one speciﬁc victim. Nevertheless, the attack scheme can
be extended to conduct large-scale attacks.
Instead of
conducting a rebinding attack directly on the main do-
main, the attacker could simply forward each user onto
a distinct subdomain that can be rebound separately. As
soon as one DNS query arrived at the attacker’s DNS
server for a speciﬁc subdomain, the DNS server could
rebind the IP immediately.
In the ﬁrst step the user’s
browser pins the IP and therefore only sends one initial
DNS request. Thus, if a second request arrives, the user’s
browser must have deleted the pinning information and
is in need to refresh the information (opening the DNS
Rebinding vector). The only challenge the attacker has

to solve in step 2 is to forward the user to the same sub-
domain as utilized for this speciﬁc user in step 1. To
identify whether the user has already conducted step 1
the attacker could simply utilize cookies that store the
subdomain information on the victims computer until the
next visit.

4.2 Utilizing multiple domains for reliable

DNS Rebinding attacks

The previously described attack has one major weak-
ness: As explained in Section 2.2, the AppCache revali-
dates the cache manifest after each access. If the mani-
fest changed, ﬁles in the cache will be updated/deleted
accordingly. Hence, in the last step of the attack, af-
ter the malicious script was fetched from the Applica-
tion Cache, the browser revalidates the manifest ﬁle from
the attacker’s domain. Since the domain is, at this point
in time, bound to the intranet host’s IP, the browser re-
quests the manifest ﬁle from the intranet host. As the
ﬁle will typically not be available on the rebound server,
the browser deletes the cached content. Nevertheless, the
attacker is able to execute the malicious script at least
once, as the cache validation takes place after the access
to the cache. However, if the attack fails, e.g. because the
user closed the browser before the script was executed
completely, the attacker has to start the whole process of
rebinding from scratch. For large-scale, automated at-
tacks this is not a feasible solution. In order to overcome
this issue, a more sophisticated attack scenario can be
used. In this scenario, we are able to prevent the dele-
tion of cached content after the rebinding step has taken
place by utilizing two distinct domain names. Thereby,
we are able to reliably repeat an attack multiple times
without the need for rebinding a domain name over and
over again. The attack thereby works as follows:

1. An attacker

is in control of

two domains (at-
tacker1.org and attacker2.org) and the corresponding
DNS server. In order to set up a DNS Rebinding at-
tack, the attacker deploys an HTML document and an
ofﬂine manifest to attacker1.org. The HTML docu-
ment embeds (via frame, object or embed tags) ac-
tive content (JavaScript, SVGs, Flash or Silverlight
applets, etc) served by attacker2.org.

2. The attacker lures a user onto attacker1.org. Con-
sequently, the user’s browser renders the malicious
HTML document and interprets the corresponding
manifest ﬁle. Due to the instructions contained within
the manifest, the browser caches the HTML document
as well as the active elements.

3. By closing the browser, the user deletes the DNS pin-
ning information. In the mean time, the attacker re-
binds attacker2.org to the IP of an intranet host.

626  22nd USENIX Security Symposium 

USENIX Association

4. The attacker again lures the user onto attacker1.org.
The Web page and the active elements are loaded
directly from cache. As the page utilizes embed,
frame or object tags for embedding the active ele-
ments, these elements are executed within the origin
of attacker2.org. Due to the fact that attacker2.org is
bound to the intranet IP, the active content is now able
to communicate with intranet applications.

Analysis: In this scenario, as opposed to the ﬁrst at-
tack, the manifest ﬁle resides on a domain that is not
subject to rebinding. Hence, when the cache validation
takes place, the manifest is still available. Consequently,
the browser does not delete the cached content. This is
an important fact as it simpliﬁes the attack a lot. If we
take, e.g., a corporate wiki containing a multitude of in-
formation, the extraction and transfer of the data to the
attacker would consume a large amount of time. How-
ever, the attacker can only extract the data while the user
still visits the malicious Web site. If the user leaves the
Web site before all parts of the data were extracted, the
attacker is able to again lure the user onto the vulnerable
page to continue the extraction process instead of need-
ing to re-iterate the ﬁrst rebinding step.

4.3 Caching of plug-in content
As mentioned before, the AppCache can be used to store
cross-domain resources for ofﬂine usage, which is a key
enabler for the attack described in the previous section.
However, the browser implementations differ in the way
they utilize the cache when it comes to cross-domain
caching and in the way they defend against rebinding at-
tacks. In this section we shed light on these differences
and explain how an attacker can make use of them.
HTML/SVG documents Caching of HTML and SVG
documents works across all browsers in the same-domain
scenario. However, when it comes to cross-domain
caching the behaviors of browsers differ substantially.
For the second attack, a distinct document embeds an
HTML or SVG ﬁle from a second domain via frame
or object tags. The manifest ﬁle resides on the ﬁrst
domain, hence referencing the HTML/SVG ﬁle across
domain boundaries. While WebKit-based browsers (e.g
Safari, Chrome) and Internet Explorer do not fetch such
embedded cross-domain resources from cache, Firefox
and Opera expose a different behavior: Opera fetches
both, content embedded via frame and via object
tags, from the AppCache. Firefox, however, only fetches
HTML/SVG documents from cache when they are em-
bedded via object tags. Therefore, the advanced attack
does not work within Safari or Chrome when utilized in
combination with JavaScript. To overcome this issue an
attacker can utilize plug-ins such as Flash or Silverlight.

Silverlight All popular desktop browsers except Inter-
net Explorer 10 support the cross-domain caching of Sil-
verlight applets within the ofﬂine application cache. This
behavior can be abused to conduct DNS Rebinding at-
tacks within these browsers. A Silverlight applet is, sim-
ilar to JavaScript, able to conduct requests and read the
corresponding responses. Hence, the abilities are similar
to the HTML/SVG case, but the desktop browser sup-
port for the complex attack is better. Mobile browsers,
however, are not able to execute Silverlight applets.

Fortunately,

In earlier versions of Silverlight, it was possible to
also create arbitrary socket connections to same-domain
hosts.
those capabilities are nowadays
severely limited by the underlying security model which
only allows opening of a socket connection when the
receiving host explicitly grants this connection by set-
ting up a whitelisting policy on port 943. If port 943 is
closed, the Silverlight plug-in attempts to download the
policy ﬁle from the Web server’s root directory. Using
the HTML5 Ofﬂine Cache, an attacker is able to cache
such a cross-domain policy at the Web server level. This
allows an attacker to open arbitrary socket connections
to the rebound IP. As this behavior was already mis-
used in earlier rebinding attacks, Microsoft limited the
connection capabilities of Silverlight to a very restricted
port range (4502-4534), effectively reducing the impact
of such attacks.

Flash Similar to Silverlight, browsers also cache Flash
applets within the AppCache. Hence, Flash can be used
as an alternative to Silverlight when conducting a DNS
Rebinding attack with multiple domains. Thereby, Flash
also has the ability to create HTTP requests towards
same-origin resources without restrictions. However,
Flash has two major advantages over Silverlight:

1. Widespread adoption: Although its market share de-
creases, Flash is still present in about 95% of all
browsers [27] (including some mobile browsers).

2. Less restrictive SOP for HTTP requests: Flash only
includes the protocol and the domain into its cross-
domain decision making process [35]. Hence, a Flash
applet is able to send requests to any same-domain
port and receive the corresponding responses. This
behavior can be used to conduct DNS Rebinding at-
tacks on non-HTTP-based intranet services.

Java
Java applets do not utilize the browser’s App-
Cache.
Instead, Java uses its own caching mechanism
that defends against DNS Rebinding by storing the IP
address of the host that served the applet. When con-
ducting a HTTP or Socket connection the applet is only
allowed to connect back to the same IP adress.

USENIX Association  

22nd USENIX Security Symposium  627

SD TD SVG TD F TD SL
Browser
√ -
IE 10
Firefox 14.0.1 √ √
√ -
Chrome 21
√ -
Safari 5.1
√∗ √∗
Opera 12
*: Opera prevents access to RFC 1918 addresses.

-
√
√
√
√∗

-
√
√
√
√∗

Table 1: Desktop browser & Attack Overview

Other plug-ins Beside Flash, Silverlight and Java
there is a multitude of other plug-ins which can poten-
tially be abused to conduct the presented attacks.
If a
plug-in applet can be cached within the browser’s Of-
ﬂine Application Cache, it is very likely that it can also
be used for the outlined rebinding attacks.

4.4 Summary
As seen in this section, there are a lot of technologies that
can be abused by an attacker to gain novel capabilities in
the context of a rebinding attack. In order to summarize
our ﬁndings, Tables 1 and 2 outline which desktop and
mobile browsers are vulnerable to the presented attacks.
As seen within the tables, the attack including a sin-
gle domain (denoted as SD) works within every browser.
The attacks comprising two distinct domain names (de-
noted as TD) affect mainly desktop browsers. The reason
for this is the missing plug-in and SVG support within
mobile browsers. Furthermore, the mobile versions seem
to be more error-prone: The mobile version of Chrome
was not able to render our SVG test case (it showed
a 404 page, although the server logs indicated that the
resource was properly requested), Android’s standard
browser even crashed every time it loaded a Flash ﬁle
from cache.

5 Practical Attacks

To demonstrate the impact of the outlined vulnerabilities,
we deployed a real-world setup including three distinct
hosts (depicted in Figure 1). In this setup we investigated
the susceptibility of two applications (Polipo and CUPS)
by conducting the attack described in Sec. 4.2

5.1 Polipo
Our ﬁrst attack targets a light-weight proxy server called
Polipo, which can be used to connect
to the TOR
anonymizing network. To simplify the handling, Polipo
offers a Web interface for conﬁguration purposes. By de-
fault, this interface listens to port 8123 and does not de-
fend against DNS Rebinding attacks. Via the Web inter-

Browser
SD TD SVG TD F
√ -
Mobile Safari
Android Browser √ n.a.
√ Error
Mobile Chrome
√ -
Mobile Firefox
Table 2: Mobile browser & Attack Overview

n.a.
Crash
n.a.
√

face, a user is able to conﬁgure the proxy settings, which
are, obviously, security critical.

To evaluate Polipo’s resilience against our DNS Re-
binding attack we successfully conducted an attack as
described in Section 4.2. Due to the fact that Polipo does
not implement any countermeasures against DNS Re-
binding, our malicious requests were processed as if the
Web application itself created it. Via this attack, we were
able to remotely change the settings of the proxy server.
Beside the standard proxy functionality, Polipo also of-
fers Web server functionality that can be abused by an at-
tacker to download arbitrary ﬁles from the attacked host.
The Web server is by default only serving the conﬁgura-
tion interface. However, the Web server’s conﬁguration
can also be changed via the conﬁguration interface. In or-
der to steal arbitrary ﬁles, an adversary could simply set
the Web server’s root directory to the server’s root direc-
tory (”/” on Unix-based systems), effectively exposing
all the ﬁles on the host to the outside world. For exam-
ple, by requesting http://attacker2.org:8123/etc/passwd
(were attacker2.org is already bound to the internal host)
our malicious script was able to extract the information
on all the registered user accounts.
5.2 CUPS
CUPS is a printing system for Unix-based operating sys-
tems. It offers a web-based administration interface run-
ning on port 631 (accessible via localhost only). Via this
interface a user can administer the installed printer, mon-
itor print jobs and conﬁgure the print server.
Interest-
ingly, the main administration panel of CUPS protects
against DNS Rebinding attacks by checking the HTTP
host header. Some features also require proper authoriza-
tion, consequently, mitigating the risk of unauthorized
access via DNS Rebinding. Nevertheless, it is still pos-
sible to extract valuable information out of the adminis-
tration interface via a DNS Rebinding attack. The reason
for this is an insufﬁcient protection of log ﬁles that are
accessible via the Web interface. While the main admin-
istrative functions are protected, the page and error log
ﬁles can be accessed with arbitrary host headers. This
allows an attacker to extract the log ﬁles containing sen-
sitive information via DNS Rebinding attacks:

Error log: The error log contains information on
failed print jobs, which can be used for reconnaissance
of a corporate intranet. When a print job fails, technical

628  22nd USENIX Security Symposium 

USENIX Association

details are written into the logs, including the username
of the creator, exact information on the printer addresses
and the administrator of the printer. Furthermore, it con-
tains information on the root directory of CUPS as well
as the value of the current PATH variable of the machine
CUPS is running on.

Page log: The page log gives an overview over the
past print jobs sent to a printer. By extracting the page
log, the adversary receives the names and dates of the
documents that were printed via CUPS. On our test sys-
tem, running Mac OS, we were able to extract the com-
plete printing history of over one year. Thereby, the name
of a document reveals a lot of information such as ab-
sence dates of the employee, data on intellectual prop-
erty, etc.

6 Extending the Same-Origin Policy

As shown in Section 3.1, DNS Rebinding is a constant
problem of the Web application paradigm (as witnessed
in 1996, 2002, and 2006). Taking the attack method
presented in this paper into account, this is the fourth
time that wide-scale DNS Rebinding issues are discov-
ered, even though the basic problem is known since 1996
and has received considerable attention. Hence, it is
safe to conclude that DNS rebinding is a fundamental,
protocol-layer ﬂaw of the Same-Origin Policy, which is
not solvable with the existing means. As discussed in
Section 3.2, all currently available remedies are either in-
complete (e.g., protecting speciﬁc IP ranges) and/or have
to be implemented explicitly on the server-side’s applica-
tion layer (e.g., host header checking).

In this section, we show how the Web interaction
paradigm can be extended in a non-disruptive manner
to enable a robust protection. For this purpose, we ﬁrst
state our design goals (Sec. 6.1) and conduct a root-
cause analysis of DNS rebinding (Sec. 6.2). Then, we
introduce the “Extended Same-Origin Policy (eSOP)“,
starting with simple scenarios (Sec. 6.3) and then itera-
tively explaining how the policy handles non-trivial cases
(Sec. 6.3.1 and Sec. 6.3.2). Finally, after stating the
eSOP’s decision logic (Sec. 6.3.3), we show how the pol-
icy protects against DNS Rebinding attacks (Sec. 6.3.5).

6.1 Design goals
Before going into detail concerning our solution, we
brieﬂy discuss the goals which steered its design process.
As stated above, we are not aiming to create band-aid so-
lutions or incomplete protection measures. Instead, the
goal is to introduce a fundamental solution that is capa-
ble of completely solving DNS Rebinding. In this con-
text, our design goals were as follows:

(DG1) Client-side enforcement: The Same-Origin
Policy is a client-side security policy. Hence, all aspects
of the policy decision and enforcement process should be
conducted in the Web browser.

(DG2) Protocol layer: It should be avoided that Web
applications have to explicitly implement protection or
decision logic on the server-side’s application layer. In-
stead, the designed solution should be capable of provid-
ing transparent protection by default purely on the proto-
col layer.

(DG3) Dedicated security functionality: The history
and present of the Web is full of cases in which non-
security features were (mis)used to realize security func-
tionality. In many cases, the resulting security properties
were fragile, often incomplete and not necessarily future
proof. Therefore, we do not want to rely on non-security
features (i.e., the host header). Instead, dedicated func-
tionality shall be introduced where necessary.

(DG4) Non-disruptive: The solution should be back-
wards compatible. This means, if a given application sce-
nario involves an entity (i.e., Web server or browser) that
does not yet implement the solution, the Web applica-
tion should not break and the security properties should
transparently revert to the currently established state.

6.2 The three principals of Web interaction
As explained in Section 2.1, the Same-Origin Policy’s
duty is to isolate unrelated Web servers. To do so, the
SOP enforces access control in the browser, based on the
“origins” of the corresponding resources. In this context,
such origins are derived from the URLs that are associ-
ated with the interacting resources - usually the URLs of
the enclosing document objects. Hence, the semantics of
the SOP are built around two principals: The browser for
enforcing the policy and the server(s) for providing the
resources which are the subjects of the policy decision.
However, the entities involved in the implementation
of the SOP differ: While the browser remains in charge
of enforcement, the underlying informations are not pro-
vided by the involved Web server(s). Instead, the net-
work in the form of Domain Name System and IP ad-
dresses is utilized to associate the URL-values to the
server resources. Hence, the principal that is central to
the SOP’s purpose, the server, is not even involved in
the actual policy decision. Even worse, security charac-
teristics associated with the server are governed by net-
work resources that are not necessarily controlled by the
server’s owner. As a consequence, a crucial mismatch
exists between the semantics and the implementation of
the SOP. As seen above, DNS Rebinding takes advantage
of this mismatch. In a rebinding scenario, the attacker
utilizes network resources under his control to undermine
the security characteristics of the server.

USENIX Association  

22nd USENIX Security Symposium  629

In summary, the Web application model actually spans
three principals in total: The browser, the server, and the
network. Hence, to address the currently existing mis-
match between policy semantics and implementation, it
is necessary to investigate approaches that involve the
server in the policy decision process.

6.3

eSOP: Extending the SOP with explicit
server-origin

When considering the SOP from an abstract point of
view, a Web “origin” deﬁnes the trust boundaries of a
Web application. Everything within the application’s ori-
gin is fully trusted, everything outside is completely dis-
trusted. Additional browser capabilities, such as domain
relaxation (see Sec. 2.1) and CORS [37], provide meth-
ods to selectively widen the application’s trust bound-
aries. In the last section, we observed that the Web server
itself is left out of the equation in the SOP’s current im-
plementation. This is counterintuitive, as among the in-
volved parties, it is the Web server that should be able
to set its own trust boundaries. However, the Web server
can only indirectly inﬂuence the browser’s enforcement
decisions. Hence, to resolve this shortcoming, we pro-
pose to extend the SOP to include Web server-provided
input. For this purpose, our approach expands the cur-
rent, triple-based SOP with a fourth component that is
provided by the server. Simpliﬁed, our proposed ex-
tended Same-Origin Policy (eSOP) works as follows: All
HTTP responses of a given server carry explicit, server-
provided information of the server’s trust boundaries.
From now on, we refer to this information as the server-
origin. Thus, in the extended model, a Web origin con-
sists of the quadruple {protocol, domain, port, server-
origin}. In consequence, whenever the browser conducts
an eSOP check, not only the classic protocol/domain/-
port triple has to match, but also the server-origin values.
Example 1 (standard behavior): For simple cases, a
Web origin’s domain and server-origin values should not
differ. Take for instance a script running under the ori-
gin {http, example.org, 80, example.org}. This script at-
tempts to access a document in an iframe which also has
the origin {http, example.org, 80, example.org}. All four
elements of the respective Web origins match, thus, the
eSOP is satisﬁed and the access is granted.

6.3.1 Multiple domains as server-origin

However, last section’s simpliﬁed policy decision logic
is not sufﬁcient to cover all application scenarios, that
are allowed with the current SOP. This primarily con-
cerns Web applications which can be accessed via mul-
tiple domain names. For instance, many Web appli-
cations do not distinguish between the main domain

name (e.g., example.org) and its “www” counterpart
(i.e., www.example.org). Similar scenarios exist for ap-
plications accepting requests for multiple top-level do-
mains (e.g., example.com and example.net). Hence, for
resources served by such applications, it is not straight
forward to decide what their corresponding server-origin
is. As stated in design goal 6.1, our solution shall not
require the implementation of application-layer decision
logic on the server-side. In consequence, a solution is
needed which allows server-side conﬁguration on the
protocol-layer. For this reason, the eSOP permits that the
server speciﬁes more than one domain value as its server-
origin. This way, the server-origin precisely speciﬁes a
server’s trust boundaries, i.e, the set of domains which it
grants access in a same-origin context. Furthermore, we
adjust the criteria under which two Web origin quadru-
ples comply to the eSOP: The eSOP is satisﬁed if and
only if the classic protocol/domain/port values of both
quadruples match and the domain value of the acting ori-
gin (i.e., the origin of the script) is included in the server-
origin of the resource which the script tries to access.

Example 2 (multiple server-origins): A Web appli-
cation available via example.org and www.example.org
speciﬁes its server-origin as a tuple of both domains:
(cid:29)example.org, www.example.org(cid:28). A script running in
a document under the origin {http, example.org, 80,
(cid:29)example.org, www.example.org(cid:28)} tries to access a doc-
ument in a iframe which also has the origin {http, ex-
ample.org, 80, (cid:29)example.org, www.example.org(cid:28)}. As
the script’s domain value (example.org) is included in
the target document’s server-origin list (cid:29)example.org,
www.example.org(cid:28), the eSOP is satisﬁed and, thus, the
access is granted.

6.3.2 Handling domain relaxation

The speciﬁc matching criterion for server-origin also al-
lows simple and robust handling of domain relaxation via
setting the document.domain property during client-
side execution: As long as the newly set origin is still in
the target resource’s list of domains, the eSOP allows ac-
cess under the relaxed domain values. This even works
in situations in which the individual subdomains are han-
dled by separate Web servers with potentially different
server-origin conﬁgurations.

Example 3 (domain relaxation): Take a Web appli-
cation on example.org, which has multiple subdomains,
including sub.example.org. The application’s subdo-
mains are handled by dedicated Web servers.
Fur-
the example.org server hosts all resources
thermore,
A script
that are shared among the subdomains.
is executed under
the extended Web origin {http,
sub.example.org, 80, (cid:29)sub.example.org(cid:28)}. Furthermore,
the browser provides a reference to a resource from

630  22nd USENIX Security Symposium 

USENIX Association

the main application with the origin {http, example.org,
80, (cid:30)example.org(cid:29)}. The script assigns the value exam-
ple.org to the document.domain property, thus, ef-
fectively relaxes its domain value to the fathering do-
main. As a result, the script’s effective origin is now
{http, example.org, 80, (cid:30)sub.example.org(cid:29)}. Conse-
quently, the eSOP is now satisﬁed in respect to the refer-
enced resource, as the script’s domain value is included
in the domain set of the resource’s server-origin, and the
access is granted.

6.3.3 The eSOP decision logic
To sum up, we now give a precise deﬁnition of the eSOP.

The eSOP is satisﬁed iff:
{prot1,domain1, port1} == {prot2,domain2, port2}

and

domain1 ∈ server-origin2

If the server-origin2 property is empty, the second
criterion always evaluates as “true”.

The last condition of the eSOP provides robustness
and backwards compatibility with the old behavior. In
addition, to facilitate ﬂexible and easy conﬁguration, we
follow the example of the Content-Security Policy for-
mat [33], and allow the usage of wildcards for subdomain
values within the set of domains in the server-origin, e.g.,
(cid:30)*.domain.com(cid:29).
6.3.4 Communicating the server-origin
The ﬁnal missing puzzle piece is the exact method,
how the server communicates the server-origin prop-
erty of his resources to the browser. We pro-
pose to introduce a dedicated HTTP response header,
X-Server-Origin,
that carries the server-origin
property in the form of a comma-separated list.

Choosing this approach has several advantages: Fore-
most, it is compatible with the caching behavior of Web
browsers. Web browsers are already required to cache
HTTP response headers along with the actual resources,
as they otherwise would not be able to properly interpret
the cached content after retrieving it from storage.
Also, unlike DNS or IP-based protection schemes,
properties communicated via HTTP response headers
are preserved when the browser accesses the network
via a Web proxy. Finally, adding features using new
response headers is non-disruptive, as older browsers
simply ignore unknown response headers. Furthermore,
implementing server-driven security functionality via

[23],
via

In the
HTTP response headers is a proven technique.
recent past, several security measures have successfully
been introduced, that leverage response headers, such as
Clickjacking protection via the X-Frame-Options
protection against SSL-stripping at-
header
tacks
the Strict-Transport-Security
header [12], Content Security Policies,
that are set
the X-Content-Security-Policy or
using
X-WebKit-CSP headers
cross-origin
resource sharing which utilizes the Allow-From-
header [37].

[33],

and

6.3.5 The eSOP and DNS Rebinding

In the previous sections, we discussed the semantics of
the eSOP and the reasoning behind the corresponding
design process. Now ﬁnally, we show that the eSOP is
indeed capable of prevention DNS Rebinding attacks. To
conduct a DNS Rebinding attack, the adversary maps the
DNS setting of a domain to the IP address of the tar-
geted Web server. However, the attacker controlled do-
main value is not in the Web server’s trust boundary. In
consequence, the value will not be included in the list
of domain values in the server’s server origin property.
Therefore, the eSOP check will necessarily fail.

Example 4 (DNS Rebinding): The attacker controls
the domain attacker.org. His goal is to access an internal
wiki server under the domain wiki.corp, which sets a cor-
responding server-origin. In the ﬁrst step of his attack,
the adversary tricks the victim to access the attacker.org,
which still is mapped to a Web server IP under his con-
trol. Hence, the script is handled by the browser under
a Web origin of the form {http, attacker.org, 80, (cid:30). . .(cid:29)}.
Please note, that this Web origin’s server-origin prop-
erty is fully controlled by the attackers, as he creates the
corresponding HTTP response. However, this does not
cause any issues, as the server-origin of the acting script
is irrelevant for the eSOP decision process. Then, the at-
tacker conducts the DNS Rebinding step. Now, the DNS
entry of attacker.org points to the IP address of the in-
ternal server. From this point on, the browser will inter-
pret all resources from the server under the Web origin
{http, attacker.org, 80, (cid:30)wiki.corp(cid:29)}. Following the re-
binding step, the attacker’s script attempts to access Web
resources that are provided by the internal server. How-
ever, as the attacker’s script carries the domain property
attacker.org, which is not included in the list of domains
in the server’s server-origin, the attack fails, even though
the classic protocol/domain/port SOP is satisﬁed.

6.3.6

Invalid eSOP origins

In [13], Jackson and Barth examine a set of proposed
SOP variants with ﬁner-grained origins. Among other

USENIX Association  

22nd USENIX Security Symposium  631

techniques they discuss two approaches closely related
to the eSOP: The Locked SOP and IP-based origins (for
details on these techniques please refer to Sec. 8), which
provide basic protection against DNS Rebinding attacks.
For both techniques they uncover a loophole which re-
enables DNS Rebinding attacks, even if the reﬁned SOP
variant is in place: Take a Web page on an internal host
which intends to import a JavaScript ﬁle from the same
host using a relative URL (see Lst. 3).

Listing 3: Direct script include using a relative URL

1

<script src="jquery.js"></script>

This Web page is retrieved by the browser using the
adversary controlled hostname attacker.org, which re-
solves to the intranet IP 10.10.10.10. Then, before the
script tag is interpreted the rebinding step takes place.
Attacker.org now points to 6.6.6.6 which is owned by
the adversary. Unlike JavaScript execution, HTML-
based script includes are not subject to origin restric-
tions. Hence, a reﬁned SOP has no direct effect here
and the script code is retrieved from the adversary’s host,
circumventing the protection of the reﬁned policy. For-
tunately, in the case of the eSOP such situations are
reliably detectable. The following condition holds for
all HTML documents with origin {prot, domain, port,
server-origin} that were retrieved from an attacked host:
domain /∈ server-origin
This necessarily results from the fact that the adver-
sary cannot control the server-origin of the internal host,
which only contains domain values within the server’s
trust boundaries (which obviously excludes the adver-
sary’s sites).
In such cases, we label the page’s Web
origin as invalid. For Web documents with an invalid
origin caching is disabled and strict DNS pinning is en-
forced for the whole browser session, effectively closing
the loophole.

6.4 Security evaluation
As shown above the eSOP protects against DNS Re-
binding attacks, without requiring additional server-side
logic or speciﬁc actions on the client-side. As soon as
the X-Server-Origin header is present, the browser
is capable of transparently enforcing the policy, fulﬁll-
ing design goals (DG1) and (DG2). Furthermore, due
to communicating the server-origin in the form of an
HTTP response header, the protection is robust in scenar-
ios which caused other countermeasures to fail: HTTP
response headers are cached alongside with the actual
cached resources. Hence, the server-origin is maintained
even in long-term caching scenarios, effectively closing
the attack vector which is the subject of Section 4. In
addition, currently problematic scenarios, in which the

browser has no control over the domain-to-IP mapping,
e.g., through a Web proxy, can be handled conveniently.
The X-Server-Origin header is preserved, even if
Web proxies obstruct the link between domain name and
server address. Hence, the attack scenario described
in [34] (see also Sec. 3.1) is not feasible anymore. Fi-
nally, the eSOP is at least as strong as the currently im-
plemented SOP: The protocol/domain/port-triple is still
required to match, as it is by the classic SOP. Thus, it
is a necessary condition that the access to a resource
is granted under the SOP for the eSOP to be satisﬁed.
Therefore, implementing the eSOP will never lead to se-
curity degradation.

6.5 Functional evaluation

The eSOP is fully backwards compatible to the classic
SOP. In cases that either the browser does not implement
the extended policy or the Web server does not provide a
X-Server-Origin header, the enforced policy trans-
parently reverts back to the standard behavior of match-
ing protocol/domain/port, fulﬁlling design goal (DG4).
A major concern during designing the extended pol-
icy was the aspect of maintainability: Especially in large
set-ups that span multiple Web servers, ensuring that
all server installations provide the exact same values for
the server-origin property, is an unrealistic hard require-
ment. Fortunately, the eSOP’s speciﬁc server-origin
matching criterion (see Sec. 6.3.3) allows a robust and
ﬂexible handling of such situations. The eSOP does not
require the server-origin values to match exactly. The
only requirement is, that the acting domain is whitelisted
in the receiving server-origin. Hence, even in situations
of slightly different server conﬁgurations (much like in
Example 3, Sec. 6.3.2), the functionality of the Web ap-
plication remains undisturbed. Additionally, this robust-
ness property also allows server-origin settings to change
in long term caching scenarios. As long as the initial
domain requirements of the cached resource remain ful-
ﬁlled, the server’s server-origin setting can be extended
or modiﬁed without causing interoperability problems.

Last but not least, an adaption of the eSOP would
obliterate the requirement of DNS Pinning for security
reasons completely. Hence, for servers that provide the
X-Server-Origin header, the DNS TTL value can
be as small as desired. No security degradation will
occur, when browsers respect such small TTL values.
This in turn allows easy setup of highly ﬂexible load-
balancing and error-correcting network setups with mul-
tiple, redundant servers.

632  22nd USENIX Security Symposium 

USENIX Association

USENIX Association  

22nd USENIX Security Symposium  633

7PracticalImplementationInordertovalidatethefeasibility,securityandfunction-alitypropertiesoftheeSOP,weimplementeditfortheChromiumWebbrowser[6].Thereby,weenhancedtheso-calledSecurity-Originwhichstoresthe”protocol,do-mainandport”-tripleofaWebsitebyaddingthepro-posedServer-Origin.Datastoredwithinthisdatastruc-tureisprovidedbytheX-Server-Originresponseheader.Ourimplementationallowstheheadertohavetwotypesofvalues.Iftheserverdoesnotsendtheheaderorsendsanemptyheader,weassumethatitdoesnotimplementourapproachorwantstoopt-outofthepro-tectionmechanism.Inthesecases,weallowaccessre-gardlessoftheactingdomainvalueforbackwardscom-patability.Additionally,theheadercanbesettoalistofcomma-separateddomains.Usingthestoredinforma-tionweareabletosuccessfullypreventrebindingsce-narios.Atthispoint,weneedtodistinguishbetweenXmlHttpRequests(XHRs)andscriptaccesstoaview-port,suchasframesorpopupwindows.ScriptaccesstoaviewportForaviewport,wewanttoalignourimplementationtohowbrowsersshouldhan-dlecross-originrequests,thusallowingapopuporframefromanyresourcetoberenderedbuttodenyscriptac-cessiftheoriginsdonotmatch.Thisisalsoimportantto-wardskeepingdesigngoal(DG4),i.e.,beingdownwardscompatible.InthecurrentimplementationofChromiumweextendedtheoriginchecktoverifytheserver-originaswellastheprotocol,domainandport.IfaWebappli-cationdoesnotimplementoursuggestedextendedsame-originpolicy,thebrowserfallsbacktothenormalSOPvalidationandrendersthepageproperly.XmlHttpRequestsForXmlHttpRequests,wepatchedthefunctionalityforsame-originrequeststoparseourre-sponseheaderﬁeldandtograntorrevokescriptingac-cessdependingonthereceivedvalue.Tobefullyinteroperablewiththebrowser’sXHRob-ject,wehadtoensurecompatibilitywithitsrecentlyin-troducedcross-origincapabilities:ToallowXHRstoaccesscross-originresources,theW3Cspeciﬁedcross-originresourcesharing(CORS)[37].CORSallowstheinitiationofsimplerequeststoacross-originresourceandonlycheckstherighttoaccesstheresponseaftertherequesthasbeencompleted.InthecontextofCORSarequestsisconsideredtobesimpleifitalsowouldbepossibletocreateanequivalentrequestwithothermeans,suchasIMG-tagsorHTMLforms.becausesimplerequestscannotchangethestateofawebapplication.Forcomplexrequests,CORSrequiresthatthebrowsersendsapreﬂightrequesttotheservertoretrievethesame-domainXmlHttpRequestcomplexnoPreflight RequestyesRequestCORS allows?yesnoRequestyesX-Server-OriginCORS HeadersResponseyesyesFigure2:ImplementationlogicforXHRCORS-relevantheaders.Onlyiftheretrievedheadersal-lowaccesstotheresource,thecomplexrequestissenttotheservertoensurethatstate-changingoperationsareonlyperformedifexplicitlyallowedbytheapplication.Inasense,requeststorebounddomainshouldalsobetreatedascross-originrequests.Thus,wecanallowsim-plerequeststobesentbutneedtoverifytheserver-originbeforeallowingaccesstotheresponse.Foracomplexre-quest,weneedtocheckthepreﬂightresponseandonlyallowtheactualrequesttobesentiftheserver-originmatches.Todistinguishbetweensimpleandcomplex,weusedthealreadyexistingcheckfromtheCORSim-plementationinChromium.However,usingthepreﬂightfunctionalityfromCORSwouldbreakconstraintDG3.If-forexample-werequestasame-domainresourceonaserverthatdoesnotimplementCORS,theCORShead-erswouldnotbesetandthecheckwouldfail.Therefore,weimplementedafunctionthatonlychecktheX-Server-Originheader.TheﬂowchartinFig.2showstheresultingimplemen-tationlogicoftheXHRobject.Ouradditiontotheim-plementationispositionedonthelowerleftofthechart,whereastherightpartoftheﬁguredepictstheoriginallogicasimplementedbyChromium.NotethatasanXHRisnotrenderedbythebrowser,wecandirectlyblockaccessuponreceivingtheresponsefromtheserver.7.1ImplementationandperformanceIntotal,wemodiﬁed34linesofcodeinChromium.Asdiscussedearlier,theimplementationmanifestsit-selfonlyasparsingandextractionoftheHTTPhead-ers,theallocationofalittleamountofmemorytostoretheserver-originandastringcomparisonofthedomainandthestoredvalue.TheparsingofHTTPheadersisexecutedforanyrequest,thustheperformanceimpactisreduced to just one more array access. Thus, in our tests
we had no noticeable overhead when accessing a Web
application.

8 Related Work
Related offensive and protective techniques have already
been the subject of Sections 3.1 and 3.2. Hence, in this
section we focus on approaches that directly relate to
the eSOP, as they propose modiﬁcations to the browser-
server interaction to combat DNS Rebinding:

Conceptually closest to our protection approach is the
“Strong Locked SOP” by Karlof et al. [19], which also
proposes to include server-provided information into the
SOP decision. In the case of the “Strong Locked SOP”,
this information is derived from the TLS/SSL certiﬁ-
cates of the involved Web servers in the form of the cer-
tiﬁcates’ public keys. Consequently, JavaScript is only
granted access to resources that share the same public
key.
In the special case of “pharming” attacks (which
is the approach’s main concern), where the attacker con-
trols the DNS resolving process of the victim, Karlof’s
approach is conceptually stronger than the eSOP. Fur-
thermore, in a scenario in which all communication is
done via HTTPS and all servers are outﬁtted with valid
SSL certiﬁcates, the Strong Locked SOP would provide
reliable protection against rebinding attacks. However,
expecting the Web to go completely HTTPS appears
unrealistic, especially regarding intranet Web resources
which only in very rare cases have valid SSL certiﬁcates.
In contrast, the eSOP only requires to conﬁgure a single
response header and works well in plain HTTP scenarios.
is mentioned that early versions of
the HTML5 speciﬁcation included “IP-based Origins”,
which utilize the server’s IP as a fourth factor in the ori-
gin check. Compared to the eSOP, IP-based Origins are
neither able to securely handle domain relaxation nor do
they provide evidence of invalid origins (see Sec. 6.3.6),
thus, making them susceptible to library include attacks.
Furthermore, Jackson et al. propose “Host Name Au-
thorization”, a network based service [14], which an-
nounces the host names that are associated with a given
IP address. Host Name Authorization relies on reverse
DNS: Whenever the browser executes a DNS lookup,
it also veriﬁes that the requested domain is actually in
the set of valid domains of the received IP address.
This is done via querying the service under auth.ip.in-
addr.arpa, with ip being the IP address which has been
returned by the DNS server. Compared to our approach,
Host Name Authorization has several drawbacks. For
one, it requires considerable setup effort, as both reverse
DNS as well as the actual service have to be enabled.
Also, Host Name Authorization is realized within the
DNS system, hence, the maintainer of the Web server

In [13]

it

also needs administrative access to the corresponding
DNS server. This requirement cannot always be satisﬁed,
e.g., in shared hosting scenarios, for local machines, or
for internal services in cooperate networks. In addition,
the approach requires two additional DNS round trips for
each DNS resolving process, which could lead to no-
ticeable latency under certain circumstance, e.g., cellu-
lar networks. In comparison, our approach only requires
Web server-provided functionality and does not add any
network overhead.

Finally, for completeness sake, the Internet draft [22]
proposes
the HTTP request header X-Request
Origin. The purpose of the header is to transport the
domain value or IP address of the browser-based compo-
nent which was responsible for initiating the HTTP re-
quest within the browser. The draft lists DNS Rebinding
attacks (in the form of “Quick-swap DNS”) as one of its
motivational examples. However, in the context of DNS
Rebinding situations, the header’s value will necessarily
always equal the value of the HTTP host header, and
hence, shares its protection properties and drawbacks.

9 Conclusion

For more than one and a half decades, DNS Rebinding
continued to be a constant problem of the Web. Sev-
eral attempts to mitigate the issue have been undertaken,
but up to now no fundamental solution for the problem
was introduced successfully. In this paper, we presented
a novel attack variant, utilizing the HTML5 AppCache.
We practically validated our attack and demonstrated that
it affects all popular browsers and most plug-in tech-
nologies, while reliably circumventing currently existing
browser-based countermeasures. Using our attack as mo-
tivation, we revisited the attack’s underlying problem and
identiﬁed a mismatch between the SOP’s semantics and
its implementation: The SOP’s main purpose is to en-
sure security boundaries of Web servers. However, the
Web servers themselves are only indirectly involved in
the security decision. Instead, the SOP relies on infor-
mation obtained from the domain name system, which
is not necessarily controlled by the Web server’s owners.
This mismatch is exploited by DNS Rebinding.

To overcome this problematic inconsistency, we pro-
posed a light-weight extension to the SOP (eSOP), which
takes input from the Web server into account. The
eSOP robustly defeats DNS Rebinding attacks while be-
ing backward compatible with user-agents that do not
yet implement the extended policy. Our solution does
not require additional network trafﬁc and fully supports
previously problematic scenarios, including domain re-
laxation, content caching, and communication over Web
proxies. Additionally, the eSOP eradicates the need for
DNS Pinning. Thus, browsers implementing the pol-

634  22nd USENIX Security Symposium 

USENIX Association

icy can better inter-operate with dynamic DNS settings,
such as DNS based load-balancing or Content Distribu-
tion Networks (CDNs). In summary, adopting the eSOP
comes with very little costs but leads to a signiﬁcant se-
curity increase and additional beneﬁts in functionality.

Acknowledgments
This work was in parts supported by the EU Project Web-
Sand (FP7-256964), http://www.websand.eu. The sup-
port is gratefully acknowledged.

References
[1] B. Anderson. Why Web Browser DNS Caching Can Be A Bad
Thing. [online], http://dyn.com/web-browser-dns-c
aching-bad-thing/, last accessed 08/06/2012, 2011.

[2] A. Bortz, A. Barth, and C. Jackson. Dnswall. [software], http:

//code.google.com/p/google-dnswall/.

[3] D. Byrne. Anti-DNS Pinning and Java Applets. Posting to the
Bugtraq mailing list, http://seclists.org/fulldiscl
osure/2007/Jul/0159.html, July 2007.

[4] D. Dean, E. Felten, and D. Wallach. Java Security: From Hot-
Java to Netscape and Beyond. In Proceedings of the 1996 IEEE
Symposium on Security and Privacy, SP ’96, pages 190–, Wash-
ington, DC, USA, 1996. IEEE Computer Society.

[5] S. Dutta. Client-side cross-domain security. Technical report,
Microsoft, Dec. 2011. http://msdn.microsoft.com/en-
us/library/cc709423\%28v=vs.85\%29.aspx.

[6] Google Chromium Developers. The Chromium projects. [online]

http://www.chromium.org.

[7] J. Grossman, R. Hansen, P. Petkov, and A. Rager. Cross Site

Scripting Attacks: XSS Exploits and Defense. Syngress, 2007.

[8] J. Grossman and T. Niedzialkowski.

Websites from the Outside.
http://www.blackhat.com/presentations/bh-
usa-06/BH-US-06-Grossman.pdf, 2006.

Hacking Intranet
Talk at Black Hat USA,

[9] C. Heffner. How to Hack Millions of Routers. Talk at the Black

Hat USA conference, 2010.

[10] I. Hickson. Html5. W3c working draft, W3C, May 2012.

http://www.w3.org/TR/html5/.

[11] J. Hirth.

It’s Time to Rethink the Default Cache Size of Web
Browsers. [online], http://kaioa.com/node/74, last ac-
cess 8/5/2012, 2008.

[12] J. Hodges, C. Jackson, and A. Barth. HTTP Strict Transport
Security (HSTS). [IETF draft], http://tools.ietf.org/h
tml/draft-ietf-websec-strict-transport-sec,
Version 11, July 2012.

[13] C. Jackson and A. Barth. Beware of Finer-Grained Origins. In In

Web 2.0 Security and Privacy (W2SP 2008), 2008.

[14] C. Jackson, A. Barth, A. Bortz, W. Shao, and D. Boneh. Protect-
ing Browsers from DNS Rebinding Attacks. In In Proceedings of
ACM CCS 07, 2007.

[15] M.

Johns.

(somewhat) breaking the same-origin pol-
icy by undermining dns-pinning.
Posting to the Bugtraq
mailinglist, http://www.securityfocus.com/archive
/107/443429/30/180/threaded, 2006.

[16] M. Johns and Kanatoko. Using Java in anti DNS-pinning attacks
(Firefox and Opera). [online], Security Advisory, http://sh
ampoo.antville.org/stories/1566124/,
(08/27/07),
Februar 2007.

[17] M. Johns and J. Winter.

Protecting the Intranet Against
”JavaScript Malware” and Related Attacks. In Detection of Intru-
sions and Malware & Vulnerability Assessment (DIMVA 2007).
Springer, July 2007.

[18] Kanatoko. Anti-DNS Pinning + Socket in Flash.

[online],
http://www.jumperz.net/index.php?i=2&a=3&b=3,
(19/01/07), January 2007.

[19] C. Karlof, U. Shankar, J. Tygar, and D. Wagner. Dynamic pharm-
ing attacks and the locked same-origin policies for web browsers.
In Proceedings of the 14th ACM Conference on Computer and
Communication Security (CCS ’07), October 2007.

[20] G. Maone. NoScript Firefox Extension. [software], http://

www.noscript.net/whats, 2012.

[21] A. Megacz. Firewall circumvention possible with all browsers.
Posting to the Bugtraq mailinglist, http://seclists.org
/bugtraq/2002/Jul/0362.html, July 2002.

[22] A. Megacz and D. Meketa.

Inter-
net Draft, http://tools.ietf.org/html/draft-mega
cz-x-requestorigin-00, June 2003.

X-RequestOrigin.

[23] Microsoft. IE8 Security Part VII: ClickJacking Defenses, 2009.

[24] M. Mueller. Response to DNS spooﬁng attack.

[Usenet post-
ing], http://sip.cs.princeton.edu/news/sun-02-2
2-96.html, 1996.

[25] Princeton University.

DNS Attack Scenario.

[online],

http://www.cs.princeton.edu/sip/news/dns-
scenario.html.

[26] Y. Rekhter, B. Moskowitz, D. Karrenberg, G. J. de Groot, and
E. Lear. Address Allocation for Private Internets. RFC 1918, ht
tp://www.ietf.org/rfc/rfc1918.txt, February 1996.

[27] Rich internet application (ria) market share. http://www.sta

towl.com/custom ria market penetration.php.

[28] B. K. Rios and N. McFeters. Slipping Past The Firewall. Talk
at the HITBSecConf2007 conference, http://conference
.hitb.org/hitbsecconf2007kl/agenda.htm, 2007.

[29] J. Roskind. Attacks Against the Netscape Browser. Talk at the

RSA Conference, April 2001.

[30] D. Ross.

Notes on DNS Pinning.

[online], http:

//blogs.msdn.com/b/dross/archive/2007/07
/09/notes-on-dns-pinning.aspx, last accessed 8/4/12,
July 2007.

[31] J. Ruderman.

The Same Origin Policy.

[online],

http://www.mozilla.org/projects/security
/components/same-origin.html (01/10/06), August
2001.

USENIX Association  

22nd USENIX Security Symposium  635

[32] J. Soref. DNS: Spooﬁng and Pinning.

[online], http:

//web.archive.org/web/20100211170613/http:
//viper.haque.net/˜timeless/blog/11/, (07/07/12),
2003.

[33] B. Sterne and A. Barth. Content Security Policy. W3C Work-
ing Draft, http://www.w3.org/TR/2011/WD-CSP-2011
1129/, 2012.

[34] D. Stuttard.

DNS Pinning and Web Proxies.

NISR
whitepaper, http://www.ngssoftware.com/research/
papers/DnsPinningAndWebProxies.pdf, 2007.

[35] P. Uhley.

Flash content and the same-origin policy.

http://blogs.adobe.com/asset/2009/11/fla
sh content and the same-ori.html, 2009.

[36] D. Ulevitch. Finally, a real solution to DNS rebinding attacks.
[online], http://blog.opendns.com/2008/04/14/fi
nally-a-real-solution-to-dns-rebinding-att
acks/, last accessed 08/06/2012, April 2008.

[37] A. van Kesteren (Editor). Cross-Origin Resource Sharing. W3C
Working Draft, Version WD-cors-20100727, http://www.w
3.org/TR/cors/, July 2010.

[38] W3C. Same Origin Policy.

/Security/wiki/Same Origin Policy,
2010.

[online], http://www.w3.org
(08/01/2012,

636  22nd USENIX Security Symposium 

USENIX Association

