Using Linearly-Homomorphic Encryption

to Evaluate Degree-2 Functions on Encrypted Data

Dario Catalano
University of Catania

Catania, Italy

catalano@dmi.unict.it

Dario Fiore

dario.ﬁore@imdea.org

IMDEA Software Institute

Madrid, Spain

ABSTRACT
We show a technique to transform a linearly-homomorphic
encryption into a scheme capable of evaluating degree-2 com-
putations on ciphertexts. Our transformation is surprisingly
simple and requires only one very mild property on the un-
derlying linearly-homomorphic scheme: the message space
must be a public ring in which it is possible to sample el-
ements uniformly at random. This allows us to instanti-
ate our transformation with virtually all existing number-
theoretic linearly-homomorphic schemes, such as Goldwasser-
Micali, Paillier, or ElGamal. Our resulting schemes achieve
circuit privacy and are compact when considering a sub-
class of degree-2 polynomials where the number of additions
of degree-2 terms is bounded by a constant.

As an additional contribution we extend our technique to
build a protocol for outsourcing computation on encrypted
data using two (non-communicating) servers. Somewhat in-
terestingly, in this case we can boost a linearly-homomorphic
scheme to support the evaluation of any degree-2 polynomial
while achieving full compactness.

Categories and Subject Descriptors
K.6.5 [Management of Computing and Information
Systems]: Security and Protection

Keywords
Homomorphic Encryption; Secure Computation

1.

INTRODUCTION

The problem of enabling computation over encrypted data
is one of the most intriguing questions in cryptography and
has been attracting signiﬁcant attention lately.
In a nut-
shell, this problem involves two parties, a client holding an
input x and a server holding some function f . The goal of
the client is to learn f (x) without disclosing unnecessary in-
formation about x (aka semantic security). The goal of the
server is to perform the computation without revealing to

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS’15, October 12–16, 2015, Denver, Colorado, USA.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-3832-5/15/10 ...$15.00.
DOI: http://dx.doi.org/10.1145/2810103.2813624 .

the client any information (beyond f (x)) about f (aka cir-
cuit privacy). Moreover, to minimize the communication be-
tween client and server as well as the client’s work, it would
be desirable that the server’s response be shorter than the
size of f (aka compactness). Computing on encrypted data
is a problem that arises in a variety of settings, including,
for instance, secure cloud computing, encrypted database
search, and many more.

A natural way to solve the problem is to rely on so-called
homomorphic encryption (HE) schemes. Informally, these
are encryption mechanisms that allow one to perform com-
putations on the encrypted plaintexts by performing similar
operations on the ciphertexts.
In other words, homomor-
phic encryption allows to perform meaningful operations on
plaintexts (e.g., additions and multiplications) without, at
any stage, needing to decrypt the corresponding ciphertexts.
The idea of homomorphic encryption was ﬁrst suggested
in 1978 by Rivest, Adleman and Dertouzous [34], though
its ﬁrst fully-ﬂedged realization was proposed only in 2009
in a breakthrough result by Gentry [17]. Earlier than that,
many other authors suggested encryption schemes that, al-
beit not supporting arbitrary functionalities, still allow for
meaningful operations. This is the case, for instance, of the
Goldwasser-Micali cryptosystem [21], Paillier’s cryptosys-
tem [33] and many other schemes [10, 30, 32, 13, 6, 25].
All these schemes are linearly-homomorphic (i.e., they sup-
port linear functions only), and they can be seen as based
on the same blueprint. Namely, they are all (probabilistic)
public-key encryption schemes based on a discrete log trap-
door modulo a large integer which is hard to factor.1
In
such schemes, the message space is a ring M of modular
residues and ciphertexts are in the group G (denoted multi-
plicatively) of invertible elements of some particular ring of
integers modulo a number hard to factor. The encryption
of a message m is a group element of the form Enc(m; r) =
gmre ∈ G, where e is some public integer, g a ﬁxed pub-
lic element, and r is chosen at random in some particular
(multiplicative) subgroup R of G. Since R is a subgroup,
such schemes have an additive homomorphic property: an
encryption of m1 + m2 can be obtained from any encryption
of m1 and m2, as E(m1; r1)· E(m2; r2) ≡ E(m1 + m2; r1r2).
In other words, (homomorphic) additions of plaintexts are
obtained by multiplying the corresponding ciphertexts.

1An exception is the scheme by Bresson et al. [6] in which
the ciphertext is composed by two group elements, as well
as schemes such as ElGamal “in the exponent” [11] where
the modulus N is allowed to be prime.

1518Generalizing these schemes to support more complex func-
tionalities – say, multiplications – seems like a lost cause at
ﬁrst as, being the ciphertext space only a group, in general
there might be no way to operate on two ciphertexts in order
to obtain a multiplication of the corresponding plaintexts.
A nice exception to this barrier was suggested by Boneh,
Goh and Nissim [3] who revisited the above blueprint in
the context of composite-order bilinear groups, and in this
setting show how to use the bilinear map to gain one sin-
gle multiplication on encrypted plaintexts. However, this
construction is very speciﬁc to bilinear groups, and it re-
mains an intriguing open problem whether it is possible to
extend any linearly-homomorphic scheme (e.g., Paillier or
Goldwasser-Micali) in a natural way in order to support
multiplications.2 Beyond its theoretical interest, answering
this question in the positive, might allow to build homomor-
phic cryptosystems that could adopt (directly and for free!)
many of the satellite protocols, tools (e.g., ZK-PoK, thresh-
old variants and so on), libraries and standard parameters
that have been studied and developed for the underlying
linear schemes over the last thirty+ years.
1.1 Our Contribution
Homomorphic Encryption for Quadratic Functions.
Our main result is a way to generalize the blueprint de-
scribed above3 in order to gain the possibility of performing
one multiplication on encrypted plaintexts. Slightly more in
detail, we show a simple technique which takes a linearly-
homomorphic encryption scheme and uses it to build an HE
scheme which supports arithmetic computations of degree 2
on ciphertexts.4

Our technique is quite generic and requires only one very
mild property from the underlying linearly-homomorphic
scheme: the message space must be a public ring in which
it is possible to sample elements uniformly at random. We
call HE schemes satisfying this property public-space and
we show that virtually all existing schemes are so (or can be
easily modiﬁed in order to become so). This means that we
can instantiate our transformation with a variety of exist-
ing schemes (e.g., [20, 10, 30, 33, 13, 6, 25]) thus obtaining
several HE schemes capable of evaluating one multiplication
and whose security relies on a variety of assumptions, such
as quadratic/composite residuosity, DDH, or decision linear,
to name a few. Furthermore, when applied to the BGN en-
cryption scheme [3], our solution yields an HE scheme that
supports computations of degree up to 4.

Our technique is surprisingly simple, and at an intuitive
level it works as follows. Starting from a linearly homomor-
phic encryption scheme HE = (KeyGen, Enc, Dec) based on
the blueprint described above, the idea is to modify an en-
cryption of m into a “multiplication-friendly” encryption of
the same plaintext. Slightly more in detail, given Enc(m),
we choose a random b(cid:48) ∈ M and set the new ciphertext as
C = (b(cid:48), Enc(m − b(cid:48))), where “−” denotes subtraction (i.e.,
addition of the additive inverse) in the ring M. Notice that

2At this point it is worth noting that Ishai and Paskin [24]
build HE from a linearly-homomorphic scheme, albeit in a
“less natural way”. We discuss this work in more detail later
on in the related work section.
3Actually, we do not need to assume the group structure –
we do it here only for ease of exposition.
4Precisely, our solution achieves compactness for a subclass
of degree-2 polynomials that we specify slightly below.

by setting b(cid:48) = m− b, for some unknown b, the above can be
rewritten as C = (m−b, Enc(b)). To perform the multiplica-
tion one proceeds as follows. Given C1 = (m1 − b1, Enc(b1))
and C2 = (m2 − b2, Enc(b2)) one ﬁrst computes the product
(m1 − b1)(m2 − b2), moves it up to the ciphertext space (i.e.,
encrypts it), and then (homomorphically) removes the terms
m1b2 and m2b1 from the product by exploiting the linearly-
homomorphic properties of HE. Slightly more in detail, one
computes C = (α, β1, β2) where:
α = Enc(m1m2 − b1b2)

= Enc ((m1 − b1) · (m2 − b2)) ·

·[Enc(b1)(m2−b2)] · [Enc(b2)(m1−b1)]

β1 = Enc(b1),

β2 = Enc(b2)

stant L, i.e., polynomials of the form P ((cid:126)x) +(cid:80)L

Decryption of any ciphertext (α, β1, β2) works by ﬁrst re-
trieving b1 and b2 (from β1 and β2) and then by adding
(b1b2) to the decryption of α. At this point, once obtained
ciphertexts via the above manipulations, these can be kept
additively-homomorphic. This however comes at the cost of
loosing compactness. In fact, addition after multiplication
consists into homomorphically adding the α components of
the ciphertexts and concatenating the β components. So the
ciphertext will start growing (linearly) with additions after
performing the multiplication (this also means that decryp-
tion cost increases linearly as well). Importantly, however,
we show a technique to re-randomize ciphertexts so as to
achieve circuit privacy. To be precise, our scheme compactly
supports all degree-2 multivariate polynomials in which the
number of additions of degree-2 terms is bounded by a con-
i=1 Qi((cid:126)x) ·
Ri((cid:126)x) where P, Qi, Ri are linear.
In fact, assuming that
P, Qi, Ri have at most n terms each, the decryption cost
is O(L) in contrast to the cost of evaluating f ((cid:126)x) which is
O(n · L). Despite limited, this class of computations is still
meaningful in some contexts. For instance, we observe that
the celebrated SPDZ protocol [14] requires a somewhat ho-
momorphic encryption scheme capable of evaluating exactly
this class of computations (for L = 1). Finally, as we il-
lustrate in a couple of paragraphs below, we show how to
completely remove this compactness issue in a novel pro-
tocol for outsourcing computation on encrypted data using
two servers. In this case we can boost linearly-homomorphic
encryption to evaluate any degree-2 multivariate polynomial
on encrypted data.
On the importance of being simple and black box. Be-
yond its simplicity, a very attractive feature of our technique
is that it applies in a black box way to essentially all known
linearly-homomorphic encryption schemes. This allows us
to directly “inherit” all the protocols and tools previously
developed for the underlying schemes.
Providing alternatives to existing schemes. Our
construction provides the ﬁrst realizations of practical ho-
momorphic encryption schemes (beyond linear) in groups
like Z∗
N . Compared to the recent lattice-based homomorphic
encryption schemes, ours are clearly much less expressive.
Yet we believe that our results remain relevant for at least
two reasons. First, they provide alternatives to lattice-based
cryptography. Given our current understanding of complex-
ity theory it is possible to imagine a world where the lattice
problems used to build homomorphic encryption are easy to
solve while (some) number theoretic problems remain hard.
Notice that we are not saying that this scenario is plausible

1519or even likely, just that it is possible. Second, our schemes
can immediately take advantage of the thirty+ years eﬀorts
done on number-theoretic (linearly) homomorphic encryp-
tion schemes.
Indeed, adopting our schemes induces only
a small overhead (i.e., the multiplication algorithm), and
this holds also from an implementation perspective. For
instance, there may be no need to develop complex new li-
braries or to deal with new delicate parameters choices.

Overcoming the Compactness Issue: Two-Server Del-
egation of Computation on Encrypted Data. As
a second contribution, we show how to extend our tech-
niques to build a protocol for outsourcing computation on
encrypted data by using two servers.
In brief, two-server
delegation of computation enables a client to outsource the
computation of a function f on some input m by using two
distinct servers in such a way that:
it is possible to re-
cover the result f (m) from the servers’ response, and the
two servers do not need to interact. For security, the proto-
col preserves the conﬁdentiality of the client’s inputs as long
as the two servers do not collude. Somewhat interestingly,
for this protocol we show a construction which completely
removes the compactness issue arising in our previous trans-
formation. Namely, we use a linearly-homomorphic scheme
in order to outsource the evaluation of any multivariate poly-
nomial of degree 2 while keeping the ciphertexts (i.e., the
servers’ responses) of constant-size.

This solution has interesting applications to outsourcing
the computation on encrypted data of various statistical
functions (e.g., mean, variance, covariance, RMS, linear re-
gression, correlation coeﬃcient, and many more) or distance
measures (e.g., euclidean distance) over vectors of integers.
And somewhat interestingly, all this can be performed quite
eﬃciently (cf. Section 6) by using cryptosystems such as
Paillier’s [33] or Joye-Libert [25].

Our solution oﬀers two more interesting properties that
we call unbalanced eﬃciency and unbalanced security. The
former says that one of the two servers can perform the com-
putation essentially “for free”, i.e., as if it computes over
the original inputs in M. This is possible because only
one of the servers need to do public-key operations. Un-
balanced security instead guarantees that w.r.t.
such ef-
ﬁcient server the semantic security of the protocol holds
information-theoretically.

Our construction of two-server delegation of computation
on encrypted data builds on essentially the same idea il-
lustrated before, with the diﬀerence that now a ciphertext
consists of two components: one for the ﬁrst server and one
for the second server. More in detail, the ﬁrst server re-
ceives C (1) = (m − b, Enc(b)), b random in M, while the
second server receives just C (2) = b.5 As one can notice,
as long as the two servers do not collude, the conﬁdential-
ity of the message m is preserved.
In order to perform
computations on these ciphertexts, the second server sim-
ply operates over the bi’s, i.e., it computes b = f (b1, . . . , bt),
while the ﬁrst server works as in our HE scheme with the
key diﬀerence that, after performing a multiplication, it can
throw away the β components of the ciphertexts and keep
doing additions on the α components without any ciphertext
growth. This way, the ﬁrst server is eventually able to com-
pute α = Enc(f (m1, . . . , mt) − f (b1, . . . , bt)). So, when the

5Notice that here b is chosen explicitly at encryption time,
rather than while performing a multiplication.

client receives such values α and b = f (b1, . . . , bt) from the
ﬁrst and the second server respectively, then it can recover
the computation’s result as Dec(α) + b. It is interesting to
note that the two servers do not need to interact during the
computation, and actually they do not even need to know
about their mutual existence!

In the full version of the paper [9], we further generalize
our technique to outsource the computation of all degree-
3 polynomials by using a level-2 homomorphic encryption.
Such transformation yields for instance a protocol for degree-
3 polynomials based on the BGN cryptosystem.
Experimentals Results. To better assess the practical rel-
evance of our constructions we implemented the schemes re-
sulting when using Paillier [33] and Joye-Libert [25] as un-
derlying cryptosystems. We compared the performance of
our solutions with that of the BGV [4] homomorphic encryp-
tion implemented in HE-Lib [23], instantiated with parame-
ters suitable to support one multiplication. Although being
in a weaker security model, our two-server solution outper-
forms the BGV somewhat homomorphic encryption on es-
sentially all fronts (ciphertext size, costs of encryption, de-
cryption and homomorphic operations). Interestingly, how-
ever, our basic schemes remain competitive even in the single
server setting. More precisely, our JL13-based solution (with
80-bit security) remains competitive for L ≤ 10. Namely,
it achieves a decryption time comparable to that of BGV,
(much) shorter ciphertexts and much faster encryption and
homomorphic operations. We also compare our JL13-based
solution with BGN [3]. While in terms of bandwidth con-
sumption the latter is preferable, our scheme allows for more
ﬂexible message spaces and is faster overall6.
Other Related Work. As already mentioned above, fully
homomorphic encryption (FHE) allows to perform arbitrary
computation over encrypted data (e.g., [17, 37, 38, 5, 4]).
A key feature of FHE is that ciphertexts are both compact
and guarantee circuit privacy. Beyond FHE-based solutions,
many other works considered the problem of computing over
encrypted data. Cachin et al. [7] observed that (any) two-
message protocol for secure function evaluation (SFE) can
be used to perform computation over encrypted data with
circuit privacy. In particular, this idea can be extended to
construct an homomorphic public key cryptosystem from
any two-message SFE. This construction uses Yao’s garbled
circuits [39] as underlying building block, achieves semantic
security and circuit privacy but unfortunately is not compact
(roughly, because the ciphertext includes a garbled circuit).
Gentry et al.
[18] generalized this construction to support
computations on previously evaluated ciphertexts via boot-
strapping (they called i-hop an homomorphic cryptosystem
allowing up to i such computations). Other works proposed
HE schemes whose complexity of decryption (and ciphertext
size) depends in various ways on the evaluated function f .
Here we discuss some of them.

Sander et al.

[35] proposed a solution to evaluate con-
stant fan-in (boolean) circuits in NC1. More precisely, their
scheme allows to evaluate circuits (in NC1) composed of OR

6An exception is decryption time, where the comparison is
slightly more delicate to assess. In our case decryption cost
grows linearly in L (i.e. the number of after-multiplication
additions). The cost of decryption in BGN, on the other
hand, grows exponentially with the message length (yet, for
10-bit messages and L ≤ 600, our solution achieves faster
decryption than BGN).

1520and NOT gates. Unfortunately, it also requires communi-
cation complexity exponential in the circuit’s depth, as ci-
phertexts grow exponentially with the number of OR gates.
Building on earlier work of Kushilevitz and Ostrovsky
[27], Ishai and Paskin [24] proposed a scheme to evaluate
branching programs on encrypted data. Their protocol uses
strong oblivious transfer, a notion that can be implemented
using any linearly homomorphic encryption. This makes
this work somewhat related to ours. In comparison, their
scheme clearly supports a wider class of functionalities. On
the other hand, if we consider the question of building upon a
linearly-homomorphic encryption to obtain more expressive
functionalities, their construction is less direct than ours:
for instance, they have to change the computation model to
branching programs, and it is unclear whether tools origi-
nally designed for the underlying HE are “recyclable” in the
transformed scheme. Moreover, while when focusing on all
degree-2 polynomials we achieve the same level of compact-
ness, instead for the speciﬁc subset of polynomials consid-
ered in this paper7 the scheme in [24] induces much larger
ciphertexts (quadratic in the number of inputs).

Another work related to ours is the one of Aguilar Mel-
chor et al. [29] who proposed a construction of homomorphic
encryption (called chained) supporting up to d multiplica-
tions, for some constant d.
In this scheme the ciphertext
grows exponentially with each multiplication (but is not af-
fected by additions). The basic idea is somewhat similar to
ours. There they show how to achieve chained encryption
out of a linearly-homomorphic scheme with certain prop-
erties. These properties, however, are more stringent than
those required in this paper. In particular, none of the cur-
rently available number-theoretic cryptosystems is known to
meet such requirements.

Finally, we mention the work of Applebaum et al. [1] that
addresses the question of garbling arithmetic circuits. By
adapting the idea in [7] for achieving homomorphic encryp-
tion from two-message SFE in order to work with garbled
arithmetic circuits [1] (instead of Yao’s garbling), one can
implement more expressive homomorphic encryption schemes
(achieving non-constant-size ciphertexts) out of linearly ho-
momorphic ones. Compared to this approach, we believe
that ours is preferable for at least two reasons: it is concep-
tually much simpler (and easier to implement), and it allows
for a two-server constant size variant which is not achievable
using these other techniques.
Strawman approaches. An idea to construct a non-
compact HE scheme from a linearly-homomorphic one might
be to simply concatenate two ciphertexts whenever they
have to be multiplied. Then one may hope to achieve circuit
privacy by multiplying one ciphertext by a random z and the
other one by its inverse z−1. We point out that such solu-
tion is not suitable for at least two reasons. First, it does
not achieve circuit privacy if there is more than one degree-2
monomial: upon decryption one always recovers the value
of the single monomials. Second, it is less general as taking
inverses requires the message space to be a ﬁeld or, at least,
that the set of invertible elements is “dense” enough (as it is
the case for Paillier’s scheme, for instance). The issue is that
several schemes (e.g. [21, 30, 25]) do not have such density

7We stress that, although our solution is not fully compact
when considering all degree-2 polynomials, it achieves com-
pactness for the speciﬁc subset of degree-2 polynomials dis-
cussed above.

property. In particular, multiplicative obfuscation would not
work for the Joye-Libert cryptosystem (which leads to very
eﬃcient instantiations of our constructions).
2. PRELIMINARIES
We review the notation and some basic deﬁnitions used
in our work. We will denote with λ ∈ N the security pa-
rameter, and by poly(λ) any function which is bounded by
a polynomial in λ. Informally, we say that a function (λ) is
negligible if it vanishes faster than the inverse of any poly-
nomial in λ, and we compactly denote it as (λ) = negl(λ).
An algorithm A is said to be PPT if it is modeled as a prob-
abilistic Turing machine that runs in time polynomial in λ.
If S is a set, x $← S denotes the process of selecting x uni-
formly at random in S (which in particular assumes that S
can be sampled eﬃciently. If A is a probabilistic algorithm,
x $← A(·) denotes the process of running A on some appro-
priate input and assigning its output to x. For a positive
integer n, we denote by [n] the set of integers {1, . . . , n}.

Definition 1

(Statistical Distance). Let X, Y be two

random variables over a ﬁnite set U. The statistical distance
between X and Y is deﬁned as

(cid:12)(cid:12) Pr[X = u] − Pr[Y = u](cid:12)(cid:12)

(cid:88)

u∈U

SD[X, Y ] =

1
2

2.1 Homomorphic Encryption

Here we recall the deﬁnition of homomorphic encryption.
In this work we make the (somewhat canonical) assump-
tion that the messages live in some ring (M, +,·) while the
computations are expressed as arithmetic circuits (i.e., addi-
tions, multiplications and multiplications by constants) over
such ring. A homomorphic encryption scheme HE consists
of a tuple of four PPT algorithms (KeyGen, Enc, Eval, Dec)
working as follows:
KeyGen(1λ): the key generation algorithm takes as input the
security parameter λ and produces a secret key sk and
a public key pk. The public key pk implicitly deﬁnes a
message space M.
Enc(pk, m): the encryption algorithm takes as input pk and
a message m ∈ M, and it outputs a ciphertext C.
Eval(pk, f, C1, . . . , Ct): the evaluation algorithm takes as in-
put pk, an arithmetic circuit f : Mt → M in a class F
of “permitted” circuits, and t ciphertexts C1, . . . , Ct.
It
returns a ciphertext C.

Dec(sk, C): given sk and a ciphertext C, the decryption al-

gorithm outputs a message m.
An HE scheme should satisfy four main properties: cor-
rectness, compactness, security and circuit privacy. The ﬁrst
two properties regard the functionality of the scheme while
the remaining two properties model security.

The basic requirement is correctness:
Definition 2

(Correctness). A homomorphic encryp-
tion scheme HE = (KeyGen, Enc, Eval, Dec) is said to cor-
rectly evaluate a family of circuits F if for all honestly gen-
erated keys (pk, sk) $← KeyGen(1λ), for all f ∈ F and for all
messages m1, . . . , mt ∈ M we have that if Ci ← Enc(pk, mi)
∀i ∈ [t], then
Pr[Dec(sk, Eval(pk, f, (C1, . . . , Ct))) (cid:54)= f (m1, . . . , mt)] = negl(λ)
where the probability is taken over all the algorithms’ random
choices.

1521In addition to correctness, any “interesting” homomorphic
encryption scheme must be compact. Roughly speaking, this
means that the ciphertexts output by Eval have some ﬁxed
size, which does not depend on the size of the evaluated
circuit. This is formally deﬁned as follows:
(Compactness). A homomorphic encryp-
tion scheme HE = (KeyGen, Enc, Eval, Dec) is said to com-
pactly evaluate a family of circuits F if the running time of
the decryption algorithm Dec is bounded by a ﬁxed polyno-
mial in λ.

Definition 3

The security of a homomorphic encryption scheme is de-
ﬁned using the notion of semantic security put forward by
Goldwasser and Micali [20].

Definition 4

(Semantic Security). Let HE = (KeyGen,

Enc, Eval, Dec) be a (homomorphic) encryption scheme, and
A be a PPT adversary. Consider the following experiment:
Experiment ExpSSHE,A(λ)

b $← {0, 1}; (pk, sk) $← KeyGen(1λ)
(m0, m1)←A(pk)
c $← Enc(pk, mb) ; b(cid:48)←A(c)
If b(cid:48) = b return 1. Else return 0.

and deﬁne A’s advantage as AdvSSHE,A(λ) = Pr[ExpSSHE,A(λ) =
1] − 1
any PPT algorithm A it holds AdvSSHE,A(λ) = negl(λ).

2 . Then we say that HE is semantically-secure if for

When considering homomorphic encryption, the notion of
semantic security may not be suﬃcient to guarantee the con-
ﬁdentiality of the encrypted messages, and in particular of
the computation’s inputs. Roughly speaking, in a homomor-
phic encryption scheme we would like that the ciphertexts
output by Eval do not reveal any information about the mes-
sages encrypted in the input ciphertexts. This property is
formalized via the following notion of circuit privacy:

Definition 5

(Circuit Privacy). We say that a ho-
momorphic encryption scheme HE is circuit private for a
family of circuits F if there exists a PPT simulator Sim and
a negligible function (λ) such that the following holds. For
$← KeyGen(1λ), any
any λ ∈ N, any pair of keys (pk, sk)
circuit f ∈ F, any tuple of messages m1, . . . , mt ∈ M and
ciphertexts C1, . . . , Ct such that ∀i ∈ [t]: Ci
$← Enc(pk, mi),
then it holds
SD[Eval(pk, f, C1, . . . , Ct), Sim(1λ, pk, f (m1, . . . , mt))] ≤ (λ)

Leveled Homomorphic Encryption.
In this work we
consider the notion of leveled homomorphic encryption in
which the parameters of the scheme depend on the depth of
the circuits that the scheme can evaluate. In particular, in
our work we refer to the level as the degree of the arithmetic
circuits. So, for example, a linearly-homomorphic encryp-
tion is a level-1 HE.

Definition 6

(Level-d Homomorphic Encryption).
For a positive integer d ∈ Z+, HE (d) is a level-d homomor-
phic encryption scheme if HE (d) compactly evaluates circuits
of degree at most d and the running time of HE (d)’s algo-
rithms is polynomial in the security parameter λ, the degree
d, and (only in the case of Eval(d)) the circuit size.

Now, for leveled homomorphic encryption schemes it is
possible to consider a weaker version of circuit privacy which,

roughly speaking, says that ciphertexts “at the same level”
look indistinguishable. In other words, this means that cir-
cuit privacy holds with respect to a diﬀerent distribution for
each level. More formally:

Definition 7

(Leveled Circuit Privacy). We say that

a leveled homomorphic encryption HE (d) satisﬁes leveled cir-
cuit privacy for a family of circuits F if there exists a PPT
simulator Sim and a negligible function (λ) such that the
following holds. For any λ ∈ N, any pair of keys (pk, sk) $←
KeyGen(1λ), any circuit f ∈ F of multiplicative depth d(cid:48) ≤
d, any tuple of messages m1, . . . , mt ∈ M and ciphertexts
C1, . . . , Ct such that ∀i ∈ [t]: Ci
SD[Eval(pk, f, C1, . . . , Ct), Sim(1λ, pk, d

$← Enc(pk, mi), it holds

(cid:48)

, f (m1, . . . , mt))] ≤ (λ)

3. Public-Space HOMOMORPHIC ENCRYP-

TION

In this section we deﬁne the property that a homomorphic
encryption scheme needs to satisfy in order to be used in
our transformation presented in Section 4. We call such
a scheme a public-space homomorphic encryption, and we
formalize this notion below.

Definition 8. A homomorphic encryption scheme ˆHE =
ˆKeyGen, ˆEnc, ˆEval, ˆDec) with message space M is said to be
(
public-space if: (1) M is a (publicly known) ﬁnite and com-
mutative ring with a unity, and (2) it is possible to eﬃciently
sample uniformly distributed elements m ∈ M.

We stress that the above is a very mild requirement, and
we point out that virtually all known number-theoretic ho-
momorphic encryption schemes (e.g., [20, 10, 30, 33, 13, 6,
25]) are public-space, or can be easily adapted to be so (as
we show in Appendix A for the case of [11, 32, 2, 3]). In
essence, given the current state of the art we have public-
space linearly-homomorphic encryption schemes based on a
variety of number-theoretic assumptions, such as p-subgroup
[32], Quadratic Residuosity and its extensions [20, 30, 25],
Composite Residuosity [33, 13], DDH [11, 8], DLin [2, 16],
subgroup decision [3]. Finally, we note that also the more
recent lattice-based homomorphic encryption schemes (e.g.,
[5, 4]) satisfy our notion of public-space.

4. OUR TRANSFORMATION

In this section we present our main construction, that is a
methodology to convert a public-space linearly-homomorphic
encryption scheme into a scheme supporting one multiplica-
tion. Precisely, the resulting scheme can compactly evalu-
ate arithmetic circuits in which the number of additions of
degree-2 terms is bounded by some constant (yet the num-
ber of additions of degree 1 is unbounded). At the same
time, the scheme satisﬁes leveled circuit-privacy.

Let ˆHE = (

ˆKeyGen, ˆEnc, ˆEval, ˆDec) be a public-space linearly-

homomorphic encryption scheme as per Deﬁnition 3. To
ease the presentation, in our description we denote by ˆC the
ciphertext space of ˆHE, we use Greek letters to denote ele-
ments of ˆC and Roman letters for elements of M. Without
loss of generality we assume ˆEval consists of two subroutines:
one to perform (homomorphic) addition and one for per-
forming (homomorphic) multiplication by known constants.
We compactly denote these operations with (cid:1) and ·, respec-

1522f ( (cid:126)m) is a polynomial of form P ( (cid:126)m) +(cid:80)L

tively.8 Namely, given two cihertexts β1, β2 ∈ ˆC, β = β1 (cid:1)β2
denotes their homomorphic addition, and β = c · β1 denotes
a multiplication by a constant c ∈ M. Addition and multi-
plication over M are denoted by + and ·, respectively.
In what follows, we propose a scheme HE = (KeyGen,
Enc, Eval, Dec) capable of evaluating arithmetic circuits of
degree 2 over M, in which the number of additions of degree-
2 terms is bounded by some constant L. Precisely, let Fd
be the class of (multi-variate) polynomials of total degree
d over the ring M. Then our scheme HE can compactly
evaluate polynomials in the class F (cid:63)
2 = {f ( (cid:126)m)} ⊂ F2, where
i=1 Qi( (cid:126)m) · Ri( (cid:126)m)
where P ( (cid:126)m), {Qi( (cid:126)m), Ri( (cid:126)m)} are all polynomials in F1.
KeyGen(1λ): On input 1λ, where λ ∈ N is a security pa-
ˆKeyGen(1λ) to get (pk, sk), and outputs
rameter, it runs
(pk, sk). We assume that pk implicitly contains a descrip-
tion of ˆHE’s message space M and ciphertext space ˆC. The
message space of the scheme HE will be the same M.
Enc(pk, m): Given a message m ∈ M, the algorithm simply
outputs ˆC = ˆEnc(pk, m).
Eval(pk, f, C1, . . . , Ct): We describe this algorithm in terms
of four diﬀerent procedures: (Add1, Mult, Add2, cMult) that
implement the basic homomorphic operations: additions,
multiplications and multiplications by known constants.
Informally, Add1 and Mult operate over pairs ciphertexts
that encode either ”fresh” messages or messages obtained
as linear combinations of fresh messages, whereas Add2
operates over pairs of ciphertexts containing “multiplied”
messages. Similarly, cMult allows to perform multiplica-
tions by constant on ciphertexts. Therefore, homomorphi-
cally evaluating a circuit f consists of evaluating the corre-
sponding homomorphic operations. Furthermore, in order
to achieve circuit privacy, the ciphertext output by Eval
must be re-randomized by using the procedures described
later.
Add1 : On input two ciphertexts C1, C2 ∈ ˆC where, for
i = 1, 2, Ci = βi, this algorithm produces a ciphertext
C = β ∈ ˆC computed as β = β1 (cid:1) β2.
2 ∈ ˆC the algorithm
Mult : On input two ciphertexts C(cid:48)
1, C(cid:48)
proceeds in two steps: a ciphertext modiﬁcation step and
the actual multiplication step. In the ﬁrst step the algo-
rithm chooses (at random) a1, a2 ∈ M. Next, it com-
(cid:48)(cid:48)
2 = ˆEnc(−a2) and sets
putes C
βi = Add1(C(cid:48)
In the multiplication step, letting C1, C2 ∈ M× ˆC where,
for i = 1, 2, Ci = (ai, βi), the algorithm computes a
ciphertext C = (α, β) ∈ ˆC × ˆC2 as follows:

(cid:48)(cid:48)
1 = ˆEnc(−a1) and C
(cid:48)(cid:48)
i ) for i = 1, 2.

i, C

α = ˆEnc(pk, a1 · a2) (cid:1) a1 · β2 (cid:1) a2 · β1
β = (β1, β2)

(cid:62)

For correctness, one can see that if ai = (mi − bi) and
βi ∈ ˆEnc(pk, bi) for some bi ∈ M, then
α ∈ ˆEnc (pk, (m1m2 − b1m2 − b2m1 + b1b2) + (b2m1 − b1b2)
+(b1m2 − b1b2)) = ˆEnc(pk, m1m2 − b1b2)
and β ∈ ( ˆEnc(pk, b1), ˆEnc(pk, b2))(cid:62).
Intuitively, the ciphertext modiﬁcation step above can
be seen as a 2-out-of-2 asymmetric secret sharing of the
8Here we slightly abuse notation as the symbol · is also used
to denote multiplication in the ring M.

message, as, in order to be able to decrypt correctly, one
would need both the components of the ciphertext.
Add2 : On input two ciphertexts C1, C2, where ∀i = 1, 2,
Ci = (ai, βi) ∈ ˆC × ˆC2×(cid:96)i such that
)(cid:62)], this algorithm re-
βi = [(β(i)
, β(i)
2,(cid:96)i
turns a ciphertext C = (α, β) ∈ ˆC × ˆC2×((cid:96)1+(cid:96)2) computed
as follows:

2,1)(cid:62), . . . , (β(i)

1,1, β(i)

1,(cid:96)i

α = α1 (cid:1) α2,

β = [β1, β2]

k=1 b(i)

1,k · b(i)

j,k ∈ ˆEnc(pk, b(i)

j,k))j,k such that(cid:80)(cid:96)i

that(cid:80)(cid:96)1+(cid:96)2

For correctness, if αi ∈ ˆEnc(pk, mi−bi) and βi is a matrix
of (β(i)
2,k = bi,
then it is not hard to see that α ∈ ˆEnc(pk, (m1 + m2) −
(b1 + b2)) and β is a matrix of βj,k ∈ ˆEnc(pk, bj,k) such
cMult : On input a constant c ∈ M and a ciphertext C,
the algorithm works as follows. If C = β ∈ ˆC, it returns
a ciphertext C(cid:48) = c · β ∈ ˆC. The correctness of this
operation is straightforward.
If C = (α, β) ∈ ˆC × ˆC2×(cid:96) such that β = [(β1,1, β2,1)(cid:62), . . . ,
(β1,(cid:96), β2,(cid:96))(cid:62)], the algorithm returns a ciphertext C(cid:48) =
(α(cid:48), β(cid:48)) ∈ ˆC × ˆC2×(cid:96) computed as follows:

b1,k · b2,k = b1 + b2.

k=1

(cid:48)
(cid:48)

α

β

= c · α,
= [(c · β1,1, β2,1)

(cid:62)

, . . . , (c · β1,(cid:96), β2,(cid:96))
(cid:62)

]

To see the correctness of ciphertexts obtained through
cMult2, if α ∈ ˆEnc(pk, m− b) and β is a matrix of (βj,k ∈
k=1 b1,k · b2,k = b, then it is
not hard to see that α(cid:48) ∈ ˆEnc(pk, cm − cb) and β(cid:48) is a
matrix of β(cid:48)
2,k =

ˆEnc(pk, bj,k))j,k such that(cid:80)(cid:96)
β2,k ∈ ˆEnc(pk, b2,k). Hence,(cid:80)(cid:96)

1,k ∈ ˆEnc(pk, cb1,k) and β(cid:48)
k=1 c · b1,k · b2,k = c · b.

j,k such that β(cid:48)

Dec(sk, C): If C = β ∈ ˆC, the algorithm simply outputs
m ← ˆDec(sk, β). On the other hand, if C = (α, β) ∈
ˆC × ˆC2×(cid:96), the algorithm outputs

(cid:33)

(cid:32) (cid:96)(cid:88)

i=1

m ← ˆDec(α) +

ˆDec(sk, β1,i) · ˆDec(sk, β2,i)

.

Before concluding the description of the scheme, we de-
scribe how to perform ciphertext re-randomization. Namely,
we give a procedure ReRand that takes as input a ciphertext
C ∈ ˆC × ˆC2×(cid:96) encrypting some message m, using random
pad b, and outputs a new encryption of m padded with a
fresh random b(cid:48). We stress that such re-randomization is
crucial to achieve circuit privacy which would not be pos-
sible by using only the re-randomization of the underlying
linearly-homomorphic scheme.
ReRand(pk, C): On input a ciphertext C, if C = β ∈ ˆC
simply run the re-randomization procedure of HE. Else
if C = (α, β) ∈ ˆC × ˆC2×(cid:96) the algorithm chooses random
˜b $← M2×(cid:96) and outputs C(cid:48) = (α(cid:48), β(cid:48)) computed as follows
1. For i = 1 to (cid:96), compute

(cid:17) (cid:1) (−˜b2,i) · β1,i (cid:1) (−˜b1,i) · β2,i

(cid:16)

pk,−(˜b1,i · ˜b2,i)
i=1 γi ∈ ˆC

γi = ˆEnc

2. Set α(cid:48) ← α +(cid:80)(cid:96)
with b =(cid:80)(cid:96)

j,i ← βj,i(cid:1) ˆEnc(pk, ˜bj,i).
3. For i = 1 to (cid:96) and j = 1, 2, set β(cid:48)
To see correctness, ﬁrst assume that α ∈ ˆEnc(pk, m − b)

i=1 b1,i · b2,i and βj,i ∈ ˆEnc(pk, bj,i).

1523(cid:16)

(cid:17)

Then we have γi ∈ ˆEnc
j,i ∈ ˆEnc(pk, b(cid:48)
β(cid:48)
j,i) with b(cid:48)
α(cid:48) ∈ ˆEnc(pk, m − b(cid:48)) where

pk,−(˜b1,i˜b2,i + ˜b1,ib2,i + b1,i˜b2,i)
,
j,i = bj,i +˜bj,i. Thus we can write

(cid:48)

b

= b +

˜b1,i · ˜b2,i + ˜b1,i · b2,i + b1,i · ˜b2,i

(cid:96)(cid:88)

i=1

(cid:96)(cid:88)
(cid:96)(cid:88)

i=1

=

=

b1,i · b2,i + ˜b1,i · ˜b2,i + ˜b1,i · b2,i + b1,i · ˜b2,i

(cid:96)(cid:88)

(b1,i + ˜b1,i) · (b2,i + ˜b2,i) =

1,i · b
(cid:48)

(cid:48)
2,i

b

i=1

i=1

j,i) ∈ M2×(cid:96).

Therefore, α is a valid encryption of m under a completely
fresh pad (b(cid:48)
Note that we are assuming the underlying scheme ˆHE to
be circuit private. This, informally, means that all homo-
morphic operations involving ˆHE ciphertexts (e.g., additions
(cid:1) and multiplication by constants) hide the function.
The correctness of the scheme HE follows from the cor-
rectness of ˆHE, the fact that its message space M is a ﬁnite
ring, and by following the observations made along our de-
scription. Second, it is easy to see that the only “extra”
property we require to the underlying ˆHE is the ability to
sample random elements in M.
Proof of Security. First, it is straightforward to see that
the scheme HE is semantically-secure.

Theorem 1. If ˆHE is semantically-secure, then HE is se-

mantically secure.

We can also show (cf. the full version [9] for the proof) that
HE satisﬁes the notion of leveled circuit-privacy of Def. 7.
Theorem 2. If ˆHE is circuit private, then HE is a leveled

circuit-private homomorphic encryption.

2 , i.e., are of the form P ( (cid:126)m) +(cid:80)L

On the ciphertext growth. As we mentioned earlier, our
scheme cannot compactly evaluate all degree-2 polynomials.
Yet we achieve compactness as long as the polynomials are
in F (cid:63)
i=1 Qi( (cid:126)m)· Ri( (cid:126)m), with
P ( (cid:126)m),{Qi( (cid:126)m), Ri( (cid:126)m)} all of degree 1. Such a class of poly-
nomials is still meaningful. For example, the SPDZ protocol
[14], in its oﬄine phase, requires a somewhat homomorphic
encryption capable of evaluating polynomials exactly of the
form P ( (cid:126)m) + Q( (cid:126)m) · R( (cid:126)m), which is a subset (for L = 1) of
our supported class F (cid:63)
2 .

In Section 5 we show how to completely remove this is-
sue in a speciﬁc application (thus achieving fully compact
ciphertexts while supporting all degree-2 polynomials).

P ( (cid:126)m) +(cid:80)L

Exact asymptotic costs. Here we provide exact asymp-
totic costs both for the client and the server. Let f ( (cid:126)m) =
i=1 Qi( (cid:126)m) · Ri( (cid:126)m), with P ( (cid:126)m),{Qi( (cid:126)m), Ri( (cid:126)m)}
all of degree 1, each containing a maximum of n monomials.
Note that the circuit for evaluating f ( (cid:126)m) has size O(n · L).
The client’s cost in decryption is dominated by the (2L+1)
decryptions that need to be performed in the worst case.
This leads to an O(Lp ˆDec) complexity, where p ˆDec is the cost
ˆDec. Notice that the client complexity is in-
of running
dependent of n. The server’s cost, on the other hand, is
O(nL(pAdd1 + pcMult) + Lp ˆEnc)9.
9Here we are ignoring the cost of ReRand as it will be run
only once.

Inheriting Properties.
Interestingly, our transforma-
tion naturally preserves useful properties of the underly-
ing linearly-homomorphic scheme. Here we highlight three
properties: proof of knowledge, threshold decryption and
multikey homomorphic encryption.
First, given that “fresh” ciphertexts are simply ciphertexts
of the ˆHE scheme, it is immediate to see that if ˆHE admits a
zero knowledge proof of plaintext knowledge protocol, then
so does HE.

As a second property, we consider multikey homomorphic
encryption. This is a scheme which is capable of performing
homomorphic operations on inputs encrypted under mul-
tiple unrelated keys, and that allows decryption only if,
roughly speaking, all the corresponding secret keys involved
in the computation are used. This notion has been for-
mally proposed in the context of multiparty computation by
L´opez-Alt et al. [28] who also proposed a fully-homomorphic
realization. We note that a multikey linearly-homomorphic
encryption scheme was earlier given by Bresson et al.
[6]
(albeit not explicitly formalized). The following theorem
shows that the schemes obtained via our transformation in-
herit the multikey property (informally this holds because
a HE ciphertext consists of one or more ˆHE ciphertexts).
Therefore, by plugging for instance the scheme of Bresson
et al. [6] we obtain a multikey HE scheme supporting one
multiplication.

Theorem 3. If ˆHE is a multikey linearly-homomorphic

encryption, then so is HE.

As a third property inherited by our transformed schemes,

we consider threshold decryption.

Theorem 4. If ˆHE has a threshold decryption protocol
associated with it, then HE has threshold decryption as well.

The theorem follows by observing that the threshold variant
of HE is basically the same threshold variant of ˆHE.
Beyond Degree 2. The main diﬃculty when trying to
extend our technique to support more than one level of mul-
tiplications come from the fact that, to keep going in the
same way, one needs to perform multiplications of the ﬁrst
components of each triplet. Clearly, this can be achieved
easily if the underlying encryption scheme is more than lin-
early homomorphic.
In the full version, we show how to
generalize our construction to boost a level-d homomorphic
encryption scheme to a level-(d + 1) scheme. As an inter-
esting consequence, such a generalization for instance shows
how to use the BGN cryptosystem [3] to evaluate polynomi-
als of degree up to 4 on ciphertexts.

Instantiations. By instantiating our transformation with
a variety of existing schemes (e.g., [20, 10, 11, 32, 30, 33, 13,
6, 2, 25, 8]) we obtain several HE schemes capable of evalu-
ating one multiplication whose security relies on a variety of
assumptions, such as standard DDH, quadratic/composite
residuosity, or Decision Linear.

5. TWO-SERVER DELEGATION OF COM-

PUTATION ON ENCRYPTED DATA

In this section we introduce a new primitive that we call
two-server delegation of computation on encrypted data (2S-
DCED, for short) and we show how to realize it building
on our technique of Section 4. Using a 2S-DCED protocol,

1524a client can outsource the computation of a function f on
some input m to two distinct servers in such a way that:
it is possible to recover the output f (m) from the servers’
outputs, and (2) the two servers do not need to interact
(nor to know of their mutual existence). For security, the
protocol preserves the conﬁdentiality of the client’s inputs
as long as the two servers do not collude.

This new notion is somehow related to the one of server-
aided secure function evaluation [26].
Indeed, in the full
version we show how to use two-server delegation of compu-
tation on encrypted data to build double-server-aided secure
function evaluation in the semi-honest model.
5.1 2S-DCED Deﬁnition

A protocol for two-server delegation of computation on en-
crypted data is a tuple of algorithms 2S.DCED = (2S.KeyGen,
2S.Enc, 2S.Dec, 2S.Eval1, 2S.Eval2) working as follows.
2S.KeyGen(1λ): the key generation algorithm takes as input
the security parameter λ and produces a secret key sk and
a public key pk.
2S.Enc(pk, m): the encryption algorithm takes as input pk
and a message m ∈ M and outputs a ciphertext C con-
sisting of two components (C (1), C (2)).

2S.Dec(sk, C (1), C (2)): the decryption algorithm takes as in-
put sk, a ciphertext (C (1), C (2)) and returns a message m.
In addition, there exist two evaluation algorithms 2S.Eval1,
2S.Eval2 (basically, one for each server):
2S.Evali(pk, f, C (i)
t ): the i-th evaluation algorithm
takes as input pk, an arithmetic circuit f : Mt → M in a
class F of “permitted” circuits, and t ciphertexts C (i)
1 , . . . ,
C (i)
, all of the same component i = 1, 2. The algorithm
outputs a ciphertext C (i) (of the same component).
As a basic property, a 2S-DCED protocol must be correct

1 , . . . , C (i)

t

and compact.

Definition 9. A 2S-DCED protocol 2S.DCED = (2S.KeyGen,

2S.Enc, 2S.Eval1, 2S.Eval2, 2S.Dec) correctly evaluates a fam-
ily of circuits F if for all honestly generated keys (pk, sk) $←
2S.KeyGen(1λ), for all f ∈ F and for all messages m1,
) ← 2S.Enc(pk, mi)
. . . , mt ∈ M we have that if (C (1)
∀i ∈ [t], then Pr[2S.Dec(sk, 2S.Eval1(pk, f, C (1)
)) = f (m1, . . . , mt)] = 1−negl(λ)
2S.Eval2(pk, f, C (2)
where the probability is taken over all the algorithms’ ran-
dom choices. Furthermore, 2S.DCED compactly evaluates F
if above the running time of the decryption algorithm 2S.Dec
is bounded by a ﬁxed polynomial in λ, independent of f .

1 , . . . , C (1)

1 , . . . , C (2)

, C (2)

),

t

t

i

i

Security.
Informally, a 2S-DCED protocol should guaran-
tee that any adversary who has access to only one component
of a ciphertext (C (1), C (2)) should not learn any information
about the underlying plaintext. We formalize this property
using the approach of semantic security. Intuitively, our no-
tion says that as long as the two servers do not collude,
each of them does not learn anything about the encrypted
messages.

Definition 10

(2S-DCED Semantic Security). Let
2S.DCED be a 2S-DCED protocol as deﬁned above, and A
be a PPT adversary. Consider the following experiment:

Experiment Exp2S.SS

2S.DCED,A(λ)

b $← {0, 1}; (pk, sk) $← 2S.KeyGen(1λ)

(m0, m1, i)←A(pk)
(C (1), C (2)) $← Enc(pk, mb)
b(cid:48)←A(C (i))
If b(cid:48) = b return 1. Else return 0.
2S.DCED,A(λ) = Pr[Exp2S.SS

Let Adv2S.SS
2 . We
say that 2S.DCED is semantically-secure if for any PPT A
it holds Adv2S.SS

2S.DCED,A(λ) = negl(λ).

2S.DCED,A(λ) = 1] − 1

We remark that the notion extends in a straightforward
way to the case where the adversary submits multiple triples
{(m0,j, m1,j, ij)} and receives the corresponding ciphertext
components {C (ij )

} (all generated with the same b).

j

In addition to semantic security we consider another se-
curity notion that we call context hiding. The motivation
is that in the outsourcing setting the party who decrypts
may be diﬀerent from the one who provides the inputs of
the computation. Hence, the decryptor who receives a ci-
phertext (C (1), C (2)) encrypting the result of a computation
f must learn nothing about all the inputs of f (that it did
not provide), beyond what the result trivially reveals, i.e.,
f (m1, . . . , mt).

Definition 11

(Context Hiding). We say that a pro-
tocol 2S.DCED for two-server delegation of computation on
encrypted data satisﬁes context-hiding for a family of cir-
cuits F if there exists a PPT simulator Sim and a negligible
function (λ) such that the following holds. For any λ ∈ N,
any pair of keys (pk, sk) $← 2S.KeyGen(1λ), any circuit f ∈
F with t inputs, any two tuples of messages (cid:126)m1 ∈ Mt1 , (cid:126)m2 ∈
Mt2 such that t = t1 + t2 and corresponding ciphertexts
$← 2S.Enc(pk, (cid:126)mk)
(cid:126)C1, (cid:126)C2 such that (cid:126)Ck = ( (cid:126)C (1)
for k = 1, 2, and a ciphertext (C (1), C (2)) where C (1) =
2S.Eval1(pk, f, (cid:126)C (1)
2) and C (2) = 2S.Eval2(pk, f, (cid:126)C (2)
1,
(cid:126)C (2)

2) it holds
SD[(C (1), C (2)), Sim(1λ, (cid:126)C1, f, pk, f ( (cid:126)m1, (cid:126)m2))] ≤ (λ)

k, (cid:126)C (2)

1, (cid:126)C (1)

k)

5.2 A 2S-DCED Protocol for Degree-2 Poly-

nomials

In this section, we propose the construction of a proto-
col for two-server delegation of computation on encrypted
data that supports the evaluation of all degree-2 multivariate
polynomials. Our construction builds upon a public-space
linearly-homomorphic encryption scheme (cf. Deﬁnition 8),
and its interesting feature is to “boost” the linear-only ho-
momorphism in order to compute functions up to degree 2.
We stress that in contrast to the result of Section 4, here
the ciphertext remains always compact and thus the scheme
can support the evaluation of all degree-2 polynomials.

Furthermore, our protocol achieves two interesting prop-
erties that we call unbalanced eﬃciency and unbalanced se-
curity. The former says that one of the two servers can
perform the computation essentially “for free”, i.e., as if it
computes over the original inputs in M. The unbalanced
security property instead says that with respect to such
eﬃcient server the semantic security of the protocol holds
information-theoretically.

The precise description of our scheme follows:

2S.KeyGen(1λ): On input 1λ, where λ is a security parame-
ˆKeyGen(1λ) to get (pk, sk), and outputs (pk, sk).
ter, it runs
We assume that pk implicitly contains a description of the
message space M and the ciphertext space ˆC.

15252S.Enc(pk, m): The randomized encryption algorithm chooses
a random value b $← M and sets a ← (m − b) ∈ M and
β ← ˆEnc(pk, b). The output is C (1) = (a, β) ∈ M × ˆC and
C (2) = b ∈ M. The ciphertexts of the ﬁrst component
C (1) are “leveled”, i.e., the ones of the form (a, β) ∈ M× ˆC
are of level 1, whereas C (1) = α ∈ ˆC are of level 2.
2S.Eval1(pk, f, C (1)

): the evaluation algorithm for
the ciphertexts of the ﬁrst component essentially consists
of the basic procedures for performing the homomorphic
operations: Add1, Mult, Add2. Informally, Add1 and Mult
operate over pairs of level-1 ciphertexts whereas Add2 op-
erates over pairs of level-2 ciphertexts.
2 ∈ M× ˆC
Add1 : On input two level-1 ciphertexts C (1)
where, for i = 1, 2, C (1)
i = (ai, βi) this algorithm returns
a (level-1) ciphertext C = (a, β) ∈ M × ˆC computed as:

1 , . . . , C (1)

1 , C (1)

t

a = a1 + a2,

β = β1 (cid:1) β2
2 ∈ M× ˆC
Mult : On input two level-1 ciphertexts C (1)
this algorithm outputs a level-2 ciphertext C (1) = α ∈ ˆC
computed as:

1 , C (1)

α = ˆEnc(pk, a1 · a2) (cid:1) a1 · β2 (cid:1) a2 · β1

Add2 : On input two level-2 ciphertexts C (1)
2 =
α2 ∈ ˆC this algorithm returns a level-2 ciphertext C (1) =
α ∈ ˆC computed as

1 = α1, C (1)

α = α1 (cid:1) α2

t

1 , . . . , C (2)

Finally, given a ciphertext C (1), a multiplication by a known
constants c ∈ M is achieved straightforwardly:
if C =
(a, β), simply return (c · a, c · β); if C = α return c · α.
i = bi ∈ M for all i ∈
): let C (2)
2S.Eval2(pk, f, C (2)
[t]. The algorithm simply executes f over the bi’s. Namely,
output C (2) = b = f (b1, . . . , bt) ∈ M.
2S.Dec(sk, C (1), C (2)): the decryption proceeds slightly dif-
ferently according to whether the ciphertext component
C (1) is of level-1 or level-2.
Given C (1) = (a, β) and C (2) ∈ M, output m ← a + C (2).
Given C (1) = α ∈ ˆC and C (2) ∈ M, output m ← ˆDec(sk, α)+
C (2).
We notice that the β component of C (1) is not necessary
for decryption. That is, in order to save bandwidth one
may require the ﬁrst server not to transmit β.

Security. First, we prove that our protocol is semantically-
secure according to our Deﬁnition 10.

Theorem 5. If ˆHE is semantically-secure, then 2S.DCED
is a semantically-secure protocol for two-server delegation of
computation on encrypted data.

The proof is rather straightforward and is omitted.

To continue, we show that the protocol 2S.DCED satisﬁes

context-hiding as per Deﬁnition 11.

Theorem 6. If ˆHE is circuit-private, then 2S.DCED is

context-hiding.

Proof. Let ˆSim be the simulator for the circuit privacy
of ˆHE. For an arithmetic circuit f of degree 1 the simulator

Sim(1λ, (cid:126)C1, f, pk, m = f ( (cid:126)m1, (cid:126)m2)) can simply output (cid:100)C (1) =
(m − b, ˆSim(1λ, pk, b)) and (cid:100)C (2) = b where b = f ((cid:126)b1,(cid:126)b2) for

a randomly sampled (cid:126)b2 ∈ Mt2 and for (cid:126)b1 = (cid:126)C (2)
1. If f is
ˆSim(1λ, pk, m − b). It is straightforward to see that by the

of degree 2, the simulator does the same except that (cid:100)C (1) =
circuit privacy of ˆHE ((cid:100)C (1), (cid:100)C (2)) is indistinguishable from

the pair (C (1), C (2)) produced by the algorithms 2S.Eval1
and 2S.Eval2 respectively.

Unbalanced Eﬃciency and Unbalanced Security. Our
2S-DCED protocol described above achieves two interesting
properties. The ﬁrst one, that we call unbalanced eﬃciency,
says, very roughly, that one of the two servers needs to invest
much fewer computational resources. More in detail, the
second server – the one executing 2S.Eval2 – can run much
faster than the ﬁrst server since it does not have to do any
public key operation. Essentially, it can perform as if it com-
putes over the messages in the plain. Moreover, the storage
overhead at such second server, i.e., the ratio |C (2)|/|m|, is
basically null. This property is particularly relevant in cloud
scenarios where clients have to pay for the servers’ storage
space and CPU cycles. In our solution the cost to pay to
the second server is indeed signiﬁcantly smaller.

The second property achieved by our construction is called
unbalanced security, and it says that the semantic security
of the protocol holds information-theoretically with respect
to the second server10, the same one who can run faster.

Oﬄine/Online Encryption. Our 2S-DCED protocol
also enjoys the possibility to perform a pre-processing that
allows to encrypt very eﬃciently. In fact, the encryptor may
generate oﬄine all the random masks b, and send β = ˆEnc(b)
and b to the ﬁrst and second server, respectively. Next, in
the online phase, to encrypt m, one has to simply compute
a = (m − b) and send a to the ﬁrst server. As a further op-
timization, instead of storing all the b values, one may also
generate them using a PRF computed on a unique label
(e.g., a counter).

Comparison with other possible solutions. We note
that by using a linear secret sharing scheme it is possible to
construct a 2S-DCED protocol which uses only two servers,
though supporting only degree-1 computations. To support
degree-2 computations using secret sharing, one would need
at least three distinct non-colluding servers (see e.g., [12]).
On the other hand, a solution (with succinct communica-
tion) based on only one server can be achieved using a some-
what homomorphic encryption scheme supporting one mul-
tiplication. In contrast, our solution can achieve the same
result with only two servers and by using only a linearly-
homomorphic encryption scheme.

6. EXPERIMENTAL EVALUATION

To give the reader a glance of the practical eﬃciency of
the schemes resulting from our transformations of Section 4
and 5, we implemented the schemes obtained by using Pail-
lier [33] and Joye-Libert [25] as underlying cryptosystems.
We show the performances related to the HE scheme, and
we note that the performances for the two-server 2S.DCED
scheme are very similar. For decryption we measured the
decryption of a single ciphertext (which is what it is done in
2S.DCED): the shown value should be multiplied by (2L+1)

10With respect to the ﬁrst server the security still holds in a
computational sense.

1526for the total decryption time of HE, where L is the number
of degree-2 monomials in the computed function.

We compared the performance of our solutions with that
of the BGV [4] homomorphic encryption implemented in
HE-Lib [23], instantiated with parameters suitable to sup-
port one multiplication. Clearly, the somewhat homomor-
phic scheme always yields a single-server solution.

More in detail, we considered an application in which one
encrypts integers and wishes to perform computations with
128-bits precision.11 This led us to instantiate Joye-Libert
with message space Z
2128 and BGV with message space12
Zp[X]/Φm(X) where p is a 21-bits prime and φ(m) > 5000.
Paillier’s cryptosystem has always a large enough message
space ZN , with N of 1024 (resp. 3072) bits.

The schemes are implemented with security parameters of
80 and 128 bits, and both implementations of the Paillier-
based and Joye-Libert-based schemes use NTL [36] with
GMP [19]. Our timings were performed on a MacBook Pro
laptop (Intel Core i5, 8GB RAM) running Mac OS X 10.10.3.
A summary of the measured costs appear in Table 1.

Timing (ms) HE(Paillier)
80bit 128bit

Security

KeyGen
Enc
Add1
Mult
Dec

20.37 787.45
7.36 154.97
0.011
0.055
32.33 707.49
155

7.28

HE(JL13)
80bit 128bit

23.54 842.78
3.93
0.018
10.49
20.76

0.49
0.005
1.29
3.29

BGV12

80bit 128bit

590
31.7
0.136
44.58
82.38

4110
36.9
0.255
45.63
116

C. size (bytes)

256

768

128

384

71K

89K

Table 1: Cost comparisons.

By analyzing the above timings and comparing the result-
ing homomorphic encryption schemes, we observe that for
L = 10 the solution based on JL13 (with 80bits of secu-
rity) still achieves: a decryption time comparable to that
of BGV (69.09ms vs. 82.38ms); ciphertexts that are 25×
shorter (2.7KB vs. 71KB); encryption and homomorphic
operations timings that are at least 30× faster. On the
other hand, our HE schemes do not scale well for large val-
ues of L (still, for L ≤ 270 our solution wins for bandwidth
as ciphertexts remain shorter). Nevertheless, in the two-
server setting, although being in a weaker security model,
our solution outperforms the BGV somewhat homomorphic
encryption: ciphertexts are almost 500× shorter; encryption
and decryption is about 60× cheaper; the costs at the ﬁrst
server are roughly 36× faster, whereas the costs at the sec-
ond server are essentially negligible (we estimated the cost
of a multiplication in Z

2128 to 0.8µs).

Comparison with BGN . To complete the picture we
provide also comparisons with the BGN [3] cryptosystem.
For 128-bit security, Guillevic [22] argues that level-1 ci-
phertexts (i.e. ciphertexts for which homomorphic additions
and - one - multiplication can be performed) require 3072-
bits, whereas level-2 ciphertexts require (roughly) 6144 bits.
For 80-bit security we consider a public modulus of 1024
bits. This leads to ciphertext sizes of 1024 bits for level
1 ciphertexts and 2048 for level 2 ones. Thus, in terms
of bandwidth consumption, BGN performs better than our
JL13-based solution for essentially all computations involv-

11Such an application for example rules out encryption
schemes such as BGN that support only small messages.
12We use the optimized message encoding techniques of [31].

ing small plaintexts. The latter, however, is preferable both
in terms of plaintext space (it allows for exponentially large
message spaces) and in terms of computational eﬃciency.
Table 2 provides more precise indications of the measured
costs. These costs do not explicitly include the costs for
additions after the multiplication (i.e. Add2) as these are
essentially the same as those for Add1 in both cases. We
notice that the plaintext space for BGN refers to the size
(in bits) of the original encrypted messages. After multi-
plication such messages can double their length and this is
why Dec2 (i.e. decryption in the target group) is often much
more costly than Dec1.

Timing (ms)

BGN05

Security

80bit

128bit

KeyGen
Enc
Add1
Mult
Dec1
Dec2

446.969 5662.638
43.127
0.074
542.364
180.88
432.043 2188.677

3.936
0.018
28.872
22.893

HE(JL13)
80bit

128bit

18.96
0.07
0.0059
0.16
0.35

762.76
0.39
0.018
0.99
5.94
(2L+1) × Dec1

Table 2: Comparison with BGN for 10-bit messages.

Acknowledgments
The authors would like to thank Mario Di Raimondo and
Rosario Sebastiano Russo for providing help and support
for the implementations, and the anonymous reviewers for
their valuable comments.

7. REFERENCES
[1] B. Applebaum, Y. Ishai, and E. Kushilevitz. How to

garble arithmetic circuits. In R. Ostrovsky, editor,
52nd FOCS, pages 120–129. IEEE Computer Society
Press, Oct. 2011.

[2] D. Boneh, X. Boyen, and H. Shacham. Short group
signatures. In M. Franklin, editor, CRYPTO 2004,
volume 3152 of LNCS, pages 41–55. Springer, Aug.
2004.

[3] D. Boneh, E.-J. Goh, and K. Nissim. Evaluating

2-DNF formulas on ciphertexts. In J. Kilian, editor,
TCC 2005, volume 3378 of LNCS, pages 325–341.
Springer, Feb. 2005.

[4] Z. Brakerski, C. Gentry, and V. Vaikuntanathan.

(leveled) fully homomorphic encryption without
bootstrapping. In S. Goldwasser, editor, ITCS 2012,
pages 309–325. ACM, Jan. 2012.

[5] Z. Brakerski and V. Vaikuntanathan. Fully

homomorphic encryption from ring-LWE and security
for key dependent messages. In P. Rogaway, editor,
CRYPTO 2011, volume 6841 of LNCS, pages 505–524.
Springer, Aug. 2011.

[6] E. Bresson, D. Catalano, and D. Pointcheval. A simple

public-key cryptosystem with a double trapdoor
decryption mechanism and its applications. In C.-S.
Laih, editor, ASIACRYPT 2003, volume 2894 of
LNCS, pages 37–54. Springer, Nov. / Dec. 2003.

[7] C. Cachin, J. Camenisch, J. Kilian, and J. Muller.

One-round secure computation and secure
autonomous mobile agents. In U. Montanari, J. D. P.
Rolim, and E. Welzl, editors, ICALP 2000, volume
1853 of LNCS, pages 512–523. Springer, July 2000.

1527[8] G. Castagnos and F. Laguillaumie. Linearly

homomorphic encryption from DDH. In K. Nyberg,
editor, Topics in Cryptology – CT-RSA 2015, volume
9048 of Lecture Notes in Computer Science, pages
487–505. Springer International Publishing, 2015.

[9] D. Catalano and D. Fiore. Boosting

linearly-homomorphic encryption to evaluate degree-2
functions on encrypted data. Cryptology ePrint
Archive, Report 2014/813, 2014.

[10] J. D. Cohen and M. J. Fischer. A robust and veriﬁable

cryptographically secure election scheme (extended
abstract). In 26th FOCS, pages 372–382. IEEE
Computer Society Press, Oct. 1985.

M. J. Jacobson Jr., M. E. Locasto, P. Mohassel, and
R. Safavi-Naini, editors, ACNS 13, volume 7954 of
LNCS, pages 357–372. Springer, June 2013.

[23] S. Halevi and V. Shoup. Helib.

https://github.com/shaih/HElib.

[24] Y. Ishai and A. Paskin. Evaluating branching

programs on encrypted data. In S. P. Vadhan, editor,
TCC 2007, volume 4392 of LNCS, pages 575–594.
Springer, Feb. 2007.

[25] M. Joye and B. Libert. Eﬃcient cryptosystems from

2k-th power residue symbols. In T. Johansson and
P. Q. Nguyen, editors, EUROCRYPT 2013, volume
7881 of LNCS, pages 76–92. Springer, May 2013.

[11] R. Cramer, R. Gennaro, and B. Schoenmakers. A

[26] S. Kamara, P. Mohassel, and M. Raykova.

secure and optimally eﬃcient multi-authority election
scheme. In W. Fumy, editor, EUROCRYPT’97,
volume 1233 of LNCS, pages 103–118. Springer, May
1997.

[12] I. Damg˚ard and Y. Ishai. Constant-round multiparty

computation using a black-box pseudorandom
generator. In V. Shoup, editor, CRYPTO 2005,
volume 3621 of LNCS, pages 378–394. Springer, Aug.
2005.

[13] I. Damg˚ard and M. Jurik. A generalisation, a

simpliﬁcation and some applications of Paillier’s
probabilistic public-key system. In K. Kim, editor,
PKC 2001, volume 1992 of LNCS, pages 119–136.
Springer, Feb. 2001.

[14] I. Damg˚ard, V. Pastro, N. P. Smart, and S. Zakarias.

Multiparty computation from somewhat homomorphic
encryption. In R. Safavi-Naini and R. Canetti, editors,
CRYPTO 2012, volume 7417 of LNCS, pages 643–662.
Springer, Aug. 2012.

[15] T. ElGamal. A public key cryptosystem and a

signature scheme based on discrete logarithms. In
G. R. Blakley and D. Chaum, editors, CRYPTO’84,
volume 196 of LNCS, pages 10–18. Springer, Aug.
1984.

[16] D. M. Freeman. Converting pairing-based

cryptosystems from composite-order groups to
prime-order groups. In H. Gilbert, editor,
EUROCRYPT 2010, volume 6110 of LNCS, pages
44–61. Springer, May 2010.

[17] C. Gentry. Fully homomorphic encryption using ideal

lattices. In M. Mitzenmacher, editor, 41st ACM
STOC, pages 169–178. ACM Press, May / June 2009.

[18] C. Gentry, S. Halevi, and V. Vaikuntanathan. i-Hop

homomorphic encryption and rerandomizable Yao
circuits. In T. Rabin, editor, CRYPTO 2010, volume
6223 of LNCS, pages 155–172. Springer, Aug. 2010.

[19] GMP. The GNU Multi Precision Arithmetic Library.

http://www.gmplib.org.

[20] S. Goldwasser and S. Micali. Probabilistic encryption
& how to play mental poker keeping secret all partial
information. In Proceedings of the Fourteenth Annual
ACM Symposium on Theory of Computing, STOC ’82,
pages 365–377, New York, NY, USA, 1982. ACM.

[21] S. Goldwasser and S. Micali. Probabilistic encryption.

Journal of Computer and System Sciences,
28(2):270–299, 1984.

[22] A. Guillevic. Comparing the pairing eﬃciency over
composite-order and prime-order elliptic curves. In

Outsourcing multi-party computation. Cryptology
ePrint Archive, Report 2011/272, 2011.
http://eprint.iacr.org/2011/272.

[27] E. Kushilevitz and R. Ostrovsky. Replication is NOT

needed: SINGLE database, computationally-private
information retrieval. In 38th FOCS, pages 364–373.
IEEE Computer Society Press, Oct. 1997.

[28] A. L´opez-Alt, E. Tromer, and V. Vaikuntanathan.

On-the-ﬂy multiparty computation on the cloud via
multikey fully homomorphic encryption. In H. J.
Karloﬀ and T. Pitassi, editors, 44th ACM STOC,
pages 1219–1234. ACM Press, May 2012.

[29] C. A. Melchor, P. Gaborit, and J. Herranz. Additively

homomorphic encryption with d-operand
multiplications. In T. Rabin, editor, CRYPTO 2010,
volume 6223 of LNCS, pages 138–154. Springer, Aug.
2010.

[30] D. Naccache and J. Stern. A new public key

cryptosystem based on higher residues. In ACM CCS
98, pages 59–66. ACM Press, Nov. 1998.

[31] M. Naehrig, K. Lauter, and V. Vaikuntanathan. Can
homomorphic encryption be practical? In Proceedings
of the 3rd ACM Workshop on Cloud Computing
Security Workshop, CCSW ’11, pages 113–124, New
York, NY, USA, 2011. ACM.

[32] T. Okamoto and S. Uchiyama. A new public-key

cryptosystem as secure as factoring. In K. Nyberg,
editor, EUROCRYPT’98, volume 1403 of LNCS,
pages 308–318. Springer, May / June 1998.

[33] P. Paillier. Public-key cryptosystems based on

composite degree residuosity classes. In J. Stern,
editor, EUROCRYPT’99, volume 1592 of LNCS,
pages 223–238. Springer, May 1999.

[34] R. L. Rivest, L. Adleman, and M. L. Dertouzos. On

data banks and privacy homomorphisms. Foundations
of Secure Computation, Academia Press, pages
169–179, 1978.

[35] T. Sander, A. Young, and M. Yung. Non-interactive

cryptocomputing for NC1. In 40th FOCS, pages
554–567. IEEE Computer Society Press, Oct. 1999.
[36] V. Shoup. Ntl library. http://www.shoup.net/ntl/.
[37] N. P. Smart and F. Vercauteren. Fully homomorphic

encryption with relatively small key and ciphertext
sizes. In P. Q. Nguyen and D. Pointcheval, editors,
PKC 2010, volume 6056 of LNCS, pages 420–443.
Springer, May 2010.

1528[38] M. van Dijk, C. Gentry, S. Halevi, and

V. Vaikuntanathan. Fully homomorphic encryption
over the integers. In H. Gilbert, editor,
EUROCRYPT 2010, volume 6110 of LNCS, pages
24–43. Springer, May 2010.

[39] A. C.-C. Yao. Protocols for secure computations

(extended abstract). In 23rd FOCS, pages 160–164.
IEEE Computer Society Press, Nov. 1982.

APPENDIX
A. ADAPTING KNOWN HE SCHEMES TO

BE Public-Space

In this section we show that those few encryption schemes
which do not ﬁt our notion of public-space, can be eas-
ily modiﬁed to do so. This is the case for the additively-
homomorphic variants (aka “in the exponent”) of the ElGa-
mal [15, 11] and the BBS Linear Encryption [2] schemes (we
show the adaptation of these schemes in the full version [9]),
as well as for BGN [3]. The case of Okamoto-Uchiyama [32]
is slightly diﬀerent: we show how to tweak the scheme so
that it can still be used in our construction of Section 4.
A.1 Adapting the BGN Cryptosystem

The basic BGN [3] does not ﬁt our requirement of public-
space encryption scheme. This is because, in order to cope
with the decryption procedure the messages are treated as
(small) integers rather than elements in a ring. This diﬃ-
culty can be easily overcome by forcing the messages to be
treated as elements in some appropriate ring.

that we call BGN(pub).

Below we give a short description of the adapted scheme
Let G(1λ) be an algorithm that on input security param-
eter λ outputs a tuple (p, q, G, GT , e) where G and GT are
groups of order N = pq and e : G× G → GT a bilinear map.
KeyGen(1λ): On input 1λ where λ is a security parameter,
run G(1λ) to obtain (p, q, G, GT , e). Set N = pq. Pick
two random generators g, g(cid:48) ∈R G and set h = (g(cid:48))q. The
public key is set as pk = (N, G, GT , e, g, h), the private key
is sk = p. For the message space, take some small integer
t << q and set M = Zt.
Enc(pk, m): To encrypt m ∈ M, the algorithm picks a ran-
dom r $← {1, ..., N} and outputs C = gmhr ∈ G.
Eval(pk, f, C1, . . . , Cn): Given two ciphertexts C1, C2 ∈ G,
homomorphic addition is performed by merely multiplying
– over G – (and re-randomizing) the ciphertexts, i.e., one
takes a random s $← {1, ..., N} and sets C = C1 · C2 ·
hs = gm1+m2 · hr1+r2+s.
If C1, C2 ∈ GT , one does the
same over GT by using e(g, h) in place of h. The (single)
homomorphic multiplication can be performed by using the
bilinear map as follows:

C = e(C1, C2)e(g, h)s = e(g, g)m1m2 e(g, h)ˆs ∈ GT

Clearly, the scheme remains additively homomorphic in
GT .
Dec(sk, C): To decrypt a ciphertext C using the private key
p, one ﬁrst computes C p = (gmhr)p = (gp)m. Next, one
extracts the discrete log m of C p in base gp. Finally, return
(m mod t).
As in [3], in order for decryption to be eﬃcient one needs
t to be small enough so that it is possible to execute in poly-
nomial time the extraction of discrete logs of at most T bits,

where 2T is an upper bound on the maximum value reach-
able by applying an admissible computation on messages of
log t bits. For instance, T = log(n · t3) when considering
degree-2 polynomials with n = poly(λ) monomials and co-
eﬃcients in Zt. The same proof of security in [3] trivially
applies to the scheme described above.

Theorem 7. If the subgroup decision assumption holds
for G, then the scheme BGN(pub) described above is a seman-
tically secure, public-space level-2 homomorphic encryption.

Moreover, note that our adaptation applies also to the vari-
ant of BGN based on the Decision Linear assumption which
can be obtained via the transformation in [16].
A.2 The modiﬁed Okamoto-Uchiyama

The encryption scheme of Okamoto-Uchiyama [32] does
not ﬁt our public-space requirement. However, we show that
with a small tweak this scheme too can be used in our basic
construction of Section 4. Let us ﬁrst recall the scheme.
KeyGen(1λ): On input 1λ where λ is a security parameter,
the algorithm generates large primes p and q, such that
|p| = |q| = λ and set N = p2q. Next, it chooses g ∈
(ZN )∗ such that g is a generator of Z∗
p2 . Finally set h =
gN mod N . Let k be such that 2k is (slightly) less than
p. The message space is M = {0, 1}k The public key is
(N, h, g) while the secret key is p.
Enc(pk, m): On input a message m ∈ M, choose a random
r ∈ ZN and output C = gmhr mod N .
Dec(sk, C): On input a ciphertext C and the secret key, one
ﬁrst computes D = C p−1 mod p2 = (gm)p−1 mod p2. Note
that D has order p in Z∗
p , over the
integers. The plaintext is retrieved as

p2 . Let L(x) = x−1

m ←

L(D)

L (gp−1 mod p2)

mod p

The problem with the above construction is that the scheme

2k .

−a2 mod N

is homomorphic modulo p while p is not public. We over-
come this diﬃculty by working directly modulo the (public!)
value N and by performing reductions modulo p only at de-
cryption time. This leads to the level-2 HE scheme that we
call OU(level−2) sketched below.
KeyGen(1λ): This is exactly as above with M = Z
Enc(pk, m): This is as above as well.
Eval(pk, f, C1, . . . , Cn): this algorithm is basically the same
as the one explained in Section 4 except that for multiply-
ing two ciphertexts C1, C2 ∈ Z∗
N one proceeds as follows.
One chooses random a1, a2
−a1 mod N,
1 · βa1

$← ZN , and sets
β2 = C2 · g

α = ga1a2 · βa2

β1 = C1 · g

2 mod N,

β = [β1, β2]

, and ﬁnally output m ← a+(cid:80)(cid:96)

Dec(sk, C): to decrypt a ciphertext of the form (α, β) ∈
ZN × Z2×(cid:96)
N , ﬁrst “decrypt” α as described above to ob-
tain a ∈ Zp, second do the same with all the β’s to obtain
b ∈ Z2×(cid:96)
i=1 b1,i·b2,i mod p.
It is straightforward to see that by applying the security
proof of [32] the above scheme is semantically secure under
the p-subgroup decision assumption.

p

Theorem 8. If the p-subgroup assumption holds, then the
scheme OU(level−2) described above is a semantically-secure
homomorphic encryption that correctly and compactly eval-
uates polynomials in F (cid:63)
2 .

1529