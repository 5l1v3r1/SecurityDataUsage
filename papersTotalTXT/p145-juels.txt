Honeywords:

Making Password-Cracking Detectable

Ari Juels

RSA Laboratories
Cambridge, MA, USA
ari.juels@rsa.com

MIT CSAIL

Ronald L. Rivest
Cambridge, MA, USA
rivest@mit.edu

ABSTRACT

We propose a simple method for improving the security of
hashed passwords: the maintenance of additional “honey-
words” (false passwords) associated with each user’s account.
An adversary who steals a ﬁle of hashed passwords and in-
verts the hash function cannot tell if he has found the pass-
word or a honeyword. The attempted use of a honeyword
for login sets oﬀ an alarm. An auxiliary server (the “hon-
eychecker”) can distinguish the user password from honey-
words for the login routine, and will set oﬀ an alarm if a
honeyword is submitted.

Categories and Subject Descriptors

D.4.6 [OPERATING SYSTEMS]: Security and Protec-
tion—Authentication

General Terms

Security

Keywords

passwords; password hashes; password cracking; honeywords;
chaﬃng; login; authentication

1.

INTRODUCTION

Passwords are a notoriously weak authentication mecha-
nism. Users frequently choose poor passwords. An adver-
sary who has stolen a ﬁle of hashed passwords can often use
brute-force search to ﬁnd a password p whose hash value
H(p) equals the hash value stored for a given user’s pass-
word, thus allowing the adversary to impersonate the user.
A recent report by Mandiant1 illustrates the signiﬁcance
of cracking hashed passwords in the current threat environ-
ment. Password cracking was instrumental, for instance,
in a recent cyberespionage campaign against the New York

1http://intelreport.mandiant.com/
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from permissions@acm.org.
CCS’13, November 4–8, 2013, Berlin, Germany.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-2477-9/13/11 ...$15.00.
http://dx.doi.org/10.1145/2508859.2516671.

Times [32]. The past year has also seen numerous high-
proﬁle thefts of ﬁles containing consumers’ passwords; the
hashed passwords of Evernote’s 50 million users were ex-
posed [20] as were those of users at Yahoo, LinkedIn, and
eHarmony, among others [19].

One approach to improving the situation is to make pass-
word hashing more complex and time-consuming. This is
the idea behind the “Password Hashing Competition.”2 This
approach can help, but also slows down the authentication
process for legitimate users, and doesn’t make successful
password cracking easier to detect.

Sometimes administrators set up fake user accounts (“hon-
eypot accounts”), so that an alarm can be raised when an
adversary who has solved for a password for such an account
by inverting a hash from a stolen password ﬁle attempts
to login. Since there is really no such legitimate user, the
adversary’s attempt is reliably detected when this occurs.
However, the adversary may be able to distinguish real user-
names from fake usernames, and thus avoid detection.

Our suggested approach may be viewed as extending this
basic idea to all users (i.e.,
including the legitimate ac-
counts), by having multiple possible passwords for each ac-
count, only one of which is genuine. The others we refer
to as “honeywords.” The attempted use of a honeyword to
log in sets oﬀ an alarm, as an adversarial attack has been
reliably detected.

This approach is not terribly deep, but it should be quite
eﬀective, as it puts the adversary at risk of being detected
with every attempted login using a password obtained by
brute-force solving a hashed password.

Consequently, honeywords can provide a very useful layer

of defense.

Some similar ideas have arisen in the literature. The clos-
est related work we’re aware of is the Kamouﬂage system
of Bojinov et al. [6]. To the best of our belief, the term
“honeyword” ﬁrst appeared in that work. Also closely re-
lated to our proposal is the anecdotally reported practice of
placing whole, bogus password ﬁles (“honeyﬁles”) on systems
and watching for submission of any password they contain
as signalling an intrusion. Finally, a patent application by
Rao [34] describes the use of per-account decoy passwords
called “failwords” used to trick an adversary into believing
he has logged into successfully, when he hasn’t. We give an
overview of related work in Section 8.

In any case, our hope is that this paper will help to en-

courage the use of honeywords.

2https://password-hashing.net/index.html

1452. TECHNICAL DESCRIPTION

We assume a computer system with n users u1, u2, . . . , un;
here ui is the username for the ith user. By “computer
system” (or just “system” for short) we mean any system that
allows a user to “log in” after she has provided a username
and a password; this includes multi-user computer systems,
web sites, smart phones, applications, etc.

We let pi denote the password for user ui. This is the
correct, legitimate, password; it is what user ui uses to log
in to the system.

In current practice, the system uses a cryptographic hash
function H and stores hashes of passwords rather than raw
passwords. That is, the system maintains a ﬁle F listing
username / password-hash pairs of the form

(ui, H(pi))

for i = 1, 2, . . . , n. On Unix systems the ﬁle F might be
/etc/passwd or /etc/shadow.

The system stores password hashes rather than raw pass-
words so that an adversary with access to F does not ﬁnd
out the passwords directly; he must invert the hash function
(compute pi from H(pi)) to ﬁnd out the password for user
ui (see Evans et al. [1] and Purdy [33]).

The computation of the hash function H may (should!)
involve the use of system-speciﬁc or user-speciﬁc parameters
(“salts”); these details don’t matter to us here. When a user
attempts to log in, the ﬁle F is checked for the presence of
the hash of the proﬀered password in the user’s entry (see
Morris and Thompson [26]).

2.1 Attack scenarios

There are many attack scenarios relating to passwords,

including the following six:

• Stolen ﬁles of password hashes: An adversary is
somehow able to steal the ﬁle of password hashes, and
solve for many passwords using oﬄine brute-force com-
putation. He may more generally be able to steal the
password hash ﬁles on many systems, or on one system
at various times.

• Easily guessable passwords: A substantial fraction
of users choose passwords so poorly that an adversary
can successfully impersonate at least some users of a
system by attempting logins with common passwords.
(See Bonneau [7, 8].) Schecter et al. [37] suggest ad-
dressing this threat by requiring users to use uncom-
mon passwords.

• Visible passwords: A user’s password is compro-
mised when an adversary views it being entered (shoulder-
surﬁng), or an adversary sees it on a yellow stickie on
a monitor. A one-time password generator 3 such as
RSA’s SecurID token provides good protection against
this threat.

• Same password for many systems or services:
A user may use the same password on many systems,
so that if his password is broken on one system, it is
also thereby broken on others.

3http://en.wikipedia.org/wiki/One-time_password

• Passwords stolen from users: An adversary may
learn user passwords by compromising endpoint de-
vices, such as phones or laptops, using malware or by
perpetrating phishing attacks against users.

• Password change compromised: The mechanism
for allowing users to change or recover their passwords
is defective or compromised, so an adversary can learn
a user’s password, or set it to a known value.

We focus on the ﬁrst attack scenario where an adversary
has obtained a copy of the ﬁle F of usernames and associated
hashed passwords, and has obtained the values of the salt or
other parameters required to compute the hash function H.
In this scenario, the adversary can perform a brute-force
search over short or likely passwords, hashing each one (with
salting if necessary) until the adversary determines the pass-
words for one or more users.
(See for example Weir et
al. [41].) If passwords are the only authentication mecha-
nism in place, the adversary can then log in to the accounts
of those users in a reliable and undetected manner.

In this paper, we assume that the adversary can invert

most or many of the password hashes in F .

We assume that the adversary does not compromise the
system on a persistent basis, directly observing and captur-
ing newly created passwords and honeywords. (Certainly,
the adversary risks detection the ﬁrst time he tries logging
in using a cracked password, since he may be using a honey-
word; after that, the ability of the system to detect further
attempts to login using cracked passwords may be compro-
mised if the adversary is able to modify the login routine
and its checks, or the password-change routine.)

Although our methods are directed to the ﬁrst attack sce-
nario, some of our approaches (e.g., the take-a-tail method)
also have beneﬁcial eﬀects on password strength, thus help-
ing to defeat the other attacks as well.

2.2 Honeychecker

We assume that the system may incorporate an auxiliary
secure server called the “honeychecker” to assist with the use
of honeywords.

Since we are assuming that the computer system is vul-
nerable to having the ﬁle F of password hashes stolen, one
must also assume that salts and other hashing parameters
can also be stolen. Thus, there is likely no place on the
computer system where one can safely store additional se-
cret information with which to defeat the adversary.

The honeychecker is thus a separate hardened computer
system where such secret information can be stored. We as-
sume that the computer system can communicate with the
honeychecker when a login attempt is made on the computer
system, or when a user changes her password. We assume
that this communication is over dedicated lines and/or en-
crypted and authenticated. The honeychecker should have
extensive instrumentation to detect anomalies of various sorts.

We also assume that the honeychecker is capable of raising
an alarm when an irregularity is detected. The alarm signal
may be sent to an administrator or other party diﬀerent than
the computer system itself.

Depending on the policy chosen, the honeychecker may
or may not reply to the computer system when a login is
attempted. When it detects that something is amiss with the
login attempt, it could signal to the computer system that
login should be denied. On the other hand it may merely

146signal a “silent alarm” to an administrator, and let the login
on the computer system proceed. In the latter case, we could
perhaps call the honeychecker a “login monitor” rather than
a “honeychecker.”

Our honeychecker maintains a single database value c(i)
for each user ui; the values are small integers in the range 1
to k, for some small integer parameter k (e.g. k = 20). The
honeychecker accepts commands of exactly two types:

• Set: i, j

Sets c(i) to have value j.

• Check: i, j

Checks that c(i) = j. May return result of check to
requesting computer system. May raise an alarm if
check fails.

Key security and design principles. The computer sys-
tem and honeychecker together provide a basic form of dis-
tributed security. A distributed security system aims to
protect secrets even when an adversary compromises some
of its systems or software. Diversifying the resources in
the system—for example, placing the computer system and
honeychecker in separate administrative domains or run-
ning their software on diﬀerent operating systems—makes
it harder to compromise the system as a whole.

We have designed the protocol so that compromise of the
honeychecker database by itself does not allow an adversary
to impersonate a user. In fact, the honeychecker only stores
randomly selected integers (the index c(i) for each ui).

Indeed, one of our design principles is that compromise
(i.e. disclosure) of the honeychecker database at worst only
reduces security to the level it was at before the introduction
of honeywords and the honeychecker. Disclosure of the ﬁle F
then means that an adversary will now no longer be fooled by
the honeywords; he will just need to crack the users’ actual
passwords, since he now knows which hash values are for
real passwords, and which hash values are for honeywords.
We also design the honeychecker interface to be extremely
simple, so that building a hardened honeychecker should
be realistic.
Importantly, the honeychecker need not in-
teract with the computer system.
If conﬁgured to send
“silent alarms” to administrators or trigger defenses such as
we consider in Section 2.4, it need not even provide input
to user authentication decisions. Additionally, the honey-
checker can be conﬁgured to manage a only minimal amount
of secret state. The index c(i) for each ui can, for instance,
be stored in a table that is encrypted and authenticated un-
der keys stored by the honeychecker.

As we discuss in Section 8, other distributed approaches
to password protection are possible. Distributed crypto-
graphic protocols, for instance, can entirely prevent disclo-
sure of passwords or password hashes against compromise
of the computer system. Unlike such schemes, though, hon-
eywords can be incorporated into existing password systems
with few system changes and little overhead in computation
or communication.

The honeychecker could be a product, using a standard-
ized interface. The honeychecker could serve a number of
computer systems.

2.3 Approach – Setup

This subsection describes how honeywords work, in sim-

plest form.

For each user ui, a list Wi of distinct words (called “poten-
tial passwords” or more brieﬂy, “sweetwords”) is represented:

Wi = (wi,1, wi,2, . . . , wi,k) .

Here k is a small integer, such as our recommended value of
k = 20. For simplicity we assume that k is a ﬁxed system-
wide parameter, although k could be chosen in a per-user
manner—for example, ki = 200 for the system administra-
tor(s). Values as low as k = 2 or as large as k = 1000 might
be reasonable choices in some circumstances.

Exactly one of these sweetwords wi,j is equal to the pass-
word pi known to user ui. Let c(i) denote the “correct” index
of user ui’s password in the list Wi, so that

wi,c(i) = pi.

Although we call the wi,j entries “potential passwords,”
they could be phrases or other strings; a potential password
could be a “potential passphrase” or a “sweetphrase.”

The correct password is also called the “sugarword.”
The other (k − 1) words wi,j are called “honeywords,”
The list Wi of sweetwords thus contains one sugarword

“chaﬀ,”“decoys,” or just “incorrect passwords.”

(the password) and (k − 1) honeywords (the chaﬀ).
We also allow a sweetword to be what we call a “tough
nut”—that is, a very strong password whose hash the ad-
versary is unable to invert. We represent a tough nut by the
symbol ‘ ? ’. A honeyword, or the password itself, may be
a tough nut.

The deﬁnition of the ﬁle F is changed so that it now con-

tains an extended entry for each user ui, of the form:

where

(ui, Hi) ,

vi,j = H(wi,j)

is the value of the hash of the user’s jth sweetword wi,j, and

Hi = (vi,1, vi,2, . . . , vi,k)

is the list of all these hash values.

The ﬁle F is now larger by a factor of roughly k. Given
the rapidly decreasing cost of storage this expansion should
not cause any problems on a typical computer system, even
for k as large as our recommended value of k = 20. Many
systems already store hashes of ten or more old passwords
per user to limit password reuse [17].

The user only needs (as usual) to remember her password
pi; she does not need to know the values of the honeywords
or even know about their existence.

We let Gen(k) denote the procedure used to generate
both a list Wi of length k of sweetwords for user ui and
an index c(i) of the correct password pi within Wi:

(Wi, c(i)) = Gen(k)

Here Gen is typically randomized and must involve inter-
action with the user (otherwise the user cannot create or
know the password). We may represent this user interac-
tion in some cases by allowing an additional argument in
the form of a user-supplied password pi to Gen, so that
Gen(k; pi) ensures that pi is the password in Wi; that is,
pi = wi,c(i).

The table c is maintained in a secure manner; in the pro-

posal of this paper it is stored on the honeychecker.

147Salt. Again, we omit discussion of per-system or per-user
salts or other parameters that may be included in the hash
computation. We do, however, strongly urge the use of per-
user salts.

We also recommend that hashing of wi,j now also take
j as an additional parameter. Such distinct per-sweetword
salting prevents an adversary from hashing a password guess
once (with the per-user salt) and then checking the result
simultaneously against all of the user’s hashed sweetwords.

2.4 Approach – Login

The system login routine needs to determine whether a
proﬀered password g is equal to the user’s password or not.
(Here mnemonics for g are “given” or “guess.”) If g is not
the user’s password, the login routine needs to determine
whether g is a honeyword or not.

If the user—or perhaps the adversary—has submitted the
correct password for the user, then login proceeds success-
fully as usual.

If the adversary has entered one of the user’s honeywords,
obtained for example by brute-forcing the password ﬁle F ,
then an appropriate action takes place (determined by pol-
icy), such as

• setting oﬀ an alarm or notifying a system administra-

tor,

• letting login proceed as usual,
• letting the login proceed, but on a honeypot system,
• tracing the source of the login carefully,
• turning on additional logging of the user’s activities,
• shutting down that user’s account until the user es-
tablishes a new password (e.g. by meeting with the
sysadmin),

• shutting down the computer system and requiring all

users to establish new passwords.

How does the login routine determine whether g = pi

(that is, that the given word is the password)?

If the hash H(g) of g does not occur in the ﬁle F in the
user ui’s entry Hi, then word g is neither the user’s password
nor one of the user’s honeywords, so login is denied.

Otherwise the login routine needs to determine whether g
is the user’s password, or it is merely one of the user’s hon-
eywords. The login routine can determine the index j such
that H(g) = vi,j, but the login routine doesn’t know whether
j = c(i), in which case g is indeed the password, or not, in
which case g is just a honeyword.

The table c is maintained securely in the separate secure
“honeychecker” server described in Section 2.2. The com-
puter system sends the honeychecker a message of the form:

Check: i, j

meaning: “Someone has requested to login as user ui and
has supplied sweetword j (that is, wi,j) in response to the
login password prompt. Please determine if j = c(i), and
take the appropriate action according to policy.”

The honeychecker determines whether j = c(i); if not, an
alarm is raised and other actions may be taken. The honey-
checker may then respond with a (signed) message indicat-
ing whether login should be allowed. (As mentioned above,

however, some policy choices may cause honeychecker not
respond to the computer system, but instead to permit lo-
gin and activate special monitoring and/or a honeypot.)

It may be desirable for a “Check” message to be sent to
the honeychecker, even when the proﬀered password g is not
on the list Wi of sweetwords; in this case the check message
could specify j = 0.
In this variant the honeychecker is
notiﬁed of every login attempt, and can observe when a
password guessing attack is in progress.

It might also be desirable for a “Check” message to in-
clude additional information that might be forensically use-
ful, such as the IP address of the user who attempted to log
in. We don’t pursue such ideas further here.

Many systems suspend an account if (say) ﬁve or more
unsuccessful login attempts are made. With our approach,
this limit is likely to be reached even if the adversary has
access to the sweetword list Wi: The chance that the user’s
password does not appear in the ﬁrst ﬁve elements of a ran-
dom ordering of a list Wi of length 20 containing the user’s
password is exactly 75%. However, when the system detects
failed attempts made with honeywords rather than arbitrary
non-sweetwords, it may be appropriate for a reduced limit to
trigger an account lockout and/or additional investigation.

2.5 Approach – Change of password

When user ui changes her password, or sets it up when

her account is ﬁrst initialized, the system needs to:

• use procedure Gen(k) to obtain a new list Wi of k
sweetwords, the list Hi of their hashes, and the value c(i)
of the index of the correct password pi in Wi.

• securely notify the honeychecker of the new value of c(i),

and

• update the user’s entry in the ﬁle F to (ui, Hi).
We emphasize that the honeychecker does not learn the
new password or any of the new honeywords. All it learns is
the position c(i) of the hash vi,c(i) of user ui’s new password
in the user’s list Hi in F . To accomplish this, the computer
system sends the honeychecker a message of the form:

Set: i, j

meaning: “User ui has changed or initialized her password;
the new value of c(i) is now j.” (This message should of
course be authenticated by the system to the honeychecker.)

3. SECURITY DEFINITIONS

We deﬁne the security of a honeyword generation algo-
rithm Gen, using an adversarial game, an algorithm or
thought experiment that models the capabilities of the ad-
versary.

For simplicity, we consider a honeyword generation scheme
of the form Gen(k; pi), with user input pi. (The deﬁnition
may be adapted to other forms of Gen.)

The game proceeds as follows:
• Gen(k, pi) is run, using a user-provided input consist-
ing of a proposed password pi chosen according to a
probability distribution U over passwords that meet a
speciﬁed password-composition policy.
The output of Gen(k; pi) is a listW i of sweetwords
and an index c(i) such that the password pi is in the
c(i)-th position of Wi.

148• The adversary is given Wi, with the exception that
some randomly chosen honeywords output by Gen(k; pi)
may be “tough nuts”; for those honeywords the adver-
sary only sees the symbol ? and not the underlying
(hard) honeyword.

• The adversary must now either “pass” (refuse to play
further) or else submit a guess j ∈{ 1, 2, . . . , k} for the
index c(i).

The outcome is three-way:
• The adversary “wins” the game (or “succeeds”) if he

guesses and his guess is correct (j = c(i)).

• The adversary is “caught” if he guesses but his guess

is a honeyword.

• The adversary “passes” if he doesn’t play.

Flatness. Let z denote the adversary’s expected probabil-
ity of winning the game, given that the adversary does not
pass. This probability is taken over the user’s choice of pass-
word pi, the generation procedure Gen(k; pi), and any ran-
domization used by the adversary to produce its guess j.
Observe that z ≥ 1/k, since an adversary can win with
probability 1/k merely by guessing j at random.
We say a honeyword generation method is“-ﬂat”(“epsilon-
ﬂat”) for a parameter  if the maximum value over all ad-
versaries of the adversary’s winning probability z is .

If the generation procedure is as ﬂat as possible (i.e., 1/k-
ﬂat), we say it is “perfectly ﬂat” (for a given distribution U).
If it is -ﬂat for  not much greater than 1/k, we say that it
is “approximately ﬂat.”

Our recommended value of k = 20 means that an adver-
sary who has compromised F and inverted H successfully k
times to obtain all 20 sweetwords has a chance of at most
5% of picking the correct password pi from this list, if Gen
is perfectly ﬂat. In this ideal case,  = 1/20.

Note that if honeyword-generation is -ﬂat, then an ad-
versary who plays has at least a (1 − ) chance of picking
a honeyword, being caught, and setting oﬀ an alarm. So a
method that is perfectly ﬂat ensures that an adversary who
plays has a chance of least (k − 1)/k of being caught.
In some cases, even a modest chance of catching an adver-
sary, e.g., 1−  = 1/4 (a 25% chance of detecting sweetword
guessing), would be suﬃcient to detect systemic exploita-
tion by the adversary of a compromised password ﬁle—and
perhaps even deter the adversary from attacking the sys-
tem altogether. So while a ﬂat Gen is ideal, Gen may be
eﬀective even if not ﬂat.

4. HONEYWORD GENERATION

This section proposes several ﬂat (or approximately ﬂat)
generation procedures Gen for constructing a list Wi of
sweetwords and for choosing an index c(i) of the actual pass-
word within this list.

The procedures split according to whether there is an im-
pact on the user interface (UI) for password change. (The
login procedure is always unchanged.) We distinguish the
two cases:

• With legacy-UI procedures, the password-change UI
is unchanged. This is arguably the more important

case. We propose two legacy-UI procedures: chaﬃng-
by-tweaking (which includes chaﬃng-by-tail-tweaking
and chaﬃng-by-tweaking-digits as special cases), and
chaﬃng-with-a-password-model.

• With modiﬁed-UI procedures, the password-change UI
is modiﬁed to allow for better password/honeyword
generation. We propose a modiﬁed-UI procedure called
take-a-tail. With take-a-tail, the UI change is really
very simple: the user’s new password is modiﬁed to
end with a given, randomly-chosen three-digit value.
Otherwise take-a-tail is the same as chaﬃng-by-tail-
tweaking.

We explain the legacy-UI scenario and associated methods
in Section 4.1, and the modiﬁed-UI scenario and the take-a-
tail method in Section 4.2.

Many other approaches are possible, and we consider it an
interesting problem to devise other practical methods under
various assumptions about the knowledge of the adversary
and the password-selection behavior of users.

4.1 Legacy-UI password changes

With a legacy-UI method, the password-change procedure
asks the user for the new password (and perhaps asks her
to type it again, for conﬁrmation). The UI does not tell the
user about the use of honeywords, nor interact with her to
inﬂuence her password choice.

A nice aspect of legacy-UI methods is that one can change
the honeyword generation procedure without needing to no-
tify anyone or to change the UI.

We start with a password pi supplied by user ui.
The system then generates a set of k−1 honeywords “sim-
ilar in style” to the password pi, or at least plausible as le-
gitimate passwords, so that an adversary will have diﬃculty
in identifying pi in the list Wi of all sweetwords for user ui.

• Chaﬃng: The password pi is picked, and then the
honeyword generation procedure Gen(k; pi) or “chaﬀ
procedure” generates a set of k − 1 additional distinct
honeywords (“chaﬀ”). Note that the honeywords may
depend upon the password pi. The password and the
honeywords are placed into a list Wi, in random order.
The value c(i) is set equal to the index of pi in this list.

The success of chaﬃng depends on the quality of the chaﬀ
generator; the method fails if an adversary can easily distin-
guish the password from the honeywords.

We propose two basic methods for chaﬃng (and one method

for embellishing chaﬀ). They are somewhat heuristic; the
chaﬃng approach in general oﬀers no provable guarantee
that the honeyword generation procedure Gen is ﬂat. This
particularly true if the user chooses her password in a rec-
ognizable manner.

We note (but do not discuss further) the obvious fact that
if there are syntax or other restrictions on what is allowed as
a password (see Section 6.1), then honeywords should also
satisfy the same restrictions.
4.1.1 Chafﬁng by tweaking
Our ﬁrst method is to “tweak” selected character positions
of the password to obtain the honeywords. Let t denote
the desired number of positions to tweak (such as t = 2 or
t = 3). For example, with “chaﬃng-by-tail-tweaking” the
last t positions of the password are chosen.

149The honeywords are then obtained by tweaking the char-
acters in the selected t positions: each character in a selected
position is replaced by a randomly-chosen character of the
same type: digits are replaced by digits, letters by letters,
and special characters (anything other than a letter of a
digit) by special characters.

For example, if the user-supplied password is “BG+7y45”,
then the list Wi might be (for tail-tweaking with t = 3 and
k = 4):

BG+7q03, BG+7m55, BG+7y45, BG+7o92.

We call the password-tail the“sugar”, while the honeyword

tails we call “honey” (of course).

Other tweaking patterns could also be used, such as choos-
ing the last digit position and the last special-character posi-
tion. With “chaﬃng-by-tweaking-digits” the last t positions
containing digits are chosen. (If there are less than t digits
in the password, then positions with non-digits could also
be selected as needed.) Here is an example of chaﬃng-by-
tweaking-digits for t = 2:

42*flavors, 57*flavors, 18*flavors

(1)

Chaﬃng-by-tweaking-digits is typical of the “tweaks” users
often use to derive new passwords from old ones; see Zhang
et al. [43] for extended discussion of password tweaks and a
model of tweaks used by users in practice when they change
their passwords.

The positions to be tweaked should be chosen solely on the
pattern of character types in the password, and not on the
speciﬁc characters in the password, otherwise the password
might be easily determined as the only sweetword capable
of giving rise to the given list Wi.

For chaﬃng-by-tail-tweaking we consider each word wij to
consist of a head hij followed by a t-character tail tij. For
example, “Hungry3741” has head “Hungry3” and tail “741”.
The value of t need not be the same for all users. There does
not need to be any separating character between the head
and the tail; the parsing of a password into password-head
and password-tail need not be obvious.

If the user picks the last three characters of her pass-
word randomly, then tail-tweaking is impossible to reverse-
engineer—an adversary cannot tell the password from its
tweaked versions, as all tails are random. Otherwise, an
adversary may be able to tell the password from the honey-
words: in the following list, which is the likely password?

57*flavors, 57*flavrbn, 57*flavctz

(2)

The take-a-tail method of the next section ﬁxes the prob-
lem of poorly-chosen password tails by requiring new pass-
words to have system-chosen random password tails.

Chaﬃng-by-tweaking works pretty well as a legacy-UI hon-
eyword generation method:
it doesn’t require users to fol-
low any password syntax requirements, other than having
enough characters in the password.

We now give another view of tweaking. Let T (p) denote
the class of sweetwords obtainable by tweaking p for the
selected character positions.

Clearly p is in T (p), since the randomly-chosen characters
may be the same as the originals—in general p is always in
T (p). Note that T () should have the property that tweaks
don’t change the class of a password: For any p∗ ∈ T (p),
T (p∗) = T (p). The classes T (p) form a partition of the set
of all passwords into disjoint sets of “similar” passwords.

We then deﬁne Gen to start with the singleton set {p},
and to repeatedly add elements chosen randomly from T (p)
to it until k distinct elements have been chosen. (Of course,
the class T (p) needs to contain at least k elements for this
to work.)

The list W is then just a randomly chosen ordering of the
elements in this set, and c(i) is the position of p in this list.
Tweaking is perfectly ﬂat in the case that each word in T (p)
was equally likely to be chosen as the password by the user—
that is, U(p∗) is constant for each word p∗ in T (p). In prac-
tice, users tend to favor some character strings more than
others. (For instance, it’s observed in [41] that for one-digit
numbers in passwords, users choose ‘1’ about half the time.)
So perfect ﬂatness may be diﬃcult to achieve, and it may
be helpful to bias selection of honeywords from T (p) toward
those most likely to be chosen by users.
4.1.2 Chafﬁng-with-a-password-model
Our second method generates honeywords using a proba-
bilistic model of real passwords; this model might be based
on a given list L of thousands or millions of passwords and
perhaps some other parameters. (Note that generating hon-
eywords solely from a published list L as honeywords is not
in general a good idea: such a list may also be available
to the adversary, who could use it to help identify honey-
words.) Unlike the previous chaﬃng methods, this method
does not necessarily need the password in order to generate
the honeywords, and it can generate honeywords of widely
varying strength.

Here is a list of 19 honeywords generated by one simple

model (see Appendix for details):

02123dia
forlinux
sbgo864959
aj1aob12

kebrton1
a71ger
1erapc
aiwkme523
9,50PEe]KV.0?RIOtc&L-:IJ"b+Wol<*[!NWT/pb
xyqi3tbato
#NDYRODD_!!
pizzhemix01
sveniresly
mobopy

a3915
venlorhan
dfdhusZ2
’Sb123
WORFmgthness

Note the presence of one “tough nut,” a very hard (length
40) password that the adversary will be unable to crack.

See Weir et al. [41] for a presentation of an interesting al-
ternative model for passwords, based on probabilistic context-
free grammars.
Modeling syntax. Bojinov et al. [6] propose an interest-
ing approach (based on [41]) to chaﬃng-with-a-password-
model in which honeywords are generated using the same
syntax as the password. (Note that with this method, un-
like the one above, honeywords do depend on the password.)
In their scheme, the password is parsed into a sequence of
“tokens,” each representing a distinct syntactic element—a
word, number, or set of special characters. For example, the
password

mice3blind

might be decomposed into the token sequence W4 | D1 | W5,
meaning a 4-letter word followed by a 1-digit number and
then a 5-letter word. Honeywords are then generated by
replacing tokens with randomly selected values that match

150the tokens. For example, the choice W4 ← “gold,” D1 ← ‘5",
W5 ← “rings” would yield the honeyword

gold5rings.

Replacements for word tokens are selected from a dictionary
provided as input to the generation algorithm. Further de-
tails are given in [6].
4.1.3 Chafﬁng with “tough nuts”
One might also like to have some honeywords that are
much harder to crack than the average—so much so that
they would probably never be cracked by an adversary. (These
“honeywords” might not even be passwords; these “honey-
word hashes” might just be long, e.g., 256-bit, random bit-
strings.) So, the adversary would not then (as we have been
assuming) be faced with a completely broken list of sweet-
words, but rather only a partial list. There may possibly be
some uncracked hashes (represented by ‘ ? ’ here) still to
work on, with the correct password possibly among them.
For example, what should the adversary do with the follow-
ing list?

gt79, tom@yahoo, ? , g*7rn45, rabid/30frogs!, ?

Having some “tough nuts” among the honeywords might give
the adversary additional reason to pause before diving in
and trying to log in with one of the cracked ones. “Tough
nuts” represent potentially correct passwords whose plausi-
bility the adversary cannot evaluate. Thus, in the presence
of “tough nuts,” the adversary cannot fully evaluate the like-
lihood of being detected during login, even if the adversary
has cracked all other sweetwords. To ensure that the adver-
sary cannot tell whether the password itself lies among the
set of “tough nuts,” both the positions and the number of
“tough nuts” added as honeywords should be random.

4.2 Modiﬁed-UI password changes

We now propose another method, “take-a-tail,” which uti-

lizes a modiﬁed UI for password-changes; the password-change
UI is just a slight variant of the standard one.

The take-a-tail method is identical to the chaﬃng-by-tail-
tweaking method, except that the tail of the new password
is now randomly chosen by the system, and required in the
user-entered new password.

That is, the password-change UI is changed from:

Enter a new password:

to something like:

Propose a password: • • • • • • •
Append ‘413’ to make your new password.
Enter your new password: • • • • • • • • • •

With take-a-tail the head of the password is chosen by the
user, thus increasing memorability, while the password tail is
picked randomly to ensure that the password and honeyword
generation procedure is perfectly ﬂat.

A user might try to reset her password repeatedly to ob-
tain a preferred tail, undermining the property of ﬂatness.
Most systems, however, prohibit frequent password changes
(to prevent users from cycling through passwords and thus
bypassing policies on old-password reuse).

4.3 Comparison of methods

Our proposed methods for generating honeywords have
various beneﬁts and drawbacks, as shown in Table 4.3. The
hybrid method is described in Section 5.5.

5. VARIATIONS AND EXTENSIONS

We now consider a few other ways of generating honey-

words and some practical deployment considerations.

5.1 “Random pick” honeyword generation

We now present a modiﬁed-UI procedure that is perfectly
ﬂat. At a high level, a good way of generating a password
and honeywords is to ﬁrst generate the list Wi of k distinct
sweetwords in some arbitrary manner (which may involve
interaction with the user) and then pick an element of this
list uniformly at random to be the new password; the other
elements become honeywords. As an example of user in-
volvement, we might just ask the user for k potential pass-
words. The value c(i) is set equal to the index of (randomly
chosen) password pi in this list.

For example, the user may supply k = 6 sweetwords:

4Tniners
sin(pi/2)

all41&14all
\{1,2,3\}

i8apickle
AB12:YZ90

and the system could then inform the user that password
c(i) = 6 (the last one) is her password.

The random pick method is perfectly ﬂat, no matter how
the list Wi of sweetwords was generated, since the given
procedure is equivalent to choosing c(i) uniformly at random
from {1, 2, . . . , k} independent of the actual sweetwords; there
is thus no information in Wi that can aid in determining c(i).
It is probably a bad idea, however, to ask the user for k
sweetwords. Not only is this burdensome on the user, but
the user may remember and mistakenly enter a sweetword
supplied by her and used by the system as a honeyword.

Instead, the random pick method is probably better ap-
plied to a set of k sweetwords output by an algorithmic pass-
word generator.

5.2 Typo-safety

Thus, if the user proposes “RedEye2,” his new password is
“RedEye2413.” This is a very simple change to the UI, and
shouldn’t require any user training. The required tail (“413”
in this example) is randomly and freshly generated for each
password change session.
It could even be by chance the
same as the tail of the user’s previous password. (The login
routine will normally prevent the user from trying to use
his old password as his new password; the system might
generate a new, diﬀerent tail in this case.)

Once the password has been determined, the system can
generate honeywords in same manner as chaﬃng-by-tail-
tweaking.

We would also like it to be rare for a legitimate user to
set oﬀ an alarm by accidentally entering a honeyword. Ty-
pos are one possible cause of such accidents, especially for
tweaking methods.

With tail-tweaking, it could thus be helpful if the pass-
word tail were quite diﬀerent from the honeyword tails, so
a typing error won’t turn the password into a honeyword.
(The honeyword tails should also be quite diﬀerent from each
other, so the password doesn’t stand out as the sweetword
that is the “most diﬀerent” from the others.)

One can use an error-detection code to detect typos (as for
ISBN book codes). Let q denote a small prime greater than

151Honeyword
method

Flatness

DoS

resistance

Storage
cost (#
of hashes)

Legacy Multiple-

-UI?

system

protection

Tweaking (§4.1.1)
Password-model (§4.1.2)
Tough nuts∗ (§4.1.3)
Take-a-tail (§4.2)
Hybrid (§5.5)

(§3)

(1/k) if U constant over T (p)

(1/k) if U ≈ G

N/A

(1/k) unconditionally
(1/k) if U ≈ G and
U constant over T (p)

(§7.5)
weak
strong
strong
weak
strong

(§5.4)

1
k
k
k
√k

(§4)
yes
yes
yes
no
yes

(§7.6)
no
no
no
yes
no

Table 1: Comparison of honeyword-generation methods. All methods can achieve excellent (1/k)-ﬂatness
under some conditions. By “weak” DoS (denial of service) resistance, we mean that an adversary can with
non-negligible probability submit a honeyword given knowledge of the password; by “strong” DoS resistance
we mean that such attack is improbable. Multiple-system protection is the property that compromise of the
same user’s account in diﬀerent systems will not immediately reveal pi. Finally, G denotes the probability
distribution of honeywords generated by chaﬃng-with-a-password-model. (Thus U ≈ G means that these
honeywords are distributed like user passwords in the view of the adversary.) The ∗ means “tough nuts”
are not useful on their own; they are best used together with other methods. The storage costs assume
generation of k − 1 honeywords. For further details, see the indicated sections.

10, such as q = 13. Suppose tails are three-digit numbers;
let tij denote the tail of wij. Then we just require that
the diﬀerence (tij − tij!) between any two sweetword tails
is a multiple of q. This property is easy to arrange, even
if (at most) one of the words is chosen arbitrarily by the
user. This property allows detection of a substitution of any
single digit for another, or of a transposition of two adjacent
digits, in the tail.

5.3 Managing old passwords

Many password systems, particularly for government and
industry users, store hashes of users’ old passwords—usually
the last 10, as stipulated in, e.g., [17]. When a user changes
her password, she is prohibited in such systems from reusing
any stored ones.

We feel strongly that a system should not store old pass-
words or their hashes. The motivation of this paper is that
the hashes are frequently inadequate protection for the pass-
words themselves; hash functions can be inverted on weak
passwords, and most passwords are pretty weak. Moreover,
the reason a user may have decided to change her password
is that she decided it was indeed weak, and moreover she is
using it on several systems. If the system keeps around her
old password, it may be placing her account on the other
system(s) at risk.

A better option is to not store old passwords on a per-user
basis and instead record previously used passwords across
the full user population. A newly created password that
conﬂicts with any password in this list may then be rejected.
The list should not consist of explicitly hashed passwords,
but should be represented in a more compact, eﬃciently
checkable data structure, such as a Bloom ﬁlter, that does
not reveal passwords directly [38]. The related proposal by
Schechter, Herley, and Mitzenmacher [37], which relies on
a similar data structure called a “count-min sketch,” allows
one to reject new passwords that are already in common use
within a user population.

When storing old passwords is required, however, we rec-
ommend storing them in a protected module strongly iso-
lated from the basic functionality of the computer system—

perhaps in a special server. A weaker alternative helpful
for achieving legacy compatability might reside in the com-
puter system itself. In this case, the set Oi of old passwords
for user ui should be encrypted, when not in use, under a
user-speciﬁc key κi. When the system must access Oi for a
password change, it decrypts Oi. The key κi should not, of
course, be stored in the computer system itself, but might
be stored in the honeychecker, which releases κi to the com-
puter system only after successful authentication by the user
using current password pi. After reading and updating Oi,
the computer system then re-encrypts it and immediately
erases κi.

Alternatively, of course, old passwords could themselves

be stored with honeywords.

5.4 Storage optimization

Some honeyword generation methods, such as tweaking
and take-a-tail, can be optimized to reduce their storage
to little more than a single password hash. Consider tail-
tweaking where the tails are t-digit numbers.

Suppose that T (pi) is of reasonable size—for example,
with t = 2 digit tails we have |T (pi)| = 100. Let k = |T (p)|
and let Wi = T (pi) = {wi,1, . . . , wi,k}, sorted into increasing
order lexicographically.
We select a random element wi,r of T (pi) and store H(wi,r)
on the computer system. (We pick this element by selecting
the index r ∈{ 0, 1, . . . , k−1} uniformly at random.) To ver-
ify a proﬀered password g, the computer system computes
the hash of each sweetword in T (g); if one is found equal
to H(wi,r) then wi,r is known, so Wi can be computed, as
can the position j of g in Wi. The honeychecker operates as
usual: The computer system sends j to the honeychecker to
check whether j = c(i).

We can also handle cases where k < |T (pi)|. To do so, we
restrict the set of sweetwords Wi to a subset of k passwords
from T (pi). Suppose here that T (pi) is sorted into increas-
ing lexicographical order as above. Then we might choose
Wi = {wi,1, . . . , wi,k} to be a set of k consecutive elements
(with wraparound) from T (pi) that includes pi. Randomly
selecting c(i) ∈{ 1, . . . , k} and setting wi,c(i) = pi yields such

152a set Wi with pi in a random position. In this case the com-
puter system should store both wi,1 and the index of wi,1 in
the list T (pi), so it knows exactly what the relevant segment
of T (pi) is.

5.5 Hybrid generation methods

It is possible to combine the beneﬁts of diﬀerent honey-
word generation strategies by composing them into a “hy-
brid” scheme.

As an example, we show how to construct a hybrid legacy-
UI scheme that combines chaﬃng-by-tweaking-digits with
chaﬃng-with-a-password-model. We assume a password-
composition policy that requires at least one digit, so that
tweaking digits is always possible.
Here is a simple hybrid scheme:

1. Use chaﬃng-with-a-password-model on user-supplied pass-

word p to generate a set of a (≥ 2) seed sweetwords W ",
one of which is the password. Some seeds may be
“tough nuts.”

2. Apply chaﬃng-by-tweaking-digits to each seed sweet-
word in W " to generate b (≥ 2) tweaks (including the
seed sweetword itself). This yields a full set W of
k = a × b sweetwords.

3. Randomly permute W . Let c(i) be the index of p such

that p = wc(i), as usual.

Note the importance of the ordering of steps 1 and 2.
The alternative approach of tweaking ﬁrst and then chaﬃng-
with-a-password-model would likely reveal p to an adversary
as the sole tweaked password.

As an example, suppose we have a = 3, b = 4, and k = 12.

The list Wi might look as follows:

abacad513
abacad941
abacad004
abacad752

snurfle672
snurfle806
snurfle772
snurfle091

zinja750
zinja802
zinja116
zinja649

A convenient choice of parameters is a = b = √k. We
assume this choice in describing the properties of the hybrid
scheme; concretely, a = b = 10 is a possible choice, given
that T (p) ≥ 10.
To detect a DoS (denial of service) attack against this
scheme (see Section 7.5) we might disregard submission of
honeywords in T (p), and raise an alarm for all other k − b
honeywords. DoS attacks, then, are very unlikely to succeed.
An adversary that has stolen F and guesses a honeyword,
though, will still be caught with probability 1 − 1/a = 1 −
1/√k. (For a = b = 10, this is 90%.)
The storage costs can be optimized along the lines of Sec-

tion 5.4 if desired, storing only a hashes.

Table 4.3 illustrates how this hybrid honeyword scheme in-
herits desirable characteristics from both component meth-
ods. Note that the scheme is ﬂat only if both ﬂatness con-
ditions given in the table hold. But if either condition is
met, the scheme is still reasonably secure: it is -secure for
 = 1/ min (a, b) = 1/√k. (For a = b = 10, an adversary is
caught with 90% probability.)

Because the hybrid method is legacy-UI, achieves excel-
lent ﬂatness under reasonable assumptions, and provides re-
sistance to DoS attacks, it is our recommended honeyword
generation method.

6. POLICY CHOICES
6.1 Password Eligibility

Some words may be ineligible as passwords because they

violate one or more policies regarding eligibility, such as:

• Password syntax: A password may be required to
have a minimum length, a minimum number of let-
ters, a minimum number of digits, and a minimum
number of special characters. The initial character
may be restricted. See [25] for an example of a com-
mon password-syntax (or “password complexity”) pol-
icy. Cheswick [13] calls such rules “eye-of-newt” rules,
because they are promulgated as if they had magical
properties. We agree that today such rules seem to be
more trouble than they are worth.

• Dictionary words: A password may not be a word

in the dictionary, or a simple variant thereof.

• Password re-use: A password may be required to be
diﬀerent than any of the last r passwords of the same
user, for some policy parameter r (e.g. r=10).

• Most common passwords: A password may not be
chosen if it appears on a list of the 500 most common
passwords in widespread use (to prevent online guess-
ing attacks).

• Popular passwords: A password may not be chosen
if m or more other users in a large population of users
are currently using this password.

6.2 Failover

The computer system can be designed to have a “failover”
mode so that logins can proceed more-or-less as usual even
if the honeychecker has failed or become unreachable.
In
failover mode, honeywords are temporarily promoted to be-
come acceptable passwords; this prevents denial-of-service
attacks resulting from attack on the honeychecker or the
communications between the system and the honeychecker.
The cost in terms of increased password guessability is small.
Temporary communication failures can be addressed by buﬀer-
ing messages on the computer system for later delivery to
and processing by the honeychecker.

6.3 Per-user policies

We can have policies that vary per-user; this is not un-

common already.

• Honeypot accounts: The use of honeypot accounts,
as mentioned in the introduction,
is a useful addi-
tion to honeywords. Such accounts can help iden-
tify theft of F and distinguish over a DoS attack (see
Section 7.5). Which accounts are honeypot accounts
would be known only to the honeychecker.

• Selective alarms:

It may be helpful raise an alarm
if there are honeyword hits against administrator ac-
counts or other particularly sensitive accounts, even
at the risk of extra sensitivity to DoS attacks. Policies
needn’t (and perhaps shouldn’t) be uniform across a
user population.

1536.4 Per-sweetword policies

The “Set: i, j” command to the honeychecker could have
an optional third argument ai,j, which says what action to
take if a “Check: i, j” command is later issued. The actions
might be of the form “Raise silent alarm,”“Allow login,”“Al-
low for single login only,” etc... There could be k diﬀerent
entries for a given user, with potentially k diﬀerent policies,
one per sweetword. This feature could be used, for example,
with the take-a-tail strategy to note which honeywords have
small edit distance to the password (e.g., a single transposi-
tion or change of character), so that user typos invoke a less
severe reaction. This gives added ﬂexibility to the policies
enabled by the use of the honeychecker.

7. ATTACKS

This section reviews more carefully various attacks possi-

ble against the methods proposed here.

7.1 General password guessing

Legacy-UI methods don’t aﬀect how users choose pass-
words, so they have no beneﬁcial eﬀect against adversaries
who try common passwords in an online guessing attack.

We do favor methods such as those proposed by Schecter

et al. [37] requiring users to choose uncommon passwords.

Modiﬁed-UI methods like take-a-tail also aﬀect the choice
of password—appending a three-digit random tail to a user-
chosen password eﬀectively reduces the probability of the
password by a factor of 1000.

7.2 Targeted password guessing

Personal information about a user could help an adversary
distinguish the user’s password from her honeywords. It is
often feasible to deanonymize users, that is, ascertain their
real-world identities, based on their social network graphs
[27] or just their usernames [31]. Given a user’s identity,
there are then many ways to ﬁnd demographic or biograph-
ical data about her online—by exploiting information pub-
lished on social networks, for example [5].

Knowing a user’s basic demographic information, speciﬁ-
cally his/her gender, age, or nationality, is known to enable
slightly more eﬀective cracking of the user’s hashed pass-
word [7, 8]. Similarly, attackers often successfully exploit
biographical knowledge to guess answers to personal ques-
tions in password recovery systems and compromise victims’
accounts [36]. (The hacking of Governor Sarah Palin’s Ya-
hoo! account is a well known example.) As chaﬃng-with-a-
password-model creates honeywords independently of user’s
password, this method of honeyword generation may enable
adversaries to target data-mining attacks against users and
gain some advantage in distinguishing their passwords from
their honeywords.

7.3 Attacking the Honeychecker

The adversary may decide to attack the honeychecker or

its communications with the computer system.

The updates (“Set” commands) sent to the honeychecker
need to be authenticated, so that the honeychecker doesn’t
incorrectly update its database.

The requests (“Check” commands) sent to the honey-
checker also need to be authenticated, so that the adversary
cannot query the honeychecker so as to cause an alarm to
be raised.

The replies from the honeychecker should be authenti-
cated, so that the computer system doesn’t improperly allow
the adversary to login.

By disabling communications between the computer sys-
tem and the honeychecker, the adversary can cause a failover
(see Section 6.2. The computer system then either has to
disallow login or take the risk of temporarily allowing lo-
gin based on a honeyword and buﬀering messages for later
processing by the honeychecker.

While our intention is that the honeychecker should be
hardened and of minimalist design, the deployment of the
computer system and the honeychecker as two distinct sys-
tems itself brings the usual beneﬁts of separation of duties in
enhancing security. The two systems may be placed in diﬀer-
ent administrative domains, run diﬀerent operating systems,
and so forth.

7.4 Likelihood Attack

If the adversary has stolen F and wishes to maximize his
chance of picking pi from Wi, he can proceed with a “likeli-
hood attack” as follows.

We assume here that we are dealing with an approach
based on generating honeywords using a probabilistic model.
Let G(x) denote the probability that the honeyword gener-
ator generates the honeyword x.

Similarly, let U(x) denote the probability that the user
picks x to be her password. (This may not be mathemati-
cally well-deﬁned; it can be interpreted as a Bayesian prior
for the adversary on such probabilities, and may or may not
be user-speciﬁc.)

Let Wi = {wi,1, . . . , wi,k}. The likelihood that c(i) = j,

given Wi, is equal to

U(wi,j) !

G(wi,j! ) = C R(wij)

j!#=j

where

and where

C = !

G(wi,j! )

j!

R(x) = U(x)/G(x)

is the relative likelihood that the user picks x compared to
the honeyword generator picking x. Note that it is desirable
that for all eligible x, G(x) > 0 (that is, the honeyword gen-
erator is capable of generating all possible words); otherwise
the password may be recognizable as one the honeyword
generator could not possibly have produced.

The adversary wants to maximize his likelihood of picking
the password, so he will pick the one maximizing R(wij).
This is the password that is maximally more likely to be
picked by the user than to be generated by the honeyword
generator. As an example, a password like

NewtonSaid:F=ma

is not very likely to be generated by a honeyword genera-
tor, but is plausibly generated by a (physics-knowledgeable)
user. An adversary might easily notice this password in a
set of honeywords.

In this context, a user might be well advised either to
(a) choose a very strong password that the adversary will
never crack, or (b) choose a password of the sort that the
honeyword generator might generate. That is, don’t pick a

154password that has “obvious structure” to a human of a sort
that an automatic generator might not use. Alternatively,
a generator might take as input a private, handcrafted list
of such distinctive passwords for (one-time) use as honey-
words; “obvious structure,” then, wouldn’t always signal a
true password to an adversary.

The above theory about relative likelihood is incomplete:
it doesn’t tell an adversary what to do when only some of
the sweetword hashes are solved, as happens when “tough
nuts” are used.

7.5 Denial-of-service

We brieﬂy discuss denial-of-service (DoS) attacks—a po-
tential problem for methods such as chaﬃng-by-tweaking
that generate honeywords by predictably modifying user-
supplied passwords. (In contrast, chaﬃng-with-a-password-
model as well as the hybrid scheme of Section 5.5 oﬀer strong
DoS resistance.)

The concern is that an adversary who has not compro-
mised the password ﬁle F , but who nonetheless knows a
user’s password—e.g., a malicious user or an adversary mount-
ing phishing attacks—can feasibly submit one of the user’s
honeywords. For example, with chaﬃng-by-tweaking-digits,
with t = 2, such an adversary can guess a valid honeyword
with probability (k − 1)/99. A false appearance of theft of
the password ﬁle F results.
An overly sensitive system can turn such honeyword hits
into a DoS vulnerability. One (drastic) example is a policy
that forces a global password reset in response to a single
honeyword hit. Conversely, in a system inadequately sensi-
tive to DoS attacks, an adversary that has stolen F can guess
passwords while simulating a DoS attack to avoid trigger-
ing a strong response. A policy of appropriately calibrated
response is important and can reduce DoS attacks’ potency.
Mitigating DoS attacks. To limit the impact of a DoS at-
tacks against chaﬃng-by-tweaking, one possible approach
is to select a relatively small set of honeywords randomly
from a larger class of possible sweetwords. For example, we
might use take-a-tail with a three-digit tail (t = 3), yielding
|T (pi)| = 1000. Setting k = 20, then, means randomly pick-
ing k− 1 = 19 honeywords from T (pi). Knowing the correct
password pi only gives an adversary (or malicious user) a
chance of (k− 1)/1000 ≈ 0.02 of hitting a honeyword in this
case, greatly reducing her ability to trigger an alarm. The
vast majority (≈ 98%) of her attempts will be passwords in
T (pi), but not in Wi.
7.6 Multiple systems

As users commonly employ the same password across dif-
ferent systems, an adversary might seek an advantage in
password guessing by attacking two distinct systems, sys-
tem A and system B—or multiple systems, for that matter.
We consider two such forms of attack, an “intersection” at-
tack and a “sweetword-submission” attack.
Intersection attack. If a user has the same password but
distinct sets of honeywords on systems A and B, then an ad-
versary that compromises the two password ﬁles learns the
user’s password from their intersection. (Of course, with-
out honeywords, an attacker learns the password by com-
promising either system.) We would aim instead that an
intersection attack against systems using honeywords oﬀer

an adversary no advantage in identifying the password on
either system.

Our favored approach, in the case where management of
multiple systems is of concern, would be the take-a-tail gen-
eration approach of Section 4.2 on each system. Although
the compromise of the password-hash ﬁle F would reveal
the password-head to an adversary, the user’s sugar would
be independently and randomly generated on each system.
A signiﬁcant advantage for system-chosen tails is that it
becomes very likely that the user’s password will be diﬀer-
ent on diﬀerent systems, even if the user chooses the same
password-head. This should increase overall security, as
users will generally no longer use the exact same password
on each system. The burden on memory is increased, but in
our judgment this increase is well worth the cost—too many
systems are compromised by having user passwords cracked
on other systems.

Note that this ability to ensure that a user has diﬀerent
passwords on diﬀerent systems is achieved without coordi-
nation between the systems: It is a statistical guarantee.
An adversary who discovers a user’s password on system A
may still be detected trying to log in with a honeyword on
system B.

The deﬁnition of ﬂatness for a generation procedure Gen
can be extended to handle this case: An adversary gets the
outputs (Wi, c(i)) from multiple invocations of Gen, and
then has to guess c(i) for an additional, last invocation of
Gen in which the adversary sees Wi (but not c(i)). Even
with this additional information, the adversary’s chance of
guessing c(i) should be at most 1/k.

The take-a-tail method also protects users against an ad-
versary who monitors changes in the password-hash ﬁle F
over time. (In contrast, chaﬃng-with-a-password-model does
not help much if the password is changed only slightly, but
entirely new chaﬀ is chosen.)

We note too that if system A and B make use of the
same tweaking method, they will automatically generate
identical sweetwords for a given password. For example, if
both systems employ chaﬃng-by-tweaking-digits with t = 1
digit, they will both output the same ten tweaks (includ-
ing the original password) as sweetwords. Under a suitable
parameterization, our recommended hybrid scheme, which
includes tweaking, may generate partially intersecting hon-
eyword sets across systems.

Emerging laws in the United States, such as the Cyber In-
telligence Sharing and Protection Act (CISPA)[28], encour-
age the exchange of cybersecurity intelligence across organi-
zations. Honeyword generation methods might be shared in
this context to help prevent intersection attacks.
Sweetword-submission attack. It is possible, as above,
that the user has the same password on systems A and B,
but distinct corresponding sets of honeywords; alternatively,
system B may not use honeywords at all. In either case, an
adversary that compromises the password ﬁle on system A
can submit the user’s sweetwords as password guesses to
system B without special risk of detection: To system B,
system A’s honeywords will be indistinguishable from any
other incorrect passwords. We refer to this as a “sweetword-
submission” attack.

If system B uses honeywords, then, the same counter-
measures to intersection attacks—particularly take-a-tail—
can also provide resistance to sweetword-submission attacks.

155Even if system B doesn’t use honeywords, though, it still
beneﬁts somewhat from the presence of honeywords on sys-
tem A in a sweetword-submission attack: The adversary will
have to submit more than k/2 sweetwords on average before
successfully guessing the password (assuming system A uses
a ﬂat Gen).

If the adversary compromises a system B that doesn’t use
honeywords, he can of course learn the user’s password and
impersonate her on system A, even if system A does in fact
use honeywords.

8. RELATED WORK

Password strength. The current, state-of-the-art heuris-
tic password cracking algorithm, due to Weir et al. is based
on probabilistic, context-free grammars [41].
In a recent
study, Kelley et al. [23] characterize the vulnerability of user-
generated passwords to Weir-style cracking attacks under
various password-composition policies. One such policy is
a common, weak one dubbed “basic8,” in which users are
instructed, “Password must have at least 8 characters.” One
billion guesses suﬃce to crack 40.3% of such passwords. Re-
cent work shows that cracking speeds for some hash func-
tions (e.g., MD5) can approach three-billion guesses per sec-
ond on a single graphical-processing unit (GPU); see, e.g.,
Table 15 of [3]. Also in recent work, Bonneau develops a
framework to assess the strength of passwords (and other
user secrets). Based on study of published password cor-
pora, including one for 70 million Yahoo! users, he estimates
that a majority of passwords have little more than 20 bits
of eﬀective entropy against an optimal attacker [7, 8].

Together, these results underscore the weakness of current
password protections even with the use of sound practices,
such as salting. There is good reason to believe that many
systems don’t even make use of salt [29]. While the reason
for this lapse is unclear, we emphasize that honeywords may
be used with or without salt (and even in principle with or
without hashing).

Bonneau and Preibusch [9] oﬀer an excellent survey of cur-
rent password management practices on popular web sites,
including password composition requirements and advice to
users, account lockout policies, and update and recovery
procedures. Herley and van Oorschot [21] argue that use
of passwords will persist for many years, and highlight key
research questions on how to create strong passwords and
manage them eﬀectively.
Password strengthening. The take-a-tail method may
be viewed as a variant on previously proposed password
strengthening schemes. Forget et al. [18], randomly inter-
leave system-generated characters into a password. The user
may request a reshuﬄing of these characters until she ob-
tains a password she regards as memorable. The extra char-
acters here are essentially sugar. (Rejected or unpresented
interleavings could serve as honeywords.) Houshmand and
Aggarwal [22] propose a related system that applies small
tweaks to user-supplied passwords to preserve memorability
while adding strength against cracking, speciﬁcally via [41].
Various proposed schemes, e.g., PwdHash [35], also aim to
strengthen passwords within password managers.
Password storage and veriﬁcation. There are stronger
approaches than honeywords for splitting password-related
secrets across servers. Some proposed and commercialized

methods employ distributed cryptography to conceal pass-
words fully in the event of a server breach [11, 12, 15]. While
such methods are perferrable to honeywords where practi-
cal, they require substantial changes to password veriﬁcation
systems and, ideally, client-side support as well. Honey-
words may be seen as a stepping stone to such approaches.
Password-authenticated key-exchange methods, such as
the Secure Remote Password Protocol (SRP)4, provide an-
other approach towards verifying that a remote party knows
a correct password. However, the remote party must have
a trusted computer to perform the necessary mathematical
operations. If successful, both parties end up with the same
secret key, which they may use to encrypt and/or authenti-
cate further communications.
Decoys. The use of decoy resources to detect security
breaches is an age-old practice in the intelligence commu-
nity. Similarly, honeypots are a stock-in-trade of computer
security. A survey of the use of honeypots and related decoys
and of pertinent history and theory may be found in [14].
It is a common industry practice today to deploy “honeyto-
kens,” bogus credentials such as credit card numbers [39], to
detect information leakage and degrade the value of stolen
credentials. (Honeywords could likewise reduce the value of
stolen passwords.) Similarly, fabricated or decoy ﬁles have
been proposed as traps to detect intrusion [42] and insider
attacks [10].

Honeywords also bear some resemblance to duress codes,
plausible-looking but invalid secrets that users may submit
to trigger a silent alarm.5 A related idea are “collisionful”
hash functions [2, 4]; these yield hash values with multiple,
feasibly computed pre-images, thus creating ambiguity as to
which pre-image is correct.

Most closely related to our proposed use of honeywords
is the Kamouﬂage system of Bojinov et al. [6]. The setting
in that work diﬀers from ours, though. Kamouﬂage aims to
protect a user’s list of passwords in a client-side password
manager against misuse should the user’s device (e.g., lap-
top or tablet) be stolen or otherwise compromised. Kamou-
ﬂage conceals the correct password list within a set of decoy
lists, which contain honeywords created using the scheme de-
scribed in Section 4.1.2. Password-consuming servers need
not be aware of Kamouﬂage deployment. (The authors do
note, though, that servers might store some honeywords to
facilitate detection of compromise.)

9. OPEN PROBLEMS

This paper is just an initial stab at the issues surrounding
the use of honeywords to protect password hash ﬁles; many
open questions remain, such as:

• How can a honeyword system best be designed to with-
stand active attacks, e.g., malicious messages issued by
a compromised computer system or code modiﬁcation
of the computer system (or the honeychecker)?

• Can a honeyword system be designed to protect at all
against persistent attacks, in which an adversary ob-
serves passwords submitted to the computer system?

• How well can targeted attacks help identify users’ pass-
words for particular honeyword-generation methods?

4http://en.wikipedia.org/wiki/Secure_Remote_Password_protocol
5http://en.wikipedia.org/wiki/Duress_code

156• Can the password models underlying cracking algo-
rithms (e.g., [41]) be easily adapted for use in chaﬃng-
with-a-password-model?

• Are there good experimental methods for quantifying

the ﬂatness of honeyword-generation methods?

• How should an adversary act optimally when some

“tough nuts” are included among the honeywords?

• What is the best way to enforce password-reuse poli-

cies?

• How user-friendly in practice is take-a-tail?

10. DISCUSSION AND CONCLUSION

Someone who has stolen a password ﬁle can brute-force to

search for passwords, even if honeywords are used.

However, the big diﬀerence when honeywords are used is
that a successful brute-force password break does not give
the adversary conﬁdence that he can log in successfully with-
out detection.

The use of an honeychecker thus forces an adversary to
either risk logging in with a large chance of causing the
detection of the compromise of the password-hash ﬁle F ,
or else to attempt compromising the honeychecker as well.
Since the honeychecker’s interface is extremely simple, one
can more readily secure the honeychecker.

The use of honeywords may be very helpful in the current
environment, and is easy to implement. The fact that it
works for every user account is its big advantage over the
related technique of honeypot accounts.

One could imagine other uses of an auxiliary server to
support of password-based authentication. However, the ar-
chitecture proposed here is clean and simple, reverts to cur-
rent practice if auxiliary server ﬁles are compromised, and
is even robust against auxiliary server failure (if one allows
logins with honeywords).

Honeywords also provide another beneﬁt. Published pass-
word ﬁles (e.g., one stolen from LinkedIn [30]) provide at-
tackers with insight into how users compose their passwords.
Attackers can then reﬁne their models of user password se-
lection and design faster password cracking algorithms [23].
Thus every breach of a password server has the potential to
improve future attacks. Some honeyword generation strate-
gies, particularly chaﬃng ones, obscure actual user password
choices, and thus complicate model building for would-be
hash crackers.
It may even be useful to muddy attack-
ers’ knowledge of users’ composition choices intentionally
by drawing some honeywords from slightly perturbed prob-
ability distributions.

Despite their beneﬁts over common methods for password
management, honeywords aren’t a wholly satisfactory ap-
proach to user authentication. They inherit many of the well
known drawbacks of passwords and something-you-know au-
thentication more generally. Eventually, passwords should
be supplemented with stronger and more convenient authen-
tication methods, e.g., [16], or give way to better authentica-
tion methods completely, as recently predicted by the media
[24, 40].

In the meantime, honeywords are a simple-to-deploy and
powerful new line of defense for existing password systems.
We hope that the security community will beneﬁt from their
use. (See our note below on IP.) Additional materials may

be found on the Honeyword Project webpage at
http://people.csail.mit.edu/rivest/honeywords.

Acknowledgments

The second author thanks Andrew and Erna Viterbi for
their support. The authors also thank Ben Adida, Sudhir
Aggarwal, Ross Anderson, Mihir Bellare, Jeremiah Blocki,
Dan Boneh, Joe Bonneau, Bill Cheswick, Burt Kaliski, Sil-
vio Micali, Mike Mitzenmacher, Benny Pinkas, Raluca Ada
Popa, Tom Ristenpart, Phil Rogaway, Tomas Sander, Stu-
art Schechter, Bruce Schneier, Eugene Spaﬀord, Matt Weir,
Nickolai Zeldovich, Yinqian Zhang, and their colleagues in
RSA Labs for numerous helpful comments and suggestions
regarding this paper.

Note on Intellectual Property (IP)

We do not know of any patent or other restrictions on the
use of the ideas proposed here. We have not ﬁled for any
such patents (and will not). The authors place into the
public domain any and all rights they have on the use of the
ideas, methods or systems proposed here. As far as we are
concerned, others may freely make, use, sell, oﬀer for sale,
import, embed, modify, or improve the ideas, methods, or
systems described in this paper. There is no need to contact
us or ask our permission in order to do so. We ask only that
this paper be cited as appropriate.

11. REFERENCES

[1] A. Evans, Jr., W. Kantrowitz, and E. Weiss. A user

authentication scheme not requiring secrecy in the
computer. Commun. ACM, 17(8):437–442, August
1974.

[2] R. J. Anderson and T.M.A. Lomas. On fortifying key

negotiation schemes with poorly chosen passwords.
Electronics Letters, 30(13):1040–1041, 1994.

[3] M. Bakker and R. van der Jagt. GPU-based password
cracking. Technical report, Univ. of Amsterdam, 2010.

[4] T. A. Berson, L. Gong, and T.M.A. Lomas. Secure,

keyed, and collisionful hash functions. Technical
Report SRI-CSL-94-08, SRI International Laboratory,
1993 (revised 2 Sept. 1994).

[5] L. Bilge, T. Strufe, D. Balzarotti, and E. Kirda. All
your contacts are belong to us: automated identity
theft attacks on social networks. In WWW, pages
551–560, 2009.

[6] H. Bojinov, E. Bursztein, X. Boyen, and D. Boneh.

Kamouﬂage: loss-resistant password management. In
ESORICS, pages 286–302, 2010.

[7] J. Bonneau. Guessing human-chosen secrets. PhD

thesis, University of Cambridge, May 2012.

[8] J. Bonneau. The science of guessing: analyzing an

anonymized corpus of 70 million passwords. In IEEE
Symposium on Security and Privacy, pages 538–552,
2012.

[9] J. Bonneau and S. Preibusch. The password thicket:

technical and market failures in human authentication
on the web. In Workshop on the Economics of
Information Security (WEIS), 2010.

[10] B. M. Bowen, S. Hershkop, A. D. Keromytis, and S. J.

Stolfo. Baiting inside attackers using decoy
documents. In SecureComm, pages 51–70, 2009.

157[11] J. Brainard, A. Juels, B. Kaliski, and M. Szydlo. A

[29] B.-A. Parnell. LinkedIn admits site hack, adds pinch

new two-server approach for authentication with short
secrets. In USENIX Security, pages 201–214, 2003.

of salt to passwords. The Register, 7 June 2012.

[30] I. Paul. Update: LinkedIn conﬁrms account passwords

[12] J. Camenisch, A. Lysyanskaya, and G. Neven.

hacked. PC World, 6 June 2012.

Practical yet universally composable two-server
password-authenticated secret sharing. In ACM CCS,
pages 525–536, 2012.

[13] William Cheswick. Rethinking passwords. Comm.

ACM, 56(2):40–44, Feb. 2013.

[14] F. Cohen. The use of deception techniques: Honeypots

and decoys. In H. Bidgoli, editor, Handbook of
Information Security, volume 3, pages 646–655. Wiley
and Sons, 2006.

[15] EMC Corp. RSA Distributed Credential Protection.

http://www.emc.com/security/rsa-distributed-
credential-protection.htm,
2013.

[16] A. Czeskis, M. Dietz, T. Kohno, D. Wallach, and

D. Balfanz. Strengthening user authentication through
opportunistic cryptographic identity assertions. In
ACM CCS, pages 404–414, 2012.

[17] Defense Information Systems Agency (DISA) for the
Department of Defense (DoD). Application security
and development: Security technical implementation
guide (STIG), version 3 release 4, 28 October 2011.

[18] A. Forget, S. Chiasson, P. C. van Oorschot, and

R. Biddle. Improving text passwords through
persuasion. In SOUPS, pages 1–12, 2008.

[19] C. Gaylord. LinkedIn, Last.fm, now Yahoo? don’t

ignore news of a password breach. Christian Science
Monitor, 13 July 2012.

[20] D. Gross. 50 million compromised in Evernote hack.

CNN, 4 March 2013.

[21] C. Herley and P. Van Oorschot. A research agenda
acknowledging the persistence of passwords. IEEE
Security & Privacy, 10(1):28–36, 2012.

[22] S. Houshmand and S. Aggarwal. Building better

passwords using probabilistic techniques. In ACSAC,
pages 109–118, 2012.

[23] P.G. Kelley, S. Komanduri, M.L. Mazurek, R. Shay,

T. Vidas, L. Bauer, N. Christin, L.F. Cranor, and
J. Lopez. Guess again (and again and again):
Measuring password strength by simulating
password-cracking algorithms. In IEEE Symposium on
Security and Privacy (SP), pages 523–537, 2012.

[24] O. Kharif. Innovator: Ramesh Kesanupalli’s biometric
passwords stored on devices. Bloomberg Businessweek,
28 March 2013.

[25] Microsoft TechNet Library. Password must meet

complexity requirements. Referenced March 2012 at
http://bit.ly/YAsGiZ.

[26] R. Morris and K. Thompson. Password security: a

case history. Commun. ACM, 22(11):594–597,
November 1979.

[27] A. Narayanan and V. Shmatikov. De-anonymizing

social networks. In IEEE Symposium on Security and
Privacy (SP), pages 173–187, 2009.

[28] U.S. House of Representatives. H.R. 624: The Cyber

Intelligence Sharing and Protection Act of 2013. 113th
Cong., 2013.

[31] D. Perito, C. Castelluccia, M. A. Kaafar, and

P. Manils. How unique and traceable are usernames?
In Privacy Enhancing Technologies, pages 1–17, 2011.
[32] N. Perlroth. Hackers in China attacked The Times for
last 4 months. New York Times, page A1, 31 January
2013.

[33] G. B. Purdy. A high security log-in procedure.
Commun. ACM, 17(8):442–445, August 1974.

[34] Shrisha Rao. Data and system security with failwords.

U.S. Patent Application US2006/0161786A1, U.S.
Patent Oﬃce, July 20, 2006.
http://www.google.com/patents/US20060161786.

[35] B. Ross, C. Jackson, N. Miyake, D. Boneh, and J.C.

Mitchell. Stronger password authentication using
browser extensions. In USENIX Security, 2005.

[36] S. Schechter, A. J. B. Brush, and S. Egelman. It’s no

secret. measuring the security and reliability of
authentication “secret” questions. In IEEE Symposium
on Security and Privacy (SP), pages 375–390, 2009.

[37] S. Schechter, C. Herley, and M. Mitzenmacher.

Popularity is everything: a new approach to
protecting passwords from statistical-guessing attacks.
In USENIX HotSec, pages 1–8, 2010.

[38] E. Spaﬀord. Observations on reusable password

choices. In USENIX Security, 1992.

[39] L. Spitzner. Honeytokens: The other honeypot.

Symantec SecurityFocus, July 2003.

[40] T. Wadhwa. Why your next phone will include

ﬁngerprint, facial, and voice recognition. Forbes, 29
March 2013.

[41] M. Weir, S. Aggarwal, B. de Medeiros, and B. Glodek.

Password cracking using probabilistic context-free
grammars. In IEEE Symposium on Security and
Privacy (SP), pages 162–175, 2009.

[42] J. Yuill, M. Zappe, D. Denning, and F. Feer.

Honeyﬁles: deceptive ﬁles for intrusion detection. In
Information Assurance Workshop, pages 116–122,
2004.

[43] Y. Zhang, F. Monrose, and M. K. Reiter. The security

of modern password expiration: an algorithmic
framework and empirical analysis. In ACM CCS,
pages 176–186, 2010.

Appendix. Chafﬁng with a password model

This appendix describes a simple way to generate honey-
words; this method is one way to implement chaﬃng-with-
a-password-model. It is just a simple example of such a prob-
abilistic model; better models certainly exist.

This method uses a list L of sample passwords. Honey-
words are not taken from this ﬁle; rather, this list is used as
an aid to generate plausible-looking honeywords. This list
is intended to contain what look like plausible passwords
users might generate; it is not intended to be a list of “high-
strength” passwords.

Thus, this honeyword generation scheme is qualitatively
diﬀerent than the process of tweaking a password to generate
a new password: it is OK for a honeyword to be much weaker

158than the true password in an attempt to trick the adversary.
However, it should not be so weak that high-probability (i.e.
very common) passwords are generated, as this would cause
an online guessing attack to hit honeywords.
A simple model for generating a single honeyword. The
password list L is initialized to a list of many thousands of
real passwords, as well as some truly random passwords of
varying lengths.

A “tough nut” is generated with some ﬁxed probability

(e.g. 8%).

Otherwise a honeyword is generated as follows. A target
length d is ﬁrst determined by picking a random password w
from L and measuring its length.

Let the characters of the new password be denoted c1,
c2, . . . , cd. These are determined sequentially. The ﬁrst
character c1 is just the ﬁrst character w1 of w. Let w =
w1w2 . . . , wd.

To determine the jth character of c, for j = 2, 3, . . . , d:
• With probability 0.1, replace w by a randomly chosen

password in L of length t. Then let cj = wj.

• Else with probability 0.4, replace w by a randomly cho-
sen password in L of length t that has wj−1 = cj−1.
Then let cj = wj.

• Else with probability 0.5, let cj = wj.

If the honeyword c is ineligible (§6.1), then begin again to
generate c (excluding the tough-nut option this time).

159