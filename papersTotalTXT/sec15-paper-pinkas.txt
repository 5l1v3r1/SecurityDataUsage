Phasing: Private Set Intersection using 

Permutation-based Hashing

Benny Pinkas, Bar-Ilan University; Thomas Schneider, Technische Universität Darmstadt;  

Gil Segev, The Hebrew University of Jerusalem; Michael Zohner,  

Technische Universität Darmstadt

https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/pinkas

This paper is included in the Proceedings of the 24th USENIX Security SymposiumAugust 12–14, 2015 • Washington, D.C.ISBN 978-1-931971-232Open access to the Proceedings of  the 24th USENIX Security Symposium is sponsored by USENIXPhasing: Private Set Intersection using Permutation-based Hashing

Benny Pinkas

Bar-Ilan University, Israel

benny@pinkas.net

Thomas Schneider

TU Darmstadt, Germany

thomas.schneider@ec-spride.de

Gil Segev

Hebrew University, Israel

segev@cs.huji.ac.il

Michael Zohner

TU Darmstadt, Germany

michael.zohner@ec-spride.de

Abstract

Private Set Intersection (PSI) allows two parties to com-
pute the intersection of private sets while revealing noth-
ing more than the intersection itself. PSI needs to be ap-
plied to large data sets in scenarios such as measurement
of ad conversion rates, data sharing, or contact discovery.
Existing PSI protocols do not scale up well, and therefore
some applications use insecure solutions instead.

We describe a new approach for designing PSI proto-
cols based on permutation-based hashing, which enables
to reduce the length of items mapped to bins while en-
suring that no collisions occur. We denote this approach
as Phasing, for Permutation-based Hashing Set Intersec-
tion. Phasing can dramatically improve the performance
of PSI protocols whose overhead depends on the length
of the representations of input items.

We apply Phasing to design a new approach for
circuit-based PSI protocols. The resulting protocol is up
to 5 times faster than the previously best Sort-Compare-
Shufﬂe circuit of Huang et al. (NDSS 2012). We also
apply Phasing to the OT-based PSI protocol of Pinkas et
al.
(USENIX Security 2014), which is the fastest PSI
protocol to date. Together with additional improvements
that reduce the computation complexity by a logarithmic
factor, the resulting protocol improves run-time by a fac-
tor of up to 20 and can also have similar communication
overhead as the previously best PSI protocol in that re-
spect. The new protocol is only moderately less efﬁcient
than an insecure PSI protocol that is currently used by
real-world applications, and is therefore the ﬁrst secure
PSI protocol that is scalable to the demands and the con-
straints of current real-world settings.

1

Introduction

Private set intersection (PSI) allows two parties P1 and P2
with respective input sets X and Y to compute the inter-
section X ∩ Y of their sets without revealing any infor-
mation but the intersection itself. Although PSI has been

1

widely studied in the literature, many real-world applica-
tions today use an insecure hash-based protocol instead
of a secure PSI protocol, mainly because of the insufﬁ-
cient efﬁciency of current PSI protocols.

In this work we present Phasing, Permutation-based
Hashing Set Intersection, which is a new approach for
constructing PSI protocols based on a hashing technique
that ensures that hashed elements can be represented by
short strings without any collisions. The overhead of re-
cent PSI protocols depends on the length of these rep-
resentations, and this new structure of construction, to-
gether with other improvements, results in very efﬁcient
performance that is only moderately larger than that of
the insecure protocol that is in current real-world usage.

1.1 Motivating Scenarios
The motivation for this work comes from scenarios
where PSI must be applied quite frequently to large
sets of data, and therefore performance becomes critical.
Moreover, the communication overhead might be even
more important than the computation overhead, since in
large data centers it is often easier to add computing
power than to improve the outgoing communication in-
frastructure. We describe here three scenarios which re-
quire large-scale PSI implementations.

Measuring ad conversion rates Online advertising,
which is a huge business, typically measures the success
of ad campaigns by measuring the success of converting
viewers into customers. A popular way of measuring this
value is by computing the conversion rate, which is the
percentage of ad viewers who later visit the advertised
site or perform a transaction there. For banner ads or ser-
vices like Google Adwords it is easy to approximate this
value by measuring ad click-throughs. However, mea-
suring click-throughs is insufﬁcient in other online ad-
vertising settings. One such setting is mobile advertis-
ing, which is becoming a dominating part of online ad-

USENIX Association  

24th USENIX Security Symposium  515

vertising. Even though mobile ads have a great effect,
click-throughs are an insufﬁcient measure of their utility,
since it is unlikely, due to small displays and the casual
nature of mobile browsing, that a user will click on an
ad and, say, purchase a car using his mobile device. An-
other setting where click rate measurement is unsatisfac-
tory is advertising of ofﬂine goods, like groceries, where
the purchase itself is done ofﬂine.1

An alternative method of measuring ad performance is
to compare the list of people who have seen an ad with
those who have completed a transaction. These lists are
held by the advertiser (say, Google or Facebook), and by
merchants, respectively. It is often possible to identify
users on both ends, using identiﬁers such as credit card
numbers, email addresses, etc. A simple solution, which
ignores privacy, is for one side to disclose its list of cus-
tomers to the other side, which then computes the nec-
essary statistics. Another option is to run a PSI protocol
between the two parties. (The protocol should probably
be a variant of PSI, e.g. compute total revenues from
customers who have seen an ad. Such protocols can be
derived from basic PSI protocols.) In fact, Facebook is
running a service of this type with Datalogix, Epsilon
and Acxiom, companies which have transaction records
for a large part of loyalty card holders in the US. Accord-
ing to reports2, the computation is done using a variant of
the insecure naive hashing PSI protocol that we describe
in §3.1. Our results show that it can be computed using
secure protocols even for large data sets.

Security incident information sharing Security inci-
dent handlers can beneﬁt from information sharing since
it provides them with a global view during incidents.
However, incident data is often sensitive and potentially
embarrassing. The shared information might reveal in-
formation about the business of the company that pro-
vided it, or of its customers. Therefore, information is
typically shared rather sparsely and protected using legal
agreements. Automated large scale sharing will improve
security, and there is in fact work to that end, such as the
IETF Managed Incident Lightweight Exchange (MILE)
effort. Many computations that are applied to the shared
data compute the intersection and its variants. Applying
PSI to perform these computations can simplify the le-
gal issues of information sharing. Efﬁcient PSI protocols
will enable it to be run often and in large scale.

Private contact discovery When a new user registers
to a service it is often essential to identify current regis-

1See, e.g., http://www.reuters.com/article/2012/10/01/

us-facebook-ads-idUSBRE8900I120121001 .

2See, e.g., https://www.eff.org/deeplinks/2012/09/deep

-dive-facebook-and-datalogix-whats-actually-getting
-shared-and-how-you-can-opt.

2

tered users who are also contacts of the new user. This
operation can be done by simply revealing the user’s con-
tact list to the service, but can also be done in a pri-
vacy preserving manner by running a PSI protocol be-
tween the user’s contact list and the registered users of
the service. This latter approach is used by the TextSe-
cure and Secret applications, but for performance rea-
sons they use the insecure naive hashing PSI protocol
described in §3.1.3
In these cases each user has a small number of
records n2, e.g., n2 = 256, whereas the service has mil-
lions of registered users (in our experiments we use
n1 = 224).
In our
the client needs only O(n2 logn1)
best PSI protocol,
memory, O(n2) symmetric cryptographic operations and
O(n1) cheap hash table lookups, and the communication
is O(n1 logn1). (The communication overhead is indeed
high as it depends on n1, but this seems inevitable if brute
force searches are to be prevented.)

It therefore holds that n2 (cid:30) n1.

1.2 Our Contributions
Our goal in this work is to enable PSI computations for
large scale sets that were previously beyond the capabil-
ities of state-of-the-art protocols. The constructions that
we design in this work improve performance by more
than an order of magnitude. We obtain these improve-
ments by generalizing the hashing approach of [22] and
applying it to generic secure computation-based PSI pro-
tocols. We replace the hash function in [22] by a permu-
tation which enables us to reduce the bit-length of inter-
nal representations. Moreover, we suggest several im-
provements to the OT-based PSI protocol of [22]. We
explain our contributions in more detail next:

Phasing: Using permutation-based hashing to reduce
the bit-length of representations. The overhead of the
best current PSI protocol [22] is linear in the length of the
representations of items in the sets (i.e., the ids of items
in the sets). The protocol maps items into bins, and since
each bin has very few items in it, it is tempting to hash
the ids to shorter values and trust the birthday paradox
to ensure that no two items in the same bin are hashed
to the same representation. However, a closer examina-
tion shows that to ensure that the collision probability is
smaller than 2−λ , the length of the representation must
be at least λ bits, which is too long.

In this work we utilize the permutation-based hashing
techniques of [1] to reduce the bit-length of the ids of
items that are mapped to bins. These ideas were sug-
gested in an algorithmic setting to reduce memory us-

3See https://whispersystems.org/blog/contact-disco
very/ and https://medium.com/@davidbyttow/demystifying
-secret-12ab82fda29f , respectively.

516  24th USENIX Security Symposium 

USENIX Association

age, and as far as we know this is the ﬁrst time that they
are used in a cryptographic or security setting to improve
performance. Essentially, when using β bins the ﬁrst
logβ bits in an item’s hashed representation deﬁne the
bin to which the item is mapped, and the other bits are
used in a way which provably prevents collisions. This
approach reduces the bit-length of the values used in the
PSI protocol by logβ bits, and this yields reduced over-
head by up to 60%-75% for the settings we examined.

the bit-length of elements in PSI. Afterwards, we ap-
ply Phasing to generic secure computation protocols, and
present Circuit-Phasing, our new approach for circuit-
based PSI §5. Thereafter, we apply Phasing to the previ-
ously fastest OT-based PSI protocol of [22] and present
several optimizations in §6. In §7 we analyze the hashing
failure probability of Circuit- and OT-Phasing. Finally,
we provide an evaluation of our PSI protocols in §8.

Circuit-Phasing:
Improved circuit-based PSI. As
we discuss in §3.4 there is a great advantage in using
generic secure computation for computing PSI, since this
enables to easily compute variants of the basic PSI func-
tionality. Generic secure computation protocols evalu-
ate Boolean circuits computing the desired functionality.
The best known circuit for computing PSI was based on
the Sort-Compare-Shufﬂe circuit of [12]. We describe
Circuit-Phasing, a new generic protocol that uses hash-
ing (speciﬁcally, Cuckoo hashing and simple hashing)
and secure circuit evaluation.
In comparison with the
previous approach, our circuits have a smaller number
of AND gates, a lower depth of the circuit (which affects
the number of communication rounds in some protocols),
and a much smaller memory footprint. These factors lead
to a signiﬁcantly better performance.

OT-Phasing: Improved OT-based PSI. We introduce
the OT-Phasing protocol which improves the OT-based
PSI protocol of [22] as follows:

• Improved computation and memory. We reduce
the length of the strings that are processed in the
OT from O(log2 n) to O(logn), which results in a
reduction of computation and memory complexity
for the client from O(nlog2 n) to O(nlogn).

• 3-way Cuckoo hashing. We use 3 instead of 2
hash functions to generate a more densely populated
Cuckoo table and thus decrease the overall number
of bins and hence OTs.

OT-Phasing improves over state-of-the-art PSI both in
terms of run-time and communication. Compared to the
previously fastest PSI protocol of [22], our protocol im-
proves run-time by up to factor 10 in the WAN setting
and by up to factor 20 in the LAN setting. Furthermore,
our OT-Phasing protocol in some cases achieves similar
communication as [18], which was shown to achieve the
lowest communication of all PSI protocols [22].

1.3 Outline
We give preliminary information in §2 and summarize
related work in §3. In §4 we describe Phasing, our op-
timization for permutation-based hashing that reduces

2 Preliminaries

2.1 Notation
We denote the parties as P1 and P2. For all protocols we
assume that P2 obtains the output. The respective input
sets are denoted as X and Y , with sizes n1 = |X| and n2 =
|Y|. Often n1 = n2 and we use the notation n = n1 = n2.
We assume that elements are of bit-length σ.
We call the symmetric security parameter κ, the bit-
length of the elliptic curves ϕ, and the statistical security
parameter λ . Throughout the paper we assume 128-bit
security, i.e., κ = 128, ϕ = 283 (using Koblitz-curves),
and λ = 40. For symmetric encryption we use AES-128.
We refer to the concatenation of bit-strings by ||, to
the exclusive-OR (XOR) operation by ⊕, and to the i-th
element in a sequence S by S[i]. In many protocols, we
shorten the size of hash values that are sent to (cid:31) = λ +
log2(n1) +log 2(n2) instead of 2κ. This yields collision
probability 2−λ , which is suited for most applications.

2.2 Security
Two types of adversaries are typically discussed in the
secure computation literature: A semi-honest adversary
is trusted to follow the protocol, but attempts to learn as
much information as possible from the messages it re-
ceives. This adversary model is appropriate for scenar-
ios where execution of the correct software is enforced
by software attestation or where an attacker might ob-
tain the transcript of the protocol after its execution, ei-
ther by stealing it or by legally enforcing its disclosure.
In contrast, a malicious adversary can behave arbitrar-
ily. Most work on PSI was in the semi-honest setting.
Protocols that are secure against malicious adversaries,
e.g., [9, 10, 14], are considerably less efﬁcient. We focus
on optimal performance and therefore design protocols
secure against semi-honest adversaries only. Further-
more, the security of the protocols is proven in the ran-
dom oracle model, as is justiﬁed in the full version [21].

2.3 Hashing to Bins
Our protocols hash the input items to bins and then op-
erate on each bin separately.
In general, our hashing

USENIX Association  

24th USENIX Security Symposium  517

3

schemes use a table T consisting of β bins. An element e
is mapped to the table by computing an address a = H(e)
using a hash function H that is modeled as a random
function. A value related to e is then stored in bin T [a].
There is a rich literature on hashing schemes, which
differ in the methods for coping with collisions, the com-
plexity for insertion/deletion/look-up, and the utilization
of storage space.
In [9, 10, 22], hashing to bins was
used to improve the number of comparisons that are per-
formed in PSI protocols. In the following, we detail the
two most promising hashing schemes for use in PSI, ac-
cording to [22]: simple hashing and Cuckoo hashing. For
the OT-based PSI protocol of [22] it was shown that a
combination of simple hashing (for P1) and Cuckoo hash-
ing (for P2) results in the best performance.

2.3.1 Simple Hashing
Simple hashing builds the table T by mapping each ele-
ment e to bin T [H(e)] and appending e to the bin. Each
bin must, of course, be able to store more than one ele-
ment. The size of the most populated bin was analyzed
in [23], and depends on the relation between the num-
ber of bins and the total number of elements. Most im-
portantly for our application, when hashing n elements
into β = n bins, it was shown that the maximum number
of elements in a bin is lnn
lnlnn (1 + o(1)). In §7.1 we give
a theoretical and an empirical analysis of the maximum
number of elements in a bin.

2.3.2 Cuckoo Hashing
Cuckoo hashing [19] uses h hash functions H1, ...,Hh to
map an element e to a bin using either one of the h hash
functions. (Typically, h is set to be h = 2; we also use
h = 3.) In contrast to simple hashing, it allows at most
one element to be stored in a bin. If a collision occurs,
Cuckoo hashing evicts the element in the bin and per-
forms the insertion again for the evicted element. This
process is repeated until an empty bin is found for the
evicted element. If the resulting sequence of insertion at-
tempts fails a certain number of times, the current evicted
element is placed in a special bin called stash. In [16] it
was shown that for h = 2 hash functions, β = 2(1 + ε)n
bins, and a stash of size s ≤ lnn, the insertion of elements
fails with small probability of O(n−s), which is smaller
than n−(s−1) for sufﬁciently large values of n (cf. §7.2).
2.4 Oblivious Transfer
1-ouf-of-2 oblivious transfer (OT) [8] is a protocol where
the receiver with choice bit c, chooses one of two strings
(x0,x1) held by the sender. The receiver receives xc but
gains no information about x1−c, while the sender gains
no information about c.

OT extension protocols [2, 17] precompute a small
number (say, κ = 128) of “real” public-key-based OTs,
and then compute any polynomial number of OTs using
symmetric-key cryptography alone. The most efﬁcient
OT variant that we use computes random OT. In that pro-
tocol the sender has no input but obtains random (x0,x1)
as output, while the receiver with input c obtains xc [2].
The advantage of this protocol is that the sender does not
need to send messages based on its inputs, as it does not
have any inputs, and instead computes them on-the-ﬂy
during the OT extension protocol. As a result, the com-
munication overhead of the protocol is greatly reduced.
An additional improvement that we use, described
in [17], efﬁciently computes 1-out-of-N OT for short
strings. The communication for a random 1-out-of-N OT
(for 3 ≤ N ≤ 256) is only 2κ-bits, whereas the commu-
nication for a random 1-out-of-2 OT is κ-bits. The com-
putation for a random 1-out-of-N OT amounts to four
pseudo-random generator (PRG) and one correlation-
robust function (CRF) evaluations for the receiver and
two PRG and N CRF evaluations for the sender. In addi-
tion, if the sender only requires i ≤ N outputs of the OT,
it only needs to perform i CRF evaluations.
We use 1-out-of-N OT since we have to perform OTs
for every bit of an element. By using 1-out-of-N OT for
N = 2µ, we process µ bits in parallel with communica-
tion equal to that of processing two bits. We denote m

(cid:29) .

1-out-of-N OTs on (cid:29)-bit strings by(cid:31)N

1(cid:30)-OTm

2.5 Generic Secure Computation
Generic secure two-party computation protocols allow
two parties to securely evaluate any function that can
be expressed as a Boolean circuit. The communica-
tion overhead and the number of cryptographic opera-
tions that are computed are linear in the number of non-
linear (AND) gates in the circuit, since linear (XOR)
gates can be evaluated “for free” in current protocols.
Furthermore, some protocols require a number of inter-
action rounds that are linear in the AND depth of the
circuit. The two main approaches for generic secure
two-party computation on Boolean circuits are Yao’s gar-
bled circuits [25] and the protocol by Goldreich-Micali-
Wigderson [11]. We give a summary of these protocols
in the full version [21].

3 Related Work

We reﬂect on existing PSI protocols by following the
classiﬁcation of PSI protocols in [22]: the naive hash-
ing protocol (§3.1), server-aided PSI protocols (§3.2),
public-key cryptography-based PSI protocols (§3.3),
generic secure computation-based PSI protocols (§3.4),
and OT-based PSI protocols (§3.5). For each category,

4

518  24th USENIX Security Symposium 

USENIX Association

we review existing work and outline the best performing
protocol, according to [22].

(Insecure) Naive Hashing

3.1
In the naive hashing protocol, detailed in the full ver-
sion [21], P1 permutes and hashes its elements, and sends
the results to P2 which compares these values to the
hashes of its elements. This approach is very efﬁcient
and is currently employed in practice, but it allows P2 to
brute-force the elements of P1 if they do not have high en-
tropy. Furthermore, even if inputs elements have high en-
tropy, forward-secrecy is not provided since P2 can check
at any later time whether an element was in X.

3.2 Server-Aided PSI
To increase the efﬁciency of PSI, protocols that use a
semi-trusted third party were proposed [15]. These pro-
tocols are secure as long as the third party does not col-
lude with any of the participants. We mention this set of
protocols here for completeness, as they require different
trust assumptions as protocols involving no third party.

The protocol of [15] has only a slightly higher over-
head than the naive hashing PSI solution described
In that protocol, P1 samples a random κ-bit
in §3.1.
key k and sends it to P2. Both parties compute hi = Fk(xi)
(resp. h(cid:30)j = Fk(y j)), where Fk is a pseudo-random permu-
tation that is parametrized by k. Both parties then send
the hashes to the third party (in randomly permuted or-
der) who then computes I = hi∩h(cid:30)j, for all 1 ≤ i ≤ n1 and
1 ≤ j ≤ n2 and sends I to P2. P2 obtains the intersection
by computing F−1

k

(e) for each e ∈ I.

3.3 Public-Key Cryptography based PSI
The ﬁrst protocols for PSI were outlined in [13, 18] and
were based on the Difﬁe-Hellmann (DH) key exchange.
The overhead of these protocols is O(n) exponentiations.
In [9, 10], a PSI protocol based on El-Gamal encryption
was introduced that uses oblivious polynomial evaluation
and requires O(nloglog(n)) public-key encryptions (the
advantage of that protocol was that its security was not
based on the random oracle model). A PSI protocol that
uses blind-RSA was introduced in [3].

We implement the DH-based protocol of [13, 18]
based on elliptic-curve-cryptography, which was shown
to achieve lowest communication in [22]. We describe
the protocol in the full version [21].

3.4 PSI based on Generic Protocols
Generic secure computation can be used to perform PSI
by encoding the intersection functionality as a Boolean

circuit. The most straightforward method for this encod-
ing is to perform a pairwise-comparison which compares
each element of one party to all elements of the other
party. However, this circuit uses O(n2) comparisons and
hence scales very poorly for larger set sizes [12]. The
Sort-Compare-Shufﬂe (SCS) circuit of [12] is much more
efﬁcient. As indicated by its name, the circuit ﬁrst sorts
the union of the elements of both parties, then compares
adjacent elements for equality, and ﬁnally shufﬂes the re-
sult to avoid information leakage. The sort and shufﬂe
operations are implemented using a sorting network of
only O(nlogn) comparisons, and the comparison step re-
quires only O(n) comparisons.

The work of [12] describes a size-optimized ver-
sion of this circuit for use in Yao’s garbled circuits;
[22] describes a depth-optimized version for use in the
GMW protocol. The size-optimized SCS circuit has
σ (3nlog2 n + 4n) AND gates4 and AND depth (σ +
2)log2(2n)+log2(σ )+1 while the depth-optimized SCS
circuit has about the same number of gates and AND
depth of (log2(σ ) +4) log2(2n), for n = (n1 + n2)/2.

PSI protocols based on generic secure computation
have higher run-time and communication complexity
than most special-purpose PSI protocols [4, 22]. Yet,
these protocols are of great importance since they en-
able to easily compute any functionality that is based
on basic PSI. Consider, for example, an application that
needs to ﬁnd if the size of the intersection is greater than
some threshold, or compute the sum of revenues from
items in the intersection. Computing these functionali-
ties using specialized PSI protocols requires to change
the protocols, whereas a PSI protocol based on generic
computation can be adapted to compute these functional-
ities by using a slightly modiﬁed circuit. In other words,
changing specialized protocols to have a new functional-
ity requires to employ a cryptographer to design a new
protocol variant, whereas changing the functionality of
a generic protocol only requires to design a new circuit
computing the new functionality. The latter task is of
course much simpler. An approximate PSI protocol that
uses generic secure computation protocols in combina-
tion with Bloom ﬁlters was given in [24].

3.5 OT-based PSI
OT-based PSI protocols are the most recent category of
PSI protocols. Their research has been motivated by re-
cent efﬁciency improvements in OT extension. The gar-
bled Bloom ﬁlter protocol of [7] was the ﬁrst OT-based
PSI protocol and was improved in [22]. A novel OT-
based PSI protocol, which we denote OT-PSI protocol,

4The original description of the SCS circuit in [12] embedded input
keys into AND gates in the sort circuit to reduce communication. We
did not use this optimization in our implementation.

USENIX Association  

24th USENIX Security Symposium  519

5

was introduced in [22], combining OT and hashing to
achieve the best run-time among all analyzed PSI pro-
tocols. We next summarize the OT-PSI protocol of [22]
and give a detailed description in the full version [21].

The abstract idea of the OT-PSI protocol is to have
both parties hash their elements into bins using the same
hash function (Step 1, cf. §3.5.1) and compare the ele-
ments mapped to the same bin. The comparison is done
using OTs that generate random masks from the elements
(Step 2, cf. §3.5.2), such that the intersection of the ran-
dom masks corresponds to the intersection of the original
inputs (Step 3, cf. §3.5.3). Finally, the intersection of the
elements in the stash is computed (§3.5.4). We give the
overhead of the protocol in §3.5.5.

3.5.1 PSI via Hashing to Bins

In the ﬁrst step of the protocol, the parties map their el-
ements into their respective hash tables T1 and T2, con-
sisting of β = h(1 + ε)n2 bins (cf. §7). P2 uses Cuckoo
hashing with h hash functions (with h = 2), and obtains
a one-dimensional hash table T2. P1 hashes each item h
times (once for each hash function) using simple hash-
ing and obtains a two-dimensional hash table T1 (where
the ﬁrst dimension addresses the bin and the second di-
mension the elements in the bin). Each party then pads
all bins in its table to the maximum size using respective
dummy elements: P1 pads each bin to maxβ elements
using a dummy element d1 (where maxβ is computed us-
ing β and n1 as detailed in §7 to set the probability of
mapping more items to a bin to be negligible), while P2
ﬁlls each empty bin with dummy element d2 (different
than d1). The padding is performed to hide the number
of elements that were mapped to a speciﬁc bin, which
would leak information about the input.

3.5.2 Masking via OT

After the hashing, the parties use OT to generate an (cid:31)-bit
random mask for each element in their hash table.

Naively, for each bin, and for each item that P2 mapped
to the bin, the parties run a 1-out-of-2 OT for each bit
of this item. P2 is the receiver and its input to the OT
is the value of the corresponding bit in the single item
that it mapped to the bin. P1’s input is two random (cid:31)-bit
strings. After running these OTs for all σ bits of the item,
P1 sends to P2 the XOR of the strings corresponding to
the bits of P1’s item. Note that if P1’s item is equal to
that of P2 then the sent value is equal to the XOR of the
output strings that P2 received in the OTs. Otherwise the
values are different with high probability, which depends
on the length (cid:31) of the output strings.

This basic protocol was improved upon in [22] in sev-

eral ways:

• Recall that OT extension is more efﬁcient when ap-
plied to 1-out-of-N OT [17]. Therefore, the proto-
col uses µ-bit characters instead of a binary repre-
sentation. It splits the elements into t µ-bit charac-
ters, and uses t invocations of 1-out-of-N OT where
N = 2µ, instead of tµ invocations of 1-out-of-2 OT.
• In each bin the parties run OTs for all maxβ items
that P1 mapped to the bin, and to all characters in
these items. P2’s inputs are the same for all maxβ
OTs corresponding to the same character. Thus, the
parties could replace them with a single OT, where
the output string of the OT has maxβ longer size.

• Recall that random OT, where the protocol ran-
domly deﬁnes the inputs of P1, is more efﬁcient
than an OT where P1 chooses these inputs by itself.
For the purpose of PSI the protocol can use random
OT. It is also important to note that if P1 mapped
m < maxβ elements to a bin, it only needs to eval-
uate inputs for m random OTs in this bin and not
for all maxβ random OTs that are taking place. This
improves the overhead of the protocol.

3.5.3

Intersection

The parties compute the intersection of their elements us-
ing the random masks (XOR values) generated during
Step 2: P1 generates a set V as the masks for all of its
non-dummy elements. P1 then randomly permutes the
set V to hide information about the number of elements
in each bin, and sends V to P2. P2 computes the inter-
section X ∩Y by computing the plaintext intersection be-
tween V and the set of XOR values that it computed.

3.5.4

Including a Stash

The OT-based PSI protocol of [22] uses Cuckoo hashing
with a stash of size s. The intersection of P2’s elements
with P1’s elements is done by running the masking pro-
cedure of Step 2 for all s items in the stash, comparing
them with all n1 items in P1’s input. Finally, P1 sends the
masks it computed to P2 (in randomly permuted order)
which can then check the intersection as in Step 3.

3.5.5 Overhead

The overhead of this protocol is linear in the bit-length
of the input elements. Therefore, any reduction in the
bit-length of the inputs directly results in a similar im-
provement in the overhead.

For readers interested in the exact overhead of the pro-
tocol, we describe here the details of the overhead. In

1(cid:30)-OTβt
total, the parties have to evaluate random(cid:31)N
maxβ (cid:31)
+(cid:31)N
1(cid:30)-OTst
n1(cid:31) and send (h + s)n1 masks of (cid:31)-bit length,
where β = h(n2 + ε), N = 2µ, t = (cid:28)σ /µ(cid:27), (cid:31) = λ +

520  24th USENIX Security Symposium 

USENIX Association

6

log2(n1) + log2(n2), and s is the size of the stash. To
be exact, the server has to perform 2t(β + s) pseudo-
random generator evaluations during OT extension, (h +
s)n1t correlation-robust function evaluations to gener-
ate the random masks, and send (2 + s)n1(cid:31) bits. The
client has to perform 4t(β +s) pseudo-random generator
evaluations during OT extension, n2tmaxβ (cid:31)/o + sn1t(cid:31)/o
correlation-robust function evaluations to generate the
random masks, and send 2(β + s)tκ bits during OT ex-
tension, where o is the output length of the correlation-
robust function. Note especially that the client has to
evaluate the correlation-robust function O(nlog2 n) times
to generate the random bits which represent the masks of
the server’s elements. This cost can become prohibitive
for larger sets, as we will show in our evaluation in §8.
4 Permutation-based Hashing

The overhead of the OT-based PSI protocol of [22] and
of the circuit-based PSI protocols we describe in §5 de-
pends on the bit-lengths of the items that the parties map
to bins. The bit-length of the stored items can be re-
duced based on a permutation-based hashing technique
that was suggested in [1] for reducing the memory usage
of Cuckoo hashing. That construction was presented in
an algorithmic setting to improve memory usage. As far
as we know this is the ﬁrst time that it is used in secure
computation or in a cryptographic context.

The construction uses a Feistel-like structure. Let
x = xL|xR be the bit representation of an input item,
where |xL| = logβ , i.e.
is equal to the bit-length of an
index of an entry in the hash table. (We assume here that
the number of bins β in the hash table is a power of 2.
It was shown in [1] how to handle the general case.) Let
f () be a random function whose range is [0,β −1]. Then
item x is mapped to bin xL ⊕ f (xR). The value that is
stored in the bin is xR, which has a length that is shorter
by logβ bits than the length of the original item. This is a
great improvement, since the length of the stored data is
signiﬁcantly reduced, especially if |x| is not much greater
than logβ . As for the security, it can be shown based on
the results in [1] that if the function f is k-wise indepen-
dent, where k = polylogn, then the maximum load of a
bin is logn with high probability.

The structure of the mapping function ensures that if
two items x,x(cid:27) store the same value in the same bin then it
must hold that x = x(cid:27): if the two items are mapped to the
same bin, then xL ⊕ f (xR) = x(cid:27)L ⊕ f (x(cid:27)R). Since the stored
values satisfy xR = x(cid:27)R it must also hold that xL = x(cid:27)L, and
therefore x = x(cid:27).

As a concrete example, assume that |x| = 32 and that
the table has β = 220 bins. Then the values that are stored
in each bin are only 12 bits long, instead of 32 bits in the
original scheme. Note also that the computation of the

bin location requires a single instantiation of f , which
can be implemented with a medium-size lookup table.

A comment about an alternative approach An al-
ternative, and more straightforward approach for reduc-
ing the bit-length could map x using a random permuta-
tion p() to a random |x|-bit string p(x). The ﬁrst logβ
bits of p(x) are used to deﬁne the bin to which x is
mapped, and the value stored in that bin holds the re-
maining |x|− logβ bits of p(x). This construction, too,
has a shorter length for the values that are stored in the
bins, but it suffers from two drawbacks: From a perfor-
mance perspective, this construction requires the usage
of a random permutation on |x| bits, which is harder to
compute than a random function. From a theoretical per-
spective, it is impossible to have efﬁcient constructions
of k-wise independent permutations, and therefore we
only know how to prove the logn maximum load of the
bins under the stronger assumption that the permutation
is random.

5 Circuit-Phasing

PSI protocols that are based on generic secure compu-
tation are of great importance due to their ﬂexibility (cf.
§3.4 for details). The best known construction of a circuit
computing the intersection (of σ-bit elements) is the SCS
circuit of [12] with about 3nσ log2 n AND gates and an
AND depth of Θ(log2 σ ·log2 n). We describe a new con-
struction of circuits with the same order of AND gates
(but with smaller constants), and a much smaller depth.
Our experiments, detailed in §8.1, demonstrate that the
new circuits result in much better performance.
The new protocol, which we denote as Circuit-
Phasing, is based on the two parties mapping their inputs
to hash tables before applying the circuit. The idea is
similar to the OT-based PSI protocol of [22] described
in §3.5, but instead of using OTs for the comparisons,
the protocol evaluates a pairwise-comparison circuit be-
tween each bin of P1 and P2 in parallel:

• Both parties use a table of size β = O(n) to store
their elements. Our analysis (§7) shows that setting
β = 2.4n reduces the error probability to be negligi-
ble for reasonable input sizes (28 ≤ n ≤ 224) when
setting the stash size according to Tab. 4.
• P2 maps its input elements to β bins using Cuckoo
hashing with two hash functions and a stash; empty
bins are padded with a dummy element d2.

• P1 maps its input elements into β bins using sim-
ple hashing. The size of the bins is set to be maxβ ,
a parameter that is set to ensure that no bin over-
ﬂows (see §7.1). The remaining slots in each bin are
padded with a dummy element d1 (cid:23)= d2. The analy-

USENIX Association  

24th USENIX Security Symposium  521

7

sis described in §7.1 shows how maxβ is computed
and is set to a value smaller than log2 n.
• The parties securely evaluate a circuit that compares
the element that was mapped to a bin by P2 to each
of the maxβ elements mapped to it by P1.

• Finally, each element in P2’s stash is checked for
equality with all n1 input elements of P1 by securely
evaluating a circuit computing this functionality.

• To reduce the bit-length of the elements in the
bins, and respectively the circuit size, the protocol
uses permutation-based hashing as described in §4.
(Note that using this technique is impossible with
SCS circuits of [12].)

A detailed analysis of the circuit size and depth
Let m be the size of P1’s input to the circuit with m =
β maxβ + sn1, i.e., for each of the β bins, P1 inputs maxβ
items as well as n1 items for each of the s positions in
the stash. The circuit computes a total of m comparisons
between the elements of the two parties. Each element
is of length σ(cid:29) bits, which is the reduced length of the
elements after being mapped to bins using permutation-
based hashing, i.e. σ(cid:29) = σ − log2 β .
A comparison of two σ(cid:29)-bit elements is done by com-
puting the bitwise XOR of the elements and then a tree
of σ(cid:29) − 1 OR gates, with depth (cid:27)log2 σ(cid:29)(cid:26). The topmost
gate of this tree is a NOR gate. Afterwards, the circuit
computes the XOR of the results of all comparisons in-
volving each item of P2. (Note that at most one of the
comparisons results in a match, therefore the circuit can
compute the XOR, rather than the OR, of the results of
the comparisons.) Overall, the circuit consists of about
m· (σ(cid:29) − 1) ≈ n1 · (maxβ + s)· (σ(cid:29) − 1) non-linear gates
and has an AND depth of (cid:27)log2 σ(cid:26).

Advantages Circuit-Phasing has several advantages
over the SCS circuit:

• Compared to the number of AND gates in the SCS
circuit, which is 3nσ logn, and recalling that σ(cid:29) <
σ, and that maxβ was shown in our experiments
to be no greater than logn, the number of non-
linear gates in Circuit-Phasing is smaller by a factor
greater than 3 compared to the number of non-linear
gates in the SCS circuit (even though both circuits
have the same big “O” asymptotic sizes).

• The main advantage of Circuit-Phasing is the low
AND depth of log2(σ ), which is also independent
of the number of elements n. This affects the over-
head of the GMW protocol that requires a round of
interaction for every level in the circuit.

• Another advantage of Circuit-Phasing is its simple
structure: the same small comparison circuit is eval-
uated for each bin. This property allows for a SIMD

(Single Instruction Multiple Data) evaluation with a
very low memory footprint and easy parallelization.

Hashing failures: The correct performance of the pro-
tocol depends on the successful completion of the hash-
ing operations: The Cuckoo hashing must succeed, and
the simple hashing must not place more than maxβ ele-
ments in each bin. Tables of size 2(1 + ε)n and maxβ =
O(logn) guarantee these properties with high probabil-
ity. We analyze the exactly required table sizes in §7 and
set them to be negligible in the statistical security param-
eter λ .

6 OT-Phasing

We improve the OT-PSI protocol of [22] by applying the
following changes to the protocol:

• Reducing the bit-length of the items using the
permutation-based hashing technique described
in §4. This improvement reduces the length of the
items from |x| bits to |x|−β bits, where β is the size
of the tables, and consequently reduces the number
of OTs by a factor of β /|x|.
• Using OTs on a single mask instead of on O(logn)
masks before. This improvement is detailed in §6.1.
• Improving the utilization of bins by using 3-way
Cuckoo hashing (§6.2).
We call the resulting PSI protocol that combines all these
optimizations OT-Phasing. In the full version [21], we
evaluate the performance gain of each optimization indi-
vidually and micro-benchmark the resulting protocol.

6.1 A Single Mask per Bin
In order to hide information about the number of items
that were mapped to a bin, the original OT-PSI proto-
col of [22] (cf. §3.5) padded all bins to a maximum size
of maxβ = O(logn). The protocol then ran OTs on maxβ
masks of (cid:29)-bit length where the parties had to generate
and process all of the maxβ masks. We describe here
a new construction that enables the parties to compute
only a constant number of masks per element, regardless
of the number of elements that were mapped to the bin
by P1. While this change seems only small, it greatly
increases the performance and scalability of the proto-
col (cf.
iterative performance improvements in the full
version [21]). In particular, this change results in two im-
provements to the protocol:

• The number of symmetric cryptographic operations
to generate the masks is reduced from O(log2 n) to
O(logn). Furthermore, note that P2 had to compute
the plaintext intersection between his n2maxβ gen-
erated masks and the 2n1 masks sent by P1. This

522  24th USENIX Security Symposium 

USENIX Association

8

also greatly improves the memory footprint and
plaintext intersection.

• In the previous OT-based protocol, a larger value of
the parameter maxβ reduced the failure probability
of the simple hashing procedure used by P1, but in-
creased the string size in the OTs. In the new proto-
col the value of maxβ does not affect the overhead.
Therefore P1 can use arbitrarily large bins and en-
sure that the mapping that it performs never fails.

Recall that in the OT-based PSI protocol of [22]
(cf. §3.5) the parties had inputs of t characters, where
each character was µ bits long, and we used the no-
tation N = 2µ. The parties performed OTs on strings
of maxβ masks per bin. Each mask had length (cid:31) =
λ +log2(n1) +log2(n2) bits, corresponded to an element
that P1 mapped to the bin, and included a 1-out-of-N
random-OT for each of the t characters of this element.
P1 was the sender, received all the N sender input-strings
of each OT, and chose from them the one correspond-
ing to the value of the character in its own element. P2
was the receiver and received the string corresponding to
the value of the character in its own element. Then P1
computed the XOR of the t strings corresponding to the
t characters of its element and sent this XOR value to P2,
which compared it to the XOR of its t outputs from OT.
The protocol can be improved by running the t 1-out-
of-N OTs on a single mask per bin. Denote by u the
actual number of items mapped by P1 to a bin. The
value of u is not revealed to P2 in the new protocol and
therefore there is no need to pad the bin with dummy
items. Denote the single item that P2 mapped to the bin
as y = y1, . . . ,y t, and the u items that P1 mapped to the bin
as x1, . . . ,x u, where each xi is deﬁned as xi = xi

1, . . . ,x i
t.
Deﬁne the input strings to the j-th OT as {s j,(cid:31)}(cid:31)=1...N.
The protocol that is executed is a random OT and there-
fore these strings are chosen by the protocol and not
by P1. The parties run a single set of t OTs and P2
learns the t strings s1,y1, . . . ,s t,yt . It computes their XOR
SP2 = s1,y1 ⊕···⊕s t,yt , and the value H(SP2), where H()
is a hash function modeled as a random oracle.
P1 learns all the Nt strings generated in the random-
OT protocols. For each input element xi that P1 mapped
to the bin, it computes the XOR of the strings corre-
sponding to the characters of the input, namely Si
P1 =
, and then computes the value H(Si
s1,xi
P1).
Note that over all bins, P1 needs to perform this compu-
tation only O(n1) times and compute O(n1) hash values.
P1 then sends all these values to P2 in randomly permuted
order. P2 computes the intersection between these values
and the H(SP2 ) values that it computed in the protocol.

Efﬁciency: P2 computes only a single set of t OTs per
bin on one mask, compared to t OTs on maxβ masks in
the OT-based protocol of [22]. As for P1’s work, it com-
putes a single set of OTs per bin, and in addition com-

1 ⊕ ··· ⊕s t,xi

t

putes a XOR of strings and a hash for each of its O(n1)
input elements. This is a factor of maxβ = O(logn1) less
work as before. Communication is only O(nσ ) strings,
as before.

Security: Assuming that the OT protocols are secure
and that the parties are semi-honest, the only informa-
tion that is received by any party in the protocol is the
H(Si
P1) values that are sent from P1 to P2. For all val-
ues in the intersection of the input sets of the two parties,
P1 sends to P2 the same hash values as those computed
by P2. Consider the set of input elements ¯X that are part
of P1’s input and are not in P2’s input, and the set of XOR
values corresponding to ¯X. There might be linear depen-
dencies between the XOR values of ¯X, but it holds with
overwhelming probability that all these values are differ-
ent, and they are also all different from the XOR values
computed by P2. Therefore, the result of applying a ran-
dom hash function H() to these values is a set of random
elements in the range of the hash function. This prop-
erty enables to easily provide a simulation based proof
of security for the protocol.

3-Way Cuckoo Hashing

6.2
The original OT-based PSI protocol of [22] uses Cuckoo
hashing which employs two hash functions to map ele-
ments into bins. It was shown in [20] that if n elements
are mapped to 2(1 + ε)n bins, Cuckoo hashing succeeds
with high probability for ε > 0. This means that Cuckoo
hashing achieves around 50% utilization of the bins. If
the number of hash functions h is increased to h > 2, a
much better utilization of bins can be achieved [6]. How-
ever, using h hash functions in our protocol requires P1 to
map each element h times into its bins using simple hash-
ing and requires P1 to send hn1 masks in the intersection
step of the protocol.

We detail in Tab. 1 the utilization and total communi-
cation of our PSI protocol for n1 = n2 = 220 and n2 =
28 (cid:25) n1 = 220, for σ = 32-bit elements with different
numbers of hash functions. We observe that there is a
tradeoff between the communication for the OTs and the
communication for the masks that are sent by P1. Our
goal is to minimize the total communication, and this is
achieved for h = 3 hash functions in the setting of n1 = n2
and for h = 2 in the setting of n2 (cid:25) n1. For n1 = n2 using
h = 3 instead of h = 2, as in the original protocol of [22],
reduces the overall communication by 33%.

Hashing failures: We observe that with OT-Phasing,
there is essentially no bound on the number of items that
the server can map to each speciﬁc bin, since the client
does not observe this value in any way (the message that
the client receives only depends on the total number of
items that the server has). However, the parameters used

USENIX Association  

24th USENIX Security Symposium  523

9

h
2
3
4
5

Util. [%]

50.0
91.8
97.7
99.2

#OTs
2.00n2 t
1.09n2 t
1.02n2 t
1.01n2 t

#Masks

2n1(cid:31)
3n1(cid:31)
4n1(cid:31)
5n1(cid:31)

Comm. [MB]

n1 = n2
148.0
99.8
105.3
114.6

n2 (cid:31) n1
17.0
25.5
34.0
42.5

Table 1: Overall communication for a larger number of
hash functions h. Communication is given for a) n1 =
n2 = 220 and b) n2 = 28 (cid:31) n1 = 220 elements of σ = 32-
bit length. Utilization according to [6].

in the protocol do need to ensure that the Cuckoo hashing
procedure does not fail. The analysis appears in §7.

7 Hashing Failures

The PSI schemes we presented use simple hashing (by
P1), and Cuckoo hashing (by P2).
In both hashing
schemes, the usage of bins (or a stash) of constant size,
might result in hashing failures if the number of items
mapped to a bin (or the stash) exceeds its capacity.

When hashing fails, the party which performed the
hashing has two options: (1) Ignore the item that can-
not be mapped by the hashing scheme. This essentially
means that this item is removed from the party’s input to
the PSI protocol. Consequently, the output of the compu-
tation might not be correct (although, if this type of event
happens rarely, the effect on correctness is likely to be
marginal). (2) Attempt to use a different set of hash func-
tions, and recompute the hash of all items. In this case
the other party must be informed that new hash functions
are used. This is essentially a privacy leak: for example,
the other party can check if the input set S of the ﬁrst
party might be equal to a set S(cid:29) (if a hashing failure does
not occur for S(cid:29) then clearly S(cid:29) (cid:28)= S). The effect of this
leak is likely to be weak, too, but it is hard to quantify.
The effect of hashing failures is likely to be marginal,
and might be acceptable in many usage settings (for ex-
ample, when measuring ad conversion rates it typically
does not matter if the revenue from a single ad view is
ignored). However, it is preferable to set the probability
of hashing failures to be negligibly small.

In OT-Phasing, P2 does not learn the number of items
that P1 maps to each bin, and therefore P1 can set the size
of the bins to be arbitrarily large. However, in that PSI
protocol P1 knows the size of the stash that is used in
the Cuckoo hashing done by P2. In Circuit-Phasing, each
party knows the size of the bins (or stash) that is used by
the other party. We are therefore interested in learning
the failures probabilities of the following schemes, and
bound them to be negligible, i.e., at most 2−40:

• §7.1:

Simple hashing in the Circuit-Phasing
scheme, where n items are mapped using two in-
dependent functions to 2.4n bins. This is equivalent

to mapping 2n items to 2.4n bins.

• §7.2: Cuckoo hashing, using 2.4n bins and either 2-
way hashing (for Circuit-Phasing), or 3-way hash-
ing (for OT-Phasing). The failure probability for
3-way hashing is smaller than for 2-way hashing
(since there is an additional bin to which each item
can be mapped), and therefore we will only examine
the failure probability of 2-way Cuckoo hashing.

7.1 Simple Hashing
It was shown in [23] that when n balls are mapped at
random to n bins then the maximum number of elements
in a bin is with high probability lnn
lnlnn (1 + o(1)). Let us
examine in more detail the probability of the following
event, “2n balls are mapped at random to 2.4n bins, and
the most occupied bin has at least k balls”:

Pr(∃bin with ≥ k balls)
≤ 2.4n· Pr(bin #1 has ≥ k balls)
k(cid:30)(cid:31) 1
≤ 2.4n(cid:31)2n
2.4n(cid:30)k
k (cid:30)k(cid:31) 1
2.4n(cid:30)k−1
≤(cid:31)2ne
k (cid:30)k(cid:31) 1
2.4(cid:30)k−1
= n(cid:31)2e

.

(1)
(2)

(3)

(4)

(5)

It is straightforward to see that this probability can be
bounded to be at most 2−40 by setting

k ≥ max(6,2elogn/loglogn).

(6)

We calculated for some values of n the desired bin sizes
based on the upper bound of Eq. (6) and the tighter cal-
culation of Eq. (5), and chose the minimal value of k that
reduces the failure probability to below 2−40. The results
are in Table 2. It is clear that Eq. (5) results in smaller
bins for sufﬁciently large n, and therefore the maximal
bin size should be set according to Eq. (5).

n

Eq. (5)
Eq. (6)

212
18
19

216
19
22

220
20
26

224
21
29

Table 2: The bin sizes maxβ that are required to ensure
that no overﬂow occurs when mapping 2n items to 2.4n
bins, according to Eq. (5) and Eq. (6).

7.2 Cuckoo Hashing
It was shown in [16] that Cuckoo hashing with a stash
of size s fails with probability O(n−s). The constants in
the big “O” notation are unclear, but it is obvious that
O(n−s) ≤ n−(s−1) for sufﬁciently large values of n.

524  24th USENIX Security Symposium 

USENIX Association

10

s
0
1
2
3
4
5
6

211

1,068,592,289
4,994,200
147,893
7,005
407
28
2

212

1,070,826,935
2,861,137
52,038
1,647
62
5
0

213

1,072,132,187
1,592,951
16,404
274
8
0
0

214

1,072,845,430
891,497
4,840
56
1
0
0

Required stash sizes

Table 3:
over
n ∈ {211,212,213,214} elements to 2.4n bins.

230 Cuckoo

hashing

s

accumulated
repetitions mapping

)

y
2
(
 
y
t
i
l
i

b
a
b
o
r
P

 
r
o
r
r

E

Number of Elements (2x)

−111 12 13 14 15 16 17 18 19 20 21 22 23 24
−10
−20
−30
−40

    s=1
s=2
s=3
s=4
s=5
s=6

−60

−80

We would like to ﬁnd the exact size of the stash that
ensures that the failure probability is smaller than 2−40.
We ran 230 repetitions of Cuckoo hashing, mapping n
for n ∈ {211,212,213,214}, and
items to 2.4n bins,
recorded the stash size s that was needed for Cuckoo
hashing to be successful. Tab. 3 depicts the number of
repetitions where we required a stash of size s. From the
results we can observe that, to achieve 2−30 failure prob-
ability of Cuckoo hashing, we would require a stash of
size s = 6 for n = 211, s = 5 for n = 212, and s = 4 for
both n = 213 and n = 214 elements.

However, in our experiments we need the stash sizes
for larger values of n ≥ 214 to achieve a Cuckoo hashing
failure probability of 2−40. To obtain the failure proba-
bilities for larger values of n, we extrapolate the results
from Tab. 3 using linear regression and illustrate the re-
sults in Fig. 1. We observe that the stash size for achiev-
ing a failure probability of 2−40 is drastically reduced for
higher values of n: for n = 216 we need a stash of size
s = 4, for n = 220 we need s = 3, and for n = 224 we
need s = 2. This observation is in line with the asymp-
totic failure probability of O(n−s).

Finally, we extrapolate the required stash sizes s to
achieve a failure probability of 2−40 for smaller values of
n ∈ {28,212} and give the results together with the stash
sizes for n ∈ {216,220,224} in Tab. 4.

number of elements n
stash size s

28
12

212
6

216
4

220
3

224
2

Table 4: Required stash sizes s to achieve 2−40 error
probability when mapping n elements into 2.4n bins.

8 Evaluation

We report on our empirical performance evaluation of
Circuit-Phasing (§5) and OT-Phasing (§6) next. We eval-
uate their performance separately (§8.1 and §8.2), since
special purpose protocols for set intersection were shown
to greatly outperform circuit-based solutions in [22].
(The latter are nevertheless of independent interest be-
cause their functionality can be easily modiﬁed.)

11

−100

Figure 1: Error probability when mapping n elements to
2.4n bins using 2-way Cuckoo hashing for stash sizes
1 ≤ s ≤ 6. The solid lines correspond to actual measure-
ments, the dashed lines were extrapolated using linear
regression. Both axes are in logarithmic scale.

consider

Benchmarking Environment We
two
benchmark settings: a LAN setting and a WAN setting.
The LAN setting consists of two desktop PCs (Intel
Haswell
i7-4770K with 3.5 GHz and 16GB RAM)
connected by Gigabit LAN. The WAN setting consists
of two Amazon EC2 m3.medium instances (Intel Xeon
E5-2670 CPU with 2.6 GHz and 3.75 GB RAM)
located in the US east coast (North Virginia) and Europe
(Frankfurt) with an average bandwidth of 50 MB/s and
average latency (round-trip time) of 96 ms.

We perform all experiments for a symmetric security
parameter κ = 128-bit and statistical security parameter
λ = 40 (cf. §2.1), using a single thread (except for GMW,
where we use two threads to compute OT extension), and
average the results over 10 executions.
In our experi-
ments, we frequently encountered outliers in the WAN
setting with more than twice of the average run-time, for
which we repeated the execution. The resulting variance
decreased with increasing input set size; it was between
0.5%− 8.0% in the LAN setting and between 4%− 16%
in the WAN setting. Note that all machines that we per-
form our experiments on are equipped with the AES-NI
extensions which allows for very fast AES evaluation.

Implementation Details We instantiate the random or-
acle,
the function for hashing into smaller domains,
and the correlation-robust function in OT extension with
SHA256. We instantiate the pseudo-random generator
using AES-CTR and the pseudo-random permutation in
the server-aided protocol of [15] using AES. To com-
(cid:29) functionality, we use the random 1-

pute the(cid:31)2µ

1(cid:30)-OTt

USENIX Association  

24th USENIX Security Symposium  525

out-of-N OT extension of [17] and set µ = 8, i.e., use
N = 256, since this was shown to result in minimal over-
head in [22]. We measure the times for the function eval-
uation including the cost for precomputing the OT exten-
sion protocol and build on the OT extension implementa-
tion of [2]. Our OT-Phasing implementation is available
online at https://github.com/encryptogroup/PSI
and our Circuit-Phasing implementation is available as
part of the ABY framework of [5] at https://github
.com/encryptogroup/ABY.

For simple hashing we use the maximum bin sizes that
were computed using Equation 5 in §7.1 (cf. Tab. 2). For
Cuckoo hashing, we set ε = 0.2 and map n elements to
2(1 +ε)n bins for 2-way Cuckoo hashing and to (1 +ε)n
bins for 3-way Cuckoo hashing with a stash size accord-
ing to Tab. 4. The only exception for the stash size are
the experiments with different set sizes in §8.2.2, where
we use no stash for our OT-Phasing protocol.
For OT-based PSI [22] and OT-Phasing, where the
performance depends on the bit-length of elements, we
hash the σ-bit input elements into a (cid:30) = λ + log2(n1) +
log2(n2)-bit representation using SHA256 if σ > (cid:30).

We use a garbled circuits implementation with most

recent optimizations (cf. full version [21] for details).

We emphasize that all implementations are done in
the same programming language (C++), use the same
underlying libraries for evaluating cryptographic opera-
tions (OpenSSL for symmetric cryptography and Miracl
for elliptic curve cryptography), perform the plaintext-
intersection of elements using a standard hash map, are
all executed using a single thread (except for the GMW
implementation which uses two threads), and run in the
same benchmarking environment.

8.1 Generic Secure Computation-based

PSI Protocols

For the generic secure computation-based PSI protocols,
we perform the evaluation on a number of elements vary-
ing from 28 to 220 and a ﬁxed bit-length of σ = 32-
bit. For n = 220 all implementations, except Circuit-
Phasing with GMW, exceeded the available memory,
which is due to the large number of AND gates in the
SCS circuit (estimated 2 billion AND gates) and the re-
quirement to represent bits as keys for Circuit-Phasing
with Yao, where storing only the input wire labels to
the circuit requires 1 GB. A more careful implementa-
tion, however, could allow the evaluation of these cir-
cuits. We compare the sort-compare-shufﬂe (SCS) cir-
cuit of [12] and its depth-optimized version of [22], with
Circuit-Phasing (§5), by evaluating both constructions
using Yao’s garbled circuits protocol [25] and the GMW
protocol [11] in the LAN and WAN setting. We use the
size-optimized version of the SCS circuit in Yao’s gar-

bled circuit and the depth-optimized version of the cir-
cuit in the GMW protocol (cf. §3.4). For the evalua-
tion in Circuit-Phasing, we set the maximum bin size in
simple hashing according to Equation 5 (cf. Tab. 2, set
ε = 0.2, set the stash size according to Tab. 4, and assume
n = n1 = n2. The run-time of Circuit-Phasing would in-
crease linear in the bin size maxβ , while the stash size s
would have a smaller impact on the total run-time as the
concrete factors are smaller.

Run-Time (Tab. 5) Our main observation is that
Circuit-Phasing outperforms the SCS circuit of [12] for
all parameters except Yao’s garbled circuits with small
set sizes n = 28. In this case, the high stash size of s = 12
greatly impacts the run-time of Circuit-Phasing. When
evaluated using Yao’s garbled circuits, Circuit-Phasing
outperforms the SCS circuit by a factor of 1-2, and when
evaluated using GMW it outperforms SCS by a factor
of 2-5. Furthermore, the run-time for Circuit-Phasing
grows slower with n than for the SCS circuit for all set-
tings except for GMW in the WAN setting. There, the
run-time of the SCS circuit grows slower than that of
Circuit-Phasing. This can be explained by the high num-
ber of communication rounds of the SCS based protocol,
which are slowly being amortized with increasing val-
ues of n. The slower increase of the run-time of Circuit-
Phasing with increasing n is due to the smaller increase
of the bin size maxβ ∈ O( lnn
lnlnn ) vs. O(logn) for the SCS
circuit, and the use of permutation-based hashing, which
reduces the bit-length of the inputs to the circuit. Note
that our Yao’s garbled circuits implementation suffers
from similar performance drawbacks in the WAN setting
as our GMW implementation, although being a constant
round protocol. This can be explained by the pipelining
optimization we implement, where the parties pipeline
the garbled circuits generation and evaluation. The per-
formance drawback could be reduced by using an im-
plementation that uses independent threads for sending /
receiving.

Communication (Tab. 6) Analogously to the run-time
results, Circuit-Phasing improves the communication of
the SCS circuit by factor of 1-4 and grows slower with
increasing values of n. The improvement of the round
complexity, which is mostly important for GMW, is even
more drastic. Here, Circuit-Phasing outperforms the SCS
circuit by a factor of 16-38. Note that the round complex-
ity of Circuit-Phasing only depends on the bit-length of
items and is independent of the number of elements.

8.2 Special Purpose PSI Protocols
For the special purpose PSI protocols we perform the
experimental evaluation for equally sized sets n1 =

526  24th USENIX Security Symposium 

USENIX Association

12

Protocol

n = 28

n = 212

LAN

n = 216

n = 220

n = 28

n = 212

WAN

n = 216

n = 220

Yao’s garbled circuits [25]
SCS [12]
Circuit-Phasing §5
Goldreich-Micali-Wigderson [11]
SCS [12]
Circuit-Phasing §5

309
376

626
280

3,464
3,154

2,175
1,290

63,857
39,785

38,727
14,149

—
—

2,878
3,004

—
168,397

11,870
2,681

20,184
17,133

21,030
8,681

301,512
178,865

—
—

218,378
81,534

—
846,510

Table 5: Run-time in ms for generic secure PSI protocols in the LAN and WAN setting on σ = 32-bit elements.

n = 28

n = 212

n = 216

229,120
297,852

5,238,784
3,946,776

Protocol
Number of AND gates
SCS [12]
Circuit-Phasing §5
Communication in MB for Yao’s garbled circuits [25] and GMW [11]
SCS [12]
Circuit-Phasing §5
Number of communication rounds for GMW [11]
SCS [12]
Circuit-Phasing §5

107,479,009
49,964,540

3,485
1,550

169
122

121
5

7
9

85
5

157
5

∗2,000,000,000
600,833,968

∗64,850
18,736

193
5

n = 220

Asymptotic

σ (3nlog2(n) +4n)

(σ − log2(n)− 2)(6(1 + ε)n lnn
2κσ (3nlog2(n) +4n)

2κ(σ − log2(n)− 2)(6(1 + ε)n lnn
(log2(σ ) +4) log2(2n) +4

log2(σ )

lnlnn + sn)

lnlnn + sn)

Table 6: Number of AND gates, concrete communication in MB, round complexity, and failure probability for generic
secure PSI protocols on σ = 32-bit elements. Numbers with ∗ are estimated.

n2 (§8.2.1) and differently sized sets n2 (cid:28) n1 (§8.2.2),
for set sizes ranging from 28 to 224 in the LAN setting
and from 28 to 220 in the WAN setting.

We compare OT-Phasing (§6) to the original OT-based
PSI protocol of [22], the naive hashing solution (§3.1),
the semi-honest server-aided protocol of [15] (§3.2), and
the Difﬁe-Hellmann (DH)-based protocol of [18] (§3.3)
using elliptic curves. Note that the naive hashing proto-
col and the server-aided protocol of [15] have different
security assumptions and cannot directly be compared to
the remaining protocols. We nevertheless included them
in our comparison to serve as a base-line on the efﬁciency
of PSI. For the protocol of [15], we run the server rou-
tine that computes the intersection between the sets on
the machine located at the US east coast (North Virginia)
and the server and client routine on the machine in Eu-
rope (Frankfurt). For the original OT-based PSI and OT-
Phasing, we give the run-time and communication for
three bit-lengths: short σ = 32 (e.g., for IPv4 addresses),
medium σ = 64 (e.g., for credit card numbers), and long
σ = 128 (for set intersection between arbitrary inputs).

Note that the OT-based PSI protocol of [22] and our
OT-Phasing protocol both evaluate public-key cryptogra-
phy during the base-OTs, which dominates the run-time
for small sets. However, these base-OTs only need to
be computed once and can be re-used over multiple ses-
sions. In the LAN setting, the average run-time for com-
puting the 256 base-OTs was 125 ms while in the WAN
setting the run-time was 245 ms. Nevertheless, our re-
sults all contain the time for the base-OTs to provide an
estimation of the total run-time.

8.2.1 Experiments with Equal Input Sizes

In the experiments for input sets of equal size n = n1 = n2
we set n ∈ {28,212,216,220,224} in the LAN setting and
n ∈ {28,212,216,220} in the WAN setting. Note that for
larger bit-lengths σ ≥ 64 and for n = 224 elements, the
memory needed for the OT-based PSI protocol of [22]
exceeded the available memory.

Run-Time (Tab. 7) As expected, the lowest run-time
for the equal set-size experiments is achieved by the (in-
secure) naive hashing protocol followed by the server-
aided protocol of [15], which has around twice the run-
time. In the LAN setting, however, for short bit-length
σ = 32, our OT-Phasing protocol nearly achieves the
same run-time as both of these solutions (which are in
a different security model). In particular, when comput-
ing the intersection for n = 224 elements, our OT-Phasing
protocol requires only 3.5 more time than the naive hash-
ing protocol and 2.5 more time than the server-aided pro-
tocol. In comparison, for the same parameters, the origi-
nal OT-based PSI protocol of [22] has a 68 times higher
run-time than the naive hashing protocol, and the DH-
based ECC protocol of [18] has a four orders of magni-
tude higher run-time compared to naive hashing.

While the run-time of our OT-Phasing protocol in-
creases with the bit-length of elements, for σ = 128-bit
its run-time is only 15 times higher than the naive hash-
ing protocol, and is still nearly two orders of magnitude
better than the DH-based ECC protocol.

Overall, in the LAN setting and for larger sets (e.g.,
n = 224), the run time of OT-Phasing is 20x better than
that of the original OT-based PSI protocol of [22], and

USENIX Association  

24th USENIX Security Symposium  527

13

Setting
Protocol
Naive Hashing(∗) §3.1
Server-Aided(∗) [15]
DH-based ECC [18]
Bit-length σ = 32-bit
OT PSI [22]
OT-Phasing §6
Bit-length σ = 64-bit
OT PSI [22]
OT-Phasing §6
Bit-length σ = 128-bit
OT PSI [22]
OT-Phasing §6

n = 28
1
1
231

n = 212
4
5
3,238

184
179

201
180

201
181

216
202

485
240

485
240

LAN

n = 216
48
78
51,380

3,681
437

7,302
865

8,478
915

n = 220
712
1,250
818,318

62,048
4,260

125,697
10,128

155,051
13,485

n = 224
13,665
20,053
13,065,904

929,685
46,631

—
137,036

—
204,593

n = 28
97
198
628

957
912

977
1,010

980
1,010

WAN

n = 216
558
2,024
161,850

n = 212
111
548
10,158

1,820
1,590

1,873
1,780

1,879
1,780

9,556
3,065

18,998
5,009

21,273
5,536

n = 220
3,538
7,737
2,584,212

157,332
14,567

315,115
29,387

392,265
37,422

Table 7: Run-time in ms for protocols with n = n1 = n2 elements. (Protocols with (∗) are in a different security model.)

Protocol
Naive Hashing(∗) §3.1
Server-Aided(∗) [15]
DH-based ECC [18]
Bit-length σ = 32-bit
OT PSI [22]
OT-Phasing §6
Bit-length σ = 64-bit
OT PSI [22]
OT-Phasing §6
Bit-length σ = 128-bit
OT PSI [22]
OT-Phasing §6

n = 28
0.01
0.01
0.02

n = 212
0.03
0.16
0.28

n = 216
0.56
2.5
4.56

n = 220
10.0
40.0
74.0

n = 224
176.0
640.0
1,200.0

Asymptotic [bit]

n1(cid:31)

(n1 + n2 +|X ∩Y|)κ
(n1 + n2)ϕ + n1(cid:31)

0.09
0.06

0.14
0.09

0.14
0.09

1.39
0.73

2.59
1.34

2.59
1.34

22.58
8.74

41.78
18.34

46.58
20.74

367.20
136.8

5,971.20
1,494.4

674.4
290.4

828.0
367.2

10,886.4
3,952.0

14,572.8
5,795.2

0.6n2σκ + 6n1(cid:31)
σ−(cid:26)log2(1.2n2)(cid:25)

(cid:24)) + (3 + s)n1(cid:31)

2.4n2κ((cid:28)

8

8

0.6n2κ ∗ min((cid:31),σ ) +6n 1(cid:31)

min((cid:31),σ )−log2(n2)

(cid:24)) + (3 + s)n1(cid:31)

2.4n2κ((cid:28)

0.6n2(cid:31)κ + 6n1(cid:31)

2.4n2κ((cid:28) (cid:31)−log2(n2)

8

(cid:24)) + (3 + s)n1(cid:31)

Table 8: Communication in MB for PSI protocols with n = n1 = n2 elements. (cid:31) = λ + log2(n1) +log 2(n2). Assuming
intersection of size 1/2· n for TTP-based protocol. (Protocols with (∗) are in a different security model.)

60-278x better than that of the DH-ECC protocol of [18].
When switching to the WAN setting, the run-times of
the protocols are all increased by a factor of 2-6. Note
that the faster protocols suffer from a greater perfor-
mance loss (factors of 5 and 6 for 220 elements, for the
naive hashing protocol and server-aided protocol) than
the slower protocols (factor 3 for the DH-based and our
OT-Phasing protocol and 2.5 for the OT-based PSI pro-
tocol of [22]). This difference can be explained by the
greater impact of the high latency of 97 ms on the run-
time of the protocols. The relative performance among
the protocols remains similar to the LAN setting.

permutation-based hashing. This is quite surprising, as
protocols that use public-key cryptography, in particular
elliptic curves, were believed to have much lower com-
munication complexity than protocols based on other
cryptographic techniques.

In comparison to the original OT-based PSI protocol
of [22], OT-Phasing reduces the communication for all
combinations of elements and bit-lengths by factor 2.5 -
4. We also observe that OT-Phasing reduces the impact
when performing PSI on elements of longer bit-length.
In fact, it even has a lower communication for σ = 128
than the original OT-based PSI protocol has for σ = 32.

Communication (Tab. 8) The amount of communica-
tion performed during protocol execution is often more
limiting than the required computation power, since the
latter can be scaled up more easily by using more ma-
chines. The naive hashing approach has the lowest com-
munication among all protocols, followed by the server-
aided solution of [15]. Among the secure two-party PSI
protocols, the DH-based ECC protocol of [18] has the
In the setting for n = 224 el-
lowest communication.
ements of short bit-length σ = 32 bit, our OT-Phasing
protocol nearly achieves the same complexity as the
DH-based ECC protocol, which is due to the use of

8.2.2 Experiments with Different Input Sizes

For examining the setting where the two parties have
different input sizes, we set n1 ∈ {216,220,224} and
n2 ∈ {28,212} and run the protocols on all combinations
such that n2 (cid:19) n1. Note that we excluded the origi-
nal OT-based PSI protocol of [22] from the compari-
son, since the bin size maxβ becomes large when β (cid:19) n
and the memory requirement when padding all bins to
maxβ elements quickly exceeded the available memory.
In this setting, unlike the equal input sizes experiments
in §8.2.1, we use h = 2 hash functions instead of h = 3,

528  24th USENIX Security Symposium 

USENIX Association

14

Setting
Protocol

Naive Hashing(∗) §3.1
Server-Aided(∗) [15]
DH-based ECC [18]
OT-Phasing §6
Bit-length σ = 32
Bit-length σ = 64
Bit-length σ = 128

n1 = 216
33
74
28,387

360
555
571

n2 = 28
n1 = 220
464
680
421,115

906
1,506
1,942

LAN

n1 = 224
7,739
8,935
6,848,215

9,465
15,789
21,843

n1 = 216
35
75
29,810

369
581
649

n2 = 212
n1 = 220
466
696
422,712

2,949
6,146
7,291

n1 = 224
7,836
8,965
6,849,534

12,634
22,368
31,932

WAN

n2 = 28

n1 = 216
560
629
112,336

n1 = 220
2,775
2,923
1,743,400

n2 = 212

n1 = 216
562
731
111,642

n1 = 220
2,797
2,951
1,753,595

2,139
3,349
3,352

4,780
6,879
7,999

3,143
3,923
4,391

11,399
20,345
23,209

Table 9: Run-time in ms for PSI protocols with n2 (cid:30) n1 elements. (Protocols with (∗) are in a different security model.)

Protocol

Naive Hashing(∗) §3.1
Server-Aided(∗) [15]
DH-based ECC [18]
OT-Phasing §6
Bit-length σ = 32
Bit-length σ = 64
Bit-length σ = 128

n1 = 216
0.5
1.0
2.5

1.1
1.1
1.1

n2 = 28
n1 = 220
8.5
16.0
40.5

18.1
18.1
18.2

n1 = 224
144.0
256.0
656.0

288.1
288.1
288.2

n1 = 216
0.5
1.1
2.7

2.0
3.2
3.5

n2 = 212
n1 = 220
9.0
16.1
41.1

18.9
20.1
20.4

n1 = 224
152.0
256.1
664.1

Asymptotic [bit]

n1(cid:31)

(n1 + n2 +|X ∩Y|)κ
(n1 + n2)ϕ + n1(cid:31)

320.9
322.1
322.7

4.8n2κ((cid:27)
4.8n2κ((cid:27)
4.8n2κ((cid:27)

8

σ−(cid:25)log2(2.4n2)(cid:24)
σ−(cid:25)log2(2.4n2)(cid:24)
σ−(cid:25)log2(2.4n2)(cid:24)

8

8

(cid:23)) +2n 1(cid:31)
(cid:23)) +2n 1(cid:31)
(cid:23)) +2n 1(cid:31)

Table 10: Communication in MB for special purpose PSI protocols with n2 (cid:30) n1 elements. (cid:31) = λ + log2(n1) +
log2(n2). Assuming intersection of size 1/2 · n2 for the TTP-based protocol. (Protocols with (∗) are in a different
security model.)

since this results in less total computation and commu-
nication (cf. §6.2). Since we use h = 2 hash functions,
we also increase the number of bins from 1.2n2 to 2.4n2.
Furthermore, we do not use a stash for our OT-Phasing
protocol with different input sizes, since the stash would
greatly increase the overall communication. However,
not using a stash reveals some information on P2’s set
(cf. §7). We show how to secure our protocol at a much
lower cost by increasing the number of bins in the full
version [21].

Run-Time (Tab. 9) Similar to the results for equal set
sizes, the naive hashing protocol is the fastest protocol
for all parameters. The server-aided protocol of [15]
is the second fastest protocol but it scales better than
the naive hashing protocol for increasing number of ele-
ments. The best scaling protocol is our OT-Phasing pro-
tocol. It achieves the same performance as the server-
aided protocol for n2 = 28, n1 = 224 with short bit-length
σ = 32. For n1 = 224 its run-time is at most twice that of
the server-aided protocol in both network settings.

When switching to the WAN setting, the run-times of
all protocols are increased by a factor 4-6 while the rela-
tive performance between the protocols remains similar,
analogously to the equal set size experiments.

aided protocol of [15] and has only two times the com-
munication of the naive hashing protocol for all bit-
lengths. Furthermore, our OT-Phasing protocol requires
a factor of 2-3 less communication than the DH-based
ECC protocol of [18] for nearly all parameters. The low
communication of our OT-Phasing protocol for unequal
set sizes is due to the low number of OTs performed.

Acknowledgements: We thank Elaine Shi and the
anonymous reviewers of USENIX Security 2015 for
their helpful comments. This work was supported by the
European Union’s 7th Framework Program (FP7/2007-
2013) under grant agreement n. 609611 (PRACTICE)
and via a Marie Curie Career Integration Grant, by
the DFG as part of project E3 within the CRC 1119
CROSSING, by the German Federal Ministry of Educa-
tion and Research (BMBF) within EC SPRIDE, by the
Hessian LOEWE excellence initiative within CASED,
by a grant from the Israel Ministry of Science and Tech-
nology (grant 3-9094), by a Magneton grant of the Israeli
Ministry of Economy, by the Israel Science Foundation
(Grant No. 483/13), and by the Israeli Centers of Re-
search Excellence (I-CORE) Program (Center No. 4/11).

References

Communication (Tab. 10) As expected,
the naive
hashing solution again has the lowest communica-
tion overhead. Surprisingly, our OT-Phasing protocol
achieves nearly the same communication as the server-

[1] Y. Arbitman, M. Naor, and G. Segev. Backyard
cuckoo hashing: Constant worst-case operations
with a succinct representation. In FOCS’10, pages
787–796. IEEE, 2010.

USENIX Association  

24th USENIX Security Symposium  529

15

[2] G. Asharov, Y. Lindell, T. Schneider,

and
M. Zohner. More efﬁcient oblivious transfer
and extensions for faster secure computation.
In
CCS’13, pages 535–548. ACM, 2013.

[3] E. De Cristofaro and G. Tsudik. Practical private
set intersection protocols with linear complexity.
In FC’10, volume 6052 of LNCS, pages 143–159.
Springer, 2010.

[4] E. De Cristofaro and G. Tsudik. Experimenting
with fast private set intersection. In TRUST’12, vol-
ume 7344 of LNCS, pages 55–73. Springer, 2012.

[5] D. Demmler, T. Schneider, and M. Zohner. ABY
- A framework for efﬁcient mixed-protocol secure
two-party computation. In NDSS’15. The Internet
Society, 2015.

[6] M. Dietzfelbinger, A. Goerdt, M. Mitzenmacher,
Tight
A. Montanari, R. Pagh, and M. Rink.
thresholds for cuckoo hashing via XORSAT.
In
ICALP’10, volume 6198 of LNCS, pages 213–225.
Springer, 2010.

[7] C. Dong, L. Chen, and Z. Wen. When private set
intersection meets big data: An efﬁcient and scal-
able protocol. In CCS’13, pages 789–800. ACM,
2013.

[8] S. Even, O. Goldreich, and A. Lempel. A random-
ized protocol for signing contracts. Communmuni-
cations of the ACM, 28(6):637–647, 1985.

[9] M. J. Freedman, C. Hazay, K. Nissim, and
set-intersection with
In Journal of Cryptol-

B. Pinkas.
Efﬁcient
simulation-based security.
ogy, pages 1–41. Springer, October 2014.

[10] M. J. Freedman, K. Nissim, and B. Pinkas. Efﬁ-
cient private matching and set intersection. In EU-
ROCRYPT’04, volume 3027 of LNCS, pages 1–19.
Springer, 2004.

[11] O. Goldreich, S. Micali, and A. Wigderson. How to
play any mental game or a completeness theorem
for protocols with honest majority.
In STOC’87,
pages 218–229. ACM, 1987.

[12] Y. Huang, D. Evans, and J. Katz. Private set in-
tersection: Are garbled circuits better than custom
protocols? In NDSS’12. The Internet Society, 2012.

[13] B. A. Huberman, M. Franklin, and T. Hogg. En-
hancing privacy and trust in electronic communi-
ties. In EC’99, pages 78–86. ACM, 1999.

[14] S. Jarecki and X. Liu. Efﬁcient oblivious pseu-
dorandom function with applications to adaptive
OT and secure computation of set intersection. In
TCC’09, volume 5444 of LNCS, pages 577–594.
Springer, 2009.

[15] S. Kamara, P. Mohassel, M. Raykova,

and
S. Sadeghian. Scaling private set intersection to
billion-element sets.
In FC’14, volume 8437 of
LNCS, pages 195–215. Springer, 2014.

[16] A. Kirsch, M. Mitzenmacher, and U. Wieder. More
robust hashing: Cuckoo hashing with a stash. SIAM
Journal of Computing, 39(4):1543–1561, 2009.

[17] V. Kolesnikov and R. Kumaresan.

Improved
OT extension for transferring short secrets.
In
CRYPTO’13 (2), volume 8043 of LNCS, pages 54–
70. Springer, 2013.

[18] C. Meadows.

A more efﬁcient cryptographic
matchmaking protocol for use in the absence of
a continuously available third party.
In S&P’86,
pages 134–137. IEEE, 1986.

[19] R. Pagh and F. F. Rodler. Cuckoo hashing. In Euro-
pean Symposium on Algorithms (ESA’01), volume
2161 of LNCS, pages 121–133. Springer, 2001.

[20] R. Pagh and F. F. Rodler. Cuckoo hashing. Journal

of Algorithms, 51(2):122–144, 2004.

[21] B. Pinkas, T. Schneider, G. Segev, and M. Zohner.
Phasing: Private set intersection using permutation-
based hashing. Cryptology ePrint Archive, Re-
port 2015/634, 2015. http://eprint.iacr.or
g/2015/634.

[22] B. Pinkas, T. Schneider, and M. Zohner. Faster
private set intersection based on OT extension.
In USENIX Security Symposium, pages 797–812.
USENIX, 2014.

[23] M. Raab and A. Steger. “Balls into bins” - a simple
and tight analysis. In RANDOM’98, volume 1518
of LNCS, pages 159–170. Springer, 1998.

[24] X. Shaun Wang, C. Liu, K. Nayak, Y. Huang, and
E. Shi.
iDASH secure genome analysis competi-
tion using ObliVM. Cryptology ePrint Archive,
Report 2015/191, 2015. http://eprint.iacr.
org/2015/191.

[25] A. C. Yao. How to generate and exchange secrets.

In FOCS’86, pages 162–167. IEEE, 1986.

530  24th USENIX Security Symposium 

USENIX Association

16

