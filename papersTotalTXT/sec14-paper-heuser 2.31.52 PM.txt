ASM: A Programmable Interface for  

Extending Android Security

Stephan Heuser, Intel CRI-SC at Technische Universität Darmstadt; Adwait Nadkarni and 

William Enck,  North Carolina State University; Ahmad-Reza Sadeghi, Technische Universität 

Darmstadt and Center for Advanced Security Research Darmstadt (CASED)

https://www.usenix.org/conference/usenixsecurity14/technical-sessions/presentation/heuser

This paper is included in the Proceedings of the 23rd USENIX Security Symposium.August 20–22, 2014 • San Diego, CAISBN 978-1-931971-15-7Open access to the Proceedings of  the 23rd USENIX Security Symposium is sponsored by USENIXASM: A Programmable Interface for Extending Android Security

Stephan Heuser∗

stephan.heuser@trust.cased.de
Intel CRI-SC at TU Darmstadt

Adwait Nadkarni*
apnadkar@ncsu.edu

North Carolina State University

William Enck

enck@cs.ncsu.edu

North Carolina State University

Ahmad-Reza Sadeghi

ahmad.sadeghi@trust.cased.de

TU Darmstadt / CASED

Abstract

Android, iOS, and Windows 8 are changing the applica-
tion architecture of consumer operating systems. These
new architectures required OS designers to rethink secu-
rity and access control. While the new security archi-
tectures improve on traditional desktop and server OS
designs, they lack sufﬁcient protection semantics for dif-
ferent classes of OS customers (e.g., consumer, enter-
prise, and government). The Android OS in particular
has seen over a dozen research proposals for security
enhancements. This paper seeks to promote OS secu-
rity extensibility in the Android OS. We propose the An-
droid Security Modules (ASM) framework, which pro-
vides a programmable interface for deﬁning new refer-
ence monitors for Android. We drive the ASM design by
studying the authorization hook requirements of recent
security enhancement proposals and identify that new
OSes such as Android require new types of authorization
hooks (e.g., replacing data). We describe the design and
implementation of ASM and demonstrate its utility by
developing reference monitors called ASM apps. Finally,
ASM is not only beneﬁcial for security researchers. If
adopted by Google, we envision ASM enabling in-the-
ﬁeld security enhancement of Android devices without
requiring root access, a signiﬁcant limitation of existing
bring-your-own-device solutions.

1 Introduction

Consumer operating systems are changing. Android,
iOS, and Windows 8 place a high priority on the user-
application experience. They provide new abstractions
for developing user-applications: applications ﬁll the
screen;
they have complex lifecycles that respond to
user and system events; and they use semantically rich
OS provided application programming interfaces (APIs)

∗These authors contributed equally to this work.

such as “get location,” “take picture,” and “search ad-
dress book.” The availability of these semantically rich
OS APIs vastly simpliﬁes application development, and
has led to an explosive growth in the number and diver-
sity of available applications.

These functional changes caused OS designers to re-
think security. The new application abstractions both en-
able and necessitate assigning each user application to a
unique protection domain, rather than executing all user
applications with the user’s ambient authority (the norm
in traditional OSes such as Windows and UNIX). By de-
fault, each application’s protection domain is small, often
containing only the OS APIs deemed not to be security
sensitive and the ﬁles it creates. The application must be
granted capabilities to access the full set of semantically
rich OS APIs. This security model provides a better ap-
proximation of least privilege, which limits both the im-
pact of an exploited application, as well as the authority
granted to a Trojan. However, how and when to grant
these privileges has been the topic of much debate [16].
For the last several years, the security research com-
munity has contributed signiﬁcant discourse on the right
security architecture for these new operating systems.
Android has been the focus of this discourse, mostly due
to its open source foundation, widespread popularity for
mobile devices, and the emergence of malware targeting
it.
In the relatively short period of time since the An-
droid platform’s initial release in 2008, there have been
more than a dozen proposals for new Android security
architectures [15, 24, 14, 23, 10, 7, 8, 37, 6, 19, 18, 12,
9, 22, 29]. As we discuss in this paper, while these secu-
rity architecture proposals have very diverse motivations,
their implementations often share hook placements and
enforcement mechanisms.

The primary goal of this paper is to promote OS secu-
rity extensibility [33] in the Android platform. History
has shown that simply providing type enforcement, in-
formation ﬂow control, or capabilities does not meet the
demands of all potential OS customers (e.g., consumers,

USENIX Association  

23rd USENIX Security Symposium  1005

enterprise, government). Therefore, an extensible OS se-
curity interface must be programmable [33]. In short, we
seek to accomplish for Android what the LSM [34] and
TrustedBSD [32] frameworks have provided for Linux
and BSD, respectively. What makes this task interesting
and meaningful to the research community is the pro-
cess of determining the correct semantics of authoriza-
tion hooks for this new OS architecture.

In this paper, we propose the Android Security Mod-
ules (ASM) framework, which provides a set of autho-
rization hooks to build reference monitors for Android
security. We survey over a dozen recent Android secu-
rity architecture proposals to identify the hook seman-
tics required of ASM. Of particular note, we identify the
need to (1) replace data values in OS APIs, and (2) allow
third-party applications to deﬁne new ASM hooks. We
design and implement an open source version of ASM
within Android version 4.4 and empirically demonstrate
negligible overhead when no security module is loaded.
ASM fulﬁlls a strong need in the research community. It
provides researchers a standardized interface for security
architectures and will potentially lead to ﬁeld enhance-
ment of devices without modifying the system ﬁrmware
(e.g., BYOD), if adopted by Google.

This paper makes the following contributions:
• We identify the authorization hook semantics re-
quired for new operating systems such as Android.
The Android OS is responsible for enforcing more
than just UNIX system calls. Android includes se-
mantically rich OS APIs and new application lifecy-
cle abstractions that must be included in OS access
control. We also identify the need for authorization
hooks to replace data values and for third-party ap-
plications to introduce new authorization hooks.

• We design and implement the extensible Android Se-
curity Modules (ASM) framework. ASM brings OS
It allows mul-
security extensibility to Android.
tiple simultaneous ASM apps to enforce security
requirements while minimizing performance over-
head based on the required authorization hooks.

• We implement two example ASM apps to demon-
strate the utility of the ASM framework. ASM al-
lowed the fast development of useful example ASM
apps with functionalities similar to MockDroid [6]
and password protected apps.

Finally, we envision multiple ways in which ASM can
beneﬁt the security community. ASM currently provides
great value to researchers with the ability to modify the
source code of a device. It provides a modular interface
to deﬁne callbacks for a set of authorization hooks that
provide mediation of important protection events. As the
Android OS changes, only the ASM hook placements

need to change, eliminating the need to port each re-
search project to new versions. ASM can provide even
greater beneﬁt if it is adopted into the Android Open
Source Project (AOSP): ASM apps can be added without
source code modiﬁcation. Ultimately, we envision an in-
terface that allows enterprise IT and researchers to load
ASM apps on production phones without root access.

The remainder of this paper proceeds as follows. Sec-
tion 2 provides a short background on Android. Section 3
deﬁnes high level goals that underlie the ASM design.
Section 4 surveys recent work enhancing Android secu-
rity and identiﬁes a common set of authorization hook se-
mantics. Section 5 describes the ASM design. Section 6
evaluates the utility and performance of ASM. Section 7
highlights related work on OS security extensibility. Sec-
tion 8 concludes.

2 Background

The Android OS is based on a Linux kernel, but pro-
vides a substantially different application abstraction
than found in traditional Linux desktop and server dis-
tributions. Android applications are written in Java and
compiled into a special DEX bytecode that executes in
Android’s Dalvik virtual machine. Applications may op-
tionally contain native code components. Application
functionality is divided into components. Android de-
ﬁnes four types of components: activity, service, broad-
cast receiver, and content provider. The application’s
user interface is composed of a set of activity compo-
nents. Service components act as daemons, providing
background processing. Broadcast receiver components
handle asynchronous messages. Content provider com-
ponents are per-application data servers that are queried
by other applications.

Application components communicate with one an-
other using Binder interprocess communication (IPC).
Binder provides message passing (called parcels) and
thread management. In addition to data values, parcels
can pass references to other binder objects as well as ﬁle
descriptors. When an application holds a reference to a
service component binder object, it can execute remote
procedure calls (RPCs) for any methods deﬁned by that
service. Most of Android’s semantically rich OS APIs
are implemented as RPCs to OS deﬁned service com-
ponents. The OS also deﬁnes several content provider
components (e.g., address book) that are queried using
special RPC methods. It should be noted that while de-
velopers are encouraged to use Binder IPC, Android also
supports standard Linux IPC mechanisms, for example
domain sockets or pipes.

Applications often interface with Binder indirectly us-
ing intent messages. The intent message abstraction is
used for communication between activity and broadcast

1006  23rd USENIX Security Symposium 

USENIX Association

receiver components, as well as starting service compo-
nents. Intent messages can be addressed to implicit ac-
tion strings that are resolved by the Activity Manager
Service (AMS). Intent messages and action strings al-
low end users and OEMs to customize the applications
used to perform tasks. The AMS resolves the desired
target application and component, starting a new process
or thread if necessary.

Android enforces component security requirements
using permissions (i.e., text strings that represent capa-
bilities). Android deﬁnes a set of core permissions for
protecting OS resources and applications, but third-party
application developers can deﬁne new permissions that
are enforced using the same mechanisms as OS permis-
sions. Permissions are granted to applications on install
and stored in the Package Manager Service (PMS). An-
droid places authorization hooks (implemented as a fam-
ily of checkPermission() methods) in the AMS as well
as OS service component RPC methods. checkPermis-
sion() is called along with the process identiﬁer (PID) of
the caller and the appropriate permission string. Calling
checkPermission() invokes an RPC in the PMS, which re-
turns granted if the caller’s PID belongs to an application
that is granted the permission, and throws a security ex-
ception if it is denied. However, not all permissions are
enforced using checkPermission(). Permissions that con-
trol access to low-level capabilities are mapped to Linux
group identiﬁers (GIDs). Such capabilities include open-
ing network sockets and accessing the SDcard storage.
For these permissions, corresponding GIDs are assigned
to applications at installation time, and the kernel pro-
vides enforcement.
3 Design Goals
A secure operating system requires a reference moni-
tor [2]. Ideally, a reference monitor provides three guar-
antees: complete mediation, tamperpoofness, and ver-
iﬁability. We seek to provide a foundation for build-
ing reference monitors in Android. As with LSM [34],
the ASM only provides the reference monitor interface
hooks upon which authorization modules are built. Fur-
thermore, similar to the initial design of LSM, our ASM
design manually places hooks throughout Android.

We seek to design a programmable interface for build-
ing new security enhancements to the Android platform.
Our design is guided by the following goals.

G1 Generic authorization expressibility. We seek to
provide the reference monitor interface hooks nec-
essary to develop both prior and future security
enhancements for Android. Not all authorization
modules will use all hooks, and hooks may need
to be placed at different levels to obtain sufﬁcient
enforcement semantics.

G2 Ensure existing security guarantees.

Android
provides sandboxing guarantees to application
providers. Allowing third-parties to extend An-
droid’s security framework potentially breaks those
guarantees. Therefore, ASM’s reference moni-
tor interface hooks should only make enforcement
more restrictive (e.g., fewer permissions or less ﬁle
system access). Note that by only allowing more
restrictive enforcement, we lose expressibility (e.g.,
for capability models).

G3 Protect kernel integrity. As an explicit extension to
Goal G2, we must maintain kernel integrity. Some
authorization modules will require hooks within the
Linux kernel. We cannot provide the LSM inter-
face to third-parties without some controls. We ex-
plore several methods of exposing this functionality
in Section 5.4.5.

G4 Multiple authorization modules. While there have
been proposals for supporting multiple LSMs [27],
ofﬁcial support for multiple authorization modules
in Linux has not been adopted at the time of writing.
We see beneﬁt in allowing multiple ASM modules
(e.g., personal and enterprise) and seek to design
support for multiple authorization modules into the
design of ASM. Achieving multiple authorization
modules requires carefully designing the architec-
ture to address potential conﬂicts.

G5 Minimize resource overhead. When no authoriza-
tion module is loaded, ASM should have negligi-
ble impact on system resources (e.g., CPU perfor-
mance, energy consumption). Furthermore, given
the wide variety of authorization hook semantics,
we recognize that not all authorization modules will
require all hooks. Since some hooks have more
overhead than others, we seek to design ASM such
that different hooks can be enabled and disabled to
minimize overhead.

Threat Model: ASM assumes that the base Android OS
and services are trusted. That is, our trusted comput-
ing base (TCB) includes the Linux kernel, the AMS, the
PMS, and all OS service and content provider compo-
nents. We assume that third-party applications have com-
plete control over their process address spaces. That is,
any authorization hooks placed in framework code that
executes within the third-party application’s process is
untrusted. Finally, since third-party applications can in-
clude their own authorization hooks, they must be trusted
to mediate the protection events they deﬁne.
4 Authorization Hook Semantics
The underlying motivation of ASM is to provide a pro-
grammable interface to extend Android security. Re-

USENIX Association  

23rd USENIX Security Symposium  1007

Table 1: Classiﬁcation of authorization hook semantics required by Android security enhancements

System
MockDroid [6]
XManDroid [7]
TrustDroid [8]
FlaskDroid [9]
CRePE [10]
Quire [12]
TaintDroid [14]
Kirin [15]
IPC Inspection [18]
AppFence [19]
Aquifer [22]
APEX [23]
Saint [24]
SEAndroid [29]
TISSA [37]

Android

ICC

(cid:31)
(cid:31)
(cid:31)
(cid:31)
(cid:31)
(cid:31)

(cid:31)
(cid:31)
(cid:31)
(cid:31)
(cid:31)
(cid:31)

Package
Manager

(cid:31)
(cid:31)
(cid:31)
(cid:31)

(cid:31)

(cid:31)
(cid:31)
(cid:31)

(cid:31)
(cid:31)
(cid:31)

Sensors /
Phone Info

(cid:31)
(cid:31)

Fake
Data
(cid:31)

(cid:31)
(cid:31)

(cid:31)

(cid:31)

(cid:31)

(cid:31)

(cid:31)

(cid:31)

(cid:31)

System Content

Providers

(cid:31)

(cid:31)
(cid:31)

(cid:31)

(cid:31)

File
Access

(cid:31)
(cid:31)
(cid:31)

(cid:31)

(cid:31)
(cid:31)

(cid:31)

Network
Access

(cid:31)
(cid:31)
(cid:31)
(cid:31)

(cid:31)

(cid:31)
(cid:31)

(cid:31)

Third Party
Extension

(cid:31)

(cid:31)

cently, Google adopted the UNIX-level portion of the
SEAndroid [29] project into AOSP. However, Android
security is signiﬁcantly more complex than simply medi-
ating UNIX system calls. Nearly all application commu-
nication occurs through Binder IPC, which from a UNIX
perspective is an ioctl to /dev/binder. Mediating the
higher level application communication has been the fo-
cus of most Android security research. The goal of this
section is to explore these different proposals to identify
a common set of authorization hooks semantics. That is,
we seek to satisfy Goal G1 by surveying existing propos-
als to enhance Android security.

Academic and industry researchers have proposed
many different security enhancements to the Android
OS. These enhancements have a wide range of mo-
tivations. For example, Kirin [15] places constraints
on permissions of applications being installed. Frame-
works such as Saint [24], XManDroid [7] and Trust-
Droid [8] focus on mediating communication between
components in different applications. FlaskDroid [9] and
the aforementioned SEAndroid [29] project also medi-
ate component interaction as a part of their enforcement.
Aquifer [22] enforces information ﬂow control policies
that follow the user’s UI workﬂow. IPC Inspection [18]
and Quire [12] track Android intent messages through a
chain of applications to prevent privilege escalation at-
tacks. TaintDroid [14] and AppFence [19] dynamically
track privacy sensitive information as it is used within
an application. APEX [23] and CRePE [10] provide
ﬁne-grained permissions. TISSA [37], MockDroid [6],
and AppFence [19] allow ﬁne-grained policies as well as
allow the substitution of fake information into Android
APIs. While these proposals have diverse motivations,
many share authorization hook semantics.

Table 1 classiﬁes this prior work by authorization hook
semantics. Nearly all of the proposals modify Android’s
Activity Manager Service (AMS) to provide additional
constraints on Inter-Component Communication (ICC).

The Package Manager Service (PMS) is also frequently
modiﬁed to customize application permissions. Per-
missions are also occasionally customized by modify-
ing the interfaces to device sensors and system content
providers containing privacy sensitive information (e.g.,
address book). Several proposals also require authoriza-
tion hooks for ﬁle and network access, which are en-
forced in the Linux kernel.

The table also denotes two areas that are nonstandard
for OS reference monitors. The ﬁrst hook semantics is
the use of fake data. That is, instead of simply allowing
or denying a protected operation, the hook must mod-
ify the value that is returned. This third option is of-
ten essential to protecting user privacy while maintain-
ing usability. For example, the geographic coordinates
of the north pole, or maybe a coarse city coordinates can
be substituted for the devices actual location. Replacing
unique identiﬁers (e.g. IMEI or IMSI) to combat adver-
tising tracking is a further example. The second interest-
ing hook semantics is the inclusion of third-party hooks.
That is, a third-party application wishes the OS reference
monitor to help enforce its security goals.

Finally, TaintDroid [14] and AppFence [19] use ﬁne-
grained taint tracking. They modify Android’s Dalvik
environment to track information within a process. How-
ever, dynamic taint tracking has false negatives, which
may lead to access control circumvention.
It also in-
curs more performance overhead than may be tolerable
for some environments. In this work, we only consider
mediation at the process level. Therefore, TaintDroid
and AppFence cannot be built on top of ASM. However,
this does not preclude researchers from combining Taint-
Droid with ASM.
5 ASM Design
The authorization hooks identiﬁed in the previous sec-
tion describe semantically what to mediate, but not how
to mediate it. Existing Android security enhancements

1008  23rd USENIX Security Symposium 

USENIX Association

Access Control Callback
ASM Hook

ASM 1

ASM 2

...

ASM apps

Other 3rd 
party apps 

Applications

Activity  

Manager Service

System Content 

Providers

System Services 
(e.g. telephony, 

location)

ASM Bridge

ASM LSM

Android OS

Linux Kernel

Figure 1: ASM framework architecture

deﬁne hooks in different ways, not all of which provide
correct or complete mediation. ASM provides a refer-
ence monitor interface for building new reference moni-
tors. By doing so, ASM allows reference monitor devel-
opers to focus on their novel security enhancements and
not on placing hooks correctly. It also allows separate
scrutiny of authorization hook placement that beneﬁts all
reference monitors built on top of ASM.

Figure 1 shows the ASM framework architecture. Ref-
erence monitors are implemented as ASM apps. Each
ASM app registers for a unique set of authorization
hooks, specifying a callback for each. When a protected
operation occurs, ASM automatically invokes the call-
back in the ASM app. The ASM reference monitor inter-
face is contained within the ASM Bridge. In addition to
managing ASM apps, the ASM Bridge receives protec-
tion events from authorization hooks placed throughout
the Android OS. Since Android places functionality in
multiple userspace processes, authorization hooks only
notify the ASM Bridge if the hook is explicitly enabled.
ASM also supports authorization hooks within the Linux
kernel. To achieve kernel authorization, a special ASM
LSM performs upcalls to the ASM Bridge, again only
doing so for hooks explicitly enabled.

This section details the design of the ASM framework.
We use the following terminology. A protection event
is an OS event requiring access control. Authorization
hooks are placed throughout the Android OS, which in-
voke a callback in the ASM Bridge. The ASM Bridge de-
ﬁnes reference monitor interface hooks, for which ASM
apps register hook callbacks. Finally, we frequently refer
to the ASM framework as a whole simply as ASM.

5.1 ASM Apps
Reference monitors are built as ASM apps. They are
developed using the same conventions as other Android
applications. The core part of an ASM app is a service
component that implements the reference monitor hook
interface provided by ASM. There are three main func-
tionalities that must be provided within this service. Fi-
nally, the registration interface itself is protected by An-
droid permissions.

ASM App Registration: An ASM app must register it-
self with the ASM Bridge after it is installed. The time
of registration depends on logic in the speciﬁc ASM app.
For example, the ASM app could register itself automat-
ically after install, or it could provide a user interface to
enable and disable it. When the ASM Bridge receives the
registration, it updates its persistent conﬁguration. To ac-
tivate the ASM app, the device must reboot. We require a
reboot to ensure ASM apps receive all protection events
since boot, which may impact their protection state.
Hook Registration: The ASM app service component is
started by ASM during the boot process. At this time, the
ASM app registers for reference monitor interface hooks
for which it wishes to receive callbacks. Different hooks
incur different overheads. ASM only enables a reference
monitor hook if it is registered by an ASM app. There-
fore, ASM app developers should only register for the
hooks required for complete mediation. Finally, if the
ASM registers for hooks deﬁned by a third-party appli-
cation (Section 5.4.4), the application developer and the
ASM app developer must agree on naming conventions.
Handling Hook Callbacks: Once an ASM app regis-
ters for a reference monitor interface hook, it will re-
ceive a callback whenever the corresponding protection
event occurs. The information provided in the callback is
hook-speciﬁc. The ASM app returns the access control
decision to the ASM Bridge. As discussed in Section 5.3,
some hooks allow the callback to replace data values.
Finally, similar to registration for third-party hooks, the
ASM app developer must coordinate with the application
developer for information passed to the callback.
Registration Protection: Reference monitors are highly
privileged. While ASM does not allow an ASM
app to override existing Android security protections
(Goal G2), ASM must still protect the ability to re-
ceive callbacks. ASM protects callbacks using An-
droid’s existing permission model. It deﬁnes two permis-
sions: REGISTER ASM and REGISTER ASM MODIFY.
The ASM Bridge ensures that an ASM app has the
REGISTER ASM permission during both ASM app reg-
istration and hook registration. Finally, since replacing
data values in an access control callback has greater se-
curity implications, the ASM Bridge ensures the ASM
app has the REGISTER ASM MODIFY permission if it
registers for a hook that allows data modiﬁcation. This
allows easy ASM app inspection to identify its abilities.
ASM App Deployment: How the ASM permissions are
granted has a signiﬁcant impact on the practical security
of devices. Previous studies [17] have demonstrated that
end users frequently do not read or understand Android’s
install time permissions. Therefore, malware may at-
tempt to exploit user comprehension of permissions and
gain ASM app privileges. To some extent, this threat is

USENIX Association  

23rd USENIX Security Symposium  1009

mitigated by our goal to ensure existing security guaran-
tees (Goal G2). Different ASM app deployment mod-
els can also mitigate malware. In the use case where re-
searchers change AOSP source code, these permissions
can be bound to the ﬁrmware signing key, thereby only
allowing the researchers’ ASM apps to be granted ac-
cess. In the case where ASM is deployed on production
devices, ASM could follow the security model used by
device administration API. That is, a secure setting that
is only modiﬁable by users would enable whether ASM
apps can be used. An alternative is to use a model simi-
lar to Android’s “Unknown sources” setting for installing
applications. That is, unless a secure user setting is se-
lected, only Google certiﬁed ASM apps can be installed.

5.2 ASM Bridge
The ASM Bridge 1) provides the reference monitor in-
terface, and 2) coordinates protection events that occur in
authorization hooks placed throughout the Android OS,
as well as third-party applications. As discussed in Sec-
tion 5.1, ASM apps notify the ASM Bridge of their exis-
tence via an ASM app registration followed by individ-
ual hook registrations. We now discuss several reference
monitor interface considerations.
Per-Hook Activation: All reference monitor interface
hooks are deactivated by default. Each authorization
hook maintains an activation state variable that deter-
mines whether or not the ASM Bridge is notiﬁed of
protection events. This approach eliminates unneces-
sary IPC and therefore improves performance (Goal G5)
when no ASM app requires a speciﬁc hook. Likewise,
this approach allows ASM to achieve negligible over-
heard when no ASM apps are loaded (see Section 6.2).

When an ASM app registers a callback for a deacti-
vated hook, the ASM Bridge activates the hook by noti-
fying the corresponding authorization hook implemen-
tation. ASM maintains a list of active hooks in each
OS component (e.g., OS service component, OS con-
tent provider component). When a protection event oc-
curs, the OS component creates an access control bundle
that is sent to the ASM Bridge. When the ASM Bridge
receives the access control bundle for a hook, it is for-
warded to each ASM app that registered for the hook.
Similarly, the ASM LSM in the kernel (Section 5.4.5)
maintains a separate activation state variable per hook
and performs an upcall for each protection event.
Callback Timeouts: The ASM Bridge is notiﬁed of pro-
tection events via synchronous communication. Autho-
rization hooks in userspace communicate with the ASM
Bridge using Binder IPC, and the ASM LSM uses syn-
chronous upcalls, as described in Section 5.4.5. The
ASM Bridge then uses synchronous Binder IPC to in-
voke all ASM app callbacks for the hook corresponding

1

hook_1

4

allow/deny

+ modied data

ASM 
Bridge

2

hook_1
allow/deny

3

hook_1_mod
modied data

ASM 1

ASM 2

1.
2.
3.
4.

ASM Bridge receives a callback.
The normal hook is invoked.
The modied data hook (i.e. mod) is invoked. 
ASM Bridge returns the result for the initial callback. 
Figure 2: ASM Hook Invocation

to the protection event. If the ASM app callback imple-
mentation is buggy, the authorization hook may stall exe-
cution. Therefore, ASM has the ability to set timeouts on
callback execution. If a timeout occurs, the ASM Bridge
conservatively assumes access is denied.
Master Policy: ASM supports multiple simultaneous
ASM apps (Goal G4). This goal is motivated by multi-
stakeholder scenarios, e.g. users, administrators, and
device manufacturers installing ASM apps on a device.
When more than one ASM app is active, a reconciliation
strategy is required to handle potential conﬂicts between
access control decisions. The correct conﬂict resolution
strategy is highly use-case speciﬁc. Therefore, providing
a general solution is infeasible [9].

ASM addresses this problem using a master policy
that deﬁnes policy conﬂict reconciliation. For our im-
plementation and evaluation, we use a consensus strat-
egy. That is, all active ASM apps must grant an access
control decision for the action to be allowed. Similar to
FlaskDroid [9], the master policy can be easily modiﬁed
to support other conﬂict resolution strategies [26, 21].
For example, a priority-based resolution policy hierar-
chically orders ASM apps, and a voting policy allows an
action if a speciﬁed threshold of ASM apps grant it.
5.3 Callbacks Modifying Data
Before discussing the reference monitor interface hooks
provided by ASM, we must describe one last concept.
While most ASM apps require a simple allow/deny ac-
cess control interface, some may beneﬁt from the abil-
ity to modify data values. For example, MockDroid [6]
modiﬁes values (e.g., IMEI, location) returned by OS
APIs before they are sent to applications. ASM supports
data modiﬁcations by providing a special hook type.

Each reference monitor interface hook that poten-
tially requires data replacement is split into two vari-
ants: 1) normal, which allows the corresponding call-
back to simply allow or deny the event, and 2) modify,
which allows the corresponding callback to modify the
value returned by the OS API or content provider, in ad-
dition to specifying allow or deny. As mentioned in Sec-
tion 5.1, modifying data has a greater security sensitivity,

1010  23rd USENIX Security Symposium 

USENIX Association

1 // Callback received by the ASM Bridge:
2 int start_act(inout Intent intent, in String
resolvedType, in ActivityInfo activity, int
requestCode, int callingPid, int callingUid);

3 // Callback to individual ASMs (No modify data):
4 int start_act(in Intent intent, in String

resolvedType, in ActivityInfo activity, int
requestCode, int callingPid, int callingUid);
5 // Callback to individual ASMs (Modify data):
6 int start_act_mod(in Intent intent, inout Bundle
extras, in String resolvedType, in ActivityInfo
activity, int requestCode, int callingPid, int
callingUid);

Listing 1: Example Callback Prototypes Modifying Data

and therefore registration of a modify callback requires
the REGISTER ASM MODIFY permission.

Figure 2 shows how the ASM Bridge manages normal
and modify hooks. To reduce the overhead of handling
authorization hooks, the ASM Bridge is only notiﬁed
once per protection event. The ASM Bridge then man-
ages the normal and modify versions, returning the ac-
cess control decision and modiﬁed data value (if needed)
to the authorization hook. Additionally, the ASM Bridge
invokes all of the normal callbacks before the modify
versions. This approach allows a performance improve-
ment if a consensus master policy is used (Section 5.2).
In this case, if a normal hook denies access, the modify
callbacks do not need to be called.

Example 1: Listing 1 explains this distinction further via
example. The listing shows the callback prototypes for
the start activity protection event. The ﬁrst pro-
totype shown, start act(), is the ASM Bridge call-
back used by the authorization hook in the Activity Stack
subsystem of Android’s AMS. This hook is invoked after
intent resolution but before the chosen activity compo-
nent is started. The hook includes 1) the intent message
from the caller, 2) information about the activity to be
started, 3) the caller’s identity, and 4) additional infor-
mation for the current event. By marking intent as inout
(a directive deﬁned in the Android Interface Deﬁnition
Language), the ASM Bridge can modify it.

The ASM Bridge splits start act() into the nor-
mal and modify versions. To ensure restrictive enforce-
ment, ASM apps can modify only the extras ﬁeld sup-
plied by the caller. It cannot modify information that has
been reviewed by the user or the OS, such as the action
string or the target activity. To ensure this restriction, the
ASM Bridge makes the intent immutable, but supplies a
mutable Bundle of extras extracted from the intent to the
ASMs registered for the modify data hook. The modi-
ﬁed extras received by the ASM Bridge are then set back
to the intent before the initial callback from the Activ-
ity Stack to the ASM Bridge returns.

1 // Callback received by the ASM Bridge:
2 int resolveActivity_mod(inout List<ResolveInfo>

resolvedList, in String resolvedtype, int userId,
inout Intent intent, int callingPid, int callingUid);

3 // Callback to individual ASM apps (Modify data):
4 int resolveActivity_mod(inout List<ResolveInfo>

resolvedList, in String resolvedtype, int userId, in
Intent intent, int callingPid, int callingUid, inout
Bundle extras);

Listing 2: Resolve Activity Hook

5.4 Hook Types

ASM provides a reference monitor interface for autho-
rization hooks placed throughout the Android OS. We
now describe ﬁve general categories of hooks: 1) lifecy-
cle hooks, 2) OS service hooks, 3) OS content provider
hooks, 4) third-party app hooks, and 5) LSM hooks.

5.4.1 Lifecycle Hooks

ASM provides reference monitor hooks for component
lifecycle events in the Activity Manager Service, the
AMS subsystems, and the Package Manager Service.
Hooks in this category include: resolving intents, start-
ing activities and services, binding to services, dynamic
registration of broadcast receivers, and receiving broad-
cast intents. We demonstrate the lifecycle hook category
with the following example. Note that Example 1 is also
a lifecycle hook.
Example 2: The resolve activity protection
event occurs within the Package Manager Service. The
ASM authorization hook for resolve activity is
placed in the PMS after the intent has been resolved by
the OS, but before a chooser with the resolved activi-
ties is presented to the user. This hook is motivated by
systems such as Saint [24] and Aquifer [22], which re-
ﬁne the list of resolved applications based on access con-
trol policies. Note that reﬁning the chooser list requires
data modiﬁcation, and therefore, resolve activity
is one of few hooks that only provide a modify version.
Listing 2 shows the callback prototypes deﬁned for
resolve activity. The callback received by the
ASM Bridge from the Android OS contains the list of re-
solved components. The ASM Bridge then executes an
RPC to the ASM app callbacks registered for this hook.
The RPC provides a modiﬁable resolved component list
and Bundle extras. The other parameters are immutable.
It is important to prevent the ASM from adding new
apps to the list, thereby overriding the OS’s restrictions
(Goal G2). Therefore, we compute the set intersection of
the original list and the modiﬁed list, and return the re-
sult to the authorization hook. When multiple ASM apps
register for this hook, the ASM Bridge calls the hook
callback for each ASM app, providing the modiﬁed data
from the previous invocation as input.

USENIX Association  

23rd USENIX Security Symposium  1011

5.4.2 OS Service Hooks

Lifecycle hooks include mediation for inter-component
communication using intent messages. However, ASM
apps also require mediation for OS APIs providing func-
tionality such as getting the geographic location and tak-
ing pictures. Android implements this functionality in
different service components designated as system ser-
vices, e.g., location and telephony services.

ASM uses Android’s AppOps subsystem to place the
authorization hooks for many OS service hooks. AppOps
is a very recent addition to AOSP. While there have been
several popular media stories of hobbyist developers us-
ing AppOps to control per-application permissions, Ap-
pOps remains largely undocumented and is not yet avail-
able for public use. Based on our code inspection, Ap-
pOps appears to be an effort by Google to provide more
ﬂexible control of permission related events. Conceptu-
ally, AppOps is an Android security enhancement and
could be implemented as an ASM app. We discuss Ap-
pOps as an ASM app further in Section 7.

The ASM authorization hooks for services use the Ap-
pOps syntax. AppOps deﬁnes opcodes for different op-
erations, e.g., OP READ CONTACTS or OP SEND SMS.
To identify the application performing an operation, the
Linux uid and the package name of the application are
used. ASM uses a single authorization hook in AppOps
to call the ASM Bridge. The ASM Bridge decodes the
opcode and translates it into an ASM hook.

AppOps supports graceful enforcement. That is, it
returns empty data instead of throwing a Security Ex-
ception wherever possible (e.g., in Cursors). As a re-
sult, apps do not crash when they are denied access
to resources. On the other hand, AppOps does not
allow data values to be modiﬁed at runtime. There-
fore, ASM adds speciﬁc data modiﬁcation hooks. We
also needed to extend AppOps with several hooks for
privacy sensitive operations (e.g., getDeviceId(),
onLocationChanged()). We now discuss two
examples,
including both regular AppOps hooks and
ASM’s data modiﬁcation hooks.
Example 3: Listing 3 shows the callback proto-
type for
the AppOps hook for sending an SMS
(OP SEND SMS). The ASM Bridge receives the generic
appOpsQuery() callback and translates the opcode
to the sendSms() hook. ASM apps registered for the
sendSms() hook receive a callback whenever an SMS
message is sent.
Example 4: Listing 4 shows the data modiﬁcation call-
back prototype for the getDeviceId() OS API call
in the PhoneSubInfo (i.e., telephony) service. The ASM
Bridge receives a callback from the authorization hook
and executes the getDeviceId mod() callback in
ASM apps. ASM apps receiving this callback can re-

1 // Callback received by the ASM Bridge:
2 int appOpsQuery(int opcode, int callingUid, String

packageName);

3 // Here, opcode = OP_SEND_SMS
4 // Callback to individual ASMs:
5 int sendSms(int callingUid, String packageName);

Listing 3: AppOps Hook for Sending SMS

1 // Callback received by the ASM Bridge:
2 int getDeviceId(int callingUid, out String[]

device_ids);

3 // Callback to individual ASMs (Modify data):
4 int getDeviceId_mod(int callingUid, out String[]

device_ids);

Listing 4: getDeviceId Hook

turn deny or allow. If the return value is allow, the ASM
app can also place a custom value in the ﬁrst index of
the device ids array. This value will be sent to the
Android application that invoked getDeviceId(), in-
stead of the real device ID.

5.4.3 Content Provider Hooks

Content provider components are daemons that provide a
relational database interface for sharing information with
other applications. The ASM Bridge receives callbacks
from the OS content provider components (e.g., Calen-
dar, Contacts, and Telephony). Separate hooks are re-
quired for the insert, update, delete and query functions.
Authorization hooks for insert, update and delete must
be invoked before the action is performed, to preserve
the integrity of the provider’s data. In contrast, the query
function’s hook is invoked after the execution, to allow
ﬁltering of the returned data.

The content provider query RPC returns a database
Cursor object. The Cursor object not a parcelable type,
and therefore the entire query response is not returned to
the caller in a single Binder message. Therefore, ASM
apps cannot ﬁlter the query. To account for this, we ex-
tract the Cursor contents into a parcelable ASMCursor
wrapper around a CursorWindow object to include in the
callback to the ASM Bridge.

The following example demonstrates the query inter-
face. ASM only provides normal (i.e., no data modiﬁca-
tion) hooks for insert, delete, and update.
Example 5: Listing 5 shows the callback prototypes
for the CallLogProvider OS content provider. The
ASM Bridge receives the original query and the result
wrapped in an ASMCursor. The callback is split into
normal and modify hook variants. ASM apps that regis-
ter for the normal hook get read access to the query and
the result. ASM apps registered for the data modify hook
can also modify the ASMCursor object. Both the hooks
return allow and deny decisions via the return value.

Finally, we note that this use of a CursorWindow ob-
ject to copy the entire content provider query response

1012  23rd USENIX Security Symposium 

USENIX Association

1 // Callback received by the ASM Bridge:
2 int callLogQuery(inout ASMCursor cursor, in Uri uri,

in String[] projection, in String selection, in
String[] selectionArgs, in String sortOrder, int
callingUid, int callingPid);

3 // Callback to individual ASMs (No modify data):
4 int callLogQuery(in ASMCursor cursor, in Uri uri, in

String[] projection, in String selection, in String[]

selectionArgs, in String sortOrder, int callingUid,

int callingPid);

5 // Callback to individual ASMs (Modify data):
6 int callLogQuery_mod(inout ASMCursor cTemp, in Uri

uri, in String[] projection, in String selection, in
String[] selectionArgs, in String sortOrder, int
callingUid, int callingPid);

Listing 5: CallLogProvider query hook

1 // Callbacks received by the ASM Bridge:
2 int hook_handler(in String name, in Bundle b);
3 int hook_handler_mod(in String name, inout Bundle b);
4 // Callback to individual ASMs (No modify data):
5 int hook_handler(in String name, in Bundle b);
6 // Callback to individual ASMs (Modify data):
7 int hook_handler_mod(in String name, inout Bundle b);

Listing 6: Third Party Hooks

into the ASM hook may lead to additional overhead
when query responses are large. This is because Android
uses a lazy retrieval of Cursor contents, only transferring
portions of the response over Binder IPC as needed. One
way to improve ASM query performance is to intercept
the actual data access via Binder to modify data, rather
than serializing the entire response. However, this will
increase the number of callbacks to ASM apps, resulting
in a trade-off. We will explore this and other methods of
performance improvement in future work.

5.4.4 Third Party Hooks

ASM allows third-party Android applications to dynam-
ically add hooks to the ASM Bridge. These hooks are
valuable for extending enforcement into Google and de-
vice manufacturer applications (which are not in AOSP),
as well as third-party applications downloaded from ap-
plication markets (e.g., Google Play Store). Third-party
hooks are identiﬁed by 1) a hook name, and 2) the pack-
age name of the application implementing the autho-
rization hook. The complete hook name is a charac-
ter string of the format package name:hook name.
This naming convention provides third parties with their
own namespaces for hooks. Note that third parties do
not specify their package name; ASM obtains it using
the registering application’s uid received from Binder.

To receive callbacks for third-party hooks, ASM apps
implement two generic third-party hook methods, shown
in Listing 6. One method handles normal hook callbacks;
the other method handles data modiﬁcation hook call-
backs. When the third-party application’s authorization
hook calls the ASM Bridge callback, it passes a generic
Bundle object. The ASM forwards the Bundle to regis-
tered ASM apps for access control decisions. As with

other ASM authorization hooks, third-party hooks are
only activated when an ASM app registers for it.

ASM apps receive hook callbacks for all of their regis-
tered third-party hooks via a single interface (technically
two callbacks, as in Listing 6). Within this callback,
ASM apps must identify the third-party hook by name
and must interpret the data in the Bundle based on the
third-party application’s speciﬁcation. We assume that
ASM apps that register for third-party hooks are aware
of the absolute hook name and the contained attributes.
The ASM app returns allow, deny, or allow along with a
modiﬁcation of the Bundle (for data modiﬁcation hooks).
Finally, the third-party application developer must im-
plement a special service component to receive hook
activation and deactivation callbacks from the ASM
Bridge. The ASM Bridge sends messages to this service
to update the status of a hook. Third-party application
developers must follow the message codes exposed by
ASM for proper hook management.

5.4.5 LSM Hooks
ASM apps sometimes require mediation of UNIX-level
objects such as ﬁles and network sockets. ASM can-
not deﬁne authorization hooks for such objects in the
userspace portion of the Android OS. Instead, autho-
rization hooks must be placed in the Linux kernel.
Fortunately,
the Linux kernel already has the LSM
reference monitor interface for deﬁning kernel refer-
ence monitors. For example, file permission and
socket connect LSM hooks mediate ﬁle and net-
work socket operations, respectively.

The main consideration for ASM is how to allow ASM
apps to interface with these LSM hooks. Several poten-
tial approaches exist. First, ASM could allow ASM apps
to load LSM kernel modules directly. This approach is
appropriate when the ASM app developer also has the
ability to rebuild the device ﬁrmware. For example, one
target audience for ASM is security researchers prototyp-
ing new reference monitors. In this case, the ASM app
developer can create userspace and kernel components
and provide communication between the two.

However, we would like to also allow ASM apps to
mediate kernel-level objects without rebuilding the de-
vice ﬁrmware. Therefore, a second option is to develop
a small mediation programming language that is inter-
preted by an ASM LSM. In this model, the ASM app
developer programs access control logic within the inter-
preted language, and the logic is loaded along with the
ASM on boot. Using an interpreted language would en-
sure kernel integrity (Goal G3).

Our current implementation uses a third option. We
deﬁne a special ASM LSM that implements LSM hooks
and performs synchronous upcalls to the ASM Bridge to
complete the access control decision. Consistent with the

USENIX Association  

23rd USENIX Security Symposium  1013

rest of the ASM design, the upcall is only activated when
an ASM app registers for the corresponding reference
monitor hook. To integrate our ASM LSM into the kernel
without removing SEAndroid (Goal G2), we used an un-
ofﬁcial multi-LSM patch [27]. We implemented autho-
rization hooks for many commonly used LSM hooks, in-
cluding file permission and socket connect.
While the upcall approach initially sounds like it
would have very slow performance, our key observation
is that many ASM apps will require very few, if any,
LSM hooks. For example, an ASM app for Aquifer [22]
would only require the file permission and
socket connect LSM hooks. Section 6.2 shows that
both of the aforementioned hooks can be evaluated in
userspace with reasonable performance overhead. Fur-
thermore, placing all ASM app logic in one place (i.e.,
userspace) simpliﬁes reference monitor design.

To improve access performance for large ﬁles, we im-
plemented a cache with an expiration policy, where ﬁle
accesses (euid, pid, inode, access mask) and decisions
received from ASM apps on those accesses are cached;
and are invalidated if the accesses do not repeat within a
timeout period of 1 ms. Since we cache and match the
ﬁle inode as well as the accessing subject’s effective uid
and pid, we do not provide an attacker the opportunity of
taking advantage of a race condition (i.e., requesting for
a ﬁle less than 1ms after its access is granted).

Note that this approach may lead to a case where ﬁle
access control is too coarse grained for a particular ASM
app. For example, consider a situation where an applica-
tion on the device reads a ﬁle continuously. An ASM app
grants this application access, but if at some point during
these accesses it wants to deny the access to this ﬁle, the
file permission hook is not triggered since the ﬁle
is read before the timeout expires resulting in cache hits.
To address this problem, we allow ASM apps to set this
timeout. If multiple ASM apps set a timeout, the mas-
ter policy can determine the timeout, e.g., the smallest
timeout. ASM apps may also disable the cache, which
provides all ﬁle access control callbacks to the ASM, but
also degrades the performance of ﬁle reads.

5.5 ASM LSM
Finally, the ASM LSM provides two security features in
addition to the LSM hook upcalls. First, it implements
the task kill LSM hook to prevent registered ASM
apps from being killed. As we discuss in Section 6.1,
some existing security enhancements can be disabled
by killing their processes. Second, it implements the
inode *xattr LSM hooks to provide ASM apps ac-
cess to their own unique extended attribute namespaces.
That is, an ASM app can use ﬁle xattrs with a preﬁx
matching its package name. No other applications can

access these xattrs. File xattrs are needed by security en-
hancements such as Aquifer [22].

6 Evaluation

We evaluate the ASM framework in two ways. First, we
evaluate the utility of ASM via case study by implement-
ing two recent security enhancements for Android as
ASM apps. Second, we evaluate the resource impact of
ASM with respect to both performance and energy con-
sumption. We implemented ASM on Android version
4.4.1, hence we use the Android 4.4.1 AOSP build as our
baseline. All the experiments were performed on an LG
Nexus 4 (GSM). The source code for ASM is available
at http://androidsecuritymodules.org.
6.1 Case Studies
In this section, we evaluate the utility of ASM by im-
plementing existing security solutions as ASM apps. We
implement and study two examples: 1) MockDroid [6]
and 2) AppLock [13]. Finally, we conclude this section
with a summary of lessons learned.

6.1.1 MockDroid
MockDroid [6] is a system-centric security extension for
the Android OS that allows users to gracefully revoke
the privileges requested by an application without the
app crashing. To do so, MockDroid provides a graphical
user interface that allows the user to decide whether in-
dividual applications are presented real or fake responses
when accessing sensitive system components.
Original Implementation: MockDroid extends An-
droid’s permissions model for accessing sensitive ser-
vices by providing alternative “mock” versions. When
users install an application, they choose to use the real
or mock version of permissions. However, users can also
revise this decision later using a graphical user interface.
MockDroid stores the mapping between applications and
permissions in an extension to Android’s Package Man-
ager Service. This policy store is the primary policy de-
cision point in MockDroid.

MockDroid places enforcement logic in relevant An-
droid OS components, as well as the kernel. If an appli-
cation is assigned a mock permission, the Android OS
component will return fake information. For example,
if an application attempts to get the device IMEI, and it
is assigned the mock version of READ PHONE STATE,
then the telephony service will return a fake static IMEI
instead of the device’s real IMEI.

MockDroid also modiﬁes the Linux kernel with en-
forcement logic. Recall from Section 2 that some per-
missions are enforced in the Linux kernel based on GIDs
assigned to applications. MockDroid deﬁnes additional

1014  23rd USENIX Security Symposium 

USENIX Association

Table 2: Hooks registered by the MockDroidASM app

Access to Fake

IMEI

ASM Hook

device id mod

Fine/Coarse Location update

on location changed mod

Internet Connection

Contacts Query
Contacts Insert
Contacts Delete
Contacts Update
Receive Broadcast

socket connect

contacts query mod

contacts insert
contacts delete
contacts update

resolve broadcast mod

ASM Callback
int getDeviceId mod(String fake imei[])
int onLocationChanged mod(int uid, Location loc)
int socket connect(String family, String type, int uid)
int query contacts mod (ASMCursor c, String projection, ...)
int contactsInsert(Uri uri, ContentValues values)
int contactsDelete(Uri uri, String selection, String selectionArgs[], ...)
int contactsUpdate(Uri uri, ContentValues values, String selection, ...)
int resolveBroadcastReceivers mod(List resolvedList, String resolvedtype, ..)

GIDs for mock permissions enforced by GID. For exam-
ple, if the user selects to assign the mock version of the
INTERNET permission to an application, it is assigned
to the mock inet group instead of the inet group. To
enforce this mock permission, MockDroid modiﬁes the
inet runtime check in the Linux kernel (a check added
by Android to Linux). In the modiﬁed check, if the appli-
cation is in the mock inet group, a socket timeout error
is returned, simulating an unavailable network server.
MockDroidASM: We implemented an ASM app ver-
sion of MockDroid called MockDroidASM. In addi-
tion to ASM permissions for hook registration, Mock-
DroidASM must register for the PACKAGE INSTALL
hook to receive the package name and the list of
requested permissions when each new application
is installed.
A MockDroidASM GUI also allows
the user to conﬁgure which permissions to grace-
fully revoke from an application (e.g., INTERNET,
READ PHONE STATE).

Instead of using additional mock permissions, Mock-
DroidASM registers for the modify version of ASM
hooks that are triggered when an application attempts
to access sensitive system components. Since Mock-
DroidASM needs to modify values returned to apps, it
requests the REGISTER ASM MODIFY permission, as
described in Section 5.3.

Table 2 shows the most important hooks used by
MockDroidASM. For example, the device id mod
hook allows MockDroidASM to fake the IMEI number
of the device. On the kernel-level, MockDroidASM reg-
isters for the socket connect hook to receive a call-
back when an application tries to connect to a network
server. If INTERNET is revoked by the user, the Mock-
DroidASM returns deny to the ASM LSM, which returns
a socket timeout error to the application.

6.1.2 AppLock
AppLock [13] is an application available on the Google
Play Store. It allows users to protect the user interface
components of applications with a password. Users set a
password to access the AppLock. They then selectively
lock other third-party and system applications through
AppLock’s user interface. When the user tries to open
a protected application, AppLock presents a password

prompt, and the user must enter the correct password be-
fore the application can be used.
Original Implementation: AppLock requests install-
time permissions for 1) getting the list of running apps, 2)
overlaying its user interface over other applications, and
3) killing application processes. While AppLock does
not require any modiﬁcations to Android’s source code,
it is uses energy very inefﬁciently. It can also be circum-
vented using an ADB shell (e.g., “am force-stop
com.domobile.applock”).

AppLock’s LockService uses a busy loop to continu-
ously query the Android operating system for the list of
running applications while the screen is on. If the top ap-
plication is protected by AppLock’s policy, LockService
overlays the current screen with a password prompt user
interface. This interface stays on the screen, trapping all
input until the correct password is entered. If the user de-
cides to return from the lock screen without entering his
password, AppLock kills the protected application. We
have veriﬁed this execution via static analysis using Ap-
kTool [1] as well as with another monitoring ASM app
that registers for the start service hook.
AppLockASM: We implemented an ASM app ver-
sion of AppLock called AppLockASM. To provide the
password-protected application functionality, AppLock-
ASM simply registers for the start activity hook.
It then receives a callback whenever an activity compo-
nent is started. When this occurs, AppLockASM dis-
plays its own lock screen. If the user enters the correct
password, the start activity event is allowed. If
the user decides not to enter a password, it is denied.
Unlike AppLock, AppLockASM never starts the target
activity component without the correct password.

6.1.3 Summary
ASM considerably simpliﬁes development of security
modules such as AppLock and MockDroid. For exam-
ple, the original AppLock app performs its functionality
by starting a service in an inﬁnite loop, a design that is in-
efﬁcient in terms of power as well as latency. AppLock-
ASM on the other hand needs to simply register for a
callback with the ASM Framework. The AppLock im-
plementation also prompts a lock screen after the app has
already been started, and has to kill the app when the lock

USENIX Association  

23rd USENIX Security Symposium  1015

Table 3: Performance - Unmodiﬁed AOSP, ASM with no reference monitor, and ASM with a reference monitor app

Overhead (%)

Overhead (ms)

w/o ASM app
5.15
18.25
105.50
-0.76
21.19
5.31
0.52
21.54
2.48
-3.5

w/ ASM app
19.50
116.45
196.71
11.51
69.44
10.59
2.34
555.38
218.63
157.50

w/o ASM app
0.98
0.71
2.30
-0.93
3.69
3.14
0.30
0.14
0.04
-0.07

w/ ASM app
3.71
4.53
4.27
13.98
12.09
6.26
1.35
3.61
3.52
3.15

ASM (ms)

Protection Event

Start Activity
Start Service
Send Broadcast
Contacts Insert
Contacts Query

File Read
File Write

Socket Create
Socket Connect

Socket Bind

AOSP (ms)
19.03±1.51
3.89±0.31
2.18±0.24
121.41±5.98
17.41±3.88
59.13±1.97
57.68±3.01
0.65±0.086
1.61±0.21
2.00±0.17

w/o ASM app
20.01±1.39
4.6±0.41
4.48±0.69
120.48±5.25
21.10±3.13
62.27±2.86
57.98±2.76
0.79±0.13
1.65±0.22
1.93±0.64

w/ ASM app
22.74±1.77
8.42±0.61
6.45±0.55
135.39±6.35
29.50±4.36
65.39±2.93
59.03±3.60
4.26±0.56
5.13±0.32
5.15±0.34
screen returns. This arbitrary killing of apps is prevented
in the AppLockASM case, where the callback happens
before the activity is started, and the activity starts only
if the AppLockASM allows. This is also beneﬁcial from
the security point of view, as an AppLockASM-like app
does not need to register for the permission to kill other
apps, reducing the risk in case the locking app itself is
malicious or malfunctions.

The original MockDroid implementation requires
modiﬁcations to the Package Manager Service, and has
to implement an entire parallel mock permission frame-
work. This effort can be reduced by registering for a
small number of ASM hooks, without having to modify
system services.

A general lesson learned from these case studies is that
the ASM architecture enables developers to easily im-
plement complex system-centric security enhancements
without the need for third party support. This broadens
the outreach of ASM, and encourages third-party devel-
opers to engage in the development of sophisticated se-
curity solutions for Android-based devices.
6.2 Performance Overhead
To understand the performance implications of ASM, we
micro benchmarked the most common ASM protection
events for modules in Table 1. We performed each ex-
periment 50 times in three execution environments: 1)
AOSP, 2) ASM with no ASM app, and 3) ASM with one
ASM app. The ASM app only registers for the callback
of the tested protection event; all other callbacks remain
deactivated. Since we are only interested in the perfor-
mance overhead caused by framework, our test callback
immediately returns allow. Table 3 shows the mean re-
sults with the 95% conﬁdence intervals.
Lifecycle protection events: To test lifecycle protection
events (i.e., start activity, start service, and send broad-
cast), we created an intent message and added a byte ar-
ray as its data payload (i.e., extras Bundle). Each test
type registered for the modify version of the ASM hook.
We sent the intent for the respective type, pausing for
ﬁve seconds between consecutive executions. Potential
areas of overhead for using the hook include: 1) cost of

establishing two additional IPCs, 2) marshalling and un-
marshalling this data across the two IPCs, 3) ASM copy-
ing the extras Bundle when sending it to the ASM app,
and 4) setting the returned Bundle back to the original
intent. To estimate worst case performance, we chose a
very large array (4KB) and registered our test ASM for
modify data hooks. This worst case overhead, though
relatively high, is not noticeable by the user due to its
low absolute value. Additionally, most applications use
ﬁles to share very large data values. We note that while
send broadcast has a high overhead percentage, the wall
clock overhead is in the order of milliseconds, which is
negligible overhead for broadcasts.

Content provider protection events: Micro bench-
marks for content providers were performed on the Con-
tacts Provider. For this experiment, our ASM app reg-
isters for the contacts insert callback.
It pro-
ceeds to insert a new contact (ﬁrst and last name) into
the contacts database exposed by the ContactsProvider.
The overhead observed is 11.51% and negligible in
terms of its absolute value. We then registered for the
contacts query mod hook, and performed a query
on the same contact. Query has a greater overhead,
which is attributable to marshalling/unmarshalling the
data between the two IPC calls, and serialization of the
Cursor object into a parcelable. A major cause of this
overhead is also that the Content Provider Cursor is not
populated when the query result is returned to the calling
application, but is instead ﬁlled as and when the appli-
cation uses it to retrieved values. As discussed in Sec-
tion 5.4.3, future work will consider alternative methods
of mediating query responses.

File access protection events: File micro benchmarks
tested the file permission hook, which uses an up-
call from the kernel. To test ﬁle access performance, our
test app performs an access (read/write) on a 5MB ﬁle.
We pause for a second between successive executions.
For writes, we do not see considerable overhead as the
ﬁle is written in one shot to disk. Reads used a 16KB
buffer and the default 1ms expiration time for caching
access control decisions, as discussed Section 5.4.5.

1016  23rd USENIX Security Symposium 

USENIX Association

Table 4: Energy overhead of ASM.

Average Power

Consumption (mW) Overhead (%)

AOSP

ASM w/o ASM app
ASM w/ ASM app

670.42
692.83
732.98

-

3.34
9.33

Socket protection events: For socket operations, we
tested the performance overhead for creating, binding
and connecting to an IPv6 socket. Our test ASM app reg-
istered for the socket create, socket bind, and
socket connect callbacks. The absolute overhead is
mainly caused by the callback to the userspace, and is a
constant overhead for socket operations.
6.3 Energy Consumption
Energy consumption is a growing concern for mobile de-
vices. To measure ASM’s impact on energy consump-
tion, we perform energy measurements in same three test
environments as performance: 1) AOSP, 2) ASM with
no ASM app, 3) ASM with one ASM app. The ASM
app registers for all the hooks from the performance ex-
periments. We use the Trepn proﬁler 4.1 [25] provided
by Qualcomm to perform power measurements. Trepn
uses an interface exposed by the Linux kernel to the
power management IC used on the System on a Chip to
measure energy consumption, a feature that is supported
on a limited set of devices, including the LG Nexus 4.
Trepn samples power consumption measurements every
100 ms. Average values are shown in the Table 4.

We monitor system energy consumption while run-
ning the test applications from Section 6.2. When the
hooks are deactivated, we measured an energy consump-
tion overhead of about 3.34%. Our ASM app used for
the performance and energy consumption experiments
measured an overhead of about 9.33%. This overhead is
caused by the active authorization hooks in the relevant
OS components and kernel, as well as the communica-
tion between the authorization hooks, the ASM Bridge,
and the ASM app.

It should be noted that performing accurate energy
consumption measurements on smartphones is a chal-
lenge. While we consider the individual measurements
to be accurate, we acknowledge that the low sampling
rate used by the Trepn proﬁler is problematic. However,
each individual experiment is performed 50 times, there-
fore we believe Trepn’s measurements to at least provide
a rough estimate of the energy consumption overhead in-
troduced by ASM.
7 Related Work
Section 4 discussed Android security enhancements that
modify the Android ﬁrmware to achieve security media-
tion. As an alternative approach, Aurasium [35], App-
Guard [5], RetroSkeleton [11] and Dr. Android and

Mr. Hide [20] repackage applications with inline ref-
erence monitors (IRMs). While IRMs do not require
ﬁrmware modiﬁcation, rewriting frequently breaks ap-
plications, and the resulting mediation may be circum-
vented if API coverage is incomplete or native libraries
are used. Placing access control mediation within the OS
provides stronger guarantees.

ASM follows the methodology of the LSM [34] and
TrustedBSD [32] reference monitor interface frame-
works. Both frameworks have been highly successful. In
Linux, LSM is widely used to extend Linux security en-
forcement. Version 3.13 of Linux kernel source includes
SELinux [28], AppArmor [3], Tomoyo [31], Smack [30],
and Yama [36] LSMs. TrustedBSD is not only used by
FreeBSD, but also by Apple to implement seatbelt in
Mac OS X and iOS [33].

FlaskDroid [9] also shares motivation with ASM. It
provides an SELinux-style Type Enforcement (TE) pol-
icy language for extending Android security. FlaskDroid
also allows third-party application developers to spec-
ify TE policies to protect their applications. However,
FlaskDroid is limited to TE access control policies. By
providing a programmable interface, ASM enables an
extensible interface that allows not only TE, but also
novel security models not yet invented. Speciﬁcally, we
believe the ability to replace data values will become vi-
tal in protecting new operating systems such as Android.
Concurrent to and independent of our work on ASM,
the Android Security Framework (ASF) [4] also pro-
vides an extensible interface to implement security mod-
ules. ASM and ASF are conceptually very similar: both
promote the need for a programmable interface, autho-
rization hooks that replace data (called edit automata in
ASF), and third-party hooks (via callModule() in ASF).
However, their individual approaches differ. A key dif-
ference is that ASM seeks to ensure existing security
guarantees (Goal G2), whereas ASF assumes the module
writer is completely trusted (e.g., can load kernel mod-
ules). Goal G2 is motivated by our vision of enterprise IT
and researchers loading ASM apps on production phones
without root access. ASF does not support this vision.
Furthermore, a vulnerable ASF module can undermine
secrecy and integrity of the system and all installed ap-
plications. That said, ASF does provide expressibility
that ASM does not. Speciﬁcally, ASF provides a pro-
grammable interface to adding inline reference monitors
to apps. While IRMs run the risk of breaking apps, they
do support sub-application policies that ASM cannot ex-
press (e.g., forcing an app to use https over http).

Finally, Section 5.4 identiﬁed the AppOps security en-
hancement that is currently under development in AOSP.
AppOps adds authorization hooks throughout the An-
droid OS. However, AppOps does not provide a pro-
grammable interface for enhancing OS security. Instead,

USENIX Association  

23rd USENIX Security Symposium  1017

we envision separating the authorization hooks from Ap-
pOps and implementing AppOps as an ASM app. A sim-
ilar process occurred during the creation of LSM when it
was split away from SELinux.
8 Conclusion
This paper has presented the Android Security Modules
framework as a programmable interface for extending
Android’s security. While similar reference monitor in-
terfaces have been proposed for Linux and TrustedBSD,
ASM is novel in how it addresses the semantically rich
OS APIs provided by new operating systems such as An-
droid. We studied over a dozen research proposals that
enhance Android security to motivate the reference mon-
itor interface hooks provided by ASM. Of particular note
is the ability for hooks to replace data, as well as for
third-party application developers to deﬁne new hooks.
ASM promotes the creation of novel security enhance-
ments to Android without restricting OS consumers (e.g.,
consumers, enterprise, government) to speciﬁc policy
languages (e.g., type enforcement). ASM currently al-
lows researchers with the ability to recompile Android to
rapidly prototype novel reference monitors without need-
ing to consider authorization hook placement. If ASM
is adopted into the AOSP source code, it potentially al-
lows researchers and enterprise IT to add new reference
monitors to production Android devices without requir-
ing root access, a signiﬁcant limitation of existing bring-
your-own-device solutions.
Acknowledgements

This material is based upon work supported by the
National Science Foundation. Adwait Nadkarni and
William Enck were partially supported by NSF grants
CNS-1253346 and CNS-1222680. Any opinions, ﬁnd-
ings, and conclusions or recommendations expressed in
this material are those of the authors and do not neces-
sarily reﬂect the views of the funding agencies.

References
[1] android-apktool.

android-apktool/.

https://code.google.com/p/

[2] ANDERSON, J. P. Computer Security Technology Planning
Study. ESDTR-73-51, Air Force Electronic Systems Division,
Hanscom AFB, Bedford, MA, 1972.
(Also available as Vol. I,
DITCAD-758206. Vol. II DITCAD-772806).

[3] AppArmor. http://apparmor.net. Accessed January

2014.

[4] BACKES, M., BUGIEL, S., GERLING, S., AND VON STYP-
REKOWSKY, P.
Android Security Framework: Enabling
Generic and Extensible Access Control on Android. Tech. Rep.
A/01/2014, Saarland University, April 2014.

[5] BACKES, M., GERLING, S., HAMMER, C., MAFFEI, M., AND
STYP-REKOWSKY, P. AppGuard - Enforcing User Requirements
on Android Apps.
In Proceedings of TACAS. Springer Berlin
Heidelberg, 2013.

[6] BERESFORD, A. R., RICE, A., SKEHIN, N., AND SOHAN, R.
MockDroid: Trading Privacy for Application Functionality on
Smartphones. In Proceedings of HotMobile (2011).

[7] BUGIEL, S., DAVI, L., DMITRIENKO, A., FISCHER, T., AND
SADEGHI, A.-R. XManDroid: A New Android Evolution to
Mitigate Privilege Escalation Attacks. Tech. Rep. TR-2011-04,
Technische Universitat Darmstadt, Center for Advanced Security
Research Darmstadt, Darmstadt, Germany, Apr. 2011.

[8] BUGIEL, S., DAVI, L., DMITRIENKO, A., HEUSER, S.,
SADEGHI, A.-R., AND SHASTRY, B. Practical and Lightweight
Domain Isolation on Android. In Proceedings of the ACM Work-
shop on Security and Privacy in Mobile Devices (SPSM) (2011).
[9] BUGIEL, S., HEUSER, S., AND SADEGHI, A.-R. Flexible and
Fine-Grained Mandatory Access Control on Android for Diverse
Security and Privacy Policies.
In Proceedings of the USENIX
Security Symposium (2013).

[10] CONTI, M., NGUYEN, V. T. N., AND CRISPO, B. CRePE:
In Proceed-

Context-Related Policy Enforcement for Android.
ings of ISC (2010).

[11] DAVIS, B., AND CHEN, H. RetroSkeleton: Retroﬁtting Android

Apps. In Proceedings of MobiSys (2013).

[12] DIETZ, M., SHEKHAR, S., PISETSKY, Y., SHU, A., AND WAL-
LACH, D. S. Quire: Lightweight Provenance for Smart Phone
Operating Systems. In Proceedings of the USENIX Security Sym-
posium (2011).

[13] DOMOBILE LAB. AppLock. https://play.google.

com/store/apps/details?id=com.domobile.
applock.

[14] ENCK, W., GILBERT, P., CHUN, B.-G., COX, L. P., JUNG,
J., MCDANIEL, P., AND SHETH, A. N.
TaintDroid: An
Information-Flow Tracking System for Realtime Privacy Moni-
toring on Smartphones. In Proceedings of USENIX OSDI (2010).
On
Lightweight Mobile Phone Application Certiﬁcation. In Proceed-
ings of ACM CCS (2009).

[15] ENCK, W., ONGTANG, M., AND MCDANIEL, P.

[16] FELT, A. P., EGELMAN, S., FINIFTER, M., AKHAWE, D., AND
WAGNER, D. How to Ask For Permission. In Proceedings of the
USENIX Workshop on Hot Topics in Security (HotSec) (2012).

[17] FELT, A. P., HA, E., EGELMAN, S., HANEY, A., CHIN, E.,
AND WAGNER, D. Android permissions: user attention, com-
prehension, and behavior. In Proceedings of SOUPS (2012).

[18] FELT, A. P., WANG, H. J., MOSHCHUK, A., HANNA, S., AND
CHIN, E. Permission Re-Delegation: Attacks and Defenses. In
Proceedings of the USENIX Security Symposium (Aug. 2011).

[19] HORNYACK, P., HAN, S., JUNG, J., SCHECHTER, S., AND
WETHERALL, D. These Aren’t the Droids You’re Looking For:
Retroﬁtting Android to Protect Data from Imperious Applica-
tions. In Proceedings of ACM CCS (2011).

[20] JEON, J., MICINSKI, K. K., VAUGHAN, J. A., FOGEL, A.,
REDDY, N., FOSTER, J. S., AND MILLSTEIN, T. Dr. Android
and Mr. Hide: Fine-grained Permissions in Android Applications.
In Proceedings of the ACM Workshop on Security and Privacy in
Mobile Devices (SPSM) (2012), ACM.

[21] MCDANIEL, P., AND PRAKASH, A. Methods and limitations
In Proceedings of IEEE S&P

of security policy reconciliation.
(2002), IEEE Computer Society.

[22] NADKARNI, A., AND ENCK, W. Preventing Accidental Data
In Proceedings of

Disclosure in Modern Operating Systems.
ACM CCS (2013).

[23] NAUMAN, M., KHAN, S., AND ZHANG, X. Apex: Extending
Android Permission Model and Enforcement with User-deﬁned
Runtime Constraints. In Proceedings of ASIACCS (2010).

1018  23rd USENIX Security Symposium 

USENIX Association

[24] ONGTANG, M., MCLAUGHLIN, S., ENCK, W., AND MC-
DANIEL, P. Semantically Rich Application-Centric Security in
Android. In Proceedings of the Annual Computer Security Appli-
cations Conference (2009).

[25] QUALCOMM.

Trepn

Proﬁler.

https://

developer.qualcomm.com/mobile-development/
increase-app-performance/trepn-profiler.

[26] RAO, V., AND JAEGER, T. Dynamic Mandatory Access Con-
trol for Multiple Stakeholders. In Proceedings of ACM SACMAT
(2009), ACM.

[27] SCHAUFLER, C.

[PATCH v13 0/9] LSM: Multiple concur-
rent LSMs. https://lkml.org/lkml/2013/4/23/307,
2013.

[28] Security-Enhanced Linux. http://selinuxproject.org.

Accessed January 2014.

[29] SMALLEY, S., AND CRAIG, R. Security Enhanced (SE) An-
In Proceedings of

droid: Bringing Flexible MAC to Android.
NDSS (2013).

[30] The Smack Project. http://schaufler-ca.com/. Ac-

cessed February 2014.

[31] TOMOYO Linux.

http://tomoyo.sourceforge.jp.

Accessed February 2014.

[32] WATSON, R. N. M. TrustedBSD: Adding Trusted Operating
In Proceedings of the USENIX

System Features to FreeBSD.
Annual Technical Conference, FREENIX Track (2001).

[33] WATSON, R. N. M. A Decade of OS Access-Control Extensibil-

ity. Communications of the ACM 56, 2 (Feb. 2013).

[34] WRITE, C., COWAN, C., SMALLEY, S., MORRIS, J., AND
KROAH-HARTMAN, G. Linux Security Modules: General Secu-
rity Support for the Linux Kernel. In Proceedings of the USENIX
Security Symposium (2002).

[35] XU, R., SAIDI, H., AND ANDERSON, R. Aurasium: Practical
Policy Enforcement for Android Applications. In Proceedings of
the USENIX Security Symposium (2012).

[36] Yama

lsm.

Documentation/security/Yama.txt.
February 2014.

https://www.kernel.org/doc/
Accessed

[37] ZHOU, Y., ZHANG, X., JIANG, X., AND FREEH, V. W. Taming
Information-Stealing Smartphone Applications (on Android). In
Proceedings of the International Conference on Trust and Trust-
worthy Computing (June 2011).

USENIX Association  

23rd USENIX Security Symposium  1019

