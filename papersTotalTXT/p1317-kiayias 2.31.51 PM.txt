Practical Non-Malleable Codes from (cid:96)-more Extractable

Hash Functions

Aggelos Kiayias

University of Edinburgh
akiayias@inf.ed.ac.uk

Feng-Hao Liu

Florida Atlantic University
fenghao.liu@fau.edu

∗
Yiannis Tselekounis
University of Edinburgh

tselekounis@sians.org

ABSTRACT
In this work, we signiﬁcantly improve the eﬃciency of non-
malleable codes in the split state model, by constructing a
code with codeword length (roughly) |s|+9k, where |s| is the
length of the message, and k is the security parameter. This
is a substantial improvement over previous constructions,
both asymptotically and concretely.

Our construction relies on a new primitive which we deﬁne
and study, called (cid:96)-more extractable hash functions. This
notion, which may be of independent interest, is strictly
stronger than the previous notion of extractable hash by
Goldwasser et al. (Eprint ’11) and Bitansky et al. (ITCS
’12, Eprint ’14), yet we can instantiate it under the same
assumption used for the previous extractable hash function
(a variant of the Knowledge of Exponent Assumption).

Keywords
Non-malleable codes, hash functions, split-state model

1.

INTRODUCTION

Non-malleable codes were introduced by Dziembowski et
al. [29] as a relaxation of error correction and error detec-
tion codes. They provide security in the following sense:
any modiﬁed codeword decodes to the original message or
to a completely unrelated one, with overwhelming probabil-
ity. Non-malleability is deﬁned through a simulation-based
deﬁnition, which informally states that, for any tampering
function f , we require the existence of a simulator that simu-
lates the tampering eﬀect, by only inspecting f , i.e., without
making any assumptions on the distribution of the encoded
message.

∗Work performed while at the National and Kapodistrian

University of Athens.
Research supported by ERC project CODAMODA, #
259152 and H2020 Project Panoramix # 653497.

Permission to make digital or hard copies of part or all of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for third-party components of this work must be honored.
For all other uses, contact the owner/author(s).
CCS’16 October 24-28, 2016, Vienna, Austria
c(cid:13) 2016 Copyright held by the owner/author(s).
ACM ISBN 978-1-4503-4139-4/16/10.
DOI: http://dx.doi.org/10.1145/2976749.2978352

Various applications of non-malleable codes have been pro-
posed, such as CCA secure encryption schemes [21], non-
malleable commitments [5], and most notably, their appli-
cation against malicious modiﬁcation attacks, also known as
tampering attacks. Indeed, using non-malleable codes to se-
cure implementations against tampering attacks was the mo-
tivation in the original work by Dziembowski et al. [29]. Due
to their important application, constructing non-malleable
codes has drawn a lot of attention, as we elaborate below.

The split-state model [29, 40]. Ideally, we would like to
achieve non-malleability against arbitrary function classes,
yet, this task is not achievable, as it is also not achievable
in the case of error correction/detection codes. As discussed
in [29], assuming a tampering function f that computes the
decoding of the codeword c = Enc(s), where s is the private
message, and computes ˜c = Enc(s + 1), we receive a tam-
pered codeword, ˜c, that decodes to a message, highly related
to the original one. Therefore, no secure construction can
exist against any function class that contains f , which con-
cludes that, restricting the function class, is inherent.

Motivated by the above, various function classes have
been studied, and in particular, the split-state function class
has been identiﬁed and extensively studied in the literature.
Brieﬂy speaking, in the split-state model, private memory
is split in two parts, L, R, and the attacker may apply any
function f = (f1, f2) that results in a tampered memory
equal to (f1(L), f2(R)). This is a plausible model since in
many cases sensitive data may be split in two storage de-
vices that are physically separated. Note that the model
can generalize to multiple split states, with the two-state
variant being the hardest to achieve; we only consider the
two state variant in this paper.

Broadly speaking, (explicit) constructions of non-malleable
codes in the split-state model can be categorized into infor-
mation -theoretic and computational.1 In a recent break-
through result [4], Aggarwal et al. provide the ﬁrst polynomial-
time, information-theoretic, non-malleable code for multi-
bit messages, thus signiﬁcantly improving over the work
of [28], which only supports single-bit messages. The en-
coder produces codewords of length O((|s| + k)7), where |s|

1The work of [29] showed that in the random oracle
model, there exist eﬃcient non-malleable codes against split-
state tampering functions. However, their approach uses a
probabilistic argument thus providing only a proof of ex-
istence and not an explicit construction. Therefore, their
random oracle result does not count as an explicit construc-
tion. Currently, there is no known explicit constructions in
the random oracle model to our knowledge.

1317denotes the length of the encoded message, s, and k is the
security parameter.2 Later Aggarwal et al. [3] proposed an-
other construction that achieves codeword length roughly
O(|s|) (for suﬃciently large |s|).3

In the computational setting, Liu and Lysyanskaya [40]
construct a non-malleable code using cryptographic tools
such as leakage resilient public-key encryption [43], and ro-
bust non-interactive zero-knowledge (NIZK) proofs [26]. The
rate of their construction is not given in the original pa-
per and a textbook instantiation with public-key encryption
combined with NIZKs, would not yield a rate 1 code; how-
ever, using state of the art tools, we can provide a better
instantiation of [40], with codeword length |s| + O(k2), see
Table 1.1. Recently, Aggarwal et al. [2] presented a compiler
that transforms any low rate, non-malleable code, to a rate
1, computationally secure, non-malleable code. The under-
lying encoding must satisfy a notion, strictly stronger than
non-malleability, called augmented non-malleability, which,
as it is stated in [2], can be satisﬁed by the construction
of [4]. Thus, by instantiating the compiler of [2] with the
construction of [4], the codeword’s length becomes |s| +
O(k7).

Although the above constructions achieve “rate 1” asymp-
totically, i.e., the ratio of message to codeword length is
1, as the message length, |s|, goes to inﬁnity, in practice,
the induced overhead can still be too large, when consider-
ing short messages (e.g., a 160-bit cryptographic key), even
without counting the potentially large hidden constants in
the asymptotic notation. Thus, even though the problem of
“optimal-rate” has been solved in theory, it is still unclear
what the practical implications of those constructions are.
Given the current state of the art, as discussed above, con-
structing codes with very small overhead, including the hid-
den constant, remains still one of the most important open
questions in the area. Note, that the natural lower bound for
code length is merely |s| + k, and none of the known, com-
putational or information-theoretic, constructions, match it,
even asymptotically.

1.1 Our Results

In this work, we tackle the challenge to construct truly
eﬃcient non-malleable codes in the split-state model. To
achieve this goal, we introduce a new cryptographic primi-
tive, called (cid:96)-more extractable hash function family, and then
we construct an eﬃcient code, using our new tool. Our ap-
proach is modular: ﬁrst we propose and formalize (cid:96)-more
extractable hash function families, and then we demonstrate
their application to non-malleable codes.

Brieﬂy speaking, (cid:96)-more extractable hash function families
capture the idea that, if an adversary, given (cid:96) hash values
v1, . . . , v(cid:96), produces a new valid hash value ˜v, then it must
know a pre-image of ˜v. This is a generalization of the notion
of extractable hash functions by Bitansky et al. [10] and
Goldwasser et al. [49], which corresponds to the (cid:96) = 0 case
(i.e., the adversary gets no access to valid hash values, prior
to producing its own value), and is somewhat reminiscent of
the strengthening of simulation-soundness in the context of

2The result of [4] can be further improved assuming spe-

ciﬁc conjectures.

3 The hidden constants might be “astronomical” as they
depend on results in additive combinatorics, as pointed out
in the conclusion of their work [3].

zero-knowlege proofs [48]. Our generalization is strict: we
prove the following (informally stated):

Theorem 1.1

(Informal). Extractable hash

(cid:54)=⇒ 1-

more extractable hash.

The subtlety comes from the fact that the (cid:96)-more attacker
might get an “unfair advantage” in producing a valid hash
value, for which it does not possess a pre-image, because
of the (cid:96) additional inputs; e.g., by modifying the vi’s in
some suitable way.
Indeed, we show that the extractable
hash function family of Bitansky et al. [10] is easily mal-
leable, and thus exploitable by “1-more” attackers. This
demonstrates that our new notion of (cid:96)-more extractability
is strictly stronger than the previous one.

Our next step is to achieve such a stronger notion. We
show, somewhat surprisingly, that the stronger notion can
be achieved under the same assumptions used by the con-
struction of Bitansky et al. [10], i.e., a variant of the Knowl-
edge of Exponent Assumption (KEA) and DLog. Thus, we
conclude that, even though (cid:96)-more extractability is strictly
stronger, KEA and DLog are still suﬃcient to achieve it.

Theorem 1.2

(Informal). DLog and (a variant of )

KEA imply (cid:96)-more extractable hash.

We remark that KEA is non-falsiﬁable (cf. [42]), and it
is indeed a strong assumption. However, one can argue
that non-falsiﬁability might be inherent for extractable hash
functions, and thus (cid:96)-more extractability. We recall that Bi-
tansky et al. [10] showed that, extractable hash function
families imply succinct non-interactive argument of knowl-
edge (SNARK), and Gentry and Wichs [35] showed that
SNARK is unlikely to be constructed based on falsiﬁable as-
sumptions. Thus, non-falsiﬁable assumptions are likely to be
inherent for achieving ((cid:96)-more) extractability. We note that
some variants of KEA were shown to contradict (public-coin)
diﬀering-inputs obfuscation and indistinguishability obfus-
cation [12, 13]; the variant we use is suitably deﬁned to cir-
cumvent this contradiction.

Next, we construct non-malleable codes using (cid:96)-more ex-
tractable hash functions. The crux of our methodology is
to adapt the “public-key-encrypt-and-prove” method of [40],
using our new (cid:96)-more extractable hash, yielding eﬀectively a
“(one-time-symmetric-key-encrypt)-and-hash” approach for
obtaining non-malleable codes. In particular, we prove the
following (informally stated):

Theorem 1.3

(Informal). (cid:96)-more extractable hash (
with some additional properties) implies non-malleable codes
in the split-state model.

Our scheme produces codewords of length |s| + 9 · k +
2 · log2(k). In Table 1.1 we compare our construction with
the current state of the art on the split-state setting. Our
scheme is truly eﬃcient in terms of codeword length, and it
is one order of magnitude better than the combination of [40]
+ [2] + [43] + [37], which is the most competitive scheme
that can be constructed,4 based on the current state of the
4For the sake of this comparison, we instantiate [40] with
the eﬃcient zero-knowledge proofs of [37] and the leakage
resilient public-key encryption of [43]; moreover we observe
that the resulting code is compatible with the compiler of [2]
(it satisﬁes “augmented non-malleability”, a property deﬁned
in the latter paper) and thus we can make the resulting
system rate 1. This provides codeword length |s| + O(k2),
cited in Table 1.1.

1318art. We note that, existing constructions in the information-
theoretic setting, such as [3, 4], and the work built on top of
them, e.g., [2], might require very large constants, inherited
by the results in additive combinatorics (cf. conclusion of
the work [3]).
1.2 Technical Overview
Concepts of extractability and (cid:96)-more extractability.
Informally, a family of functions, H, is extractable, if for a
uniform h ∈ H, sampling an element v ∈ Image(h), with-
out actually evaluating the function on a pre-image s, such
that h(s) = v, is infeasible. This idea is formalized in the
following way: for any algorithm Av, there exists an extrac-
tor EAv , such that, if Av produces some v ∈ Image(h), EAv
outputs s, such that h(s) = v. Clearly, such families are in-
teresting only if they posses some sort of hardness property,
like one-wayness, otherwise the problem is trivial.

In this work, we introduce the notion of (cid:96)-more extractable
hash function families, for which the extractability property
holds, even if Av is given access to (cid:96) valid hash values. Even
though (cid:96)-more extractability looks similar to extractabil-
ity (0-more extractability in our deﬁnition), we provide a
separation between those two primitives. Before explaining
further details, we ﬁrst recall the underlying assumption,
t-KEA, and the construction of Bitansky et al. [10].

t-KEA and the extractable hash function family of [10].
Assuming a group G, of prime order p, the Knowledge of
Exponent Assumption (KEA), introduced by Damg˚ard [25],
states the following: any adversary that is given a generator,
g, of G, and a random group element ga, produces the pair
(gs, gas), only if it “knows” the exponent s. The assumption
was later extended by [8, 38], by requiring that, given gr1 ,
gar1 , gr2 , gar2 , it is infeasible to produce v = gr1s1+r2s2 and
va, without “knowing” s1, s2. This assumption, generalized
for t = poly(log |G|) pairs gri , gari , is referred to as t-KEA
by [10].

An element from the hash function family of [10] is de-
scribed by the pair (gr, gar), for uniformly random vector r,
and element a. Note that, gr denotes the value (gr1 , . . . , grt ),
where r = (r1, . . . , rt). The hash of a message s = (s1, . . . , st),
is the pair (g(cid:104)r,s(cid:105), ga(cid:104)r,s(cid:105)), where (cid:104)r, s(cid:105) denotes the inner
product of r, s. It is not hard to see that the hash value
can be computed eﬃciently given the message and the de-
scription of the hash function, and assuming the t-KEA, the
above hash function family is extractable, or in our terminol-
ogy, 0-more extractable. As we argue in the next paragraph,
this family is not 1-more extractable, and thus, extractabil-
ity does not imply (cid:96)-more extractability.

we show in Lemma 3.5, that the above construction is not
1-more extractable.

Next we present our strategy for constructing 1-more ECRH.

Our main observation is that, even though the above hash
function family is malleable, the modiﬁed hash value, v(cid:48), has
some structure: it is the hash value of the message yielded
after applying an aﬃne transformation on the original mes-
sage, s, (in the above case, the aﬃne transformation was
x · s). Interestingly, we show that under the t-KEA, apply-
ing an aﬃne transformation is the only thing the adversary
can do! In particular, we show that, if the adversary out-
puts a valid, new hash value, v(cid:48), then there exists an extrac-
tor that extracts an aﬃne transformation on the underlying
message. So, in order to make the hash non-malleable (and
then 1-more extractable), we ﬁrst encode c ← Enc(s) using
a non-malleable code against aﬃne functions, and then we
compute v = (g(cid:104)r,c(cid:105), ga(cid:104)r,c(cid:105)). This approach can be viewed
as a computational analogue of a non-malleable reduction,
as previously used by [4], and then formally presented by [3]
(both are in the information-theoretic setting).

It turns out that, in order to apply the methodology de-
scribed above, a slightly stronger ﬂavor of non-malleability is
required for the underlying code, which we formalize as ran-
domness simulatable non-malleable codes. Below, we brieﬂy
discuss this notion and we give the main idea of the proposed
scheme.

Randomness simulatable NM codes against aﬃne
tampering. This notion of non-malleability is stronger
than the standard one, in the sense that, besides simulating
the pre-image of the tampered codeword, ˜s, the simulator,
also produces the randomness of the encoder, ˜sr, such that
the encoding of ˜s with randomness ˜sr, produces the tam-
pered codeword. The main idea of our construction method
is given in the next paragraph.

1, s(cid:48)

1, s2

i = s(cid:48)

2), decoding proceeds as follows: if s2

For any message s, the encoder secret shares s into (s1, s2),
using a two-out-of-two, additive, secret sharing scheme, and
outputs c = (s1, s2, s2
2). Then, for any codeword c =
(s1, s2, s(cid:48)
i, for
i ∈ {1, 2}, the decoder outputs s1 + s2, otherwise, it outputs
⊥. An aﬃne tampering function, f , against the code is de-
scribed by the pair (b, d), and the application of f on a code-
word c, yields the codeword d · c + b. We prove security of
the above code by considering the following cases (roughly).
If d = 0, then the tampered codeword is completely over-
written by b, and clearly, the output of the decoder depends
only on b. If d (cid:54)= 0, then, we argue that, either the attack
leaves the codeword intact, i.e., d = 1, b = 0, or the de-
coding of the tampered codeword is ⊥, with overwhelming
probability.

1-more Extractable Collision Resistant Hash (ECRH).
Suppose the adversary receives a hash value v = h(s) =
(g(cid:104)r,s(cid:105), ga(cid:104)r,s(cid:105)), for some unknown message s, and then com-
putes v(cid:48) = vx = (g(cid:104)r,xs(cid:105), ga(cid:104)r,xs(cid:105)), for some non-zero x, of
its choice. Clearly, the new hash value v(cid:48) equals h(xs), and
thus, it is valid. Then, assuming an extractor for the cur-
rent family, under the “1-more” setting, we can retrieve the
original message s, by ﬁrst extracting xs and then dividing
it by x. This idea can be turned into a DLog solver, and
thus, assuming the hardness of DLog with respect to G,

5The size of the CRS is O(k), see [37]. The size of the
CRS in our construction is roughly 32k bits, cf. Section 4.
CRS size is independent of |s|.

In Section 5.2, we formally deﬁne randomness simulatable,
non-malleable codes, and prove security for the proposed
scheme. It is worth to point out that the idea of construct-
ing a NM-code for aﬃne functions, as an intermediate step
for providing split-state codes, was also followed by [4], still,
our technique diﬀers signiﬁcantly, and their code does not
directly satisfy our requirements. Moreover, in [22] the au-
thors construct AMD codes, still their notions are slightly
diﬀerent and do ﬁt in our framework.

NM codes against split-state tampering. Our con-
struction of non-malleable codes is inspired by the one of
Liu and Lysyanskaya [40], so we ﬁrst recall their construc-
tion. To encode a message s, their encoder outputs (sk, (pk,

1319Scheme

[4]
[3]3

[4] + [2]

[40] + [2] + [43] + [37]

This work

O(cid:0)(|s| + k)7 log7(|s| + k)(cid:1)

Codeword length
O(max{|s|, k})

|s| + O(cid:0)k7(cid:1)
|s| + O(cid:0)k2(cid:1)

|s| + 9 · k + 2 · log2(k)

Model

Information-theoretic
Information-theoretic

Assumption

N/A
N/A

Computational

Authenticated Encryption (AE)

Computational, CRS5 Leakage-Resilient PKE + robust NIZK
Computational, CRS

1-time Leakage-Resilient AE + KEA

Table 1: Comparison of multi-bit NMC’s in the split-state model. k is the security parameter.
In the
information-theoretic setting, typically security breaks with probability  = 2−Ω(k); in the computational
setting, we have  = negl(k), e.g.,  = k−ω(1) or 2−Ω(k), depending on how strong the underlying computational
assumption is.

Esk(s), π)), where E is the encryption algorithm of a leakage
resilient, semantically secure, public-key encryption scheme
(KGen, E, D), sk, pk, denote the secret key and public key,
respectively, and π is a non-interactive proof of knowledge
(robust NIZK), that proves the existence of a valid secret
key, decrypting the ciphertext to the message s.

Our construction signiﬁcantly improves the eﬃciency of
[40] by reﬁning their approach: (1) we replace the leakage
resilient public key encryption with a one-time, symmetric-
key, leakage resilient authenticated encryption; (2) we re-
place the (robust) NIZK proof with our 1-more-ECRH. Our
encoder works as follows: to encode a message s, the en-
, where E
coder outputs
is the encryption algorithm of a symmetric, leakage resilient
authenticated encryption scheme, sk is the secret key, h is a
(randomized) 1-more ECRH.

(r, sk), (e = Esk(s), v = h(r, sk))

(cid:16)

(cid:17)

Here the reader can easily observe that, using a func-
tion h that is extractable, or in our terminology, 0-more
extractable,
is not a good idea. Since generic authenti-
cated encryption schemes guarantee security only if the se-
cret key remains the same, it is possible to break security
if one modiﬁes sk as well.
In fact, it is possible to con-
struct an authenticated encryption such that it becomes
insecure if the secret key is modiﬁed. Therefore,
if the
hash is malleable, then the tampering function may com-
pute (e(cid:48) = Esk(cid:48) (s + 1), v(cid:48) = h(r, sk(cid:48))), where the sk(cid:48) is a bad
key that does not provide security. The tampered codeword
clearly decodes to a related message, and thus cannot be
non-malleable. Our 1-more extractability property resolves
this issue: even if the attacker is given access to a valid
hash value v, it cannot produce a valid hash value v(cid:48), unless
it knows a valid pre-image. Proving security for the above
construction requires to handle multiple subtleties, and we
refer the reader to Section 4 for further details.
Putting things together. We construct a one-time, sym-
metric, leakage resilient authenticated encryption scheme,
that in order to sustain 2·k+log2 k bits of leakage, it requires
key and ciphertext length |s| + 5 · k + 2 · log2(k) (cf. Section
7). In addition, for our 1-more ECRH we have |r| = |v| = 2k
(see Constructions 5.5 and 5.2). Therefore, the total code-
word length is |s| + 9 · k + 2 · log2(k). The encoding and
decoding procedures require 128 group operations (64 ex-
ponentiations plus 64 multiplications), independently of the
message length, plus the cost of one-time authenticated en-
cryption and decryption, respectively.
1.3 Related work

The ﬁrst non-malleable code in the split-state model, for
the information-theoretic setting was proposed by [28], yet
their scheme can only encode single-bit messages. Subse-

quent constructions for multi-bit messages are discussed in
the previous section. Non-malleable codes for other function
classes have been extensively studied, e.g., bit-wise inde-
pendent tampering [29], bounded-size function classes [32],
the k-split setting [18], block-wise tampering [16, 20], and
bounded depth and fan-in circuits [6]. The work of [3] devel-
ops beautiful connections among diﬀerent function classes.
Other aspects of non-malleable codes have also been stud-
ied, such as rate-function class tradeoﬀ, in the information-
theoretic setting [19]. Other variants of non-malleable codes
have been proposed, such as continuous non-malleable codes
[30], augmented non-malleable codes [2], locally decodable/up-
datable non-malleable codes [17, 23, 31], which were used
to secure the implementation of RAM computation. Leak-
age resilience was also considered as an additional feature,
e.g., [17, 23, 40].

KEAs and previous work. In [25], Damg˚ard introduces
KEA to construct a CCA-secure encryption scheme. In [8,
38], the authors extend the assumption of [25], and construct
three-round, zero-knowledge arguments. Abe and Fehr [1]
construct the ﬁrst perfect NIZK for NP with adaptive sound-
ness, by extending the assumption of [8]. Prabhakaran and
Xue [47] constructed statistically-hiding sets for trapdoor
DDH groups [27], by introducing a new knowledge assump-
tion. Gennaro et al. [34] proved that a modiﬁed version of
the Okamoto-Tanaka key-agreement protocol [44] satisﬁes
perfect forward secrecy against fully active attackers, by in-
troducing a new knowledge assumption.
In [9–11, 33, 36],
the authors construct succinct, non-interactive, arguments
of knowledge (SNARKs), and NIZKs, while in [41], Mie
presents a private information retrieval (PIR), scheme. In
[14,15,24], Canetti and Dakdouk provide an extensive study
on extractable functions. In [45], Parno et al. show how to
perform veriﬁable computation, eﬃciently.

In [12,13], the authors show that, assuming indistinguisha-
bility obfuscation [7], extractable one-way functions, and
thus ECRHs, does not exist against adversaries receiving
arbitrary, polynomial-size, auxiliary input,
if the extrac-
tor is ﬁxed before the attacker’s auxiliary input. On the
other hand, they show that, under standard assumptions,
extractable one-way functions, may exist against adversaries
with bounded auxiliary input.

In this work, and as it is suggested by [12], we consider
individual auxiliary, i.e., we allow the auxiliary info of the
extractor to depend on the attacker’s auxiliary info, and
therefore, we do not contradict the impossibility results of
[12, 13].

13202. PRELIMINARIES

In this section we present basic primitives and notation

that we use in our constructions.

Definition 2.1

(Notation). N+, R+, denote the set
of positive natural and real numbers, respectively. For t ∈
N+, [t] is the set {1, . . . , t}. For vectors x, y, (cid:104)x, y(cid:105) is the
inner product of x, y, and [x]i is the i-th coordinate of x.
For strings x, y, x||y, is the concatenation of x, y, and
|x| denotes the length of x. For a distribution D over a
set X , x ← D, denotes sampling an element x ∈ X , ac-
cording to D, x $← X , denotes sampling a uniform ele-
ment x, from X , and UX denotes the uniform distribution
over X . The statistical distance between two random vari-
ables X, Y , with range D, is denoted by ∆(X, Y ), i.e.,
u∈D | Pr[X = u] − Pr[Y = u]|. Moreover,
∆(X, Y ) = 1
“≈” and “≈c”, denote statistical and computational indistin-
2
guishability, respectively. A function f : N → R+ is negli-
gible, if for every positive polynomial poly(·), and all suﬃ-
ciently large k, f (k) ≤ 1/poly(k), and negl(k) denotes an
unspeciﬁed, negligible function, in k. For a random vari-
able X, H∞(X) and ˜H∞(X), denote the min-entropy, and
average min-entropy, of X, respectively. Finally, for any
element g and vector r = (r1, . . . , rt), gr = (gr1 , . . . , grt ).

(cid:80)

Below, we deﬁne coding schemes, based on the deﬁnitions
of [29, 40].

Definition 2.2. (coding scheme in the common ref-
erence string (crs) model [40] ) A (κ, ν)-coding scheme
in the CRS model, κ, ν ∈ N, is a triple of algorithms (Init,
Enc, Dec) such that:
Init is a randomized algorithm which
receives 1k, where k denotes the security parameter, and
produces a common reference string Σ ∈ {0, 1}poly(k), and
(Enc(1k, Σ,·), Dec(1k, Σ,·)) is a (κ, ν)-coding scheme, κ, ν =
poly(k).

For brevity, 1k will be omitted from the inputs of Enc and
Dec. In the full version of the paper we provide the standard
deﬁnitions of coding schemes and non-malleability. Now we
state the deﬁnition of strong non-malleability in the CRS
model based on the deﬁnitions of [29, 40].

Definition 2.3. (strong non-malleability in the crs
model [29,40]) Let (Init, Enc, Dec) be a (κ, ν)-coding scheme
in the common reference string model, and F be a family of
functions f : {0, 1}ν → {0, 1}ν . For any CRS Σ, f ∈ F and
s ∈ {0, 1}κ, deﬁne the tampering experiment

(cid:26) c ← Enc(Σ, s), ˜c ← f Σ(c), ˜s = Dec(Σ, ˜c)

(cid:27)

Output same∗ if ˜c = c, and ˜s otherwise.

TamperΣ,f

s

def=

which is a random variable over the randomness of Enc and
Dec. The coding scheme (Init, Enc, Dec) is strongly non-
malleable with respect to the function family F, if for each
f ∈ F and any s0, s1 ∈ {0, 1}κ,

Σ, TamperΣ,f
s0

k∈N

Σ, TamperΣ,f
s1

,

k∈N

where Σ ← Init(1k), and “≈” may refer to statistical, or
computational, indistinguishability, with parameter k.

According to the standard deﬁnition of non-malleability, the
decoding procedure is not randomized, however, as it is sug-
gested by Ball et al. [6] Dec may be randomized.

(cid:110)(cid:16)

(cid:17)(cid:111)

≈(cid:110)(cid:16)

(cid:17)(cid:111)

Next we state the t-variant, due to [10], of the Knowledge
of Exponent assumption (KEA), [8, 25, 38], with individual
auxiliary inputs for adversary and extractor, which is known
not to contradict the impossibility results of [12, 13].

Assumption 2.4

(t-KEA assumption). Let t ∈ N.

There exists a group generation algorithm G, such that for
any pair (G, g) sampled according to G(1k), where G is a
group of prime order p ∈ (2k−1, 2k), the following holds: for
any PPT algorithm A with auxiliary input auxA ∈ {0, 1}poly(k),
there exist PPT extractor EA with auxiliary input auxE ∈
{0, 1}poly(k), such that for all suﬃciently large k ∈ N,

(cid:20) (v, v(cid:48)) ← A(gr, gar, auxA), v(cid:48) = va :

(cid:21)

x ← EA(gr, gar, auxE ) ∧ g(cid:104)r,x(cid:105) (cid:54)= v

≤ negl(k).

Pr

(G,g)←G(1k)
$←Zp×Zt
(a,r)

p

Below, we deﬁne the class of aﬃne functions.

Definition 2.5

(The function family Faﬀ ). For any
set M and any t ∈ N+, we deﬁne the following function class

Faﬀ = {f (s) = d · s + b | b, s ∈ Mt, d ∈ M}.

Next we recall the deﬁnition of extractable hash of [10].
The deﬁnition can be modiﬁed to have diﬀerent auxiliary
inputs for adversary and extractor as the t-KEA above.

Definition 2.6

(Extractable hash [10]). An eﬃciently
samplable hash function ensemble H = {Hk}k∈N is extractable,
if for any PPT algorithm A, there exists a PPT extractor
A , such that for all large k ∈ N and any auxiliary input
EH
aux ∈ {0, 1}poly(k):

(cid:20) y ← A(h, aux),∃x : h(x) = y :

(cid:21)

Pr
h←Hk

x(cid:48) ← EH

A (h, aux) ∧ h(x(cid:48)) (cid:54)= y

≤ negl(k).

Below, we deﬁne the split-state functions class, Fss, and
the λ-bit leakage function class Lλ. A deﬁnition for split-
state leakage functions was considered in [40].

Definition 2.7

(The split-state function family Fss).

For any, even, ν ∈ N and any eﬃciently computable function
f : {0, 1}ν → {0, 1}ν , f ∈ Fss, if there exist eﬃciently com-
putable functions f1 : {0, 1}ν/2 → {0, 1}ν/2, f2 : {0, 1}ν/2 →
{0, 1}ν/2, such that for every x1, x2 ∈ {0, 1}ν/2 × {0, 1}ν/2,
f (x1||x2) = f1(x1)|| f2(x2).

Definition 2.8

(The λ-bit leakage function class Lλ).

For any λ ∈ N, Lλ is the set of the eﬃciently computable
functions that output λ bits, i.e., for any g ∈ Lλ, g : {0, 1}∗ →
{0, 1}λ.

Next, we state the deﬁnition of semantically secure authen-
ticated encryption, against one time leakage.

Definition 2.9. (semantically secure authenticated

encryption against one time leakage) Let k be the se-
curity parameter, let (KGen, E, D) be a symmetric encryption
scheme and let L be a set of functions. Then, (KGen, E, D) is
authenticated, semantically secure against one-time leakage
with respect to L, if

1. (Correctness): For every message s, Pr[Dsk(Esk(s)) =

s] = 1, where sk ← KGen(1k).

13212. (Semantic security):

for any function g ∈ L and
any two messages s0, s1, the following distributions are
(either computationally or statistically) indistinguish-
able:

(cid:17)

Esk(s1), g(sk)

,

(cid:16)

(cid:17) ≈(cid:16)

Esk(s0), g(sk)
where sk ← KGen(1k).

3. (Unforgeability): For every PPT algorithm A =
(cid:21)

(A1,A2), the probability
(cid:20)

(cid:12)(cid:12)(cid:12)(cid:12) sk ← KGen(1k); (s, st) ← A1(1k);

e ← Esk(s); e(cid:48) ← A2(e, st)

(cid:48)
(cid:48) (cid:54)= e ∧ Dsk(e

) (cid:54)= ⊥

Pr

e

is negligible in k.

Here, it should be noted that the leakage function is being
deﬁned by the attacker before receiving the challenge cipher-
text, otherwise semantic security breaks.

3.

(cid:96)-MORE EXTRACTABLE HASH FUNC-
TION FAMILIES

In this section we deﬁne the notion of (cid:96)-more extractable
hash function families, and we provide a general discussion
on the primitive.

Definition 3.1. ((cid:96)-more extractable hash function
families) For (cid:96) ∈ N, an eﬃciently samplable hash function
ensemble H = {Hk}k∈N, is (cid:96)-more extractable, if for any
PPT algorithm Av and any auxAv ∈ {0, 1}poly(k), there ex-
Av and auxE ∈ {0, 1}poly(k), such that
ist a PPT extractor EH
for all PPT algorithms As, any large k ∈ N and any vector
of messages s = (s1, . . . , s(cid:96)),

Exps,hzAv ,As,EH
Av

((cid:96), auxAv , auxE ) = 1

≤ negl(k),

(cid:20)

Pr

hz←Hk

where,

(cid:21)

Exps,hzAv ,As,EH
Av
∀i ∈ [(cid:96)], sri ← U{0,1}poly(k) , vi = hz(sri , si)

((cid:96), auxAv , auxE ) :

(hash computation)

sr = (sr1 , . . . , sr(cid:96) ), v = (v1, . . . , v(cid:96))
(˜v, st) ← Av(hz, v, auxAv ) (hash tampering)
(ˆsr, ˆs) ← EH
Av (hz, v, auxE ) (pre-image extraction)
(˜sr, ˜s) ← As (hz, sr, s, st) (pre-image tampering)
If hz(˜sr, ˜s) = ˜v ∧ ∀i : ˜v (cid:54)= vi ∧ hz(ˆsr, ˆs) (cid:54)= ˜v, return 1
otherwise, return 0

The main steps in the above experiment are the following.
Initially, we sample randomness for the hash, and perform
the hash computation over (cid:96) ∈ N, pre-images. For determin-
istic hash function families we just omit randomness sam-
pling, and we compute the hash, only using the messages.
The challenge for the attacker Av, is to produce a valid hash
value ˜v, given (cid:96) has values, denoted as v, and auxiliary infor-
mation auxAv . Then, the extractor EH
Av is executed, given v
and its own auxiliary input auxE . Notice, that, we allow the
auxiliary input of the extractor to depend on the attacker’s
auxiliary input.6 Finally, the adversary As produces a valid
pre-image for ˜v, while given all information generated dur-
ing the execution. The output of the experiment is 1, if Av
6For this reason our deﬁnition is not contradicting the

impossibility results of [12, 13].

produces a valid hash value ˜v, As produces a valid pre-image
for ˜v, while the extractor fails.

Leaving aside the fact that the above deﬁnition consid-
ers randomized function families, the major diﬀerence be-
tween the current deﬁnition and the one given by Bitansky
et al. [9, 10] (Deﬁnition 2.6), is two-fold: ﬁrst the “(cid:96)-more”
generalization that allows the attacker to have access to (cid:96)
valid hash values for which it does not know the pre-images,
prior to delivering its own hash value. Second, the intro-
duction of the algorithm As, that takes the place of the
existential quantiﬁer that appears in the original deﬁnition.
This is in fact a weakening of the original deﬁnition, in the
sense that the extractor is allowed to fail in case a pre-image
exists but is not eﬃciently computable based on the view of
the adversary (this would not be allowed in the original def-
inition).
Note, that, the existence of As does not trivialize the prob-
lem for the extractor since the extractor is challenged to pro-
duce a valid pre-image for ˜v, given only the code of Av and
its own auxiliary input (and in particular it lacks access to
the state of Av and the program of As).

It is easy to see that, constructing (cid:96)-more extractable hash
function families that are non-compressing, can be achieved
using existing tools, such as robust NIZKs [26]. Here we
construct an (cid:96)-more extractable, collision resistant, hash
(ECRH) function family, achieving length-eﬃciency compa-
rable to that of a regular hash function.

In the following lemma we prove that, for any (cid:96)-more
ECRH function family, the output of the extractor should
match the output of As, in case both of them output valid
pre-images, otherwise we break collision resistance.

Lemma 3.2. Let H = {Hk}k∈N be a collision resistant,
(cid:96)-more extractable, eﬃciently samplable, hash function en-
Av , auxE , As, s =
semble. Then, for any Av, auxAv , EH
(cid:35)
(s1, . . . , s(cid:96)), (cid:96), as they were deﬁned in Deﬁnition 3.1, the
probability

(cid:34)

(ˆsr, ˆs) (cid:54)= (˜sr, ˜s)

Pr

hz←Hk

((cid:96), auxAv , auxE ) = 0

hz(˜sr, ˜s) = ˜v, ˜v (cid:54)= vi, i ∈ [(cid:96)]

(cid:12)(cid:12)(cid:12)(cid:12)(cid:12) Exps,hzAv ,As,EH

Av

is negligible in k.

For the proof see the full version of the paper.

Next, we show a separation of 0-more extractability and
general (cid:96)-more extractability as we discussed in the intro-
duction. In particular, we prove that the 0-more extractable
hash of [10] is not 1-more extractable. Before doing so, we
ﬁrst revisit their construction, which is based on the t-KEA
assumption (Assumption 2.4).

Construction 3.3. (0-more extractable hash from
t-kea [10] ) Let G be a group-generation algorithm. An in-
stance of a (kt, 2k)-compressing, hash function family, H∗ =
(Gen∗, h∗), with respect to G, is deﬁned as follows:

1. Gen∗(1k): sample (G, g, p) ← G(1k), p ∈ (2k−1, 2k),
p, where p = |G|, and output z =

$← Zp × Zt

(a, r)
(G, gr, gar).

2. Hashing computation: on input s, compute h∗

z(s) =

(g(cid:104)r,s(cid:105), g(cid:104)ar,s(cid:105)).

In [10] the authors prove that Construction 3.3 is collision
resistant.

1322Lemma 3.4. (collision resistance for construction
3.3 [10] ) Assuming the hardness of the discrete logarithm
problem, with respect to a group G, Construction 3.3 is col-
lision resistant, with respect to G.

The above construction is also extractable with respect to
Deﬁnition 2.6 and 0-more extractable, where both properties
follow from the t-KEA assumption. In the following lemma
we prove that Construction 3.3 is not 1-more extractable.

Lemma 3.5. (construction 3.3 is not 1-more extrac-
table) Let H∗ be the hash function family of Construction
3.3, with respect to a group generation algorithm G. Then,
assuming the diﬃculty of the discrete logarithm problem for
G, H∗ is not 1-more extractable.

In the introduction, we argued that the hash function fam-
ily of Construction 3.3 is highly malleable, and thus not 1-
more extractable, under the discrete logarithm assumption.
We formalize the proof in the full version.

4. A NON-MALLEABLE CODE AGAINST

SPLIT-STATE TAMPERING

In this section, we present our construction of non-malleable

codes against split-state tampering functions. Our construc-
tion requires (i) a one-time, authenticated, symmetric-key
encryption scheme that is also leakage resilient, and (ii) a
1-more ECRH.

Construction 4.1. Let Hk = (Gen, h) be a hash func-
tion family, and let (KGen, E, D) be a symmetric encryption
scheme. We deﬁne a coding scheme (Init, Enc, Dec), as fol-
lows:

• Init(1k): sample z ← Gen(1k) and set Σ = z.
• Enc(Σ,·): let s be the input to the encoder. The en-
coder samples sk ← KGen(1k), r $← {0, 1}poly(k), e ←
Esk(s), and outputs
. In particular,
the left part of the codeword is (r, sk), while the right
part is (e, hz(r, sk)).

r, sk, e, hz(r, sk)

(cid:16)

(cid:17)

• Dec(Σ,·): let (r, sk, e, v) be the input to Dec. If hz(r, sk)
= v, the decoder outputs Dsk(e), otherwise, it outputs
⊥.

Since the input message to hz, sk, possesses adequate en-
tropy, it is possible to omit r in the above construction, still
for the sake of clarity we stick to the formulation provided in
Deﬁnition 3.1 and we use independent randomness for hash-
ing sk. In what follows we prove that Construction 4.1 is
strongly non-malleable against Fss (Deﬁnition 2.7), assum-
ing that for any f = (f1, f2) ∈ Fss, f1, f2, aﬀect (r, sk) and
(e, v), independently, i.e., we assume the strings r||sk, e||v,
are of length ν/2, where ν is the length the codeword.7

Intuition for the construction. Before formally ana-
lyzing the construction, we ﬁrst discuss the ideas on why
our construction is secure. Consider a split-state tamper-
ing function (f1, f2), where f1 is applied to (r, sk), and f2 is
applied to (e, v). To prove non-malleability, roughly speak-
ing, we need to simulate the tampering experiment without
knowing the underlying message distribution. A ﬁrst idea is

7This can always be achieved using padding.

to simulate the left side with (r(cid:48), sk(cid:48)), and the right side with
(e(cid:48) = Esk(cid:48) (0), v(cid:48) = h(r(cid:48), sk(cid:48))), where r(cid:48), sk(cid:48) is fresh random-
ness and key, respectively, hoping to infer the ﬁnal outcome
of the tampering experiment correctly due to the semantic
security of the encryption.

There are several subtleties in doing so. First and fore-
most, the simulator needs to be able to produce the decod-
ing of the codeword in case v(cid:48) is modiﬁed by f2. This is
where 1-more extractability will be used to obtain a valid
pre-image, (ˆr, ˆsk).
It might be very tempting to conclude
the simulation by outputting the decrypted message D ˆsk(ˆe)
(where ˆe is the modiﬁed codeword). However, this may not
be consistent with the real-world experiment, as the values
produced by the extractor (ˆr, ˆsk) might not be consistent
with the output of f1. To check consistency, the simulator
would want to check the output of f1, yet such a simulation
would be impossible to prove since it depends on sk, where
the indistinguishability between e(cid:48) and e does not hold in the
presence of it. To go around this, we use a similar technique
to Liu and Lysyanskaya [40], who observed that, the equal-
ity test between f1(ˆr, ˆsk) and f1(r, sk) can be performed via
the leakage of a universal hash (cf. the full version) with
log2 k bits of output. Putting this to our setting, by requir-
ing the encryption (KGen, E, D) to be a one-time semanti-
cally secure, symmetric-key authenticated encryption, that
is secure under 2k + log2 k bits of leakage, is suﬃcient to
facilitate the simulation. We also note that the case when
v(cid:48) is not modiﬁed by f2 can be easily taken care of by the
security of the authenticated encryption: as long as the key
is not modiﬁed, any attempt to modify the ciphertext will
result in an invalid ciphertext.

Theorem 4.2. Let k be the security parameter, Hk be a
1-more extractable hash function family that outputs β(k)
bits, β(k) = poly(k), and let (KGen, E, D) be an authen-
ticated, semantically secure, symmetric encryption scheme,
that is leakage resilient against Lλ, λ(k) = ω(log k) + β(k).
Then, Construction 4.1 is strongly non-malleable against
Fss.

Proof. Following the deﬁnition of strong non-malleability
(Deﬁnition 2.3), we need to prove that for any f = (f1, f2) ∈
) ≈c
Fss and any pair of messages s0, s1, (Σ, Tamperf,Σ
), where Σ ← Init(1k). We introduce a se-
(Σ, Tamperf,Σ
s1
ries of hybrids (see Figure 1), and the proof can be derived
directly from the indistinguishability between adjacent hy-
brids. We ﬁrst explain the hybrids and deﬁne the notation
used in those experiments.

s0

• Given a tampering function f = (f1, f2) and message
, is exactly the original

s, the ﬁrst experiment, Expf,Σ,s
0
tampering game, Tamperf,Σ

, of Deﬁnition 2.3.

s

• In Expf,Σ,s

1

, we slightly modify the previous hybrid by
checking whether the function f2 has modiﬁed the hash
value v. Intuitively, by the collision resistance property
of the hash function family Hk, if f2 does not modify
v, then the attack produces a valid codeword, ˜c, only
if the parts of ˜c that constitute the pre-image of ˜v, are
kept intact, i.e., (r, sk) = (˜r, ˜sk), otherwise there is a
collision. In addition, assuming sk = ˜sk, we have that,
if ˜e (cid:54)= e, then the output of the decoder should be
⊥, otherwise we break the authenticity under leakage
(v is considered as leakage over sk) property of the

1323encryption scheme. On the other hand, if v (cid:54)= ˜v, the
output of the current experiment is produced as in
Expf,Σ,s

.

0

• In Expf,Σ,s

1

2

, we modify the previous experiment for the
case in which v is modiﬁed: instead of using the real
decoding procedure, we use the extractor of the hash
function family, to extract a pre-image (ˆr, ˆsk), for ˜v,
and then compute the output, ˜s, with respect to that
pre-image. However, we cannot output ˜s directly as
we still need to check consistency with the output of
f , i.e., we need to check whether (ˆr, ˆsk) is equal to
(˜r, ˜sk). The indistinguishability between the current
hybrid and the previous one, follows by the 1-more ex-
tractability property of the hash function, which, in-
formally, guarantees that if ˜c is a valid codeword, then
EH
Av produces a valid pre-image for ˜v, with overwhelm-
ing probability. If the extracted pre-image is consistent
with the one output by f , the current hybrid outputs
a non-bottom value, equal to the one output by the
decoding procedure of Expf,Σ,s
. On the other hand, if
(ˆr, ˆsk) (cid:54)= (˜r, ˜sk), Lemma 3.2 guarantees that (˜r, ˜sk) is
not a valid pre-image for ˜v, with overwhelming proba-
bility, and the current experiment properly outputs ⊥.
Finally, it is straightforward to see, that if ˜v is invalid,
both experiments output ⊥.
In order to deﬁne the extractor EH
Av , introduced in
, we ﬁrst need to deﬁne Av, auxAv , with re-
Expf,Σ,s
spect to hz, v, e, and f = (f1, f2). Formally, we deﬁne
the following:
1. (Deﬁne Av): Av(hz, v, auxAv ) := ([f2(auxAv , v)]2,
2. (Choose auxiliary info for Av): set auxAv = e.
3. (Existence of the extractor, EH
Av , and aux-
iliary input, auxE ): Given Av and auxAv , by
the 1-more extractability property of Hk, there
exists an extractor EH
Av , with hardwired auxiliary
info, auxE , that computes (ˆr, ˆsk) ← EH
Av (hz, v).
The extractor EH
and all sub-
sequent experiments (for brevity we denote it as
E).

st), where st = (f2(auxAv , v), auxAv , v).

Av is used in Expf,Σ,s

2

2

We remind, that, for any vector v, [v]i, denotes the
i-th coordinate of v.

• In Expf,Σ,s

3

, we modify the consistency check proce-
dure, so that we access the right part of the codeword,
only through leakage. Instead of checking consistency
using directly the output of f1, we do the check using
a random hash function, ¯h, from a universal family (cf.
full version), applied to the output of f1, plus one more
bit, that indicates whether f1 has modiﬁed its input.
Here, the hash v is computed through leakage over
sk. The experiment diﬀers from the previous one only
when there is a collision against ¯h, which happens with
negligible probability, as ¯h is a universal hash function.
let ¯h ←
Below, we formalize the above procedure:
¯Hλ−1 be a random hash function from a universal hash
function family, that outputs λ− 1 bits. We deﬁne the
function g¯h,hz (·) as follows:

(cid:40)

g¯h,hz

(x, y) =

(0, ¯h(f1(x, y)), hz(x, y)),
(1, ¯h(f1(x, y)), hz(x, y)),

if f1(x, y) = (x, y),
if f1(x, y) (cid:54)= (x, y).

2

We view g¯h,hz as a leakage function that outputs
λ = ω(log k) + β(k) bits in total. The experiment will
then use the leaked value to check consistency, instead
of using the whole string output by f1. Concretely,
we introduce the random variable b, which depends
on the output of the leakage function, and we mod-
ify Expf,Σ,s
, so that the condition “If (b = 1)”, intro-
duced in Expf,Σ,s
, is exactly the same as the condition
“If (r, sk, e) = (˜r, ˜sk, ˜e)”, of experiment Expf,Σ,s
. This
modiﬁcation does not induce any statistical diﬀerence.
In the next modiﬁcation, we check equality between
(ˆr, ˆsk), (˜r, ˜sk), by checking if ¯h(ˆr, ˆsk) = ¯h(f1(r, sk)).
Clearly, this part induces a statistical diﬀerence only
if there is a collision against ¯h, which happens with
negligible probability, since ¯h is a universal hash func-
tion, chosen by the current experiment, independently.

2

3

• Finally, we are going to show that Expf,Σ,s

is indistin-
→
guishable from Expf,Σ,
0
denotes the zero-message. This follows by the seman-
tic security of the leakage resilient encryption scheme
(Deﬁnition 2.9).

, for any message s, where

→
0

3

3

the full version of the paper.

A concrete presentation of the hybrids, is given in Figure 1.
The indistinguishability between the hybrids in proved in
(cid:4)
Length of the CRS. The length of the CRS in our con-
struction is roughly 32k bits: we need to hash a 6k-bit
(roughly) key of an authenticated encryption scheme and
then encrypt the message using that key; this would require
the parameters for the 16-KEA to be on the CRS, resulting
in the 32k bits length.
5. CONSTRUCTING 1-MORE ECRH

In this section, we present our construction of 1-more
extractable hash function families. Our construction is in
two steps: (1) we ﬁrst present a construction assuming a
coding scheme that satisﬁes randomness simulatable non-
malleability (RSS-NM), against aﬃne tampering functions,
and (2) we show how to construct such a code. Finally, we
present Corollary 5.7 to summarize our overall construction,
by putting all things together in a single statement. As we
have already discussed on the introduction, the idea of con-
structing a NM-code for aﬃne functions, as an intermediate
step for providing split-state codes, was also followed by [4],
still, our technique diﬀers signiﬁcantly, and their code does
not directly satisfy our requirements. Moreover, in [22] the
authors construct AMD codes, still their notions are slightly
diﬀerent and do ﬁt in our framework.
5.1

1-more extractable hash functions from RSS-
NM codes against afﬁne functions

In this section we construct a collision resistant, 1-more
extractable hash function family. Before doing so, we present
the notion of “randomness simulatable, strongly non-malleable
codes” (RSS-NMC). This notion is stronger than strong non-
malleability in the sense that besides simulating the pre-
image, ˜s, of the tampered codeword, the simulator also needs
to produce the randomness of the encoder, ˜sr, such that the
encoding of ˜s with randomness ˜sr, produces the tampered
codeword. To ease the presentation of RSS-NMC, we mod-
ify the syntax of non-malleable codes, so that the Dec algo-
rithm returns, not only the decoded message ˜s, but also the

13240

:

Expf,Σ,s
(r, sk, e, v) ← Enc(s), c = (r, sk, e, v)
(˜r, ˜sk) ← f1(r, sk), (˜e, ˜v) ← f2(e, v)
˜c = (˜r, ˜sk, ˜e, ˜v)
˜s = Dec(˜c)

1

:

Expf,Σ,s
(r, sk, e, v) ← Enc(s)
(˜r, ˜sk) ← f1(r, sk), (˜e, ˜v) ← f2(e, v)
˜c = (˜r, ˜sk, ˜e, ˜v)
If v = ˜v :

If (r, sk, e) = (˜r, ˜sk, ˜e) : set ˜s = same∗
Else : set ˜s = ⊥

If v (cid:54)= ˜v :

Output same∗ if ˜c = c, and ˜s otherwise.

Set ˜s = Dec(˜c)

Output ˜s.

2

:

Expf,Σ,s
(r, sk, e, v) ← Enc(s)
(˜r, ˜sk) ← f1(r, sk), (˜e, ˜v) ← f2(e, v)

If (r, sk, e) = (˜r, ˜sk, ˜e) : set ˜s = same∗
Else : set ˜s = ⊥

If v = ˜v :

If v (cid:54)= ˜v :

(ˆr, ˆsk) ← E(hz, v)
set ˜s = ⊥

3

:

Expf,Σ,s
sk ← KGen(1k), e ← Esk(s)
r $← {0, 1}poly(k), ¯h ← ¯Hλ−1
(lmod, lhash, v) ← g¯h,hz (r, sk) , (˜e, ˜v) ← f2(e, v)
b ← (lmod = 0 ∧ e = ˜e)
If v = ˜v :

If v (cid:54)= ˜v :

If (b = 1) : set ˜s = same∗
Else : set ˜s = ⊥
(ˆr, ˆsk) ← E(hz, v)
set ˜s = ⊥

If (ˆr, ˆsk) = (˜r, ˜sk) :

If hz(ˆr, ˆsk) = ˜v, set ˜s = D ˆsk(˜e)

Output ˜s.

If ¯h(ˆr, ˆsk) = lhash :

If hz(ˆr, ˆsk) = ˜v, set ˜s = D ˆsk(˜e)

Output ˜s.

Figure 1: Hybrid experiments for the proof of Theorem 4.2. Their programs are based on (Enc, Dec), the
encoding scheme, (KGen, E, D) the encryption scheme, and E, the extractor that is speciﬁed in the proof. The
gray part signiﬁes the portion of the code that diﬀers from the previous experiment.

randomness string ˜sr for the encoder Enc. This is the string
that in the tampering experiment the simulator should be
able to match.8

Definition 5.1. (randomness simulatable, strongly
non-malleable code) Let (Enc, Dec) be a (κ, ν)-coding sche-
me and F be a family of functions f : {0, 1}ν → {0, 1}ν . For
every f ∈ F and s ∈ {0, 1}κ, deﬁne the tampering experi-
(cid:27)
ment

c ← Enc(s), ˜c ← f (c), (˜sr, ˜s) = Dec(˜c)

(cid:26)

Output same∗ if ˜c = c, and (˜sr, ˜s) otherwise.

Tamperf
s

def
=

which is a random variable over the randomness of Enc and
Dec. A coding scheme (Enc, Dec) is randomness simulatable,
strongly non-malleable (RSS-NM), with respect to the func-
tion family F, if for every f ∈ F and any s0, s1 ∈ {0, 1}κ,
we have:

Tamperf
s0

k∈N

Tamperf
s1

k∈N

where “≈” may refer to statistical, or computational, indis-
tinguishability. For coding schemes in the common reference
string model, the deﬁnition is analogous.

(cid:110)

(cid:111)

≈(cid:110)

(cid:111)

Next we present our construction:

Construction 5.2

(1-more extractable hash). Let
G be a group-generation algorithm and let (Enc, Dec) be a
(kt, kt(cid:48))-coding scheme, t, t(cid:48) = O(poly(k)). An instance of
a (kt, 2k)-compressing hash function family H = (Gen, h) is
deﬁned as follows:

8It is possible to deﬁne RSS-NMC without modifying
the operation of Dec at the expense of slightly complicating
the deﬁnition of non-malleability. Due to the fact that our
RSS-NMC construction conforms to the modiﬁed syntax,
we opt for the simpler alternative.

1. Gen(1k): sample (G, g, p) ← G(1k), (a, r) $← Zp × Zt(cid:48)
p ,

where p = |G|, and output z = (G, gr, gar).

2. Hashing computation: on input s = (s1, . . . , st),
$← U{0,1}poly(k) , compute hz(sr, s) = (g(cid:104)r,c(cid:105),

sample sr
g(cid:104)ar,c(cid:105)), where c ← Enc(sr, s).

For coding schemes (Init, Enc, Dec) in the CRS model, Gen(1k)
outputs (z, Σ), where Σ ← Init(1k).
In the following we prove that Construction 5.2, which is a
composition of a coding scheme (Enc, Dec), with construc-
tion 3.3 (the 0-more extractable hash function by Bitan-
sky et al. [10]), is collision resistant, 1-more extractable,
and uniform under leakage, assuming that (Enc, Dec), satis-
ﬁes certain properties. Then, in Section 5.2, we instantiate
(Enc, Dec) with the desired properties. Below, we prove that
Construction 5.2 is collision resistant.

Lemma 5.3. Let G be any group generation algorithm.
Then, assuming the hardness of the discrete logarithm prob-
lem on G, and the underlying encoding algorithm is injective,
Construction 5.2 is collision resistant with respect to G.

Proof. The work [10] proves that the hash function fam-
ily of Construction 3.3, i.e., H∗, is collision resistant, as-
suming the diﬃculty of the discrete logarithm problem. We
note that Construction 5.2 is a composition of Enc(·) and
H∗. Following a simple fact that any injective function com-
posed with a collision resistant hash function still results in a
collision resistant hash function (composition in any order),
we can conclude that the hash function family of Construc-
tion 5.2 is collision resistant, under the same assumption.
(cid:4)

In the following theorem, we prove that, under certain

assumptions, Construction 5.2, is 1-more extractable.

1325Theorem 5.4. Let t(k), t(cid:48)(k) = O(poly(k)), (Enc, Dec)
be any RSS-non-malleable, (kt, kt(cid:48))-coding scheme, against
Faﬀ , let H be the hash function family of Construction 5.2
with respect to (Init, Enc, Dec), and assume that for any mes-
sage s, H∞ (Enc(s)) ≥ k +ω(log k). Then, assuming t(cid:48)-KEA
and the hardness of DLog, H is 1-more extractable, with re-
spect to (Init, Enc, Dec).

Proof. For k ∈ N, let (Enc, Dec) be an RSS-NM, (kt, kt(cid:48))-
coding scheme, against Faﬀ , t(k), t(cid:48)(k) = O(poly(k)), and let
H be the (kt, 2k)-compressing, collision-resistant, hash func-
tion family of Construction 5.2. Following Deﬁnition 3.1, we
need to prove that for any PPT algorithm Av with auxiliary
input auxAv , there exist extractor EH
Av and auxiliary input
auxE , such that for any PPT algorithm As, any large k and
every message s = (s1, . . . , st) ∈ Zt
p,

Pr

(1, auxAv , auxE ) = 1

Exps,hzAv ,As,EH
Av

≤ negl(k). (1)
hz←Hk
Clearly, if Av fails to produce a new valid hash, or, if As
fails to produce a valid pre-image for the new hash, the
experiment simply outputs 0, and there is no challenge for
the extractor. Therefore, the interesting case is when Av
produces a valid hash value, say ˜v, while having access to
an element in the range of the hash, say v, and As produces
a valid pre-image for ˜v, while having access to s, v, ˜v, and
any other state information produced by Av. Hence, for
the rest of the proof we assume ˜v (cid:54)= v, and (˜sr, ˜s) is a valid
pre-image for ˜v, i.e., hz(˜sr, ˜s) = ˜v.
Given any Av with auxiliary input auxAv , the idea behind
the deﬁnition of the extractor, EH
Av , and its auxiliary input,
auxE , goes as follows:

(cid:20)

(cid:21)

• First we deﬁne an adversary against the hash func-
tion family H∗, of Construction 3.3: ¯Av(h∗
z(cid:48) , auxAv ) :=
Av(hz, v, auxAv ), where ¯Av ﬁrst interprets the descrip-
tion of the hash function h∗
z(cid:48) , as (hz, v), i.e., as a de-
scription of a hash function in H and a hash value v,
and then executes Av(hz, v, auxAv ). The function h∗
z(cid:48)
will be stated concretely below.

• Since H∗ is a 0-more extractable hash function family,
and assuming h∗
z(cid:48) is indistinguishable from an element
in H∗, there exists an extractor ¯EH∗
with its auxiliary
¯Av
input aux ¯E , that extracts a valid pre-image for ˜v, with
respect to h∗
z(cid:48) . We deﬁne the auxiliary input auxE :=
aux ¯E .

The extractor is deﬁned below.
The extractor EH
Av :
Input: (z = (gr, gar), v = (gr(cid:48)
, gar, gar(cid:48)

1. Set z(cid:48) = (gr, gr(cid:48)

a description of hash function h∗
messages with t(cid:48) + 1 coordinates.
(h∗
.

2. Sample (b1, . . . , bt(cid:48) , d) ← ¯EH∗
¯Av
(b1, . . . , bt(cid:48) , d) = (b, d) ∈ Zt(cid:48)+1

p

), auxE ).

, gar(cid:48)
). Here, we interpret z(cid:48) as
z(cid:48) ∈ H∗, for vector

z(cid:48) , auxE ) and set f =

3. Interpret f as an aﬃne function that on input (x1, . . .
xt(cid:48) ) outputs (dx1 +b1, dx2 +b2, . . . , dxt(cid:48) +bt(cid:48) ), and then
sample (ˆsr, ˆs) ← Daﬀ
f is the simulator of the
underlying RSS-NM code, (Enc, Dec), parameterized
by the aﬃne function f .

f , where Daﬀ

4. Output: (ˆsr, ˆs).

The extractor is deﬁned with respect to any input v, still
by the deﬁnition of the (cid:96)-more experiment, v is always a
valid hash value, i.e., v = hz(s) = (g(cid:104)r,c(cid:105), ga(cid:104)r,c(cid:105)), where
c ← Enc(sr, s), for some message s. Then, for any As,
and message s, we are going to analyze the execution of
Exps,hzAv ,As,EH
(1, auxAv , auxE ). We ﬁrst prove that with over-
Av
whelming probability, the following events happen:

• E1: h∗

of Av on input (hz, v).

z(cid:48) (b1, . . . , bt(cid:48) , b0) = ˜v. Recall that ˜v is the output

• E2: Enc(˜sr, ˜s) = f (c). Recall that (˜sr, ˜s) is the output

of As.

We formalize those ideas in a series of claims, where their
(cid:4)

concrete proofs are given in the full version of the paper.
5.2 Constructing RSS-NM codes

In this section, we construct RSS-NM codes as required

by the previous section.

Construction 5.5

(The code for Faﬀ ). For any k ∈
N, t = O(poly(k)), we deﬁne a (kt, (2t + 4)k)-coding scheme
(Init, Enc, Dec) in the CRS model,9 as follows:

• Init(1k): sample a k-bit prime p ∈ (2k−1, 2k) and set

Σ = p.

• Enc(Σ,·):

let s = (s1, . . . , st) ∈ Ft

then output c =(cid:0)v, v2, r, r2, u1, u2

p be the input to
Enc. Sample two random ﬁeld elements v, r $← Fp, and
,
where ui = si − r for i ∈ [t].

(cid:1) ∈ F2t+4

1, . . . , ut, u2
t

p

• Dec(Σ,·): on input c = (v, ¯v, r, ¯r, u1, ¯u1, . . . , ut, ¯ut),
the decoder checks whether ¯v = v2, ¯r = r2, and ¯ui = u2
for all i ∈ [t]. If so, then it outputs (v, r, u1 + r, u2 +
i
r, . . . , ut + r), otherwise, outputs ⊥.

All operations are performed modulo p. We also consider the
deterministic version of Enc by allowing the randomness to
be given on the input. In that case we have c = Enc(Σ, sr, s),
where sr = (v, r).
Notice, that, the randomness employed by the above con-
struction is 2k, independently of the message length.

Theorem 5.6. The code of Construction 5.5 is random-
ness simulatable, strongly non-malleable (Deﬁnition 5.1), with
respect to Faﬀ . In addition, for any message s, H∞ (Enc(s)) ≥
k + ω(log k).

The proof intuition is presented in the introduction and
the concrete proof is given in the full version of this paper.
5.3 Our resulting instantiation

By plugging Construction 5.5, as the underlying coding

scheme to Construction 5.2, we receive the corollary:

Corollary 5.7. Under the DLog assumption and t-KEA,

there exists a 1-more extractable, collision resistant, hash
function family Hk.

Proof. Let (Init, Enc, Dec) be the (kt, (2t + 4)k), RSS-
NM code of Construction 5.5. Then we construct Hk by
plugging in (Init, Enc, Dec), as the underlying coding scheme
to the hash function family of Construction 5.2. Clearly,

9Note that the CRS is not essential for this encoding, but

for simplicity we describe the code in this model.

1326by Lemma 5.3, Hk is collision resistant as the underlying
encoding algorithm is injective. By Theorem 5.6, the under-
lying coding scheme is RSS-non-malleable against Faﬀ , and
moreover, for any message s, H∞ (Enc(s)) ≥ k + ω(log k).
Thus, by Theorem 5.4, Hk is 1-more extractable. This con-
(cid:4)
cludes the proof of this corollary.
6. CONSTRUCTING (cid:96)-MORE EXTRACTA-

BLE HASH

In the “(cid:96)-more” setting, the attacker is given v1, . . . , v(cid:96),
hash values, and produces a new hash value ˜v. Having the
techniques from the “1-more” setting, one can easily argue
the attack against ˜v (in the (cid:96)-more setting), can be reduced
to an aﬃne attack against the codewords c1, . . . , c(cid:96), that
are related to v1, . . . , v(cid:96), respectively. In order to construct
(cid:96)-more ECRH, for (cid:96) > 1, we generalize the notion of RSS-
NM codes, for multiple codewords. The generalization is a
straightforward extension of Deﬁnition 5.1, where the tam-
pering function receives (cid:96) codewords and the simulator needs
to recover the message and randomness in case the output of
the tampering function is not among the given codewords.
The formal is deﬁnition is given in the full version.

Clearly, for (cid:96) = 1, the notion of multi-codeword RSS-
NMC matches Deﬁnition 5.1. In order to construct, (cid:96)-more
ECRH, for (cid:96) > 1, we need an RSS-NM code, for the follow-
ing function class.
Definition 6.1

(The function class ¯F (cid:96)

aﬀ ). We deﬁne

the following function class
¯F (cid:96)
aﬀ = {f (x1, . . . , x(cid:96)) = f1(x1) + . . . + f(cid:96)(x(cid:96)) | fi ∈ Faﬀ}.
We present the following lemma.

aﬀ , for (cid:96) > 1.

Lemma 6.2. The code of Construction 5.5, (Enc, Dec), is

a multi-codeword RSS-NM code against ¯F (cid:96)

Proof. A proof sketch is given in the full version.

(cid:4)
In the “(cid:96)-more” setting the attacker receives vi = (g(cid:104)r,ci(cid:105),
ga(cid:104)r,ci(cid:105)), i ∈ [(cid:96)], and constructs a valid hash ˜v. The proof of
ing that ˜v = g(cid:104)r,(cid:80)(cid:96)
Theorem 5.4 easily extends to the “(cid:96)-more” setting by prov-
i=1 fi(ci)(cid:105)), where (f1, . . . ,
f(cid:96)) ∈ ¯F (cid:96)
aﬀ , and we achieve extractability using the simulator
of the underlying, rss-nmc for multiple codewords. Thus,
we are able to show the following theorem.

i=1 fi(ci)(cid:105), ga(cid:104)r,(cid:80)(cid:96)

Theorem 6.3. Under the DLog assumption and t-KEA,
Construction 5.2, instantiated with the Construction 5.5, is
an (cid:96)-more extractable hash function family.

The proof is essentially the same as that of Theorem 5.4, as
we discussed above.
7.

INSTANTIATING AUTHENTICATED EN-
CRYPTION

In the following we instantiate one-time leakage-resilient,

authenticated, semantically secure symmetric encryption (Def-
inition 2.9), against λ bits of leakage. The idea is to combine
a leakage-resilient pseudorandom generator [46] with a mes-
sage authentication code that outputs k bits.

Construction 7.1

(Authenticated encryption). Let

PRG be a pseudo-random generator, i.e., PRG : {0, 1}2λ →
{0, 1}|s|+k, and let (Gen, Mac, Vrfy) be a message authentica-
tion code that outputs tags of length k (cf. [39]). We deﬁne
a symmetric encryption scheme (KGen, E, D), as follows:

• KGen(1k): sample sk $← {0, 1}2λ.
• Esk(·): On input message s, compute (r0, r1) = PRG(sk),
where |r0| = |s| and |r1| = k, e = r0 + s, t = Macr1 (e),
and outputs (e, t).

• Dsk(·): On input (e, t), compute (r0, r1) = PRG(sk),
(e, t) = 1, output s = r0 − e, otherwise

and if Vrfyr1
output ⊥.

The PRG of [46] considers |sk| = 2λ/α, and sustains αλ bits
of leakage (cf. [50]), where α ∈ [0, 1] depends on how strong
the underlying assumption is.
In the above construction
we use the strongest assumption, i.e., α = 1, which yields
|sk| = 2λ. The ciphertext length is |s|+k, and by setting λ =
2k +log2 k, which is adequate for our needs, we receive |sk|+
|e|+|t| = 5k+2 log2 k+|s|. In the full version we analyze the
above construction and we provide instantiations that use
weaker assumptions. By plugging the above instantiation to
our split-state non-malleable code, the total codeword length
is |s| + 9 · k + 2 · log2(k), since the hash and the randomness
for computing it, are of size 2k, each.

8. REFERENCES
[1] M. Abe and S. Fehr. Perfect nizk with adaptive

soundness. In TCC, pages 118–136, 2007.

[2] D. Aggarwal, S. Agrawal, D. Gupta, H. K. Maji,

O. Pandey, and M. Prabhakaran. Optimal
computational split-state non-malleable codes.
Cryptology ePrint Archive, Report 2015/1063, 2015.

[3] D. Aggarwal, Y. Dodis, T. Kazana, and M. Obremski.
Non-malleable reductions and applications. In STOC,
pages 459–468, 2015.

[4] D. Aggarwal, Y. Dodis, and S. Lovett. Non-malleable

codes from additive combinatorics. In STOC, pages
774–783, 2014.

[5] S. Agrawal, D. Gupta, H. K. Maji, O. Pandey, and

M. Prabhakaran. CRYPTO, chapter Explicit
Non-malleable Codes Against Bit-Wise Tampering
and Permutations, pages 538–557. 2015.

[6] M. Ball, D. Dachman-Soled, M. Kulkarni, and

T. Malkin. Advances in Cryptology – EUROCRYPT
2016, chapter Non-malleable Codes for Bounded
Depth, Bounded Fan-In Circuits. 2016.

[7] B. Barak, O. Goldreich, R. Impagliazzo, S. Rudich,

A. Sahai, S. Vadhan, and K. Yang. On the
(im)possibility of obfuscating programs. In CRYPTO,
pages 1–18. 2001.

[8] M. Bellare and A. Palacio. The knowledge-of-exponent
assumptions and 3-round zero-knowledge protocols. In
CRYPTO, pages 273–289. 2004.

[9] N. Bitansky, R. Canetti, A. Chiesa, S. Goldwasser,

H. Lin, A. Rubinstein, and E. Tromer. The hunting of
the snark. Cryptology ePrint Archive, Report
2014/580, 2014.

[10] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer.

From extractable collision resistance to succinct
non-interactive arguments of knowledge, and back
again. In ITCS, pages 326–349, 2012.

[11] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer.
Recursive composition and bootstrapping for snarks
and proof-carrying data. In STOC, pages 111–120,
2013.

1327[12] N. Bitansky, R. Canetti, O. Paneth, and A. Rosen. On

the existence of extractable one-way functions. In
STOC, pages 505–514, 2014.

[13] E. Boyle and R. Pass. Limits of extractability

assumptions with distributional auxiliary input. In
ASIACRYPT, pages 236–261. 2015.

and Key-Derivation for Poly-size Tampering Circuits,
pages 111–128. 2014.

[33] R. Gennaro, C. Gentry, B. Parno, and M. Raykova.

EUROCRYPT ’13, chapter Quadratic Span Programs
and Succinct NIZKs without PCPs, pages 626–645.
2013.

[14] R. Canetti and R. Dakdouk. Extractable perfectly

[34] R. Gennaro, H. Krawczyk, and T. Rabin.

one-way functions. In Automata, Languages and
Programming, pages 449–460. 2008.

[15] R. Canetti and R. Dakdouk. Towards a theory of

extractable functions. In TCC, pages 595–613. 2009.

[16] N. Chandran, V. Goyal, P. Mukherjee, O. Pandey, and

J. Upadhyay. Block-wise non-malleable codes. IACR
Cryptology ePrint Archive, page 129, 2015.

[17] N. Chandran, B. Kanukurthi, and S. Raghuraman.

Information-Theoretic Local Non-malleable Codes and
Their Applications, pages 367–392. TCC 2016-A. 2016.

[18] E. Chattopadhyay and D. Zuckerman. Non-malleable

codes against constant split-state tampering. In
FOCS, pages 306–315, 2014.

[19] M. Cheraghchi and V. Guruswami. Capacity of

non-malleable codes. In ITCS, pages 155–168, 2014.

[20] S. G. Choi, A. Kiayias, and T. Malkin. Bitr: Built-in

tamper resilience, 2011.

[21] S. Coretti, U. Maurer, B. Tackmann, and D. Venturi.

TCC, chapter From Single-Bit to Multi-bit Public-Key
Encryption via Non-malleable Codes, pages 532–560.
2015.

[22] R. Cramer, Y. Dodis, S. Fehr, C. Padr´o, and

D. Wichs. Detection of algebraic manipulation with
applications to robust secret sharing and fuzzy
extractors. In EUROCRYPT, pages 471–488. 2008.

[23] D. Dachman-Soled, F.-H. Liu, E. Shi, and H.-S. Zhou.
TCC 2015, chapter Locally Decodable and Updatable
Non-malleable Codes and Their Applications, pages
427–450. 2015.

[24] R. R. Dakdouk. Theory and application of extractable

functions, 2009.

[25] I. Damg˚ard. Towards practical public key systems

secure against chosen ciphertext attacks. In CRYPTO,
pages 445–456. 1992.

[26] A. De Santis, G. Di Crescenzo, R. Ostrovsky,

G. Persiano, and A. Sahai. Robust non-interactive
zero knowledge. In CRYPTO, pages 566–598. 2001.

[27] A. Dent and S. Galbraith. Hidden pairings and

trapdoor ddh groups. In Algorithmic Number Theory,
pages 436–451. 2006.

[28] S. Dziembowski, T. Kazana, and M. Obremski.

Non-malleable codes from two-source extractors. In
CRYPTO, pages 239–257. 2013.

[29] S. Dziembowski, K. Pietrzak, and D. Wichs. D.:

Non-malleable codes. In ICS, 2010.

[30] S. Faust, P. Mukherjee, J. B. Nielsen, and D. Venturi.
TCC 2014, chapter Continuous Non-malleable Codes,
pages 465–488. 2014.

[31] S. Faust, P. Mukherjee, J. B. Nielsen, and D. Venturi.

PKC 2015, chapter A Tamper and Leakage Resilient
von Neumann Architecture, pages 579–603. 2015.

[32] S. Faust, P. Mukherjee, D. Venturi, and D. Wichs.

EUROCRYPT, chapter Eﬃcient Non-malleable Codes

Okamoto-tanaka revisited: Fully authenticated
diﬃe-hellman with minimal overhead. In ACNS, pages
309–328. 2010.

[35] C. Gentry and D. Wichs. Separating succinct
non-interactive arguments from all falsiﬁable
assumptions. Cryptology ePrint Archive, Report
2010/610, 2010.

[36] J. Groth. Short pairing-based non-interactive

zero-knowledge arguments. In ASIACRYPT, pages
321–340. 2010.

[37] J. Groth and A. Sahai. Eﬃcient non-interactive proof
systems for bilinear groups. In EUROCRYPT, pages
415–432, 2008.

[38] S. Hada and T. Tanaka. On the existence of 3-round

zero-knowledge protocols. In CRYPTO ’98, pages
408–423. 1998.

[39] J. Katz and Y. Lindell. Introduction to Modern

Cryptography. 2007.

[40] F.-H. Liu and A. Lysyanskaya. Tamper and leakage

resilience in the split-state model. In CRYPTO, pages
517–532. 2012.

[41] T. Mie. Polylogarithmic two-round argument systems,

2008.

[42] M. Naor. CRYPTO ’03, chapter On Cryptographic

Assumptions and Challenges, pages 96–109. 2003.
[43] M. Naor and G. Segev. Public-key cryptosystems

resilient to key leakage. SIAM Journal on Computing,
pages 772–814, 2012.

[44] E. Okamoto and K. Tanaka. Key distribution system
based on identiﬁcation information. Selected Areas in
Communications, IEEE Journal on, pages 481–485,
1989.

[45] B. Parno, J. Howell, C. Gentry, and M. Raykova.

Pinocchio: Nearly practical veriﬁable computation. In
Security and Privacy, pages 238–252, 2013.

[46] K. Pietrzak. Advances in Cryptology - EUROCRYPT

2009: 28th Annual International Conference on the
Theory and Applications of Cryptographic Techniques,
Cologne, Germany, April 26-30, 2009. Proceedings,
chapter A Leakage-Resilient Mode of Operation. 2009.
[47] M. Prabhakaran and R. Xue. Statistically hiding sets.

In CT-RSA, pages 100–116. 2009.

[48] A. Sahai. Simulation-sound non-interactive zero
knowledge. Technical report, IBM RESEARCH
REPORT RZ 3076, 2001.

[49] A. R. Shaﬁ Goldwasser, Huijia Lin. Delegation of

computation without rejection problem from
designated veriﬁer cs-proofs. Cryptology ePrint
Archive, Report 2011/456, 2011.

[50] F.-X. Standaert, O. Pereira, Y. Yu, J.-J. Quisquater,

M. Yung, and E. Oswald. chapter Leakage Resilient
Cryptography in Practice, pages 99–134. 2010.

1328