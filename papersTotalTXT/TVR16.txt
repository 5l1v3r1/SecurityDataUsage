Automated Veriﬁcation of Electrum Wallet(cid:63)

Mathieu Turuani1, Thomas Voegtlin2, Michael Rusinowitch1

1 INRIA Nancy–Grand Est mathieu.turuani@inria.fr,rusi@loria.fr

2 Electrum Technologies GmbH thomasv@electrum.org

Abstract. We introduce a formal modeling in ASLan++ of the two-
factor authentication protocol used by the Electrum Bitcoin wallet. This
allows us to perform an automatic analysis of the wallet and show that
it is secure for standard scenarios in Dolev Yao model [Dolev 1981]. The
result could be derived thanks to some advanced features of the protocol
analyzer such as the possibility to specify i) new intruder deduction rules
with clauses and ii) non-deducibility constraints.

1 Context

Electrum is a popular Bitcoin Wallet. Thanks to a deterministic key derivation
algorithm (BIP32), users can regenerate their wallet from a secret seed phrase,
which protects them in case of loss or computer failure. It is a lightweight client,
which means that it does not need to download the whole Bitcoin blockchain.
Instead, the client communicates with a set of servers, and retrieves only needed
information. The private keys used to sign Bitcoin transactions are never com-
municated to the servers, and servers do not store users accounts.

In order to protect users from Bitcoin theft, Electrum provides two-factor
authentication, implemented using multi-signature addresses (P2SH) and an ex-
ternal co-signer (TrustedCoin). Our objective is to initiate the veriﬁcation of
Electrum’s two-factor authentication protocol in order to increase user conﬁ-
dence or detect potential weaknesses and rise warnings.

Several tools have been recently developed to perform fully automated anal-
ysis of cryptographic protocols (e.g. [Proverif]). Some have been able to discover
new ﬂaws and most of them rely on symbolic models where messages are con-
sidered as terms in some abstract algebra as opposed to sequences of bits in
more concrete models. In these tools generally no properties are assumed (and
exploited) about cryptographic primitives besides the fact that when a message
has been encrypted by some key, it can be recovered by applying the inverse key
to the ciphered text. Although symbolic analysis relies on high-level protocol
abstractions it has been able to discover important ﬂaws in real-world protocols
[Armando 2008]. Moreover, under some suitable hypothesis these analyses are
cryptographically sound, i.e. from the absence of ﬂaws at the symbolic level we
can derive the correctness of the protocol w.r.t. cryptographic models too.

(cid:63) This work has received funding from the European Research Council (ERC) under
the European Union’s Horizon 2020 research and innovation program (grant agree-
ment No 645865-SPOOC)

For this analysis we have employed Cl-Atse, a state-of-the-art protocol an-
alyzer eﬃcient and complete for bounded number of sessions [Turuani 2006]. It
is compliant with ASLan++ speciﬁcation language [von Oheim 2010], which al-
lowed us to model relevant properties of the BIP32 key-derivation functions.
Moreover, Cl-Atse’s unique ability to handle so-called non-deducibility con-
straints over the agent’s knowledge was fundamental in this analysis.

There exists a huge number of works on formal veriﬁcation of security proto-
cols. For instance, Bitcoin contracts have been modeled and veriﬁed using timed
automata [Andrychowicz 2014]. However, to our knowledge previous veriﬁcation
works have not considered Bitcoin wallets.

2 Electrum Wallet

Electrum users may decide to enable two-factor authentication on their wallet.
In that case, transactions will be signed by both the Electrum client and a
cosigning server (TrustedCoin), if the user authenticates himself using a one-time
password generated by Google Authenticator. The user (the human who owns
the electronic wallet) keeps an oﬄine copy of the wallet initialization data (seed
phrase), in order to regenerate their wallet in case of data loss or disappearance
of the cosigning service. A key feature of Electrum’s two-factor authentication
protocol is that the wallet regeneration procedure only requires the seed phrase,
and does not need the cosigning server.

The cosigning server, however, has no way to use the wallet without the
client’s signature. Electrum’s two factor authentication uses Bitcoin Pay-to-
Script-Hash addresses (P2SH), and the BIP32 standard for deterministic gener-
ations of keys. BIP32 allows the cosigning server to deterministically generate
new private keys -following a ’path’ from a root key- which is needed to sign
Bitcoin transactions, while the client alone is able to generate the corresponding
public keys, which are needed in order to create new P2SH addresses.

The interactions between agents are described by four sequences of actions:
initialisation (user/client), registration and conﬁrmation (client/server), and (re-
curring) transaction phase. Authentication is carried out via the Google OTP
function using a secret and the current time. BIP32 extended keys are denoted
by k,K,C for private/public keys and the associated chain parameter. Personal
data are denoted by: email for the client’s e-mail (public); time for the current
time (public); database for the server’s database (private); and a, b, c, d, ... for
some paths (public) used to build child keys in the BIP32 structure.

User and Client’s Initialization.

: Both knows Ks, Cs;

Initial knowledge
User generates two fresh seeds : Seed1 and Seed2;
User extracts the priv./public : k1,K1,C1 from Seed1;
k2,K2,C2 from Seed2;
keys and chain parameters
User ∗ → ∗ Client
: email.k1.C1.K1.C2.K2
Client computes the user IDs : LongUserID from K1,C1,K2,C2; -secret-

-secret-
-secret-
-secret-

UserID preﬁx of LongUserID;

This sequence of actions simulates an exchange between a user and his client
to model initialization. In practice, the Electrum client generates and shows to
the user a sequence of English words called the seed phrase. Two independent
BIP32 seeds are derived from this phrase, and only one of the private keys
derived from them is stored by the client. To avoid the trivial case of a client
already compromised when the seed phrase is generated, we model a user who
generates both BIP32 seeds and sends only one of the corresponding extended
private keys to the client. Let A → B : M denote a message M sent from A to
B. This is decorated by stars when the channel is secured, i.e. protected against
eavesdropping or modiﬁcation. The concatenation of messages is written with a
dot, as in email.k1. Finally, the long user ID is a hash of the public keys and
parameters, and the (short) user ID is built from its ﬁrst-10 characters.

New User Registration.

Initial knowledge
Client opens a channel
Client → Server
Server gets the user IDs : LongUserID from K1, C1, K2, C2;

: Client was initialized; Server knows ks, Ks, Cs;
: Session key Sk shared with Server;
: {|register.{email.K1.C1.K2.C2} Ks|} Sk;

-secret-

-secret-

: {|{Sec} K1|} Sk;

UserID preﬁx of LongUserID;
Server builds the secret : Sec from UserID, ks and Cs;
Server adds to database : UserID.email.K1.C1.K2.C2.false
Server → Client
This describes how a new client registers to the server, with new data later
conﬁrmed. The client uses the (known) server’s public key to open a secure chan-
nel with a fresh symmetric key Sk. We denote the symmetric and asymmetric
encryptions of M by {|M|} Sk and {M} Ks respectively. Then the client sends
its registration query, allowing the server to rebuild its IDs and ﬁll the database.
Finally, for future authentications a secret data is returned to the client.

-secret-

New User Conﬁrmation.

: Client was registered; Server knows ks, Ks, Cs;
: Session key Sk shared with Server;
-secret-
: OTP = googleOTP(Sec,time)
-secret-
: {|conﬁrm.UserID.OTP|} Sk;
: UserID.email.K1.C1.K2.C2.false
: Sec from UserID, Ks and Cs;
: OTP ?= googleOTP(Sec,time)
: {|false|} Sk; exit;

Initial knowledge
Client opens a channel
Client builds the OTP
Client → Server
Server reads database
Server builds the Secret
Server tests the OTP
if data not found
Server → Client
if OTP diﬀer
Server del. from database : UserID.email.K1.C1.K2.C2.false
Server → Client
otherwise
Server updates database : UserID.email.K1.C1.K2.C2.true
Server → Client

: {|false|} Sk; exit;

: {|true|} Sk;

-secret-

Now, the client must conﬁrm his registration before signing transactions.
The Electrum client does not store the OTP secret, but displays it to the user
who stores it on an external device with Google Authenticator. However, this
cannot be modeled directly since the D.Y. intruder rather concentrates on in-
ternet communications between the client and the server. Therefore, this step is
abstracted by a client who generates the OTP himself. The conﬁrmation phase
starts with the client opening a secure channel as before to send his request
and OTP. Depending on server’s agreement, true or f alse is returned and the
client data is either conﬁrmed or deleted from the database. The exit keyword
indicates procedure termination for both parties when the server disagrees.

Signing a Transaction with the Server.

Initial knowledge
Client opens a channel
Client creates a list
Client iterates

: Client was conﬁrmed; Server knows ks, Ks, Cs;
: Session key Sk shared with Server;
: SigList = empty list of signature requests;

-secret-

: Path = sequence of a, b, c, d, ...
: Script using key from K1,C1 following Path;
: Add Path.Script to SigList;
: {|sign.UserID.tx data.SigList.OTP|} Sk;
: UserID.email.K1.C1.K2.C2.true

choose a path
create a script
add to the list
Client builds the OTP : OTP = googleOTP(Sec,time);
Client → Server
Server reads database
Server builds the Secret : Sec from UserID, Ks and Cs;
Server tests the OTP
if data not found or OTP diﬀers
Server → Client
otherwise Server iterates

: OTP ?= googleOTP(Sec,time);
: {|false|} Sk; exit;

-secret-

-secret-

: pick-up Path.Script from SigList;
: k4 from ks,Cs following LongUserID.Path;
: Sign tx data and Script with k4 in signed tx;
: {|signed tx|} Sk;

select element
derive new key
sign the transaction
Server → Client
Once the client is registered, it is allowed to request transaction signatures.
As before, this is done by opening a secure channel with the server, and sending a
transaction request containing the one-time password generated with the current
time. The request also includes the transaction data tx data to be signed, along
with a list SigList of signature requests. Each element in this lists consists in
a Bitcoin script using a key derived from the client’s root key K1 (plus C1)
using the BIP32’s CKD pub (and CKD priv) method. The path used to derive
this key is also included in the list, so that the server can use it to derive his
own key too. This method allows the client and the server to forget all the keys
locally used in each transaction, as long as the root keys are safely stored along
with the paths used to derive new keys. Moreover, the two keys used to sign
transactions -client side and server side- are generated using the same, unique,
path. On the server side, this path is extended with the long user ID so that
all the keys used for all the clients are generated from one, single, root key pair

ks, Ks. Moreover, the server has no need to store key paths: the responsibility
to keep these is left to the client. In practice, these paths are of length two and
sequentially generated, so that a fast sieve allows the user to recover his keys in
case of client loss. Once successful, the server returns the signed transaction to
the client. While not modeled here, the Electrum server can also push the signed
transaction to the Bitcoin network for the client.

3 Modeling BIP32

The BIP32 standard describes a hierarchy of keys derived from a single seed
and by following paths, i.e. a sequences of integers. The master key generation
function is a hash and does not require any speciﬁc construction. The Child Key
Derivation (CKD) functions admit two variants: CKD pub for deriving public
keys and CKD priv for private keys. Each one takes a public (resp. private)
key, a chain parameter, and a path to follow, and produces the child public
(resp. private) key. Consequently the algebraic relation linking CKD pub and
CKD priv is: CKD priv(inv(K), C, S) = inv(CKD pub(K, C, S)) where inv is
the key inversion function, used here to specify the private key associated to
the public key K or to CKD pub(..). For simplicity we have omitted the chain
parameter in our description: it will be modeled by a function called cCKD in
our ASLan++ speciﬁcation. In our model, each public key is either the root
public key pk(A) of some agent A, or a child public key derived with BIP32.
Note that pk already exists in ASLan++ syntax and thus will not be redeﬁned.
The two CKD functions can be modeled by declaring a single pCKD function
which takes a private key (as would CKD priv) but computes the corresponding
public child key (as would CKD pub):

n o n i n v e r t i b l e pCKD ( private_key , message , message ) : p u b l i c _ k e y ;

where message is the generic type (used for a chain parameter and a path here),
and noninvertible ensures that this function can be freely used but the intruder
cannot retrieve the arguments from the result.

In our protocol model every occurrence of CKD pub(K, C, S) from the ini-
tial speciﬁcation is represented by pCKD(inv(K), C, S) and every occurrence
of CKD priv(K, C, S) is represented by inv(pCKD(K, C, S)). This modeling
ensures the validity of the above algebraic relation since for all K, C, S:

CKD priv(inv(K), C, S) = inv(pCKD(inv(K), C, S)) = inv(CKD pub(K, C, S))

The intruder deduction ability should be extended to take into account the
CKD functions from BIP32. Therefore we deﬁne these two new intruder deduc-
tion rules expressed by Horn Clauses in ASLan++:

iknows ( pCKD ( inv ( K ) ,C , S ) ) : - iknows ( K . C . S ) ;
iknows ( inv ( pCKD (K ,C , S ) ) ) : - iknows ( K . C . S ) ;

\% for CKD \ _pub
\% for CKD \ _priv

The ability for the intruder to deduce a public key from its inverse (private) key
is expressed using two Horn Clauses:

inv(pk(A))

Pub. key

pk(A)

CKD priv

pCKD

CKD pub

inv(pCKD(inv(pk(A)), ..))

Pub. key

pCKD(inv(pk(A)), ..)

Fig. 1. Example of key derivations with ﬁxed chain and path

iknows ( pk ( A ) )
iknows ( pCKD (K ,C , S ) ) : - iknows ( inv ( pCKD (K ,C , S ) ) ) ;

: - iknows ( inv ( pk ( A ) ) ) ;

These functions are summarized in Figure 3, where each arrow represents an
operator over keys, where both the chain parameter and the path are ﬁxed.

4 ASLan++ Wallet Model

The ASLan++ model for the Electrum wallet is detailed here. It speciﬁes the user
agent and his client software (separately), plus the three server agents described
previously. It also speciﬁes the security properties to be preserved in any run,
plus the intruder capabilities. Conforming to BIP32’s modeling from Section 3,
the CKD priv and CKD pub function are replaced by combining pCKD and inv.
Note that pCKD is universally known and thus can be used by the intruder. The
list containing the elements that the client want to be signed, and the list of these
elements once they are signed by the server, are represented with concatenation
of pairings. While the model contains variants for choosing Input inf o (the list of
signature requests), only the most general one where the intruder has full control
over it is used for the analysis. Moreover, the ASLan++ syntax uses names
starting with a non-capital letter to denote constants, e.g. atoms/nonces/... ,
and names starting with a capital letter for variables. Therefore, a key pair
denoted by Ks,ks (public/private) in the description of the protocol will now be
written Ks/inv(Ks) instead, with Ks a variable of type public key and inv(Ks)
the inverse of its value, thus the associated private key.

4.1 Attacker Model and Assumptions

Our analysis relies on the perfect cryptography hypothesis: no information about
the content of a ciphertext can be derived by agents that do not possess the de-
cryption key. Fresh random numbers used in a ciphering algorithm cannot be
derived either. Random numbers cannot be predicted by the intruder. A ci-
phertext is in general not malleable and therefore cannot be used to generate a
diﬀerent ciphertext without being decrypted ﬁrst. This can be slightly relaxed

when the protocol uses speciﬁc operators (Xor, exponentiation, ..): the alge-
braic properties of these operators that can be exploited are made explicit. Horn
Clauses are also used to express agent capabilities to modify or learn messages
that goes beyond the perfect cryptography hypothesis.

A honest agent follows the protocol speciﬁcation and is assumed to be pru-
dent, that is, the agent decrypts as soon as possible every part of a received
message, checks the content by relating it to its known data. In the same way
signatures are veriﬁed by agents whenever possible.

4.2 Security Properties

While the built-in ASLan++ security properties are ﬁne for protecting objects
with scope larger than just one session, they were not adequate for protecting
local objects inside sessions where one agent (e.g., the server) has no idea, and
do not truly care, if he is speaking to a honest client or not. The server has
to serve any client, honest or not, and he has no idea which one will contact
him. Therefore, instead of tweaking the built-in properties, we have designed
new speciﬁc ones for this kind of model:

uSecret ( message , message )
: fact ;
uChecks ( agent , message , message , message , message ) : fact ;

which associated security properties are:

uSecret : []( forall M K .

(! uSecret (M , K )

|

! iknows ( M ) | iknows ( K )

) ) ;

uChecks : []( forall A M K U V . (! uChecks (A ,M ,K ,U , V ) | A = i

| K = M

| ! U = V ) ) ;

where [] means ’in every trace at any moment’ and ! denotes the negation.
The ﬁrst one, uSecret(M, K), ensures that the message M remains unknown for
the intruder, unless he can build or deduce K. This is widely used to preserve the
security of some data inside a session, where K will be the session key. This way,
an attack is raised on a local data, or a data transmitted during a session, only
if the intruder has no access to the main key protecting it. Naturally, the session
key itself has its own security property, to check whether it can be captured
by the intruder. This method builds an interesting hierarchical structure among
security properties reﬂecting the dependencies between data and the means used
to protect them. This was made possible only thanks to the recent extension of
Cl-Atse (the analysis backend used for this study) that allows it to check for
non-deducibility constraints over the intruder knowledge. Indeed, this does not
simply require that the key K was received by the intruder, but that among the
inﬁnite set of possible intruder knowledge solutions of some set of constraints,
only those where he is unable to deduce that key, or to rebuild it from pieces,
are kept.

The second property, uChecks(A, M, K, U, V ), ensures that if the agent A is
not played by the intruder, then either the message M and K are equal, or the
messages U and V diﬀer. This is widely used to check the server’s responses to

the client’s requests. Therefore, in this context an attack is conservatively raised
iﬀ: i) the agent A was an honest agent; ii) the response M from the server diﬀers
from the expected result K; iii) the request (list of) parameter U was correct,
i.e. identical to its expected value V .

4.3 User Role

The ASLan++ User role models human owner(s) of an Electrum wallet to be
distinguished from a role played by software client(s), that owns only a subset of
User’s knowledge. The User role appears only during the initialization phase as
described in Section 2. Thus, he will ﬁrst generate two seeds using the f resh()
nonce generator, and declares them as secrets:

s e c r e t _ S e e d 1 :( Seed1 ) := fresh () ;
s e c r e t _ S e e d 2 :( Seed2 ) := fresh () ;

Then, he derives two key pairs K1/inv(K1) and K2/inv(K2) from the seeds,
plus their associated chain parameters C1 and C2, and declares the private keys
as secrets. The chain parameters (or the public keys) being sent to the server,
they can also be declared as secrets (for testing, as they are not critical) but under
the assumption that the server was not compromised (actively or passively), i.e.
that its root key remains private:

K1 := pk ( Seed1 ) ; uSecret ( inv ( K1 ) , Seed1 ) ;
K2 := pk ( Seed2 ) ; uSecret ( inv ( K2 ) , Seed2 ) ;
C1 := cp ( Seed1 ) ; C2 := cp ( Seed2 ) ;
uSecret ( C2 , inv ( pk ( server ) ) ) ;

Finally, he gives these initialization data to his client, necessarily through a
secure channel:

Actor * - >* Client : email . inv ( K1 ) . C1 . K1 . C2 . K2 ;

The secure channel is speciﬁed in ASLan++ syntax by arrow decorations: left
star for origin authenticity, and right-star for read-protection and guaranty of
delivery to the correct recipient.

4.4 Client Role

The Client role is played by Electrum software client on behalf of the user. After
a ﬁrst initialization phase:

User * - >* Actor : ? Email . inv (? K1 ) .? C1 .? K1 .? C2 .? K2 ;

where it receives its parameters from the User role, it computes the long user
ID (Long ID) and declares it as secret, truncates it to U ID, and deduces the
main server’s public key K3 and chain parameter C3 devoted to this user. Also
non essential or obviously public data are leaked to the intruder, in case some
real user would do so involuntarily:

:= pCKD ( inv ( pk ( server ) ) , cp ( server ) , Long_ID ) ;
:= cCKD (
pk ( server ) , cp ( server ) , Long_ID ) ;

K3
C3
Actor -> ? : Email . K1 . C1 . K2 . K3 . C3 ;

Then, the clients starts a registration process to the server. To do so, it ﬁrst
generates a fresh session key Sk and declares it as secret, then transmits it to
the server through a read-protected channel followed by the registration request
protected by that key:

s e c r e t _ S k :( Sk ) := fresh () ;
Actor -> Server :

Actor - >* Server : Sk ;

{| r egi ste r .{ Email . K1 . C1 . K2 . C2 } _pk ( server ) |} _Sk ;

After processing the request, the servers gives its answer protected by the session
key too:

Server -> Actor : {|{? Secret } _K1 |} _Sk ; uSecret ( Secret , Sk ) ;

This answer contains the Secret that will be used for further authentication
using the google OTP function. Naturally Secret is declared as a secret w.r.t.
the session key Sk. This goal is made inactive if the intruder can deduce or
compute Sk, namely if the session oﬃcially involves an intruder (but this is not
an attack) or if the session was compromised (but the goal associated to Sk must
trigger instead). Then, following the same method and using an OTP declared
as secret and generated through google otp(Secret, T ime) with T ime being the
current time of the client (correct or not), it casts the conﬁrmation request (with
a new session key) and gets the server Result, that could be true or f alse. This
response is checked for validity:

uChecks ( Server , true , Result , ctime , Time ) ;

i.e. the Result must be true unless the client did not use the current time
properly. This may generate an attack, see Section 5.2. Finally, the client casts a
signature request. This request uses a Raw transaction which is some fresh data
leaked to the intruder, plus a list of signature requests called Input inf o which
must be as general as possible, and thus, directly provided by the intruder at its
own discretion. This way, the intruder can choose the most dangerous values for
the client. At the end, the client checks the server’s response similarly as before.

4.5 Server Registration Role

The registration role is the ﬁrst of the three server roles. Its goal is to record new
user’s registration data. The model does not even need to check if a previous
user was already registered with the same ID, since the probability to ﬁnd hash
collisions by chance is considered to be negligible. Therefore, this role ﬁrst opens
a new connection to a client by receiving a session key, though a read-only
channel, followed by the request itself:

Client - >* Actor : ? Sk ;
Client ->

Actor :

{| r egi ste r .{? Email .? K1 .? C1 .? K2 .? C2 } _pk ( server ) |} _Sk ;

This allows him to rebuild the long and short user ID in the same way as the
client did on his side, along with the OTP’s secret which is an hash over the
user’s short ID, the private server’s key, and the server’s chain parameter:

Secret := hash ( UID . inv ( pk ( server ) ) . cp ( server ) ) ;
uSecret ( Long_ID , Sk ) ; uSecret ( Secret , Sk ) ; uSecret ( Long_ID , C2 ) ;

Naturally these data are also declared as secrets, w.r.t. the session key Sk since
the data allowing to rebuild Long ID, and Secret, are both transmitted in a
channel protected by Sk. However, we can notice that losing the session key Sk
here does not necessarily implies losing the long user ID, since the data building
it are also protected by the server’s public key. Therefore, it is declared as secret
a second time, but w.r.t. one of its element that was already declared as secret
by the User (c.f. Section 4.3), i.e. C2. We note here that this study does not
consider cryptographic attacks on the primitives. In particular, the server and
the hashing method must be resistant by other means to an intruder performing
e.g. huge series of (fake) client/server registrations to retrieve many pairs of U ID
and Secret with the objective of rebuilding the secret associated to a known,
honest, user ID. Finally, the server adds the client’s data to its database, and
sends the Secret back for further authentication:

database - > add ( UID . Email . K1 . C1 . K2 . C2 . false ) ;
Actor -> Client : {|{ Secret } _K1 |} _Sk ;

where f alse refers to the unconﬁrmed status, and the secret is protected by both
the session key and an encryption with the public key K1.

4.6 Server Conﬁrmation Role

The conﬁrmation role is mandatory to allow the client to send further requests.
It ensures that Google OTP can be used for authentication and if so, switch its
status from unconﬁrmed to conﬁrmed. The server starts this role as before, by
receiving a new session key though a read-only channel, followed by the request
itself containing the user ID from which the secret can be rebuilt:

Client - >* Actor : ? Sk ;
Client ->
Secret := hash ( UID . inv ( pk ( server ) ) . cp ( server ) ) ;

Actor : {| confirm .? UID .? OTP |} _Sk ;

This way, the server does not need to store each user’s secret in the database.
Then, the server has three choices, depending on the validity of the one-time
password and the content of the database for this user ID:

– Either the database contains a non-conﬁrmed user under that ID, and the
provided password was correct. Then the server validates the request by
switching the user status to conﬁrmed in the database, and sending back the
true response:

database - > remove ( UID . Email . K1 . C1 . K2 . C2 . false ) ;
database - > add (
UID . Email . K1 . C1 . K2 . C2 . true ) ;
Actor -> Client : {| res pon se . true |} _Sk ;

– Or the database contains a non-conﬁrmed user under that ID, but the pro-
vided password was not correct. Then the server deletes (yes, it does!) the
unregistered user account from the database, and sends back a f alse re-
sponse. Whatever the reason was, a user mistake or an intruder trying to
interfere with a wrong password, in both cases the client has to register
again:

database - > remove ( UID . Email . K1 . C1 . K2 . C2 . false ) ;
Actor -> Client : {| res pon se . false |} _Sk ;

– Or the database does not contains any non-conﬁrmed user under that ID. If
there exists some user registered and already conﬁrmed under that ID, it is
not seen here and thus it remains unchanged. Then the server simply sends
back a f alse answer:

Actor -> Client : {| res pon se . false |} _Sk ;

Moreover, in all three cases above, the server also declares the local data as
secrets within the session, i.e.:

uSecret ( Secret , Sk ) ; uSecret ( OTP , Sk ) ;

Other cases than these three could be introduced in future protocol variants. For
example, the server could send an adequate response when the user is already
registered. Depending of these future improvements on the server’s tests and
actions on data, a new analysis would be necessary.

4.7 Server Signature Role

The signature role is the master piece of the Electrum two factor authentication
protocol. It allows the client to cast Bitcoin transactions signed both by him
and the server. This is the most complex part of the protocol since the number
of signatures to perform for one single request is not ﬁxed, and thus requires
an iterative process. The server starts this role as usual by receiving the session
key followed by the request and uses it to rebuild the user secret and query the
database:

Client
Client

- >* Actor : ? Sk ;
->

Actor :

{| sign .? UID .? R a w _ t r a n s a c t i o n .? I n p u t _ i n f o .? OTP |} _Sk ;

Secret := hash ( UID . inv ( pk ( server ) ) . cp ( server ) ) ;
if ( database - > c ont ain s ( UID .? Email .? K1 .? C1 .? K2 .? C2 . true )

& OTP = g o o g l e _ o t p ( Secret , ctime ) ) { ...

Similarly to the conﬁrmation role, the server tests the database content and
one-time password for user authentication. If this test is positive then the server
processes Input inf o, i.e. the list of objects that must be signed, by the server for
some of them, and not for some others. This list is modeled by right-parenthesised
pairings, and the server iterates the process until no more pairing is found (the
last element in the list is supposed to be end):

while ( I n p u t _ i n f o = ? Elem .? Next ) {

if ( Elem = m ust Sig n (? A .? B .? Script ) ) { ...

The list elements of the form mustSign(..) are objects that the server is asked to
sign. Others are objects that can be simply ignored. For each object of this kind
found in the list, thus for each elementary signature request A.B.Script found
inside, the server computes the key pair K3/inv(K3) derived from his private
root key using BIP32 and following the long user ID plus A and B as path. For
readability, this is decomposed in two steps here:

K3 := pCKD ( inv ( pk ( server ) ) , cp ( server ) , Long_ID ) ;
C3 := cCKD (
pk ( server ) , cp ( server ) , Long_ID ) ;
K4 := pCKD ( inv ( pCKD ( inv ( K3 ) ,C3 , A ) ) , cCKD ( K3 , C3 , A ) ,B ) ;
C4 := cCKD (
pCKD ( inv ( K3 ) ,C3 , A ) , cCKD ( K3 , C3 , A ) ,B ) ;

An implementation of the server would certainly build K3/inv(K3) before the
loop, but this has no impact on the analysis. The server can now use inv(K4)
to sign the requested element, and add it to the list of signatures that he is
building, and proceed to the next element:

S i g n a t u r e s := S i g n a t u r e s .{ R a w _ t r a n s a c t i o n . Script } _inv ( K4 ) ;
I n p u t _ i n f o := Next ; s e c r e t _ K 4 p :( K4p ) := inv ( K4 ) ;
Empty := false ;

The private key inv(K4) is also declared as secret, but this time, for the server:
it is used for signing, so it must remain perfectly private to the server even if
this one communicates with a compromised client. The Empty variable records
the information that the signature list is not empty anymore. This is used right
after the end of the iterative process, to declare the ﬁnal signature list as a secret
w.r.t. the session key (since it is transmitted during the session):

if ( Empty = false ) { uSecret ( Signatures , Sk ) ; }

Note that this secrecy goal would be trivially invalidated without the condition.
Finally, the server can send back the signed list to the client:

Actor -> Client : {| res pon se . S i g n a t u r e s |} _Sk ;

If the password is incorrect or if the database does not contain a conﬁrmed used
of that ID, then the server simply replies f alse instead of the signature list. In
both cases (correct or not), the secrecy of the local data (such as the user IDs
or the OTP secret) is ensured w.r.t. the session key, in the same way as in the
previous roles.

5 Results

We have performed several analyses using our ASLan++ model of Electrum’s
two factor authentication protocol. We ﬁrst tested the executability of the pro-
tocol, i.e. to make sure that participants can truly run their parts as expected.
Second we present a replay attack on the conﬁrmation message that was unveiled

by the tools. This attack does not threaten private data but makes the client er-
roneously believe that it is in some state with the server and this may block him
in future actions. Finally we evaluate the protocol security according to several
scenarios and show that no attack is possible for these conﬁgurations (beside the
previously mentioned one). The investigated scenarios cover standard uses of the
protocol (with honest server and client) but also critical cases where the client
or the server is dishonest. We have employed a computer cluster for increasing
the number of protocol sessions considered during our experiments.

5.1 Executability Checking

To check the absence of blocking during protocol execution and therefore that the
protocol can reach a successful ﬁnal state, we have considered several scenarios
too. We consider here the case of a single honest client and a single honest server.
Hence the body section contains:

n e w S e s s i o n ( alice , client1 , server , inv ( pk ( server ) ) ) ;

Moreover the fact that a client role receives a correct ﬁnal answer from the server
is encoded with an ASLan property added at the end of the client role.

uChecks ( Actor , true , false , Signatures ,

start .{ R a w _ t r a n s a c t i o n . Script2 } _inv ( SerKey2 ) .

none .{ R a w _ t r a n s a c t i o n . Script1 } _inv ( SerKey1 ) ) ;

This property requires that the signature Signature sent by the server is
exactly data. For the server to provide this signature, the client request must be
properly constructed. Cl-Atse generates this request. Signatures are built from
paths a, b and c, d that have been used to compute the public keys SerKey1 and
SerKey2 with the corresponding scripts, i.e.:

K3 := pCKD ( inv ( pk ( server ) ) , cp ( server ) , Long_ID ) ;
C3 := cCKD (
pk ( server ) , cp ( server ) , Long_ID ) ;
SerKey1 := pCKD ( inv ( pCKD ( inv ( K3 ) ,C3 , a ) ) , cCKD ( K3 , C3 , a ) ,b ) ;
SerKey2 := pCKD ( inv ( pCKD ( inv ( K3 ) ,C3 , c ) ) , cCKD ( K3 , C3 , c ) ,d ) ;

5.2 Attack by Conﬁrmation Replay

In a scenario where the client and the intruder have each one an open session
with the server, the intruder has the possibility to replay the registration conﬁr-
mation sequence of the client towards the server. This is possible since the server
authenticates the client solely by its transmitted information, basically U serID
and OT P . The fact that the same session key is reused is neither detected by
the server in our modeling, nor in real implementations. The fact that the OT P
password used in a ﬁrst request does not expire instantaneously and therefore
remains valid for a second immediately following a session is not exploited here.
However if an already conﬁrmed client send a new conﬁrmation request then
according to the the technical documentation the server will check whether the

client is already recorded with not conﬁrmed tag in the database. Hence the test
will fail since the client is recorded with another tag. By consequence the second
session fails and the server returns false. Then the intruder needs only to replace
the positive answer to the ﬁrst request by the negative answer to the second one
to deceive the client into thinking that its conﬁrmation was denied. Moreover,
by believing so the client will probably not emit signature requests. If he tries
again to get a conﬁrmation he will be rejected again without any action from the
intruder. This forces the client to initiate a new registration. In order to correct
this protocol behavior the server should check after a conﬁrmation request if the
client is already conﬁrmed and reply positively in that case.

Cl-Atse has generated automatically the following attack trace that corre-
sponds. Agents between brackets < and > are controlled by the intruder. We
note that client1 sends a request to the server that is duplicated, and he only
receives the second answer.

client1

< client1 >
< client1 >

->
- >*
->

< server > : _msg

server
server

: n19 ( Sk )
: _msg

server

->

< client1 > : {| r esp ons e . true |} _n19 ( Sk )

<i >
<i >

- >*
->

server
server

server

< server >

->
->

<i >

client1

: n19 ( Sk )
: _msg
: {| r esp ons e . false |} _n19 ( Sk )
: {| r esp ons e . false |} _n19 ( Sk )

where for readability msg (and uid) are shortened forms of:

_msg : {| confirm . _uid . g o o g l e O T P ( hash ( _uid . inv ( pk ( server ) ) .

cp ( server ) ) , time ) |} _n19 ( Sk )

_uid : first10 ( hash ( pk ( n17 ( Seed1 ) ) . cp ( n17 ( Seed1 ) ) .

pk ( n17 ( Seed2 ) ) . cp ( n17 ( Seed2 ) ) ) )

Suggestion: the server’s answer could be more explicit to let the client understand
that it is under attack. Also, the client must not accept a server’s response if
it arrives after the end of validity for the OTP, to prevent replay. The non-
conﬁrmed data deletion is acceptable if the client understands that he must
restart from registration because an intruder interfered.

5.3 Security Analysis

Case of Dishonest Server: With a compromised server only few security prop-
erties can be preserved for the client. In particular, secrecy of C2, LongU serID,
Secret, OT P is lost. However, the client’s master private keys and their children
should remain secret even with a compromised server. This includes K1 priv
stored by the client and K2 priv stored by Human role and the seeds that have
been used for generating keys.

The model features a server that is compromised and thus, whose private root
key is provided to the intruder. Therefore, its security properties are ignored and
the intruder forces the server to follow or not the speciﬁcation. The analysis of
this speciﬁcation by Cl-Atse shows that the client’s security properties that are
not related to data shared with the server are preserved.

Case of Honest Server: This is the main case. The number of honest clients
running in parallel is a source of combinatorial explosion of the number of traces
to analyze. To perform the analysis we have employed 50 nodes of a computation
cluster. It appears that the limit was reached when analyzing this model for 2
to 3 concurrent sessions, each one being sequentially iterated 3 to 4 times. Each
session is a block specifying one human owner and his software client, plus each
of the three server’s roles.

Finally, the scenarios containing two sessions featuring either two honest
clients or one honest and one dishonest were found to be secure for up to four
iterations (option ’--nb 4’ of the tool). We have tried to speed-up analysis by
’branching’ the client sessions to speciﬁc server sessions (these are perfectly in-
terchangeable anyway) since this eliminates a large number of equivalent execu-
tions, but a scenario without this ’branching’ was also tried and appeared to be
truly diﬃcult, when running on 30 nodes of the cluster for a week.

6 Conclusion

In this paper we have modeled Electrum’s two factor authentication protocol
using the ASLan++ language advanced features. Conditional security goals allow
us to model several scenarios in one shot, without knowing beforehand which
agent will be compromised. Horn Clauses allow us to model intruder capabilities
(e.g. exploiting BIP32 related properties) in a ﬂexible way and beyond standard
Dolev Yao deduction rules. Our computer experiments have pointed a potential
problem in the user registration process, and have shown that, assuming perfect
cryptography, the protocol oﬀers good security guarantees in standard scenarios.
We have not studied privacy properties in this paper. In particular, a further
analysis could check if an intruder is able to relate transactions that belong to
the same user.

References

[Andrychowicz 2014] M. Andrychowicz, S. Dziembowski, D. Malinowski and L.
Mazurek. Modeling Bitcoin Contracts by Timed Automata. FORMATS 2014: 7-22.
[Armando 2008] A. Armando et al. Formal Analysis of SAML 2.0 Web Browser Single

Sign-On: Breaking the SAML-based Single Sign-On for Google Apps.

[Dolev 1981] D. Dolev and A. Yao. On the Security of Public Key Protocols (Extended

Abstract) .FOCS 1981: 350-357

[von Oheim 2010] D. von Oheimb and S. M¨odersheim. ASLan++: A Formal Security
Speciﬁcation Language for Distributed Systems. Formal Methods for Components
and Objects, Volume 6957 of LNCS pp 1-22.

[Proverif] Proverif http://prosecco.gforge.inria.fr/personal/bblanche/proverif/.
[Turuani 2006] M. Turuani. The CL-Atse Protocol Analyser. In: Term Rewriting and

Applications (RTA). LNCS 4098. pp. 277–286.

[Wuille 2012] P. Wuille. Hierarchical Deterministic Wallets. Online speciﬁcation for

BIP32 at https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki

