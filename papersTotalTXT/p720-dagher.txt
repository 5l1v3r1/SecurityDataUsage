Provisions: Privacy-preserving Proofs of Solvency

for Bitcoin Exchanges

Gaby G. Dagher
Concordia University

Benedikt Bünz
Stanford University

Joseph Bonneau ((cid:66))

Stanford University

˚

Jeremy Clark

Concordia University

Dan Boneh

Stanford University

ABSTRACT
Bitcoin exchanges function like banks, securely holding their cus-
tomers’ bitcoins on their behalf. Several exchanges have suffered
catastrophic losses with customers permanently losing their sav-
ings. A proof of solvency demonstrates that the exchange controls
sufﬁcient reserves to settle each customer’s account. We introduce
Provisions, a privacy-preserving proof of solvency whereby an ex-
change does not have to disclose its Bitcoin addresses; total hold-
ings or liabilities; or any information about its customers. We also
propose an extension which prevents exchanges from colluding to
cover for each other’s losses. We have implemented Provisions
and it offers practical computation times and proof sizes even for a
large Bitcoin exchange with millions of customers.

Categories and Subject Descriptors
K.4.4 [Electronic Commerce]: Security, Cybercash, digital cash;
E.3 [Data Encryption]: Public key cryptosystems

Keywords
Bitcoin; Exchange Services; Solvency; Zero Knowledge Protocols

1.

INTRODUCTION

Digital currencies enable transactions that are electronically au-
thorized, cleared and settled. After decades of research [7, 5, 2, 25]
and failed business ventures attempting to establish a digital cur-
rency, Bitcoin [23] was proposed and deployed in 2009. While still
in its infancy, Bitcoin has achieved unprecedented success, enjoy-
ing a multi-billion dollar market capitalization and deployment by
large retailers. Bitcoin transactions can be executed at any time by
any device in the world with low (sometimes zero) fees.

Users can maintain security of their assets by managing the pri-
vate keys used to control them. However, managing cryptographic
keys is difﬁcult for many users [12]. Equipment failure, lost or
˚Corresponding Author

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS’15, October 12–16, 2015, Denver, Colorado, USA.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-3832-5/15/10 ...$15.00.
DOI: http://dx.doi.org/10.1145/2810103.2813674 .

stolen devices, or Bitcoin-speciﬁc malware [18] could all result in
the loss of one’s holdings. Many users prefer to keep their hold-
ings with online exchanges for a simple user experience similar to
online banking—e.g., with passwords, account recovery, velocity
limits and customer support. Exchanges, as their name suggest,
also provide conversion services between bitcoin1 and other cur-
rencies. Customers can ‘withdraw’ by instructing the exchange to
send the stored bitcoin to a Bitcoin address for which they manage
the private key.

Unfortunately, storing assets with an exchange leaves users vul-
nerable to the exchange being hacked and losing its assets. One of
the most notorious events in Bitcoin’s short but storied history is
the collapse and ongoing bankruptcy of the oldest and largest ex-
change, Mt. Gox, which lost over US$450M in customer assets. A
number of other exchanges have lost their customers’ Bitcoin hold-
ings and declared bankruptcy due to external theft, internal theft, or
technical mistakes [22].

While the vulnerability of an exchange to catastrophic loss can
never be fully mitigated, a sensible safeguard is periodic demon-
strations that an exchange controls enough bitcoins to settle all of
its customers’ accounts. Otherwise, an exchange which has (se-
cretly) suffered losses can continue operating until the net with-
drawal of Bitcoin exceeds their holdings. Note that while con-
ventional banks typically implement fractional reserve banking in
which they only retain enough assets to cover a fraction of their
liabilities, the Bitcoin community is skeptical of this approach and
exchanges are generally expected to be fully solvent at all times.

A rudimentary approach to demonstrating assets is simply to
transfer them to a fresh public key. Mt. Gox did so once in 2011 in
the face of customer skepticism, moving over B420k (then worth
over US$7 M) in a single large transaction. However, this demon-
stration undermined Mt. Gox’s privacy by revealing which Bitcoin
addresses they controlled. It was never repeated.

More importantly, a proof of reserves without a corresponding
proof of liabilities is not sufﬁcient to prove solvency. A proof of
liabilities might consist of an audit by a trusted accountant, as done
for example by Coinbase2 and Bitstamp3. This might be improved

1Following convention, we refer to the protocol as ‘Bitcoin’ and
the units of currency as ‘bitcoin’ or B.
2A. Antonopoulos, “Coinbase Review,” antonopoulos.com (Blog),
25 Feb 2014.
3E. Spaven, “Bitstamp Passes Audit Overseen by Bitcoin Devel-
oper Mike Hearn,” CoinDesk, 27 May 2014.

720by allowing users to independently verify they are in the dataset
seen by the auditor, a step taken by Kraken4 and OKCoin5.

The notion of a cryptographic proof of liabilities, veriﬁable
by any party with no trusted auditor, was ﬁrst proposed by
Maxwell [29], although this initial proposal leaks information
about the number and size of customer accounts (see Section 2.2).
These privacy issues (as well as those inherent to a simple public
proof of assets) have been cited by some exchanges (e.g., Kraken6)
as a reason to use a trusted auditor instead.

In this paper we propose Provisions, a cryptographic proof of

solvency scheme with the following properties:

‚ no information is revealed about customer holdings
‚ the value of the exchange’s total total holdings is kept secret
‚ the exchange maintains unlinkability from its Bitcoin ad-
‚ multiple exchanges performing Provisions contemporane-

dress(es) through an anonymity set of arbitrary size

ously can prove they are not colluding

While the Maxwell proof of reserves is a straightforward use of
a Merkle tree, a data structure well known by Bitcoin community,
Provisions employs somewhat heavier cryptography not found in
Bitcoin itself—e.g., homomorphic commitments and zero knowl-
edge proofs. However, we demonstrate that Provisions is efﬁcient
enough in practice even for the largest of today’s exchanges to con-
duct a daily proof of solvency, being computable by a single server
in a few hours and requiring proofs which are less than 20 GB in
size. Given this practicality and the strong privacy guarantees, we
hope it will become the norm for exchanges to regularly compute a
Provisions proof of solvency which might go a long way to restor-
ing conﬁdence in the Bitcoin ecosystem.

Limitations.

It is important to recognize that no proof of solvency (or any
other type of audit) is future proof, as exchanges can still be hacked
at any time. Likewise, proving control of a quantity of bitcoin does
not guarantee the exchange itself will behave honestly in the fu-
ture. It may simply abscond with all of its customers funds after
completing a Provisions proof. The best we can hope for is efﬁ-
cient enough proofs to enable frequent and continual monitoring of
the ﬁnancial health of exchanges to quickly detect the loss of funds,
which Provisions enables.

Provisions also requires customers to check individually that
their balance has been included in the proof of liabilities. This
appears to be a fundamental limitation given our privacy goals that
a user’s account balance is not revealed to any other party. On the
positive side, as long as some users check and the exchange cannot
predict conﬁdently which users will check, it runs a high risk of
detection if it cheats (see Section 9.2).

Provisions is also limited to proving ownership of accounts with
a full public key on the blockchain (not unused pay-to-pub-key-
hash or pay-to-script-hash addresses which haven’t yet be been
used or multi-sig addresses). Removing this limitation is an in-
teresting challenge for future work.

2. BACKGROUND

We assume the reader is familiar with Bitcoin [23]. Bonneau
et al. [4] provide an extensive survey of Bitcoin, although a deep
understanding is not needed for understanding Provisions. The
pertinent features are that each unit of bitcoin is usually redeemable
by a speciﬁed public key7 and this information is maintained in a
public data structure called the blockchain.

Note that the blockchain is an ever-growing log of transactions.
Any proof of solvency will be inherent to a single block, represent-
ing one snapshot of the state of the system. In the remainder of
the paper we leave implicit the proof will be valid for a speciﬁc
block number t. It is also possible for the blockchain to fork (or
“re-org”) in which case an apparently-valid proof at block t may
not be valid in the ﬁnal block number t. As is standard with Bit-
coin transactions, the defense against this is to wait until a block
is conﬁrmed with high probability, typically after observing that 6
followup blocks have been published.

Bitcoin public keys which hold funds are interchangeably called
accounts or addresses. We note here that while we designed Pro-
visions with Bitcoin in mind as it is the dominant cryptocurrency
today, it could easily be ported to similar cryptocurrencies which
have the above properties.

A proof of solvency consists of two components. In the ﬁrst, the
proof of liabilities, the exchange proves the total value of bitcoin
it owes to each of its users. In the second, the proof of assets, the
exchange proves the total value of bitcoin it has signing authority
over. If the latter amount is greater than or equal to the former, the
exchange is considered solvent.
2.1 Exchange structure and holdings

Nearly all large Bitcoin exchanges operate by pooling cus-
tomers’ funds into a small number of large accounts. Typically for
security reasons the keys for some of these accounts are kept on of-
ﬂine computers or in hardware security modules, requiring human
action to authorize transactions (commonly called cold storage).

One might ask why an exchange does not simply maintain a sep-
arate Bitcoin address for each customer, enabling direct monitor-
ing by each user of their funds on the public blockchain; a simple
mechanism that eschews the need for a more complicated crypto-
graphic proof of solvency. By itself, this scheme is not secure, as
a malicious exchange might attempt to convince two users with the
same balance that a single address is holding funds for both of them
(a variation of the clash attack [28] discussed later).

This model also has several key practical shortcomings. First, it
prevents simple division of money into hot and cold storage. Cur-
rent exchanges can exist with a limited amount of money in more
vulnerable hot storage because, on aggregate, the number of with-
drawals in a given day is typically only a small amount of total
holdings. This is similar to a large ofﬂine bank which does not
carry enough cash in ATMs to cover all customer accounts, keep-
ing substantial assets in secure (but less accessible) storage.8

Second, pooling assets means that transfers between customers
can be efﬁciently settled by changing each customers’ account bal-
ance without executing a transaction on the Bitcoin blockchain (in-
curring a transaction fee and a wait of around an hour for conﬁrma-

4N. Hajdarbegovic. “Kraken Bitcoin Exchange Passes ‘Proof of
Reserves’ Cryptographic Audit,” CoinDesk, 24 Mar 2014.
5J. Southurst, “OKCoin Reveals BTC Reserves of 104% as China’s
Exchanges Undergo Audits,” CoinDesk, 22 Aug 2014.
6“Kraken Proof-of-Reserves Audit Process,” https://www.
kraken.com/security/audit

7Technically, bitcoins are redeemable by a speciﬁc transaction
script which can encode various spending conditions, though in the
vast majority of cases this is simply a public key signature and we
will discuss Bitcoin as if this is the only method.
8Executing Provisions will require computation using all of an
exchange’s private keys, including those for assets in cold storage.
However, this can be done with human intervention at a predictable
time and does not require network access to the cold storage.

721Figure 1: The Merkle tree from the Maxwell protocol [29] for proof of solvency. When a customer desires to verify their account (e.g. dashed
line node), only two nodes need to be sent to the customer (bold line nodes).

tion). Similarly, two exchanges can aggregate multiple transactions
between pairs of their customers into a single settlement payment
(referred to as netting). Minimizing reliance on the blockchain
(especially for small transfers) is a key beneﬁt of exchanges. By
contrast, maintaining a separate Bitcoin account for each customer
requires “hitting the blockchain” with every transaction.

Finally, although it is not typically advertised, exchanges offer a
signiﬁcant privacy beneﬁt to users as as pooling funds ensures that
it is not easy for outside observers to link deposits and withdrawals
to the same individual [20].

Thus, we consider the pooled assets model likely to persist and
we have designed Provisions to work in this model. If we com-
bine these factors with maintaining the privacy of an exchange’s
addresses—proving that one owns (i.e., knows) a private key with-
out disclosing which—zero knowledge proofs appear inescapable.

2.2 Maxwell’s proof of liabilities

Maxwell proposed a protocol (summarized by Wilcox [29]) that
enables an exchange to prove its total liabilities while allowing
users to verify that their accounts are included in this total. The
exchange constructs a binary Merkle hash tree [21] where each leaf
node contains a customer’s balance, as well as the hash of the bal-
ance concatenated with the customer id and a fresh nonce (i.e., a
hash-based commitment). Each internal node stores the aggregate
balance of its left child (lc) and right child (rc), as well as the hash
of its aggregate balance concatenated with the hash of its left and
right children. The root node stores the aggregate of all customers’
balances, representing the total liabilities, and the exchange broad-
casts the root node. This is illustrated in Figure 1.

When a customer wants to verify that their balance is included in
the total liabilities declared by the exchange, it is sufﬁcient to send
to the customer only part of the hash tree in order to perform the
veriﬁcation. Speciﬁcally, the exchange sends to the customer her
nonce and the sibling node of each node on the unique path from the
customer’s leaf node to the root node. The other nodes on the path,
including the leaf node itself, do not need to be sent to the customer
because they will have sufﬁcient information to reconstruct them.
The customer eventually accepts that their balance is included iff
their path terminates with the same root broadcast by the exchange.
While elegant, this protocol does not hide the value of the ex-
change’s total liabilities which is published in the root node. While
a rough sense of this value may be public knowledge, the exact
value may be sensitive commercial data. Furthermore, regular
proofs will reveal precise changes in the exchange’s holdings.

This protocol also leaks partial information about other cus-
tomers’ balances. For example, if a simple balanced tree is used

then each customer’s proof reveals the exact balance of the sibling
account in the tree (although the account holder remains anony-
mous). More generally, each sibling node revealed in a given users’
path to the root node reveals the total holdings of each customer in
that neighboring subtree. This could be mitigated somewhat by us-
ing an unbalanced tree so it is not immediately clear how many
customers are in any neighboring subtree, but the protocol inher-
ently leaks some information. Provisions removes this problem
entirely, revealing no information about any users’ assets beyond
the fact that the total is less than the exchange’s proven reserves.
2.3 Proof of assets

Once an exchange establishes its total liabilities, it must prove
it owns sufﬁcient bitcoin to match (or exceed) its liabilities. This
proof of assets together with the proof of liabilities forms a proof
of solvency. Maxwell’s proof of assets does not preserve privacy.
Instead, the exchange publicly demonstrates control of a set of ad-
dresses holding at least as much bitcoin as the exchange’s total li-
abilities. This demonstration of control might involve moving a
challenge amount of bitcoin from each account or signing a chal-
lenge message with the private key associated with each address.
Exchanges may be reluctant to do so for privacy and security con-
cerns (revealing their internal division of funds between accounts).
In Provisions, we enable the exchange to prove ownership of an
anonymous subset of addresses pulled from the blockchain. The
total quantity of bitcoin across these addresses can then be deter-
mined, without being revealed, and proved to be equal or greater
than the exchange’s total liabilities.

2.3.1 Control vs. ownership
Any proof of assets, including Provisions, faces the inherent
problem that the ability to use the signing key of an address does
not necessarily imply ownership of it. A malicious exchange may
collude with one or more bitcoin holders who agree to use their ac-
counts to cover the exchange’s liabilities. However, these partners
may have no intention of ever making their holdings available to
the exchange’s customers.

An exchange might try consolidating its holdings into a single
address to demonstrate that either exchange or the colluder is risk-
ing their bitcoin by placing it under the other’s control. However,
there is no guarantee that the single address does not implement a
shared access structure by a threshold signature scheme [15].

This problem is fundamental, as no system can cryptographi-
cally prove its intentions to return something of value to a given
user if requested. This customer request will be made without cryp-
tographic authentication (e.g., password-authenticated) because by

h(B2 | CID2 | Nonce2)HashB2Balanceh(B1 | CID1 | Nonce1)HashB1Balanceh(B4 | CID4 | Nonce4)HashB4Balanceh(B3 | CID3 | Nonce3)HashB3Balancelcrclcrch(Sum | lc(Hash) | rc(Hash))Hashlc(Sum) + rc(Sum)Sum(Total Liabilities)lcrc When a customer desires to verify his account (e.g. dashed line node), only two nodes need to be sent to the customer (bold line nodes).h(Sum | lc(Hash) | rc(Hash))Hashlc(Balance) + rc(Balance)Sumh(Sum | lc(Hash) | rc(Hash))Hashlc(Balance) + rc(Balance)Sum722assumption exchange customers are unwilling or unable to manage
cryptographic keys. Otherwise, assets could be proved by send-
ing each customer’s bitcoins to a 1-out-of-2 multisig address re-
deemable by either the exchange or the user [29], providing a win-
dow for each customer to redeem their coins if desired. Again, we
assume this is impractical for most exchange customers.

2.3.2 Collusion attacks
Another potential vulnerability is that a cabal of two or more ma-
licious exchanges might collude by using their own assets to partic-
ipate in each other’s proof of assets, making each exchange appear
to control the total amount controlled by the cabal. With a pub-
lic proof of assets, this would be detected if done simultaneously
(because the same addresses would appear in multiple exchanges’
proofs) while the transaction graph might reveal if assets are simply
being moved around in a shell game.

In Provisions, because the exchange’s addresses are kept conﬁ-
dential, detection of this attack becomes more challenging. How-
ever, in Section 7 we show an extension to the basic Provisions
protocol which enables exchanges to prove that they are not us-
ing the same assets as other exchanges running the protocol. To
do so, they publish an additional value which is unlinkable to their
real Bitcoin address, yet is a deterministic function of (and requires
knowledge of) their private key. Thus, if any two exchanges attempt
to use the same bitcoin address in separate executions of Provi-
sions, they can be detected.

This extension imposes a small performance cost (see Sec-
tion 10.4) and a small impact on the exchange’s privacy as it reveals
the number of addresses to which the exchange knows the private
key (see Section 9.1). Thus we leave it as an extension for now, as
it will only become beneﬁcial when multiple exchanges are imple-
menting Provisions and are willing to synchronize their proofs.

3. PROTOCOL OVERVIEW

The objective of Provisions is to enable an exchange E to pub-
licly prove that it owns enough bitcoin to cover all its customers’
balances such that (1) all customer accounts remain fully conﬁden-
tial, (2) no account contains a negative balance, (3) the exchange
does not reveal its total liabilities or total assets, and (4) the ex-
change does not reveal its Bitcoin addresses. Provisions consists
of three main protocols:

Protocol 1 - Proof of assets. In this protocol, the exchange se-
lects a large set of public keys PK from the blockchain that hold
bitcoin to serve as an anonymity set for its own keys. The ex-
change possesses the private keys to a subset of the public keys
in PK. Next, the exchange creates a commitment to its total as-
sets and proves in zero-knowledge that the sum of balances held
by the public keys it owns (i.e. public keys for which it knows the
secret key) is equal to the committed value. This is done without
revealing which public keys it owns.

Protocol 2 - Proof of liabilities. In this protocol, the exchange
publishes a commitment to each user’s account balance, reveal-
ing to each user individually the random factors used to commit
to the balance for their veriﬁcation. For each committed balance,
it also proves it is a small positive integer. These committed val-
ues are summed homomorphically to produce a commitment to the
exchange’s total liabilities.

Protocol 3 - Proof of solvency. Using the commitments to its
total assets and liabilities produced by the above two protocols, the
exchange will homomorphically compute a commitment to their
difference and prove in zero-knowledge that this ﬁnal commitment
is a commitment to zero. This will prove that the total liabilities is

exactly equal to the total assets (or, via a minor modiﬁcation, that
it is strictly less than the total assets).
3.1 Preliminaries & notation

Public parameters. We let g and h be ﬁxed public generators
of a group G of prime order q. Our implementation uses the el-
liptic curve secp256k1 [6] as the group G; this is the group used
for Bitcoin ECDSA signatures. Note that this allows us to work
with existing Bitcoin public and private keys, although we do not
actually perform any ECDSA signatures. While implemented over
elliptic curves, we use the more conventional multiplicative nota-
tion (e.g., y “ gx instead of Y “ xG).

Bitcoin balance lookups. We assume that

the Bitcoin
blockchain is universally agreed upon and all parties can use it to
compute the quantity of bitcoin owned by each address. More pre-
cisely, for a Bitcoin public key y P G we use balpyq to denote the
balance associated with y. We assume balpyq is an integer between
0 and MaxBTC for all y. We can represent any bitcoin account
with MaxBTC “ 251—the rules of Bitcoin limit the total currency
supply to 21M B, each divisible into a maximum of 10´8 atomic
units called satoshis. Note that satoshis are the true units of cur-
rency in Bitcoin, with B1 “ 108 satoshis simply a convention to
provide more human-friendly accounting units. In the remainder
of this paper when we speak of account balances we will always be
working with satoshis.
Pedersen Commitments. Provisions makes heavy use of Ped-
ersen commitments [26]. The commitment to a message m P Zq is
deﬁned as com “ gm ¨ hr where g and h are ﬁxed public elements
of G and the quantity r is chosen at random in Zq. The genera-
tors g and h are chosen once in a way that ensures no one knows
their relative discrete logarithm. Speciﬁcally, we use the standard
g from secp256k1 and derive h deterministically by hashing the
string Provisions. Recall that Pedersen commitments are per-
fectly hiding so that com reveals no information about m.

Non-Interactive Zero-Knowledge Proofs (NIZKP). Provi-
sions requires a number of non-interactive zero knowledge proofs.
In all cases, these can be adapted from basic Σ-protocols such as
the Schnorr proof of knowledge of a discrete logarithm [27] or the
Chaum-Pedersen proof of representation of a Difﬁe-Hellman tu-
ple [9], using Fiat-Shamir [13] to compile into a non-interactive
zero-knowledge protocol (NIZKP). If one wishes to avoid the ran-
dom oracle model, any alternative Σ-protocol to NIZKP compila-
tion [16] is sufﬁcient.

4. PROOF OF ASSETS

We begin with Protocol 1 which lets the exchange E generate a
commitment to its total assets along with a zero-knowledge proof
that the exchange knows the private keys for a set of Bitcoin ad-
dresses whose total value is equal to the committed value.

The exchange E chooses a set of Bitcoin public keys

PK “ ty1, . . . , ynu Ď G

that will serve as an anonymity set (we will discuss choosing this
in Section 10). We let x1, . . . , xn P Zq be the corresponding secret
keys so that yi “ gxi for i “ 1, . . . , n.

Let S be the exchange’s own set of Bitcoin addresses for which it
knows the private keys. The anonymity set PK must of course be a
superset of the exchange’s own Bitcoin addresses so that S Ď PK.
We use the booleans si P t0, 1u to indicate which accounts the
exchange controls in PK. We set si “ 1 whenever the exchange
knows the private key xi for Bitcoin public key yi P PK. The

723exchange’s total assets can then be expressed as
si ¨ balpyiq

Assets “ nÿ

i“1

Finally, it will be convenient to deﬁne

bi “ gbalpyiq

for i “ 1, . . . , n.

Given the set PK, a veriﬁer can easily compute all the bi for itself
using information in the Bitcoin blockchain.
4.1 Proof of assets Σ-Protocol
The exchange constructs Pedersen commitments to each si ¨
balpyiq for i P r1, ns by choosing a random vi P Zq and com-
puting

pi “ hvi ¨ bsi

(1)
A homomorphic addition of these commitments yields a Pedersen
commitment ZAssets to Assets:

.

i

ř
i“1 viq
p

n

hvi ¨ bsi

i “ h

gAssets .

(2)

ZAssets “ nź

pi “ nź

i“1

i“1

It remains to prove in zero-knowledge that ZAssets is valid. To
do so the exchange publishes a few additional auxiliary values. For
each i P r1, ns the exchange chooses a random ti P Zq and pub-
lishes

li “ ysi

i hti P G

(3)
which is a Pedersen commitment for si. Equivalently, these li can
be written as

li “ gxi¨si hti

which is a Pedersen commitment to the quantity xi ¨ si P Zq. By
setting ˆxi “ xi ¨ si the equation can be written as

li “ g ˆxi hti

(4)
Now, to prove that ZAssets is a commitment to the exchange’s
assets the exchange needs to prove that for every i P r1, ns it knows
si P t0, 1u, vi, ti, ˆxi P Zq satisfying conditions (1), (3), and (4).
ZAssets can then be computed according to (2).

The exchange proves knowledge of the required values using
the Σ-protocol presented in Protocol 1 along with a Σ-protocol to
prove that each si is binary and known to the exchange. Proving in
zero-knowledge that a Pedersen commitment li is a commitment to
a binary value is a standard zero-knowledge proof and is presented
in full version of this paper [11] for completeness.

The protocol can be made non-interactive using the standard
Fiat-Shamir heuristic. It therefore sufﬁces to prove that the protocol
is honest-veriﬁer zero knowledge. This is captured in the following
theorem:
Theorem 1. The Σ-protocol in Protocol 1 is a honest-veriﬁer zero
knowledge proof of knowledge of quantities

Assets and psi P t0, 1u, vi, ti, ˆxi P Zqq for i P r1, ns

that satisfy conditions (1),(2), (3) and (4) for all i P r1, ns.

The proof of Theorem 1 is given in Appendix A.
The proof of knowledge convinces the veriﬁer that ZAssets is a
commitment to the exchange’s total assets. More precisely, the ver-
iﬁer is convinced that

ř
i“1 si ¨ balpyiq P Zq (by equa-
tion (2)), where si P t0, 1u, and

‚ ZAssets is a commitment to

n

1. For i P r1, ns

, u

, u

, u

p4q
i

p3q
i

p2q
i

p1q
i

$ÐÝ Zq.
(a) E chooses u
(b) The exchange E sends to the veriﬁer:
i “ y
p2q
p3q
i “ gu
p4q
i

p4q
i “ b
p1q
hu
i
p2q
i “ hu
p3q
i

p1q
u
i
i

a

a

a

a

,

,

p1q
u
i
i

$ÐÝ Zq

(c) The veriﬁer replies with a challenge ci
(d) E replies with:
rsi “ u
i ` ci ¨ si,
p1q
rti “ u
i ` ci ¨ ti,
p2q
i ` ci ¨ ˆxi,
rˆxi “ u
p3q
rvi “ u
i ` ci ¨ vi,
p4q

Response for si
Response for ti
Response for ˆxi
Response for vi

b

(e) The veriﬁer accepts if:
p1q
i
p2q
i a
p3q
i a

rsi
i hrvi
rsi
i hrti
grˆxi hrti

?“ pci
i a
?“ lci
i a
?“ lci
i a

y

Verify statement (1)

Verify statement (3)

Verify statement (4)

p3q
i
p4q
i

(f) Run a zero knowledge proof (described in [11]) on

li to prove knowledge of si P t0, 1u

2. The veriﬁer computes ZAssets “

n

i“1 pi Statement (2)

ś

Protocol 1: Privacy-preserving proof of assets

‚ whenever si “ 1 the exchange knows the corresponding pri-
vate key xi P Zq. To see why observe that dividing equa-
tion (3) by (4) proves that when si “ 1 the exchange knows
ˆxi P Zq such that g ˆxi “ yi, as required.

That the proof is honest-veriﬁer zero knowledge implies that
nothing is revealed about the total assets, the si, or the xi, as re-
quired.

Proof length. The proof is linear in the anonymity set size n, re-
quiring about 13n elements in Zq. This is feasible even for large
anonymity sets. We will discuss practical parameters in Section 10.

5. PROOF OF LIABILITIES

Protocol 2 enables the exchange E to veriﬁably commit to its
total liabilities and convince all clients that their balances were in-
cluded in the commitment.

To provide some intuition behind the design of Protocol 2, con-
sider the mapping of real customers to entries on LiabList. Each
real customer should have an entry in LiabList (i.e., the mapping
is a function) and no distinct customers should be given the same
entry (i.e., the mapping should be injective). Perhaps it would be
ideal if all entries would correspond to customers (i.e., the mapping
were surjective) however this property cannot be enforced—E can

724To veriﬁably compute its liabilities, E does:

1. For each customer Ci : 1 ď i ď c:

(a) Represent each Ci’s balance Balancei as an m-bit binary number (where m “ rlg2 MaxBTCs):

BinBalancei “ xxi,0, xi,1, . . . , xi,m´1y ,

(then Balancei “

ř
k“0 xi,k ¨ 2k)
m´1

(b) Compute and publish a Pedersen commitment to each xi,k in the group G using generators g and h:

(c) Compute a non-interactive proof of knowledge Πi of all ri,k and xi,k, and that every xi,k is binary (see [11]).
(d) Compute a commitment to Ci’s balance as yi “

Then yi is a Pedersen commitment to Balancei because yi “ gbalancei hri where ri “

ř
k“0 ri,k ¨ 2k.
m´1

(e) Compute a fresh customer identiﬁer CIDi by picking a random nonce ni and committing Ci’s username: CIDi

$Ð

commitpusernamei, niq

$ÐÝ Zq

ri,k

yi,k “ gxi,k hri,k ,
ś
k“0 pyi,kqp2kq P G.
m´1

2. Homomorphically add the commitments to all customers balance into a single commitment to the total liabilities:

ZLiabilities “ cź

yi

i“1

3. Publish the commitment to total liabilities ZLiabilities and the list LiabList of all customers’ tuples:

LiabList “ xCIDi, yi,0, . . . , yi,m´1, Πiy for i “ 1, . . . , c.

and locates it in LiabList. The client then veriﬁes that its balance is included as follows:

4. Every client Ci, upon login, is privately given usernamei, ri and a string n1

usernamei “ open
CIDi, n1
(a) compute yi “
k“0 pyi,kqp2kq and verify that yi “ gbalancei hri,
m´1
(b) verify that ZLiabilities “
i“1 yi, and
(c) verify the proof Πi for i “ 1, . . . , c.
Note that steps (b) and (c) can be carried out by any public auditor and need not be done by every client.

c

i to open the commitment CIDi. The client veriﬁes that

`
ś

˘
ś

i

Protocol 2: Privacy-preserving proof of liabilities

always add fake users to the list, but we ensure that doing so can
only increase E’s apparent liabilities.9
If two users have the same balance, a malicious E might try to
point both users to the same entry—in the voting literature, this is
called a clash attack [28]. To ensure an injective mapping, cus-
tomers are provided an ID in line 1e which commits10 to unique in-
formation about the customer usernamei (which may include their
username, email address, and/or account number). The commit-
ment is binding, preventing the exchange from opening a CID to
distinct data for different users. It is also hiding, preventing an ad-
versary who knows the email address of a potential customer from
determining if that customer is in LiabList (or if a user is known to
be a customer, which CID they correspond to).
The exchange can add arbitrary accounts to the list. However, as
long as accounts can only add to the total liabilities (e.g., E cannot
commit to a negative balance and assign it to a fake user account),
adding accounts is detrimental to a malicious E’s goal as it could
only increase its apparent liabilities. Since negative numbers do

9It might be in E’s interest to include fake users with a zero (or
tiny) balance to obscure the total number of customers it truly has.
10Unlike the other commitments used in Provisions, the commit-
ment scheme used to produce CIDi need only be binding and hid-
ing, not additively homomorphic. We use a simpler hash-based
commitment scheme instead of Pedersen commitments.

not technically exist in modular arithmetic, the precise requirement
is that when added together, the sum will never cause a reduction
mod q where q « 2256 for our group G “secp256k1.
To enforce this, E provides a range proof (adapted from [19])
for each committed balance showing it is from a ‘small’ interval
between 0 and MaxBTC “ 251. This makes it easy to ensure a
modular reduction will never occur, as long as the exchange has
fewer than 2205 accounts.

The range proof works by providing a bit-by-bit commitment of
the account balance in binary representation, proving each bit is a
0 or 1 (using the proof of knowledge, mentioned above, twice with
conjunctive logic [10]), and showing how many bits the number
contains (an upper-bound on its maximum value). This committed
binary representation is homomorphically converted into an integer
and homomorphically summed.

In the full version of the paper [11], we prove the following the-

orem:

Theorem 2. Protocol 2 is a honest-veriﬁer zero knowledge proof
of knowledge of quantities Liabilities and

pxi,k P t0, 1u, ri,k P Zqq for i P r1, cs and k P r0, m ´ 1s

725ZAssets to its total assets.

1. E runs Protocol 1 to veriﬁably generate a commitment
2. E runs Run Protocol 2 to veriﬁably generate a commit-
ment ZLiabilities to its total assets and a list LiabList of its
liabilities.

3. E computes ZAssets ¨ ZLiabilities
4. E proves in zero-knowledge that ZAssets´Liabilities is a

´1 “ ZAssets´Liabilities.

commitment to the value 0.

Protocol 3: Complete privacy-preserving proof of solvency

that satisfy the condition

ZLiabilities “ cź

yi “ cź

i“1

i“1

k“0

for all i P r1, cs and k P r0, m ´ 1s.

m´1ź
pyi,kqp2kq “ cź

i“1

m´1ź
pgxi,k hri,kqp2kq

k“0

This step leads to the bulk of the proof size (see Section 10). In
the full version of the paper [11], we discuss an alternate version of
this protocol using zero-knowledge succinct non-interactive argu-
ments of knowledge (zk-SNARKs) [3]. The proof generated by this
protocol is signiﬁcantly shorter (constant in the number of users) at
the expense of a large common reference string, the use of heavier
cryptographic tools and a trusted setup step.
5.1 Customer veriﬁcation

We assume that customers each verify LiabList to conﬁrm the
existence of their accounts and the correctness of their balances
yi and ID commitments CIDi. A malicious E which omits some
customers will only be detected if at least one of those customers
checks, although this is an inherent limitation given our privacy
goals which require that only customers themselves can tell if their
balance has been included or not. This limit applies equally, for
example, to Maxwell’s protocol.

The required checks from individual customers are fortunately
Each customer Ci receives from E their
quite lightweight.
usernamei, ri and ni. They then locate in LiabList, with a hint
from E, their tuple:

xCIDi, yi,0, . . . , yi,m´1, Πiy

Using ni, they can open their commitment CIDi and verify that it
commits to usernamei. Next, using ri the customer checks that
yi is indeed a commitment to their true account balance Balancei.
This is shown in Step (4a) and is a simple calculation.

The other two veriﬁcation steps, (4b) and (4c), can be carried
out by any party—we assume a public auditor will do so on behalf
of most customers, so that individuals will typically not verify the
entire proof (though they are free do to so). We discuss the cost of
verifying the entire proof further in Section 10.

6. PROOF OF SOLVENCY

Protocol 3 speciﬁes how E can complete the proof of solvency
given commitments to total assets and liabilities from Protocols 1
and 2. The proof that ZAssets´Liabilities is a commitment to 0 (line 4)
is a simple Schnorr ZK proof of knowledge of the discrete log of
ZAssets´Liabilities to the base h, since ZAssets´Liabilities “ g0hk for a
value k known to the exchange and if ZAssets´Liabilities were a com-
mitment to any other value then computing its discrete log to the
base h would reveal the discrete log of h relative to g.

Variation for exchanges with a surplus.

If the exchange is actually running a surplus (total assets are
greater than total liabilities), this can easily be handled with a sim-
ple modiﬁcation—the exchange can create a commitment to its sur-
plus, ZSurplus, and apply the same range proof used for customer
balances to prove that this is a small positive number. It then re-
places line 3 in Protocol 3 with:

ZAssets ¨ ZLiabilities

´1 ¨ ZSurplus

´1

This approach reveals that a surplus exists. The exchange can also
prove the magnitude of its surplus if desired by opening the com-
mitment ZSurplus. Alternatively, to hide even the existence of any
surplus, the exchange could simply move its surplus into a separate
address which is not included in the addresses S used in its proof
of assets, or include the value of the surplus in a number of fake
customers’ accounts which will add to its apparent liabilities.

Variation for fractional-reserve exchanges.

Fractional reserve banking, in which an exchange promises to
keep assets equal to only a fraction ρ of its total liabilities instead of
all of them, has been frowned upon by many in the Bitcoin commu-
nity and not seen signiﬁcant deployment. However if this approach
becomes more popular in the future, it is easy to modify Provi-
sions to handle this case by modifying Protocol 3 to commit to a
modiﬁed balance fipBalanceiq instead of the customer’s true bal-
ance Balancei. Each user can then check during veriﬁcation that
fi was computed correctly on their true balance. Simple fractional
reserves could be implemented by deﬁning fipxq “ ρ ¨ x for all
users. It would also be straightforward to deﬁne fipxq “ ρi¨x with
a different ρi for each user if, for example, some users’ accounts
are fully-guaranteed (ρi “ 1) while others are only fractionally-
guaranteed (ρi ă 1). Arbitrary other functions are possible, with
a natural example from traditional ﬁnance being guaranteeing a
user’s assets up to some maximum value.
Finally, an exchange can also prove that it is running a surplus
of proportion ρ by setting fipxq “ p1 ` ρq ¨ x, with a “fractional
surplus” effectively being the inverse of a fractional reserve.

7. PROOF OF NON-COLLUSION

Recall from Section 2.3.2 that the privacy guarantees of Provi-
sions introduce the risk that a cabal of insolvent exchanges col-
luding by covering each exchanges’ individual liabilities with their
collective assets. In effect, the assets of a single Bitcoin address
can be used in the proof of solvency for multiple exchanges. This
can be done by having the exchanges contribute to a set of joint
NIZKPs of their keys (e.g., using divertable ZK [1]).

The simplest defense is for each exchange to choose an
anonymity set PK which is smaller than the set of all public keys
and where each exchange’s set is disjoint from the anonymity set of
all other exchanges. This ensures that each exchange is proving sol-
vency using assets it owns and without the help of other exchanges.
The difﬁculty with this approach is that there may not be sufﬁ-
ciently many addresses on the Bitcoin blockchain to accommodate
strong privacy for all the exchanges. In the long run, if exchanges
come to collectively control the majority of all bitcoins, we would
like them to be able to use each other as an anonymity set.

Extension to Proof of Assets.

We can obtain a stronger defense by extending Protocol 1 with a
few additional steps. Our goal is to ensure that the assets of every
Bitcoin address is used in at most one proof of solvency. Recall that
the exchange has a set of Bitcoin signing keys PK “ ty1, . . . , ynu

726where yi “ gxi for i P r1, ns . The exchange knows the secret keys
xi for some subset of these public keys. We use indicator variables
s1, . . . , sn P t0, 1u such that si “ 1 when the exchange knows the
secret key xi and si “ 0 otherwise.
We extend Protocol 1 to force every exchange to also compute
the list L “ thˆxi “ hxi¨si for i P r1, nsu which is randomly per-
muted and published. Note that when si “ 1 the corresponding
element in L is hxi and when si “ 0 the corresponding element
is simply 1 P G, the identity element. Thus L is a random permu-
tation of the exchange’s Bitcoin public keys, but using the base h
instead of g.

We require the exchange to prove that L is correctly constructed
(i.e., a permutation of hˆx1 , . . . , hˆxn) using a zero knowledge proof
used as a component of the Neff mix net [24]. That zero-knowledge
proof is used to prove that a given list (cid:96)2 “ thz1 , . . . , hznu
is a permutation and base change of another given list (cid:96)1 “
tgz1 , . . . , gznu. This Neff proof thus proves that the published list
L is constructed correctly. It is a simple and efﬁcient proof, re-
quiring 8n group elements (8 for each account) and 4n additional
exponentiations during construction and veriﬁcation.
We show below that the list L reveals no information about the
E’s Bitcoin addresses beyond the number of addresses ν controlled
by E. Note that ν is not revealed by the basic protocol (Protocol 1).
We’ll return to the implications of making this information public
in Section 9.1 but this is one reason (in addition to added complex-
ity) why we present this as an optional protocol extension.
Now, suppose two exchanges collude and use the same Bitcoin
address y “ gx in their proof of solvency. Then hx will appear in
the L list of both exchanges. In other words, the L lists of these
two exchanges will have a non-trivial intersection.

Since every exchange is required to publish its list L, an auditor
can simply check that these lists are mutually disjoint (ignoring the
elements 1 P G). If so, then the auditor is assured that every Bitcoin
address is used in at most one proof of solvency and this holds even
if all the exchanges use the same anonymity set PK.

An important security requirement is that all exchanges run the
extension at the same time—barring this, a simple attack is for ex-
changes to move bitcoins from one address to another in between
runs of the protocol so that the same funds can be used but with
a different value for hˆxi “ hxi¨si in each L (since xi will have
changed). Fortunately, the blockchain already provides an easy
method of synchronization. Exchanges simply need to agree on
a common block number (say, every 240th block to run the protocol
daily) and all run the protocol based on the state of the blockchain
up to that block. No further synchronization is required; all ex-
changes can run the protocol and publish their proofs independently
and any assets used by more than one exchange will be detectable.
It remains to argue that the list L reveals no information about
the exchange’s Bitcoin addresses beyond the number of addresses.
This follows directly from the Decision Difﬁe-Hellman (DDH) as-
sumption which is believed to hold in the secp256k1 group. DDH
states that given the tuple xg, h, hxy, the quantity gx is compu-
tationally indistinguishable from a random element of G. There-
fore, given the list L it is not possible to distinguish the n-bit string
ps1, . . . , snq P t0, 1un from a random bit string of the same length.
8. SECURITY DEFINITION & PROOF
We now present a general (not speciﬁc to Provisions) deﬁnition
of a privacy-preserving proof of solvency. We say a function νpkq
is negligible if for all positive polynomials pp¨q, there is a sufﬁ-
ciently large k such that νpkq ă 1{ppkq.
Let A and A1 denote mappings py “ gxq ÞÑ balpyq where
A Ď A1, y is the public key corresponding to a Bitcoin address

with private key x and balpyq is the amount of currency, or assets,
observably spendable by this key on the blockchain.
Let L denote a mapping ID ÞÑ (cid:96) where (cid:96) is the amount of cur-
rency, or liabilities, owed by the exchange to each user identiﬁed
by the unique identity ID.
Deﬁnition 1 (Valid Pair). We say that A and L are a valid pair
with respect to a positive integer MaxBTC iff @ID P L ,

ř
yPA Arys ´
1.
2. 0 ď LrIDs ď MaxBTC
Consider an interactive protocol ProveSolvency run between an

ř
IDPL LrIDs ě 0 and

exchange E and user U such that

1. outputProveSolvency

E

2. outputProveSolvency

tACCEPT, REJECTu

U

p1k, MaxBTC,A,L,A1q “ ø
p1k, MaxBTC,A1, ID, (cid:96)q

P

For brevity, we refer to these as outE and outU respectively.

Deﬁnition 2 (Privacy-Preserving Proof of Solvency). A privacy-
preserving proof of solvency is a probabilistic polynomial-time in-
teractive protocol ProveSolvency, with inputs/outputs as above,
such that the following properties hold:

1. Correctness. If A and L are a valid pair and LrIDs “ (cid:96),

then P rroutU “ ACCEPTs “ 1.

2. Soundness. If A and L are instead not a valid pair, or if

LrIDs ‰ (cid:96), then P rroutU “ REJECTs ě 1 ´ νpkq.

3. Ownership. For all valid pairs A and L, if P rroutU “
ACCEPTs “ 1, then the exchange must have ‘known’ the
private keys associated with the public keys in A; i.e., there
exists an extractor that, given A, L, and rewindable black-
box access to E, can produce x for all y P A.

4. Privacy. A potentially dishonest user interacting with an
honest exchange cannot learn anything about a valid pair A
and L beyond its validity and LrIDs (and possibly |A| and
|L|); i.e., even a cheating user cannot distinguish between
an interaction using the real pair A and L and any other
(equally sized) valid pair ˆA and ˆL such that ˆLrIDs “ LrIDs.

We prove the following theorem in the full paper [11]:

Theorem 3. Provisions, as speciﬁed in Protocol 3, is a privacy-
preserving proof of solvency.

9. SECURITY DISCUSSION
9.1 Anonymity sets

Although Theorem 3 is true, in the case that the protocol ex-
tension of Section 7 is used, the number of Bitcoin addresses ν
controlled by the exchange is revealed as well as the size of the
anonymity set n “ |PK| (which includes the ν addresses). For ef-
ﬁciency reasons, exchanges may opt to use smaller anonymity sets
than the set of all public keys on the blockchain; in particular, if the
number of keys grows unexpectedly in the future. In such a case,
the exchange must be aware that this might leak some meaningful
information about what E’s total assets are.
Speciﬁcally, the adversary can determine that E’s assets consist
subsets of the anonymity set PK. We remark

of one of the

`

˘

n
ν

727`

˘

n
ν

that E can easily control n and can also control ν (by splitting ac-
counts up or by padding ν with zero balance accounts). For prac-
grows quickly—e.g., ν “ 25 and µ “ 250
tical instances,
already yields « 2114 candidates. That said, we have no idea what
types of external information might be useful for eliminating un-
likely or impossible totals from this set (e.g., the adversary’s cor-
ruption of customers may provides them with a lower bound on
the total assets), or for whittling n down by eliminating addresses
known or suspected not to be controlled by the exchange. Research
on deanonymizing Bitcoin addresses, e.g., through clustering and
reidentiﬁcation [20], has demonstrated that Bitcoin’s anonymity is
limited (see [4] for a survey).

If an exchange conducts proofs of solvency on a regular basis (or
more than once), each anonymity set should be based closely on the
anonymity set used previously—choosing independent anonymity
sets could reveal the exchange’s addresses by intersecting the sets.
Exchanges can remove addresses from their anonymity set if the
criteria for doing so is independent of whether the exchange owns
the address or not. For example, it might remove addresses once
the balance is under a certain threshold. However, generally,
anonymity sets should grow over time with new addresses (some
owned by the exchange and some as cover) being added to the set.
We leave the process of developing and analyzing a heuristic for
forming an anonymity set (in terms of size of n and ν and the dis-
tribution of amounts across the ν accounts) as future work. For the
current state of Bitcoin at the time of writing, we show in Section 10
that it is reasonable for all exchanges to choose an anonymity set
equal to most available accounts, sieving out tiny “dust” accounts.
9.2 User Veriﬁcation

U
A

Although Theorem 3 is true, it may fall short of an ideal level of
user veriﬁcation. Speciﬁcally, a proof of solvency enables user ver-
iﬁcation, but it does not guarantee that users actually perform the
veriﬁcation. Consider a malicious E that does not correctly include
some set of users accounts—by either omitting them or zeroing
their balances. Assume the exchange has U users, F (for fraudu-
lent) entries, and that a random subset A Ă U of users choose to
audit the correctness of LiabList. In this case, the probability that
an adversary will go undetected is
, which is closely
bounded from above by minrp1 ´ A{UqF ,p1 ´ F{UqAs (cf. the
probability of a malicious election authority being caught modi-
fying ballot receipts in a cryptographic voting system [8]). This
probability decreases close-to-exponentially in F and A. Due to
the approximation, we conservatively conclude the probability of
being caught is high, instead of overwhelming.

`
{

U´F
A

`

˘

˘

Next, one might question the assumption that each customer is
equally likely to verify LiabList. However, it is reasonable that the
distribution skews in the direction of customers with high balances
(and thus more at stake) being more likely to check. This is ac-
tually beneﬁcial, because the probability of catching a malicious
exchange does not depend on the amount of bitcoin zeroed out. In
other words, zeroing out the largest account is equivalent to zero-
ing out the smallest in terms of being caught, yet the former action
better beneﬁts the adversary’s goal of lowering its liabilities.

We also note that Provisions as described does not provide dis-
pute resolution.
If a user ﬁnds their account missing or balance
incorrect, they do not have sufﬁcient cryptographic evidence that
this is the case [17]. The issue appears unsolvable cryptographi-
cally. Recall that the primary motivation for users keeping funds
with an exchange is to avoid needing to remember long-term cryp-
tographic secrets, therefore exchanges must be able to execute user
orders and change their balance without cryptographic authentica-
tion from the user (e.g., password authentication). Resolving this

will likely require legal regulation. Users who dislike an exchange
may also falsely claim that veriﬁcation of their accounts failed, and
it is not possible to judge if the user or the exchange is correct in
this case based on a Provisions transcript alone.

Lastly, we note that if a user does verify their account, they
should use a veriﬁcation tool other than one provided by the ex-
change itself; such a tool could be automated to increase partici-
pation. All of the issues discussed in this remark deserve followup
work to ensure that Provisions is implemented in practice in such a
way that users are likely to perform auditing and to do so correctly.

IMPLEMENTATION

10.
10.1 Asymptotic performance

Provisions scales linearly in proof size, construction and veri-
ﬁcation time with respect to its inputs: the proof of assets scales
with the size of the anonymity set and the proof of liabilities scales
with the number of customer accounts. The ﬁnal proof of solvency
given an encryption of the total assets and an encryption of the total
liabilities is constant and in practice is negligible. All of the linear
parts of the protocol can be run in parallel and require only asso-
ciative aggregations to compute homomorphic sums, meaning the
protocol is straightforward to parallelize.

Speciﬁcally the proof of assets is linear in n, the number of pub-
lic keys in the anonymity set, regardless of the size of S, the total
number of accounts actually owned by E, requiring 13n integers
from Zq in total. The proof of liabilities is linear with respect to
the number of customers c. It is dominated by m ` 1 elements
from Zq used to commit to each bit of each customer’s balance,
where m “ rlg2 MaxBTCs “ 51. If needed, an exchange could
slightly reduce proof sizes by capping the size of assets below or
reducing precision. For example, with m “ 32 the exchange could
still include accounts worth up to US$1 billion with precision to
the nearest penny. However, we’ll assume full precision is desired
in our implementation.

Full veriﬁcation of the protocol requires approximately equal
time to the construction of the proof. For customers opting to only
validate their own balance’s correct inclusion in the proof and trust
a third party to run the full veriﬁcation, veriﬁcation is much sim-
pler, the customer to check their CID value with a single hash and
check that yi is a correct commitment their balance which requires
only m ` 2 group operations.
10.2 Incremental updates

As described in Section 1 the protocol is intended to be run often
(e.g. daily) to give continued proof of solvency. A natural question
is whether it is possible to update the proof incrementally. We will
consider updates to the anonymity set, to the assets proof and to the
liabilities proof separately.

The full set of addresses (anonymity set + owned addresses) used
in the proof is public. As such any newly created addresses by
the exchange need to be published. To hide these new addresses
it is important to additionally add addresses to the anonymity set.
As with the anonymity set in general and discussed in Section 9.1
it is important to choose in such a way that the actual addresses
are indistinguishable from it. A proper implementation would for
example add addresses deterministically (e.g. all addresses with
balances over X bitcoin).

The asset proof is almost perfectly separable, in that there is a
separate and independent component for each address in the full
set of addresses. The components for new addresses and addresses
with changed balance need to be updated. However, it is not nec-
essary to update the components of all other addresses. This is

728especially useful for cold addresses, which do not have a private
key easily accessible. The set of addresses which are new or have
changed balances is public on the blockchain anyways and thus no
additional information is leaked.

The liabilities proof mainly consists of a commitment to each
customer’s balance and a proof that said balance is within a range.
For all new users and users whose balance changed the commit-
ment the proof needs to be redone. For the other users it is not
technically necessary to redo the proof. However, not changing the
proofs for customers whose balance remained unchanged will leak
how many users were actively using their account between the two
proofs. If the complete proof were redone then this information
would remain private. If an exchange were to accept this privacy
leak it could drastically reduce the size of the proof updates.
10.3 Practical parameter sizes

An exchange could achieve optimum anonymity by choosing the
anonymity set PK to be the entire set of unclaimed transaction out-
puts (called the UTXO set) which represents all potentially active
Bitcoin accounts. The size of the UTXO set has steadily increased
throughout Bitcoin’s history [4] and at the time of this writing con-
tains approximately 17M addresses. However, the vast majority
of these are “dust” addresses holding only a tiny value. There are
fewer than 500,000 addresses with a balance of more than 0.1 BTC,
which collectively control 99.8% of all bitcoin.11 Some of these
addresses are unusable for the protocol because they do not have
public keys available (i.e., they are pay-to-pub-key-hash addresses
with only a hash of the public key visible in the block chain), others
have questionable anonymity value as they have never been moved
since being mined and exchanges are not expected to be mining
their own bitcoin directly. Thus, we expect that fewer than a million
addresses are available to be used in the anonymity set in practice
We tested our implementation with anonymity sets up to 500,000.
On the proof of liabilities side, Coinbase is thought to be one
the largest exchanges and currently claims roughly 2 million cus-
tomers.12 We take as our goal supporting this number of users.
10.4 Implementation & performance tests

To test the performance of our protocol in practice we created a
prototype implementation of our protocol in Java 1.8. All crypto-
graphic operations are performed using BouncyCastle,13 a standard
cryptographic library for Java which is also used by the popular bit-
coinj implementation of Bitcoin in Java. We performed tests on a
commodity server with 2 E5-2680 v2 Xenon processors and 128GB
RAM. The max heap size of the JVM was set to the default 256MB.
Our implementation assumes a previously downloaded and veriﬁed
blockchain, to enable efﬁcient balance lookups and selection of an
appropriate anonymity set.

Our simulations conﬁrm that Provisions should be practical
even for large exchanges desiring strong anonymity and full pre-
cision to represent customer accounts. Figure 2 shows proof sizes
and computation times for Protocol 1, the proof of assets, varying
the anonymity set size n from 10 to 500,000. Figure 3 shows proof
sizes and computation times for Protocol 2, the proof of liabilities,
varying the number of customers c from 1,000 to 2,000,000. We
tested with m “ 51, supporting full precision of account balances.
Reducing m would lead to proportional reductions in proof sizes
and construction times. Note that, given realistic parameters today,

11https://bitinfocharts.com/
top-100-richest-bitcoin-addresses.html
12https://www.coinbase.com/about
13https://www.bouncycastle.org/

Figure 2: Performance for Protocol 1 (proof of assets).

Figure 3: Performance for Protocol 2 (proof of liabilities).

it appears that the proof of liabilities is the more expensive protocol
today for a large exchange.

We report numbers without the protocol extension from Sec-
tion 7 to ensure assets are not shared between colluding exchanges
executing the protocol contemporaneously. This extensions would
increase the size and construction time of the proof of assets by
13 « 30%. Because the proof of liabilities is likely much
about 4
larger, this extension makes only a minor impact on performance.
We omit performance ﬁgures for Protocol 3 as this protocol is
constant size and negligible compared to Protocols 1 and 2. Sim-
ilarly, veriﬁcation time for individual clients depends only m and
not the anonymity set or number of other customers. In our imple-
mentation it took fewer than 10 ms.

11. CONCLUDING REMARKS

Stu Feldman has outlined a roadmap for technical maturity (as

quoted in [14]):

1. You have a good idea;
2. You can make your idea work;
3. You can convince a (gullible) friend to try it;
4. People stop asking why you are doing it; and
5. Other people are asked why they are not doing it.

Given the shaky track record of Bitcoin exchanges, the onus
upon an exchange to perform some kind of audit is nearing level 5.

010020030040050060070080090010000 min10 min20 min30 min40 min50 min60 min0k100k200k300k400k500kSize in MBTime in MinutesAnonymity Set Size(in Thousands) Construction TimeVerification TimeProof Size024681012141618200 min30 min60 min90 min120 min150 min180 min210 min240 min270 min300 min0k250k500k750k1000k1250k1500k1750k2000kSize in GBTime in MinutesNumber of Customers (in Thousands), m=51Construction TimeVerification TimeProof Size729However, cryptographic solvency proofs, like the Maxwell proto-
col, are lagging behind around level 3. Our belief is that the privacy
implications of Maxwell are hindering it—there are good reasons
for an exchange not to reveal which addresses it controls, the scale
of its total holdings, or potentially leak information about large cus-
tomers’ account sizes. Provisions removes these barriers. While
cryptographic proofs of solvency still have inherent limits, namely
that control of an address’ key at present does not guarantee the fu-
ture ability to use that key to refund customers, we believe that with
Provisions there are no longer good reasons for an exchange not to
provide regular proofs of solvency to increase customer conﬁdence.

Acknowledgments
We thank the reviewers for their insights. We especially thank our
shepherd Sarah Meiklejohn for her constructive feedback and con-
tributions which improved the paper. J. Bonneau is supported by
a Secure Usability Fellowship from the Open Technology Fund
and Simply Secure as well and is also supported by DARPA. J.
Clark acknowledges funding from NSERC, FQRNT and Concordia
OVPRGS. D. Boneh acknowledges funding from NSF, DARPA,
and a grant from ONR. Opinions, ﬁndings and conclusions or rec-
ommendations expressed in this material are those of the authors
and do not necessarily reﬂect the views of DARPA.

References
[1] O. Baudron, P.-A. Fouque, D. Pointcheval, G. Poupard, and
J. Stern. Practical multi-candidate election system. In ACM
PODC, 2001.

[2] M. Belenkiy. E-Cash. In Handbook of Financial

Cryptography and Security. CRC, 2011.

[3] E. Ben-Sasson, A. Chiesa, D. Genkin, E. Tromer, and
M. Virza. Snarks for C: verifying program executions
succinctly and in zero knowledge. In CRYPTO, 2013.

[4] J. Bonneau, A. Miller, J. Clark, A. Narayanan, J. A. Kroll,

and E. W. Felten. Research Perspectives and Challenges for
Bitcoin and Cryptocurrencies. IEEE Symposium on Security
and Privacy, 2015.

[5] J. Camenisch, S. Hohenberger, and A. Lysyanskaya.

Compact e-cash. In EUROCRYPT, 2005.

[6] Certicom Research. SEC 2: Recommended Elliptic Curve

Domain Parameters, Version 1.0., 2000.

[7] D. Chaum. Blind signatures for untraceable payments. In

CRYPTO, 1982.

[8] D. Chaum, R. Carback, J. Clark, A. Essex, S. Popoveniuc,

R. L. Rivest, P. Y. A. Ryan, E. Shen, and A. T. Sherman.
Scantegrity II: end-to-end veriﬁability for optical scan
election systems using invisible ink conﬁrmation codes. In
EVT, 2008.

[9] D. Chaum and T. P. Pedersen. Wallet databases with

observers. In CRYPTO, 1992.

[10] R. Cramer, I. Damgård, and B. Schoenmakers. Proofs of
partial knowledge and simpliﬁed design of witness hiding
protocols. In CRYPTO, 1994.

[11] G. Dagher, B. Bünz, J. Bonneau, J. Clark, and D. Boneh.

Provisions: Privacy-preserving proofs of solvency for bitcoin
exchanges (full version). Technical report, IACR Cryptology
ePrint Archive, 2015.

[12] S. Eskandari, D. Barrera, E. Stobert, and J. Clark. A ﬁrst look
at the usability of bitcoin key management. In USEC, 2015.

[13] A. Fiat and A. Shamir. Witness indistinguishable and

witness hiding protocols. In ACM STOC, 1990.

[14] D. Geer. Technical maturity, reliability, implicit taxes, and

wealth creation. login: The magazine of Usenix & Sage,
26(8), 2001.

[15] S. Goldfeder. Better wallet security for bitcoin. Technical

report, Princeton, March 2014.

[16] C. Hazay and Y. Lindell. Efﬁcient Secure Two-Party

Protocols. Springer, 2010.

[17] R. Kusters, T. Truderung, and A. Vogt. Accountability:

Deﬁnition and relationship to veriﬁability. In ACM CCS,
2010.

[18] P. Litke and J. Stewart. Cryptocurrency-stealing malware
landscape. Technical report, Dell SecureWorks Counter
Threat Unit, 2014.

[19] W. Mao. Guaranteed correct sharing of integer factorization

with off-line shareholders. In PKC, 1998.

[20] S. Meiklejohn, M. Pomarole, G. Jordan, K. Levchenko,

D. McCoy, G. M. Voelker, and S. Savage. A ﬁstful of
bitcoins: characterizing payments among men with no
names. In IMC, 2013.

[21] R. C. Merkle. Secrecy, Authentication, and Public Key

Systems. PhD thesis, Stanford, 1979.

[22] T. Moore and N. Christin. Beware the middleman: Empirical
analysis of bitcoin-exchange risk. In Financial Cryptography
and Data Security, 2013.

[23] S. Nakamoto. Bitcoin: A peer-to-peer electionic cash

system. Unpublished, 2008.

[24] C. A. Neff. A veriﬁable secret shufﬂe and its application to

e-voting. In ACM CCS, 2001.

[25] R. Parhonyi. Micropayment Systems. In Handbook of

Financial Cryptography and Security. CRC, 2011.

[26] T. P. Pedersen. Non-interactive and information-theoretic

secure veriﬁable secret sharing. In CRYPTO, 1992.

[27] C. P. Schnorr. Efﬁcient signature generation by smart cards.

Journal of Cryptography, 4, 1991.

[28] A. Vogt, T. Truderung, and R. Kusters. Clash attacks on the

veriﬁability of e-voting systems. In IEEE Symposium on
Security and Privacy, 2012.

[29] Z. Wilcox. Proving your bitcoin reserves.

https://iwilcox.me.uk/2014/proving-bitcoin-reserves, Feb.
2014.

730APPENDIX
A. PROOF OF ASSETS IS HVZKP

Recall Theorem 1:

Theorem 1. The Σ-protocol in Protocol 1 is a honest-veriﬁer zero
knowledge proof of knowledge of quantities

Assets and psi P t0, 1u, vi, ti, ˆxi P Zqq for i P r1, ns

that satisfy conditions (1),(2), (3) and (4) for all i P r1, ns.

In other words, Protocol 1 is honest-veriﬁer zero knowledge of

the following relation:

PoKtpAssets, si P t0, 1u, vi, ti, ˆxiq : g, h, yi, balpyiq, li, piu

Proof. By the deﬁnition of HVZKP (see full paper [11]), proofs of
the following Claims 1.1, 1.2, and 1.3 imply Theorem 1 holds.
Claim 1.1. (Completeness) If P and a veriﬁer V follow protocol 1
on input pg, h, yi, balpyiq, li, piq and private input pAssets, si P
t0, 1u, vi, ti, ˆxiq, then V always accepts.
Proof. Suppose E knows vi , si and ti. By assumption E followed
the protocol and all pi and li are, thus, well formed. E can then
for any random u
and challenges ci compute all responses rp¨q.
Completeness follows because for i P r1, ns:
p4q
i hci¨vi

p¨q
i

rsi

b

y

rsi

hu

p1q
i hrvi “ b
bci¨si
u
i
i
i
“ pci
p1q
i a
i
p1q
i hrti “ y
yci¨si
u
i
i
i
“ lci
p2q
p3q
i a
i a
i
p3q
grˆxi hrti “ gu
i gci¨ˆxi hu
“ lci
p3q
i a
i a

p4q
i

hu

p2q
i hci¨ti

p2q
i hci¨ti

Claim 1.2. (Soundness) There exists a polynomial-time algorithm
(extractor E) for Protocol 1 such that for each i P r1, ns and any
pair of accepting transcripts with the same a
i, E can
compute pvi, si, ti, ˆxiq.

i and ci ‰ c1
p¨q

Proof. We show in Figure 4 that there exists an extractor E for all
efﬁcient provers P‹ that convince the veriﬁer. Note that

1. For i P r1, ns

p1q
(a) Run P ‹ to obtain a
i
$ÐÝ Zq to P ‹
(b) Send ci
(c) P ‹ will output rsi , rti , rˆxi , rvi such that

p2q
i

p3q
i

p4q
i

, a

, a

, a

b

rsi

i hrvi “ pci
i a
i hrti “ lci
y
i a
grˆxi hrti “ lci
i a

p1q
i
p2q
i a
p3q
i a

rsi

p3q
i
p4q
i

i

b

(d) Rewind P ‹ to right after step 1b of the protocol.
$ÐÝ Zqztciu to P ‹
(e) Send c1
ˆxi , r1
ti , r1
si , r1
(f) P ‹ will output r1
r1
vi “ pc1
i hr1
si
i a
r1
i hr1
ti “ lc1
si
y
i a
gr1
ˆxi hr1
ti “ lc1
i a
(g) Output: vi “ rvi´r1
mod q, si “ rsi´r1
v1
si
ci´c1
ci´c1
´r1
mod q, ti “ rti´r1
mod q, ˆxi “ rˆxi
ˆxi
ti
ci´c1
ci´c1

vi such that
p1q
i
p2q
i a
p3q
i a

p3q
i
p4q
i

i

i

i

i

i

i

mod q

Figure 4: Extractor for Proof of Assets protocol

Claim 1.3. (Honest Veriﬁer Zero Knowledge) There exists a prob-
abilistic polynomial-time simulator S that, given pg, h, yi, balpyiq,
li, pi and random challenge ci for each i P r1, ns, can produce a
transcript that has the same distribution as a transcript between P
and an honest veriﬁer.

Proof. A simulator is given in Figure 5. Note that both the original
a’s as well as the simulated a’s are distributed uniformly at random
in G given that the challenge ci was chosen uniformly at random.
Given uniformly chosen u’s the responses in the protocol are uni-
form in Zq. The simulated responses are uniformly drawn. The
probability of a simulated transcript thus equals the probability of
an actual transcript.

nź

b

i“1

i

hrtZ ´r1

tZ

rsi´r1

si

“ pZAssetsqci´c1

i

1. For each i P r1, ns

y

and

rsi´r1

si

i

hrti´r1

ti “ lci´c1

i

i

grˆxi

´r1

ˆxi hrti´r1

ti “ lci´c1

i

i

Since ci ‰ c1
that the protocol is sound.

i we can conclude that E gives valid outputs and thus

Additionally in the full version [11], we provide an extractor and
simulator for a HVZKP proof that a committed value is binary.
Were this extractor run on li, it can extract a binary si.

(a) Choose rsi , rti , rˆxi , rvi uniformly at
i “ y
p2q

from Zq
i “ b
p1q
(b) Let: a
´ci
, and a
hrti l
(c) Publish pa

´ci
rsi
i hrvi p
i “ grˆxi
p4q
p3q
p2q
, a
i
i
as the transcript.

p1q
i

p4q
i

, a

, a

, a

rsi
i

i

i

random

i “
p3q

, a

; ci ; rsi , rti , rˆxi , rviq

Figure 5: Simulator for Proof of Assets protocol

731