Enhancing Bitcoin Security and Performance  
with Strong Consistency via Collective Signing

Eleftherios Kokoris Kogias, Philipp Jovanovic, Nicolas Gailly, Ismail Khoffi,  
Linus Gasser, and Bryan Ford, École Polytechnique Fédérale de Lausanne (EPFL)
 https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/kogias

This paper is included in the Proceedings of the 25th USENIX Security SymposiumAugust 10–12, 2016 • Austin, TXISBN 978-1-931971-32-4Open access to the Proceedings of the 25th USENIX Security Symposium is sponsored by USENIX Enhancing Bitcoin Security and Performance with

Strong Consistency via Collective Signing

Eleftherios Kokoris-Kogias, Philipp Jovanovic, Nicolas Gailly,

Ismail Khofﬁ, Linus Gasser, and Bryan Ford

EPFL

Abstract
While showing great promise, Bitcoin requires users to
wait tens of minutes for transactions to commit, and
even then, offering only probabilistic guarantees. This
paper introduces ByzCoin, a novel Byzantine consen-
sus protocol that leverages scalable collective signing to
commit Bitcoin transactions irreversibly within seconds.
ByzCoin achieves Byzantine consensus while preserv-
ing Bitcoin’s open membership by dynamically form-
ing hash power-proportionate consensus groups that rep-
resent recently-successful block miners. ByzCoin em-
ploys communication trees to optimize transaction com-
mitment and veriﬁcation under normal operation while
guaranteeing safety and liveness under Byzantine faults,
up to a near-optimal tolerance of f faulty group members
among 3 f + 2 total. ByzCoin mitigates double spend-
ing and selﬁsh mining attacks by producing collectively
signed transaction blocks within one minute of trans-
action submission. Tree-structured communication fur-
ther reduces this latency to less than 30 seconds. Due
to these optimizations, ByzCoin achieves a throughput
higher than Paypal currently handles, with a conﬁrma-
tion latency of 15-20 seconds.

1 Introduction

Bitcoin [47] is a decentralized cryptocurrency providing
an open, self-regulating alternative to classic currencies
managed by central authorities such as banks. Bitcoin
builds on a peer-to-peer network where users can sub-
mit transactions without intermediaries. Special nodes,
called miners, collect transactions, solve computational
puzzles (proof-of-work) to reach consensus, and add the
transactions in form of blocks to a distributed public
ledger known as the blockchain.

The original Bitcoin paper argues that transaction pro-
cessing is secure and irreversible, as long as the largest
colluding group of miners represents less than 50% of

total computing capacity and at least about one hour has
elapsed. This high transaction-conﬁrmation latency lim-
its Bitcoin’s suitability for real-time transactions. Later
work revealed additional vulnerabilities to transaction
reversibility, double-spending, and strategic mining at-
tacks [25, 31, 34, 35, 48, 3].

The key problem is that Bitcoin’s consensus algo-
rithm provides only probabilistic consistency guarantees.
Strong consistency could offer cryptocurrencies three
important beneﬁts. First, all miners instantly agree on
the validity of blocks, without wasting computational
power resolving inconsistencies (forks). Second, clients
need not wait for extended periods to be certain that a
submitted transaction is committed; as soon as it ap-
pears in the blockchain, the transaction can be consid-
ered conﬁrmed. Third, strong consistency provides for-
ward security: as soon as a block has been appended
to the blockchain, it stays there forever. Although in-
creasing the consistency of cryptocurrencies has been
suggested before [17, 19, 43, 52, 56], existing propos-
als give up Bitcoin’s decentralization, and/or introduce
new and non-intuitive security assumptions, and/or lack
experimental evidence of performance and scalability.

This work introduces ByzCoin, a Bitcoin-like cryp-
tocurrency enhanced with strong consistency, based on
the principles of the well-studied Practical Byzantine
Fault Tolerance (PBFT) [14] algorithm. ByzCoin ad-
dresses four key challenges in bringing PBFT’s strong
consistency to cryptocurrencies: (1) open membership,
(2) scalability to hundreds of replicas, (3) proof-of-work
block conﬂicts, and (4) transaction commitment rate.

PBFT was not designed for scalability to large consen-
sus groups: deployments and experiments often employ
the minimum of four replicas [38], and generally have
not explored scalability levels beyond 7 [14] or 16 repli-
cas [16, 32, 1]. ByzCoin builds PBFT atop CoSi [54],
a collective signing protocol that efﬁciently aggregates
hundreds or thousands of signatures. Collective sign-
ing reduces both the costs of PBFT rounds and the costs

USENIX Association  

25th USENIX Security Symposium  279

1

for “light” clients to verify transaction commitment. Al-
though CoSi is not a consensus protocol, ByzCoin imple-
ments Byzantine consensus using CoSi signing rounds to
make PBFT’s prepare and commit phases scalable.

PBFT normally assumes a well-deﬁned, closed group
of replicas, conﬂicting with Bitcoin’s open membership
and use of proof-of-work to resist Sybil attacks [23].
ByzCoin addresses this conﬂict by forming consensus
groups dynamically from windows of recently mined
blocks, giving recent miners shares or voting power
proportional to their recent commitment of hash power.
Lastly, to reduce transaction processing latency we adopt
the idea from Bitcoin-NG [24] to decouple transaction
veriﬁcation from block mining.

Experiments with a prototype implementation of Byz-
Coin show that a consensus group formed from approxi-
mately the past 24 hours of successful miners (144 min-
ers) can reach consensus in less than 20 seconds, on
blocks of Bitcoin’s current maximum size (1MB). A
larger consensus group formed from one week of suc-
cessful miners (1008) reached consensus on an 8MB
block in 90 seconds, showing that the systems scales
both with the number of participants and with the block
size. For the 144-participant consensus group, with a
block size of 32MB, the system handles 974 transac-
tions per second (TPS) with a 68-second conﬁrmation la-
tency. These experiments suggest that ByzCoin can han-
dle loads higher than PayPal and comparable with Visa.
ByzCoin is still a proof-of-concept with several lim-
itations. First, ByzCoin does not improve on Bitcoin’s
proof-of-work mechanism; ﬁnding a suitable replace-
ment [4, 28, 37, 58] is an important but orthogonal area
for future work. Like many BFT protocols in prac-
tice [15, 32], ByzCoin is vulnerable to slowdown or tem-
porary DoS attacks that Byzantine nodes can trigger. Al-
though a malicious leader cannot violate or permanently
block consensus, he might temporarily exclude minority
sets (< 1
3) of victims from the consensus process, depriv-
ing them of rewards, and/or attempt to censor transac-
tions. ByzCoin guarantees security only against attack-
ers who consistently control less than a third (not 50%)
of consensus group shares – though Bitcoin has analo-
gous weaknesses accounting for selﬁsh mining [25].

In this paper we make the following key contributions:
• We use collective signing [54] to scale BFT protocols
to large consensus groups and enable clients to verify
operation commitments efﬁciently.

• We demonstrate experimentally (§4) that a strongly-
consistent cryptocurrency can increase Bitcoin’s
throughput by two orders of magnitude, with a trans-

(§3)

• We present

the ﬁrst demonstrably practical
Byzantine consensus protocol supporting not only
static consensus groups but also dynamic membership
proportional to proof-of-work as in Bitcoin.

action conﬁrmation latency under one minute.

• We ﬁnd through security analysis (§5) that ByzCoin
can mitigate several known attacks on Bitcoin pro-
vided no attacker controls more than 1
4 of hash power.

2 Background and Motivation

This section ﬁrst outlines the three most relevant areas
of prior work that ByzCoin builds on: cryptocurrencies
such as Bitcoin and Bitcoin-NG, Byzantine fault toler-
ance (BFT) principles, and collective signing techniques.

2.1 Bitcoin and Variations
Bitcoin. At the core of Bitcoin [47] rests the so-called
blockchain, a public, append-only database maintained
by miners and serving as a global ledger of all transac-
tions ever issued. Transactions are bundled into blocks
and validated by a proof-of-work. A block is valid if its
cryptographic hash has d leading zero bits, where the dif-
ﬁculty parameter d is adjusted periodically such that new
blocks are mined about every ten minutes on average.
Each block includes a Merkle tree [44] of new transac-
tions to be committed, and a cryptographic hash chaining
to the last valid block, thereby forming the blockchain.
Upon successfully forming a new block with a valid
proof-of-work, a miner broadcasts the new block to the
rest of the miners, who (when behaving properly) accept
the new block, if it extends a valid chain strictly longer
than any they have already seen.

Bitcoin’s decentralized consensus and security derive
from an assumption that a majority of the miners, mea-
sured in terms of hash power or ability to solve hash-
based proof-of-work puzzles, follows these rules and al-
ways attempts to extend the longest existing chain. As
soon as a quorum of miners with the majority of the
network’s hash power approves a given block by min-
ing on top of it, the block remains embedded in any fu-
ture chain [29]. Bitcoin’s security is guaranteed by the
fact that this majority will be extending the legitimate
chain faster than any corrupt minority that might try to
rewrite history or double-spend currency. However, Bit-
coin’s consistency guarantee is only probabilistic, which
leads to two fundamental problems.

First, multiple miners might ﬁnd distinct blocks with
the same parent before the network has reached consen-
sus. Such a conﬂict is called a fork, an inconsistency that
is temporarily allowed until one of the chains is extended
yet again. Subsequently, all well-behaved miners on the
shorter chain(s) switch to the new longest one. All trans-
actions appearing only in the rejected block(s) are invalid
and must be resubmitted for inclusion into the winning
blockchain. This means that Bitcoin clients who want
high certainty that a transaction is complete (e.g., that

280  25th USENIX Security Symposium 

USENIX Association

2

they have irrevocably received a payment) must wait not
only for the next block but for several blocks thereafter,
thus increasing the time interval until a transaction can
be considered complete. As a rule of thumb [47], a block
is considered as permanently added to the blockchain af-
ter about 6 new blocks have been mined on top of it, for
a conﬁrmation latency of 60 minutes on average.

Second, the Bitcoin block size is currently limited to
1 MB. This limitation in turn results in an upper bound
on the number of transactions per second (TPS) the Bit-
coin network can handle, estimated to be an average
of 7 TPS. For comparison, Paypal handles 500 TPS and
VISA even 4000 TPS. An obvious solution to enlarge
Bitcoin’s throughput is to increase the size of its blocks.
Unfortunately, this solution also increases the probability
of forks due to higher propagation delays and the risk of
double-spending attacks [53, 30, 36]. Bitcoin’s liveness
and security properties depend on forks being relatively
rare. Otherwise, the miners would spend much of their
effort trying to resolve multiple forks [31, 17], or in the
extreme case, completely centralize Bitcoin [24]

Bitcoin-NG. Bitcoin-NG [24] makes the important ob-
servation that Bitcoin blocks serve two different pur-
poses: (1) election of a leader who decides how to re-
solve potential inconsistencies, and (2) veriﬁcation of
transactions. Due to this observation, Bitcoin-NG pro-
poses two different block types: Keyblocks are generated
through mining with proof-of-work and are used to se-
curely elect leaders, at a moderate frequency, such as ev-
ery 10 minutes as in Bitcoin. Microblocks contain trans-
actions, require no proof-of-work, and are generated and
signed by the elected leader. This separation enables
Bitcoin-NG to process many microblocks between the
mining of two keyblocks, enabling transaction through-
put to increase.

Bitcoin-NG, however, retains many drawbacks of Bit-
coin’s consistency model. Temporary forks due to near-
simultaneous keyblock mining, or deliberately intro-
duced by selﬁsh or malicious miners, can still throw the
system into an inconsistent state for 10 minutes or more.
Further, within any 10-minute window the current leader
could still intentionally fork or rewrite history and inval-
idate transactions. If a client does not wait several tens
of minutes (as in Bitcoin) for transaction conﬁrmation,
he is vulnerable to double-spend attacks by the current
leader or by another miner who forks the blockchain.
Although Bitcoin-NG includes disincentives for such be-
havior, these disincentives amount at most to the “mining
value” of the keyblock (coinbase rewards and transaction
fees): Thus, leaders are both able and have incentives to
double-spend on higher-value transactions.

Consequently, although Bitcoin-NG permits higher
transaction throughput, it does not solve Bitcoin’s con-

sistency weaknesses. Nevertheless, Bitcoin-NG’s decou-
pling of keyblocks from microblocks is an important
idea that we build on in Section 3.6 to support high-
throughput and low-latency transactions in ByzCoin.

2.2 Byzantine Fault Tolerance
The Byzantine Generals’ Problem [39, 49] refers to the
situation where the malfunctioning of one or several
components of a distributed system prevents the latter
from reaching an agreement. Pease et al. [49] show that
3 f + 1 participants are necessary to be able to tolerate f
faults and still reach consensus. The Practical Byzantine
Fault Tolerance (PBFT) algorithm [14] was the ﬁrst ef-
ﬁcient solution to the Byzantine Generals’ Problem that
works in weakly synchronous environments such as the
Internet. PBFT offers both safety and liveness provided
that the above bound applies, i.e., that at most f faults
among 3 f +1 participants occur. PBFT triggered a surge
of research on Byzantine replication algorithms with var-
ious optimizations and trade-offs [1, 16, 38, 32].

Every round of PBFT has three distinct phases.

In
the ﬁrst, pre-prepare phase, the current primary node or
leader announces the next record that the system should
agree upon. On receiving this pre-prepare, every node
validates the correctness of the proposal and multicasts
a prepare message to the group. The nodes wait until
they collect a quorum of (2 f + 1) prepare messages and
publish this observation with a commit message. Finally,
they wait for a quorum of (2 f + 1) commit messages to
make sure that enough nodes have recorded the decision.
leader to begin each
round and proceeds if a two-thirds quorum exists; con-
sequently, the leader is an attack target. For this reason
PBFT has a view-change protocol that ensures liveness
in the face of a faulty leader. All nodes monitor the
leader’s actions and if they detect either malicious be-
havior or a lack of progress, initiate a view-change. Each
node independently announces its desire to change lead-
ers and stops validating the leader’s actions. If a quorum
of (2 f + 1) nodes decides that the leader is faulty, then
the next leader in a well-known schedule takes over.

PBFT relies upon a correct

PBFT has its limitations. First, it assumes a ﬁxed,
well-deﬁned group of replicas, thus contradicting Bit-
coin’s basic principle of being decentralized and open
for anyone to participate. Second, each PBFT replica
normally communicates directly with every other replica
during each consensus round, resulting in O(n2) com-
munication complexity: This is acceptable when n is
typically 4 or not much more, but becomes impractical
if n represents hundreds or thousands of Bitcoin nodes.
Third, after submitting a transaction to a PBFT service,
a client must communicate with a super-majority of the
replicas in order to conﬁrm the transaction has been com-

USENIX Association  

25th USENIX Security Symposium  281

3

Authoritative statements: e.g. log records

1 record

2 record

3 record

each statement collectively
signed by both authority
and all or most witnesses

Authority

Witness
Cosigners

Figure 1: CoSi protocol architecture

mitted and to learn its outcome, making secure transac-
tion veriﬁcation unscalable.

2.3 Scalable Collective Signing
CoSi [54] is a protocol for scalable collective signing,
which enables an authority or leader to request that state-
ments be publicly validated and (co-)signed by a decen-
tralized group of witnesses. Each protocol run yields
a collective signature having size and veriﬁcation cost
comparable to an individual signature, but which com-
pactly attests that both the leader and its (perhaps many)
witnesses observed and agreed to sign the statement.

To achieve scalability, CoSi combines Schnorr multi-
signatures [51] with communication trees that are long
used in multicast protocols [13, 21, 55].
Initially, the
protocol assumes that signature veriﬁers know the public
keys of the leader and those of its witnesses, all of which
combine to form a well-known aggregate public key. For
each message to be collectively signed, the leader then
initiates a CoSi four-phase protocol round that require
two round-trips over the communication tree between the
leader and its witnesses:
1. Announcement: The leader broadcasts an announce-
ment of a new round down the communication tree.
The announcement can optionally include the message
M to be signed, otherwise M is sent in phase three.

2. Commitment: Each node picks a random secret
and uses it to compute a Schnorr commitment.
In
a bottom-up process, each node obtains an aggre-
gate Schnorr commitment from its immediate chil-
dren, combines those with its own commitment, and
passes a further-aggregated commitment up the tree.

3. Challenge: The leader computes a collective Schnorr
challenge using a cryptographic hash function and
broadcasts it down the communication tree, along with
the message M to sign, if the latter has not already

been sent in phase one.

4. Response: Using the collective challenge, all nodes
compute an aggregate response in a bottom-up fashion
that mirrors the commitment phase.
The result of this four-phase protocol is the production
of a standard Schnorr signature that requires about 64
bytes, using the Ed25519 elliptic curve [6], and that any-
one can verify against the aggregate public key nearly as
efﬁciently as the veriﬁcation of an individual signature.
Practical caveats apply if some witnesses are ofﬂine dur-
ing the collective signing process: in this case the CoSi
protocol can proceed, but the resulting signature grows
to include metadata veriﬁably documenting which wit-
nesses did and did not co-sign. We refer to the CoSi pa-
per for details [54].

3 ByzCoin Design

This section presents ByzCoin with a step-by-step ap-
proach, starting from a simple “strawman” combination
of PBFT and Bitcoin. From this strawman, we progres-
sively address the challenges of determining consensus
group membership, adapting Bitcoin incentives and min-
ing rewards, making the PBFT protocol scale to large
groups and handling block conﬂicts and selﬁsh mining.

3.1 System Model
ByzCoin is designed for untrustworthy networks that can
arbitrarily delay, drop, re-order or duplicate messages.
To avoid the FLP impossibility [27], we assume the net-
work has a weak synchrony property [14]. The Byz-
Coin system is comprised of a set of N block miners
that can generate key-pairs, but there is no trusted public-
key infrastructure. Each node i has a limited amount of
hash power that corresponds to the maximum number of
block-header hashes the node can perform per second.

At any time t a subset of miners M (t) is controlled by
a malicious attacker and are considered faulty. Byzantine
miners can behave arbitrarily, diverting from the protocol
and colluding to attack the system. The remaining hon-
est miners follow the prescribed protocol. We assume
that the total hash power of all Byzantine nodes is less
than 1
4 of the system’s total hash power at any time, since
proof-of-work-based cryptocurrencies become vulnera-
ble to selﬁsh mining attacks by stronger adversaries [25].

3.2 Strawman Design: PBFTCoin
For simplicity, we begin with PBFTCoin, an unrealisti-
cally simple protocol that naively combines PBFT with
Bitcoin, then gradually reﬁne it into ByzCoin.

For now, we simply assume that a group of n = 3 f + 1
PBFT replicas, which we call trustees, has been ﬁxed and

282  25th USENIX Security Symposium 

USENIX Association

4

globally agreed upon upfront, and that at most f of these
trustees are faulty. As in PBFT, at any given time, one of
these trustees is the leader, who proposes transactions
and drives the consensus process. These trustees col-
lectively maintain a Bitcoin-like blockchain, collecting
transactions from clients and appending them via new
blocks, while guaranteeing that only one blockchain his-
tory ever exists and that it can never be rolled back or
rewritten. Prior work has suggested essentially such a
design [17, 19], though without addressing the scalabil-
ity challenges it creates.

Under

these simplifying assumptions, PBFTCoin
guarantees safety and liveness, as at most f nodes are
faulty and thus the usual BFT security bounds apply.
However, the assumption of a ﬁxed group of trustees
is unrealistic for Bitcoin-like decentralized cryptocurren-
cies that permit open membership. Moreover, as PBFT
trustees authenticate each other via non-transferable
symmetric-key MACs, each trustee must communicate
directly with most other trustees in every round, thus
yielding O(n2) communication complexity.

Subsequent sections address these restrictions, trans-

forming PBFTCoin into ByzCoin in four main steps:
1. We use Bitcoin’s proof-of-work mechanism to deter-
mine consensus groups dynamically while preserving
Bitcoin’s defense against Sybil attacks.

2. We replace MAC-authenticated direct communica-
tion with digital signatures to make authentication
transferable and thereby enabling sparser communica-
tion patterns that can reduce the normal case commu-
nication latency from O(n2) to O(n).

3. We employ scalable collective signing to reduce per-
round communication complexity further to O(logn)
and reduce typical signature veriﬁcation complexity
from O(n) to O(1).

4. We decouple transaction veriﬁcation from leader elec-

tion to achieve a higher transaction throughput.

3.3 Opening the Consensus Group
Removing PBFTCoin’s assumption of a closed consen-
sus group of trustees presents two conﬂicting challenges.
On the one hand, conventional BFT schemes rely on a
well-deﬁned consensus group to guarantee safety and
liveness. On the other hand, Sybil attacks [23] can triv-
ially break any open-membership protocol involving se-
curity thresholds, such as PBFT’s assumption that at
most f out of 3 f + 1 members are honest.

Bitcoin and many of its variations employ a mecha-
nism already suited to this problem: proof-of-work min-
ing. Only miners who have dedicated resources are al-
lowed to become a member of the consensus group. In
reﬁning PBFTCoin, we adapt Bitcoin’s proof-of-work
mining into a proof-of-membership mechanism. This

blockchain

share window of size w

block

share

miner

L

leader

L

trustees

Figure 2: Valid shares for mined blocks in the blockchain
are credited to miners

mechanism maintains the “balance of power” within the
BFT consensus group over a given ﬁxed-size sliding
share window. Each time a miner ﬁnds a new block, it re-
ceives a consensus group share, which proves the miner’s
membership in the group of trustees and moves the share
window one step forward. Old shares beyond the cur-
rent window expire and become useless for purposes of
consensus group membership. Miners holding no more
valid shares in the current window lose their membership
in the consensus group, hence they are no longer allowed
to participate in the decision-making.

At a given moment in time, each miner wields “vot-
ing power” of a number of shares equal to the number
of blocks the miner has successfully mined within the
current window. Assuming collective hash power is rel-
atively stable, this implies that within a window, each
active miner wields a number of shares statistically pro-
portionate to the amount of hash power that the miner
has contributed during this time period.

The size w of the share window is deﬁned by the av-
erage block-mining rate over a given time frame and in-
ﬂuences certain properties such as the resilience of the
protocol to faults. For example, if we assume an average
block-mining rate of 10 minutes and set the duration of
the time frame to one day (or one week), then w = 144
(w = 1008). This mechanism limits the membership of
miners to recently active ones, which prevents the sys-
tem from becoming unavailable due to too many trustees
becoming inactive over time, or from miners aggregat-
ing many shares over an extended period and threatening
the balance in the consensus group. The relationship be-
tween blocks, miners and shares is illustrated in Fig. 2.

Mining Rewards and Transaction Fees. As we can
no longer assume voluntary participation as in PBFT-
Coin’s closed group of trustees, we need an incentive
for nodes to obtain shares in the consensus group and to
remain active. For this purpose, we adopt Bitcoin’s ex-

USENIX Association  

25th USENIX Security Symposium  283

5

isting incentives of mining rewards and transaction fees.
But instead of these rewards all going to the miner of
the most recent block we split a new block’s rewards and
fees across all members of the current consensus group,
in proportion to the number of shares each miner holds.
As a consequence, the more hash power a miner has de-
voted within the current window, hence the more shares
the miner holds, the more revenue the miner receives dur-
ing payouts in the current window. This division of re-
wards also creates incentives for consensus group mem-
bers to remain live and participate, because they receive
their share of the rewards for new blocks only if they con-
tinually participate, in particular contributing to the pre-
pare and commit phases of each BFT consensus round.

3.4 Replacing MACs by Digital Signatures
In our next reﬁnement step towards ByzCoin, we tackle
the scalability challenge resulting from PBFT’s typical
communication complexity of O(n2), where n is the
group size. PBFT’s choice of MAC-authenticated all-
to-all communication was motivated by the desire to
avoid public-key operations on the critical transaction
path. However, the cost for public-key operations has
decreased due to well-optimized asymmetric cryptosys-
tems [6], making those costs less of an issue.

By adopting digital signatures for authentication, we
are able to use sparser and more scalable communica-
tion topologies, thus enabling the current leader to col-
lect and distribute third-party veriﬁable evidence that cer-
tain steps in PBFT have succeeded. This removes the
necessity for all trustees to communicate directly with
each other. With this measure we can either enable the
leader to collect and distribute the digital signatures, or
let nodes communicate in a chain [32], reducing the
normal-case number of messages from O(n2) to O(n).

3.5 Scalable Collective Signing
Even with signatures providing transferable authentica-
tion, the need for the leader to collect and distribute –
and for all nodes to verify – many individual signatures
per round can still present a scalability bottleneck. Dis-
tributing and verifying tens or even a hundred individual
signatures per round might be practical. If we want con-
sensus groups with a thousand or more nodes, however
(e.g., representing all blocks successfully mined in the
past week), it is costly for the leader to distribute 1000
digital signatures and wait for everyone to verify them.
To tackle this challenge, we build on the CoSi proto-
col [54] for collective signing. CoSi does not directly im-
plement consensus or BFT, but it offers a primitive that
the leader in a BFT protocol can use to collect and aggre-
gate prepare and commit messages during PBFT rounds.

We implement a single ByzCoin round by using two
sequential CoSi rounds initiated by the current leader
(i.e., the owner of the current view). The leader’s an-
nouncement of the ﬁrst CoSi round (phase 1 in Sec-
tion 2.3) implements the pre-prepare phase in the stan-
dard PBFT protocol (Section 2.2). The collective sig-
nature resulting from this ﬁrst CoSi round implements
the PBFT protocol’s prepare phase, in which the leader
obtains attestations from a two-thirds super-majority
quorum of consensus group members that the leader’s
proposal
is safe and consistent with all previously-
committed history.

As in PBFT, this prepare phase ensures that a proposal
can be committed consistently, but by itself it is insufﬁ-
cient to ensure that the proposal will be committed. The
leader and/or some number of other members could fail
before a super-majority of nodes learn about the success-
ful prepare phase. The ByzCoin leader therefore initi-
ates a second CoSi round to implement the PBFT proto-
col’s commit phase, in which the leader obtains attesta-
tions from a two-thirds super-majority that all the sign-
ing members witnessed the successful result of the pre-
pare phase and made a positive commitment to remem-
ber the decision. This collective signature, resulting from
this second CoSi round, effectively attests that a two-
thirds super-majority of members not only considers the
leader’s proposal “safe” but promises to remember it, in-
dicating that the leader’s proposal is fully committed.

In cryptocurrency terms, the collective signature re-
sulting from the prepare phase provides a proof-of-
acceptance of a proposed block of transactions. This
block is not yet committed, however, since a Byzantine
leader that does not publish the accepted block could
double-spend by proposing a conﬂicting block in the next
round.
In the second CoSi commit round, the leader
announces the proof-of-acceptance to all members, who
then validate it and collectively sign the block’s hash to
produce a collective commit signature on the block. This
way a Byzantine leader cannot rewrite history or double-
spend, because by counting arguments at least one honest
node would have to sign the commit phase of both histo-
ries, which an honest node by deﬁnition would not do.

The use of CoSi does not affect the fundamental prin-
ciples or semantics of PBFT but improves its scalability
and efﬁciency in two main ways. First, during the com-
mit round where each consensus group member must
verify that a super-majority of members have signed the
prior prepare phase, each participant generally needs to
receive only an O(1)-size rather than O(n)-size message,
and to expend only O(1) rather than O(n) computation
effort by verifying a single collective signature instead
of n individual ones. This beneﬁt directly increases the
scalability and reduces the bandwidth and computation
costs of consensus rounds themselves.

284  25th USENIX Security Symposium 

USENIX Association

6

A second beneﬁt is that after the ﬁnal CoSi commit
round has completed, the ﬁnal resulting collective com-
mit signature serves as a typically O(1)-size proof, which
anyone can verify in O(1) computation time that a given
block – hence any transaction within that block – has
been irreversibly committed. This secondary scalability-
beneﬁt might in practice be more important than the
ﬁrst, because it enables “light clients” who neither mine
blocks nor store the entire blockchain history to verify
quickly and efﬁciently that a transaction has committed,
without requiring active communication with or having
to trust any particular full node.

3.6 Decoupling Transaction Veriﬁcation

from Leader Election

Although ByzCoin so far provides a scalable guarantee
of strong consistency, thus ensuring that clients need to
wait only for the next block rather than the next sev-
eral blocks to verify that a transaction has committed,
the time they still have to wait between blocks can, nev-
ertheless, be signiﬁcant: e.g., up to 10 minutes using
Bitcoin’s difﬁculty tuning scheme. Whereas ByzCoin’s
strong consistency might in principle make it “safe” from
a consistency perspective to increase block mining rate,
doing so could still exacerbate liveness and other per-
formance issues, as in Bitcoin [47]. To enable lower
client-perceived transaction latency, therefore, we build
on the idea of Bitcoin-NG [24] to decouple the functions
of transaction veriﬁcation from block mining for leader
election and consensus group membership.

As in Bitcoin-NG, we use two different kinds of
blocks. The ﬁrst, microblocks or transaction blocks, rep-
resent transactions to be stored and committed. The cur-
rent leader creates a new microblock every few seconds,
depending on the size of the block, and uses the CoSi-
based PBFT protocol above to commit and collectively
sign it. The other type of block, keyblocks, are mined
via proof-of-work as in Bitcoin and serve to elect leaders
and create shares in ByzCoin’s group membership pro-
tocol as discussed earlier in Section 3.3. As in Bitcoin-
NG, this decoupling allows the current leader to pro-
pose and commit many microblocks that contain many
smaller batches of transactions, within one ≈ 10-minute
keyblock mining period. Unlike Bitcoin-NG, in which
a malicious leader could rewrite history or double-spend
within this period until the next keyblock, ByzCoin en-
sures that each microblock is irreversibly committed re-
gardless of the current leader’s behavior.

In Bitcoin-NG one blockchain includes both types of
blocks, which introduces a race condition for miners.
As microblocks are created, the miners have to change
the header of their keyblocks to mine on top of the lat-
est microblock. In ByzCoin, in contrast, the blockchain

1

2

1

2

3

4

5

Keyblock

Microblock

Collective Signature

Figure 3: ByzCoin blockchain: Two parallel chains store
information about the leaders (keyblocks) and the trans-
actions (microblocks)

becomes two separate parallel blockchains, as shown
in Fig. 3. The main blockchain is the keyblock chain,
consisting of all mined blocks. The microblock chain is
a secondary blockchain that depends on the primary to
identify the era in which every microblock belongs to,
i.e., which miners are authoritative to sign it and who is
the leader of the era.

Microblocks. A microblock is a simple block that the
current consensus group produces every few seconds
to represent newly-committed transactions. Each mi-
croblock includes a set of transactions and a collective
signature. Each microblock also includes hashes refer-
ring to the previous microblock and keyblock: the for-
mer to ensure total ordering, and the latter indicating
which consensus group window and leader created the
microblock’s signature. The microblock’s hash is collec-
tively signed by the corresponding consensus group.

Keyblocks. Each keyblock contains a proof-of-work,
which is used to determine consensus group membership
via the sliding-window mechanism discussed earlier, and
to pay signers their rewards. Each newly-mined key-
block deﬁnes a new consensus group, and hence a new
set of public keys with which the next era’s microblocks
will be collectively signed. Since each successive con-
sensus group differs from the last in at most one mem-
ber, PBFT ensures the microblock chain’s consistency
and continuity across this group membership change pro-
vided at most f out of 3 f + 2 members are faulty.

Bitcoin-NG relies on incentives to discourage the next
leader from accidentally or maliciously “forgetting” a
prior leader’s microblocks. In contrast, the honest super-
majority in a ByzCoin consensus group will refuse to
allow a malicious or amnesiac leader to extend any but
the most recently-committed microblock, regardless of
which (current or previous) consensus group committed
it.
Thus, although competing keyblock conﬂicts may
still appear, these “forks” cannot yield an inconsistent
microblock chain.
Instead, a keyblock conﬂict can at

USENIX Association  

25th USENIX Security Symposium  285

7

share window of size w

L

keyblock (co-signed)

microblock (co-signed)

share

miner (co-signer)

L

leader

0

H0

1

H1

n − 2

n − 1

...

Hn−2

null

y
r
t
n
e

h
t
i

t
c
e
l
e
s

Hash

h

i = h mod (n − 1)

Figure 4: Overview of the full ByzCoin design

Figure 5: Deterministic fork resolution in ByzCoin

worst temporarily interrupt the PBFT protocol’s liveness,
until it is resolved as mentioned in Section 3.6.1.

Decoupling transacton veriﬁcation from leader elec-
tion and consensus group evolution in this way brings
the overall ByzCoin architecture to completion, as illus-
trated in Fig. 4. Subsequent sections discuss further im-
plications and challenges this architecture presents.

3.6.1 Keyblock Conﬂicts and Selﬁsh Mining
PBFT’s strong consistency by deﬁnition does not permit
inconsistencies such as forks in the microblock chain.
The way the miners collectively decide how to resolve
keyblock conﬂicts, however, can still allow selﬁsh min-
ing [25] to occur as in Bitcoin. Worse, if the min-
ers decide randomly to follow one of the two blocks,
then keyblock forks might frequently lead to PBFT live-
ness interruptions as discussed above, by splitting min-
ers “too evenly” between competing keyblocks. Another
approach to deciding between competing keyblocks is
to impose a deterministic priority function on their hash
values, such as “smallest hash wins.” Unfortunately, this
practice can encourage selﬁsh mining.

One way to break a tie without helping selﬁsh miners,
is to increase the entropy of the output of the determinis-
tic prioritization function. We implement this idea using
the following algorithm. When a miner detects a key-
block fork, it places all competing blocks’ header hashes
into a sorted array, from low to high hash values. The
array itself is then hashed, and the ﬁnal bit(s) of this hash
determine which keyblock wins the fork.

This solution, shown in Fig. 5, also uses the idea of a
deterministic function applied to the blocks, thus requir-
ing no voting. Its advantage is that the input of the hash
function is partially unknown before the fork occurs, thus
the entropy of the output is high and difﬁcult for an at-
tacker to be able to optimize. Given that the search space
for a possible conﬂict is as big as the search space for
a new block, trying to decide if a block has better than
50% probability of winning the fork is as hard as ﬁnding
a new block.

3.6.2 Leader Election and PBFT View Changes

Decoupling transaction veriﬁcation from the block-
mining process comes at a cost. So far we have as-
sumed, as in PBFT, that the leader remains ﬁxed unless
he fails.
If we keep this assumption, then this leader
gains the power of deciding which transactions are ver-
iﬁed, hence we forfeit the fairness-enforcing beneﬁt of
Bitcoin’s leader election. To resolve this issue, every
time a keyblock is signed, ByzCoin forces a mandatory
PBFT view-change to the keyblock’s miner. This way
the power of verifying transactions in blocks is assigned
to the rightful miner, who has an era of microblock cre-
ation from the moment his keyblock is signed until the
next keyblock is signed.

When a keyblock conﬂict occurs, more than one such
“mandatory” view-change occurs, with the successful
miners trying to convince other participants to adopt their
keyblock and its associated consensus group. For exam-
ple, in a keyblock fork, one of the two competing key-
blocks wins the resolution algorithm described above.
However, if the miner of the “losing” block races to
broadcast its keyblock and more than 33% honest min-
ers have already committed to it before learning about
the competing keyblock, then the “winning” miner is too
late and the system either commits to the ﬁrst block or (in
the worst case) loses liveness temporarily as discussed
above. This occurs because already-committed miners
will not accept a mandatory view-change except to a key-
block that represents their committed state and whose
microblock chain extends all previously-committed mi-
croblocks. Further analysis of how linearizability is pre-
served across view-changes may be found in the original
PBFT paper [14].

3.6.3 Tree Creation in ByzCoin

Once a miner successfully creates a new keyblock, he
needs to form a CoSi communication tree for collec-
tive signing, with himself as the leader.
If all miners
individually acknowledge this keyblock to transition to

286  25th USENIX Security Symposium 

USENIX Association

8

the next view, this coordination normally requires O (N)
messages. To avoid this overhead at the beginning of
each keyblock round, the miners autonomously create
the next round’s tree bottom-up during the previous key-
block round. This can be done in O (1) by using the
blockchain as an array that represents a full tree.

This tree-building process has three useful side-
effects. First, the previous leader is the ﬁrst to get the new
block, hence he stops creating microblocks and wasting
resources by trying to sign them. Second, in the case of
a keyblock conﬂict, potential leaders use the same tree,
and the propagation pattern is the same; this means that
all nodes will learn and decide on the conﬂict quickly.
Finally, in the case of a view change, the new view will
be the last view that worked correctly. So if the leader
of the keyblock i fails, the next leader will again be the
miner of keyblock i− 1.

3.7 Tolerating Churn and Byzantine Faults
In this section we discuss the challenges of fault toler-
ance in ByzCoin, particularly tree failures and maximum
tolerance for Byzantine faults.

3.7.1 Tree Fault Tolerance

In CoSi, there are multiple different mechanisms that al-
low substantial fault-tolerance. Furthermore the strict
membership requirements and the frequent tree changes
of ByzCoin increase the difﬁculty for a malicious at-
tacker with less than around 25% of the total hash power
to compromise the system. A security analysis, however,
must assume that a Byzantine adversary is able to get the
correct nodes of the ByzCoin signing tree so that it can
compromise the liveness of the system by a simple DoS.
To mitigate this risk, we focus on recent Byzantine
fault tolerance results [32], modifying ByzCoin so that
the tree communication pattern is a normal-case perfor-
mance optimization that can withstand most malicious
attacks. But when the liveness of the tree-based ByzCoin
is compromised, the leader can return to non-tree-based
communication until the end of his era.

The leader detects that the tree has failed with the fol-
lowing mechanism: After sending the block to his chil-
dren, the leader starts a timer that expires before the
view-change timer. Then he broadcasts the hash of the
block he proposed and waits. When the nodes receive
this message they check if they have seen the block and
either send an ACK or wait until they see the block and
then send the ACK. The leader collects and counts the
ACKs, to detect if his block is rejected simply because
it never reaches the witnesses. If the timer expires or a
block rejection arrives before he receives two-thirds of
the ACKs, the leader knows that the tree has failed and

reverts to a ﬂat ByzCoin structure before the witnesses
assume that he is faulty.

As we show in Section 4, the ﬂat ByzCoin structure
can still quickly sign keyblocks for the day-long window
(144 witnesses) while maintaining a throughput higher
than Bitcoin currently supports. Flat ByzCoin is more
robust to faults, but increases the communication latency
back to O(n). Furthermore, if all faults (� N
3 � ) are con-
secutive leaders, this can lead back to a worst case O(n2)
communication latency.

3.7.2 Membership Churn and BFT
After a new leader is elected, the system needs to en-
sure that the ﬁrst microblock of the new leader points
to the last microblock of the previous leader. Having
2 f + 1 supporting votes is not enough. This occurs be-
cause there is the possibility than an honest node lost its
membership when the new era started. Now in the worst
case, the system has f Byzantine nodes, f honest nodes
that are up to date, f slow nodes that have a stale view of
the blockchain, and the new leader that might also have
a stale view. This can lead to the leader proposing a new
microblock, ignoring some signed microblocks and get-
ting 2 f + 1 support (stale+Byzantine+his own). For this
reason, the ﬁrst microblock of an era needs 2 f + 2 sup-
porting signatures. If the leader is unable to obtain them,
this means that he needs to synchronize with the system,
i.e., he needs to ﬁnd the latest signed microblock from
the previous roster. He asks all the nodes in his roster,
plus the node that lost its membership, to sign a latest-
checkpoint message containing the hash of the last mi-
croblock. At this point in time, the system has 3 f + 2
(3 f + 1 of the previous roster plus the leader) members
and needs 2 f + 1 honest nodes to verify the checkpoint,
plus an honest leader to accept it (a Byzantine leader will
be the f + 1 fault and compromise liveness). Thus, Byz-
Coin can tolerate f fails in a total of 3 f + 2 nodes.

4 Performance Evaluation

In this section we discuss the evaluation of the ByzCoin
prototype and our experimental setup. The main ques-
tion we want to evaluate is whether ByzCoin is usable in
practice without incurring large overheads. In particular
we focus on consensus latency and transaction through-
put for different parameter combinations.

4.1 Prototype Implementation
We implemented ByzCoin in Go1 and made it pub-
licly available on GitHub.2 ByzCoin’s consensus mecha-

1https://golang.org
2https://github.com/DeDiS/Cothority

USENIX Association  

25th USENIX Security Symposium  287

9

nism is based on the CoSi protocol with Ed25519 signa-
tures [6] and implements both ﬂat- and tree-based collec-
tive signing layouts as described in Section 3. For com-
parison, we also implemented a conventional PBFT con-
sensus algorithm with the same communication patterns
as above and a consensus algorithm that uses individual
signatures and tree-based communication.

To simulate consensus groups of up to 1008 nodes,
we oversubscribed the available 36 physical machines
(see below) and ran up to 28 separate ByzCoin pro-
cesses on each server. Realistic wide-area network con-
ditions are mimicked by imposing a round-trip latency
of 200 ms between any two machines and a link band-
width of 35 Mbps per simulated host. Note that this sim-
ulates only the connections between miners of the con-
sensus group and not the full Bitcoin network. Full nodes
and clients are not part of the consensus process and can
retrieve signed blocks only after consensus is reached.
Since Bitcoin currently is rather centralized and has only
a few dozen mining pools [3], we assume that if/when
decentralization happens, all miners will be able to sup-
port these rather constrained network requirements.

The experimental data to form microblocks was taken
by ByzCoin clients from the actual Bitcoin blockchain.
Both micro- and keyblocks are fully transmitted and col-
lectively signed through the tree and are returned to the
clients upon request together with the proof. Veriﬁ-
cation of block headers is implemented but transaction
veriﬁcation is only emulated to avoid further measure-
ment distortion through oversubscribed servers. A sim-
ilar practice is used in Shadow Bitcoin [45]. We base
our emulation both on measurements [31] of the aver-
age block-veriﬁcation delays (around 200 ms for 500 MB
blocks) and on the claims of Bitcoin developers [8] that
as far as hardware is concerned Bitcoin can easily ver-
ify 4000 TPS. We simulate a linear increase of this delay
proportional to the number of transactions included in the
block. Because of the communication pattern of Byz-
Coin, the transaction-veriﬁcation cost delays only the
leaf nodes. By the time the leaf nodes ﬁnish the block
veriﬁcation and send their vote back to their parents, all
other tree nodes should have already ﬁnished the veriﬁ-
cation and can immediately proceed. For this reason the
primary delay factor is the transmission of the blocks that
needs to be done logN sequential times.

We ran all our experiments on DeterLab [22] using
36 physical machines, each having four Intel E5-2420
v2 CPUs and 24 GB RAM and being arranged in a star-
shaped virtual topology.

4.2 Consensus Latency
The ﬁrst two experiments focus on how microblock com-
mitment latency scales with consensus group size and

Figure 6: Inﬂuence of the consensus group size on the
consensus latency

with number of transactions per block.

4.2.1 Consensus Group Size Comparison

This experiment focuses on the scalability of ByzCoin’s
BFT protocol in terms of the consensus group size. The
number of unique miners participating in a consensus
group is limited by the number of membership shares
in the window (Section 3.3), but can be smaller if some
miners hold multiple shares (i.e., successfully mined sev-
eral blocks) within the same window.

We ran experiments for Bitcoin’s maximum block size
(1 MB) with a variable number of participating hosts.
Every time we increased the number of hosts, we also in-
creased the servers’ bandwidth so that the available band-
width per simulated host remained constant (35 Mbps).
For the PBFT simulation, the 1 MB block was too big
to handle, thus the PBFT line corresponds to a 250 KB
block size.

As Fig. 6 shows,

the simple version of ByzCoin
achieves acceptable latency, as long as the consensus
group size is less than 200. After this point the cost
for the leader to broadcast the block to everyone incurs
large overheads. On the contrary, the tree-based Byz-
Coin scales well, since the same 1 MB block for 1008
nodes suffers signing latency less than the ﬂat approach
for 36 nodes. Adding 28 times more nodes (from 36 to
1008) causes a latency increase close to a factor 2 (from
6.5 to 14 seconds). The basic PBFT implementation is
quite fast for 2 nodes but scales poorly (40 seconds for
100 nodes), whereas the tree-based implementation with
individual signatures performs the same as ByzCoin for
up to 200 hosts. If we aim for the higher security level of
1008 nodes, however, then ByzCoin is 3 times faster.

Fig. 7 shows the performance cost of keyblock sign-

288  25th USENIX Security Symposium 

USENIX Association

10

Figure 7: Keyblock signing latency

Figure 8: Inﬂuence of the block size on the consensus
latency

ing. The ﬂat variant outperforms the tree-based version
when the number of hosts is small since the blocks have
as many transactions as there are hosts and thus are small
themselves. This leads to a fast transmission even in the
ﬂat case and the main overhead comes from the block
propagation latency, which scales with O(logN) in the
tree-based ByzCoin variant.

4.2.2 Block Size Comparison

The next experiment analyzes how different block sizes
affect the scalability of ByzCoin. We used a constant
number of 144 hosts for all implementations. Once
again, PBFT was unable to achieve acceptable latency
with 144 nodes, thus we ran it with 100 nodes only.

Fig. 8 shows the average latency of the consensus
mechanism, determined over 10 blocks when their re-
spective sizes increase. As in the previous section we
see that the ﬂat implementation is acceptable for a 1 MB
block, but when the block increases to 2 MB the latency
quadruples. This outcome is expected as the leader’s
link saturates when he tries to send 2 MB messages to
every participating node.
In contrast ByzCoin scales
well because the leader outsources the transmission of
the blocks to other nodes and contacts only his chil-
dren. The same behavior is observed for the algorithm
that uses individual signatures and tree-based communi-
cation, which shows that the block size has no negative
effect on scalability when a tree is used. Finally, we ﬁnd
that PBFT is fast for small blocks, but the latency rapidly
increases to 40 seconds for 250 KB blocks.

ByzCoin’s signing latency for a 1 MB block is close
to 10 seconds, which should be small enough to make
the need for 0-conﬁrmation transactions almost disap-
pear. Even for a 32 MB block (≈ 66000 transactions) the
delay is much lower (around 90 seconds) than the ≈ 10

Figure 9: Inﬂuence of the consensus group size on the
block signing latency

minutes required by Bitcoin.

Fig. 9 demonstrates the signing latency of various
blocks sizes on tree-based ByzCoin.
Signing one-
transaction blocks takes only 3 seconds even when 1008
miners co-sign it. For bigger blocks, we have included
Bitcoin’s current maximum block size of 1 MB along
with the proposed limits of 2 MB in Bitcoin Classic and
8 MB in Bitcoin Unlimited [2]. As the graph shows,
1 MB and 2 MB blocks scale linearly in number of nodes
at ﬁrst but after 200 nodes, the propagation latency is
higher than the transmission of the block, hence the la-
tency is close to constant. For 8 MB blocks, even with
1008 the signing latency increases only linearly.

USENIX Association  

25th USENIX Security Symposium  289

11

5 Security Analysis

In this section, we conduct a preliminary, informal se-
curity analysis of ByzCoin, and discuss how its consen-
sus mechanism can mitigate or eliminate some known
attacks against Bitcoin.

5.1 Transaction Safety
In the original Bitcoin paper [47], Nakamoto mod-
els Bitcoin’s security against transaction double spend-
ing attacks as in a Gambler’s Ruin Problem. Further-
more, he models the progress an attacker can make as a
Poisson distribution and combines these two models to
reach Eq. (1). This equation calculates the probability of
a successful double spend after z blocks when the adver-
sary controls q computing power.

Figure 10: Throughput of ByzCoin

4.3 Transaction Throughput

P = 1−

z

∑

k=0

λke−λ

k! (cid:31)1−(cid:30) q

p(cid:29)(z−k)(cid:28)

(1)

In this experiment, we investigate the maximum through-
put in terms of transactions per second (TPS) that Byz-
Coin can achieve, and show how Bitcoin could improve
its throughput by adopting a ByzCoin-like deployment
model. We tested ByzCoin versions with consensus
group sizes of 144 and 1008 nodes, respectively. Note
that performance-wise this resembles the worst case sce-
nario since the miner-share ratio is usually not 1:1 as
miners in the consensus group are allowed to hold multi-
ple shares, as described in Section 3.3.

Analyzing Fig. 10 shows that Bitcoin can increase its
overall throughput by more than one order of magnitude
through adoption of a ﬂat ByzCoin-like model, which
separates transaction veriﬁcation and block mining and
deals with forks via strong consistency. Furthermore, the
144 node conﬁguration can achieve close to 1000 TPS,
which is double the throughput of Paypal, and even the
1008-node roster achieves close to 700 TPS. Even when
the tree fails, the system can revert back to 1 MB mi-
croblocks on the ﬂat and more robust variant of ByzCoin
and still have a throughput ten times higher than the cur-
rent maximum throughput of Bitcoin.

In both Figs. 8 and 10, the usual trade-off between
throughput and latency appears. The system can work
with 1–2 MB microblocks when the load is normal and
then has a latency of 10–20 seconds. If an overload oc-
curs, the system adaptively changes the block size to en-
able higher throughput. We note that this is not the case
in the simple ByzCoin where 1 MB microblocks have op-
timal throughput and acceptable latency.

In Figs. 11 and 12 we compare the relative safety
of a transaction over time in Bitcoin3 versus ByzCoin.
Fig. 11 shows that ByzCoin can secure a transaction in
less than a minute, because the collective signature guar-
antees forward security. On the contrary, Bitcoin’s trans-
actions need hours to be considered fully secured from a
double-spending attempt. Fig. 12 illustrates the required
time from transaction creation to the point where a dou-
ble spending attack has less than 0.1% chance of success.
ByzCoin incurs a latency of below one minute to achieve
the above security, which boils down to the time the sys-
tems needs to produce a collectively signed microblock.
Bitcoin on the other hand needs several hours to reach
the same guarantees. Note that this graph does not con-
sider other advanced attacks, such as eclipse attacks [34],
where Bitcoin offers no security for the victim’s transac-
tions.

5.2 Proof-of-Membership Security
The security of ByzCoin’s proof-of-membership mecha-
nism can be modeled as a random sampling problem with
two possible independent outcomes (honest, Byzantine).
The probability of picking a Byzantine node (in the worst
case) is p = 0.25 and the number of tries corresponds to
the share window size w. In this setting, we are inter-
ested in the probability that the system picks less than
c = � w
3 � Byzantine nodes as consensus group members
and hence guarantees safety. To calculate this probabil-
ity, we use the cumulative binomial distribution where
X is the random variable that represents the number of
times we pick a Byzantine node:

3Based on data from https://blockchain.info.

290  25th USENIX Security Symposium 

USENIX Association

12

available shares and not necessarily the number of ac-
tual miners as each member of the consensus group is
allowed to hold multiple shares. This means that the
number of available shares gives an upper bound on the
latency of the consensus mechanism with the worst case
being that each member holds exactly one share.

In order to choose a value for w appropriately one
must take into account not only consensus latency and
the desired security level (ideally ≥ 99%) but also the in-
creased chance for resource churn when values of w be-
come large. From a security perspective the results of Ta-
ble 1 suggest that the share window size should not be set
to values lower than w = 144. Ideally, values of w = 288
and above should be chosen to obtain a reasonable secu-
rity margin and, as demonstrated in Section 4, values up
to w = 1008 provide excellent performance numbers.

Finally, care should be taken when bootstrapping the
protocol, as for small values of w there is a high proba-
bility that a malicious adversary is able to take over con-
trol. For this reason we suggest that ByzCoin starts with
vanilla Nakamoto consensus and only after w keyblocks
are mined the ByzCoin consensus is activated.

5.3 Defense Against Bitcoin Attacks
0-conﬁrmation Double-Spend Attacks. Race [35]
and Finney [26] attacks belong to the family of 0-
conﬁrmation double-spend attacks which might affect
traders that provide real-time services to their clients. In
such scenarios the time between exchange of currency
and goods is usually short because traders often cannot
afford to wait an extended period of time (10 or more
minutes) until a transaction they received can be consid-
ered indeed conﬁrmed.

ByzCoin can mitigate both attacks by putting the mer-
chant’s transaction in a collectively signed microblock
whose veriﬁcation latency is in the order of a few sec-
onds up to a minute. If this latency is also unacceptable,
then he can send a single transaction for signing, which
will cost more, but is secured in less than 4 seconds.

N-conﬁrmation Double-Spend Attacks. The
as-
sumption underlying this family of attacks [7] is that,
after receiving a transaction for a trade, a merchant
waits N − 1 additional blocks until he concludes the
interaction with his client. At this point, a malicious
client creates a new double-spending transaction and
tries to fork the blockchain, which has a non-negligible
success-probability if the adversary has enough hash
power.
if N = 3 then an adversary
holding 10% of the network’s hash power has a 5%
success-chance to mount the above attack [47].

For example,

In ByzCoin the merchant would simply check the
collective signature of the microblock that includes the

Figure 11: Successful double-spending attack probabil-
ity

Figure 12: Client-perceived secure transaction latency

P [X ≤ c] =

c

k=0(cid:31)w
∑

k(cid:30)pk (1− p)w−k

(2)

Table 1 displays the results for the evaluation of Eq. (2)
for various window sizes w both in the common threat
model where an adversary controls up to 25% hash
power and in the situation where the system faces a
stronger adversary with up to 30% computing power.
The latter might temporarily occur due to hash power
variations and resource churn.

Table 1: Expected proof-of-membership security levels
2016
p | w
0.25
1.000
0.999
0.30

12
0.842
0.723

1008
0.999
0.989

288
0.999
0.902

100
0.972
0.779

144
0.990
0.832

At this point, recall that w speciﬁes the number of

13

USENIX Association  

25th USENIX Security Symposium  291

transaction, which allows him to verify that it was ac-
cepted by a super-majority of the network. Afterwards
the attacker cannot succeed in forking the blockchain as
the rest of the signers will not accept his new block. Even
if the attacker is the leader, the proposed microblock will
be rejected, and a view change will occur.

Eclipse and Delivery-Tampering Attacks.
In an
eclipse attack [34] it is assumed that an adversary con-
trols a sufﬁciently large number of connections between
the victim and the Bitcoin network. This enables the at-
tacker to mount attacks such as 0- and N-conﬁrmation
double-spends with an ever increasing chance of suc-
cess the longer the adversary manages to keep his control
over the network. Delivery-tampering attacks [31] ex-
ploit Bitcoin’s scalability measures to delay propagation
of blocks without causing a network partition. This al-
lows an adversary to control information that the victim
receives and simpliﬁes to mount 0- and 1-conﬁrmation
double-spend attacks as well as selﬁsh-mining.

While ByzCoin does not prevent an attacker from
eclipsing a victim or delaying messages in the peer-to-
peer network, its use of collective signatures in transac-
tion commitment ensure that a victim cannot be tricked
into accepting an alternate attacker-controlled transac-
tion history produced in a partitioned network fragment.

Selﬁsh and Stubborn Mining Attacks. Selﬁsh min-
ing [25] allows a miner to increase his proﬁt by adding
newly mined blocks to a hidden blockchain instead of in-
stantly broadcasting them. This effect can be further am-
pliﬁed if the malicious miner has good connectivity to the
Bitcoin network. The authors of selﬁsh mining propose
a countermeasure that thwarts the attack if a miner has
less than 25% hash power under normal circumstances or
less than 33% in case of an optimal network. Stubborn
mining [48] further generalizes the ideas behind selﬁsh
mining and combines it with eclipse attacks in order to
increase the adversary’s revenue.

In ByzCoin, these strategies are ineffective as forks are
instantly resolved in a deterministic manner, hence build-
ing a hidden blockchain only wastes resources and min-
imizes revenue. Another approach to prevent the above
attacks would be to include bias-resistant public random-
ness [40] in every keyblock. This way even if an attacker
gains control over the consensus mechanism (e.g., by
having > 33% hash power) he would still be unable to
mine hidden blocks. We leave exploring this approach
for future research.

Transaction Censorship.
In Bitcoin-NG, a malicious
leader can censor transactions for the duration of his
epoch(s). The same applies for ByzCoin. However, as

not every leader is malicious, the censored transactions
are only delayed and will be processed eventually by the
next honest leader. ByzCoin can improve on this, as the
leader’s actions are double-checked by all the other min-
ers in the consensus group. A client can announce his
censored transaction just like in classic PBFT; this will
indicate a potential leader fault and will either stop cen-
sorship efforts or lead to a view-change to remove the
malicious leader. Finally, in Bitcoin(-NG) a miner can
announce his intention to fork over a block that includes
a transaction, giving an incentive to other miners to ex-
clude this transaction. In ByzCoin using fork-based at-
tacks to censor transactions is no longer possible due to
ByzCoin’s deterministic fork resolution mechanism. An
attacker can therefore only vote down a leader’s propos-
als by refusing to co-sign. This is also a limitation, how-
ever, as an adversary who controls more than 33% of the
shares (Section 7) deny service and can censor transac-
tions for as long as he wants.

6 Related Work

ByzCoin and Bitcoin [47] share the same primary ob-
jective:
implement a state machine replication (SMR)
system with open membership [9, 29]. Both therefore
differ from more classic approaches to Byzantine fault-
tolerant SMRs with static or slowly changing consensus
groups such as PBFT [14], Tendermint [10], or Hyper-
ledger [42].

Bitcoin has well-known performance shortcomings;
there are several proposals [41, 57] on how to address
these. The GHOST protocol [53] changes the chain se-
lection rule when a fork occurs. While Bitcoin declares
the fork with the most proof-of-work as the new valid
chain, GHOST instead chooses the entire subtree that
received the most computational effort. Put differently,
the subtree that was considered correct for the longest
time will have a high possibility of being selected, mak-
ing an intentional fork much harder. One limitation of
GHOST is that no node will know the full tree, as in-
valid blocks are not propagated. While all blocks could
be propagated, this makes the system vulnerable to DoS
attacks since an adversary can simply ﬂood the network
with low-difﬁculty blocks.

Off-chain transactions, an idea that originated from the
two-point channel protocol [33], are another alternative
to improve latency and throughput of the Bitcoin net-
work. Other similar proposals include the Bitcoin Light-
ning Network [50] and micro-payment channels [20],
which allow transactions without a trusted middleman.
They use contracts so that any party can generate proof-
of-fraud on the main blockchain and thereby deny rev-
enue to an attacker. Although these systems enable faster
cryptocurrencies, they do not address the core problem

292  25th USENIX Security Symposium 

USENIX Association

14

of scaling SMR systems, thus sacriﬁcing the open and
distributed nature of Bitcoin. Finally, the idea behind
sidechains [5] is to connect multiple chains with each
other and enable the transfer of Bitcoins from one chain
to another. This enables the workload distribution to
multiple subsets of nodes that run the same protocol.

There are several proposals that, like ByzCoin, tar-
get the consensus mechanism and try to improve differ-
ent aspects. Ripple [52] implements and runs a variant
of PBFT that is low-latency and based on collectively-
trusted subnetworks with slow membership changes.
The degree of decentralization depends on the concrete
conﬁguration of an instance. Tendermint [10] also im-
plements a PBFT-like algorithm, but evaluates it with at
most 64 “validators”. Furthermore, Tendermint does not
address important challenges such as the link-bandwidth
between validators, which we found to be a primary bot-
tleneck. PeerCensus [19] is an interesting alternative that
shares similarities with ByzCoin, but is only a prelimi-
nary theoretical analysis.

Finally, Stellar [43] proposes a novel consensus proto-
col named Federated Byzantine Agreement, which intro-
duces Quorum slices that enable a BFT protocol “open
for anyone to participate”. Its security, however, depends
on a nontrivial and unfamiliar trust model requiring cor-
rect conﬁguration of trustees by each client.

7 Limitations and Future Work

This section brieﬂy outlines several of ByzCoin’s impor-
tant remaining limitations, and areas for future work.

Consensus-Group Exclusion. A malicious ByzCoin
leader can potentially exclude nodes from the consen-
sus process. This is easier in the ﬂat variant, where
the leader is responsible for contacting every participat-
ing miner, but it is also possible in the tree-based ver-
sion, if the leader “reorganizes” the tree and puts nodes
targeted for exclusion in subtrees where the roots are
colluding nodes. A malicious leader faces a dilemma,
though: excluded nodes lose their share of newly minted
coins which increases the overall value per coin and thus
the leader’s reward. The victims, however, will quickly
broadcast view-change messages in an attempt to remove
the Byzantine leader.

As an additional countermeasure to mitigate such an
attack, miners could run a peer-to-peer network on top of
the tree to communicate protocol details. Thus each node
potentially receives information from multiple sources.
If the parent of a node fails to deliver the announcement
message of a new round, this node could then choose
to attach itself (together with its entire subtree) to an-
other participating (honest) miner. This self-adapting

tree could mitigate the leader’s effort to exclude miners.
As a last resort, the malicious leader could exclude the
commitments of the victims from the aggregate commit-
ment, but as parts of the tree have witnessed these com-
mitments, the risk of triggering a view-change is high.

In summary, the above attack seems irrational as the
drawbacks of trying to exclude miners seem to outweigh
the beneﬁts. We leave a more thorough analysis of this
situation for future work.

Defenses Against 33%+ Attacks. An attacker pow-
erful enough to control more than 1
3 of the consensus
shares can, in the Byzantine threat model, trivially censor
transactions by withholding votes, and double-spend by
splitting honest nodes in two disjoint groups and collect-
ing enough signatures for two conﬂicting microblocks.
Fig. 12 shows how the safety of ByzCoin fails at 30%,
whereas Bitcoin remains safe even for 48%, if a client
can wait long enough.

However, the assumption that an attacker completely
controls the network is rather unrealistic, especially if
messages are authenticated and spooﬁng is impossi-
ble [3]. The existence of the peer-to-peer network on
top of the tree, mentioned in the previous paragraph, en-
ables the detection of equivocation attacks such as mi-
croblock forks and mitigates the double-spending efforts,
as honest nodes will stop following the leader. Thus,
double-spending and history rewriting attacks in Byz-
Coin become trivial only after the attacker has 66% of
the shares, effectively increasing the threshold from 51%
to 66%. This assumption is realistic, as an attacker con-
trolling the complete network can actually split Bitcoin’s
network in two halves and trivially double-spend on the
weaker side. This is possible because the weak side cre-
ates blocks that will be orphaned once the partition heals.
We again leave a more thorough analysis of this situation
for future work.

Proof-of-Work Alternatives. Bitcoin’s hash-based
proof-of-work has many drawbacks, such as energy
waste and the efﬁciency advantages of custom ASICs
that have made mining by “normal users” impracti-
cal. Many promising alternatives are available, such
as memory-intensive puzzles [4], or proof-of-stake de-
signs [37]. Consensus group membership might in prin-
ciple also be based on other Sybil attack-resistant meth-
ods, such as those based on social trust networks [58].
A more democratic alternative might be to apportion
mining power on a “1 person, 1 vote” principle, based
on anonymous proof-of-personhood tokens distributed at
pseudonym parties [28]. Regardless, we treat the ideal
choice of Sybil attack-resistance mechanism as an issue
for future work, orthogonal to the focus of this paper.

USENIX Association  

25th USENIX Security Symposium  293

15

Other Directions. Besides the issues outlined above,
there are many more interesting open questions worth
considering: Sharding [17] presents a promising ap-
proach to scale distributed protocols and was already
studied for private blockchains [18]. A sharded variant of
ByzCoin might thus achieve even better scalability and
performance numbers. A key obstacle that needs to be
analyzed in that context before though is the generation
of bias-resistant public randomness [40] which would
enable to pick members of a shard in a distributed and se-
cure manner. Yet another challenge is to ﬁnd ways to in-
crease incentives of rational miners to remain honest, like
binding coins and destroying them when misbehavior is
detected [10]. Finally, asynchronous BFT [12, 11] is an-
other interesting class of protocols, which only recently
started to be analyzed in the context of blockchains [46].

8 Conclusion

ByzCoin is a scalable Byzantine fault tolerant consen-
sus algorithm for open decentralized blockchain systems
such as Bitcoin. ByzCoin’s strong consistency increases
Bitcoin’s core security guarantees—shielding against at-
tacks on the consensus and mining system such as
N-conﬁrmation double-spending, intentional blockchain
forks, and selﬁsh mining—and also enables high scal-
ability and low transaction latency. ByzCoin’s applica-
tion to Bitcoin is just one example, though:
theoreti-
cally, it can be deployed to any blockchain-based system,
and the proof-of-work-based leader election mechanism
might be changed to another approach such as proof-
of-stake.
If open membership is not an objective, the
consensus group could be static, though still potentially
large. We developed a wide-scale prototype implemen-
tation of ByzCoin, validated its efﬁciency with measure-
ments and experiments, and have shown that Bitcoin can
increase the capacity of transactions it handles by more
than two orders of magnitude.

Acknowledgments

We would like to thank the DeterLab project team for
providing the infrastructure for our experimental evalu-
ation, Joseph Bonneau for his input on our preliminary
design, and the anonymous reviewers for their helpful
feedback.

References

[1] ABD-EL-MALEK, M., GANGER, G. R., GOOD-
SON, G. R., REITER, M. K., AND WYLIE, J. J.
Fault-scalable Byzantine Fault-tolerant Services.

SIGOPS Operating Systems Review 39, 5 (Oct.
2005), 59–74.

[2] ANDRESEN, G. Classic? Unlimited? XT? Core?,

Jan. 2016.

[3] APOSTOLAKI, M., ZOHAR, A., AND VAN-
BEVER, L. Hijacking Bitcoin: Large-scale Net-
work Attacks on Cryptocurrencies. arXiv preprint
arXiv:1605.07524 (2016).

[4] ATENIESE, G., BONACINA, I., FAONIO, A., AND
GALESI, N. Proofs of Space: When Space is of
the Essence. In Security and Cryptography for Net-
works. Springer, 2014, pp. 538–557.

[5] BACK, A., CORALLO, M., DASHJR, L.,
FRIEDENBACH, M., MAXWELL, G., MILLER,
A., POELSTRA, A., TIM ´ON, J., AND WUILLE,
P. Enabling Blockchain Innovations with Pegged
Sidechains.

[6] BERNSTEIN, D. J., DUIF, N., LANGE, T.,
SCHWABE, P., AND YANG, B.-Y. High-speed
high-security signatures. Journal of Cryptographic
Engineering 2, 2 (2012), 77–89.

[7] BITCOIN WIKI. Conﬁrmation, 2016.

[8] BITCOIN WIKI. Scalability, 2016.

[9] BONNEAU,

J., MILLER, A., CLARK,

J.,
NARAYANAN, A., KROLL, J., AND FELTEN,
E. W. Research Perspectives and Challenges for
Bitcoin and Cryptocurrencies. In 2015 IEEE Sym-
posium on Security and Privacy. IEEE (2015).

[10] BUCHMAN, E. Tendermint: Byzantine Fault Tol-

erance in the Age of Blockchains, 2016.

[11] CACHIN, C., KURSAWE, K., PETZOLD, F., AND
SHOUP, V. Secure and Efﬁcient Asynchronous
Broadcast Protocols.
In Advances in Cryptology
(CRYPTO) (Aug. 2001).

[12] CACHIN, C., KURSAWE, K., AND SHOUP, V.
Random Oracles in Constantinople: Practical asyn-
chronous Byzantine agreement using cryptography.
In 19th ACM Symposium on Principles of Dis-
tributed Computing (PODC) (July 2000).

[13] CASTRO, M., DRUSCHEL, P., KERMARREC, A.-
M., NANDI, A., ROWSTRON, A., AND SINGH, A.
SplitStream: high-bandwidth multicast in coopera-
tive environments. In ACM Symposium on Operat-
ing Systems Principles (SOSP) (2003).

294  25th USENIX Security Symposium 

USENIX Association

16

[14] CASTRO, M., AND LISKOV, B. Practical Byzan-
tine Fault Tolerance.
In 3rd USENIX Symposium
on Operating Systems Design and Implementation
(OSDI) (Feb. 1999).

[15] CLEMENT, A., WONG, E. L., ALVISI, L.,
DAHLIN, M., AND MARCHETTI, M. Making
Byzantine Fault Tolerant Systems Tolerate Byzan-
tine Faults.
In 6th USENIX Symposium on Net-
worked Systems Design and Implementation (Apr.
2009).

[16] COWLING, J., MYERS, D., LISKOV, B., RO-
DRIGUES, R., AND SHRIRA, L. HQ Replication:
A Hybrid Quorum Protocol for Byzantine Fault
Tolerance. In 7th Symposium on Operating Systems
Design and Implementation (Berkeley, CA, USA,
2006), OSDI ’06, USENIX Association, pp. 177–
190.

[17] CROMAN, K., DECKE, C., EYAL, I., GENCER,
A. E., JUELS, A., KOSBA, A., MILLER, A.,
SAXENA, P., SHI, E., SIRER, E. G., AN, D. S.,
AND WATTENHOFER, R. On Scaling Decentral-
ized Blockchains (A Position Paper). In 3rd Work-
shop on Bitcoin and Blockchain Research (2016).

[18] DANEZIS, G., AND MEIKLEJOHN, S. Centrally

Banked Cryptocurrencies.

[19] DECKER, C., SEIDEL, J., AND WATTENHOFER,
In 17th
R. Bitcoin Meets Strong Consistency.
International Conference on Distributed Comput-
ing and Networking (ICDCN), Singapore (January
2016).

[20] DECKER, C., AND WATTENHOFER, R. A Fast and
Scalable Payment Network with Bitcoin Duplex
Micropayment Channels.
In Stabilization, Safety,
and Security of Distributed Systems. Springer, Aug.
2015, pp. 3–18.

[21] DEERING, S. E., AND CHERITON, D. R. Mul-
ticast Routing in Datagram Internetworks and Ex-
tended LANs. ACM Transactions on Computer
Systems 8, 2 (May 1990).

[22] DeterLab Network Security Testbed, September

2012.

[23] DOUCEUR, J. R. The Sybil Attack. In 1st Interna-
tional Workshop on Peer-to-Peer Systems (IPTPS)
(Mar. 2002).

(NSDI 16) (Santa Clara, CA, Mar. 2016), USENIX
Association.

[25] EYAL, I., AND SIRER, E. G. Majority is not
enough: Bitcoin mining is vulnerable. In Financial
Cryptography and Data Security. Springer, 2014,
pp. 436–454.

[26] FINNEY, H. Best practice for fast transaction ac-
ceptance – how high is the risk?, Feb. 2011. Bitcoin
Forum comment.

[27] FISCHER, M. J., LYNCH, N. A., AND PATERSON,
M. S. Impossibility of distributed consensus with
one faulty process. Journal of the ACM (JACM) 32,
2 (1985), 374–382.

[28] FORD, B., AND STRAUSS, J. An ofﬂine founda-
tion for online accountable pseudonyms. In 1st In-
ternational Workshop on Social Network Systems
(SocialNets) (2008).

[29] GARAY, J., KIAYIAS, A., AND LEONARDOS, N.
The Bitcoin backbone protocol: Analysis and ap-
plications. In EUROCRYPT 2015. Springer, 2015,
pp. 281–310.

[30] GERVAIS, A., KARAME, G. O., WUST, K.,
GLYKANTZIS, V., RITZDORF, H., AND CAPKUN,
S. On the Security and Performance of Proof of
Work Blockchains. Tech. rep., IACR: Cryptology
ePrint Archive, 2016.

[31] GERVAIS, A., RITZDORF, H., KARAME, G. O.,
AND CAPKUN, S. Tampering with the Delivery of
Blocks and Transactions in Bitcoin. In 22nd ACM
SIGSAC Conference on Computer and Communi-
cations Security (2015), ACM, pp. 692–705.

[32] GUERRAOUI, R., KNE ˇZEVI ´C, N., QU ´EMA, V.,
AND VUKOLI ´C, M. The next 700 BFT protocols.
In 5th European conference on Computer systems
(2010), ACM, pp. 363–376.

[33] HEARN, M., AND SPILMAN, J. Rapidly-adjusted
(micro)payments to a pre-determined party, 2015.

[34] HEILMAN, E., KENDLER, A., ZOHAR, A., AND
GOLDBERG, S. Eclipse Attacks on Bitcoin’s Peer-
to-Peer Network. In 24th USENIX Security Sympo-
sium (2015), pp. 129–144.

[24] EYAL, I., GENCER, A. E., SIRER, E. G., AND
VAN RENESSE, R.
Bitcoin-NG: A Scalable
Blockchain Protocol. In 13th USENIX Symposium
on Networked Systems Design and Implementation

[35] KARAME, G. O., ANDROULAKI, E., AND CAP-
KUN, S. Double-spending fast payments in Bitcoin.
In 19th ACM Conference on Computer and commu-
nications security (2012), ACM, pp. 906–917.

USENIX Association  

25th USENIX Security Symposium  295

17

[36] KIAYIAS, A., AND PANAGIOTAKOS, G. Speed-
Security Tradeoffs in Blockchain Protocols. Tech.
rep., IACR: Cryptology ePrint Archive, 2015.

[50] POON, J., AND DRYJA, T. The Bitcoin Lightning
Network: Scalable Off-Chain Instant Payments,
Jan. 2016.

[51] SCHNORR, C. P. Efﬁcient signature generation by
smart cards. Journal of Cryptology 4, 3 (1991),
161–174.

[52] SCHWARTZ, D., YOUNGS, N., AND BRITTO, A.
The Ripple protocol consensus algorithm. Ripple
Labs Inc White Paper (2014), 5.

[53] SOMPOLINSKY, Y., AND ZOHAR, A. Accelerat-
ing Bitcoin’s Transaction Processing. Fast Money
Grows on Trees, Not Chains, Dec. 2013.

[54] SYTA, E., TAMAS, I., VISHER, D., WOLINSKY,
D. I., L., GAILLY, N., KHOFFI, I., AND FORD, B.
Keeping Authorities “Honest or Bust” with Decen-
tralized Witness Cosigning. In 37th IEEE Sympo-
sium on Security and Privacy (May 2016).

[55] VENKATARAMAN, V., YOSHIDA, K., AND FRAN-
CIS, P. Chunkyspread: Heterogeneous Unstruc-
tured Tree-Based Peer-to-Peer Multicast.
In 14th
International Conference on Network Protocols
(ICNP) (Nov. 2006).

[56] VUKOLI ´C, M. The quest for scalable blockchain
fabric: Proof-of-work vs. BFT replication. In Inter-
national Workshop on Open Problems in Network
Security (2015), Springer, pp. 112–125.

[57] WOOD, G. Ethereum: A secure decentralised gen-
eralised transaction ledger. Ethereum Project Yel-
low Paper (2014).

[58] YU, H., GIBBONS, P. B., KAMINSKY, M., AND
XIAO, F. SybilLimit: A Near-Optimal Social Net-
work Defense against Sybil Attacks. In 29th IEEE
Symposium on Security and Privacy (S&P) (May
2008).

[37] KING, S., AND NADAL, S. PPCoin: Peer-to-peer

Crypto-Currency with Proof-of-Stake.

[38] KOTLA, R., ALVISI, L., DAHLIN, M., CLEMENT,
A., AND WONG, E. Zyzzyva: Speculative Byzan-
tine Fault Tolerance.
In 21st ACM SIGOPS Sym-
posium on Operating Systems Principles (SOSP)
(Oct. 2007), ACM.

[39] LAMPORT, L., SHOSTAK, R., AND PEASE, M.
The Byzantine Generals Problem.
ACM Trans-
actions on Programming Languages and Systems
(TOPLAS) 4, 3 (1982), 382–401.

[40] LENSTRA, A. K., AND WESOLOWSKI, B. A ran-
IACR eprint

dom zoo: sloth, unicorn, and trx.
archive, Apr. 2015.

[41] LEWENBERG, Y., SOMPOLINSKY, Y., AND ZO-
HAR, A. Inclusive Block Chain Protocols. In Fi-
nancial Cryptography and Data Security. Springer,
Jan. 2015, pp. 528–547.

[42] LINUX FOUNDATION. Hyperledger Project, 2016.

[43] MAZI `ERES, D. The Stellar Consensus Protocol: A

Federated Model for Internet-level Consensus.

[44] MERKLE, R. C. Secrecy, Authentication, and Pub-
lic Key Systems. PhD thesis, Stanford University,
June 1979.

[45] MILLER, A., AND JANSEN, R. Shadow-Bitcoin:
scalable simulation via direct execution of multi-
threaded applications.
In 8th Workshop on Cy-
ber Security Experimentation and Test (CSET 15)
(2015).

[46] MILLER, A., XIA, Y., CROMAN, K., SHI, E.,
AND SONG, D. The honey badger of BFT pro-
tocols.
Tech. rep., Cryptology ePrint Archive
2016/199, 2016.

[47] NAKAMOTO, S. Bitcoin: A Peer-to-Peer Elec-

tronic Cash System, 2008.

[48] NAYAK, K., KUMAR, S., MILLER, A., AND SHI,
E. Stubborn Mining: Generalizing Selﬁsh Min-
ing and Combining with an Eclipse Attack. In 1st
IEEE European Symposium on Security and Pri-
vacy (Mar. 2015).

[49] PEASE, M., SHOSTAK, R., AND LAMPORT, L.
Reaching agreement in the presence of faults. Jour-
nal of the ACM (JACM) 27, 2 (1980), 228–234.

296  25th USENIX Security Symposium 

USENIX Association

18

