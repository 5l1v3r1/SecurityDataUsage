A Cryptographic Analysis of the

TLS 1.3 Handshake Protocol Candidates

Benjamin Dowling

Electrical Engineering and Computer Science

Queensland University of Technology

Brisbane, Australia

b1.dowling@qut.edu.au

Marc Fischlin
Cryptoplexity

Technische Universität Darmstadt

Darmstadt, Germany

marc.ﬁschlin@cryptoplexity.de

Felix Günther
Cryptoplexity

Technische Universität Darmstadt

Darmstadt, Germany

guenther@cs.tu-darmstadt.de

Electrical Engineering and Computer Science

Mathematical Sciences

Queensland University of Technology

Douglas Stebila

Brisbane, Australia

stebila@qut.edu.au

ABSTRACT
The Internet Engineering Task Force (IETF) is currently
developing the next version of the Transport Layer Secu-
rity (TLS) protocol, version 1.3. The transparency of this
standardization process allows comprehensive cryptographic
analysis of the protocols prior to adoption, whereas previ-
ous TLS versions have been scrutinized in the cryptographic
literature only after standardization. This is even more im-
portant as there are two related, yet slightly diﬀerent, can-
didates in discussion for TLS 1.3, called draft-ietf-tls-
tls13-05 and draft-ietf-tls-tls13-dh-based.

We give a cryptographic analysis of the primary ephemeral
Diﬃe–Hellman-based handshake protocol, which authenti-
cates parties and establishes encryption keys, of both TLS
1.3 candidates. We show that both candidate handshakes
achieve the main goal of providing secure authenticated key
exchange according to an augmented multi-stage version of
the Bellare–Rogaway model. Such a multi-stage approach
is convenient for analyzing the design of the candidates, as
they establish multiple session keys during the exchange.

An important step in our analysis is to consider composi-
tional security guarantees. We show that, since our multi-
stage key exchange security notion is composable with ar-
bitrary symmetric-key protocols, the use of session keys in
the record layer protocol is safe. Moreover, since we can
view the abbreviated TLS resumption procedure also as a
symmetric-key protocol, our compositional analysis allows
us to directly conclude security of the combined handshake
with session resumption.

We include a discussion on several design characteristics of
the TLS 1.3 drafts based on the observations in our analysis.

Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for proﬁt or commercial advantage and that copies bear this notice and the full citation
on the ﬁrst page. Copyrights for components of this work owned by others than the
author(s) must be honored. Abstracting with credit is permitted. To copy otherwise, or
republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission
and/or a fee. Request permissions from Permissions@acm.org.
CCS’15, October 12–16, 2015, Denver, Colorado, USA.
Copyright is held by the owner/author(s). Publication rights licensed to ACM.
ACM 978-1-4503-3832-5/15/10 ...$15.00.
DOI: http://dx.doi.org/10.1145/2810103.2813653.

Categories and Subject Descriptors
C.2.0 [Computer–Communication Networks]: General—
Security and protection

Keywords
Transport Layer Security (TLS); key exchange; protocol anal-
ysis; composition

1.

INTRODUCTION

The Transport Layer Security (TLS) protocol is one of
the most widely deployed cryptographic protocols in prac-
tice, protecting numerous web and e-mail accesses every day.
The TLS handshake protocol allows a client and a server to
authenticate each other and to establish a key, and the sub-
sequent record layer protocol provides conﬁdentiality and in-
tegrity for communication of application data. Despite its
large-scale deployment, or perhaps because of it, we have
witnessed frequent successful attacks against TLS. In the
past few years alone, there have been many practical at-
tacks that have received signiﬁcant attention, either exploit-
ing weaknesses in underlying cryptographic primitives (such
as weaknesses in RC4 [2]), errors in the design of the TLS
protocol (BEAST [16], the Lucky 13 attack [3], the triple
handshake attack [8], the POODLE attack [24], the Log-
jam attack [1]), or ﬂaws in implementations (the Heartbleed
attack [14], state machine attacks (SMACK [7])). Some of
these attacks apply only to earlier versions of the TLS proto-
col, but for legacy reasons many parties still support versions
older than the latest one, TLS 1.2.

Partly due to the above security problems with the exist-
ing versions of TLS, but also because of additional desirable
privacy features and functional properties such as low hand-
shake latency, the Internet Engineering Task Force (IETF) is
currently drafting a new TLS 1.3 standard. As of May 2015,
there were two (slightly diﬀerent) candidates in discussion:
one is draft-ietf-tls-tls13-05 [25] (which we shorten
to draft-05), the other one is the forked draft-ietf-tls-
tls13-dh-based [27] (which we shorten to draft-dh), incor-
porating a diﬀerent key schedule based on ideas by Krawczyk

1197and Wee.1 In this work, we provide a comprehensive cryp-
tographic evaluation of the primary Diﬃe–Hellman-based
handshake of both drafts.2 We believe that it is important
that cryptographic evaluation take place before standardiza-
tion. This contrasts with the history of TLS and its prede-
cessor the Secure Sockets Layer (SSL) protocol: SSL 3 was
standardized in 1996, TLS 1.0 in 1999, TLS 1.1 in 2006, and
TLS 1.2 in 2008, but the ﬁrst comprehensive cryptographic
proof of any complete TLS ciphersuite did not appear until
2012 [19].

The protocol design in both TLS 1.3 drafts includes sev-
eral cryptographic changes that are substantially diﬀerent
from TLS 1.2, including: (1) encrypting some handshake
messages with an intermediate session key, to provide conﬁ-
dentiality of handshake data such as the client certiﬁcate; (2)
signing the entire handshake transcript for authentication;
(3) including hashes of handshake messages in a variety of
key calculations; (4) encrypting the ﬁnal Finished messages
in the handshake with a diﬀerent key than is used for en-
crypting application data; (5) deprecating a variety of cryp-
tographic algorithms (including RSA key transport, ﬁnite-
ﬁeld Diﬃe–Hellman key exchange, SHA-1, RC4, CBC mode,
MAC-then-encode-then-encrypt); (6) using modern authen-
ticated encryption with associated data (AEAD) schemes for
symmetric encryption; and (7) providing handshakes with
fewer message ﬂows to reduce latency.

These changes are meant in part to address several of the
aforementioned attacks. While some of those attacks are
implementation-speciﬁc and escape abstract cryptographic
evaluation, assessing the cryptographic security of the design
of TLS 1.33 can provide assurance that the protocol design
does not display any unexpected cryptographic weaknesses.
Our goal is a comprehensive assessment of the security of
the handshake protocol in draft-05 and draft-dh. We focus
solely on the handshake protocol as a key exchange protocol;
these drafts provide a cleaner separation between the key ex-
change in the handshake protocol and the use of the resulting
session key in the record layer protocol. This contrasts with
TLS 1.2 and earlier, where the session key was used both
for record layer encryption and encryption of the Finished
messages in the handshake, making it impossible for TLS 1.2
to satisfy standard key exchange indistinguishability notions
and requiring either (a) a more complex security model that
treats the handshake and record layer together [19] or (b) a
cunning approach to release the record layer key early [10]
(see also Section 1.3). The cleaner separation in the TLS
1.3 design allows us to take a compositional approach to the
security of TLS 1.3, treating the handshake separate from
the record layer, and also allowing us to include session re-
sumption for abbreviated handshakes.
1.1 TLS 1.3 as a Multi-Stage Key Exchange

The message ﬂow for both drafts is similar and shown in
Figures 1 and 2. It is convenient to view TLS 1.3 as a multi-

1Since May 2015, two follow-up draft versions of TLS 1.3
have been published; draft-07 [26] builds on draft-05
but incorporates major key exchange changes including the
draft-dh key schedule. We expect that our draft-dh anal-
ysis can be adapted to cover draft-07’s design.
2draft-05 foresees and draft-dh sketches a subordinate pre-
shared key variant relying on previously shared keys.
3When we refer to “TLS 1.3”, we mean the common features
of draft-05 and draft-dh.

stage key exchange protocol [17] in which both parties, the
client and the server, agree on multiple session keys, possibly
using one key to derive the next one. In the ﬁrst stage, the
ﬁrst session key is derived via an anonymous Diﬃe–Hellman
key exchange (in the ClientKeyShare and ServerKeyShare
messages) from which a handshake master secret HMS is
computed. This handshake master secret is used to compute
a handshake traﬃc key tkhs which encrypts the remaining
messages of the handshake and should provide some form of
outsider privacy for the exchanged certiﬁcates.

In the second stage, the parties (depending on the desired
authentication level) exchange signatures over the (hash of
the) transcript under a certiﬁed key in order to authenti-
cate. They then derive the application traﬃc key tkapp for
securing the application messages, the resumption master
secret RMS if they resume sessions, and the exporter master
secret EMS which can be used for deriving additional keying
material. Viewing each of the keys as one of the multi-stage
session keys enables us to argue about their security, even if
the other keys are leaked. Both parties conclude the proto-
col by exchanging Finished messages over the transcripts,
generated using HMS or a separate key.
1.2 Our Results
Security of draft-05 and draft-dh full handshakes.
First, we show (in Sections 5 and 6) that both TLS 1.3
drafts are secure multi-stage key exchange protocols where
diﬀerent stages and simultaneous runs of the protocols can
be unauthenticated, unilaterally authenticated, or mutually
authenticated. On a high level, this means that the hand-
shakes establish record layer keys, resumption keys, and ex-
porter keys that look random to an adversary. This holds
even with sessions that run concurrently and if the adversary
controls the whole network, is able to corrupt the long-term
secret keys of other parties, and allowed to reveal keys estab-
lished in other sessions, thus providing quite strong security
guarantees for practice. Moreover, the multi-stage model
used allows us to show that even leakage of record layer or
exporter keys in the same handshake session do not compro-
mise each other’s security.

This requires some additions to the multi-stage key ex-
change security model of Fischlin and Günther [17] to al-
low for unauthenticated sessions and post-speciﬁed peers,
as described in Section 4, as well as to handle authentica-
tion based on pre-shared symmetric keys, as described in
Section 8. Notably, our security proof only relies on so-
called standard cryptographic assumptions such as the De-
cisional Diﬃe–Hellman (DDH) assumption, unforgeability
of the deployed signature scheme, collision resistance of the
hash function, and pseudorandomness of the key derivation
function. This is in sharp contrast to many other key ex-
change protocols, where often the key derivation function is
modeled as a random oracle. The cryptographic analysis
of signed-Diﬃe–Hellman ciphersuites in TLS 1.2 required
an uncommon (yet not implausible) pseudorandom-oracle
Diﬃe–Hellman assumption [19, 23].
Composition theorem for use of session keys.
In
order to show that the keys established in TLS 1.3’s multi-
stage key exchange handshake can be safely used in the
record layer encryption, we extend the composition frame-
works of Brzuska et al. [12] and Fischlin and Günther [17] in
Section 7 to multi-stage key exchange protocols with mixed
unauthenticated, unilateral, and mutual authentication.

1198A key point to secure composition of multi-stage key agree-
ment protocols with arbitrary symmetric-key protocols in
[17] is (session-)key independence. This roughly means that
one can reveal a session key without endangering the secu-
rity of future session keys. Both TLS 1.3 drafts satisfy this,
enabling us to argue about secure composition of the full
handshake protocols with, say, a secure channel protocol.

Recent work by Badertscher et al. [5] shows that the au-
thenticated encryption (with associated data) used in the
record layer in both TLS 1.3 drafts is secure. Our compo-
sitional approach immediately implies that the traﬃc keys
output by both drafts’ handshakes can be safely used in the
record layer.
Security of session resumption in TLS 1.3 drafts.
TLS includes a mode for abbreviated handshakes, in which
parties who have previously established a session can save
round trips and computation by using the previous key as
the basis for a new session; this is called session resump-
tion. We can treat the abbreviated handshake as a separate
symmetric-key protocol (modeled in Section 8) with an inde-
pendent, modular security analysis (in Section 9), then use
our compositional approach to show that the resumption
master secrets output by the full handshake can be safely
composed with the abbreviated handshake.
Comments on the design of TLS 1.3.
Our results
allow us to give insight on some of the design choices of
TLS 1.3, such as the role of the Finished messages and of
the new session hash. Those comments follow in Section 3,
immediately after we review the structure of the TLS 1.3
handshakes in the next section.
This proceedings version omits some details due to length
restrictions; additional explanation, particularly in the se-
curity model, as well as detailed proofs, appear in the full
version [15].
1.3 Related work

A signiﬁcant step forward to a comprehensive analysis of
TLS 1.2 handshake protocol and its implementation came
with the recent work of Bhargavan et al. [10], who analyze
the TLS 1.2 handshake protocol in the agile setting, cover-
ing the various ciphersuite options in TLS 1.2, and applying
the results to a miTLS implementation [18, 9]. Using epochs
and shared states between executions they also capture re-
sumption and renegotiation in TLS 1.2. We are not aware
of extensions of their result to the TLS 1.3 candidates.

A key point in the analysis of Bhargavan et al. [10] is to
overcome the session key usage in the ﬁnishing messages of
the TLS 1.2 handshake by separating these from the remain-
ing handshake, achieved through so-called (peer-)exchange
variables to safely determine partners. While the Finished-
message problem is eliminated in TLS 1.3, we also introduce
contributive identiﬁers as an alternative partnering concept.
In contrast to [10] those resemble closer the common session
identiﬁers (which we also use) and are only employed for
non-mutually authenticated sessions and our compositional
result. We furthermore use a general composition approach
to deal with resumption, while [10] considers resumption as
an abbreviated handshake, executed in a diﬀerent epoch.
Finally, the analysis in [10] extends to the implementation
level; our results are purely on the abstract level.

Concurrently to our work, Kohlweiss et al. [21] transferred
their constructive-cryptography based analysis of TLS 1.2

to (a modiﬁed version of) the draft-05 version of TLS 1.3,
where they assume that the second-stage messages are actu-
ally sent unencrypted. They do not consider the draft-dh
draft, nor do they cover the resumption step. However,
our approach of integrating resumption via composition may
also be viable for their model.
1.4 Limitations

Since TLS 1.3 is still a work in progress, our analysis is
inevitably limited to the draft speciﬁcations available at the
time of writing, and the actual TLS 1.3 may eventually diﬀer
from the draft versions we have analyzed. Nonetheless, this
paper’s analysis can provide insight into the design of the
existing drafts. We believe it is imperative for the crypto-
graphic community to be engaged in the design and analysis
of TLS 1.3 before, rather than after, it is standardized.

One of the aspired design goals of TLS 1.3 is to sup-
port the possibility for zero round-trip time (0-RTT) for
the handshake protocol, which would enable transmission of
application from the client to the server on the ﬁrst mes-
sage ﬂow, saving latency. This unfortunately comes with
inherent problems, namely, lack of forward secrecy and the
possibility of replay attacks. draft-05 provides no speciﬁ-
cation for 0-RTT handshakes; draft-dh introduces an extra
“semi-static” public key for this purpose, however at the
time of writing draft-dh does not provide suﬃcient proto-
col detail to allow a full cryptographic analysis of this. We
do not model leakage of the draft-dh semi-static key at this
point as it plays no role (for secrecy) in our security analy-
sis, but defer carefully crafting reasonable conditions for its
exposure until the 0-RTT handshake is speciﬁed completely.
As noted above, our compositional approach allows for
the separate analysis of the full handshake, the record layer,
and the session resumption handshake, and then compo-
sition shows that the various keys output from the hand-
shake can be safely used with the record layer encryption
and session resumption. This suggests the following ap-
proach to prove the full TLS protocol suite to be secure:
show that session resumption itself constitutes a secure key
exchange protocol (with a pre-shared symmetric key which
comes from the handshake protocol here), compose it se-
curely with the record layer protocol, and then “cascade”
this composed symmetric-key protocol with the composi-
tional handshake protocol. Unfortunately, one limitation of
the current composition frameworks is that composition is
only supported between a key exchange protocol with for-
ward secrecy and an arbitrary symmetric key protocol. This
holds here for the main handshake protocol and allows us to
immediately argue secure composition with session resump-
tion or with the record layer. However, session resumption
does not provide forward secrecy (with respect to corrup-
tion of the resumption (pre-)master secrets), so we cannot
automatically conclude safe use of the session keys output
by session resumption in the record layer. Extending the
composition framework to support multi-stage key exchange
protocols without forward secrecy is left for future work.

2. THE TLS 1.3 HANDSHAKE PROTOCOL
For both draft-05 and draft-dh, the handshake protocol
is divided into two phases: the negotiation phase, where
parties negotiate ciphersuites and key-exchange parameters,
generate unauthenticated shared key material, and establish
handshake traﬃc keys; and the authentication phase, where

1199Client
ClientHello: rc ←$ {0, 1}128
ClientKeyShare: X ← gx

Server

Client

Server

ClientHello
ClientKeyShare

PMS ← Y x

H1 ← H(CHk . . .kSKS)

HMS ← PRF(PMS, label1kH1)
tkhs ← PRF(HMS, label2krskrc)

ServerHello: rs ← {0, 1}128
ServerKeyShare: Y ← gy
PMS ← X y

stage 1
{EncryptedExtensions∗}
{ServerCertificate∗}: pkS
{CertificateRequest∗}
{ServerCertificateVerify∗}:
SCV ← Sign(skS, H2)
{ServerFinished}:
SF ← PRF(HMS, label3kH3)

H2 ← H(CHk . . .kCR∗)

H3 ← H(CHk . . .kSCV∗)

Verify(pkS, H2, SCV)
check SF = PRF(HMS, label3kH3)
{ClientCertificate∗}: pkC
{ClientCertificateVerify∗}:
CCV ← Sign(skC , H4)
{ClientFinished}:
CF ← PRF(HMS, label4kH5)

H4 ← H(CHk . . .kCCRT∗)

H5 ← H(CHk . . .kCCV∗)

Verify(pkC , H4, CCV)
check CF = PRF(HMS, label4kH5)

MS ← PRF(HMS, label5kH5)
tkapp ← PRF(MS, label2krskrc)
RMS ← PRF(HMS, label6kH5)

stage 2
stage 3

HMS ← HKDF.Extract(0, ES)

tkhs ← HKDF.Expand(HMS, label1kH1)

ServerHello
ServerKeyShare
ES ← X y
stage 1
{EncryptedExtensions∗}
{ServerCertificate∗}
{CertificateRequest∗}
{ServerParameters∗}:
SP ← S = gs, Sign(skS, gskH2)
SS ← X s

ES ← Y x

SS ← Sx

AMS ← HKDF.Extract(0, SS)

FS ← HKDF.Expand(AMS, rskrc)

H3 ← H(CHk···kSP∗)

{ServerFinished}:
SF ← HKDF.Expand(FS, label2kH3)

Verify(pkS, SkH2, SP)
check SF = HKDF.Expand(FS, label2kH3)
{ClientCertificate∗}
{ClientCertificateVerify∗}
{ClientFinished}:
CF ← HKDF.Expand(FS, label3kH5)

H5 ← H(CHk . . .kCCV∗)

check CF = HKDF.Expand(FS, label3kH5)

MS ← HKDF.Extract(AMS, ES)

tkapp ← HKDF.Expand(MS, label1kH5)
RMS ← HKDF.Expand(MS, label4kH5)
EMS ← HKDF.Expand(MS, label5kH5)

stage 2
stage 3
stage 4

record layer (application data), using AEAD with key tkapp

record layer (application data), using AEAD with key tkapp

Figure 1: The handshake protocol in TLS 1.3 draft-05.
XXX: Y denotes TLS message XXX containing Y . {XXX} indi-
cates a message XXX encrypted using AEAD encryption with
handshake traﬃc key tkhs. XXX∗ indicates a message that is
only sent in unilateral or mutual authentication modes.

Figure 2: The handshake protocol in TLS 1.3 draft-dh.
Hash value and message computations not stated explic-
itly are performed identically to TLS 1.3 draft-05 (Fig-
For unauthenticated handshakes,
ure 1).
the Server
Certificate and ServerParameters messages are omitted
and key derivation proceeds with SS set to ES.

parties authenticate the handshake transcript according to
the authentication properties negotiated earlier and output
authenticated application traﬃc keys, independent from the
previous handshake traﬃc keys.
2.1 draft-05 Handshake

Figure 1 shows the message ﬂow and relevant crypto-

graphic computations for the full handshake in draft-05.

The handshake messages are as follows:
• ClientHello (CH)/ServerHello (SH) contain the sup-
ported versions and ciphersuites for negotiation pur-
poses, as well as random nonces rc resp. rs. SH can
contain a session identiﬁer session_id ﬁeld for future
session resumption.
• ClientKeyShare (CKS)/ServerKeyShare (SKS) contain
the ephemeral Diﬃe–Hellman shares X = gx resp. Y =
gy for one or more groups selected by an extension
in CH/SH.

Both parties can now compute the premaster secret PMS as
gxy and then use a pseudorandom function PRF to compute
a handshake master secret HMS and handshake traﬃc key
tkhs; both are unauthenticated at this point.

All subsequent messages are encrypted using tkhs:
• EncryptedExtensions (EE) contains more extensions.

that the client authenticates using a certiﬁcate.

• ServerCertificate (SCRT)/ClientCertificate (CCRT)
contain the public-key certiﬁcate of the respective party.
• CertificateRequest (CR) indicates the server requests
• ServerCertificateVerify (SCV)/ClientCertificate
Verify (CCV) contain a digital signature over the ses-
sion hash (the hash of all handshakes messages sent
and received at that point in the protocol run).
• ClientFinished (CF)/ServerFinished (SF) contain the
PRF evaluation on the session hash keyed with HMS.
Both parties can now compute the master secret MS and
the application traﬃc key tkapp as well as the resumption
master secret RMS for use in future session resumptions.
2.2 draft-dh Handshake

Figure 2 shows the message ﬂow and cryptographic com-
putations for the full handshake in draft-dh. The main dif-
ference to draft-05 is the ServerParameters message (re-
placing SCV) containing the server’s additional semi-static
Diﬃe–Hellman share, allowing the application traﬃc keys
to rely on both ephemeral and non-ephemeral secrets. Key
derivation is done using the HKDF extract-then-expand key
derivation function [22], rather than the TLS PRF.

1200Client
ClientHello: rc ←$ {0, 1}128, session_id ∈ {0, 1}256

Server

H ← H(CH||SH)

HMS ← PRF(RMS, label1kH)
tkhs ← PRF(HMS, label2krskrc)

ServerHello: rs ←$ {0, 1}128

stage 1
{ServerFinished}:
SF ← PRF(HMS, label3kH)

check SF = PRF(HMS, label3kH)
{ClientFinished}:
CF ← PRF(HMS, label4kH)

check CF = PRF(HMS, label4kH)

MS ← PRF(HMS, label5kH)
tkapp ← PRF(MS, label6krskrc)

stage 2

record layer (application data), using AEAD with key tkapp

Figure 3: Session resumption in TLS 1.3 draft-05, using
the resumption master secret RMS as a pre-shared key.

2.3 Session Resumption

Session resumption in draft-05 has similarly been changed
from TLS 1.2 to separate handshake and application traf-
ﬁc keys. As shown in Figure 3, ClientHello includes a
preshared-secret identiﬁer session_id of some previously
established session, whose resumption master secret is used
for the key derivation. We omit a description of resumption
in draft-dh as its key schedule is not conclusively speciﬁed.

3. COMMENTS ON THE TLS 1.3 DESIGN
Our analysis provides several insights into the TLS 1.3
drafts, for both the basic cryptographic choices, as well as
for the yet to be fully speciﬁed 0-RTT versions.
Soundness of key separation.
Earlier versions of TLS
used in the same session key to encrypt the application data
as well as the Finished messages at the end of the hand-
shake. This made it impossible to show that the TLS session
key satisﬁed standard Bellare–Rogaway-style key indistin-
guishability security [6], and necessitated non-standard as-
sumptions in the security proof (e.g., the PRF-Oracle-Diﬃe–
Hellman (PDF-ODH) assumption [19, 23]). We conﬁrm that
the change in keys for encryption of handshake messages al-
lows both TLS 1.3 drafts to achieve standard key indistin-
guishability security without non-standard assumptions.
Key independence. Both TLS 1.3 drafts achieve key in-
dependence in the multi-stage security setting, which heavily
strengthens their overall security. (Recall key independence
is the property that one can reveal a session key without
endangering the security of later-stage keys.) Beyond mak-
ing it amenable to generic composition, key independence
safeguards the usage of derived keys against inter-protocol
eﬀects of security breakdowns.

draft-dh takes a slightly more composable approach to
keying material exporting than draft-05. In draft-dh, an
exporter master secret EMS is derived from the master se-
cret and then applications get exported keying material as
PRF(EMS, label).
In draft-05, applications get exported
keying material directly as PRF(MS, label). Key indepen-
dence in the draft-dh approach allows us to treat deriva-
tion of exported keying material as a separate symmetric
protocol, whereas in draft-05 each exported key must be

considered in the main analysis, so we argue the draft-dh
approach of a separate exporter master secret is preferable.
Encryption of handshake messages.
Both TLS 1.3
drafts encrypt the second part of the handshake using the
initial handshake traﬃc key tkhs, aiming to provide some
form of privacy (against passive adversaries) for these mes-
sages, in particular for the server and client certiﬁcates. Our
analysis shows that the handshake traﬃc key does indeed
have security against passive adversaries and hence increases
the handshake’s privacy. The secrecy of the ﬁnal session keys
however does not rely on the handshake being encrypted and
would remain secure even if was done in clear. Our analysis
considers the encrypted case, showing that this encryption
does not negatively aﬀect the security goals.
Finished messages.
The Finished messages in both
drafts are computed by applying the PRF (or HKDF in
draft-dh) to the (hash of the) handshake transcript. Inter-
estingly, the Finished messages do not contribute to the ses-
sion key secrecy in the full handshake or the session resump-
tion handshake in the sense that the key exchange would
be secure without these messages. This contrasts with the
case of RSA key transport in the TLS 1.2 full handshake:
the analyses of both Krawczyk et al. [23] and Bhargavan et
al. [10] note potential weaknesses or require stronger secu-
rity assumptions if Finished messages are omitted. From
an engineering perspective, the Finished messages can still
be interpreted as providing some form of (explicit) session
key conﬁrmation, but is not cryptographically required to
achieve key indistinguishability. In session resumption, the
Finished messages give the only explicit authentication.
Session hash in key derivation.
Both TLS 1.3 drafts
include a hash of all messages exchanged so far in the deriva-
tion of all session keys and, in draft-05, also in deriving
the master secrets. This session hash was introduced in re-
sponse to the triple handshake attack [8] on TLS 1.2 and
earlier, with the goal of ensuring that sessions with diﬀerent
session identiﬁers have diﬀerent master secrets. In our secu-
rity analysis of both full handshakes, the online signatures
computed over the handshake messages already suﬃce to
bind the exchanged messages to the authenticated parties
and established keys, so including the session hash in the
key derivations does not contribute to the session keys’ se-
crecy. If keys are meant to be used as a channel identiﬁer or
for channel binding (with the purpose of leveraging the sess-
sion protection and authentication properties established by
TLS in an application-layer protocol), including the session
hash is appropriate. While the standardized tls-unique
[4] and proposed tls-unique-prf [20] TLS channel binding
methods do not use keys directly for binding, the low cost
of including the session hash seems worth it in case an ap-
plication developer decides to use keying material directly
for binding.
In draft-dh session resumption, there is no
ephemeral shared secret and the master secret is computed
as a series of HKDF.Extract computations over a 0-string us-
ing the resumption secret as the key. All sessions sharing
the same resumption master secret then compute the same
master secret. However, since key derivation still uses the
session hash as context, keys are unique assuming unique-
ness of protocol messages (assured, e.g., via unique nonces).
Upstream hashing for signatures.
In signing the
transcript for authentication, both draft-05 and draft-dh
have the signer input the hash of the current transcript to

1201the signing algorithm; if the signature algorithm is a hash-
then-sign algorithm, it will then perform an additional hash.
From a cryptographic point of view, it would be preferable
to insert the full (unhashed) transcript and let the sign-
ing algorithm opaquely take care of processing this message.
For engineering purposes, however, it may be amenable to
hash the transcript iteratively, only storing the intermedi-
ate values instead of entire transcript. Furthermore, since
the hashed transcript is likewise given to the key derivation
function, storing the hash value may be also advantageous
in this regard. In our security proof, this upstream hashing
leads to an additional assumption about the collision resis-
tance of the hash function (which would otherwise be taken
care of by the signature scheme).

4. MULTI-STAGE KEY EXCHANGE

In this section we recap and extend the model for multi-
stage key exchange by Fischlin and Günther [17] based on
the Bellare–Rogaway-style model of Brzuska et al. [12, 11].
4.1 Outline

Our model for multi-stage key exchange protocols follows
the Bellare–Rogaway paradigm. We assume that an adver-
sary controls the network which connects multiple sessions of
honest parties, enabling the adversary to modify, inject, or
drop transmissions of these honest parties. This is captured
via a NewSession (for starting a new session of an honest
party) and a Send query (delivering some message to it).
Since the goal is to ultimately provide secrecy of the various
session keys, the adversary may pose Test queries for some
stage to either receive the corresponding session key of that
stage, or to get an independent random key instead. Since
a session key may be used to derive the next one, we need
to be careful when such a Test query is admissible.

Our model allows the adversary to learn certain secret in-
puts to the protocol execution, as well as outputs such as
session keys; we do not allow the adversary to learn inter-
mediate values from protocol execution, as we do not aim
to capture implementation ﬂaws within the protocol. The
Corrupt query models leakage of long-term authentication
keys. The Reveal query models leakage of session keys. For
both of these, we must prohibit compromise of secrets that
make it trivial to break the security property: we do so by
deﬁning partners via session identiﬁers. In the multi-stage
setting, each stage involves its own identiﬁer. An important
aspect for the Reveal query in the multi-stage setting con-
cerns the security of future session keys of later stages, given
that a session key of some stage is revealed. (Session-)key in-
dependence says that such leakage does not endanger future
keys. Our model does not consider leakage of draft-dh’s
semi-static keys: since draft-dh does not actually include
0-RTT session keys, the leakage of semi-static secrets does
not aﬀect the security of the handshake. However, in a fu-
ture protocol using semi-static secrets to derive 0-RTT ses-
sion keys, security would depend on semi-static secrets and
leakage would have to be modeled appropriately.

For TLS 1.3 some adaptations of the multi-stage model
of Fischlin and Günther [17] are necessary or beneﬁcial. In
order to cover the various authenticity properties of the
TLS 1.3 handshake, we extend their model to encompass,
besides mutually and unilaterally authenticated keys, also
unauthenticated keys. One can imagine TLS 1.3 as be-
ing composed of various protocol versions which share joint

steps, but are fundamentally diﬀerent in terms of security.
Namely, TLS 1.3 can be seen as a family of three protocols,
one without any authentication, one for unilateral authen-
tication (of the server), and another one for mutual authen-
tication where both client and server authenticate. We cap-
ture this by allowing the adversary in the security model
to determine the type of authentication, and thus the cor-
responding sub protocol, when initializing a session. We
also capture keys and executions with increasing authentic-
ity properties, starting with an unauthenticated session key
and then establishing a unilaterally or mutually authenti-
cated key. We also allow executions of diﬀerent types to run
concurrently, even within a single party.

We additionally allow the communication partner of a ses-
sion to be unknown at the start of the protocol, i.e., we
allow for “post-speciﬁed peers” as introduced by Canetti
and Krawczyk [13]. In our model, this is captured by let-
ting the adversary initialize a session with a wildcard ‘∗’
as the intended communication partner and corresponds to
the regular case in TLS 1.3 that parties discover their peer’s
identity during protocol execution when they receive their
peer’s certiﬁcate. Note that the common approach to au-
thenticate clients by password-based login over the already
established TLS connection is beyond the scope of this pa-
per; from the perspective of our key exchange model, those
are sessions where the client does not authenticate.

Another change concerns stronger key secrecy properties
for sessions communicating with unauthenticated partners.
For example, in TLS 1.3 a server can communicate with
an unauthenticated client. Since the adversary could easily
impersonate the unauthenticated client and thereby legiti-
mately compute the shared session key, we cannot in gen-
eral allow all server sessions with unauthenticated partners
to be tested. However, if there is an honest unauthenticated
client, then the key between these honest parties should still
be secure, so we allow Test queries for sessions with unau-
thenticated partners if an honest partner exists (as done
in [17]).

This, though, turns out to be overly restrictive and less
handy for our composition result.
Intuitively, one should
also allow to Test such a server session even if the adver-
sary does not deliver the server’s ﬁnal message to the hon-
est client session. Since the client at this point has already
completed his contribution to the session key on the server
side, this key should already be considered secure. We hence
introduce the notion of contributive identiﬁers, identifying
sessions of honest parties which are currently not partnered
according to (full) session identiﬁers, but indicating that the
key is entirely based on an honest peer’s contribution. For
soundness we assume that partnered sessions (having match-
ing session identiﬁers) also agree on the contributive identi-
ﬁer. Both session identiﬁers and contributive identiﬁers are
set primarily as administrative tokens by the key exchange
protocol during the execution. In contrast to session identi-
ﬁers, a contributive identiﬁer can be updated several times
instead of being set only once, e.g., to eventually match the
session identiﬁer. Guidance for how and when to set con-
tributive identiﬁers can be obtained by considering composi-
tion: we will show that secure usage of an established session
key in a subsequent symmetric protocol is possible whenever
the parties honestly (or authentically) contributed to that
key, i.e., agree on the contributive identiﬁers. Contributive
identiﬁers may be seen as the identiﬁer-based analogue to

1202preﬁx-matching deﬁnitions used in ACCE models [19], al-
lowing the adversary to issue Test queries to sessions that
are non-trivial to break but normally force the adversary to
lose the game.

4.2 Preliminaries
We denote by U the set of identities used to model the
participants in the system, each identiﬁed by some U ∈ U
and associated with a certiﬁed long-term public key pkU and
secret key skU. Note that in addition to the long-term keys
parties may also hold (uncertiﬁed) temporary (“semi-static”
in draft-dh) key pairs for the 0-RTT protocol version, each
identiﬁed by a key identiﬁer kid. Sessions of a protocol are
uniquely identiﬁed (on the administrative level of the model)
using a label label ∈ LABELS = U × U × N, where (U, V, k)
indicates the k-th local session of identity U (the session
owner) with V as the intended communication partner.

For each session, a tuple with the following information is
maintained as an entry in the session list ListS, where values
in square brackets [ ] indicate the default/initial value. Some
variables have values for each stage i ∈ {0, . . . , M}.4

this session

key pair (tpk, tsk) used by the session owner

• label ∈ LABELS: the (administrative) session label
• U ∈ U: the session owner
• V ∈ (U ∪ {∗}): the intended communication partner,
where the distinct wildcard symbol ‘∗’ stands for “un-
known identity” and can be set to a speciﬁc identity
in U once by the protocol
• role ∈ {initiator, responder}: the session owner’s role in
• auth ∈ AUTH ⊆ {unauth, unilateral, mutual}M: the as-
pired authentication type of each stage from the set
of supported properties AUTH, where M is the maxi-
mum stageand authi indicates the authentication level
in stage i > 0
• kidU: the key identiﬁer for the temporary public/secret
• kidV : the key identiﬁer for the communication partner
• stexec ∈ (RUNNING ∪ ACCEPTED ∪ REJECTED): the
state of execution [running0], where RUNNING =
{runningi | i ∈ N0}, ACCEPTED = {acceptedi | i ∈ N},
REJECTED = {rejectedi | i ∈ N}
• stage ∈ {0, . . . , M}: the current stage [0], where stage
is incremented to i when stexec reaches acceptedi resp.
rejectedi
• sid ∈ ({0, 1}∗ ∪ {⊥})M: sidi [⊥] indicates the session
identiﬁer in stage i > 0
• cid ∈ ({0, 1}∗ ∪{⊥})M: cidi [⊥] indicates the contribu-
• K ∈ ({0, 1}∗ ∪ {⊥})M: Ki [⊥] indicates the established
• stkey ∈ {fresh, revealed}M: stkey,i [fresh] indicates the
• tested ∈ {true, false}M:
test indicator testedi [false],

state of the session key in stage i > 0

tive identiﬁer in stage i > 0

session key in stage i > 0

where true means that Ki has been tested

By convention, if we add a partly speciﬁed tuple (label, U,
V, role, auth, kidU , kidV ) to ListS, then the other tuple entries
are set to their default value. As labels are unique, we write
as a shorthand, e.g., label.sid for the element sid in the tuple
with label label in ListS, and analogously for other entries.

4We ﬁx a maximum stage M only for ease of notation. Note
that M can be arbitrary large in order to cover protocols
where the number of stages is not bounded a-priori.

4.3 Authentication Types

We distinguish between three diﬀerent levels of authenti-
cation for the keys derived in a multi-stage key exchange pro-
tocol: unauthenticated stages and keys (which provides no
authentication for either communication partner); unilater-
ally authenticated stages and keys (which authenticates one
party, in our case the responder); and mutually authenticated
stages and keys (which authenticates both communication
partners). We let the adversary choose the authentication
type for each session it creates.

For stages with unilateral authentication, where only the
responder authenticates, we consequently only aim for se-
crecy of the initiator’s session key, or of the responder’s
key, if the initiator’s contribution to the key is honest and
the adversary merely observes the interaction. In the non-
authenticated case we only ask for secrecy of those keys es-
tablished through contributions of two honest parties. Since
the adversary can trivially impersonate unauthenticated par-
ties we cannot hope for key secrecy beyond that.
Formally, we capture the authenticity properties provided
in a protocol by a set AUTH ⊆ {unauth, unilateral, mutual}M,
representing each protocol variant’s authentication by a vec-
tor (auth1, . . . , authM) ∈ AUTH specifying the authenticity
for each stage. We moreover treat all authenticity vari-
ants of a protocol concurrently in our model (and hence
speak about concurrent authentication properties): we al-
low concurrent executions of the diﬀerent key exchange sub
protocols, simultaneously covering all potential unauthenti-
cated, unilaterally authenticated, or mutually authenticated
runs. Given that the authenticity of keys is a strictly non-
decreasing property with progressing stage, we also simply
speak of no authentication if all keys are unauthenticated
and stage-k unilateral (resp. mutual) authentication if the
keys of stages i are unauthenticated for i < k and unilater-
ally (resp. mutually) authenticated for i ≥ k.

4.4 Adversary Model
We consider a probabilistic polynomial-time (PPT) adver-
sary A which controls the communication between all par-
ties, enabling interception, injection, and dropping of mes-
sages. As in [17] we distinguish diﬀerent levels of the fol-
lowing three (orthogonal) security aspects of a multi-stage
key exchange scheme: forward secrecy, authentication, and
key dependence; the latter refers to whether the next session
key relies on the conﬁdentiality of the previous session key.
Similarly to the diﬀerent authentication types we also speak
of stage-k forward secrecy if the protocol provides forward
secrecy from the k-th stage onwards.

To capture admissible adversarial interactions it is con-
venient here to add a ﬂag lost to the experiment which is
initialized to false. This ﬂag will later specify if the adver-
sary loses due to trivial attacks, such as revealing the session
key of a partner session to a tested session.

The adversary interacts with the protocol via the following

queries:
NewTempKey(U): Generate a new temporary key pair (tpk,
tsk), create and return a (unique) new identifer kid for it.
NewSession(U, V, role, auth, kidU , kidV ): Creates a new ses-
sion for participant identity U with role role and key iden-
tiﬁer kidU having V with key identiﬁer kidV as intended
partner (potentially unspeciﬁed, indicated by V = ∗) and
aiming at authentication type auth.

1203exec, stage0, sid0, cid0, K0, st0
i and st0

If there is no temporary key with identiﬁer kidU for user U
or with identiﬁer kidV for user V , return the error symbol
⊥. Otherwise, generate and return a (unique) new label
label and add (label, U, V, role, auth, kidU , kidV ) to ListS.
Send(label, m): Sends a message m to the session label.
If there is no tuple (label, U, V, role, auth, kidU , kidV , stexec,
stage, sid, cid, K, stkey, tested) in ListS, return ⊥. Otherwise,
run the protocol on behalf of U on message m and return
the response and the updated state of execution stexec. As
a special case, if role = initiator and m = init, the protocol
is initiated (without any input message).
If, during the protocol execution, the state of execution
changes to acceptedi for some i, the protocol execution is
immediately suspended and acceptedi is returned as result
to the adversary. The adversary can later trigger the re-
sumption of the protocol execution by issuing a special
Send(label, continue) query. For such a query, the proto-
col continues as speciﬁed, with the party creating the next
protocol message and handing it over to the adversary to-
gether with the resulting state of execution stexec. We note
that this is necessary to allow the adversary to test such
a key, before it may be used immediately in the response
and thus cannot be tested anymore for triviality reasons.
If the state of execution changes to stexec = acceptedi for
some i and there is a tuple (label0, V, U, role0, auth0, kidV ,
kidU , st0
key, tested0) in ListS with sidi
= sid0
key,i = revealed, then, for key-independence,
stkey,i is set to revealed as well, whereas for key-dependent
security, all stkey,i0 for i0 ≥ i are set to revealed. The for-
mer corresponds to the case that session keys of partnered
sessions should be considered revealed as well, the latter
implements that for key dependency all subsequent keys
are potentially available to the adversary, too.
If the state of execution changes to stexec = acceptedi for
some i and there is a tuple (label0, V, U, role0, auth0, kidV ,
kidU , st0
key, tested0) in ListS with sidi
= sid0
i and
label.testedi ← true. This ensures that, if the partnered
session has been tested before, this session’s key Ki is set
consistently5 and subsequent Test queries for the session
here are answered accordingly.
If the state of execution changes to stexec = acceptedi for
some i and the intended communication partner V is cor-
rupted, then set stkey,i ← revealed.
Reveal(label, i): Reveals label.Ki, the session key of stage i
in the session with label label.
If there is no tuple (label, U, V, role, auth, kidU , kidV , stexec,
stage, sid, cid, K, stkey, tested) in ListS, or i > stage, or testedi
= true, then return ⊥. Otherwise, set stkey,i to revealed and
provide the adversary with Ki.
If there is a tuple (label0, V, U, role0, auth0, kidV , kidU , st0
exec,
stage0, sid0, cid0, K0, st0
key, tested0) in ListS with sidi = sid0
i and
stage0 ≥ i, then st0
key,i is set to revealed as well. This means
the i-th session keys of all partnered sessions (if established)
are considered revealed too.
As above, in the case of key-dependent security, since future
keys depend on the revealed key, we cannot ensure their
security anymore (neither in this session in question, nor
in partnered sessions). Therefore, if i = stage, set stkey,j =

i = true, then set label.Ki ← label0.K0

exec, stage0, sid0, cid0, K0, st0

i and tested0

5This implicitly assumes the following property of the later-
deﬁned Match security: Whenever two partnered sessions
both accept a key in some stage, these keys will be equal.

i has stage0 = i, then set st0

revealed for all j > i, as they depend on the revealed key.
For the same reason, if a partnered session label0 with sidi =
sid0
key,j = revealed for all j > i.
Note that if however stage0 > i, then keys K0
j for j >
i derived in the partnered session are not considered to
be revealed by this query since they have been accepted
previously, i.e., prior to Ki being revealed in this query.
Corrupt(U): Provide skU to the adversary. No further queries
are allowed to sessions owned by U.
In the non-forward-secret case, for each session label owned
by U and all i ∈ {1, . . . , M}, set label.stkey,i to revealed. In
this case, all (previous and future) session keys are consid-
ered to be disclosed.
In the case of stage-j forward secrecy, label.stkey,i is set to
revealed only if i < j or if i > stage. This means that
session keys before the j-th stage (where forward secrecy
kicks in) as well as keys that have not yet been established
are potentially disclosed.
Independent of the forward secrecy aspect, in the case of
key-dependent security, setting the relevant key states to
revealed for some stage i is done by internally invoking
Reveal(label, i), ignoring the response and also the restric-
tion that a call with i > stage would immediately return
⊥. This ensures that follow-up revocations of keys that
depend on the revoked keys are carried out correctly.
Test(label, i): Tests the session key of stage i in the session
with label label. In the security game this oracle is given
a uniformly random test bit btest as state which is ﬁxed
throughout the game.
If there is no tuple (label, U, V, role, auth, kidU , kidV , stexec,
6=
stage, sid, cid, K, stkey, tested) in ListS or if
acceptedi, return ⊥.
If there is a tuple (label0, V, U, role0,
auth0, kidV , kidU , st0
exec, stage0, sid0, cid0, K0, st0
in
exec 6= acceptedi, set the ‘lost’
i, but st0
ListS with sidi = sid0
ﬂag to lost ← true. This ensures that keys can only be
tested if they have just been accepted but not used yet,
including ensuring any partnered session that may have
already established this key has not used it.
If label.authi = unauth or if label.authi = unilateral and
label.role = responder, but there is no tuple (label0, V, U,
role0, auth0, kidV , kidU , st0
key, tested0)
i, then set lost ←
(for label 6= label0) in ListS with cidi = cid0
true. This ensures that having an honest contributive part-
ner is a prerequisite for testing responder sessions in an
unauthenticated or unilaterally authenticated stage and for
testing an initiator session in an unauthenticated stage.6
If label.testedi = true, return Ki, ensuring that repeated
queries will be answered consistently.
Otherwise, set label.testedi to true. If the test bit btest is 0,
sample label.Ki ←$ D at random from the session key distri-
bution D. This means that we substitute the session key by
a random and independent key which is also used for future
deployments within the key exchange protocol. Moreover,
if there is a tuple (label0, V, U, role0, auth0, kidV , kidU , st0
exec,
stage0, sid0, cid0, K0, st0
key, tested0) in ListS with sidi = sid0
i,
i ← true to
also set label0.K0
ensure consistency in the special case that both label and
label0 are in state acceptedi and, hence, either of them can
be tested ﬁrst.
Return label.Ki.

i ← label.Ki and label0.tested0

label.stexec
key, tested0)

exec, stage0, sid0, cid0, K0, st0

6Note that ListS entries are only created for honest sessions,
i.e., sessions generated by NewSession queries.

12044.5 Security of Multi-Stage Key Exchange

The security properties for multi-stage key exchange pro-
tocols are split in two games, following Fischlin et al. [17]
and Brzuska et al. [12, 11]. On the one hand, Match security
ensures that the session identiﬁers sid eﬀectively match the
partnered sessions. On the other hand, Multi-Stage security
ensures Bellare–Rogaway-like key secrecy.

Our notion of Match security—extended beyond [17] to
cover diﬀerent levels of key authenticity and soundness of
the newly introduced contributive identiﬁers—ensures that
the session identiﬁers sid eﬀectively match the partnered ses-
sions which must share the same view on their interaction
concerning the session’s derived keys, authentication type,
contributive identiﬁers, and intended (authenticated) part-
ner. Moreover, session identiﬁers must not match across
diﬀerent stages or be shared by more than two sessions.
Definition 4.1 (Match security). Let KE be a key exchange
protocol and A a PPT adversary interacting with KE via the
queries deﬁned in Section 4.4 in the following game GMatch
KE,A:
Setup. The challenger generates long-term public/private-
key pairs for each participant U ∈ U.
Query. The adversary A receives the generated public keys
and has access to the queries NewSession, Send,
NewTempKey, Reveal, and Corrupt.

Stop. At some point, the adversary stops with no output.
We say that A wins the game, denoted by GMatch
KE,A = 1, if at
least one of the following conditions hold:
1. There exist two distinct labels label, label0 such that
label.sidi = label0.sidi 6= ⊥ for some stage i ∈ {1, . . . , M},
label.stexec 6= rejectedi, and label0.stexec 6= rejectedi, but
label.Ki 6= label0.Ki. (Diﬀerent session keys in some
stage of partnered sessions.)
2. There exist two distinct labels label, label0 such that
label.sidi = label0.sidi 6= ⊥ for some stage i ∈ {1, . . . , M},
but label.authi 6= label0.authi.
(Diﬀerent authentica-
tion types in some stage of partnered sessions.)
3. There exist two distinct labels label, label0 such that
label.sidi = label0.sidi 6= ⊥ for some stage i ∈ {1, . . . , M},
but label.cidi 6= label0.cidi or label.cidi = label0.cidi =
⊥. (Diﬀerent or unset contributive identiﬁers in some
stage of partnered sessions.)
4. There exist two distinct labels label, label0 such that
label.sidi = label0.sidi 6= ⊥ for some stage i ∈ {1, . . . ,
M}, label.authi = label0.authi ∈ {unilateral, mutual},
label.role = initiator, and label0.role = responder, but
label.V 6= label0.U or (only if label.authi = mutual)
label.U 6= label0.V . (Diﬀerent intended authenticated
partner.)
5. There exist two (not necessarily distinct) labels label,
label0 such that label.sidi = label0.sidj 6= ⊥ for some
stages i, j ∈ {1, . . . , M} with i 6= j. (Diﬀerent stages
share the same session identiﬁer.)
6. There exist three distinct labels label, label0, label00 such
that label.sidi = label0.sidi = label00.sidi 6= ⊥ for some
stage i ∈ {1, . . . , M}. (More than two sessions share
the same session identiﬁer.)
We say KE is Match-secure if for all PPT adversaries A
the following advantage function is negligible in the security
parameter: AdvMatch
Definition 4.2 (Multi-Stage security). Let KE be a key
exchange protocol with key distribution D and authenticity
properties AUTH, and A a PPT adversary interacting with

KE,A := Pr(cid:2)GMatch

KE,A = 1(cid:3).

:

Multi-Stage,D
KE,A

KE via the queries deﬁned in Section 4.4 within the following
game G
Setup. The challenger generates long-term public/private-
key pairs for each participant U ∈ U, chooses the test
bit btest ←$ {0, 1} at random, and sets lost ← false.
Query. The adversary A receives the generated public keys
and has access to the queries NewSession, Send,
NewTempKey, Reveal, Corrupt, and Test. Note that
such queries may set lost to true.

Guess. At some point, A stops and outputs a guess b.
Finalize. The challenger sets the ‘lost’ ﬂag to lost ← true
if there exist two (not necessarily distinct) labels label,
label0 and some stage i ∈ {1, . . . , M} such that label.sidi
= label0.sidi, label.stkey,i = revealed, and label0.testedi =
true. (Adversary has tested and revealed the key in a
single session or in two partnered sessions.)
Multi-Stage,D
KE,A

We say that A wins the game, denoted by G
= 1,
if b = btest and lost = false. Note that the winning conditions
are independent of key dependency, forward secrecy, and au-
thentication properties of KE, as those are directly integrated
in the aﬀected (Reveal and Corrupt) queries and the ﬁnaliza-
tion step of the game; for example, Corrupt is deﬁned diﬀer-
ently for non-forward-secrecy versus stage-j forward secrecy.
We say KE is Multi-Stage-secure in a key-dependent resp.

key-independent and non-forward-secret resp. stage-j-forward-
secret manner with concurrent authentication types AUTH
if KE is Match-secure and for all PPT adversaries A the
following advantage function is negligible in the security pa-
rameter: AdvMulti-Stage,D

:= Pr(cid:2)G

= 1(cid:3) − 1

Multi-Stage,D
KE,A

KE,A

2.

5. DRAFT-05 HANDSHAKE SECURITY

We can now analyze the handshake as speciﬁed in TLS 1.3

draft-05 [25].

First, we deﬁne the session identiﬁers for the two stages
deriving the handshake traﬃc key tkhs and the applica-
tion traﬃc key tkapp to be the unencrypted messages sent
and received excluding the ﬁnished messages: sid1 = (CH,
CKS, SH, SKS), sid2 = (CH, CKS, SH, SKS, EE∗, SCRT∗, CR∗, SCV∗,
CCRT∗, CCV∗). Here, starred (∗) components are not present
in all authentication modes. We moreover capture the deriva-
tion of the resumption premaster secret RMS in a further
stage 3 for which we deﬁne the session identiﬁer to be sid3 =
(sid2, “RMS”).

We stress that deﬁning session identiﬁers over the un-
encrypted messages is necessary to obtain key-independent
Multi-Stage security. Otherwise, we would need to either re-
sort to key dependence, or guarantee that an adversary is
not able to re-encrypt a sent message into a diﬀerent cipher-
text even if it knows the handshake traﬃc key tkhs used (due
to a Reveal query)—a property generally not to be expected
from a (potentially randomized) encryption scheme.

Concerning the contributive identiﬁers, we let the client
(resp. server) on sending (resp. receiving) the ClientHello
and ClientKeyShare messages set cid1 = (CH, CKS) and sub-
sequently, on receiving (resp. sending) the ServerHello and
ServerKeyShare messages, extend it to cid1 = (CH, CKS, SH,
SKS). The other contributive identiﬁers are set to cid2 = sid2
and cid3 = sid3 by each party on sending its respective
Finished message.

As draft-05’s handshake does not involve semi-static keys
(other than the parties’ long-term keys) shared between mul-
tiple sessions, there are no temporary keys in the notation

1205of our model. We can hence ignore NewTempKey queries in
the following analysis.
Theorem 5.1 (Match security of draft-05). The draft-05
full handshake is Match-secure: for any eﬃcient adversary
A we have AdvMatch
s · 1/q · 2−|nonce|, where ns is
the maximum number of sessions, q is the group order, and
|nonce| = 128 is the bitlength of the nonces.

draft-05,A ≤ n2

Match security follows from the way the session identiﬁers
are chosen (to include all unencrypted messages), in partic-
ular guarantees that partnered sessions derive the same key,
authenticity, and contributive identiﬁers. The given security
bound takes into account the probability that three honest
session chose the same nonce and group element. The proof
appears in the full version [15].
Theorem 5.2 (Multi-Stage security of draft-05). The
draft-05
in a
key-independent and stage-1-forward-secret manner concur-
rently providing no authentication, stage-2 unilateral authen-
tication, and stage-2 mutual authentication. Formally, for
any eﬃcient adversary A against the Multi-Stage security
there exist eﬃcient algorithms B1,
. . . , B8 such that
AdvMulti-Stage,D
Sig,B2 +AdvCOLL
H,B3 +
nu · AdvEUF-CMA
PRF,B6 + AdvPRF-sec
PRF,B7 +
AdvPRF-sec
PRF,B8
and nu is the maximum number of users.

draft-05,A ≤ 3ns ·(cid:2)AdvCOLL
Sig,B4 + ns ·(cid:0)AdvDDHG,B5 + AdvPRF-sec,G
(cid:1)(cid:3), where ns is the maximum number of sessions

H,B1 + nu ·AdvEUF-CMA

is Multi-Stage-secure

handshake

full

If we charge the running time of the original security game
to A, then the running times of algorithms B1, . . . ,B8 are
essentially identical to the one of A. This holds as these
adversaries merely simulate A’s original attack with some
additional administrative steps.

Proof sketch. We only sketch the main steps of the proof in
this version here due to space restrictions; see the full version
[15]. The proof uses the common game-hopping techniques
to bound the adversary’s success probability.

First, we consider the case that the adversary makes a
single Test query only. This reduces its advantage, according
to a hybrid argument constructing out of A with multiple
Test queries to an adversary B with a single Test query, by
a factor at most 1/3ns as there are three stages in each of
the ns sessions.7 The hybrid details are omitted here due to
space restrictions; see the full version for details [15].

From now on, we can speak about the session label tested
at stage i. Furthermore the hybrid argument also provides
the number of the test session and therefore label, so we can
assume that we know label in advance.

Our subsequent security analysis separately considers the

three (disjoint) cases that

1. the adversary tests a client session without honest con-

tributive partner in the ﬁrst stage,

2. the adversary tests a server session without honest con-

tributive partner in the ﬁrst stage, and

3. the tested session has an honest contributive partner

in stage 1.

Case A. Test client without partner. First we abort if any
two sessions compute the same value for diﬀerent hash in-
puts, and use a hash-collision challenger with algorithm B1
7We can assume w.l.o.g. that A issues Test queries for a key
only after that key was accepted.

to bound the diﬀerence in advantage. Without honest part-
ner, the client session must have an authenticated peer in
order to allow testing and hence needs to receive a signa-
ture that, however, no honest server will sent (otherwise,
algorithm B2 will have a signature forgery). This leads to a
situation where no client accepts without a partner.
Case B. Test server without partner. This case proceeds
virtually identically to the previous case (in particular with
the same game hops and associated probabilities for hash-
collision algorithm B3 and signature forger B4), this time
assuring partnering due to the CCV message sent.
Case C. Test with partner. We proceed as follows.
Game C.1. We ﬁrst guess the contributively partnered
session label label0 and abort label.cid1 6= label0.cid1, bound-
ing the probability of an abort even by ns.
Game C.2.
In this game we replace the premaster secret
PMS in the tested and partner session with random value
(cid:93)PMS = gz (where z ←$ Zq), using a DDH challenger to re-
place gx, gy, P M S with gu, gv, h bounding the diﬀerence in
the advantage of A between Games C.1 and C.2 by the prob-
ability of algorithm B5 breaking the DDH assumption.
Game C.3.
In this game we replace the handshake master
secret PMS in the tested and partner session with random
value (cid:93)HMS ←$ {0, 1}λ using a PRF challenger with (cid:93)PMS as
the PRF key, bounding the diﬀerence in the advantage of A
between Games C.2 and C.3 by the probability of success of
algorithm B6 breaking the PRF assumption.
Game C.4.
In this game we replace the handshake traf-
ﬁc key tkhs, the resumption master secret RMS and the

master secret MS with uniformly random values gtkhs, fMS,

(cid:93)RMS ←$ {0, 1}λ respectively (the output from a PRF chal-
lenger using (cid:93)HMS as a PRF key), bounding the diﬀerence
in advantage for A between Games C.3 and C.4 with the
success of algorithm B7 in breaking the PRF assumption.
Game C.5.
In this game we replace the application traf-
ﬁc key tkapp with uniformly random values (cid:93)tkapp ←$ {0, 1}λ
as a PRF key), bounding the diﬀerence in advantage for A
between Games C.3 and C.4 with the success of algorithm
B8 in breaking the PRF assumption.

respectively (the output from a PRF challenger using fMS
Note that in game C.5 the session keys gtkhs and (cid:93)tkapp as

well as the resumption master secret (cid:93)RMS are now chosen
independently from the protocol run and uniformly at ran-
dom. As the response to the Test query is now independent
of the test bit btest, A cannot distinguish whether it is given
the real or random key, and combining the various bounds
yields the above security bound.

6. DRAFT-DH HANDSHAKE SECURITY

We now analyze the TLS 1.3 handshake variant as speci-
ﬁed in the draft-dh fork by Rescorla [27]. Session and con-
tributive identiﬁers are deﬁned and set as for draft-05 (in
particular again over the unencrypted messages, for key in-
dependence), except for renaming the ServerCertificate
Verify message to ServerParameters and adding a fourth
stage for the exporter master secret EMS derived with a
unique sid label “EMS”. The semi-static keys gs involved
in draft-dh on the server side are captured as temporary

1206keys in our model, allowing the adversary to decide which
value to use in each session. Exposure of the server’s semi-
static keys s is not considered in our analysis (in particular
they are not revealed by Corrupt). We stress that, while our
Multi-Stage security result below would indeed hold even
under full exposure of of all values s in use (due to its non–
security-critical inﬂuence on the full handshake’s key deriva-
tion), the envisioned 0-RTT keys will critically rely on the
contributing s being secret. Hence, acceptable conditions
for its exposure need to be carefully crafted once the 0-RTT
handshake is fully speciﬁed.
Theorem 6.1 (Match security of draft-dh). The draft-dh
full handshake is Match-secure: for any eﬃcient adversary
A we have AdvMatch
s · 1/q · 2−|nonce|, where ns is
the maximum number of sessions, q is the group order, and
|nonce| = 128 is the bitlength of the nonces.

draft-dh,A ≤ n2

full

(cid:1)(cid:3),

handshake

HKDF.Expand,B10

is Multi-Stage-secure

As all aspects of the draft-dh handshake relevant for
Match security equal those of the draft-05 handshake (aside
from ServerCertificateVerify being renamed to Server
Parameters and the added fourth session identiﬁer which is
distinct due to its “EMS” label), the proof of Theorem 5.1
applies here, too.
Theorem 6.2 (Multi-Stage security of draft-dh). The
draft-dh
in a
key-independent and stage-1-forward-secret manner concur-
rently providing no authentication, stage-2 unilateral authen-
tication, and stage-2 mutual authentication. Formally, for
any eﬃcient adversary A against the Multi-Stage security
. . . , B10 such that
there exist eﬃcient algorithms B1,
AdvMulti-Stage,D
Sig,B2 +AdvCOLL
H,B3 +
nu · AdvEUF-CMA
Sig,B6 + AdvDDHG,B7 +
AdvPRF-sec,G
HKDF.Extract,B8 + AdvPRF-sec
where ns is the maximum number of sessions and nu is the
maximum number of users.
Proof sketch. We again only sketch the main points and
again refer to the full version for details [15].

draft-dh,A ≤ 4ns ·(cid:2)AdvCOLL
Sig,B4 + ns ·(cid:0)AdvCOLL

H,B1 + nu ·AdvEUF-CMA
H,B5 + nu · AdvEUF-CMA
HKDF.Expand,B9 + AdvPRF-sec

First, as in the draft-05 proof we consider a single Test
query only (reducing the advantage by a factor of 4ns due
to four stages by the same hybrid argument) and split the
analysis in the same three cases as for draft-05. Cases A
and B are virtually identical to the respective cases in the
draft-05 proof, aside from renaming the server’s signature
message to ServerParameters.

In the proof steps of the third case, we ﬁrst guess the
contributively partnered session (introducing a factor of ns)
and abort in case of a hash collision (bounded by the colli-
sion resistance of H) or signature forgery on gs and the ses-
sion hash in ServerParameters (bounded by the signature’s
EUF-CMA security). We are then ensured that the chal-
lenger controls all key inputs in the tested session (as well
as its potential partner) and can hence gradually replace the
keys derived within the following steps. First, we replace ES
with a random value (bounded by winning a DDH challenge
encoded in gx, gy, and ES). Second, we choose HMS and
MS at random (bounded by the security of HKDF.Extract
modelled as pseudorandom function using a now uniformly
random ES). Finally, we replace the HKDF.Expand evalu-
ations under HMS and MS, which are now uniformly ran-
dom, by random functions (bounded twice by the security
of HKDF.Expand, also modelled as pseudorandom function).
The Test response is now independent of btest).

7. COMPOSITION

Key exchange protocols are in general of very limited use
when considered on their own. Typically, such protocols are
deployed as a preliminary step followed by a symmetric-key
protocol (e.g., the record layer protocol in case of TLS 1.3)
that makes uses of the established shared secret keys. As
shown in previous work by Brzuska et al. [12] for Bellare–
Rogaway-secure key exchange protocols and by Fischlin and
Günther [17] for Multi-Stage-secure key exchange protocols,
such composition can be proven to be generically secure un-
der certain conditions.

The latter (multi-stage) result however is not yet readily
applicable to the setting of TLS 1.3, as it requires the multi-
stage key exchange protocol to provide—apart from key in-
dependence and forward secrecy, which TLS 1.3 satisﬁes—
mutual authentication and a public session matching. For
authentication, Fischlin and Günther state only informally
how the composition theorem can be adapted to the unilat-
eral authentication case and furthermore do not treat unau-
thenticated key exchange (stages). Public session match-
ing moreover requires that, informally, an eﬃcient algorithm
eavesdropping on the communication between the adversary
and the key exchange security game is able to determine
the partnered sessions in the key exchange game. Since it
is necessary to deﬁne session identiﬁers (and, hence, part-
nering) over the unencrypted messages exchanged in the
TLS 1.3 handshake to achieve key independence (see Sec-
tions 5 and 6), partnering of sessions is no longer publicly
decidable from the (encrypted) key exchange messages.

We therefore need to strengthen the previous composi-
tion result for multi-stage key exchange protocols [17] to
cover, ﬁrst, key exchange sessions and stages which are only
unilaterally authenticated or completely unauthenticated,
and, second, protocols that do not allow for a public session
matching, but for one where session partnering at a certain
stage i is deducible given all stage-j keys for j < i. Jump-
ing ahead, knowledge of earlier stages’ keys can be taken for
granted as such keys can be revealed without impairing the
chances of winning in a key-independent setting, which is
in any case required for composition. In particular, as both
achieve key independence, the analyzed TLS 1.3 handshake
drafts are amenable to our composition result.

As established by Brzuska et al. [12], session matching
is both a necessary and suﬃcient condition for the compo-
sition of Bellare–Rogaway-secure key exchange and generic
symmetric-key protocols. They moreover observe that such
a matching might not be (eﬃciently) computable in certain
cases, e.g., if the key exchange messages are encrypted us-
ing a (publicly) re-randomizable cipher, but partnering is
deﬁned over the unencrypted messages.

The latter restriction becomes particularly relevant in the
multi-stage setting, as key exchange protocols may—and
TLS 1.3 does—use keys of previous stages to encrypt later
stages’ messages. In such cases, session matching based on
the public transcript may not be feasible anymore; this espe-
cially holds for the case of TLS 1.3. We can however leverage
that key independence is already a prerequisite for composi-
tion in the multi-stage setting and hence, when targeting the
keys of a certain stage, revealing the keys of previous stages
is of no harm in the key exchange game. Therefore, we
can strengthen session matching in the multi-stage setting
to obtain also the session keys Kj for all stages j < i when
determining the partnering for stage i. We moreover extend

1207session matching to comprise not only the session identiﬁers
but also the newly introduced contributive identiﬁers.

Due to space limitations, we can only provide a summary
of our composition result here; details appear in the full
version [15]. We ﬁrst extend the syntax of composed games
introduced by Brzuska et al. [12, 11] and extended by Fis-
chlin and Günther [17] for the purpose of formal reason-
ing about composition of (multi-stage) key exchange and
symmetric-key protocols, broadening its scope to encompass
composition with arbitrarily authenticated multi-stage key
exchange stages. Moreover, we strengthen their notion of
session matching to capture non-public partnering.

We can then provide our extended composition result for
multi-stage key exchange: the composition KEi; Π of a multi-
stage key exchange protocol KE with an arbitrary symmetric-
key protocol Π employing the stage-i session keys of KE is
secure if the key exchange is Multi-Stage-secure providing key
independence, stage-j forward secrecy (for j ≤ i), and multi-
stage session matching. Observe that we, in contrast to the
previous composition result [17], do not require a particu-
lar level of authentication, but instead show compositional
security for any concurrent authentication properties AUTH
of KE. We remark that, as captured in the composed game
for multi-stage key exchange, security in the symmetric-key
protocol Π can naturally be guaranteed only in those cases
where the two parties who derived the session key are ei-
ther authenticated or honestly contributed to the derived
key, since otherwise we expect the adversary to know the
key (e.g., by playing the role of an unauthenticated client)
and cannot hope for any security.
Theorem 7.1 (Multi-stage composition). Let KE be a key-
independent stage-j-forward-secret Multi-Stage-secure key
exchange protocol with concurrent authentication properties
AUTH and key distribution D that allows for eﬃcient multi-
stage session matching. Let Π be a secure symmetric-key
protocol w.r.t. some game GΠ with a key generation algo-
rithm that outputs keys with distribution D. Then the com-
position KEi; Π for i ≥ j is secure w.r.t. the composed se-
curity game GKEi;Π. Formally, for any eﬃcient adversary A
against GKEi;Π there exist eﬃcient algorithms B1,B2,B3 such
+ AdvGΠ
that AdvGKEi;Π
Π,B3
where ns is the maximum number of sessions in the key ex-
change game.

KE,B1 + ns · AdvMulti-Stage,D

KEi;Π,A ≤ AdvMatch

KE,B2

The proof is omitted here due to space restrictions;

it
follows the one for multi-stage composition [17], and appears
in the full version [15].

8. PRESHARED-SECRET MODEL

In this section we modify the multi-stage key exchange
(MSKE) framework from Section 4 to model multi-stage
preshared-secret key exchange (MS-PSKE) security for the
purpose of analyzing TLS 1.3 session resumption. TLS 1.3
drafts draft-05 and draft-dh do not conclusively specify
preshared key (PSK) ciphersuites yet, but we expect this
model to be readily applicable to those as well.
In MS-PSKE, each protocol participant is identiﬁed by
some U ∈ U and holds a set of pairwise preshared secrets
pssU,V,k = pssV,U,k (U, V, k indicating the k-th preshared
secret between parties U and V ) from a ﬁxed keyspace,
associated with a unique (public) preshared-secret identi-
ﬁer psidU,V,k = psidV,U,k and a ﬂag CorruptedU,V,k.
(For

example, in TLS session resumption, the preshared-secret
identiﬁer is the session_id value established by the server
in a ﬁeld in the ServerHello message in the original hand-
shake, which the client subsequently sends in its Client
Hello message during the resumption handshake.)

list ListS now contains an additional entry:

Compared to our MSKE model, each entry in the session
• k ∈ N : the index of the preshared secret used in the

protocol run between the parties U and V .

8.1 Adversary Model

Like in the MSKE model of Section 4, we consider an ad-
versary that controls the network communication, allowing
delivery, injection, modiﬁcation and dropping of messages.
We deﬁne a ﬂag lost (initialized to false) that will be set
to true when the adversary makes queries that would triv-
ially break the security experiment. In the preshared secret
case the common key with index k between U and V plays
the role of the long-term keys and can be used to derive
sessions keys in multiple (concurrent) executions, capturing
many parallel session resumption steps in TLS. Corruption
reveals these keys for (U, V, k) and renders all derived keys
as insecure in the non-forward setting we discuss here.

The adversary interacts with the protocol via the Send,
Reveal, and Test queries deﬁned in Section 4.4, inheriting the
key (in-)dependence treatment but only treating the non–
forward-secret setting; our model can easily be extended
to the forward-secret setting. The NewSession and Corrupt
queries are modiﬁed slightly. The new query NewSecret al-
lows the adversary to establish (new) preshared secrets be-
tween two parties.
• NewSecret(U, V ): Creates a preshared secret sampled
uniformly at random from the preshared secret space
and stores it as pssU,V,k = pssV,U,k where k is the next
unused index for U and V . Also creates a unique
new preshared secret identiﬁer psidU,V,k = psidV,U,k
and returns psidU,V,k.
Initializes CorruptedU,V,k and
CorruptedV,U,k as fresh.
• NewSession(U, V, k, role, auth): Creates a new session
for party U with role role and authentication auth hav-
ing V as intended partner and key index k (both V and
k being potentially unspeciﬁed). A party may learn
and set unspeciﬁed values during execution.
• Corrupt(U, V, k): If there exists a session label with par-
ties (U, V ) or (V, U) and key identiﬁer k and some
stage i such that label.testedi = true, then return ⊥.
Otherwise, provide the adversary with pssU,V,k and set
CorruptedU,V,k and CorruptedV,U,k to revealed; in this
case no further queries are allowed to sessions using
pssU,V,k = pssV,U,k.

8.2 Security of Preshared Key Exchange

We adapt the notions for matching and multi-stage key
secrecy to the preshared secret setting, essentially replacing
long-term secret compromise with preshared secret compro-
mise.

As previously, Match security for preshared-secret key ex-
change protocols ensures that session identiﬁers eﬀectively
match the partnered sessions which must share the same
view on their interaction. The Match security conditions
are identical for MS-PSKE and MSKE with the following
exception (condition 4):

12084. sessions are partnered with the intended (authenti-
cated) participant, and for mutual authentication share
the same key index.

Definition 8.1 (Match security). Let KE be a key exchange
protocol and A a PPT adversary interacting with KE via the
queries deﬁned in Section 8.1 in the following game GMatch
KE,A:
Query. The adversary A has access
to the queries

NewSecret, NewSession, Send, Reveal, and Corrupt.
Stop. At some point, the adversary stops with no output.
We say that A wins the game, denoted by GMatch
KE,A = 1, if
at least one of the conditions from Deﬁnition 4.1 (with the
following condition replacing condition 4) hold:
4. There exist two distinct labels label, label0 such that
label.sidi = label0.sidi 6= ⊥ for some stage i ∈ {1, . . . ,
M}, label.authi = label0.authi ∈ {unilateral, mutual},
label.role = initiator, and label0.role = responder, but
label.V 6= label0.U, or label.k 6= label0.k, or, when
label.authi = mutual, label.U 6= label0.V .
We say KE is Match-secure if for all adversaries A the
following advantage is negligible in the security parameter:
AdvMatch
Definition 8.2 (Multi-Stage security). Let KE be a pre-
shared key exchange protocol with (session) key distribu-
tion D, and A a PPT adversary interacting with KE via
the queries deﬁned in Section 8.1 in the following game
Multi-Stage,D
G
KE,A
Setup. Choose the test bit btest ←$ {0, 1} at random, and set
lost ← false.
Query. The adversary has access to the queries NewSecret,
NewSession, Send, Reveal, Corrupt, and Test. Note that
some queries may set lost to true.

KE,A := Pr(cid:2)GMatch

KE,A = 1(cid:3).

:

Guess. At some point, A stops and outputs a guess b.
Finalize. The challenger sets the ‘lost’ ﬂag to lost ← true
if any of the following conditions hold:
1. There exist two (not necessarily distinct) labels label,
label0 and some stage i ∈ {1, . . . , M} such that label.sidi =
label0.sidi, label.stkey,i = revealed, and label0.testedi =
true. (Adversary has tested and revealed the key in a
single session or in two partnered sessions.)
2. The adversary A has issued a Test(label, i) query such
that Corruptedlabel.U,label.V,label.k = revealed.
(Adver-
sary has tested a session key and revealed the pre-
shared secret used in the tested session.)
Multi-Stage,D
KE,A

We say that A wins the game, denoted by G
if b = btest and lost = false.

= 1,

We say KE is Multi-Stage-secure in a key-dependent/key-
independent manner with concurrent authentication proper-
ties AUTH if KE is Match-secure and for all PPT adver-
saries A the following advantage is negligible in the security
parameter: AdvMulti-Stage,D
2.
9. DRAFT-05 RESUMPTION SECURITY

:= Pr(cid:2)G

= 1(cid:3) − 1

Multi-Stage,D
KE,A

KE,A

We now turn towards session resumption and analyze the
resumption handshake as speciﬁed in the draft-05 draft,
denoted as d05-SR. The key schedule for resumption in
draft-dh is not conclusively speciﬁed, so we omit a detailed
analysis; since the main message ﬂow is identical, we expect
its security analysis to closely follow that of draft-05.

Let sid1 = cid1 = (ClientHello, ServerHello, “stage1”)
and sid2 = cid2 = (ClientHello, ServerHello, “stage2”).
By using the preshared-secret in deriving the session keys,
both stages achieve mutual (implicit) authentication.

In TLS session resumption, ClientHello contains the ﬁeld
session_id, which serves as our preshared-secret identiﬁer
psid. This value was previously chosen by the server (the
TLS standard does not specify how) and sent to the client
in the ServerHello message in the original handshake. We
assume that the session_id values are globally unique in
TLS, for example, chosen at random from a suﬃciently large
space to make collisions unlikely, or of the form “server-
name k counter”. We also assume each party U knows the
mapping between preshared-secret identiﬁers psidU,V,k and
the peer identiﬁer V and key index k for all its preshared
secrets.
Theorem 9.1 (Match security of d05-SR). The TLS 1.3
draft-05 session resumption handshake d05-SR is Match-
secure: for any eﬃcient adversary A we have AdvMatch
d05-SR,A ≤
s · 2−|nonce|, where |nonce| = 128 is the bitlength of the
n2
nonces.

Proof sketch. Match security follows from the session iden-
tiﬁers including the nonces and the identiﬁer psid of the
preshared secret, where the latter also maps to the intended
partner. Hence identical session identiﬁers lead to agree-
ment on keys and communication partner, while the random
nonces used can be used to bound the probability of three
honest sessions choosing the same nonce by n2

s·2−|nonce|.

Theorem 9.2 (Multi-Stage security of d05-SR). The
TLS 1.3 draft-05 session resumption handshake d05-SR is
Multi-Stage-secure in a key-independent manner with con-
current authentication types AUTH = {(mutual, mutual)}:
for any eﬃcient adversary A against the Multi-Stage se-
curity there exist eﬃcient algorithms B1, . . . ,B4 such that
AdvMulti-Stage,D
PRF,B3 +
AdvPRF-sec
PRF,B4

(cid:1), where ns is the maximum number of sessions.

d05-SR,A ≤ 2ns ·(cid:0)AdvCOLL

PRF,B2 + AdvPRF-sec

H,B1 + AdvPRF-sec

Proof sketch. As in the main draft-05 Multi-Stage proof
(Theorem 5.2), considering a single Test query introduces
a factor of 1/2ns. We then proceed by ﬁrst ruling out col-
lisions under H (due to its collision resistance) before we
gradually replace evaluations of PRF by random functions,
bounded three times by the PRF security: Firstly, in all
sessions sharing the tested preshared secret pssU,V,k (includ-
ing the partner session), we replace the handshake master
secret value HMS with a random value (leveraging that the
sent psid uniquely identiﬁes the secret which must be uncor-
rupted and hence uniformly random for A). We then replace
evaluations under, secondly, HMS and, thirdly, MS resulting
in tkhs and tkapp to be chosen uniformly at random and the
Test response being independent of btest.

10. CONCLUSION

Our successful analysis of both draft-05 and draft-dh
is encouraging: both TLS 1.3 candidate handshake designs
can be shown to be cryptographically sound, even when re-
stricting to standard cryptographic assumptions only. The
analysis also reveals some points where the security aspects
allows for ﬂexibility and various options without endanger-
ing security, as pointed out in Section 3.

From a theoretical viewpoint, our “cascading” approach
to treat session resumption not as part of the key exchange
protocol, but as another symmetric-key protocol which is
composed with the main handshake protocol, is useful to

1209tame the complexity of such analyses (here and in general).
Working out the details of this approach to get a full-ﬂedged
compositional analysis of the TLS 1.3 candidates is a worth-
while direction. Still, our results already conﬁrm the sound
design of the handshake protocols, as we have shown that
the session keys can be safely used in the channel protocol
and session resumption, and that session resumption is itself
a strongly secure key exchange protocol.

Acknowledgments
We thank the anonymous reviewers for valuable comments.
Marc Fischlin is supported by Heisenberg grant Fi 940/3-2
of the German Research Foundation (DFG). This work has
been co-funded by the DFG as part of project S4 within the
CRC 1119 CROSSING. Benjamin Dowling and Douglas Ste-
bila are supported by Australian Research Council (ARC)
Discovery Project grant DP130104304.

11. REFERENCES
[1] D. Adrian, K. Bhargavan, Z. Durumeric, P. Gaudry,

M. Green, J. A. Halderman, N. Heninger, D. Springall,
E. Thomé, L. Valenta, B. VanderSloot, E. Wustrow,
S. Zanella-Béguelin, and P. Zimmermann. Imperfect
forward secrecy: How Diﬃe-Hellman fails in practice.
In ACM CCS 15, 2015.

[2] N. AlFardan, D. J. Bernstein, K. G. Paterson,

B. Poettering, and J. C. N. Schuldt. On the security of
RC4 in TLS. In Proc. 22nd USENIX Security
Symposium, pages 305–320, 2013.

[3] N. J. AlFardan and K. G. Paterson. Lucky thirteen:

Breaking the TLS and DTLS record protocols. In
2013 IEEE Symposium on Security and Privacy, pages
526–540, 2013.

[4] J. Altman, N. Williams, and L. Zhu. Channel Bindings

for TLS. RFC 5929 (Proposed Standard), 2010.

[5] C. Badertscher, C. Matt, U. Maurer, P. Rogaway, and

B. Tackmann. Augmented secure channels and the
goal of the TLS 1.3 record layer. Cryptology ePrint
Archive, Report 2015/394, 2015.
http://eprint.iacr.org/2015/394.

[6] M. Bellare and P. Rogaway. Entity authentication and
key distribution. In CRYPTO’93, pages 232–249, 1994.

[7] B. Beurdouche, K. Bhargavan, A. Delignat-Levaud,

C. Fournet, M. Kohlweiss, A. Pironti, P.-Y. Strub, and
J. K. Zinzindohoue. A messy state of the union:
Taming the composite state machines of TLS. In Proc.
IEEE Symp. on Security & Privacy (S&P) 2015,
pages 535–552, 2015.

[8] K. Bhargavan, A. Delignat-Lavaud, C. Fournet,

A. Pironti, and P.-Y. Strub. Triple handshakes and
cookie cutters: Breaking and ﬁxing authentication
over TLS. In 2014 IEEE Symposium on Security and
Privacy, pages 98–113, 2014.

[9] K. Bhargavan, C. Fournet, M. Kohlweiss, A. Pironti,

and P.-Y. Strub. Implementing TLS with veriﬁed
cryptographic security. In 2013 IEEE Symposium on
Security and Privacy, pages 445–459, 2013.

[10] K. Bhargavan, C. Fournet, M. Kohlweiss, A. Pironti,

P.-Y. Strub, and S. Zanella Béguelin. Proving the TLS
handshake secure (as it is). In CRYPTO 2014, Part
II, pages 235–255, 2014.

[15] B. Dowling, M. Fischlin, F. Günther, and D. Stebila.
A cryptographic analysis of the TLS 1.3 handshake
protocol candidates (full version). Cryptology ePrint
Archive, 2015. http://eprint.iacr.org/.

[16] T. Duong. BEAST. http:

//vnhacker.blogspot.com.au/2011/09/beast.html,
2011.

[17] M. Fischlin and F. Günther. Multi-stage key exchange
and the case of Google’s QUIC protocol. In ACM CCS
14, pages 1193–1204, 2014.

[18] C. Fournet, M. Kohlweiss, and P.-Y. Strub. Modular
code-based cryptographic veriﬁcation. In ACM CCS
11, pages 341–350, 2011.

[19] T. Jager, F. Kohlar, S. Schäge, and J. Schwenk. On
the security of TLS-DHE in the standard model. In
CRYPTO 2012, pages 273–293, 2012.

[20] S. Josefsson. Channel bindings for TLS based on the

PRF. https://tools.ietf.org/html/
draft-josefsson-sasl-tls-cb-03, 2015.

[11] C. Brzuska. On the Foundations of Key Exchange.

PhD thesis, Technische Universität Darmstadt,
Darmstadt, Germany, 2013.
http://tuprints.ulb.tu-darmstadt.de/3414/.
[12] C. Brzuska, M. Fischlin, B. Warinschi, and S. C.
Williams. Composability of Bellare-Rogaway key
exchange protocols. In ACM CCS 11, pages 51–62,
2011.

[13] R. Canetti and H. Krawczyk. Security analysis of
IKE’s signature-based key-exchange protocol. In
CRYPTO 2002, pages 143–161, 2002.
http://eprint.iacr.org/2002/120/.

[14] Codenomicon. The Heartbleed bug.

http://heartbleed.com, 2014.

[21] M. Kohlweiss, U. Maurer, C. Onete, B. Tackmann,
and D. Venturi. (de-)constructing TLS. Cryptology
ePrint Archive, Report 2014/020, 2014.
http://eprint.iacr.org/2014/020.

[22] H. Krawczyk. Cryptographic extraction and key

derivation: The HKDF scheme. In CRYPTO 2010,
pages 631–648, 2010.

[23] H. Krawczyk, K. G. Paterson, and H. Wee. On the
security of the TLS protocol: A systematic analysis.
In CRYPTO 2013, Part I, pages 429–448, 2013.

[24] B. Möller, T. Duong, and K. Kotowicz. This

POODLE bites: Exploiting the SSL 3.0 fallback.
https://www.openssl.org/~bodo/ssl-poodle.pdf,
2014.

[25] E. Rescorla. The Transport Layer Security (TLS)

Protocol Version 1.3 – draft-ietf-tls-tls13-05. https:
//tools.ietf.org/html/draft-ietf-tls-tls13-05,
2015.

[26] E. Rescorla. The Transport Layer Security (TLS)

Protocol Version 1.3 – draft-ietf-tls-tls13-07. https:
//tools.ietf.org/html/draft-ietf-tls-tls13-07,
2015.

[27] E. Rescorla. The Transport Layer Security (TLS)
Protocol Version 1.3 – draft-ietf-tls-tls13-dh-based.
https://github.com/ekr/tls13-spec/blob/ietf92_
materials/draft-ietf-tls-tls13-dh-based.txt,
2015.

1210