2016 IEEE Symposium on Security and Privacy
2016 IEEE Symposium on Security and Privacy

Downgrade Resilience in Key-Exchange Protocols

Karthikeyan Bhargavan∗, Christina Brzuska†, C´edric Fournet‡, Matthew Green§,

Markulf Kohlweiss‡ and Santiago Zanella-B´eguelin‡

∗Inria Paris-Rocquencourt, Email: karthikeyan.bhargavan@inria.fr

†Hamburg University of Technology, Email: brzuska@tuhh.de

‡Microsoft Research, Email: {fournet,markulf,santiago}@microsoft.com

§Johns Hopkins University, Email: mgreen@cs.jhu.de

Abstract—Key-exchange protocols such as TLS, SSH, IPsec,
and ZRTP are highly conﬁgurable, with typical deployments
supporting multiple protocol versions, cryptographic algorithms
and parameters. In the ﬁrst messages of the protocol, the peers
negotiate one speciﬁc combination: the protocol mode, based on
their local conﬁgurations. With few notable exceptions, most
cryptographic analyses of conﬁgurable protocols consider a single
mode at a time. In contrast, downgrade attacks, where a network
adversary forces peers to use a mode weaker than the one they
would normally negotiate, are a recurrent problem in practice.
How to support conﬁgurability while at the same time guar-
anteeing the preferred mode is negotiated? We set to answer this
question by designing a formal framework to study downgrade
resilience and its relation to other security properties of key-
exchange protocols. First, we study the causes of downgrade
attacks by dissecting and classifying known and novel attacks
against widely used protocols. Second, we survey what is known
about the downgrade resilience of existing standards. Third, we
combine these ﬁndings to deﬁne downgrade security, and analyze
the conditions under which several protocols achieve it. Finally,
we discuss patterns that guarantee downgrade security by design,
and explain how to use them to strengthen the security of existing
protocols, including a newly proposed draft of TLS 1.3.

I. INTRODUCTION

Popular protocols such as TLS, SSH and IPSec as used
in practice do not ﬁt a simple textbook deﬁnition of a key-
exchange protocol, where the state machine, cryptographic
algorithms, parameters and message formats are all ﬁxed in
advance. Rather, these modern protocols feature cryptographic
agility, which provides for conﬁgurable selection of multiple
protocol and cipher modes, so that the key exchange actually
executed between two peers depends on a negotiation phase
embedded in the exchange.

Agility has proven important in securing real-world protocol
implementations. For example, in the wake of recent vulnera-
bility disclosures in TLS [2, 3, 4, 10, 23], network operators
reacted by updating client and server conﬁgurations to disable
weak algorithms and protocol versions. Moreover, experience
shows that when sufﬁcient agility is not present within a
single protocol, application developers construct their own
ad hoc negotiation mechanisms, for example, by sequentially
attempting connections with different versions of a protocol
and “falling back” to the best one supported [39].

Unfortunately, support for algorithm agility opens up op-
portunities for downgrade attacks, where an active network
adversary interferes with the negotiation, causing honest peers
to complete a key exchange, albeit using a mode that is weaker

A

B

[G1, . . . , Gn]

Gi, gy

(km, ks) = kdf(gxy)

A, gx, sign(sk A, (Gi, gy, gx)), mac(km, A)

(km, ks) = kdf(gxy)

B, sign(sk B, (Gi, gx, gy)), mac(km, B)

Fig. 1: SIGMA-N: Basic SIGMA [30] with group negotiation

than the one they would have used on their own. Such attacks
have been identiﬁed in a number of protocols, most famously
in the early versions of the SSL protocol [43] and even in
recent versions of TLS [2, 39].

Surprisingly, there has been relatively little formal work
around the security of negotiation in modern cryptographic
protocols. Several recent works formally prove the security of
different aspects of TLS and SSH. Some [25, 31] only model
a single mode at a time. Some [12, 13] do model negotiation
of weak algorithms, but do not guarantee negotiation of the
preferred mode. Some others [9, 21] consider only interactions
where both parties have secure conﬁgurations. For this reasons,
all of these works overlook certain downgrade attacks that
occur when one party supports an insecure mode.

This is concerning because negotiation has proven to be
fertile ground for attacks, e.g. [2, 10, 43], and because recent
Internet-wide scans have revealed the prevalence of hosts
supporting insecure protocol modes [2, 5, 42].

In this work we aim to address this situation by system-
atically investigating the problem of downgrade resilience in
cryptographic protocols.

A. Motivating example

We begin with a simple motivating example: we adapt
the SIGMA protocol of Krawczyk [30] by adding a na¨ıve
extension intended to negotiate Difﬁe-Hellman groups: In the
ﬁrst message, A proposes a list of groups it supports; in the
second message, B indicates which of these groups should be

2375-1207/16 $31.00 © 2016 IEEE
© 2016, Karthikeyan Bhargavan. Under license to IEEE.
DOI 10.1109/SP.2016.37
DOI 10.1109/SP.2016.37

506
506

A

MitM

B

[Gstrong , Gweak ]

Gweak , gy

[Gweak ]

To prevent an attack on a particular protocol mode,
it is sufﬁcient to deactivate the conﬁgurations that
lead to its negotiation.

(km, ks) = kdf(gxy)

A, gx, sign(sk A, (Gweak , gy, gx)), mac(km, A)

B, sign(sk B, (Gweak , gx, gy)), mac(km, B)

(km, ks) = kdf(gxy)

y = dlog(Gweak , gy)
(km, ks) = kdf(gxy)

Fig. 2: Man-in-the-Middle downgrade attack on SIGMA-N

used in the exchange. The modiﬁed protocol appears in Fig. 1.
The goal of the protocol is to compute session keys (km, ks).
Under normal circumstances, the protocol succeeds in cor-
rectly selecting a group. However, consider a scenario where
both participants support both strong and weak groups. B’s
signature authenticates the chosen group, but not A’s proposal.
This leads to a downgrade attack (see Fig. 2) similar to the
Logjam attack on TLS [2], where an attacker can break the
session keys at leisure and compromise the connection.

Protocol designers have adopted a number of techniques
to prevent such downgrade attacks. Based on a review of
deployed protocols, we identify three common patterns. In
the ﬁrst, exempliﬁed by SSH, protocol designers assume the
existence of strong signing keys shared between the two
parties, and use these keys to authenticate all negotiation
messages, either at the time they are transmitted, or after
the fact. In a second pattern, exempliﬁed by TLS, designers
transmit unauthenticated protocol messages, perform a key
exchange, and then subsequently use the resulting shared
secrets to retroactively authenticate the negotiation messages.
The ﬁnal approach relies on whitelisting certain modes, and is
best exempliﬁed by Google’s TLS False Start proposal [32],
which is being codiﬁed as part of TLS 1.3 [40].

Each approach has various advantages and disadvantages.
The devil is often in the details: each protocol is sensitive
to the precise nature of the implementation, e.g. the inputs of
authentication functions, or the speciﬁcs of what a valid mode
is for whitelisting. As a concrete example, modern versions of
TLS-DHE fail to sign the identity of the ciphersuite chosen by
a server, leading to cross-protocol attacks [2, 35]. Similarly,
TLS False Start relies solely on ciphersuite identiﬁer (rather
than more detailed information such as key strength) in its
selection of which modes to whitelist, which converts the
online attack of Adrian et al. [2] into an ofﬂine one.

B. Overview of our approach

We give a deﬁnition and a theorem for downgrade resilience
that model the following intuitive and desirable property for
deployed key-exchange protocols:

507507

Our work builds on the deﬁnitions of Bhargavan et al. [13],
used to model security in MITLS, a reference implementation
of the TLS standard. A fundamental difference between these
deﬁnitions and previous work is that they attempt to model
entire deployed protocols. This requires a deﬁnition of security
cognizant of the fact that some aspects (modes) of the protocol
may be insecure. To deal with this, the deﬁnitions of [13]
incorporate predicates determining modes that are expected
to provide security guarantees, e.g., key indistinguishability.
This approach allows to deﬁne security when secure modes
are chosen, yet tolerates the existence of insecure modes.

One limitation of these deﬁnitions is that they do not take
into account how modes are chosen. In a protocol secure in
the MITLS framework, two parties under adversarial inﬂuence
may arrive at an insecure mode even when otherwise they
would use a secure mode. In theory each party can detect
and react to the negotiation of an insecure mode, e.g., by
terminating the protocol execution. Nonetheless,
this does
not guarantee that the preferred common mode is selected.
Our solution is to incorporate downgrade resilience in our
security deﬁnitions, to ensure that an adversary cannot force
the selection of another mode than the preferred one.

We consider protocols between an Initiator and a Responder.
These two parties each have their own local static conﬁgura-
tions, expressing their preferences and their intent to negoti-
ate a shared protocol mode. To deﬁne downgrade resilience
formally, we introduce a downgrade protection predicate DP
that operates on pairs of conﬁgurations (analogous to MITLS
predicates on modes), and that identiﬁes pairs of conﬁgurations
from which we expect downgrade resilience. We also introduce
a function Nego that maps two opposite-role conﬁgurations to
the protocol mode that should be negotiated in the absence
of active adversaries. Intuitively, our deﬁnition says that a
protocol is downgrade secure if two peers starting from conﬁg-
urations satisfying DP can only negotiate the mode determined
by Nego, even in the presence of an active adversary.

By way of example, a speciﬁc instantiation of Nego for the
TLS protocol might determine that two peer conﬁgurations
should result in the negotiation of TLS 1.2 in combination with
a ciphersuite such as DHE-RSA-AES256-GCM-SHA384
with a 2048-bit Difﬁe-Hellman modulus. However, if a server
supports an insecure mode, such as a DHE-EXPORT cipher-
suite, an adversary might force the pair to downgrade to this
mode [2]. This shows that without additional countermeasures,
TLS 1.2 does not meet our deﬁnition. On the other hand,
protocols with just one possible mode are trivially secure. The
challenge we address in this paper is to consider agile proto-
cols that support multiple modes (e.g., ciphersuites, versions).
To apply our deﬁnition to real-world protocols, we adopt
the following approach. Rather than analyzing a protocol in
its entirety, we ﬁrst extract a core negotiation sub-protocol,
which captures the main downgrade-protection mechanisms
of the larger protocol. We next prove that this sub-protocol

in the sense that an
is complete for downgrade security,
adversary that succeeds in downgrading the full protocol will
also succeed in downgrading the sub-protocol.

This technique of lifting security from the sub-protocol to
the main protocol was previously employed by Bergsma et al.
[9] to prove multi-ciphersuite security.

In our analysis we manually extract sub-protocols that cover
speciﬁc families of modes, e.g., signature-based modes or pre-
shared key modes, while some of our attacks are cross-family
attacks. Proving the absence of cross-family attacks requires
either to consider more complex sub-protocols that encompass
several families, or to study families independently and prove
a composition theorem similar to that of Bergsma et al. [9].
Our work is a stepping stone in this direction, and our results
are readily applicable in situations where peer conﬁgurations
are from the same family.

C. Summary of our results

Our primary contribution is a novel downgrade security def-
inition for key-exchange protocols. We devise a methodology
to analyze the downgrade security of a complex protocol by
abstracting away irrelevant details and studying only the core
negotiation sub-protocol.

We demonstrate the relevance of our deﬁnition and the
applicability of our methodology by analyzing the downgrade
security of several exemplary real-world protocols, namely
TLS, SSH, IPSec and ZRTP. We do so by taking in their
standard speciﬁcations and extracting appropriate core ne-
gotiation sub-protocols. Our analysis identiﬁes known and
novel attacks on certain conﬁgurations, as well as sufﬁcient
conditions under which these protocols achieve downgrade
security. These conditions inform practitioners as to how to
restrict host conﬁgurations to best avoid downgrade attacks.

The following are concrete novel contributions:
• We describe new downgrade vulnerabilities on IKEv2
and ZRTP. These vulnerabilities are present in the protocol
standards, but can be avoided by carefully conﬁgured imple-
mentations.

• We conﬁrm the conclusion evidenced by recent attacks:
TLS versions up to 1.2 are not generally downgrade secure.
• We prove a downgrade security theorem for SSHv2
with publickey client authentication that is stronger than
previous results. This stems from both peers signing all the
messages that determine the protocol mode.

• We show that although TLS 1.3 Draft 10 [40] includes
a mandatory server-side message for signing the handshake
transcript, this does not prevent downgrades to earlier versions
of TLS or non-preferred groups. Informed by this analysis, we
deﬁne and prove two new downgrade protection mechanisms.
The concrete countermeasures, designed jointly with the core
TLS 1.3 working group, have been included in Draft 11.

D. Outline of the paper

In §II we introduce the terminology used throughout and
we provide a primer on security deﬁnitions for key exchange
protocols. We formally deﬁne downgrade resilience in §III.

508508

In §IV through §VII we apply these deﬁnitions to analyze the
security of SSH, IPSec IKE, ZRTP and TLS. We survey related
work in §VIII and conclude in §IX. The full version [14]
includes additional discussions and proofs.

II. MODELING MULTI-MODE KEY-EXCHANGES

Popular key-exchange models [9, 13, 22] focus mainly
on entity authentication and key-indistinguishability [8]. Our
focus lies on considering multi-mode protocols and incorpo-
rating the negotiation of the mode into the security model.

initial conﬁguration (including the role);
unique identiﬁer of the session;
negotiated mode (including long-term identities);
session key;

A key exchange protocol Π is a two-party protocol with an
initiator role I and a responder role R (sometimes called client
and server). The adversary interacts with multiple sessions of
the protocol. Each session π maintains variables in a local
state and makes assignments to them before sending or after
receiving a message. We write π.x for the value of variable x
in session π. We will consider the following variables:
π.cfg
π.uid
π.mode
π.key
π.complete ﬂag set when the session completes successfully.
Variables are initialized to ⊥ and each session assigns a
value to each variable only once, typically in the order given
above. The conﬁguration variable π.cfg is assigned when a
session is created and contains other variables, including one
for the session role. We use π.role as shorthand for π.cfg.role
and let I = R, R = I.
An adversary interacts with sessions via queries to oracles.
A query π ← Init(cfg) initializes a session. Recall that cfg
determines role and furthermore, in the setting where we have
symmetric or public keys, cfg will contain handles to those
keys. A query mout ← Send(π, min) sends a message min
to session π, which processes it to update its local state and
output an ongoing message mout. A query k ← Reveal(π)
reveals the session key of π, i.e., returns the value of π.key.
There are several variants of this setting for handling long-term
keys and other authentication mechanisms as well as corrup-
tion settings, and each variant requires different variables and
oracles. As these settings are mostly standard and orthogonal
to our deﬁnition, we leave those details unspeciﬁed for now
and get back to them in Section IV. Note that our deﬁnitions
only become complete once we add the speciﬁcs of long-term
keys or other authentication mechanisms.

A. Unique identiﬁers and partnering

The goal of a key exchange protocol is to establish sessions
between two different parties so that they compute the same
key and agree on the algorithms and authentication setting. We
say that two sessions match when they derive the same session
key [29]. For deﬁning downgrade resilience, we rely on the
weaker notion of partnering, based on unique identiﬁers—at
most two sessions may assign the same value to uid.
(cid:2) are partnered if
(cid:2)
.uid = π.uid.
π
A session π is unpartnered when there is no such π

Deﬁnition 1 (Partnering): Sessions π and π
.role = π.role (they have opposite roles) and π

(cid:2).

(cid:2)

For example, in TLS, a suitable value for uid is the pair of
nonces sent by the client and server in their hello messages. To
guarantee partnering upon completion, a protocol needs to pro-
tect the messages that inﬂuence uid against man-in-the-middle
attacks. As some conﬁgurations—in particular those where
entity authentication is optional—do not protect against man-
in-the-middle attacks, our deﬁnition depends on a predicate PS
that indicates conﬁgurations that provide Partnering Security.
Typically, these conﬁgurations demand peer authentication.
Deﬁnition 2 (Partnering security): The advantage of adver-
sary A against the partnering security of Π, Advpartnering
(A),
is the probability that, when A interacts with protocol Π, there
is an unpartnered session π such that π.complete = true and
PS(π.cfg) holds.

Π, PS

That is, partnering security requires that sessions that com-
plete with a protected conﬁguration have at least one partner
session that assigns the same value to uid.

B. Multi-mode authentication

We now deﬁne authentication for protocols in which long-
term identiﬁers (e.g. public keys or pre-shared key identiﬁers)
of peers are themselves negotiated. This is also known as
the post-speciﬁed peer setting [18] and the type of authen-
tication (e.g. mutual or bilateral) is determined as part of
the negotiation [22]. We incorporate entity identiﬁers eidr
for r ∈ {I, R} and authentication type, together with the
negotiated cryptographic algorithms in the mode variable. We
write eidr as shorthand for mode.eidr. As algorithms can
be weak, keys can be compromised, and authentication can
be unilateral, whether participants get guarantees depends
crucially on the outcome of negotiation.

While the predicate PS for partnering is deﬁned over con-
ﬁgurations ﬁxed upon creation of a session, our authentication
deﬁnition depends on a predicate Auth(mode, r), which holds
when mode is expected to authenticate role r. Authentication
as deﬁned by Lowe [33] guarantees agreement on the variables
of authenticated peers.
(cid:2) on x
.x. For agreement on a set X we require that
(cid:2) on all x ∈ X.

Deﬁnition 3 (Agreement): A session π agrees with π

(cid:2)
when π.x = π
π agrees with π

When deﬁning downgrade resilience, we consider a weaker
notion that guarantees equality once both peers have assigned
a value to x.
Deﬁnition 4 (Pre-agreement): A session π pre-agrees with
(cid:2) on x when π.x = π
We consider authentication with agreement. Authentication

.x = ⊥.

π

(cid:2)

(cid:2)

.x or π

with pre-agreement can be deﬁned analogously.

The advantage Advmm-auth

Deﬁnition 5 (Multi-mode authentication): A session π com-
pletes maliciously for X when π.complete = true but there is
(cid:2) matching π that agrees with π on X.
no partnered session π
Π, Auth, X (A) of an adversary A against
the multi-mode authentication security with agreement on X
of protocol Π is the probability that, when A interacts with
protocol Π, a session π completes maliciously for X and
Auth(π.mode, π.role) holds.

Let r = π.role. Note that Auth(π.mode, r) typically includes
the requirement that the long term key π.eidr of the peer is
honest. If, as in SIGMA-N, the mode is secure against key-
compromise impersonation attacks [26] then π.eidr need not
be honest. In addition, the predicate Auth models concurrent
mixed-mode authentication. A protocol mode provides mutual-
authentication if Auth(π.mode, r) holds regardless of r. It
provides server-only authentication if only Auth(π.mode, I)
holds, i.e., only clients get guarantees.

Observe that the authentication mode is itself negotiated.
The same long-term keys eidr routinely appear in different
modes and protocols may assign the same key in different
modes. Agreement on mode and other variables may be
critical for higher-level protocols; mode may include record
algorithms and using the same keys with different algorithms
may lead to agile security problems. In any case it contains the
entity identiﬁers that should be in agreement to avoid identity
confusion attacks [20]. As we will see, protocols need to have
sufﬁcient downgrade resilience to guarantee that the preferred
authentication mode is negotiated.

C. Key-indistinguishability and user privacy

Classical deﬁnitions of key indistinguishability are param-
eterized by a freshness predicate Fresh that determines the
sessions with uncompromised keys. Key indistinguishability
requires that for fresh sessions, an adversary cannot tell apart
the real session key from a random one.
For SIGMA-N, a suitable Fresh predicate holds for π when
the group in π.mode is strong, A neither queried Reveal(π)
(cid:2), and π.eid¯r is honest.
nor Reveal(π
Identity protection and deniability are other orthogonal
security requirements of key-exchange protocols. Although we
do not formally present them here, we note that many design
decisions in real-world key-exchange protocols are motivated
by user privacy in addition to the more common security goals
of key indistinguishability and entity authentication.

(cid:2)) for a matching session π

D. Instantiating our model for SIGMA-N

Consider the SIGMA-N protocol of Fig. 1. The conﬁg-
urations should include sufﬁcient detail
to determine the
negotiated mode. We thus include the acceptable groups and
a function PK from identities to peer public keys. The latter
would normally be implemented by looking up the public key
of the peer in a certiﬁcate store. We thus have variables

(cid:2)

cfg

uid
mode

(cid:2)
=

(I, A, pkA, PK, groups)
(R, B, pkB, PK, groups)

for initiator I
for responder R

(cid:2)
= (gx, gy)
(cid:2)
= (Gi, pkA, pkB) .
III. DEFINING DOWNGRADE RESILIENCE

Downgrade resilience is motivated by protocols such as
SIGMA-N that despite satisfying the deﬁnitions above remain
vulnerable to practical attacks. We model the desired outcome
of negotiation using a function Nego that maps two conﬁgu-
rations with opposite roles to the protocol mode negotiated (if

509509

any) in the absence of active adversaries. Formally, if a session
(cid:2) completes, it must be the
π with role r talking to a session π
(cid:2)
case that π.mode = Negor(π.cfg, π
.cfg), where Negor is an
abbreviation deﬁned by case:

(cid:2)

Negor(cfgr, cfg¯r)

(cid:2)
=

Nego(cfgr, cfg¯r) when r = I
Nego(cfg¯r, cfgr) when r = R .

Deﬁnition 6 (Negotiation correctness): The protocol nego-
tiation is correct if, whenever a session π with role r and
conﬁguration cfgr completes, there exists a peer conﬁguration
cfg¯r such that π.mode = Negor(cfgr, cfg¯r).

This property captures that, if a protocol mode is disabled
by a conﬁguration, then it cannot be negotiated. Although we
expect this basic property to hold unconditionally, implemen-
tation errors may break it. For instance, the FREAK attack
stems from TLS clients that do not offer export ciphersuites
but still accept export-grade RSA keys. An implementation
of SIGMA-N in which an initiator accepts groups it did not
propose would also fail to satisfy negotiation correctness.

Downgrade security complements negotiation correctness.
Informally, a protocol is downgrade secure when two sessions
of opposite roles with the same unique identiﬁer uid always
negotiate the mode prescribed by their conﬁgurations. Hence,
downgrade security concerns situations in which one partic-
ipant can save the other, even if the latter supports broken
cryptography. However, we have to assume that at least some
of the mechanisms of the protocol (e.g., its signature modes)
are strong enough. Conversely,
if both participants enable
(among others) a mode that is entirely insecure, then there
is no cryptographically sound way to prevent an attacker from
downgrading their connection.

Our deﬁnition is parameterized by a Downgrade Protection

(cid:2)

(cid:2)

.cfg).

(cid:2) such that DP(π.cfg, π
(π.cfg, π

predicate DP on pairs of conﬁgurations.
DP(cfgr, cfg¯r) indicates the pairs of conﬁgurations from
which we expect downgrade protection; it is not necessarily
symmetric. By convention, cfgr is the local conﬁguration,
cfg¯r is the peer conﬁguration, and when DP(cfgr, cfg¯r)
holds, we expect that the local session is protected.
Deﬁnition 7 (Downgrade security): A session π is down-
graded when π.complete = true and there is a partnered
.cfg) holds, but π.mode (cid:5)=
session π
Negoπ.role
Π, DP, X (A) of A against downgrade
security with pre-agreement on X is the probability that, when
A terminates after interacting with Π, there is a session π that
either is downgraded or does not pre-agree with a partnered
(A) when X = {}.
session π
Note that only partnered sessions get downgrade protection
guarantees, so our deﬁnition is meaningful only for protocols
for which partnering security holds. Thus, for role r,
if
DP(cfgr, cfg¯r) holds for any peer conﬁguration cfg¯r, we need
that PS(cfgr) holds; we write this concisely as DP ⊆r PS, and
observe that this property holds in our case studies.

(cid:2) on X. We write Advdowngrade

The advantage Advdowngrade

Π, DP

Agreement on mode (or some of its parts) is desirable but
not essential for downgrade protection. A downgrade attack

510510

(cid:2) does not assign a mode,

(cid:2) assign
means that one or both partnered sessions π and π
a mode weaker than the prescribed one. In particular, if the
then it has not been
session π
downgraded. Pre-agreement ensures that if the partner session
(cid:2) of π assigns some mode, then this mode coincides with
π
the mode of π. Conversely, for conﬁgurations cfgr and cfg¯r
for which both DP(cfgr, cfg¯r) and DP(cfg¯r, cfgr) hold, we do
have downgrade protection with pre-agreement on mode.

The DP predicate for downgrade protection plays a role
it depends only
similar to Auth for authentication, except
on static conﬁgurations and on the honesty of long-term
credentials. This reﬂects that downgrade protection should
depend only on the inputs to the negotiation, and not the
negotiation itself, which may be inﬂuenced by an adversary.
Our formal conﬁgurations are session-speciﬁc, and do not
necessarily coincide with concrete conﬁgurations in real-
world protocol deployments. In particular, each conﬁguration
contains credentials only for the intended peer (e.g. cached
certiﬁcates, key ﬁngerprints). As an example, our conﬁgura-
tions for TLS include the authentication settings of the session:
the client’s conﬁguration expresses its intent to communicate
with a particular server, who may support multiple negotiable
certiﬁcates with different long-term keys, for instance, using
the server name indication extension [15].
Ideally, DP(π.cfg,·) would hold regardless of the second
conﬁguration. Anticipating on our results, this is the case for
SSH, where DP is deﬁned as follows: the conﬁguration of π
must require authentication of its peer, all peer keys accepted
by π must be honest, and all signature algorithms must be
.cfg has on the
(agile) strong. In this case the only inﬂuence π
(cid:2)
downgrade protection of π is in the level of agility, i.e. will π
use its long-term keys also in other protocol and cipher modes?
However, this is not the case e.g. for TLS 1.2 clients, which do
not get downgrade protection with servers that support weak
Difﬁe-Hellman groups.

(cid:2)

A. Downgrade resilience of SIGMA-N

Recall that SIGMA-N conﬁgurations are tuples of the form
(r, ID, pkID, PK, groups) where PK is a function mapping
identities to public keys. The negotiation function describes
the correct mode upon completion. Given a function nego
that selects the preferred common group, Nego(cfgI , cfgR) is
deﬁned as

(nego(cfgI .groups, cfgR.groups), cfgI .pkA, cfgR.pkB)

when cfgI .pk A = cfgR.PK(A), and ⊥ otherwise.

For such a Nego function, DP can hold only for pairs of
conﬁgurations with at most one group in common, as shown
by the attack in Fig. 2.

B. Downgrade resilience and multi-mode security

Protocol analysts often consider protocols restricted to spe-
ciﬁc modes and conﬁgurations. For instance it is common
practice to analyze individual protocol modes in isolation.
Similarly we can restrict the universe of conﬁgurations of a
protocol to those that provide downgrade protection. Consider

sets of conﬁgurations CI and CR picked by initiators and
responders respectively. We consider restricted protocols in
which sessions abort whenever they are initialized with a
conﬁguration outside of the set CI ∪ CR.

Deﬁnition 8 (Protected conﬁgurations): Let DP be a down-
grade protection predicate. A pair of sets of conﬁgurations
(Cr, C¯r) gives downgrade protection to role r if Cr×C¯r ⊆ DP.
The following theorem expresses that when downgrade se-
curity holds, only the security of modes that can be negotiated
in the absence of an adversary matters. That is, if peers support
insecure modes, but with such a low priority that they never
negotiate them on their own, then these modes do not affect
security in the presence of an adversary.

Theorem 1 (Downgrade resilience and multi-mode security):
Let Π be a protocol, (Cr, C¯r) sets of conﬁgurations, DP a
downgrade protection predicate, and N = {Negor(cfgr, cfg¯r) |
cfgr, cfg¯r ∈ Cr × C¯r} the modes negotiable without adversary
inﬂuence. If DP ⊆r PS and

• (Cr, C¯r) gives downgrade protection to r,
• Π is multi-mode authentication secure for Auth, X,
• Π is partnering secure for PS, and
• Π is downgrade secure for DP,

then the protocol Π restricted to conﬁgurations in Cr ∪ C¯r
(cid:2)
is multi-mode authentication secure for a more lax Auth
predicate that deems all modes outside of N as “good”,
= Auth(m, role)∨(m /∈ N ∧ role = r).
i.e. Auth
Concretely, given an adversary A against authentication for
(cid:2)
Auth

(cid:2)(m, role)

, X, we have

(cid:2)

Advauth

Π(cid:3), Auth

(A) + Advdowngrade

(A)

Π, DP

(cid:3), X (A) ≤ Advpartnering

Π, PS
+ Advauth

Π, Auth, X (A) ,

where Π(cid:2) is Π restricted to conﬁgurations Cr ∪ C¯r.
Proof sketch: Consider the multi-mode authentication
experiment G0 for Π(cid:2). Let S hold when at some point a session
π completes maliciously on X and Auth(π.mode, π.role) holds
(i.e., A succeeds in breaking authentication iff S holds at the
end of the experiment).

Π, PS

(A).

Game G1 behaves as G0 except it aborts just before a session
π of role r would complete without being partnered. Because
of the restriction in Π(cid:2) and the hypothesis that DP ⊆r PS, it
must be the case that PS(π.cfg). Thus, any time G1 aborts, A
succeeds in breaking the partnering security of Π(cid:2), and thus
that of Π. Hence, the difference in the probability of S between
G0 and G1 is at most Advpartnering
Game G2 behaves as G1 except

(cid:2) such that π.mode (cid:5)= Negor(π.cfg, π

it aborts just before a
session π of role r would complete and there is a partnered
.cfg). The
session π
difference in the probability of S between G1 and G2 is at
(A) since any time G2 aborts but G1 does
most Advdowngrade
not, A succeeds in breaking the downgrade security of Π(cid:2), and
thus that of Π.
By deﬁnition of N , G2 never completes with a session
of role r assigning a mode outside of N . Consequently, the
probability of S in this game is at most Advauth

Π, Auth, X (A) .

Π, DP

(cid:2)

Interestingly, partnering security is similar to the alive-
ness requirement in some (single-mode) security deﬁnitions
which Krawczyk [30] does not consider as fundamental for
key-exchange security. Our second game transformation how-
(cid:2) with the same uid
ever only works if a partnered session π
exists. Otherwise an abort in G2 cannot be translated into a
downgrade security attack.

We sketch a similar theorem for key-indistinguishability in

the full version [14].

C. Downgrade secure sub-protocols

We are interested in minimal core sub-protocols that guar-
antee downgrade security. We justify our use of sub-protocols
as a sound abstraction of a full protocol using simulation. A
sub-protocol can take additional input as part of Init and Send
queries to allow for an accurate simulation of the execution of
the full protocol. This is akin to the sub-protocols of Bergsma
et al. [9] which allow for additional signing oracles (restricted
to not breaking security of the sub-protocol).

For simplicity, the following deﬁnition leaves out details
about handling of long-term keys and corruption models.
When ﬁlling in the details for a particular setting, we require
the simulation to be accurate with respect to e.g. corruption, so
that it issues exactly the same corruption queries as in the full
protocol. We model access to session variables using oracles
that just return the value of the corresponding variable.
of Π for X if we have an efﬁcient simulator S with access to
1) S transparently relays queries to oracles for reading

Deﬁnition 9 (Sub-protocol): A protocol (cid:3)Π is a sub-protocol
the oracles of (cid:3)Π such that:
variables in X to the same oracles in (cid:3)Π.
2) S ◦(cid:3)Π is information-theoretic indistinguishable from Π.
bilistic algorithm. The composition S ◦ (cid:3)Π of a simulator S
and a sub-protocol (cid:3)Π is well-deﬁned when (cid:3)Π includes all
Operationally, the oracles of S ◦(cid:3)Π behave as the algorithmic
composition of the oracles of S and (cid:3)Π. That is, S may use
oracles of (cid:3)Π as subroutines. Similarly, we model an adversary

algorithms called by the oracles of S. The composition itself
is a new collection of algorithms, one for each oracle of S.

Formally, we model a protocol (and a simulator) as a
collection of oracles sharing state, each oracle being a proba-

A as a single probabilistic algorithm with access to oracles,
and the composition A ◦ S (resp. A ◦ Π) behaves as the
algorithmic composition of this algorithm with the oracles of
S (resp. Π).

properties satisﬁed by a sub-protocol to the full protocol.

As the next theorem shows, simulation allows to lift security

Theorem 2 (Downgrade security lifting): Let (cid:3)Π be
tection predicate. Let S be a simulator for(cid:3)Π as in Deﬁnition 9.
downgrade security of (cid:3)Π with pre-agreement on X, and
Π, DP, X (A) .

a sub-protocol of a protocol Π for
session variables
{cfg, uid, mode, key, complete}∪ X, and DP a downgrade pro-
Then, for any adversary A against the downgrade security of
Π with pre-agreement on X, A◦S is an adversary against the

(A ◦ S) = Advdowngrade

Advdowngrade
(cid:2)Π, DP, X

511511

(cid:2)

(cid:2)

(π.cfg, π

Proof sketch:

(cid:2) such that DP(π.cfg, π

If A is successful when interacting with
Π through the protocol oracles, then during the downgrade
security experiment there must be a session π partnered with
.cfg) holds and either
a session π
π.mode (cid:5)= Negoπ.role
(cid:2) disagree on
.cfg) or π and π
Now, since the simulation S ◦ (cid:3)Π is accurate with respect
X. Let E denote this event. Note that the probability of E in
the experiment A ◦ Π is exactly Advdowngrade
to all variables this event depends on, and S ◦(cid:3)Π is indistin-
experiment A◦(S ◦(cid:3)Π) is the same as in the experiment A◦Π.
(cid:3)Π) = (A◦S)◦(cid:3)Π, we conclude by construing the composition
(cid:3)Π with pre-agreement on X.

guishable from Π for A, the probability of E occurring in the
Because the composition operator ◦ is such that A ◦ (S ◦
of A and S as an adversary against the downgrade security of

Π, DP, X (A).

An analogous theorem holds for partnering security.

D. Downgrade security by whitelisting

Consider a protocol that is negotiation correct and guar-
antees multi-mode authentication with pre-agreement on all
variables that inﬂuence the computation of mode, then we get
downgrade protection for

DP(cfg, .)

(cid:2)

= ∀cfg
(cid:2)

. Auth(Negocfg.role

(cfg, cfg

(cid:2)), cfg.role) .

That is, all negotiable modes from downgrade secure conﬁgu-
rations must provide authentication security. This generalizes
the Negotiation-authentication theorem of [21].

IV. SECURE SHELL

Figure 3a models a run of the SSHv2 [45] protocol with a
client that authenticates using the publickey method [44].
We analyze the downgrade security of this protocol using
(cid:2)
the sub-protocol shown on Figure 3b. The functions H, H
in these ﬁgures stand for the composition of a ﬁxed in-
jective formatting function and a negotiated hash function.
Note that there are potential downgrade attacks in SSHv2
from publickey authentication to other mechanisms like
password but the protocol we consider does not model the
negotiation of the authentication mechanism. We stress that
our analysis only applies assuming servers are conﬁgured to
require publickey.

Client and server conﬁgurations include lists algs of key
exchange, server signature, encryption and MAC algorithms
ordered by preference. We let F (cfg) = cfg.algs. Each party
computes the negotiated ciphersuite independently, following
the rules in the protocol speciﬁcation [45, Sect. 7.1], which we
encode in a nego function. Roughly, these rules dictate that the
ﬁrst algorithm for each category in cfgI that is also in cfgR be
selected. Each session locally assigns nego(F (cfgI ), F (cfgR))
to a. In addition, a client conﬁguration cfgI includes a user
name and a service name u, a function PKI mapping a pair
(a, u) to a public key, and a function PKsR mapping a value
a to a set of acceptable server public keys. Conversely, a
server conﬁguration cfgR includes a function PKR mapping
a value a to a public key, and a function PKsI mapping a pair
(a, u) to a set of acceptable client public keys. For instance, in

512512

OpenSSH the keys cfgI .PKsR of acceptable server public keys
are taken from the clients known_hosts ﬁle, whereas the
keys cfgR.PKsI of acceptable client public keys are taken from
the .ssh/authorized_keys ﬁle in the home directory of
the user on the server.

In terms of the template in Section II, the sub-protocol uses

the following session variables:

(cid:2)

cfg

uid
mode

(cid:2)
=

(I, algs, u, PKI , PKsR)
(R, algs, PKR, PKsI )

for I
for R

(cid:2)
= (nI , nR)
(cid:2)
= (a, u, pk I , pk R) .

Client and server exchange nonces and their algorithmic
preferences F (cfgI ), F (cfgR). The server then selects a com-
patible signature key pair (pk R, sk R) and signs a hash log that
includes the ﬁrst two exchanged messages. When receiving
this message, the client checks that pk R is an acceptable
server key in its local conﬁguration, computes log locally and
veriﬁes the server signature. If the signature veriﬁes, it selects
a key pair (pk I , sk I ) in its conﬁguration for authenticating
and sends back to the server a signature over log, u, and
pk I. When receiving this message, the server checks that
pk I is an acceptable client key in cfgR.PKsI (a, u). Each
party completes the session upon successfully verifying the
peer signature, otherwise aborts. Formally, a client aborts if
pk R (cid:5)∈ cfgI .PKsR(a); otherwise it sets mode to:

(nego(F (cfgI ), F (cfgR)), cfgI .u, cfgI .PKI (a, u), pk R)

The server’s behavior is speciﬁed analogously.

We augment the Send oracles of each a session in the sub-
protocol with extra parameters that allow to ﬁll in the blank
(−) used to compute log. This allows a simulator to compute
signatures on the same values as the full protocol, as needed to
consistently answer Send queries. Consequently, we allow an
adversary against the downgrade security of the sub-protocol
to ﬁll in − parameters arbitrarily.
We complete our security model with oracles pk ← KeyGen
for key generation, sk ← Corrupt(pk) for adaptive corruption,
and Coerce(pk) for adversarial key registration. A public key
pk is honest if it was generated by a query to oracle KeyGen
but not corrupted by a Corrupt query.

Theorem 3 (Simulation): SSH-sub (Fig. 3b) is a sub-protocol

of SSH (Fig. 3a) for their common variables.

Proof sketch: The sub-protocol is oblivious of the Difﬁe-
Hellman exchange in the full protocol, so the simulator gener-
ates fresh Difﬁe-Hellman shares of his own for each session.
When needed, the simulator S forwards queries to SSH-sub
after applying message parsing and formatting functions. To
simulate signatures of honest sessions S uses the Difﬁe-
Hellman shares it has computed and the messages it has
received to ﬁll in the value of the extra parameter − of oracles
of the sub-protocol. Note that the adversary knows the secret
exponents of an instance’s Difﬁe-Hellman shares and so it can
always compute the encryption keys k1, k2 needed to simulate
the last two messages of the full protocol.

Client I

Server R

VI
VR

II = KEXINIT(nI , algsI )
IR = KEXINIT(nR, algsR)

KEXDH_INIT(gx)

Client I

Server R

m1 = (nI , F (cfgI ))
m2 = (nR, F (cfgR))

KEXDH_REPLY(pk R, gy, sign(sk R, hash(log)))

uid = (nI , nR)
a = nego(F (cfgI ), F (cfgR))

uid = (nI , nR)
a = nego(F (cfgI ), F (cfgR))

(k1, k2) = kdf(gxy, log)

(k1, k2) = kdf(gxy, log)

NEWKEYS
NEWKEYS

{USERAUTH_REQUEST(u, pk I , sign(sk I , hash(log, u, pk I )))}k1

{USERAUTH_SUCCESS}k2

pk R, sign(sk R, hash(log))

u, pk I , sign(sk I , hash(log, u, pk I ))

mode = (a, u, pk I , pk R)
complete = true

mode = (a, u, pk I , pk R)
complete = true

(a) log = H(VI , VR, II , IR, pk R, g

x

y

, g

, g

xy)

(b) log = H

(cid:2)(m1, m2, pk R,−)

Fig. 3: SSHv2 mutually-authenticated key exchange: (a) full protocol and (b) sub-protocol SSH-sub.

A. SSHv2 is partnering and downgrade secure

A remarkable property of the downgrade protection sub-
protocol of mutually-authenticated SSHv2 is that, because both
client and server sign (a hash of) the inputs to the nego
function, downgrade protection security relies only on the
honesty of the signature keys, the collision resistance of the
hash algorithm, and the strength of the signature algorithms.
Notably, it does not rely on the key exchange algorithm being
strong or contributive, not even on it providing high entropy
inputs to H. This means that we can prove this protocol secure
for a predicate DP that only constrains the signature and hash
algorithms of cfgr, and requires honesty of peer public keys
in cfgr.PKs¯r, but has no requirements on cfg¯r.

We prove partnering and downgrade security of SSHv2
with publickey authentication under the agile security
assumptions on hash functions and signatures that we present
next.
Agile hash functions and signatures

As protocol participants may negotiate different hash func-

tions we need to capture collisions across hash functions.
Deﬁnition 10 (Agile collision resistance): Let h(cid:3) be a hash
function, and H a set of hash functions. Consider the game:

(cid:2) ← A()

- h, v, v
- Return h(cid:3)(v) = h(v

(cid:2)) ∧ v (cid:5)= v

(cid:2)

The collision resistance advantage of A, AdvCR
probability that the game returns true.

h(cid:2), P (A) is the

If the ranges of hash functions are disjoint, agile collision
resistance reduces to ordinary collision resistance. Bhargavan
et al. [13] also deﬁne existential unforgeability under chosen-
message attacks (EUF-CMA) for agile hash-then-sign signa-
tures. We here consider such signatures as primitives, although
typical constructions can be proved secure in the random
oracle model.

Deﬁnition 11 (Agile EUF-CMA security): Consider an agile
signature scheme s = (keygen, sign, verify). Let p(cid:3) be an
agility parameter, and P a set of parameters. Consider the
forgery game:

- Let pk, sk ← keygen()
- Set M := {} and run m, σ ← ASign(pk)

513513

- Return m /∈ M ∧ verify(pk, p(cid:3), m, σ)
where Sign(p, m) returns ⊥ if p /∈ P and otherwise sets M :=
M ∪ {m} before returning sign(sk, p, m).
s, p(cid:2), P (A) of A in forging a signature

The advantage AdvEUF-CMA

for s is the probability that the forgery game returns true.

Since we proved that SSH-sub soundly abstracts negotiation
in the full protocol, any downgrade attack on the full protocol
can be turned into a downgrade attack on SSH-sub. By virtue
of Theorem 2 it sufﬁces to prove that SSH-sub is downgrade
secure. The same reasoning applies to partnering security.
Partnering security

Deﬁne Nego(cfgI , cfgR)

(cid:2)
= (a, cfgI .u, cfgI .PKI (a, u), pk R) ,
where a = nego(F (cfgI ), F (cfgR)) if pk R = cfgR.P KR(a),
and ⊥ otherwise. Let M be the set of all supported modes
and H be the set of all supported hash algorithms. We deﬁne

M(cid:3) (cid:2)
H(cid:3) (cid:2)
Ps

(cfg, cfg

(cid:2))|PS(cfg)}

= {Negocfg.role
= {mode.hash | mode ∈ M(cid:3)}
= {p | s, p = mode.sig ∧ mode ∈ M}

(cid:2)

That is, M(cid:3) are the modes negotiated by pairs of conﬁg-
urations where the ﬁrst conﬁguration guarantees partnering
security, H are the hash algorithms used in partnering secure
modes, and Ps are the agility parameters for the peer signature
scheme s.

Theorem 4 (Partnering security of SSH-sub): Let PS be
such that PS(cfg) implies that all public keys in the range
of cfg.PKscfg.role are honest. Given an adversary A against
the partnering security of SSH-sub, we construct adversaries
Bs,p and Bh running in about the same time as A such that
(cid:4)
Advpartnering
SSH-sub, PS

(cid:4)
(A) is at most
h, H(Bh) +

ns AdvEUF-CMA

(Bs,p) ,

AdvCR

s, p, Ps

h∈H(cid:2)

(s,p)∈sig(M(cid:2))

where ns is the number of keys generated for scheme s.
Downgrade security
To prove downgrade security, we deﬁne Nego, M, Ps, and
H as before, but re-deﬁne M(cid:3), H(cid:3) to use DP instead of PS,
i.e. M(cid:3) (cid:2)

(cid:2)) | DS(cfg, cfg

= {Negocfg.role

(cfg, cfg

(cid:2))}.

Theorem 5 (Downgrade security of SSH sub-protocol): Let
DP be such that DP(cfg,·) implies that all public keys in
the range of cfg.PKcfg.role are honest. Given an adversary
A against the downgrade security of the sub-protocol, we
construct adversaries Bs,p and Bh running in about the same
(cid:4)
(A) is at most
time as A such that Advdowngrade
n2

(cid:4)

SSH-sub, DP

AdvCR

h, H(Bh) +

ns AdvEUF-CMA

s, p, Ps

(Bs,p) ,

2|uid|/2

+

h∈H(cid:2)

(s,p)∈sig(M(cid:2))

where n is the number of sessions, ns the number of keys
generated for scheme s, and |uid| the size of unique identiﬁers.

V. INTERNET KEY EXCHANGE

The Internet Key Exchange (IKE) protocol

is the key
exchange component of the IPsec suite of protocols. Two
versions of the protocol are commonly deployed: IKEv1 [24]
and IKEv2 [27]. Both variants are inspired by the SIGMA
protocol [30] recalled in the introduction, and are believed to
inherit its authentication and key-indistinguishability guaran-
tees. Next, we study their downgrade protection sub-protocols.
A. IKEv1 does not prevent downgrade attacks

We ﬁrst consider the DHE-PSK modes of IKEv1, whose
ﬁrst three messages are depicted in Figure 4a. The corre-
sponding downgrade protection sub-protocol is depicted in
Figure 4b.

The protocol presumes that both parties can select the pre-
shared key (psk) to use from the negotiated security association
SAR and identiﬁers IDI and IDR; it then conﬁrms that the two
parties agree, using a MAC based on psk. The two parties also
exchange Difﬁe-Hellman shares and use them to derive session
keys and protect application data but, in ‘aggressive’ modes,
their authentication and downgrade-protection relies solely on
the pre-shared key.

The initiator begins by extracting a list of supported security
associations [SA1, . . . , SAn] from its conﬁguration, presum-
ably ordered by preference, formats them (using the function
F ), and sends them along with a nonce (nI) to the responder.
Each security association speciﬁes a Difﬁe-Hellman group (for
the key exchange); an encryption scheme and a hash algorithm
(for protecting messages); and a peer authentication method.
The responder chooses one of these associations (SAR), based
on its own conﬁguration, and responds with its own nonce.
The initiator checks that this choice is compatible with its
proposals, which completes the negotiation. To authenticate
one another, to provide key conﬁrmation, and to prevent down-
grade attacks, the initiator and responder exchange MACs,
optionally signed when using certiﬁcates for authentication.
For simplicity, Figures 4a and 4b depict the use of just a pre-
shared key for authentication. The MACs are computed with a
key derived from the pre-shared key and the nonces, over some
important parts of the protocol transcript: the key shares, the
8 byte ISAKMP cookies taken from the headers, the client’s
offered security associations and the sender’s identity.

Surprisingly, the MAC does not cover the negotiated secu-
rity association (SAR), and this omission leads to a downgrade

(cid:2)
R compatible with the initiator’s proposals. If this new SA

attack. A man-in-the-middle can simply modify the second
message to replace the server’s chosen SAR with a different
(cid:2)
SA
R
uses an encryption algorithm that the attacker can break (e.g.
DES or NULL), then the attacker can break the conﬁdentiality
of the ﬁrst messages sent by the initiator. (Similarly, the ﬁrst
MAC includes IDR but not IDI, so an attacker can modify
IDI in the ﬁrst message, and yet the initiator will complete
the sub-protocol without detecting the modiﬁcation; this is less
problematic in the full protocol because IKEv1 continues with
a conﬁrmation message from the responder.)

We instantiate our main deﬁnitions to IKEv1 to better un-
derstand this downgrade-protection failure and propose ﬁxes.
Clearly, the protocol offers no authentication guarantees unless
the PSKs used by both parties are honest, so we always
make that assumption in the following, which enables us to
omit the choice of PSKs from the negotiation predicates. In
IKEv1,
the mac and kdf functions are negotiated as part
of SAR. In practice,
they are effectively HMAC-MD5 or
HMAC-SHA1. For simplicity, in the following we assume that
conﬁgurations specify ﬁxed kdf and mac algorithms. (See §IV
for an explicit handling of cryptographic agility.) We use the
following notations for the sub-protocol:

• the goal is to agree on a mode (SAR, IDI , IDR);
• cfgI = (IDI , [SA1, . . . , SAn]).
• cfgR includes IDR and is otherwise unspeciﬁed; it would
typically also include a list of SAs.
• F is a formatting function from cfgI to the payload of
the ﬁrst message that encodes the list of proposals above.
• nego is a partial function, used by the responder to map
F (cfgI ) and cfgR to some SAR.
• check is used by the initiator to conﬁrm that the mode is
acceptable, checking for instance that SAR matches one
of the initiator’s proposals [SA1, . . . , SAn].
• Nego(cfgI , cfgR), our speciﬁcation for negotiation, is de-
ﬁned as (nego(F (cfgI ), cfgR), cfgI .IDI , cfgR.IDR) when
check succeeds, and is otherwise undeﬁned.

Our statements and proofs only rely on the properties of
F , nego, and check as stated above, we hence omit a full
description.

We also assume that the protocol rejects runs in which
IDI = IDR. This is referred to in the literature as the self-
communication scenario, and in such settings there are well
known reﬂection attacks on IKEv1 [19, 36]. Positive results
in this setting would require an extension of our sub-protocol
and assumptions about the DH groups or the ISAKMP cookies
employed in the protocol.

We ﬁrst prove partnering security (Deﬁnition 2) relying
on the security of both kdf (modeled as a PRF keyed with
psk) and mac (modeled as a MAC, relying e.g. on existential
unforgeability under chosen-message attacks).

Theorem 6 (Partnering security of IKEv1 sub-protocol): Let
PS be such that all PSKs referenced by handles in cfg are
honest. Given an adversary A against the partnering security
of IKEv1-sub, we construct adversaries B and B(cid:2) running in

514514

Init. I

Resp. R

HDR1(nI , [SA1, . . . , SAn], gx, IDI )

km = kdf(psk , nI | nR)

HDR2(nR, SAR, gy, IDR, mac(km, m1))

km = kdf(psk , nI | nR)

Init. I

Resp. R

nI , F (cfg I ), IDI

uid = (nI , nR)
SAR = nego(F (cfg I ), cfg R)
mode = (SAR, IDI , IDR)
km = kdf(psk , nI | nR)

nR, SAR, IDR, mac(km,− | F (cfg I ) | IDR)

uid = (nI , nR)
mode = (SAR, IDI , IDR)
check (cfg I , mode)
km = kdf(psk , nI | nR)

mac(km,− | F (cfg I ) | IDI )

HDR3(mac(km, m2))

complete = true

complete = true

(a) m1 = g
m2 = g

y | g
x | g

x | CKYR | CKYI | [SA1, . . . , SAn] | IDR,
y | CKYI | CKYR | [SA1, . . . , SAn] | IDI .

(b) F is a formatting function from cfg I to the payload of the ﬁrst
message that encodes the list of proposals.

Fig. 4: IKEv1 aggressive DHE-PSK protocol (a) ﬁrst messages (b) downgrade protection sub-protocol.

about the same time as A such that Advpartnering
most

IKEv1-sub, PS

(A) is at

n2

2|uid|/2

+ np · AdvPRF(B) + n · AdvEUF-CMA(B(cid:2)) ,

where n is the number of sessions and np is the number
different psks employed by sessions.

While partnering security can be shown to hold for a very
general partnering security predicate, because of the SAR
spooﬁng attack the protocol offers provable downgrade pro-
tection only for very restrictive conﬁgurations. For example,
relying on the unambiguous formatting of IDI and IDR in the
MACed payloads, we have downgrade protection when

1) the client (or the server) uses each PSK only for a ﬁxed

saR, IDI , IDR; or

2) the client proposes only one SA at a time and checks that
the server echoes this proposal in SAR, and moreover SA
determines IDI.
Our analysis of
suggests

the IKEv1 downgrade-protection sub-
protocol
an obvious ﬁx:
the mode
(SAR, IDI , IDR) in both MACs. We then obtain downgrade
protection under the same conditions as for partnering: that
PSKs be honest and both kdf and mac be secure.

include

We also considered other modes of IKEv1, based on signa-
tures instead of PSKs (much as in our introductory SIGMA
example), and also when the MACs are protected using the
keys derived from the Difﬁe-Hellman exchange. In those cases,
the downgrade-protection sub-protocol is almost the same:
SAR is similarly left unauthenticated and, even if the messages
are protected, there is still an attack when the client proposes
a weak group, as explained in the introduction.

B. IKEv2 does not prevent downgrade attacks

IKEv2 [27] is a revision of the IKEv1 protocol intended
to simplify the speciﬁcation and extend it to cover popular
authentication methods such as EAP [1].

515515

IKEv2 with signatures: We ﬁrst consider

the plain,
signature-based protocol and sub-protocol in Figures 5a and
5b.

We ignore signature agility issues, since in IKEv2 the hash
algorithm for signing is not negotiated; it is chosen by the
sender, who almost always picks SHA1.

As in IKEv1, the initiator begins by offering a sequence of
security associations (extracted from cfg I) and the responder
chooses one of these. In the full protocol, the initiator and
responder also exchange Difﬁe-Hellman public values and use
them to derive session keys, used (in particular) to encrypt and
MAC all messages after m2.

The client and the server then exchange signatures over
MACs of their own views of the protocol (presumably to pro-
vide some deniability): their full ﬁrst message, their identity,
and the nonce of their peer. In particular, and in contrast with
IKEv1, the server’s signature covers its chosen SAR but not
the initiator’s offered security associations.

The sub-protocol

leaves important payloads unauthenti-
cated: the peers do not sign or MAC each other’s DH public
keys, and not even each other’s identities. It also ignores
the fact that, in the full protocol, all messages after m2 are
encrypted and MACed using a derived key. Thus, some attacks
against the sub-protocol may not occur in the full protocol.

Still, there is a downgrade attack against the full protocol as
soon as the client tolerates a weak group. The attack proceeds
as follows (see Fig. 6). Suppose an initiator offers two security
associations, one using the 1024-bit Difﬁe-Hellman group 14
and another using the 768-bit group 1. The attacker tampers
with the ﬁrst message to delete the ﬁrst association, so that
the responder thinks that the initiator only supports group 1.
The attacker forwards the responder’s messages to the initiator,
who thinks that the responder only supports group 1. If the
attacker has performed enough pre-computation so as to be
able to compute discrete logs in group 1, then he can compute
the session and MAC keys and impersonate the responder.

In practice, executing this attack requires the MitM to send

Init. I

Resp. R

m1 = (nI , F (cfg I ))

Init. I

Resp. R

m1 = SA_INIT(nI , [SA1, . . . , SAn], gx, infoI )

m2 = SA_INIT(nR, SAR, gy, infoR)

uid = (nI , nR)
Check (cfg I , SAR)

uid = (nI , nR)
SAR = nego

(cid:2)(F (cfg I ), cfg R)

m2 = (nR, SAR)

(km, k

(cid:2)
m, ke, k

e) = kdf(gxy, nI | nR)
(cid:2)

(cid:2)
m, ke, k
[AUTH(IDI , sign(sk I , hash(m1 | nR | mac(km, IDI ))))]ke
[AUTH(IDR, sign(sk R, hash(m2 | nI | mac(k
(cid:2)
m, IDR))))]k(cid:3)

(km, k

e

e) = kdf(gxy, nI | nR)
(cid:2)

IDI , sign(sk I , H(m1, nR, IDI ,−))
(cid:2)(m2, nI , IDR,−))
IDR, sign(sk R, H

mode = (SAR, IDI , IDR)
complete = true

mode = (SAR, IDI , IDR)
complete = true

(a) IKEv2 protocol with mutual signatures.

(b) IKEv2 sub-protocol with mutual signatures.

Fig. 5: IKEv2 protocol and sub-protocol for signature-based authentication

Init. I

MitM

Resp. R

SA_INIT(nI , [SA14, SA1], (G14, go), infoI )

INVALID_KE(G1)

m1 = SA_INIT(nI , [SA14, SA1], (G1, gx), infoI )

m2 = SA_INIT(nR, SA1, (G1, gy), infoR)

(km, k

(cid:2)
m, ke, k

e) = kdf(gxy, nI | nR)
(cid:2)

(km, k

y = dlog(G1, gy)

e) = kdf(gxy, nI | nR)
(cid:2)

(cid:2)
m, ke, k

(cid:2)
1 = SA_INIT(nI , [SA1], (G1, gx), infoI )
m

[AUTH(IDI , sign(sk I , hash(m1 | nR | mac(km, IDI ))))]ke

[AUTH(IDR, sign(sk R, hash(m2 | nI | mac(k

[AUTH(IDM , sign(sk M , hash(m
(cid:2)
m, IDR))))]k(cid:3)

e

[Data1]ke
(cid:2)
2]k(cid:3)
[Data

e

(cid:2)
1]ke
[Data
[Data2]k(cid:3)

e

(km, k

(cid:2)
m, ke, k

e) = kdf(gxy, nI | nR)
(cid:2)

1 | nR | mac(km, IDM ))))]ke
(cid:2)

Fig. 6: Man-in-the-middle downgrade on IKEv2 with mutual signatures and weak Difﬁe-Hellman groups

an extra INVALID_KE message to the client. This does not
present any difﬁculty since this message is unauthenticated.

The attack described above is reminiscent of Logjam [2]
and is arguably feasible with modern computing power, or
will be in the coming years. There are other downgrade attacks
with a similar impact on IKEv2: the man-in-the-middle could
downgrade the security association to use weak encryption or
authentication algorithms.

IKEv2 with EAP client authentication: We now consider
the downgrade protection sub-protocol in case the initiator is
authenticated using some EAP method, whereas the responder
still uses a certiﬁcate and a signature (see Figures 7a and 7b).
In this variant, in the third message, the initiator sends
its identity without any signature. Instead, after verifying the
server’s signature, it engages in an application-level ‘embed-
ded’ authentication protocol that generates a shared key. Its
use of EAP is asymmetric, in that EAP authenticates the
initiator (IDI) but does not re-authenticate the responder. The
resulting shared key is used to MAC the initiator’s view of the
negotiation: the full ﬁrst message, including the client’s offered
security associations, the responder’s nonce, and a MAC over
the initiator’s identity with the session key.

Enabling EAP actually weakens downgrade protection: the
responder (still) does not sign the initiator’s proposals, and
also does not sign the chosen client AUTH method (signature

or EAP), and this opens the possibility of cross-authentication
attacks between different AUTH methods.

For example, consider the attack in Fig. 8. Suppose the ini-
tiator disables EAP, but the responder supports it. The attacker
can then replace the initiator’s signature message with an EAP
authentication message, forward the responder’s signature, and
thereby downgrade the SA used by the initiator, to use a weak
encryption algorithm, for instance. In comparison with the ﬁrst
attack on IKEv2 discussed above, this attack does not require
breaking the Difﬁe-Hellman exchange to gain control of the
key used to MAC the signature payloads.

This would be a powerful downgrade, and it would allow
ofﬂine decryption of the initiator’s subsequent messages, but
it is still difﬁcult to implement in practice because the au-
thentication messages are themselves encrypted-and-MACed.
Hence, the attack requires that the attacker should be able to
break the (downgraded) authenticated encryption mechanism
in the SA.

For example,

it can be mounted if the encryption and
integrity algorithms are downgraded to NULL, an allowed
(but not recommended) option in IKEv2. In particular, the
speciﬁcation says: “Though the security of negotiated Child
SAs does not depend on the strength of the encryption and
integrity protection negotiated in the IKE SA, implementations
MUST NOT negotiate NONE as the IKE integrity protection

516516

Init. I

Resp. R

m1 = SA_INIT(nI , [SA1, . . . , SAn], (G, gx), infoI )

m2 = SA_INIT(nR, SAR, (G, gy), infoR)

(km, k

(cid:2)
m, ke, k

e) = kdf(gxy, nI | nR)
(cid:2)

(km, k

(cid:2)
m, ke, k

e) = kdf(gxy, nI | nR)
(cid:2)

Init. I

Resp. R

m1 = (nI , F (cfg I ))

uid = (nI , nR)
SAR = nego(F (cfg I ), cfg R)

m2 = (nR, SAR)

[AUTH(IDR, sign(sk R, hash(m2 | nI | mac(k

[AUTH(IDI )]ke

(cid:2)
m, IDR))))]k(cid:3)

e

[AUTH(eap1(. . .))]ke
[AUTH(eap2(. . .))]k(cid:3)

e

uid = (nI , nR)
Check (cfg I , SAR)

IDI
IDR, sign(sk R, H(m2, nI , IDR,−))
(cid:2)(m1, nR, IDI ,−))
mac(msk , H
mac(msk , H(m2, nI , IDR,−))

msk = EAP shared key

msk = EAP shared key

[AUTH(mac(msk , m1 | nR | mac(km, IDI )))]ke
[AUTH(mac(msk , m2 | nI | mac(k
(cid:2)
m, IDR)))]k(cid:3)

e

mode = (SAR, IDI , IDR)
complete = true

mode = (SAR, IDI , IDR)
complete = true

(a) IKEv2 protocol with EAP client authentication.

(b) IKEv2 sub-protocol with EAP client authentication.

Fig. 7: IKEv2 protocol and sub-protocol for EAP-based authentication

Init. I

MitM

m1 = SA_INIT(nI , [SAstrong , SAnull ], (G, gx), infoI )

m2 = SA_INIT(nR, SAnull , (G, gy), infoR)

(cid:2)
1 = SA_INIT(nI , [SAnull ], (G, gx), infoI )
m

Resp. R

(km, k

(cid:2)
m, ke, k

e) = kdf(gxy, nI | nR)
(cid:2)

Encryption and Integrity set to null

(km, k

(cid:2)
m, ke, k

e) = kdf(gxy, nI | nR)
(cid:2)

AUTH(IDI , sign(sk I , hash(m1 | nR | mac(km, IDI ))))

AUTH(IDR, sign(sk R, hash(m2 | nI | mac(k
Data

AUTH(IDI )

(cid:2)
m, IDR))))

Fig. 8: Man-in-the-middle cross-protocol downgrade on IKEv2 mixing signatures and EAP authentication

algorithm or ENCR NULL as the IKE encryption algorithm.”
[27, Section 5]. Our attack shows that this assumption is
wrong: the downgrade security of IKEv2 crucially depends
on the strength of the encryption and integrity algorithms,
especially when both signatures and EAP are enabled.

We also note that in case the initiator also supports EAP, any
subsequent initiator authentication makes no difference since
the initiator is now talking to the attacker and does not seek
to re-authenticate the responder.

While these attacks can be mitigated by disabling weak al-
gorithms, or by relying on subsequent key exchanges in Child
SAs, a simple protocol-level ﬁx would be for the responder to
include the client’s ﬁrst message and authentication mode in
its signature (at the cost of losing deniability). We could then
obtain downgrade protection simply by relying on the strength
of the responder’s signature, irrespective of weak groups and
broken encryption algorithms.

C. Version downgrade attacks from IKEv2 to IKEv1

IKE does not include a version negotiation protocol. Ini-
tiators ﬁrst try to connect with IKEv2 and if that fails they
fall back to IKEv1. This allows a simple downgrade attack
between this versions, since IKEv1 has no way of authenti-
cating the highest supported version. The IKEv2 speciﬁcation
acknowledges this version downgrade possibility to IKEv1,

517517

but sets up a ﬂag to prevent future downgrade attacks from
IKEv(n > 2) to IKEv2: “Note that IKEv1 does not follow
these rules, because there is no way in v1 of noting that
you are capable of speaking a higher version number. So an
active attacker can trick two v2-capable nodes into speaking
v1. When a v2-capable node negotiates down to v1, it should
note that fact in its logs” [27, Section 2.5].

VI. Z REAL-TIME PROTOCOL

ZRTP [46] is a specialized protocol used to establish key
material for encrypted voice-over-IP (VoIP) communications.
Unlike TLS, ZRTP does not rely on public-key infrastructure
or certiﬁcates for authentication. Instead, participants authen-
ticate each other by comparing a “short authentication string”
derived from the session key, also known as a SAS, via some
trusted channel. For our purposes in this analysis, we assume
in our model that the SAS comparison is conducted via an
ideal, trusted channel that is not susceptible to tampering.

Because the SAS is short, the protocol offers a more limited
form of protection. If the SAS length is (cid:4) bits,
then the
probability of an attacker subverting the authentication is at
least 2−(cid:4) with each execution of the handshake. In most
implementations (cid:4) is typically a small value, e.g. 16. The
use of a short authentication string presents challenges for
both key exchange and downgrade security. For example, if

the SAS employed a full-length collision-resistant hash, it
would sufﬁce for the parties to exchange a hash of the full
protocol transcript. However, even when constructed using
a (truncated) collision-resistant hash function,
the SAS is
too short to provide the necessary protection, and additional
measures must be taken.

A. ZRTP does not prevent downgrade attacks

The ZRTP protocol is presented in Figure 9a. The down-

grade protection sub-protocol is presented in Figure 9b.

The ciphersuite negotiation is conducted within the ﬁrst two
(“Hello”) messages exchanged by the Initiator and the Respon-
der. The chosen ciphersuite ai is determined by selecting a
ciphersuite in the intersection of the available algorithms pre-
sented by each party. Ciphersuites consist of a key exchange
algorithm, a cipher and MAC algorithm for subsequent data
exchange, and a SAS algorithm determining the length and
format of the SAS string. Additionally, the protocol negotiates
options such as a “trusted” PBX ﬂag and an optional signature
on the SAS.

Following the initial negotiation messages, the parties deter-
mine who will play the role of the Initiator, engage in a key
exchange, and derive session keys. Transcript correctness is
enforced by incorporating a hash of most of the transcript into
the key derivation function, which produces both session keys
and a SAS. A ﬁnal mechanism tries to authenticate each of the
handshake messages by computing a MAC over each message,
using a key that is revealed in the subsequent message. To bind
these messages together, ZRTP uses a hash chain.1
Downgrading protocol versions: ZRTP includes a negotiation
mechanism for protocol versions and options that is not in-
corporated into the calculation of the shared secrets and SAS.
When the parties support multiple versions of the protocol and
protocol options, a MitM can substitute the protocol versions
vI , vR to downgrade both parties to a previous version of
the protocol, as illustrated in Figure 10. Moreover, since the
ﬁrst (Initiator Hello) message is not authenticated, the attacker
can also change the options ﬂags oI. This second proce-
dure requires the attacker to defeat the hash chain security
mechanism. Unfortunately this may be done by capturing and
delaying subsequent messages until the authentication key for
earlier messages has been revealed, allowing the attacker to
change messages arbitrarily. The ﬁx for this vulnerability is
straightforward: all negotiation messages should be included
in the calculation of the session key and SAS.
Downgrade from DH to PSK: ZRTP supports both Difﬁe-
Hellman key exchange and a pre-shared key mode. The latter
is analogous to the session resumption handshake in TLS, in
that it provides an inexpensive (symmetric-key only) hand-
shake, which operates under the assumption that the parties

1Speciﬁcally, each participant computes an initial nonce H0 and hashes it
to obtain the sequence H3 = hash(H2 = hash(H1 = hash(H0))). At each
message in the handshake, the party reveals Hi and uses Hi−1 as a MAC
key to authenticate the current message. Veriﬁcation is only possible when
the next message is received. The initial value H0 is revealed only within the
encrypted conﬁrmation message at the conclusion of the protocol.

have previously completed a full Difﬁe-Hellman handshake
to establish a pre-shared key. The corresponding negotiation
sub-protocol is shown in Fig. 11.

The limitation of this pre-shared mode is that it does not
force the parties to commit to their protocol inputs before
revealing them, which admits an ofﬂine attack in which a
MitM may identify protocol inputs that result in a chosen
SAS. The attack begins with the establishment of a shared key
(via Difﬁe-Hellman) before restarting with the PSK mode. We
describe the attack in detail in the full version [14]. In practice,
most ZRTP implementations do not
implement pre-shared
mode, and those that do only allow SAS authentication after
DH exchanges. Nevertheless, this protocol-level attack should
serve as a cautionary tale for future ZRTP implementations
and extensions.

VII. TRANSPORT LAYER SECURITY

The Transport Layer Security protocol (TLS) is used to
provide secure channels for a variety of Internet applications.
It offers a number of key exchange mechanisms, authentication
methods, and encryption schemes, so that users can pick and
choose mechanisms best suited to their needs.

A negative consequence of this agility is the potential
for downgrades. TLS clients and servers commonly support
multiple protocol versions and hundreds of ciphersuites, even
though some of them are known to be obsolete or even broken.
For example, SSL 2.0 is still supported by 10% of web servers
even though it has long been known to be vulnerable to
multiple attacks including, notably, a ciphersuite downgrade
attack [43] and a dangerous backward compatibility attack [5].
Equally, about 25% of web servers were found to still support
export-grade ciphersuites that were deprecated in 2000, en-
abling powerful downgrade and server impersonation attacks
like FREAK [10] and Logjam [2].

Since SSL 3.0, all versions of TLS incorporate various
downgrade protection mechanisms. We will analyze the down-
grade protection provided by TLS 1.2 and the proposed im-
provements in TLS 1.3. In both cases we focus on ephemeral
Difﬁe-Hellman key exchange (DHE/ECDHE).

A. Negotiation in TLS 1.0–1.2

Figure 12a depicts a mutually authenticated TLS connection
incorporating a Difﬁe-Hellman key exchange that uses either
a ﬁnite-ﬁeld group (DHE) or an elliptic curve (ECDHE). Most
TLS connections authenticate only the server, but the ﬁgure
also depicts the optional client authentication messages.

The client I ﬁrst sends a hello message (CH) with a nonce
(nI) and a list of agility parameters [a1, . . . , an] that include
ciphersuites, compression methods, and protocol extensions.
The server responds with a hello message (SH) containing
its chosen parameters (aR). At
the client and
server know which key exchange they will execute next. In
an ephemeral Difﬁe-Hellman key exchange (DHE/ECDHE),
the server sends its public-key certiﬁcate (cert R) and uses the
private key to sign the nonces, the group (or curve) parameters
(p, g) and its own Difﬁe-Hellman public value (gy). The

this point,

518518

Initiator I

Responder R

m1 = Hello(vI , IDI , [aI,1, . . . , aI,n])
m2 = Hello(vR, IDR, [aR,1, . . . , aR,n])

m3 = Commit(IDI , hash(m5), ai)

m4 = DHPart1(gy)
m5 = DHPart2(gx)

R , ke

I , km

(km
R, sas)
= kdf(gxy, IDI , IDR,

I , ke

hash(m2, m3, m4, m5))

R , ke

I , km

(km
R, sas)
= kdf(gxy, IDI , IDR,

I , ke

hash(m2, m3, m4, m5))

m6 = Confirm1(mac(km
m7 = Confirm2(mac(km

R , [ﬂags]ke
I , [ﬂags]ke

R ))
I ))

Initiator I

Responder R

m1 = (IDI , F (cfg I )), mac(kI , m1), hash(kI )
m2 = (IDR, F (cfg R)), mac(kR, m2), hash(kR)

a = nego(cfg I , F (cfg R))

m3 = (IDI , a, hash(nI )), kI

m4 = (nR), kR

m5 = (nI )

uid = h = H(m2, m3, m4, m5,−)
sas = H

(cid:2)(IDI , IDR, h,−)

check (cfg R, a)
uid = h = H(m2, m3, m4, m5,−)
sas = H

(cid:2)(IDI , IDR, h,−)

sas
sas

sas
sas

mode = (a, IDI , IDR)
complete = true

mode = (a, IDI , IDR)
complete = true

(a)
Fig. 9: ZRTP (a) protocol (b) downgrade protection sub-protocol

(b)

Initiator I

MitM

Responder R

m1 = Hello(vI , oI , IDI , [aI,1, . . . , aI,n], hash(KI )), mac(KI , m1)

(cid:2)(cid:2)
1 = Hello(v

(cid:2)(cid:2)
(cid:2)
I , oI , IDI , [aI,1, . . . , aI,n], hash(KI )), mac(KI , m
1 )

m

m3 = Commit(IDI , hash(m5), ai, KI )

m2 = Hello(vR, oR, IDR, [aR,1, . . . , aR,n], h), m
(cid:2)
I , oI , IDR, [aR,1, . . . , aR,n], $), $
m

(cid:2)
1 = Hello(v

m2 = Hello(v

(cid:2)
R, oR, IDR, [aR,1, . . . , aR,n]), hash(KR)), mac(KR, m2)

(cid:2)(cid:2)(cid:2)
1 = Hello(v

(cid:2)
(cid:2)
I , IDI , [aI,1, . . . , aI,n], hash(KI )), mac(KI , m
I , o

(cid:2)(cid:2)(cid:2)
1 )

m

m3

m4 = DHPart1(gy)

R , ke

I , km

(km
kdf(gxy, IDI , IDR, hash(m2, m3, m4, m5))

S, sas) =

R, ke

m5 = DHPart2(gx)

sas

m6 = Confirm1(mac(km
m7 = Confirm2(mac(km

R , [ﬂags]ke
I , [ﬂags]ke

R ))
I ))

R , ke

I , km

(km
kdf(gxy, IDI , IDR, hash(m2, m3, m4, m5))

S, sas) =

R, ke

sas

Fig. 10: Man-in-the-Middle attack on ZRTP version and option negotiation. We assume that both peers prefer version vI = vR,
but will support an older version v

(cid:2)
R. The attacker additionally modiﬁes the options ﬂags oI transmitted in m1.

(cid:2)
I = v

server may let the client remain anonymous, or it may require
authentication (specifying the class of acceptable certiﬁcates
[cert 1, . . . , cert m]), in which case the client sends its own
certiﬁcate (cert I) and public value (gx), and uses its private
key to sign the full protocol transcript so far (log 1). The client
and server then derive a master secret (ms) and session keys
(k1, k2) from the nonces and shared secret (gxy). To complete
the key exchange, both sides compute MACs using the master
secret over the protocol transcript, and exchange them in ﬁn-
ished messages (CFIN,SFIN). These MACs provide key con-
ﬁrmation as well as downgrade protection. Once exchanged,
the client and server can start exchanging application data
encrypted under the new session keys ([Data]k).

B. TLS 1.0–1.2 do not prevent downgrades

The downgrade protection sub-protocol for TLS 1.0–1.2 is
depicted in Fig. 12b. The sub-protocols for TLS 1.0, 1.1, and
1.2 have an almost identical protocol ﬂow and primarily differ
in the choice of algorithms. For simplicity, we consider only

server-authenticated (EC)DHE connections, where clients are
anonymous.

The client offers its entire public conﬁguration (F (cfg I ))
to the server, which then computes the negotiated parameters
(mode) that consist of the protocol version (v), the chosen
parameters (aR), the group (GR), the server identity (pk R),
and the hash function used in the server signature (hash1). The
protocol version and the ciphersuite in aR together determine
other protocol parameters, such as the key derivation function
(kdf), the authenticated encryption scheme, and the MAC and
hash functions used in the ﬁnished messages (mac, hash).
We note that the server may possess several identities and
choose one based on the chosen ciphersuite or other protocol
extensions offered by the client.

Downgrade protection primarily relies on the MACs in the
ﬁnished messages, which in turn rely on the strength of the
group GR and the negotiated algorithms kdf, hash, and mac.
If a client and server support a weak group, for example, then
an attacker can downgrade the group and then break the master

519519

Initiator I

Responder R

m1 = (IDI , F (cfg I ))
m2 = (IDR, F (cfg R))

a = nego(cfg I , F (cfg R))

m3 = (IDI , a, nI , mac(psk IR, “P rsh

(cid:2)(cid:2)))

uid = h = H(m2, m3,−)
(kI , kR, sas) = kdf(psk IR, h)

check (cfg R, a)
uid = h = H(m2, m3,−)
(kI , kR, sas) = kdf(psk IR, h)

m4 = mac(kR,−)
m5 = mac(kI ,−)

sas
sas

mode = (a, IDI , IDR)
complete = true

mode = (a, IDI , IDR)
complete = true

Fig. 11: ZRTP with Pre-Shared Keys: negotiation sub-protocol

secret to forge the MACs, as in Logjam.

A second protection mechanism is the server signature,
but we observe that this signature covers only the unique
identiﬁer and the group GR, but none of the other negotiated
parameters. For example, the Logjam attacker tricks the server
into using an export ciphersuite (DHE-EXPORT) that results
in a weak Difﬁe-Hellman group. The client does not support
DHE-EXPORT and still thinks it is using standard DHE, but
the attacker can forge the MAC to hide this discrepancy.
Importantly, the server signature fails to prevent this attack,
because it does not include the ciphersuite. Before this attack
was disclosed, many implementations of TLS clients still
accepted arbitrary groups.

Furthermore, we note that the negotiated algorithms can be
weak in practice. For example, TLS 1.2 supports MD5-based
signatures; TLS 1.1 derives keys and transcript hashes based
on combinations of MD5 and SHA1. These weak constructions
also lead to downgrade and impersonation attacks [11].

Let minr, maxr be the supported minimum and maximum
protocol versions, let algsr = [a1, . . . , am] = F (cfgI ) be the
ciphersuites and extensions, and let groupsr be the groups
supported by role r. In terms of the general deﬁnition in
Section II, the downgrade protection sub-protocol uses the
following session variables:

(cid:2)

cfg

(cid:2)
=

(I, minI , maxI , algsI , groupsI , PKsR)
(R, minR, maxR, algsR, groupsR, PKR)

for I
for R

(cid:2)
= (nI , nR)
(cid:2)
= (v, aR, GR, pk R, hash1)

uid
mode
The negotiation function nego is executed by the server and
is based on the server’s conﬁguration cfg R and the server’s
partial view F (cfg I ) of the client conﬁguration. The client
does not get to inspect cfg R, but it does check that the resulting
mode is consistent with its conﬁguration.

The protocol only offers downgrade protection if the peer
is authenticated with an honest key and strong signature and

hash algorithms. So we will consider downgrade security from
the viewpoint of a client, while assuming that all keys in PKsR
are honest and hash1 is collision-resistant. We get partnering
security from the freshness of the uid and the strength of the
server signature (which includes the uid).

However, downgrade protection for the client cannot rely
on just the signature, and hence requires one of the following
conditions:

• the server uses its pk R only with modes that use strong
groups, key derivation algorithm kdf, hash and mac
algorithms and the client is aware of the servers choice
and aborts whenever it sees an unexpected algorithm
combination;
• the client only accepts modes with strong groups (in
particular not
the groups ‘negotiated’ by the Logjam
and the ECDHE-DHE cross-protocol attacks [35]) and
algorithms.

An extreme example of the ﬁrst condition would be to
require that the server uses a different public key for each
mode; the proofs in [21] rely on this somewhat unrealistic
assumption to avoid ECDHE-DHE cross-protocol attacks and
the need for agile security assumptions. More pragmatically,
if a client and server only support TLS 1.2 (and hence only
strong hash constructions), only support strong groups and
curves for (EC)DHE and all other ciphersuites that use Difﬁe-
Hellman, then TLS clients can be protected from downgrade.
Of course, we rely on the server using only honest and strong
signing keys (e.g. 2048-bit RSA) with strong signature and
hash algorithms (e.g. RSA-SHA256).

We also get some downgrade protection for the server when
the client is authenticated, relying only on the client signature
and the transcript hash algorithm hash. Pragmatically, TLS
1.2 servers that require client authentication and only accept
strong signature and hash algorithms cannot themselves be
tricked into completing a connection with a weak mode.

As evidenced by the Logjam attack, the TLS protocol does
not satisfy downgrade security unless the DP predicate guar-
antees that the client and server conﬁgurations exclusively use
strong algorithms, hence guaranteeing that all the negotiated
algorithms used in the ﬁnished MACs are strong.

C. On downgrade protection in Draft 10 of TLS 1.3
that

Draft 10 of TLS 1.3 proposes a protocol

is quite
different from TLS 1.2 and earlier versions; a typical run of the
1-round-trip mode is depicted in Fig. 13a. The corresponding
downgrade protection sub-protocol is in Fig. 13b.

In contrast to TLS 1.2, the client hello message includes
Difﬁe-Hellman public values for the client’s preferred groups.
The server may choose one of these groups or ask for a public
value in a different group, as long as it is one supported by
the client. The server sends its own public value in the server
hello message, and all subsequent messages are encrypted and
integrity-protected using the Difﬁe-Hellman shared key.

For downgrade security from the client’s viewpoint, a key
difference is that server signatures in TLS 1.3 cover the full
transcript, and hence they cover the full client and server hello

520520

Client I

Server R

CH(nI , vmaxI , [a1, . . . , an])

SH(nR, v, aR)

SC(cert R)

SKE(sign(sk R, hash1(nI | nR | p | g | gy)))

∗([cert 1, . . . , cert m])

SCR

log 1
log 2

SHD
∗(cert I )
CC
CKE(gx)

∗(sign(sk I , hash2(log 1)))

CCV

log 1
log 2

(ms, k1, k2) = kdf(gxy, nI | nR)

(ms, k1, k2) = kdf(gxy, nI | nR)

log 3

[CFIN(mac(ms, hash(log 2)))]k1
[SFIN(mac(ms, hash(log 3)))]k2

log 3

[Data]k1
[Data]k2

(a)

Client I

Server R

m1 = (nI , F (cfg I ))

= (nI , nR)

uid
mode = nego(F (cfg I ), cfg R)

= (v, aR, GR, pk R, hash1)

m2 = (nR, v, aR, GR, pk R, sign(sk R, hash1(nI | nR | GR | gy)))

uid = (nI , nR)
mode = (v, aR, GR, pk R, hash1)
Check (cfg I , mode)
ms = kdf(gxy, nI | nR)

ms = kdf(gxy, nI | nR)

m3 = (gx, mac(ms, H(m1, m2, gx,−)))
(cid:2)(m1, m2, m3,−)))
m4 = (mac(ms, H

complete = true

complete = true

(b)

Fig. 12: TLS 1.0–1.2 with (EC)DHE key exchange (a), where messages labeled with * occur only when client authentication
is enabled, and (b) its downgrade protection sub-protocol

Client I

Server R

CH(nI , maxI , [a1, . . . , an], [(G1, gx1 )])

Retry(G2)

log 1

CH(nI , maxI , [a1, . . . , an], [(G1, gx1 ), (G2, gx2 )])

log 1

SH(nR, v, aR, (G2, gy))

(k1, k2) = kdf(gx2y, log 1)

(k1, k2) = kdf(gx2y, log 1)

log 2
log 3

[SC(cert R)]k2

[SCV(sign(sk R, hash1(hash(log2))))]k2

log 2
log 3

ms = kdf(gx2y, log 3)

ms = kdf(gx2y, log 3)

log 4

[SFIN(mac(ms, hash(log 3)))]k2
[CFIN(mac(ms, hash(log 4)))]k1

log 4

[Data]k1
[Data]k2

(a)

Client I

Server R

m1 = (nI , F (cfg I ))

= (nI , nR)

uid
mode = nego(F (cfg I ), cfg R)

= (v, aR, GR, pk R, hash1)

m2 = (nR, v, aR, GR, pk R)

2 = sign(sk R, hash1(H(m1, m2,−)))
(cid:2)
m

uid = (nI , nR)
mode = (v, aR, GR, pk R, hash 1)
check (cfg I , mode)
complete = true

complete = true

(b)

Fig. 13: TLS 1.3 1-RTT mode with server-only authentication (a) and its downgrade protection sub-protocol (b)

messages. This foils most of the downgrade attacks on TLS
1.2; as long as the client only accepts strong signature and
hash algorithms and honest public keys from the server, it
cannot be downgraded to a weaker ciphersuite, and moreover,
it yields agreement on the chosen ciphersuite.

Although Draft 10 of TLS 1.3 provides strong downgrade
protection for the ciphersuite, downgrade attacks remain,
in particular, because clients and servers will continue to
support lower protocol versions for backward compatibility.
Considering that TLS 1.2 does not provide strong downgrade
protections, this unfortunately means that all the downgrade
attacks on TLS 1.2 will be inherited by TLS 1.3.

There are three downgrade attacks possible on TLS 1.3 as
described in Draft 10. One, an attacker downgrades the con-

nection to TLS 1.2 or lower and mounts any of the downgrade
attacks mentioned before. This will succeed as long as the
attacker can forge the ﬁnished MACs. Second, an attacker uses
the TLS fallback mechanism to stop TLS 1.3 connections and
allows only TLS 1.2 connections to go through. Even if the
endpoints implement the fallback protection mechanism [38],
the attacker can use one of the downgrade attacks in TLS
1.2 to break the connection. Third, in Draft 10 of the TLS 1.3
protocol, the handshake hashes restart upon receiving a Retry
message and hence, the attacker can downgrade the Difﬁe-
Hellman group for some classes of negotiation functions.

We can prevent all of these attacks by two countermeasures,
both of which have been incorporated into TLS 1.3 Draft 11.
See Fig. 14a. First, we continue the handshake hashes over

521521

retries. Second, TLS 1.3 servers always include their highest
supported version number in the server nonce, even when they
choose a lower version such as TLS 1.0.

Including the maximum version number into the server
nonce of all versions yields version downgrade protection
for clients. It is a simple patch (For the server, it amounts
to changing how nonces are generated. The client needs to
implement an equality check.) that can be incorporated into
TLS versions without making them incompatible with TLS
versions that do not implement the patch. If a server and
a client both implement the patch, the client gets version
downgrade protection.

We proceed in three steps: We show that when hashes
continue over Retry, clients that interact with servers that
just support TLS 1.3 achieve downgrade security. We then
show that embedding the version number into the server’s
nonce yields version downgrade protection from the client’s
perspective. We then put the two results together and show that
servers supporting TLS 1.0–1.3 with these countermeasures
yield the same client-side downgrade protection as when
servers just support TLS 1.3.

(cfg, cfg

The downgrade protection sub-protocol uses the same ses-
sion variables as TLS 1.0–1.2, but deﬁnes Nego using the func-
tion nego from Fig. 14a. Let M be the set of modes supported
by TLS and M(cid:3) = {Negocfg.role
(cid:2))|PS(cfg)} be the
modes negotiated between any pair of conﬁgurations for which
the ﬁrst guarantees partnering security. Let Ps = {p | s, p =
mode.sig∧mode ∈ M} be the signature agility parameters for
peer signature scheme s, H be the set of all hash algorithms
supported by TLS, and H(cid:3) = {mode.hash | mode ∈ M(cid:3)}
be the hash algorithms used by partnering secure modes. We
now prove partnering security for TLS 1.0–1.3 and downgrade
security for clients speaking to servers that implement the
ﬁx described in Fig. 14a. We then deﬁne version downgrade
security and show that the ﬁxes in Fig. 14a (TLS 1.3) and
Fig. 14b (TLS 1.0–1.2) prevent version downgrade.

In all of our theorems we consider a universe of conﬁgu-
rations that support subsets of TLS 1.0, 1.1, 1.2 and 1.3 and
that enable only (EC)DHE. Note that RSA keys are thus used
for signing only.

Theorem 7 (Partnering security of TLS 1.0–1.3): Let PS be
such that PS(cfg) implies that cfg.role = I and that all public
keys in the range of cfg.PKsR are honest. Given an adversary
A against the partnering security of our sub-protocol, we
construct adversaries Bs,p and Bh running in about the same
(cid:4)
time as A such that Advpartnering

(A) is at most

(cid:4)

TLS1.0-1.3-sub, PS

AdvCR

h, H(Bh) +

ns AdvEUF-CMA

s, p, Ps

(Bs,p) ,

h∈H(cid:2)

(s,p)∈sig(M(cid:2))

where ns keys are generated for signing scheme s.
For downgrade security, we deﬁne Nego, M, Ps, and H
as before. However, we redeﬁne M(cid:3), H(cid:3) to use DP instead
(cid:2))} and
of PS, i.e., M(cid:3) = {Negocfg.role
H(cid:3) = {mode.hash | mode ∈ M(cid:3)}.
Theorem 8 (Downgrade security of TLS 1.3): Let DP be
(cid:2)) implies that cfg.role = I, that all public

(cid:2)) | DS(cfg, cfg

such that DP(cfg, cfg

(cfg, cfg

(cid:2)

keys in the range of cfg.PKsR are honest and such that: (a)
cfg supports at least TLS 1.3 and implements the counter-
only supports TLS 1.3 and implements the
measure. (b) cfg
countermeasure. Given an adversary A against the downgrade
security of TLS 1.3 sub-protocol, we construct adversaries
Bs,p and Bh running in about the same time as A such that
Advdowngrade

TLS1.3-sub, DP

(A) is at most
h, H(Bh) +

AdvCR

(cid:4)

(cid:4)

h∈H(cid:2)

(s,p)∈sig(M(cid:2))

n2

2|nR|+1

+

nsAdvEUF-CMA

s, p, Ps

(Bs,p) ,

where n is the number of sessions, ns is the number of keys
generated for signing scheme s, and |nR| is the size of the
servers contribution to the unique identiﬁers. (The current
proposal is 24 bytes.)

We deﬁne version downgrade security similarly to down-
grade security via a function Versionr that maps two opposite-
role conﬁgurations (which include the version numbers) to the
version number negotiated (if any) in the absence of active
(cid:2)
adversaries. Formally, if a session π talking to a session π
completes, it must be the case that π.v = Versionr(cfgr, cfg¯r).
Akin to downgrade security, our deﬁnition of version down-
grade security is parameterized by a version downgrade
protection predicate VDP on pairs of conﬁgurations. When
VDP(cfgr, cfg¯r) holds, we expect that the local session r is
protected. For TLS, we will only consider version downgrade
protection from the client’s perspective.

Π, VDP(A) of A against

(cid:2) such that VDP(π.cfg, π
(cid:2)
.cfg).

Deﬁnition 12 (Version downgrade security): The advan-
tage Advversion
the version downgrade
security of Π is the probability that, when A terminates
after interacting with protocol Π through its oracles, there
exists a session π such that π.complete = true and there
.cfg) but
is a partnered session π
π.v (cid:5)= Versionπ.role(π.cfg, π
Theorem 9 (Version downgrade security of TLS 1.0–1.3):
(cid:2)) implies that cfg.role = I
Let VDP be such that VDP(cfg, cfg
and that all public keys in the range of cfg.PKsR are honest
(cid:2)
support at least TLS 1.3 and
and such that both cfg and cfg
activate the countermeasure.
Given an adversary A against the version downgrade se-
curity of our sub-protocol, we construct adversaries Bs,p
the same time as A such that
and Bh running in about
Advversion

(cid:4)
TLS1.0-TLS1.3-sub, VDP(A) is at most
n2

(cid:4)

(cid:2)

AdvCR

h, H(Bh) +

nsAdvEUF-CMA

s, p, Ps

(Bs,p) ,

2|nR|+1

+

h∈H(cid:2)

(s,p)∈sig(M(cid:2))

where n is the number of sessions, ns is the number of keys
generated for signing scheme s, and |nR| is the size of the
servers contribution to the unique identiﬁers.
For predicates DP and VDP such that DP ⊆ VDP, let
DP+VDP be the predicate that holds for pairs of conﬁgurations
in DP, with server conﬁgurations extended to support conﬁg-
urations of lower version protocols that by VDP should never
be negotiated. Putting Theorems 8 and 9 together, we get that
when both client and server implement the countermeasures,
then clients supporting multiple versions including TLS 1.3 are

522522

Client I

Server R

Client I

Server R

m0 = (nI , F0(cfg I ))

(cid:2)
0 = GR

m

m1 = (nI , F1(cfg I , GR))

= (nI , nR)
= maxR | nR

uid
(cid:2)
n
R
mode = nego(F1(cfg I , GR), cfg R)

= (v, aR, GR, pk R, hash1)

m2 = (n

(cid:2)
R, v, aR, GR, pk R)

verifyVersion(n
uid = (nI , nR)

(cid:2)
R, v, cfg I )

0, m1, m2,−)))
(cid:2)
(cid:2)
2 = sign(sk R, hash1(H(m0, m
m

mode = (v, aR, GR, pk R, hash1)
check (cfg I , mode)
complete = true

complete = true

m1 = (nI , F (cfg I ))

= (nI , nR)
= maxR | nR

uid
(cid:2)
n
R
mode = nego(F (cfg I ), cfg R)
= (v, aR, pk R, G, hash1)

m2 = (n

R, v, aR, G, pk R, sign(sk R, hash1(nI | n
(cid:2)

R | G | gy)))
(cid:2)

(cid:2)
R, v, cfg I )

verifyVersion(n
uid = (nI , nR)
mode = (v, aR, pk R, G, hash 1)
check (cfg I , mode)
ms = kdf(gxy, nI | n

(cid:2)
R)

ms = kdf(gxy, nI | n

(cid:2)
R)

m3 = (gx, mac(ms, H(m1, m2, gx,−)))
(cid:2)(m1, m2, m3,−))
m4 = mac(ms, H

complete = true

complete = true

(a) A version downgrade ﬁx for TLS 1.3

(b) A version downgrade ﬁx for TLS 1.0–1.2

as good as supporting only TLS 1.3. Version 1.3 needs to be
always present as our version downgrade guarantees concern
downgrades from 1.3 to lower versions.
Corollary 1 (Downgrade security of TLS 1.0–1.3): Assume
DP ⊆ VDP and let VDP be such that VDP(cfg,·) implies that
cfg.role = I, that all public keys in the range of cfg.PKsR are
support at least TLS 1.3 and
honest and that cfg and cfg
activate the countermeasure. Given an adversary A against
the downgrade security of our sub-protocol, we construct
adversaries B and C running in about the same time as A
such that

(cid:2)

Advdowngrade

TLS1.0-1.3-sub, DP+VDP (A) ≤

Advversion

TLS1.0-1.3-sub, VDP(B) + Advdowngrade

TLS1.3-sub, DP

(C)

VIII. RELATED WORK

Downgrade as an attack vector: The role of downgrade
attacks in practical exploits against key exchange protocols
has been widely recognized [2, 10, 39, 43].

Moeller and Langley [38] propose the use of a Signaling
Cipher Suite Value (SCSV) in TLS that prevents version
downgrade attacks when all versions provide transcript au-
thentication. SSL 2.0 and 3.0 are being deprecated, partly to
prevent version downgrades as these versions do not support
TLS extensions [6, 41] and SSL 2.0 in any case does not pro-
vide transcript authentication. Similarly, ciphersuite hygiene is
frequently discussed in standard documents [32, 34].

Retroﬁtting countermeasures against downgrade attacks can
inadvertently introduce or amplify attack vectors. For instance,
as a countermeasure against version rollback in TLS-RSA,
clients incorporate the newest protocol version they support
in the PKCS#1-encrypted pre-master secret. Kl´ıma et al. [28]
showed that many server implementations revealed whether
the version in a decrypted secret matches the version adver-
tised in the ClientHello message, thus introducing a side-
channel that can be exploited to implement a decryption oracle.
Multi-ciphersuite security of SSH: Bergsma et al. [9] analyzed
SSH in a multi-ciphersuite setting. They split the protocol into

a negotiation phase NP and key-exchange phase SP, one for
each value of π.mode. They show that if each combination
NP(cid:13)SP is ACCE secure, then NP(cid:13) # »SP is multi-ciphersuite ACCE
secure. While they do not prove downgrade security per se,
the result of [21] adapted to SSH corresponds to a proof of
downgrade security for a DP predicate that guarantees that all
negotiable ciphersuites and versions provide ACCE security.
Sharing of public keys is admissible under the condition that
each sub-protocol is still secure in the presence of an auxiliary
oracle with long-term key functionality, e.g., signing, to simu-
late all other sub-protocols. In our terminology, the protocols
NP(cid:13)SP of Bergsma et al. [9] are single-mode restrictions of
NP(cid:13) # »SP. After their extension with auxiliary oracles providing
sufﬁcient access to long-term key functionalities, they are sub-
protocols in our sense. We prove downgrade protection for a
predicate DP that includes a much larger set of conﬁgurations.
Combined with the result of Bergsma et al. [9], our result
allows to prove multi-ciphersuite ACCE security when not all
sub-protocols in # »SP are ACCE secure, as long as we restrict
the protocol to conﬁgurations in DP that do not negotiate them
(cf. Theorem 1).
Previous downgrade security theorems about TLS 1.2: Dowl-
ing and Stebila [21] model ciphersuite and version negotiation
for TLS up to version 1.2 in the multi-ciphersuite setting
introduced by Bergsma et al. [9]. In our model, their result
corresponds to a proof of downgrade security for a DP
predicate that guarantees that all negotiable ciphersuites and
versions are strong enough to provide ACCE security and
that all public keys are honest and used at most by one
negotiable ciphersuite. Their optimality function ω is a more
limited variant of our Nego function and does not include
entity identiﬁers. Their main theorem, restated in §III-D, states
that under such conditions multi-mode authentication implies
downgrade security. This is a rather weak form of downgrade
security, but as shown by Logjam, TLS 1.2 does not provide
much stronger protection for clients. Servers that authenticate
clients can however obtain stronger guarantees.

523523

IX. CONCLUSION AND FUTURE WORK

REFERENCES

In this paper we put forward a methodology to analyze
the downgrade security of real-world key exchange protocols.
Our approach breaks down the complexity of analyzing a full
protocol by considering only a core sub-protocol that abstracts
away details that are irrelevant for negotiation of a protocol
mode. We showed that proving a simulatability property for
a sub-protocol is sufﬁcient for ensuring the soundness of our
methodology: proving the absence of downgrade attacks on the
sub-protocol is enough to guarantee the downgrade security
of the full protocol. In contrast, our methodology does not
provide completeness: it may very well be the case that a
particular choice of sub-protocol abstracts too much and ends
up allowing attacks that are impossible to turn into attacks
on the full protocol. Indeed, sometimes sieving through false
positives helped us to reﬁne our choice of sub-protocols.

Our analysis of exemplary protocols shows that many de-
signs fail to appropriately address downgrade security. We thus
advocate incorporating downgrade security as an integral part
of security models for key exchange protocols.

We believe that analyzing the downgrade security of typical
sub-protocols is within reach of automated tools. Symbolic
analysis tools like ProVerif [17] and Tamarin [37] seem par-
ticularly well suited to detect attacks on sub-protocols, helping
analysts to ﬁnd attacks against the full protocol or converge
toward a sub-protocol that rules out false positives. Computa-
tionally sound tools like CryptoVerif [16], on the other hand,
provide a means to prove the downgrade security of sub-
protocols and, provided the sub-protocol is a sound abstraction
of the full protocol, conclude that
the corresponding full
protocol also enjoys downgrade security. Finding a simulator
that witnesses the correctness of a sub-protocol appears to be a
more difﬁcult task that may require ingenuity. While this may
be out of reach of fully automated tools, interactive proofs
can be constructed and machine-checked with tools like e.g.
EasyCrypt [7]. Exploring the use of automated tools could
increase the conﬁdence in our proofs of downgrade security,
and perhaps ﬁnd other simpler or more practical attacks on
protocols for which we only showed negative results.

ACKNOWLEDGMENTS

We thank Cas Cremers, Travis Cross, and Antoine Delignat-
Lavaud for useful discussions, and the anonymous review-
ers for their valuable comments. The TLS 1.3 downgrade
countermeasures were formulated in collaboration with Eric
Rescorla, Martin Thomson, and the IETF TLS working group.
Karthikeyan Bhargavan is funded by the ERC grants CRYSP
and CIRCUS. Christina Brzuska is grateful to NXP for sup-
porting her chair for IT Security Analysis. This material is
based in part upon work supported by the U.S. National
Science Foundation under award EFRI-1441209; The Mozilla
Foundation; and the Ofﬁce of Naval Research under contract
N00014-11-1-0470.

524524

[1] B. Aboba, L. Blunk, J. Vollbrecht, J. Carlson, and H. Lev-
(EAP),”

kowetz, “Extensible Authentication Protocol
IETF RFC 3748, 2004.

[2] D. Adrian, K. Bhargavan, Z. Durumeric, P. Gaudry,
M. Green, J. A. Halderman, N. Heninger, D. Springall,
E. Thom´e, L. Valenta, B. VanderSloot, E. Wustrow,
S. Zanella-B´eguelin, and P. Zimmermann, “Imperfect
forward secrecy: How Difﬁe-Hellman fails in practice,”
in 22nd ACM Conference on Computer and Communi-
cations Security, 2015, pp. 5–17.

[3] N. J. AlFardan and K. G. Paterson, “Lucky thirteen:
Breaking the TLS and DTLS record protocols,” in 2013
IEEE Symposium on Security and Privacy, 2013, pp.
526–540.

[4] N. J. AlFardan, D. J. Bernstein, K. G. Paterson, B. Po-
ettering, and J. C. N. Schuldt, “On the security of RC4
in TLS,” in 22th USENIX Security Symposium, 2013, pp.
305–320.

[5] N. Aviram, S. Schinzel, J. Somorovsky, N. Heninger,
M. Dankel, J. Steube, L. Valenta, D. Adrian, J. A. Hal-
derman, V. Dukhovni, E. K asper, S. Cohney, S. Engels,
C. Paar, and Y. Shavitt, “DROWN: Breaking TLS with
SSLv2,” https://drownattack.com/, Mar. 2016.

[6] R. Barnes, M. Thomson, A. Pironti, and A. Langley,
“Deprecating Secure Sockets Layer Version 3.0,” IETF
RFC 7568, 2015.

[7] G. Barthe, B. Gr´egoire, S. Heraud, and S. Zanella-
B´eguelin, “Computer-aided security proofs for the work-
ing cryptographer,” in Advances in Cryptology, CRYPTO
2011, 2011, pp. 71–90.

[8] M. Bellare and P. Rogaway, “Entity authentication and
key distribution,” in CRYPTO 1993, 1993, pp. 232–249.
[9] F. Bergsma, B. Dowling, F. Kohlar, J. Schwenk, and
D. Stebila, “Multi-ciphersuite security of the secure shell
(SSH) protocol,” in 21st ACM Conference on Computer
and Communications Security, 2014, pp. 369–381.

[10] B. Beurdouche, K. Bhargavan, A. Delignat-Lavaud,
C. Fournet, M. Kohlweiss, A. Pironti, P.-Y. Strub, and
J. Zinzindohoue, “A Messy State of the Union: Taming
the Composite State Machines of TLS,” in 2015 IEEE
Symposium on Security and Privacy, 2015, pp. 535–552.
[11] K. Bhargavan and G. Leurent, “Transcript collision at-
tacks: Breaking authentication in TLS, IKE, and SSH,”
in Network and Distributed System Security Symposium
(NDSS’16), 2016.

[12] K. Bhargavan, C. Fournet, M. Kohlweiss, A. Pironti, and
P. Strub, “Implementing TLS with veriﬁed cryptographic
security,” in 2013 IEEE Symposium on Security and
Privacy, 2013, pp. 445–459.

[13] K. Bhargavan, C. Fournet, M. Kohlweiss, A. Pironti,
P. Strub, and S. Zanella-B´eguelin, “Proving the TLS
handshake secure (as it is),” in CRYPTO 2014, 2014,
pp. 235–255.

[14] K. Bhargavan, C. Brzuska, C. Fournet, M. Green,

tems – CHES 2003. Springer, 2003, pp. 426–440.

[29] K. Kobara, S. Shin, and M. Streﬂer, “Partnership in
key exchange protocols,” in 2009 ACM Symposium on
Information, Computer and Communications Security,
ASIACCS 2009, 2009, pp. 161–170.

[30] H. Krawczyk, “SIGMA: the ’SIGn-and-MAc’ approach
to authenticated Difﬁe-Hellman and its use in the IKE
protocols,” in CRYPTO 2003, 2003, pp. 400–425.

[31] H. Krawczyk, K. G. Paterson, and H. Wee, “On the
security of the TLS protocol: A systematic analysis,” in
CRYPTO 2013, 2013, pp. 429–448.

[32] A. Langley, N. Modadugu, and B. Moeller, “Transport
Layer Security (TLS) False Start,” Internet Draft, 2010.
[33] G. Lowe, “A hierarchy of authentication speciﬁcation,” in
10th Computer Security Foundations Workshop (CSFW
’97).

IEEE Computer Society, 1997, pp. 31–44.

[34] R. H. M. Salter, E. Rescorla, “Suite B Proﬁle for Trans-

port Layer Security (TLS),” IETF RFC 5430, 2009.

[35] N. Mavrogiannopoulos, F. Vercauteren, V. Velichkov,
and B. Preneel, “A cross-protocol attack on the TLS
protocol,” in 19th ACM Conference on Computer and
Communications Security, 2012, pp. 62–72.

[36] C. Meadows, “Analysis of the internet key exchange
protocol using the NRL protocol analyzer,” in 1999 IEEE
Symposium on Security and Privacy, 1999, pp. 216–231.
[37] S. Meier, B. Schmidt, C. Cremers, and D. Basin, “The
tamarin prover for the symbolic analysis of security pro-
tocols,” in 25th International Conference on Computer
Aided Veriﬁcation, CAV 2013, 2013, pp. 696–701.

[38] B. Moeller and A. Langley, “TLS Fallback Signaling
Cipher Suite Value (SCSV) for Preventing Protocol
Downgrade Attacks,” IETF RFC 7507, 2015.

[39] B. M¨oller, T. Duong, and K. Kotowicz, “This POODLE
Bites: Exploiting The SSL 3.0 Fallback,” Available at
https://www.openssl.org/∼bodo/ssl-poodle.pdf, 2014.

[40] E. Rescorla, “The Transport Layer Security (TLS) Pro-

tocol Version 1.3, Draft 10,” Internet Draft, 2015.

[41] S. Turner and T. Polk, “Prohibiting Secure Sockets Layer

(SSL) Version 2.0,” IETF RFC 6176, 2011.

[42] University of Michigan, “Tracking the FREAK Attack,”

Available at https://freakattack.com/, November 2015.

[43] D. Wagner and B. Schneier, “Analysis of the SSL 3.0
protocol,” in 2nd USENIX Workshop on Electronic Com-
merce, WOEC 1996, 1996, pp. 29–40.

[44] T. Ylonen and C. Lonvick, “The secure shell (SSH)

authentication protocol,” IETF RFC 4252, 2006.

[45] ——, “The secure shell (SSH) transport layer protocol,”

IETF RFC 4253, 2006.

[46] P. Zimmermann, “RFC 6189bis: ZRTP: Media Path Key

Agreement for Unicast Secure RTP,” 2012.

M. Kohlweiss, and S. Zanella-Bguelin, “Downgrade re-
silience in key-exchange protocols,” Cryptology ePrint
Archive, Report 2016/072, 2016, http://eprint.iacr.org/.

[15] S. Blake-Wilson, M. Nystrom, D. Hopwood,
J. Mikkelsen, and T. Wright, “Transport Layer Security
(TLS) Extensions,” IETF RFC 3546, 2003.

[16] Blanchet, “A computationally sound mechanized prover
for security protocols,” Dependable and Secure Comput-
ing, IEEE Transactions on, vol. 5, no. 4, pp. 193–207,
2008.

[17] B. Blanchet, “An efﬁcient cryptographic protocol veriﬁer
based on prolog rules,” in 14th IEEE Computer Security
Foundations Workshop, CSFW 2014, 2001, pp. 82–96,.
[18] R. Canetti and H. Krawczyk, “Security analysis of IKE’s
signature-based key-exchange protocol,” in CRYPTO
2002, 2002, pp. 143–161.

[19] C. J. F. Cremers, “Key exchange in IPsec revisited:
Formal analysis of IKEv1 and IKEv2,” in 16th Euro-
pean Symposium on Research in Computer Security –
ESORICS 2011, 2011, pp. 315–334.

[20] A. Delignat-Lavaud and K. Bhargavan, “Network-based
origin confusion attacks against HTTPS virtual hosting,”
in 24th International Conference on World Wide Web,
WWW 2015, 2015, pp. 227–237.

[21] B. Dowling and D. Stebila, “Modelling ciphersuite and
version negotiation in the TLS protocol,” in 20th Aus-
tralasian Conference on Information Security and Pri-
vacy, ACISP 2015, 2015, pp. 270–288.

[22] B. Dowling, M. Fischlin, F. G¨unther, and D. Stebila, “A
cryptographic analysis of the TLS 1.3 handshake protocol
candidates,” in 22nd ACM Conference on Computer and
Communications Security, 2015, pp. 1197–1210.

[23] C. Garman, K. G. Paterson, and T. V. der Merwe, “At-
tacks only get better: Password recovery attacks against
RC4 in TLS,” in 24th USENIX Security Symposium,
2015, pp. 113–128.

[24] D. Harkins and D. Carrel, “The internet key exchange
(IKE),” IETF RFC 2409, 1998. [Online]. Available:
http://www.ietf.org/rfc/rfc2409.txt

[25] T. Jager, F. Kohlar, S. Sch¨age, and J. Schwenk, “On the
security of TLS-DHE in the standard model,” in CRYPTO
2012, 2012, pp. 273–293.

[26] M. Just and S. Vaudenay, “Authenticated multi-party key

agreement,” in ASIACRYPT 1996, 1996, pp. 36–49.

[27] C. Kaufman, P. Hoffman, Y. Nir, and P. Eronen, “Internet
Key Exchange Protocol Version 2 (IKEv2),” IETF RFC
5996, 2010.

[28] V. Kl´ıma, O. Pokorn´y, and T. Rosa, “Attacking RSA-
based sessions in SSL/TLS,” in 5th International Work-
shop on Cryptographic Hardware and Embedded Sys-

525525

