Full Proof Cryptography: Veriﬁable Compilation of

Efﬁcient Zero-Knowledge Protocols∗

José Bacelar Almeida

HASLab - INESC TEC
Univ. do Minho, Portugal

jba@di.uminho.pt

Gilles Barthe

IMDEA Software Institute

Madrid, Spain

Manuel Barbosa

HASLab - INESC TEC
Univ. do Minho, Portugal
mbb@di.uminho.pt

Stephan Krenn†

IST Austria

Klosterneuburg, Austria

Endre Bangerter

Bern Univ. of Appl. Sciences

Bern, Switzerland

endre.bangerter@bfh.ch

Santiago Zanella Béguelin

Microsoft Research

Cambridge, UK

gilles.barthe@imdea.org

stephan.krenn@ist.ac.at

santiago@microsoft.com

ABSTRACT
Developers building cryptography into security-sensitive applica-
tions face a daunting task. Not only must they understand the se-
curity guarantees delivered by the constructions they choose, they
must also implement and combine them correctly and efﬁciently.
Cryptographic compilers free developers from this task by turn-
ing high-level speciﬁcations of security goals into efﬁcient imple-
mentations. Yet, trusting such tools is hard as they rely on com-
plex mathematical machinery and claim security properties that are
subtle and difﬁcult to verify. In this paper we present ZKCrypt,
an optimizing cryptographic compiler achieving an unprecedented
level of assurance without sacriﬁcing practicality for a comprehen-
sive class of cryptographic protocols, known as Zero-Knowledge
Proofs of Knowledge. The pipeline of ZKCrypt integrates purpose-
built veriﬁed compilers and verifying compilers producing formal
proofs in the CertiCrypt framework. By combining the guarantees
delivered by each stage, ZKCrypt provides assurance that the out-
put implementation securely realizes the abstract proof goal given
as input. We report on the main characteristics of ZKCrypt, high-
light new deﬁnitions and concepts at its foundations, and illustrate
its applicability through a representative example of an anonymous
credential system.

∗This work was partially funded by National Funds through
the FCT - Fundação para a Ciência e a Tecnologia (Portuguese
Foundation for Science and Technology) within project ENI-
AC/2224/2009, by ENIAC Joint Undertaking under grant agree-
ment number 120224, European Projects FP7-256980 NESSoS
and FP7-229599 AMAROUT, Spanish National project TIN2009-
14599 DESAFIOS 10, and Madrid Regional project S2009TIC-
1465 PROMETIDOS.
†Most of this work was done while the author was at Bern Univer-
sity of Applied Sciences and University of Fribourg.

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
CCS’12, October 16–18, 2012, Raleigh, North Carolina, USA.
Copyright 2012 ACM 978-1-4503-1651-4/12/10 ...$15.00.

Categories and Subject Descriptors
D.2 [Software Engineering]: Software/Program Veriﬁcation; D.3
[Programming Languages]: Processors—Compilers

Keywords
Zero-knowledge, verifying compilation, cryptographic compiler

1.

INTRODUCTION

Zero-Knowledge Proofs of Knowledge (ZK-PoKs) [33, 34] are
two-party protocols in which a prover convinces a veriﬁer that it
knows a secret piece of information satisfying some property with-
out revealing anything except the correctness of this claim. ZK-
PoKs allow obtaining assurance on a prover’s honest behavior with-
out compromising privacy, and are used in a number of practical
systems, including Direct Anonymous Attestation (DAA) [15], a
privacy-enhancing mechanism for remote authentication of com-
puting platforms, the identity mixer [17], an anonymous credential
system for user-centric identity management, Off-the-Record mes-
saging [13,31], a protocol enabling deniability in instant messaging
protocols, and privacy-friendly smart metering [47], an emerging
technology for smart meters. However, more than 25 years after
their inception [32], the potential of ZK-PoKs has not yet been fully
realized, and many interesting applications of ZK-PoKs still only
exist at the speciﬁcation level. In our experience, one main hurdle
towards a larger use of ZK-PoKs is the difﬁculty of designing and
correctly implementing these protocols for custom proof goals.

Zero-knowledge compilers [6, 43] are domain-speciﬁc compil-
ers that automatically generate ZK-PoKs for a large class of proof
goals. They are a promising enabling technology for ZK-PoKs, be-
cause they allow developers to build cryptographic protocols that
use them, without deep expertise in cryptography, and without the
risk of introducing security ﬂaws in their implementations. Zero-
knowledge compilers embed a sophisticated mathematical machin-
ery, and as a consequence implementing them correctly can be
difﬁcult—arguably more difﬁcult than implementing optimizing
compilers. Moreover, such compilers cannot be tested and de-
bugged because their purported correctness properties are formu-
lated in the style of provable security, and testing such properties is
out of reach of current methods. This leaves practitioners with no
other option than blindly trusting that the compiler is correct.
Contributions. We present ZKCrypt, a high-assurance zero-know-
ledge compiler that outputs formally veriﬁed and optimized imple-
mentations of ZK-PoKs for a comprehensive set of proof goals.

488.zk File

.psl File

Templates

Proof goal G

Resolution

Resolved goal 

Implementation

Gres

.pil File
Optimized 

implementation 

Iopt

Generation

.c or .java Files

C or Java 

implementation

CACE Compiler

CertiCrypt

Proof goal G

Automatic
Veriﬁcation

Translate, 
Recover and
correctness of

Gres wrt G

Resolved goal 

Gres

Veriﬁed

Compilation

Reference 

implementation Iref

Completeness, 

Proof of Knowledge 

and

Zero Knowledge of 

Iopt wrt Gres

Optimized 

implementation 

Iopt

Automatic
Veriﬁcation

Observational 
equivalence 
of Iopt vs Iref

Completeness, Proof of Knowledge and 

Zero Knowledge of Iopt wrt goal G

Figure 1: ZKCrypt architecture, depicting a verifying compiler that takes high-level proof goals G to optimized implementations
(top), relying on a veriﬁed compiler implemented in Coq/CertiCrypt (center). Full lines denote compilation steps and translation
over formalization boundary (i.e. the generation of code that can be fed into formal veriﬁcation tools), dashed lines denote formal
veriﬁcation guarantees. Rectangular boxes denote code in various (intermediate) languages either stored in ﬁles or as data structures
in memory. Rounded rectangles represent the main theorems that are generated and formally veriﬁed by ZKCrypt and which jointly
yield the desired formal correctness and security guarantees.

We consider in particular Σ-protocols [24] for proving knowl-
edge of pre-images under group homomorphisms, which underly
essentially all practically relevant applications of ZK-PoKs, in-
cluding those mentioned above and the identiﬁcation schemes by
Schnorr [49] and Guillou-Quisquater [36].

ZKCrypt achieves an unprecedented level of conﬁdence among
cryptographic compilers by leveraging and transposing to the realm
of cryptography two recent breakthroughs: veriﬁed compilation
[39], in which the correctness of a compiler is proved once and
for all, and verifying compilation [45, 52], in which the correctness
of the output of a compiler is proved for each run. Speciﬁcally,
ZKCrypt implements a veriﬁed compiler that generates a reference
implementation, and a verifying compiler that outputs an optimized
implementation provably equivalent to the reference implementa-
tion. Taken together, the proofs output by the compilers establish
that the reference and optimized implementations satisfy the fol-
lowing properties1 (see §3 for formal deﬁnitions):

• Completeness: an honest prover can always convince an hon-

est veriﬁer;

• Proof of knowledge: a malicious prover not knowing the
secret cannot convince the veriﬁer, except with some small
probability;

• Zero-knowledge: a veriﬁer following the protocol cannot

learn additional information about the secret.

The architecture of the compiler is shown in Figure 1. At the top
level, ZKCrypt is composed of a chain of compilation components
that generates C and Java implementations of ZK-PoKs; these im-
plementations can be turned into executable binaries using general-
purpose compilers. These top-level components are an extension
of the CACE compiler [2] with support for user-deﬁned templates
and high-level proof goals. At the bottom level, ZKCrypt generates
formal proofs in the CertiCrypt framework [8]. The compilation
component is independent of the veriﬁcation component.

The main compilation phases in ZKCrypt are the following:

1In the remainder of this paper, we refer to these three properties
as the (relevant) security properties of ZK-PoKs.

Resolution takes a user-friendly description of proof goal G and
outputs an equivalent goal Gres, where high-level range
restrictions are converted, using standard techniques, into
proofs of knowledge of pre-images under homomorphisms;
such pre-image proofs are atomic building blocks that cor-
respond to well known concrete instances of ZK-PoK pro-
tocols, which can be handled by subsequent compilation
phases. The correctness of resolution is captured by a trans-
formation that provably converts ZK-PoK protocols for Gres
into ZK-PoK protocols for G. The compiler implements both
the decomposition and the transformation, and we prove a set
of sufﬁcient conditions for correctness and security;

Veriﬁed compilation takes a resolved goal Gres and outputs a ref-
erence implementation Iref in the embedded language of Cer-
tiCrypt. A once-and-for-all proof of correctness guarantees
that this component only produces reference implementa-
tions that satisfy the relevant security properties, for all sup-
ported input goals. This result hinges on two contributions
of independent interest: a uniﬁed treatment of the proof of
knowledge property, and a formalization of statistical zero-
knowledge;

Implementation takes a resolved goal Gres and outputs an opti-
mized implementation Iopt. The correctness of this step is
established, in the style of verifying compilation, using an
equivalence checker proving semantic equivalence between
the reference and optimized implementations Iref and Iopt.

Generation takes the optimized implementation Iopt and produces
implementations of the protocol
in general-purpose lan-
guages. This component in the compiler is the same as that
presented in [2], and is not veriﬁed.

Combining the correctness results for each phase yields a proof that
the optimized implementation Iopt satisﬁes the security properties
of the original high-level goal G. This approach is the same as
veriﬁed compilers such as CompCert [39]. As in CompCert, it is
convenient to combine certiﬁed and certifying compilation, instead
of certifying the whole compiler chain. Our results show that these
techniques are also beneﬁcial for cryptographic compilers.

489New additions to the compiler. There are main two aspects in
which this work extends the CACE compiler [2]. Firstly, the ver-
iﬁcation back-end of ZKCrypt supports more proof goals: by ad-
dressing ΣGSP-protocols and high-level goal resolution, we can ver-
ify implementations satisfying the needs of many practical appli-
cations. Secondly, in addition to soundness, ZKCrypt also for-
mally veriﬁes the completeness and HVZK properties, covering
all properties relevant to practical applications. Achieving these
extensions posed signiﬁcant challenges. The theoretical aspects
surrounding ΣGSP-protocols are knottier compared to Σφ-protocols
addressed in [2, 11]. For example, reasoning about statistical dis-
tance and dealing with computational assumptions required to de-
velop a backend from scratch based on cryptography-speciﬁc ver-
iﬁcation tools. Indeed, using formal tools such as CertiCrypt as
backends for verifying the compilation of cryptographic protocols
is unprecedented.
Limitations. Although the veriﬁcation component of our compiler
is comprehensive, it currently has two limitations. First, ZKCrypt
delivers formal guarantees about the correctness of the optimized
implementation Iopt, but not for the last step in the compilation
chain, namely the generation of Java or C code. Although we con-
sider the veriﬁcation of this last compilation step as an important
direction for future development, we see this as an independent
line of work because the veriﬁcation goals involved at this level are
of a different nature to those presented in this paper. Speciﬁcally,
the natural path to achieve correctness guarantees about binaries is
to extend ZKCrypt with formal veriﬁcation at the code generation
level, and then to use a high-assurance compiler from C or Java to
binaries. Given the characteristics of the programming language
used for the optimized implementations Iopt, the key step to adding
a formal veriﬁcation back-end for code generation is to build a cer-
tiﬁed number theory library that matches the one provided with
the CACE compiler. Compilation from C to binaries can then be
certiﬁed directly using state-of-the-art veriﬁed compilers, such as
CompCert [39]. Second, we do not prove completeness of veriﬁ-
cation, i.e., that all CACE compiler programs can be veriﬁed by our
component. A reason for this is that there are some known sources
of incompleteness, as some of the proof goals that can be handled
by the CACE compiler are not yet supported. A more fundamental
reason is that certifying compilation techniques, as used by part of
the formal veriﬁcation back-end, are seldom proved complete; in-
stead, one validates the effectiveness of a technique by its ability to
cover a wide range of examples. As we will show, ZKCrypt sat-
isfactorily complies with this more practical view, as the class of
goals for which veriﬁcation is available is already broad enough to
cover most practical applications.
Paper organization. The applicability of ZKCrypt is illustrated in
§2 through a use case from the identity mixer anonymous creden-
tial system [17]; §3 provides some necessary background material;
§4–§6 explain the resolution, veriﬁed compilation and implementa-
tion phases, respectively; §7 brieﬂy reports on further experimental
results. We conclude with a discussion of related work in §8 and
future research directions in §9.

2. USE CASE

Anonymous credential systems [22,23] are among the most prac-
tically relevant applications of ZK-PoKs; examples of prominent
realizations include the IBM identity mixer library (Idemix) [21],
the Microsoft U-Prove toolkit [44], as well as Trusted Platform
Modules (TPMs), which implement the Direct Anonymous Attes-
tation (DAA) protocol [15], and are widely built into consumer lap-
tops and PCs. In a further and coordinated effort to bring anony-

mous credential systems to practice, the ABC4Trust project [1] is
working to deliver open reference implementations of attribute-
based credential systems, and to integrate them into real-world
identity-management systems.

An anonymous credential system consists of a collection of pro-
tocols to issue, revoke, prove possession of credentials, etc. One
key feature for ensuring anonymity is that users can selectively
reveal certain identity attributes without disclosing anything else.
In the Idemix system [21] this goal is realized using Camenisch-
Lysyanskana (CL) signatures [18]. Informally, such a signature on
two messages m1, m2 consists of integers e, v and A ∈ Z∗
n satisfy-
ing Z = Rm1
2 SvAe, where R1, R2, S, Z are public quadratic
residues modulo n, and n is a strong RSA modulus (i.e., n = pq
where p, q, (p − 1)/2 and (q − 1)/2 are all prime).

1 Rm2

Assume now that a user holds a signature on his name m1 and his
birthdate m2. Now, when authenticating to a server, the user may
be willing to reveal his name but not his birthdate. On the other
hand, he is required to show that he was born after some date b to
get student discount. To achieve authentication agreeably to both
parties, the user will reveal m1 and A, and then give a ZK-PoK
that he knows m2, e, v such that (e, v, A) is a valid CL-signature
on (m1, m2). Using the standard notation for ZK-PoK [20], this
goal G is formally stated as:

ZPKh (m2, v, e) :

Z
Rm1

1

= Rm2

2 SvAe ∧ m2 ≥ bi

(1)

The convention in the formulation above is that knowledge of all
values before the colon has to be proved, while all other values are
assumed to be publicly known. Note that the ﬁrst conjunct shows
possession of a valid CL-signature on m1, m2, and the second con-
junct shows that m2 ≥ b, as required by the server policy.

ZKCrypt generates an optimized implementation of a ZK-PoK
and machine-checkable proofs that it satisﬁes the relevant security
properties. We give below an overview of the compilation process.

Resolution. ZKCrypt resolves the above proof goal G to the fol-
lowing goal Gres:

ZPKh (e, m2, v, r∆, u1, u2, u3, u4, r1, r2, r3, r4, α) :

2 ∧ T∆Z b = Zm2 Sr∆ ∧

= AeSvRm2

Z
Rm1

1

4

^i=1

Ti = Z ui Sri ∧ T∆ = T u1

1 T u2

2 T u3

3 T u4

4 Sαi

The ﬁrst conjunct is obtained by unfolding the deﬁnition of the CL
predicate, making explicit the groups elements Z and S used in
the signature. The remaining conjuncts are obtained by applying
Lipmaa’s technique [40] to resolve the goal m2 ≥ b into equalities
between exponentiations of Z and S. This compilation step and
the formal veriﬁcation of its correctness are described in detail in
§4. In short, we formalize the sufﬁcient conditions for correctness
based on a procedure Translate for turning a witness for G into a
witness for Gres and a procedure Recover for computing a witness
for Gres from a witness for G.

Veriﬁed compilation This phase outputs a reference implementa-
tion Iref in the embedded language of CertiCrypt. This is done in
two steps: ﬁrst, ZKCrypt extends the base language of CertiCrypt
by specifying and deﬁning the necessary algebraic constructions,
e.g., the underlying group with its operations and generators. Sec-
ond, the compiler instantiates a CertiCrypt module for Σ-protocols
with the resolved goal Gres expressed using a single homomorphism

490Φ. In the use case we present, Φ is deﬁned as:

Φ (e, m2, v, r∆, u1, u2, u3, u4, r1, r2, r3, r4, α)

.
=

i=1 T ui

(cid:0)AeSvRm2

2

i (cid:1)

, Zm2 Sr∆ , Z u1 Sr1 , . . . , Z u4 Sr4 , Sα Q4

This instantiation yields a reference implementation Iref of a ZK-
PoK protocol, comprising four procedures that represent the com-
putations performed by each party during a run of a Σ-protocol.
Each procedure consists of either a random assignment followed
by a deterministic assignment, or just a deterministic assignment.
The completeness, proof of knowledge, and honest veriﬁer zero-
knowledge (HVZK) properties of Iref are a direct consequence of
generic proofs in CertiCrypt.
Interestingly, statistical HVZK is
established using an approximate version of the Probabilistic Rela-
tional Hoare Logic of CertiCrypt, which has been recently devel-
oped for different purposes [9].
Implementation This phase outputs a representation Iopt that can
be used for code generation. Contrary to the reference implemen-
tation, Iopt does not adhere to a constrained shape; in particular,
it uses long sequences of instructions and branching statements.
Also, algebraic expressions are re-arranged in order to enable opti-
mizations during code generation. The equivalence of Iopt and Iref
is proved in two steps. First, ZKCrypt builds a representation of
Iopt in the embedded language of CertiCrypt. It then generates a
proof that Iopt satisﬁes the relevant security properties, by establish-
ing that each algorithm in the protocol is observationally equivalent
to the matching algorithm in the reference implementation.

By glueing together the correctness proofs of the different
phases, one obtains the end-to-end guarantee that Iopt is a correct
implementation of a ZK-PoK for G.

3. ZERO-KNOWLEDGE PROOFS

In the remainder, we denote deterministic assignments by y ←
f (x), and uniformly random assignments by x $← A, where A may
be a set or a randomized algorithm.

All ZK proofs generated by ZKCrypt are Σ-protocols:

DEFINITION 1

(Σ-PROTOCOL). Let R denote a binary rela-
tion, (x, w) ∈ R, and let P1, P2, and V denote arbitrary algo-
.
= P(x, w) and a prob-
rithms. A protocol between a prover P
.
= V(x) is called a Σ-
abilistic polynomial-time (PPT) veriﬁer V
protocol with challenge set C = {0, . . . , c+–1}, if it satisﬁes the
following conditions.

3-move form. The protocol is of the following form:

• P sets (r, st) $← P1(x, w) and sends r to V;
• V sends a random challenge c $← C to P. We refer to the

algorithm that samples the challenge as Vc;
• P sends s ← P2(x, w, st, c) to the veriﬁer;
• V accepts if V(x, r, c, s) = true, otherwise V rejects.

Completeness. For an honest prover P, the veriﬁer V accepts on

common input x, whenever (x, w) ∈ R.

Every triple (r, c, s) for which V(x, r, c, s) = true is called an

accepting conversation.

Informally, a two-party protocol is a proof of knowledge if from
every successful (potentially malicious) prover P ∗, a witness can
be extracted within a certain time bound by a knowledge extractor
algorithm. For all practically relevant Σ-protocols, the knowledge
extractor works in two phases. First, using rewinding black-box
access to P ∗, two accepting conversations (r, c, s) and (r, c′, s′)
are extracted. Then, in a second step, a witness is computed from
these conversations. The ﬁrst part of the knowledge extractor is

well-known to work for arbitrary Σ-protocols [26]. ZKCrypt does
not include a formalization of the proof of this part of the knowl-
edge extractor, as this would imply formalizing rewinding argu-
ments and reasoning about expected polynomial time executions,
which are currently out of reach of formal veriﬁcation tools such as
CertiCrypt. The second phase of extraction only works only under
certain conditions, which are formalized next:

DEFINITION 2

(GENERALIZED SPECIAL SOUNDNESS).

A Σ-protocol satisﬁes generalized special soundness for a relation
R′, if there is a PPT extractor that, on input a relation R $← R(1λ),
a value x in the language deﬁned by R, and any two accepting con-
versations, (r, c, s) and (r, c′, s′) satisfying R′, computes a witness
w satisfying R(x, w) with overwhelming probability.

Observe that a Σ-protocol satisfying this deﬁnition is a proof of
knowledge for R if the conversations extracted by the ﬁrst phase of
the knowledge extractor satisfy R′.

Deﬁnition 2 is a generalization of the classical notion of special
soundness found in the literature, e.g., Cramer [24], and enables a
uniform formalization of the proof of knowledge property for all
Σ-protocols supported by ZKCrypt. Following this approach we
extend the modularization of the proof of knowledge property that
is well-known for other Σ-protocols, so that we can treat ΣGSP-
protocols in a similar way.

Roughly, the special extractor algorithm can only recover a valid
witness if the accepting conversations display speciﬁc properties
captured by relation R′. Furthermore, in some cases, the existence
of an algorithm that is able to extract these conversations relies on a
computational assumption. To account for this, following Damgård
and Fujisaki [27], we allow relation R to be sampled using an efﬁ-
cient algorithm R. We will detail R and R′ for each concrete in-
stance of a Σ-protocol later2. The implication for our formalization
approach is that the soundness of the protocols veriﬁed by ZKCrypt
is guaranteed, provided that the relations are sampled from the dis-
tribution generated by the prescribed algorithm R.

The proof of knowledge property ensures a veriﬁer that a con-
vincing prover indeed knows the secret. On the other hand, the
veriﬁer should not be able to deduce any information about this
witness. This is captured by the zero-knowledge property. In the
following, we denote by viewP
V (x) the random variable describing
the content of the random tape of V and the messages V receives
from P during a successful protocol run on common input x.

DEFINITION 3

(HONEST VERIFIER ZERO KNOWLEDGE).

A protocol (P, V) is perfectly (resp. statistically) honest-veriﬁer
zero-knowledge (HVZK), if there exists a PPT simulator S such
that the distribution ensembles {S(x)}x and {viewP
V (x)}x are
perfectly (resp. statistically) indistinguishable, for all inputs x in
the language of R.

Note that this deﬁnition only gives guarantees against veriﬁers
that do not deviate from the protocol speciﬁcation. Security against
arbitrarily behaving veriﬁers can be realized using the Fiat-Shamir
heuristic [29] to make the protocol non-interactive, which is also
supported by our compiler (although, as we will explain later, this
is currently outside of the scope of the veriﬁcation back-end).
The ΣGSP-protocol. Most practical applications of ZK-PoKs are
proofs for pre-images under a group homomorphism φ : G → H.
Depending on whether G is ﬁnite or G ≃ Z, (typically) either the
Σφ-, the Σexp-, or the ΣGSP-protocol is used [2]. In the following
2For the completeness and zero-knowledge properties, we quantify
over all relations R in the range of R.

491we recapitulate the ΣGSP-protocol, which is central for understand-
ing the remainder, as it is used for the running example. All the
mentioned techniques are also incorporated in ZKCrypt.

The so called Generalized Schnorr Protocol (ΣGSP-protocol) can
be used to prove knowledge of pre-images under arbitrary exponen-
tiation homomorphisms, in particular including such with a hidden-
order co-domain. That is, it can be used for mappings of the form:

φ : Zm → H : (w1, . . . , wm) 7→  m
Yi=1

gwi
1i , . . . ,

gwi

ui! .

m

Yi=1

In the protocol, an upper bound Ti on the absolute value of each
wi needs to be known. These values can be chosen arbitrarily
large, and required to assert that the protocol is (statistically) zero-
knowledge for wi ∈ [−Ti, Ti]. The protocol ﬂow and the parties’
algorithms are given in Figure 2, where ℓ is a security parameter.

P(x, (w1, . . . , wm))

V(x)

$←[−2Tic+2ℓ, 2Tic+2ℓ], 1 ≤ i ≤ m

ki
r ← φ(k1, . . . , km)

-

r

c



c $← C = {0, . . . , c+ − 1}

si ← ki + c(wi + Ti), 1 ≤ i ≤ m
s1, . . . , sm

-

= φ(s1 − cT1, . . . , sm − cTm)
?
∈ [−2Tic+2ℓ, 2Tic+2ℓ + 2Ti(c+ − 1)], 1 ≤ i ≤ m

rxc ?

si

Figure 2: Protocol ﬂow of the ΣGSP-protocol.

The ΣGSP-protocol is statistically HVZK for arbitrary values of

c+ (the simulation error is upper-bounded by m/2ℓ).

Concerning generalized special soundness, the relation genera-
tor R picks a group H in which the generalized strong RSA as-
sumption [30] holds (i.e., given x $← H, it is hard to ﬁnd (w, e) ∈
H × Z \ {−1, 0, 1} such that x = we), and deﬁnes:

R(x, (µ, w))

.
= x = µφ(w) ∧ µd = 1,

Here, φ is as before, the gij are generators of a large subgroup of
H with hidden order such that all relative discrete logarithms (i.e.,
all loggij
guv) are unknown to P, and d is the product of all primes
smaller than c+ dividing ord H.

The relation R′ is deﬁned as follows:

R′((r, c, s), (r, c′, s′))

.
= (c − c′)|(s − s′) .

It can be shown [27] that the conversations extracted in the ﬁrst step
of the knowledge extractor satisfy R′ with overwhelming probabil-
ity, given that H satisﬁes the generalized RSA assumption and φ
is deﬁned as above. Thus, the ΣGSP-protocol satisﬁes Deﬁnition 2
and is a ZK-PoK for R′.

For instance, if n = pq is sampled as a strong RSA modulus,
H = Z∗
n and the gij all generate the quadratic residues modulo
n, we get d = 4 and knowledge of a pre-image is proved up to a
fourth root of unity.

In practice one often has to prove
Combination of proof goals.
knowledge of multiple, or one out of a set of secret values in one
step. This can be achieved by so-called And- and Or-compositions
[25]. To support our description of the Idemix example in the rest
of the paper we only require And-compositions of ΣGSP-protocols
for homomorphisms φ1, . . . , φn. This can be realized by running a
single ΣGSP-protocol for the homomorphism φ = φ1 × · · · × φn.

4. GOAL RESOLUTION

ZKCrypt generates implementations for arbitrary Boolean And-
and Or-compositions of pre-image proofs under homomorphisms
and claims on the size of secrets. That is, besides claims on the
knowledge of pre-images also terms of the form w ∈ [L, R] for
secret w and public L, R ∈ Z are supported natively.

The ﬁrst compilation step consists of rewriting all semantic ex-
pressions to pre-image proofs, i.e., every term w ∈ [L, R] is rewrit-
ten to a proof speciﬁcation of the following form [38, 40]:

ZPKh(w, r, w1, . . . , w8, r1, . . . , r8, rw, rL, rR) :

8

xw = gwhrw ∧

xi = gwi hri ∧

^i=1

8

Yi=5

xwi

i hrwi .

(2)

xwg−L =

i hrL ∧ gRx−1
xwi

w =

4

Yi=1

Here, g and h are both random generators of a group of hidden
order (e.g., the quadratic residues modulo a strong RSA modulus
n). Further, logg h and logh g must be hard to compute. If such a
group is already used in the original proof goal, it may be reused.

4.1 A Cryptographic Perspective

We next describe how ZKCrypt deals with the formal veriﬁca-

tion of the goal translation stage.

The starting point in the goal resolution procedure is a (high-
level) goal G associated to a relation generation algorithm R, i.e.,
we aim to construct a Σ-protocol for proving (in zero-knowledge)
knowledge of a witness w for a public input x such that R(x, w)
holds, for R sampled from R. The resolution procedure ﬁrst deﬁnes
a generator for a (lower-level) family of relations Rres associated
with a resolved goal Gres and then deﬁnes a translation algorithm
Translate(R, x, w) which, on input a relation R and a pair (x, w),
produces the description of a relation Rres and a pair (x′, w′). The
following properties must be satisﬁed by the Translate algorithm:

1. Completeness. On a valid input (R, x, w), i.e., where R
is in the range of R and R(x, w) holds, Translate outputs
triples (Rres, x′, w′) such that Rres is in the range of Rres,
and Rres(x′, w′) holds.

2. Soundness. There is an efﬁcient algorithm Recover such
that for all PPT adversaries A the following holds for
R $← R, (x, w) ∈ R and (Rres, x′, w′) $← A(R, x, w):
if (Rres, x′) are in the range of Translate(R, x, w) and
Rres(x′, w′) holds, Recover(Rres, x′, w′) outputs ˜w such that
R(x, ˜w) holds with overwhelming probability.

3. Public veriﬁability. The public outputs of Translate, i.e.,
Rres and x′, can efﬁciently be checked to be in the correct
range for all valid public inputs (R, x).

4. Simulatability. There exists an efﬁcient simulator S which,
on input R sampled from R and x in the language that it de-
ﬁnes, outputs (Rres, x′) with a distribution identical (or sta-
tistically close) to that produced by Translate(R, x, w) for a
valid witness w.

Intuitively, public veriﬁability allows the veriﬁer to check that
the prover provides a valid output of Translate, and hence rely on
the soundness of this algorithm. Simulatability is necessary for
the HVZK property, as simulating traces for the complete protocol
implies simulating the public outputs of Translate.

Now, to construct a protocol for goal G, one ﬁrst generates de-
scriptions of algorithms P′
2 and V′ of a Σ-protocol for Gres, and
then deﬁnes the procedures for the high-level protocol as follows:

1, P′

492• P1(x, w) runs Translate(R, x, w) to get (Rres, x′, w′), and

P′

1(x′, w′) to get (r′, st′), and returns

(r, st) = ((Rres, x′, r′), (Rres, x′, w′, st′)).

• P2(x, w, c, st) recovers (Rres, x′, w′, st′) from st.
2(x′, w′, st′, c) to get s′ and returns s = s′.

runs P′

It then

• V(x, r, c, s) recovers (Rres, x′, r′) from r and checks that
Rres and x are in the correct range w.r.t. R and x. Then it
runs V′(x′, r′, c, s) and returns the result.

The correctness and security of the resulting protocol is established
in the following theorem.

THEOREM 1. Assume that algorithms P′

2 and V′ yield a
Σ-protocol for Rres, which is complete, HVZK and satisﬁes gen-
eralized special soundness for relation R′
res. Then, if Translate
satisﬁes the four properties listed above, algorithms P1, P2 and V
yield a Σ-protocol for R, which is complete, HVZK and satisﬁes
generalized special soundness for relation

1, P′

R′((Rres, x′, r′), c, s), (Rres, x′, r′), ˆc, ˆs)) = R′

res((r′, c, s), (r, ˆc, ˆs))

This result permits identifying the proof obligations that sufﬁce to
formally verify that the resulting protocol is correct and secure.
First of all, one needs to show that the low-level protocol is itself
correct and secure for the relation generator Rres (in ZKCrypt this
maps to the formal veriﬁcation of subsequent compilation steps,
which we discuss later). Secondly, one needs to show that the
Translate procedure has all properties described in the theorem.
Idemix goal resolution. To make things more concrete, let us go
back to the goal resolution performed by ZKCrypt and recast the
rewriting performed for a term of the form w ≥ b in the theoret-
ical framework above (an upper bound on w can be treated anal-
ogously). This matches the resolution of the proof goal in our
Idemix running example. From §2, and using x = Z/Rm1
, we
can rewrite the relation corresponding to goal G as

1

R(x, w)

.
= x = AeSvRm2

2 ∧ m2 ≥ b

(3)

Here, we have w = (e, m2, v). Similarly, using Y1 = T∆Z b, the
relation associated with resolved goal Gres is:

Rres(x′, w′)

.
= x = AeSvRm2

2 ∧ Y1 = Zm2 Sr∆ ∧

Ti = Z ui Sri ∧ T∆ = gu1

1 gu2

2 gu3

3 gu4

4 Sα

(4)

4

^i=1

Here w′ = (e, m2, v, r∆, u1, u2, u3, u4, r1, r2, r3, r4, α) and
x′ = (x, Y1, T1, T2, T3, T4, T∆). We observe that implicit in the
deﬁnition of these goals are the relation generators R and Rres that
produce descriptions of the (hidden order) groups and generators
that are used in the protocol. Furthermore, note that the resolved
goal Gres can be handled by the ΣGSP protocol, for which ZKCrypt
can generate an implementation of a ZK-PoK protocol which is
proven to display the relevant security properties.

Figures 3 and 4 provide the pseudo-code of the Translate and
Recover algorithms for the Idemix example. Observe the dual
role of the Ti values in Gres: these values appear both as generators
in Rres, and as images in x′. As we will see, this is essential to
guarantee that witnesses for the original goal G can be recovered.
We will now discuss how we prove that these algorithms satisfy
the hypotheses of Theorem 1, from which we can conclude that
resolution is correct.

Translate(R, x, w):

Parse (A, S, R2, Z) ← R
Parse (e, m2, v) ← w
Find (u1, u2, u3, u4) s.t. m2 − b = u2
$←[0..2|n|2ℓ], for i = ∆, 1, 2, 3, 4
ri

1 + u2

2 + u2

3 + u2

4

α ← r∆ −P4

i=1 uiri

4 Sα

3 T u4

2 T u3

1 T u2

Ti ← Z ui Sri , for i = 1, 2, 3, 4
T∆ ← T u1
Y1 ← T∆Z b
(g1, g2, g3, g4) ← (T1, T2, T3, T4)
x′ ← (x, Y1, T1, T2, T3, T4, T∆)
w′ ← (e, m2, v, r∆, u1, u2, u3, u4, r1, r2, r3, r4, α)
return (Rres, x′, w′)

Figure 3: Translate algorithm for Idemix example. Relations
R and Rres are as in (3) and (4).

Recover(Rres, x′, w′):

(e, m2, v, r∆, u1, u2, u3, u4, r1, r2, r3, r4, α) ← w′
w ← (e, m2, v)
return w

Figure 4: Recover algorithm for Idemix example

4.2 A Formal Veriﬁcation Perspective

We will continue to rely on the Idemix example to illustrate our
approach to verifying the goal translation step. We ﬁrst show how
we use EasyCrypt [10] to prove that the Translate algorithm from
Figure 3 satisﬁes the completeness and soundness properties. We
then discuss how the simulatability and public veriﬁability proper-
ties are handled with a once-and-for-all proof for supported goals.
Completeness of Translate. The idea underlying the complete-
ness property is the following. Assume a prover knows w ≥ b.
Then, by Lagrange’s Four Square Theorem [38], she can ﬁnd in-
i . By choosing
i=1 uiri she
can now clearly perform the above proof. Formally verifying this
property using EasyCrypt is achieved by proving that the follow-
ing experiment always returns true for all R in the range of R and
all pairs (x, w) such that R(x, w) holds:

tegers u1, . . . , u4 such that m − b = P4
r∆, r1, . . . , r4 at random, and deﬁning α = r∆ −P4

i=1 u2

(Rres, x′, w′) $← Translate(R, x, w); return Rres(x′, w′)

The Translate algorithm is represented in EasyCrypt in a form
very close to its description in Figure 3, with the sole difference that
the decomposition of m2 − b as a sum of four squares is computed
by applying a function assumed to correctly implement Lagrange’s
decomposition. The proof itself is written as a series of game tran-
sitions, where the initial experiment is gradually transformed until
it is reduced to the trivial program that simply returns true. All
transitions are proved automatically by the tool.
Soundness of Translate. A detailed speciﬁcation of the Recover
.
algorithm for the Idemix example is given in Figure 4. Let m′
=
2 ≥ b and, by the deﬁnition of Rres associ-
ated with Gres, we have that Z = AeSvRm1
2 . The correctness
of Recover thus hinges on the fact that R computationally guaran-
tees m2 = m′

2, down to the following assumption:

i + b. Clearly m′

P4

1 Rm2

i=1 u2

2

DEFINITION 4

(UNIQUE REPRESENTATION ASSUMPTION).
Let H be as before, and let Z and S be generators of H.
If a
PPT algorithm outputs (a, b), (a′, b′) ∈ Z × Z such that
Z aSb = Z a′
then, with overwhelming probability, we have
that a = a′ ∧ b = b′.

Sb′

Any witness w′ given to Recover, satisfying Rres(x′, w′), for pub-
licly validated Rres and x′, can be expressed in the following form:

Zm2 −bSr∆ = Zm′

2−bSα+P4

i=1 riui

493If m2 6= m′
2, the input witness would provide two alternative repre-
sentations for the same value under generators Z and S, contradict-
ing the unique representation assumption. Thus, necessarily with
overwhelming probability m2 = m′
2.

Formally, if the group parameters are generated in a particular
way, the unique representation assumption can be shown to hold in
n, down to the hardness of factoring the modulus n [19],
H = Z∗
e.g. when n is sampled as a strong RSA modulus. The Idemix
speciﬁcation incorporates this method into its parameter generation
procedure. We note that this computational assumption is used im-
plicitly throughout relevant literature when dealing with such trans-
formations. We believe that forcing such assumptions to be stated
explicitly is one of the advantages of using mechanized support to
validate security proofs for cryptographic protocols.

The correctness of this algorithm is again formally veriﬁed in
EasyCrypt. The proof is more intricate than in the case of Trans-
late, since we now must take into account the unique representation
assumption. The proof is quantiﬁed for all relations R in the range
of R, and all x and w such that R(x, w) holds. Consistently with
the deﬁnition of the soundness property, we begin by deﬁning the
following experiment in EasyCrypt:

(Rres, x′, w′) $← A(R, x, w);
w∗ ← Recover(Rres, x′, w′);
if ¬Rres(x′, w′) ∨ ¬pubVerify(R, x, Rres, x′) then return ⊥
else return R(x, w∗)

Here, an adversary (i.e., a malicious prover) A is given such an
input (R, x, w), and outputs a tuple (Rres, x′, w′). The Recover
algorithm is then called to produce a high-level witness. The ex-
periment output expresses that the event in which the adversary
produces a valid tuple (Rres, x′, w′) must imply that Recover suc-
ceeds in obtaining a valid high-level witness w∗. This is expressed
as a disjunction where either the adversary fails to produce publicly
veriﬁable Rres, x′ and a witness w′ such that Rres(x′, w′) holds,
or Recover must succeed. Public veriﬁability is captured by a
predicate pubVerify imposing that Y1 = T∆Z b, and gi = Ti for
i = 1, 2, 3, 4.

The proof establishes that this experiment is identical to the triv-
ial program that always returns true, conditioning on a failure
event that occurs when both Rres(x′, w′) and pubVerif(Rres, x′)
hold, but the witness w′ satisﬁes the following Boolean test:

i=1 u2

i + b ∨ r∆ 6=P4

i=1 riui + α

m2 6=P4

Intuitively, this failure condition can be triggered only if the ad-
versary was able to recover a low level witness which contradicts
the unique representation assumption: in the proof we show that
the probability of failure is bounded by the probability that an ad-
versary B ﬁnds two different representations for the same group
element under generators Z and S. On the other hand, condition-
ing on the event that failure does not occur, and through a series of
transformations involving algebraic manipulations, we show that
Recover always succeeds. Again, the validity of all transforma-
tions is handled automatically by EasyCrypt.
Integration and automation The above approach to formally ver-
ifying the goal resolution procedure was not integrated in earlier
versions of ZKCrypt. This meant that user intervention was re-
quired to deal with this compilation step, and hence the natural
back-end to use was EasyCrypt. This was not a major limitation
because in many practical scenarios, including Idemix, the output
of goal resolution is the speciﬁcation of the proof goal. Neverthe-
less, the latest release of ZKCrypt has been extended with an extra
component that deals with this compilation step without user inter-
vention. Formal veriﬁcation of this phase is handled in two steps:

1. Given a high-level goal G, a certiﬁed goal resolution module
implemented in Coq generates a description of a reference
low-level goal Gref
res and a description of the translation and re-
covery procedures. A once-and-for-all proof in Coq guaran-
tees that translation is complete and sound for the reference
low-level goal. This is done using essentially the same for-
malization approach as described above, extended to handle
the general case of ΣGSP-type goals where each pre-image
can be bounded with an arbitrary interval.

2. The resolved goal produced by the CACE compiler Gres is
then proven to be equivalent to Gref
res. This establishes that
the goal resolution step carried out by the CACE compiler is
indeed correct. The optimized implementation produced by
the CACE compiler is generated from Gres, as described in
the following Sections. This equivalence therefore provides
guarantees of correctness and security of the generated opti-
mized protocol with respect to the original high-level goal.

Public veriﬁability and simulatability. We now brieﬂy discuss why
the resolution procedure used in Idemix can be easily shown to sat-
isfy public veriﬁability and simulatability. This argument extends
to all instances of the resolution step implemented in ZKCrypt.

Looking at (4), one can immediately see that the public outputs
of Translate can be validated to be in the correct range assuming
that group membership can be efﬁciently checked, and given the
ﬁxed structure of the low-level relation. For simulatability we see
that the description (Rres, x′) output by Translate comprises the
values of the images x′ = (x, Y1, T1, T2, T3, T4, T∆) and genera-
tors (g1, g2, g3, g4) = (T1, T2, T3, T4). Since x and Y1 are fully
determined by public inputs and (T1, T2, T3, T4, T∆), all that re-
mains to show is that the latter values can be efﬁciently simulated.
Observing that the domain of ri is sufﬁciently large for the distribu-
tion of Sri (i ∈ {1, 2, 3, 4, ∆}) to be statistically close to uniform
in hSi, we conclude that the variables Ti are also statistically close
to uniform (note that Z and S are both generators of the same group
of hidden order). It follows that these values can be trivially simu-
lated by sampling uniformly random elements in the target group.

5. VERIFIED COMPILATION

At the core of the formal veriﬁcation tool of ZKCrypt sits a ver-
iﬁed compiler that generates correct and secure reference imple-
mentations of ZK-PoK for the following class of resolved proof
goals produced by the front end of the compiler:

(i) Atomic goals consisting of pre-image proofs under a homo-
morphism with a ﬁnite domain using the Σφ-protocol, includ-
ing product homomorphisms where the co-domain is a tuple
of images in the range of the group operation.

(ii) Atomic goals consisting of pre-image proofs under an expo-
nentiation homomorphism in a hidden-order group using the
ΣGSP-protocol, including product homomorphisms where the
co-domain is a tuple of images in the range of the group op-
eration. In particular, these include goals resulting from the
resolution of interval proofs as described in §4.

(iii) Arbitrary, possibly nested, AND- and OR-compositions of

proof goals as in point (i).

We stress that, although the code generation component of
ZKCrypt addresses an even broader set of proof goals, this class
was selected to cover essentially all practical applications. Indeed,
although we do not support compositions of ΣGSP-protocol, this
is only a restriction for OR-compositions, which are rarely used

494P1hGresi(x, w):

$← stTypehGresi

stP
r ← Prover1hGresi(x, w, stP )
return (r, stP )

VchGresi():

c $← cTypehGresi
return c

P2hGresi(x, w, c, stP ):

VhGresi(x, r, c, s):

s ← Prover2hGresi(x, w, c, stP )
return s

a ← VeriﬁerhGresi(x, r, c, s)
return a

Figure 5: Descriptions of reference implementations.

in practice. Flat AND-compositions can be achieved with product
homomorphisms.

Given a resolved proof goal Gres, the veriﬁed compiler is able
to generate a description of a reference implementation for a suit-
able Σ-protocol, consisting of CertiCrypt programs corresponding
to algorithms P1, P2, V and Vc. The generated descriptions of
these algorithms follow a carefully designed structure, tailored to
facilitate the formal proof that, for any goal, the (therefore) veriﬁed
compiler produces correct and secure reference implementations.

The challenge here was to ﬁnd the best balance between the
level of abstraction at which the formalization is performed in Cer-
tiCrypt, and our goal to give formal veriﬁcation guarantees over
the optimized implementations generated by ZKCrypt. On the
one hand, proving that the reference implementations meet the pre-
scribed correctness and security requirements is much easier if one
can reason abstractly about homomorphisms, group operations, etc.
On the other hand, we wish to prove observational equivalence to
programs produced by ZKCrypt in what is essentially pseudo-code
of an imperative language very close to common programming
languages. We achieve a compromise between these two aspects,
which enables us to reach both objectives simultaneously.

Concretely, we construct each algorithm as shown in Figure 5,
where we introduce annotations between angle brackets as in
XhGresi to make explicit the goal G an object X corresponds to.

Note that all algorithms have at most two statements: a random
assignment that samples all necessary random values up-front, and
a deterministic assignment that computes the output in terms of the
input of the algorithm and the sampled random values. For exam-
ple, in algorithm P1hGresi, the ﬁrst operation corresponds to sam-
pling a tuple uniformly at random from the set stTypehGresi, which
corresponds to a Cartesian product of sets derived from the proof
goal Gres. The second statement consists of a single assignment
that evaluates a function of the inputs of the algorithm and the ran-
domly sampled tuple; this is typically a huge expression performing
all the necessary parsing and algebraic computations. More pre-
cisely, functions Prover1hGresi, Prover2hGresi and VeriﬁerhGresi
may map to arbitrarily complex CertiCrypt expressions.

We observe that by restricting the reference implementation of
protocols to the form shown in Figure 5 we do not lose general-
ity. Indeed, this form is achievable for all goals, including those
comprising arbitrary (possibly nested) Boolean compositions of
atomic goals, which is a non-trivial aspect of the formalization ap-
proach adopted in ZKCrypt. Intuitively, for atomic goals, the com-
putations performed by the reference implementation correspond
to those described in §3 for the Σφ- and ΣGSP- protocols. For
Boolean combinations of Σφ-protocols, the reference implemen-
tation is generated recursively by unfolding the inductively deﬁned
proof goal according to the standard procedures for Boolean com-
position described in §3. This is made possible by our approach
to isolating random sampling operations from other computations.
For illustrative purposes we present a short excerpt of the deﬁni-
tion of the prover function Prover1 in Listing 1. The excerpt corre-
sponds to the case of Boolean compositions of proof goals that can
be handled using the Σφ-protocol, and takes as input a pair (x, w)

and the value stP comprising all values randomly sampled by the
P1hGresi algorithm. The base case maps to a concrete homomor-
phism, whereas recursive calls construct homomorphisms for And
and Or combinations.

Listing 1: Deﬁnition of algorithm Prover1 in Coq.

F i x p o i n t p r o v e r _ p h i g :

( DomType g ) → e x p r
( TGtype ( RandTG g ) ) → e x p r

e x p r
e x p r
match g w i t h
| Hom ( PhiHom A B h ) ⇒ f u n w x ⇒ phiHom h
| And g1 g2 ⇒ f u n w x ps ⇒

( CodomType g ) →

( CodomType g )

: =

( p r o v e r _ p h i
p r o v e r _ p h i

( F s t w)
( Snd w)

( F s t x )
( Snd x )

( F s t ps )
( Snd ps )

|
)

| Or g1 g2 ⇒ f u n w x ps ⇒

IF I s L (w) THEN
( p r o v e r _ p h i

( P r o j L w)

( F s t x )

( F s t

( Snd ps ) )

|

s i m _ p h i

( Snd x )

( F s t ps )

( Snd ( Snd ps ) )

ELSE
(

s i m _ p h i
p r o v e r _ p h i

( F s t x )

( F s t ps )

( P r o j r w)

( F s t
( Snd x )

( Snd ps ) )

( Snd ( Snd ps ) )

)

)

|

end

In addition to the descriptions of reference implementations for
the algorithms of Σ-protocols, the compiler also generates the aux-
iliary algorithms that are required to establish security. In particu-
lar, for each goal, the compiler generates deﬁnitions of a suitable
simulator and special extractor that can be used in the theorem
statements that capture the zero-knowledge and proof of knowl-
edge properties. The ability to generate suitable simulators is also
an essential part of generating ZK-PoK protocols for Or compo-
sitions of Σφ-protocols. Indeed, the deﬁnitions of algorithms P1
and P2 explicitly rely on the simulator descriptions as part of their
code, as can be seen in the snippet in Listing 1: in Or-compositions,
the prover uses as a sub-procedure the simulator of the protocol for
which it does not know a witness.

We discuss next how we prove the correctness and security prop-

erties of reference implementations for all supported proof goals.
Completeness. Completeness of reference implementations is
given by the CertiCrypt theorem below.

THEOREM 2

(COMPLETENESS). For all supported goals
Gres, and all pairs (x, w) satisfying the associated relation, we
prove

c $← VchGresi();
(r, stP ) $← P1hGresi(x, w);
s ← P2hGresi(x, w, c, stP );
a ← VhGresi(x, r, c, s)

≈{a}

0

a ← true

Intuitively, this formalization states that in an honest execution, the
veriﬁer always will accept. Observe that, also in the protocol def-
inition, the challenge generation is hoisted to the beginning of the
protocol, as this facilitates proving equivalence claims. This is a
valid transformation because we only have to prove that properties
hold for an honest veriﬁer that does not deviate from the protocol.
The proof of this theorem requires combined reasoning about the
algebraic manipulations performed by the protocol parties. This is
particularly challenging in the case of goals based on Σφ, for which
the proof is by induction on the structure of the goal, dealing with
the recursive deﬁnitions of the algorithms themselves. For exam-
ple, in Or-compositions one needs to deal with the rearrangement
of recursive calls, by establishing intermediate results of the form:

(r, c, s, a) $← ProtocolhG1 ∨ G2i(x, ι1(w1)) ≈{r,c,s,a}
(r1, c1, s1, a1) $← ProtocolhG1i(π1(x), w1);
c $← cTypehGresi; c2 ← c − c1;
(r2, c2, s2, a2) $← ShG2i(π2(x), c2);
r ← (r1, r2); a ← a1 ∧ a2

0

495This result states that the behavior of the protocol, when run on the
prover side with the witnesses corresponding to goal G1 is identical
to that of another procedure which explicitly relies on a protocol for
goal G1 and a simulator for goal G2. The proof of this equivalence
must then make use of the recursive deﬁnition of the protocol (itself
based on the prover and veriﬁer algorithms presented in Figure 5)
and of the simulator, and requires proving that the needed code
rearrangements do not modify the semantics of the experiments.
HVZK. Honest veriﬁer ZK of reference implementations is given
by the CertiCrypt theorem below.

THEOREM 3

(HVZK). For all supported goals Gres, and for
all pairs (x, w) satisfying the relation associated with Gres, we
prove the following statistical equivalence:

c $← VchGresi();
(r, stP ) $← P1hGresi(x, w);
s ← P2hGresi(x, w, c, stP );
a ← VhGresi(x, r, c, s)

≈{r,c,s}
ǫhGresi

(r, c, s) $← ShGresi(x)

Here, ShGresi is the simulator algorithm generated by ZKCrypt
for goal Gres. The concrete value of the statistical distance between
the distributions depends on the goal. For the particular case of
Σφ-protocols and Boolean combinations thereof, this is actually
0, and so proving this property corresponds to showing that the
distributions are identical, implying perfect HVZK. In this case,
the type of reasoning required to construct the proof is very similar
to that described for completeness.

On the contrary, proving the zero knowledge property of ΣGSP-
protocols constitutes a signiﬁcant challenge because it requires rea-
soning about statistical distance. Given any ΣGSP goal Gres deﬁned
over a homomorphism where the co-domain is a tuple of arbitrary
size m, we bound the statistical distance in the statement above by
ǫhGresi = m/2ℓ, where ℓ is a concrete security parameter given
as input to the compiler along with the goal speciﬁcation (see §3).
Establishing this result for arbitrary homomorphisms required rea-
soning about the number of points contained in hypercubes in Zm,
and proving the upper bound using Bernoulli’s inequality.
Proof of Knowledge. The following CertiCrypt theorem ensures
that all generated reference implementations satisfy the General-
ized Special Soundness introduced in §3.

THEOREM 4

every

(PROOF OF KNOWLEDGE). For

sup-
ported valid goals Gres,
for all (x, w) satisfying the relation
associated with Gres, and for any two accepting conversations
(r, c, s) and (r, c′, s′) satisfying relation R′hGresi,

RhGresi(x, EhGresi(r, c, c′, s, s′)) = true .

The theorem statement nicely matches Deﬁnition 2, where re-
lation R′hGresi expresses the restriction on traces described in §3
for either Σφ- or ΣGSP- protocols, and EhGresi denotes the knowl-
edge extractor generated by the compiler. However, the theorem
includes an additional validity restriction on proof goals that we
now explain. Referring to §3, recall that for c+ > 2 both the
Σφ-protocol and the ΣGSP-protocol can only be proven to satisfy
Deﬁnition 2 if the underlying homomorphisms satisfy an addi-
tional property. Our notion of proof goal validity captures these ex-
tra restrictions. Concretely, the validity requirement for Σφ goals
implies that all prime factors of special exponents for homomor-
phisms are greater than c+. For the ΣGSP-protocol, the validity re-
quirement is as follows. Recall, from §3 that R typically samples
an RSA modulus n and deﬁnes a relation R as

R(x, (µ, w))

.
= x = µφ(w) ∧ µd = 1

(mod n)

Here, d is the product of the primes dividing the order of the mul-
tiplicative group modulo n, which are less than or equal to c+. We
require for validity that d satisﬁes this property.

Proving this theorem in CertiCrypt posed a different sort of chal-
lenge when compared to the previous ones, as it is not formulated in
the form of a program equivalence statement. Essentially, it trans-
lates into a proof goal formulated over the semantics of the un-
derlying algebraic constructions. Here we make critical use of the
extensive Coq library that is included in ZKCrypt and that was de-
veloped to support the semantics of the data types included in the
necessary CertiCrypt extensions. In turn, this library makes inten-
sive use of SSReﬂect [35] and its comprehensive Coq library on
algebraic and number theoretic results.

6.

IMPLEMENTATION

To establish our ultimate veriﬁcation goal, we translate the opti-
mized implementations of protocols generated by ZKCrypt to the
language of CertiCrypt. By taking advantage of the convenient
notation that ZKCrypt automatically sets up in CertiCrypt, this
translation step is straightforward and essentially corresponds to
pretty-printing the output implementation ﬁles. Our strategy to for-
mally verify these optimized implementations is to ﬁrst establish
an intermediate result stating that these are correct with respect to
a reference implementation. More precisely, we establish that each
of the algorithms in the implementation ﬁle, namely P1, P2, V, and
Vc, are observationally equivalent to the corresponding algorithms
in the reference implementation. These results are formalized in
CertiCrypt by lemmas that typically look as the one below.

LEMMA 1

(CORRECTNESS OF P1). For all (x, w) in the do-
main of relation R, associated with resolved goal Gres, the following
equivalence holds:

(r, stP ) $← P1(x, w) ≈{r,stP }

0

(r, stP ) $← Pref

1 hGresi(x, w)

Here Pref
1

refers to the reference implementation for algorithm
P1. Equivalence is formalized by imposing that, for any possi-
ble ﬁxed input, the outputs of both algorithms are identically dis-
tributed. Several differences between the reference and optimized
implementations make proving these lemmas non trivial:

1. The reference implementation is expressed at a slightly
higher level of abstraction than the optimized implementa-
tion. In particular, the reference implementation expresses
homomorphism computations as native operations in the
CertiCrypt language, whereas these are expanded as lower-
level operations over the underlying algebraic groups in the
optimized protocol implementation.

2. The reference implementation typically uses different lan-
guage constructions than the optimized protocol.
In par-
ticular, the reference implementation uses a minimum num-
ber of statements and local variables, in exchange for more
elaborate expressions. For example, expressions in the ref-
erence implementation pack program variables into product
data types, and contain conditional expressions in order to
eliminate the need for if-then-else statements.

3. The ZK-compiler implementation may rearrange algebraic
expressions to enable the generation of optimized implemen-
tations by the lower-level code generators or back-ends.

Listing 2 shows an example observational equivalence proof goal
as it appears in CertiCrypt, extracted from the deniable authenti-
cation example included in the next section. The reference and
optimized implementations sit at the bottom and top, respectively.

496These differences between the two implementations that we have
described above are clearly visible in the code.

Listing 2: Equivalence proof goal in CertiCrypt.

EqObs {x , w} { r , s t , x ,w}

[ i f

I s L (w)

t h e n [

r 1
← Gs ;
$
t 1 ← [ g ]
t 2 ← [ h ]

[
e l s e
c1
← c s ;
$
t 1 ← [ g ]
F s t
t 2 ← [ h ]

[ ^H]
[ ^H]

( [ G t o _ n a t ]
( [ G t o _ n a t ]

r 1 ) ;
r 1 )

]

s1
← Gs ;
$
[ ^H]
( F s t _x )
[ ^H]

( [ G t o _ n a t ]

s1 )

[ / H]

[ ^H]

( [ c t o _ n a t ] c1 ) ;

( [ G t o _ n a t ]

s1 )

[ / H]

Snd ( F s t _x )

[ ^H]

( [ c t o _ n a t ] c1 )

] ;

I f

! I s L (w)
← Gs ;
r 2
$
[
e l s e
c2
← c s ;
$
t 3 ← [ g ]

t h e n [

t 3 ← [ g ]

[ ^H]

( [ G t o _ n a t ]

r 2 )

]

s2
← Gs ;
$
[ ^H]

( [ G t o _ n a t ]

s2 )

[ / H]

Snd _x [ ^H]

( [ c t o _ n a t ] c2 )

] ;

r ← ( ( t 1 |
s t ← IF I s L (w) THEN ( c2 | ( r 1 | s2 ) )
ELSE ( c1 | ( s1 | r 2 ) ) ;

t 3 ) ;

t 2 )

|

]

[ s t

← E . Dprod c s
$

( E . Dprod Gs Gs ) ;

r ← IF I s L (w) THEN

( [ p h i ] F s t
( Snd s t )
[ p s i ] Snd ( Snd s t )
Snd _x [ ^H]

|
[ / H]
( [ c t o _ n a t ]

( F s t

s t ) ) )

ELSE

( ( F s t

( [ p h i ] F s t

( Snd s t ) )

[ / H]

[ ^H]

( F s t _x )

F s t
Snd ( [ p h i ] F s t
Snd ( F s t _x )
[ p s i ] Snd ( Snd s t )

[ ^H]

( [ c t o _ n a t ]
)

]

( F s t

s t ) ) )

|

( [ c t o _ n a t ]

( F s t

s t ) )

|

( Snd s t ) )

[ / H]

Pleasingly, our automation approach performed well in handling
such equivalence proofs, both for this example and for the ones
described in §7. Speciﬁcally, we have found that tactics already
implemented in CertiCrypt are ideally suited to reduce proof goals
as the one in Listing 2 to lower-level veriﬁcation conditions over the
semantics of operators used to implement the algorithms. Thanks
to this, the problem of automation becomes one of constructing
Coq tactics that can solve these lower level goals. To do this, we
combine the powerful decision procedures ring and omega built
into Coq with customized tactics that handle patterns observed in
a comprehensive set of practical examples.
Combining the results. Once the equivalence lemmas above are es-
tablished, generic proof scripts are used to discharge the proof obli-
gations associated with completeness, HVZK, and generalized spe-
cial soundness of optimized implementations. The theorem state-
ments are identical to those in §5 for the reference implementations
produced by ZKCrypt, but their proofs are essentially different. We
rely on a general lemma stating that any given algorithms P1, P2,
V, and Vc, observationally equivalent to the respective algorithms
in a reference implementation, lead to a protocol whose transcripts
are distributed exactly as in the reference implementation.

Proving the completeness and honest veriﬁer zero knowledge
properties of the optimized protocol then amounts to arguing that
these results are directly implied by the identical distributions dis-
played by reference and optimized protocol implementations. For
the soundness property, one appeals directly to the correctness of
the optimized V2 algorithm, which implies that an accepting trace
for the optimized protocol is a valid input to the knowledge extrac-
tor that is proven to exist for the reference implementation.

7. MORE EXPERIMENTS AND RESULTS
Besides the running example presented in the previous sections,
we also tested and veriﬁed the functionality of ZKCrypt based on

a representative set of proof goals of academic and practical inter-
est. We brieﬂy report on some of these applications to illustrate
the capabilities of ZKCrypt. We provide benchmarking results in
Table 1 in terms of lines of code of the implementations output
by the compiler and veriﬁcation time of formal proofs. We note
that the formal veriﬁcation component of ZKCrypt described in
this paper was developed in a way that is totally non-intrusive to
the original CACE compiler that generates the executable imple-
mentations, and hence the efﬁciency of the generated C- and Java-
implementations remains unaffected.
Electronic Cash. Electronic payment systems realize fully digi-
tal analogues of classical cash systems involving bills and coins.
Besides high security and privacy guarantees, real-world usability
requires that they work off-line, i.e., the bank must not be required
to participate in transactions. One of the ﬁrst schemes satisfying
this condition was suggested by Brands [14]. All phases of his
scheme use ZK-PoKs as sub-protocols. For instance, when with-
drawing money from a bank account, a user has to prove its identity
by proving possession of a secret key. The respective proof goal is
given as follows:

ZPKh (u1, u2) : I = gu1

1 gu2

2 i.

Here, I, g1, g2 ∈ Z∗
p such that ord g1 = ord g2 = q, where q|(p −
1) and p, q ∈ P. The secrets u1, u2 are elements of Zq. This proof
goal can be realized by a single instance of the Σφ-protocol.
Deniable Authentication. Any Σ-protocol can be transformed into
a non-interactive protocol using the Fiat-Shamir heuristic [29]. The
idea is to substitute the veriﬁer’s ﬁrst algorithm by a cryptographic
hash function: Instead of relying on V to choose the challenge c
uniformly at random, the prover computes c itself as c ← H(r),
where r is the commitment computed in its ﬁrst step. It then com-
putes its response s as in the original protocol. Upon receiving
(r, c, s), the veriﬁer checks whether the triple is an accepting con-
versation, and whether c = H(r).3

Clearly, proofs obtained in this way are not deniable. Namely,
the veriﬁer can convince a third party that it knows the prover’s
secret by just forwarding (r, c, s). This problem can be solved by
migrating to designated veriﬁer ZK proofs: assume a public key
infrastructure, where each party deposits a public key. The prover
then shows that it either knows the secret key for its own public key,
or the secret key of the veriﬁer. The resulting authentication scheme
is deniable, as V could simulate proofs using its own secret key.

To make things concrete, we brieﬂy recap the scheme of Wang
and Song [51] here. A party A holds a secret key xA ∈ Zq, and pub-
lishes the corresponding public key yA = (y1A, y2A) = (gxA, hxA ),
where q ∈ P and g, h are elements of Z∗
p with order q. Now, au-
thenticating P towards V boils down to the following proof goal:

ZPKh (xP , xV ) : (y1P = gxP ∧ y2P = hxP ) ∨ y1V = gxVi.

As the order q of g, h is known, this proof goal can be realized
using the Σφ-protocol and Boolean compositions [25].
Ring Signatures. A ring signature scheme allows a set of parties to
sign documents on behalf of the whole group [48], without reveal-
ing the identities of the signers. Such schemes are often realized
by modifying the Fiat-Shamir transformation as follows: instead of
setting c ← H(r), the prover sets c ← H(r, m), hashing the pair
(m, r) where m is the message to be signed.

In a very basic scenario one wants to allow each member of the
group to issue signatures on behalf of the group. Let therefore be
3Currently,
the Fiat-Shamir heuristic is implemented at code-
generation, so formal veriﬁcation only covers the original protocol.

497TYPE COMPOSITIONS HLL (LOC)
23
Σφ
Electronic Cash
31
Deniable Authentication Σφ
37
Σφ
Ring Signatures
23
ΣGSP
Identity Mixer

None
And, Or
Or
And

PIL (LOC) CertiCrypt (LOC) VERIFICATION
< 2m
< 3m
< 4m
< 25m

1288
1383
1384
1515

59
89
110
134

Table 1: Benchmark results for representative applications of ZKCrypt. The ﬁrst two columns describe the type and complexity
of the protocol required to realize the proof goal. ZK, PIL and CertiCrypt denote the lines of code of the high-level input ﬁle, the
generated protocol and the formal proof. VERIFICATION denotes the duration of generating and verifying the proofs in CertiCrypt.

given a PKI containing public keys (yA, eA) ∈ Z∗
nA × Z for strong
RSA moduli nA, and let each party A hold its secret key xA sat-
isfying yA = xeA
A . For simplicity, assume further that the group
consists of only three parties. Then the proof goal is given by:

1 ∨ y2 = xe2

2 ∨ y3 = xe3

3 i.

ZPKh (x1, x2, x3) : y1 = xe1

Again, as the domain of each mapping x 7→ xei is ﬁnite, realization
is done using the Σφ-protocol and Boolean compositions [25].
Summary. Our experimental results illustrate that ZKCrypt is ﬂex-
ible enough to generate and verify implementations for a large set
of proof goals occurring in practically relevant applications. We ob-
serve that, although proof veriﬁcation is performed automatically,
the performance of the developed Coq/Certicrypt tactics degrades
signiﬁcantly for proof goals based on the ΣGSP-protocol. This is
due to the complexity of the formalization of the underlying alge-
braic structures, which involve the deﬁnition of product homomor-
phisms with a large number of inputs and outputs.

8. RELATED WORK

Cryptographic compilers for ZK-PoK were studied before in two
different lines of work; in the setting of the CACE project [2, 5, 6,
16] and for e-cash applications [43].

The CACE compiler is a certifying compiler that generates efﬁ-
cient implementations of zero-knowledge protocols. The compiler
takes moderately abstract speciﬁcations of proof goals as input and
generates C or Java implementations. The core compilation steps
(i.e., all but the backends) are certifying in the sense that they gener-
ate an Isabelle [46] proof of the existence of a knowledge extractor
guaranteeing special soundness. However, neither the fundamental
zero-knowledge property nor completeness are addressed by the
compiler, and the veriﬁcation component only supports a very lim-
ited set of proof goals, not including the ΣGSP-protocol. ZKCrypt
builds on the compilation functionality of the CACE compiler,
adding a new front-end and a completely reengineered veriﬁcation
component. Moreover, it solves several minor bugs, some of which
were uncovered as a direct consequence of the new formal veriﬁca-
tion back-end development.

The ZKPDL compiler generates efﬁcient distributed implemen-
tations of ZK-PoKs from high-level goals [43]. It has been used to
build a realistic e-cash library. ZKPDL offers a level of abstraction
similar to ours, but foregoes any attempt to verify the generated
code and supports a more restricted set of proof goals.

Besides tools for ZK-PoK, a large variety of other domain spe-
ciﬁc compilers exists, e.g., Fairplay [42], VIFF [28] and the tool
described in [41] for generating implementations of secure two-
party computations. Also, generic cryptographic compilers of-
fering differently abstract input languages have been proposed,
e.g., [4, 7, 37, 50]. However, none of those tools supports formal
veriﬁcation.

A number of works have considered applications of formal ver-
iﬁcation to ZK-PoK. Barthe et al. [11] use CertiCrypt to prove
soundness, completeness, and zero-knowledge of Σφ-protocols and

simple And/Or-compositions thereof. Although these results were
constructed by hand and needed to be extended for a wider range of
proof goals and arbitrary Boolean compositions, they are at the gen-
esis of the formal veriﬁcation infrastructure of ZKCrypt. Backes et
al. [3] propose a method for checking that zero-knowledge proofs
are adequately used, and apply their method to the DAA protocol.

9. CONCLUSIONS

ZKCrypt is an experimental high-assurance zero-knowledge
compiler that applies state-of-the-art approaches in veriﬁed and
verifying compilation to the realm of cryptography.
It achieves
an unprecedented level of conﬁdence among cryptographic com-
pilers. The veriﬁcation infrastructure of ZKCrypt is based on the
CertiCrypt platform, and relies on a set of carefully isolated con-
cepts, including a new uniﬁed approach to special soundness and
a novel formal treatment of goal resolution as a compilation step.
We demonstrated that the compiler and the veriﬁcation component
are able to handle a large number of applications using ZK-PoKs.
There are plenty of avenues for future research in the ﬁeld of
cryptographic compilation and veriﬁcation in general, and for the
class of ZK-PoKs in particular. One future task is to verify the last
stage of the compiler chain, code generation, to cover the entire
compilation process. An interesting question is how far veriﬁed
compilation can be extended beyond ZK-PoKs.

10. REFERENCES

[1] ABC4TRUST EU PROJECT. Ofﬁcial Website.

https://abc4trust.eu/, 2011.

[2] ALMEIDA, J. B., BANGERTER, E., BARBOSA, M.,

KRENN, S., SADEGHI, A.-R., AND SCHNEIDER, T. A
Certifying Compiler for Zero-Knowledge Proofs of
Knowledge Based on Σ-Protocols. In ESORICS ’10 (2010),
vol. 6345 of LNCS, Springer.

[3] BACKES, M., HRITCU, C., AND MAFFEI, M.

Type-Checking Zero-Knowledge. In ACM CCS 08 (2008),
ACM, pp. 357–370.

[4] BAIN, A., MITCHELL, J. C., SHARMA, R., STEFAN, D.,

AND ZIMMERMAN, J. A Domain-Speciﬁc Language for
Computing on Encrypted Data (Invited Talk). In FSTTCS
2011 (2011), vol. 13 of LIPIcs, Schloss Dagstuhl, pp. 6–24.

[5] BANGERTER, E., BARZAN, S., KRENN, S., SADEGHI,

A.-R., SCHNEIDER, T., AND TSAY, J.-K. Bringing
zero-knowledge proofs of knowledge to practice. In SPW 09
(2009).

[6] BANGERTER, E., BRINER, T., HENEKA, W., KRENN, S.,

SADEGHI, A.-R., AND SCHNEIDER, T. Automatic
generation of Σ-protocols. In EuroPKI 09 (2009).
[7] BANGERTER, E., KRENN, S., SEIFRIZ, M., AND

ULTES-NITSCHE, U. cPLC - A Cryptographic Programming
Language and Compiler. In ISSA 2011 (2011), IEEE.

498[8] BARTHE, G., GRÉGOIRE, B., AND BÉGUELIN, S. Formal

certiﬁcation of code-based cryptographic proofs. In POPL 09
(2009), pp. 90–101.

[9] BARTHE, G., GRÉGOIRE, B., HERAUD, S., OLMEDO, F.,

AND ZANELLA BÉGUELIN, S. Veriﬁed indifferentiable
hashing into elliptic curves. In POST 2012 (Heidelberg,
2012), LNCS, Springer.

[10] BARTHE, G., GRÉGOIRE, B., HERAUD, S., AND

ZANELLA BÉGUELIN, S. Computer-aided security proofs
for the working cryptographer. In CRYPTO 2011
(Heidelberg, 2011), vol. 6841 of LNCS, Springer, pp. 71–90.

[11] BARTHE, G., HEDIN, D., ZANELLA BÉGUELIN, S.,

GRÉGOIRE, B., AND HERAUD, S. A machine-checked
formalization of Σ-protocols. In CSF 2010 (2010), IEEE.

[12] BARTHE, G., KÖPF, B., OLMEDO, F., AND ZANELLA

BÉGUELIN, S. Probabilistic reasoning for differential
privacy. In POPL 2012 (2012), ACM.

[13] BORISOV, N., GOLDBERG, I., AND BREWER, E.

Off-the-Record Communication, or, why not to use PGP. In
WPES 2004 (2004), ACM, pp. 77–84.

[14] BRANDS, S. An Efﬁcient Off-line Electronic Cash System

Based on the Representation Problem. Tech. Rep. CS-R9323,
CWI, 1993.

[15] BRICKELL, E. F., CAMENISCH, J., AND CHEN, L. Direct

Anonymous Attestation. In ACM CCS 04 (2004), ACM.

[16] BRINER, T. Compiler for zero-knowledge proof-of-

knowledge protocols. Master’s thesis, ETH Zurich, 2004.

[17] CAMENISCH, J., AND HERREWEGHEN, E. V. Design and

Implementation of the idemix Anonymous Credential
System. In ACM CCS 02 (2002), ACM Press, pp. 21–30.
[18] CAMENISCH, J., AND LYSYANSKAYA, A. A Signature

Scheme with Efﬁcient Protocols. In SCN 02 (2002),
vol. 2576 of LNCS, Springer, pp. 268–289.

[19] CAMENISCH, J., AND SHOUP, V. Practical Veriﬁable
Encryption and Decryption of Discrete Logarithms. In
CRYPTO 03 (2003), vol. 2729 of LNCS, Springer.

[20] CAMENISCH, J., AND STADLER, M. Efﬁcient group

signature schemes for large groups. In CRYPTO 97 (1997),
vol. 1294 of LNCS, Springer, pp. 410–424.

[21] CAMENISCH et al., J. Speciﬁcation of the Identity Mixer

Cryptographic Library (Version 2.3.0). Research Report RZ
3730 (#99740), IBM Research, 2010.

[22] CHAUM, D. Security without identiﬁcation: Transaction

systems to make big brother obsolete. Commun. ACM 28, 10
(1985), 1030–1044.

[23] CHAUM, D., AND EVERTSE, J.-H. A secure and

privacy-protecting protocol for transmitting personal
information between organizations. In CRYPTO (1986),
vol. 263 of LNCS, Springer, pp. 118–167.

[24] CRAMER, R. Modular Design of Secure yet Practical

Cryptographic Protocols. PhD thesis, CWI and University of
Amsterdam, 1997.

[25] CRAMER, R., DAMGÅRD, I., AND SCHOENMAKERS, B.

Proofs of partial knowledge and simpliﬁed design of witness
hiding protocols. In CRYPTO 94 (1994), vol. 839 of LNCS,
Springer, pp. 174–187.

[26] DAMGÅRD, I. On Σ-protocols, 2004. Lecture on

Cryptologic Protocol Theory; Faculty of Science, University
of Aarhus.

[27] DAMGÅRD, I., AND FUJISAKI, E. A statistically-hiding
integer commitment scheme based on groups with hidden

order. In ASIACRYPT 02 (2002), vol. 2501 of LNCS,
Springer, pp. 77–85.

[28] DAMGÅRD, I., GEISLER, M., KRØIGAARD, M., AND

NIELSEN, J. B. Asynchronous Multiparty Computation:
Theory and Implementation. In PKC 09 (2009), vol. 5443 of
LNCS, Springer, pp. 160–179.

[29] FIAT, A., AND SHAMIR, A. How to prove yourself:

practical solutions to identiﬁcation and signature problems.
In CRYPTO 86 (1987), vol. 263 of LNCS, Springer.
[30] FUJISAKI, E., AND OKAMOTO, T. Statistical zero

knowledge protocols to prove modular polynomial relations.
In CRYPTO 97 (1997), vol. 1294 of LNCS, Springer.

[31] GOLDBERG, I., USTAOGLU, B., GUNDY, M. V., AND

CHEN, H. Multi-party off-the-record messaging. In ACM
CCS 09 (2009), ACM, pp. 358–368.

[32] GOLDREICH, O. Zero-knowledge twenty years after its

invention. Tech. Rep. TR02-063, Electronic Colloquium on
Computational Complexity, 2002.

[33] GOLDREICH, O., MICALI, S., AND WIGDERSON, A.

Proofs that yield nothing but their validity or all languages in
NP have zero-knowledge proof systems. Journal of the ACM
38, 1 (1991), 691–729.

[34] GOLDWASSER, S., MICALI, S., AND RACKOFF, C. The

knowledge complexity of interactive proof-systems. In STOC
85 (1985), ACM, pp. 291–304.

[35] GONTHIER, G., MAHBOUBI, A., AND TASSI, E. A Small
Scale Reﬂection Extension for the Coq system. Rapport de
recherche RR-6455, INRIA, 2008.

[36] GUILLOU, L., AND QUISQUATER, J.-J. A “paradoxical”

identity-based signature scheme resulting from
zero-knowledge. In CRYPTO 88 (1990), vol. 403 of LNCS,
Springer, pp. 216–231.

[37] KIYOMOTO, S., OTA, H., AND TANAKA, T. A Security
Protocol Compiler Generating C Source Codes. In ISA 08
(2008), IEEE, pp. 20–25.

[38] LAGRANGE, J. L. Œuvres, 1770.
[39] LEROY, X. Formal certiﬁcation of a compiler back-end or:

programming a compiler with a proof assistant. In POPL 06
(2006), ACM Press, pp. 42–54.

[40] LIPMAA, H. On diophantine complexity and statistical
zeroknowledge arguments. In ASIACRYPT 03 (2003),
vol. 2894 of LNCS, Springer, pp. 398–415.

[41] MACKENZIE, P., OPREA, A., REITER, M. Automatic
generation of two-party computations. In ACM CCS 03
(2003), ACM, pp. 210–219.

[42] MALKHI, D., NISAN, N., PINKAS, B., AND SELLA, Y.

Fairplay – Secure two-party computation system. In USENIX
Security Symposium (2004), USENIX Association.

[43] MEIKLEJOHN, S., ERWAY, C., KÜPÇÜ, A., HINKLE, T.,

AND LYSYANSKAYA, A. ZKPDL: A Language-Based
System for Efﬁcient Zero-Knowledge Proofs and Electronic
Cash. In USENIX Security Symposium (2010), USENIX
Association, pp. 193–206.

[44] MICROSOFT. U-Prove.

http://www.microsoft.com/u-prove, 2011.

[45] NECULA, G. C., AND LEE, P. The design and

implementation of a certifying compiler. In PLDI (New
York, NY, USA, 1998), vol. 33, PUB-ACM, pp. 333–344.

[46] NIPKOW, T., AND PAULSON, L. Isabelle web site.

http://isabelle.in.tun.de, 2010.

499[47] RIAL, A., AND DANEZIS, G. Privacy-preserving smart

metering, 2011.

[48] RIVEST, R., SHAMIR, A., AND TAUMAN, Y. How to Leak a

Secret - Theory and Applications of Ring Signatures. In
ASIACRYPT 01 (2001), vol. 2248 of LNCS, Springer.

[49] SCHNORR, C. Efﬁcient signature generation by smart cards.

Journal of Cryptology 4, 3 (1991), 161–174.

[50] SCHRÖPFER, A., KERSCHBAUM, F., BISWAS, D.,

GEISSINGER, S., AND SCHÜTZ, C. L1 - Faster
Development and Benchmarking of Cryptographic
Protocols. In SPEED-CC 09 (2009).

[51] WANG, B., AND SONG, Z. A Non-Interactive Deniable

Authentication Scheme Based on Designated Veriﬁer Proofs.
Information Sciences 179, 6 (2009), 858–865.

[52] ZUCK, L. D., PNUELI, A., GOLDBERG, B., BARRETT,
C. W., FANG, Y., AND HU, Y. Translation and run-time
validation of loop transformations. Formal Methods in
System Design 27, 3 (2005), 335–360.

APPENDIX

A. AN OVERVIEW OF CertiCrypt

CertiCrypt [8, 10] is an automated toolset for proving the se-
curity of cryptographic constructions in the computational model.
It builds upon state-of-the-art veriﬁcation technologies to support
code-based proofs, in which security is cast in terms of equivalence
of probabilistic programs. The core of CertiCrypt is a rich set of
veriﬁcation techniques based on a Relational Hoare Logic for prob-
abilistic programs [8]. A recent extension [9] supports reasoning
about a broad range of quantitative properties, including statistical
distance, which is crucial in our deﬁnition of zero-knowledge.

The CertiCrypt toolset consists of two main components. Both
allow proving that the distributions generated by probabilistic ex-
periments are identical or statistically close, but differ in their de-
gree of automation, ﬂexibility and formal guarantees. The ﬁrst
component, called CertiCrypt, excels in ﬂexibility and is fully for-
malized in the Coq proof assistant; its veriﬁcation methods are
implemented in Coq and proved correct w.r.t. program seman-
tics. The second component, EasyCrypt, delivers a higher de-
gree of automation by relying on SMT solvers and automated the-
orem provers to discharge veriﬁcation conditions arising in proofs.
EasyCrypt generates proof certiﬁcates that can be mechanically
checked in Coq, thus practically reducing the trusted computing
base to that of the ﬁrst component; however, it lacks on generality
as it only exposes a limited set of proof methods. ZKCrypt takes
advantage of both components: it uses the latter to check the cor-
rectness of goal resolution and the former for verifying the compiler
for reference implementations and the equivalence of reference and
optimized implementations. We outline below some of the essen-
tial features of both components.
Language. Programs are written in a procedural, probabilistic im-
perative language that includes deterministic and random assign-
ments, conditional statements and loops. This base language suf-
ﬁces to conveniently express a wide class of cryptographic experi-
ments and security properties. However, to achieve greater ﬂexibil-
ity, the language of deterministic and random expressions is user-
extensible. A program c in the language of CertiCrypt denotes a
function JcK from an initial memory m (a mapping from program
variables to values) to a distribution over ﬁnal memories. We de-
note by Pr [c, S : m] the probability of event S w.r.t to the distri-
bution JcK m. We refer the reader to Barthe et al. [12] for a more
detailed description of the language and its semantics.

Reasoning principles. Proving the (approximate) equivalence of
the distributions generated by two probabilistic programs in Cer-
tiCrypt amounts to deriving valid judgments in an approximate Re-
lational Hoare Logic (apRHL). We restrict our attention in this pa-
per to a fragment of apRHL that captures both perfect and statisti-
cal indistinguishability of distributions generated by programs. We
consider judgments of the form c1 ∼ǫ c2 : Ψ ⇒ Φ where c1 and
c2 are probabilistic programs, Ψ, Φ binary relations over program
memories and ǫ ∈ [0, 1]. Taking Φ as the equality relation on a
subset of observable program variables X, one recovers the usual
deﬁnition of statistical indistinguishability. In particular, given an
event A, represented as a predicate over memories, if A only de-
pends on variables in X, one has

m1 Ψ m2 =⇒ |Pr [c1, m1 : A] − Pr [c2, m2 : A] | ≤ ǫ .

ǫ

We let c1 ≈Ψ,X
c2 denote the validity of c1 ∼ǫ c2 : Ψ ⇒ Φ when
Φ is the equality relation on variables in X; we omit Ψ when it is
the total relation or can be inferred from the context.

B.

INPUT FILE OF THE USE CASE

Figure 6 shows the input (a .zk-ﬁle) for our running exam-
ple. It is obtained by instantiating the template CL(m1, m2) with
the mapping underlying the CL-signature scheme [18] (cf. Equa-
tion 1), as is already done in the identity mixer speciﬁcation. The
rest of the ﬁle describes the algebraic setting and required security
goals.

The ﬁrst two blocks, Declarations and Inputs declare
all variables used in the protocol and the public and private in-
puts of the parties. Typically, variables will be declared as private
if and only if knowledge of these values has to be proved. The
Properties block speciﬁes the security properties and the over-
all structure of the protocol. The KnowledgeError of the gen-
erated protocol shall be at most 2−80, and the statistical distance of
simulated from real protocol runs must be at most 2−SZKParameter .
Inside ZKCrypt, the KnowledgeError parameter is translated
onto a concrete challenge length and SZKParameter gives the
security parameter controlling the tightness of the HVZK property.
The proof goal only consists of a single predicate. It shall be proved
using a SigmaGSP-protocol; the maximum ChallengeLength
that may safely be used for the homomorphism is speciﬁed (this
cannot be computed from phi as it would require to compute the
order of Zmod*(n)). For concrete values of n, i.e., strong RSA
moduli, this parameter implicitly gives the concrete value of d (the
product of all primes smaller than c+ dividing ord H) for which
the proof of knowledge property holds.

:= n, z, R_1, A, S, R_2, b;

Declarations {
Int(2048) n;
Zmod*(n)
z, R_1, R_2, A, S;
Int(1000) m_1, m_2, e, v, b;
}
Inputs {
Public
ProverPrivate := e, m_2, v;
}
Properties {
KnowledgeError
SZKParameter
ProtocolComposition := P_0;
}
SigmaGSP P_0 {
Homomorphism(phi: Z^3 -> Zmod*(n):

:= 80;
:= 80;

(e,m_2,v) |-> (A^e*S^v*R_2^m_2));

ChallengeLength := 80;
Relation(

(z*R_1^(-m_1)) = phi(e,m_2,v) And m_2 >= b); }

Figure 6: .zk-ﬁle specifying Idemix proof goal G.

500