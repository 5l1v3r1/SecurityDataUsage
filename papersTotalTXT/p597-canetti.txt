Practical UC Security with a Global Random Oracle


[Extended Abstract]

∗

Ran Canetti†

Abhishek Jain

Alessandra Scafuro‡

Boston and Tel-Aviv University

Boston University and MIT

USA and Israel

canetti@bu.edu

USA

abhishek@csail.mit.edu

UCLA
USA

scafuro@cs.ucla.edu

ABSTRACT
Contrary to prior belief, we show that there exist commit-
ment, zero-knowledge and general function evaluation proto-
cols with universally composable security, in a model where
all parties and all protocols have access to a single, global,
random oracle and no other trusted setup. This model pro-
vides signiﬁcantly stronger composable security guarantees
than the traditional random oracle model of Bellare and Ro-
gaway [CCS’93] or even the common reference string model.
Indeed, these latter models provide no security guarantees
in the presence of arbitrary protocols that use the same ran-
dom oracle (or reference string or hash function).

Furthermore, our protocols are highly eﬃcient. Speciﬁ-
cally, in the interactive setting, our commitment and gen-
eral computation protocols are much more eﬃcient than the
best known ones due to Lindell [Crypto’11,’13] which are
secure in the common reference string model. In the non-
interactive setting, our protocols are slightly less eﬃcient
than the best known ones presented by Afshar et al. [Euro-
crypt ’14] but do away with the need to rely on a non-global
(programmable) reference string.

†Supported by the Check Point Institute for Information Se-
curity, the NSF SaTC MACS project, and NSF Algorithmic
Foundations grant no. 1218461.
‡Supported in part by NSF grants 09165174, 1065276,
1118126 and 1136174, US-Israel BSF grant 2008411,
OKAWA Foundation Research Award, IBM Faculty Re-
search Award, Xerox Faculty Research Award, B. John
Garrick Foundation Award, Teradata Research Award, and
Lockheed-Martin Corporation Research Award. This mate-
rial is based upon work supported by the Defense Advanced
Research Projects Agency through the U.S. Oﬃce of Naval
Research under Contract N00014 -11 -1-0392. The views ex-
pressed are those of the author and do not reﬂect the oﬃcial
policy or position of the Department of Defense or the U.S.
Government.
∗A full version of this paper is available at [7]

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are not
made or distributed for proﬁt or commercial advantage and that copies bear
this notice and the full citation on the ﬁrst page. Copyrights for components
of this work owned by others than ACM must be honored. Abstracting with
credit is permitted. To copy otherwise, or republish, to post on servers or to
redistribute to lists, requires prior speciﬁc permission and/or a fee. Request
permissions from permissions@acm.org.
CCS’14, November 3–7, 2014, Scottsdale, Arizona, USA.
Copyright 2014 ACM http://dx.doi.org/10.1145/2660267.2660374 .

Categories and Subject Descriptors
C.2.0 [Computer-Communication Networks]: General,
security and protection

General Terms
Theory, Security

Keywords
Secure Computation; Universal Composition; Global Ran-
dom Oracle Model

1.

INTRODUCTION

The random oracle model (ROM) [2] has been extremely
successful as a tool for justifying the design of highly eﬃ-
cient cryptographic schemes that lack more direct proofs of
security. Indeed, while security in the ROM does not in gen-
eral imply security when the random oracle is replaced by a
concrete, publically computable hash function [6, 12, 22], it
is generally accepted that security analysis in the ROM does
provide strong corroboration to the resilience of the protocol
in question to practical attacks.

However, when attempting to use the ROM for analyz-
ing security of general protocols, and in particular when at-
tempting to assert simulation-based security deﬁnitions, the
following question comes up: Does security analysis in the
ROM provide any composable security guarantees? In par-
ticular, what does security analysis in the stand-alone ROM
say about the security of the protocol within a larger sys-
tem that involves also other protocols, where these protocols
may have themselves been analyzed in the ROM?

To provide a positive answer to this question, we would
like to come up with a model for analyzing security of pro-
tocols in a stand-alone fashion, while taking advantage of
the ROM, and still be able to provide security guarantees in
a composite system where multiple such protocols co-exist
and interact.

A natural approach to devising such a model is to start
from an existing framework with composability guarantees,
and try to add the ROM to that framework. Speciﬁcally,
start from the universally composable (UC) security frame-
work [3] that provides strong composability, and formulate
the ROM as a “trusted functionality” that is available to the
parties (i.e., this “random oracle functionality” simply re-
turns an independent random value RO(x) to each query x,
while maintaining consistency among diﬀerent queries with
the same x).

597However, it turns out that if one wants to use the full
power of the ROM, and in particular to allow the simulator,
in the security analysis, to have free access to the adversary’s
RO queries and furthermore to set the responses of the ran-
dom oracle to values of its choice, the resulting modeling
loses all composability guarantees. More precisely, secure
composition holds only if each instance of each protocol uses
a completely diﬀerent and independent random oracle than
all other instances. This of course does not correspond to
the practice of replacing the random oracle in all executions
with a single hash function.

Furthermore, this is not just a modeling issue: Using the
same instance of the RO across multiple protocols inevitably
gives rise to some unavoidable attacks. For instance, con-
sider a UC non-interactive zero knowledge (NIZK) protocol
in the RO model. If RO is available outside the individual
instance of the protocol then the transcript of the proto-
col (i.e., the proof) becomes transferable - it is veriﬁable
not only by the intended veriﬁer, but rather by anyone who
has access to RO. This stands in contrast to the ideal zero
knowledge functionality, which allows only the intended ver-
iﬁer to verify the verity of the statement.
(It should be
remarked that the same issue happens even in interactive
Zero Knowledge protocols in the ROM, but is perhaps most
evident for non-interactive ones.)

Indeed, this discrepancy between the abstract model and
its intended use was already noticed in the context of the
common reference string setup [4]. To handle this discrep-
ancy, [4] suggests to explicitly consider only trusted setup
constructs that are global, namely only a single instance of
this setup exists in the system. In particular, this construct
exists even in the “ideal model”, where the protocol is re-
placed by a “trusted party”, or an ideal functionality repre-
senting the task at hand. They then proceed to propose such
a global trusted setup construct. However their construct is
not just a public hash function (or a random oracle). Rather,
it consists of a global public key for which each party has
its own identity-based secret key. Furthermore, they argue
that no “public setup construct”, namely no construct that
provides only public information that is available to all, can
suﬃce for realizing tasks such as commitment or zero knowl-
edge in the UC framework. Given that the random oracle
does provide only public information, the avenue of com-
ing up with a useful, global ROM that provides composable
security guarantees seemed to have reached a dead end.

1.1 Our Contributions

1.1.1 The global random oracle model

We formulate a natural, global variant of the “random
oracle functionality”. As per the formalism of [4], this func-
tionality, which we denote by gRO – standing for global Ran-
dom Oracle – is accessible to all parties (both honest and
corrupted), both in the ideal model and in the model for
protocol execution. This functionality answers consistently
to all queries made by all parties. Furthermore, only a sin-
gle instance of this functionality exists. As shown in [4], the
universal composition theorem holds in this model - even
though multiple protocols and instances thereof use the same
instance of gRO.

In addition, we incorporate in gRO a mechanism that cap-
tures the fact, sketched above, that the global random ora-
cle, being a single global construct that provides the same

information to all, allows third parties to double up as ad-
versarial protocol participants and mount a transferability
attack.

In a nutshell, this analytical mechanism provide each pro-
tocol session with a unique domain of queries: queries that
pertain to a session that the querying party does not be-
long to are considered “illegitimate” and are disclosed to the
adversary. This mechanism allows capturing security prop-
erties such as “transferable non-interactive zero knowledge”,
namely protocols that are zero-knowledge except for the fact
that proofs may be transferable. As we explain in more de-
tails later, transferability attacks are the only ones allowed
in this model.
Intuitively the reason is that, whatever a
malicious third party can do by accessing the RO in some
concurrent adversarial protocol execution, can be done by
the adversary itself in her protocol execution.

We then observe that simple variants of known proto-
cols, such as the two-message zero-knowledge protocol of
Pass [24], is in fact UC zero knowledge in our global random
oracle model (gRO model).

The gRO model, the CRS/RO model and the JUC
model. The advantage of the gRO model is that it guaran-
tees secure composition even with arbitrary protocols that
use the same instance of the RO (or the same hash function).
In practice it means that the RO can be reused by any pro-
tocol in the system, without jeopardizing security. Neither
the standard (programmable) RO model nor the standard
(programmable) CRS model give any security guarantees
when the same setup is reused. One might object that there
exist protocols that are UC-secure in the Joint State model
(JUC) [9] where the same CRS is reused. However, the form
of reusability guaranteed by the JUC model is very limited
as that protocols must be pre-designed to work well together
with same CRS instance. Instead, in the gRO model proto-
cols do not need to synchronize their access to the RO.

Discussion on the random oracle model. One might
wonder about the utility in rigorously arguing secure compo-
sition of protocols in the gRO model, given that this model
anyway does not provide rigorous security guarantees once
the random oracle is replaced by a publicly computable hash
function. We provide several answers to this valid question.
First, we note that attacks that take advantage of insecure
composition might come up even when no other attacks are
found against a protocol instantiated with some hash func-
tion. (In fact, the transferability attack is a quintessential
example for such a situation.)

Second, we observe that protocols in the gRO model give
us a level of security that was not known to exist in any other
general computation (or even zero knowledge or commit-
ment) protocol that was proven secure in the UC framework:
Indeed, protocols in that framework cannot exist without
some “trusted setup” construct. All known such constructs
require trust in some third party or an external entity that is
outside the control of the players. Furthermore, these proto-
cols invariably provide the trusted external entity with the
ability, if played maliciously, to completely compromise the
security of the players.

The gRO model is diﬀerent, in that it “only” reduces the
security guarantees to the level of the stand-alone security
guarantees provided by the random oracle methodology to
begin with. That is, the level of reassurance provided by
analysis in the gRO model with respect to universally com-

598posable security is no lower than the level of assurance pro-
vided by analysis in the ROM for traditional, stand-alone
security.

Certainly, in some respects, a protocol that was analyzed
in the gRO model and instantiated with a concrete hash
function may well provide better security than a protocol
analyzed in the (non-global) CRS model and instantiated
with a globally available reference string.

Still, it should be stressed that (similar to standard ROM)
as soon as the gRO is replaced by a concrete hash function,
the security guarantees provided by this model are inevitably
only heuristic.

1.1.2 Highly-Efﬁcient Protocols

We design eﬃcient protocols for a variety of tasks in the

gRO model.

Starting from the work of Lindell and Pinkas [18], who
constructed eﬃcient two-party computation protocols based
on Yao’s garbled circuit [30] via a novel cut-and-choose tech-
nique, a proliﬁc sequence of works [20, 19, 14, 28, 21, 17, 13,
29, 1] have shown increasingly more eﬃcient protocols for se-
cure computation, which are either only stand-alone secure,
or UC-secure in the CRS model [19, 16, 17, 1]. We show how
to construct very eﬃcient protocols in the gRO model, which
in most cases improve on the highly eﬃcient known existing
solutions in the CRS model.
In particular, we ﬁrst show
a highly eﬃcient UC-commitment scheme, which compares
very favorably to the most eﬃcient known UC-commitment
scheme of Lindell in [16] (in the CRS model). When plugged
in [17], this construction directly yields very eﬃcient UC-
secure protocol for two-party computation. Finally we show
that non-interactive secure two-party computation (NISC)
is also achievable in the gRO model, building on the work of
Afshar et al. [1]. More speciﬁcally we provide the following
protocols.

UC commitments in the gRO model. We show a general
construction that combines the use of any straight-line ex-
tractable commitment in the gRO model and any trapdoor
commitment, to construct a UC-secure commitment scheme
in the gRO model. By instantiating the extractable commit-
ment with the protocol provided by Pass in [24] and the trap-
door commitment with Pedersen’s scheme [25], we obtain
an extremely eﬃcient UC-secure commitment scheme that
is signiﬁcantly more eﬃcient than the best known UC-secure
commitment scheme in the CRS model of [16]. Concretely
our protocol requires only 5 exponentiations per party and
5 rounds of communication in total (including the commit-
ment and decommitment phases).

UC two-party computation in the gRO model. We
observe that the highly eﬃcient UC-secure two-party com-
putation protocol (2PC for short) of Lindell [17], that works
in the CRS model, requires the use of UC-secure zero knowl-
edge proofs, which in turns is based on UC-Commitments
only. By instantiating Lindell’s construction with our UC-
commitments, we obtain a more eﬃcient UC-2PC protocol
in the gRO model.

UC NISC in the gRO model. NISC – non-interactive se-
cure computation– is a two-message protocol run between
parties P1 and P2, where P1 speaks ﬁrst. Very recently, Af-
shar et al. in [1] presented the most eﬃcient NISC protocol,
which is UC-secure in the CRS model. We show how to
instantiate this construction without using the CRS, in the

gRO model, while preserving the non-interactive nature of
the protocol. Our construction is slightly less eﬃcient than
the protocol of [1] but but do away with the need to rely on
a non-global (programmable) reference string.

1.2 Our Techniques

Here we provide an overview of the main technical ideas

underlying our constructions.

1.2.1 Efﬁcient UC Commitment in gRO Model

Recall that a UC secure commitment scheme requires two
main properties: (a) Equivocation: When the receiver is cor-
rupted, the simulator should be able to commit (on behalf
of the honest sender) in such a way that it is able to de-
commit to any desired value. (b) Extractability: When the
sender is corrupted, the simulator should be able to extract
the committed value during the commitment phase.

Note that the observability property of the gRO natu-
rally yields the desired extraction property discussed above.
Indeed, this was already used to build extractable commit-
ments in prior works (see e.g., [24]). How to achieve the
equivocation property, however, is not immediately clear.
Indeed, as discussed earlier, in the gRO model the simulator
cannot program the outputs of the random oracle. Further,
since we do not allow for trusted setups (such as a CRS),
the simulator does not have immediate access to a “trap-
door” that allows for equivocation.

Towards that end, our starting point is the observation (al-
ready implicit in prior works) that the task of equivocation
can, in fact, be reduced to the task of trapdoor extraction.
More concretely, consider a trapdoor commitment scheme in
the CRS model where the knowledge of the CRS trapdoor
allows for equivocation (but does not compromise the hiding
property of the scheme). For example, Pedersen’s commit-
ment scheme [25] satisﬁes these properties. Then, consider
the following protocol template: ﬁrst, the receiver chooses
the CRS of the trapdoor commitment scheme on its own
and sends it to the sender along with an extractable com-
mitment to the associated trapdoor. For concreteness, let us
think of the extractable commitment as simply the answer
of the gRO when queried with the trapdoor string. Next, the
committer commits to its input string by simply using the
trapdoor commitment scheme. Since we want to preserve
the extractability property from the committer side, we fur-
ther require the committer to query the gRO on the opening
of the above commitment and then commit to the answer
of the gRO via another instance of trapdoor commitment.
(Similar ideas were used in [23].)

Now, consider the following simple strategy for equivoca-
tion: the simulator ﬁrst extracts the value committed by the
receiver in the ﬁrst message (by simply observing its query
to the gRO) and then uses it as a trapdoor to later equivo-
cate in both of the trapdoor commitments. While such an
approach would indeed work against a semi-honest receiver,
unfortunately, it does not work against a malicious receiver.
The problem is that the above protocol does not preclude
a cheating receiver from committing to some bogus value
(instead of the correct trapdoor). Note that here we cannot
simply require the receiver to provide a proof of consistency
since proving that a given string is the output of the random
oracle is not an NP statement.

Going further, one can observe that an extractable com-
mitment in the gRO model is, in fact, only eﬀective if it is

599later decommitted. This is because otherwise the adversary
can choose to simply not query the gRO at all! Thus, in or-
der to verify that the receiver actually commits to the valid
trapdoor, we ask it to open its commitment in the decom-
mitment phase. Now, the simulator can indeed extract the
trapdoor from the ﬁrst message of the receiver and be con-
vinced of its validity since otherwise the receiver would fail
to decommit properly later on.

While the above modiﬁcation yields us the desired equiv-
ocation property, unfortunately, the resultant protocol is no
longer sound against adversarial committers. This is be-
cause after viewing the trapdoor revealed by the receiver,
a cheating committer can now also equivocate in the same
manner as the simulator. Indeed, it may seem that now the
simulator and an adversarial committer have the exact same
power (i.e., both have access to the trapdoor). In order to
solve this problem, we leverage the asymmetry between the
simulator and the cheating committer. In particular, note
that the simulator knows how to equivocate even at the start
of the decommitment phase (conditioned on the event that
it previously extracted a valid trapdoor from the receiver),
while the cheating sender can only equivocate after the re-
ceiver reveals the trapdoor. Thus, we now require the com-
mitter to commit to its openings of the commitments (from
the commitment phase) before the receiver reveals the trap-
door. This immediately prevents the committer from being
able to equivocate, but still preserves the equivocation prop-
erty of the simulator. Due to technical reasons, we require
the above commitment to also be extractable. Very brieﬂy,
this is necessary to formally reduce the binding property of
the UC commitment scheme to the binding property of the
trapdoor commitment scheme.

Discussion on Efficiency. We compare the eﬃciency of
our scheme with Lindell’s commitment scheme [16] (which,
to the best of our knowledge, is the most eﬃcient UC secure
commitment scheme in the CRS model, in the literature).
Round Complexity. The commitment phase in our scheme
requires 2 rounds while the commitment phase in [16] is
non-interactive. On the positive side, our decommitment
phase requires 3 rounds, while [16] requires 5 rounds. Com-
putational Complexity. Prior works have demonstrated that
the main bottleneck in the computational eﬃciency is the
number of exponentiations. When instantiated with Peder-
sen’s commitment scheme, our protocol requires only 5 ex-
ponentiations per party: the commitment phase requires 1
exponentiation from the receiver to compute the parameters
for Pedersen commitment, and 4 exponentiations from the
committer to compute two Pedersen’s commitments; in the
decommitment phase the same exponentiations are required
in the reverse order for the veriﬁcation of the parameters and
the decommitments. In contrast, in [16], requires 13 expo-
nentiations per parties. Our protocol additionally requires
6 random oracle evaluations.

1.2.2 Efﬁcient NISC in gRO Model.

Our starting point is the NISC protocol of [1], which is
UC-secure in the CRS model. Our goal is to emulate their
approach in the gRO model. Towards that end, we observe
that this task can be reduced to implementing a UC secure
oblivious transfer (OT) protocol in the gRO model. In par-
ticular, since our focus is on eﬃciency, recall that the NISC
protocol of [1] relies on the highly eﬃcient UC OT protocol
of Peikert et. al [26]. (For convenience, let us refer to this

protocol as PVW OT.) Therefore, our goal then is to realize
a version of PVW OT in the gRO model.

Realizing this simple idea, however, turns out to be highly
problematic. Note that since a CRS is not available in our
setting, the natural approach is to have the OT receiver
choose the OT parameters (that comprise the CRS in [26])
and provide a zero-knowledge proof of knowledge (ZKPoK)
of consistency. We stress that both the ZK and PoK prop-
erties of the proof are crucial here to ensure that the result-
ing OT protocol is fully simulatable. Speciﬁcally, the ZK
property is necessary to allow the simulator to cheat in the
computation of the parameters and extract both the inputs
of a malicious OT sender. The PoK property, on the other
hand, allows the simulator to extract the input of the re-
ceiver. Note, however, that a ZK proof in the gRO model
requires at least two rounds [24]. As such, the resulting OT
protocol in the gRO model becomes 3 rounds which violates
the non-interactivity requirement for NISC.

Towards that end, upon closer inspection of the NISC
protocol of [1], we make the following observation: Let P1
and P2 denote the two parties in the NISC protocol where
P1 is the evaluator of the garbled circuit, and therefore the
receiver of the OT, and P2 is the generator of the garbled
circuit and therefore the sender of the OT. Then, [1] uses the
simulatability property of OT against malicious OT senders
to extract the input of the sender P2.

Our ﬁrst idea is to extract the critical information from P2
by exploiting the observability property of gRO. Speciﬁcally,
we modify the NISC protocol of [1] by requiring that the
randomness used to compute the commitments and the gar-
bled circuits is generated by querying gRO. This enables the
simulator –that observes the queries– to extract all the keys
of the garbled circuits in “straight-line” without simulating
the OT protocol for adversarial OT sender. Therefore, the
problem of implementing the NISC protocol of [1] in the gRO
model now reduces to constructing a 2 round one-sided sim-
ulatable OT, namely, an OT which is UC simulatable against
malicious receivers but only guarantees indistinguishability
security against malicious senders.

Our next contribution is to provide such a construction.
The high-level strategy is to replace the (2-round) ZKPoK in
the above construction of PVW OT with a non-interactive
witness hiding (or witness indistinguishable) PoK in the
gRO model.
Implementing this idea, however, turns out
to be quite non-trivial. Recall that the security of PVW
OT against a malicious sender relies on the hardness of the
DDH problem: an adversary distinguishing the input bit
of the honest receiver can be used to construct an adver-
sary that distinguishes a DDH tuple from a non-DDH tuple.
This reduction goes smoothly when the receiver in PVW OT
gives a ZKPoK proof of the correctness of the OT parame-
ters since the DDH distinguisher can use its challenge tuple
as the OT parameters and give a simulated ZK proof of cor-
rectness without knowledge of the corresponding witness.

However, when we replace the ZK proof with (say) a wit-
ness hiding (WH) proof, then the above reduction does not
work because the DDH distinguisher does not know the wit-
ness for the proof. Towards that end, we pursue the idea
of using a witness-indistinguishable (WI) proof instead of
a WH proof. We have the following two-fold requirement:
ﬁrst, the statement for the WI proof should enable a sec-
ondary witness that can be used by the DDH distinguisher
in the above reduction to construct a valid proof (without

600knowledge of the witness corresponding to the challenge tu-
ple). Second, the PoK property of the proof should enable
extraction of a cheating OT receiver’s input even if she uses
the secondary witness.

As we discuss later in Sec.4, realizing the above two prop-
erties simultaneously turns out to be a diﬃcult task. Our
ﬁnal idea towards this end is to essentially run the OT proto-
col twice in parallel. Speciﬁcally, we require the OT receiver
to choose two independent OT parameters and give a single
WIPoK proof that proves the correctness of one of them.
The sender then secret shares each of its OT input into two
parts and then computes two diﬀerent OT messages (using
diﬀerent OT parameters), one for each set of input shares.
Now, in order to argue security against cheating senders,
we can construct a DDH distinguisher who uses the challenge
tuple as one of the two OT parameters and generates the
second one on its own. This allows the distinguisher to suc-
cessfully give a WI proof of correctness. On the other hand,
when the OT receiver is corrupted, the soundness of WIPoK
ensures that at least one of the OT parameters is honestly
generated. Therefore, we can ensure that a cheating receiver
cannot learn both the inputs of the honest sender. In par-
ticular, the simulator uses the PoK property to extract the
input of the receiver (which may be ⊥ if the one set of OT
parameters chosen by the receiver is malformed, since in
this case, the receiver will not learn either of the inputs of
the honest sender). We refer the reader to Sec. 4 for more
details.

Discussion on Efficiency. Our one-sided simulatable OT
in the gRO model is more expensive in terms of exponentia-
tions compared with the PVW OT in the CRS model. This
is due to the WIPoK that the OT receiver has to perform
at the beginning of the protocol to prove the consistency of
the OT parameters. The WIPoK protocol that we use re-
quires t parallel repetitions of a Σ-protocol (which are nec-
essary to achieve straight-line extractability [11] in the gRO
model), where t is the statistical security parameter. The
underlying Σ-protocol is based on the Σ-protocol provided
in [10] to prove OR-statements, and requires 8 exponentia-
tions. Therefore, in total the proof requires 8t exponentia-
tions. We stress that this proof is executed only once at the
beginning, and the same parameters can be reused for all
the subsequent transfers.

Furthermore, as our OT-protocol consists of a double rep-
etition of PVW OT, each transfer is twice more expensive
than a transfer with PVW OT. Additionally, our protocol
requires 4.5t random oracle evaluations (the explanation of
such values are deferred to Sec. 4). However, we observe that
the NISC protocol of [1] requires (O(tn+t2) exponentiations,
where t is the statistical parameter for the cut-and-choose
protocol and n is the size of the input of one of the parties.
Therefore, when plugged into NISC, our one-sided simulat-
able OT construction does not add a signiﬁcant overhead.

2. THE GLOBAL ROM

In this work we show how to model the random oracle as a
global functionality and achieve UC-security in this model.
Before describing our model we provide a brief overview of
the deﬁnition of UC and generalized UC.

The UC framework was introduced by Canetti in [3] to
model security for protocols running in the complex net-
work environment like the Internet. The framework is based

on the ideal/real world paradigm, and the complex interac-
tions between protocols are modeled via the concept of the
environment Z.
In the ideal world, one speciﬁes an ideal
functionality F as an interactive Turing machine that pri-
vately communicates with the parties and the adversary S
and computes a task in a trusted manner. The speciﬁca-
tion of the functionality also models the adversary’s ability
to inﬂuence the computation and the information that the
protocol leaks.

In the real world, one speciﬁes a protocol Π as an interac-
tive Turing machine executed by the parties. Parties commu-
nicate over the channel in presence of an adversary A which
controls the schedule of the communication over the chan-
nel, and can corrupt parties. When a party is corrupted the
adversary receives its secret input and its internal state. In
this work, we consider only static adversaries, which means
that A can corrupt a party only before the protocol execu-
tion starts.

The basic UC execution model lets the environment Z de-
termine the inputs to the parties running the protocol and
see the outputs generated by these parties, and also allow
free communication between the environment and the ad-
versary A/S. A protocol Π securely realizes a functionality
F in the UC framework if for any real world adversary A,
there exists an ideal adversary S, such that for any PPT
environment Z the view of an interaction with the protocol
and A is indistinguishable from the view of an interaction
with the trusted party F and S. One also consider a G-
hybrid model, where the real-world parties are additionally
given access to an ideal setup functionality G. During the
execution of the protocol, the parties can send inputs to,
and receive outputs from, the functionality G.

A crucial aspect of the UC framework is its modular-
ity: when programs call subroutines, these subroutines are
treated as separate entities that can be analyzed separately
for their security properties by way of realizing a function-
ality G.
It is then argued, via the universal composition
theorem, that any protocol that uses subroutine calls to G
keeps all its security properties when G is replaced by a pro-
tocol that realizes it.

However, the universal composition theorem holds only
when subroutines do not share any part of their internal
states with each other or with the calling protocol. In par-
ticular, a setup functionality that is modeled as a subroutine
of the analyzed protocol cannot be invoked by more than one
protocol session. Consequently, when modeling trusted set-
up assumptions by way of trusted subroutines for protocols
(as is done, e.g., in the standard modeling of the Common
Reference String (CRS) model), this means that secure com-
position is not guaranteed when diﬀerent protocol sessions
use the same CRS.

The Generalized Universal Composability (GUC) frame-
work [4] extends the UC framework in order to capture se-
curity even for the case where the same trusted setup is
accessible to all protocols in the system.
[4] extends the
basic execution model of the UC framework to allow the
environment to create parties that run multiple protocols
and sessions thereof in a single execution. All such parties
have access to the same setup functionality, that is therefore
called global functionality. The global functionality exists
both in the real and the ideal system and the simulator has
no control over it. This modeling has the eﬀect that the
environment can access global functionalities directly (via

601protocols that it has created and interact with the global
functionalities). It is no longer restricted to interacting with
the global functionality via the adversary/simulator.

Then, as in the UC-framework, a single session of protocol
Π is identiﬁed. Let s∗ denote the SID of this session. It is
required that for any adversary there exists a simulator such
that no environment, having access to the global functional-
ity, can tell whether it is interacting with the adversary and
a ‘real’ system where parties of session s∗ run protocol Π, or
with the simulator and an ‘ideal’ system where the parties
of session s∗ are interacting with F.

The global random oracle model. We aim to model
the random oracle as a global functionality and to achieve
UC-security in this model. Let us ﬁrst consider a simplistic
candidate formulation: When queried by anyone for a value
x, the random oracle functionality simply checks if x was
queried before by anyone. If not, then it returns a freshly
chosen random string of some pre-speciﬁed length.
If yes
then the previously chosen value is returned again — even if
the earlier query was made by another party. No other infor-
mation is disclosed to anyone. Let us call this functionality
GsRO (where the s stands for “strict”).

While GsRO is natural, it seems to be of little help for
proving security of protocols. For one, GsRO does not al-
low the simulator to “emulate” the random oracle function-
ality to the environment, or in other words to “program”
the answers of the random oracle.
Indeed, recall that the
environment can create additional parties that query GsRO
and report the answer directly back. Furthermore, if we
attempt to modify the deﬁnition of GsRO by allowing the
simulator to determine the answers, we will lose the useful-
ness of the functionality altogether since the adversary too
would be able to attack protocols by modifying the answers
accordingly. This means that we essentially have to use this
“non-programmable” variant of the random oracle.

More importantly, GsRO is of little help to the simulator for
another reason: The environment can obtain random-oracle
values, via the auxiliary parties, without having the adver-
sary/simulator be aware of the queried values or answers.
This means that GsRO is essentially useless to the simulator.
Indeed, the impossibility results for UC computation in the
[5, 8]) are easily extendible to the GsRO
plain model (e.g.
model.1

If one attempts to modify the deﬁnition of GsRO so that it
will disclose to the simulator all the queries made by other
parties then one will again lose the usefulness of the func-
tionality altogether, since the adversary too would be able
to see the queries made by uncorrupted parties.

We provide a mechanism that allows designing protocols
where the oracle queries made by honest parties are invisible
to external entities, while providing suﬃcient information to
the simulator to “extract” illegitimate queries made by the
environment. We ﬁrst present the mechanics of this mecha-
nism. Next we present the semantics and the justiﬁcation.
The mechanism is simple: the random oracle functionality
continues to answer oracle queries as before.
In addition,
it now agrees to disclose, to some pre-speciﬁed set of ideal
functionalities, some of the values queried by parties. The

1Still, it should be kept in mind that having access to a ran-
dom oracle such as GsRO is not something that can be emu-
lated in the standard model using an eﬃciently computable
hash function family. In particular, the impossibility results
of [6] still hold even with respect to this model.

Functionality GgRO

Parameters: output length ℓ(n) and a list ¯F of ideal func-
tionality programs.

1. Upon receiving a query x, from some party P =

(pid, sid) or from the adversary S do:

• If there is a pair (x, v) for some v ∈ {0, 1}ℓ(n)
in the (initially empty) list Q of past queries,
return v to P . Else, choose uniformly v ∈
{0, 1}ℓ(n) and store the pair (x, v) in Q. Return
v to P .

• Parse x as (s, x′). If sid 6= s then add (s, x′, v)
to the (initially empty) list of illegitimate
queries for SID s, that we denote by Q|s.

2. Upon receiving a request from an instance of an ideal
functionality in the list ¯F , with SID s, return to this
instance the list Q|s of illegitimate queries for SID s.

Figure 1: GgRO

idea is that these ideal functionalities will then forward the
disclosed values to the adversary/simulator. (The reason for
having these values disclosed only to ideal functionalities,
rather than directly to the adversary/simulator, is to make
it explicit that these values are leaked by the functionalities.
We discuss this important issue at more length below.)

Determining which queried values are disclosed to an ideal
functionality F is done as follows. Queries are expected to
have an explicit session identiﬁer (SID) ﬁeld, namely, a query
x is parsed as the pair x = (s, x′) where s is the SID. If the
content of the SID ﬁeld of the query diﬀers from the content
of the SID ﬁeld of the querying party P (recall that in the
UC framework each party is identiﬁed with the unique pair
(PID, SID) where PID is the program identiﬁer and SID is
the session identiﬁer), then the query is considered “illegiti-
mate”, and can be disclosed to the instance of F whose SID
is the one in the query. It is stressed that illegitimate queries
are answered as usual; they are just recorded separately and
potentially disclosed. The resulting random oracle function-
ality, denoted GgRO, is described in Fig. 1.

The rationale behind this way of deﬁning (il-)legitimate
queries is the following. On the one hand, it allows designing
protocols where the legitimate participants make RO queries
that are never disclosed (simply preﬁx each query by the
SID of the present session). Furthermore, it forces an ideal
functionality to explicitly represent the information that is
leaked by ideal functionalities regarding the oracle queries.
To further exemplify the properties of GgRO, let us con-
sider the case of zero-knowledge protocols in the presence of
GgRO. Recall that the traditional ideal Zero Knowledge func-
tionality, FZK, allows a prover to convince a veriﬁer (whose
identity is determined by the prover) of the correctness of
a statement without revealing any additional information,
and without allowing the veriﬁer to “transfer” the proof to
another party. In contrast, as discussed in the Introduction,
any proof in the global ROM is inherently transferable: To
transfer a proof to party C, the veriﬁer V simply lets C act
as the veriﬁer, and in particular have C make all the ora-
cle queries herself. Consequently, any formal modeling of
the global ROM should mirror this property of the global

602Functionality FtZK

FtZK is parameterized by a relation R ⊂ {0, 1}∗ × {0, 1}∗.
We require that there exists a polynomial p such that
(x, w) ∈ R implies that |w| ≤ p(|x|) and such that
(x, w) ∈ R can be checked in time p(|x|). FtZK runs with
a prover P , a veriﬁer V and an adversary S and proceeds
as follows.

• Upon

receiving

the

ﬁrst

sid, P, V, x, w) from P, do:
send (ZK-proof, sid, P, V, x) to V and S.

input

(ZK-prover,
If (x, w) ∈ R, then

• When asked by the adversary, obtain from GgRO the
list Qsid of illegitimate queries that pertain to SID
sid, and send Qsid to S.

Figure 2: The Zero-Knowledge functionality FtZK

ROM. Indeed, it can be seen that FZK is not realizable if
the parties only have access to GsRO. (Intuitively, disclosing
the queries of third parties to the adversary/simulator has
the eﬀect that these third parties can no longer use GgRO to
verify claims made by parties that participate in the session
under consideration. This, for instance, means that GgRO can
no longer be used, in the model, to “transfer” proofs made
within the session to third parties.)

Furthermore GgRO allows us to capture a more nuanced
property: “Zero Knowledge up to transferability”. This is
done via a relaxed variant of the ideal zero knowledge func-
tionality, FtZK where tzk stands for transferable zero knowl-
edge, which leaks to the simulator the values of the ille-
gitimate queries made with the present SID. Intuitively, the
leakage of the adversarial queries made by third parties does
not compromise zero knowledge beyond allowing the ability
to transfer proofs. Indeed, since any query made by a third
party could have been made by the adversary itself, any ad-
versary that uses GgRO’s answer to queries made by third
parties can be simulated by an adversary that makes the
same queries by itself. We describe the FtZK functionality in
Fig. 2. As an additional example, in Fig. 3 we describe the
Commitment functionality, that we denote by Ftcom.

3. UC-SECURE COMMITMENT

In this section, we show a UC secure commitment scheme
hC, Ri in the global RO model. The intuition behind the
security proof was given in Sec.1.2. For the formal proof the
reader is referred to the full version.

Let (TCGen, TVer, TCom, TRec, TEquiv) be a trapdoor
commitment scheme, where TCGen(1n) is the generation al-
gorithm that on input the security parameter n, outputs
a public key pk and a trapdoor sk; TCom is the commit-
ment algorithm that takes in input pk and a message m and
outputs the commitment c and the decommitment d; TVer
is the trapdoor veriﬁcation algorithm that on input (pk, sk)
outputs 1 if sk is the correct trapdoor associated to pk. TRec
is the veriﬁcation algorithm that on input (c, d, m) outputs
1 iﬀ d is a valid decommitment of c for message m; TEquiv is
a polynomial-time algorithm that (very informally) on input
sk, m and some auxiliary information about a commitment
c′, outputs a valid an opening d for the message m.

Functionality Ftcom

Ftcom running in presence of an adversary S proceeds as
follows:

• Commitment Phase: Upon receiving a message
(commit, sid, Pi, Pj , m) from Pi where m ∈ {0, 1}n:
Record the tuple (sid, Pi, Pj , m) and send the mes-
sage (receipt, sid, Pi, Pj ) to Pj and S. Ignore any
subsequent commit messages.

• Decommit Phase: Upon receiving (decommit,
sid, Pi, Pj) from Pi, if the tuple (sid, Pi, Pj, m) is
recorded then send (decommit, sid, Pi, Pj , m) to Pj
and to S and halt. Otherwise ignore the message.

• When asked by the adversary, obtain from GgRO the
list Qsid of illegitimate queries that pertain to SID
sid, and send Qsid to S.

Figure 3: The Commitment Functionality Ftcom.

Our commitment scheme can be based on any stand-alone
secure trapdoor commitment scheme. However, in order to
obtain the concrete eﬃciency parameters as discussed earlier
in Sec.1.2, we instantiate the trapdoor commitment scheme
with Pederson’s perfectly hiding commitment scheme [25],
that we now describe for completeness. The generation
algorithm TCGen is a randomized algorithm that outputs
pk = (G, p, q, g, h) and sk = trap where p = 2q + 1, p
and q are primes, G is a subgroup of order q of Z∗
p , g
and h = gtrap are generators of G. The trapdoor veriﬁca-
tion algorithm TVer outputs 1 iﬀ h = gsk. The commit-
ment algorithm is implemented as: TCom(pk, m) = gmhr
(mod p), d = (m, r) where r ∈ Z⋆
p is randomly chosen. The
receiver algorithm TRec takes as input (c, m, r) and out-
puts 1 iﬀ c = gmhr. The equivocation algorithm TEquiv
takes as input (c, m, r, m′, sk), where c denotes a commit-
ment, (m, r) denotes the decommitment for c, m′ is the new
message (for which equivocation is required) and sk is the
trapdoor. The algorithm computes the new decommitment
(for m′) as r′ = m′−m

and outputs it.

r

Protocol 1. UC Commitment in the gRO model.
Inputs. C has in input m ∈ {0, 1}n. R has no input. Let
sid denote the session identiﬁer.

Commitment Phase: This phase consists of two rounds.

• R → C: R ﬁrst computes (pk, sk) ← TCGen(1n).
Next, it samples a random string r (of appropriate
length) and queries the gRO on the string (sid, ‘R’kskkr).
Let aR be the resulting answer.

R sends (pk, aR) to C.

• C → R: C ﬁrst computes a trapdoor commitment to
its input string m, namely, (cmsg, dmsg) ← TCom(pk, m).
Next, it samples a random string s and queries the
gRO on the string (sid, ‘C’kmkdmsgks). Let aC be the
resulting answer. Finally, it computes a trapdoor com-
mitment to aC as (cro, dro) ← TCom(pk, aC ).

C sends (cmsg, cro) to R.

Decommitment Phase: This phase consists of 3 rounds.

603• C → R: C commits to the decommitments dmsg, dro: it
ﬁrst samples a random string s′ and queries the gRO
on the string (sid, ‘C’kdmsgkdroks′). It then sends the
resulting answer a′

C to R.

• R → C: R sends (sk, r) to C.

• C → R: C aborts the protocol if either of the fol-
lowing veriﬁcations fails: (a) aR = gRO(sid, ‘R’kskkr),
(b) TVer(pk, sk) = 1. Otherwise, if both the checks
succeed, then C reveals (m, dmsg, dro, aC , s, s′) to R.
The receiver R accepts m as the decommitted value
iﬀ all of the following veriﬁcations succeed: (a) a′
C =
gRO(sid, ‘C’kdmsgkdroks′), (b) TRec(cro, aC , dro) = 1,
(c) aC = gRO(sid, ‘C’kmkdmsgks), (d) TRec(cmsg, m,
dmsg) = 1.

Efﬁciency.

The commitment protocol has the following complexity.
Round Complexity. The protocol requires two rounds for
the commitment phase and 3 rounds for the decommitment
phase. Exponentiations. The total number of exponenti-
ations is 8. Hash evaluations. The total number of hash
evaluations is 6.

4. ONE-SIDED UC-SIMULATABLE OT

The NISC protocol of [1] builds upon the eﬃcient PVW
OT protocol of [26], which is UC-secure in the CRS model
(more speciﬁcally, they rely on a modiﬁcation of it due
to [28], which we will explain later). UC-realizing NISC in
the gRO model amounts to provide a 2-round OT protocol
which is UC secure in the gRO model.

As we discussed in Sec. 1.2, the ﬁrst approach that comes
into mind to implement eﬃcient UC-OT, is to take the PVW
OT that works without the CRS and adapt it to the gRO
model. This version of PVW OT was shown by Lindell
and Pinkas in [19], and it requires the receiver to choose the
parameters for the OT and to provide a zero-knowledge PoK
of their correctness.

This naive approach is correct, but it yields a 3-round OT
protocol. The reason is that any ZKPoK in the gRO model
requires at least two rounds (as observed in [24]).

Our ﬁrst observation is that the zero knowledge property
is required only to extract from the sender, thus if we relax
this requirement and demands only that a malicious sender
cannot distinguish whether the receiver is playing with input
0 or input 1, then a witness indistinguishable proof – which
can be made non-interactive in the gRO model – suﬃces.

Before proceeding with our discussion, let us recall the
PVW OT protocol in the plain model (without CRS). Let
g0, q, G be public parameters, where g0 is the generator of
the group G of prime order q. PVW OT consists of two
steps. Step 1. The receiver R picks α0, y at random in Zq
and set α1 = α0 + 1, and g1 = gy
0 and
h1 = gα1
1 . It sends parameters (g0, h0, g1, h1) to the sender S
and additionally proves that (g0, h0, g1, h1
) is a DDH tuple
g1
using a ZK PoK. (Such parameters can be reused among
several transfers with the same sender). Concretely, such
ZKPoK is instantiated with the zero-knowledge version of a
Σ-protocol for Discrete Log (due to [27]), for the theorem
(cid:16)h0 = gα0
1 (cid:17). For the actual transfer, R sends
the temporary key g = gr
b , where r ←R Zq and b

0 . It computes h0 = gα0

b , h = hr

0 ∧ h1

= gα0

g1

is R’s input. Step 2. If the ZK proof is accepting, S uses
parameters (g0, h0, g1, h1) and h, g to encrypt its two strings
s0, s1.

The security of the receiver relies on the DDH assump-
tions. To see why, note that if b = 0, then (g0, h0, g, h) is
a DDH tuple, if b = 1, then (g1, h1, g, h) is a DDH tuple.
Thus, a malicious sender distinguishing bit 0 from 1 can be
transformed in DDH distinguisher.

Our ﬁrst attempt is to replace the ZK protocol with a
(non-interactive) witness-hiding PoK protocol (WHPoK).
The crucial problem of this approach is that the reduction
to the DDH problem does not go through. Indeed, in order
to complete the OT protocol, and thus to be able to exploit
the distinguishing power of a malicious sender S∗, the DDH
distinguisher needs to provide a valid WHPoK, for which he
does not know the witness. Although intuitively it seems
that the witness hiding property should help, it is not clear
how to exploit S∗ to extract the witness. (Note that techni-
cally one can also use a WI proof for the following theorem:
(h0 = gα0
0 ). The prob-
lem here is that extracting the witness y does not help the
simulator in extracting the bit of R∗).

1 ) OR (g1 = gy

0 ∧ h1

0 ∧ h1

= gα0

g1

= hy

g0

Our approach is to run two parallel executions of Step
1 (with independent parameters), and prove using a single
WIPoK that one of the parameters is correctly generated. In
Step 2, the sender will secret share its inputs in two shares,
and compute two parallel executions of Step 2, one for each
share. Due to the the soundness of the proof, in one of the
executions the parameters are correctly computed, and thus
a malicious receiver can never get two shares for both inputs.
This solution works against the malicious sender. Indeed,
now we have the freedom to chose between two independent
DDH tuples, and place the challenge of the DDH experi-
ment in one of the two, while computing the WI proof with
the witness of the other tuple. Against the malicious re-
ceiver, the simulator can extract the bit played in one of the
sessions only. Nevertheless, this knowledge is suﬃcient, as
the receiver will be able to get two shares only for the bit
committed in the “correct” session. For the formal proof the
reader is referred to the full version.

We now present our protocol in details.

Notation. Our OT protocol essentially consists of two par-
allel sessions of the PVW OT, that we denote by session
0 and session 1 respectively. To identify the parameters
used in each session we use two indexes in the subscript,
where the second index identiﬁes the session. For example,
in our PVW OT the receiver send two set of OT parame-
ters (g0, h0, g1, h1), one for each session. Hence, we denote
the parameters for session 0 by (g0,0, h0,0, g1,0, h1,0), and pa-
rameters for session 1 by (g0,1, h0,1, g1,1, h1,1).
In general
notation hb,s must be interpreted as follows: hb,s is the pa-
rameter hb (as in PVW OT) played in session s.

Similarly, the sender will break up its input (s0, s1) in the
shares (s0,0, s1,0) to play in session 0 and (s0,1, s1,1) to play
in session 1, where notation (s0,s, s1,s) means, the share of
s0 in session s and the the share of s1 in session s.

We use DL to denote the Discrete Log problem. A pair
(g, h) ∈ DL iﬀ there exists x such that h = gx. We de-
note by NIWIpok a non-interactive witness indistinguishable
proof of knowledge in the gRO model model for the (OR
composition) of the DL problem. Such construction was
provided in [24] and consists in the parallel repetition of
t executions of a Σ-protocol for the OR composition of DL

604problem (shown in [10]), where the veriﬁer’s challenge in the
Σ-protocol is replaced with the answers of gRO. Finally, for
easiness of explanation we omit some validity checks that S
has to perform on the parameters sent by R.

Protocol 2. One-sided UC-simulatable OT.
Common parameter. (G, q, g0,0, g0,1).
Inputs. Inputs to S: a pair (s0, s1). Input to R : a bit b.

Round 1. R performs the following steps.

1. Generate OT Parameters. (Session 0) Pick y0, α0,0.
Set α1,0 = α0,0 + 1.
(Session 1) Pick y1, α0,1. Set
α1,1 = α0,1 + 1. Compute g1,e = (g0,e)ye , h0,e =
(g0)α0,e , h1,e = (g1)α1,e , for e = 0, 1.

2. Generate proof of consistency. Run NIWIpok for
the theorem {h0,0 = (g0,0)α0,0 ∧ h1,0
= (g1,0)α0,0 } OR
g1,0
{h0,1 = (g0,1)α0,1 ∧ h1,1
= (g1,1)α0,1 } using witness
g1,1
α0,e for a randomly chosen bit e. We denote this proof
by proofcons. For this computation R needs to query
the random oracle gRO (see [24]).

3. Generate temporary public keys. Pick r0, r1 ∈ Zq
at random. Compute temporary key for session 0. Set
pk0 = (g0, h0) where g0 = (gb,0)r0 , h0 = (hb,0)r0 . Set
pk1 = (g1, h1) where g1 = (gb,1)r1 , h1 = (hb,1)r1 .

4. Send parameters. Send par0 = (g0, h0,0, g1,0, h1,0);

par1 = (g0, h0,1, g1,1, h1,1); proofcons, pk0, pk1 to S.

Round 2. If the proof is accepting, S performs the fol-

lowing steps.

1. Compute shares. Pick s0,0, s1,0 at random, and

compute s1,0 = s0,0 + s0, s1,1 = s1,0 + s1.

2. OT transfer.

• Session 0. Play as sender of PVW OT with in-
put (s0,0, s1,0). Namely, compute (ud,0, vd,0) =
RAND(gd,0, hd,0, pk0) for d = 0, 1 and w0,0 = v0,0 ·
s0,0 w1,0 = v1,0 · s1,0.

• Session 1. Play as sender of PVW OT with in-
put (s0,1, s1,1). Namely, compute (ud,0, vd,0) =
RAND(gd,0, hd,0, pk0), for d = 0, 1 and w0,1 =
v0,1 · s0,1 w1,1 = v1,1 · s1,1.
Where RAND(g, h, g′, h′) is the following function-
ality: pick s, t ∈ Zq, output u = gs · ht and
v = g′s · h′s.

3. Send (u0,0, w0,0), (u1,0, w1,0) for session 0. Send

(u0,1, w0,1), (u1,1, w1,1) for session 1.

Decryption. R obtains sb,0 = wb,0

(ub,0)r0 and sb,1 = wb,1
(ub,1)r1

and outputs sb = sb,0 + sb,1.

Efﬁciency.

The above protocol has the following complexity. Round
Complexity. The protocol requires one message per party
only. Exponentiations.
In the initialization phase the re-
ceiver computes 6 exponentiation for the parameter genera-
tion and 2t exponentiations for the non-interactive WI proof
proofcons. This is done only once and the same parameter can
be re-used for more than one transfer. For each transfer the
receiver computes 6 exponentiations. The sender computes

2t exponentiations to check the WI proof, and 8 exponen-
tiations for each transfer. The total number of exponen-
tiation is 4t+20 exponentiations, where t is the statistical
parameter. Hash evaluations. The sender compute 2t + 1
hash evaluations for the WI proof proofcons, while the receiver
evaluates the hash t + 1 times.

Batch Committing OT.

The notion of Committing-OT has been introduced by
Kiraz and Schoenmakers in [15], and is a modiﬁcation of
standard OT functionality where, at the end of the protocol,
the OT receiver additionally receives commitments to the
inputs of the sender, and the OT sender outputs the opening
of such commitments.

More speciﬁcally, the sender runs OT with input (s0, r0),
(s1, r1) and the receiver runs with input b. At the end of
the protocol the receiver additionally obtains commitments
Com(s0; r0), Com(s1, r1) and the sender outputs r0, r1.

The work [1] on which we build upon, requires a commit-
ting OT protocol which is a property already satisﬁed by
PVW OT. To see why, note that the message sent by the
OT sender in the second round can be seen as a commitment
of the sender’s input. (E.g., the message to retrieve string
sb corresponds to the pair (ub, wb) where ub = gs
b and
w = g′s · h′t · sb and g′, h′ is the temporary key sent by the
receiver). Our one-sided simulatable OT is also a commit-
ting OT. The reason is that it can be seen as a modiﬁcation
of the PVW OT where sender and receiver basically repeats
the PVW OT twice in parallel.

b · ht

Furthermore, as in [28] our protocol can be modiﬁed to
allow batch OT, where the sender plays with m strings for
0 and m strings for 1: [K0,1, . . . , K0,m] and [K1,1, . . . , K1,m]
and the receiver plays with one bit b only, and select one
of the m-tuples.
In order to send m strings, the sender
simply runs procedure RAND() 2m times reusing the same
temporary keys sent by the receiver for that transfer.

5. UC-SECURE NISC

Given any two-round UC-OT, a non-interactive UC-2PC
(UC-NISC, for short) for any function f (x, y) can be easily
constructed in the CRS model as follows. P1 sends the ﬁrst
message of the OT based on its input x, P2 prepares a gar-
bled circuit for f and computes the second message of the
OT on input the appropriate garbled keys for P1. Addition-
ally P2 sends the keys for the input wires corresponding to
its own input y and a NIZK proof to prove that the garbled
circuit is correct and the keys sent in the OT are consistent
with the circuit and P2’s input. However, this solution is
very ineﬃcient as it requires non-black-box use of the un-
derlying primitives.

In [1] Afshar et al. show a highly eﬃcient NISC protocol,
which is UC-secure in the CRS model. Toward this goal,
they start with the multi-round highly-eﬃcient 2PC protocol
presented by Lindell [17] and squash it down to two rounds.
Lindell’s protocol is based on cut-and-choose techniques, and
it requires several rounds of interaction.

The main contribution of [1] is to show how to perform
all the checks required by the cut-an-choose technique non-
interactively, using ingenious new ideas. We built upon their
protocol to achieve the same result in the gRO model. In
the following, we ﬁrst outline the NISC protocol of [1] and
then we discuss how we modify their construction to achieve
our result.

605NISC in the CRS model [1].

To implement the cut-and-choose in only two rounds [1]
uses several techniques. For lack of space we cannot fully
describe the ideas behind the protocol (the reader can refer
to Pagg. 392-395 of [1] and references within for an overview
of their techniques). Instead we highlight two salient points
of their protocol that allow us to achieve the same result in
the gRO model.

Recall that in a typical cut-and-choose protocol, P2 sends
t garbled circuits gc1, . . . , gct to P1, who tests the correct-
ness of them by asking P2 to “open” half of the circuits (i.e.,
to reveal the randomness used to generate them).
If all
the checks go through, P1 is convinced that most of the
remaining circuits are correct . The ﬁrst idea to achieve
non-interactiveness, is to let P1 select the circuits that she
wants to check via OT. Namely, additionally to the OT for
the input, called input-OT in [1], P1 runs one OT for each
garbled circuit. Such OTs are called circuit-OT: P1 par-
ticipates to the i-th circuit-OT with input bi = 0 if she
wants to check (i.e., obtain the randomness for) circuit gci,
otherwise she sends bi = 1.

The second idea is to let P2 compute the garbled circuit,
the messages for input-OT protocols, and other relevant in-
formation related to input/output consistency proofs, using
randomness generated by a PRF. Namely, all such messages
are computed by invoking a PRF with key seedi.
In the
circuit-OT protocol P2 will place the string seedi for the
case bi = 0 and thus gci is a circuit that will be checked,
and will instead send the keys corresponding to her input,
in case bi = 1 and thus gci is an evaluation circuit.

Security of NISC [1] in the CRS model. The UC-
security of NISC of [1] relies completely on the fully simu-
latability of the underlying PVW OT protocol. Informally,
the intuition behind the proof is the following. Simulating
Malicious P ∗
1 . The simulator extracts the secret input x∗ of
P ∗
1 from the input-OT, by running the UC-simulator granted
by PVW OT in the CRS model. It sends x∗ to the ideal func-
tionality and receives the output z = f (x∗, y). Next, from
the circuit-OTs it extracts the indexes of the circuits that
will be checked, and hence it computes the evaluation and
checking garbled circuits accordingly.

Simulating Malicious P ∗

2 . The simulator generates the
ﬁrst message of P1 for circuit-OTs and input-OTs, by run-
ning honest P1 with a random input. Due to the security of
PVW OT in the CRS model, these messages are distributed
identically for the real input and the random one. When
the simulator receives P2’s message it performs the same
correctness checks as P1. If P2 cheats in one of the checked
garbled circuits, the simulator will abort, and this happens
with the same probability that P1 would abort in the real
execution. If the emulated P1 does not abort, the cut-and-
choose guarantees that whp, at least one evaluated garbled
circuit is correct. Therefore, the simulator derives the input
of P2 by extracting the seed seedi of the correct circuit i
from the corresponding execution of circuit-OT.

NISC in the gRO model: Our techniques.

In the original NISC protocol the extraction of the input
of the sender is done by extracting the keys and the seeds
from the executions of input-OT and circuit-OT. Our idea
is to extract the input of P2 by observing the queries that P2
makes to the RO. Toward this end, we require that each seed

seedi used to generate the randomness for the computation
of the circuits and other critical information, is not picked
by P2 but it is computed as the output of the RO. Namely,
P2 queries the RO on some random input qi and set seedi
= gRO(sid, P2kqi). Then, in the cut-and-choose phase, P2
plays the OT protocol using qi instead of seedi.
In order
to pass the consistency checks, P2 must query the RO to
compute most of the PRF seeds. In this way the simulator,
which obtains all the queries made to GgRO for a speciﬁc
session sid, gets most of the seeds and is able to recompute
the keys and garbled circuits without having to extract them
from the input-OTs and circuit-OTs.

Therefore, the next step is to replace the PVW OT proto-
col used in [1] with our one-sided UC-simulatable OT pro-
tocol.

Security of our NISC in the gRO model. We now
outline the ideas behind the security proof of our NISC pro-
tocol. Simulating Malicious P ∗
1 . Because our OT protocol
is UC-simulatable against a malicious receiver the proof in
this case follows the same proof provided in [1]. Simulating
Malicious P ∗
2 . Our simulator works similarly to the simula-
tor of [1] except that the information necessary to derive the
input of P ∗
2 is obtained by looking at the queries to the RO.
Due to the cut-and-choose, P2 is forced to query the RO to
compute most of the PRF seeds used in the protocol, oth-
erwise it will be caught whp by P1. Therefore, if P ∗
2 passes
all the checks, whp the simulator will extract the relevant
information.

The crucial diﬀerence in our case is in the indistinguisha-
bility of the ﬁrst message of input-OTs computed by the
simulator. In [1], the simulator, following the UC-simulator
of PVW OT, sets the OT parameters contained in the CRS,
to be a DDH tuple, with the result that its ﬁrst message of
input-OTs computed using a random input, is distributed
identically to the one played by an honest P1 computed with
the actual input.

In our case, as we are using our one-sided simulatable OT
in the gRO model, the OT parameters are honestly gen-
erated to be a non-DDH tuple. Nevertheless, due to the
indistinguishability property of our OT against malicious
senders, the messages computed by the simulator are com-
putationally indistinguishable from the messages computed
by P1. For the formal proof the reader is referred to the full
version.

5.1 The Protocol

In this section we present our modiﬁcation of the NISC
protocol of [1] which is UC-secure in the gRO model. We
stress that the protocol is essentially the same as [1] with the
following two modiﬁcations: (a) the underlying OT is one-
sided UC-simulatable; (b) the seed of the PRF is computed
using the RO. In the description of the protocol we will
highlight the points where the two protocols diﬀer.

1, k1

t , k1

1), . . . , (k0

Notation and sub-protocols. We denote by oneside-COT1(b)
and oneside-COT2((k0
t )) Round 1 and Round
2 of our one-sided UC-simulatable (batch) committing OT
shown in Sec. 4, respectively. Notation oneside stresses that
we use a one-sided UC-simulatable OT instead of a fully UC-
secure OT. Let G be a group of prime order q with genera-
tor g. Deﬁne EGCom(h, b, r) = (gr, hrgb) as the “El Gamal”
commitment. This commitment has two important proper-
ties: (1) there exists a very eﬃcient way to prove the equality
of two commitments, (2) there exists a trapdoor that allows

606the extraction of the committed value. Both properties are
used crucially to guarantee correctness against a malicious
sender. Let ReHash be a collision-resistant hash function
that is a suitable randomness extractor.

Protocol 3. NISC in the gRO model(built upon [1]).
Inputs. P1 has input x ∈ {0, 1}n1 and P2 has input y ∈
{0, 1}n2 . Let f : {0, 1}n1 × : {0, 1}n2 → {0, 1}m and C be
a circuit computing f . The inputs wires of P1 and P2 are
denote by IN(1) and IN(2) respectively. The set of output
wires is denoted by OUT.

Enc denotes an encryption scheme, Commit denotes a com-
mitment scheme and prf a pseudo-random function. Let t
denote the number of circuits and sid the session identiﬁer.
P1’s message:

• (Choose circuits to check) Pick a random t-bit string

c1, . . . , ct. Let T be the set of i such that ci = 1.

• (Circuit-OT queries) For each index i ∈ [t], publish

oneside-COT1(ci).

• (Input-OT queries) For each input j ∈ IN(1) publish
oneside-COT1(xj). Diﬀerence with [1]. We use one-
sided UC-simulatable OT, instead of UC-secure OT.

P2’s message:

Commit to inputs, outputs and trapdoor.

• (Trapdoor) Pick w ∈R Zq and send h = gw.

• Two encryptions to the labels of the output:

Enc(lbl(gci, j, 0), Ki,j,0), Enc(lbl(gci, j, 1), Ki,j,1).

Prepare proofs of input/output consistency.

• Let inputsi be the set {ui,j,yj , di,j,yj }j∈IN(2).
Let inputsEqi be the set {rj − ri,j,yj }j∈IN(2).

• Let outputsDecomi be the set {wj,0 + Ki,j,0, wj,1 +

Ki,j,1}j∈OUT(2).

• Pick a random ki and send encryption Enc(ki, inputsi ◦

inputsEqi ◦ outputsDecomi).

Prepare the OT answers.

• (Input-OT) P2 prepares the messages of oneside-COT2
for the input-OT executions. These messages are com-
puted on input the labels: [lbl(gc1, j, 0), . . .,
lbl(gct, j, 0)], and [lbl(gc1, j, 1), . . .,lbl(gct, j, 1)] with j ∈
IN(1).

The randomness ri,j used to compute the OT message
(“OT ′′ ◦
for wire j and circuit i is set as ri,j = prfseedi
1 ◦ “r′′ ◦ i ◦ j).

• (Circuit-OT) P2 prepares the messages oneside-COT2
for the circuit-OT executions. These messages are
computed on input the pairs (qi, ki), for i ∈ [t]. Dif-
ference with [1]. P2 transfers the query qi instead
of the seed seedi.

P1’s Computation:

• (Input commitment) Send EGCom(h; yj , rj) for j ∈
IN(2), where yj is its input for input-wire j and rj
is randomly chosen.

• (Output commitment) Send hj,0 = gwj,0 and hj,1 =
gwj,1 for each output wire j ∈ OUT, where wj,0 ∈R Zq
and wj,1 = w − wj,0.

• Check circuit consistency. For each i ∈ T , compute
seedi = gRO(sid, P2kqi) and check that seedi correctly
generated circuit gci and the answers of the i-th exe-
cution of input-OT. If any check fails, abort.

• Check consistency of the input/output of P2.

For all circuits i ∈ [t]/T .

Generate garbled circuits. For each circuit i ∈ [t].

• Randomly choose qi and set seedi = gRO(sid, P2kqi).
Diﬀerence with [1]. The seed seedi is computed by
invoking the random oracle gRO.

• Compute ui,j,b = EGCom(h; b, ri,j,b) for all wire j ∈
(“EGCom”◦j ◦b).

IN(2), b ∈ {0, 1} and ri,j,b = prfseedi

• (Compute Garbled Circuit) Compute gci:

– (Labels for input wires) For j ∈ IN(2) and b ∈

{0, 1}, set lbl(gci, j, b) = ReHash(P2 ◦ sid, ui,j,b).

– (Labels for other wires) Any other label for wire
j and bit b is constructed as usual using random-
ness generated by seedi,
i.e., with randomness
prfseedi

(“label” ◦ j ◦ b).

• (Commitments to the input labels) Send commitments
{Commit(ui,j,δi,j ), Commit(ui,j,1−δi,j )}j∈IN(2) where bit
δi,g is randomly chosen. Such commitments are com-
puted using randomness derived from seedi. We de-
note by di,j,δ the decommitment of the commitment of
ui,j,δ.

Prepare cheating recovery box. For j ∈ OUT send:

• Output recovery commitments: hj,0 · gKi,j,0 and

hj,1 · gKi,j,1 where Ki,j,0, Ki,j,1 are randomly chosen.

– Verify that hj,0 · hj,1 = h for j ∈ OUT.
– Check that outputsDecomi are correct discrete-
logs of the values in set {hj,bgKi,j,b }j∈OUT,b∈{0,1}.
– Check that inputs, inputsEq are consistent with
the input-commitments: check ui,j,yj (grj −ri,j,yj ,
hrj −ri,j,yj ) = EGCom(h; yj , rj). Otherwise abort.

– Evaluate circuit gi. Say P1 learns the labels

{li,j }j∈OUT. P1 uses these labels to decrypt the
corresponding encryptions Enc(lbl(gci, j, b), Ki,j,b)
from the cheating recovery box. Then it checks
if the result is the correct “decommitment” of the
output recovery commitment hj,bgKi,j,b where the
b are the actual output bits P1 received from gci.
If all these steps pass for all output wires, label
circuit gci as semi-trusted.

• Compute the output.

If the output of all semi-
trusted circuits is the same, then output such value.
Otherwise,

– Let gci, gci′ be two semi-trusted circuits that have
diﬀerent outputs in the j-th output wire, and let
li,j and li′,j be their output labels. P1 learns wj,0
from one of the labels and wj,1 from the other
(since it learns Ki,j,b, Ki′ ,j,1−b from the cheating
recovery boxes, and wj,b +Ki,j,b, wj,1−b+Ki′ ,j,1−b
from outputsDecomi, outputsDecomi′ ).

607– P1 computes w = wj,0 + wj,1 and decrypts the
input-commitments provided by P2. Say y is the
input so obtained. P1 outputs f (x, y).

This concludes the description of the protocol.

Efﬁciency.

Our protocol inherits the same complexity of the NISC
protocol of [1] with the following additional overhead. Con-
cerning the exponentiations, the additional overhead corre-
sponds to the overhead of the one-sided OT protocol that we
discussed in Sec. 4. Concerning hash evaluations, our pro-
tocol requires t hash evaluations for P2 necessary to obtain
each seed seedi for the PRF evaluations, and t/2 hash eval-
uations for the receiver when checking the garbled circuits.

6. CONCLUSIONS

We introduced the Global Random Oracle model and pro-
vided highly eﬃcient protocols that are additionally UC-
secure. The main advantage of the gRO model is that the
random oracle is a global resource and is shared by all proto-
col executions, in contrast with the CRS/ RO model where
the security crucially relies on the assumption that each pro-
tocol execution uses its own local CRS/ Random Oracle.

7. REFERENCES

[1] A. Afshar, P. Mohassel, B. Pinkas, and B. Riva.

Non-interactive secure computation based on
cut-and-choose. In EUROCRYPT, pages 387–404,
2014.

[2] M. Bellare and P. Rogaway. Random oracles are

practical: A paradigm for designing eﬃcient protocols.
In ACM Conference on Computer and
Communications Security, pages 62–73, 1993.

[3] R. Canetti. Universally composable security: A new

paradigm for cryptographic protocols. In FOCS, pages
136–145, 2001.

[4] R. Canetti, Y. Dodis, R. Pass, and S. Walﬁsh.

Universally composable security with global setup. In
TCC, pages 61–85, 2007.

[5] R. Canetti and M. Fischlin. Universally composable

commitments. In CRYPTO, pages 19–40, 2001.

[6] R. Canetti, O. Goldreich, and S. Halevi. The random
oracle methodology, revisited (preliminary version). In
STOC, 1998.

[7] R. Canetti, A. Jain, and A. Scafuro. Practical UC
security with a global random oracle. Cryptology
ePrint Archive, 2014. http://eprint.iacr.org/2014.

[8] R. Canetti, E. Kushilevitz, and Y. Lindell. On the

limitations of universally composable two-party
computation without set-up assumptions. In
EUROCRYPT, pages 68–86, 2003.

[9] R. Canetti and T. Rabin. Universal composition with

joint state. In CRYPTO, pages 265–281, 2003.

[10] R. Cramer, I. Damg˚ard, and B. Schoenmakers. Proofs
of Partial Knowledge and Simpliﬁed Design of Witness
Hiding Protocols. In CRYPTO, pages 174–187, 1994.
[11] M. Fischlin. Communication-eﬃcient non-interactive

proofs of knowledge with online extractors. In
CRYPTO, pages 152–168, 2005.

[12] S. Goldwasser and Y. T. Kalai. On the (in)security of

the ﬁat-shamir paradigm. In FOCS, pages 102–113,
2003.

[13] Y. Huang, J. Katz, and D. Evans. Eﬃcient secure

two-party computation using symmetric
cut-and-choose. In CRYPTO (2), pages 18–35, 2013.

[14] Y. Ishai, E. Kushilevitz, R. Ostrovsky,

M. Prabhakaran, and A. Sahai. Eﬃcient
non-interactive secure computation. In EUROCRYPT,
pages 406–425, 2011.

[15] M. Kiraz and B. Schoenmakers. A protocol issue for

the malicious case of yao’s garbled circuit
construction. In Symposium on Information Theory in
the Benelux, pages 283–290, 2006.

[16] Y. Lindell. Highly-eﬃcient universally-composable

commitments based on the ddh assumption. In
EUROCRYPT, pages 446–466, 2011.

[17] Y. Lindell. Fast cut-and-choose based protocols for
malicious and covert adversaries. In CRYPTO (2),
pages 1–17, 2013.

[18] Y. Lindell and B. Pinkas. An eﬃcient protocol for

secure two-party computation in the presence of
malicious adversaries. In EUROCRYPT, pages 52–78,
2007.

[19] Y. Lindell and B. Pinkas. Secure two-party

computation via cut-and-choose oblivious transfer. In
TCC, pages 329–346, 2011.

[20] P. Mohassel and M. K. Franklin. Eﬃciency tradeoﬀs
for malicious two-party computation. In Public Key
Cryptography, pages 458–473, 2006.

[21] P. Mohassel and B. Riva. Garbled circuits checking
garbled circuits: More eﬃcient and secure two-party
computation. In CRYPTO (2), pages 36–53, 2013.

[22] J. B. Nielsen. Separating random oracle proofs from

complexity theoretic proofs: The non-committing
encryption case. In CRYPTO, 2002.

[23] R. Ostrovsky, A. Scafuro, I. Visconti, and A. Wadia.

Universally composable secure computation with
(malicious) physically uncloneable functions. In
EUROCRYPT, pages 702–718, 2013.

[24] R. Pass. On deniability in the common reference

string and random oracle model. In CRYPTO, pages
316–337, 2003.

[25] T. P. Pedersen. Non-interactive and

information-theoretic secure veriﬁable secret sharing.
In CRYPTO, pages 129–140, 1991.

[26] C. Peikert, V. Vaikuntanathan, and B. Waters. A
framework for eﬃcient and composable oblivious
transfer. In CRYPTO, pages 554–571, 2008.

[27] C.-P. Schnorr. Eﬃcient Signature Generation for

Smart Cards. Journal of Cryptology, 4(3):239–252,
1991.

[28] A. Shelat and C.-H. Shen. Two-output secure

computation with malicious adversaries. In
EUROCRYPT, pages 386–405, 2011.

[29] A. Shelat and C.-H. Shen. Fast two-party secure
computation with minimal assumptions. In ACM
Conference on Computer and Communications
Security, pages 523–534, 2013.

[30] A. C.-C. Yao. How to generate and exchange secrets
(extended abstract). In FOCS, pages 162–167, 1986.

608